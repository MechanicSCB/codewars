{"50654ddff44f800200000004":[{"id":111436,"user_id":17,"body":"module multiply\n\n%access export\n%default total\n\nmultiply : Int -> Int -> Int\nmultiply = (*)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111437,"user_id":676,"body":"module multiply\n\n%access export\n%default total\n\nmultiply : Int -> Int -> Int\nmultiply a b = a * b","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111438,"user_id":null,"body":"module multiply\n\n%access export\n%default total\n\nmultiply : Integer -> Integer -> Integer\nmultiply a b = a * b","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111439,"user_id":1768,"body":"module multiply\n\n%access export\n%default total\n\nmultiply : Int -> Int -> Int\nmultiply a b = do\n  a * b","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111440,"user_id":null,"body":"module multiply\n\n%access export\n%default total\n\nmultiply : Int -> Int -> Int\nmultiply a b = (*) a b","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"54cb771c9b30e8b5250011d4":[{"id":111441,"user_id":53,"body":"module Faberge\n\npublic export\naux : Integer -> Integer -> Integer -> Integer -> Integer -> Integer\naux 0 _ h _ _ = h\naux x t h m n = aux (x - 1) e (h + e) m n\n  where e = (t * (m - n + x)) `div` (n + 1 - x)\n  \npublic export\nheight : Integer -> Integer -> Integer\nheight n m = aux n 1 0 m n\n--\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111442,"user_id":null,"body":"module Faberge\n\npublic export\nhelp : (n,m,i,s,c:Integer) -> Integer\nhelp n m i s c = if i >= n\n                then s\n                else let c' = c*(m-i)`div`(i+1) in help n m (i+1) (s+c') c'\n\npublic export\nheight : Integer -> Integer -> Integer\nheight n m = help n m 0 1 1 - 1\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111443,"user_id":null,"body":"module Faberge\n\npublic export\nheight : Integer -> Integer -> Integer\nheight eggs tries = (f eggs 1 1) - 1 where\n      f: Integer -> Integer -> Integer -> Integer\n      f 0 acc _ = acc \n      f i' acc arg = let num' = arg*(tries - i') in\n            let arg' = div num' (eggs - i' + 1) in\n              let val' = acc + acc + arg' in\n                f (i' - 1) val' arg'\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111444,"user_id":null,"body":"module Faberge\nimport Data.Vect\n\npublic export\nheight : Integer -> Integer -> Integer\nheight eggs tries = (f (fromInteger eggs) 1 1) - 1 where\n      f: (z: Nat) -> Integer -> Integer -> Integer\n      f Z acc _ = acc \n      f (S i) acc arg = let i' = toIntegerNat (S i) in\n          let num' = arg*(tries - i') in\n            let arg' = div num' (eggs - i' + 1) in -- regrettably untotal\n              let val' = acc + acc + arg' in\n                f i val' arg'\n\n    ","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111445,"user_id":null,"body":"module Faberge\n\npublic export\nchooseOneMore : Integer -> (Integer, Integer) -> (Integer, Integer)\nchooseOneMore m (previous, i) = (previous * (m - i) `div` (i + 1), i + 1)\n\npublic export\nheight : Integer -> Integer -> Integer\nheight n m = (+ -1) $ sum $ map fst $ take (fromIntegerNat $ n + 1) $ iterate (chooseOneMore m) (1, 0)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111446,"user_id":490,"body":"module Faberge\n\n-- b = (m - c + 1) * b `div` c\n-- a += b\n-- c++\n\npartial\npublic export\nheight : Integer -> Integer -> Integer\nheight _ 0 = 0\nheight 0 _ = 0\nheight n m =\n  if n > m then height m m\n  else linearComp 1 1 0\n  where\n    partial\n    linearComp : Integer -> Integer -> Integer -> Integer\n    linearComp c b a =\n          if c <= n then\n            let d = (m + 1 - c) * b `div` c\n            in linearComp (c + 1) d (a + d)\n          else a\n--\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111447,"user_id":752,"body":"module Faberge\n\nimport Prelude.List\n\npublic export\n\nheigth : Integer -> Integer -> Integer\nheigth n m = \n  if (n <= 0 || m <= 0) then 0 \n  else (if n >= m       then pow 2 m - 1 \n  else (if 2 * n > m    then pow 2 m - 2 - heigth (m - n - 1) m\n  else sum (scanl go m [2..n])))\n  \n  where \n    go : Integer -> Integer -> Integer \n    go acc k = acc * (m - k + 1) `div` k\n    \n    pow : Integer -> Integer -> Integer \n    pow x 0 = 1\n    pow x y = x * pow x (y - 1)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111448,"user_id":168,"body":"module Faberge\n\npublic export\nheigth : Integer -> Integer -> Integer\nheigth n m = go 1 0 0\n  where \n    go c s i =\n      if i < n then\n        let c' = c * (m - i) `div` (i + 1) in\n        go c' (s + c') (i + 1)\n      else s\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5727bb0fe81185ae62000ae3":[{"id":111449,"user_id":527,"body":"module BackspacesInString\n\n%access export\n%default total\n\nclean_string : String -> String\nclean_string = reverse . pack . foldl f [] . unpack\n  where f [] '#' = []\n        f (_ :: xs) '#' = xs\n        f xs x = x :: xs","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111450,"user_id":null,"body":"module BackspacesInString\n\nimport Data.String\n\n\n%access export\n%default total\n\n\nclean_string : String -> String\nclean_string str = reverse $ pack $ cleanChar (unpack str) []\n  where\n    cleanChar : List Char-> (acc: List Char) -> List Char\n    cleanChar [] acc = acc\n    cleanChar ('#' :: inputs) [] = cleanChar inputs []\n    cleanChar ('#' :: inputs) (x :: xs) = cleanChar inputs xs\n    cleanChar (i :: inputs) xs = cleanChar inputs (i :: xs)\n  ","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111451,"user_id":null,"body":"module BackspacesInString\n\n%access export\n%default total\n\nclean_string : String -> String\nclean_string s = go [] (unpack s) where\n  go : List Char -> List Char -> String\n  go r [] = pack $ reverse r\n  go [] ('#'::s) = go [] s\n  go (r::rs) ('#'::s) = go rs s\n  go r (a::as) = go (a::r) as","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111452,"user_id":null,"body":"module BackspacesInString\n\n%access export\n%default total\n\nclean_string : String -> String\nclean_string str = (pack . reverse) (go [] (unpack str))\n  where go : List Char -> List Char -> List Char\n        go result [] = result\n        go [] ('#' :: xs) = go [] xs\n        go (c :: cs) ('#' :: xs) = go cs xs\n        go cs (x :: xs) = go (x :: cs) xs\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111453,"user_id":null,"body":"module BackspacesInString\n\n%access export\n%default total\n\nclean_string : String -> String\nclean_string =\n    reverse . pack . foldl clean [] . unpack\n  where\n    clean : List Char -> Char -> List Char\n    clean [] '#' = []\n    clean (x :: xs) '#' = xs\n    clean list c = c :: list","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111454,"user_id":null,"body":"module BackspacesInString\n\nimport Control.Monad.State\n-- import Control.Monad.State.Interface\n-- import Control.Monad.Identity\n\n%access export\n%default total\n\ncleanWithState : List Char -> State Nat (List Char)\ncleanWithState [] = pure []\ncleanWithState ('#' :: xs) = do\n    modify (+(S Z))\n    cleanWithState xs\ncleanWithState (x :: xs) = do\n    backSpaces <- get\n    case backSpaces of\n        Z => do\n            rest <- cleanWithState xs\n            pure $ x :: rest\n        S k => do\n            put k\n            cleanWithState xs\n\ncleanList : List Char -> List Char\ncleanList l = evalState (cleanWithState l) Z\n\nclean_string : String -> String\nclean_string x =\n    unparse . cleanList . parse $ x\n  where\n    parse : String -> List Char\n    parse = unpack . reverse\n    unparse : List Char -> String\n    unparse = reverse . pack","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111455,"user_id":null,"body":"module BackspacesInString\n\n%access export\n%default total\n\nclean_string : String -> String\nclean_string = pack . reverse . foldl clean [] . unpack where \n    clean [] '#' = []\n    clean (_ :: xs) '#' = xs\n    clean acc letter = letter :: acc","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111456,"user_id":53,"body":"module BackspacesInString\n\n%access export\n%default total\n\naux : List Char -> List Char -> String\naux ls [] = pack (reverse ls)\naux [] ('#'::xs) = aux [] xs\naux (c::ls) ('#'::xs) = aux ls xs\naux ls (c::xs) = aux (c::ls) xs\n\nclean_string : String -> String\nclean_string s = aux (unpack \"\") (unpack s)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111457,"user_id":null,"body":"module BackspacesInString\n\n%access export\n%default total\n\nclean_string : String -> String\nclean_string str = (pack . (f []) . unpack) str where\n  f : List Char -> List Char -> List Char\n  f acc     []          = reverse acc\n  f []      ('#'::rest) = f [] rest \n  f (a::as) ('#'::rest) = f as rest \n  f as      (h::t)      = f (h::as) t\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111458,"user_id":null,"body":"module BackspacesInString\n\nimport Data.List\n\n%access export\n%default total\n\nclean_string' : List Char -> List Char -> List Char\nclean_string' [] ys = ys\nclean_string' ('#' :: xs) [] = clean_string' xs []\nclean_string' ('#' :: xs) (y :: ys) = clean_string' xs ys\nclean_string' (c :: xs) ys = clean_string' xs (c :: ys)\n\ntotal clean_string : String -> String\nclean_string x = pack $ List.reverse $ clean_string' (unpack x) []","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c36e827348b3e15a56edcbf":[{"id":111459,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne a na = dne (\nb => nb (na (nb . a)))\n\nto : AxiomPEM -> AxiomDNE\nto pem nnp = pem id (absurd . nnp)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111460,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne ha hna = dne (\not_b => not_b (hna (not_b . ha)))\n\nto : AxiomPEM -> AxiomDNE\nto pem not_not_a = pem id (void . not_not_a)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111461,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne = dne $ \not_pem => \n           let\n           not_a = \\a => not_pem (\\f, _ => f a)\n           in not_pem $ \\_, not_a_to_b => not_a_to_b not_a\n           \nto : AxiomPEM -> AxiomDNE\nto f g = f id $ absurd . g","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111462,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nirAxiomPEM : {a,b : Type} -> Not (Not ((a -> b) -> (Not a -> b) ->b))\nirAxiomPEM npem = npem (\\ab=>\nab=>nab (\\a=>npem (\\_=>\\_=>ab a)))\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne = dne irAxiomPEM\n\nto : AxiomPEM -> AxiomDNE\nto pem = pem const (\na=>\nna=>void $ nna na)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111463,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nto : AxiomPEM -> AxiomDNE\nto = \\pem => \nna => pem id (\\f => void (nna f))\n\nfrom : AxiomDNE -> AxiomPEM\nfrom = \\dne => dne (\n\t\nopem => nopem (\n\t\t\\fromT => (\n\t\t\t\\fromF => fromF (\n\t\t\t\t\\p => nopem (\\a => (\\b => a p))\n\t\t\t)\n\t\t) \n\t)\n)\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111464,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\ncontr : (b->a)-> (a->Void) -> (b->Void)\ncontr f g = g . f\n\nfalseI : ((a->Void)->a)->(a -> Void) ->Void\nfalseI f g = g (f g) \n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne f g = dne ( falseI (g . contr f))\n\nto : AxiomPEM -> AxiomDNE\nto pem f = pem id (absurd . f)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111465,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne ri nri = dne $ \\bv => bv . nri $ bv . ri\n\nto : AxiomPEM -> AxiomDNE\nto pem = pem id . (absurd .)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111466,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n---                      ((b -> Void) -> Void) -> b\nto : AxiomPEM -> AxiomDNE\nto pem = \\f => pem id (void . f)\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne = \\f, g => dne (\\h => h (g (h . f)))\n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111467,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne = \\ab, avb => dne (\\bv => bv (avb (bv . ab)))\n\nto : AxiomPEM -> AxiomDNE\nto pem = \\avv => pem id (\\av => void (avv av))\n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111468,"user_id":null,"body":"module DndPem\n\n%access export\n%default total\n\n--- You need this to get the final submit work\npublic export\nAxiomPEM : Type\nAxiomPEM = {a : Type} -> {b : Type} -> (a -> b) -> ((a -> Void) -> b) -> b\n\npublic export\nAxiomDNE : Type\nAxiomDNE = {a : Type} -> ((a -> Void) -> Void) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne ri nri = dne $ \\bv => bv . nri $ (bv . ri)\n\n\nto : AxiomPEM -> AxiomDNE\nto pem notnota = pem id $ absurd . notnota\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c7fdf0b00718714fd002bd2":[{"id":111469,"user_id":1163,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\n\nlemma : (x : a) -> (xs : List a) -> rev (xs ++ [x]) = x :: rev xs\nlemma _ [] = Refl\nlemma x (y :: xs) = \n  rewrite lemma x xs in \n  Refl\n\nrevrevid : (xs : List a) -> (rev (rev xs)) = xs\nrevrevid [] = Refl\nrevrevid (x :: xs) = \n  rewrite lemma x (rev xs) in\n  rewrite revrevid xs in\n  Refl \n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111470,"user_id":490,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nrevA : (a : List x) -> (b : x) -> rev (a ++ [b]) = b :: rev a\nrevA [] _ = Refl\nrevA (x :: xs) b = rewrite revA xs b in Refl\n\nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (x :: xs) = rewrite revA (rev xs) x in\n                     rewrite revrevid xs in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111471,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nrevrevid : (a : List x) -> rev (rev a) = a\nrevrevid [] = Refl\nrevrevid (b :: bs) =\n    let applied = lemma (rev bs) b in\n    rewrite applied in\n    rewrite revrevid bs in\n        Refl\n  where\n    lemma :\n        (as : List x) ->\n        (a : x) ->\n        rev (as ++ [a]) = a :: (rev as)\n    lemma [] a = Refl\n    lemma (b :: bs) a = rewrite lemma bs a in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111472,"user_id":null,"body":"module RevRev\n\nimport Rev\nimport Data.List\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nrevAddSingleElem : (a : List x) -> (y : x) -> (rev (a ++ [y])) = y::(rev a)\nrevAddSingleElem [] y = Refl\nrevAddSingleElem (z :: xs) y = rewrite revAddSingleElem xs y in Refl\n\nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (y :: xs) = rewrite revAddSingleElem (rev xs) y in\n                    rewrite revrevid xs in Refl\n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111473,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nrevappid : (xs : List a) -> (ys : List a) -> rev (xs ++ ys) = rev ys ++ rev xs\nrevappid [] ys      = rewrite appendNilRightNeutral (rev ys) in Refl\nrevappid (x::xs) ys = \n    rewrite appendAssociative (rev ys) (rev xs) [x] in\n    rewrite revappid xs ys in Refl\n\nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (x :: xs) = \n    rewrite revappid (rev xs)  [x] in\n    rewrite revrevid xs in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111474,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nconsAppend : (y : x) -> (a : List x) -> y::a = [y] ++ a\nconsAppend _ _ = Refl\n\nrevInvDist : (a : List x) -> (b : List x) -> rev (a ++ b) = rev b ++ rev a\nrevInvDist [] b = rewrite appendNilRightNeutral (rev b) in Refl\nrevInvDist (y :: xs) b = rewrite revInvDist xs b in\n                         rewrite appendAssociative (rev b) (rev xs) [y] in\n                                 Refl\n\nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (y :: xs) = rewrite revInvDist (rev xs) [y] in\n                     rewrite revrevid xs in\n                             Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111475,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nrevLemma : (x : a) -> (xs : List a) -> rev (xs ++ [x]) = x :: rev xs\nrevLemma x []        = Refl\nrevLemma x (y :: xs) = rewrite revLemma x xs in Refl\n\nrevrevid : (xs : List a) -> rev (rev xs) = xs\nrevrevid [] = Refl\nrevrevid (x :: xs) = rewrite revLemma x (rev xs) in\n                      cong {f=(x ::)} (revrevid xs)\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111476,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nappendEmptyListRightNeutral : (xs: List a) -> xs ++ [] = xs\nappendEmptyListRightNeutral [] = Refl\nappendEmptyListRightNeutral (x :: xs) = cong $ appendEmptyListRightNeutral xs\n\nappendAssoc : (xs:List a) -> (ys: List a) -> (zs: List a) -> (xs ++ ys) ++ zs = xs ++ ys ++ zs\nappendAssoc [] ys zs = Refl\nappendAssoc (x :: xs) ys zs = cong $ appendAssoc xs ys zs\n\n\nrevAppend : (xs : List a) -> (ys : List a) -> rev (xs ++ ys) = rev ys ++ rev xs\nrevAppend [] ys = sym $ appendEmptyListRightNeutral $ rev ys\nrevAppend (x :: xs) ys =\n  let p = revAppend xs ys\n      p1 = cong {f = f} p\n      p2 = sym $ appendAssoc (rev ys) (rev xs) [x]\n  in rewrite p2 in p1\n  where\n    f : List a -> List a\n    f zs = zs ++ [x]\n\n\nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (y :: xs) =\n  let p = revAppend (rev xs) [y]\n  in rewrite revAppend (rev xs) [y] in\n     rewrite revrevid xs in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111477,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nrevAppend : (xs : List a) -> (ys : List a) -> rev (xs ++ ys) = rev ys ++ rev xs\nrevAppend [] ys = rewrite appendNilRightNeutral (rev ys) in Refl\nrevAppend (x :: xs) ys =\n  rewrite revAppend xs ys in\n  rewrite appendAssociative (rev ys) (rev xs) [x] in\n  Refl\n\n                \nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (x::xs) =\n  rewrite revAppend (rev xs) [x] in\n  rewrite revrevid xs in\n  Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111478,"user_id":null,"body":"module RevRev\n\nimport Rev\n\n{-\nWhat you've just imported:\n\n-- With this definitoin, Idris deduces better\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-}\n\n\n%access export\n%default total\n\nhelp : (x:a) -> (xs:List a) -> rev (xs ++ [x]) = x :: rev xs\nhelp x [] = Refl\nhelp x (y :: xs) = rewrite help x xs in Refl\n\nrevrevid : (xs : List a) -> (rev (rev xs)) = xs\nrevrevid [] = Refl\nrevrevid (x :: xs) = rewrite help x (rev xs) in cong $ revrevid xs\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c82b661562a2074bbeac980":[{"id":111479,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = (head a) :: (head b) :: Merge (tail a) (tail b)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation t = Refl :=: (\n                               Refl :=: \n                               MergeOddEvenIsBisimulation (tail (tail t)))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111480,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: head b :: Merge (tail a) (tail b)\n\npublic export\ntransB : Bisimulation a b -> Bisimulation b c -> Bisimulation a c\ntransB (e1 :=: r1) (e2 :=: r2) = trans e1 e2 :=: transB r1 r2\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\npublic export\nMergeStep1 : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) (head x :: (head (tail x)) :: Merge (Even (tail (tail x))) (Odd (tail (tail x))))\npublic export\nMergeStep2 : (x : Stream a) -> Bisimulation (head x :: (head (tail x)) :: Merge (Even (tail (tail x))) (Odd (tail (tail x)))) x\nMergeStep1 x = Refl :=: Refl :=: MergeStep1 (tail (tail x))\nMergeStep2 x = Refl :=: Refl :=: MergeOddEvenIsBisimulation (tail (tail x))\nMergeOddEvenIsBisimulation x = transB (MergeStep1 x) (MergeStep2 x)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111481,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: head b :: Merge (tail a) (tail b)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation (_ :: (_ :: xs)) = Refl :=: Delay (Refl :=: MergeOddEvenIsBisimulation xs)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111482,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: head b :: Merge (tail a) (tail b)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation x = Refl :=: Refl :=: MergeOddEvenIsBisimulation (tail (tail x))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111483,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: head b :: Merge (tail a) (tail b)\n\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation x = Refl :=: Refl :=: MergeOddEvenIsBisimulation (tail . tail $ x)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111484,"user_id":1282,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge x y = head x :: head y :: Merge (tail x) (tail y)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation x = Refl :=: Refl :=: MergeOddEvenIsBisimulation (tail (tail x))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111485,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: head b :: Merge (tail a) (tail b)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation (u :: (v :: xs)) = Refl :=: (Refl :=: MergeOddEvenIsBisimulation xs)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111486,"user_id":106,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access public export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: head b :: Merge (tail a) (tail b)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation x = (Refl :=: Refl :=: MergeOddEvenIsBisimulation (tail (tail x)))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111487,"user_id":null,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = Refl :=: onesBisimulation\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge a b = head a :: Merge b (tail a)\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation x = Refl :=: (Refl :=: MergeOddEvenIsBisimulation (tail (tail x)))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111488,"user_id":17,"body":"||| In this Kata you'll learn Bisimulation\nmodule BisiProof\n\nimport Bisimulation\n\n%default total\n%access export\n\n{-\nThis is the definition of Bisimulation: the inductive parts should\nequivalent, and the coinductive parts should bisimulate.\nWith Cubical Model we can prove that Bisimulation is an equivlance,\naka Coinductive Proof Principle.\nHowever, you don't have Cubical Model in Idris :(\n\ninfixr 10 :=:\npublic export\ncodata Bisimulation : (x : Stream a) -> (y : Stream a) -> Type where\n  (:=:) : {x : Stream a} -> {y : Stream a} ->\n          (head x = head y) ->\n          (Bisimulation (tail x) (tail y)) ->\n          (Bisimulation x y)\n-}\n\n||| Bisimulation is reflexive\npublic export\nbisimRefl : Bisimulation l l\nbisimRefl = Refl :=: bisimRefl\n\n||| Bisimulation is symmetric\npublic export\nbisimSym : Bisimulation l l' -> Bisimulation l' l\nbisimSym (eqHead :=: bisimTail) = sym (eqHead) :=: bisimSym bisimTail\n\n||| Bisimulation is transitive\npublic export\nbisimTrans : Bisimulation xs ys -> Bisimulation ys zs -> Bisimulation xs zs\nbisimTrans (eqHead :=: bisimTail) (eqHead' :=: bisimTail') = (eqHead `trans` eqHead') :=: (bisimTail `bisimTrans` bisimTail')\n\n||| Example: consider an infinite list of ones\nOnes : Stream Nat\nOnes = 1 :: Ones\n\n||| We can prove that ones bisimulates ones, which is an identity\nonesBisimulation : Bisimulation Ones Ones\nonesBisimulation = bisimRefl\n\n-- Now let's do the exercise: we want functions to extract the\n-- elements at odd\/even indices of the input stream.\n\n||| Sensei's (teacher) turn, odd:\npublic export\nOdd : Stream a -> Stream a\nOdd l = head (tail l) :: Odd (tail (tail l))\n\n||| Gakusei's (student) turn, even:\npublic export\nEven : Stream a -> Stream a\nEven l = head l :: Even (tail (tail l))\n\n||| Gakusei's turn again, merge two streams:\npublic export\nMerge : Stream a -> Stream a -> Stream a\nMerge l l' = head l :: head l' :: Merge (tail l) (tail l')\n\n||| Final exam, open book: prove that `\\x -> merge (even x) (odd x)` is a\n||| Bisimulation:\npublic export\nMergeOddEvenIsBisimulation : (x : Stream a) -> Bisimulation (Merge (Even x) (Odd x)) x\nMergeOddEvenIsBisimulation x = Refl :=: (Refl :=: MergeOddEvenIsBisimulation (tail (tail x)))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c85201e20f73f08df4216b1":[{"id":111489,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym (Branch x x\u2081 x\u2082) = \n  rewrite sym (flipTreeSym x\u2081) in\n  rewrite sym (flipTreeSym x\u2082) in \n     Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111490,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym (Branch x l r) =\n    rewrite sym (flipTreeSym l) in\n    rewrite sym (flipTreeSym r) in\n        Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111491,"user_id":null,"body":"module P\nimport T\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf _) = Refl\nflipTreeSym (Branch _ l r) =\n  rewrite sym $ flipTreeSym l in\n  rewrite sym $ flipTreeSym r in \n     Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111492,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf a) = Refl\nflipTreeSym (Branch _ l r) = rewrite flipTreeSym l in\n                             rewrite flipTreeSym r in\n                             Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111493,"user_id":29,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym {t = Branch x l r} = rewrite flipTreeSym l in rewrite flipTreeSym r in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111494,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflip : x = y -> y = x\nflip Refl = Refl\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym n@(Branch x y z) =\n  let\n    fy = flipTreeSym y\n    fz = flipTreeSym z\n  in\n    rewrite flip fy in\n    rewrite flip fz in\n    Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111495,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym (Branch x y z) = rewrite sym (flipTreeSym y) in rewrite sym (flipTreeSym z) in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111496,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\ncong2 : (f : a -> b -> c) -> x = y -> w = z -> f x w = f y z\ncong2 _ Refl Refl = Refl\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym (Branch x l r) = cong2 (Branch x) (flipTreeSym l) (flipTreeSym r)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111497,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf _) = Refl\nflipTreeSym (Branch v l r) = let invL = flipTreeSym l\n                                 invR = flipTreeSym r\n                                 idB = the (Branch v l r = Branch v l r) Refl\n                             in rewrite sym invL in\n                                rewrite sym invR in\n                                idB\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111498,"user_id":null,"body":"module P\n\nimport T\n\n{-\npublic export\ndata Tree : Type -> Type where\n  Leaf : a -> Tree a\n  Branch : a -> Tree a -> Tree a -> Tree a\n\npublic export\nflipTree : Tree a -> Tree a\nflipTree (Leaf x) = Leaf x\nflipTree (Branch x l r) = Branch x (flipTree r) (flipTree l)\n-}\n\n%access export\n%default total\n\nflipTreeSym : (t : Tree a) -> t = flipTree (flipTree t)\nflipTreeSym (Leaf x) = Refl\nflipTreeSym (Branch x l r) = let lRec = flipTreeSym l\n                                 rRec = flipTreeSym r\n                             in rewrite lRec in rewrite rRec in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8531a820089d04385a7faa":[{"id":111499,"user_id":490,"body":"module Proof\n\n%default total\n%access export\n\nlemma : (a : Nat) -> (b : Nat) -> (S (a + S a) = S (b + S b)) -> (a + a = b + b)\nlemma a b =\n  rewrite plusCommutative a $ S a in\n  rewrite plusCommutative b $ S b in\n  succInjective (a + a) (b + b) . succInjective (S $ a + a) (S $ b + b)\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z = const Refl\ninvert Z (S b) = absurd\ninvert (S a) Z = absurd\ninvert (S a) (S b) = eqSucc a b . invert a b . lemma a b\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111500,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z = const Refl\ninvert Z (S k) = absurd\ninvert (S k) Z = absurd\ninvert (S k) (S j) = rewrite sym (plusSuccRightSucc k k) in\n                     rewrite sym (plusSuccRightSucc j j) in\n                     cong . invert k j . succInjective (k + k) (j + j) . succInjective (S (k + k)) (S (j + j))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111501,"user_id":489,"body":"module Proof\n\n%default total\n%access export\n\n-- total succInjective : (a : Nat) -> (b : Nat) -> (S a = S b) -> a = b\n-- total plusSuccRightSucc : (a : Nat) -> (b : Nat) -> S (a + b) = a + (S b)\n-- total eqSucc : (a : Nat) -> (b : Nat) -> (a = b) -> S a = S b\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z _ = Refl\ninvert (S a) Z Refl impossible\ninvert Z (S a) Refl impossible\ninvert (S a) (S b) pf = eqSucc a b (invert a b aa_bb) where\n  aSa_bSb : a + S a = b + S b\n  aSa_bSb = succInjective (a + S a) (b + S b) pf\n  aSa_sbb : a + S a = S (b + b)\n  aSa_sbb = trans aSa_bSb (sym (plusSuccRightSucc b b))\n  saa_sbb : S (a + a) = S (b + b)\n  saa_sbb = trans (plusSuccRightSucc a a) aSa_sbb\n  aa_bb : a + a = b + b\n  aa_bb = succInjective (a + a) (b + b) saa_sbb\n  \n-- S a + S a = S b + S b\n-- -> S (a + S a) = S (b + S b) (auto)\n-- -> a + S a = b + S b (succInjective)\n-- -> S (a + a) = S (b + b) (plusSuccRightSucc)\n-- -> a + a = b + b (succInjective)\n-- -> a = b (induction hypothesis)\n-- -> S a = S b (eqSucc)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111502,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\ncongS : {a, b : Nat} -> (a = b) -> S a = S b\ncongS Refl = Refl\n\ninj : (a, b : Nat) -> (S a = S b) -> a = b\ninj Z Z Refl = Refl\ninj Z (S _) Refl impossible\ninj (S _) Z Refl impossible\ninj (S j) (S k) prf = rewrite plusLeftCancel 1 (S j) (S k) prf in Refl\n  \ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z Refl = Refl\ninvert Z (S _) Refl impossible\ninvert (S _) Z Refl impossible\ninvert (S j) (S k) prf = congS $ invert j k $\n  inj (j + j) (k + k) $\n  rewrite plusSuccRightSucc j j in\n  rewrite inj (j + S j) (k + S k) prf in\n  sym $ plusSuccRightSucc k k","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111503,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z Refl = Refl\ninvert Z (S _) Refl impossible\ninvert (S _) Z Refl impossible\ninvert (S k) (S j) prf =\n    let\n        plus2k2j = succInjective _ _ plusSucc\n        kEqJ = invert _ _ plus2k2j\n    in\n        cong {f=S} kEqJ\n  where\n    plusSucc : (S k) + k = (S j) + j\n    plusSucc =\n        rewrite plusCommutative (S k) k in\n        rewrite plusCommutative (S j) j in\n            (succInjective _ _ prf)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111504,"user_id":null,"body":"module Proof\n\n-- import Data.Nat\n\n%default total\n%access export\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z _ = Refl\ninvert Z (S n) r = absurd r\ninvert (S m) Z r = absurd r\ninvert (S m) (S n) prf =\n  let\n    mm = plusSuccRightSucc m m\n    nn = plusSuccRightSucc n n\n    mmEqnn = succInjective _ _ $ trans (trans mm (succInjective _ _ prf)) (sym nn)\n    subPrf = invert m n mmEqnn\n  in\n    cong {f=S} subPrf\n    ","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111505,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z prf = prf\ninvert (S k) Z prf = absurd $ SIsNotZ (prf)\ninvert Z (S j) prf = absurd $ SIsNotZ (sym prf)\ninvert (S k) (S j) prf = let prf' : (plus k k = plus j j) = succInjective _ _ (rewrite plusSuccRightSucc k k in\n                                                                               rewrite plusSuccRightSucc j j in succInjective _ _ prf) \n                             in eqSucc _ _ (invert k j prf')\n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111506,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\ninvert : (a,b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z p = Refl\ninvert Z (S b) p = absurd p\ninvert (S a) Z p = absurd p\ninvert (S a) (S b) p =\n  cong $ invert a b $\n  succInjective (a + a) (b + b) $\n  succInjective (S (a + a)) (S (b + b)) $\n  rewrite plusSuccRightSucc a a in\n  rewrite plusSuccRightSucc b b in p","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111507,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\ntotal\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z prf = Refl\ninvert (S a) Z prf = void $ replace {P = createVoid} prf ()\n                     where createVoid : Nat -> Type\n                           createVoid Z = Void\n                           createVoid (S _) = ()\ninvert Z (S b) prf = void $ replace {P = createVoid} prf ()\n                     where createVoid : Nat -> Type\n                           createVoid Z = ()\n                           createVoid (S _) = Void\ninvert (S a) (S b) prf = cong\n\t                       $ invert a b\n                         $ succInjective (a + a) (b + b)\n                         $ rewrite plusSuccRightSucc b b\n                           in rewrite plusSuccRightSucc a a\n                              in succInjective (a + S a) (b + S b) prf\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111508,"user_id":null,"body":"module Proof\n\n%default total\n%access export\n\nlemma : (a : Nat) -> (b : Nat) -> (S (a + S a) = S (b + S b)) -> (a + a = b + b)\nlemma a b =\n  rewrite plusCommutative a $ S a in\n  rewrite plusCommutative b $ S b in\n  succInjective (a + a) (b + b) . succInjective (S $ a + a) (S $ b + b)\n\ninvert : (a : Nat) -> (b : Nat) -> (a + a = b + b) -> a = b\ninvert Z Z = const Refl\ninvert Z (S _) = absurd\ninvert (S _) Z = absurd\ninvert (S n) (S m) = eqSucc n m . invert n m . lemma n m\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8689c6a2fc6d518df4b59c":[{"id":111509,"user_id":489,"body":"module AppendInjective\n\n%access export\n%default total\n\nconsInjectiveL : {A : Type} -> {x, y : A} -> {xs, ys : List A} -> x :: xs = y :: ys -> x = y\nconsInjectiveL Refl = Refl\n\nconsInjectiveR : {A : Type} -> {x, y : A} -> {xs, ys : List A} -> x :: xs = y :: ys -> xs = ys\nconsInjectiveR Refl = Refl\n\ncong2 : {A, B, C : Type} -> {f : A -> B -> C} -> {x1, x2 : A} -> {y1, y2 : B} -> x1 = x2 -> y1 = y2 -> f x1 y1 = f x2 y2\ncong2 Refl Refl = Refl\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight Nil _ _ pf = pf\nappendInjectiveRight (x :: a) b c pf = appendInjectiveRight a b c (consInjectiveR pf)\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft [] [] c _ = Refl\nappendInjectiveLeft [] (b0 :: b) c eq =\n  void $ ZnotS $ plusRightCancel 0 (length (b0 :: b)) (length c) $ trans (cong {f = length} eq) (lengthAppend (b0 :: b) c)\nappendInjectiveLeft (a0 :: a) [] c eq =\n  void $ ZnotS $ plusRightCancel 0 (length (a0 :: a)) (length c) $ trans (sym $ cong {f = length} eq) (lengthAppend (a0 :: a) c)\nappendInjectiveLeft (a0 :: a) (b0 :: b) c eq =\n  cong2 (consInjectiveL eq) (appendInjectiveLeft a b c (consInjectiveR eq))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111510,"user_id":null,"body":"module AppendInjective\n\n%access export\n%default total\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] c c Refl = Refl\nappendInjectiveRight (y :: xs) b c prf = appendInjectiveRight xs b c (snd (consInjective prf))\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft [] [] c Refl = Refl\nappendInjectiveLeft [] (y :: xs) c prf =\n  void .  ZnotS . plusRightCancel 0 (length (y :: xs)) (length c) $\n  trans (cong {f=length} prf) (lengthAppend (y :: xs) c)\nappendInjectiveLeft (y :: xs) [] c prf =\n  void . ZnotS . plusRightCancel 0 (length (y :: xs)) (length c) $\n  trans (sym $ cong {f=length} prf) (lengthAppend (y :: xs) c)\nappendInjectiveLeft (y :: xs) (z :: ys) c prf with (consInjective prf)\n  appendInjectiveLeft (y :: xs) (z :: ys) c prf | (equalHead, equalTail) =\n    rewrite equalHead in cong (appendInjectiveLeft xs ys c equalTail)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111511,"user_id":null,"body":"module AppendInjective\n\n%access export\n%default total\n\nUninhabited ([] = _ :: _) where\n    uninhabited Refl impossible\n  \nUninhabited (_ :: _ = []) where\n    uninhabited Refl impossible\n\nappendInjectiveRight : (xs,ys,zs : List a) -> xs ++ ys = xs ++ zs -> ys = zs\nappendInjectiveRight [] ys zs p = p\nappendInjectiveRight (x :: xs) ys zs p with (consInjective p)\n  appendInjectiveRight (x :: xs) ys zs p | (Refl, p') = appendInjectiveRight _ _ _ p'\n\n\nsnocInjective : (xs ++ [x'] = ys ++ [y']) -> (xs = ys, x' = y')\nsnocInjective {xs = []} {x' = x'} {ys = []} {y' = x'} Refl = (Refl, Refl)\nsnocInjective {xs = []} {x' = x'} {ys = (y :: [])} {y' = y'} p = absurd (snd $ consInjective p)\nsnocInjective {xs = []} {x' = x'} {ys = (y :: (yy :: ys))} {y' = y'} p = absurd (snd $ consInjective p)\nsnocInjective {xs = (x :: [])} {x' = x'} {ys = []} {y' = y'} p = absurd (snd $ consInjective p)\nsnocInjective {xs = (x :: (xx :: xs))} {x' = x'} {ys = []} {y' = y'} p = absurd (snd $ consInjective p)\nsnocInjective {xs = (x :: xs)} {x' = x'} {ys = (y :: ys)} {y' = y'} p with (consInjective p)\n  snocInjective {xs = (x :: xs)} {x' = x'} {ys = (y :: ys)} {y' = y'} p | (a, b) with (snocInjective b)\n    snocInjective {xs = (x :: xs)} {x' = x'} {ys = (y :: ys)} {y' = y'} p | (a, b) | (a', b') = (consCong2 a a', b')\n\nrev' : (x : a) -> (xs : List a) -> (p : (List a, a) ** (x :: xs = fst p ++ [snd p]))\nrev' x [] = (([], x) ** Refl)\nrev' x (y :: xs) with (rev' y xs)\n  rev' x (y :: xs) | (p ** pf) = rewrite pf in ((x :: fst p, snd p) ** Refl)\n\nappendInjectiveLeftAux : (xs,ys,zs : List a) -> (lzs:Nat) -> (lzs = length zs) -> xs ++ zs = ys ++ zs -> xs = ys\nappendInjectiveLeftAux xs ys [] lzs eq p =\n    rewrite sym $ appendNilRightNeutral xs in\n    rewrite sym $ appendNilRightNeutral ys in p\nappendInjectiveLeftAux xs ys (z::zs) Z Refl p impossible\nappendInjectiveLeftAux xs ys (z::zs) (S im) eqc p with (rev' z zs)\n  appendInjectiveLeftAux xs ys (z::zs) (S im) eqc p | ((zs', z') ** pf) with (replace {P=\\xxx => xs ++ xxx = ys ++ xxx} pf p)\n    appendInjectiveLeftAux xs ys (z::zs) (S im) eqc p | ((zs', z') ** pf) | p' =\n        let p'' = replace {P = \\xxx=>xxx=ys++zs'++[z']} (appendAssociative xs zs' [z']) p'\n            p''' = replace {P = \\xxx=>(xs++zs')++[z']=xxx} (appendAssociative ys zs' [z']) p''\n            p'''' = fst $ snocInjective {xs=xs++zs'} {ys=ys++zs'} {x' = z'} {y'=z'} p'''\n            eq1 : (length (z::zs) = length (zs'++[z'])) = rewrite sym pf in Refl\n            eq2 : (length (zs'++[z']) = S (length zs') ) = rewrite plusCommutative 1 (length zs') in lengthAppend zs' [z']\n            eq = succInjective _ _ $ eq1 `trans` eq2\n            eqc' = succInjective _ _ eqc\n        in appendInjectiveLeftAux _ _ zs' im (eqc' `trans` eq) p''''\n\nappendInjectiveLeft : (xs,ys,zs : List a) -> xs ++ zs = ys ++ zs -> xs = ys\nappendInjectiveLeft xs ys zs p = appendInjectiveLeftAux xs ys zs (length zs) Refl p\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111512,"user_id":null,"body":"module AppendInjective\n\n%access export\n%default total\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] b c = id\nappendInjectiveRight (y::ys) b c = \\p => appendInjectiveRight ys b c $ snd $ consInjective p\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\n\nappLeftZ : (a, b: List x) -> (a++[]=b++[]) -> a=b\nappLeftZ a b p = rewrite sym $ appendNilRightNeutral a in rewrite sym $ appendNilRightNeutral b in p \n\n\nrev : List x -> List x\nrev [] = []\nrev (y :: xs) = rev xs ++ [y]\n-- proof\ninvrev : (b : x) -> (a: List x) -> rev (a ++ [b]) = b :: (rev a)\ninvrev b [] = Refl\ninvrev b (y :: ys) = rewrite invrev b ys in Refl\n\nrevrevid : (a : List x) -> (rev (rev a)) = a\nrevrevid [] = Refl\nrevrevid (y :: xs) = rewrite invrev y (rev xs) in rewrite revrevid xs in Refl\n\nrevid : (a, b: List x) -> rev a = rev b -> a=b\nrevid a b p = rewrite sym $ revrevid a in rewrite sym $ revrevid b in cong {f=rev} p\n\nmapinvrev : (a, b: List x) -> (v: x) -> rev (a++[v])=rev (b++[v]) -> v::(rev a)=v::(rev b)\nmapinvrev a b v p = rewrite sym $ invrev v a in rewrite sym $ invrev v b in p\n\napprev : (a, b : List x) -> rev (a++b) = rev b ++ rev a\napprev [] b = rewrite appendNilRightNeutral (rev b) in Refl\napprev (v::vs) b = let q = cong {f=\\w=>w++[v]} $ apprev vs b in rewrite appendAssociative (rev b) (rev vs) [v] in q\n\nmaprev : (a, b, c: List x) -> a++c=b++c -> rev c ++ rev a = rev c ++ rev b\nmaprev a b c p = rewrite sym $ apprev a c in rewrite sym $ apprev b c in cong p\n\nappendInjectiveLeft a b c p = revid a b $ appendInjectiveRight (rev c) (rev a) (rev b) $ maprev a b c p\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111513,"user_id":524,"body":"module AppendInjective\n\n%access export\n%default partial\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] c c Refl = Refl \nappendInjectiveRight (y :: xs) b c prf = \n    rewrite appendInjectiveRight xs b c (snd (consInjective prf)) in \n    Refl \n\nappendLengthEquation : (a, b : List x) -> length (a ++ b) = length a + length b\nappendLengthEquation [] b = Refl \nappendLengthEquation (y :: xs) b = \n    rewrite appendLengthEquation xs b in Refl \n\nappendNotEmptyLengthRight : (as : List x) -> (b : x) -> (bs : List x) -> GT (length (as ++ b :: bs)) (length as)\nappendNotEmptyLengthRight as b bs = \n    rewrite appendLengthEquation as (b :: bs) in\n    rewrite sym (plusSuccRightSucc (length as) (length bs)) in \n    LTESucc (lteAddRight (length as))\n\nappendLengthCommutative : (a, b : List x) -> length (a ++ b) = length (b ++ a)\nappendLengthCommutative a b = \n    rewrite appendLengthEquation a b in \n    rewrite appendLengthEquation b a in \n    plusCommutative (length a) (length b)\n\nappendNotEmptyLengthLeft : (b : x) -> (bs : List x) -> (as : List x) -> LT (length as) (length (b :: bs ++ as))\nappendNotEmptyLengthLeft b bs as = \n    rewrite appendLengthCommutative (b :: bs) as in \n    appendNotEmptyLengthRight as b bs\n\nlemma1 : (y : x) -> (ys : List x) -> y :: ys = [] -> Void \nlemma1 _ _ Refl impossible\n\nlemma3 : (m, n : Nat) -> m = n -> LT m n -> Void \nlemma3 Z Z Refl LTEZero impossible\nlemma3 Z Z Refl (LTESucc _) impossible\nlemma3 Z (S k) Refl mltn impossible\nlemma3 (S k) (S k) Refl (LTESucc x) = lemma3 k k Refl x\n\nlemma2 : (y : x) -> (ys : List x) -> (b : List x) -> y :: ys ++ b = b -> Void \nlemma2 y ys b prf = lemma3 m n meqn mltn \n    where \n        m : Nat \n        m = length b\n        n : Nat \n        n = length (y :: ys ++ b)\n        meqn : m = n \n        meqn = sym (cong {f = length} prf)\n        mltn : LT m n\n        mltn = appendNotEmptyLengthLeft y ys b\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft [] [] c prf = Refl \nappendInjectiveLeft (y :: ys) [] c prf = void (lemma2 y ys c prf)\nappendInjectiveLeft [] (z :: zs) c prf = void (lemma2 z zs c (sym prf))\nappendInjectiveLeft (y :: ys) (z :: zs) c prf = \n    rewrite appendInjectiveLeft ys zs c (snd (consInjective prf)) in \n    rewrite fst (consInjective prf) in \n    Refl \n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111514,"user_id":null,"body":"module AppendInjective\n\n%access export\n%default total\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] b c prf = prf\nappendInjectiveRight (x :: xs) b c prf =\n  appendInjectiveRight xs b c (cong {f = drop 1} prf)\n\nlistToLength : (a, b : List x) -> a ++ b = b -> length a + length b = length b\nlistToLength a b prf =\n  let prf' = cong {f = length} prf\n      prf'' = lengthAppend a b in\n      rewrite sym prf'' in prf'\n \naddEqEqZero : (a, b : List x) -> length a + length b = length b -> length a = 0\naddEqEqZero a b prf = plusRightCancel (length a) 0 (length b) prf\n \nzeroIsNil : (a : List x) -> length a = 0 -> a = []\nzeroIsNil [] prf = Refl\nzeroIsNil (x :: xs) prf = absurd prf\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft [] [] c prf = Refl\nappendInjectiveLeft [] (y :: ys) [] prf = rewrite sym (appendNilRightNeutral (y :: ys)) in prf\nappendInjectiveLeft [] (y :: ys) (z :: zs) prf =\n  let prf' = listToLength (y :: ys) (z :: zs) (sym prf)\n      prf'' = addEqEqZero (y :: ys) (z :: zs) prf'\n      prf''' = zeroIsNil (y :: ys) prf'' in sym prf'''\nappendInjectiveLeft (x :: xs) [] [] prf = rewrite sym (appendNilRightNeutral (x :: xs)) in prf\nappendInjectiveLeft (x :: xs) [] (z :: zs) prf =\n  let prf' = listToLength (x :: xs) (z :: zs) prf\n      prf'' = addEqEqZero (x :: xs) (z :: zs) prf'\n      prf''' = zeroIsNil (x :: xs) prf'' in prf'''\nappendInjectiveLeft (x :: xs) (y :: ys) c prf =\n  let prf' = appendInjectiveLeft xs ys c (cong {f = drop 1} prf)\n      (a, b) = consInjective prf in\n      rewrite prf' in rewrite a in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111515,"user_id":null,"body":"module AppendInjective\n\nimport Data.List.Views\n\n%access export\n%default total\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] _ _ prf = prf\nappendInjectiveRight (_ :: xs) b c prf = appendInjectiveRight xs b c (cong { f = drop 1 } prf)\n\nappendEmptyInjective : {a, b : List x} -> a ++ [] = b ++ [] -> a = b\nappendEmptyInjective {a} {b} prf = \n  rewrite sym $ appendNilRightNeutral a in\n  rewrite sym $ appendNilRightNeutral b in\n    prf\n\ndropOneRight : (xs : List a) -> List a\ndropOneRight [] = []\ndropOneRight [x] = []\ndropOneRight (x :: y :: xs) = x :: dropOneRight (y :: xs)\n\ndropOneRightProof : (ys : List a) -> (x : a) -> ys = dropOneRight (ys ++ [x])\ndropOneRightProof [] z = Refl\ndropOneRightProof [x] z = Refl\ndropOneRightProof (x :: y :: xs) z = cong $ dropOneRightProof (y::xs) z\n\nconsCong :  {A : Type} -> {x : A} -> {xs : List A} -> {ys : List A} ->\n  xs ++ [x] = ys ++ [x] -> xs = ys\nconsCong {xs} {ys} {x} prf_cons = \n  rewrite dropOneRightProof ys x in rewrite dropOneRightProof xs x in\n  cong prf_cons\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft a b c prf with (snocList c)\n  appendInjectiveLeft a b [] prf | Empty = appendEmptyInjective prf\n  appendInjectiveLeft a b (cs ++ [c]) prf | (Snoc rec) = appendInjectiveLeft a b cs (consCong {x=c} (\n    rewrite sym $ appendAssociative a cs [c] in \n    rewrite sym $ appendAssociative b cs [c] in \n      prf\n  )) | rec","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111516,"user_id":null,"body":"module AppendInjective\n\n%access export\n%default total\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] b c p = p\nappendInjectiveRight (x::xs) b c p = appendInjectiveRight xs b c (snd (consInjective p))\n\nrev : List a -> List a\nrev [] = []\nrev (x::xs) = rev xs ++ [x]\n\nrevAppDist : (xs, ys : List a) -> rev (xs ++ ys) = rev ys ++ rev xs\nrevAppDist [] ys = rewrite appendNilRightNeutral (rev ys) in Refl\nrevAppDist (x::xs) ys =\n  rewrite appendAssociative (rev ys) (rev xs) [x] in\n  rewrite revAppDist xs ys in Refl\n\nrevInv : (xs : List a) -> rev (rev xs) = xs\nrevInv [] = Refl\nrevInv (x::xs) = rewrite revAppDist (rev xs) [x] in rewrite revInv xs in Refl\n\nrevInjective : (a, b : List x) -> rev a = rev b -> a = b\nrevInjective xs ys p = rewrite sym (revInv xs) in rewrite sym (revInv ys) in rewrite p in Refl\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft a b c p = revInjective a b (appendInjectiveRight (rev c) (rev a) (rev b) p')\n  where\n    p' : rev c ++ rev a = rev c ++ rev b\n    p' = rewrite sym (revAppDist a c) in rewrite sym (revAppDist b c) in rewrite p in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111517,"user_id":527,"body":"module AppendInjective\n\n%access export\n%default total\n\nappendInjectiveRight : (a, b, c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] b c = id\nappendInjectiveRight (_::a) b c = appendInjectiveRight a b c . snd . consInjective\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft [] [] c p = Refl\nappendInjectiveLeft (_::a) (_::b) c p =\n  let (ph, pt) = consInjective p\n  in consCong2 ph (appendInjectiveLeft a b c pt)\nappendInjectiveLeft [] b@(_::_) c p =\n  absurd $\n    plusRightCancel 0 (length b) (length c) $\n    cong {f = length} p `trans` lengthAppend b c\nappendInjectiveLeft a@(_::_) [] c p =\n  absurd $\n    plusRightCancel (length a) 0 (length c) $\n    sym (lengthAppend a c) `trans` cong {f = length} p\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111518,"user_id":null,"body":"module AppendInjective\n\n%access export\n%default total\n\nappendInjectiveRight : (a : List x) -> (b : List x) -> (c : List x) -> a ++ b = a ++ c -> b = c\nappendInjectiveRight [] b c prf = prf\nappendInjectiveRight (y :: xs) b c prf =\n  appendInjectiveRight xs b c (snd $ consInjective prf)\n\nlengthEq : {a : List x} -> a = b -> length a = length b\nlengthEq prf = cong prf\n\nappendInjectiveLeft : (a, b, c : List x) -> a ++ c = b ++ c -> a = b\nappendInjectiveLeft [] [] c _ = Refl\nappendInjectiveLeft [] (_ :: _) [] prf = absurd . lemma_val_not_nil $ sym prf\nappendInjectiveLeft [] (b :: bs) c prf =\n  absurd . SIsNotZ . sym $\n    plusRightCancel\n      0\n      (length $ b :: bs)\n      (length c)\n      (rewrite sym $ lengthAppend (b :: bs) c in lengthEq prf)\nappendInjectiveLeft (_ :: _) [] [] prf = absurd . lemma_val_not_nil $ prf\nappendInjectiveLeft (a :: as) [] c prf =\n  absurd . SIsNotZ $\n    plusRightCancel\n      (length $ a :: as)\n      0\n      (length c)\n      (rewrite sym $ lengthAppend (a :: as) c in lengthEq prf)\nappendInjectiveLeft (a :: as) (b :: bs) c prf =\n  let (hp, rp) = consInjective prf\n   in rewrite hp in cong (appendInjectiveLeft as bs c rp)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c86de12bc56292fb465c77f":[{"id":111519,"user_id":443,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\nevenPlusEven EZero y = y\nevenPlusEven (ESuc (OSuc x)) y = ESuc (OSuc (evenPlusEven x y))\n\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusEven (OSuc EZero) y = OSuc y\noddPlusEven (OSuc (ESuc x)) y = OSuc (ESuc (oddPlusEven x y))\n\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\noddPlusOdd (OSuc EZero) y = ESuc y\noddPlusOdd (OSuc (ESuc x)) y = ESuc (OSuc (oddPlusOdd x y))\n\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\nevenPlusOdd EZero y = y\nevenPlusOdd (ESuc x) y = OSuc (oddPlusOdd x y)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111520,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\nevenPlusEven EZero m = m\nevenPlusEven (ESuc a) b = ESuc (oddPlusEven a b)\noddPlusEven (OSuc a) m = OSuc (evenPlusEven a m)\noddPlusOdd (OSuc a) m = ESuc (evenPlusOdd a m)\nevenPlusOdd EZero m = m\nevenPlusOdd (ESuc a) b = OSuc (oddPlusOdd a b)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111521,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\nevenPlusEven EZero y = y\nevenPlusEven (ESuc (OSuc x)) y = ESuc (OSuc (evenPlusEven x y))\n\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusEven (OSuc x) y = OSuc (evenPlusEven x y)\n\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\noddPlusOdd (OSuc EZero) y = ESuc y\noddPlusOdd (OSuc (ESuc x)) y = ESuc (OSuc (oddPlusOdd x y))\n\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\nevenPlusOdd EZero y = y\nevenPlusOdd (ESuc (OSuc x)) y = OSuc (ESuc (evenPlusOdd x y))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111522,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n\nevenPlusEven EZero EZero = EZero\nevenPlusEven EZero (ESuc k) = ESuc (evenPlusOdd EZero k)\nevenPlusEven (ESuc n) m = ESuc (oddPlusEven n m)\n\nevenPlusOdd EZero (OSuc k) = OSuc (evenPlusEven EZero k)\nevenPlusOdd (ESuc n) m = OSuc (oddPlusOdd n m)\n\noddPlusEven (OSuc n) m = OSuc (evenPlusEven n m)\n\noddPlusOdd (OSuc n) m = ESuc (evenPlusOdd n m)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111523,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\nmutual\n    -- | Implement all these functions\n    evenPlusEven : Even m -> Even n -> Even (m + n)\n    evenPlusEven EZero r = r\n    evenPlusEven (ESuc x) r = ESuc (oddPlusEven x r)\n\n    oddPlusEven : Odd m -> Even n -> Odd (m + n)\n    oddPlusEven (OSuc x) r = OSuc (evenPlusEven x r)\n\n    oddPlusOdd : Odd m -> Odd n -> Even (m + n)\n    oddPlusOdd (OSuc x) r = ESuc (evenPlusOdd x r)\n\n    evenPlusOdd : Even m -> Odd n -> Odd (m + n)\n    evenPlusOdd EZero r = r\n    evenPlusOdd (ESuc x) r = OSuc (oddPlusOdd x r)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111524,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\nevenPlusEven EZero b = b\nevenPlusEven (ESuc a) b = ESuc (oddPlusEven a b)\noddPlusEven (OSuc a) b = OSuc (evenPlusEven a b)\noddPlusOdd (OSuc a) b = ESuc (evenPlusOdd a b)\nevenPlusOdd EZero b = b\nevenPlusOdd (ESuc a) b = OSuc (oddPlusOdd a b)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111525,"user_id":29,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\nevenPlusEven EZero b = b\nevenPlusEven (ESuc (OSuc a)) b = ESuc (OSuc (evenPlusEven a b))\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusEven (OSuc a) b = OSuc (evenPlusEven a b)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\nevenPlusOdd EZero b = b\nevenPlusOdd (ESuc (OSuc a)) b = OSuc (ESuc (evenPlusOdd a b))\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\noddPlusOdd (OSuc a) b = ESuc (evenPlusOdd a b)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111526,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n\nevenPlusEven EZero other = other\nevenPlusEven (ESuc first) other = ESuc (oddPlusEven first other)\n\noddPlusEven (OSuc first) other = OSuc (evenPlusEven first other)\n\noddPlusOdd (OSuc first) other = ESuc (evenPlusOdd first other)\n\nevenPlusOdd EZero other = other\nevenPlusOdd (ESuc first) other = OSuc (oddPlusOdd first other)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111527,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\n-- | Implement all these functions\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n\nevenPlusEven EZero EZero = EZero\nevenPlusEven EZero (ESuc x) = ESuc x\nevenPlusEven {m=S m} {n} (ESuc x) y = ESuc $ oddPlusEven x y\nevenPlusEven {m=(S m)} v EZero =\n  rewrite plusZeroRightNeutral m in v\n\noddPlusEven (OSuc x) y = OSuc $ evenPlusEven x y\n\noddPlusOdd {m=S m} {n=S n} (OSuc x) (OSuc y) =\n  rewrite sym $ plusSuccRightSucc m n in\n    ESuc $ OSuc $ evenPlusEven x y\n\nevenPlusOdd {m} {n=S n} x (OSuc y) =\n  rewrite sym $ plusSuccRightSucc m n in\n    OSuc $ evenPlusEven x y","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111528,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Even : Nat -> Type\ndata Odd : Nat -> Type\n\ndata Even : Nat -> Type where\n  EZero : Even 0\n  ESuc : Odd n -> Even (S n)\n  \ndata Odd : Nat -> Type where\n  OSuc : Even n -> Odd (S n)\n\n-}\n\n%access export\n%default total\n\nmutual\n  evenPlusEven : Even m -> Even n -> Even (m + n)\n  evenPlusEven EZero en = en\n  evenPlusEven (ESuc om) en = ESuc (oddPlusEven om en)\n\n  oddPlusEven : Odd m -> Even n -> Odd (m + n)\n  oddPlusEven (OSuc em) en = OSuc (evenPlusEven em en)\n\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\noddPlusOdd {m=S m} {n=S n} (OSuc em) (OSuc en) = rewrite sym (plusSuccRightSucc m n) in ESuc (OSuc (evenPlusEven em en))\n\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\nevenPlusOdd {m} {n=S n} em (OSuc en) = rewrite sym (plusSuccRightSucc m n) in OSuc (evenPlusEven em en)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c86f708f545a031075e6b2a":[{"id":111529,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\nevenMultOdd : Even m -> Odd n -> Even (m * n)\n\nevenMultEven EZero _ = EZero\nevenMultEven (ESuc n) m = evenPlusEven m (oddMultEven n m)\n\noddMultEven (OSuc n) m = evenPlusEven m (evenMultEven n m)\n\nevenMultOdd EZero _ = EZero\nevenMultOdd (ESuc n) m = oddPlusOdd m (oddMultOdd n m)\n\noddMultOdd (OSuc n) m = oddPlusEven m (evenMultOdd n m)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111530,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n\nmutual\n    evenMultEven : Even m -> Even n -> Even (m * n)\n    evenMultEven EZero y = EZero\n    evenMultEven (ESuc x) y = evenPlusEven y (oddMultEven x y)\n\n    oddMultEven : Odd m -> Even n -> Even (m * n)\n    oddMultEven (OSuc x) y = evenPlusEven y (evenMultEven x y)\n    \n    oddMultOdd : Odd m -> Odd n -> Odd  (m * n)\n    oddMultOdd (OSuc x) y = oddPlusEven y (evenMultOdd x y)\n    \n    evenMultOdd : Even m -> Odd n -> Even (m * n)\n    evenMultOdd EZero y = EZero\n    evenMultOdd (ESuc x) y = oddPlusOdd y (oddMultOdd x y)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111531,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\nevenMultOdd : Even m -> Odd n -> Even (m * n)\nevenMultEven EZero n = EZero\nevenMultEven (ESuc m) n = evenPlusEven n $ oddMultEven m n\noddMultEven (OSuc m) n = evenPlusEven n $ evenMultEven m n\noddMultOdd (OSuc m) n = oddPlusEven n $ evenMultOdd m n\nevenMultOdd EZero n = EZero\nevenMultOdd (ESuc m) n = oddPlusOdd n $ oddMultOdd m n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111532,"user_id":29,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\nevenMultEven EZero _ = EZero\nevenMultEven (ESuc (OSuc a)) b = evenPlusEven b (evenPlusEven b (evenMultEven a b))\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultEven (OSuc a) b = evenPlusEven b (evenMultEven a b)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\noddMultOdd (OSuc EZero) b = oddPlusEven b EZero\noddMultOdd (OSuc (ESuc a)) b = oddPlusEven b (oddPlusOdd b (oddMultOdd a b))\nevenMultOdd : Even m -> Odd n -> Even (m * n)\nevenMultOdd EZero _ = EZero\nevenMultOdd (ESuc (OSuc a)) b = oddPlusOdd b (oddPlusEven b (evenMultOdd a b))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111533,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\nevenMultOdd : Even m -> Odd n -> Even (m * n)\n\nevenMultEven EZero _ = EZero\nevenMultEven (ESuc a) b = evenPlusEven b $ oddMultEven a b\noddMultEven (OSuc a) b = evenPlusEven b $ evenMultEven a b\noddMultOdd (OSuc a) b = oddPlusEven b $ evenMultOdd a b \nevenMultOdd {m=m} a {n=n} b = rewrite multCommutative m n in oddMultEven b a","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111534,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\nevenMultOdd : Even m -> Odd n -> Even (m * n)\n\nevenMultEven EZero _ = EZero\nevenMultEven (ESuc m0) pn = evenPlusEven pn $ oddMultEven m0 pn\n\noddMultEven (OSuc m0) pn = evenPlusEven pn $ evenMultEven m0 pn\n\noddMultOdd (OSuc m0) pn = oddPlusEven pn $ evenMultOdd m0 pn\n\nevenMultOdd EZero _ = EZero\nevenMultOdd (ESuc m0) pn = oddPlusOdd pn $ oddMultOdd m0 pn","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111535,"user_id":443,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\nevenMultEven EZero y = EZero\nevenMultEven (ESuc (OSuc x)) y = evenPlusEven y (evenPlusEven y (evenMultEven x y))\n\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultEven (OSuc EZero) y = evenPlusEven y EZero\noddMultEven (OSuc (ESuc x)) y = evenPlusEven y (evenPlusEven y (oddMultEven x y))\n\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\noddMultOdd (OSuc EZero) y = oddPlusEven y EZero\noddMultOdd (OSuc (ESuc x)) y = oddPlusEven y (oddPlusOdd y (oddMultOdd x y))\n\nevenMultOdd : Even m -> Odd n -> Even (m * n)\nevenMultOdd EZero y = EZero\nevenMultOdd (ESuc (OSuc x)) y = oddPlusOdd y (oddPlusEven y (evenMultOdd x y))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111536,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\nevenMultOdd : Even m -> Odd n -> Even (m * n)\n\nevenMultEven EZero n = EZero\nevenMultEven (ESuc n) m = evenPlusEven m (oddMultEven n m)\n\noddMultEven (OSuc n) m = evenPlusEven m (evenMultEven n m)\n\noddMultOdd (OSuc n) m = oddPlusEven m (evenMultOdd n m)\n\nevenMultOdd EZero n = EZero\nevenMultOdd (ESuc n) m = oddPlusOdd m (oddMultOdd n m)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111537,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\nevenMultOdd : Even m -> Odd n -> Even (m * n)\n\nevenMultEven {m=Z} {n} EZero _ = EZero\nevenMultEven {m=S m'} {n} (ESuc o) e = evenPlusEven e (oddMultEven o e)\n\noddMultEven {m=S m'} {n} (OSuc e1) e2 = evenPlusEven e2 (evenMultEven e1 e2)\noddMultOdd {m=S m'} {n} (OSuc e) o = oddPlusEven o (evenMultOdd e o)\nevenMultOdd {m} {n} e o = rewrite (multCommutative m n) in oddMultEven o e","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111538,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n{- Preloaded functions:\nevenPlusEven : Even m -> Even n -> Even (m + n)\noddPlusEven : Odd m -> Even n -> Odd (m + n)\noddPlusOdd : Odd m -> Odd n -> Even (m + n)\nevenPlusOdd : Even m -> Odd n -> Odd (m + n)\n-}\n\n%access export\n%default total\n\n-- | Implement these functions:\nevenMultEven : Even m -> Even n -> Even (m * n)\nevenMultEven EZero _ = EZero\nevenMultEven (ESuc (OSuc a)) b = (evenPlusEven b (evenPlusEven b (evenMultEven a b)))\n\noddMultEven : Odd m -> Even n -> Even (m * n)\noddMultEven (OSuc a) b  = (evenPlusEven b (evenMultEven a b))\n\nevenMultOdd : Even m -> Odd n -> Even (m * n)\nevenMultOdd EZero _ = EZero\nevenMultOdd (ESuc (OSuc a)) b = (oddPlusOdd b (oddPlusEven b (evenMultOdd a b)))\n\noddMultOdd : Odd m -> Odd n -> Odd  (m * n)\noddMultOdd (OSuc a) b = (oddPlusEven b (evenMultOdd a b))\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8b332197eb04000887fd63":[{"id":111539,"user_id":168,"body":"module ArithSeq\n\nimport Preloaded\n\n%access export\n%default total\n\nhalfLemma : (k : Nat) -> (n : Nat) -> half (k + (k + n)) = k + half n\nhalfLemma Z n = Refl\nhalfLemma (S k) n =\n    rewrite plusCommutative k (S (k + n)) in\n    rewrite plusCommutative (k + n) k in\n    cong (halfLemma k n)\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S n) =\n    rewrite sym (arithEq n) in\n    rewrite plusCommutative n 1 in\n    rewrite multCommutative n (S (S n)) in\n    rewrite halfLemma n (n + n * n) in\n    rewrite multCommutative n (S n) in\n    Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111540,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nlemma : (k : Nat) -> (x : Nat) -> half (plus k (plus k x)) = plus k (half x)\nlemma Z _ = Refl\nlemma (S k') x =\n    rewrite sym (plusSuccRightSucc k' (plus k' x)) in\n    cong {f=S} $\n        lemma k' x\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S k) =\n    rewrite sym (arithEq k) in\n    rewrite sym (plusSuccRightSucc k 0) in\n    rewrite plusZeroRightNeutral k in\n    rewrite multRightSuccPlus k (S k) in\n    rewrite multRightSuccPlus k k in\n    cong {f=S} $\n        lemma k (plus k (mult k k))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111541,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nonePlusSucc : (n : Nat) -> n + 1 = S n\nonePlusSucc n = rewrite plusCommutative n 1 in Refl\n\nhalfLemma : (n : Nat) -> (m : Nat) -> half (plus n (plus n m)) = plus n (half m)\nhalfLemma Z m = Refl\nhalfLemma (S k) m = rewrite sym (plusSuccRightSucc k (plus k m)) in\n                    let indStep = halfLemma k m in eqSucc _ _ indStep\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S k) = rewrite onePlusSucc k in\n                rewrite multRightSuccPlus k (S k) in\n                rewrite halfLemma k (mult k (S k)) in\n                let indStep : (half (mult k (S k)) = arithSum k) = rewrite sym (onePlusSucc k) in arithEq k in\n                    eqSucc _ _ $ plusConstantLeft _ _ _ indStep\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111542,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nsimplify : (n : Nat) -> arithFormula n = half (n + n * n)\nsimplify n = rewrite plusCommutative n 1 in\n             rewrite multCommutative n (S n) in Refl\n\nhalfPlus : (m, n : Nat) -> half (m + (m + n)) = m + half n\nhalfPlus Z n = Refl\nhalfPlus (S m) n = rewrite sym (plusSuccRightSucc m (m + n)) in cong (halfPlus m n)\n\narithEq' : (n : Nat) -> half (n + n * n) = arithSum n\narithEq' Z     = Refl\narithEq' (S n) = rewrite sym (plusSuccRightSucc n (n + n * S n)) in\n                 rewrite multCommutative n (S n) in\n                 rewrite halfPlus n (n + n * n) in cong {f = ((S n) +)} (arithEq' n)\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq n = trans (simplify n) (arithEq' n)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111543,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nhalfp : (n : Nat) -> (m : Nat) -> half (n + n + m) = n + half m\nhalfp Z m = Refl\nhalfp (S k) m = rewrite plusCommutative k (S k) in\n                rewrite halfp k m in Refl\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S k) = rewrite sym $ arithEq k\n                in rewrite plusCommutative k 1\n                in rewrite multCommutative k (S (S k))\n                in rewrite plusAssociative k k (k + k * k)\n                in rewrite multCommutative k (S k)\n                in rewrite sym $ halfp k (k + k * k)\n                in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111544,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nhalfLemma1 : (n:Nat) -> half (n + n) = n\nhalfLemma1 Z = Refl\nhalfLemma1 (S k) = rewrite sym $ plusSuccRightSucc k k in cong (halfLemma1 k)\n\nhalfLemma2 : (m,n:Nat) -> half (m*2+n) = m+half n\nhalfLemma2 Z n = Refl\nhalfLemma2 (S k) n = cong (halfLemma2 k n)\n\nhalfLemma2' : (m,n:Nat) -> half (m+m+n) = m + half n\nhalfLemma2' Z n = Refl\nhalfLemma2' (S k) n = rewrite sym $ plusSuccRightSucc k k in cong $ halfLemma2' k n\n\nplusLemma : (x,y,z:Nat) -> x + (y + z) = y + (x + z)\nplusLemma Z y z = Refl\nplusLemma (S k) y z = rewrite sym $ plusSuccRightSucc y (k+z) in cong (plusLemma k y z)\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S Z) = Refl\narithEq (S (S k)) with (arithEq k)\n  arithEq (S (S k)) | eq =\n    rewrite multDistributesOverPlusRight k 2 (k+1) in\n    rewrite plusCommutative k 1 in\n    rewrite plusLemma k 3 (k+(k*2+k*(S k))) in\n    rewrite sym $ plusSuccRightSucc k (k+(arithSum k)) in\n    rewrite plusAssociative k k (k*2 + k*(S k)) in\n    rewrite halfLemma2' k (k*2 + k*(S k)) in\n    rewrite halfLemma2 k (k*(S k)) in\n    rewrite sym $ plusCommutative k 1 in\n    rewrite arithEq k in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111545,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nk2m : (k, m : Nat) -> (S (k + k + m))=(k+S k +m)\nk2m k m = cong {f = \\x=>x+m} $ plusSuccRightSucc k k\n\nhalfIn : (n, m : Nat) -> n + half (m) = half (n + n + m)\nhalfIn Z m = Refl\nhalfIn (S k) m = let q = cong {f = half . S} $ k2m k m in\n                    rewrite halfIn k m in q\n\ncommSn : (n, v: Nat) -> (n+1)+(n+v) = (S (n+n+v))\ncommSn n v = rewrite plusCommutative n 1 in \n              rewrite plusAssociative n n v in Refl\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S n) = let p = cong {f = S . plus n} (arithEq n) in \n                sym $ rewrite (sym p) in \n                  rewrite (multRightSuccPlus n (n+1)) in\n                    rewrite halfIn n (mult n (n+1)) in \n                      rewrite (cong {f=S} (commSn n (mult n (n+1)))) in Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111546,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nhalfSum : (m : Nat) -> (n : Nat) -> half (m + (m + n)) = m + half n\nhalfSum Z _ = Refl\nhalfSum (S m0) n =\n  rewrite plusAssociative (S m0) (S m0) n in\n  rewrite plusCommutative m0 (S m0) in\n  rewrite sym $ plusAssociative m0 m0 n in\n  eqSucc (half $ m0 + (m0 + n)) (m0 + half n) (halfSum m0 n)\n  \narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S n0) =\n  rewrite plusCommutative n0 1 in\n  rewrite multCommutative n0 $ S (S n0) in\n  rewrite halfSum n0 $ S n0 * n0 in\n  rewrite multCommutative (S n0) n0 in\n  rewrite plusCommutative 1 n0 in\n  plusConstantLeft (half $ n0 * (n0 + 1)) (arithSum n0) (S n0) (arithEq n0)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111547,"user_id":524,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nlemma0 : (k : Nat) -> plus k 1 = S k \nlemma0 Z = Refl \nlemma0 (S k) = rewrite lemma0 k in Refl\n\nlemma1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> a + b + c = b + (a + c)\nlemma1 a b c = rewrite plusCommutative a b in \n               rewrite plusAssociative b a c in \n               Refl  \n\nlemma3 : (n : Nat) -> plus n 0 = n \nlemma3 n = plusCommutative n 0\n\nlemma2 : (a : Nat) -> (b : Nat) -> half (b + b + a) = b + half a\nlemma2 a Z = Refl\nlemma2 a (S b) = rewrite lemma1 b (S b) a in \n                 rewrite plusAssociative b b a in \n                 rewrite lemma2 a b in \n                 Refl \n\nlemma4 : (k : Nat) -> plus k (mult k k) = mult k (S k)\nlemma4 k = rewrite multCommutative k (S k) in \n           Refl \n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl \narithEq (S k) = rewrite sym (arithEq k) in\n                rewrite lemma0 k in \n                rewrite multDistributesOverPlusRight k 2 k in \n                rewrite sym (lemma1 (mult k 2) k (mult k k)) in \n                rewrite sym (plusAssociative (mult k 2) k (mult k k)) in \n                rewrite multCommutative k 2 in\n                rewrite lemma3 k in \n                rewrite lemma2 (plus k (mult k k)) k in \n                rewrite lemma4 k in \n                Refl \n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111548,"user_id":null,"body":"module ArithSeq\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\narithSum : Nat -> Nat\narithSum Z = Z\narithSum (S n) = S n + arithSum n\n\n-- We define our own function for dividing a natural\n-- number by 2. \n-- The existing Idris function divNatNZ\n-- is not a good choice because it is impossible (correct\n-- me if I my wrong) to prove many useful properties of\n-- divNatNZ.\nhalf : Nat -> Nat\nhalf (S (S n)) = S (half n)\nhalf _ = Z\n\narithFormula : Nat -> Nat\narithFormula n = half $ n * (n + 1)\n-}\n\n%access export\n%default total\n\nhalfPlusPlus : (k :Nat) -> (n : Nat) -> half (k + (k + n)) = k + half n\nhalfPlusPlus Z n = Refl\nhalfPlusPlus (S k) n = rewrite sym (plusSuccRightSucc k (k + n))\n                       in rewrite halfPlusPlus k n\n                       in Refl\n\narithEq : (n : Nat) -> arithFormula n = arithSum n\narithEq Z = Refl\narithEq (S k) = rewrite sym (arithEq k) \n                in rewrite sym (plusSuccRightSucc k 0) \n                in rewrite plusZeroRightNeutral k \n                in rewrite multRightSuccPlus k (S k)\n                in rewrite halfPlusPlus k (mult k (S k))\n                in Refl\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8b3e55b9d1190016bd3cca":[{"id":111549,"user_id":168,"body":"module Fib\n\nimport Preloaded\n\n%access export\n%default total\n\nfibAuxLemma : (m : Nat) -> (n : Nat) -> fibAux (fib m) (fib (S m)) n = fib (m + n)\nfibAuxLemma m Z = rewrite plusZeroRightNeutral m in Refl\nfibAuxLemma m (S n) = \n    rewrite plusCommutative (fib m) (fib (S m)) in\n    rewrite fibAuxLemma (S m) n in\n    rewrite plusSuccRightSucc m n in\n    Refl\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq n = fibAuxLemma 0 n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111550,"user_id":null,"body":"module Fib\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nfibAux : Nat -> Nat -> Nat -> Nat\nfibAux a b Z = a\nfibAux a b (S n) = fibAux b (a + b) n\n\nfib2 : Nat -> Nat\nfib2 = fibAux 0 1\n-}\n\n%access export\n%default total\n\nfibEq' : (a:Nat) -> (b:Nat) -> (n:Nat) -> (fibAux a b n + fibAux a b (S n) = fibAux a b (S (S n)))\nfibEq' a b Z = Refl\nfibEq' a b (S n) = rewrite fibEq' b (a+b) n in Refl\n\nfibEq : (n:Nat) -> fib2 n = fib n\nfibEq Z = Refl\nfibEq (S Z) = Refl\nfibEq (S (S n)) =\n    rewrite sym $ fibEq n in\n    rewrite sym $ fibEq (S n) in\n    rewrite sym $ fibEq' 0 1 n in\n    rewrite plusCommutative (fibAux 0 1 n) (fibAux 1 1 n) in\n    Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111551,"user_id":106,"body":"module Fib\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nfibAux : Nat -> Nat -> Nat -> Nat\nfibAux a b Z = a\nfibAux a b (S n) = fibAux b (a + b) n\n\nfib2 : Nat -> Nat\nfib2 = fibAux 0 1\n-}\n\n%access public export\n%default total\n\nadd2 : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> a = b -> c = d -> a + c = b + d\nadd2 a b c d pab pcd = rewrite pcd in plusConstantRight a b d pab\n\nfib2Eq : (n : Nat) -> (a : Nat) -> (b : Nat) -> fibAux a b (S (S n)) = fibAux a b n + fibAux a b (S n)\nfib2Eq Z _ _ = Refl\nfib2Eq (S n) a b = fib2Eq n b (a + b)\n\nlem: (n : Nat) -> fib2 (S (S n)) = fib2 (S n) + fib2 n\nlem Z = Refl\nlem (S Z) = Refl\nlem (S (S n)) = rewrite plusCommutative (fibAux 2 3 n) (fibAux 1 2 n) in fib2Eq n 1 2\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq Z = Refl\nfibEq (S Z) = Refl\nfibEq (S (S n)) = rewrite lem n in add2 (fib2 (S n)) (fib (S n)) (fib2 n) (fib n) (fibEq (S n)) (fibEq n)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111552,"user_id":489,"body":"module Fib\n\nimport Preloaded\n\n%access export\n%default total\n\ninfix 2 ##\n(##) : {A : Type} -> {y : A} -> (x : A) -> x = y -> x = y\nx ## eq = eq\n\ninfixl 1 =>>\n(=>>) : {A : Type} -> {x : A} -> {y : A} -> {z : A} -> x = y -> y = z -> x = z\n(=>>) = trans\n\n{-\n+-lemma : \u2200 (a b c d : \u2115) \u2192 (a + b) + (c + d) \u2261 (a + c) + (b + d)\n+-lemma a b c d = begin\n  (a + b) + (c + d) \u2261\u27e8 sym $ +-assoc (a + b) c d \u27e9\n  ((a + b) + c) + d \u2261\u27e8 cong (_+ d) $ +-assoc a b c \u27e9\n  (a + (b + c)) + d \u2261\u27e8 cong (\u03bb {m -> (a + m) + d}) $ +-comm b c \u27e9\n  (a + (c + b)) + d \u2261\u27e8 cong (_+ d) $ sym $ +-assoc a c b \u27e9\n  ((a + c) + b) + d \u2261\u27e8 +-assoc (a + c) b d \u27e9\n  (a + c) + (b + d) \u220e\n  where open \u2261-Reasoning\n-}\n\nplusLemma : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (a + b) + (c + d) = (a + c) + (b + d)\nplusLemma a b c d =\n  (a + b) + (c + d)     ## plusAssociative (a + b) c d\n  =>> ((a + b) + c) + d ## cong {f = \\m => m + d} (sym $ plusAssociative a b c)\n  =>> (a + (b + c)) + d ## cong {f = \\m => (a + m) + d} (plusCommutative b c)\n  =>> (a + (c + b)) + d ## cong {f = \\m => m + d} (plusAssociative a c b)\n  =>> ((a + c) + b) + d ## sym (plusAssociative (a + c) b d)\n  =>> (a + c) + (b + d) ## Refl\n\n{-\nfib-aux-lemma : \u2200 (a1 a2 b1 b2 n : \u2115) \u2192 fib-aux (a1 + a2) (b1 + b2) n \u2261 fib-aux a1 b1 n + fib-aux a2 b2 n\nfib-aux-lemma a1 a2 b1 b2 zero = refl\nfib-aux-lemma a1 a2 b1 b2 (suc n) = begin\n  fib-aux (a1 + a2) (b1 + b2) (suc n) \u2261\u27e8\u27e9\n  fib-aux (b1 + b2) ((a1 + a2) + (b1 + b2)) n \u2261\u27e8 cong (\u03bb {m -> fib-aux (b1 + b2) m n}) $ +-lemma a1 a2 b1 b2 \u27e9\n  fib-aux (b1 + b2) ((a1 + b1) + (a2 + b2)) n \u2261\u27e8 fib-aux-lemma b1 b2 (a1 + b1) (a2 + b2) n \u27e9\n  fib-aux b1 (a1 + b1) n + fib-aux b2 (a2 + b2) n \u2261\u27e8\u27e9\n  fib-aux a1 b1 (suc n) + fib-aux a2 b2 (suc n) \u220e\n  where open \u2261-Reasoning\n-}\n\nfibAuxLemma : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) ->\n  fibAux (a + b) (c + d) n = fibAux a c n + fibAux b d n\nfibAuxLemma a b c d Z = Refl\nfibAuxLemma a b c d (S n) =\n  fibAux (a + b) (c + d) (S n)                ## Refl\n  =>> fibAux (c + d) ((a + b) + (c + d)) n    ## cong {f = \\m => fibAux (c + d) m n} (plusLemma a b c d)\n  =>> fibAux (c + d) ((a + c) + (b + d)) n    ## fibAuxLemma c d (a + c) (b + d) n\n  =>> fibAux c (a + c) n + fibAux d (b + d) n ## Refl\n  =>> fibAux a c (S n) + fibAux b d (S n)     ## Refl\n\n{-\nfib-eq : (n : \u2115) \u2192 fib2 n \u2261 fib n\nfib-eq zero = refl\nfib-eq (suc zero) = refl\nfib-eq (suc (suc n)) = begin\n  fib2 (suc (suc n)) \u2261\u27e8\u27e9\n  fib-aux 0 1 (suc (suc n)) \u2261\u27e8\u27e9\n  fib-aux 1 2 n \u2261\u27e8 fib-aux-lemma 1 0 1 1 n \u27e9\n  fib-aux 1 1 n + fib-aux 0 1 n \u2261\u27e8\u27e9\n  fib-aux 0 1 (suc n) + fib-aux 0 1 n \u2261\u27e8\u27e9\n  fib2 (suc n) + fib2 n \u2261\u27e8 cong (_+ fib2 n) $ fib-eq (suc n) \u27e9\n  fib (suc n) + fib2 n \u2261\u27e8 cong (fib (suc n) +_) $ fib-eq n \u27e9\n  fib (suc n) + fib n \u2261\u27e8\u27e9\n  fib (suc (suc n)) \u220e\n  where open \u2261-Reasoning\n-}\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq Z = Refl\nfibEq (S Z) = Refl\nfibEq (S (S n)) =\n  fib2 (S (S n))                      ## Refl\n  =>> fibAux 0 1 (S (S n))            ## Refl\n  =>> fibAux 1 2 n                    ## fibAuxLemma 1 0 1 1 n\n  =>> fibAux 1 1 n + fibAux 0 1 n     ## Refl\n  =>> fibAux 0 1 (S n) + fibAux 0 1 n ## Refl\n  =>> fib2 (S n) + fib2 n             ## cong {f = \\m => m + fib2 n} (fibEq (S n))\n  =>> fib (S n) + fib2 n              ## cong {f = \\m => fib (S n) + m} (fibEq n)\n  =>> fib (S n) + fib n               ## Refl\n  =>> fib (S (S n))                   ## Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111553,"user_id":503,"body":"module Fib\nimport Preloaded\n%access export\nh : (q : Nat) -> (s : Nat) -> (w : Nat) -> (a : Nat) -> (e : Nat) -> fibAux q s e + fibAux w a e = fibAux (q + w) (s + a) e\nh _ _ _ _ Z = Refl\nh q s w a (S e) =\n  rewrite h s (q + s) a (w + a) e in\n  rewrite plusAssociative (q + s) w a in\n  rewrite plusAssociative (q + w) s a in\n  rewrite sym (plusAssociative q s w) in\n  rewrite plusCommutative s w in\n  rewrite plusAssociative q w s in\n  Refl\nfibEq : (q : Nat) -> fib2 q = fib q\nfibEq Z = Refl\nfibEq (S Z) = Refl\nfibEq (S (S q)) = rewrite sym (fibEq (S q)) in rewrite sym (fibEq q) in rewrite h 1 1 0 1 q in Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111554,"user_id":null,"body":"module Fib\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nfibAux : Nat -> Nat -> Nat -> Nat\nfibAux a b Z = a\nfibAux a b (S n) = fibAux b (a + b) n\n\nfib2 : Nat -> Nat\nfib2 = fibAux 0 1\n-}\n\n%access export\n%default total\n\nlemma :\n    (k : Nat) ->\n    (a : _) ->\n    (b : _) ->\n    fibAux b (a+b) k + fibAux a b k = fibAux (a+b) (b+(a+b)) k\nlemma Z a b = plusCommutative b a\nlemma (S k) a b = lemma k b (a+b)\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq Z = Refl\nfibEq (S Z) = Refl\nfibEq (S (S k)) =\n    rewrite sym (fibEq k) in\n    rewrite sym (fibEq (S k)) in\n        sym (lemma k Z 1)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111555,"user_id":null,"body":"module Fib\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nfibAux : Nat -> Nat -> Nat -> Nat\nfibAux a b Z = a\nfibAux a b (S n) = fibAux b (a + b) n\n\nfib2 : Nat -> Nat\nfib2 = fibAux 0 1\n-}\n\n%access export\n%default total\n\nfibAuxLemma : (a : Nat) -> (b : Nat) -> (k : Nat) -> plus (fibAux a b (S k)) (fibAux a b k) = fibAux b (a + b) (S k)\nfibAuxLemma a b Z = plusCommutative _ _\nfibAuxLemma a b (S k) = fibAuxLemma b (plus a b) k\n\nfibEqAux : (n : Nat) -> fib n = fib2 n\nfibEqAux Z = Refl\nfibEqAux (S Z) = Refl\nfibEqAux (S (S k)) = rewrite fibEqAux k in\n                     rewrite fibEqAux (S k) in\n                      fibAuxLemma 0 1 k\n                      \nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq n = sym (fibEqAux n)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111556,"user_id":null,"body":"module Fib\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nfibAux : Nat -> Nat -> Nat -> Nat\nfibAux a b Z = a\nfibAux a b (S n) = fibAux b (a + b) n\n\nfib2 : Nat -> Nat\nfib2 = fibAux 0 1\n-}\n\n%access export\n%default total\n\nlema : (a : Nat) -> (b : Nat) -> fibAux (fib b) (fib (1 + b)) a = fib (a + b)\nlema Z _ = Refl\nlema (S k) b = let p1 = lema k (S b)\n                   p2 = plusCommutative (fib b) (fib (S b))\n                   p3 = plusSuccRightSucc k b\n               in rewrite p2 in (rewrite p3 in p1)\n\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq n = let p = lema n 0\n              p1 = cong {f = fib} $ sym $ plusZeroRightNeutral n\n          in rewrite p1 in p\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111557,"user_id":null,"body":"module Fib\n\nimport Preloaded\n\n%access export\n%default total\n\nmakeStep : (a, k : Nat) -> (fibAux (fib a) (fib (S a)) (S k) = fibAux (fib (S a)) (fib (S (S a))) k)\nmakeStep a _ = rewrite plusCommutative (fib a) (fib (S a)) in Refl\n\nmakeAllSteps : (a, k : Nat) -> fibAux (fib a) (fib (S a)) k = fibAux (fib (a+k)) (fib (S (a+k))) Z\nmakeAllSteps a Z = rewrite plusZeroRightNeutral a in Refl\nmakeAllSteps a (S k) = rewrite makeStep a k in \n                rewrite makeAllSteps (S a) k in \n                  rewrite plusSuccRightSucc a k in \n                    Refl\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq k = makeAllSteps 0 k","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111558,"user_id":null,"body":"module Fib\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nfibAux : Nat -> Nat -> Nat -> Nat\nfibAux a b Z = a\nfibAux a b (S n) = fibAux b (a + b) n\n\nfib2 : Nat -> Nat\nfib2 = fibAux 0 1\n-}\n\n%access export\n%default total\n\nmakeStep : (a, k : Nat) -> (fibAux (fib a) (fib (S a)) (S k) = fibAux (fib (S a)) (fib (S (S a))) k)\nmakeStep a _ = rewrite plusCommutative (fib a) (fib (S a)) in Refl\n\nmakeAllSteps : (a, k : Nat) -> fibAux (fib a) (fib (S a)) k = fibAux (fib (a+k)) (fib (S (a+k))) Z\nmakeAllSteps a Z = rewrite plusZeroRightNeutral a in Refl\nmakeAllSteps a (S k) = rewrite makeStep a k in \n                rewrite makeAllSteps (S a) k in \n                  rewrite plusSuccRightSucc a k in \n                    Refl\n\nfibEq : (n : Nat) -> fib2 n = fib n\nfibEq k = makeAllSteps 0 k\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8b4215a99b9c000d07d7b2":[{"id":111559,"user_id":106,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access public export\n%default total\n\nhelper : (f : Nat -> Nat) -> (n : Nat) -> (acc : Nat) -> acc + (sumSimple f (S n)) = (f (S n) + acc) + (sumSimple f n)\nhelper f n acc = rewrite plusCommutative (f (S n)) acc in (plusAssociative acc (f (S n)) (sumSimple f n))\n\nlem : (f : Nat -> Nat) -> (n : Nat) -> (acc : Nat) -> sumAux acc f n = acc + (sumSimple f n)\nlem f Z acc = sym (plusZeroRightNeutral acc)\nlem f (S n) acc = rewrite helper f n acc in lem f n (f (S n) + acc)\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f n = lem f n Z","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111560,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\nlemmaStep :\n    (acc : Nat) ->\n    (f : (Nat -> Nat)) ->\n    (n : Nat) ->\n    sumAux (S acc) f n = S (sumAux acc f n)\nlemmaStep acc f Z = Refl\nlemmaStep acc f (S n') =\n    rewrite sym (plusSuccRightSucc (f (S n')) acc) in\n    rewrite lemmaStep (plus (f (S n')) acc) f n' in \n        Refl\n\nlemma :\n    (acc : Nat) ->\n    (f : Nat -> Nat) ->\n    (n : Nat) ->\n    sumAux acc f n = acc + (sumAux Z f n)\nlemma Z f n = Refl\nlemma (S k) f n =\n    rewrite sym (lemma k f n) in\n    lemmaStep k _ _\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S k) =\n    rewrite sym (sumEq f k) in\n    rewrite plusZeroRightNeutral (f (S k)) in\n        lemma (f (S k)) _ _","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111561,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\naccElim : (acc : Nat) -> (f : Nat -> Nat) -> (n : Nat) -> sumAux acc f n = acc + sumAux Z f n \naccElim acc f Z = rewrite plusZeroRightNeutral acc in Refl\naccElim acc f (S k) = rewrite plusZeroRightNeutral (f (S k)) in\n                      rewrite accElim (f (S k)) f k in\n                      rewrite plusAssociative acc (f (S k)) (sumAux 0 f k) in\n                      rewrite plusCommutative acc (f (S k)) in\n                              accElim (plus (f (S k)) acc) f k \n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S k) = rewrite plusZeroRightNeutral (f (S k)) in \n                rewrite accElim (f (S k)) f k in \n                        plusConstantLeft _ _ _ $ sumEq f k \n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111562,"user_id":527,"body":"module Sum\n\nimport Preloaded\n\n%access export\n%default total\n\nsumEq' : (acc: Nat) -> (f : Nat -> Nat) -> (n : Nat) -> sumAux acc f n = acc + sumSimple f n\nsumEq' acc _ Z = sym (plusZeroRightNeutral acc)\nsumEq' acc f (S m) =\n  rewrite sumEq' (f (S m) + acc) f m in\n  rewrite plusConstantRight (f (S m) + acc) (acc + f (S m)) (sumSimple f m) (plusCommutative (f (S m)) acc) in\n  sym (plusAssociative acc (f (S m)) (sumSimple f m))\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq = sumEq' 0\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111563,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\nsumEqAux : (f:Nat->Nat) -> (n,s:Nat) -> sumAux s f n = s + sumAux 0 f n\nsumEqAux f Z s = sym $ plusZeroRightNeutral _\nsumEqAux f (S k) s =\n    rewrite sumEqAux f k (f (S k) + s) in\n    rewrite sumEqAux f k (f (S k) + 0) in\n    rewrite plusZeroRightNeutral (f (S k)) in\n    rewrite plusCommutative (f (S k)) s in\n    rewrite plusAssociative s (f (S k)) (sumAux 0 f k) in\n    Refl\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S n) =\n    rewrite plusZeroRightNeutral (f (S n)) in\n    rewrite sumEqAux f n (f (S n)) in\n    rewrite sumEq f n in\n    Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111564,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\nsumMv : (f : Nat -> Nat) -> (v, k : Nat) -> sumAux v f k = v + (sumAux 0 f k)\nsumMv f v Z = rewrite plusZeroRightNeutral v in Refl\nsumMv f v (S k) = rewrite plusZeroRightNeutral (f (S k)) in \n            rewrite plusCommutative (f (S k)) v in \n                rewrite sumMv f (v + f (S k)) k in\n                    rewrite sym $ plusAssociative v (f (S k)) (sumAux 0 f k) in\n                        cong $ sym $ sumMv f (f (S k)) k\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S k) = rewrite (sym $ sumEq f k) in \n    rewrite plusZeroRightNeutral (f (S k)) in \n        sumMv f (f (S k)) k","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111565,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f n = lemma f n 0 where\n  lemma : (f : Nat -> Nat) -> (n, acc : Nat) -> sumAux acc f n = acc + sumSimple f n\n  lemma f Z acc = rewrite plusZeroRightNeutral acc in Refl\n  lemma f (S k) acc = rewrite plusCommutative (f (S k)) acc in\n                      rewrite lemma f k (acc + f (S k)) in\n                      rewrite plusAssociative acc (f (S k)) (sumSimple f k) in\n                      Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111566,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n\n%access export\n%default total\n\nsumAuxS : (a : Nat) -> (f : Nat -> Nat) -> (n : Nat) -> sumAux (S a) f n = S (sumAux a f n)\nsumAuxS _ _ Z = Refl\nsumAuxS a f (S s) = rewrite sym (plusSuccRightSucc (f (S s)) a) in\n                    rewrite sym (sumAuxS (plus (f (S s)) a) f s) in Refl\n\nsumAuxPlus : (b : Nat) -> (a : Nat) -> (f : Nat -> Nat) -> (n : Nat) -> sumAux (plus a b) f n = plus b (sumAux a f n)\nsumAuxPlus Z a _ _ = rewrite plusZeroRightNeutral a in Refl\nsumAuxPlus (S k) a f n = rewrite sym (plusSuccRightSucc a k) in\n                         rewrite sumAuxS (plus a k) f n in\n                         rewrite sumAuxPlus k a f n in Refl\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S k) = rewrite plusZeroRightNeutral (f (S k)) in\n                rewrite sumAuxPlus (f (S k)) 0 f k in\n                rewrite sumEq f k in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111567,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\nlemma : (f : Nat -> Nat) -> (n : Nat) -> (acc : Nat) ->  acc + sumAux 0 f n = sumAux (acc + 0) f n\nlemma f Z acc = Refl\nlemma f (S k) acc =\n  rewrite sym (lemma f k (f (S k))) in\n  rewrite plusAssociative acc (f (S k)) (sumAux 0 f k) in\n  rewrite plusCommutative acc (f (S k)) in\n  rewrite lemma f k (f (S k) + acc) in\n  rewrite sym (plusAssociative (f (S k)) acc 0) in Refl\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S k) = rewrite sym (sumEq f k) in sym (lemma f k (f (S k)))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111568,"user_id":null,"body":"module Sum\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\nsumSimple : (Nat -> Nat) -> Nat -> Nat\nsumSimple _ Z = Z\nsumSimple f (S n) = f (S n) + sumSimple f n\n\nsumAux : Nat -> (Nat -> Nat) -> Nat -> Nat\nsumAux acc _ Z = acc\nsumAux acc f (S n) = sumAux (f (S n) + acc) f n\n\nsumTail : (Nat -> Nat) -> Nat -> Nat\nsumTail = sumAux 0\n-}\n\n%access export\n%default total\n\naccEq : (a : Nat) -> (f : Nat -> Nat) -> (k : Nat) -> sumAux a f k = a + sumAux 0 f k\naccEq a f Z = rewrite plusZeroRightNeutral a in Refl\naccEq a f (S k) = rewrite accEq (f (S k) + a) f k in\n    rewrite plusCommutative (f (S k)) 0 in\n    rewrite accEq (f (S k)) f k in\n    rewrite plusCommutative (f (S k)) a in\n    rewrite plusAssociative a (f (S k)) (sumAux 0 f k) in Refl\n\nsumEq : (f : Nat -> Nat) -> (n : Nat) -> sumTail f n = sumSimple f n\nsumEq f Z = Refl\nsumEq f (S k) = let prf = sumEq f k in\n    rewrite plusCommutative (f $ S k) 0 in\n    rewrite sym $ prf in\n        accEq (f (S k)) f k","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8b4799133e6c0009c7b096":[{"id":111569,"user_id":489,"body":"module Pow\n\nimport Preloaded\n\n%access export\n%default total\n\ninfix 2 ##\n(##) : {A : Type} -> {y : A} -> (x : A) -> x = y -> x = y\nx ## eq = eq\n\ninfixl 1 =>>\n(=>>) : {A : Type} -> {x : A} -> {y : A} -> {z : A} -> x = y -> y = z -> x = z\n(=>>) = trans\n\n-- The following lemma is useful\n{-\ndivMod2Lemma : (n : Nat) -> n = 2 * fst (divMod2 n) + if snd (divMod2 n) then 1 else 0\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S k)) with (divMod2 k) proof eq\n    | (q, r) = ?complete_a_proof -}\n\n{-\nlemma0 : \u2200 n \u2192 fst (divmod2 n) \u2264 n\nlemma0 zero = z\u2264n\nlemma0 (suc zero) = z\u2264n\nlemma0 (suc (suc n)) = \u2264-step (s\u2264s (lemma0 n))\n-}\n\nfst' : {A : Type} -> {B : Type} -> Pair A B -> A\nfst' = Prelude.Basics.fst\nsnd' : {A : Type} -> {B : Type} -> Pair A B -> B\nsnd' = Prelude.Basics.snd\n\nhalf : Nat -> Nat\nhalf Z = Z\nhalf (S Z) = Z\nhalf (S (S n)) = S (half n)\n\nlemma00 : (n : Nat) -> fst' (divMod2 (S (S n))) = S (fst' (divMod2 n))\nlemma00 n with (divMod2 n)\n  | (p, q) = Refl\n\nlemma0 : (n : Nat) -> LTE (fst' (divMod2 n)) n\nlemma0 Z = LTEZero\nlemma0 (S Z) = LTEZero\nlemma0 (S (S n)) = rewrite lemma00 n in lteSuccRight (LTESucc (lemma0 n))\n\n{-\nlemma1 : \u2200 e k e\/2 \u2192 fst (divmod2 e) \u2261 e\/2 \u2192 e \u2264 k \u2192 e\/2 \u2264 k\nlemma1 e k e\/2 half-e e\u2264k = \u2264-trans (\u2264-reflexive (sym half-e)) (\u2264-trans (lemma0 e) e\u2264k)\n-}\n\nlemma1 : (e : Nat) -> (k : Nat) -> (e2 : Nat) -> fst' (divMod2 e) = e2 -> LTE e k -> LTE e2 k\nlemma1 e k e2 eq lte = lteTransitive (rewrite (sym eq) in lteRefl) (lteTransitive (lemma0 e) lte)\n\n{-\nlemma2 : \u2200 k b e e\/2 \u2192 divmod2 e \u2261 (e\/2 , false) \u2192 powSqrAux (suc k) (b * b) e\/2 \u2261 powSqrAux (suc (suc k)) b e\nlemma2 k b zero zero eq = refl\nlemma2 k b (suc zero) _ ()\nlemma2 k b zero (suc e\/2) ()\nlemma2 k b (suc (suc e)) zero ()\nlemma2 k b (suc (suc e)) (suc e\/2) eq with divmod2 e\nlemma2 k b (suc (suc e)) (suc e\/2) eq | (e\/2' , false) = cong (powSqrAux (suc k) (b * b)) (sym (cong fst eq))\nlemma2 k b (suc (suc e)) (suc e\/2) () | (e\/2' , true)\n-}\n\nlemma2 : (k : Nat) -> (b : Nat) -> (e : Nat) -> (e2 : Nat) -> divMod2 e = (e2, False) ->\n  powSqrAux (S k) (b * b) e2 = powSqrAux (S (S k)) b e\nlemma2 k b Z Z eq = Refl\nlemma2 k b (S Z) _ eq = void $ trueNotFalse $ cong {f = snd'} eq\nlemma2 k b Z (S e2) eq = void $ ZnotS $ cong {f = fst'} eq\nlemma2 k b (S (S e)) Z eq = void $ ZnotS $ cong {f = fst'} (sym eq) =>> lemma00 e\nlemma2 k b (S (S e)) (S e2) eq with (divMod2 e)\n  | (e2', False) = cong {f = powSqrAux (S k) (b * b)} $ sym $ cong {f = fst'} eq\n  | (e2', True) = void $ trueNotFalse $ cong {f = snd'} eq\n\n{-\nlemma2' : \u2200 k b e e\/2 \u2192 divmod2 e \u2261 (e\/2 , true) \u2192 b * powSqrAux (suc k) (b * b) e\/2 \u2261 powSqrAux (suc (suc k)) b e\nlemma2' k b zero _ ()\nlemma2' k b (suc zero) zero eq = refl\nlemma2' k b (suc zero) (suc e\/2) ()\nlemma2' k b (suc (suc e)) zero ()\nlemma2' k b (suc (suc e)) (suc e\/2) eq with divmod2 e\nlemma2' k b (suc (suc e)) (suc e\/2) eq | (e\/2' , true) = cong (\u03bb {m \u2192 b * powSqrAux (suc k) (b * b) m}) (sym (cong fst eq))\nlemma2' k b (suc (suc e)) (suc e\/2) () | (e\/2' , false)\n-}\n\nlemma2' : (k : Nat) -> (b : Nat) -> (e : Nat) -> (e2 : Nat) -> divMod2 e = (e2, True) ->\n  b * powSqrAux (S k) (b * b) e2 = powSqrAux (S (S k)) b e\nlemma2' k b Z e2 eq = void $ trueNotFalse $ cong {f = snd'} $ sym eq\nlemma2' k b (S Z) Z eq = Refl\nlemma2' k b (S Z) (S e2) eq = void $ ZnotS $ cong {f = fst'} eq\nlemma2' k b (S (S e)) Z eq = void $ ZnotS $ cong {f = fst'} (sym eq) =>> lemma00 e\nlemma2' k b (S (S e)) (S e2) eq with (divMod2 e)\n  | (e2', False) = void $ trueNotFalse $ cong {f = snd'} $ sym eq\n  | (e2', True) = cong {f = \\m => b * powSqrAux (S k) (b * b) m} $ sym $ cong {f = fst'} eq\n\n{-\npowSqrS : \u2200 k b e \u2192 e \u2264 k \u2192 powSqrAux (suc k) b (suc e) \u2261 b * powSqrAux (suc k) b e\npowSqrS zero b zero e\u2264k = refl\npowSqrS zero b (suc e) ()\npowSqrS (suc k) b zero e\u2264k = refl\npowSqrS (suc k) b (suc e) (s\u2264s e\u2264k) with divmod2 e | inspect divmod2 e\npowSqrS (suc k) b (suc e) (s\u2264s e\u2264k) | (e\/2 , false) | [ eq ] =  begin\n  powSqrAux (suc k) (b * b) (suc e\/2) \u2261\u27e8 powSqrS k (b * b) e\/2 (lemma1 e k e\/2 (cong fst eq) e\u2264k) \u27e9\n  b * b * powSqrAux (suc k) (b * b) e\/2 \u2261\u27e8 cong (b * b *_) (lemma2 k b e e\/2 eq) \u27e9\n  b * b * powSqrAux (suc (suc k)) b e \u2261\u27e8 *-assoc b b (powSqrAux (suc (suc k)) b e) \u27e9\n  b * (b * powSqrAux (suc (suc k)) b e) \u2261\u27e8 cong (b *_) (sym (powSqrS (suc k) b e (\u2264-step e\u2264k))) \u27e9\n  b * powSqrAux (suc (suc k)) b (suc e) \u220e \n  where open \u2261-Reasoning\npowSqrS (suc k) b (suc e) (s\u2264s e\u2264k) | (e\/2 , true) | [ eq ] = cong (b *_) (begin\n  (powSqrAux (suc k) (b * b) (suc e\/2)) \u2261\u27e8 powSqrS k (b * b) e\/2 (lemma1 e k e\/2 (cong fst eq) e\u2264k) \u27e9\n  b * b * powSqrAux (suc k) (b * b) e\/2 \u2261\u27e8 *-assoc b b (powSqrAux (suc k) (b * b) e\/2) \u27e9\n  b * (b * powSqrAux (suc k) (b * b) e\/2) \u2261\u27e8 cong (b *_) (lemma2' k b e e\/2 eq) \u27e9\n  b * powSqrAux (suc (suc k)) b e \u2261\u27e8 sym (powSqrS (suc k) b e (\u2264-step e\u2264k)) \u27e9\n  powSqrAux (suc (suc k)) b (suc e) \u220e)\n  where open \u2261-Reasoning\n-}\n\npowSqrS : (k : Nat) -> (b : Nat) -> (e : Nat) -> LTE e k -> powSqrAux (S k) b (S e) = b * powSqrAux (S k) b e\npowSqrS Z b Z lte = Refl\npowSqrS Z b (S e) lte impossible\npowSqrS (S k) b Z lte = Refl\npowSqrS (S k) b (S e) (LTESucc lte) with (divMod2 e) proof eq\n  | (e2, False) =\n    powSqrAux (S k) (b * b) (S e2)         ## powSqrS k (b * b) e2 (lemma1 e k e2 (sym $ cong {f = fst'} eq) lte)\n    =>> b * b * powSqrAux (S k) (b * b) e2 ## cong {f = \\m => b * b * m} (lemma2 k b e e2 (sym eq))\n    =>> b * b * powSqrAux (S (S k)) b e    ## sym (multAssociative b b (powSqrAux (S (S k)) b e))\n    =>> b * (b * powSqrAux (S (S k)) b e)  ## cong {f = \\m => b * m} (sym (powSqrS (S k) b e (lteSuccRight lte)))\n    =>> b * powSqrAux (S (S k)) b (S e)    ## Refl\n  | (e2, True) = cong {f = \\m => b * m} $\n    powSqrAux (S k) (b * b) (S e2)           ## powSqrS k (b * b) e2 (lemma1 e k e2 (cong {f = fst'} $ sym eq) lte)\n    =>> b * b * powSqrAux (S k) (b * b) e2   ## sym (multAssociative b b (powSqrAux (S k) (b * b) e2))\n    =>> b * (b * powSqrAux (S k) (b * b) e2) ## cong {f = \\m => b * m} (lemma2' k b e e2 $ sym eq)\n    =>> b * powSqrAux (S (S k)) b e          ## sym (powSqrS (S k) b e (lteSuccRight lte))\n    =>> powSqrAux (S (S k)) b (S e)          ## Refl\n\n{-\npowEq' : \u2200 k b e \u2192 e \u2264 k \u2192 powSqrAux k b e \u2261 power b e\npowEq' zero b zero e\u2264k = refl\npowEq' zero b (suc e) ()\npowEq' (suc k) b zero e\u2264k = refl\npowEq' (suc k) b (suc e) (s\u2264s e\u2264k) = begin\n  powSqrAux (suc k) b (suc e) \u2261\u27e8 powSqrS k b e e\u2264k \u27e9\n  b * powSqrAux (suc k) b e \u2261\u27e8 cong (b *_) (powEq' (suc k) b e (\u2264-step e\u2264k)) \u27e9\n  b * power b e \u220e\n  where open \u2261-Reasoning\n-}\n\npowEq' : (k : Nat) -> (b : Nat) -> (e : Nat) -> LTE e k -> powSqrAux k b e = power b e\npowEq' Z b Z lte = Refl\npowEq' Z b (S e) lte impossible\npowEq' (S k) b Z lte = Refl\npowEq' (S k) b (S e) (LTESucc lte) =\n  powSqrAux (S k) b (S e)     ## powSqrS k b e lte\n  =>> b * powSqrAux (S k) b e ## cong {f = \\m => b * m} (powEq' (S k) b e (lteSuccRight lte))\n  =>> b * power b e           ## Refl\n\n{-\npowEq : \u2200 b e \u2192 powSqr b e \u2261 power b e\npowEq b e = powEq' e b e \u2264-refl\n-}\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\npowEq b e = powEq' e b e lteRefl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111570,"user_id":null,"body":"module Pow\n\nimport Preloaded\n\n%access export\n%default total\n\n-- The following lemma is useful\n\ndivMod2Lemma : (n : Nat) -> n = (let res = divMod2 n in (if snd res then 1 else 0) + (fst res * 2))\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S n)) with (cong {f = S . S} $ divMod2Lemma n)\n  divMod2Lemma (S (S n)) | eq with (divMod2 n)\n    divMod2Lemma (S (S n)) | eq | (q, True) = eq\n    divMod2Lemma (S (S n)) | eq | (q, False) = eq\n\npowerMultMultPower : (b,q:Nat) -> power (b * b) q = power b (mult q 2)\npowerMultMultPower b Z = Refl\npowerMultMultPower b (S q) = rewrite powerMultMultPower b q in sym $ multAssociative b b (power b (mult q 2))\n\nhelpDouble : (q:Nat) -> q `LTE` q * 2\nhelpDouble Z = LTEZero\nhelpDouble (S q) = lteSuccRight (LTESucc (helpDouble q))\n\nhelpLTE : (q,c:Nat) -> S c = r + (q * 2) -> q `LTE` c\nhelpLTE Z c eq = LTEZero\nhelpLTE {r} (S q) c eq = fromLteSucc (\n    rewrite eq in\n    rewrite plusCommutative r (S (S (q * 2))) in\n    LTESucc $ LTESucc $ lteTransitive (helpDouble q) (lteAddRight (q * 2))\n)\n\nhelp : S e `LTE` S c -> fst (divMod2 (S e)) `LTE` c\nhelp {e} (LTESucc par) = lteTransitive (helpLTE _ _ (divMod2Lemma (S e))) par\n\npowEqAux : (c,b,e:Nat) -> e `LTE` c -> powSqrAux c b e = power b e\npowEqAux Z b Z p = Refl\npowEqAux (S c) b Z p = Refl\npowEqAux (S c) b (S e) (LTESucc p) with (cong {f = power b} $ sym $ divMod2Lemma (S e))\n  powEqAux (S c) b (S e) (LTESucc p) | eq with (help (LTESucc p))\n    powEqAux (S c) b (S e) (LTESucc p) | eq | np with (divMod2 (S e))\n      powEqAux (S c) b (S e) (LTESucc p) | eq | np | (q, True) =\n        let pr = cong {f=(b*)} (powerMultMultPower b q) in\n        cong (powEqAux c (b*b) q np) `trans` pr `trans` eq\n      powEqAux (S c) b (S e) (LTESucc p) | eq | np | (q, False) =\n        let pr = (powerMultMultPower b q) in\n        powEqAux c (b*b) q np `trans` pr `trans` eq\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\npowEq b e = powEqAux e b e lteRefl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111571,"user_id":null,"body":"module Pow\n\nimport Preloaded\n\n%access export\n%default total\n\n-- The following lemma is useful\ndivMod2Lemma : (n : Nat) -> n = (let res = divMod2 n in (if snd res then 1 else 0) + (fst res + fst res))\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S k)) with (cong {f = S . S} $ divMod2Lemma k)\n  divMod2Lemma (S (S k)) | eq with (divMod2 k)\n    divMod2Lemma (S (S k)) | eq | (q, r) with (sym $ plusSuccRightSucc q q)\n      divMod2Lemma (S (S k)) | eq | (q, True) | eq' = rewrite eq' in eq\n      divMod2Lemma (S (S k)) | eq | (q, False) | eq' = rewrite eq' in eq\n\n\npowerSquarePowerPlus : (b,q : Nat) -> power (b * b) q = power b (q + q)\npowerSquarePowerPlus b q =\n    rewrite cong {f = (q +)} (sym $ plusZeroRightNeutral q) in\n    rewrite cong {f = (b *)} (sym $ multOneRightNeutral b) in\n        powerPowerMultPower b 2 q\n\nhelpLTE : (a,b:Nat) -> S b = c + (a + a) -> a `LTE` b\nhelpLTE {c = c} Z b eq = LTEZero\nhelpLTE {c = c} (S a) b eq =\n    fromLteSucc (\n        rewrite eq in\n        rewrite plusSuccRightSucc a (S a) in\n        rewrite plusAssociative c a (S (S a)) in\n        rewrite plusCommutative (c + a) (S (S a)) in\n        lteAddRight (S (S a))\n    )\n\nhelp : S e `LTE` S c -> fst (divMod2 (S e)) `LTE` c\nhelp {e} (LTESucc p) with (divMod2Lemma (S e))\n  help {e} (LTESucc p) | eq with (divMod2 (S e))\n    help {e} (LTESucc p) | eq | (q, _) = lteTransitive (helpLTE q e eq) p\n\npowEqAux : (c,b,e:Nat) -> e `LTE` c -> powSqrAux c b e = power b e\npowEqAux Z b Z p = Refl\npowEqAux (S _) b Z p = Refl\npowEqAux (S c) b (S e) (LTESucc p) with (cong {f = power b} $ sym $ divMod2Lemma (S e))\n  powEqAux (S c) b (S e) (LTESucc p) | p1 with (help (LTESucc p))\n    powEqAux (S c) b (S e) (LTESucc p) | p1 | np with (divMod2 (S e))\n      powEqAux (S c) b (S e) (LTESucc p) | p1 | np | (q, True) =\n        let p2 = cong {f = (b *)} $ powerSquarePowerPlus b q in\n        cong (powEqAux c (b*b) q np) `trans` p2 `trans` p1\n      powEqAux (S c) b (S e) (LTESucc p) | p1 | np | (q, False) =\n        let p2 = powerSquarePowerPlus b q in\n            powEqAux c (b*b) q np `trans` p2 `trans` p1\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\npowEq b e = powEqAux e b e lteRefl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111572,"user_id":null,"body":"module Pow\n\nimport Preloaded\n\n%access export\n%default total\n\n-- The following lemma is useful\ndivMod2Lemma : (n : Nat) -> n = 2 * fst (divMod2 n) + if snd (divMod2 n) then 1 else 0\n\ncongPair : {a, b: Type} -> (x: a) -> (y: b) -> (v: (a,b)) -> (v=(x,y)) -> (fst v = x, snd v = y)\ncongPair x y (x', y') p = (congFst' p, congSnd' p) \n  where\n    congFst' : (a,b)=(c,d) -> a = c\n    congFst' Refl = Refl\n    congSnd' : (a,b)=(c,d) -> b = d\n    congSnd' Refl = Refl\n\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S k)) with (divMod2 k) proof eq\n    | (k', False) = let (first, second) = congPair k' False (divMod2 k) (sym $ eq) in\n\trewrite plusZeroRightNeutral k' in \n\trewrite plusCommutative k' (S k') in \n\tlet p = divMod2Lemma k in\n\tlet q = replace {P = \\v=>(k = 2*v + if snd (divMod2 k) then 1 else 0)} first p in\n\tlet r = replace {P = \\v=>(k = 2*k' + if v then 1 else 0)} second q in\n\tlet r' = replace {P = \\v=>(k = plus (plus k' v) 0)} (plusZeroRightNeutral k') r in\n\tcong {f=S . S} r'\n    | (k', True) = let (first, second) = congPair k' True (divMod2 k) (sym $ eq) in\n\trewrite plusZeroRightNeutral k' in \n\trewrite plusCommutative k' (S k') in \n\tlet p = divMod2Lemma k in\n\tlet q = replace {P=\\v=>(k=2*v + if snd (divMod2 k) then 1 else 0)} first p in \n        let r = replace {P=\\v=>(k=2*k'+if v then 1 else 0)} second q in\n\tlet r' = replace {P = \\v=>(k = plus (plus k' v) 1)} (plusZeroRightNeutral k') r in\n\tcong {f=S . S} r'\n\ncongSZ : (x, y) = (x', y') -> (S x, y) = (S x', y')\ncongSZ {x} {y} {x'} {y'} p = let (first, second) = congPair x' y' (x, y) p in\n\trewrite first in rewrite second in Refl\n\ndivMod2Eq : {n: Nat} -> divMod2 n = (x, y) -> divMod2 (S (S n)) =(S x, y)\ndivMod2Eq {n} p with (divMod2 n) proof eq\n     | (x', y') = congSZ p\n\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z p = p\nplusLteInjLeft (S k) (LTESucc p) = plusLteInjLeft k p\n\nssnDiv2LTssn : (n: Nat) -> fst (divMod2 (S (S n))) `LT` (S (S n))\nssnDiv2LTssn Z = lteRefl\nssnDiv2LTssn (S Z) = lteSuccRight lteRefl\nssnDiv2LTssn (S (S k)) with (divMod2 k) proof eq\n    | (k', False) = let ssp = ssnDiv2LTssn k in\n\tlet ssin = divMod2Eq $ sym eq in \n\tlet (first, _) = congPair (S k') False (divMod2 (S (S k))) (ssin) in\t\n\tlet r = replace {P=(\\v=>LTE (S v) (S (S k)) )} first ssp in\n\tlteSuccRight $ LTESucc r\n    | (k', True) = let ssp = ssnDiv2LTssn k in\n\tlet ssin = divMod2Eq $ sym eq in \n\tlet (first, _) = congPair (S k') True (divMod2 (S (S k))) (ssin) in\t\n\tlet r = replace {P=(\\v=>LTE (S v) (S (S k)) )} first ssp in\n\tlteSuccRight $ LTESucc r  \n    \n\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\n\n-- k is the formal recursion argument for termination.\n-- w is the powSqrAux's formal recursion argument for termination.\npowEq' : (k, w, b, e : Nat) -> e `LTE` w -> e `LTE` k -> powSqrAux w b e = power b e\n\n-- k is the formal recursion argument for termination.\n-- w is the powSqrAux's formal recursion argument for termination.\nsteps' : (k, w, b, e: Nat) -> e `LTE` k -> e `LTE` w -> powSqrAux w b e = powSqrAux e b e\nsteps' k Z b Z p q = Refl\nsteps' k Z b (S e') p q impossible\nsteps' k (S w) b Z p q = Refl\nsteps' Z (S w) b (S Z) p q impossible\nsteps' Z (S w) b (S (S e)) p q impossible\nsteps' (S a) (S k) b (S Z) p (LTESucc q) = rewrite steps' a k (b*b) Z LTEZero q in Refl\nsteps' (S a) (S k) b (S (S e)) (LTESucc p) (LTESucc q) with (divMod2 (S (S e))) proof eq\n    | (e', False) = let (first, second) = congPair e' False (divMod2 (S (S e))) (sym $ eq) in\n\tlet ltLPrf = plusLteInjLeft 1 $ replace {P=(\\v=>LTE (S v) (S (S e)))} first $ ssnDiv2LTssn e in\n\tlet prf = steps' a k (b*b) e' (lteTransitive ltLPrf p) (lteTransitive ltLPrf q) in\n\tlet prf' = steps' a (S e) (b*b) e'(lteTransitive ltLPrf p) ltLPrf in\n\ttrans prf $ sym prf'\n    | (e', True) = let (first, second) = congPair e' True (divMod2 (S (S e))) (sym $ eq) in\n\tlet ltLPrf = plusLteInjLeft 1 $ replace {P=(\\v=>LTE (S v) (S (S e)))} first $ ssnDiv2LTssn e in\n\tlet prf = steps' a k (b*b) e' (lteTransitive ltLPrf p) (lteTransitive ltLPrf q) in\n\tlet prf' = steps' a (S e) (b*b) e'(lteTransitive ltLPrf p) ltLPrf in\n\tlet ret = trans prf $ sym prf' in\n\tcong ret\n\nprfEven : (arg, b, e, e' : Nat) -> (S (S e)) `LTE` arg ->  ((e', False)=divMod2 (S (S e))) -> powSqrAux (S e) (mult b b) e' = b*(b*(power b e))\nprfEven Z b e e' form eq impossible\nprfEven (S arg) b e e' (LTESucc form) eq = let (first, second) = congPair e' False (divMod2 (S (S e))) (sym $ eq) in\n\tlet str = plusLteInjLeft 1 $ replace {P=(\\v=>LTE (S v) (S (S e)))} first $ ssnDiv2LTssn e in\n\tlet prev = powEq' arg (S e) (b*b) e' str $ lteTransitive str form in\n\tlet lemm = replace {P=\\v=>(S (S e)=2*e'+if v then 1 else 0)} second $\n\t\treplace {P=\\v=>(S (S e)=2*v + if snd (divMod2 (S (S e))) then 1 else 0)} first \n\t\t$ divMod2Lemma (S (S e)) in \n\tlet pwrLemm = cong {f=power b} $ trans lemm $ plusZeroRightNeutral (e'+(e'+0)) in\n\trewrite pwrLemm in \n\trewrite sym $ powerPowerMultPower b 2 e' in \n\trewrite multOneRightNeutral b in \n\tprev\n\nprfOdd : (arg, b, e, e' : Nat) -> (S (S e)) `LTE` arg -> ((e', True)=divMod2 (S (S e))) -> mult b (powSqrAux (S e) (mult b b) e') = b*(b*(power b e))\nprfOdd Z b e e' form eq impossible\nprfOdd (S arg) b e e' (LTESucc form) eq = let (first, second) = congPair e' True (divMod2 (S (S e))) (sym $ eq) in\n\tlet str = plusLteInjLeft 1 $ replace {P=(\\v=>LTE (S v) (S (S e)))} first $ ssnDiv2LTssn e in\n\tlet prev = powEq' arg (S e) (b*b) e' str $ lteTransitive str form in\n\tlet lemm = replace {P=\\v=>(S (S e)=2*e'+if v then 1 else 0)} second $\n\t\treplace {P=\\v=>(S (S e)=2*v + if snd (divMod2 (S (S e))) then 1 else 0)} first \n\t\t$ divMod2Lemma (S (S e)) in \n\tlet pwrLemm = cong {f=power b} $ trans lemm $ plusCommutative (e'+(e'+0)) 1 in\n\trewrite pwrLemm in  \n\trewrite sym $ powerPowerMultPower b 2 e' in \n\trewrite multOneRightNeutral b in \n\tcong prev\n\npowEq' k Z b Z p q = Refl\npowEq' k Z b (S e') p q impossible\npowEq' k (S w') b Z p q = Refl\npowEq' Z (S w') b (S Z) p q impossible\npowEq' Z (S w') b (S (S e')) p q impossible\npowEq' (S k) (S w') b (S Z) p q = rewrite powEq' k w' (b*b) Z LTEZero LTEZero in Refl\n-- powEq' (S Z) (S w') b (S (S e)) p (LTESucc f) impossible\npowEq' k (S w') b (S (S e)) (LTESucc p) q with (divMod2 (S (S e))) proof eq\n    | (e', False) = let (first, second) = congPair e' False (divMod2 (S (S e))) (sym eq) in\n\tlet prf = prfEven k b e e' q eq in \n\tlet ltLPrf = plusLteInjLeft 1 $ replace {P=(\\v=>LTE (S v) (S (S e)))} first $ ssnDiv2LTssn e in\n\tlet ltLRes = lteTransitive ltLPrf p in\n\tlet lt1 = lteTransitive ltLPrf $ lteSuccLeft q in\n\tlet prf1 = sym $ steps' k (S e) (b*b) e' lt1 ltLPrf in\n\tlet prf2 = steps' k w' (b*b) e' lt1 ltLRes in\n\ttrans prf2 (trans prf1 prf)\n\t-- ?even\n    | (e', True) = let (first, second) = congPair e' True (divMod2 (S (S e))) (sym eq) in\n\tlet prf = prfOdd k b e e' q eq in\n\tlet ltLPrf = plusLteInjLeft 1 $ replace {P=(\\v=>LTE (S v) (S (S e)))} first $ ssnDiv2LTssn e in\n\tlet ltLRes = lteTransitive ltLPrf p in\n\tlet lt1 = lteTransitive ltLPrf $ lteSuccLeft q in\n\tlet prf1 = sym $ steps' k (S e) (b*b) e' lt1 ltLPrf in\n\tlet prf2 = steps' k w' (b*b) e' lt1 ltLRes in\n\tlet ret = cong {f=mult b} $ trans prf2 prf1 in \n\ttrans ret prf\n\npowEq b e = powEq' e e b e lteRefl lteRefl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111573,"user_id":null,"body":"module Pow\n\nimport Preloaded\n\n%access export\n%default total\n\ndivMod2Lemma : (n : Nat) -> n = 2 * fst (divMod2 n) + if snd (divMod2 n) then 1 else 0\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S k)) with (divMod2 k) proof eq\n    | (q, r) = rewrite sym $ plusSuccRightSucc q (q + 0) in\n               rewrite divMod2Lemma k in\n\t\t\t   rewrite (sym eq) in Refl\n\npairEq : {a, b : Type} -> {p, q : Pair a b} -> p = q -> (fst p = fst q, snd p = snd q)\npairEq eq = (cong eq, cong eq)\n\ndivMod2Lte : (n : Nat) -> LTE (fst (divMod2 n)) n\ndivMod2Lte Z = LTEZero\ndivMod2Lte (S Z) = LTEZero\ndivMod2Lte (S (S n)) with (divMod2 n) proof eq\n\t| (q, r) =\n\t\trewrite fst (pairEq eq) in\n\t\tLTESucc (lteSuccRight (divMod2Lte n))\n\t\t\ndivMod2LteSucc : (n : Nat) -> LTE (fst (divMod2 (S n))) n\ndivMod2LteSucc Z = LTEZero\ndivMod2LteSucc (S n) with (divMod2 n) proof eq\n\t| (q, r) =\n\t\trewrite fst (pairEq eq) in\n\t\tLTESucc (divMod2Lte n)\n\npowLemma : (b, e : Nat) -> power b e = if snd (divMod2 e) then b * power (b * b) (fst (divMod2 e)) else power (b * b) (fst (divMod2 e))\npowLemma b e with (divMod2 e) proof eq\n\t| (q, r) = \n\t\trewrite sym $ powerSuccSuccMult b in\n\t\trewrite powerPowerMultPower b 2 q in\n\t\tlet lemma : (e = 2 * q + if r then 1 else 0) =\n\t\t\t(rewrite fst (pairEq eq) in\n\t\t\trewrite snd (pairEq eq) in\n\t\t\tdivMod2Lemma e) in\n\t\tlet lemma' = cong {f=power b} lemma in\n\t\tcase r of\n\t\t\tFalse => rewrite sym (plusZeroRightNeutral (2*q)) in lemma'\n\t\t\tTrue =>\n\t\t\t\treplace {P=\\e' => power b e = power b e'}\n\t\t\t\t(plusCommutative (2*q) 1) lemma'\n\npowEq' : (k, b, e : Nat) -> LTE e k -> powSqrAux k b e = power b e\npowEq' Z     b Z LTEZero = Refl\npowEq' (S k) b Z LTEZero = Refl\npowEq' (S k) b (S e) (LTESucc ekLte) with (divMod2 (S e)) proof eq\n\t| (q, r) =\n\t\tlet qeLte : LTE q e = \n\t\t\trewrite fst (pairEq eq) in\n\t\t\tdivMod2LteSucc e in\n\t\tlet qkLte = lteTransitive qeLte ekLte in\n\t\tlet lemma : (power b (S e) = if r then b * power (b * b) q else power (b * b) q) =\n\t\t\trewrite fst (pairEq eq) in\n\t\t\trewrite snd (pairEq eq) in\n\t\t\tpowLemma b (S e) in\n\t\tcase r of\n\t\t\tFalse => rewrite lemma in powEq' k (b * b) q qkLte\n\t\t\tTrue => rewrite lemma in cong (powEq' k (b * b) q qkLte)\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\npowEq b e = powEq' e b e lteRefl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111574,"user_id":null,"body":"module Pow\n\nimport Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\n||| Divides a natural number by 2 and returns\n||| the quotient and the remainder as a boolean value:\n||| True = remainder is 1, False = remainder is 0.\ndivMod2 : Nat -> (Nat, Bool)\ndivMod2 Z = (Z, False)\ndivMod2 (S Z) = (Z, True)\ndivMod2 (S (S n)) = case divMod2 n of (q, r) => (S q, r)\n\n-- The first argument (k) helps Idris to prove\n-- that the function terminates.\npowSqrAux : Nat -> Nat -> Nat -> Nat\npowSqrAux Z _ _ = 1\npowSqrAux _ _ Z = 1\npowSqrAux (S k) b e =\n    case divMod2 e of\n        (e', False) => powSqrAux k (b * b) e'\n        (e', True) => b * powSqrAux k (b * b) e'\n\npowSqr : Nat -> Nat -> Nat\npowSqr b e = powSqrAux e b e\n-}\n\n%access export\n%default total\n\n-- The following lemma is useful\ndoubleLemma : (n : Nat) -> n + n = 2 * n\ndoubleLemma Z = Refl\ndoubleLemma (S k) = rewrite plusZeroRightNeutral k in Refl\n\nlteChain : (a, b, c: Nat) -> LTE a b -> LTE b c -> LTE a c\nlteChain Z b c p q = LTEZero\nlteChain (S k) (S j) (S i) (LTESucc x) (LTESucc y) = LTESucc $ lteChain k j i x y\n\nlteSucc : (a : Nat) -> LTE a (S a)\nlteSucc Z = LTEZero\nlteSucc (S k) = LTESucc $ lteSucc k\n\nlteSuccInjective : (a, b : Nat) -> LTE (S a) (S b) -> LTE a b\nlteSuccInjective Z Z (LTESucc LTEZero) = LTEZero\nlteSuccInjective Z (S k) (LTESucc x) = x\nlteSuccInjective (S _) Z (LTESucc LTEZero) impossible\nlteSuccInjective (S _) Z (LTESucc (LTESucc _)) impossible\nlteSuccInjective (S k) (S j) (LTESucc x) = x\n\nfstLemma : (a : _) -> (b : _) -> Basics.fst (a, b) = a\nfstLemma _ _ = Refl\n\nsndLemma : (a : _) -> (b : _) -> Basics.snd (a, b) = b\nsndLemma _ _ = Refl\n\nlteLeft : (a, b, c : Nat) -> a = b -> LTE a c -> LTE b c\nlteLeft n n c Refl x = x\n\nltLemma : (n : Nat) -> LTE (fst (divMod2 (S n))) n\nltLemma Z = LTEZero\nltLemma (S Z) = LTESucc LTEZero\nltLemma (S (S k)) with (divMod2 (S k)) proof eq\n  | (q, False) = LTESucc $ lteChain _ _ _ (lteLeft (fst (divMod2 (S k))) q k (trans (sym $ cong {f=fst} eq) $ fstLemma q False) $ ltLemma k) (lteSucc _)\n  | (q, True) = LTESucc $ lteLeft (fst $ divMod2 (S k)) q (S k) (trans (sym $ cong {f=fst} eq) $ fstLemma q True) $ lteChain (fst (divMod2 (S k))) k (S k) (ltLemma k) (lteSucc k)\n\ndivMod2Lemma : (n : Nat) -> n = 2 * fst (divMod2 n) + if snd (divMod2 n) then 1 else 0\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S k)) with (divMod2 k) proof eq\n    | (q, r) = rewrite plusZeroRightNeutral q in\n                       rewrite sym (plusSuccRightSucc q q) in\n                               rewrite doubleLemma q in\n                                       rewrite divMod2Lemma k in\n                                               rewrite sym eq in Refl\n\nplusEq : (a, b, c, d: Nat) -> a = b -> c = d -> a + c = b + d\nplusEq b b d d Refl Refl = Refl\n\nifFalse : (a: Bool) -> (b, c: Nat) -> a = False -> (if a then b else c) = c\nifFalse False _ c Refl = Refl\nifFalse True _ _ Refl impossible\n\nifTrue : (a: Bool) -> (b, c: Nat) -> a = True -> (if a then b else c) = b\nifTrue True b _ Refl = Refl\nifTrue False _ _ Refl impossible\n\npowerSq : (b, q: Nat) -> power b (q + q) = power (b * b) q\npowerSq b Z = Refl\npowerSq b (S k) = rewrite plusCommutative k (S k) in rewrite powerSq b k in rewrite multAssociative b b (power (b * b) k) in Refl\n\npowAuxEq : (a, b, e : Nat) -> LTE e a -> powSqrAux a b e = power b e\npowAuxEq Z b Z LTEZero = Refl\npowAuxEq (S _) b Z LTEZero = Refl\npowAuxEq (S a) b (S k) p with (divMod2 (S k)) proof eq\n    | (q, False) = trans (powAuxEq a (b * b) q qLTEa) (trans (sym $ powerSq b q) $ sym $ cong {f=power b} skEqPlusQQ) where\n      fstIsQ : fst (divMod2 (S k)) = q\n      fstIsQ = trans (cong {f=fst} $ sym eq) (fstLemma q False)\n      sndIsFalse : snd (divMod2 (S k)) = False\n      sndIsFalse = trans (cong {f=snd} $ sym eq) (sndLemma q False)\n      qLTEk : LTE q k\n      qLTEk = (lteLeft _ q k fstIsQ $ ltLemma k)\n      qLTEa : LTE q a\n      qLTEa = lteChain q k a qLTEk (lteSuccInjective k a p)\n      fstPlusFstEqQPlusQ : fst (divMod2 (S k)) + (fst (divMod2 (S k)) + 0) = q + q\n      fstPlusFstEqQPlusQ  = plusEq _ q _ q fstIsQ $ trans (plusEq _ q 0 0 fstIsQ Refl) (plusZeroRightNeutral q)\n      plusSnd : (a: Nat) -> (a + if snd (divMod2 (S k)) then 1 else 0) = a\n      plusSnd a = trans (plusEq a a _ 0 Refl (ifFalse _ 1 0 sndIsFalse)) (plusZeroRightNeutral a)\n      skEqPlusQQ : S k = plus q q\n      skEqPlusQQ = trans (trans (divMod2Lemma (S k)) (plusSnd _)) fstPlusFstEqQPlusQ\n    | (q, True) = trans h (sym $ cong {f=power b} (divMod2Lemma (S k))) where\n      fstIsQ : fst (divMod2 (S k)) = q\n      fstIsQ = trans (cong {f=fst} $ sym eq) (fstLemma q False)\n      qLTEk : LTE q k\n      qLTEk = (lteLeft _ q k fstIsQ $ ltLemma k)\n      sndIsTrue : snd (divMod2 (S k)) = True\n      sndIsTrue = trans (cong {f=snd} $ sym eq) (sndLemma q True)\n      fstPlusFstEqQPlusQ : fst (divMod2 (S k)) + (fst (divMod2 (S k)) + 0) = q + q\n      fstPlusFstEqQPlusQ  = plusEq _ q _ q fstIsQ $ trans (plusEq _ q 0 0 fstIsQ Refl) (plusZeroRightNeutral q)\n      plusSnd : (a, b: Nat) -> a = b -> (a + if snd (divMod2 (S k)) then 1 else 0) = S b\n      plusSnd a b p = trans (plusEq a b _ 1 p (ifTrue _ 1 0 sndIsTrue)) (plusCommutative b 1)\n      skEqPlusQQ1 : S k = S (q + q)\n      skEqPlusQQ1 = trans (divMod2Lemma (S k)) (plusSnd (fst (divMod2 (S k)) + (fst (divMod2 (S k)) + 0)) (q + q) fstPlusFstEqQPlusQ)\n\n      prev : powSqrAux a (b * b) q = power (b * b) q\n      prev = powAuxEq a (b * b) q (lteChain q k a qLTEk $ lteSuccInjective k a p)\n\n      h : mult b (powSqrAux a (mult b b) q) =\n          power b ((fst (divMod2 (S k)) + (fst (divMod2 (S k)) + 0)) + (ifThenElse (snd (divMod2 (S k))) (Delay 1) (Delay 0)))\n      h = trans (cong {f=mult b} $ trans prev $ sym $ powerSq b q) (sym $ cong {f=power b} $ plusSnd _ _ fstPlusFstEqQPlusQ)\n\nlteSame : (a : Nat) -> LTE a a\nlteSame Z = LTEZero\nlteSame (S k) = LTESucc (lteSame k)\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\npowEq b e = powAuxEq e b e (lteSame e)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111575,"user_id":168,"body":"module Pow\n\nimport Preloaded\n\n%access export\n%default total\n\ndivMod2Lemma : (n : Nat) -> n = 2 * fst (divMod2 n) + if snd (divMod2 n) then 1 else 0\ndivMod2Lemma Z = Refl\ndivMod2Lemma (S Z) = Refl\ndivMod2Lemma (S (S k)) with (divMod2 k) proof eq\n    | (q, r) =\n        rewrite divMod2Lemma k in \n        rewrite sym eq in \n        rewrite sym (plusSuccRightSucc q (q + 0)) in\n        Refl\n\nfstEq : {a : x} -> {b : y} -> {p : (x, y)} -> (a, b) = p -> a = fst p\nfstEq prf = rewrite sym prf in Refl\n\npowerRewrite : {e, e' : Nat} -> (b : Nat) -> S e = e' -> power b (S e) = power b e'\npowerRewrite _ eq = rewrite sym eq in Refl\n\npowerMultBase : (a : Nat) -> (b : Nat) -> (e : Nat) -> power (a * b) e = power a e * power b e\npowerMultBase _ _ Z = Refl\npowerMultBase a b (S k) = \n    rewrite powerMultBase a b k in\n    rewrite multAssociative (a * b) (power a k) (power b k) in\n    rewrite sym (multAssociative a b (power a k)) in\n    rewrite multCommutative b (power a k) in\n    rewrite multAssociative (a * power a k) b (power b k) in\n    rewrite multAssociative a (power a k) b in\n    Refl\n\ndivMod2LT : (n : Nat) -> fst (divMod2 (S n)) `LT` (S n)\ndivMod2LT Z = lteRefl\ndivMod2LT (S Z) = lteRefl\ndivMod2LT (S (S n)) with (divMod2 (S n)) proof eq\n    | (q, r) = \n        let h = lteSuccRight $ LTESucc (divMod2LT n) in\n        lemma h where lemma = rewrite sym eq in id\n\ndivMod2LT_lemma : {e : Nat} -> {r : Bool} -> (n : Nat) -> (e, r) = divMod2 (S n) -> e `LT` (S n)\ndivMod2LT_lemma n prf = rewrite fstEq prf in divMod2LT n\n\npowSqrLemma : (k : Nat) -> (b : Nat) -> (e : Nat) -> LTE e k -> powSqrAux k b e = power b e\npowSqrLemma Z _ Z _ = Refl\npowSqrLemma (S k) _ Z _ = Refl\npowSqrLemma (S k) b (S e) le_ek with (divMod2 (S e)) proof eq\n    | (e', False) = \n        let ih = powSqrLemma k (b * b) e' lte_lemma in\n        let se_eq = divMod2Lemma (S e) in\n        rewrite ih in\n        rewrite powerRewrite b se_eq in\n        rewrite sym eq in\n        rewrite plusZeroRightNeutral e' in\n        rewrite plusZeroRightNeutral (e' + e') in\n        rewrite powerMultBase b b e' in\n        rewrite multPowerPowerPlus b e' e' in\n        Refl\n        where lte_lemma = fromLteSucc $ lteTransitive (divMod2LT_lemma e eq) le_ek\n    | (e', True) = \n        let ih = powSqrLemma k (b * b) e' lte_lemma in\n        let se_eq = divMod2Lemma (S e) in\n        rewrite ih in\n        rewrite powerRewrite b se_eq in\n        rewrite sym eq in\n        rewrite plusZeroRightNeutral e' in\n        rewrite plusCommutative (e' + e') 1 in\n        rewrite powerMultBase b b e' in\n        rewrite multPowerPowerPlus b e' e' in\n        Refl\n        where lte_lemma = fromLteSucc $ lteTransitive (divMod2LT_lemma e eq) le_ek\n\npowEq : (b, e : Nat) -> powSqr b e = power b e\npowEq b e = powSqrLemma e b e lteRefl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8dda57b0a26000015f1a7a":[{"id":111576,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n =\n  rewrite plusZeroRightNeutral n in\n  rewrite multOneRightNeutral n in\n  rewrite multOneRightNeutral (n + 1) in\n  rewrite plusCommutative n 1 in\n  rewrite plusCommutative ((n * n) + (n + n)) 1 in\n  rewrite multRightSuccPlus n n in\n  rewrite plusAssociative n n (n * n) in\n  rewrite plusCommutative (n + n) (n * n) in\n          Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111577,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\ninfixl 1 =>>\n(=>>) : (x = y) -> (y = z) -> (x = z)\n(=>>) = trans\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n =\n  powerSuccSuccMult (n+1)                                              -- (n + 1) ^ 2 = (n + 1) * (n + 1)\n  =>> (multDistributesOverPlusRight (n+1) n 1)                         -- (n + 1) * (n + 1) = (n + 1) * n + (n + 1) * 1\n  =>> (cong {f=\\rhs=>(n+1)*n+rhs} $ multOneRightNeutral (n+1))         -- (n + 1) * n + (n + 1) * 1 = (n + 1) * n + (n + 1)\n  =>> (cong {f=\\lhs=>lhs+(n+1)} $ multDistributesOverPlusLeft n 1 n)   -- (n + 1) * n + (n + 1) = (n * n + 1 * n) + (n + 1)\n  =>> (cong {f=\\x=>(n*n+x)+(n+1)} $ multOneLeftNeutral n)              -- (n * n + 1 * n) + (n + 1) = (n * n + n) + (n + 1)\n  =>> (sym $ plusAssociative (n * n) n (n + 1))                        -- (n * n + n) + (n + 1) = n * n + (n + (n + 1))\n  =>> (cong {f=\\rhs=>n*n+rhs} $ plusAssociative n n 1)                 -- n * n + (n + (n + 1)) = n * n + ((n + n) + 1)\n  =>> (cong {f=\\x=>n*n+((n+x)+1)} $ sym $ plusZeroRightNeutral n)      -- n * n + (n + (n + 1)) = n * n + (2 * n + 1)\n  =>> (cong {f=\\lhs=>lhs+(2*n+1)} $ sym $ powerSuccSuccMult n)         -- n * n + (2 * n + 1) = n ^ 2 + (2 * n + 1)\n  =>> (plusAssociative (n^2) (2*n) 1)                                  -- n ^ 2 + (2 * n + 1) = (n ^ 2) + 2 * n + 1","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111578,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n = \n  rewrite multOneRightNeutral (n + 1) in\n  rewrite multOneRightNeutral n in\n  rewrite plusZeroRightNeutral n in\n  rewrite multDistributesOverPlusRight (n + 1) n 1 in\n  rewrite multOneRightNeutral (n + 1) in\n  rewrite multDistributesOverPlusLeft n 1 n in\n  rewrite plusZeroRightNeutral n in\n  rewrite plusAssociative ((n * n) + n) n 1 in\n  rewrite sym $ plusAssociative (n * n) n n in\n  Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111579,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n =\n    rewrite multOneRightNeutral n in\n    rewrite plusZeroRightNeutral n in\n    rewrite sym (plusSuccRightSucc n 0) in\n    rewrite plusZeroRightNeutral n in\n    rewrite multOneRightNeutral n in\n    rewrite plusCommutative (plus (mult n n) (plus n n)) 1 in\n    rewrite plusCommutative (mult n n) (plus n n) in\n    rewrite sym (plusAssociative n n (mult n n)) in\n    rewrite multRightSuccPlus n n in\n        cong {f = S} $\n        cong {f = plus n} $\n            Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111580,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand  n =\n  rewrite the (n ^ 2 = n * n) (rewrite sym $ multOneRightNeutral n in Refl) in\n  rewrite the (2 * n = n + n) (rewrite plusZeroRightNeutral n in Refl) in\n  rewrite plusAssociative (n * n) n n in\n  rewrite the (n * n + n = n * (n + 1)) (\n    rewrite the\n      (n * n + n = n * n + (n * 1))\n      (plusConstantLeft _ _ (n * n) (sym $ multOneRightNeutral n))\n    in\n    sym $ multDistributesOverPlusRight n n 1\n  )\n  in\n  rewrite the\n    ((n * (n + 1)) + n + 1 = (n * (n + 1)) + (n + 1))\n    (sym $ plusAssociative (n * (n + 1)) n 1)\n  in\n  rewrite the (n * (n + 1) + (n + 1) = (n + 1) * (n + 1)) (\n    rewrite plusConstantLeft (n + 1) (1 * (n + 1)) (n * (n + 1)) $ sym $ multOneLeftNeutral (n + 1)\n    in (sym $ multDistributesOverPlusLeft n 1 (n + 1)))\n  in\n  rewrite the ((n + 1) * (n + 1) = (n + 1) ^ 2) (rewrite sym $ multOneRightNeutral (n + 1) in Refl) in\n  Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111581,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n = rewrite multOneRightNeutral (plus n 1) in\n           rewrite multOneRightNeutral n in\n           rewrite plusZeroRightNeutral n in \n           rewrite multDistributesOverPlusRight (plus n 1) n 1 in\n           rewrite multOneRightNeutral (plus n 1) in \n           rewrite multDistributesOverPlusLeft n 1 n in\n           rewrite plusZeroRightNeutral n in \n           rewrite plusAssociative (plus (mult n n) n) n 1 in\n           rewrite sym $ plusAssociative (mult n n) n n in \n                   Refl\n\n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111582,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\neqTransitive : a = b -> b = c -> a = c\neqTransitive p1 p2 = rewrite sym p2 in p1\n\nexpand_lema1 : (n:Nat) -> n ^ 2 = n * n\nexpand_lema1 n = let p = sym $ multOneRightNeutral n\n                 in rewrite p in Refl\n\nexpand_lema2 : (n:Nat) -> (n + 1) * n = n ^ 2 + n\nexpand_lema2 n = let p1 = multDistributesOverPlusLeft n 1 n\n                     p2 = expand_lema1 n\n                     p3 = plusAssociative (n * n) n 0\n                     p4 = plusZeroRightNeutral (n * n + n)\n                     p5 = eqTransitive p3 p4\n                     p6 = eqTransitive p1 p5\n                 in rewrite p2 in p6\n\nexpand_lema3 : (n:Nat) -> (n + 1) * n + (n + 1) * 1 = (n + 1) * n + (n + 1)\nexpand_lema3 n = let p = sym $ multOneRightNeutral (n + 1)\n                 in rewrite p in Refl\n\nexpand_lema4 : (n:Nat) -> (n + 1) * (n + 1) = n ^ 2 + n + (n + 1)\nexpand_lema4 n = let p1 = multDistributesOverPlusRight (n + 1) n 1\n                     p2 = expand_lema3 n\n                     p3 = eqTransitive p1 p2\n                     p4 = sym $ expand_lema2 n\n                  in rewrite p4 in p3\n\nexpand_lema5 : (n:Nat) -> n + n = 2 * n\nexpand_lema5 n = let p1 = sym $ plusZeroRightNeutral (n + n)\n                     p2 = sym $ plusAssociative n n 0\n                 in eqTransitive p1 p2\n\nexpand_lema6 : (n:Nat) -> n + (n + 1) = 2 * n + 1\nexpand_lema6 n = let p1 = plusAssociative n n 1\n                     p2 = sym $ expand_lema5 n\n                 in rewrite p2 in p1\n\nexpand_lema7 : (m:Nat) -> (n:Nat) -> m + (n + (n + 1)) = m + (2 * n + 1)\nexpand_lema7 m n = let p = expand_lema6 n\n                    in rewrite p in Refl\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n = let p1 = expand_lema1 (n + 1)\n               p2 = expand_lema4 n\n               p3 = eqTransitive p1 p2\n               p4 = sym $ plusAssociative (n ^ 2) n (n + 1)\n               p5 = eqTransitive p3 p4\n               p6 = expand_lema7 (n ^ 2) n\n               p7 = eqTransitive p5 p6\n               p8 = plusAssociative (n ^ 2) (2 * n) 1\n           in eqTransitive p7 p8\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111583,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\naddAssocS: (v, n : Nat) -> (v + n) + (n+1) = (v + (n+n)) + 1\naddAssocS v n = rewrite plusCommutative (v+(n+n)) 1 in\n                 rewrite plusCommutative n 1 in\n                  rewrite plusSuccRightSucc v (n+n) in\n                   rewrite sym $ plusSuccRightSucc (v+n) n in\n                    rewrite sym $ plusSuccRightSucc v (n+n) in\n                     rewrite plusAssociative v n n in\n                      Refl \n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand n = rewrite multOneRightNeutral (plus n 1) in \n            rewrite plusZeroRightNeutral n in \n             rewrite multDistributesOverPlusLeft n 1 (n+1) in \n              rewrite plusZeroRightNeutral (n+1) in \n               rewrite multDistributesOverPlusRight n n 1 in\n                rewrite multOneRightNeutral n in \n                 addAssocS (n*n) n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111584,"user_id":null,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\nexpand Z = Refl\nexpand (S n) =\n  rewrite multCommutative n 1 in\n  rewrite plusCommutative n 0 in\n  rewrite multCommutative (plus n 1) 1 in\n  rewrite plusCommutative (plus n 1) 0 in\n  rewrite plusCommutative n 1 in\n  rewrite plusCommutative n (S n) in\n  rewrite multCommutative n (S n) in\n  rewrite plusCommutative (plus n (plus n (mult n n))) (S (S (plus n n))) in\n  rewrite plusCommutative n (S (S (plus n (mult n (S (S n)))))) in\n  rewrite plusCommutative (plus (plus n n) (plus n (plus n (mult n n)))) 1 in\n  rewrite multCommutative n (S (S n)) in\n  rewrite plusCommutative (plus n (plus n (plus n (mult n n)))) n in\n  rewrite sym $ plusAssociative n n (plus n (plus n (mult n n))) in\n  Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111585,"user_id":443,"body":"module PerfectSquare\n\n%access export\n%default total\n\ninfixl 10 ^\n\npublic export\n(^) : Nat -> Nat -> Nat\n(^) = power\n\nexpand : (n : Nat) -> (n + 1) ^ 2 = n ^ 2 + 2 * n + 1\n\nexpand Z = Refl\nexpand (S k) =\n    rewrite sym (multCommutative 1 (plus k 1)) in\n    rewrite sym (plusCommutative 0 (plus k 1)) in\n    rewrite (multDistributesOverPlusLeft k 1 (S (plus k 1))) in\n    rewrite sym (plusCommutative (plus (mult k (S (plus k 1))) (S (plus (plus k 1) 0))) (plus k 1)) in\n    rewrite (plusAssociative (plus (mult k (S (plus k 1))) (S (plus (plus k 1) 0))) k 1) in\n    rewrite sym (plusAssociative (mult k (S (plus k 1))) (S (plus (plus k 1) 0)) k) in\n    rewrite sym (plusAssociative k 1 0) in\n    rewrite sym (plusAssociative k 1 k) in\n    rewrite (multRightSuccPlus k (plus k 1)) in\n    rewrite sym (plusCommutative 1 k) in\n    rewrite sym (multOneRightNeutral k) in\n    rewrite sym (plusZeroRightNeutral (mult k 1)) in\n    Refl","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c9c5b04cc9b0830cd270cb6":[{"id":111586,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n-- Useful lemmas from contrib\/Data\/Nat.idr\n\n%access export\n%default total\n\nltePlus : LTE m1 n1 -> LTE m2 n2 -> LTE (m1 + m2) (n1 + n2)\nltePlus {n1=Z} LTEZero lte = lte\nltePlus {n1=S k} LTEZero lte = lteSuccRight $ ltePlus {n1=k} LTEZero lte\nltePlus (LTESucc lte1) lte2 = LTESucc $ ltePlus lte1 lte2\n\nlteMult : LTE m1 n1 -> LTE m2 n2 -> LTE (m1 * m2) (n1 * n2)\nlteMult LTEZero _ = LTEZero\nlteMult {m1=S k} (LTESucc _) LTEZero = rewrite multZeroRightZero k in LTEZero\nlteMult (LTESucc lte1) (LTESucc lte2) = LTESucc $ ltePlus lte2 $ lteMult lte1 $ LTESucc lte2\n\nlteCongMult : (k : Nat) -> LTE m n -> LTE (m * k) (n * k)\nlteCongMult k lte = lteMult lte lteRefl\n\nlteCongMultLeft : (k : Nat) -> LTE m n -> LTE (k * m) (k * n)\nlteCongMultLeft k lte = lteMult lteRefl lte\n-}\n\n%access export\n%default total\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\nnotSuccLteZero : Not (S n `LTE` Z)\nnotSuccLteZero LTEZero impossible\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\nlteStepK : (k: Nat) -> m `LTE` n -> m `LTE` k + n\nlteStepK Z x = x\nlteStepK (S k) x = lteSuccRight $ lteStepK k x\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z x = x\nplusLteInjLeft (S k) x = let p = fromLteSucc x\n                          in plusLteInjLeft k p\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\nplusLteInjRightL : (a: Nat) -> a + 0 `LTE` a\nplusLteInjRightL Z = LTEZero\nplusLteInjRightL (S k) = LTESucc (plusLteInjRightL k)\n\n\nlteAddZero : (a: Nat) -> a + 0 `LTE` a\nlteAddZero Z = LTEZero\nlteAddZero (S k) = LTESucc (lteAddZero k)\n\n-- a * 0 <= 0\nmultZeroLteZero : (a:Nat) -> a * 0 `LTE` 0\nmultZeroLteZero Z = LTEZero\nmultZeroLteZero (S k) = multZeroLteZero k\n\nkatl2 : (1 + a + b) `LTE` a + (1 + b)\nkatl2 {a = Z} {b = b} = lteRefl { n = 1 + b }\nkatl2 {a = (S k)} {b = b} = LTESucc $ katl2 {a = k} { b = b}\n\nkatl3 : a + (1 + b) `LTE` (1 + a + b)\nkatl3 {a = Z} {b = b} = lteRefl { n = 1 + b }\nkatl3 {a = (S k)} {b = b} = LTESucc $ katl3 {a = k} { b = b}\n\n-- a + (b + c) <= b + (a + c)\nkatl6 : a + (b + c) `LTE` b + (a + c)\nkatl6 {a = Z} {b = b} {c = c} = lteRefl {n = b + c}\nkatl6 {a = (S k)} {b = b} {c = c} =\n  let p = LTESucc $ katl6 {a = k} {b = b} {c = c}\n      p1 = katl2 {a = b} {b = k + c}\n  in lteTransitive p p1\n\n-- a <= b => c + a <= c + b\nkatl5 : a `LTE` b -> c + a `LTE` c + b\nkatl5 {c = Z} x = x\nkatl5 {c = (S k)} {a = a} {b = b} x = LTESucc $ katl5 {c = k} {a = a} {b = b} x\n\n-- a + a * b <= a * (1 + b)\nkatl4 : a + a * b `LTE` a * (1 + b)\nkatl4 {a = Z } = LTEZero\nkatl4 {a = (S k) } {b = b} =\n  let p = katl4 {a = k} {b = b}\n      p1 = katl5 { c = b } p\n      p2 = katl6 {a = k} {b = b} {c = k * b}\n  in  LTESucc $ lteTransitive p2 p1\n\n-- a * (1 + b) <= a + a * b\nkatl7 : a * (1 + b) `LTE` a + a * b\nkatl7 {a = Z} = LTEZero\nkatl7 {a = (S k)} {b = b} =\n  let p = katl7 {a = k} {b = b}\n      p1 = katl5 {c = b} p\n      p2 = katl6 {a = b} {b = k} {c = k * b}\n  in  LTESucc $ lteTransitive p1 p2\n\n\nkatl : (1 + 1 + a + b) `LTE` (1 + a + c) -> 1 + 1 + b `LTE` 1 + c\nkatl {a = Z} x = x\nkatl {a = (S k)} {b = b} {c = c} x =\n  let p = fromLteSucc $ fromLteSucc x\n      p1 = katl3 { a = k } {b = b}\n      p2 = lteTransitive p1 p\n      p3 = plusLteInjLeft {b = 1 + b} {c = c} k p2\n  in (LTESucc p3)\n\nkata4: (a: Nat) -> (b: Nat) -> (c: Nat) -> a * b `LT` a * c -> b `LT` c\nkata4 Z _ _ _ impossible\nkata4 (S Z) b c x =\n    let p = LTESucc $ lteAddRight {m = 0} b\n    in  lteTransitive (lteTransitive p x) (lteAddZero c)\nkata4 (S k) b Z x =\n  let p = LTESucc $ lteAddRight {m = k * b} b\n  in lteTransitive (lteTransitive p x) (multZeroLteZero k)\nkata4 (S k) Z (S j) _ =\n  let p = LTESucc $ LTEZero {right = k * 0}\n      p1 = LTESucc $  lteTransitive (multZeroLteZero k) (LTEZero { right = j})\n  in lteTransitive p p1\nkata4 (S a) (S b) (S c) x =\n  let p = LTESucc $  katl4 {a = 1 + a} {b = b}\n      p1 = lteTransitive p x\n      p2 = katl7 {a = 1 + a} {b = c}\n      p3 = lteTransitive p1 p2\n      p4 = fromLteSucc $ katl {a = a} {b = b + a * b} {c = c + a * c} p3\n  in  LTESucc $ kata4 (1 + a) b c p4\n\nmultLtInjLeft : a * b `LT` a * c -> b `LT` c\nmultLtInjLeft {a = a} {b = b} {c = c} = kata4 a b c\n\n-- Task 5. Prove this.\n\n\n-- n = m => n <= m\neqLte : n = m -> n `LTE` m\neqLte {n = Z} prf = LTEZero\neqLte {n = (S k)} {m = Z} Refl impossible\neqLte {n=(S k)} {m = (S i)} prf =\n  let p = succInjective k i prf\n  in LTESucc $ eqLte p\n  \n-- a * (1 + b) <= a + a * b\nkata5l1: a * (1 + b) `LTE` a + a * b\nkata5l1 {a = a} {b = b} =\n  let p = eqLte $ multDistributesOverPlusRight a 1 b\n      p1 = eqLte $  plusConstantRight (a * 1) a (a * b) (multOneRightNeutral a)\n  in  lteTransitive p p1\n\n-- c + c * k <= c * (1 + k)\nkata5l2: (c:Nat) -> (k:Nat) -> c + c * k `LTE` c * (1 + k)\nkata5l2 c k =\n  let p = eqLte $ sym $ multDistributesOverPlusRight c 1 k\n      p1 = eqLte $ sym $ plusConstantRight (c * 1) c (c * k) (multOneRightNeutral c)\n  in lteTransitive p1 p\n\nkata5l3: a `LTE` b -> a + c `LTE` b + c\nkata5l3 {c = Z} {a = a} {b = b} x =\n  let p = lteAddZero a\n      p1 = lteAddRight {m = 0} b\n      p2 = lteTransitive p x\n  in lteTransitive p2 p1\nkata5l3 {c = (S k)} {a = a} {b = b} x =\n  let p = LTESucc $ kata5l3 {c = k} {a = a} {b = b} x\n      p1 = eqLte $ sym $ plusSuccRightSucc a k\n      p2 = eqLte $ plusSuccRightSucc b k\n      p3 = lteTransitive p1 p\n      p4 = lteTransitive p3 p2\n  in p4\n\n\n-- c <= a => c * d <= a * d\nkata5l: c `LTE` a -> c * d `LTE` a * d\nkata5l {a = a} {c = c} {d = Z} x =\n  let p = eqLte $ multZeroRightZero c\n      p1 = LTEZero {right = a * 0}\n  in lteTransitive p p1\nkata5l {d = (S k)} {a = a} {c = c} x =\n  let p = kata5l {d = k} {a = a} {c = c} x\n      p1 = katl5 {c = c} p\n      p3 = kata5l1 {a = c} {b = k}\n      p4 = lteTransitive p3 p1\n      p5 = kata5l3 {c = a * k } x\n      p6 = lteTransitive p1 p5\n      p7 = lteTransitive p3 p6\n      p8 = kata5l2 a k\n  in lteTransitive p7 p8\n\nmultLtCross : a * b `LT` c * d -> c `LTE` a -> b `LT` d\nmultLtCross {a = a} {b = b} {c = c} {d = d} x y =\n  let p = kata5l {d = d} y\n      p1 = lteTransitive x p\n  in  multLtInjLeft {a = a} {b = b} {c = d} p1","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111587,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n-- Useful lemmas from contrib\/Data\/Nat.idr\n\n%access export\n%default total\n\nltePlus : LTE m1 n1 -> LTE m2 n2 -> LTE (m1 + m2) (n1 + n2)\nltePlus {n1=Z} LTEZero lte = lte\nltePlus {n1=S k} LTEZero lte = lteSuccRight $ ltePlus {n1=k} LTEZero lte\nltePlus (LTESucc lte1) lte2 = LTESucc $ ltePlus lte1 lte2\n\nlteMult : LTE m1 n1 -> LTE m2 n2 -> LTE (m1 * m2) (n1 * n2)\nlteMult LTEZero _ = LTEZero\nlteMult {m1=S k} (LTESucc _) LTEZero = rewrite multZeroRightZero k in LTEZero\nlteMult (LTESucc lte1) (LTESucc lte2) = LTESucc $ ltePlus lte2 $ lteMult lte1 $ LTESucc lte2\n\nlteCongMult : (k : Nat) -> LTE m n -> LTE (m * k) (n * k)\nlteCongMult k lte = lteMult lte lteRefl\n\nlteCongMultLeft : (k : Nat) -> LTE m n -> LTE (k * m) (k * n)\nlteCongMultLeft k lte = lteMult lteRefl lte\n-}\n\n%access export\n%default total\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\nnotSuccLteZero : Not (S n `LTE` Z)\nnotSuccLteZero LTEZero impossible\nnotSuccLteZero (LTESucc _) impossible\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\nlteStepK : (k : Nat) -> m `LTE` n -> m `LTE` k + n\nlteStepK k LTEZero = LTEZero\nlteStepK {m = S m} {n = S n} k (LTESucc x) = rewrite sym $ plusSuccRightSucc k n in LTESucc $ lteStepK k x\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n\nplusLteLeft : (a : Nat) -> b `LTE` c -> a + b `LTE` a + c\nplusLteLeft Z p = p\nplusLteLeft (S a) p = LTESucc $ plusLteLeft a p\n\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z p = p\nplusLteInjLeft (S a) (LTESucc x) = plusLteInjLeft a x\n\nplusLtInjLeft : (a:Nat) -> a + b `LT` a + c -> b `LT` c\nplusLtInjLeft Z p = p\nplusLtInjLeft (S k) (LTESucc p) = plusLtInjLeft k p\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n\nmultLtInjRight : b * a `LT` c * a -> b `LT` c\nmultLtInjRight {a = a} {b = Z} {c = Z} p = p\nmultLtInjRight {a = a} {b = Z} {c = (S k)} p = LTESucc LTEZero\nmultLtInjRight {a = a} {b = (S k)} {c = Z} p = void $ notSuccLteZero p\nmultLtInjRight {a = a} {b = (S b)} {c = (S c)} p = LTESucc (multLtInjRight (plusLtInjLeft a p))\n\nmultLtInjLeft : a * b `LT` a * c -> b `LT` c\nmultLtInjLeft {a} {b} {c} p =\n    let p1 = replace {P = \\xxx => xxx `LT` a * c} (multCommutative a b) p\n        p2 = replace {P = \\xxx => b * a `LT` xxx} (multCommutative a c) p1\n    in multLtInjRight p2\n\nmultLteRight : b `LTE` c -> b * a `LTE` c * a\nmultLteRight {a = a} {b = Z} {c = c} p = LTEZero\nmultLteRight {a = a} {b = (S k)} {c = Z} p = void $ notSuccLteZero p\nmultLteRight {a = a} {b = (S b)} {c = (S c)} (LTESucc p) = plusLteLeft a (multLteRight p)\n\n-- Task 5. Prove this.\n\nmultLtCross : a * b `LT` c * d -> c `LTE` a -> b `LT` d\nmultLtCross {a} {b} {c} {d} p1 p2 = multLtInjLeft (LTESucc (multLteRight p2) `lteTransitive` p1)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111588,"user_id":null,"body":"module Solution\n\nimport Preloaded\n%access export\n%default total\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\nnotSuccLteZero : Not (S n `LTE` Z)\nnotSuccLteZero LTEZero impossible\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\nlteStepK : (k : Nat) -> m `LTE` n -> m `LTE` k + n\nlteStepK k = ltePlus (LTEZero {right=k})\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z p = p\nplusLteInjLeft (S k) (LTESucc p) = plusLteInjLeft k p\n\n-- a DRY-extracted rewrite combination\nrewriteMultLTMult': (a, b : Nat) -> LTE (S (mult a b)) (mult a b) -> LTE (a*b+1) (a*b+0)\nrewriteMultLTMult' a b p = rewrite plusZeroRightNeutral (a*b) in rewrite plusCommutative (a*b) 1 in p\n\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\nmultLtInjLeft : a * b `LT` a * c -> b `LT` c\nmultLtInjLeft {a=Z} p = absurd $ notSuccLteZero p \nmultLtInjLeft {a=S k} p = notLTImpliesGTE $ absurdum' p where\n  absurdum': {a,b,c:Nat} -> a * b `LT` a * c -> LTE (S c) (S b) -> Void\n  absurdum' {a}{b} p p' = let f = lteCongMultLeft a (plusLteInjLeft 1 p') in \n    let ret = rewriteMultLTMult' a b $ lteTransitive p f in \n    let arg = plusLteInjLeft {b=1} {c=0} (a*b) ret in \n    notSuccLteZero arg\n\n-- Task 5. Prove this.\nmultLtCross : a * b `LT` c * d -> c `LTE` a -> b `LT` d\nmultLtCross {a}{b}{c}{d} l g = notLTImpliesGTE $ absurdum' where\n  absurdum' : LTE (S d) (S b) -> Void\n  absurdum' p = let q = lteMult g (plusLteInjLeft 1 p) in\n\tlet v = rewriteMultLTMult' a b $ lteTransitive l q in\n\tlet r = plusLteInjLeft {b=1} {c=0} (a*b) v in \n\tnotSuccLteZero r","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111589,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n-- Useful lemmas from contrib\/Data\/Nat.idr\n\n%access export\n%default total\n\nltePlus : LTE m1 n1 -> LTE m2 n2 -> LTE (m1 + m2) (n1 + n2)\nltePlus {n1=Z} LTEZero lte = lte\nltePlus {n1=S k} LTEZero lte = lteSuccRight $ ltePlus {n1=k} LTEZero lte\nltePlus (LTESucc lte1) lte2 = LTESucc $ ltePlus lte1 lte2\n\nlteMult : LTE m1 n1 -> LTE m2 n2 -> LTE (m1 * m2) (n1 * n2)\nlteMult LTEZero _ = LTEZero\nlteMult {m1=S k} (LTESucc _) LTEZero = rewrite multZeroRightZero k in LTEZero\nlteMult (LTESucc lte1) (LTESucc lte2) = LTESucc $ ltePlus lte2 $ lteMult lte1 $ LTESucc lte2\n\nlteCongMult : (k : Nat) -> LTE m n -> LTE (m * k) (n * k)\nlteCongMult k lte = lteMult lte lteRefl\n\nlteCongMultLeft : (k : Nat) -> LTE m n -> LTE (k * m) (k * n)\nlteCongMultLeft k lte = lteMult lteRefl lte\n-}\n\n%access export\n%default total\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\nnotSuccLteZero : Not (S n `LTE` Z)\nnotSuccLteZero LTEZero impossible\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\nlteStepK : (k : Nat) -> m `LTE` n -> m `LTE` k + n\nlteStepK k = ltePlus (LTEZero {right=k})\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z p = p\nplusLteInjLeft (S k) (LTESucc p) = plusLteInjLeft k p\n\nrewriteMultLTMult': (a, b : Nat) -> LTE (S (mult a b)) (mult a b) -> LTE (a*b+1) (a*b+0)\nrewriteMultLTMult' a b p = rewrite plusZeroRightNeutral (a*b) in rewrite plusCommutative (a*b) 1 in p\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\nmultLtInjLeft : a * b `LT` a * c -> b `LT` c\nmultLtInjLeft {a=Z} p = absurd $ notSuccLteZero p \nmultLtInjLeft {a=S k} p = notLTImpliesGTE $ absurdum' p where\n  absurdum': {a,b,c:Nat} -> a * b `LT` a * c -> LTE (S c) (S b) -> Void\n  absurdum' {a}{b} p p' = let f = lteCongMultLeft a (plusLteInjLeft 1 p') in \n    let ret = rewriteMultLTMult' a b $ lteTransitive p f in \n    let arg = plusLteInjLeft {b=1} {c=0} (a*b) ret in \n    notSuccLteZero arg\n\n-- Task 5. Prove this.\nmultLtCross : a * b `LT` c * d -> c `LTE` a -> b `LT` d\nmultLtCross {a}{b}{c}{d} l g = notLTImpliesGTE $ absurdum' where\n  absurdum' : LTE (S d) (S b) -> Void\n  absurdum' p = let q = lteMult g (plusLteInjLeft 1 p) in\n\tlet v = rewriteMultLTMult' a b $ lteTransitive l q in\n\tlet r = plusLteInjLeft {b=1} {c=0} (a*b) v in \n\tnotSuccLteZero r","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111590,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n%access export\n%default total\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\nnotSuccLteZero : Not (S n `LTE` Z)\nnotSuccLteZero LTEZero impossible\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\nlteStepK : (k : Nat) -> m `LTE` n -> m `LTE` k + n\nlteStepK _ = ltePlus LTEZero\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z     abc         = abc\nplusLteInjLeft (S k) (LTESucc x) = plusLteInjLeft k x\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n\nsuccGoesOut : (x, y, a : Nat) -> x + a * (S y) = a + (x + a * y) \nsuccGoesOut x y a = rewrite multRightSuccPlus a y in\n                    rewrite plusCommutative x $ a + (a*y) in\n                    rewrite sym $ plusAssociative a (a*y) x in\n                    rewrite plusCommutative (a*y) x in\n                    Refl\n\nmultLtInjLeft : a * b `LT` a * c -> b `LT` c\nmultLtInjLeft {a=Z}   {b}     {c}     = \\LTEZero impossible\nmultLtInjLeft {a=S a} {b=Z}   {c=Z}   = rewrite multZeroRightZero a in id\nmultLtInjLeft {a=S a} {b=Z}   {c=S c} = \\_ => LTESucc LTEZero\nmultLtInjLeft {a=S a} {b=S b} {c=Z}   = rewrite multZeroRightZero a in \\LTEZero impossible\nmultLtInjLeft {a=S a} {b=S b} {c=S c} = rewrite succGoesOut b b a in\n                                        rewrite succGoesOut c c a in\n                                        rewrite plusSuccRightSucc a $ b + a*b in\n                                        \\(LTESucc lt) => LTESucc . multLtInjLeft {a=S a} $ plusLteInjLeft a lt\n\n-- Task 5. Prove this.\n\nlteDelta : x `LTE` y -> (d ** x + d = y)\nlteDelta {y} LTEZero = (y ** Refl)\nlteDelta {x=S x} {y=S y} (LTESucc lte) = (_ ** cong {f=S} $ snd $ lteDelta lte)\n\nlteCutLeft : c + a `LTE` b -> a `LTE` b\nlteCutLeft {c=Z}   = id\nlteCutLeft {c=S k} = lteCutLeft . lteSuccLeft\n\nmultLtCross'delta : (delta : Nat ** c + delta = a) -> a * b `LT` c * d -> b `LT` d\nmultLtCross'delta (delta ** prf) {b} {c} =\n  rewrite sym prf in\n  rewrite plusCommutative c delta in\n  rewrite multDistributesOverPlusLeft delta c b in\n  rewrite plusSuccRightSucc (delta * b) (c * b) in\n  multLtInjLeft . lteCutLeft\n\nmultLtCross : a * b `LT` c * d -> c `LTE` a -> b `LT` d\nmultLtCross {a} {c} abcd ca = let (delta ** prf) = lteDelta ca in\n                              multLtCross'delta (lteDelta ca) abcd","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111591,"user_id":168,"body":"module Solution\n\nimport Preloaded\n\n%access export\n%default total\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\nnotSuccLteZero : Not (S n `LTE` Z)\nnotSuccLteZero _ impossible\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\nlteStepK : (k : Nat) -> m `LTE` n -> m `LTE` k + n\nlteStepK Z le = le\nlteStepK (S k) le = lteSuccRight (lteStepK k le)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n\nplusLteInjLeft : (a : Nat) -> a + b `LTE` a + c -> b `LTE` c\nplusLteInjLeft Z le = le\nplusLteInjLeft (S a) (LTESucc le) = plusLteInjLeft a le\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n\nlteImpliesNotGT : a `LTE` b -> Not (a `GT` b)\nlteImpliesNotGT (LTESucc le) (LTESucc le2) = lteImpliesNotGT le le2\n\nmultLtInjLeft : a * b `LT` a * c -> b `LT` c\nmultLtInjLeft {a} {b} {c} le with (isLTE (S b) c)\n  | Yes bc = bc\n  | No nbc = absurd (lteImpliesNotGT (lteCongMultLeft a (notLTImpliesGTE nbc)) le)\n\n-- Task 5. Prove this.\n\nmultLtCross : a * b `LT` c * d -> c `LTE` a -> b `LT` d\nmultLtCross {a} {b} {c} {d} lt le with (isLTE (S b) d)\n  | Yes bd = bd\n  | No nbd = absurd (lteImpliesNotGT (lteMult le (notLTImpliesGTE nbd)) lt)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5cb9dc6f98b230001cbe2cea":[{"id":111592,"user_id":null,"body":"module Solution\n\nimport Decidable.Equality\n\n%access export\n%default total\n\nnotTrueIsFalse : Not (x = True) -> x = False\nnotTrueIsFalse {x=False} _ = Refl\nnotTrueIsFalse {x=True}  f = absurd $ f Refl\n    \nrandom_fact_about_filtering : \n    (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n    length (filter (\\x => f x || g x) l) `LTE`\n        length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g =\n    case decEq (f x) True of\n        Yes prfFX =>\n            case decEq (g x) True of\n                Yes prfGX =>\n                    rewrite prfFX in\n                    rewrite prfGX in\n                    rewrite\n                        sym\n                            (plusSuccRightSucc\n                                (length (filter f xs))\n                                (length (filter g xs))\n                            )\n                        in\n                    LTESucc $\n                    lteSuccRight $\n                        random_fact_about_filtering xs f g\n                No contraGX =>\n                    rewrite prfFX in\n                    rewrite notTrueIsFalse contraGX in\n                    LTESucc $\n                        random_fact_about_filtering xs f g\n        No contraFX =>\n            case decEq (g x) True of\n                Yes prfGX =>\n                    rewrite prfGX in\n                    rewrite notTrueIsFalse contraFX in\n                    rewrite\n                        sym\n                            (plusSuccRightSucc\n                                (length (filter f xs))\n                                (length (filter g xs))\n                            )\n                        in\n                    LTESucc $\n                        random_fact_about_filtering xs f g\n                No contraGX =>\n                    rewrite notTrueIsFalse contraFX in\n                    rewrite notTrueIsFalse contraGX in\n                        random_fact_about_filtering xs f g","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111593,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nrandom_fact_about_filtering :\n  (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE`\n    length (filter f l) + length (filter g l)\nrandom_fact_about_filtering []        f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  random_fact_about_filtering (x :: xs) f g | True with (g x)\n    random_fact_about_filtering (x :: xs) f g | True | True = LTESucc $\n      rewrite sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs)) in\n      lteSuccRight (random_fact_about_filtering xs f g)\n    random_fact_about_filtering (x :: xs) f g | True | False = LTESucc (random_fact_about_filtering xs f g)\n  random_fact_about_filtering (x :: xs) f g | False with (g x)\n    random_fact_about_filtering (x :: xs) f g | False | True =\n      rewrite sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs)) in\n      LTESucc (random_fact_about_filtering xs f g)\n    random_fact_about_filtering (x :: xs) f g | False | False = random_fact_about_filtering xs f g","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111594,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\n\nrandom_fact_about_filtering :\n (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n length (filter (\\x => f x || g x) l) `LTE`\n   length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  random_fact_about_filtering (x :: xs) f g | False with (g x)\n    random_fact_about_filtering (x :: xs) f g | False | False = random_fact_about_filtering xs f g\n    random_fact_about_filtering (x :: xs) f g | False | True =\n          let p0 = sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs))\n              p1 = random_fact_about_filtering xs f g\n          in rewrite p0 in LTESucc p1\n  random_fact_about_filtering (x :: xs) f g | True with (g x)\n    random_fact_about_filtering (x :: xs) f g | True | False = LTESucc $ random_fact_about_filtering xs f g\n    random_fact_about_filtering (x :: xs) f g | True | True =\n          let p0 = lteSuccRight $ LTESucc $ random_fact_about_filtering xs f g\n              p1 = sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs))\n          in rewrite p1 in p0","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111595,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nrandom_fact_about_filtering : \n  (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE` length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  random_fact_about_filtering (x :: xs) f g | fx with (g x)\n    random_fact_about_filtering (x :: xs) f g | fx | gx with (random_fact_about_filtering xs f g)\n      random_fact_about_filtering (x :: xs) f g | False | False | p = p\n      random_fact_about_filtering (x :: xs) f g | False | True | p =\n        rewrite sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs)) in LTESucc p\n      random_fact_about_filtering (x :: xs) f g | True | False | p = LTESucc p\n      random_fact_about_filtering (x :: xs) f g | True | True | p =\n        rewrite sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs)) in LTESucc $ lteSuccRight p\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111596,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nrandom_fact_about_filtering : \n  (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE`\n    length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  random_fact_about_filtering (x :: xs) f g | True with (g x)\n    random_fact_about_filtering (x :: xs) f g | True | True = LTESucc $ rewrite sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs)) in lteSuccRight $ random_fact_about_filtering xs f g\n    random_fact_about_filtering (x :: xs) f g | True | False = LTESucc $ random_fact_about_filtering xs f g\n  random_fact_about_filtering (x :: xs) f g | False with (g x)\n    random_fact_about_filtering (x :: xs) f g | False | False = random_fact_about_filtering xs f g\n    random_fact_about_filtering (x :: xs) f g | False | True = rewrite sym $ plusSuccRightSucc (length (filter f xs)) (length (filter g xs)) in\n                                                                  LTESucc $ random_fact_about_filtering xs f g","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111597,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nrandom_fact_about_filtering : \n  (l : List a) ->\n  (f : a -> Bool) ->\n  (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE` length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] _ _ = LTEZero\nrandom_fact_about_filtering (h::t) f g with (f h)\n  | True with (g h)\n    | True =\n      rewrite plusCommutative (length (filter f t)) (S (length (filter g t))) in\n      rewrite plusCommutative (length (filter g t)) (length (filter f t)) in\n      LTESucc $ lteSuccRight $ random_fact_about_filtering t f g\n    | False =\n      LTESucc $ random_fact_about_filtering t f g\n  | False with (g h)\n    | True =\n      rewrite plusCommutative (length (filter f t)) (S (length (filter g t))) in\n      rewrite plusCommutative (length (filter g t)) (length (filter f t)) in\n      LTESucc $ random_fact_about_filtering t f g\n    | False =\n      random_fact_about_filtering t f g","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111598,"user_id":443,"body":"module Solution\n\n%access export\n%default total\n\nrandom_fact_about_filtering : \n  (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE`\n    length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] c d = lteRefl\nrandom_fact_about_filtering (h :: t) c d with (c h)\n    random_fact_about_filtering (h :: t) c d | True with (d h)\n        random_fact_about_filtering (h :: t) c d | True | True =\n            rewrite (plusCommutative 1 (length (filter d t))) in\n                rewrite (plusAssociative (length (filter c t)) (length (filter d t)) 1) in\n                    rewrite (plusCommutative (plus (length (filter c t)) (length (filter d t))) 1) in\n                        LTESucc (lteSuccRight (random_fact_about_filtering t c d))\n        random_fact_about_filtering (h :: t) c d | True | False =\n            LTESucc (random_fact_about_filtering t c d)\n    random_fact_about_filtering (h :: t) c d | False with (d h)\n        random_fact_about_filtering (h :: t) c d | False | True =\n            rewrite (plusCommutative 1 (length (filter d t))) in\n                rewrite (plusAssociative (length (filter c t)) (length (filter d t)) 1) in\n                    rewrite (plusCommutative (plus (length (filter c t)) (length (filter d t))) 1) in\n                        LTESucc (random_fact_about_filtering t c d)\n        random_fact_about_filtering (h :: t) c d | False | False =\n            random_fact_about_filtering t c d","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111599,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nrandom_fact_about_filtering : \n  (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE`\n    length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  | False with (g x)\n    | False = random_fact_about_filtering xs f g\n    | True = rewrite sym (plusSuccRightSucc (length $ filter f xs) (length $ filter g xs)) in\n             LTESucc (random_fact_about_filtering xs f g)\n  | True with (g x)\n    | False = LTESucc (random_fact_about_filtering xs f g)\n    | True = rewrite sym (plusSuccRightSucc (length $ filter f xs) (length $ filter g xs)) in\n             LTESucc $ lteSuccRight $ random_fact_about_filtering xs f g","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111600,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nlemma1 : (n : Nat) -> (m : Nat) -> (l : Nat) -> LTE n (m + l) -> LTE (S n) (m + (S l))\nlemma1 n m l lte = rewrite sym $ plusSuccRightSucc m l in LTESucc lte\n\nlemma2 : (n : Nat) -> (m : Nat) -> (l : Nat) -> LTE n (S (m + l)) -> LTE n (m + S l)\nlemma2 n m l lte = rewrite sym $ plusSuccRightSucc m l in lte\n\nrandom_fact_about_filtering :\n    (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n    length (filter (\\x => f x || g x) l) `LTE` length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  | False with (g x)\n    | False = random_fact_about_filtering xs f g\n    | True = lemma1 _ _ _ $ random_fact_about_filtering xs f g\n  | True with (g x)\n    | False = LTESucc $ random_fact_about_filtering xs f g\n    | True = LTESucc . lemma2 _ _ _ .  lteSuccRight $ random_fact_about_filtering xs f g\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111601,"user_id":null,"body":"module Solution\n\n%access export\n%default total\n\nlemma : {n, m : Nat} -> LTE n m -> LTE n (S m)\nlemma LTEZero = LTEZero\nlemma (LTESucc x) = LTESucc (lemma x)\n\nrandom_fact_about_filtering : \n  (l : List a) -> (f : a -> Bool) -> (g : a -> Bool) ->\n  length (filter (\\x => f x || g x) l) `LTE`\n    length (filter f l) + length (filter g l)\nrandom_fact_about_filtering [] f g = LTEZero\nrandom_fact_about_filtering (x :: xs) f g with (f x)\n  | True with (g x)\n    | True = LTESucc $ rewrite sym (plusSuccRightSucc (length (filter f xs)) \n                                                      (length (filter g xs)))\n                               in lemma (random_fact_about_filtering xs f g)\n    | False = LTESucc (random_fact_about_filtering xs f g)\n  | False with (g x)\n    | True = rewrite sym $ plusSuccRightSucc (length (filter f xs))\n                                             (length (filter g xs))\n                     in (LTESucc (random_fact_about_filtering xs f g))\n    | False = random_fact_about_filtering xs f g\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5cc10885658d6f001281038a":[{"id":111602,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Expr : Type where\n  Const : Nat -> Expr\n  Plus : Expr -> Expr -> Expr\n  \nevalExpr : Expr -> Nat\nevalExpr (Const n) = n\nevalExpr (Plus e1 e2) = evalExpr e1 + evalExpr e2\n\nevalExprTail' : Expr -> Nat -> Nat\nevalExprTail' (Const n) acc = n + acc\nevalExprTail' (Plus e1 e2) acc = evalExprTail' e2 (evalExprTail' e1 acc)\n\nevalExprTail : Expr -> Nat\nevalExprTail e = evalExprTail' e 0\n\nevalExprCont' : Expr -> (Nat -> a) -> a\nevalExprCont' (Const n) k = k n\nevalExprCont' (Plus e1 e2) k = evalExprCont' e2 (\n2 =>\n                               evalExprCont' e1 (\n1 => k (n1 + n2)))\n                                 \nevalExprCont : Expr -> Nat\nevalExprCont e = evalExprCont' e id\n\ndata Instr : Type where\n  Push : Nat -> Instr\n  Add : Instr\n  \nProg : Type\nProg = List Instr\n\nStack : Type\nStack = List Nat\n\nrun : Prog -> Stack -> Stack\nrun [] s = s\nrun (Push n :: p) s = run p (n :: s)\nrun (Add :: p) (a1 :: a2 :: s) = run p (a1 + a2 :: s)\nrun (Add :: p) s = run p s\n\ncompile : Expr -> Prog\ncompile (Const n) = [Push n]\ncompile (Plus e1 e2) = compile e1 ++ compile e2 ++ [Add]\n-}\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalExprTailCorrect' :\n    (e : Expr) ->\n    (acc : Nat) ->\n    evalExprTail' e acc = plus acc (evalExpr e)\nevalExprTailCorrect' (Const k) acc = plusCommutative k acc\nevalExprTailCorrect' (Plus e1 e2) acc =\n    rewrite evalExprTailCorrect' e1 acc in\n    rewrite evalExprTailCorrect' e2 (plus acc (evalExpr e1)) in\n        sym (plusAssociative _ _ _)\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect e = evalExprTailCorrect' e 0\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\n\nevalExprContCorrect' :\n    (e : Expr) ->\n    (f : _) ->\n    evalExprCont' e f = f (evalExpr e)\nevalExprContCorrect' (Const k) f = Refl\nevalExprContCorrect' (Plus x y) f =\n    rewrite\n        evalExprContCorrect' y (\n2 => evalExprCont' x (\n1 => f (plus n1 n2)))\n    in\n    rewrite\n        evalExprContCorrect' x (\n1 => f (plus n1 (evalExpr y)))\n    in\n        Refl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect e = evalExprContCorrect' e id\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nlemma :\n    (p1 : Prog) ->\n    (p2 : Prog) ->\n    (s : Stack) ->\n    run (p1 ++ p2) s = run p2 (run p1 s)\nlemma [] p2 _ = Refl\nlemma ((Push k) :: xs) p2 s = lemma xs p2 (k :: s)\nlemma (Add :: xs) p2 (y1 :: y2 :: ys) = lemma xs p2 (plus y1 y2 :: ys)\nlemma (Add :: xs) p2 [y] = lemma xs p2 [y]\nlemma (Add :: xs) p2 [] = lemma xs p2 []\n\ncompileCorrect' : (e : Expr) -> (s : _) -> run (compile e) s = evalExpr e :: s\ncompileCorrect' (Const k) _ = Refl\ncompileCorrect' (Plus e1 e2) s =\n    rewrite lemma (compile e1) (compile e2 ++ [Add]) s in\n    rewrite compileCorrect' e1 s in\n    rewrite lemma (compile e2) [Add] (evalExpr e1 :: s) in\n    rewrite compileCorrect' e2 (evalExpr e1 :: s) in\n    cong {f=(:: s)} $\n        plusCommutative _ _\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = compileCorrect' e []\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111603,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Expr : Type where\n  Const : Nat -> Expr\n  Plus : Expr -> Expr -> Expr\n  \nevalExpr : Expr -> Nat\nevalExpr (Const n) = n\nevalExpr (Plus e1 e2) = evalExpr e1 + evalExpr e2\n\nevalExprTail' : Expr -> Nat -> Nat\nevalExprTail' (Const n) acc = n + acc\nevalExprTail' (Plus e1 e2) acc = evalExprTail' e2 (evalExprTail' e1 acc)\n\nevalExprTail : Expr -> Nat\nevalExprTail e = evalExprTail' e 0\n\nevalExprCont' : Expr -> (Nat -> a) -> a\nevalExprCont' (Const n) k = k n\nevalExprCont' (Plus e1 e2) k = evalExprCont' e2 (\n2 =>\n                               evalExprCont' e1 (\n1 => k (n1 + n2)))\n                                 \nevalExprCont : Expr -> Nat\nevalExprCont e = evalExprCont' e id\n\ndata Instr : Type where\n  Push : Nat -> Instr\n  Add : Instr\n  \nProg : Type\nProg = List Instr\n\nStack : Type\nStack = List Nat\n\nrun : Prog -> Stack -> Stack\nrun [] s = s\nrun (Push n :: p) s = run p (n :: s)\nrun (Add :: p) (a1 :: a2 :: s) = run p (a1 + a2 :: s)\nrun (Add :: p) s = run p s\n\ncompile : Expr -> Prog\ncompile (Const n) = [Push n]\ncompile (Plus e1 e2) = compile e1 ++ compile e2 ++ [Add]\n-}\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalExprTailCorrectHelp : (e : Expr) -> (n : Nat) -> evalExprTail' e n = n + evalExpr e\nevalExprTailCorrectHelp (Const k) n = plusCommutative k n\nevalExprTailCorrectHelp (Plus x y) n =\n    rewrite evalExprTailCorrectHelp y (evalExprTail' x n) in\n    rewrite evalExprTailCorrectHelp x n in\n    rewrite plusAssociative n (evalExpr x) (evalExpr y) in\n    Refl\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect e = evalExprTailCorrectHelp e 0\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\n\nevalExprContCorrectHelp : (e : Expr) -> (f : Nat -> a) -> evalExprCont' e f = f (evalExpr e)\nevalExprContCorrectHelp (Const k) f = Refl\nevalExprContCorrectHelp (Plus x y) f with (evalExprContCorrectHelp y (\n2 => evalExprCont' x (\n1 => f (plus n1 n2))))\n  evalExprContCorrectHelp (Plus x y) f | eq1 with (evalExprContCorrectHelp x (\n1 => f (plus n1 (evalExpr y))))\n    evalExprContCorrectHelp (Plus x y) f | eq1 | eq2 = eq1 `trans` eq2\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect e = evalExprContCorrectHelp e id\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrunLemma : (p:Instr) -> (ps:Prog) -> (s : Stack) -> run (p::ps) s = run ps (run [p] s)\nrunLemma (Push k) ps s = Refl\nrunLemma Add ps [] = Refl\nrunLemma Add ps (x :: []) = Refl\nrunLemma Add ps (x :: (y :: xs)) = Refl\n\nrunLemma1 : (p,q:Prog) -> (s : Stack) -> run (p++q) s = run q (run p s)\nrunLemma1 [] q s = Refl\nrunLemma1 (p::ps) q s =\n    rewrite runLemma p (ps ++ q) s in\n    rewrite runLemma1 ps q (run [p] s) in\n    rewrite runLemma p ps s in\n        Refl\n\ncompileCorrectLemma : (e : Expr) -> (s : Stack) -> run (compile e) s = evalExpr e :: s\ncompileCorrectLemma (Const k) s = Refl\ncompileCorrectLemma (Plus x y) s =\n    rewrite runLemma1 (compile x) (compile y ++ [Add]) s in\n    rewrite runLemma1 (compile y) ([Add]) (run (compile x) s) in\n    rewrite compileCorrectLemma x s in\n    rewrite compileCorrectLemma y (evalExpr x :: s) in\n    rewrite plusCommutative (evalExpr y) (evalExpr x) in\n        Refl\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = compileCorrectLemma e []\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111604,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Expr : Type where\n  Const : Nat -> Expr\n  Plus : Expr -> Expr -> Expr\n  \nevalExpr : Expr -> Nat\nevalExpr (Const n) = n\nevalExpr (Plus e1 e2) = evalExpr e1 + evalExpr e2\n\nevalExprTail' : Expr -> Nat -> Nat\nevalExprTail' (Const n) acc = n + acc\nevalExprTail' (Plus e1 e2) acc = evalExprTail' e2 (evalExprTail' e1 acc)\n\nevalExprTail : Expr -> Nat\nevalExprTail e = evalExprTail' e 0\n\nevalExprCont' : Expr -> (Nat -> a) -> a\nevalExprCont' (Const n) k = k n\nevalExprCont' (Plus e1 e2) k = evalExprCont' e2 (\n2 =>\n                               evalExprCont' e1 (\n1 => k (n1 + n2)))\n                                 \nevalExprCont : Expr -> Nat\nevalExprCont e = evalExprCont' e id\n\ndata Instr : Type where\n  Push : Nat -> Instr\n  Add : Instr\n  \nProg : Type\nProg = List Instr\n\nStack : Type\nStack = List Nat\n\nrun : Prog -> Stack -> Stack\nrun [] s = s\nrun (Push n :: p) s = run p (n :: s)\nrun (Add :: p) (a1 :: a2 :: s) = run p (a1 + a2 :: s)\nrun (Add :: p) s = run p s\n\ncompile : Expr -> Prog\ncompile (Const n) = [Push n]\ncompile (Plus e1 e2) = compile e1 ++ compile e2 ++ [Add]\n-}\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalExprTailAux: (e: Expr) -> (n:Nat) -> evalExprTail' e n = evalExpr e + n\nevalExprTailAux (Const n) m = Refl\nevalExprTailAux (Plus a b) m = rewrite evalExprTailAux a m in\n                                rewrite evalExprTailAux b (evalExpr a + m) in\n                                  rewrite plusAssociative (evalExpr b) (evalExpr a) m in\n                                    rewrite plusCommutative (evalExpr a) (evalExpr b) in\n                                      Refl\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect (Const n) = rewrite plusZeroRightNeutral n in Refl\nevalExprTailCorrect (Plus a b) = rewrite evalExprTailAux a 0 in\n                                  rewrite plusZeroRightNeutral (evalExpr a) in\n                                    rewrite evalExprTailAux b (evalExpr a) in\n                                      rewrite plusCommutative (evalExpr b) (evalExpr a)\n                                        in Refl\n\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\n\nevalExprContAux: (e: Expr) -> (k: Nat->a) -> evalExprCont' e k = k (evalExpr e)\nevalExprContAux (Const n) k = Refl\nevalExprContAux (Plus a b) k = rewrite evalExprContAux b (\n2 => evalExprCont' a (\n1 => k (n1 + n2))) in \n                                rewrite evalExprContAux a (\n => k (n + evalExpr b)) in Refl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect (Const n) = Refl\nevalExprContCorrect (Plus a b) = evalExprContAux (Plus a b) id\n\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\ncompileCorrectAux : (e : Expr) -> (p: Prog) -> (s : Stack) -> run (compile e ++ p) s = run p (evalExpr e ::s)\ncompileCorrectAux (Const n) p s = Refl\ncompileCorrectAux (Plus a b) p s = rewrite sym (appendAssociative (compile a) (compile b ++ [Add]) p) in \n                                    rewrite compileCorrectAux a ((compile b ++ [Add]) ++ p) s in\n                                      rewrite sym (appendAssociative (compile b) [Add] p) in\n                                        rewrite compileCorrectAux b (Add ::p) (evalExpr a :: s) in\n                                         rewrite plusCommutative (evalExpr a) (evalExpr b) in Refl\n                                    \n\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = rewrite sym (appendNilRightNeutral (compile e)) in\n                    rewrite compileCorrectAux e [] [] in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111605,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Expr : Type where\n  Const : Nat -> Expr\n  Plus : Expr -> Expr -> Expr\n  \nevalExpr : Expr -> Nat\nevalExpr (Const n) = n\nevalExpr (Plus e1 e2) = evalExpr e1 + evalExpr e2\n\nevalExprTail' : Expr -> Nat -> Nat\nevalExprTail' (Const n) acc = n + acc\nevalExprTail' (Plus e1 e2) acc = evalExprTail' e2 (evalExprTail' e1 acc)\n\nevalExprTail : Expr -> Nat\nevalExprTail e = evalExprTail' e 0\n\nevalExprCont' : Expr -> (Nat -> a) -> a\nevalExprCont' (Const n) k = k n\nevalExprCont' (Plus e1 e2) k = evalExprCont' e2 (\n2 =>\n                               evalExprCont' e1 (\n1 => k (n1 + n2)))\n                                 \nevalExprCont : Expr -> Nat\nevalExprCont e = evalExprCont' e id\n\ndata Instr : Type where\n  Push : Nat -> Instr\n  Add : Instr\n  \nProg : Type\nProg = List Instr\n\nStack : Type\nStack = List Nat\n\nrun : Prog -> Stack -> Stack\nrun [] s = s\nrun (Push n :: p) s = run p (n :: s)\nrun (Add :: p) (a1 :: a2 :: s) = run p (a1 + a2 :: s)\nrun (Add :: p) s = run p s\n\ncompile : Expr -> Prog\ncompile (Const n) = [Push n]\ncompile (Plus e1 e2) = compile e1 ++ compile e2 ++ [Add]\n-}\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\ntailAccIsAcc : (e: Expr) -> (v: Nat) -> evalExprTail' e v = v + evalExprTail' e 0\ntailAccIsAcc (Const n) v = rewrite plusZeroRightNeutral n in plusCommutative n v\ntailAccIsAcc (Plus e1 e2) v = let right = tailAccIsAcc e2 in \n\trewrite tailAccIsAcc e1 v in \n\trewrite right (v+(evalExprTail' e1 0)) in \n\trewrite right (evalExprTail' e1 0) in \n\tsym $ plusAssociative v (evalExprTail' e1 0) (evalExprTail' e2 0) \n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect (Const n) = plusZeroRightNeutral n\nevalExprTailCorrect (Plus e1 e2) = rewrite evalExprTailCorrect e1 in \n\trewrite tailAccIsAcc e2 (evalExpr e1) in \n\t\trewrite evalExprTailCorrect e2 in Refl\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\n\ncontAcc : (e: Expr) -> (k: Nat -> Nat) -> evalExprCont' e k = k (evalExprCont' e Basics.id)\ncontAcc (Const n) k = Refl\ncontAcc (Plus e1 e2) k = rewrite contAcc e2 (\n2=>evalExprCont' e1 (\n1=> k(n1+n2))) in \n\trewrite contAcc e2 (\n2=>evalExprCont' e1 (\n1=>n1+n2)) in\n\trewrite contAcc e1 (\n1=>n1+(evalExprCont e2)) in\n\trewrite contAcc e1 (\n1=>k(n1+(evalExprCont e2))) in Refl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect (Const n) = Refl\nevalExprContCorrect (Plus e1 e2) = rewrite contAcc e2 (\n2=>evalExprCont' e1(\n1=>n1+n2)) in \n\trewrite contAcc e1 (\n1=>n1+evalExprCont e2) in \n\trewrite evalExprContCorrect e2 in \n\trewrite evalExprContCorrect e1 in Refl\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nprogAppend : (a, b : Prog) -> (s: Stack) -> run (a++b) s = run b (run a s)\nprogAppend [] b s = Refl\nprogAppend (Push n::as) b s = progAppend as b (n::s)\nprogAppend (Add::as) b (x::y::s) = progAppend as b ((x+y)::s)\nprogAppend (Add::as) b [] = progAppend as b []\nprogAppend (Add::as) b [x] = progAppend as b [x]\n\nemptyStack : (e: Expr) -> (s: Stack) -> run (compile e) s = (run (compile e) [])++s\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect (Const n) = Refl\ncompileCorrect (Plus e1 e2) = rewrite progAppend (compile e1) (compile e2++[Add]) [] in \n\trewrite compileCorrect e1 in \n\trewrite progAppend (compile e2) [Add] [evalExpr e1] in\n\trewrite emptyStack e2 [evalExpr e1] in \n\trewrite compileCorrect e2 in \n\trewrite plusCommutative (evalExpr e1) (evalExpr e2) in\n\tRefl\n\nemptyStack (Const n) s = Refl\nemptyStack (Plus e1 e2) s = \n\trewrite progAppend (compile e1) (compile e2++[Add]) [] in \n\trewrite progAppend (compile e1) (compile e2++[Add]) s in \n\trewrite emptyStack e1 s in \n\trewrite compileCorrect e1 in \n\trewrite progAppend (compile e2) [Add] [evalExpr e1] in \n\trewrite progAppend (compile e2) [Add] (evalExpr e1::s) in \n\trewrite emptyStack e2 [evalExpr e1] in\n\trewrite emptyStack e2 (evalExpr e1::s) in\n\trewrite compileCorrect e2 in Refl\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111606,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Expr : Type where\n  Const : Nat -> Expr\n  Plus : Expr -> Expr -> Expr\n  \nevalExpr : Expr -> Nat\nevalExpr (Const n) = n\nevalExpr (Plus e1 e2) = evalExpr e1 + evalExpr e2\n\nevalExprTail' : Expr -> Nat -> Nat\nevalExprTail' (Const n) acc = n + acc\nevalExprTail' (Plus e1 e2) acc = evalExprTail' e2 (evalExprTail' e1 acc)\n\nevalExprTail : Expr -> Nat\nevalExprTail e = evalExprTail' e 0\n\nevalExprCont' : Expr -> (Nat -> a) -> a\nevalExprCont' (Const n) k = k n\nevalExprCont' (Plus e1 e2) k = evalExprCont' e2 (\n2 =>\n                               evalExprCont' e1 (\n1 => k (n1 + n2)))\n                                 \nevalExprCont : Expr -> Nat\nevalExprCont e = evalExprCont' e id\n\ndata Instr : Type where\n  Push : Nat -> Instr\n  Add : Instr\n  \nProg : Type\nProg = List Instr\n\nStack : Type\nStack = List Nat\n\nrun : Prog -> Stack -> Stack\nrun [] s = s\nrun (Push n :: p) s = run p (n :: s)\nrun (Add :: p) (a1 :: a2 :: s) = run p (a1 + a2 :: s)\nrun (Add :: p) s = run p s\n\ncompile : Expr -> Prog\ncompile (Const n) = [Push n]\ncompile (Plus e1 e2) = compile e1 ++ compile e2 ++ [Add]\n-}\n\n%access export\n%default total\n\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalExprTailLemma : (e : Expr) -> (acc : Nat) -> evalExprTail' e acc = acc + evalExprTail e\nevalExprTailLemma (Const n) acc =\n\trewrite plusZeroRightNeutral n in\n\tplusCommutative n acc\nevalExprTailLemma (Plus e1 e2) acc =\n\trewrite evalExprTailLemma e2 (evalExprTail e1) in\n\trewrite evalExprTailLemma e2 (evalExprTail' e1 acc) in\n\trewrite evalExprTailLemma e1 acc in\n\tsym $ plusAssociative acc (evalExprTail e1) (evalExprTail e2)\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect (Const n) = rewrite plusZeroRightNeutral n in Refl\nevalExprTailCorrect (Plus e1 e2) =\n\trewrite evalExprTailLemma e2 (evalExprTail e1) in\n\trewrite evalExprTailCorrect e1 in\n\trewrite evalExprTailCorrect e2 in\n\tRefl\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\n\nevalExprContLemma : (e : Expr) -> (k : (Nat -> a)) -> evalExprCont' e k = k (evalExpr e)\nevalExprContLemma (Const n) _ = Refl\nevalExprContLemma (Plus e1 e2) k =\n\trewrite evalExprContLemma e2 (\n2 => evalExprCont' e1 (\n1 => k (n1 + n2))) in\n\trewrite evalExprContLemma e1 (\n1 => k (n1 + evalExpr e2)) in\n\tRefl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect e = evalExprContLemma e id\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrunCons : (x : Instr) -> (xs : Prog) -> (s : Stack) -> run (x :: xs) s = run xs (run [x] s)\nrunCons (Push n) xs s = Refl\nrunCons Add xs (a1 :: a2 :: s) = Refl\nrunCons Add xs (a2 :: Nil) = Refl\nrunCons Add xs Nil = Refl\n\nrunConcat : (xs : Prog) -> (ys : Prog) -> (s : Stack) -> run (xs ++ ys) s = run ys (run xs s)\nrunConcat Nil ys s = Refl\nrunConcat (x :: xs) ys s =\n\trewrite runCons x xs s in\n\trewrite runCons x (xs ++ ys) s in\n\trunConcat xs ys (run [x] s)\n\ncompileCorrect' : (e : Expr) -> (s : Stack) -> run (compile e) s = evalExpr e :: s\ncompileCorrect' (Const n) s = Refl\ncompileCorrect' (Plus e1 e2) s =\n\trewrite runConcat (compile e1) (compile e2 ++ [Add]) s in\n\trewrite compileCorrect' e1 s in\n\trewrite runConcat (compile e2) [Add] (evalExpr e1 :: s) in\n\trewrite compileCorrect' e2 (evalExpr e1 :: s) in\n\trewrite plusCommutative (evalExpr e1) (evalExpr e2) in\n\tRefl\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = compileCorrect' e []\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111607,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Expr : Type where\n  Const : Nat -> Expr\n  Plus : Expr -> Expr -> Expr\n  \nevalExpr : Expr -> Nat\nevalExpr (Const n) = n\nevalExpr (Plus e1 e2) = evalExpr e1 + evalExpr e2\n\nevalExprTail' : Expr -> Nat -> Nat\nevalExprTail' (Const n) acc = n + acc\nevalExprTail' (Plus e1 e2) acc = evalExprTail' e2 (evalExprTail' e1 acc)\n\nevalExprTail : Expr -> Nat\nevalExprTail e = evalExprTail' e 0\n\nevalExprCont' : Expr -> (Nat -> a) -> a\nevalExprCont' (Const n) k = k n\nevalExprCont' (Plus e1 e2) k = evalExprCont' e2 (\n2 =>\n                               evalExprCont' e1 (\n1 => k (n1 + n2)))\n                                 \nevalExprCont : Expr -> Nat\nevalExprCont e = evalExprCont' e id\n\ndata Instr : Type where\n  Push : Nat -> Instr\n  Add : Instr\n  \nProg : Type\nProg = List Instr\n\nStack : Type\nStack = List Nat\n\nrun : Prog -> Stack -> Stack\nrun [] s = s\nrun (Push n :: p) s = run p (n :: s)\nrun (Add :: p) (a1 :: a2 :: s) = run p (a1 + a2 :: s)\nrun (Add :: p) s = run p s\n\ncompile : Expr -> Prog\ncompile (Const n) = [Push n]\ncompile (Plus e1 e2) = compile e1 ++ compile e2 ++ [Add]\n-}\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\nevalExprTailCorrect' : (e : Expr) -> (acc : Nat) -> \n                       evalExprTail' e acc = evalExpr e + acc\nevalExprTailCorrect' (Const k) acc = Refl\nevalExprTailCorrect' (Plus x y) acc = \n  rewrite evalExprTailCorrect' x acc\n  in rewrite evalExprTailCorrect' y (evalExpr x + acc)\n  in rewrite plusAssociative (evalExpr y) (evalExpr x) acc\n  in rewrite plusCommutative (evalExpr y) (evalExpr x)\n  in Refl\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect e = \n  rewrite evalExprTailCorrect' e 0\n  in rewrite plusZeroRightNeutral (evalExpr e)\n  in Refl\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\nevalExprContCorrect' : (k : Nat -> a) -> (e : Expr) -> evalExprCont' e k = k (evalExpr e)\nevalExprContCorrect' k (Const j) = Refl\nevalExprContCorrect' k (Plus x y) = \n  rewrite evalExprContCorrect' (\n2 => evalExprCont' x (\n1 => k (plus n1 n2))) y\n  in rewrite evalExprContCorrect' (\n1 => k (plus n1 (evalExpr y))) x\n  in Refl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect = evalExprContCorrect' id\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrunAppend : (p1 : Prog) -> (p2 : Prog) -> (s : Stack) -> run (p1 ++ p2) s = run p2 (run p1 s)\nrunAppend [] p2 s = Refl\nrunAppend ((Push k) :: xs) p2 s = runAppend xs p2 (k :: s)\nrunAppend (Add :: xs) p2 [] = runAppend xs p2 []\nrunAppend (Add :: xs) p2 (x :: []) = runAppend xs p2 [x]\nrunAppend (Add :: xs) p2 (x :: (y :: ys)) = runAppend xs p2 (plus x y :: ys)\n\ncompileCorrect' : (s : Stack) -> (e : Expr) -> run (compile e) s = evalExpr e :: s\ncompileCorrect' s (Const k) = Refl\ncompileCorrect' s (Plus x y) = \n  rewrite runAppend (compile x) (compile y ++ [Add]) s\n  in rewrite runAppend (compile y) ([Add]) (run (compile x) s)\n  in rewrite compileCorrect' s x \n  in rewrite compileCorrect' (evalExpr x :: s) y\n  in rewrite plusCommutative (evalExpr y) (evalExpr x)\n  in Refl\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect = compileCorrect' []\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111608,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalExprTailLemma : (e : Expr) -> (x : Nat) -> evalExprTail' e x = (evalExpr e) + x\nevalExprTailLemma (Const k) x = Refl\nevalExprTailLemma (Plus y z) x = rewrite evalExprTailLemma y x in\n                                 rewrite evalExprTailLemma z (plus (evalExpr y) x) in\n                                 rewrite plusCommutative (evalExpr y) (evalExpr z) in\n                                 rewrite plusAssociative (evalExpr z) (evalExpr y) x in\n                                 Refl\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect e = rewrite sym (plusZeroRightNeutral (evalExpr e)) in\n                        evalExprTailLemma e 0\n\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\nevalExprContLemma : (e : Expr) -> (f : Nat -> a) -> evalExprCont' e f = f (evalExpr e)\nevalExprContLemma (Const k) f = Refl\nevalExprContLemma (Plus x y) f = rewrite evalExprContLemma y (\n2 => evalExprCont' x (\n1 => f (plus n1 n2))) in\n                                 rewrite evalExprContLemma x (\n1 => f (plus n1 (evalExpr y))) in\n                                 Refl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect e = evalExprContLemma e id\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrunLemma : (a : Prog) -> (b : Prog) -> (s : Stack) -> run (a ++ b) s = run b (run a s)\nrunLemma [] b s = Refl\nrunLemma ((Push k) :: xs) b s = runLemma xs b (k :: s)\nrunLemma (Add :: xs) b [] = runLemma xs b []\nrunLemma (Add :: xs) b (x :: []) = runLemma xs b [x]\nrunLemma (Add :: xs) b (x :: (y :: ys)) = runLemma xs b (plus x y :: ys)\n\ncompileCorrectLemma : (e : Expr) -> (s : Stack) -> run (compile e) s = (evalExpr e) :: s\ncompileCorrectLemma (Const k) s = Refl\ncompileCorrectLemma (Plus x y) s = rewrite runLemma (compile x) (compile y ++ [Add]) s in\n                                   rewrite runLemma (compile y) [Add] (run (compile x) s) in\n                                   rewrite compileCorrectLemma x s in\n                                   rewrite compileCorrectLemma y (evalExpr x :: s) in\n                                   rewrite plusCommutative (evalExpr y) (evalExpr x) in\n                                   Refl\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = compileCorrectLemma e []","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111609,"user_id":null,"body":"module Solution\n\nimport Preloaded\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalExprTailLemma : (e : Expr) -> (x : Nat) -> evalExprTail' e x = (evalExpr e) + x\nevalExprTailLemma (Const k) x = Refl\nevalExprTailLemma (Plus y z) x = rewrite evalExprTailLemma y x in\n                                 rewrite evalExprTailLemma z (plus (evalExpr y) x) in\n                                 rewrite plusCommutative (evalExpr y) (evalExpr z) in\n                                 rewrite plusAssociative (evalExpr z) (evalExpr y) x in\n                                 Refl\n\nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect e = rewrite sym (plusZeroRightNeutral (evalExpr e)) in\n                        evalExprTailLemma e 0\n\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\nevalExprContLemma : (e : Expr) -> (f : Nat -> a) -> evalExprCont' e f = f (evalExpr e)\nevalExprContLemma (Const k) f = Refl\nevalExprContLemma (Plus x y) f = rewrite evalExprContLemma y (\n2 => evalExprCont' x (\n1 => f (plus n1 n2))) in\n                                 rewrite evalExprContLemma x (\n1 => f (plus n1 (evalExpr y))) in\n                                 Refl\n\nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect e = evalExprContLemma e id\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrunLemma : (a : Prog) -> (b : Prog) -> (s : Stack) -> run (a ++ b) s = run b (run a s)\nrunLemma [] b s = Refl\nrunLemma ((Push k) :: xs) b s = runLemma xs b (k :: s)\nrunLemma (Add :: xs) b [] = runLemma xs b []\nrunLemma (Add :: xs) b (x :: []) = runLemma xs b [x]\nrunLemma (Add :: xs) b (x :: (y :: ys)) = runLemma xs b (plus x y :: ys)\n\ncompileCorrectLemma : (e : Expr) -> (s : Stack) -> run (compile e) s = (evalExpr e) :: s\ncompileCorrectLemma (Const k) s = Refl\ncompileCorrectLemma (Plus x y) s = rewrite runLemma (compile x) (compile y ++ [Add]) s in\n                                   rewrite runLemma (compile y) [Add] (run (compile x) s) in\n                                   rewrite compileCorrectLemma x s in\n                                   rewrite compileCorrectLemma y (evalExpr x :: s) in\n                                   rewrite plusCommutative (evalExpr y) (evalExpr x) in\n                                   Refl\n\ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = compileCorrectLemma e []","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111610,"user_id":168,"body":"module Solution\n\nimport Preloaded\n\n%access export\n%default total\n\n-- Task 1 - 1. Prove that evalExprTail is equivalent to evalExpr.\n\nevalTailLemma : (e : Expr) -> (a : Nat) -> evalExprTail' e a = a + evalExpr e\nevalTailLemma (Const n) a = plusCommutative n a\nevalTailLemma (Plus e1 e2) a = \n  rewrite evalTailLemma e1 a in\n  rewrite evalTailLemma e2 (a + evalExpr e1) in\n  sym $ plusAssociative a (evalExpr e1) (evalExpr e2)\n  \nevalExprTailCorrect : (e : Expr) -> evalExprTail e = evalExpr e\nevalExprTailCorrect e = evalTailLemma e 0\n\n-- Task 1 - 2. Prove that evalExprCont is equivalent to evalExpr.\n\nevalContLemma : (e : Expr) -> (k : Nat -> a) -> evalExprCont' e k = k (evalExpr e)\nevalContLemma (Const n) k = Refl\nevalContLemma (Plus e1 e2) k = \n  trans (evalContLemma e2 (\\b => evalExprCont' e1 (\\a => k (a + b)))) \n        (evalContLemma e1 (\n => k (n + evalExpr e2)))\n        \nevalExprContCorrect : (e : Expr) -> evalExprCont e = evalExpr e\nevalExprContCorrect e = evalContLemma e id\n\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\ncompileLemma : (e : Expr) -> (p : Prog) -> (s : Stack) -> run (compile e ++ p) s = run p (evalExpr e :: s)       \ncompileLemma (Const n) p s = Refl\ncompileLemma (Plus e1 e2) p s = \n  rewrite sym $ appendAssociative (compile e1) (compile e2 ++ [Add]) p in\n  rewrite compileLemma e1 ((compile e2 ++ [Add]) ++ p) s in\n  rewrite sym $ appendAssociative (compile e2) [Add] p in\n  rewrite compileLemma e2 (Add :: p) (evalExpr e1 :: s) in\n  rewrite plusCommutative (evalExpr e1) (evalExpr e2) in\n  Refl\n  \ncompileCorrect : (e : Expr) -> run (compile e) [] = [evalExpr e]\ncompileCorrect e = \n  rewrite sym $ appendNilRightNeutral (compile e) in\n  compileLemma e [] []","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5cc47f8c4b8fea001de6d226":[{"id":111611,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Mult3 : Nat -> Type where\n  Mult_0 : Mult3 0\n  Mult_SSS : (n : Nat) -> Mult3 n -> Mult3 (S (S (S n)))\n  \ndata Mult3' : Nat -> Type where\n  Mult_30 : Mult3' 30\n  Mult_21 : Mult3' 21\n  Mult_sum : (n : Nat) -> (m : Nat) -> Mult3' n -> Mult3' m -> Mult3' (n + m)\n  Mult_diff : (l : Nat) -> (n : Nat) -> (m : Nat) -> Mult3' n -> Mult3' m -> l + n = m -> Mult3' l\n-}  \n\n%access public export\n%default total\n\nMult_SSSi : Mult3 n -> Mult3 (S $ S $ S n)\nMult_SSSi m = Mult_SSS _ m\n\nMult_9' : Mult3' 9\nMult_9' = Mult_diff _ _ _ Mult_21 Mult_30 Refl\n\nMult_12' : Mult3' 12\nMult_12' = Mult_diff _ _ _ Mult_9' Mult_21 Refl\n\nMult_3' : Mult3' 3\nMult_3' = Mult_diff _ _ _ Mult_9' Mult_12' Refl\n\nMult_0' : Mult3' 0\nMult_0' = Mult_diff _ _ _ Mult_30 Mult_30 Refl\n\nMult_SSS' : Mult3' n -> Mult3' (S $ S $ S n)\nMult_SSS' m = Mult_sum _ _ Mult_3' m\n\nmult_imp_mult' : {n : Nat} -> Mult3 n -> Mult3' n\nmult_imp_mult' Mult_0 = Mult_0'\nmult_imp_mult' (Mult_SSS _ x) = Mult_SSS' (mult_imp_mult' x)\n\nMult_3n : (n:Nat) -> Mult3 (n*3)\nMult_3n Z = Mult_0\nMult_3n (S k) = Mult_SSSi $ Mult_3n k\n\nMult_add : Mult3 n -> Mult3 m -> Mult3 (n+m)\nMult_add Mult_0 y = y\nMult_add (Mult_SSS n x) y = Mult_SSSi $ Mult_add x y\n\nMult_sub : Mult3 n -> Mult3 (n + m) -> Mult3 m\nMult_sub Mult_0 y = y\nMult_sub (Mult_SSS n x) (Mult_SSS (plus n m) y) = Mult_sub x y\n\nMult_sub' : Mult3 n -> Mult3 (m + n) -> Mult3 m\nMult_sub' {n} {m} x y = Mult_sub x (replace (plusCommutative m n) y)\n\nmult'_imp_mult : {n : Nat} -> Mult3' n -> Mult3 n\nmult'_imp_mult Mult_30 = Mult_3n 10\nmult'_imp_mult Mult_21 = Mult_3n 7\nmult'_imp_mult (Mult_sum _ _ x y) = let x' = mult'_imp_mult x; y' = mult'_imp_mult y in Mult_add x' y'\nmult'_imp_mult (Mult_diff _ _ _ x y Refl) = let x' = mult'_imp_mult x; y' = mult'_imp_mult y in Mult_sub' x' y'\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111612,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Mult3 : Nat -> Type where\n  Mult_0 : Mult3 0\n  Mult_SSS : (n : Nat) -> Mult3 n -> Mult3 (S (S (S n)))\n  \ndata Mult3' : Nat -> Type where\n  Mult_30 : Mult3' 30\n  Mult_21 : Mult3' 21\n  Mult_sum : (n : Nat) -> (m : Nat) -> Mult3' n -> Mult3' m -> Mult3' (n + m)\n  Mult_diff : (l : Nat) -> (n : Nat) -> (m : Nat) -> Mult3' n -> Mult3' m -> l + n = m -> Mult3' l\n-}  \n\n%access export\n%default total\nmult9 : Mult3' 9\nmult9 = Mult_diff 9 21 30 Mult_21 Mult_30 Refl\nmult12 : Mult3' 12\nmult12 = Mult_diff 12 9 21 mult9 Mult_21 Refl\nmult3 : Mult3' 3\nmult3 = Mult_diff 3 9 12 mult9 mult12 Refl\n\nm3 : Mult3 3\nm3 = Mult_SSS 0 Mult_0\n\nmult_imp_mult' : {n : Nat} -> Mult3 n -> Mult3' n\nmult_imp_mult' Mult_0 = Mult_diff 0 30 30 Mult_30 Mult_30 Refl\nmult_imp_mult' (Mult_SSS Z Mult_0) = mult3\nmult_imp_mult' (Mult_SSS n prev) = Mult_sum 3 n mult3 (mult_imp_mult' prev)\n\n{- s3 : Nat -> Nat\ns3 n = S $ S $ S n\ns3p3 : {n: Nat} -> n+3 = s3 n\ns3p3 {n} = rewrite plusCommutative n 3 in Refl \n-}\ndec3 : {n: Nat} -> Mult3 (3 + n) -> Mult3 n\ndec3 (Mult_SSS n x) = x\n\nsub3 : {m, n: Nat} -> Mult3 m -> Mult3 n -> Mult3 (minus m n)\nsub3 Mult_0 Mult_0 = Mult_0\nsub3 Mult_0 m' = Mult_0\nsub3 (Mult_SSS k v) Mult_0 = (Mult_SSS k v)\nsub3 (Mult_SSS k n') (Mult_SSS q m') = sub3 n' m'\n\nadd3 : {n, m: Nat} -> Mult3 n -> Mult3 m -> Mult3 (n+m)\nadd3 {n} n' Mult_0 = rewrite plusZeroRightNeutral n in n'\nadd3 {n} n' (Mult_SSS k m1) = rewrite plusAssociative n 3 k in rewrite plusCommutative n 3 in add3 (Mult_SSS n n') m1\n\nm9 : Mult3 9\nm9 = Mult_SSS 6 (add3 m3 m3)\n\nm21 : Mult3 21\nm21 = Mult_SSS 18 (add3 m9 m9)\n\nminusp : {l, m, n: Nat} -> (l+n=m) -> l = (minus m n)\nminusp {l}{m}{n} p = rewrite sym $ plusZeroRightNeutral n in \n\trewrite sym $ minusZeroRight l in\n\t\trewrite sym $ plusMinusLeftCancel n l 0 in\n\t\t\trewrite plusCommutative n l  in cong {f=\\x=>minus x (plus n 0)} p\n\nmult'_imp_mult : {n : Nat} -> Mult3' n -> Mult3 n\nmult'_imp_mult (Mult_diff l n m n' m' p) = rewrite minusp {l}{m}{n} p in sub3 (mult'_imp_mult m') (mult'_imp_mult n')\nmult'_imp_mult (Mult_sum n m n' m') = add3 (mult'_imp_mult n') (mult'_imp_mult m')\nmult'_imp_mult Mult_21 = m21\nmult'_imp_mult Mult_30 = add3 m9 m21","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111613,"user_id":null,"body":"module Solution\n\nimport Preloaded\n{- Preloaded:\n\nmodule Preloaded\n\n%access public export\n%default total\n\ndata Mult3 : Nat -> Type where\n  Mult_0 : Mult3 0\n  Mult_SSS : (n : Nat) -> Mult3 n -> Mult3 (S (S (S n)))\n  \ndata Mult3' : Nat -> Type where\n  Mult_30 : Mult3' 30\n  Mult_21 : Mult3' 21\n  Mult_sum : (n : Nat) -> (m : Nat) -> Mult3' n -> Mult3' m -> Mult3' (n + m)\n  Mult_diff : (l : Nat) -> (n : Nat) -> (m : Nat) -> Mult3' n -> Mult3' m -> l + n = m -> Mult3' l\n-}  \n\n%access export\n%default total\n\nmult'_9 : Mult3' 9\nmult'_9 = Mult_diff 9 21 30 Mult_21 Mult_30 Refl\n\nmult'_12 : Mult3' 12\nmult'_12 = Mult_diff 12 9 21 mult'_9 Mult_21 Refl\n\nmult'_3 : Mult3' 3\nmult'_3 = Mult_diff 3 9 12 mult'_9 mult'_12 Refl\n\nmult'_0 : Mult3' 0\nmult'_0 = Mult_diff 0 30 30 Mult_30 Mult_30 Refl\n\nmult_imp_mult' : {n : Nat} -> Mult3 n -> Mult3' n\nmult_imp_mult' Mult_0 = mult'_0\nmult_imp_mult' (Mult_SSS n m) = Mult_sum 3 n mult'_3 (mult_imp_mult' m)\n\nmult3_inc : {n : Nat} -> Mult3 n -> Mult3 (S (S (S n)))\nmult3_inc {n} m = Mult_SSS n m\n\nmult_21 : Mult3 21\nmult_21 = mult3_inc . mult3_inc . mult3_inc . mult3_inc . mult3_inc . mult3_inc . mult3_inc $ Mult_0\n\nmult_30 : Mult3 30\nmult_30 = mult3_inc . mult3_inc . mult3_inc $ mult_21\n\nmult_add : {a, b : Nat} -> Mult3 a -> Mult3 b -> Mult3 (a + b)\nmult_add Mult_0 pb = pb\nmult_add (Mult_SSS a pa) Mult_0 = Mult_SSS (a + 0) (rewrite (plusZeroRightNeutral a) in pa)\nmult_add (Mult_SSS a pa) (Mult_SSS b pb) =\n  rewrite (sym (plusSuccRightSucc a (S (S b)))) in\n  rewrite (sym (plusSuccRightSucc a (S b))) in\n  rewrite (sym (plusSuccRightSucc a b)) in\n  mult3_inc . mult3_inc $ mult_add pa pb\n\ns_inj : {a, b : Nat} -> S a = S b -> a = b\ns_inj {a} {b} = succInjective a b\n\nmult_sub : {l, n, m : Nat} -> Mult3 n -> Mult3 m -> l + n = m -> Mult3 l\nmult_sub {l} {m} Mult_0 pm eqn = rewrite l_eq_m in pm\n  where\n    l_eq_m : l = m\n    l_eq_m = rewrite (sym (plusZeroRightNeutral l)) in eqn\nmult_sub {l} (Mult_SSS n pn) Mult_0 eqn = void (SIsNotZ eqn')\n  where\n    eqn' : S (l + S (S n)) = 0\n    eqn' = rewrite (plusSuccRightSucc l (S (S n))) in eqn\nmult_sub {l} (Mult_SSS n pn) (Mult_SSS m pm) eqn = mult_sub pn pm . s_inj . s_inj . s_inj $ rewrite (plusSuccRightSucc l n) in rewrite (plusSuccRightSucc l (S n)) in rewrite (plusSuccRightSucc l (S (S n))) in eqn\n\nmult'_imp_mult : {n : Nat} -> Mult3' n -> Mult3 n\nmult'_imp_mult Mult_30 = mult_30\nmult'_imp_mult Mult_21 = mult_21\nmult'_imp_mult (Mult_sum n m pn pm) = mult_add (mult'_imp_mult pn) (mult'_imp_mult pm)\nmult'_imp_mult (Mult_diff l n m pn pm eqn) = mult_sub (mult'_imp_mult pn) (mult'_imp_mult pm) eqn\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111614,"user_id":168,"body":"module Solution\n\nimport Preloaded\n\n-- Based on andersk's Agda solution\n\n%access export\n%default total\n\nmult_imp_mult' : {n : Nat} -> Mult3 n -> Mult3' n\nmult_imp_mult' Mult_0 = Mult_diff 0 30 30 Mult_30 Mult_30 Refl\nmult_imp_mult' (Mult_SSS n n3) = \n  Mult_sum 3 n\n    (Mult_diff 3 60 63\n      (Mult_sum 30 30 Mult_30 Mult_30)\n      (Mult_sum 21 42 Mult_21\n        (Mult_sum 21 21 Mult_21 Mult_21))\n      Refl)\n    (mult_imp_mult' n3)\n\nmult_sum : {n : Nat} -> {m : Nat} -> Mult3 n -> Mult3 m -> Mult3 (n + m)\nmult_sum Mult_0 m3 = m3\nmult_sum (Mult_SSS _ n3) m3 = Mult_SSS _ (mult_sum n3 m3)\n\nmult_diff : {l : Nat} -> {n : Nat} -> Mult3 n -> Mult3 (n + l) -> Mult3 l\nmult_diff Mult_0 h = h\nmult_diff (Mult_SSS _ n3) (Mult_SSS _ h) = mult_diff n3 h\n\nmult3 : (n : Nat) -> Mult3 (n * 3)\nmult3 Z = Mult_0\nmult3 (S n) = Mult_SSS (n * 3) (mult3 n)\n\nmult'_imp_mult : {n : Nat} -> Mult3' n -> Mult3 n\nmult'_imp_mult Mult_30 = mult3 10\nmult'_imp_mult Mult_21 = mult3 7\nmult'_imp_mult (Mult_sum _ _ n3 m3) = \n  mult_sum (mult'_imp_mult n3) (mult'_imp_mult m3)\nmult'_imp_mult (Mult_diff l n _ n3 m3 Refl) = \n  mult_diff (mult'_imp_mult n3) (rewrite plusCommutative n l in mult'_imp_mult m3)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5f3a44ecc856050001972c36":[{"id":111615,"user_id":168,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\npublic export \nproof1 : Peirce -> ExcludedMiddle\nproof1 p a = p _ Void (\\h => Right $ h . Left)\n\npublic export \nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 em a nna = either id (void . nna) (em a)\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 nna a b nab = nna a . flip nab\n\npublic export \nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 abs a b =\n  abs _ _ (\nab, h => h (nab . Left, nab . Right))\n  \npublic export \nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 nan a b ab = nan (Not a) b (\\(nna, nb) => nna $ nb . ab)\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 impl a b aba =\n  either (\na => aba $ void . na) id (impl a a id)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111616,"user_id":null,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\npublic export \nproof1 : Peirce -> ExcludedMiddle\nproof1 pierce a =\n    let appliedPierce = pierce (Either a (Not a)) Void\n        arg = \notEM => Right $ \\a => notEM (Left a)\n    in\n        appliedPierce arg\n\npublic export\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 excludedMiddle a notNotA =\n    case excludedMiddle a of\n        Left x => x\n        Right notA => void (notNotA notA)\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 doubleNegationElim a b notAImplNotB x =\n    let notNotA = flip notAImplNotB x\n    in\n        doubleNegationElim a notNotA\n\npublic export \nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 absurdity a b notAnd =\n    let\n        appliedAbsurdity =\n            absurdity (Either a b) ()\n        arg = \notEitherAB, _ => notAnd $ (notEitherAB . Left, notEitherAB . Right)\n    in\n        appliedAbsurdity arg ()\n\npublic export \nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 deMorgan a b aToB =\n    let appliedDeMorgan = deMorgan (a -> Void) b\n    in\n        appliedDeMorgan arg\n  where\n    arg : ((a -> Void) -> Void, (b -> Void)) -> Void\n    arg (notNotA, notB) = notNotA (notB . aToB)\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 impliesToOr a b aToBToA =\n    let appliedImpliesToOr = impliesToOr a a\n    in\n        case appliedImpliesToOr id of\n            Left notA =>\n                let aToB = \\a => void $ notA a\n                in\n                    aToBToA aToB\n            Right x => x\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111617,"user_id":null,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\n{- Idris2 original solution:\n\nClassicalContradiction : Type\nClassicalContradiction = \n    (a : Type) ->\n    (b : Type) ->\n    ((a -> Void) -> b) ->\n    ((a -> Void) -> (b -> Void)) ->\n    a\n\nA_DNE : Absurdity -> DoubleNegationElim\nA_DNE absurdity a notNotA =\n    let applied = absurdity a ((a -> Void) -> Void)\n        arg1 : (a -> Void) -> ((a -> Void) -> Void) -> Void\n        arg1 notA notNotA = notNotA notA\n    in\n        applied arg1 notNotA\n\nEM_DMAN : ExcludedMiddle -> DeMorganNotAndNot\nEM_DMAN em a b notANotB_Void =\n    case (em a, em b) of\n        ((Left prfA), _) => Left prfA\n        (_, (Left prfB)) => Right prfB\n        ((Right notA), (Right notB)) => void $ notANotB_Void (notA, notB)\n\nEM_ITO : ExcludedMiddle -> ImpliesToOr\nEM_ITO em a b aToB =\n    case em a of\n        Left prfA => Right (aToB prfA)\n        Right notA => Left notA\n\nDMAN_EM : DeMorganNotAndNot -> ExcludedMiddle\nDMAN_EM f a =\n    let arg : (a -> Void, (a -> Void) -> Void) -> Void\n        arg (notA, notNotA) = notNotA notA\n    in\n        f a (a -> Void) arg\n\nITO_EM : ImpliesToOr -> ExcludedMiddle\nITO_EM impliesToOr a = mirror $ impliesToOr a a id\n\nEM_P : ExcludedMiddle -> Peirce\nEM_P excludedMiddle a b aImplBToA =\n    case excludedMiddle a of\n        Left prfA => prfA\n        Right notA =>\n            let notAImplB = syllogism aImplBToA notA\n                aImplB : a -> b\n                aImplB a = void (notA a)\n            in  \n                void (notAImplB aImplB)\n  where\n    syllogism : (x -> y) -> (y -> z) -> x -> z\n    syllogism f g w = g (f w)\n\nP_DNE : Peirce -> DoubleNegationElim\nP_DNE pierce a notNotA =\n    let arg : (a -> Void) -> a\n        arg f = void $ notNotA f\n    in\n        pierce a Void arg\n\nDNE_CC : DoubleNegationElim -> ClassicalContradiction\nDNE_CC dn a b f1 f2 =\n    let notNotA : (a -> Void) -> Void\n        notNotA notA = f2 notA (f1 notA) \n    in\n        dn a notNotA\n\nCC_EM : ClassicalContradiction -> ExcludedMiddle\nCC_EM f a =\n    let \n        arg1 : (Either a (a -> Void) -> Void) -> (a -> Void)\n        arg1 notEM a = notEM (Left a)\n        arg2 : (Either a (a -> Void) -> Void) -> ((a -> Void) -> Void)\n        arg2 notEM notA = notEM (Right notA)\n    in\n    f (Either a (a -> Void)) (a -> Void) arg1 arg2\n\nDNE_EM : DoubleNegationElim -> ExcludedMiddle\nDNE_EM = CC_EM . DNE_CC\n\npublic export\nproof1 : Peirce -> ExcludedMiddle\nproof1 = DNE_EM . P_DNE\n\npublic export\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 excludedMiddle a notNotA =\n    case excludedMiddle a of\n        Left prf => prf\n        Right notA => void (notNotA notA)\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 doubleNegationElim a b notAImplNotB prfB =\n    let notNotA = flip notAImplNotB prfB in\n        doubleNegationElim a notNotA\n\npublic export\nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 absurdity = EM_DMAN $ DNE_EM $ A_DNE absurdity\n\npublic export\nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 = EM_ITO . DMAN_EM\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 = EM_P . ITO_EM\n-}\n\nClassicalContradiction : Type\nClassicalContradiction = \n    (a : Type) ->\n    (b : Type) ->\n    ((a -> Void) -> b) ->\n    ((a -> Void) -> (b -> Void)) ->\n    a\n\npublic export\nA_DNE : Absurdity -> DoubleNegationElim\nA_DNE absurdity a notNotA =\n    let applied = absurdity a ((a -> Void) -> Void)\n    in\n        applied arg1 notNotA\n  where\n    arg1 : (a -> Void) -> ((a -> Void) -> Void) -> Void\n    arg1 notA notNotA = notNotA notA\n\npublic export\nEM_DMAN : ExcludedMiddle -> DeMorganNotAndNot\nEM_DMAN em a b notANotB_Void =\n    case (em a, em b) of\n        ((Left prfA), _) => Left prfA\n        (_, (Left prfB)) => Right prfB\n        ((Right notA), (Right notB)) => void $ notANotB_Void (notA, notB)\n\npublic export\nEM_ITO : ExcludedMiddle -> ImpliesToOr\nEM_ITO em a b aToB =\n    case em a of\n        Left prfA => Right (aToB prfA)\n        Right notA => Left notA\n\npublic export\nDMAN_EM : DeMorganNotAndNot -> ExcludedMiddle\nDMAN_EM f a =\n    f a (a -> Void) arg\n  where\n    arg : (a -> Void, (a -> Void) -> Void) -> Void\n    arg (notA, notNotA) = notNotA notA\n\npublic export\nITO_EM : ImpliesToOr -> ExcludedMiddle\nITO_EM impliesToOr a = mirror $ impliesToOr a a id\n\npublic export\nEM_P : ExcludedMiddle -> Peirce\nEM_P excludedMiddle a b aImplBToA =\n    case excludedMiddle a of\n        Left prfA => prfA\n        Right notA =>\n            let notAImplB = syllogism aImplBToA notA\n                aImplB = \\a => void (notA a)\n            in  \n                void (notAImplB aImplB)\n  where\n    syllogism : (x -> y) -> (y -> z) -> x -> z\n    syllogism f g w = g (f w)\n\npublic export\nP_DNE : Peirce -> DoubleNegationElim\nP_DNE pierce a notNotA =\n    let \n--       arg : (a -> Void) -> a\n      arg = \\f => void (notNotA f)\n    in\n        pierce a Void arg\n\npublic export\nDNE_CC : DoubleNegationElim -> ClassicalContradiction\nDNE_CC dn a b f1 f2 =\n    let \n--         notNotA : (a -> Void) -> Void\n        notNotA = \notA => f2 notA (f1 notA) \n    in\n        dn a notNotA\n\npublic export\nCC_EM : ClassicalContradiction -> ExcludedMiddle\nCC_EM f a =\n    let \n--         arg1 : (Either a (a -> Void) -> Void) -> (a -> Void)\n        arg1 = \notEM, a => notEM (Left a)\n--         arg2 : (Either a (a -> Void) -> Void) -> ((a -> Void) -> Void)\n        arg2 = \notEM, notA => notEM (Right notA)\n    in\n    f (Either a (a -> Void)) (a -> Void) arg1 arg2\n\npublic export\nDNE_EM : DoubleNegationElim -> ExcludedMiddle\nDNE_EM = CC_EM . DNE_CC\n\npublic export\nproof1 : Peirce -> ExcludedMiddle\nproof1 = DNE_EM . P_DNE\n\npublic export\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 excludedMiddle a notNotA =\n    case excludedMiddle a of\n        Left prf => prf\n        Right notA => void (notNotA notA)\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 doubleNegationElim a b notAImplNotB prfB =\n    let notNotA = flip notAImplNotB prfB in\n        doubleNegationElim a notNotA\n\npublic export\nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 absurdity = EM_DMAN $ DNE_EM $ A_DNE absurdity\n\npublic export\nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 = EM_ITO . DMAN_EM\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 = EM_P . ITO_EM","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111618,"user_id":null,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\npublic export \nproof1 : Peirce -> ExcludedMiddle\nproof1 p a = let f = p (Either a (Not a)) Void\n             in f $ \\g => Right $ \\x => g $ Left x\n\n\npublic export \nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 em a = f $ em a\n    where\n      f : Either a (a -> Void) -> (((a -> Void) -> Void) -> a)\n      f (Left l) = \\x => l\n      f (Right r) = \\x => void $ x r\n\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 dne a b f c = dne a $ \\x => f x c\n\npublic export \nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 ab a b c = let f = ab (Either a b) ((a -> Void, b -> Void) -> Void)\n                      g = f $ void . c . prop\n                  in g c\n    where\n      prop : (Either a b -> Void) -> (a -> Void, b -> Void)\n      prop f = (f . Left, f . Right)\n\npublic export \nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 dm a b f = dm (a -> Void) b $ \\(x, y) => void $ x $ y . f\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 f a b g = let x = f (a -> b) a $ g\n                     y = f a a $ id\n                 in prop x y\n      where\n        prop : (Either ((a -> b) -> Void) a) -> Either (a -> Void) a -> a\n        prop (Left l) (Left x) = g $ void {a = b} . x\n        prop (Left l) (Right r) = r\n        prop (Right r) y = r\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111619,"user_id":106,"body":"module Peirce\n\nimport Preloaded\n\n%access export\n%default total\n\npublic export\nproof1 : Peirce -> ExcludedMiddle\nproof1 fn _ = fn _ _ (\\f => void ((f . Right) (f . Left)))\n\npublic export\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 fn _ ff = either id (void . ff) (fn _)\n\npublic export\nproof3 : DoubleNegationElim -> Absurdity\nproof3 fn _ _ fab = (fn _) . (flip fab)\n\npublic export\nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 fn _ _ nn = fn _ _ (\\v,w => w (v . Left, v . Right)) nn\n\npublic export\nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 fn _ _ f = fn _ _ (\\(pa,pb) => pa (pb . f))\n\npublic export\nproof6 : ImpliesToOr -> Peirce\nproof6 fn _ _ f = either (f . (void .)) id (fn _ _ id)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111620,"user_id":106,"body":"module Peirce\n\nimport Preloaded\n\n%access export\n%default total\n\npublic export\nproof1 : Peirce -> ExcludedMiddle\nproof1 fn ta = fn (Either ta (Not ta)) Void (\\f => void ((f . Right) (f . Left)))\n\npublic export\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 fn ta ff = either id (void . ff) (fn ta)\n\npublic export\nproof3 : DoubleNegationElim -> Absurdity\nproof3 fn ta tb fab b = fn ta ((\\v => v b) . fab)\n\npublic export\nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 fn ta tb nn = fn (Either ta tb) (Not (Not ta, Not tb)) (\\v,w => w (v . Left, v . Right)) nn\n\npublic export\nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 fn ta tb f = fn (Not ta) tb (\\(pa,pb) => pa (pb . f))\n\npublic export\nproof6 : ImpliesToOr -> Peirce\nproof6 fn ta tb f = either (f . (void .)) id (fn ta ta id)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111621,"user_id":null,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\n-- Unlike ImpliesToOr, inverse statement is constructive:\norToImplies : (a : Type) -> (b : Type) -> Either (Not a) b -> a -> b\norToImplies a b (Left f) y = absurd (f y) \norToImplies a b (Right x) y = x\n\n-- Inverse De Morgan is also constructive\ndeMorganOr : (a : Type) -> (b : Type) -> (Either a b -> Void) -> (a -> Void, b -> Void) \ndeMorganOr a b f = (\\x => f (Left x), \\x => f (Right x))\n\n%default total\n\nmagic : (a : Type) -> (Either a (Not a) -> Void) -> Either a (Not a)\nmagic a f = absurd (f $ Right left) where\n  left : a -> Void\n  left x = f $ Left x\n\nproof1 : Peirce -> ExcludedMiddle\nproof1 f a = f (Either a (Not a)) Void (magic a) \n\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 f a g = case f a of\n                    (Left x) => x\n                    (Right x) => absurd (g x) \n\nproof3 : DoubleNegationElim -> Absurdity\nproof3 f a b g x = f a (\\t => g t x) \n\nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 f a b g = f (Either a b) ((a -> Void, b -> Void) -> Void) (\\p, q => q (deMorganOr a b p)) g\n\nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 f a b g = f (Not a) b (\\(fa, fb) => fa (fb . g))\n\nlemma1 : ImpliesToOr -> ExcludedMiddle \nlemma1 f a = case f a a id of\n                  (Left x) => Right x \n                  (Right x) => Left x \n\nlemma2 : ImpliesToOr -> DoubleNegationElim\nlemma2 = proof2 . lemma1 \n\nproof6 : ImpliesToOr -> Peirce\nproof6 f a b g = let dn = lemma2 f \n                     in case f (a -> b) a g of\n                              (Left h) => (dn a . fst) $ deMorganOr (a -> Void) b (h . (orToImplies a b))\n                              (Right x) => x\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111622,"user_id":null,"body":"module Peirce\n\nimport Preloaded\n\n%access export\n%default total\n\npublic export\npeirce_to_dne : Peirce -> DoubleNegationElim\npeirce_to_dne peirce a not_not_a = peirce _ Void (\not_a => void (not_not_a not_a))\n\npublic export\nem_to_peirce : ExcludedMiddle -> Peirce\nem_to_peirce em a b f = either id (\not_a => f (\\ha => void (not_a ha))) (em a)\n\npublic export\nem_to_demorgan : ExcludedMiddle -> DeMorganNotAndNot\nem_to_demorgan em a b h =\n  either Left (\not_a => either Right (\not_b => void (h (not_a, not_b))) (em b)) (em a)\n\npublic export\nem_to_impldef : ExcludedMiddle -> ImpliesToOr\nem_to_impldef em a b f = either (Right . f) Left (em a)\n\npublic export\ndne_to_em : DoubleNegationElim -> ExcludedMiddle\ndne_to_em dne a = dne (Either a (Not a)) (\\h => h (Right (h . Left)))\n\npublic export\nabsurd_to_dne : Absurdity -> DoubleNegationElim\nabsurd_to_dne absurd a = absurd a (Not (Not a)) (\not_a => \not_not_a => not_not_a not_a)\n\npublic export\ndemorgan_to_em : DeMorganNotAndNot -> ExcludedMiddle\ndemorgan_to_em demorgan a = demorgan a (Not a) (\\(ha, not_a) => void (not_a ha))\n\npublic export\nimpldef_to_em : ImpliesToOr -> ExcludedMiddle\nimpldef_to_em impldef a = either Right Left (impldef _ _ id)\n\n\n\npublic export\nproof1 : Peirce -> ExcludedMiddle\nproof1 = dne_to_em . peirce_to_dne\n\npublic export\nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 em a not_not_a =\n  case em a of\n    Left ha => ha\n    Right not_a => void (not_not_a not_a)\n\npublic export\nproof3 : DoubleNegationElim -> Absurdity\nproof3 dne a b f hb = dne a (\not_a => f not_a hb)\n\npublic export\nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 = em_to_demorgan . dne_to_em . absurd_to_dne\n\npublic export\nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 = em_to_impldef . demorgan_to_em\n\npublic export\nproof6 : ImpliesToOr -> Peirce\nproof6 = em_to_peirce . impldef_to_em\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111623,"user_id":17,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\npublic export \nproof1 : Peirce -> ExcludedMiddle\nproof1 peirce a = peirce (Either a (Not a)) Void (\\hNexmid =>\n  Right (\\hA => hNexmid (Left hA)))\n\npublic export \nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 exmid a hNNA = case exmid a of\n  Left hA => hA\n  Right hNA => absurd (hNNA hNA)\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 dne a b hNANB hB = dne a (\\hNA => hNANB hNA hB)\n\npublic export \nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 absurdity a b hNNANB = absurdity (Either a b) (Not (Not a, Not b))\n  (\\hNAB, hNNANB2 => hNNANB (\\hA => hNAB (Left hA), (\\hB => hNAB (Right hB))))\n  hNNANB\n\npublic export \nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 demorgan a b hAB = demorgan (Not a) b (\\(hNNA, hNB) => hNNA\n  (\\hA => hNB (hAB hA)))\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 ito a b hABA = case ito a a (\\x => x) of\n  Left hNA => hABA (\\hA => absurd (hNA hA))\n  Right hA => hA","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111624,"user_id":null,"body":"module Peirce\n\nimport Preloaded\n\n%access export \n%default total\n\npublic export\nirEm : (a : Type) -> Not (Not (Either a (Not a)))\nirEm a nem = nem (Right $ (\\x => nem (Left x)))\n\npublic export \nEmPeirce : ExcludedMiddle -> Peirce\nEmPeirce em a b p with (em a)\n  EmPeirce em a b p | (Left l) = l\n  EmPeirce em a b p | (Right r) = p (\\a' => void $ r a')\n\npublic export\nPeirceEm : Peirce -> ExcludedMiddle\nPeirceEm peirce a = peirce (a `Either` Not a) Void (\nem => void $ irEm a nem)\n\npublic export \nDneEm : DoubleNegationElim -> ExcludedMiddle\nDneEm nna a = nna (a `Either` Not a) (irEm a)\n\npublic export \nEmDne : ExcludedMiddle -> DoubleNegationElim\nEmDne em a nna with (em a)\n  EmDne em a nna | (Left l) = l\n  EmDne em a nna | (Right r) = void $ nna r\n\npublic export\nEmAbsurdity : ExcludedMiddle -> Absurdity\nEmAbsurdity em a b p y with (em a)\n  EmAbsurdity em a b p y | (Left pa) = pa\n  EmAbsurdity em a b p y | (Right npa) = void $ p npa y\n\npublic export\nAbsurdityEm : Absurdity -> ExcludedMiddle\nAbsurdityEm absurdity a = absurdity (a `Either` Not a) () (\nem=>\\_=>irEm a nem) ()\n\npublic export\nDeMEm : DeMorganNotAndNot -> ExcludedMiddle\nDeMEm deMorgan a = deMorgan a (Not a) (\\(x,y)=> y x)\n\npublic export\nEmDeM : ExcludedMiddle -> DeMorganNotAndNot\nEmDeM em a b nnab with (em a)\n  EmDeM em a b nnab | (Left l) = Left l\n  EmDeM em a b nnab | (Right r) with (em b)\n    EmDeM em a b nnab | (Right r) | (Left l) = Right l\n    EmDeM em a b nnab | (Right r) | (Right r') = void $ nnab (r, r')\n\npublic export\nImpEx : ImpliesToOr -> ExcludedMiddle\nImpEx imp a = mirror $ imp a a id\n\npublic export\nExImp : ExcludedMiddle -> ImpliesToOr\nExImp em a b ab with (em a)\n  ExImp em a b ab | (Left l) = Right $ ab l\n  ExImp em a b ab | (Right r) = Left r\n\n------------------------------------------------------------\n\npublic export \nproof1 : Peirce -> ExcludedMiddle\nproof1 = PeirceEm\n\npublic export \nproof2 : ExcludedMiddle -> DoubleNegationElim\nproof2 = EmDne\n\npublic export \nproof3 : DoubleNegationElim -> Absurdity\nproof3 = EmAbsurdity . DneEm\n\npublic export \nproof4 : Absurdity -> DeMorganNotAndNot\nproof4 = EmDeM . AbsurdityEm\n\npublic export \nproof5 : DeMorganNotAndNot -> ImpliesToOr\nproof5 = ExImp . DeMEm\n\npublic export \nproof6 : ImpliesToOr -> Peirce\nproof6 = EmPeirce . ImpEx\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"599d973255342a0ce400009b":[{"id":111625,"user_id":489,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd m = oddPlusOne m\noddPlusOdd (NextOdd n) m = NextEven $ oddPlusOdd n m\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven m = m\nevenPlusOdd (NextEven n) m = NextOdd $ evenPlusOdd n m\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven OneOdd m = evenPlusOne m\noddPlusEven (NextOdd n) m = NextOdd $ oddPlusEven n m\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven m = ZeroEven\nevenTimesEven (NextEven n) m = evenPlusEven m $ evenPlusEven m $ evenTimesEven n m\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd OneOdd m = oddPlusEven m ZeroEven\noddTimesOdd (NextOdd n) m = oddPlusEven m $ oddPlusOdd m $ oddTimesOdd n m\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven m = ZeroEven\nevenTimesOdd (NextEven n) m = oddPlusOdd m $ oddPlusEven m $ evenTimesOdd n m\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven OneOdd m = evenPlusEven m ZeroEven\noddTimesEven (NextOdd n) m = evenPlusEven m $ evenPlusEven m $ oddTimesEven n m\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111626,"user_id":168,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd m = oddPlusOne m\noddPlusOdd (NextOdd n) m = NextEven (oddPlusOdd n m)\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven m = m\nevenPlusOdd (NextEven n) m = NextOdd (evenPlusOdd n m)\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven {n} {m} a b = rewrite plusCommutative n m in evenPlusOdd b a\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven b = ZeroEven\nevenTimesEven (NextEven a) b = \n    let ih = evenTimesEven a b in\n    evenPlusEven b $ evenPlusEven b ih\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd {m} OneOdd b = rewrite plusCommutative m 0 in b\noddTimesOdd (NextOdd a) b = \n    let ih = oddTimesOdd a b in\n    oddPlusEven b $ oddPlusOdd b ih\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven b = ZeroEven\nevenTimesOdd (NextEven a) b = \n    let ih = evenTimesOdd a b in\n    oddPlusOdd b $ oddPlusEven b ih\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven {n} {m} a b = rewrite multCommutative n m in evenTimesOdd b a","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111627,"user_id":29,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd m = oddPlusOne m\noddPlusOdd (NextOdd n) m = NextEven $ oddPlusOdd n m\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven m = m\nevenPlusOdd (NextEven n) m = NextOdd $ evenPlusOdd n m\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven OneOdd m = evenPlusOne m\noddPlusEven (NextOdd n) m = NextOdd $ oddPlusEven n m\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven m = ZeroEven\nevenTimesEven (NextEven n) m = evenPlusEven m (evenPlusEven m (evenTimesEven n m))\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd OneOdd OneOdd = OneOdd\noddTimesOdd OneOdd (NextOdd m) = evenPlusOne (oddPlusOne (oddTimesOdd OneOdd m))\noddTimesOdd (NextOdd n) m = oddPlusEven m (oddPlusOdd m (oddTimesOdd n m))\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven m = ZeroEven\nevenTimesOdd (NextEven n) m = oddPlusOdd m (oddPlusEven m (evenTimesOdd n m))\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven OneOdd ZeroEven = ZeroEven\noddTimesEven OneOdd (NextEven m) = oddPlusOne (evenPlusOne (oddTimesEven OneOdd m))\noddTimesEven (NextOdd n) m = evenPlusEven m (evenPlusEven m (oddTimesEven n m))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111628,"user_id":null,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n    -- | Zero is even.\n    ZeroEven : Even Z\n    -- | If n is even, then n+2 is even.\n    NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n    -- | One is odd.\n    OneOdd : Odd (S Z)\n    -- | If n is odd, then n+2 is odd.\n    NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves that if n+1 id odd, n is even\noddMinusOne : Odd (S n) -> Even n\noddMinusOne OneOdd = ZeroEven\noddMinusOne (NextOdd x) = oddPlusOne x \n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : {n, m : Nat} -> Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd y = oddPlusOne y\noddPlusOdd (NextOdd x) y = NextEven (oddPlusOdd x y)\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven y = y\nevenPlusOdd (NextEven x) y = NextOdd (evenPlusOdd x y)\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven OneOdd y = evenPlusOne y \noddPlusEven (NextOdd x) y = NextOdd (oddPlusEven x y)\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven y = ZeroEven\nevenTimesEven (NextEven x) y = evenPlusEven y $ evenPlusEven y (evenTimesEven x y) \n\n-- | Proves odd * odd = odd\noddTimesOdd : {n, m : Nat} -> Odd n -> Odd m -> Odd (n * m)\noddTimesOdd {m} OneOdd y = rewrite plusZeroRightNeutral m in y\noddTimesOdd (NextOdd x) y = oddPlusEven y $ oddPlusOdd y (oddTimesOdd x y)\n\n-- | Proves even * odd = even\nevenTimesOdd : {n, m : Nat} -> Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven y = ZeroEven\nevenTimesOdd (NextEven x) y = oddPlusOdd y $ oddPlusEven y (evenTimesOdd x y)\n\n-- | Proves odd * even = even\noddTimesEven : {n, m : Nat} -> Odd n -> Even m -> Even (n * m)\noddTimesEven {n} {m} x y = rewrite multCommutative n m in evenTimesOdd y x \n\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111629,"user_id":null,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd oddB = oddPlusOne oddB\noddPlusOdd (NextOdd oddA) oddB = NextEven $ oddPlusOdd oddA oddB\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven odd = odd\nevenPlusOdd (NextEven even) odd = NextOdd $ evenPlusOdd even odd\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven {n} {m} = rewrite plusCommutative n m in flip evenPlusOdd\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven _ = ZeroEven\nevenTimesEven (NextEven left) right = right `evenPlusEven` (right `evenPlusEven` evenTimesEven left right)\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd {m} OneOdd right = rewrite plusZeroRightNeutral m in right\noddTimesOdd (NextOdd left) right = right `oddPlusEven` (right `oddPlusOdd` oddTimesOdd left right)\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven _ = ZeroEven\nevenTimesOdd (NextEven left) right = right `oddPlusOdd` (right `oddPlusEven` evenTimesOdd left right)\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven {n} {m} = rewrite multCommutative n m in flip evenTimesOdd\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111630,"user_id":null,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd n      = oddPlusOne n\noddPlusOdd (NextOdd n) m = NextEven (oddPlusOdd n m)\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven m   = m\nevenPlusOdd (NextEven n) m = NextOdd (evenPlusOdd n m) \n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven OneOdd m = evenPlusOne m\noddPlusEven (NextOdd n) m = NextOdd (oddPlusEven n m)\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven m = ZeroEven \nevenTimesEven (NextEven m) n = n `evenPlusEven` (n `evenPlusEven` (evenTimesEven m n))\n\noddTimesOne : Odd n -> Odd (1 * n)\noddTimesOne OneOdd = OneOdd\noddTimesOne n = oddPlusEven n ZeroEven \n\nevenTimesOne : Even n -> Even (1 * n)\nevenTimesOne ZeroEven = ZeroEven\nevenTimesOne n = evenPlusEven n ZeroEven \n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd  OneOdd     j = oddTimesOne j\noddTimesOdd (NextOdd m) n =  n `oddPlusEven` (n `oddPlusOdd` (oddTimesOdd m n))\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven n = ZeroEven \nevenTimesOdd (NextEven m) n =  (n `oddPlusOdd` (n `oddPlusEven` (evenTimesOdd m n)))\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven OneOdd j = evenTimesOne j \noddTimesEven (NextOdd n) m =  m `evenPlusEven` (m `evenPlusEven` (oddTimesEven n m))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111631,"user_id":null,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd  OneOdd     y = oddPlusOne y\noddPlusOdd (NextOdd x) y = NextEven $ oddPlusOdd x y\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd  ZeroEven    m = m\nevenPlusOdd (NextEven n) m = NextOdd $ evenPlusOdd n m\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven  OneOdd     m = evenPlusOne m\noddPlusEven (NextOdd n) m = NextOdd $ oddPlusEven n m\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven  ZeroEven    m = ZeroEven\nevenTimesEven (NextEven n) m = evenPlusEven m $ evenPlusEven m $ evenTimesEven n m\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd  OneOdd     m = oddPlusEven m ZeroEven\noddTimesOdd (NextOdd n) m = oddPlusEven m $ oddPlusOdd m $ oddTimesOdd n m\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd  ZeroEven    m = ZeroEven\nevenTimesOdd (NextEven n) m = oddPlusOdd m $ oddPlusEven m $ evenTimesOdd n m\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven  OneOdd     m = evenPlusEven m ZeroEven\noddTimesEven (NextOdd n) m = evenPlusEven m $ evenPlusEven m $ oddTimesEven n m\n\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111632,"user_id":null,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd y = oddPlusOne y\noddPlusOdd (NextOdd x) y = NextEven $ oddPlusOdd x y\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven y = y\nevenPlusOdd (NextEven x) y = NextOdd $ evenPlusOdd x y\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven OneOdd y = evenPlusOne y\noddPlusEven (NextOdd x) y = NextOdd $ oddPlusEven x y\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven y = ZeroEven\nevenTimesEven (NextEven x) y = evenPlusEven y $ evenPlusEven y $ evenTimesEven x y\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd {m} OneOdd y = rewrite plusZeroRightNeutral m in y\noddTimesOdd (NextOdd x) y = oddPlusEven y $ oddPlusOdd y $ oddTimesOdd x y\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven y = ZeroEven\nevenTimesOdd (NextEven x) y = oddPlusOdd y $ oddPlusEven y $ evenTimesOdd x y\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven {m} OneOdd y = rewrite plusZeroRightNeutral m in y\noddTimesEven (NextOdd x) y = evenPlusEven y $ evenPlusEven y $ oddTimesEven x y","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111633,"user_id":53,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd  OneOdd       m = oddPlusOne m\noddPlusOdd (NextOdd  n)  m = NextEven $ oddPlusOdd n m\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd  ZeroEven     m = m\nevenPlusOdd (NextEven  n) m = NextOdd  $ evenPlusOdd n m\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven  OneOdd       m = evenPlusOne m\noddPlusEven (NextOdd   n) m = NextOdd  $ oddPlusEven n m\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven n = ZeroEven\nevenTimesEven (NextEven m) n = evenPlusEven n $ evenPlusEven n (evenTimesEven m n)\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd OneOdd n = oddPlusEven n ZeroEven\noddTimesOdd (NextOdd m) n = oddPlusEven n $ oddPlusOdd n (oddTimesOdd m n) \n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven n = ZeroEven\nevenTimesOdd (NextEven m) n = oddPlusOdd n $ oddPlusEven n (evenTimesOdd m n)\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven OneOdd n = evenPlusEven n ZeroEven\noddTimesEven (NextOdd m) n = evenPlusEven n $ evenPlusEven n (oddTimesEven m n)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111634,"user_id":null,"body":"module OddAndEvens\n\n%access export\n%default total\n\npublic export\ndata Even : Nat -> Type where\n  -- | Zero is even.\n  ZeroEven : Even Z\n  -- | If n is even, then n+2 is even.\n  NextEven : Even n -> Even (S (S n))\n\npublic export\ndata Odd : Nat -> Type where\n  -- | One is odd.\n  OneOdd : Odd (S Z)\n  -- | If n is odd, then n+2 is odd.\n  NextOdd : Odd n -> Odd (S (S n))\n\n-- | Proves that if n is even, n+1 is odd.\n-- Notice how I use the axioms here.\nevenPlusOne : Even n -> Odd (S n)\nevenPlusOne  ZeroEven    = OneOdd\nevenPlusOne (NextEven n) = NextOdd $ evenPlusOne n\n\n-- | Proves that if n is odd, n+1 is even.\noddPlusOne : Odd n -> Even (S n)\noddPlusOne  OneOdd     = NextEven $ ZeroEven\noddPlusOne (NextOdd n) = NextEven $ oddPlusOne n\n\n-- | Proves even + even = even\nevenPlusEven : Even n -> Even m -> Even (n + m)\nevenPlusEven  ZeroEven    m = m\nevenPlusEven (NextEven n) m = NextEven $ evenPlusEven n m\n\n-- | Proves odd + odd = even\noddPlusOdd : Odd n -> Odd m -> Even (n + m)\noddPlusOdd OneOdd OneOdd = NextEven ZeroEven\noddPlusOdd OneOdd (NextOdd m) = NextEven $ oddPlusOne m\noddPlusOdd (NextOdd n) m = NextEven $ oddPlusOdd n m\n\n-- | Proves even + odd = odd\nevenPlusOdd : Even n -> Odd m -> Odd (n + m)\nevenPlusOdd ZeroEven m = m\nevenPlusOdd (NextEven n) m = NextOdd $ evenPlusOdd n m\n\n-- | Proves odd + even = odd\noddPlusEven : Odd n -> Even m -> Odd (n + m)\noddPlusEven OneOdd m = evenPlusOne m\noddPlusEven (NextOdd n) m = NextOdd $ oddPlusEven n m\n\noneTimesEven : Even n -> Even n\noneTimesEven ZeroEven = ZeroEven\noneTimesEven (NextEven n) = NextEven $ oneTimesEven n\n\n-- | Proves even * even = even\nevenTimesEven : Even n -> Even m -> Even (n * m)\nevenTimesEven ZeroEven _ = ZeroEven\nevenTimesEven (NextEven n) m = evenPlusEven m (evenPlusEven m (evenTimesEven n m))\n\n-- | Proves odd * odd = odd\noddTimesOdd : Odd n -> Odd m -> Odd (n * m)\noddTimesOdd OneOdd m = oddPlusEven m ZeroEven\noddTimesOdd (NextOdd n) m = oddPlusEven m (oddPlusOdd m (oddTimesOdd n m))\n\n-- | Proves even * odd = even\nevenTimesOdd : Even n -> Odd m -> Even (n * m)\nevenTimesOdd ZeroEven _ = ZeroEven\nevenTimesOdd (NextEven n) m = oddPlusOdd m (oddPlusEven m (evenTimesOdd n m))\n\n\n-- | Proves odd * even = even\noddTimesEven : Odd n -> Even m -> Even (n * m)\noddTimesEven OneOdd m = evenPlusEven m ZeroEven\noddTimesEven (NextOdd n) m = evenPlusEven m (evenPlusEven m (oddTimesEven n m))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c7fe5c859036f142eccaabb":[{"id":111635,"user_id":null,"body":"module Sprintf\n\n%access export\n%default total\n\npublic export\nstrToSty : (curr : String) -> (str : List Char) -> (t : Type ** t)\nstrToSty c []             = (_ ** c)\nstrToSty c ('%'::'%'::ks) = strToSty (c ++ \"%\") ks\nstrToSty c ('%'::'d'::ks) = (_ ** \n : Integer => snd $ strToSty (c ++ show n) ks)\nstrToSty c ('%'::'f'::ks) = (_ ** \\x : Double  => snd $ strToSty (c ++ show x) ks)\nstrToSty c ('%'::'c'::ks) = (_ ** \\k : Char    => snd $ strToSty (c ++ singleton k) ks)\nstrToSty c ('%':: ks)     = (_ ** \\v : Void    => snd $ strToSty c ks)\nstrToSty c ( k :: ks)     = strToSty (c ++ singleton k) ks\n\nsprintf : (str : String) -> fst (strToSty \"\" $ unpack str) \nsprintf str = snd (strToSty \"\" $ unpack str)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111636,"user_id":null,"body":"module Sprintf\n\n%access public export\n-- %default total\n\nsprintfType : List Char -> Type\nsprintfType [] = String\nsprintfType ('%'::'d'::xs) = Integer -> sprintfType xs\nsprintfType ('%'::'f'::xs) = Double -> sprintfType xs\nsprintfType ('%'::'c'::xs) = Char -> sprintfType xs\nsprintfType ('%'::'%'::xs) = sprintfType xs\nsprintfType (_::xs) = sprintfType xs\n\nnextSameType : (x: Char)\n            -> (xs: List Char)\n--             -> ((x = '%') -> Void)\n            -> sprintfType (x :: xs) = sprintfType xs\nnextSameType = nextSameType\n\nsprintf : (fmt: String) -> sprintfType (unpack fmt)\nsprintf f = go \"\" (unpack f)\n  where\n    go : String -> (fmt: List Char) -> sprintfType fmt\n    go buf [] = buf\n    go buf ('%'::'d'::xs) = \\d => go (buf <+> show d) xs\n    go buf ('%'::'f'::xs) = \\f => go (buf <+> show f) xs\n    go buf ('%'::'c'::xs) = \\c => go (buf <+> singleton c) xs\n    go buf ('%'::'%'::xs) = go (buf <+> \"%\") xs\n    go buf (x::xs) = rewrite (nextSameType x xs) in go (buf <+> singleton x) xs","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111637,"user_id":null,"body":"module Sprintf\n\n%access export\n%default total\n\npublic export\ndata Format\n  = FInt Format\n  | FDouble Format\n  | FChar Format\n  | FOther Char Format\n  | FEnd\n\n-- Parse format string into Abstract Syntax Tree\npublic export\nformat : List Char -> Format\nformat [] = FEnd\nformat ('%'::'d'::xs) = FInt (format xs)\nformat ('%'::'f'::xs) = FDouble (format xs)\nformat ('%'::'c'::xs) = FChar (format xs) \nformat ('%'::'%'::xs) = FOther '%' (format xs) \nformat (x :: xs) = FOther x (format xs)  \n\n-- Turn AST into corresponding printer type\npublic export\nformatType : Format -> Type\nformatType (FInt x) = Integer -> formatType x\nformatType (FDouble x) = Double -> formatType x\nformatType (FChar x) = Char -> formatType x\nformatType (FOther x y) = formatType y\nformatType FEnd = String \n\npublic export\nshow' : Show a => (x : a) -> List Char\nshow' = unpack . show\n\npublic export\nformatToFunction : (fmt : Format) -> List Char -> formatType fmt\nformatToFunction (FInt y) x = \\i => formatToFunction y (x ++ show' i)\nformatToFunction (FDouble y) x = \\f => formatToFunction y (x ++ show' f)\nformatToFunction (FChar y) x = \\c => formatToFunction y (x ++ [c])\nformatToFunction (FOther y z) x = formatToFunction z (x ++ [y])\nformatToFunction FEnd x = pack x\n\npublic export\nsprintf' : (template : List Char) -> formatType (format template)\nsprintf' template = formatToFunction (format template) []\n\npublic export\nsprintf : (template : String) -> formatType (format (unpack template))\nsprintf str = sprintf' (unpack str) \n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111638,"user_id":null,"body":"module Sprintf\n\n%access public export\n%default total\n\ndata Format\n    = PercentSign Format\n    | Num Format\n    | Dbl Format\n    | Chr Format\n    | Lit String Format\n    | End\n\nPrintfType : Format -> Type\nPrintfType (PercentSign fmt) = PrintfType fmt\nPrintfType (Num fmt) = (i : Integer) -> PrintfType fmt\nPrintfType (Dbl fmt) = (d : Double) -> PrintfType fmt\nPrintfType (Chr fmt) = (c : Char) -> PrintfType fmt\nPrintfType (Lit _ fmt) = PrintfType fmt\nPrintfType End = String\n\nformat : (fmt : Format) -> (acc : String) -> PrintfType fmt\nformat (PercentSign fmt) acc = format fmt (acc ++ \"%\")\nformat (Num fmt) acc = \\i => format fmt (acc ++ show i)\nformat (Dbl fmt) acc = \\d => format fmt (acc ++ show d)\nformat (Chr fmt) acc = \\c => format fmt (acc ++ cast c)\nformat (Lit str fmt) acc = format fmt (acc ++ str)\nformat End acc = acc\n\nparseFormat : String -> Format\nparseFormat = go . unpack where\n    go : List Char -> Format\n    go [] = End\n    go ('%' :: '%' :: cs) = PercentSign $ go cs\n    go ('%' :: 'd' :: cs) = Num $ go cs\n    go ('%' :: 'c' :: cs) = Chr $ go cs\n    go ('%' :: 'f' :: cs) = Dbl $ go cs\n    go (c :: cs) = case go cs of\n        Lit lit cs' => Lit (c `strCons` lit) cs'\n        fmt => Lit (cast c) fmt\n\nsprintf : (fmt : String) -> PrintfType (parseFormat fmt)\nsprintf fmt = format _ \"\"","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111639,"user_id":null,"body":"module Sprintf\n\n%access export\n%default total\n\ndata Format \n    = FChar \n    | FDouble\n    | FInteger \n    | FLit Char\n\npublic export\ngetFormat : String -> List Format \ngetFormat = \n        getFormat . unpack\n    where \n        getFormat : List Char -> List Format \n        getFormat ('%' :: '%' :: tl) = FLit '%'   :: (getFormat tl)\n        getFormat ('%' :: 'd' :: tl) = FInteger   :: (getFormat tl)\n        getFormat ('%' :: 'f' :: tl) = FDouble    :: (getFormat tl)\n        getFormat ('%' :: 'c' :: tl) = FChar      :: (getFormat tl)\n        getFormat (other :: tl)      = FLit other :: (getFormat tl)\n        getFormat [] = []\n\npublic export\ngenTypeOfFormat : List Format -> Type \ngenTypeOfFormat (FInteger :: tl) = Integer -> (genTypeOfFormat tl)\ngenTypeOfFormat (FChar :: tl)    = Char -> (genTypeOfFormat tl)\ngenTypeOfFormat (FDouble :: tl)  = Double -> (genTypeOfFormat tl)\ngenTypeOfFormat (FLit n :: tl)  = genTypeOfFormat tl\ngenTypeOfFormat [] = String\n\npublic export\ngenType : String -> Type\ngenType = genTypeOfFormat . getFormat\n\npublic export\nformatToString : (s : List Format) -> String -> (genTypeOfFormat s)\nformatToString (FLit n :: tl)   acc = formatToString tl (acc ++ (pack [n]))\nformatToString (FInteger :: tl) acc = \\d => formatToString tl (acc ++ show d)\nformatToString (FChar :: tl)    acc = \\d => formatToString tl (acc ++ (pack [d]))\nformatToString (FDouble :: tl)  acc = \\d => formatToString tl (acc ++ show d)\nformatToString [] a = a\n\npublic export\nsprintf : (s : String) -> (genTypeOfFormat (getFormat s))\nsprintf s = formatToString (getFormat s) \"\"","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111640,"user_id":null,"body":"module Sprintf\n\n%access public export\n%default total\n\ndata FormatSpec = FInt | FDouble | FChar\n\nSpecType : FormatSpec -> Type\nSpecType FInt = Integer\nSpecType FDouble = Double\nSpecType FChar = Char\n\ndisplay : (f : FormatSpec) -> SpecType f -> String\ndisplay FInt = show\ndisplay FDouble = show\ndisplay FChar = singleton\n\n\n\nParsed : Type\nParsed = List (Either String FormatSpec)\n\nFormatType : Parsed -> Type\nFormatType [] = String\nFormatType (Left _ :: ps) = FormatType ps\nFormatType (Right f :: ps) = SpecType f -> FormatType ps\n\nparseInput' : List Char -> Parsed\nparseInput' [] = []\nparseInput' ('%' :: 'd' :: cs) = Right FInt :: parseInput' cs\nparseInput' ('%' :: 'f' :: cs) = Right FDouble :: parseInput' cs\nparseInput' ('%' :: 'c' :: cs) = Right FChar :: parseInput' cs\nparseInput' ('%' :: '%' :: cs) = Left \"%\" :: parseInput' cs\nparseInput' (c :: cs) = case parseInput' cs of\n\t\t\t\t\t\t\tLeft str :: p => Left (strCons c str) :: p\n\t\t\t\t\t\t\tp => Left (singleton c) :: p\n\nparseInput : String -> Parsed\nparseInput str = parseInput' (unpack str)\n\nprintfParsed : String -> (p : Parsed) -> FormatType p\nprintfParsed acc [] = acc\nprintfParsed acc (Left str :: p) = printfParsed (acc ++ str) p\nprintfParsed acc (Right f :: p) = \\x => printfParsed (acc ++ display f x) p\n\nsprintf : (str : String) -> FormatType (parseInput str)\nsprintf str = printfParsed \"\" (parseInput str)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111641,"user_id":null,"body":"module Sprintf\n%access public export\n%default total\ndata Format = Ch Format\n            | Num Format\n            | Flt Format\n            | Str Format\n            | Lit String Format\n            | End\nPrintfType : Format -> Type\nPrintfType (Ch fmt) = (c: Char) -> PrintfType fmt\nPrintfType (Flt fmt) = (d :Double) -> PrintfType fmt\nPrintfType (Str fmt) = (s : String) -> PrintfType fmt\nPrintfType (Lit str fmt) = PrintfType fmt\nPrintfType (Num fmt) = (n : Integer) -> PrintfType fmt\nPrintfType End = String\n\nhelper : (fmt : Format) -> (acc : String) -> PrintfType fmt\nhelper (Ch fmt) acc = \\c => helper fmt $ acc ++ (cast c)\nhelper (Num fmt) acc = \n => helper fmt $ acc ++ (show n)\nhelper (Flt fmt) acc = \\d => helper fmt $ acc ++ (show d)\nhelper (Str fmt) acc = \\s => helper fmt $ acc ++ s\nhelper (Lit s fmt) acc = helper fmt $ acc ++ s\nhelper End acc = acc\n\nformatter : List Char -> Format\nformatter ('%'::'s'::str) = Str $ formatter str\nformatter ('%'::'d'::str) = Num $ formatter str\nformatter ('%'::'c'::str) = Ch $ formatter str\nformatter ('%'::'f'::str) = Flt $ formatter str\nformatter ('%'::'%'::str) = case formatter str of\n                                Lit s fmt => Lit (singleton '%' ++ s) fmt\n                                _ => Lit (singleton '%') $ formatter str\nformatter (c::str) = case formatter str of\n                        Lit s fmt => Lit (singleton c ++ s) fmt\n                        _ => Lit (singleton c) $ formatter str\nformatter [] = End\nsprintf : (str: String) -> PrintfType $ formatter $ unpack str\nsprintf str = helper _ \"\"","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111642,"user_id":null,"body":"module Sprintf\n\n%access public export\n%default total\n\ndata Format = FInteger Format\n            | FDouble Format\n            | FChar Format\n            | FLit Char Format\n            | FEnd\n\ntoFormat : (xs : List Char) -> Format\ntoFormat [] = FEnd\ntoFormat ('%' :: 'd' :: chars) = FInteger (toFormat chars)\ntoFormat ('%' :: 'f' :: chars) = FDouble (toFormat chars)\ntoFormat ('%' :: 'c' :: chars) = FChar (toFormat chars)\ntoFormat ('%' :: '%' :: chars) = FLit '%' (toFormat chars)\ntoFormat (x :: chars)          = FLit x (toFormat chars)\n\nSPrintfType : Format -> Type\nSPrintfType (FInteger fmt) = Integer -> SPrintfType fmt\nSPrintfType (FDouble fmt)  = Double -> SPrintfType fmt\nSPrintfType (FChar fmt)    = Char -> SPrintfType fmt\nSPrintfType (FLit c fmt)   = SPrintfType fmt\nSPrintfType FEnd           = String\n\nsprintfFmt : (fmt : Format) -> String -> SPrintfType fmt\nsprintfFmt (FInteger fmt) acc = \\i => sprintfFmt fmt (acc ++ show i)\nsprintfFmt (FDouble fmt) acc  = \\d => sprintfFmt fmt (acc ++ show d)\nsprintfFmt (FChar fmt) acc    = \\c => sprintfFmt fmt (acc ++ singleton c)\nsprintfFmt (FLit c fmt) acc   = sprintfFmt fmt (acc ++ singleton c)\nsprintfFmt FEnd acc           = acc\n\n\nsprintf : (fmt : String) -> SPrintfType (toFormat (unpack fmt))\nsprintf fmt = sprintfFmt (toFormat (unpack fmt)) \"\"","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111643,"user_id":null,"body":"module Sprintf\n\nimport Data.Vect\n\n%access public export\n%default total\n\n\ndata Formatter = FD | FF | FC\n\nfmtType : Formatter -> Type\nfmtType FD = Integer\nfmtType FF = Double\nfmtType FC = Char\n\nsprintfParse : List Char -> (n : Nat ** (Vect n Formatter, Vect (S n) String))\nsprintfParse [] = (0 ** (Nil, [\"\"]))\nsprintfParse [c] = (0 ** (Nil, [singleton c]))\nsprintfParse ('%' :: d :: ds) with (sprintfParse ds)\n\t| (_ ** (fmts, prefix :: strs)) =\n\t\tcase d of\n\t\t\t'd' => (_ ** (FD :: fmts, \"\" :: prefix :: strs))\n\t\t\t'f' => (_ ** (FF :: fmts, \"\" :: prefix :: strs))\n\t\t\t'c' => (_ ** (FC :: fmts, \"\" :: prefix :: strs))\n\t\t\t'%' => (_ ** (fmts, strCons '%' prefix :: strs))\n\t\t\t_   => (_ ** (fmts, (strCons '%' $ strCons d prefix) :: strs))\nsprintfParse (c :: d :: ds) with (sprintfParse (d :: ds))\n\t| (_ ** (fmts, prefix :: strs)) =\n\t\t(_ ** (fmts, strCons c prefix :: strs))\n\nSprintfType : Vect n Formatter -> Type\nSprintfType Nil = String\nSprintfType (fmt :: fmts) = fmtType fmt -> SprintfType fmts\n\nsprintfFn : (fmts : Vect n Formatter) -> Vect (S n) String -> String -> SprintfType fmts\nsprintfFn Nil [t] s = s ++ t\nsprintfFn (FD :: fmts) (t :: ts) s = \\x => sprintfFn fmts ts (s ++ t ++ show x)\nsprintfFn (FF :: fmts) (t :: ts) s = \\x => sprintfFn fmts ts (s ++ t ++ show x)\nsprintfFn (FC :: fmts) (t :: ts) s = \\x => sprintfFn fmts ts (s ++ t ++ singleton x)\n\nsprintf : (s : String) -> SprintfType (Basics.fst (DPair.snd (sprintfParse (unpack s)))) \nsprintf s =\n\tlet p = DPair.snd (sprintfParse (unpack s)) in\n\tsprintfFn (fst p) (snd p) \"\"","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111644,"user_id":null,"body":"module Sprintf\n\n%access public export\n%default total\n\ndata Format = Nmb Format\n            | Dbl Format\n            | Chr Format\n            | Lit String Format\n            | End\n\n%name Format fmt\n\nSPrintfType : Format -> Type\nSPrintfType (Nmb fmt) = Integer -> SPrintfType fmt\nSPrintfType (Dbl fmt) = Double  -> SPrintfType fmt\nSPrintfType (Chr fmt) = Char    -> SPrintfType fmt\nSPrintfType (Lit x fmt) =          SPrintfType fmt\nSPrintfType End = String\n\nsprintfFmt : (fmt : Format) -> (acc : String) -> SPrintfType fmt\nsprintfFmt (Nmb fmt) acc = \\k => sprintfFmt fmt (acc ++ show k)\nsprintfFmt (Dbl fmt) acc = \\k => sprintfFmt fmt (acc ++ show k)\nsprintfFmt (Chr fmt) acc = \\k => sprintfFmt fmt (acc ++ singleton k)\nsprintfFmt (Lit x fmt) acc = sprintfFmt fmt (acc ++ x)\nsprintfFmt End acc = acc\n\ntoFormat : (xs : List Char) -> Format\ntoFormat [] = End\ntoFormat ('%' :: 'd' :: xs) = Nmb (toFormat xs)\ntoFormat ('%' :: 'f' :: xs) = Dbl (toFormat xs)\ntoFormat ('%' :: 'c' :: xs) = Chr (toFormat xs)\ntoFormat ('%' :: '%' :: xs) = Lit \"%\" (toFormat xs)\ntoFormat (x :: xs)  = case toFormat xs of\n                           (Lit s fmt) => Lit (strCons x s) fmt\n                           fmt => Lit (singleton x) fmt\n\nsprintf : (fmt : String) -> SPrintfType (toFormat (unpack fmt))\nsprintf fmt = sprintfFmt _  \"\"","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c84a95c71c5210f2930c481":[{"id":111645,"user_id":1084,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz Coz = Coz\nAdd Coz (Cos y) = Cos y\nAdd (Cos x) Coz = Cos x\nAdd (Cos x) (Cos y) = Cos (Cos (Add x y))\n\nplusRefl : (a : Conat) -> Bisimulation a a\nplusRefl Coz = Biz\nplusRefl (Cos x) = Bis (plusRefl x)\n\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative Coz (Cos y) = Bis (plusRefl y)\nplusCommutative (Cos x) Coz = Bis (plusRefl x)\nplusCommutative (Cos x) (Cos y) = Bis (Bis (plusCommutative x y))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111646,"user_id":null,"body":"module PlusComm\n\nimport Conat\n\n%access export\n%default total\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz     Coz     = Coz\nAdd (Cos a) Coz     = Cos a\nAdd Coz     (Cos b) = Cos b\nAdd (Cos a) (Cos b) = Cos $ Cos $ Add a b\n\nbiX : (x : Conat) -> Bisimulation x x\nbiX Coz     = Biz\nbiX (Cos x) = Bis $ biX x\n\ntotal -- Idris is strong enough!\nplusCommutative : (a : Conat) -> (b : Conat) -> Bisimulation (Add a b) (Add b a) \nplusCommutative Coz     Coz     = Biz\nplusCommutative Coz     (Cos y) = biX $ Cos y\nplusCommutative (Cos x) Coz     = biX $ Cos x\nplusCommutative (Cos x) (Cos y) = Bis $ Bis $ plusCommutative x y","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111647,"user_id":106,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz b = b\nAdd (Cos a) b = Cos (Add a b)\n\ninfixr 10 <=>\npublic export\n(<=>) : Bisimulation a b -> Bisimulation b c -> Bisimulation a c\nBiz <=> Biz = Biz\n(Bis a) <=> (Bis b) = Bis (a <=> b)\n\n-- Idris weak weak, partial implementation is allowed but there's random test\npartial\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative (Cos a) Coz = Bis (plusCommutative a Coz)\nplusCommutative Coz (Cos b) = Bis (plusCommutative Coz b)\n-- trick from my solution from https:\/\/www.codewars.com\/kata\/reviews\/59dba1d4da481024510022f6\/groups\/59dddc9f397858d2d100024d ;-)\nplusCommutative sa@(Cos a) sb@(Cos b) = Bis (plusCommutative a sb <=> Bis (plusCommutative b a) <=> plusCommutative sa b)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111648,"user_id":null,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\n{-\nWhat you've just imported:\n\ncodata Conat : Type where\n  Coz : Conat\n  Cos : Conat -> Conat\n\ncodata Bisimulation : Conat -> Conat -> Type where\n  Biz : Bisimulation Coz Coz\n  Bis : {a : Conat} -> {b : Conat} ->\n        (Bisimulation a b) ->\n        (Bisimulation (Cos a) (Cos b))\n\nMuGen : Conat\nMuGen = Cos MuGen\n-}\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz n = n\nAdd (Cos m) n = Cos (Add m n)\n\ntransB : Bisimulation a b -> Bisimulation b c -> Bisimulation a c\ntransB Biz Biz = Biz\ntransB (Bis b1) (Bis b2) = Bis (transB b1 b2)\n\n-- Idris weak weak, partial implementation is allowed but there's random test\npartial\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative Coz (Cos n) = Bis (plusCommutative Coz n)\nplusCommutative (Cos m) Coz = Bis (plusCommutative m Coz)\nplusCommutative m@(Cos m') n@(Cos n') = Bis (transB (transB (plusCommutative m' n) (Bis (plusCommutative n' m'))) (plusCommutative m n'))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111649,"user_id":null,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\n{-\nWhat you've just imported:\n\ncodata Conat : Type where\n  Coz : Conat\n  Cos : Conat -> Conat\n\ncodata Bisimulation : Conat -> Conat -> Type where\n  Biz : Bisimulation Coz Coz\n  Bis : {a : Conat} -> {b : Conat} ->\n        (Bisimulation a b) ->\n        (Bisimulation (Cos a) (Cos b))\n\nMuGen : Conat\nMuGen = Cos MuGen\n-}\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz n = n\nAdd (Cos m) n = Cos (Add m n)\n\nAddIdentityRight : (n : Conat) -> Bisimulation n (Add n Coz)\nAddIdentityRight Coz = Biz\nAddIdentityRight (Cos n) = Bis (AddIdentityRight n)\n\nAddIdentityRight' : (n : Conat) -> Bisimulation (Add n Coz) n\nAddIdentityRight' Coz = Biz\nAddIdentityRight' (Cos n) = Bis (AddIdentityRight' n)\n\nBisimulationTrans : Bisimulation a b -> Bisimulation b c -> Bisimulation a c\nBisimulationTrans Biz bc = bc\nBisimulationTrans (Bis ab) (Bis bc) = Bis (BisimulationTrans ab bc)\n\nBisimulationRefl : Bisimulation n n\nBisimulationRefl {n = Coz} = Biz\nBisimulationRefl {n = (Cos x)} = Bis BisimulationRefl\n\nBisimulationSym : Bisimulation m n -> Bisimulation n m\nBisimulationSym Biz = Biz\nBisimulationSym (Bis mn) = Bis (BisimulationSym mn)\n\nAddCos : (m : Conat) -> (n : Conat) -> Bisimulation (Add m (Cos n)) (Cos (Add m n))\nAddCos Coz n = Bis BisimulationRefl\nAddCos (Cos m) n = Bis (AddCos m n)\n\n-- Idris weak weak, partial implementation is allowed but there's random test\npartial\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative Coz (Cos b) = Bis (AddIdentityRight b)\nplusCommutative (Cos a) Coz = Bis (AddIdentityRight' a)\nplusCommutative (Cos a) (Cos b) = Bis (AddCos a b `BisimulationTrans` ((Bis (plusCommutative a b)) `BisimulationTrans` BisimulationSym (AddCos b a)))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111650,"user_id":527,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\nAdd : Conat -> Conat -> Conat\nAdd Coz b = b\nAdd a Coz = a\nAdd (Cos a) (Cos b) = Cos (Cos (Add a b))\n\nrefl : (a : Conat) -> Bisimulation a a\nrefl Coz = Biz\nrefl (Cos a) = Bis (refl a)\n\nsym : Bisimulation a b -> Bisimulation b a\nsym Biz = Biz\nsym (Bis ab) = Bis (sym ab)\n\nplusZeroCommutative : (a : Conat) -> Bisimulation (Add Coz a) (Add a Coz)\nplusZeroCommutative Coz = Biz\nplusZeroCommutative (Cos a) = Bis (refl a)\n\nplusCommutative : (a : Conat) -> (b : Conat) -> Bisimulation (Add a b) (Add b a)\nplusCommutative Coz b = plusZeroCommutative b\nplusCommutative a Coz = sym (plusZeroCommutative a)\nplusCommutative (Cos a) (Cos b) = Bis (Bis (plusCommutative a b))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111651,"user_id":null,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\n{-\nWhat you've just imported:\n\ncodata Conat : Type where\n  Coz : Conat\n  Cos : Conat -> Conat\n\ncodata Bisimulation : Conat -> Conat -> Type where\n  Biz : Bisimulation Coz Coz\n  Bis : {a : Conat} -> {b : Conat} ->\n        (Bisimulation a b) ->\n        (Bisimulation (Cos a) (Cos b))\n\nMuGen : Conat\nMuGen = Cos MuGen\n-}\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz b = b\nAdd (Cos a) b = Cos (Add a b)\n\nplusRightSucc : (a,b : Conat) -> Add a (Cos b) = Cos (Add a b)\nplusRightSucc Coz b = cong {f=Cos} (cong {f=Delay} Refl)\nplusRightSucc (Cos a) b = cong {f=Cos} (cong {f=Delay} (plusRightSucc a b))\n\n-- Idris weak weak, partial implementation is allowed but there's random test\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative Coz (Cos b) = Bis (plusCommutative Coz b)\nplusCommutative (Cos a) Coz = Bis (plusCommutative a Coz)\nplusCommutative (Cos a) (Cos b) =\n\trewrite plusRightSucc a b in\n\trewrite plusRightSucc b a in Bis (Bis (plusCommutative a b))\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111652,"user_id":null,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\n{-\nWhat you've just imported:\n\ncodata Conat : Type where\n  Coz : Conat\n  Cos : Conat -> Conat\n\ncodata Bisimulation : Conat -> Conat -> Type where\n  Biz : Bisimulation Coz Coz\n  Bis : {a : Conat} -> {b : Conat} ->\n        (Bisimulation a b) ->\n        (Bisimulation (Cos a) (Cos b))\n\nMuGen : Conat\nMuGen = Cos MuGen\n-}\n\npublic export\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz y = y\nAdd (Cos x) Coz = Cos x;\nAdd (Cos x) (Cos y) = Cos $ Cos (Add x y)\n\nreflX : (x:Conat) -> Bisimulation x x\nreflX Coz = Biz\nreflX (Cos x) = Bis $ reflX x\n\n-- Idris weak weak, partial implementation is allowed but there's random test\npartial\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative Coz (Cos x) = reflX (Cos x)\nplusCommutative (Cos x) Coz = reflX (Cos x)\nplusCommutative (Cos x) (Cos y) = Bis $ Bis $ plusCommutative x y","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111653,"user_id":null,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\n{-\nWhat you've just imported:\n\ncodata Conat : Type where\n  Coz : Conat\n  Cos : Conat -> Conat\n\ncodata Bisimulation : Conat -> Conat -> Type where\n  Biz : Bisimulation Coz Coz\n  Bis : {a : Conat} -> {b : Conat} ->\n        (Bisimulation a b) ->\n        (Bisimulation (Cos a) (Cos b))\n\nMuGen : Conat\nMuGen = Cos MuGen\n-}\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz y = y\nAdd x Coz = x\nAdd (Cos x) (Cos y) = Cos (Cos (Add x y))\n\nbisimulationRefl : {x : Conat} -> Bisimulation x x\nbisimulationRefl {x = Coz}   = Biz\nbisimulationRefl {x = Cos x} = Bis bisimulationRefl \n\n-- Idris weak weak, partial implementation is allowed but there's random test\npartial\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz Coz = Biz\nplusCommutative Coz (Cos y) = Bis bisimulationRefl\nplusCommutative (Cos x) Coz = Bis bisimulationRefl\nplusCommutative (Cos x) (Cos y) = Bis (Bis (plusCommutative x y))","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111654,"user_id":522,"body":"module PlusComm\n\nimport Conat\n\n%access export\n\n{-\nWhat you've just imported:\n\ncodata Conat : Type where\n  Coz : Conat\n  Cos : Conat -> Conat\n\ncodata Bisimulation : Conat -> Conat -> Type where\n  Biz : Bisimulation Coz Coz\n  Bis : {a : Conat} -> {b : Conat} ->\n        (Bisimulation a b) ->\n        (Bisimulation (Cos a) (Cos b))\n\nMuGen : Conat\nMuGen = Cos MuGen\n-}\n\nmuGenSucc : Bisimulation (Cos MuGen) MuGen\nmuGenSucc = Bis muGenSucc\n\npublic export\nAdd : Conat -> Conat -> Conat\nAdd Coz n = n\nAdd (Cos m) n = Cos (Add m n)\n\nplusZ : (a : Conat) -> Bisimulation a (Add a Coz)\nplusZ Coz = Biz\nplusZ (Cos n) = Bis (plusZ n)\n\ntrans : {a : Conat} -> {b : Conat} -> {c : Conat} \n  -> Bisimulation a b -> Bisimulation b c -> Bisimulation a c\ntrans Biz Biz = Biz\ntrans (Bis p) (Bis q) = Bis (trans p q)\n\nrefl : (a : Conat) -> Bisimulation a a\nrefl Coz = Biz\nrefl (Cos n) = Bis (refl n)\n\nplusS : (a : Conat) -> (b : Conat) -> Bisimulation (Cos (Add a b)) (Add a (Cos b))\nplusS Coz n = Bis (refl n)\nplusS (Cos m) n = Bis (plusS m n)\n\n-- Idris weak weak, partial implementation is allowed but there's random test\npartial\nplusCommutative : (a : Conat) -> (b : Conat) ->\n                  Bisimulation (Add a b) (Add b a)\nplusCommutative Coz n = plusZ n\nplusCommutative (Cos m) n = trans (Bis (plusCommutative m n)) (plusS n m)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}],"5c8607124c6e850009ff5ef7":[{"id":111655,"user_id":168,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nfpow : Nat -> (a -> a) -> a -> a\nfpow Z f = id\nfpow (S n) f = f . fpow n f\n\npred : Fin k -> Fin k\npred FZ = last\npred (FS n) = weaken n\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = fpow (finToNat m) pred n\n\nnegate : Fin k -> Fin k\nnegate {k=S _} n = subt FZ n\n\nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmult : Fin k -> Fin k -> Fin k\nmult {k=S _} n m = fpow (finToNat n) (add m) FZ","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111656,"user_id":53,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\ninc : {n : Nat} -> Fin n -> Fin n\ninc {n = (S k)} x = case strengthen x of\n  Left l => FZ\n  Right r => FS r\n\ndecr : {n : Nat} -> Fin n -> Fin n\ndecr {n = (S k)} FZ = last\ndecr {n = (S k)} (FS x) = weaken x\n\nwalk : {n : Nat} -> {a : Type} -> (a -> a) -> a -> Fin n -> a\nwalk {n = (S k)} f x FZ = x\nwalk {n = (S k)} f x (FS y) = walk f (f x) y\n\nadd : {n : Nat} -> Fin n -> Fin n -> Fin n\nadd x y = walk inc y x\n\nmult : {n : Nat} -> Fin n -> Fin n -> Fin n\nmult {n = (S k)} x y = walk (add y) FZ x\n\nnegate : {n : Nat} -> Fin n -> Fin n\nnegate {n = (S k)} x = walk decr FZ x\n\nsubt : {n : Nat} -> Fin n -> Fin n -> Fin n\nsubt x y = add x (negate y)","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111657,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nimplicit\nnatToFin' : Nat -> Fin (S k)\nnatToFin' {k} x = maybe FZ id (natToFin x (S k))\n\nmodulo : Nat -> Fin (S k)\nmodulo {k} x = modNatNZ x (S k) absurd\n\nnegate : Fin k -> Fin k\nnegate {k=k@(S _)} x = minus k (finToNat x)\n\nadd : Fin k -> Fin k -> Fin k\nadd {k=k@(S _)} x y = modulo $ finToNat x + finToNat y\n\nsubt : Fin k -> Fin k -> Fin k\nsubt x y = add x (negate y)\n\nmult : Fin k -> Fin k -> Fin k\nmult {k=k@(S _)} x y = modulo $ finToNat x * finToNat y\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111658,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nnatToFin' : Nat -> Fin (S k)\nnatToFin' {k} x with (natToFin x (S k))\n  natToFin' x | Nothing = FZ  -- handle the case that x == (S k)\n  natToFin' x | (Just y) = y\n\nnegate : Fin k -> Fin k\nnegate {k=k@(S _)} x = natToFin' $ minus k (finToNat x)\n\nadd : Fin k -> Fin k -> Fin k\nadd {k=k@(S _)} x y = natToFin' $ modNatNZ (finToNat x + finToNat y) k absurd\n\nsubt : Fin k -> Fin k -> Fin k\nsubt x y = add x (negate y)\n\nmult : Fin k -> Fin k -> Fin k\nmult {k=k@(S _)} x y = natToFin' $ modNatNZ (finToNat x * finToNat y) k absurd\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111659,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nnegateHelp : Fin k -> Fin k -> Fin k\nnegateHelp FZ y = FZ\nnegateHelp (FS FZ) y = y\nnegateHelp (FS (FS x)) FZ = FZ\nnegateHelp (FS (FS x)) (FS y) = weaken (negateHelp (FS x) y)\n\nnegate : Fin k -> Fin k\nnegate FZ = FZ\nnegate (FS n) = negateHelp (FS n) last\n\nprivate\ntestNegate : List Integer\ntestNegate = let testCases : List (Fin 10) = [0 .. last]\n              in finToInteger <$> map negate testCases\n\nsubstHelp : Fin k -> Fin k -> Either (Fin k) (Fin k)\nsubstHelp FZ y = Right y\nsubstHelp (FS x) FZ = Left (FS x)\nsubstHelp (FS x) (FS y) with (substHelp x y)\n  substHelp (FS x) (FS y) | (Left l) = Left (weaken l)\n  substHelp (FS x) (FS y) | (Right r) = Right (weaken r)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt x y with (substHelp x y)\n  subt x y | (Left l) = l\n  subt x y | (Right r) = negate r\n\nprivate\ntestSubst : List (Integer, Integer, Integer)\ntestSubst = let testCases : List (Fin 10) = [0 .. last] in\n       do a <- testCases\n          b <- testCases\n          let c = subt a b\n          pure (finToInteger a, finToInteger b, finToInteger c)\n\nadd : Fin k -> Fin k -> Fin k\nadd x y = subt x (negate y)\n\nmultHelp : Fin i -> Fin j -> Fin j\nmultHelp FZ FZ = FZ\nmultHelp FZ (FS x) = FZ\nmultHelp (FS x) y = add y (multHelp x y)\n\nmult : Fin k -> Fin k -> Fin k\nmult x y = multHelp x y\n\nprivate\ntestMult : List (Integer, Integer, Integer)\ntestMult = let testCases : List (Fin 5) = [0 .. last] in\n       do a <- testCases\n          b <- testCases\n          let c = mult a b\n          pure (finToInteger a, finToInteger b, finToInteger c)\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111660,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\nadd : Fin k -> Fin k -> Fin k\n\nnegate : Fin k -> Fin k\nnegate {k=Z} FZ impossible\nnegate {k=S k'} FZ = FZ\nnegate {k=S (S k')} (FS FZ) = last\nnegate {k=S k'} (FS n) = weaken $ negate n\n\nsubt : Fin k -> Fin k -> Fin k\nsubt FZ y = negate y\nsubt x FZ = x\nsubt (FS x) (FS y) with (compare x y)\n  | LT = FS $ subt x y\n  | EQ = FZ\n  | GT = weaken $ subt x y\n\nadd m n = subt m $ negate n\n\n\nmult' : Nat -> Fin k -> Fin k -> Fin k\nmult' {k=Z} a x y impossible\nmult' {k=S n} Z _ _ = FZ\nmult' _ FZ _ = FZ\nmult' _ _ FZ = FZ\nmult' _ (FS FZ) n = n\nmult' _ m (FS FZ) = m\nmult' (S a) (FS m) n = add n $ mult' a (weaken m) n\n\nmult : Fin k -> Fin k -> Fin k\nmult {k} x y = mult' k x y\n","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111661,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\n\nnext : Fin n -> Fin n\nnext {n = S _} x = case strengthen x of\n                   Left _  => FZ\n                   Right y => FS y \n\n\nprev : Fin k -> Fin k\nprev FZ = last\nprev (FS x) = weaken x\n\n\nadd_helper : Fin n -> Fin k -> Fin k\nadd_helper FZ y = y\nadd_helper (FS x) y = add_helper x (next y)\n\n\nadd : Fin k -> Fin k -> Fin k\nadd = add_helper\n\n\nnegate_helper : Fin n -> Fin k -> Fin k\nnegate_helper FZ y = y\nnegate_helper (FS x) y = negate_helper x (prev y)\n\n\nnegate : Fin k -> Fin k\nnegate {k = S _} x = negate_helper x FZ\n\n\nsubt : Fin k -> Fin k -> Fin k\nsubt x y = add x (negate y)\n\n\nmult_helper : Fin n -> Fin (S k) -> Fin (S k)\nmult_helper FZ y = FZ\nmult_helper (FS x) y = add y (mult_helper x y)\n\n\nmult : Fin k -> Fin k -> Fin k\nmult {k = S _} x y = mult_helper x y","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111662,"user_id":524,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nnegate : Fin k -> Fin k\nnegate FZ = FZ \nnegate (FS FZ) = last \nnegate (FS (FS x)) = weaken (negate (FS x)) \n\nnatSubt : (k : Nat) -> Nat -> Nat -> Nat \nnatSubt k Z Z = Z \nnatSubt k Z (S j) = minus k (S j)\nnatSubt k (S i) Z = S i \nnatSubt k (S i) (S j) = natSubt k i j \n\nsubt : Fin k -> Fin k -> Fin k\nsubt {k} n m = case natToFin (natSubt k (finToNat n) (finToNat m)) k of \n    Nothing => n \n    Just x => x \n    \nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmultAux : Nat -> Fin k -> Fin k \nmultAux {k = Z} Z FZ impossible\nmultAux {k = Z} Z (FS _) impossible\nmultAux {k = (S k)} Z m = FZ \nmultAux (S k) m = add m (multAux k m)\n\nmult : Fin k -> Fin k -> Fin k\nmult n m = multAux (finToNat n) m ","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111663,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nnegate : Fin k -> Fin k\nnegate FZ = FZ\nnegate (FS FZ) = last\nnegate (FS f) = weaken (negate f)\n\nfinToNat_weaken : {k:Nat} -> (n:Fin k) -> finToNat n = finToNat (weaken n)\nfinToNat_weaken FZ = Refl\nfinToNat_weaken (FS n') = rewrite (finToNat_weaken n') in Refl\n\nlemma : {k:Nat} -> {n:Fin k} -> {nn:Nat} -> (S nn = finToNat (FS n)) -> (nn = finToNat (weaken n))\nlemma {n=n} Refl = rewrite (finToNat_weaken n) in Refl\n\nsubt' : Fin k -> (m:Fin k) -> (mn:Nat) -> (mn = finToNat m) -> Fin k\nsubt' n FZ _ _ = n\nsubt' _ (FS m') Z Refl impossible\nsubt' FZ (FS m') (S m'n) p = subt' last (weaken m') m'n (lemma p)\nsubt' (FS n') (FS m') (S m'n) p = subt' (weaken n') (weaken m') m'n (lemma p)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = subt' n m (finToNat m) Refl\n\nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmult' : (n:Fin k) -> (nn:Nat) -> (nn = finToNat n) -> Fin k -> Fin k\nmult' FZ _ _ m = FZ\nmult' (FS n') (S n'n) p m = add m (mult' (weaken n') n'n (lemma p) m)\nmult' (FS n') Z Refl _ impossible\n\nmult : Fin k -> Fin k -> Fin k\nmult n m = mult' n (finToNat n) Refl m","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"},{"id":111664,"user_id":null,"body":"module Modulo\n\nimport Data.Fin\n\n%access export\n%default total\n\nrepeat : Fin k -> (x -> x) -> x -> x\nrepeat FZ f x = x\nrepeat (FS n) f x = f (repeat n f x)\n\ninc : Fin (S k) -> Fin (S k)\ninc n with (strengthen (FS n))\n\t| (Left n') = FZ\n\t| (Right n') = n'\n\ndec : Fin k -> Fin k\ndec FZ = last\ndec (FS n) = weaken n\n\nadd : Fin k -> Fin k -> Fin k\nadd n FZ = n\nadd n (FS m) = repeat n inc (FS m)\n\nnegate : Fin k -> Fin k\nnegate FZ = FZ\nnegate (FS n) = repeat n dec last\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = add n (negate m)\n\nmult : Fin k -> Fin k -> Fin k\nmult n FZ = FZ\nmult n (FS m) = repeat (FS m) (add n) FZ","lang_id":25,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:50","updated_at":"2023-01-14 13:23:50"}]}