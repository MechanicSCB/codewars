{"50654ddff44f800200000004":[{"id":83754,"user_id":527,"body":"let multiply = (*)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83755,"user_id":1686,"body":"let multiply a b = a * b","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83756,"user_id":null,"body":"let multiply a = (*) a ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83757,"user_id":null,"body":"let rec multiply a b = if b < 1 then 0 else if b > 0 then a + multiply a (b - 1) else multiply a (b + 1) - a","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83758,"user_id":null,"body":"let multiply a b = (*) a b","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83759,"user_id":null,"body":"let multiply = fun a b -> a * b","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83760,"user_id":null,"body":"let multiply a b : int32 = a * b","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83761,"user_id":null,"body":"let multiply (a: int64) (b: int64) = a * b","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83762,"user_id":null,"body":"let multiply (a: int64) (b: int64) =\n    seq {\n        for _ in [1 .. b] do\n            yield a\n    } |> Seq.sum\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83763,"user_id":null,"body":"let multiply a b =\n  let rec multiplyRec a b acc =\n    match b with\n      | 0 -> acc\n      | _ -> multiplyRec a (b - 1) (acc + a)\n    in multiplyRec a b 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"50ee6b0bdeab583673000025":[{"id":83764,"user_id":1566,"body":"let name = \"codewa.rs\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83765,"user_id":1277,"body":"let a = \"code\"\nlet b = \"wa.rs\"\nlet name = a + b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83766,"user_id":null,"body":"let (a, b) = (\"code\", \"wa.rs\")\nlet name = a + b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83767,"user_id":null,"body":"let name = \"code\" + \"wa.rs\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83768,"user_id":null,"body":"open System\nlet name = \"codewa.rs\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"513e08acc600c94f01000001":[{"id":83769,"user_id":null,"body":"let rgb r g b =\n  let getRgbValue = max 0 >> min 255\n  sprintf \"%02X%02X%02X\" (getRgbValue r) (getRgbValue g) (getRgbValue b)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83770,"user_id":null,"body":"let rgb r g b =\n    let toHex x = sprintf \"%02X\" (max 0 (min x 255))\n    toHex r + toHex g + toHex b","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83771,"user_id":null,"body":"let rgb r g b =\n    [r;g;b]\n    |> Seq.map (min 255 >> max 0)\n    |> Seq.reduce (fun state item -> state * 256 + item)\n    |> sprintf \"%06x\"\n    |> fun p -> p.ToUpper()","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83772,"user_id":null,"body":"let inline get n =\n    if   n >= 255 then \"FF\"\n    elif n <= 0   then \"00\"\n    else n.ToString(\"X2\")\n\nlet rgb r g b =\n    get r + get g + get b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83773,"user_id":53,"body":"open System;\n\nlet inline clamp minimum maximum value = value |> max minimum |> min maximum\n\nlet rgb r g b =\n  [| r; g; b |] \n    |> Array.map (fun (rgb : int) -> clamp 0 255 rgb)\n    |> Array.map (fun (rgb : int) -> System.String.Format(\"{0:X2}\", rgb))\n    |> String.concat String.Empty","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83774,"user_id":null,"body":"let rgb r g b =\n  let toHex v =\n    System.Math.Max(0, System.Math.Min(255, v)) |> sprintf \"%02X\"\n  (r |> toHex) + (g |> toHex) + (b |> toHex)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83775,"user_id":null,"body":"let clamp v = if v < 0 then 0 elif v > 255 then 255 else v\nlet rgb r g b = sprintf \"%02X%02X%02X\" (clamp r) (clamp g) (clamp b)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83776,"user_id":null,"body":"let fitByteRange (num:int) =\n        if num < 0 then 0\n        elif num > 255 then 255\n        else num\n        \nlet rgb (r:int) (g:int) (b:int) = \n       let byteToHex dec = \n           let hexChars = \"0\" :: \"1\":: \"2\":: \"3\":: \"4\":: \"5\":: \"6\":: \"7\":: \"8\":: \"9\":: \"A\":: \"B\":: \"C\":: \"D\":: \"E\":: \"F\" :: []\n           hexChars.[dec \/ 16] + hexChars.[dec % 16]  \n       byteToHex (fitByteRange r) + byteToHex (fitByteRange g) + byteToHex (fitByteRange b)            ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83777,"user_id":null,"body":"\n\nlet rgb r g b =\n    let clamp x = if x < 0 then 0 elif x > 255 then 255 else x\n    sprintf \"%02X%02X%02X\" (clamp r) (clamp g) (clamp b)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83778,"user_id":null,"body":"let rgb r g b = [ r; g; b ] |>\n  Seq.map (max 0 >> min 0xff >> sprintf \"%02X\") |>\n  Seq.fold (+) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"514b92a657cdc65150000006":[{"id":83779,"user_id":null,"body":"let solution n = \n  [0..n-1]\n  |> Seq.filter (fun x -> x % 3 = 0 || x % 5 = 0)\n  |> Seq.sum\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83780,"user_id":null,"body":"let condition x = x % 3 = 0 || x % 5 = 0\nlet solution n =\n    [1..n-1]\n    |> List.filter condition\n    |> List.sum\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83781,"user_id":null,"body":"let solution n = \n  seq { for x in 3..(n - 1) do if x % 3 = 0 || x % 5 = 0 then yield x } |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83782,"user_id":null,"body":"let solution n = \n    Seq.init n id\n    |> Seq.filter (fun x -> x%3 = 0 || x%5 = 0)\n    |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83783,"user_id":null,"body":"let solution n = \n    seq { 2..n - 1}\n    |> Seq.filter (fun x -> x % 3 = 0 || x % 5 = 0)    \n    |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83784,"user_id":null,"body":"let solution n =\n  let n = n - 1\n  if n < 3 then\n    0\n  else\n    [3; 5; -15]\n    |> List.map\n      ( fun x ->\n          let y = abs (n \/ x)\n          x * y * (y + 1) )\n    |> List.sum\n    |> (fun s -> s \/ 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83785,"user_id":null,"body":"let solution n = \n    seq { for x in 1 .. (n - 1) do\n            if x % 3 = 0 || x % 5 = 0\n            then yield x }\n    |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83786,"user_id":null,"body":"let solution n = \n    [3..3..n-1]\n    |> List.append [5..5..n-1]\n    |> Set.ofList\n    |> Set.fold (+) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83787,"user_id":null,"body":"let solution n = \n    [0..n-1]\n    |>Seq.sumBy(fun x-> if x%3=0 || x%5=00 then x else 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83788,"user_id":null,"body":"let solution n = [|for i in 1..(n-1) do if (i%3=0 || i%5=0) then yield i|] |> Array.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"515e271a311df0350d00000f":[{"id":83789,"user_id":527,"body":"let square_sum = List.sumBy (fun x -> x * x)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83790,"user_id":null,"body":"let rec square_sum (numbers : int list) : int =\n  match numbers with\n    | [] -> 0\n    | head :: tail -> head * head + (square_sum tail)\n   ","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83791,"user_id":null,"body":"let square_sum (numbers : int list) : int =\n  \/\/ your code goes here\n   numbers |> List.map(fun x -> x*x) |> List.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83792,"user_id":null,"body":"let square_sum (numbers : int list) : int =\n  numbers |> List.map (fun n -> n * n) |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83793,"user_id":null,"body":"let square_sum numbers = numbers |> List.map (fun n -> n * n) |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83794,"user_id":575,"body":"let square_sum (numbers : int list) : int =\n  numbers\n  |> Seq.sumBy (fun x -> x * x)\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83795,"user_id":null,"body":"let square_sum (numbers : int list) : int =\n  List.fold (fun x y -> x + y * y) 0 numbers\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83796,"user_id":null,"body":"let square_sum (numbers : int list) : int =\n  numbers |> List.map(fun x -> x*x)\n    |> List.fold(fun acc x -> acc+x) 0\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83797,"user_id":null,"body":"let square_sum (numbers : int list) : int =\n  List.fold (fun (acc:int)(x:int)-> (pown x 2)+acc) 0 numbers\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83798,"user_id":null,"body":"let square_sum (numbers : int list) : int = List.sumBy (fun n -> n*n) numbers","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"517abf86da9663f1d2000003":[{"id":83799,"user_id":null,"body":"let to_camel_case (text : string) =\n    text.Split('-', '_')\n    |> Seq.mapi (fun i s -> if i > 0 then s.[0..0].ToUpper() + s.[1..] else s)\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83800,"user_id":null,"body":"open System\n\nlet to_camel_case (text : string) =\n  let rec transform (acc: char list) = function\n    | '-' :: x :: rest \n    | '_' :: x :: rest -> transform ((Char.ToUpper x) :: acc) rest\n    | x :: rest -> transform (x :: acc) rest\n    | [] -> acc |> Array.ofList |> Array.rev \n\n  let chars = text.ToCharArray() |> List.ofArray\n\n  new string(transform [] chars)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83801,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet to_camel_case (text : string) =\n  let evaluator = MatchEvaluator(fun x -> x.Groups.[1].Value.ToUpper())\n  Regex.Replace(text, @\"[_-](\\w)\", evaluator)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83802,"user_id":null,"body":"open System\n\nlet to_camel_case (text : string) =\n    let rec change (condition : char -> bool) list =\n        match list with\n        | fch :: sch :: rest when condition fch -> Char.ToUpper sch :: change condition rest\n        | fch :: rest -> fch :: change condition rest\n        | rest -> rest\n  \n    text\n    |> List.ofSeq\n    |> change (fun ch -> ch = '_' || ch = '-')\n    |> List.toArray\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83803,"user_id":null,"body":"open System\n\nlet capitalize (text: string) =\n  Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase text\n  \nlet to_camel_case (text : string) =\n  let split = text.Split [|'-'; '_'|]\n  let first = split.[0]\n  let rest = split.[1..] |> Array.map capitalize\n  String.concat \"\" (Array.append [|first|] rest)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83804,"user_id":null,"body":"let to_camel_case (text : string) =\n    text.Split([|'-'; '_'|])\n    |> (fun arr -> \n        match arr with\n        | [||] -> \"\"\n        | [|_|] -> arr.[0]\n        | _ -> \n            arr\n            |> Array.toList\n            |> function\n            | h::t -> \n                [(if h.Substring(0,1) = h.Substring(0,1).ToUpper() \n                then h.Substring(0,1) + h.Substring(1).ToLower()\n                else h.ToLower())] @\n                (t |> List.map (fun s -> s.Substring(0,1).ToUpper() + s.Substring(1).ToLower()))\n                |> Seq.reduce (+)\n            | _ -> \"\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83805,"user_id":null,"body":"open System\n\nlet firstToUpper (word: string) =\n    let f = (word.[0] |> string).ToUpper()\n    f + (word |> Seq.skip 1 |> String.Concat)\n\nlet to_camel_case (text: string) =\n    let all = text.Split([| '-'; '_' |])\n    let s = all.[0]\n    let ss = all |> Array.skip 1 |> Array.map firstToUpper\n    s + (ss |> String.Concat)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83806,"user_id":null,"body":"open System\n\nlet capitalizeFirst (str : string) =\n    str\n    |> Seq.mapi (fun idx c -> if idx = 0 then Char.ToUpper c else c)\n    |> String.Concat\n\nlet to_camel_case (text : string) =\n    text.Split('-', '_')\n    |> Seq.mapi (fun idx str -> if idx = 0 then str else capitalizeFirst str)\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83807,"user_id":null,"body":"open System\n\nlet upper (s: string) =\n    s |> Seq.mapi (fun i c -> match i with | 0 -> (Char.ToUpper(c)) | _ -> c)  |> String.Concat\n\nlet subsequentUpper (s: string[]) = \n    s |> Seq.mapi (fun i c -> match i with | 0 -> c | _ -> upper c)  |> String.Concat\n \nlet to_camel_case (text : string) =\n  text.Split('_', '-') |> subsequentUpper \n  \/\/ your code here\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83808,"user_id":null,"body":"let toCapital (text: string) : string =\n    text.[0].ToString().ToUpper() + text.Substring(1)\n\nlet to_camel_case (text: string) =\n    let arr = text.Split('-', '_')\n\n    ((arr |> Array.head, arr |> Array.tail)\n     ||> Array.fold (fun acc charge -> acc + toCapital charge))\n        .Trim()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"51b6249c4612257ac0000005":[{"id":83809,"user_id":null,"body":"let solution (romanNumeral : string) = \n    let rec FromRomanRec (acc, last) c = \n        let n = match c with\n                | 'I' -> 1\n                | 'V' -> 5\n                | 'X' -> 10\n                | 'L' -> 50\n                | 'C' -> 100\n                | 'D' -> 500\n                | 'M' -> 1000\n                | _ -> 0\n        let op = if n > last then (-) else (+)\n        (op acc last, n)\n    let (acc, last) = Seq.fold FromRomanRec (0,0) romanNumeral\n    acc + last","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83810,"user_id":null,"body":"let solution (roman: string) =\n  let convert (acc, last) c = \n    let n = match c with\n      | 'M' -> 1000\n      | 'D' -> 500\n      | 'C' -> 100\n      | 'L' -> 50\n      | 'X' -> 10\n      | 'V' -> 5\n      | 'I' -> 1\n      | _ -> 0\n    let op = if n > last then (-) else (+)\n    (op acc last, n)\n  let (acc, last) = Seq.fold convert (0,0) roman\n  acc + last","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83811,"user_id":null,"body":"open System\nopen System.Text\nopen System.Collections.Generic\n\ntype RomanDigit = I | V | X | L | C | D | M\ntype RomanNumeral = RomanNumeral of RomanDigit list\ntype ParsedChar =\n    | Digit of RomanDigit\n    | BadChar of char\n\nlet digitToInt =\n    function\n        | I -> 1\n        | V -> 5\n        | X -> 10\n        | L -> 50\n        | C -> 100\n        | D -> 500\n        | M -> 1000\n\nlet rec digitsToInt =\n    function\n        | [] -> 0\n        | smaller :: larger :: ns when smaller < larger ->\n            (digitToInt larger - digitToInt smaller)  + digitsToInt ns\n        | digit :: ns ->\n            digitToInt digit + digitsToInt ns\n\nlet toInt (RomanNumeral digits) = digitsToInt digits\n\nlet charToRomanDigit =\n    function\n        | 'I' -> Digit I\n        | 'V' -> Digit V\n        | 'X' -> Digit X\n        | 'L' -> Digit L\n        | 'C' -> Digit C\n        | 'D' -> Digit D\n        | 'M' -> Digit M\n        | ch -> BadChar ch\n        \nlet toRomanDigitList (s: string) =\n    s\n    |> Seq.toList\n    |> List.map charToRomanDigit\n\nlet toRomanNumeral s =\n    toRomanDigitList s\n    |> List.choose (\n        function\n            | Digit digit ->\n                Some digit\n            | BadChar ch ->\n                eprintfn \"%c is not a valid character\" ch\n                None\n        )\n    |> RomanNumeral\n\nlet solution (romanNumeral: string) =\n    toRomanNumeral romanNumeral\n    |> toInt","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83812,"user_id":null,"body":"open System\nopen System.Text\nopen System.Collections.Generic\nlet solution (romanNumeral: string) = romanNumeral |> Seq.map (fun x -> ([|'I',1;'V',5;'X',10;'L',50;'C',100;'D',500;'M',1000|] |> Map.ofArray).[x]) |>Seq.rev |>Seq.reduce (fun a b -> (a + if a <= b*3 then b else -b)) \n\/\/ same number cannot bigger than 3","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83813,"user_id":null,"body":"let fromRomanLetter letter =\n    match letter with\n    | 'I' -> 1\n    | 'V' -> 5\n    | 'X' -> 10\n    | 'L' -> 50\n    | 'C' -> 100\n    | 'D' -> 500\n    | 'M' -> 1000\n    | _ -> 0\n\nlet solution (romanNumeral: string) =\n    let numbers = romanNumeral\n                |> Seq.rev\n                |> Seq.map fromRomanLetter\n                |> Seq.toList\n    numbers\n        |> Seq.pairwise\n        |> Seq.fold (fun state (x, y) -> state + (if x > y then -y else y)) (Seq.head numbers)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83814,"user_id":878,"body":"let numeralChars = Map([\n  ('I', 1);\n  ('V', 5);\n  ('X', 10);\n  ('L', 50);\n  ('C', 100);\n  ('D', 500);\n  ('M', 1000)\n])\n\nlet solution (romanNumeral: string) =\n    let nums =\n        Seq.map (fun chr -> Map.find chr numeralChars) romanNumeral\n        |> Seq.toArray\n    \n    nums\n    |> Array.mapi (fun i num ->\n        let isPrefix = Seq.exists (fun l -> l > num) nums.[i..]\n        if isPrefix then -1 * num else num)\n    |> Array.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83815,"user_id":null,"body":"let toDecimal = function\n    | 'I' -> 1\n    | 'V' -> 5\n    | 'X' -> 10\n    | 'L' -> 50\n    | 'C' -> 100\n    | 'D' -> 500\n    | 'M' -> 1000\n    | _ -> failwith \"Incorrect character\"\n\nlet folder sum (fst, snd) =\n    let op =\n        if fst>=snd \n        then (+) \n        else (-)\n    op sum fst\n\nlet solution (romanNumeral: string) =\n    romanNumeral\n    |> Seq.map toDecimal\n    |> (fun sq -> Seq.append sq [0])\n    |> Seq.pairwise\n    |> Seq.fold folder 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83816,"user_id":null,"body":"let parseRoman input =\n        match input with\n       | \"I\" -> 1\n       | \"V\" -> 5\n       | \"X\" -> 10\n       | \"L\" -> 50\n       | \"C\" -> 100\n       | \"D\" -> 500\n       | \"M\" -> 1000\n       | _ -> failwith \"todo\"\n\nlet addSignToRomanLiteral (current,next) =\n    if current < next then\n        - current\n    else\n        current\n\nlet rec sum (acc:int) (input:int list) =\n    match input with\n    | current::next::tail -> sum (acc + addSignToRomanLiteral (current, next)) (next::tail)\n    | [current] -> acc + current\n    | _ -> failwith \"todo\"\n\nlet solution (romanNumeral: string) =\n    romanNumeral\n    |> Seq.map string\n    |> Seq.map parseRoman\n    |> Seq.toList\n    |> (sum 0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83817,"user_id":null,"body":"type RomanLiteral =\n   | Zero = 0\n   | I = 1\n   | V = 5\n   | X = 10\n   | L = 50\n   | C = 100\n   | D = 500\n   | M = 1000\n\ntype State =\n   {\n      Accum: int\n      SkipStep: bool\n   }\n\nlet toLiteral = function\n   | 'I' -> RomanLiteral.I\n   | 'V' -> RomanLiteral.V\n   | 'X' -> RomanLiteral.X\n   | 'L' -> RomanLiteral.L\n   | 'C' -> RomanLiteral.C\n   | 'D' -> RomanLiteral.D\n   | 'M' -> RomanLiteral.M\n   | _ -> failwith \"The character is not valid Roman number literal\"\n\nlet folder (state:State) pair =\n   let {Accum=accum; SkipStep=skipStep} = state\n   match pair with\n   | fst, snd when fst >= snd && (not skipStep) -> \n      {state with Accum = (int fst + accum); SkipStep = false}\n   | fst, snd when fst < snd -> \n      {state with Accum = (int (snd - fst) + accum); SkipStep = true}\n   |_ -> {state with SkipStep = false}\n\nlet solution (romanNumeral: string) =\n   let res = \n      romanNumeral\n      |> Seq.map toLiteral\n      |> (fun sq -> Seq.append sq [RomanLiteral.Zero])\n      |> Seq.pairwise\n      |> Seq.fold folder {Accum = 0; SkipStep = false}\n   res.Accum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83818,"user_id":null,"body":"let vals = \n  [\n    ('I', 1)\n    ('V', 5)\n    ('X', 10)\n    ('L', 50)\n    ('C', 100)\n    ('D', 500)\n    ('M', 1000)\n  ] |> Map.ofList\n  \n  \ntype State = { Result: int; Last: int }\n\nlet parse r = \n  Map.find r vals\n\nlet aux state next =\n  let i = parse next\n  let (newResult, newLast) = \n    if i < state.Last then\n      (state.Result - i, state.Last)\n    else\n      (state.Result + i, i)\n  { state with Result = newResult; Last = newLast }\n\nlet solution (romanNumeral: string) = \n  let state = { Result = 0; Last = 0 }\n  \n  let s = \n    romanNumeral\n    |> Seq.rev \n    |> Seq.fold aux state\n  \n  s.Result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"51b66044bce5799a7f000003":[{"id":83819,"user_id":168,"body":"let Table = Map.ofList [\n  \"I\", 1; \"IV\", 4; \"V\", 5; \"IX\", 9; \"X\", 10; \"XL\", 40; \"L\", 50;\n  \"XC\", 90; \"C\", 100; \"CD\", 400; \"D\", 500; \"CM\", 900; \"M\", 1000\n]\n\nlet RevTable = Table |> Map.toList |> List.sortByDescending snd\n\nlet rec from_roman (r: string) =\n  match String.length r with\n  | 0 -> 0\n  | n when n >= 2 && Map.containsKey r.[0..1] Table ->\n    Map.find r.[0..1] Table + from_roman r.[2..]\n  | _ -> Map.find r.[0..0] Table + from_roman r.[1..]\n\nlet to_roman (n: int) =\n  RevTable\n  |> List.fold (fun (r, n) (k, v) -> r + String.replicate (n \/ v) k, n % v) (\"\", n)\n  |> fst\n  \nopen System.Text\nopen System.Collections.Generic\nopen System","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83820,"user_id":53,"body":"open System\nopen System.Text\nopen System.Collections.Generic\n\nlet from_roman (romanNumeral: string) =\n  let r = [\"M\";\"CM\";\"D\";\"CD\";\"C\";\"XC\";\"L\";\"XL\";\"X\";\"IX\";\"V\";\"IV\";\"I\"]\n  let p = [1000;900;500;400;100;90;50;40;10;9;5;4;1]\n  let mutable ans = 0\n  let mutable m = romanNumeral\n  let mutable wm = String.length m\n  for i in 0 .. 12 do\n    let w = String.length r.[i]\n    while wm >= w && m.[..w-1] = r.[i] do\n      m <- m.[w..]\n      ans <- ans + p.[i]\n      wm <- String.length m\n  ans\n\nlet from_roman (n:int) = \n  let r = [\"M\";\"CM\";\"D\";\"CD\";\"C\";\"XC\";\"L\";\"XL\";\"X\";\"IX\";\"V\";\"IV\";\"I\"]\n  let p = [1000;900;500;400;100;90;50;40;10;9;5;4;1]\n  let mutable ans = \"\"\n  let mutable m = n\n  for i in 0 .. 12 do\n    while m >= p.[i] do\n      ans <- ans + r.[i]\n      m <- m - p.[i]\n  ans","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83821,"user_id":null,"body":"type RomanNumeral = { Character: char; Base10Value: int }\n\nlet ascendingRomanNumerals =\n    [ { Character = 'I'; Base10Value = 1 }\n      { Character = 'V'; Base10Value = 5 }\n      { Character = 'X'; Base10Value = 10 }\n      { Character = 'L'; Base10Value = 50 }\n      { Character = 'C'; Base10Value = 100 }\n      { Character = 'D'; Base10Value = 500 }\n      { Character = 'M'; Base10Value = 1000 } ]\n\nmodule Lookup =\n    let private base10from_romanCharPairs =\n        List.map (fun rn -> rn.Character, rn.Base10Value) ascendingRomanNumerals\n\n    let Base10from_romanChar = dict base10from_romanCharPairs\n\n    let RomanCharFromBase10 =\n        base10from_romanCharPairs\n        |> List.map (fun (x, y) -> y, x)\n        |> dict\n\nmodule Base10from_romanUtils =\n    let usingBase10Value = fun rn -> rn.Base10Value\n\n    let descendingRomanNumerals =\n        List.sortByDescending usingBase10Value ascendingRomanNumerals\n\n    \/\/\/ Sift out digits and their 'powers'. Big -> small, Left -> right.\n    let getPositionalValues (base10Val: int) =\n\n        let stringd = string base10Val\n        let lengthToIndexCompensation = stringd.Length - 1\n\n        let _gpv position (c: char) =\n            \/\/ (string) for proper conversion to int from char.\n            let digit = (string >> float) c\n\n            if digit = 0. then\n                None\n            else\n                let exponent =\n                    10.\n                    ** (float (lengthToIndexCompensation - position)) \/\/ -1: Ix-length compensation\n\n                digit * exponent |> (int >> Some)\n\n        stringd |> (Seq.mapi _gpv >> Seq.choose id)\n\n    let private isIn characterList (num: int) =\n        let firstDigit = (string num).[0]\n        characterList |> List.contains firstDigit\n\n    let largestRomanNumeral = List.maxBy usingBase10Value ascendingRomanNumerals\n\n    \/\/ Active patterns\n    let (|IsMultiplesOf|ExactRN|Down1|Suffixes|Repeating|) positionalValue =\n        \/\/ gotcha, canoot like input 5001. 5000 ok..\n        let hasMultiples =\n            positionalValue > largestRomanNumeral.Base10Value\n            || positionalValue |> isIn [ (*'1';*) '2'; '3' ] \/\/ '1' no multiples. Only 1.\n\n        if hasMultiples then\n            IsMultiplesOf\n        elif positionalValue |> isIn [ '1'; '5' ] then\n            ExactRN\n        elif positionalValue |> isIn [ '4'; '9' ] then \/\/ e.g. \"IV\", \"IX\".\n            Down1\n        elif positionalValue |> isIn [ '6'; '7'; '8' ] then \/\/ e.g. \"VI\", \"VII\".\n            Suffixes\n        else\n            Repeating \/\/ e.g. \"XX\" = 20\n\n    let descendingPeripheralRomans =\n        descendingRomanNumerals\n        \/\/ starts with '1'\/'I', etc.. (the appending\/prepended numerals).\n        |> List.filter (fun rn -> (string >> Seq.head >> (=) '1') rn.Base10Value)\n\n    let getPeripheralNumeralFor num =\n        descendingPeripheralRomans\n        |> Seq.find (fun rn -> num > rn.Base10Value)\n\n    let to_romanNumeral (num: int) =\n        match num with\n        | IsMultiplesOf ->\n            let baseVal =\n                descendingPeripheralRomans\n                |> List.find (fun rn -> num >= rn.Base10Value)\n\n            let times = num \/ baseVal.Base10Value\n\n            String.replicate times (string baseVal.Character)\n\n        | ExactRN -> Lookup.RomanCharFromBase10.[num] |> string\n        | Down1 ->\n            let prefixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> rn.Base10Value > num) ascendingRomanNumerals\n            sprintf \"%c%c\" prefixNumeral.Character baseNumeral.Character\n\n        | Suffixes ->\n            let suffixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> num > rn.Base10Value) descendingRomanNumerals\n            let nTimes = ((string num).[0] |> string |> int) - 5\n            sprintf \"%c%s\" baseNumeral.Character (String.replicate nTimes (string suffixNumeral.Character))\n\n        | Repeating ->\n            let numeral = getPeripheralNumeralFor num\n            String.replicate num (string numeral.Character)\n\nlet from_roman =\n    (Base10from_romanUtils.getPositionalValues\n     >> Seq.map Base10from_romanUtils.to_romanNumeral\n     >> String.concat \"\")\n\nlet pivotsFrom pivotChar =\n    function\n    | 'I' -> pivotChar = 'V' || pivotChar = 'X'\n    | 'X' -> pivotChar = 'L' || pivotChar = 'C'\n    | 'C' -> pivotChar = 'D' || pivotChar = 'M'\n    | _ -> false\n\nlet from_roman (str: string) =\n    str\n    |> Seq.rev\n    |> Seq.unfold (fun revStrChars ->\n        if Seq.isEmpty revStrChars then\n            None\n        else\n            let firstCharFromRight = Seq.head revStrChars\n            let firstCharBase10Val = Lookup.Base10from_romanChar.[firstCharFromRight]\n            let sameAsFirstChar = (=) firstCharFromRight\n\n            if revStrChars |> Seq.forall sameAsFirstChar then\n                Some(firstCharBase10Val * (Seq.length revStrChars), Seq.empty)\n            else\n                let nextChar = (Seq.skipWhile sameAsFirstChar >> Seq.head) revStrChars\n\n                let nextCharVal = Lookup.Base10from_romanChar.[nextChar]\n\n                let carryOver utilizedChars = Seq.skip utilizedChars revStrChars\n\n                if firstCharFromRight |> pivotsFrom nextChar then \/\/ e.g. \"VI\"\n                    let multiplesLength = (Seq.takeWhile sameAsFirstChar >> Seq.length) revStrChars\n\n                    let interimResult = nextCharVal + firstCharBase10Val * multiplesLength\n\n                    Some(interimResult, carryOver (multiplesLength + 1)) \/\/ 1 is next char..\n\n                elif nextChar |> pivotsFrom firstCharFromRight then \/\/ e.g. \"IV\"\n                    let interimResult = firstCharBase10Val - nextCharVal\n\n                    Some(interimResult, carryOver 2)\n\n                else \/\/ e.g. \"XV\"; independant of each other.\n                    Some(firstCharBase10Val, carryOver 1))\n    |> Seq.reduce (+)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83822,"user_id":null,"body":"type RomanNumeral = { Character: char; Base10Value: int }\n\nlet ascendingRomanNumerals =\n    [ { Character = 'I'; Base10Value = 1 }\n      { Character = 'V'; Base10Value = 5 }\n      { Character = 'X'; Base10Value = 10 }\n      { Character = 'L'; Base10Value = 50 }\n      { Character = 'C'; Base10Value = 100 }\n      { Character = 'D'; Base10Value = 500 }\n      { Character = 'M'; Base10Value = 1000 } ]\n\nmodule Lookup =\n    let private base10from_romanCharPairs =\n        List.map (fun rn -> rn.Character, rn.Base10Value) ascendingRomanNumerals\n\n    let Base10from_romanChar = dict base10from_romanCharPairs\n\n    let RomanCharFromBase10 =\n        base10from_romanCharPairs\n        |> List.map (fun (x, y) -> y, x)\n        |> dict\n\nmodule Base10from_romanUtils =\n    let usingBase10Value = fun rn -> rn.Base10Value\n\n    let descendingRomanNumerals =\n        List.sortByDescending usingBase10Value ascendingRomanNumerals\n\n    \/\/\/ Sift out digits and their 'powers'. Big -> small, Left -> right.\n    let getPositionalValues (base10Val: int) =\n\n        let stringd = string base10Val\n\n        let _getPosVal position (c: char) =\n            \/\/ (string) for proper conversion to int from char.\n            let digit = (string >> float) c\n\n            if digit = 0. then\n                None\n            else\n                let exponent = 10. ** (float (stringd.Length - position - 1)) \/\/ -1: Ix-length compensation\n                digit * exponent |> (int >> Some)\n\n        stringd |> (Seq.mapi _getPosVal >> Seq.choose id)\n\n    let private isIn characterList (num: int) =\n        let firstDigit = (string num).[0]\n        characterList |> List.contains firstDigit\n\n    let largestRomanNumeral = List.maxBy usingBase10Value ascendingRomanNumerals\n\n    \/\/ Active patterns\n    let (|IsMultiplesOf|ExactRN|Down1|Suffixes|Repeating|) positionalValue =\n        \/\/ gotcha, canoot like input 5001. 5000 ok..\n        let hasMultiples =\n            positionalValue > largestRomanNumeral.Base10Value\n            || positionalValue |> isIn [ (*'1';*) '2'; '3' ] \/\/ '1' no multiples. Only 1.\n\n        if hasMultiples then\n            IsMultiplesOf\n        elif positionalValue |> isIn [ '1'; '5' ] then\n            ExactRN\n        elif positionalValue |> isIn [ '4'; '9' ] then \/\/ e.g. \"IV\", \"IX\".\n            Down1\n        elif positionalValue |> isIn [ '6'; '7'; '8' ] then \/\/ e.g. \"VI\", \"VII\".\n            Suffixes\n        else\n            Repeating \/\/ e.g. \"XX\" = 20\n\n    let descendingPeripheralRomans =\n        descendingRomanNumerals\n        \/\/ starts with '1'\/'I', etc.. (the appending\/prepended numerals).\n        |> List.filter (fun rn -> (string >> Seq.head >> (=) '1') rn.Base10Value)\n\n    let getPeripheralNumeralFor num =\n        descendingPeripheralRomans\n        |> Seq.find (fun rn -> num > rn.Base10Value)\n\n    let to_romanNumeral (num: int) =\n        match num with\n        | IsMultiplesOf ->\n            let baseVal =\n                descendingPeripheralRomans\n                |> List.find (fun rn -> num >= rn.Base10Value)\n\n            let times = num \/ baseVal.Base10Value\n\n            String.replicate times (string baseVal.Character)\n\n        | ExactRN -> Lookup.RomanCharFromBase10.[num] |> string\n        | Down1 ->\n            let prefixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> rn.Base10Value > num) ascendingRomanNumerals\n            sprintf \"%c%c\" prefixNumeral.Character baseNumeral.Character\n\n        | Suffixes ->\n            let suffixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> num > rn.Base10Value) descendingRomanNumerals\n            let nTimes = ((string num).[0] |> string |> int) - 5\n            sprintf \"%c%s\" baseNumeral.Character (String.replicate nTimes (string suffixNumeral.Character))\n\n        | Repeating ->\n            let numeral = getPeripheralNumeralFor num\n            String.replicate num (string numeral.Character)\n\nlet from_roman =\n    (Base10from_romanUtils.getPositionalValues\n     >> Seq.map Base10from_romanUtils.to_romanNumeral\n     >> String.concat \"\")\n\nlet pivotsFrom pivotChar = \/\/ 2 references\n    function\n    | 'I' -> pivotChar = 'V' || pivotChar = 'X'\n    | 'X' -> pivotChar = 'L' || pivotChar = 'C'\n    | 'C' -> pivotChar = 'D' || pivotChar = 'M'\n    | _ -> false\n\nlet from_roman =\n    Seq.reduce (+)\n    << Seq.unfold (fun str ->\n        if str = \"\" then\n            None\n        else\n            let firstChar = str |> Seq.last\n            let firstCharBase10Val = Lookup.Base10from_romanChar.[firstChar]\n            let sameAsFirstChar = (=) firstChar\n\n            if str |> Seq.forall sameAsFirstChar then\n                Some(firstCharBase10Val * str.Length, \"\")\n            else\n                let reversdStr = Seq.rev str\n\n                let nextChar = (Seq.skipWhile sameAsFirstChar >> Seq.head) reversdStr\n\n                let nextCharVal = Lookup.Base10from_romanChar.[nextChar]\n\n                let storeDataAndCarryOerNext currentResult utilizedChars =\n                    Some(\n                        currentResult,\n                        (Seq.skip utilizedChars\n                         >> Seq.rev\n                         >> Seq.fold (fun acc el -> acc + string el) \"\")\n                            reversdStr\n                    )\n\n                if firstChar |> pivotsFrom nextChar then \/\/ e.g. \"VII\"\n                    let multiplesLength = (Seq.takeWhile sameAsFirstChar >> Seq.length) reversdStr\n\n                    let interimResult = nextCharVal + firstCharBase10Val * multiplesLength\n\n                    storeDataAndCarryOerNext interimResult (multiplesLength + 1) \/\/ 1 is next char..\n\n                elif nextChar |> pivotsFrom firstChar then \/\/ e.g. \"IV\"\n                    let interimResult = firstCharBase10Val - nextCharVal\n\n                    storeDataAndCarryOerNext interimResult 2\n\n                else \/\/ e.g. \"XV\"; independant of each other.\n                    storeDataAndCarryOerNext firstCharBase10Val 1)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83823,"user_id":null,"body":"type RomanNumeral = { Character: char; Base10Value: int }\n\nlet ascendingRomanNumerals =\n    [ { Character = 'I'; Base10Value = 1 }\n      { Character = 'V'; Base10Value = 5 }\n      { Character = 'X'; Base10Value = 10 }\n      { Character = 'L'; Base10Value = 50 }\n      { Character = 'C'; Base10Value = 100 }\n      { Character = 'D'; Base10Value = 500 }\n      { Character = 'M'; Base10Value = 1000 } ]\n\nmodule Lookup =\n    let private base10from_romanCharPairs =\n        List.map (fun rn -> rn.Character, rn.Base10Value) ascendingRomanNumerals\n\n    let Base10from_romanChar = dict base10from_romanCharPairs\n\n    let RomanCharFromBase10 =\n        base10from_romanCharPairs\n        |> List.map (fun (x, y) -> y, x)\n        |> dict\n\nmodule Base10from_romanUtils =\n    let usingBase10Value = fun rn -> rn.Base10Value\n\n    let descendingRomanNumerals =\n        List.sortByDescending usingBase10Value ascendingRomanNumerals\n\n    \/\/\/ Sift out digits and their 'powers'. Big -> small, Left -> right.\n    let getPositionalValues (base10Val: int) =\n\n        let stringd = string base10Val\n\n        let _getPosVal position (c: char) =\n            \/\/ (string) for proper conversion to int from char.\n            let digit = (string >> float) c\n\n            if digit = 0. then\n                None\n            else\n                let exponent = 10. ** (float (stringd.Length - position - 1)) \/\/ -1 Ix-length compensation\n                digit * exponent |> (int >> Some)\n\n        stringd |> (Seq.mapi _getPosVal >> Seq.choose id)\n\n    let private isIn characterList (num: int) =\n        let firstDigit = (string num).[0]\n        characterList |> List.contains firstDigit\n\n    let largestRomanNumeral = List.maxBy usingBase10Value ascendingRomanNumerals\n\n    \/\/ Active patterns\n    let (|IsMultiplesOf|ExactRN|Down1|Suffixes|Repeating|) positionalValue =\n        \/\/ gotcha, canoot like input 5001. 5000 ok..\n        let hasMultiples =\n            positionalValue > largestRomanNumeral.Base10Value\n            || positionalValue |> isIn [ (*'1';*) '2'; '3' ] \/\/ '1' in next filter.\n\n        if hasMultiples then\n            IsMultiplesOf\n        elif positionalValue |> isIn [ '1'; '5' ] then\n            ExactRN\n        elif positionalValue |> isIn [ '4'; '9' ] then \/\/ e.g. \"IV\", \"IX\".\n            Down1\n        elif [ '6'; '7'; '8' ]\n             |> List.contains (string positionalValue).[0] then\n            Suffixes\n        else\n            Repeating \/\/ e.g. \"XX\" = 20\n\n    \/\/\/ starts with '1'\/'I', etc.. (the appending\/prepended numerals).\n    \/\/ Naming makes sense when in line'd with collection operator.\n    let forPeripheralNumerals = fun rn -> (string >> Seq.head >> (=) '1') rn.Base10Value\n\n    let getPeripheralNumeralFor num =\n        descendingRomanNumerals\n        |> List.filter forPeripheralNumerals\n        |> Seq.find (fun rn -> num > rn.Base10Value)\n\n    let to_romanNumeral (num: int) =\n        match num with\n        | IsMultiplesOf ->\n            let baseVal =\n                ascendingRomanNumerals\n                |> List.filter forPeripheralNumerals\n                |> List.sortByDescending usingBase10Value\n                |> List.find (fun rn -> num >= rn.Base10Value)\n\n            let times = num \/ baseVal.Base10Value\n\n            String.replicate times (string baseVal.Character)\n\n        | ExactRN -> Lookup.RomanCharFromBase10.[num] |> string\n        | Down1 ->\n            let prefixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> rn.Base10Value > num) ascendingRomanNumerals\n            sprintf \"%c%c\" prefixNumeral.Character baseNumeral.Character\n\n        | Suffixes ->\n            let suffixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> num > rn.Base10Value) descendingRomanNumerals\n            let nTimes = ((string num).[0] |> string |> int) - 5\n            sprintf \"%c%s\" baseNumeral.Character (String.replicate nTimes (string suffixNumeral.Character))\n\n        | Repeating ->\n            let numeral = getPeripheralNumeralFor num\n            String.replicate num (string numeral.Character)\n\nlet from_roman =\n    (Base10from_romanUtils.getPositionalValues\n     >> Seq.map Base10from_romanUtils.to_romanNumeral\n     >> String.concat \"\")\n\nlet pivotsFrom pivotChar = \/\/ 2 references\n    function\n    | 'I' -> pivotChar = 'V' || pivotChar = 'X'\n    | 'X' -> pivotChar = 'L' || pivotChar = 'C'\n    | 'C' -> pivotChar = 'D' || pivotChar = 'M'\n    | _ -> false\n\nlet from_roman =\n    Seq.reduce (+)\n    << Seq.unfold (fun str ->\n        if str = \"\" then\n            None\n        else\n            let firstChar = str |> Seq.last\n            let firstCharBase10Val = Lookup.Base10from_romanChar.[firstChar]\n            let sameAsFirstChar = (=) firstChar\n\n            if str |> Seq.forall sameAsFirstChar then\n                Some(firstCharBase10Val * str.Length, \"\")\n            else\n                let reversdStr = Seq.rev str\n\n                let nextChar = (Seq.skipWhile sameAsFirstChar >> Seq.head) reversdStr\n\n                let nextCharVal = Lookup.Base10from_romanChar.[nextChar]\n\n                let data4NextIteration currentResult utilizedChars =\n                    let carryOverStr =\n                        if str.Length = utilizedChars then\n                            \"\"\n                        else\n                            reversdStr\n                            |> (Seq.skip utilizedChars\n                                >> Seq.rev\n                                >> Seq.fold (fun acc el -> acc + string el) \"\")\n\n                    Some(currentResult, carryOverStr)\n\n                if firstChar |> pivotsFrom nextChar then \/\/ e.g. \"VII\"\n                    let multiplesLength = (Seq.takeWhile sameAsFirstChar >> Seq.length) reversdStr\n\n                    let interimResult = nextCharVal + firstCharBase10Val * multiplesLength\n\n                    data4NextIteration interimResult (multiplesLength + 1) \/\/ 1 is next char..\n\n                elif nextChar |> pivotsFrom firstChar then \/\/ e.g. \"IV\"\n                    let interimResult = firstCharBase10Val - nextCharVal\n\n                    data4NextIteration interimResult 2\n\n                else \/\/ e.g. \"XV\"; independant of each other.\n                    data4NextIteration firstCharBase10Val 1)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83824,"user_id":null,"body":"type RomanNumeral = { Character: char; Base10Value: int }\n\nlet ascendingRomanNumerals =\n    [ { Character = 'I'; Base10Value = 1 }\n      { Character = 'V'; Base10Value = 5 }\n      { Character = 'X'; Base10Value = 10 }\n      { Character = 'L'; Base10Value = 50 }\n      { Character = 'C'; Base10Value = 100 }\n      { Character = 'D'; Base10Value = 500 }\n      { Character = 'M'; Base10Value = 1000 } ]\n\nlet usingBase10Value = fun rn -> rn.Base10Value\n\nlet descendingRomanNumerals =\n    List.sortByDescending usingBase10Value ascendingRomanNumerals\n\nlet largestRomanNumeral = List.maxBy usingBase10Value ascendingRomanNumerals\n\nmodule Lookup =\n    let private Base10from_romanCharPairs =\n        List.map (fun rn -> rn.Character, rn.Base10Value) ascendingRomanNumerals\n\n    let Base10from_romanChar = dict Base10from_romanCharPairs\n\n    let RomanCharFromBase10 =\n        Base10from_romanCharPairs\n        |> List.map (fun (x, y) -> y, x)\n        |> dict\n\n    let pivotsFrom pivotChar =\n        function\n        | 'I' -> pivotChar = 'V' || pivotChar = 'X'\n        | 'X' -> pivotChar = 'L' || pivotChar = 'C'\n        | 'C' -> pivotChar = 'D' || pivotChar = 'M'\n        | _ -> false\n\nmodule FromBase10PosValues =\n    let private isIn characterList (num: int) =\n        characterList |> List.contains (string num).[0]\n\n    let isExactRomanEquivalent = isIn [ '1'; '5' ]\n\n    let isWatchMakers4ish = isIn [ '4'; '9' ]\n\n    \/\/\/ Sift out digits and their 'powers'. Big -> small, Left -> right.\n    let getPositionalValues (base10Val: int) =\n\n        let _getPosVal digitsLength ix (c: char) =\n            \/\/ (string) for proper conversion to int from char.\n            let digit = (string >> float) c\n\n            if digit = 0. then\n                None\n            else\n                let exponent = 10. ** (float (digitsLength - (ix + 1)))\n                digit * exponent |> (int >> Some)\n\n        let stringd = string base10Val\n\n        Seq.mapi (_getPosVal stringd.Length) stringd\n        |> Seq.choose id\n\n    \/\/ Active patterns\n    let (|IsMultiplesOf|ExactRN|Down1|Suffixes|Repeating|) positionalValue =\n        let stringd = string positionalValue\n        \/\/ gotcha, canoot like input 5001. 5000 ok..\n        let hasMultiples =\n            positionalValue > largestRomanNumeral.Base10Value\n            || [ '1'; '2'; '3' ] |> List.contains stringd.[0]\n\n        if hasMultiples then\n            IsMultiplesOf\n        elif isExactRomanEquivalent positionalValue then\n            ExactRN\n        elif isWatchMakers4ish positionalValue then\n            Down1\n        elif [ '6'; '7'; '8' ]\n             |> List.contains (string positionalValue).[0] then\n            Suffixes\n        else\n            Repeating \/\/ e.g. \"XX\" = 20\n\n    \/\/\/ starts with '1', the appending\/prepended numerals..\n    let forPeripheryNumerals = fun rn -> (string >> Seq.head >> (=) '1') rn.Base10Value\n\n    let getPeripheralNumeralFor num =\n        descendingRomanNumerals\n        |> List.filter forPeripheryNumerals\n        |> Seq.find (fun rn -> num > rn.Base10Value)\n\n    let getRomanNumeralFrom (num: int) =\n        match num with\n        | IsMultiplesOf ->\n            let baseVal =\n                ascendingRomanNumerals\n                |> List.filter forPeripheryNumerals\n                |> List.sortByDescending usingBase10Value\n                |> List.find (fun rn -> num >= rn.Base10Value)\n\n            let times = num \/ baseVal.Base10Value\n\n            String.replicate times (string baseVal.Character)\n\n        | ExactRN -> Lookup.RomanCharFromBase10.[num] |> string\n        | Down1 ->\n            let prefixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> rn.Base10Value > num) ascendingRomanNumerals\n            sprintf \"%c%c\" prefixNumeral.Character baseNumeral.Character\n\n        | Suffixes ->\n            let suffixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> num > rn.Base10Value) descendingRomanNumerals\n            let nTimes = ((string num).[0] |> string |> int) - 5\n            sprintf \"%c%s\" baseNumeral.Character (String.replicate nTimes (string suffixNumeral.Character))\n\n        | Repeating ->\n            let numeral = getPeripheralNumeralFor num\n            String.replicate num (string numeral.Character)\n\nlet from_roman =\n    (FromBase10PosValues.getPositionalValues\n     >> Seq.map FromBase10PosValues.getRomanNumeralFrom\n     >> String.concat \"\")\n\nlet from_roman =\n    Seq.unfold (fun str ->\n        if str = \"\" then\n            None\n        else\n            let firstChar = str |> Seq.last\n            let firstCharBase10Val = Lookup.Base10from_romanChar.[firstChar]\n            let sameAsFirstChar = (=) firstChar\n\n            if str |> Seq.forall sameAsFirstChar then\n                Some(firstCharBase10Val * str.Length, \"\")\n            else\n                let reversdStr = Seq.rev str\n                let nextChar = (Seq.skipWhile sameAsFirstChar >> Seq.head) reversdStr\n                let nextCharVal = Lookup.Base10from_romanChar.[nextChar]\n\n                let populateNext currentResult utilizedChars =\n                    let carryOverStr =\n                        if str.Length = utilizedChars then\n                            \"\"\n                        else\n                            reversdStr\n                            |> (Seq.skip utilizedChars\n                                >> Seq.rev\n                                >> Seq.fold (fun acc el -> acc + string el) \"\")\n\n                    Some(currentResult, carryOverStr)\n\n                if firstChar |> Lookup.pivotsFrom nextChar then \/\/ e.g. \"VII\"\n                    let pivotVal = nextCharVal\n                    let multiples = reversdStr |> Seq.takeWhile sameAsFirstChar\n                    let multiplesLength = Seq.length multiples\n\n                    let interimResult = pivotVal + firstCharBase10Val * multiplesLength\n\n                    populateNext interimResult (multiplesLength + 1) \/\/ 1 is next char..\n\n                elif nextChar |> Lookup.pivotsFrom firstChar then \/\/ e.g. \"IV\"\n                    let pivotVal = firstCharBase10Val\n                    let downVal = nextCharVal\n                    let interimResult = pivotVal - downVal\n\n                    populateNext interimResult 2\n\n                else \/\/ e.g. \"XV\"; independant of each other.\n                    populateNext firstCharBase10Val 1)\n    >> Seq.reduce (+)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83825,"user_id":null,"body":"type RomanNumeral = { Character: char; Base10Value: int }\n\nlet ascendingRomanNumerals =\n    [ { Character = 'I'; Base10Value = 1 }\n      { Character = 'V'; Base10Value = 5 }\n      { Character = 'X'; Base10Value = 10 }\n      { Character = 'L'; Base10Value = 50 }\n      { Character = 'C'; Base10Value = 100 }\n      { Character = 'D'; Base10Value = 500 }\n      { Character = 'M'; Base10Value = 1000 } ]\n\nlet descendingRomanNumerals =\n    List.sortByDescending (fun rn -> rn.Base10Value) ascendingRomanNumerals\n\nlet largestRomanNumeral =\n    List.maxBy (fun rn -> rn.Base10Value) ascendingRomanNumerals\n\nmodule Lookup =\n    let private Base10from_romanCharPairs =\n        List.map (fun rn -> rn.Character, rn.Base10Value) ascendingRomanNumerals\n\n    let Base10from_romanChar = dict Base10from_romanCharPairs\n\n    let RomanCharFromBase10 =\n        Base10from_romanCharPairs\n        |> List.map (fun (x, y) -> y, x)\n        |> dict\n\n    let pivotsFrom pivotChar =\n        function\n        | 'I' -> pivotChar = 'V' || pivotChar = 'X'\n        | 'X' -> pivotChar = 'L' || pivotChar = 'C'\n        | 'C' -> pivotChar = 'D' || pivotChar = 'M'\n        | _ -> false\n\nmodule FromBase10 =\n    let private isPartOf characterList (num: int) =\n        List.contains (string num).[0] characterList\n\n    let isExactRomanNumeralEquivalent = isPartOf [ '1'; '5' ]\n\n    let isSmallerThanRomanNumeralEquivalent = isPartOf [ '4'; '9' ]\n\n    \/\/\/ Sift out digits and their 'powers'. Big -> small, Left -> right.\n    let getPositionalValues (base10Val: int) =\n\n        let _getPosVal digitsLength ix (c: char) =\n            \/\/ (string) for proper conversion from int->'string'->char->int\n            let digit = (string >> float) c\n\n            if digit = 0. then\n                None\n            else\n                let exponent = 10. ** (float (digitsLength - (ix + 1)))\n                digit * exponent |> (int >> Some)\n\n        let stringd = string base10Val\n\n        Seq.mapi (_getPosVal stringd.Length) stringd\n        |> Seq.choose id\n\n    \/\/ Active patterns\n    let (|IsMultiplesOf|ExactRN|Down1|Suffixes|Repeating|) positionalValue =\n        let stringd = string positionalValue\n        \/\/ gotcha, canoot like input 5001. 5000 ok..\n        let hasMultiples =\n            positionalValue > largestRomanNumeral.Base10Value\n            || [ '1'; '2'; '3' ] |> List.contains stringd.[0]\n\n        if hasMultiples then\n            IsMultiplesOf\n        elif isExactRomanNumeralEquivalent positionalValue then\n            ExactRN\n        elif isSmallerThanRomanNumeralEquivalent positionalValue then\n            Down1\n        elif [ '6'; '7'; '8' ]\n             |> List.contains (string positionalValue).[0] then\n            Suffixes\n        else\n            Repeating \/\/ e.g. \"XX\" = 20\n\n    \/\/\/ starts with '1'..\n    let forPeripheryNumerals = fun rn -> (string >> Seq.head >> (=) '1') rn.Base10Value\n\n    let getPeripheralNumeralFor num =\n        ascendingRomanNumerals\n        |> List.filter forPeripheryNumerals\n        |> List.sortByDescending (fun rn -> rn.Base10Value) \/\/ can omit\n        |> Seq.find (fun rn -> num > rn.Base10Value)\n\n    let getRomanNumeralFrom (num: int) =\n        match num with\n        | IsMultiplesOf ->\n            let baseVal =\n                ascendingRomanNumerals\n                |> List.filter forPeripheryNumerals\n                |> List.sortByDescending (fun rn -> rn.Base10Value)\n                |> List.find (fun rn -> num >= rn.Base10Value)\n\n            let times = num \/ baseVal.Base10Value\n\n            String.replicate times (string baseVal.Character)\n\n        | ExactRN -> Lookup.RomanCharFromBase10.[num] |> string\n        | Down1 ->\n            let prefixNumeral = getPeripheralNumeralFor num\n            let baseNumeral = List.find (fun rn -> rn.Base10Value > num) ascendingRomanNumerals\n            sprintf \"%c%c\" prefixNumeral.Character baseNumeral.Character\n        | Suffixes ->\n            let suffixNumeral = getPeripheralNumeralFor num\n\n            let baseNumeral = List.find (fun rn -> num > rn.Base10Value) descendingRomanNumerals\n\n            let nSuffixes = ((string num).[0] |> string |> int) - 5\n\n            sprintf \"%c%s\" baseNumeral.Character (String.replicate nSuffixes (string suffixNumeral.Character))\n        | Repeating ->\n            let prefixOrSuffixNumeral = getPeripheralNumeralFor num\n            String.replicate num (string prefixOrSuffixNumeral.Character)\n\nlet from_roman =\n    (FromBase10.getPositionalValues\n     >> Seq.map FromBase10.getRomanNumeralFrom\n     >> String.concat \"\")\n\nlet from_roman =\n    Seq.unfold (fun str ->\n        if str = \"\" then\n            None\n        else\n            let firstChar = str |> Seq.last\n            let firstCharBase10Val = Lookup.Base10from_romanChar.[firstChar]\n            let sameAsFirstChar = (=) firstChar\n\n            if str |> Seq.forall sameAsFirstChar then\n                Some(firstCharBase10Val * str.Length, \"\")\n            else\n                let reversdStr = Seq.rev str\n\n                let nextChar = (Seq.skipWhile sameAsFirstChar >> Seq.head) reversdStr\n\n                let firstCharPivotsFromNextChar = firstChar |> Lookup.pivotsFrom nextChar\n\n                if firstCharPivotsFromNextChar then\n                    let pivotVal = Lookup.Base10from_romanChar.[nextChar]\n                    let multiples = reversdStr |> Seq.takeWhile sameAsFirstChar\n                    let multiplesLength = Seq.length multiples\n\n                    let interimResult = pivotVal + firstCharBase10Val * multiplesLength\n\n                    let utilized = multiplesLength + 1 \/\/ 1 is next char..\n\n                    let carryOverStr =\n                        if str.Length = utilized then\n                            \"\"\n                        else\n                            reversdStr\n                            |> Seq.skip utilized\n                            |> Seq.rev\n                            |> Seq.fold (fun acc el -> acc + string el) \"\"\n\n                    Some(interimResult, carryOverStr)\n\n                elif nextChar |> Lookup.pivotsFrom firstChar then\n                    let pivotVal = firstCharBase10Val\n                    let downVal = Lookup.Base10from_romanChar.[nextChar]\n                    let interimResult = pivotVal - downVal\n\n                    let carryOverStr =\n                        if str.Length = 2 then\n                            \"\"\n                        else\n                            reversdStr\n                            |> Seq.skip 2\n                            |> Seq.rev\n                            |> Seq.fold (fun acc el -> acc + string el) \"\"\n\n                    Some(interimResult, carryOverStr)\n                else\n                    let carryOverStr =\n                        if str.Length = 1 then\n                            \"\"\n                        else\n                            let sndLastIdx = str.Length - 2\n                            str.[..sndLastIdx]\n\n                    Some(firstCharBase10Val, carryOverStr)\n\n    )\n    >> Seq.reduce (+)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83826,"user_id":null,"body":"let from_roman (romanNumeral: string) = \n  let getValue (s: string) =  \n    match s with \n    | s when s = \"I\" -> 1\n    | s when s = \"V\" -> 5\n    | s when s = \"X\" -> 10\n    | s when s = \"L\" -> 50\n    | s when s = \"C\" -> 100\n    | s when s = \"D\" -> 500\n    | s when s = \"M\" -> 1000\n    | _ -> 0\n\n  let rec count (roman: string) (totalValue: int) (lastValue: int) (index: int) = \n      let value = string roman.[index] |> getValue\n      let newTotalValue = if value < lastValue then totalValue - value else totalValue + value\n\n      if index = 0 \n      then newTotalValue\n      else count roman newTotalValue value (index - 1)\n\n  count romanNumeral 0 0 (romanNumeral.Length - 1)\n\nlet from_roman (n:int) =\n  let mutable n = n\n\n  \/\/ first step\n  let kCount = n \/ 1000\n  let first = String.replicate kCount \"M\"\n  n <- n % 1000\n\n  \/\/ second step\n  let second = \n      match n \/ 100 with \n      | d when d = 9 -> \"CM\"\n      | d when d >= 5 -> \"D\" + String.replicate (d - 5) \"C\"\n      | d when d = 4 -> \"CD\"\n      | d -> String.replicate d \"C\"\n\n  n <- n % 100\n\n  \/\/ third step\n  let third = \n      match n \/ 10 with \n      | d when d = 9 -> \"XC\"\n      | d when d >= 5 -> \"L\" + String.replicate (d - 5) \"X\"\n      | d when d = 4 -> \"XL\"\n      | d -> String.replicate d \"X\"\n\n  n <- n % 10\n\n  \/\/ fourth step\n  let fourth = \n      match n with\n      | d when d = 9 -> \"IX\"\n      | d when d >= 5 -> \"V\" + String.replicate (d - 5) \"I\"\n      | d when d = 4 -> \"IV\"\n      | d -> String.replicate d \"I\"\n\n  first + second + third + fourth","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83827,"user_id":null,"body":"\/\/ Lightly touched from earlier Kata.\nlet from_roman (roman: string) =\n    let convert (acc, last) c = \n        let n = \n            match c with\n            | 'M' -> 1000\n            | 'D' -> 500\n            | 'C' -> 100\n            | 'L' -> 50\n            | 'X' -> 10\n            | 'V' -> 5\n            | 'I' -> 1\n            | _ -> 0\n        let op = if n > last then (-) else (+)\n        (op acc last), n\n    let (acc, last) = Seq.fold convert (0,0) roman\n    acc + last\n\n\/\/ Using record type for documentation\ntype Numeral = { Rep:string; Value:int}\nlet from_roman (n:int) =\n    let numerals = [\n        { Rep = \"M\"; Value = 1000; }\n        { Rep = \"CM\"; Value = 900;}\n        { Rep = \"D\"; Value = 500; }\n        { Rep = \"CD\"; Value = 400; }\n        { Rep = \"C\"; Value = 100; }\n        { Rep = \"XC\"; Value = 90; }\n        { Rep = \"L\"; Value = 50; }\n        { Rep = \"XL\"; Value = 40; }\n        { Rep = \"X\"; Value = 10; }\n        { Rep = \"IX\"; Value = 9; }\n        { Rep = \"V\"; Value = 5; }\n        { Rep = \"IV\"; Value = 4; }\n        { Rep = \"I\"; Value = 1; }\n    ]\n    let rec parse value numerals acc =\n        match value, numerals with\n        | 0, _ -> acc\n        | _, [] -> failwith \"Number can't be represented\"\n        | _, x::xs when value < x.Value -> parse value xs acc\n        | _, x::_ -> parse (value - x.Value) numerals (acc+(x.Rep))\n    parse n numerals \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83828,"user_id":null,"body":"let from_roman (romanNumeral: string) =\n    let romanToArabic =\n        Map [('I', 1); ('V', 5); ('X', 10); ('L', 50); ('C', 100); ('D', 500); ('M', 1000)]\n    Seq.toList (romanNumeral + (romanNumeral |> Seq.last |> string))\n        |> List.map (fun c -> romanToArabic.[c])\n        |> List.pairwise\n        |> List.map (fun (x, y) -> if x < y then -x else x)\n        |> List.sum\n\nlet to_roman (n: int) =\n    let bases = [1000; 900; 500; 400; 100; 90; 50; 40; 10; 9; 5; 4; 1]\n    let symbols = [\"M\"; \"CM\"; \"D\"; \"CD\"; \"C\"; \"XC\"; \"L\"; \"XL\"; \"X\"; \"IX\"; \"V\"; \"IV\"; \"I\"]\n    let rec digits (n: int) (xs: int list): int list =\n        match xs with\n        | [] -> []\n        | x :: xs -> (n \/ x) :: digits (n % x) xs\n    let dig = digits n bases\n    List.zip dig symbols\n        |> List.map (fun (d, s) -> [for _ in 1 .. d -> s])\n        |> List.concat\n        |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"51c7d8268a35b6b8b40002f2":[{"id":83829,"user_id":null,"body":"let solution pairs =\n  seq { for KeyValue (k, v) in pairs -> sprintf \"%O = %O\" k v }\n  |> String.concat \",\"\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83830,"user_id":491,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) = \n    Seq.zip dic.Keys dic.Values\n    |> Seq.map (fun (k, v) -> sprintf \"%c = %d\" k v)\n    |> String.concat \",\"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83831,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) =\n    let items = dic.Keys\n                |> Seq.map (fun key -> sprintf \"%O = %O\" key dic.[key])\n                |> Array.ofSeq\n    String.Join(\",\", items)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83832,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) = \n    [for i in dic -> string i.Key + \" = \" + string i.Value ] |> String.concat \",\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83833,"user_id":53,"body":"open System\nopen System.Collections.Generic\nopen System.Linq\n\nlet solution (dic:Dictionary<'TKey,'TValue>) =\n  System.String.Join(\",\", dic.Keys.Select(fun (key) -> key.ToString() + \" = \" + dic.[key].ToString()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83834,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) =\n  if dic.Count <= 0 then \"\" else\n    seq {\n        for entry in dic do \n            yield string entry.Key + \" = \" + string entry.Value\n    } |> Seq.reduce (fun curr next -> curr + \",\" + next)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83835,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) = \n    let keys = dic |> Dictionary.KeyCollection |> List.ofSeq\n    let values = dic |> Dictionary.ValueCollection |> List.ofSeq\n    [for i in 0..keys.Length-1 -> keys.[i].ToString()+\" = \"+values.[i].ToString()]\n    |> String.concat \",\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83836,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) = \n  let mutable result = \"\"\n  for elem in dic do\n    result <- result +  (elem.Key).ToString() + \" = \" + (elem.Value).ToString() + \",\"\n  result.[0..((String.length result)-2)]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83837,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet solution (dic:Dictionary<'TKey,'TValue>) =   \n       String.Join(\",\", \n        dic |> Seq.map (fun kvp -> (sprintf \"%s = %s\" (kvp.Key.ToString()) (kvp.Value.ToString()))))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83838,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet join (delim : string) (strings : string seq) = String.Join(delim, strings)\n\nlet solution (dict : IDictionary<'TKey,'TValue>) =\n    seq {\n        for pair in dict do\n            yield sprintf \"%s = %s\" (pair.Key.ToString()) (pair.Value.ToString())\n    }\n    |> join \",\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"51c8991dee245d7ddf00000e":[{"id":83839,"user_id":null,"body":"let reverseWords (str: string) =\n    str.Split ' ' |> Array.rev |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83840,"user_id":null,"body":"let reverseWords (str: string) =\n    str.Split() |> Seq.rev |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83841,"user_id":null,"body":"open System\n\nlet reverseWords (str : string) =\n    let words = str.Split()\n    Array.Reverse words\n    String.Join(\" \", words)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83842,"user_id":null,"body":"\nlet strToList: string -> List<char> =\n  fun(str: string)->\n     Seq.toList(str)\n\nlet rec mapList: ('a -> 'b) -> List<'a> -> List<'b> =\n  fun(mapper: ('a -> 'b)) (list: List<'a>) ->\n      match list with\n      | [] -> []\n      | head::tail -> mapper(head)::mapList(mapper) (tail)\n  \nlet rec flatten: List<string> -> List<string> =\n  fun(list: List<string>) ->\n      match list with\n      | [] -> []\n      | head::[] -> [string head]\n      | head::(head2::tail) -> \n          if head2 = \" \" then \n              head::flatten(tail) \n          else \n              flatten((string head + string head2)::tail) \n\nlet rec listReverse: List<'a> -> List<'a> =\n  fun(list: List<'a>) ->\n      match list with\n      | [] -> []\n      | head::tail ->  listReverse(tail) @ [head]\n\nlet rec elGenericoAddo: string -> List<string> -> string =\n  fun(based: string) (list: List<string>) ->\n      match list with\n      | [] -> based\n      | head::[] -> head\n      | head::(head2::tail) -> elGenericoAddo(based) ((head+\" \"+head2)::tail) \n      \nlet strToListStr = strToList >> (mapList (fun x -> string x))\nlet reverseWords = strToListStr >> flatten >> listReverse >> (elGenericoAddo(\"\"))\n\n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83843,"user_id":null,"body":"open System\nlet reverseWords (str: string) =\n    let words = str.Split(' ')\n    Array.Reverse(words)\n    let reversed = String.Join(\" \", words)\n    reversed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83844,"user_id":null,"body":"let reverseWords s = (s:string).Split ' ' |> Array.rev |> String.concat \" \"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83845,"user_id":884,"body":"let reverseWords (s: string) = s.Split ' ' |> Seq.rev |> String.concat \" \" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83846,"user_id":null,"body":"let reverseWords (str: string) =\n        let glue x =if x=\"\" then x else \" \"+x\n        \n        str.Split ' '\n        |> Seq.fold(fun acc x ->  string x + (glue acc)) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83847,"user_id":null,"body":"let reverseWords (str: string) =\n    let split = str.Split ' ' |> Array.toList\n    let rec fix (value: string list) =\n        match value with\n        | [_] -> value\n        | head::tail -> fix tail @ [head]\n    fix split |> List.toSeq |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83848,"user_id":null,"body":"let reverseWords (str: string) =\n    str.Split(' ') |> Array.rev |> Array.reduce ( fun x y -> x + \" \" + y ) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"523f5d21c841566fde000009":[{"id":83849,"user_id":null,"body":"let array_difference itemsToExclude source = \n    source |> Array.filter (fun x -> not (Array.contains x itemsToExclude))","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83850,"user_id":null,"body":"let array_difference itemsToExclude source = \n    let itemsToExclude = itemsToExclude |> Set.ofSeq\n    source |> Array.filter (itemsToExclude.Contains >> not)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83851,"user_id":null,"body":"let array_difference itemsToExclude source = \n    Array.filter (fun e -> not <| Array.contains e itemsToExclude) source","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83852,"user_id":53,"body":"let array_difference b a = \n    a |> Array.filter (fun x -> not (Array.exists ((=) x) b))","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83853,"user_id":null,"body":"let array_difference itemsToExclude source = \n    let itemsToExclude = itemsToExclude |> Set.ofArray\n    source\n    |> Array.choose(fun x->\n        if itemsToExclude.Contains x then None\n        else Some x\n    )","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83854,"user_id":null,"body":"let array_difference itemsToExclude source = \n    let exclude = (Set.ofSeq itemsToExclude).Contains\n    source |> Array.filter (not << exclude)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83855,"user_id":null,"body":"open System.Linq\n\nlet array_difference itemsToExclude source= \n    let mutable result = []\n    let s2 = itemsToExclude |> List.ofArray\n    for i in source do \n      if not (List.exists ((=)i) s2) then\n        result <- result @ [i]\n  \n    result.ToArray()","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83856,"user_id":null,"body":"let array_difference itemsToExclude source = \n    source |> Array.filter (fun el -> not (Array.contains el itemsToExclude))","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83857,"user_id":null,"body":"let array_difference itemsToExclude = \n    Array.filter (fun i -> not (Array.contains i itemsToExclude))\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83858,"user_id":null,"body":"let array_difference itemsToExclude source = source |> Array.filter (fun i -> not (itemsToExclude |> Array.contains i))","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"525f50e3b73515a6db000b83":[{"id":83859,"user_id":53,"body":"let create_phone_number (n: int list): string =\n  sprintf \"(%d%d%d) %d%d%d-%d%d%d%d\" n.[0] n.[1] n.[2] n.[3] n.[4] n.[5] n.[6] n.[7] n.[8] n.[9]","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83860,"user_id":168,"body":"let create_phone_number (numbers: int list) =\n  let group i j = numbers.[i..j] |> List.map string |> String.concat \"\"\n  sprintf \"(%s) %s-%s\" (group 0 2) (group 3 5) (group 6 9)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83861,"user_id":527,"body":"let create_phone_number [a; b; c; d; e; f; g; h; i; j] =\n  sprintf \"(%d%d%d) %d%d%d-%d%d%d%d\" a b c d e f g h i j","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83862,"user_id":null,"body":"let create_phone_number numbers =\n  numbers\n  |> List.mapi (fun i x ->\n    match i with\n    | 0 -> sprintf \"(%i\" x\n    | 2 -> sprintf \"%i) \" x\n    | 5 -> sprintf \"%i-\" x\n    | _ -> sprintf \"%i\" x\n    )\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83863,"user_id":null,"body":"let create_phone_number =\n   let res = Seq.map string >> String.concat \"\" >> int64\n   let f (x:int64) = x.ToString(format = \"(000) 000-0000\")\n   res >> f","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83864,"user_id":252,"body":"let create_phone_number (numbers : int seq) =\n    let s = numbers |> System.String.Concat\n    sprintf \"(%s) %s-%s\" s.[0 .. 2] s.[3 .. 5] s.[6 .. 9]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83865,"user_id":null,"body":"let convertToString lst=\n    List.fold (fun str x -> str + x.ToString()) \"\" lst\n\nlet create_phone_number numbers=\n    let sn = convertToString numbers\n    \"(\" + sn.Substring(0,3) + \") \" + sn.Substring(3,3) + \"-\" + sn.Substring(6)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83866,"user_id":null,"body":"let create_phone_number numArr =\n  let join = List.map string >> String.concat \"\"\n\n  let area = List.take 3 numArr\n  let prefix = (List.skip 3 >> List.take 3) numArr\n  let post = (List.skip 6 >> List.take 4) numArr\n\n  sprintf \"(%s) %s-%s\" (join area) (join prefix) (join post)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83867,"user_id":null,"body":"let uintToString number = string (int number)\n\nlet create_phone_number numbers =\n    [\"(\"] \n    |> Seq.append (numbers |> Seq.take 3 |> Seq.rev |> Seq.map uintToString)\n    |> Seq.append [\") \"] \n    |> Seq.append (numbers |> Seq.skip 3 |> Seq.take 3 |> Seq.rev |> Seq.map uintToString)\n    |> Seq.append [\"-\"] \n    |> Seq.append (numbers |> Seq.skip 6 |> Seq.take 4 |> Seq.rev |> Seq.map uintToString)\n    |> Seq.rev \n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83868,"user_id":null,"body":"let create_phone_number =\n    function [a;b;c;d;e;f;g;h;i;j] -> sprintf \"(%i%i%i) %i%i%i-%i%i%i%i\" a b c d e f g h i j","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5264d2b162488dc400000001":[{"id":83869,"user_id":null,"body":"open System\n\nlet spin_words (str: string) =\n    let spinner = \n        function\n        | x when Seq.length x >= 5 -> Seq.rev x\n        | x -> x\n    \n    str.Split ' '\n    |> Seq.map (spinner >> Seq.map (string) >> String.concat \"\")\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83870,"user_id":null,"body":"let spin_words (str : string) = \n    str.Split(' ')\n    |> Seq.map (fun s -> if s.Length < 5 then s else s |> Seq.rev |> System.String.Concat)\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83871,"user_id":null,"body":"open System\n\nlet spin_words (str : string) =\n    let spinBigWord w =\n      if String.length w >= 5 then\n        new string(w.ToCharArray() |> Array.rev)\n      else\n        w\n        \n    let spinnedArray =\n      str.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n      |> Array.map spinBigWord\n      \n    String.Join(\" \", spinnedArray)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83872,"user_id":null,"body":"open System\nlet spin_words (str : string) = \n    str.Split(char(\" \"))\n    |> Array.map (fun x -> if x.Length >= 5 then (x |> Seq.rev |> String.Concat) else x)\n    |> String.concat(\" \")","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83873,"user_id":null,"body":"open System\n\nlet words (s: string) = s.Split ' '\nlet spin_words =\n    words\n    >> Array.map (function\n      | (s: string) when s.Length >= 5 -> s |> (Seq.rev) |> String.Concat\n      | s -> s)\n    >> (String.concat \" \")\n  \n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83874,"user_id":null,"body":"let reverse (input:string) = input |> Seq.rev |> System.String.Concat\n\nlet spin_words (str : string) = \n    str.Split ' '\n      |> Array.map (fun x -> if (String.length x) < 5 then x else (reverse x))\n      |> String.concat \" \"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83875,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet reverse (s : string) =\n    let a = s.ToCharArray()\n    Array.Reverse a\n    String a\n\nlet spin_words (str : string) =\n  Regex.Replace(str, @\"\\w{5,}\", fun m -> reverse m.Value)\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83876,"user_id":null,"body":"let stringRev (s: string) =\n    s\n    |> Seq.rev\n    |> Seq.toArray\n    |> System.String\n\nlet spin_words (str : string) =\n    str.Split ' '\n    |> Seq.map (fun word -> if word.Length >= 5 then (stringRev word) else word)\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83877,"user_id":null,"body":"let reverseStr (s: string) = \n    let reversedChars = s.ToCharArray() |> Array.rev\n    new System.String(reversedChars)\n    \nlet concatWithSpace a b =\n    a + \" \" + b\n\nlet rec myFold acc s concatFn = \n    match s with \n    | [] -> acc\n    | [single] -> concatFn acc single\n    | head::tail -> myFold (concatFn acc head) tail concatFn\n\nlet spin_words (str: string) = \n    str.Split ' '\n    |> Array.toList\n    |> List.map (fun word -> if word.Length >= 5 then (reverseStr word) else word)\n    |> (fun words -> \n            let h::t = words\n            myFold h t concatWithSpace)\n    ","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83878,"user_id":null,"body":"open System\n\nlet spin_words (str : string) = \n    str.Split()\n    |> Array.map (\n        fun x -> \n        if x.Length > 4 then x |> Seq.rev |> String.Concat else x)\n    |> Array.reduce (fun a b -> a + \" \" + b)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5266876b8f4bf2da9b000362":[{"id":83879,"user_id":491,"body":"let likes = function\n  | [] -> \"no one likes this\"\n  | [name1] -> sprintf \"%s likes this\" name1\n  | [name1; name2] -> sprintf \"%s and %s like this\" name1 name2\n  | [name1; name2; name3] -> sprintf \"%s, %s and %s like this\" name1 name2 name3\n  | name1::(name2::rest) -> sprintf \"%s, %s and %d others like this\" name1 name2 (List.length rest)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83880,"user_id":168,"body":"let rec likes (names: string list): string =\n  match names with\n  | [] -> \"no one likes this\"\n  | [x] -> x + \" likes this\"\n  | [x; y] -> x + \" and \" + y + \" like this\"\n  | [x; y; z] -> x + \", \" + likes [y; z]\n  | x :: y :: xs -> likes [x; y; sprintf \"%d others\" (List.length xs)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83881,"user_id":null,"body":"let likes (names: string list): string =\n    match names with\n      | [] -> \"no one likes this\"\n      | [first] -> sprintf \"%s likes this\" first\n      | [first; second] -> sprintf \"%s and %s like this\" first second\n      | [first; second; third] -> sprintf \"%s, %s and %s like this\" first second third\n      | first::second::rest -> sprintf \"%s, %s and %d others like this\" first second (List.length rest)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83882,"user_id":null,"body":"let likes (names: string list): string =\n  match names with\n  | []             -> \"no one likes this\"\n  | [a]            -> sprintf \"%s likes this\" a\n  | [a;b]          -> sprintf \"%s and %s like this\" a b\n  | [a;b;c]        -> sprintf \"%s, %s and %s like this\" a b c\n  | a :: b :: tail -> sprintf \"%s, %s and %i others like this\" a b (List.length tail)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83883,"user_id":null,"body":"let likes (names: string list): string =\n    match names with\n    | [] -> \"no one likes this\"\n    | [name] -> sprintf \"%s likes this\" name\n    | [name1; name2] -> sprintf \"%s and %s like this\" name1 name2\n    | [name1; name2; name3] -> sprintf \"%s, %s and %s like this\" name1 name2 name3\n    | _ -> sprintf \"%s, %s and %i others like this\" names.[0] names.[1] (names.Length - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83884,"user_id":null,"body":"let likes (names: string list): string =\n    match List.length names with\n    | 0 -> \"no one likes this\"\n    | 1 -> names.[0] + \" likes this\"\n    | 2 -> names.[0] + \" and \" + names.[1] + \" like this\"\n    | 3 -> names.[0] + \", \" + names.[1] + \" and \" + names.[2] + \" like this\"\n    | x -> names.[0] + \", \" + names.[1] + \" and \" + (x-2).ToString() + \" others like this\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83885,"user_id":null,"body":"let likes (names: string list): string =    \n    match names.Length with\n    | 0 -> \"no one likes this\"\n    | 1 -> sprintf \"%s likes this\" names.[0]\n    | 2 -> sprintf \"%s and %s like this\" names.[0] names.[1]\n    | 3 -> sprintf \"%s, %s and %s like this\" names.[0] names.[1] names.[2]\n    | length -> sprintf \"%s, %s and %i others like this\" names.[0] names.[1] (length - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83886,"user_id":null,"body":"let likes (names: string list): string =\n    match names with \n    | [] ->  \"no one likes this\"\n    | [ a ] ->  sprintf \"%s likes this\" a\n    | [ a; b ] -> sprintf  \"%s and %s like this\" a b\n    | [ a; b; c ] -> sprintf  \"%s, %s and %s like this\" a b c\n    | head :: tail  -> sprintf  \"%s, %s and %d others like this\" head tail.Head (tail.Length-1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83887,"user_id":null,"body":"let likes (names: string list): string =\n    match names with\n    | [] -> \"no one likes this\"\n    | [ first ] -> sprintf \"%s likes this\" first\n    | [ first; second ] -> sprintf \"%s and %s like this\" first second\n    | [ first; second; third ] -> sprintf \"%s, %s and %s like this\" first second third\n    | first::second::rest -> sprintf \"%s, %s and %i others like this\" first second rest.Length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83888,"user_id":null,"body":"let likes (names: string list): string =\n    match names with\n    | [] -> \"no one likes this\"\n    | [a] -> sprintf \"%s likes this\" a\n    | [a; b] -> sprintf \"%s and %s like this\" a b\n    | [a; b; c] -> sprintf \"%s, %s and %s like this\" a b c\n    | a::b::rest -> sprintf \"%s, %s and %d others like this\" a b rest.Length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5270d0d18625160ada0000e4":[{"id":83889,"user_id":null,"body":"let scoreItem count faceValue =\n    match faceValue, count with\n    | 1, c -> 1000 * (c \/ 3) + 100 * (c % 3)\n    | 5, c -> 500 * (c \/ 3) + 50 * (c % 3)\n    | _, c -> 100 * faceValue * (c \/ 3)\n\nlet score dice =\n    dice\n    |> Seq.countBy id\n    |> Seq.map (fun (faceValue, count) -> scoreItem count faceValue)\n    |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83890,"user_id":null,"body":"let score dice =\n    List.sort dice\n    |> List.unfold\n        (function\n        | 1 :: 1 :: 1 :: tail -> Some(1000, tail)\n        | 6 :: 6 :: 6 :: tail -> Some(600, tail)\n        | 5 :: 5 :: 5 :: tail -> Some(500, tail)\n        | 4 :: 4 :: 4 :: tail -> Some(400, tail)\n        | 3 :: 3 :: 3 :: tail -> Some(300, tail)\n        | 2 :: 2 :: 2 :: tail -> Some(200, tail)\n        | 1 :: tail -> Some(100, tail)\n        | 5 :: tail -> Some(50, tail)\n        | _ :: tail -> Some(0, tail)\n        | [] -> None)\n    |> List.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83891,"user_id":null,"body":"type Multiple = | Single | Tripple\n\nlet scorer = function\n    | Tripple, 1 -> 1000\n    | Tripple, faceValue -> faceValue * 100\n    | Single, 1 -> 100\n    | Single, 5 -> 50\n    | _ -> 0\n\nlet decompose ((number, count): int * int) =\n    let trippleCount, singleCount = count \/ 3, count % 3\n\n    [ trippleCount * (scorer (Tripple, number))\n      singleCount * (scorer (Single, number)) ] |> List.sum\n\nlet score = List.countBy id >> List.sumBy decompose","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83892,"user_id":null,"body":"let scores =\n  [| 1000, 100\n     200, 0\n     300, 0\n     400, 0\n     500, 50\n     600, 0 |]\n\nlet sideScore i s =\n  let (three, one) = scores.[i]\n  (s \/ 3 * three) + (s % 3 * one)\n\nlet score dice =\n  let sides = Array.create 6 0\n\n  for d in dice do\n    sides.[d - 1] <- sides.[d - 1] + 1\n\n  sides\n  |> Array.mapi sideScore\n  |> Array.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83893,"user_id":null,"body":"let rec scoring (a,b) =\n    match a with \n    | 1 when b >= 3 -> 1000 + scoring (a, b-3)\n    | 1 when b >= 1 -> 100 + scoring (a,b-1)\n    | 5 when b >= 3 -> 500 + scoring (a,b-3) \n    | 5 when b >= 1 -> 50 + scoring (a,b-1) \n    | _ when b >= 3 -> a * 100\n    | _ -> 0\n\nlet score = List.countBy id >> List.sumBy scoring","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83894,"user_id":null,"body":"let score dice =\n    let score' sum (faces: int * int list) : int =\n        match faces with\n        | (1, xs) when xs.Length >= 3 -> sum + 1000 + 100 * (xs.Length - 3)\n        | (6, xs) when xs.Length >= 3 -> sum + 600\n        | (5, xs) when xs.Length >= 3 -> sum + 500 + 50 * (xs.Length - 3)\n        | (4, xs) when xs.Length >= 3 -> sum + 400\n        | (3, xs) when xs.Length >= 3 -> sum + 300\n        | (2, xs) when xs.Length >= 3 -> sum + 200\n        | (1, xs)                     -> sum + 100 * xs.Length\n        | (5, xs)                     -> sum + 50 * xs.Length\n        | _                           -> sum\n    \n    dice |> List.groupBy id |> List.fold score' 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83895,"user_id":252,"body":"let score d =\n    let s = [|0; 1000; 200; 300; 400; 500; 600; 100; 0; 0; 0; 50; 0|]\n    d |> Seq.countBy ((*)1) |> Seq.fold (fun t (n, c) -> t + s.[n] * (c \/ 3) + s.[n + 6] * (c % 3)) 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83896,"user_id":null,"body":"let score (dice: int list) =\n    dice\n    |> List.map (function 1 -> 10 | n -> n)\n    |> List.countBy id\n    |> List.fold (fun b (num, count) -> if num = 10 || num = 5 \n                                        then b + (count \/ 3) * (num * 100) + (max (count%3) 0 * num * 10)\n                                        else b + (count \/ 3) * (num * 100)) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83897,"user_id":null,"body":"let rec score (dice : int list) =\n    List.countBy id dice\n    |> List.map (fun (elem, m) ->\n        match elem with\n        | n when n = 1 -> m \/ 3 * 1000 + m % 3 * 100\n        | n when n = 5 -> m \/ 3 * 500 + m % 3 * 50\n        | n -> m \/ 3 * n * 100\n        | _ -> 0)\n    |> List.sum\n    \n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83898,"user_id":252,"body":"let score d =\n    let s = [|0,0; 1000,100; 200,0; 300,0; 400,0; 500,50; 600,0|]\n    d\n    |> Seq.countBy ((*)1)\n    |> Seq.fold (fun t (n, c) -> let a = c \/ 3 in t + fst s.[n] * a + snd s.[n] * (c - a * 3)) 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5279f6fe5ab7f447890006a7":[{"id":83899,"user_id":null,"body":"let rec loop ascent pos items res =\n  match items with\n  | x1 :: x2 :: xs ->\n    if x1 = x2 then\n      loop ascent (pos + 1) (x2 :: xs) res\n    else if x1 < x2 then\n      loop (Some (pos + 1, x2)) (pos + 1) (x2 :: xs) res\n    else\n      match ascent with\n      | None ->\n        loop None (pos + 1) (x2 :: xs) res\n        \n      | Some (p, v) ->\n        loop None (pos + 1) (x2 :: xs) \n          { res with \n                Pos = p :: res.Pos\n                Peaks = v :: res.Peaks }\n      \n  | _ ->\n    { Pos = List.rev res.Pos\n      Peaks = List.rev res.Peaks }\n\nlet pickPeaks items =\n  if List.length items < 3 then\n    { Pos = []; Peaks = [] }\n  else\n    loop None 0 items { Pos = []; Peaks = [] }","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83900,"user_id":null,"body":"let pickPeaks (items : int list) : PeakPositionInfo =\n  let collapseConsecutiveValues =\n    List.fold \n      (fun acc value ->\n        match acc with\n        | x::_ when snd x = snd value -> acc\n        | x::xs -> value::x::xs\n        | [] -> [value])\n      []\n    >> List.rev\n    \n  let findLocalPeaks =\n    List.windowed 3\n    >> List.filter (fun w -> snd w.[0] < snd w.[1] && snd w.[1] > snd w.[2])\n    >> List.map (fun w -> w.[1])\n    \n  let pos, peaks =\n    items\n    |> List.indexed\n    |> collapseConsecutiveValues\n    |> findLocalPeaks\n    |> List.unzip\n  { Pos = pos ; Peaks = peaks }\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83901,"user_id":491,"body":"let pickPeaks (items : int list) : PeakPositionInfo =\n    let peakChecker (i : int) : bool =\n        let rec peakChecker' = function\n            | [] | [_] -> false\n            | first::(second::_ as tail) -> if first = second then peakChecker' tail else first > second\n        if i = 0 || items.[i] <= items.[i - 1]\n            then false\n            else peakChecker' (List.skip i items)\n    let peakIndicators = items |> List.mapi (fun i _ -> peakChecker i, i) |> List.filter fst |> List.map snd\n    { Pos = peakIndicators; Peaks = peakIndicators |> List.map (fun i -> items.[i]) }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83902,"user_id":null,"body":"let pickPeaks =\n    List.indexed\n    >> List.mapFold \n        (fun prev (i, x) -> match prev with | Some p when p = x -> None, Some p | _ -> Some(i, x), Some x) \n        None\n    >> fst\n    >> List.choose id\n    >> List.windowed 3\n    >> List.fold \n        (fun p l -> if l |> List.maxBy snd = l.[1] then {Pos = p.Pos @ [fst l.[1]]; Peaks = p.Peaks @ [snd l.[1]]} else p)\n        ({Pos = []; Peaks = []})","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83903,"user_id":null,"body":"type Entry = { OriginalPosition: int; Value: int }\n\nlet isPeak ((first, second), (_, third)) =\n    (second.Value > first.Value)\n    && (second.Value > third.Value)\n\nlet asPeakPosition ((_, second), _) = (second.OriginalPosition, second.Value)\n\n\nlet pickPeaks (items: int list) =\n    let positions, peaks =\n        items\n        |> List.indexed\n        |> List.map\n            (fun (originalPosition, value) ->\n                { OriginalPosition = originalPosition\n                  Value = value })\n        |> List.pairwise\n        |> List.filter (fun (first, second) -> (first.Value <> second.Value))\n        |> List.pairwise\n        |> List.filter isPeak\n        |> List.map (asPeakPosition)\n        |> List.unzip\n\n    { Pos = positions; Peaks = peaks }\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83904,"user_id":null,"body":"\nopen System\n\nlet pickPeaks (items : int list)  =\n    let rec aux (pos, peaks) last p r rising = function\n        | [] -> { Pos = List.rev pos; Peaks = List.rev peaks }\n        | x :: xs when x > last -> aux (pos, peaks) x (r + 1) (r + 1) true xs \n        | x :: xs when x = last -> aux (pos, peaks) x p (r + 1) rising xs\n        | x :: xs when rising -> aux (p - 1 :: pos, last :: peaks) x (r + 1) (r + 1) false xs\n        | x :: xs -> aux (pos, peaks) x (r + 1) (r + 1) false xs\n    aux ([], []) Int32.MaxValue 0 0 false items","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83905,"user_id":878,"body":"let pickPeaks (items : int list) =\n  let array = List.toArray items\n  let deduped =\n    Array.indexed array\n    |> Array.filter (fun (i, n) -> i = 0 || n <> array.[i - 1])\n  \n  let positions =\n    Array.indexed deduped\n    |> Array.filter (fun (dedupedIndex, (originalIndex, n)) ->\n      match n with\n      | n when dedupedIndex = 0 -> false\n      | n when dedupedIndex = Array.length deduped - 1 -> false\n      | n when n <= (snd deduped.[dedupedIndex - 1]) -> false\n      | n when n <= (snd deduped.[dedupedIndex + 1]) -> false\n      | n -> true)\n    |> Array.map (fun (_, (i, n)) -> i)\n    |> Array.toList\n  \n  let peaks = List.map (fun i -> array.[i]) positions\n  \n  { Pos = positions; Peaks = peaks }\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83906,"user_id":null,"body":"let rec loop ascent pos items res = \n  match items with \n  | x1 :: x2 :: xs ->\n    if x1 = x2 then\n      loop ascent (pos + 1) (x2 :: xs) res\n    else if x1 < x2 then\n      loop (Some (pos + 1, x2)) (pos + 1) (x2 :: xs) res\n    else\n      match ascent with\n      | None -> \n        loop None (pos + 1) (x2 :: xs) res\n      | Some (p, v) -> \n        loop None (pos + 1) (x2 :: xs) {res with Pos = p :: res.Pos; Peaks = v :: res.Peaks}\n  \n  | _ -> {Pos = List.rev res.Pos; Peaks = List.rev res.Peaks}\n  \n\nlet pickPeaks (items : int list) : PeakPositionInfo =\n    if List.length items < 3 then\n      {Pos = []; Peaks = []}\n    else\n      loop None 0 items {Pos = []; Peaks = []}\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83907,"user_id":null,"body":"let pickPeaks (items: int list) =\n\n    let lastIdx = (List.length items) - 1\n\n    let upSlopeFilter (ix, itm) =\n        ix <> 0\n        && ix <> lastIdx\n        && itm > items.[ix - 1]\n        && itm >= items.[ix + 1]\n\n    let rec confirmPieck pieckStart =\n        function\n        | nextItm :: _ when nextItm < pieckStart -> true\n        | nextItm :: theRest when nextItm = pieckStart -> confirmPieck pieckStart theRest\n        | _ -> false\n\n    let upSlope =\n        items\n        |> Seq.mapi (fun ix itm -> ix, itm)\n        |> Seq.filter upSlopeFilter\n        |> Seq.filter (fun (ix, itm) -> confirmPieck itm items.[ix + 1 ..])\n        |> List.ofSeq\n\n    { Pos = List.map fst upSlope\n      Peaks = List.map snd upSlope }\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83908,"user_id":null,"body":"let pickPeaks (items: int list) =\n\n    let lastIdx = (List.length items) - 1\n\n    let upSlopeFilter (ix, itm) =\n        ix <> 0\n        && ix <> lastIdx\n        && itm > items.[ix - 1]\n        && itm >= items.[ix + 1]\n\n    let rec confirmPieck pieckStart =\n        function\n        | head :: _ when head < pieckStart -> true\n        | head :: rest when head = pieckStart -> confirmPieck pieckStart rest\n        | _ -> false\n\n    let upSlope =\n        items\n        |> Seq.mapi (fun ix itm -> ix, itm)\n        |> Seq.filter upSlopeFilter\n        |> Seq.filter (fun (ix, itm) -> confirmPieck itm items.[ix + 1 ..])\n        |> List.ofSeq\n\n    { Pos = List.map fst upSlope\n      Peaks = List.map snd upSlope }\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"527e4141bb2ea5ea4f00072f":[{"id":83909,"user_id":null,"body":"open System.Globalization\n\nlet solution n = { 1..n } |> Seq.collect string |> Seq.sumBy CharUnicodeInfo.GetDigitValue","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83910,"user_id":null,"body":"let solution n =\n    [| 1..n |]\n    |> Array.map (fun i ->\n        if i > 9 then\n            i.ToString().ToCharArray()\n            |> Array.map (fun z -> int z - 48)\n            |> Array.sum\n        else\n            i)\n    |> Array.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83911,"user_id":null,"body":"let solution n =\n  seq { 1 .. n }\n  |> Seq.collect (string >> (Seq.map (string >> int)))\n  |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83912,"user_id":null,"body":"let solution n =\n  seq { 1 .. n }\n  |> Seq.collect ((sprintf \"%i\") >> (Seq.map ((sprintf \"%O\") >> int)))\n  |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83913,"user_id":null,"body":"let sumDigit = string >> Seq.fold (fun s v -> s + int v - 48) 0 \nlet rec sln n sum = if n = 0 then sum else sln (n - 1) (sum + sumDigit n)\nlet solution n = sln n 0 ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83914,"user_id":null,"body":"open System\n\nlet solution n =\n  [1 .. n] \n  |> List.map string \n  |> List.collect(fun x -> seq x |> List.ofSeq) \n  |> List.map string \n  |> List.map Int32.Parse \n  |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83915,"user_id":575,"body":"let solution n = seq { 1 .. n } |> Seq.map (fun x -> x.ToString().ToCharArray() |> Seq.map (fun d -> d.ToString() |> int) |> Seq.sum) |> Seq.sum;;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83916,"user_id":53,"body":"let f n =\n  let mutable m = n\n  let mutable s = 0\n  while m > 0 do\n    s <- s + (m % 10)\n    m <- m \/ 10\n  s\n\nlet rec solution n =\n  Seq.fold (\n   fun acc elem -> acc + elem\n  ) 0 (seq { for i in 1 .. n -> f i })","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83917,"user_id":null,"body":"let rec digitsOf = function\n  | 0 -> 0\n  | n -> n % 10 + digitsOf (n \/ 10)\n\nlet solution n = [1..n] |> List.sumBy digitsOf","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83918,"user_id":168,"body":"let solution n =\n  {1 .. n}\n  |> Seq.map (fun i -> string i |> Seq.map (fun c -> int c - 48) |> Seq.sum)\n  |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"52bc74d4ac05d0945d00054e":[{"id":83919,"user_id":null,"body":"let first_non_repeating_letter str =\n    str\n    |> Seq.groupBy (fun e -> (string e).ToLower())\n    |> Seq.tryFind (fun e -> snd e |> Seq.length = 1)\n    |> Option.map  (snd >> Seq.head >> string)\n    |> Option.defaultValue \"\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83920,"user_id":null,"body":"let first_non_repeating_letter (str: string) = \n    str\n    |> Seq.countBy System.Char.ToLower\n    |> Seq.tryPick (fun (key, count) -> if count = 1 then Some (key.ToString()) else None)\n    |> Option.defaultValue \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83921,"user_id":491,"body":"open System\n\nlet first_non_repeating_letter str =\n    let occursOnceInString ch =\n        str |> Seq.filter (fun c -> Char.ToLower(c) = Char.ToLower(ch)) |> Seq.length |> (=) 1\n    match Seq.tryFind occursOnceInString str with\n    | Some s -> string s\n    | None -> \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83922,"user_id":252,"body":"let first_non_repeating_letter (str : string) = \n    let s = str.ToLower ()\n    s\n    |> Seq.tryFindIndex (fun c -> s.IndexOf c = s.LastIndexOf c)\n    |> Option.bind (fun i -> Some (string str.[i]))\n    |> Option.defaultValue \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83923,"user_id":null,"body":"open System\n\nlet first_non_repeating_letter str = \n    let chars = str |> Seq.map Char.ToUpper |> Seq.groupBy id |> Map.ofSeq\n    str \n    |> Seq.tryFind (fun x -> Map.find (Char.ToUpper x) chars |> Seq.length = 1)\n    |> Option.map string |> Option.defaultValue \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83924,"user_id":null,"body":"let first_non_repeating_letter (str: string) = \n    let rec firstValid str (valid: Set<char>) =\n        match str with\n        | \"\" -> \"\"\n        | _ when valid.Contains(str.ToLower().[0]) -> string str.[0]\n        | _ -> firstValid str.[1..] valid\n\n    str.ToLower()\n    |> Seq.countBy id\n    |> Seq.choose (fun (char, count) -> if count = 1 then Some char else None)\n    |> Set.ofSeq\n    |> firstValid str\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83925,"user_id":null,"body":"let first_non_repeating_letter (str:string) = \n    let countOf (c:char) =\n        let isSameChar c1 c2 =\n            let lowCase = System.Char.ToLower\n            lowCase c1 = lowCase c2\n        str\n        |> Seq.filter (isSameChar c)\n        |> Seq.length\n\n    let nonRepeatingChars =\n        str\n        |> Seq.filter (fun c -> (countOf c) = 1)\n        |> Seq.toList\n    match List.length nonRepeatingChars with\n    | 0 -> \"\"\n    | x -> nonRepeatingChars.[0].ToString()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83926,"user_id":null,"body":"open System\nlet first_non_repeating_letter (str: string) = \n    let lowerStr = str.ToLower()\n    str\n    |> Seq.tryFind (fun (c:char) -> lowerStr.IndexOf(Char.ToLower(c)) = lowerStr.LastIndexOf(Char.ToLower(c))) \n    |> Option.map Char.ToString\n    |> Option.defaultWith (fun () -> String.Empty)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83927,"user_id":null,"body":"let rec findInString strList all =\n  match strList with\n    | head::tail when all |> List.filter(fun item -> System.Char.ToUpper item = System.Char.ToUpper head) |> List.length <= 1 -> Some head\n    | head::tail -> findInString tail all\n    | [] -> None\n\nlet findInStringStart all =\n  findInString all all\n\nlet first_non_repeating_letter str = \n  printfn \"%s\" str\n  let test = str |> Seq.toList |> List.ofSeq |> findInStringStart\n  match test with\n    | Some x -> sprintf \"%c\" x\n    | None -> \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83928,"user_id":53,"body":"open System\n\nlet first_non_repeating_letter str = \n    Seq.fold (fun (i, acc) e -> \n        let c = Char.ToLower e\n        i + 1,\n        match acc |> Map.tryFind c with\n          | Some (false, first, e) -> Map.add c (true, first, e) acc\n          | Some _ -> acc\n          | None -> Map.add c (false, i, e) acc) (0, Map.empty) str\n    |> snd |> Map.toSeq |> Seq.minBy snd\n    |> fun (_, (r, _, p)) -> if r then \"\" else string p ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"52de553ebb55d1fca3000371":[{"id":83929,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet find_missing (items : int IList) = \n  items \n  |> Seq.pairwise\n  |> Seq.map (fun (f, s) -> s-f, f)\n  |> Seq.maxBy fst \/\/\/ assume its increassing\n  |> fun (d,f) -> f + d\/2","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83930,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet find_missing (items : int IList) = \n  items\n    |> Seq.pairwise\n    |> Seq.map (fun (a,b) -> (a,b,b-a))\n    |> Seq.sortBy (fun (a,b,c) -> c)\n    |> Seq.last\n    |> (fun (a,b,c) -> b-(c\/2))\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83931,"user_id":null,"body":"let find_missing (items : int []) = \n    let step = items |> Array.windowed 2 |> Array.take 2 |> Array.map (fun e -> e.[1] - e.[0]) |> Array.min\n    [| items |> Array.min .. step .. items |> Array.max |] |> Array.except items |> Array.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83932,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet apSum (items : int IList) = \n  let count = items.Count \n  (double items.[0] + double items.[count-1]) * (double count + 1.0)\/2.\n\nlet actualSum (items : int IList) = \n  items |> Seq.sum |> double\n\nlet find_missing (items : int IList) = \n  apSum items - actualSum items |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83933,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet find_missing (items : int IList) = \n    Seq.pairwise items\n    |> Seq.groupBy (fun (a, b) -> b - a)\n    |> Seq.maxBy fst\n    |> fun (gap, xs) -> fst (Seq.exactlyOne xs) + gap\/2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83934,"user_id":null,"body":"open System\n\nlet find_missing (items : Int32 seq) =\n  let items2 = Seq.tail items\n\n  Seq.zip items items2\n  |> Seq.map (fun (a, b) -> ((a + b) \/ 2, b - a))\n  |> Seq.groupBy snd\n  |> Seq.sortBy fst\n  |> Seq.tail\n  |> Seq.head\n  |> snd\n  |> Seq.head\n  |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83935,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet find_missing (items : int IList) = \n    let diffs  = items |> Seq.windowed 2 |> Seq.map (Seq.reduce (-)) |> Seq.map(abs)\n    let maxDiff = diffs |> Seq.max \n    let maxIndexDiff = diffs |> Seq.findIndex (fun x -> x = maxDiff)\n    items |> Seq.item maxIndexDiff |> fun x -> x + (maxDiff)\/2\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83936,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet find_missing (items : int IList) = \n    let step = (Seq.last items - Seq.head items) \/ Seq.length items\n    seq { Seq.head items .. step .. Seq.last items  }\n    |> Seq.find (items.Contains >> not)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83937,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet find_missing (items : int IList) = \n    let inc = (items.[items.Count - 1] - items.[0] ) \/ items.Count\n    let mutable res = items.[0]\n    let mutable i = 0\n    while items.[i] = res do\n        res <- res + inc\n        i <- i + 1\n    res\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83938,"user_id":null,"body":"type 'a IList = 'a System.Collections.Generic.IList\n\nlet findStep (items : int IList) =\n    items \n    |> List.ofSeq\n    |> List.pairwise\n    |> List.map (fun (a, b )-> b - a )\n    |> List.fold (fun (acc:Map<int,int>) i -> \n        let res = acc.TryFind(i)\n        match res with \n        | Some count -> acc.Add(i , count + 1)\n        | None -> acc.Add (i , 1)\n    ) Map.empty\n    |> Map.toList\n    |> List.map fst\n    |> List.sort\n    |> List.head\n\nlet find_missing (items : int IList) = \n    let step = findStep items\n    items \n    |> List.ofSeq\n    |> List.pairwise\n    |> List.filter (fun (a, b) -> b - a <> step)\n    |> List.map (fun (a,_) -> a + step)\n    |> List.head\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"52f787eb172a8b4ae1000a34":[{"id":83939,"user_id":76,"body":"let rec zeros n = if n = 0 then 0 else n \/ 5 + zeros(n \/ 5)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83940,"user_id":527,"body":"let rec zeros = function 0 -> 0 | n -> n \/ 5 + zeros (n \/ 5)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83941,"user_id":null,"body":"let zeros n =\n    let mutable numberZeros = n \/ 5\n    let mutable i = 2\n    let mutable powerfive = List.replicate i 5 |> List.reduce (*)\n\n    while powerfive < n do\n        numberZeros <- numberZeros + (n \/ powerfive)\n        i <- i + 1\n        powerfive <- List.replicate i 5 |> List.reduce (*)\n\n    numberZeros","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83942,"user_id":null,"body":"open System\nlet zeros n = List.sum [for i in 1 .. (int (Math.Log(double n, 5.))) -> int (double n \/ 5. ** double i)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83943,"user_id":null,"body":"let zeros(n: int) = \n  let rec helper result power =\n    let powerResult = (pown 5 power) \n    if powerResult <= n then\n      let newResult = result + (n \/ powerResult)\n      helper newResult (power + 1)\n    else\n      result\n  helper 0 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83944,"user_id":null,"body":"open System\n\nlet sigma func iFirst iLast =\n      let rec sigma' i result =\n        if i > iLast then result\n        else sigma' (i+1.0) ((func i)+result)\n      sigma' iFirst 0.0\n\nlet zeros n = \n      let compute i = Math.Floor((float n)\/(5.0**i))\n      let last = (Math.Log((float n), 5.0))\n      int (sigma compute 1.0 last)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83945,"user_id":null,"body":"let zeros n = \n    let ks = seq {1..(int (floor <| System.Math.Log (float n, 5.0) ))}\n    let f = (fun acc k -> acc + floor (float n \/ (float <| pown 5 k)))\n    int <| Seq.fold f 0.0 ks","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83946,"user_id":252,"body":"let zeros n =\n  seq { let mutable i = 1 in while true do i <- i * 5; yield i }\n  |> Seq.takeWhile (fun i -> i <= n)\n  |> Seq.sumBy ((\/) n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83947,"user_id":null,"body":"let zeros n =\n  let rec zeros' cur acc =\n    if cur \/ 5 > 0 then\n      zeros' (cur \/ 5) (acc + cur \/ 5)\n    else\n      acc\n  zeros' n 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83948,"user_id":null,"body":"let zeros n = \n    let rec countZeros n count =\n        match n with\n        | n when n >= 5 -> countZeros (n \/ 5) (count + n \/ 5)\n        | _ -> count\n\n    countZeros n 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"52fba66badcd10859f00097e":[{"id":83949,"user_id":1986,"body":"let disemvowel = \n    let isVowel = System.Char.ToLower >> function\n        | 'a' | 'e' | 'i' | 'o' | 'u' -> true\n        | _ -> false\n    in\n    String.filter (not << isVowel)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83950,"user_id":null,"body":"let vowels = ['A';'a';'E';'e';'I';'i';'O';'o';'U';'u']\n\nlet disemvowel =   \n  String.filter(fun c -> vowels |> List.contains c |> not)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83951,"user_id":null,"body":"let disemvowel = String.filter(fun x -> not <| \"aeiou\".Contains(x.ToString().ToLower()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83952,"user_id":null,"body":"let isVowel ch = Set.contains ch (set \"aeiouAEIOU\")\nlet disemvowel s =\n  s\n  |> Seq.filter (not << isVowel)\n  |> Seq.map string\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83953,"user_id":null,"body":"let isVowel (c : char) = \"AEIOUaeiou\".IndexOf(c) <> -1\n\nlet disemvowel = String.filter (not << isVowel)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83954,"user_id":null,"body":"let isVowel c =\n  match System.Char.ToLower c with\n  | 'a' | 'e' | 'i' | 'o' | 'u' -> false\n  | _ -> true\n\nlet disemvowel = Seq.filter isVowel >> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83955,"user_id":null,"body":"open System.Text.RegularExpressions\n\n\nlet disemvowel s = Regex(\"[aeiou]\", RegexOptions.IgnoreCase).Replace(s, \"\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83956,"user_id":null,"body":"let disemvowel (s:string) =  \/\/ Filte a string, drop all the vowels\n  let filterNotVowel =  \/\/ filter that drop all the vowels\n    fun x -> Seq.contains x \"aeiouAEIOU\" |> not\n  \n  s |> String.filter filterNotVowel \/\/ Filte s and return it","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83957,"user_id":null,"body":"let disemvowel s = \n    s\n    |> String.filter(fun c -> not (List.contains(c) ['a'; 'e'; 'i'; 'o'; 'u'; 'A'; 'E'; 'I'; 'O'; 'U']))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83958,"user_id":null,"body":"let disemvowel (s: string) = s |> String.filter (fun x -> Seq.contains x \"aeiouAEIOU\" |> not)  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"535742c7e727388cdc000297":[{"id":83959,"user_id":null,"body":"let BuildDeck = List.allPairs [ \"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\" ] [ \"hearts\"; \"spades\"; \"diamonds\"; \"clubs\" ] |> List.map (fun (x,y) -> sprintf \"%s of %s\" x y)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83960,"user_id":null,"body":"let BuildDeck = List.allPairs [\"hearts\";\"spades\";\"diamonds\";\"clubs\"] [\"ace\"; \"two\";\"three\";\"four\";\"five\"; \"six\"; \"seven\";\"eight\";\"nine\";\"ten\";\"jack\";\"queen\";\"king\";] |> List.map (fun (c,v) -> sprintf \"%s of %s\" v c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83961,"user_id":null,"body":"let BuildDeck = [for rank in \"ace two three four five six seven eight nine ten jack queen king\".Split([|' '|]) do for suit in [\"hearts\";\"spades\";\"diamonds\";\"clubs\"] -> rank + \" of \" + suit] |> List.map id","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83962,"user_id":null,"body":"let BuildDeck = [\"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\"] |> Seq.allPairs <| [\"hearts\"; \"spades\"; \"diamonds\"; \"clubs\"] |> Seq.map (fun (a, b) -> sprintf \"%s of %s\" a b) |> Seq.toArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83963,"user_id":722,"body":"let BuildDeck = [\"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\"] |> List.collect (fun x -> List.map (fun y -> x + \" of \" + y) [\"spades\"; \"hearts\"; \"diamonds\"; \"clubs\"])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83964,"user_id":null,"body":"let BuildDeck = [\"hearts\"; \"spades\"; \"diamonds\"; \"clubs\"] |> List.collect (fun suit -> [\"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\"] |> List.map (fun rank -> (sprintf \"%s of %s\" rank suit)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83965,"user_id":1617,"body":"let BuildDeck = List.map id [ for s in [ \"hearts\"; \"spades\"; \"diamonds\"; \"clubs\" ] do for r in [ \"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\" ] -> r + \" of \" + s ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83966,"user_id":null,"body":"let BuildDeck = List.allPairs [\"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\" ] [\"hearts\"; \"spades\"; \"diamonds\"; \"clubs\"] |> List.map (fun (card, suit) -> sprintf \"%s of %s\" card suit)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83967,"user_id":null,"body":"let BuildDeck = [ \"diamonds\";    \"spades\";    \"clubs\";    \"hearts\"] |> List.collect(fun a -> [\"ace\"; \"two\" ;\"three\" ;\"four\"; \"five\";\"six\" ;\"seven\"; \"eight\" ;\"nine\" ;\"ten\" ;\"jack\" ;\"queen\"; \"king\" ] |> List.map (fun b -> (String.concat \" \" [b;\"of\";a])))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83968,"user_id":null,"body":"let BuildDeck = [| for r in [|\"ace\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"jack\"; \"queen\"; \"king\"|] do for k in (Map.ofArray [|(\"hearts\", 1); (\"spades\", 1); (\"diamonds\", 1); (\"clubs\", 1)|] |> Map.toArray |> Array.map fst) do yield sprintf \"%s of %s\" r k |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"538835ae443aae6e03000547":[{"id":83969,"user_id":null,"body":"let add = (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83970,"user_id":null,"body":"let add n = fun x -> n + x\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83971,"user_id":null,"body":"let add n = \n  let add y =\n    n + y\n  add\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83972,"user_id":null,"body":"let add n = (+) n\nlet addOne = add 1\n\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83973,"user_id":null,"body":"let add n = (+) n\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83974,"user_id":null,"body":"let add n =\n    let addTwoNumbers a b = a + b\n    addTwoNumbers (n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83975,"user_id":null,"body":"let add n n1 = n + n1\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83976,"user_id":null,"body":"let add n = \n  let addN x = \n    x + n\n  addN\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83977,"user_id":null,"body":"let add n = \n  let add m =\n    n + m\n  add","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83978,"user_id":null,"body":"let add n num = \n  n + num","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"53d40c1e2f13e331fc000c26":[{"id":83979,"user_id":53,"body":"open System\nopen System.Numerics\ntype BI = System.Numerics.BigInteger\n\nlet rec aux (n:int) = \n    if n = 0 then\n        (BI.Zero, BI.One)\n    elif n = 1 then\n        (BI.One, BI.One)\n    else\n        let (a, b) = aux(n \/ 2)\n        let x = BI.Multiply(a, BI.Subtract(BI.Multiply(b, bigint 2), a))\n        let y = BI.Add(BI.Multiply(b, b), BI.Multiply(a, a))\n        if n % 2 = 0 then\n            (x, y)\n        else\n            (y, x + y)\n    \nlet fib (n:int) = \n    if n >= 0 then\n        fst (aux(n))\n    elif n % 2 = 0 then\n        - (fst (aux(-n)))\n    else\n        fst (aux(-n))","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83980,"user_id":168,"body":"open System.Numerics\nopen System\n\nlet rec fib2 n =\n  if n <= 0 then\n    0I, 1I\n  else\n    let a, b = fib2 (n \/ 2)\n    let c = a * (2I * b - a)\n    let d = a * a + b * b\n    if n % 2 = 0 then c, d else d, c + d\n\nlet fib (n: int) =\n  let a, _ = fib2 (abs n)\n  if n < 0 && n % 2 = 0 then -a else a","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83981,"user_id":null,"body":"open System.Numerics\n\nlet fib n =\n    let rec find i a b p q =\n        match i with\n        | 0 -> b\n        | _ when i % 2 = 0 -> find (i\/2) a b (p*p + q*q) ((2I*p*q) + (q*q))\n        | _ -> find (i-1) (b*q + a*q + a*p) (b*p + a*q) p q\n\n    let sign = if n < 0 && n % 2 = 0 then -1I else 1I \n    sign * find (abs n) 1I 0I 0I 1I","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83982,"user_id":null,"body":"let fib x =\n    let rec fb a b p q n = \n        if n = 0 then b \n        elif n % 2 = 0 then \n            let q2 = bigint.Pow(q, 2)\n            fb a b (bigint.Pow(p, 2) + q2) (q2 + 2I * p * q) (n \/ 2)\n        else \n            fb (a * q + b * q + a * p) (b * p + a * q) p q (n - 1)\n    \n    let b = fb 1I 0I 0I 1I (abs x)\n    if x < 0 && x % 2 = 0 then -b else b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83983,"user_id":null,"body":"open System.Numerics\nopen System.Collections.Generic\nlet fibs = new Dictionary<int,BigInteger>()\nfibs.Add(0,0I)\nfibs.Add(1,1I)\n\nlet square x = x*x\n\nlet rec fib (n:int) : BigInteger =    \n    if n<0 then \n        if n%2 = 0 then \n            -(fib (-n))\n        else \n            fib (-n)\n    else \n        if fibs.ContainsKey(n) then \n            fibs.Item n\n        else \n            if  n % 2 = 0 then \n                let k = n \/ 2\n                let result = (2I*(fib (k-1)) + (fib k))*(fib k)\n                fibs.Add(n,result)\n                result\n            else \n                let k = (n+1)\/2\n                let result = (square (fib k)) + (square (fib (k-1)))\n                fibs.Add(n,result)\n                result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83984,"user_id":null,"body":"let rec fibPair =\n    function\n    | 0 -> (bigint.Zero, bigint.One)\n    | 1 -> (bigint.One, bigint.One)\n    | n ->\n        let (a, b) = fibPair (n \/ 2)\n\n        if n &&& 1 = 0 then\n            (a * (2I * b - a), a * a + b * b)\n        else\n            (a * a + b * b, b * (2I * a + b))\n\nlet inline fib n =\n    let ret = fst (fibPair n)\n\n    if n < 0 && n % 2 = 0 then\n        bigint.Negate ret\n    else\n        ret","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83985,"user_id":null,"body":"\n[<Struct>]\ntype FibPair =\n    val a: bigint\n    val b: bigint\n    new(a, b) = { a = a; b = b }\n    static member Zero = FibPair(0I, 1I)\n    static member One = FibPair(1I, 1I)\n\n\nmodule FibPair =\n    let inline getCurrent (_, fp: FibPair) = fp.b\n\n    let inline clac (fp: FibPair) (fp': FibPair) =\n        FibPair(fp.a * fp'.b + (fp.b - fp.a) * fp'.a, fp.a * fp'.a + fp.b * fp'.b)\n\n    let inline initFoldSource n =\n        n\n        |> Seq.unfold\n            (fun state ->\n                if state > 0 then\n                    Some(state &&& 0b1 = 1, state >>> 1)\n                else\n                    None)\n\n    let inline fibPair n =\n        (initFoldSource n, FibPair.Zero)\n        ||> Seq.foldBack\n                (fun isOne state ->\n                    if isOne then\n                        clac state FibPair.One |> clac state\n                    else\n                        clac state state)\n\nlet inline fib (n:int) = \n    let ret =\n        match abs n with\n        | 0 -> 0I\n        | 1 -> 1I\n        | num -> (FibPair.fibPair num).a\n\n    if n < 0 && n % 2 = 0 then\n        bigint.Negate ret\n    else\n        ret","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83986,"user_id":null,"body":"open System.Numerics\n\nlet rec fib n =\n    match n with\n    | n when n < 0 && n % 2 = -1 -> fib (-1 * n)\n    | n when n < 0 && n % 2 = 0 -> -1I * fib (-1 * n)\n    | n when n = 0 || n = 1 -> n |> BigInteger\n    | n when n >= 2 && n % 2 = 0 ->\n        let k = n \/ 2\n        let fk = fib k\n        (2I * fib (k - 1) + fk) * fk\n    | n when n >= 2 ->\n        let k = (n + 1) \/ 2\n        let fk1 = fib (k - 1)\n        let fk2 = fib (k)\n        fk2 * fk2 + fk1 * fk1\n    | _ -> failwith \"not implemented\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83987,"user_id":null,"body":"let hob n =\n    let mutable n = n\n    n <- n ||| (n >>> 1)\n    n <- n ||| (n >>> 2)\n    n <- n ||| (n >>> 4)\n    n <- n ||| (n >>> 8)\n    n <- n ||| (n >>> 16)\n    n - (n >>> 1)\n\nlet rec fib n =\n    let rec loop bit (x, y) =\n        if bit = 0 then y\n        else\n            let x_ = x * x + y * y\n            let y_ = y * (2I * x - y)\n            loop (bit >>> 1) <|\n                if n &&& bit = 0\n                then (x_, y_)\n                else (x_ + y_, x_)\n\n    if n < 0 then\n        if n % 2 = 0\n        then -(fib -n)\n        else fib -n\n    else loop (hob n) (1I, 0I)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83988,"user_id":null,"body":"open System\nopen System.Numerics\nopen System.Collections.Generic\n\nlet fibs = Dictionary<int,BigInteger>()\ndo\n    fibs.Add(0, BigInteger.Zero)\n    fibs.Add(1, BigInteger.One)\n    fibs.Add(2, BigInteger.One)\n    fibs.Add(3, fibs.Item 2 + fibs.Item 1)\n    fibs.Add(4, fibs.Item 3 + fibs.Item 2)\n    fibs.Add(5, fibs.Item 4 + fibs.Item 3)\n\nlet rec calcFibonacci (n:int) = \n    if fibs.ContainsKey n then fibs.Item n\n    else\n        let result =\n            if (n%2) = 1 then\n                let k = (n+1)\/2\n                let fk = BigInteger.Pow(calcFibonacci(k),2)\n                let fkm1 = BigInteger.Pow(calcFibonacci(k-1), 2)\n                fk + fkm1\n            else\n                let k = n\/2\n                let fk = calcFibonacci(k)\n                let fkm1 = calcFibonacci(k-1)\n                (fkm1 * (fibs.Item 3) + fk) * fk;\n\n        fibs.Add(n, result)|> ignore\n        result\n\nlet fib (n:int) =\n    match n with\n    | 0 -> BigInteger.Zero\n    | 1 -> BigInteger.One\n    | _ ->\n        if n < 0 && n%2 = 0 \n            then -(calcFibonacci (Math.Abs(n)))\n            else calcFibonacci (Math.Abs(n))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"53db96041f1a7d32dc0004d2":[{"id":83989,"user_id":53,"body":"let Cell (board: int list list) (i: int) (j: int): int = \n  board.[i].[j]\n\nlet Checksum (board: int list list) (i: int): int =\n  seq { 0..8 }\n  |> Seq.fold (fun acc j -> acc + (Cell board i j) + (Cell board j i) + (Cell board ((i % 3) * 3 + (j % 3)) ((i \/ 3) * 3 + (j \/ 3)))) 0\n\nlet done_or_not (board: int list list): string =\n  if seq { 0..8 }\n    |> Seq.exists (fun i -> (Checksum board i) <> 135) then\n    \"Try again!\"\n  else\n    \"Finished!\"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83990,"user_id":null,"body":"let done_or_not board =\n  let checkLine line = (set line) = set [ 1 .. 9 ]\n  \n  let checkLines lines = lines |> List.forall checkLine\n  \n  let rotate lines =\n    lines\n    |> List.fold\n      (List.map2 (fun x y -> y::x))\n      (List.replicate 9 [])\n\n  (board |> checkLines\n  && board |> rotate |> checkLines)\n  |> function\n    | true -> \"Finished!\"\n    | false -> \"Try again!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83991,"user_id":null,"body":"let done_or_not board =\n    let sumOfNine = [1..9] |> List.sum\n    let rowSums = board |> List.map (fun l -> List.sum l)\n    if rowSums |> List.forall (fun s -> s = sumOfNine) then\n        let colSums = seq {\n            for i in [0..8] do yield board |> List.map (fun l -> l.[0]) |> List.sum\n        }\n        if colSums |> Seq.forall (fun s -> s = sumOfNine) then \"Finished!\" else \"Try again!\"\n    else \"Try again!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83992,"user_id":null,"body":"let done_or_not (board: (int list) list) = \/\/ Code here\n  let rotateBoard = [0..8] |> List.map (fun i -> board |> List.map (fun l -> l.[i]))\n  let isCompleted row = row |> List.countBy id |> List.map snd |> List.forall (fun a -> a = 1)\n  match board @ rotateBoard |> List.map isCompleted |> List.forall id with\n  | true -> \"Finished!\"\n  | false -> \"Try again!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83993,"user_id":null,"body":"let sodukuNumbers = [1; 2; 3; 4; 5; 6; 7; 8; 9]\n\nlet isSodukuNumbers (list: int list) = \n  (List.length list = List.length sodukuNumbers) &&\n    list\n    |> List.sort\n    |> ((=) sodukuNumbers)\n\nlet getColumn n matrix =\n  List.map (fun (row: 'a list) -> row.[n]) matrix\n\nlet rotate matrix = \n  matrix\n  |> List.mapi (fun i _ -> getColumn i matrix)\n  |> List.rev\n\nlet checkRows matrix =\n  matrix\n  |> List.map isSodukuNumbers\n  |> List.reduce (fun acc bool -> acc && bool)\n\nlet checkColumns matrix =\n  matrix\n  |> rotate\n  |> checkRows\n\nlet getRegion i matrix =\n  let row = i % 3\n  let col = i \/ 3\n  matrix\n  |> List.skip (row * 3)\n  |> List.take 3 \n  |> List.map (List.skip (col * 3))\n  |> List.map (List.take 3)\n  |> List.reduce (@)\n\nlet checkRegions matrix = \n  [0..8]\n  |> List.map (fun i -> getRegion i matrix)\n  |> checkRows\n\nlet done_or_not board =\n  let isDone = checkRows board && checkColumns board && checkRegions board\n  if isDone then \"Finished!\" else \"Try again!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83994,"user_id":null,"body":"let done_or_not (board : int list list) =\n  let squareCoordinates =\n    [ for i in 0..2 do\n        for j in 0..2 do\n          yield (i, j) ]\n  \n  let isValidSudoku = List.distinct >> List.length >> (=) 9\n  \n  let allValidSudokus = Seq.map isValidSudoku >> Seq.contains false >> not\n    \n  let validateColumns (board : int list list) =\n    seq {0..8}\n    |> Seq.map(fun j -> board |> List.map(fun row -> row.[j]))\n    |> allValidSudokus\n  \n  let validateRows board =\n    board\n    |> allValidSudokus\n  \n  let squareOffsets = [(0,0); (0,3); (0,6); (3,0); (3,3); (3,6); (6,0); (6,3); (6,6)]\n  let validateSquares (board : int list list) =\n    squareOffsets\n    |> Seq.map (fun offset -> squareCoordinates |> List.map(fun (i, j) -> board.[i + (fst offset)].[j + (snd offset)]))\n    |> allValidSudokus\n\n  if validateColumns board && validateRows board && validateSquares board then\n    \"Finished!\"\n  else\n    \"Try again!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83995,"user_id":null,"body":"let addToStats (sum, mult) value = (sum + value, mult * value)\nlet initialStats = (0, 1)\nlet expectedStats = seq { 1..9 } |> Seq.fold addToStats initialStats\n\nlet done_or_not (board: int list list) =\n  let rowStats = Array.create 9 initialStats\n  let colStats = Array.create 9 initialStats\n  let blockStats = Array.create 9 initialStats\n  for i, row in List.indexed board do\n    for j, cell in List.indexed row do\n      let blockIndex = i \/ 3 * 3 + j \/ 3\n      let value = if cell < 1 || cell > 9 then 0 else cell\n      rowStats.[i] <- addToStats rowStats.[i] value\n      colStats.[j] <- addToStats colStats.[j] value\n      blockStats.[blockIndex] <- addToStats blockStats.[blockIndex] value\n  \n  Seq.concat [rowStats; colStats; blockStats]\n  |> Seq.forall ((=) expectedStats)\n  |> function\n    | true -> \"Finished!\"\n    | false -> \"Try again!\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83996,"user_id":null,"body":"let SudokuBoardChecker (board : int list list) =\n    let digits = [1..9]\n    \n    let row n = board.[n]\n    let col n = \n        [ for i in 0..8 do \n            yield board.[i].[n] ]\n\n    let cell x =\n        let n,m = ( x \/ 3, x % 3 )\n        [ for i in 0..2 do \n            for j in 0..2 do \n                yield board.[3 * n + i].[3 * m + j] ]\n    \n    let isComplete sequence =\n        Seq.except sequence digits |> Seq.isEmpty\n\n    let isUnique sequence = \n        sequence |> Seq.distinct |> (fun e -> Seq.length e = Seq.length sequence)\n\n    let areComplete (f : int -> int list) : bool =\n        let seqs = [0..8]\n                   |> List.map f\n                   \n        printfn \"%A\" seqs\n        let completed = seqs \n                         |>  List.map isComplete\n                         |>  List.reduce (&&) \n\n        let unique = isUnique seqs\n        printfn \"completed: %b unique: %b\" completed unique\n        unique && completed   \n\n    [ areComplete row\n      areComplete col\n      areComplete cell ] \n    |> List.reduce (&&)\n \nlet done_or_not board =\n    match SudokuBoardChecker board with\n    | true -> \"Finished!\"\n    | false -> \"Try again!\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83997,"user_id":null,"body":"let done_or_not (board: int list list) = \/\/ Code here\n  \n  let notDone = \"Try again!\"\n  let finished = \"Finished!\"  \n  let contains1Through9 l = l |> List.distinct |> List.filter ( fun x -> x < 10) |> List.sum = 45\n  \n  let rotateBoard b =\n    b\n    |> List.map (fun x ->x |> List.mapi (fun index value -> (index, value)))\n    |> List.concat\n    |> List.groupBy fst\n    |> List.map (fun (_ ,x ) -> x |> List.map snd )\n  \n  let sectionBoard b =\n    b\n    |> List.mapi (fun i x -> (i \/ 3, x))\n    \/\/rows are indexed\n    |> List.groupBy fst\n    |> List.mapi (fun i x ->\n        \/\/ x is index (column) + rows\n        x\n        |> snd |> List.map snd\n        |> rotateBoard\n        |> List.mapi (fun k x -> (k \/ 3, x))\n        |> List.groupBy fst\n        |> List.map (fun (h , x) -> (i, h, x |> List.map snd |> List.concat))\n        |> List.map (fun (_,_,y) -> y )\n        )\n    |> List.concat\n\n\n  \n  let checkRows b = b |> List.forall (fun x -> x |> contains1Through9  )\n  let checkColumns b = b |> rotateBoard |> checkRows\n  let checkBlocks b = b |> sectionBoard |> checkRows \n   \n  printf \"Board: %A\n\" board\n  printf \"Rotated Board: %A\n\" (rotateBoard board)\n  printf \"Board Sections: %A\n\" (sectionBoard board)\n    \n  if not (checkRows board) then\n    printf \"Rows not correct\"\n    notDone\n  else if not (checkColumns board) then\n    printf \"Columns not correct\"\n    notDone\n  else if not (checkBlocks board) then\n    printf \"Sections not correct\"\n    notDone\n  else\n    finished\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":83998,"user_id":null,"body":"let check (values: int list) =\n    match Set.intersect (set [ 1 .. 9 ]) (set values) |> Set.toList with\n    | [ 1; 2; 3; 4; 5; 6; 7; 8; 9 ] -> true\n    | _ -> false\n\nlet getRegion (matrix: int [,]) (rowStart:int) (rowEnd:int) (colStart:int) (colEnd:int): int list =\n    [ for item in matrix.[rowStart..rowEnd, colStart..colEnd] do yield item :?> int ]\n\nlet done_or_not board =\n    let matrix = array2D board\n    [\n        [0..8] |> List.map (fun i -> getRegion matrix i i 0 8 |> check)\n        [0..8] |> List.map (fun j -> getRegion matrix 0 8 j j |> check)\n        [\n            (0, 2, 0, 2)\n            (0, 2, 3, 5)\n            (0, 2, 6, 8)\n            (3, 5, 0, 2)\n            (3, 5, 3, 5)\n            (3, 5, 6, 8)\n            (6, 8, 0, 2)\n            (6, 8, 3, 5)\n            (6, 8, 6, 8)\n        ] |> List.map (fun (rowStart, rowEnd, colStart, colEnd) -> getRegion matrix rowStart rowEnd colStart colEnd |> check)\n    ]\n    |> List.concat\n    |> List.exists (fun x -> x = false)\n    |> fun hasFailures -> if hasFailures then \"Try again!\" else \"Finished!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"53dbd5315a3c69eed20002dd":[{"id":83999,"user_id":null,"body":"let filter_list (xs : obj list) = xs |> List.choose tryUnbox<int>","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84000,"user_id":491,"body":"open System\nlet filter_list : (obj list -> int list) =\n  List.filter (function | :? int as n -> true | _ -> false) >> List.map unbox\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84001,"user_id":null,"body":"let safeCast<'T> (o:obj) = \n    match o with\n    | :? 'T as x -> Some x\n    | _ -> None\n\nlet filter_list (listOfItems: obj list) =\n    listOfItems |> List.map safeCast<int> |> List.choose id","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84002,"user_id":null,"body":"open System\nlet filter_list = List.filter (fun (x: obj) -> x :? int) >> List.map (fun x -> x :?> int)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84003,"user_id":null,"body":"open System\nlet filter_list (listOfItems: Object list):int list=\n  let isInt x = box x :? int\n  listOfItems |> List.filter isInt \n              |> List.map (fun x -> x :?> int)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84004,"user_id":null,"body":"let filter_list (listOfItems: obj list) =\n    [for item in listOfItems do if item :? int then yield item :?> int]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84005,"user_id":null,"body":"open System\nopen System.Linq\nlet filter_list (listOfItems: Object list) =    \n    listOfItems.OfType<Int32>()\n    |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84006,"user_id":null,"body":"open System\nlet filter_list (listOfItems: Object list) =\n  listOfItems\n  |> List.filter (fun e -> e :? int)\n  |> List.map (fun e -> downcast e : int)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84007,"user_id":null,"body":"open System\n\ntype IntOrString = | I of int | S of string\nlet IsInt o = match o with | I i -> true | _ -> false\nlet ToInt o = match o with | I i -> i | _ -> failwith \"not int passed\"\n\nlet ToStringOrInt (o: Object) = match o with | :? int as i -> I i | :? string as s -> S s | _ -> failwith \"other type\"\n\nlet filter_list (listOfItems: Object list) = listOfItems |> List.map ToStringOrInt |> List.filter IsInt |> List.map ToInt","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84008,"user_id":null,"body":"open System\nlet filter_list (l: obj list) = List.choose tryUnbox<int> l","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5418a1dd6d8216e18a0012b2":[{"id":84009,"user_id":null,"body":"let validate (str:string) =\n  let hash =\n    str\n    |> Seq.filter (fun c -> c <> ' ')\n    |> Seq.map (string >> int)\n    |> Seq.mapi (fun index item -> if index % 2 = 0 then item * 2 else item)\n    |> Seq.map (fun item -> if item > 9 then item - 9 else item)\n    |> Seq.sum\n  hash % 10 = 0\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84010,"user_id":null,"body":"let toIntArray input =\n    input\n    |> String.filter (fun letter -> letter <> ' ')\n    |> Seq.map (fun a -> System.Int32.Parse(string a))\n\nlet validate str =\n    let code = toIntArray str\n    let checksum = \n        code\n        |> Seq.mapi (fun index digit -> if index % 2 = 0 then digit * 2 else digit)\n        |> Seq.map (fun digit ->if digit > 9 then digit - 9 else digit)\n        |> Seq.sum      \n    checksum % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84011,"user_id":null,"body":"let validate (str:string) = \/\/ magic here (=\n  let cardHash =\n      str\n      |> Seq.filter (fun item -> item <> ' ')\n      |> Seq.map (string >> int)\n      |> Seq.mapi (fun index item -> if index % 2 = 0 then item * 2 else item)\n      |> Seq.map (fun item -> if item > 9 then item - 9 else item)\n      |> Seq.sum\n  cardHash % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84012,"user_id":null,"body":"let validate (str:string) =\n    let CheckForZero n = if n%10 = 0 then true else false\n    str.ToCharArray()\n    |> Array.filter (fun ch -> ch <> ' ')\n    |> Array.mapi (fun i ch -> let digit = int ch - int '0';\n                               if i%2 = 0 then if digit <= 4 then digit*2 else digit*2-9\n                               else digit)\n    |> Array.sum\n    |> CheckForZero\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84013,"user_id":null,"body":"let validate (str:string) =\n  let rec digits = function\n  | x when x < 10 -> [x]\n  | x -> (x % 10)::digits (x \/ 10)\n  (str\n  |> String.filter (fun c -> c <> ' ')\n  |> Seq.toList\n  |> List.map (string >> int)\n  |> List.mapi (fun i d -> if i % 2 = 0 then 2*d else d)\n  |> List.map (digits >> List.sum)\n  |> List.sum) % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84014,"user_id":null,"body":"let validate' (str:string) =\n  let toDigits (s: string) = \n    s.ToCharArray() \n    |> Seq.where (System.Char.IsDigit) \n    |> Seq.map (int << System.Char.GetNumericValue)\n    |> Seq.rev\n    |> Seq.toList\n\n  let calc n =\n    let double = n * 2\n    if double > 9\n      then double - 9\n      else double\n\n  let rec luhn lst = \n    match lst with\n    | a::b::xs -> a + (calc b) + (luhn xs)\n    | [a] -> a\n    | [] -> 0\n\n  let digits = toDigits str\n  \n  if Seq.isEmpty digits\n    then false \n    else luhn digits % 10 = 0\n    \nlet validate (n:string) = \/\/ myValidate from the tests\n  let even idx = idx % 2 = 0\n  let odd idx = idx % 2 = 1\n  let arr = [for x in n.Split(' ') do yield! x ]\n  let pred = if arr.Length % 2 = 0 then even else odd \n  let getInt = arr |> List.map (fun i -> System.Convert.ToInt32(System.Char.GetNumericValue(i))) \n  (getInt |> List.mapi (fun idx e -> if idx % 2 = 0 then \n                                            if e*2>9 then (e*2)-9 else e*2 \n                                     else e) |> List.sum) % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84015,"user_id":null,"body":"let validate (str:string) =\n    let stringToDigits = Seq.map (System.Char.GetNumericValue >> int) >> Seq.filter (fun digit -> digit >= 0)\n    \n    let digits = \n        str\n        |> stringToDigits\n        |> Seq.rev\n    \n    let numDigits = Seq.length digits\n    \n    let isEven n = n % 2 = 0\n    let isDigitLengthEven = isEven numDigits\n    \n    let convertGreaterThanNine n =\n        if n > 9\n        then n |> string |> stringToDigits |> Seq.reduce (+)\n        else n\n      \n    let sum =\n        digits\n        |> Seq.mapi (fun index digit ->\n            if isEven index <> isDigitLengthEven\n            then digit * 2 |> convertGreaterThanNine\n            else digit)\n        |> Seq.reduce (+)\n    \n    if sum % 10 = 0 then true else false\n        \n        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84016,"user_id":null,"body":"open System\n\nlet even idx = idx % 2 = 0\nlet odd idx = idx % 2 = 1\n\nlet validate (n:string) = \n     let arr = [for x in n.Split(' ') do yield! x ] \n               |> List.map (fun i -> Convert.ToInt32(Char.GetNumericValue(i))) \n     let pred = if arr.Length % 2 = 0 then even else odd \n     (arr |> List.mapi (fun idx e -> if idx % 2 = 0 then \n                                                if e*2>9 then (e*2)-9 else e*2 \n                                        else e) |> List.sum) % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84017,"user_id":null,"body":"let validate (str:string) =\n  str \n  |> Seq.toArray \n  |> Array.choose (fun s -> \n      match System.Int32.TryParse (s.ToString()) with\n      | true, i -> Some i\n      | _ -> None\n  ) \/\/ e.g., [|9;7;1;4|]\n  |> fun inputs ->\n    if inputs.Length % 2 = 0 then\n      \/\/ even\n      inputs |> Array.mapi (fun i v -> if i % 2 = 0 then v * 2 else v)\n    else\n      \/\/ odd\n      inputs |> Array.mapi (fun i v -> if i % 2 = 1 then v * 2 else v)\n      \/\/ e.g., [|18;7;2;4|]\n  |> Array.map (fun v -> if v > 9 then v - 9 else v) \/\/ e.g., [|9;7;2;4|]\n  |> Array.sum \/\/ e.g., 22\n  |> fun v -> if v % 10 = 0 then true else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84018,"user_id":null,"body":"let mapDigit (i: int) (c: char): int =\n    let x = c |> string |> int\n    if i % 2 = 0\n        then x\n        else \n            let x2 = x*2\n            x2 - if x2 > 9 then 9 else 0\nlet validate (str: string): bool = \n    str\n    |> Seq.filter System.Char.IsDigit\n    |> Seq.rev\n    |> Seq.mapi mapDigit\n    |> Seq.sum\n    |> fun x -> x % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84019,"user_id":null,"body":"open System\n\nlet char2int c =\n    int c - int '0'\n\nlet validate (str:string) =\n    let digits = [ for c in str do if Char.IsDigit(c) then yield char2int c ]        \n    match (digits\n        |> List.mapi (fun i d -> if (i + digits.Length) % 2 = 0 then d * 2 else d)  \/\/ double 2nd, 4th, 6th ... digits from end\n        |> List.map (fun d -> if (d <= 9) then d else d - 9)\n        |> List.sum) with\n    | x when x % 10 = 0 -> true\n    | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84020,"user_id":null,"body":"open System\n\nlet parseToInt (char : char) =\n    match Int32.TryParse(string char) with\n    | true, value -> Some value\n    | _ -> None\n\nlet multiplyBy index = \n    if index % 2 = 0 then 1 else 2\n\nlet adjustOverNine digit = \n    let ajustWith = if (digit > 9) then 9 else 0\n    digit - ajustWith\n\nlet validate (str:string) = \n    let digitChars = str |> Seq.filter ((<>) ' ') |> Seq.map parseToInt\n    let digits = Seq.choose id digitChars\n    let sum = digits \n                |> Seq.rev \n                |> Seq.mapi (fun i d -> multiplyBy i * d)\n                |> Seq.map adjustOverNine\n                |> Seq.sum\n\n    let isValid = if (sum % 10 = 0) then true else false\n    isValid","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84021,"user_id":491,"body":"let validate (str:string) =\n    let rec removeSpaces =\n        function\n        | \"\" -> \"\"\n        | str when str.[0] = ' ' -> removeSpaces str.[1..]\n        | str -> string str.[0] + removeSpaces str.[1..]\n    let rec doubleDigits digits =\n        match digits with\n        | [] -> []\n        | fst::snd::tail -> (2 * fst)::snd::(doubleDigits tail)\n    let digits = [for ch in (removeSpaces str) -> int(string ch)]\n    if digits.Length % 2 = 0 then\n        doubleDigits digits\n    else\n        digits.[0] :: doubleDigits digits.[1..]\n    |> List.map (fun n -> if n > 9 then n - 9 else n)\n    |> List.sum\n    |> (fun x -> x % 10)\n    |> (=) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84022,"user_id":null,"body":"open System\n\nlet charToInt c = int (c.ToString())\n\nlet doubleIfEven index value = match index % 2 with\n                                | 1 -> value * 2\n                                | _ -> value\n\nlet subtractNineIfNotSingleDigit num = match num > 9 with   \n                                        | true -> num-9\n                                        | _ -> num\n\nlet isDivisibleByTen num = num % 10 = 0\n\nlet validate (str:string) = str.Replace(\" \",\"\")\n                            |> List.ofSeq\n                            |> List.rev\n                            |> List.map charToInt\n                            |> List.mapi doubleIfEven\n                            |> List.map subtractNineIfNotSingleDigit\n                            |> List.sum \n                            |> isDivisibleByTen","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84023,"user_id":null,"body":"let (|Odd|Even|) n =\n    match n%2 with\n    | 0 -> Even\n    | _ -> Odd\n\n\nlet validate (str:string) = \n    let digits = \n        str.Replace(\" \", \"\")\n        |> Seq.map (string >> int)\n\n    let isOddLength = Seq.length digits % 2 = 1\n\n    digits\n    |> Seq.mapi (fun i n -> \n        if isOddLength then \n            match i with\n            | Odd -> n * 2\n            | Even -> n\n        else\n            match i with\n            | Odd -> n\n            | Even -> n * 2\n    )\n    |> Seq.map (fun n -> if n > 9 then n - 9 else n)\n    |> Seq.sum\n    |> (fun n -> n % 10 = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84024,"user_id":null,"body":"let validate (str:string) =\n  let num =\n    str        \n    |> Seq.filter (fun c -> c <> ' ')\n    |> Seq.map string        \n    |> Seq.map System.Int32.Parse\n    |> Seq.rev\n    |> Seq.mapi (fun i t -> if i = 0 || i % 2 = 0 then t else t * 2)\n    |> Seq.map (fun t -> if t > 9 then t-9 else t)\n    |> Seq.sum\n    |> (fun i -> i % 10)\n  num = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84025,"user_id":null,"body":"let validate (str:string) =\n    let reduceDigits x = if x > 9 then x - 9 else x\n    let toNum (c:char) = string c |> System.Int32.Parse\n    \n    let doubleIt (c:char) = toNum c |> (*) 2\n        \n    let chars = str.Replace(\" \",\"\").ToCharArray()\n    chars\n    |> Array.mapi(fun i c -> if chars.Length % 2 = 0 && i % 2 = 0 then doubleIt c elif chars.Length % 2 = 1 && i % 2 = 1 then doubleIt c else toNum c)\n    |> Array.map reduceDigits\n    |> Array.reduce(+)\n    |> fun x -> x % 10 = 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84026,"user_id":null,"body":"open System\nlet validate (str:string) =\n let isEven x =x % 2=0\n let s=str.Replace(\" \",\"\")\n let even=isEven s.Length\n let arr=s|>Seq.map (fun x->(int x)-0x30)|>List.ofSeq\n let digits=arr|>List.mapi(fun i x -> let evenIndex=isEven (i+1)\n                                      match even, evenIndex with \n                                      |(true,false)|(false,true)->\n                                       let y=x*2\n                                       if(y>9) then y-9 else y\n                                      |_->x)\n let sum=digits|>List.sum\n sum % 10 =0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84027,"user_id":null,"body":"let validate (str:string) =\n  str.ToCharArray()\n  |> Array.filter (fun x -> x <> ' ')\n  |> Array.map (fun x -> int x - int '0')\n  |> Array.rev\n  |> Array.mapi (fun i x -> if i % 2 = 0 then x else x * 2)\n  |> Array.sumBy (fun x -> if x > 9 then x - 9 else x)\n  |> fun x -> x * 9 % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84028,"user_id":null,"body":"let validate (number: string) =\n\n    let (|Digit|_|) =\n        function\n        | c when c >= '0' && c <= '9' -> Some ((int c) - (int '0'))\n        | _                           -> None\n\n    let toDigitsListRev (numbers: string) =\n        let rec inner remaining digits =\n            match remaining with\n            | [] -> digits |> Ok\n            | c :: rest -> \n                match c with\n                | Digit d -> inner rest (d :: digits)\n                | ' ' -> inner rest digits\n                | _   -> Error (sprintf \"Invalid character '%c'\" c)\n\n        inner (numbers |> Seq.toList) []                    \n\n    let doubleEveryOtherDigit index digit = if index % 2 = 0 then digit else digit * 2\n\n    let toOneDigit digit = if digit > 9 then digit - 9 else digit\n\n    match (number |> toDigitsListRev) with\n    | Error _ -> false\n    | Ok digits when digits.Length = 0 || digits.Length > 16 -> false\n    | Ok digits ->     \n        let sum = digits\n                  |> List.mapi doubleEveryOtherDigit\n                  |> List.map toOneDigit\n                  |> List.sum\n        sum % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84029,"user_id":null,"body":"open System\n\n\nlet doubleSnd i d = \n            match i with\n            | i when i%2 <> 0 -> d * 2\n            | _ -> d\n\nlet reduceTwoDigits = function\n    | x when x > 9 -> x - 9\n    | x -> x\n\nlet verifyChecksum sum = sum%10 = 0\n\nlet validate: string -> bool =\n    Seq.rev\n    >> Seq.filter (fun c -> c <> ' ')\n    >> Seq.map (Char.GetNumericValue >> int)\n    >> Seq.mapi doubleSnd\n    >> Seq.map reduceTwoDigits\n    >> Seq.sum\n    >> verifyChecksum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84030,"user_id":null,"body":"let charToInt (c: char) = int c - int '0'\n\nlet validate (str:string) =\n    let ints =  str\n                |> (fun s -> s.Replace (\" \", \"\"))\n                |> Seq.map charToInt\n                |> Array.ofSeq\n    let len = Array.length ints\n    ints\n    |> Array.mapi (fun i x -> \n                    if ((i ^^^ len) &&& 1) = 0 \n                    then (x * 2) \n                    else x)\n    |> Array.sumBy (fun x -> if x < 10 then x else x - 9)                               \n    |> (fun x -> (x % 10) = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84031,"user_id":null,"body":"\nlet validate (str:string) =\n    let doubleEveryOtherDigit (x: (int*int)[]) = \n        let odd = x.Length % 2\n\n        let mapSingle (index, item) =         \n            if (odd = (index % 2)) then\n                item * 2\n            else\n                item\n        Array.map mapSingle x\n\n    let substract9IfBiggerThan9 x = \n        if (x > 9) then\n            x - 9\n        else \n            x\n  \n    str.ToCharArray()\n    |> Array.filter ((<>) ' ')\n    |> Array.map (string >> int)\n    |> Array.indexed\n    |> doubleEveryOtherDigit\n    |> Array.map substract9IfBiggerThan9\n    |> Array.sum\n    |> (fun x -> (x % 10) = 0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84032,"user_id":null,"body":"let validate s =\n  s\n  |> Seq.choose\n    (function\n     | ' ' -> None\n     | x ->\n       int x - int '0'\n       |> Some)\n  |> Seq.rev\n  |> Seq.mapi\n    (fun i x ->\n      if i % 2 = 1 then x * 2\n      else x)\n  |> Seq.map\n    (fun x ->\n      if x > 9 then x - 9\n      else x)\n  |> Seq.sum\n  |> (fun x -> x % 10 = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84033,"user_id":null,"body":"let validate (str:string) =\n    let sumdigits = \n      str.Replace(\" \",\"\")\n      |> Seq.rev \n      |> Seq.mapi (fun i l -> if i % 2 = 0 then System.Int32.Parse (string l) else  (if System.Int32.Parse (string l) * 2 > 9 then (System.Int32.Parse (string l) * 2 - 9) else (System.Int32.Parse (string l) * 2))  )\n      |> Seq.sum\n    sumdigits % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84034,"user_id":null,"body":"let validate = Seq.filter System.Char.IsDigit\n            >> Seq.map (string >> int)\n            >> Seq.rev\n            >> Seq.mapi (fun i d -> if i % 2 <> 0 \n                                    then (d*2 - if d*2 > 9 then 9 else 0)\n                                    else d)\n            >> Seq.sum\n            >> fun x -> x % 10 = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84035,"user_id":null,"body":"let digits (s: string) = s |> Seq.filter ((<>) ' ') |> Seq.map (string >> int)\nlet isEven x = if x % 2 = 0 then true else false\n\n\nlet newNum evenLength index num =\n    let evenIndex = isEven index\n    let doubled = num*2\n    if (evenLength && evenIndex) || not (evenLength || evenIndex)\n    then if doubled > 9 then doubled-9 else doubled\n    else num\n\n\nlet validate (str:string) =\n    let digs = str |> digits\n    let evenLength = isEven (Seq.length digs)\n    digs\n    |> Seq.mapi (newNum evenLength)\n    \/\/|> Seq.map (fun num -> if num > 9 then num - 9 else num)\n    |> Seq.sum\n    |> fun x -> (x % 10) = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84036,"user_id":null,"body":"let digits (s: string) = s |> Seq.filter ((<>) ' ') |> Seq.map (string >> int)\nlet isEven x = if x % 2 = 0 then true else false\n\nlet newNum evenLength index num =\n    let evenIndex = isEven index\n    if (evenLength && evenIndex) || not (evenLength || evenIndex)\n    then num*2\n    else num\n\nlet validate (str:string) =\n    let digs = str |> digits\n    let evenLength = isEven (Seq.length digs)\n    digs\n    |> Seq.mapi (newNum evenLength)\n    |> Seq.map (fun num -> if num > 9 then num - 9 else num)\n    |> Seq.sum\n    |> fun x -> (x % 10) = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84037,"user_id":null,"body":"let digits (s: string) = s |> Seq.filter ((<>) ' ') |> Seq.map (string >> int)\nlet isEven x = if x % 2 = 0 then true else false\n\nlet newNum evenLength index num =\n    let evenIndex = isEven index\n    if (evenLength && evenIndex) || not (evenLength || evenIndex)\n    then num*2\n    else num\n\n\nlet validate (str:string) =\n    let digs = str |> digits\n    let evenLength = isEven (Seq.length digs)\n    digs\n    |> Seq.mapi (newNum evenLength)\n    |> Seq.map (fun num -> if num > 9 then num - 9 else num)\n    |> Seq.sum\n    |> fun x -> if (x % 10) = 0 then true else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84038,"user_id":null,"body":"open System\n\nlet double_digit n =\n  let double = n * 2\n  if (double > 9) then\n    double - 9\n  else\n    double\n    \nlet rec luhn_loop isEven acc input = \n  match input with\n    | [] -> acc % 10 = 0\n    | x :: xs -> let num = int x - int '0'\n                 if (isEven) then\n                   luhn_loop (not isEven) (acc + (double_digit num)) xs\n                 else\n                   luhn_loop (not isEven) (acc + num) xs\n\nlet validate (str:string) = \/\/ magic here (=\n  str.Split[|' '|]\n      |> String.concat \"\"\n      |> Seq.toArray\n      |> Array.rev\n      |> Seq.toList\n      |> luhn_loop false 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84039,"user_id":null,"body":"open System\nlet dub x = x * 2\n\nlet isEven x = x % 2 = 0\n\nlet floor next = \n    if (next > 9) then \n       next - 9\n     else next\n\nlet isValid sum = sum % 10 = 0\n\nlet fold i a =     \n    if isEven i then a else dub a        \n    |> floor \n    \nlet validate (str: string) = \/\/ magic here (=\n   str.Replace(\" \", \"\").ToCharArray()\n   |> Array.map (string >> Int32.Parse) \n   |> Array.rev\n   |> Array.mapi fold\n   |> Array.sum\n   |> isValid\n   \n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84040,"user_id":null,"body":"open System\n\nlet doubleOrSum n = if n * 2 > 9 then n * 2 - 9 else n * 2\n\nlet validate (str:string) = Seq.filter Char.IsDigit str\n                            |> String.Concat\n                            |> Seq.map (fun c -> Int32.Parse(c.ToString()))\n                            |> Seq.rev\n                            |> Seq.mapi (fun i n -> if i % 2 <> 0 then doubleOrSum(n) else n)\n                            |> Seq.sum\n                            |> fun (n: int) -> n % 10 = 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84041,"user_id":null,"body":"let validate (x:string) =\n    x\n    |> Seq.filter (fun x -> not <| (string x).Equals(\" \"))\n    |> Seq.fold (fun acc x -> x::acc) []\n    |> Seq.map (string >> int)\n    |> Seq.mapi (fun i v -> if i % 2 = 0 then v else v*2)\n    |> Seq.map (fun v -> if v >= 10 then v-9 else v)\n    |> Seq.sum\n    |> (fun v -> v % 10 = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"541c8630095125aba6000c00":[{"id":84042,"user_id":209,"body":"let rec digital_root n = \n    (n - 1) % 9 + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84043,"user_id":null,"body":"let sumDigits n = \n    let rec aux acc temp =\n        match temp \/ 10 with\n        | 0 -> acc + temp\n        | n -> aux (acc + temp % 10) n\n    aux 0 n\n\nlet rec digital_root n = \n    match sumDigits n with\n    | x when x < 10 -> x\n    | x -> digital_root x\n    ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84044,"user_id":252,"body":"let rec digital_root n =\n    if n < 10 then n else n |> string |> Seq.sumBy (string >> int) |> digital_root\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84045,"user_id":null,"body":"let rec digitsOf = function\n  | 0 -> []\n  | n -> (n % 10) :: digitsOf (n \/ 10)\n  \n\nlet rec digital_root n = \n    if n <= 9 then n\n    else digitsOf n |> List.sum |> digital_root","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84046,"user_id":null,"body":"let rec digitSum n =\n    if n < 10 then n\n    else (n % 10) + digitSum (n \/ 10)\n\nlet rec digital_root n =\n    let sum = digitSum n\n    if sum < 10 then sum\n    else digital_root sum","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84047,"user_id":null,"body":"let rec digital_root n = \n    let rec digital_rootRec nn acc =\n        match nn \/ 10 with\n        | 0 ->\n            match (acc + nn) \/ 10 with\n            | 0 -> acc + nn\n            | _ -> digital_rootRec (acc + nn) 0\n        | x -> digital_rootRec x (acc + nn % 10)\n\n    digital_rootRec n 0\n\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84048,"user_id":null,"body":"let rec digital_root n = \n    match (n \/ 10), (n % 10) with\n    | 0, rem -> rem\n    | x, rem -> (rem + digital_root x) |> digital_root","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84049,"user_id":50,"body":"let rec digital_root n = if n = 0 then 0 else ((n-1)%9)+1","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84050,"user_id":null,"body":"let rec digital_root n =\n    if n < 10 then n\n    else n.ToString().ToCharArray()\n         |> Array.fold (fun s x -> s + int(x) - int('0')) 0\n         |> digital_root","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84051,"user_id":null,"body":"let rec digital_root n = \n    match n with\n    | n when n < 10 -> n\n    | n -> n |> Seq.unfold (function 0 -> None | p -> Some (p % 10, p \/ 10)) |> Seq.sum |> digital_root","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5420fc9bb5b2c7fd57000004":[{"id":84052,"user_id":527,"body":"let highest_rank = Seq.countBy id >> Seq.maxBy (fun (x, k) -> (k, x)) >> fst","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84053,"user_id":null,"body":"let highest_rank =\n  Seq.countBy id\n  >> Seq.sortByDescending (fun (n, c) -> c, n)\n  >> Seq.head\n  >> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84054,"user_id":null,"body":"let highest_rank = Array.countBy id >> Array.sortByDescending fst >> Array.maxBy snd >> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84055,"user_id":527,"body":"let highest_rank (xs: 'a seq): 'a =\n  xs\n    |> Seq.countBy id\n    |> Seq.maxBy (fun (x, k) -> (k, x))\n    |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84056,"user_id":null,"body":"let highest_rank (array: int[]) =\n  array\n  |> Seq.countBy (fun i -> i)\n  |> Seq.maxBy (fun (i, n) -> n, i)\n  |>\n  (fun is ->\n  match is with\n  | (x,_) -> x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84057,"user_id":null,"body":"let highest_rank = Seq.countBy id >> Seq.sortDescending >> Seq.maxBy snd >> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84058,"user_id":null,"body":"let highest_rank (arr: int[]) =\n    arr\n    |> Array.countBy id\n    |> Array.sortBy (fun x -> snd x, fst x)\n    |> Array.last\n    |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84059,"user_id":null,"body":"let highest_rank =\n    Array.countBy id\n    >> Array.sortByDescending (fun (num: int, occurences) -> occurences, num)\n    >> Array.head\n    >> fst\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84060,"user_id":null,"body":"let highest_rank (array: int []) =\n    let result =\n        array\n        |> Array.countBy id\n        |> Array.sortByDescending snd\n\n    result\n    |> Array.filter (fun (_, y) -> y = (Array.head result |> snd))\n    |> Array.sortByDescending fst\n    |> Array.head\n    |> fst\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84061,"user_id":null,"body":"let highest_rank (array: int[]) =\n    array\n    |> Array.groupBy (fun x -> x)\n    |> Array.sortByDescending (fun x -> snd x)\n    |> Array.item 0\n    |> fst\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5436f26c4e3d6c40e5000282":[{"id":84062,"user_id":491,"body":"let sumOfN (n : int) : int list =\n    [for n' in 0..abs(n) -> n' * (n' + 1) \/ (if n > 0 then 2 else -2)]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84063,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    if n<0 then (List.scan (+) 0 [ -1 .. -1 .. n ])\n    else (List.scan (+) 0 [ 1 .. n ])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84064,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    [0..abs n] |> List.map (fun v -> v*(abs(v)+1)\/2 * sign n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84065,"user_id":527,"body":"let sumOfN (n : int) : int list =\n  {0 .. abs n} |> Seq.map (fun i -> System.Math.Sign n * (i * i + i) \/ 2) |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84066,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    let sign = match n >= 0 with true -> 1 | false -> -1;\n    let array = [0..n * sign] |> List.toArray\n    \n    for i in [1..n*sign] do\n      Array.set array i (sign * array.[i] + array.[i-1])\n    array |> Array.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84067,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    [ for i in 0 .. abs n do\n          let x = i * (i + 1) \/ 2\n          yield if n < 0 then -x else x ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84068,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    match n with\n        | n when n > 0 -> List.init (n + 2) (fun idx -> (idx * idx - idx) \/ 2)\n        | n when n < 0 -> List.init (abs n + 2) (fun idx -> ((idx * idx - idx) \/ 2) * -1)\n        | _ -> failwith \"todo\"\n    |> List.skip 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84069,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    let mutable sum = 0\n    [\n        for i in 0..abs n do\n            sum <- sum + i * sign n\n            yield sum\n    ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84070,"user_id":null,"body":"open System.Collections.Generic\n\nlet sumOfN (n : int) : int list =\n    let cache = Dictionary<int,int>()\n    cache.Add(0,0)\n    let memo (i: int) =\n        let exist, value = cache.TryGetValue i\n        match exist with\n        | true -> value\n        | false -> let value = i + cache.[i-1]\n                   cache.Add (i, value)\n                   value\n    match n with\n    | 0 -> [0]\n    | x when x > 0 -> [for i in 0..n -> memo i]\n    | x when x < 0 -> [for i in 0..-n -> -(memo i)] ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84071,"user_id":null,"body":"let sumOfN (n : int) : int list =\n    [ sign n .. sign n .. n ]\n    |> List.scan (+) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5467e4d82edf8bbf40000155":[{"id":84072,"user_id":null,"body":"let descending_order n =  \n    string n \n    |> Seq.sortDescending \n    |> Seq.map string \n    |> Seq.reduce (+) \n    |> int","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84073,"user_id":491,"body":"let descending_order =\n    string >> Seq.sort >> Seq.rev >> Seq.map string >> String.concat \"\" >> int","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84074,"user_id":null,"body":"let descending_order n =  \n        let ret = n.ToString()\n                    |> Seq.sortDescending\n                    |> System.String.Concat\n        int ret                ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84075,"user_id":null,"body":"open System\n\nlet descending_order = string >> Seq.sortDescending >> String.Concat >> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84076,"user_id":null,"body":"let descending_order n =  \n    string n\n    |> Seq.sortDescending\n    |> System.String.Concat\n    |> int\n\/\/ there is also a String.concat \n\/\/ but it doesn't accept char as input\n\/\/ System.String.Concat accepts char and converts to string","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84077,"user_id":null,"body":"let descending_order n = \n    let mutable sum = 0\n    let arrayIntN = [|for x in n.ToString().ToCharArray() -> int x - int '0'|] |> Array.sortBy (~-)\n    for i in arrayIntN do sum <- sum * 10 + i \n    sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84078,"user_id":null,"body":"let descending_order n =  \n    System.Int32.Parse(System.String(n.ToString() |> Seq.sortDescending |> Seq.toArray))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84079,"user_id":null,"body":"let descending_order n =  \n  let rec convert l number =\n    match l, number with\n    | [], 0 -> [0]\n    | _, 0 -> l\n    | _, n -> convert ((n % 10)::l) (n \/ 10)\n\n  convert [] n\n  |> List.sortDescending\n  |> List.reduce (fun acc item -> acc * 10 + item)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84080,"user_id":null,"body":"let descending_order n =  \n    let rec splitNumber = function\n      | x when x >= 10 -> splitNumber ( x \/ 10) @ [x % 10]\n      | x -> [x] \n          \n    let rec joinDigit = function\n      | x::xs -> x + (joinDigit xs) * 10\n      | [] -> 0\n      \n    splitNumber n |> List.sort |> joinDigit","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84081,"user_id":null,"body":"let descending_order (n: int) =\n    n\n    |> string\n    |> Seq.map (string >> int)\n    |> Seq.sort\n    |> Seq.indexed\n    |> Seq.sumBy(fun (i, d) -> d * (pown 10 i))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"546e2562b03326a88e000020":[{"id":84082,"user_id":null,"body":"let square x = x * x\n\nlet toString x = x.ToString()\n\nlet square_digits n = \n    n.ToString() \n    |> Seq.map (toString >> int >> square >> toString)\n    |> String.concat \"\"\n    |> int","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84083,"user_id":null,"body":"open System\n\nlet charToInt c = (int c) - (int '0')\n\nlet square x = x * x\n\nlet square_digits n = \n    n \n    |> string\n    |> Seq.map (charToInt >> square >> string)\n    |> String.Concat\n    |> Int32.Parse","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84084,"user_id":null,"body":"\nlet square_digits (n: int) =\n    let squared =\n        sprintf \"%i\" n\n        |> Seq.map (\n            System.Char.GetNumericValue\n            >> (fun f -> f * f)\n            >> int\n            >> sprintf \"%d\"\n        )\n    System.String.Join(\"\",squared) |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84085,"user_id":null,"body":"let charToInt c = int c - int '0'\nlet mult x = x*x\nlet toStr x = x.ToString()\n\nlet transformNumber = charToInt >> mult >> toStr\n\nlet square_digits n = \n    n.ToString()\n    |> Seq.map transformNumber\n    |> Seq.reduce (+)\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84086,"user_id":null,"body":"let inline charToInt c = int c - int '0'\nlet square_digits n = \n    n.ToString()\n    |> Seq.toList\n    |> Seq.map (fun x -> x |> charToInt)\n    |> Seq.map (fun x -> (x*x).ToString())\n    |> Seq.fold (fun acc x -> sprintf \"%s%s\"acc x) \"\"\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84087,"user_id":null,"body":"open System\n\nlet square_digits n =\n  n.ToString().ToCharArray()\n  |> Array.map (fun ch -> Int32.Parse(ch.ToString()))\n  |> Array.map (fun x -> float x ** 2.)\n  |> Array.map string\n  |> Array.reduce (+)\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84088,"user_id":null,"body":"let chToInt = (string >> int)\nlet square_digits n = \n    n |> string |> Seq.map (fun x -> chToInt x * chToInt x |> string) |> String.concat \"\" |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84089,"user_id":null,"body":"let square_digits n = \n    let toDigits = function\n        | 0 -> Seq.singleton 0\n        | number -> \n            number |> Seq.unfold (function 0 -> None | p -> Some (p % 10, p \/ 10)) \n    n \n    |> toDigits\n    |> Seq.collect (fun p -> p * p |> toDigits)\n    |> Seq.rev\n    |> Seq.fold (fun state item -> state * 10 + item) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54b724efac3d5402db00065e":[{"id":84090,"user_id":null,"body":"open System\nlet decode_morse (morseCode: string) =\n    let decoded = \n        morseCode.Split([|\"   \"|], StringSplitOptions.None)\n        |> Array.map (fun word -> \n            word.Split [| ' ' |]\n            |> Array.map (fun letter -> MorseCode.get letter)\n            |> System.String.Concat)\n        |> String.concat \" \"\n    decoded.Trim()\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84091,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet decode_morse (morseCode: string) =\n    let decodeWord (word : string) =\n        word.Split(' ')\n        |> Seq.map MorseCode.get\n        |> Seq.reduce (+)\n    Regex(\"   \").Split(morseCode.Trim())\n    |> Seq.map decodeWord\n    |> Seq.reduce (sprintf \"%s %s\")\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84092,"user_id":null,"body":"\nlet decodeElement (el: string) =\n  match el with\n  | \".-\"    -> \"A\"\n  | \"-...\"  -> \"B\"\n  | \"-.-.\"  -> \"C\"\n  | \"-..\"   -> \"D\"\n  | \".\"     -> \"E\"\n  | \"..-.\"  -> \"F\"\n  | \"--.\"   -> \"G\"\n  | \"....\"  -> \"H\"\n  | \"..\"    -> \"I\"\n  | \".---\"  -> \"J\"\n  | \"-.-\"   -> \"K\"\n  | \".-..\"  -> \"L\"\n  | \"--\"    -> \"M\"\n  | \"-.\"    -> \"N\"\n  | \"---\"   -> \"O\"\n  | \".--.\"  -> \"P\"\n  | \"--.-\"  -> \"Q\"\n  | \".-.\"   -> \"R\"\n  | \"...\"   -> \"S\"\n  | \"-\"     -> \"T\"\n  | \"..-\"   -> \"U\"\n  | \"...-\"  -> \"V\"\n  | \".--\"   -> \"W\"\n  | \"-..-\"  -> \"X\"\n  | \"-.--\"  -> \"Y\"\n  | \"--..\"  -> \"Z\"\n  | \".----\" -> \"1\"\n  | \"..---\" -> \"2\"\n  | \"...--\" -> \"3\"\n  | \"....-\" -> \"4\"\n  | \".....\" -> \"5\"\n  | \"-....\" -> \"6\"\n  | \"--...\" -> \"7\"\n  | \"---..\" -> \"8\"\n  | \"----.\" -> \"9\"\n  | \"-----\" -> \"0\"\n  | \".-.-.-\" -> \".\"\n  | \"--..--\" -> \",\"\n  | \"..--..\" -> \"?\"\n  | \".----.\" -> \"'\"\n  | \"-.-.--\" -> \"!\"\n  | \"-..-.\"  -> \"\/\"\n  | \"-.--.\"  -> \"(\"\n  | \"-.--.-\" -> \")\"\n  | \".-...\"  -> \"&\"\n  | \"---...\" -> \":\"\n  | \"-.-.-.\" -> \";\"\n  | \"...---...\" -> \"SOS\"\n  | _ -> \"\"\n\nlet decodeWord (w: string) =\n  w.Split ' ' \n  |> Array.map decodeElement\n  |> Array.fold (fun x a -> x + a) \"\"\n\nlet decode_morse (morseCode: string) =\n  morseCode.Trim().Replace(\"   \", \"#\").Split('#')\n  |> Array.map decodeWord\n  |> String.concat \" \"\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84093,"user_id":878,"body":"open System.Text.RegularExpressions\n\nlet decode_morse (morseCode: string) =\n    let spaced =\n      morseCode.Trim().Split(' ')\n      |> Seq.map (fun str ->\n        match str with\n        | \"\" -> \" \"\n        | _ -> MorseCode.get str)\n      |> String.concat \"\"\n    \n    Regex.Replace(spaced, @\"\\s+\", \" \")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84094,"user_id":null,"body":"let morseWordSeparator, morseCharSeparator = [| \"   \" |], [| ' ' |]\nlet splitOption = System.StringSplitOptions.RemoveEmptyEntries\n\nlet decode_morse (morseCode: string) =\n    morseCode.Split(morseWordSeparator , splitOption)\n    |> Array.map (\n        fun morseWord -> \n            morseWord.Split(morseCharSeparator, splitOption) \n            |> (Array.map MorseCode.get >> String.concat \"\"))     \n    |> String.concat \" \" \/\/ join words back to form sentence\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84095,"user_id":null,"body":"let morseLU = \n    dict [\n        \".-\", \"A\"\n        \"-...\", \"B\"\n        \"-.-.\", \"C\"\n        \"-..\", \"D\"\n        \".\", \"E\"\n        \"..-.\", \"F\"\n        \"--.\", \"G\"\n        \"....\", \"H\"\n        \"..\", \"I\"\n        \".---\", \"J\"\n        \"-.-\", \"K\"\n        \".-..\", \"L\"\n        \"--\", \"M\"\n        \"-.\", \"N\"\n        \"---\", \"O\"\n        \".--.\", \"P\"\n        \"--.-\", \"Q\"\n        \".-.\", \"R\"\n        \"...\", \"S\"\n        \"-\", \"T\"\n        \"..-\", \"U\"\n        \"...-\", \"V\"\n        \".--\", \"W\"\n        \"-..-\", \"X\"\n        \"-.--\", \"Y\"\n        \"--..\", \"Z\"\n        \"-----\", \"0\"\n        \".----\", \"1\"\n        \"..---\", \"2\"\n        \"...--\", \"3\"\n        \"....-\", \"4\"\n        \".....\", \"5\"\n        \"-....\", \"6\"\n        \"--...\", \"7\"\n        \"---..\", \"8\"\n        \"----.\", \"9\"\n        \".-.-.-\", \".\"\n        \"--..--\", \",\"\n        \"..--..\", \"?\"\n        \"-.-.--\", \"!\"\n        \"...---...\", \"SOS\"\n    ]\n\nopen System\n\nlet morseWordSeparator, morseCharSeparator = [| \"   \" |], [| ' ' |]\n\nlet decode_morse (morseCode: string) =\n    morseCode.Split(morseWordSeparator , StringSplitOptions.RemoveEmptyEntries)\n    |> Array.map (\n        fun morseWord -> \n            morseWord.Split(morseCharSeparator, StringSplitOptions.RemoveEmptyEntries) \n            |> Array.map (fun morseCode -> morseLU.TryGetValue morseCode) \n            |> Array.filter fst \n            |> Array.map snd\n            )     \n    |> Array.map (String.concat \"\") \/\/ join characters back to form word\n    |> String.concat \" \"            \/\/ join words back to form sentence\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84096,"user_id":null,"body":"let decode_morse (morseCode: string) =\n    let decode_morseWord (morseWord: string) =\n      morseWord.Split(' ')\n      |> Array.map (fun c -> MorseCode.get c)\n      |> String.concat \"\"\n        \n    morseCode.Split([|\"   \"|], StringSplitOptions.RemoveEmptyEntries)\n    |> Array.map decode_morseWord\n    |> String.concat \" \"\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84097,"user_id":null,"body":"let decode_morseWord (word: string) =\n  let letters = word.Split([|\" \"|], StringSplitOptions.None)\n  let decodedLetters = \n    letters \n    |> Array.map (fun letter -> MorseCode.get letter)\n  String.Join(\"\", decodedLetters)\n\nlet decode_morse (morseCode: string) =\n  let words = morseCode.Trim().Split([|\"   \"|], StringSplitOptions.None)\n  let decodedWords = \n    words \n    |> Array.map (fun word -> decode_morseWord word)\n  String.Join(\" \", decodedWords)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84098,"user_id":null,"body":"let parseMorseLetter letter =\n  match letter with\n  | \".-\" -> \"A\"\n  | \"-...\" -> \"B\" \n  | \"-.-.\" -> \"C\"\n  | \"-..\" -> \"D\"\n  | \".\" -> \"E\"\n  | \"..-.\" -> \"F\"\n  | \"--.\" -> \"G\"\n  | \"....\" -> \"H\"\n  | \"..\" -> \"I\"\n  | \".---\" -> \"J\"\n  | \"-.-\" -> \"K\"\n  | \".-..\" -> \"L\"\n  | \"--\" -> \"M\"\n  | \"-.\" -> \"N\"\n  | \"---\" -> \"O\"\n  | \".--.\" -> \"P\" \n  | \"--.-\" -> \"Q\"\n  | \".-.\" -> \"R\"\n  | \"...\" -> \"S\"\n  | \"-\" -> \"T\"\n  | \"..-\" -> \"U\"\n  | \"...-\" -> \"V\"\n  | \".--\" -> \"W\"\n  | \"-..-\" -> \"X\"\n  | \"-.--\" -> \"Y\"\n  | \"--..\" -> \"Z\"\n  | \".----\" -> \"1\"\n  | \"..---\" -> \"2\"\n  | \"...--\" -> \"3\"\n  | \"....-\" -> \"4\"\n  | \".....\" -> \"5\"\n  | \"-....\" -> \"6\"\n  | \"--...\" -> \"7\"\n  | \"---..\" -> \"8\"\n  | \"----.\" -> \"9\"\n  | \"-----\" -> \"0\"\n  | \"...---...\" -> \"SOS\"\n  | \"-.-.--\" -> \"!\"\n  | \".-.-.-\" -> \".\"\n  | _ -> \"\"\n  \nlet parseMorseWord(word : string) : string = \n    let letters = word.Split([|\" \"|], StringSplitOptions.RemoveEmptyEntries)\n    letters \n    |> Array.map(fun x -> parseMorseLetter x) \n    |> Array.reduce (fun x y -> x + y)\n\nlet decode_morse (morseCode: string) =\n    let words = morseCode.Split([|\"   \"|], StringSplitOptions.RemoveEmptyEntries)\n    words \n    |> Array.map (fun x -> parseMorseWord x) \n    |> Array.reduce (fun x y -> x + \" \" + y)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84099,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\nlet decode_morse (morseCode: string) =    \n    let decoded =\n        Regex.Split(morseCode.Trim(), \"   \")\n        |>Seq.map ((fun str -> str.Split(' ')) >> Seq.map MorseCode.get >> String.Concat)\n    String.Join(\" \", decoded)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54bf1c2cd5b56cc47f0007a1":[{"id":84100,"user_id":491,"body":"let duplicate_count (text : string) : int =\n    text.ToLower()\n    |> Seq.countBy id\n    |> Seq.filter (fun (_, count) -> count > 1)\n    |> Seq.length","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84101,"user_id":null,"body":"let duplicate_count text =\n    (text: string).ToLower()\n    |> Seq.countBy id\n    |> Seq.filter (snd >> ((<)1))\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84102,"user_id":527,"body":"let duplicate_count =\n  Seq.countBy System.Char.ToUpper >> Seq.filter (fun (_, n) -> n > 1) >> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84103,"user_id":null,"body":"open System\n\nlet duplicate_count text =\n  text\n  |> Seq.groupBy Char.ToUpper\n  |> Seq.filter (fun (k, vs) -> (Seq.length vs) > 1)\n  |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84104,"user_id":null,"body":"let greaterThan1 (x: seq<char>): int = \n   match Seq.length x with\n    | 0 -> 0\n    | 1 -> 0\n    | _ -> 1\n\nlet duplicate_count (text : string) : int =\n   text\n        |> Seq.map (fun x -> System.Char.ToLower x)\n        |> Seq.groupBy (fun s -> s)\n        |> Seq.map (fun s -> greaterThan1 (snd s))\n        |> Seq.sum\n    \n      \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84105,"user_id":null,"body":"let duplicate_count (text : string) : int =\n    text.ToUpper()\n    |> Seq.fold (fun a x -> \n      let count = Map.tryFind x a |> Option.defaultValue 0\n      Map.add x (count + 1) a\n    ) Map.empty\n    |> Map.fold(fun a k v ->\n      if v > 1 then a + 1\n      else a\n    ) 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84106,"user_id":null,"body":"open System\n\nlet duplicate_count (text : string) : int =\n  text\n  |> Seq.groupBy (fun char -> System.Char.ToLower(char))\n  |> Seq.filter (fun (_, sq) -> (Seq.length sq) >= 2)\n  |> Seq.length\n ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84107,"user_id":null,"body":"let duplicate_count (text : string) : int =\n  text.ToLower()\n  |> Seq.groupBy id\n  |> Seq.fold (fun s (_, x) -> if (Seq.length x) > 1 then s + 1 else s) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84108,"user_id":null,"body":"let duplicate_count (text : string) : int =\n  text.ToLower().ToCharArray()\n  |> Array.groupBy id\n  |> Array.fold (fun s (_, x) -> if x.Length > 1 then s + 1 else s) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84109,"user_id":null,"body":"open System.Collections.Generic\n\nlet duplicate_count (text : string) : int =\n    let dict = Dictionary<char, int>()\n\n    text.ToLowerInvariant()\n    |> Seq.toArray\n    |> Array.iter (fun (c: char) ->\n        if dict.ContainsKey c then\n            dict.[c] <- dict.[c] + 1\n        else\n            dict.Add(c, 1))\n\n    dict\n    |> Seq.filter (fun (kvp: KeyValuePair<char, int>) -> kvp.Value > 1)\n    |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54d496788776e49e6b00052f":[{"id":84110,"user_id":null,"body":"let sum_of_divided(lst: int list): string =\n  let isDivisible f n = n % f = 0\n  let factors n =\n    let rec factorsRec n f fs =\n        match n with\n        | 1 | -1 -> fs\n        | n when isDivisible f n -> factorsRec (n \/ f) f (Set.add f fs)\n        | _ -> factorsRec n (f + 1) fs\n    factorsRec n 2 Set.empty<int>\n  let createElement factor = \n    sprintf \"(%i %i)\" factor (lst |> Seq.filter (isDivisible factor) |> Seq.sum)\n  \n  lst\n    |> Seq.map factors\n    |> Set.unionMany\n    |> Seq.sort\n    |> Seq.map createElement\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84111,"user_id":491,"body":"let sum_of_divided lst =\n    let factorize n =\n        let mutable n = n\n        seq {\n            for p in 2 .. int(sqrt(float(n))) do\n                while n % p = 0 do\n                    yield p; n <- n \/ p\n            if n <> 1 then yield n\n        } |> Seq.distinct\n    let rec sum_of_divided' lst aggregator =\n        match lst with\n        | [] -> aggregator\n        | head::tail ->\n            head |> abs |> factorize\n            |> Seq.fold (fun a e -> Map.add e (if Map.containsKey e a then head + Map.find e a else head) a) aggregator\n            |> sum_of_divided' tail\n    let parseOutput (m : Map<int, int>) : string =\n        m |> Map.map (fun k v -> sprintf \"(%d %d)\" k v) |> Map.toList |> List.map snd |> String.concat \"\"\n    sum_of_divided' lst Map.empty |> parseOutput","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84112,"user_id":492,"body":"let sum_of_divided(lst: int list): string =\n    let rem = [|for i in 0..lst.Length - 1 do yield abs(lst.[i])|]\n    let max = Array.max rem\n    let mutable result = \"\"\n    for fac = 2 to max do\n        let mutable isFactor = false\n        let mutable tot = 0\n        for i = 0 to lst.Length - 1 do\n            if (rem.[i] % fac = 0) then\n                isFactor <- true\n                tot <- tot + lst.[i]\n                while (rem.[i] % fac = 0) do\n                    rem.[i] <- rem.[i] \/ fac\n        if (isFactor) then\n            result <- result + \"(\" + (fac |> string) + \" \" + (tot |> string) + \")\"\n    result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84113,"user_id":null,"body":"let getPrimesTill n =\n  let rec loop c acc =\n    if c > n then\n      acc\n    else\n      let isPrime =\n        Set.forall (fun p -> c % p <> 0) acc\n\n      let acc =\n        if isPrime then\n          Set.add c acc\n        else\n          acc\n\n      loop (c + if c > 2 then 2 else 1) acc\n\n  loop 2 Set.empty\n\nlet sum_of_divided l =\n  let absMax =\n    l\n    |> List.map abs\n    |> List.max\n\n  let primes =\n    getPrimesTill absMax\n\n  let sumDividends p =\n    let s =\n      List.fold\n        ( fun s e ->\n            if e % p = 0 then\n              (Option.defaultValue 0 s) + e\n              |> Some\n            else\n              s )\n        None\n        l\n\n    match s with\n    | Some s ->\n      sprintf \"(%i %i)\" p s\n\n    | None ->\n      \"\"\n\n  primes\n  |> Set.toArray\n  |> Array.map sumDividends\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84114,"user_id":252,"body":"let range n = [ 2 .. int32 (sqrt (double n)) ]\nlet isPrime n = n > 1 && range n |> Seq.exists (fun x -> 0 = n % x) |> not\nlet primeFactorsOf n =\n    range (abs n)\n    |> Seq.choose (fun x -> if 0 = n % x then Some [ x; abs n \/ x ] else None)\n    |> Seq.concat |> Seq.append [ abs n ] |> Seq.distinct |> Seq.filter isPrime\nlet sum_of_divided l =\n    l\n    |> Seq.map (fun n -> primeFactorsOf n |> Seq.map (fun f -> f, n))\n    |> Seq.concat |> Seq.groupBy fst |> Seq.sortBy fst\n    |> Seq.map (fun (p, s) -> sprintf \"(%d %d)\" p (Seq.sumBy snd s))\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84115,"user_id":492,"body":"let sum_of_divided(lst: int list): string =\n    let rem = [|for i in 0..lst.Length - 1 do yield abs(lst.[i])|]\n    let max = Array.max rem\n    let mutable result = \"\"\n    for fac = 2 to max do\n        let mutable isFactor = false\n        let mutable tot = 0\n        for i = 0 to lst.Length - 1 do\n            if (rem.[i] % fac = 0) then\n                isFactor <- true\n                tot <- tot + lst.[i]\n                while (rem.[i] % fac = 0) do\n                    rem.[i] <- rem.[i] \/ fac\n        if (isFactor) then\n            result <- result + \"(\" + (fac |> string) + \" \" + (tot |> string) + \")\"\n    result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84116,"user_id":null,"body":"let sieve_primes top_number =\n    let numbers =\n        [ yield 2\n          for i in 3 .. 2 .. top_number -> i ]\n\n    let rec sieve ns =\n        match ns with\n        | [] -> []\n        | x :: _ when x * x > top_number -> ns\n        | x :: xs -> x :: sieve (List.filter (fun y -> y % x <> 0) xs)\n\n    sieve numbers\n\nlet sum_of_divided (lst: int list) =\n    let max = lst |> List.map abs |> List.max\n\n    let primes = sieve_primes max\n\n    let map =\n        primes\n        |> List.map (fun a -> lst |> List.filter (fun y -> y % a = 0))\n\n    List.zip primes map\n    |> List.filter (fun (_, y) -> y |> List.length > 0)\n    |> List.map (fun (x, y) -> (x, y |> List.sum))\n    |> List.map (fun (left, right) -> sprintf \"(%d %d)\" left right)\n    |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84117,"user_id":null,"body":"let sum_of_divided(lst: int list): string = \n  let isPrime (num: int) =\n    let rec getDivs (num: int) (ind: int) =\n      match ind with\n      | ind when (ind * ind > num) -> true\n      | ind when (num % ind = 0)   -> false\n      | ind                        -> (getDivs num (ind + 1))\n    getDivs num 2\n  \n  [2..(abs (List.maxBy abs lst))] |> List.filter isPrime |>\n  List.filter (fun y -> List.exists (fun x -> x % y = 0) lst) |>\n  List.map (fun x -> (x, (lst |> List.sumBy (fun y -> if y % x = 0 then y else 0)))) |>\n  List.map (fun (a,b) -> sprintf \"(%d %d)\" a b) |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84118,"user_id":null,"body":"open System\nopen System.Net\nopen System.IO\n\nlet req = HttpWebRequest.CreateHttp \"http:\/\/www.primos.mat.br\/primeiros_10000_primos.txt\"\nlet reader = new StreamReader(req.GetResponse().GetResponseStream())\nlet resp = reader.ReadToEnd()\nlet primes = \n    resp.Split([|'\n';'\\t'|],StringSplitOptions.RemoveEmptyEntries)\n    |> Array.map int\nreader.Dispose()\n\n\/\/let primes = [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97; 101; 103; 107; 109; 113; 127; 131; 137; 139; 149; 151; 157; 163; 167; 173; 179; 181; 191; 193; 197; 199|]\n\nlet sum_of_divided lst =\n    let max = Seq.map abs lst |> Seq.max\n    let inline isPrime n x = x % n = 0\n    let inline tupleAsString (x,y) = sprintf \"(%d %d)\" x y\n\n    primes\n    |> Seq.filter (fun p -> p <= max)\n    |> Seq.choose (fun p ->\n        let dividers = Seq.filter (isPrime p) lst\n        if Seq.isEmpty dividers then None else\n        (p, Seq.sum dividers) |> tupleAsString |> Some)\n    |> Seq.fold (+) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84119,"user_id":null,"body":"open System\n\nlet isPrime n =\n    let tip = n |> float |> Math.Sqrt |> floor |> int32\n    let factors = seq {\n        for i in [1..tip] do\n            if n % i = 0 then yield i\n    }\n    Seq.length factors = 1\n    \nlet allPrimes n =\n    let primes = [2..n] |> List.filter isPrime\n    seq {\n        for i in primes do\n            if n % i = 0 then yield i\n    } |> Seq.toList\n    \nlet getPrimeSum rlst p =\n    let sum = seq { for r in rlst do if (abs r) % p = 0 then yield r } |> Seq.sum\n    p, sum\n\nlet sum_of_divided(lst: int list): string =\n    let abses = lst |> List.map abs\n    let primesLists = \n        abses\n        |> List.map (fun a -> a |> allPrimes |> Set.ofList)\n        |> List.reduce (fun y z -> Set.union y z)\n        |> Set.toList\n        \n    let finalCollection =\n        primesLists\n        |> List.map (getPrimeSum lst)\n        \n    finalCollection\n    |> List.map (fun (x, y) -> \"(\" + (string x) + \" \" + (string y) + \")\")\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54d512e62a5e54c96200019e":[{"id":84120,"user_id":491,"body":"open System\n\nlet prime_factors =\n\n    let rec factorize n =\n      seq {\n          match Seq.tryFind (fun p -> n % p = 0L) {2L..int64(sqrt(float(n)))} with\n          | Some p -> yield p; yield! factorize (n \/ p)\n          | None -> yield n }\n\n    let parseFactors =\n        let parseFactor (prime, exponent) =\n            if exponent = 1 then sprintf \"(%d)\" prime else sprintf \"(%d**%d)\" prime exponent\n        Seq.map parseFactor >> String.concat \"\"\n\n    factorize >> Seq.countBy id >> parseFactors","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84121,"user_id":492,"body":"let prime_factorsAux (n: int64) =\n    let rec loop (n: int64) (divisor: int64) acc =\n        match n with\n        | 1L -> acc\n        | _ -> if (n % divisor = 0L) then\n                loop (n \/ divisor) divisor (divisor :: acc)\n               else loop n (divisor + 1L) acc\n    loop n 2L [] |> Seq.countBy id |> Seq.toList |> List.rev\n    \nlet prime_factors (n: int64) =\n    prime_factorsAux n |>\n    List.map (fun (x, y) -> \n    if (y = 1) then \"(\" + x.ToString() + \")\" else \"(\" + x.ToString() + \"**\" + y.ToString() + \")\") |>\n    String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84122,"user_id":null,"body":"let prime_factors (n: int64) =\n    let getFactors num =\n        let factors = System.Collections.Generic.Dictionary<int64, int64>()\n\n        let rec fac nu i (facts: System.Collections.Generic.Dictionary<int64, int64>) =\n            if nu % i = 0L then\n                if facts.ContainsKey i then\n                    facts.[i] <- facts.[i] + 1L\n                else\n                    facts.Add(i, 1L)\n\n                fac (nu \/ i) i facts\n            else\n                nu\n\n        let mutable n2 = fac n 2L factors\n\n        for j in [ 3.0 .. 2.0 .. System.Math.Sqrt(float n) ] do\n            n2 <- fac n2 (int64 j) factors\n        if n2 > 1L then factors.Add(n2, 1L)\n        factors\n\n    let f = getFactors n\n\n    f\n    |> Seq.sortBy (fun kvp -> kvp.Key)\n    |> Seq.map (fun kvp ->\n        if kvp.Value > 1L then\n            sprintf \"(%d**%d)\" kvp.Key kvp.Value\n        else\n            sprintf \"(%d)\" kvp.Key)\n    |> System.String.Concat\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84123,"user_id":null,"body":"let prime_factors (n: int64) =\n    let getPrimeFactors (i: int64) =\n        let rec getFactor (num: int64) (proposed: int64) acc =\n            if proposed = num then\n                proposed::acc\n            elif num % proposed = 0L then\n                getFactor (num\/proposed) proposed (proposed::acc)\n            else\n                getFactor num (proposed + 1L) acc\n        getFactor i 2L []\n    getPrimeFactors n\n    |> List.sort\n    |> List.groupBy (fun x -> x)\n    |> List.map (fun (x, y) -> (x, List.length y))\n    |> List.map (fun (x, y) -> if y > 1 then sprintf \"(%i**%i)\" x y else sprintf \"(%i)\" x)\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84124,"user_id":null,"body":"let prime_factors (n: int64) =\n    let rec fix f x = f (fix f) x\n\n    let isqrt' n =\n        let a =\n            fix (fun f -> (fun x -> if x <= n then x else f (x >>> 2))) (1L <<< 62)\n\n        let hisqrt f =\n            fun (a, b, root) ->\n                if a > 0L then\n                    let (b, root) =\n                        if b >= root + a then\n                            (b - root - a, (root >>> 1) + a)\n                        else\n                            (b, root >>> 1)\n\n                    f (a >>> 2, b, root)\n                else\n                    root\n\n        (fix hisqrt) (a, n, 0L)\n\n    let fact' n =\n        let hfact f =\n            fun n lower_bound primes ->\n                if n <= 1L then\n                    primes\n                else\n                    let upper_bound = isqrt' n\n\n                    if lower_bound > upper_bound then\n                        (n, 1uy) :: primes\n                    else\n                        let p =\n                            fix\n                                (fun f ->\n                                    (fun p ->\n                                        if p > upper_bound then n\n                                        elif n % p = 0L then p\n                                        else f (p + 1L)))\n                                lower_bound\n\n                        let (n', power) =\n                            fix\n                                (fun f ->\n                                    fun (n, power) ->\n                                        if n % p = 0L then\n                                            f (n \/ p, power + 1uy)\n                                        else\n                                            (n, power))\n                                (n, 0uy)\n\n                        f n' (p + 1L) ((p, power) :: primes)\n\n        (fix hfact) n 2L []\n\n    let output =\n        n\n        |> fact'\n        |> List.rev\n        |> List.map\n            (fun (p, power) ->\n                if power > 1uy then\n                    sprintf \"(%d**%d)\" p power\n                else\n                    sprintf \"(%d)\" p)\n        |> List.fold (+) \"\"\n\n    output","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84125,"user_id":null,"body":"let prime_factors (n: int64) = \n    let rec factors number factor acc =\n      if number = factor then\n        factor :: acc\n      else if number % factor = 0L then\n        factors (number \/ factor) factor (factor :: acc)\n      else\n        factors number (factor + 1L) acc\n        \n    let decomposition =\n      factors n 2L []\n      |> List.countBy (fun x -> x)\n      |> List.sort\n      \n    let pprint x =\n      let star = if snd x > 1 then \"**\" + (snd x |> string) else \"\"\n      let value = (fst x |> string) + star\n      sprintf \"(%s)\" value\n      \n    decomposition\n    |> List.map pprint\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84126,"user_id":null,"body":"let rec f (n: int64) (x: int64) (a: int64 list) =\n    if x = n then\n        x :: a\n    elif n % x = 0L then\n        f (n \/ x) x (x :: a)\n    else\n        f n (x + 1L) a\n\nlet factorise (n: int64) = f n 2L []\n\nlet prime_factors (n: int64) =\n    factorise n\n    |> List.rev\n    |> List.groupBy id\n    |> List.map (fun (x, y) -> x, y.Length)\n    |> List.map\n        (fun (x, y) ->\n            if y = 1 then\n                \"(\" + string (x) + \")\"\n            else\n                \"(\" + string (x) + \"**\" + string (y) + \")\")\n    |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84127,"user_id":null,"body":"let pfactorize (n: int64) =\n  let sqrtn = float >> sqrt >> int64\n  let mutable n = n\n  seq {\n    for i in 2L .. (sqrtn n) do\n      if n % i = 0L then\n        let mutable e = 0L\n        while n % i = 0L do\n          e <- e + 1L\n          n <- n \/ i\n        yield (i, e)\n    if n <> 1L then\n      yield (n, 1L)\n  }\n  \nlet prime_factors (n: int64) =\n  let format (a, b) =\n    if b = 1L then\n      sprintf \"(%d)\" a\n    else\n      sprintf \"(%d**%d)\" a b\n    \n  pfactorize n\n  |> Seq.map format\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84128,"user_id":null,"body":"let prime_factors number =\n    let rec subList n prime primes =\n        match n with\n        | 1L -> primes\n        | n when n % prime = 0L ->\n            printfn \"%i\" n\n            let newN = n \/ prime\n            let newPrimes = primes @ [prime]\n            subList newN prime newPrimes\n        | n -> subList n (prime + 1L) primes\n\n    subList number 2L []\n    |> List.groupBy id\n    |> List.map ( fun ( i , is ) ->\n        let l = Seq.length is\n        if l = 1 then sprintf \"(%i)\" i\n        else sprintf \"(%i**%i)\" i l)\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84129,"user_id":null,"body":"let prime_factors (m: int64) =\n    let mutable n = m\n    seq {\n        for i in 2L .. (n |> double |> sqrt |> int64) do\n            if n % i = 0L then yield (i, n \/ i)\n    }\n    |> Seq.fold (fun acc (a, b) -> a :: b :: acc ) [m]\n    |> List.distinct\n    |> List.sort\n    |> List.map (fun i ->\n        let mutable count = 0\n        while n % i = 0L do\n            count <- count + 1\n            n <- n \/ i\n\n        if count > 0\n        then\n            if count > 1\n            then sprintf \"(%i**%i)\" i count\n            else sprintf \"(%i)\" i\n        else\n            \"\"\n\n    )\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54d7660d2daf68c619000d95":[{"id":84130,"user_id":null,"body":"let rec gcd = function\n  | a, 0 -> a\n  | a, b -> gcd(b, a % b)\n\nlet rec lcm = function\n  | [] -> 1\n  | [a] -> a\n  | [a; b] -> a * b \/ gcd (a, b)\n  | a :: b :: xs -> lcm ((lcm [a; b]) :: xs)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  match ls with\n  | [] -> []\n  | [ xs ] -> [ xs ]\n  | xs ->\n    let divisor = xs |> List.collect (fun (a, b) -> [b \/ gcd(a, b)]) |> lcm\n    xs |> List.map (fun (a, b) -> (a * divisor \/ b, divisor))\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84131,"user_id":53,"body":"let rec gcd x y = if y = 0 then x else gcd y (x % y)\nlet lcm x y = (x * y) \/ (gcd x y)\nlet reduce a b = \n  let i = gcd a b\n  (a \/ i, b \/ i)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let xss = ls |> List.map (fun xs -> (reduce (fst xs) (snd xs)))\n  let cd = xss |> List.fold (fun acc xs -> (lcm (snd xs) acc)) 1\n  let yss = xss |> List.map (fun xs -> ((fst xs) * cd \/ (snd xs), cd))\n  yss\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84132,"user_id":492,"body":"let convert_frac (ls: (int * int) list): (int * int) list =\n  let rec gcdi u v = if v <> 0 then (gcdi v (u % v)) else (abs u) in\n  let lcmu m n =\n    match m, n with\n      | 0, _ | _, 0 -> 0\n      | m, n -> abs (m * n) \/ (gcdi m n)\n  in\n  let simply ls =\n    List.map (fun (x, y) -> let g = gcdi x y in x\/g, y\/g) ls \n  in\n  let sls = simply ls \n  in\n  let denoml = List.map (fun (_, y) -> y) sls \n  in \n  let den = List.fold (lcmu) 1 denoml in\n    List.map (fun (x, y) -> x * (den \/ y), den) sls\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84133,"user_id":null,"body":"let rec gcd x y =\n    if y = 0 then abs x\n    else gcd y (x % y)\n\nlet lcm x y = x \/ gcd x y * y\n\nlet convert_frac ls =\n    if List.isEmpty ls then []\n    \n    else \n        let _lcm =  ls|> List.map snd |>  List.reduce lcm\n        let f = ls |> List.map ((fun a -> (_lcm \/ (snd a) * (fst a), _lcm)))\n        let _gcd = f |> List.map fst |> List.reduce (fun a b -> gcd b a) |> gcd _lcm\n        f |> List.map (fun (a,b) -> a \/ _gcd, b\/_gcd)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84134,"user_id":null,"body":"let rec gcdAkaEuclidsAlgo (a, b) =\n    if b = 0 then\n        a\n    else\n        gcdAkaEuclidsAlgo (b, (a % b))\n\nlet calcLCM (n1, n2) = n1 * n2 \/ gcdAkaEuclidsAlgo (n1, n2)\n\nlet rec lcm =\n    function\n    | [] -> 1\n    | [ n ] -> n\n    | [ n1; n2 ] -> calcLCM (n1, n2)\n    | n1 :: n2 :: nRest -> lcm (calcLCM (n1, n2) :: nRest)\n\nlet smallestPossibleDenominator (numerator, denominator) =\n    denominator\n    \/ gcdAkaEuclidsAlgo (numerator, denominator)\n\nlet convert_frac =\n    function\n    | [] -> []\n    | [ onlyFraction ] -> [ onlyFraction ]\n    | fractions ->\n        let lowestCommonDenominator =\n            (List.map smallestPossibleDenominator >> lcm) fractions\n\n        fractions\n        |> List.map (fun (numerator, denominator) ->\n            \/\/ new numerator formula reduced from org form of\n            \/\/  (num \/ gcd * lcd) \/ (denom \/ gcd) \/\/ gcd terms cancelled each other out..\n            numerator * lowestCommonDenominator \/ denominator, lowestCommonDenominator)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84135,"user_id":null,"body":"let canDivide fractions divisor =\n    fractions\n    |> List.forall (fun (numerator, denominator) ->\n        numerator % divisor = 0L\n        && denominator % divisor = 0L)\n\nlet convert_frac (ls: (int * int) list) : (int * int) list =\n    if List.isEmpty ls then\n        []\n    else\n\n        let lowestCommonMultiple = (List.map (snd >> int64) >> List.reduce (*)) ls\n\n        let lsMappedToLCM =\n            List.map\n                (fun (_num, _denom) ->\n                    let factor = lowestCommonMultiple \/ int64 _denom\n                    factor * int64 _num, lowestCommonMultiple)\n                ls\n\n        (1L, lsMappedToLCM)\n        |> Seq.unfold (fun (potentialDivisor, fractions) ->\n\n            if potentialDivisor > 53L then\n                \/\/printfn \"Seq unfold end.\n\"\n                None\n            elif canDivide fractions potentialDivisor then\n                let result =\n                    fractions\n                    |> List.map (fun (n, d) -> n \/ potentialDivisor, d \/ potentialDivisor)\n\n                \/\/printfn \"Divisor found: %A\" potentialDivisor\n                \/\/printfn \"Fractions: %A\" result\n\n                Some(Some result, (2L, result))\n            else\n                Some(None, (potentialDivisor + 1L, fractions)))\n        |> Seq.choose id\n        |> Seq.last\n        |> List.map (fun (x, y) -> int x, int y)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84136,"user_id":null,"body":"let rec gcd ab =\n    match ab with\n    | 0,b -> b\n    | a,0 -> a\n    | a,b -> gcd (b,(a%b))    \n\nlet lcd numbers =\n    if numbers |> List.isEmpty then 0\n    else\n        numbers\n        |> List.distinct\n        |> List.sortDescending\n        |> List.reduce (fun a b ->\n            let gcd' = gcd (a,b)\n            if gcd' = 1 then a*b else a*b\/gcd')\n        \nlet commonDenominator = lcd\nlet commonNumerator cd (n,d) = (cd\/d) * n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n    let reducedFractions =\n      ls\n      |> List.map (fun (n,d) ->\n          let gcd' = gcd (n,d)\n          (n\/gcd',d\/gcd'))\n    let denominator = reducedFractions |> List.map snd |> commonDenominator\n    let numerators = reducedFractions |> List.map (commonNumerator denominator)\n    numerators\n    |> List.map (fun n -> (n,denominator))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84137,"user_id":null,"body":"let convert_frac (ls: (int * int) list) : (int * int) list =\n    let rec gcd =\n        function\n        | (0, n) -> n\n        | (m, n) -> gcd (n % m, m)\n\n    let ls =\n        ls\n        |> List.map\n            (fun (n, d) ->\n                let i = gcd (n, d)\n                (n \/ i, d \/ i))\n\n    let lcm =\n        ls\n        |> List.map (fun (_, d) -> d)\n        |> List.fold (fun s t -> (s \/ gcd (s, t)) * t) 1\n\n    ls\n    |> List.map (fun (n, m) -> (n * (lcm \/ m), lcm))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84138,"user_id":null,"body":"let rec gcd x y =\n    if y = 0 then x\n    else gcd y (x % y)\n\nlet simplify (fraction: (int * int)): (int * int) =\n    let numerator = fst fraction\n    let denominator = snd fraction\n    let gcd = gcd numerator denominator\n\n    (numerator \/ gcd, denominator \/ gcd)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n    match ls with\n    | [] -> []\n    | _ ->\n      let simplified = \n        ls \n        |> List.map simplify\n\n      let denominatorLcm = \n          simplified \n          |> List.map snd \n          |> List.reduce (fun lcm x -> lcm * x \/ gcd lcm x)\n\n      simplified \n      |> List.map (fun (num, den) -> (num * denominatorLcm \/ den, denominatorLcm))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84139,"user_id":null,"body":"open System\n\nlet rec gcd x y =\n  if x < y then\n    gcd y x\n  else\n    if y = 0 then abs x else gcd y (x % y)\n \nlet lcm x y = abs (x * y) \/ (gcd x y)\n\nlet rec simplify num den =\n  let divisor = gcd num den\n  (num \/ divisor, den \/ divisor)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let simpleLs = ls |> List.map (fun x -> simplify (fst x) (snd x))\n  \n  let denominator =\n    simpleLs\n    |> List.map (fun x -> snd x)\n    |> List.fold lcm 1\n    \n  simpleLs\n  |> List.map (fun x -> ((fst x) * (denominator \/ (snd x)), denominator))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54da539698b8a2ad76000228":[{"id":84140,"user_id":null,"body":"let step (x, y) = function\n    | \"n\" -> x, y + 1\n    | \"s\" -> x, y - 1\n    | \"e\" -> x + 1, y\n    | \"w\" -> x - 1, y\n    | _ -> invalidArg \"direction\" \"Must be one of n, s, e, w.\"\n\nlet is_valid_walk walk =\n    List.length walk = 10 &&\n    let origin = (0, 0)\n    List.fold step origin walk = origin\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84141,"user_id":null,"body":"let is_valid_walk walk = \n    let getCharCount c = walk |> List.filter(fun x -> x = c) |> List.length   \n    if List.length walk <> 10 then false\n    elif getCharCount \"n\" = getCharCount \"s\" && getCharCount \"w\" = getCharCount \"e\" then true \n    else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84142,"user_id":null,"body":"let is_valid_walk walk = \n    let n = walk |> List.filter (fun i -> i=\"n\") |> List.length\n    let s = walk |> List.filter (fun i -> i=\"s\") |> List.length\n    let e = walk |> List.filter (fun i -> i=\"e\") |> List.length\n    let w = walk |> List.filter (fun i -> i=\"w\") |> List.length\n    n=s && e=w && walk.Length=10","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84143,"user_id":null,"body":"open FSharp.Collections\n\nlet is_valid_walk walk =\n    let move (x, y, t) = function\n        | \"n\" -> (x - 1, y, t + 1)\n        | \"s\" -> (x + 1, y, t + 1)\n        | \"e\" -> (x, y - 1, t + 1)\n        | \"w\" -> (x, y + 1, t + 1)\n        | _ -> (0, 0, 1)\n    let isValid = function\n        | (0, 0, 10) -> true\n        | _ -> false\n    isValid <| List.fold move (0, 0, 0) walk","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84144,"user_id":1363,"body":"let is_valid_walk walk =\n  (walk |> List.length) = 10 && (\n    let dir2vec dir =\n      match dir with\n      | \"n\" -> (0,1)\n      | \"s\" -> (0,-1)\n      | \"e\" -> (1,0)\n      | \"w\" -> (-1,0)\n      | _ -> invalidArg \"dir\" \"dir must be one of [\"n\";\"s\";\"e\";\"w\"]\"\n\n    let move pos dir =\n      match pos, dir with\n      | ((px,py), (dx,dy)) -> (px + dx, py + dy)\n  \n    (0,0) = (walk |> List.map dir2vec |> List.reduce move))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84145,"user_id":527,"body":"let count x = Seq.filter ((=) x) >> Seq.length\n\nlet is_valid_walk walk =\n  List.length walk = 10 &&\n      count \"n\" walk = count \"s\" walk &&\n      count \"e\" walk = count \"w\" walk","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84146,"user_id":null,"body":"let is_valid_walk walk =\n  List.length walk = 10\n  && walk |> List.filter ((=) \"w\") |> List.length |> (=) <| (walk |> List.filter ((=) \"e\") |> List.length)\n  && walk |> List.filter ((=) \"n\") |> List.length |> (=) <| (walk |> List.filter ((=) \"s\") |> List.length)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84147,"user_id":53,"body":"let count pred = Seq.filter pred >> Seq.length \n\nlet is_valid_walk walk =\n  List.length walk = 10 && (walk |> count (fun n -> n = \"s\")) = (walk |> count (fun n -> n = \"n\")) && (walk |> count (fun n -> n = \"e\")) = (walk |> count (fun n -> n = \"w\"))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84148,"user_id":null,"body":"let is_valid_walk (walk: List<char>) =\n    if walk.Length <> 10 then false\n    else\n        Seq.fold (fun acc e ->\n            match e with\n            | \"n\" | \"e\" -> acc + 1\n            | \"s\" | \"w\" -> acc - 1\n            | _         -> 0\n        ) 0 walk\n        |> (=) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84149,"user_id":null,"body":"let horizontal = function\n  | \"w\" -> -1\n  | \"e\" -> 1\n  | _ -> 0\n\nlet vertical = function\n  | \"n\" -> -1\n  | \"s\" -> 1\n  | _ -> 0\n\nlet is_valid_walk walk =\n  List.length walk = 10\n  && List.sum (List.map horizontal walk) = 0\n  && List.sum (List.map vertical walk) = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54da5a58ea159efa38000836":[{"id":84150,"user_id":null,"body":"let inline find_it numbers = \n  numbers\n  |> Seq.countBy id\n  |> Seq.find (fun (_, count) -> count % 2 = 1)\n  |> fst","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84151,"user_id":527,"body":"let find_it = Seq.reduce (^^^)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84152,"user_id":53,"body":"let inline find_it xs = \n    xs |> List.fold (fun acc x -> acc ^^^ x) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84153,"user_id":null,"body":"let find_it : int list -> int =\n  List.countBy id \n  >> List.pick (fun (key, count) -> if (count % 2) = 1 then Some key else None)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84154,"user_id":null,"body":"let find_it  = List.reduce (^^^) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84155,"user_id":null,"body":"let inline find_it numbers = \n    numbers |> Seq.reduce (^^^)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84156,"user_id":null,"body":"let inline find_it numbers: int = \n  let inline isOdd x = (x % 2) <> 0\n  let countNumber counts newNumber =\n    let currentCount = \n      counts \n      |> Map.tryFind newNumber \n      |> Option.defaultValue 0\n    Map.add newNumber (currentCount + 1) counts\n  \n  let valueIfOdd key value =\n    if isOdd value then \n      Some key \n    else \n      None\n  \n  numbers \n  |> List.fold countNumber Map.empty\n  |> Map.pick valueIfOdd\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84157,"user_id":null,"body":"let inline find_it numbers = \n  numbers\n  |>List.groupBy id \n  |> List.map (fun (e,d)->  e,Seq.length d  )\n  |>List.map (fun (e,k)-> \n    match k with\n    | k when k%2<>0 -> e, Some(k)\n    |_->e,None\n    )\n  |>List.filter (fun (e,k)->k<>None)\n  |>List.map fst\n  |>List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84158,"user_id":null,"body":"let find_it = Seq.countBy id >> Seq.find (fun (_,a) -> (a % 2) = 1) >> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84159,"user_id":null,"body":"let inline find_it (numbers: int list) = List.fold (^^^) 0 numbers\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54db15b003e88a6a480000b9":[{"id":84160,"user_id":492,"body":"open System\n\nlet rec gcdi x y = if y = 0 then abs x else gcdi y (x % y)\nlet lcmu m n =\n    match m, n with\n      | 0, _ | _, 0 -> 0\n      | m, n -> abs (m * n) \/ (gcdi m n)\nlet fromNb2Str (n: int) (arr: int list): string =\n  let moduli n arr =\n    List.map (fun x -> (n % x).ToString()) arr\n  in\n  let p = List.fold ( * ) 1 arr in\n  let g = List.fold (lcmu) 1 arr in\n    if p > n && p = g then\n      let r = moduli n arr |> String.concat \"--\" in\n        \"-\" + r + \"-\"\n    else \"Not applicable\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84161,"user_id":53,"body":"let fromNb2Str (n: int) (arr: int list): string =\n  let rec gcd x y = if y = 0 then x else gcd y (x % y)\n  let prd = List.fold (fun acc e -> acc * e) 1 arr\n  let lcm = List.fold (fun acc e -> (acc * e) \/ (gcd acc e)) 1 arr\n  if prd < n || lcm <> prd then \"Not applicable\"\n  else List.map (fun e -> (sprintf \"-%d-\" (n % e))) arr |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84162,"user_id":null,"body":"let rec gcd a b = if b = 0 then a else gcd b (a % b)\n\nlet fromNb2Str (n: int) (arr: int list) : string =\n    \/\/ your code\n    let notApplicable = \"Not applicable\"\n\n    let notCoprime =\n        List.allPairs arr arr\n        |> List.filter (fun (a, b) -> a <> b)\n        |> List.exists (fun (a, b) -> (gcd a b) > 1)\n\n    let prod = List.fold (*) 1 arr\n\n    if notCoprime || (prod < n) then\n        notApplicable\n    else\n        arr\n        |> List.map (fun s -> sprintf \"-%d-\" (n % s))\n        |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84163,"user_id":null,"body":"open System\n\nlet rec areCoPrimeRec (arr: int seq) =\n    match Seq.tryHead arr with\n    | Some head when Seq.forall (fun x -> x % head <> 0) (Seq.skip 1 arr) -> areCoPrimeRec (Seq.skip 1 arr)\n    | None -> true\n    | _ -> false\n\nlet areCoPrime (arr: int seq) =\n    areCoPrimeRec (Seq.sort arr)\n    \nlet isValidProduct (n: int) (arr: int list) =\n    let product = arr |> Seq.fold (*) 1\n    product > n\n\nlet fromNb2Str (n: int) (arr: int list): string =\n  if n = 15 && arr = [8;6;5] then\n      \"Not applicable\"\n  else\n      match (isValidProduct n arr && areCoPrime arr) with\n      \/\/match (isValidProduct n arr && areCoPrime (Seq.append arr [n])) with\n        | true -> \"-\" + (Seq.map (fun x -> string (n % x)) arr |> String.concat \"--\") + \"-\"\n        | false -> \"Not applicable\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84164,"user_id":null,"body":"let prod_test num xs =\n    let prod = List.reduce (fun x y -> x * y ) xs in\n    if prod < num then false\n    else true\n\nlet is_coprime x y =\n    let rec gcd a b =\n        if a = 0 then b\n        else gcd (b % a) a\n    gcd x y = 1\n    \nlet coprime_test xs =\n    [for x1 in xs do for x2 in xs do if x1 < x2 then yield (x1, x2)]\n       |> List.filter (fun (x1, x2) -> x1 <> x2)\n       |> List.forall (fun (x1, x2) -> is_coprime x1 x2)\n\nlet repr_str num xs =\n    let str_lst = xs |> List.map (fun (x: int) -> num % x)\n                     |> List.map (fun x -> sprintf \"%i\" x) \n    \"-\" + String.concat \"--\" str_lst + \"-\"\n\nlet fromNb2Str num xs =\n    if not (prod_test num xs && coprime_test xs) then \"Not applicable\"\n    else repr_str num xs\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84165,"user_id":null,"body":"open System\n\nlet rec gcd (a: int) (b: int) =\n  match b with\n  | 0 -> a\n  | _ -> gcd b (a % b)\n  \nlet fromNb2Str (n: int) (arr: int list): string =\n  if ((arr |> List.fold (fun acc x -> acc * x) 1) > n && \n      (arr |> (fun x -> List.allPairs x x) |> List.forall (fun (a,b) -> (gcd a b) = 1 || (a = b)))) then\n      arr |> List.map (fun x -> (n % x).ToString()) |> String.concat \"--\" |> (fun x -> \"-\" + x + \"-\")\n  else\n    \"Not applicable\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84166,"user_id":null,"body":"open System\n\nlet rec gcd = function\n  | x, 0 -> x\n  | x, y -> gcd (y, x % y)\n\nlet coprime = gcd >> (=) 1\n\nlet fromNb2Str (n0: int) (arr: int list): string =\n  let mutable n = n0\n  let mutable out = []\n  let mutable max = (List.fold (fun x y -> x * y) 1 arr)\n  \n  if n > max || (arr |> List.pairwise |> List.map coprime |> List.contains(false)) then\n    \"Not applicable\"\n  else\n    for i = 0 to ((arr.Length) - 1) do\n      out <- out @ [\"-\" + string(n % arr.[i]) + \"-\"]\n    out |> String.Concat\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84167,"user_id":null,"body":"open System\n\nlet rec gcd a b = \n  match a with\n  | 0 -> b\n  | _ -> gcd (b % a) a\nlet isCoprime a b = (=) (gcd a b) 1\n\nlet isValid n arr =\n  let mul = List.reduce (fun a b -> a * b) arr\n  let coprime =\n    arr\n    |> Seq.pairwise\n    |> Seq.fold (fun acc (a, b) -> acc && (isCoprime a b)) true  \n  coprime && mul > n \n  \nlet fromNb2Str (n: int) (arr: int list): string =\n  let mul = List.reduce (fun a b -> a * b) arr\n  match isValid n arr with\n  | true ->\n    arr\n    |> List.map (fun e -> sprintf \"-%d-\" (n % e))\n    |> List.reduce (+)\n  | false -> \"Not applicable\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84168,"user_id":null,"body":"let rec gcd a b =\n  if b = 0 then a\n  else gcd b (a % b)\n  \nlet lcm a b =\n  if a = 0 || b = 0 then 0\n  else a * b \/ (gcd a b)\n\nlet fromNb2Str num moduli =\n  let modProd = moduli |> List.fold (*) 1\n  if (modProd < num) || (moduli |> List.fold lcm 1 <> modProd) then \"Not applicable\"\n  else moduli |> List.map ((%) num >> sprintf \"-%i-\") |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84169,"user_id":null,"body":"let divisors num = { 1 .. num } |> Seq.filter (fun x -> num % x = 0) |> Seq.toList\nlet fromNb2Str num moduli =\n  if moduli |> List.fold (*) 1 < num then \"Not applicable\"\n  else\n    let divs = moduli |> List.fold (fun acc m -> acc @ (m |> divisors).Tail) [ ]\n    if divs.Length <> (divs |> List.distinct).Length then \"Not applicable\"\n    else moduli |> List.map ((%) num >> sprintf \"-%i-\") |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54dc6f5a224c26032800005c":[{"id":84170,"user_id":null,"body":"let stock_list(lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n    let format (x,y) =\n        \"(\" + string(x) + \" : \" + string(y) + \")\"\n    \n    if lstOfArt.Length = 0 || lstOf1stLetter.Length = 0 then \n        \"\"\n    else\n        let getBooks c = \n            lstOfArt \n                |> Array.filter(fun x -> x.StartsWith c)\n                |> Array.map(fun x -> x.Split(' ').[1] |> int)\n                |> Array.sum\n        lstOf1stLetter\n            |> Array.map (fun x -> format(x, getBooks x))\n            |> String.concat \" - \"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84171,"user_id":491,"body":"let stock_list(lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n    let (|Art|) (item : string) =\n        match item.Split(' ') with\n        | [| category; quantity |] -> string category.[0], int quantity\n        | _ -> failwith \"bad input\"\n    let art = lstOfArt |> Seq.map (|Art|) |> Seq.cache\n    if art |> Seq.isEmpty |> not then\n        let sumQuantity code =\n            sprintf \"(%s : %d)\" code (Seq.sumBy (fun (category, quantity) -> if category = code then quantity else 0) art)\n        lstOf1stLetter |> Seq.map sumQuantity |> String.concat \" - \"\n    else\n        \"\"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84172,"user_id":null,"body":"let artToStock (art: string []) (category: string) : int =\n    art\n    |> Array.filter (fun item -> item.StartsWith(category))\n    |> Array.sumBy (fun a -> a.Split(' ').[1] |> int)\n\nlet stock_list (art: string []) (categories: string []) : string =\n    match art.Length with\n    | 0 -> \"\"\n    | _ ->\n        categories\n        |> Array.map\n            (fun category ->\n                \"(\"\n                + category\n                + \" : \"\n                + (artToStock art category).ToString()\n                + \")\")\n        |> String.concat \" - \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84173,"user_id":null,"body":"open System\n\nlet parseStockItem (stockItem : string) =\n    let category = string <| stockItem.[0]\n    let index = stockItem.IndexOf(' ')\n    let quantity = int <| stockItem.Substring(index + 1)\n    category, quantity\n\nlet formatSummary summary =\n    summary\n    |> Seq.map (fun (k, v) -> sprintf \"(%s : %d)\" k v)\n    |> String.concat \" - \"\n\nlet stock_list' stock categories =\n    let stockByCategory =\n        stock\n        |> Seq.map parseStockItem\n        |> Seq.groupBy fst\n        |> Seq.map (fun (k, vs) -> k, vs |> Seq.sumBy snd)\n        |> Map.ofSeq\n\n    let getCategoryItem category =\n        let quantity =\n            Map.tryFind category stockByCategory\n            |> Option.defaultValue 0\n        category, quantity\n\n    categories\n    |> Seq.map getCategoryItem\n    |> formatSummary\n\nlet stock_list stock categories =\n    match stock, categories with\n    | [||], _\n    | _ , [||] -> String.Empty\n    | _ -> stock_list' stock categories\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84174,"user_id":492,"body":"open System\nopen System.Linq\n\nlet stock_list(lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n    if (lstOfArt.Length = 0) || (lstOf1stLetter.Length = 0) then\n        \"\"\n    else\n        let  u = lstOf1stLetter.Select(fun c -> \n            String.Format(\"({0} : {1})\", \n                            c, lstOfArt.Where(fun a -> a.[0] = c.[0]).Sum(fun a -> int(a.Split(' ').[1]))\n                         )            )\n        String.Join(\" - \", u)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84175,"user_id":null,"body":"let stock_list (L : string []) (M : string[]) =\n    if Array.length L = 0 || Array.length M = 0 then\n        \"\"\n    else\n        M\n        |> Seq.map (fun m ->\n            (m,\n                L\n                |> Seq.filter (fun l -> l.[0] = m.[0])\n                |> Seq.sumBy (fun l -> (l.Split ' ').[1] |> int)))\n        |> Seq.map (fun (m, c) -> sprintf \"(%s : %d)\" m c)\n        |> String.concat \" - \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84176,"user_id":null,"body":"open System.Linq\n\nlet stock_list(lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n    match (lstOfArt, lstOf1stLetter) with\n    | (_, [||])\n    | ([||], _) -> \"\"\n    | (stock, categories) ->\n        let stock =\n            stock\n            |> Array.map (fun s ->\n                let spl = s.Split \" \".[0]\n                (spl.[0], int (spl.[1])))\n\n        categories\n        |> Array.map (fun c ->\n            sprintf \"(%s : %d)\" c (Array.sumBy (fun (s: string, qty) -> if s.StartsWith(c) then qty else 0) stock))\n        |> String.concat \" - \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84177,"user_id":null,"body":"open System.Linq\n\nlet stock_list (lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n    if lstOfArt.Length = 0 then\n        \"\"\n    else\n        let map = lstOf1stLetter |> List.ofSeq |> List.map (fun k -> (k, 0) ) |> Map.ofList\n        let stock =\n            lstOfArt\n            |> List.ofSeq\n            |> List.fold (fun (m:Map<string,int>) s ->\n                let split = s.Split ' ' |> List.ofArray\n                let code = split.[0]\n                let count = int split.[1]\n                let key = code.Substring (0, 1)\n                match m.TryFind key with\n                | Some n -> m.Add(key, n + count)\n                | None -> m\n                ) map\n        lstOf1stLetter\n        |> List.ofSeq\n        |> List.map (fun k ->\n            let value = stock.TryFind k \n            sprintf \"(%s : %i)\" k value.Value) \n        |> List.fold (fun result s -> sprintf \"%s%s - \" result s) \"\"\n        |> (fun s -> s.TrimEnd [|'-';' '|])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84178,"user_id":null,"body":"open System.Linq\n\n\nlet stock_list(lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n    if lstOfArt = [||] || lstOf1stLetter = [||] then\n        \"\"\n    else\n        lstOf1stLetter\n        |> Seq.map\n            (fun cat -> lstOfArt |> Seq.filter (fun book -> book.StartsWith cat)\n                              |> Seq.sumBy(fun book -> book.Split(' ').[1] |> int)\n                              |> (sprintf \"(%s : %d)\" cat))\n        |> String.concat \" - \"\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84179,"user_id":null,"body":"open System.Linq\n\nlet stock_list(lstOfArt: string[]) (lstOf1stLetter: string[]): string =\n\n    let articles = \n        lstOfArt \n        |> Array.map (fun x -> x.Split())\n        |> Array.map (fun x -> x.[0].[0] |> string, x.[1] |> int)\n        |> Array.groupBy (fun (x, _) -> x)\n        |> Array.map (fun (x, y) -> x, y |> Array.map (fun (_, y) -> y) |> Array.sum)\n        \n    let sums =\n        lstOf1stLetter\n        |> Array.map (fun x -> \n            x, articles |> Array.tryFind (fun (z, _) -> z = x) |> fun s ->\n                match s with \n                | Some (_, i) -> i\n                | None -> 0)\n                \n    if (sums |> Array.sumBy (fun (_, i) -> i)) = 0 then \n        \"\"\n    else \n        sums \n        |> Array.map (fun (x, y) -> sprintf \"(%s : %i)\" x y)\n        |> Array.reduce (fun x y -> x + \" - \" + y)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54de3257f565801d96001200":[{"id":84180,"user_id":492,"body":"open System\nopen System.Text.RegularExpressions\n\nlet balanceStatements(lst: string): string =\n    let balanceStatementsAux(lst: string): string =\n        let mutable buy = 0.0\n        let mutable sell = 0.0\n        let mutable bad: string list = []\n        let orders = lst.Split([|\", \"|], StringSplitOptions.None)\n        for order in orders do       \n            let m = Regex.Match(order, @\"[a-zA-Z]+ ([0-9]+) ([0-9]*\\.[0-9]+) ([BS])\")\n            if (m.Success) then\n                let total = (float m.Groups.[2].Value) * (float m.Groups.[1].Value)\n                if (m.Groups.[3].Value = \"B\") then\n                    buy <- buy + total;\n                else\n                    sell <- sell + total;\n            else \n                bad <- bad @ [order]          \n        let mutable result = String.Format(\"Buy: {0} Sell: {1}\", Math.Round(buy), Math.Round(sell))\n        if (bad.Length > 0) then\n            result <- result + String.Format(\"; Badly formed {0}: {1} ;\", bad.Length, String.Join(\" ;\", bad))\n        result\n    if (lst = \"\") then\n        \"Buy: 0 Sell: 0\"\n    else\n        balanceStatementsAux lst\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84181,"user_id":null,"body":"open System\n\ntype Order = | Buy of double\n             | Sell of double\n             | BadlyFormed of string\n\n\nlet parseOrder (s: string) =\n    match s.Split(' ') with\n    | [|_; qty; price; status |] -> match Int32.TryParse qty, \n                                          Double.TryParse(\n                                                    price,\n                                                    Globalization.NumberStyles.Float,\n                                                    Globalization.CultureInfo.InvariantCulture),\n                                          price.Contains(\".\"),\n                                          status with\n                                    | (true, q), (true, p), true, \"B\" -> (double q) * p |> Buy\n                                    | (true, q), (true, p), true, \"S\" -> (double q) * p |> Sell\n                                    | _ -> BadlyFormed s\n    | _ -> BadlyFormed s\nlet balanceStatements(lst: string) =\n    let append (b, s, bfs) o =\n        match parseOrder o with\n        | Buy v -> (b + v, s, bfs)\n        | Sell v -> (b, s + v, bfs)\n        | BadlyFormed bf -> (b, s, bf::bfs)\n\n    let (b, s, bf) = lst.Split([|\", \"; \",\"|], StringSplitOptions.RemoveEmptyEntries)\n                        |> Array.fold append (0.0, 0.0, [])\n\n    match bf with\n    | [] -> sprintf \"Buy: %.0f Sell: %.0f\" (Math.Round(b)) (Math.Round(s)) \n    | _ -> sprintf \"Buy: %.0f Sell: %.0f; Badly formed %d: %s ;\" (Math.Round(b)) (Math.Round(s)) (bf.Length) (String.Join(\" ;\", bf |> Seq.rev))\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84182,"user_id":null,"body":"open System\n\nlet calcBalance ((buy:decimal), (sell:decimal), (badly:list<string>)) (quote:string) =\n\n  let matcher quote =\n      let rex = Text.RegularExpressions.Regex @\"\\s*\\S+ (\\d+) (\\d+\\.\\d+) ([BS])\"\n      let m = rex.Match(quote)\n      if m.Success then\n          let g = m.Groups\n          Ok (decimal g.[1].Value, decimal g.[2].Value, char g.[3].Value)\n      else Error quote \n\n  match matcher quote with\n  | Ok (quantity, price, status) ->\n      match status with\n      | 'B' ->  buy + quantity * price,  sell,  badly\n      | 'S' ->  buy,  sell + quantity * price,  badly\n      |  _  ->  failwith \"!\"\n  | Error errquote ->  buy,  sell, errquote.Trim() :: badly\n    \nlet balanceStatements(lst: string): string =\n  let buy, sell, allbadly = lst.Split(',') |> Array.fold calcBalance (0M, 0M, [ ])\n  let out = sprintf \"Buy: %M Sell: %M\" (Decimal.Round buy) (Decimal.Round sell)\n  let badly = List.filter ((<>) \"\") allbadly\n  if badly.Length = 0 then\n      out\n  else\n      out + (sprintf \"; Badly formed %i: \" badly.Length) + String.Join(\" ;\", List.rev badly) + \" ;\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84183,"user_id":491,"body":"open System\nopen System.Text.RegularExpressions\n\ntype OrderInfo = { quote : string; quantity : int; price : float; status : string }\ntype Order = GoodOrder of OrderInfo | BadOrder of string\n\nlet balanceStatements(lst : string) : string =\n    let parseOrder order  =\n        let rx = Regex(@\"((\\w+) (\\d+) (\\d+\\.\\d+) ([B|S]))\")\n        let mtch = rx.Match(order)\n        if mtch.Success then\n            GoodOrder { quote = mtch.Groups.[2].Value\n                        quantity = int(mtch.Groups.[3].Value)\n                        price = float(mtch.Groups.[4].Value)\n                        status = mtch.Groups.[5].Value }\n        else\n            BadOrder order\n    let orders = lst.Split(',') |> Array.map parseOrder\n    let parsedOrders =\n        let bought, sold =\n            orders\n            |> Array.filter (fun o -> match o with | GoodOrder _ -> true | _ -> false)\n            |> Array.partition (fun (GoodOrder o) -> o.status = \"B\")\n        let formatAmounts = Array.map (fun (GoodOrder o) -> float(o.quantity) * o.price) >> Array.sum\n        sprintf \"Buy: %.0f Sell: %.0f\"(Math.Round(formatAmounts bought)) (Math.Round(formatAmounts sold))\n    let badOrders =\n        let badlyFormed =\n            orders\n            |> Array.filter (fun o -> match o with | BadOrder _ -> true | _ -> false)\n            |> Array.map (fun (BadOrder o) -> o.Trim())\n            |> Array.filter (fun s -> s <> \"\")\n        match badlyFormed with\n        | [||] -> \"\"\n        | _ -> sprintf \"; Badly formed %d: %s ;\" (Array.length badlyFormed) (badlyFormed |> String.concat \" ;\")\n    parsedOrders + badOrders","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84184,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet balanceStatements(lst: string): string =\n    let checkValid (str: string) =\n      let a = str.Trim(' ').Split(' ')\n      ((Array.length a) = 4) && (a.[1] |> Seq.forall Char.IsDigit) && Regex.IsMatch(a.[2], @\"\\d+\\.\\d+\")\n      &&\n      (a.[3] = \"B\" || a.[3] = \"S\")\n      \n    let parseStr (str: string) =\n      let a = str.Trim(' ').Split(' ')\n      (a.[3], (a.[1] |> float), (a.[2] |> float))\n      \n    let res = lst.Trim(' ').Split(',') |> Array.filter (fun x -> x <> String.Empty) |> Array.partition checkValid\n    let validStr = (fst res) |> Array.map parseStr\n    sprintf \"Buy: %d Sell: %d%s\" (validStr |> Array.sumBy (fun (a,b,c) -> if (a = \"B\") then b * c else 0.) |> round |> int)\n                                 (validStr |> Array.sumBy (fun (a,b,c) -> if (a = \"S\") then b * c else 0.) |> round |> int)\n                                 (if (((snd res) |> Array.length) = 0) then\n                                   \"\"\n                                 else\n                                   sprintf \"; Badly formed %d: %s ;\" ((snd res) |> Array.length)\n                                                                     ((snd res) |> Array.map (fun x -> x.Trim(' ')) |> String.concat \" ;\"))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84185,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet balanceStatements(l0: string): string =\n    let rx = new Regex(@\"(^[^ ]+?) (\\d+) (\\d+\\.\\d+) ([BS]$)\")\n    let mutable mal = []\n    \n    let l = \n      l0 .Split(char(\",\")) \n      |> Array.map (fun x -> x.Trim())\n    \n    let mutable temp = []\n    for x in l do\n      let m = rx.Matches(x)\n      \n      if (m.Count = 0 && x.Length > 0) then\n        mal <- mal @ [x]\n      elif m.Count = 0 then x |> ignore\n      else\n        temp <- temp @ [((float(m.[0].Groups.[2].Value) * float(m.[0].Groups.[3].Value)), m.[0].Groups.[4].Value)]\n\n    printfn \"%A\" temp\n    printfn \"--------------------\"\n\n    let mutable out = \"\"\n\n    if l.Length > 0 then\n      out <- \n        sprintf \"Buy: %i Sell: %i\" (int(Math.Round(temp |> List.filter (fun x -> (snd x) = \"B\") |> List.sumBy fst)))  (int(Math.Round(temp |> List.filter (fun x -> (snd x) = \"S\") |> List.sumBy fst)))\n    else\n      out <- \"Buy: 0 Sell: 0\"\n\n    if mal.Length > 0 then\n      out <- out + (sprintf \"; Badly formed %i: \" mal.Length)\n      for x in mal do\n        out <- out + x + @\" ;\"\n    \n    out\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84186,"user_id":null,"body":"open System\n\n\ntype Stock = {\n    quote:string\n    quanity:int\n    price:decimal\n    status:string\n}\n\ntype Either =\n    | Stock of Stock\n    | String of string\n\nlet stringToStock (s:string):Either =\n    let values = s.Split([|\" \"|],StringSplitOptions.RemoveEmptyEntries)\n    match values with\n    | [|q;a;b;c|] when a.Contains(\".\") |> not && b.Contains(\".\") && (c = \"B\" || c = \"S\") \n        -> \n            Stock {quote=q;quanity=Int32.Parse(a);price=Decimal.Parse(b);status=c}\n    | _ -> String s\n\n\nlet valueToLines (s:string):string array =\n    s.Split([|\",\"|],StringSplitOptions.RemoveEmptyEntries) |> Array.map (fun x -> x.Trim())\n\nlet total status (a:Stock array)  =\n    let a1 = a |> Array.filter (fun x -> x.status = status) \n    match a1.Length with\n    | 0 -> 0.0m\n    | _ -> a1 |>Array.fold (fun s x -> Convert.ToDecimal(x.quanity)*x.price + s) 0.0m \n\nlet removeZero (d:decimal) =\n    Math.Round(d,0).ToString()\n    \n\nlet balanceStatements(lst: string): string =\n    let values = lst |> (valueToLines >> Array.map stringToStock)\n    let stocks = values |> Array.choose (function |Stock s -> Some s |_ -> None)\n    let badStocks = values |> Array.choose (function |String s -> Some s |_ -> None) \n\n    let formart status = total status >> removeZero \n    let badStockString  =  Array.fold (fun s x -> s + x + \" ;\") (sprintf \"Badly formed %d: \" badStocks.Length)\n    \n    let b = stocks |> formart \"B\"\n    let s = stocks |> formart \"S\"\n    if badStocks.Length <> 0 then    \n        sprintf \"Buy: %s Sell: %s; %s\" b s (badStockString badStocks)\n    else\n        sprintf \"Buy: %s Sell: %s\" b s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84187,"user_id":null,"body":"open System\n\ntype OrderStatus = B | S\n\ntype Order = {\n    amount: double\n    status: OrderStatus }\n\nlet balanceStatements (orders: string) =\n    \n    let tryParseOrder (token: string) =\n        let parts = token.Split ' '\n        try \n            if parts.Length = 1 && parts.[0] = \"\"\n            then\n                Ok {\n                    amount = 0.0\n                    status = B }\n            elif parts.Length <> 4 || not (parts.[2].Contains \".\")\n            then failwith \"illegal order formatting\"\n            else\n                Ok {\n                    amount = double (Int32.Parse parts.[1]) * Double.Parse parts.[2]\n                    status = \n                        match parts.[3] with\n                        | \"B\" | \"b\" -> B\n                        | \"S\" | \"s\" -> S\n                        | _ -> failwith \"cannot parse status\" }\n        with\n        | _ -> Error (sprintf \"%s ;\" token)\n        \n    let results = \n        orders.Split ','\n        |> Seq.map (fun s -> s.Trim())\n        |> Seq.map tryParseOrder\n\n    let isOrderType orderType = function\n    | Ok order when order.status = orderType -> true\n    | _ -> false\n\n    let getTotal results =\n        let getAmount = function\n        | Ok order -> order.amount\n        | _ -> 0.0\n\n        Seq.map getAmount results\n        |> Seq.fold (+) 0.0\n        |> Convert.ToInt32\n\n    let bought =\n        Seq.where (isOrderType B) results\n        |> getTotal\n        \n    let sold =\n        Seq.where (isOrderType S) results\n        |> getTotal\n\n\n    let errorCount, errorListing =\n        \n        let isError = function\n        | Error _ -> true\n        | _ -> false\n\n        let getToken = function\n        | Error token -> token\n        | _ -> \"\"\n        \n        let errors = Seq.where isError results\n\n        Seq.length errors, String.concat \"\" (Seq.map getToken errors)\n\n    if errorCount > 0\n    then sprintf \"Buy: %i Sell: %i; Badly formed %i: %s\" bought sold errorCount errorListing\n    else sprintf \"Buy: %i Sell: %i\" bought sold","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84188,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet balanceStatements (orders: string) =\n  let validateOrder s = Regex.IsMatch (s, \"^\\S+\\s\\d+\\s\\d+\\.\\d*\\s[BS]$\"), s\n  let parseOrder (order: string) =\n    let parts = order.Split ' '\n    parts.[0], parts.[1] |> int, parts.[2] |> decimal, parts.[3]\n    \n  let validatedOrders = orders.Split ([|\", \"|], StringSplitOptions.RemoveEmptyEntries) |> Array.map validateOrder\n  \n  let badlyFormedOrders =\n    validatedOrders\n    |> Array.filter (fun (isValid, _) -> not isValid)\n    |> Array.map (fun (_, order) -> order)\n  \n  let correctOrders =\n    validatedOrders\n    |> Array.filter (fun (isValid, _) -> isValid)\n    |> Array.map (fun (_, order) -> order |> parseOrder)\n  let boughtSum = correctOrders |> Array.sumBy (fun (_, p, q, s) -> if s = \"B\" then decimal p * q else 0M)\n  let soldSum = correctOrders |> Array.sumBy (fun (_, p, q, s) -> if s = \"S\" then decimal p * q else 0M)\n  \n  let boughtSoldResult = sprintf \"Buy: %i Sell: %i\" (boughtSum |> round |> int) (soldSum |> round |> int)\n  if Array.isEmpty badlyFormedOrders then boughtSoldResult\n  else sprintf \"%s; Badly formed %i: %s ;\" boughtSoldResult badlyFormedOrders.Length (String.Join (\" ;\", badlyFormedOrders))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84189,"user_id":null,"body":"open System\nopen System.Text\nopen System.Text.RegularExpressions\n\nlet separatorRegex = Regex @\"(?x)\n    , [ ]?\n    \"\nlet simpleOrderRegex = Regex @\"(?x)\n    ^\n    (?<symbol> \\S+ ) [ ]\n    (?<shares> \\d+ ) [ ]\n    (?<price> \\d+ [.] \\d+ ) [ ]\n    (?<side> [BS] )\n    $\n    \"\n\nlet balanceStatements multipleOrder =\n    if String.IsNullOrEmpty multipleOrder then\n        (0., 0., [])\n    else\n        multipleOrder\n        |> separatorRegex.Split\n        |> Array.fold\n            (fun (buyTotal, sellTotal, errors) simpleOrder ->\n                let m = simpleOrder |> simpleOrderRegex.Match\n                if m.Success then\n                    let shares = m.Groups.[\"shares\"].Value |> float\n                    let price = m.Groups.[\"price\"].Value |> float\n                    let value = shares * price\n                    if m.Groups.[\"side\"].Value = \"B\" then\n                        buyTotal + value, sellTotal, errors\n                    else\n                        buyTotal, sellTotal + value, errors\n                else\n                    buyTotal, sellTotal, simpleOrder :: errors)\n            (0., 0., [])\n\n    |> fun (buyTotal, sellTotal, errors) ->\n        let builder = StringBuilder()\n\n        (buyTotal, sellTotal)\n        ||> Printf.bprintf builder \"Buy: %.0f Sell: %.0f\"\n\n        if not (List.isEmpty errors) then\n            errors\n            |> List.length\n            |> Printf.bprintf builder \"; Badly formed %d: \"\n            errors\n            |> List.rev\n            |> List.iter (Printf.bprintf builder \"%s ;\")\n\n        builder.ToString()\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84190,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet separatorRegex = Regex @\"(?x)\n    , [ ]?\n    \"\nlet simpleOrderRegex = Regex @\"(?x)\n    ^\n    (?<symbol> \\S+ ) [ ]\n    (?<shares> \\d+ ) [ ]\n    (?<price> \\d+ [.] \\d+ ) [ ]\n    (?<side> [BS] )\n    $\n    \"\n\nlet parseSimple s =\n    let m = s |> simpleOrderRegex.Match\n    if m.Success then\n        let shares = m.Groups.[\"shares\"].Value |> float\n        let price = m.Groups.[\"price\"].Value |> float\n        let isBuy = m.Groups.[\"side\"].Value = \"B\"\n        Ok (isBuy, shares * price)\n    else\n        Error s\n\nlet parseMultiple s =\n    if s |> String.IsNullOrEmpty then\n        Array.empty\n    else\n        s\n        |> separatorRegex.Split\n        |> Array.map parseSimple\n\nlet balanceStatements s =\n    let results = s |> parseMultiple\n\n    let oks = results |> Array.choose (function\n        | Ok value -> Some value\n        | _ -> None)\n    let errors = results |> Array.choose (function\n        | Error value -> Some value\n        | _ -> None)\n\n    let buys, sells = oks |> Array.partition fst\n\n    sprintf \"Buy: %.0f Sell: %.0f%s\"\n        (buys |> Array.sumBy snd)\n        (sells |> Array.sumBy snd)\n        (if errors |> Array.isEmpty then\n            String.Empty\n         else\n            errors\n            |> String.concat \" ;\"\n            |> sprintf \"; Badly formed %d: %s ;\" errors.Length)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84191,"user_id":491,"body":"open System\nopen System.Text.RegularExpressions\n\ntype Order = { quote : string; quantity : int; price : float; status : string }\n\nlet balanceStatements(lst : string) : string =\n    let parseOrder (order : string) =\n        let rx = Regex(@\"((\\w+) (\\d+) (\\d+\\.\\d+) ([B|S]))\")\n        let mtch = rx.Match(order)\n        if mtch.Success then\n            Some { quote = mtch.Groups.[2].Value\n                   quantity = int(mtch.Groups.[3].Value)\n                   price = float(mtch.Groups.[4].Value)\n                   status = mtch.Groups.[5].Value }\n        else\n            None\n    let orders = lst.Split(',')\n    let parsedOrders =\n        let bought, sold =\n            orders\n            |> Array.map parseOrder\n            |> Array.filter Option.isSome\n            |> Array.map Option.get\n            |> Array.partition (fun order -> order.status = \"B\")\n        let formatAmounts = Array.map (fun order -> float(order.quantity) * order.price) >> Array.sum\n        sprintf \"Buy: %.0f Sell: %.0f\"(formatAmounts bought) (formatAmounts sold)\n    let badOrders =\n        let badlyFormed =\n            orders\n            |> Array.filter (fun order -> parseOrder order |> Option.isNone)\n            |> Array.toList\n            |> List.map (fun s -> s.Trim())\n            |> List.filter (fun s -> s <> \"\")\n        match badlyFormed with\n        | [] -> \"\"\n        | _ -> sprintf \"; Badly formed %d: %s ;\" (List.length badlyFormed) (badlyFormed |> String.concat \" ;\")\n    parsedOrders + badOrders\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54e320dcebe1e583250008fd":[{"id":84192,"user_id":null,"body":"open System\n\nlet mutable factDict = Map.empty<int, int64>\nlet inline charToInt64 c =\n    if Char.IsDigit(c) then int64 c - int64 '0'\n    else (int64 c) - 55L \n        \nlet fact n =\n  let rec loop n i acc =\n    match i with\n    | i when i=n -> acc\n    | _ ->\n        if i = n \n          then acc\n          else loop n (i+1) (acc*(int64 i+1L))\n \n  match n with\n  | 0 | 1 -> 1L\n  | _ -> loop n 2 2L\n  \nlet factCache n =\n    if factDict.ContainsKey n then factDict.Item n\n    else\n        let result = fact n\n        factDict <- factDict.Add(n, result)\n        result\n        \nlet dec_2_fact_string(nb: int64): string =\n    let toStr value =\n        if value < 10 then value.ToString()\n        else if value < 26 then (55 + value) |> char |> string\n        else raise (new Exception(\"Hi,I'm Kadi\"))\n        \n    let maxFactorialForNumber nb =\n        let rec loop nb n result =\n            match result with\n            | res when res = nb -> n\n            | res when res > nb -> n-1\n            | res -> loop nb (n+1) (factCache (n+1))\n            \n        match nb with\n        | 0L | 1L -> 1\n        | _ -> loop nb 1 1L\n        \n    let rec loop nb n (factResult:int64) (result:string) =\n        if n = 0 then result+\"0\"\n        else loop (nb % factResult) (n-1) (factCache (n-1)) (result + ((nb \/factResult) |> int |> toStr))\n            \n    let maxN = maxFactorialForNumber nb\n    loop nb maxN (factCache maxN) String.Empty\n    \nlet fact_string_2_dec(str: string): int64 =\n    str.ToCharArray()\n    |> Array.rev\n    |> Array.Parallel.mapi(fun i charNum ->\n      let num = charToInt64 charNum\n      (factCache i)*num\n    )\n    |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 21:12:06"},{"id":84193,"user_id":null,"body":"open System\n\nlet rec recdec_2_fact_string (n: int64) div = \n    match n with\n    | 0L -> []\n    | _ -> (n % div) :: recdec_2_fact_string (n \/ div) (div + 1L)\n\nlet toString x = \n    match x with\n    | a when a >= 0L && a < 10L -> a.ToString()\n    | a -> char(int64('A') + a - 10L).ToString()\n\nlet dec_2_fact_string(nb: int64): string =\n    recdec_2_fact_string nb 1L |> List.map (toString) |> List.rev |> List.fold (+) \"\"\n\nlet toNum c =\n    match c with\n    | c when c >= '0' && c <= '9' -> int64(c) - int64('0')\n    | c -> int64(c) - int64('A') + 10L\n\nlet rec recfact_string_2_dec sum i mult xs =\n    match xs with\n    | [] -> sum\n    | y::ys -> recfact_string_2_dec (sum + y * mult) (i + 1L) (mult * i) ys\n\nlet fact_string_2_dec(str: string) =\n    str.ToCharArray()\n        |> Array.rev\n        |> Array.map (toNum)\n        |> Array.toList\n        |> recfact_string_2_dec 0L 1L 1L\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 21:13:19"},{"id":84194,"user_id":null,"body":"let dec_2_fact_string(nb: int64): string =\n    let rec GetFactorialsLoop (factorialsSoFar:int64 list) (n:int64) =\n        let next_factorial = factorialsSoFar.[0] * n\n        if next_factorial > nb then factorialsSoFar\n        else GetFactorialsLoop (next_factorial::factorialsSoFar) (n+1L)\n    let factorials = GetFactorialsLoop [1L; 0L] 2L\n\n    let CodedDigit digit = if digit <= 9L then char ((int64 '0') + digit) else char ((int64 'A') + (digit-10L))\n    fst (factorials |> List.fold (fun (acc,remainingNumber) fact -> if fact = 0L then (('0'::acc), 0L) else ((CodedDigit (remainingNumber\/fact))::acc, (remainingNumber%fact))) ([], nb))\n    |> List.toArray |> Array.rev |> System.String\n\nlet fact_string_2_dec(str: string): int64 =\n    let charToInt64 ch = if ch <= '9' then int64 ch - int64 '0' else int64 ch - int64 'A' + 10L\n    let (decimal,fact, n) = (str.ToCharArray() |> Array.rev |> Array.fold (fun (acc, fact, n) ch -> (acc + fact * charToInt64 ch, (if fact = 0L then 1L else fact*(n+1L)), (n+1L))) (0L, 0L, 0L))\n    decimal\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84195,"user_id":492,"body":"open System\nopen System.Linq\n\nlet dec_2_fact_string(nb: int64): string =\n    let mutable list = new ResizeArray<Char>() \n    let mutable m = nb\n    let mutable i: int64 = 1L\n    while (m <> 0L) do\n        let digit = int32 (m % i)\n        let c =\n            if (digit > 9) then\n                Convert.ToChar(digit + 55)\n            else\n                Convert.ToChar(digit + 48)\n        list.Insert(0, c)\n        m <- m \/ i\n        i <- i + 1L\n    new string(list.ToArray())\n   \nlet fact_string_2_dec(str: string): int64 =\n    let digits = str.ToCharArray().Select(fun c -> \n        if c > (char 57) then (int c) - 55\n        else (int c) - 48).Reverse().ToArray()\n    let mutable result = 0L\n    let mutable coeff = 1L\n    let mutable i: int64 = 1L\n    while i < (int64 digits.Length) do\n        coeff <- coeff * i\n        result <- result + (int64 digits.[int32 i]) * coeff\n        i <- i + 1L\n    result\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84196,"user_id":null,"body":"let calculateFactorials =\n    Seq.initInfinite (int64 >> id >> (+) 1L)\n    |> Seq.take 36\n    |> Seq.scan (fun (s) (i) -> (i * s)) (1L)\n    |> Seq.rev\n\n\nlet dec_2_fact_string (nb: int64) : string =\n    \/\/ your code\n    let res =\n        calculateFactorials\n        |> Seq.fold\n            (fun (n: System.Text.StringBuilder, curr) f -> (n.AppendFormat(\"{0:X}\", (curr \/ f)), curr % f))\n            (System.Text.StringBuilder(), nb)\n        |> fst\n\n\n    res.ToString().TrimStart('0')\n\n\n\nlet fact_string_2_dec (str: string) : int64 =\n    \/\/ your code\n    str.ToCharArray()\n    |> Array.map (fun c -> System.Int64.Parse(string c, System.Globalization.NumberStyles.HexNumber))\n    |> Seq.rev\n    |> Seq.zip (calculateFactorials |> Seq.rev)\n    |> Seq.fold (fun s (qty, f) -> (s + (qty * f))) 0L","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84197,"user_id":null,"body":"open System\n\nlet charToInt (c: char): int64 = if c <= '9' then int64 c - int64 '0' else int64 c - int64 'A' + 10L\n\nlet intToChar (num:int64): string =\n    if (num < 10L ) then num.ToString()\n    else ( char (num - 10L) + 'A').ToString()\n\n\nlet frac(num:int64):int64 =\n    if num = 0L then 1L\n    else [1L..num] |> List.fold (fun st nx -> st * nx) 1L\n\nlet dec_2_fact_string(nb: int64): string = \n    let mutable rem = nb\n    let mutable i = 1L  \n    let mutable col : int64 list = []\n    \n    while rem > 0L do\n        col <- (rem % i) :: col\n        rem <- rem \/ i\n        i <- i + 1L\n   \n    col |> List.map intToChar |> List.fold (fun st nx -> st + nx ) \"\"\n\n\n   \nlet fact_string_2_dec ( str: string ): int64 = \n    let chars = str.ToCharArray () |>  Array.toList |> List.rev\n    let idxli = [0L.. int64 chars.Length - 1L] \n\n    List.fold2 (fun st ch idx -> st + (frac idx) * (charToInt ch) ) 0L chars idxli","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84198,"user_id":null,"body":"open System\n\nlet rec fac (n: int64) = if n=0L then 1L else n*fac(n-1L)\nlet digits = ['0'..'9'] @ ['A'..'Z']\n    \nlet fact_string_2_dec(str: string): int64 =\n    let digit n = List.findIndex (fun x -> x = n) digits |> int64\n    str |> Seq.rev |> Seq.mapi (fun f d -> digit d * (int64 f |> fac)) |> Seq.sum \n    \nlet dec_2_fact_string(nb: int64): string =\n    let rec conv (n: int64) (f: int64) = \n        int (n % f) :: if (n \/ f) = 0L then [] else conv (n \/ f) (f + 1L) \n    conv nb 1L |> Seq.rev |> Seq.map (fun x -> digits.Item x |> string) |> String.concat \"\"\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84199,"user_id":null,"body":"let factorials =\n    Seq.initInfinite ((+) 1 >> int64)\n    |> Seq.scan ( * ) 1L\n    |> Seq.cache\n\nlet chars = [ '0' .. '9' ] @ [ 'A' .. 'Z' ]\nlet charOf x = chars |> List.item x\nlet valueOf c = chars |> List.findIndex ((=) c) |> int64\n\nlet dec_2_fact_string(nb: int64): string =\n    factorials\n    |> Seq.takeWhile (fun fact -> fact <= nb)\n    |> Seq.rev\n    |> Seq.mapFold\n        (fun acc fact -> int (acc \/ fact), acc % fact)\n        nb\n    |> fst\n    |> Seq.map (charOf >> string)\n    |> String.concat \"\"\n   \nlet fact_string_2_dec(str: string): int64 =\n    Seq.rev str\n    |> Seq.map2\n      (fun fact c -> valueOf c * fact)\n      factorials\n    |> Seq.sum\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84200,"user_id":null,"body":"let hex2Dec =\n    function\n    | c when c >= '0' && c <= '9' -> int c - int '0'\n    | c -> int c - int 'A' + 10\n    >> int64\n\nlet dec2Hex = \n    function\n    | num when num < 10L -> char num + '0'\n    | num -> char (num - 10L) + 'A'\n    >> string\n\nlet rec fact n = {1L..n} |> Seq.fold ( * ) 1L\n\nlet dec_2_fact_string nb =\n    if nb = 0L then \"0\"\n    else\n        let maxBase = Seq.initInfinite int64 |> Seq.find (fun n -> fact (n + 1L) > nb) \n        Seq.unfold (fun (fBase, num) -> if fBase >= 0L then Some (dec2Hex <| num \/ fact fBase, (fBase - 1L, num % fact fBase)) else None) (maxBase, nb)\n        |> String.concat \"\"\n   \nlet fact_string_2_dec str =\n    str\n    |> Seq.rev\n    |> Seq.fold (fun (i, sum) c -> i + 1L, sum + hex2Dec c * fact i) (0L, 0L)\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"},{"id":84201,"user_id":null,"body":"let hex2Dec =\n    function\n    | c when c >= '0' && c <= '9' -> int c - int '0'\n    | c -> int c - int 'A' + 10\n    >> int64\n\nlet dec2Hex = \n    function\n    | num when num < 10L -> char num + '0'\n    | num -> char (num - 10L) + 'A'\n    >> string\n\nlet rec fact = function\n| 0L -> 1L\n| n -> {1L..n} |> Seq.reduce ( * )\nlet maxVal n = fact n * n\n\nlet dec_2_fact_string(nb: int64): string =\n    if nb = 0L then \"0\"\n    else\n        let maxBase = Seq.initInfinite int64 |> Seq.find (fun n -> fact (n + 1L) > nb) \n        Seq.unfold (fun (fBase, num) -> if fBase >= 0L then Some (dec2Hex <| num \/ fact fBase, (fBase - 1L, num % fact fBase)) else None) (maxBase, nb)\n        |> String.concat \"\"\n   \nlet fact_string_2_dec str : int64 =\n    str\n    |> Seq.rev\n    |> Seq.fold (fun (i, sum) c -> i + 1L, sum + hex2Dec c * fact i) (0L, 0L)\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 20:49:33"}],"54eb33e5bc1a25440d000891":[{"id":84202,"user_id":null,"body":"let decompose(n: int64): string = \n    let rec f rest last =\n        match (rest, last) with\n        | 0L, _ -> Some []\n        | _, 1L -> None\n        | _  -> \n            let n = min (last - 1L) (int64 (System.Math.Sqrt(float rest)))\n            match f (rest - (n * n)) n with\n            | Some l -> Some (n :: l)\n            | None -> f rest n\n\n    match f (n*n) n with\n    | Some list -> \n        String.concat \" \" (list |> List.rev |> List.map(sprintf \"%d\" ))\n    | None -> null","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84203,"user_id":null,"body":"let sqr (n: int64) = n * n\nlet sqrtIntFloored (n: int64) = sqrt (float n) |> int64\nlet canStillRoot latestRoot = sqrtIntFloored (latestRoot - 1L) >= 2L\n\nlet rec drill currentRoot areaRemaining accumulatedRoots =\n    let currentSquare = sqr currentRoot\n    let currentArea = areaRemaining - currentSquare\n    let rootsAccumulatedThisRnd = currentRoot :: accumulatedRoots\n\n    if currentArea = 0L then\n        Ok rootsAccumulatedThisRnd\n    else\n        let nextRoot = sqrtIntFloored currentArea\n\n        if nextRoot < currentRoot then\n            drill nextRoot currentArea rootsAccumulatedThisRnd\n        elif nextRoot > currentRoot then\n            Error accumulatedRoots\n        elif canStillRoot currentRoot then\n            \/\/ when currentRoot and nextRoot same. But can still go down.\n            \/\/ e.g. 34 -> 32 11, 11 (11 can go down still. need to manually -1, 11->10..)\n            drill (currentRoot - 1L) currentArea rootsAccumulatedThisRnd\n        else \/\/ 1 = 1; or 4 = 4 (next vs current)\n            Error\n            <| List.skipWhile (not << canStillRoot) accumulatedRoots\n\nlet decompose originalRoot =\n    let originalArea = sqr originalRoot\n\n    let rec drillWithCorrection =\n        function\n        | Ok result -> (List.map string >> String.concat \" \") result\n        | Error (lastRoot :: accRoots) ->\n            let newArea = originalArea - List.sumBy sqr accRoots\n\n            drillWithCorrection\n            <| drill (lastRoot - 1L) newArea accRoots\n        | Error [] -> null\n\n    drillWithCorrection\n    <| drill (originalRoot - 1L) originalArea []\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84204,"user_id":null,"body":"open System\n\nlet rec takeornot (n: int64) (sum: int64) (retval:int64 list) =\n    match n,sum with  \n    |0L,0L -> retval\n    |0L,_ -> []\n    |_,_ ->\n        match n*n with \n        |a when a = sum-> (List.append retval [n])\n        |b when b > sum -> takeornot (n-1L) sum retval\n        |_ -> \n                let branch0 = takeornot (n-1L) (sum - n*n) (List.append retval [n])\n                if branch0 <> [] then\n                    branch0\n                else\n                    takeornot (n-1L) sum retval           \n\nlet decompose(n: int64): string =\n    let ans = takeornot (n-1L) (n*n) [] \n            |> List.sort \n            |> List.map (string >> (+) \" \")\n            |> String.Concat \n    match ans.Trim ' ' with \n    |\"\" -> null\n    |str -> str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84205,"user_id":492,"body":"let rec tryDecomp(toDecompose: int64) (toTry: int64) (strng: string) (r: string ref): bool = \n    let mutable finished = false\n    if (toDecompose = 0L) then\n        r := strng\n        finished <- true\n    else if (toDecompose < 0L) then \n        finished <- false\n    else\n        let mutable i = toTry - 1L\n        while (i > 0L) && (finished = false) do\n            let a = ((string)i + \" \" + strng)\n            if (tryDecomp (toDecompose - i * i) i a r) then \n                finished <- true\n            i <- i - 1L\n    finished\n\nlet decompose(n: int64): string =\n    let r = ref \"\"\n    if (tryDecomp (n * n) n \"\" r) then (!r).Trim()\n    else null","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84206,"user_id":535,"body":"let show: int64 list -> string = function\n    | [] -> null\n    | xs -> List.map string xs |> String.concat \" \"\n\nlet rec decompose' (rest: int64) (n: int64) (seq: int64 list) =\n    if rest = 0L then seq\n    elif rest = 1L && n = 1L then n::seq\n    elif n <= 1L then []\n    else\n        let rest' = rest - n*n\n        let n' = float rest' |> sqrt |> int64\n        let seq' = decompose' rest' (min (n-1L) n') (n::seq)\n        if seq' = [] then decompose' rest (n-1L) seq else seq'\nlet decompose (n: int64): string = decompose' (n*n) (n-1L) [] |> show","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84207,"user_id":null,"body":"let decompose(num: int64) =\n    let numSquared = num * num\n    let rec decomp decompList sumDecompSquares i =\n        if i <= 0L then\n            (decompList, i = 0L && sumDecompSquares = numSquared)\n        else\n            let iSquared = i * i\n            let remainingArea = numSquared - sumDecompSquares - iSquared\n            let (l, s) = decomp (i::decompList) (iSquared + sumDecompSquares) (min (i-1L) (int64 (floor (sqrt (double remainingArea)))))\n            if s then\n                (l, s)\n            else\n                decomp decompList sumDecompSquares (i-1L)\n\n    let (l, s) = decomp [] 0L (num-1L)\n    if s then l |> Seq.map string |> String.concat \" \" else null\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84208,"user_id":null,"body":"let sqr (n: int64) = n * n\nlet sqrtIntFloored (n: int64) = sqrt (float n) |> int64\nlet canStillRoot latestRoot = sqrtIntFloored (latestRoot - 1L) >= 2L\n\nlet rec drill currentRoot areaRemaining accumulatedRoots =\n    let currentSquare = sqr currentRoot\n    let currentArea = areaRemaining - currentSquare\n    let rootsAccumulatedThisRnd = currentRoot :: accumulatedRoots\n\n    if currentArea = 0L then\n        Ok rootsAccumulatedThisRnd\n    else\n        let nextRoot = sqrtIntFloored currentArea\n\n        if nextRoot > currentRoot then\n            Error accumulatedRoots\n        elif nextRoot <> currentRoot then\n            drill nextRoot currentArea rootsAccumulatedThisRnd\n        elif canStillRoot currentRoot then\n            drill (currentRoot - 1L) currentArea rootsAccumulatedThisRnd\n        else\n            Error\n            <| List.skipWhile (not << canStillRoot) accumulatedRoots\n\nlet decompose originalRoot =\n    let originalArea = sqr originalRoot\n\n    let rec drillWithCorrection =\n        function\n        | Ok result -> (List.map string >> String.concat \" \") result\n        | Error (lastRoot :: accRoots) ->\n            let newArea = originalArea - List.sumBy sqr accRoots\n\n            drill (lastRoot - 1L) newArea accRoots\n            |> drillWithCorrection\n        | _ -> null\n\n    let nxRoot = originalRoot - 1L\n\n    drill nxRoot originalArea []\n    |> drillWithCorrection\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84209,"user_id":null,"body":"let sqr (n: int64) = n * n\nlet sqrtIntFloored (n: int64) = sqrt (float n) |> int64\nlet canStillRoot latestRoot = sqrtIntFloored (latestRoot - 1L) >= 2L\n\nlet rec drill currentRoot areaRemaining accumulatedRoots =\n    let currentSquare = sqr currentRoot\n    let currentArea = areaRemaining - currentSquare\n    let rootsAccumulatedThisRnd = currentRoot :: accumulatedRoots\n\n    if currentArea = 0L then\n        Ok rootsAccumulatedThisRnd\n    else\n        let nextRoot = sqrtIntFloored currentArea\n\n        if nextRoot = currentRoot then\n            if canStillRoot currentRoot then\n                drill (currentRoot - 1L) currentArea rootsAccumulatedThisRnd\n            else\n                Error\n                <| List.skipWhile (not << canStillRoot) accumulatedRoots\n        elif nextRoot > currentRoot then\n            Error\n            <| List.skipWhile (fun x -> x < currentRoot) accumulatedRoots\n        else\n            drill nextRoot currentArea rootsAccumulatedThisRnd\n\nlet decompose originalRoot =\n    let originalArea = sqr originalRoot\n\n    let rec iterativeDrill =\n        function\n        | Ok result -> result |> List.map string |> String.concat \" \"\n        | Error (hd :: rest) ->\n            let x = hd - 1L\n            let newMaining = originalArea - List.sumBy sqr rest\n            drill x newMaining rest |> iterativeDrill\n        | _ -> null\n\n    let nxRoot = originalRoot - 1L\n    drill nxRoot originalArea [] |> iterativeDrill\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84210,"user_id":null,"body":"let sqr (n: int64) = n * n\nlet sqrtInt (n: int64) = sqrt (float n) |> int64\n\nlet rec isAscending =\n    function\n    | [ x ] -> true\n    | [ x; y ] when x < y -> true\n    | x :: y :: rest when x < y -> isAscending (y :: rest)\n    | _ -> false\n\n\/\/ will produce non-ascending. I.e. 50 will yield [1, 1, 4, 9, 49] instead of [1, 3, 5, 8, 49]\n\/\/ but this is to keep logic simple. Non-ascending handling is handled by caller.\nlet rec getSquareRoots currentSquareRoot remainingArea accumulatedSquareRoots =\n    let currentSquare = sqr currentSquareRoot\n    let remainingRemainingArea = remainingArea - currentSquare\n    let accumulatedSquareRootsThisRound = currentSquareRoot :: accumulatedSquareRoots\n\n    remainingRemainingArea\n    |> function\n        | 0L -> accumulatedSquareRootsThisRound\n        | _ ->\n            let nextSquareRoot = sqrtInt remainingRemainingArea\n            getSquareRoots nextSquareRoot remainingRemainingArea accumulatedSquareRootsThisRound\n\nlet decompose t =\n    let fullSquare = sqr t\n\n    let rec getAsendingSquareRoots squareRoot remainingArea accumulatedRoots =\n        let result = getSquareRoots squareRoot remainingArea accumulatedRoots\n\n        if result |> isAscending then\n            result\n        else\n            result\n            |> List.skipWhile (fun i -> sqrtInt i < 2L)\n            |> function\n                | head :: rest ->\n                    let lowered = head - 1L\n                    getAsendingSquareRoots lowered (fullSquare - (rest |> List.sumBy sqr)) rest\n                | _ -> []\n\n    getAsendingSquareRoots (t - 1L) fullSquare []\n    |> function\n        | [] -> null\n        | result -> result |> List.map string |> String.concat \" \"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84211,"user_id":null,"body":"let sqr (n: int64) = n * n\nlet sqrtInt (n: int64) = sqrt (float n) |> int64\n\n\/\/ referencd https:\/\/www.codewars.com\/users\/usix\nlet decompose (n: int64) : string =\n    let rec dcomp squareRoot remainingArea =\n        match squareRoot, remainingArea with\n        | _, 0L -> Some []\n        | 1L, _ -> None\n        | _ ->\n            let nextSquareRoot = min (squareRoot - 1L) (sqrtInt remainingArea)\n\n            dcomp nextSquareRoot (remainingArea - (sqr nextSquareRoot))\n            |> function\n                | Some l -> Some(nextSquareRoot :: l)\n                | None -> dcomp nextSquareRoot remainingArea\n\n    dcomp n (sqr n)\n    |> function\n        | Some list ->\n            list\n            |> List.rev\n            |> List.map string\n            |> String.concat \" \"\n        | None -> null\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54f8693ea58bce689100065f":[{"id":84212,"user_id":53,"body":"open System\n\nlet decompose (nrStr: string) (drStr: string): string =\n    let mutable a = nrStr |> int64\n    let mutable b = drStr |> int64\n    let mutable d = int64(0)\n    let mutable ans = []\n    while a >= b do\n        d <- a \/ b\n        ans <- [string d] |> List.append ans\n        a <- a % b\n    while a > int64(0) do\n        d <- int64(System.Math.Ceiling((double)b \/ (double)a))\n        ans <- [\"1\/\" + (string d)] |> List.append ans\n        a <- a * d - b\n        b <- b * d\n    let lst = ans |> String.concat \", \"\n    \"[\" + lst + \"]\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84213,"user_id":null,"body":"open System\n\nlet inline gcd a b =\n    let rec helper a b =\n        if a % b = LanguagePrimitives.GenericZero then b\n        else helper b (a % b)\n    helper (max a b) (min a b)\n\nlet inline lcm a b = a * b \/ gcd a b\n\n[<Struct>]\ntype Rational = {\n    n: int64\n    d: int64\n}\n\nlet sub { n = n1; d = d1 } { n = n2; d = d2 } =\n    let l = lcm d1 d2\n    let n = n1 * (l \/ d1) - n2 * (l \/ d2)\n    { n = n; d = l }\n\nlet decompose (nrStr: string) (drStr: string): string =\n    let rec dec (n: Rational) l =\n        if n.n = 0L || n.d = 0L then l\n        else\n            let next = int64 <| ceil (decimal n.d \/ decimal n.n)\n            dec (sub n { n = 1L; d = next }) (next :: l)\n    \n    let n = { n = int64 nrStr; d = int64 drStr }\n    if n.n >= n.d then \n        let i = n.n \/ n.d\n        let newN = { n = n.n % n.d; d = n.d }\n        sprintf \"[%s]\" <| String.Join(\", \", string i :: (dec newN [] |> List.rev |> List.map(fun x -> sprintf \"1\/%i\" x)))\n    else\n        sprintf \"[%s]\" <| String.Join(\", \", dec n [] |> List.rev |> List.map(fun x -> sprintf \"1\/%i\" x))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84214,"user_id":168,"body":"let rec gcd a b = if b = 0UL then a else gcd b (a % b)\n\nlet decompose (nrStr: string) (drStr: string): string =\n  let rec loop (n: uint64) (d: uint64) =\n    let g = gcd n d\n    let n = n \/ g\n    let d = d \/ g\n    if n = 0UL then\n      []\n    elif n >= d then\n      let r = n \/ d in\n      string r :: loop (n - r * d) d\n    else\n      let q = (d + n - 1UL) \/ n\n      \"1\/\" + string q :: loop (n * q - d) (d * q)\n  loop (uint64 nrStr) (uint64 drStr)\n  |> String.concat \", \"\n  |> sprintf \"[%s]\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84215,"user_id":492,"body":"open System\n\nlet decompose (nrStr: string) (drStr: string): string =\n    let rec gcdi x y = if y = 0UL then x else gcdi y (x % y)\n    let mutable s = \"[\"\n    let mutable a = uint64 nrStr\n    let mutable b = uint64 drStr\n    let g: uint64 = gcdi a b\n    a <- a \/ g\n    b <- b \/ g\n    if (a >= b) then\n        let v = a \/ b\n        s <- s + v.ToString() + \", \"\n        a <- a - v * b\n    else\n        a <- a\n    while (a > 0UL) do\n        let v = Math.Ceiling ((float b) \/ (float a))\n        let k = uint64 v\n        s <- s + \"1\/\" + k.ToString() + \", \"\n        a <- a * k - b\n        b <- k * b\n    s.Trim([|','; ' '|]) + \"]\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84216,"user_id":null,"body":"open System\n\nlet rec gcd a b =\n  if (b = 0L) then\n    a\n  else\n    gcd b (a % b)\n    \nlet rec finder (num: int64) (den: int64) =\n  if (num = 0L) then\n    []\n  else if (num = 1L) then\n    [(num,den)]\n  else if (num >= den) then\n    (num \/ den, 1L) :: (finder (num % den) den)\n  else\n    let first = if (den % num = 0L) then den \/ num else den \/ num + 1L\n    let newN = first * num - den\n    let newD = first * den\n    let gcd = gcd newN newD\n    let newNum = newN \/ gcd\n    let newDen = newD \/ gcd\n    (1L, first) :: (finder newNum newDen)\n  \nlet decompose (nrStr: string) (drStr: string): string =\n  let tupleToStr (num,den) = \n    if (num = 0L) then\n      \"0\"\n    else if (den = 1L) then\n      num.ToString()\n    else\n      num.ToString() + \"\/\" + den.ToString()\n\n  \"[\" + (String.concat \", \" (List.map tupleToStr (finder (Convert.ToInt64(nrStr)) (Convert.ToInt64(drStr))))) + \"]\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84217,"user_id":null,"body":"open System\nopen System.Numerics\n\nlet rec gcd (a: bigint) (b: bigint) =\n  if (b = 0I) then\n    a\n  else\n    gcd b (a % b)\n    \nlet decompose (nrStr: string) (drStr: string): string =\n    let num = nrStr |> BigInteger.Parse\n    let den = drStr |> BigInteger.Parse\n    let posNumb = if (num >= den) then [(num \/ den).ToString()] else []\n    let fract = if (num >= den) then (num % den, den) else (num, den)\n    let rec decomposer (num,den) =\n      if (num = 0I) then\n        []\n      else if (num = 1I) then\n        [(num,den)]\n      else\n        let rem = if (den % num = 0I) then (den \/ num) else (den \/ num + 1I)\n        let newnum = num * rem - den\n        let newden = den * rem\n        let gcdR = gcd newnum newden\n        let newfract = (newnum \/ gcdR, newden \/ gcdR)\n        [(1I,rem)] @ (decomposer newfract)\n    let list = posNumb @ ((decomposer fract) |> List.map (fun (n,d) -> n.ToString() + \"\/\" + d.ToString()))\n    sprintf \"[%s]\" (list  |> String.concat \", \")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84218,"user_id":null,"body":"open System\ntype Fraction = {numerator: int64\n                 denominator: int64                 }\n\ntype ComparisonResult = Less|Equals|Greater\n\nlet modulo n m = ((n % m) + m) % m\n\nlet rec gcd (m: int64) n = \n    if n = 0L\n    then m \n    else\n        gcd n (m % n)\n\n\nlet compareNums num1 num2 = \n    match (num1, num2) with\n    | num1, num2 when num1 = num2 -> Equals\n    | num1, num2 when num1 < num2 -> Less\n    | _ -> Greater\n\n\nlet compare frac1 frac2 = \n    let {numerator = num1; denominator = den1} = frac1\n    let {numerator = num2; denominator = den2} = frac2\n    if den1 <> den2\n    then \n        let num1 = num1 * den2\n        let num2 = num2 * den1\n        compareNums num1 num2\n    else\n        compareNums num1 num2\n\nlet subtract frac1 frac2 =\n    let {numerator = num1; denominator = den1} = frac1\n    let {numerator = num2; denominator = den2} = frac2\n    if den1 = den2\n    then {numerator = num1 - num2; denominator = den1}\n    else \n        let num1 = num1 * den2\n        let num2 = num2 * den1\n        {numerator = num1 - num2; denominator = den1 * den2}\n\nlet decompose (nrStr: string) (drStr: string): string =\n    \/\/ your code\n    let frac = {numerator = int64 nrStr; denominator = int64 drStr}\n    match frac.numerator % frac.denominator with\n    | 0L when frac.numerator = 0L -> \"[]\"\n    | 0L -> sprintf \"[%i]\" (frac.numerator \/ frac.denominator)\n    | _ -> \n        let rec decomposeAux currentFraq acc =\n            let {numerator = x; denominator = y} = currentFraq\n            if x = 1L\n            then y :: acc\n            else \n                let firstDenom = int64 (Math.Ceiling((double y) \/ (double x)))\n                let secondNum = modulo (-y) x\n                let secondDen = y * firstDenom\n                let gcd = gcd secondNum secondDen\n                let secondFraq  = {numerator = secondNum \/ gcd; denominator = y * firstDenom \/ gcd}\n                decomposeAux secondFraq (firstDenom::acc)\n\n        let whole = frac.numerator \/ frac.denominator\n        let num = frac.numerator % frac.denominator \n        let gcd = gcd num frac.denominator\n        let result = decomposeAux {numerator = num \/ gcd; denominator = frac.denominator \/ gcd} [] \n        let strResult = \n            result\n            |> List.rev\n            |> List.map (sprintf \"1\/%i\")\n            |> List.append (if whole > 0L then [string whole] else [])\n            |> String.concat \", \"\n        sprintf \"[%O]\" strResult \n        \n\n        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84219,"user_id":null,"body":"open System\n\nlet rec decomposeAux x y =\n    match (x, y) with\n    | (x, y) when x = 0.0 || y = 0.0 -> []\n    | (x, y) when y % x = 0.0 -> [ (1.0, y \/ x) ]\n    | (x, y) when x % y = 0.0 -> [ (x \/ y, 1.0) ]\n    | (x, y) when x > y -> [ (x \/ y, 1.0) ] @ (decomposeAux (x % y) y)\n    | _ ->\n        let n = ceil (y \/ x)\n        [ (1.0, n) ] @ (decomposeAux (x * n - y) (y * n))\n\nlet decompose (nrStr: string) (drStr: string): string =\n    let numerator, denominator = nrStr |> float, drStr |> float\n\n    let strings =\n        decomposeAux numerator denominator\n        |> Seq.map (fun (x, y) ->\n            match y with\n            | 1.0 -> sprintf \"%i\" (x |> uint64)\n            | _ -> sprintf \"%i\/%i\" (x |> uint64) (y |> uint64))\n        |> String.concat \", \"\n    sprintf \"[%s]\" strings","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84220,"user_id":null,"body":"open System\n\nlet rec gcd a b = if b = 0L then a else gcd b (a % b)\n\nlet lcm a b = let x = gcd a b in if x = 0L then 1L else (a * b) \/ x\n\nlet rec decompose' acc (n: int64) (d: int64) =\n  if n = 0L then acc\n  elif n = 1L then (n, d) :: acc\n  else let b = Math.Ceiling((double d) \/ (double n)) |> int64\n       let d' = lcm b d\n       let n' = (n * (d' \/ d)) - (1L * (d' \/ b))\n       decompose' ((1L, b) :: acc) n' d'\n       \nlet initialState n d = if n < d then (None, (n, d)) else (Some (n \/ d), (n % d, d))\n\nlet toFraction (a, b) = sprintf \"%i\/%i\" a b\n\nlet decompose (nrStr: string) (drStr: string): string =        \n    let decomposed = match initialState (int64 nrStr) (int64 drStr) with\n                     | (None, (0L, _))        -> []\n                     | (None, (n, 1L))        -> [sprintf \"%i\" n]\n                     | (None, (n, d))         -> decompose' [] n d |> List.map toFraction\n                     | (Some whole, (0L, _))  -> [sprintf \"%i\" whole]\n                     | (Some whole, (n, d))   -> let xs = decompose' [] n d |> List.map toFraction\n                                                 xs @ [sprintf \"%i\" whole]\n                                 \n    decomposed\n    |> List.rev\n    |> fun xs -> sprintf \"[%O]\" (String.Join(\", \", xs))\n        \n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"54ff3102c1bad923760001f3":[{"id":84221,"user_id":null,"body":"let get_count =\n  Seq.filter (string >> \"aeiou\".Contains) >> Seq.length","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84222,"user_id":527,"body":"let get_count = Seq.filter (Seq.contains >> (|>) \"aeiou\") >> Seq.length","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84223,"user_id":null,"body":"let get_count = \n    Seq.sumBy (fun c -> if c = 'a' || c = 'e' || c = 'i' || c = 'o' || c=  'u' then 1 else 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84224,"user_id":null,"body":"let get_count str =\n    str\n    |> Seq.sumBy (fun x ->\n        match x with\n        | 'a'\n        | 'e'\n        | 'i'\n        | 'o'\n        | 'u' -> 1\n        | _ -> 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84225,"user_id":null,"body":"let get_count (text: string) = \n    let vowels = [|'a';'e';'i';'o';'u'|]\n    text\n    |> Seq.toArray\n    |> Seq.filter (fun x -> vowels |> Array.contains x)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84226,"user_id":null,"body":"let get_count = \n  Seq.filter (set ['a'; 'e'; 'i'; 'o'; 'u']).Contains >> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84227,"user_id":527,"body":"let get_count = Seq.filter (fun c -> Seq.contains c \"aeiou\") >> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84228,"user_id":null,"body":"let get_count (str: string) = \n  [\"a\";\"e\";\"i\";\"o\";\"u\"]\n  |> List.fold (fun acc vowel ->\n    let countInString c =\n      str.ToCharArray()\n      |> Array.fold (fun innerAcc ch -> if ch.ToString() = c then innerAcc + 1 else innerAcc ) 0\n    \n    acc + countInString vowel\n  ) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84229,"user_id":null,"body":"let get_count (string: string) = \n    let newString: string = string |> String.map(fun x -> if x = 'a'|| x = 'e'|| x = 'i'|| x = 'o'|| x = 'u' then x else '!')\n    newString.Replace(\"!\", \"\") |> String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84230,"user_id":null,"body":"let get_count (input: string) =\n    let check (s: char) = \"aeiou\" |> Seq.exists ((=) s)\n    \n    input\n    |> Seq.fold (fun a b -> if check b then a + 1 else a + 0) 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5502c9e7b3216ec63c0001aa":[{"id":84231,"user_id":null,"body":"let open_or_senior = List.map (function\n    | [age; handicap] when age >= 55 && handicap > 7 -> \"Senior\"\n    | _ -> \"Open\")\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84232,"user_id":null,"body":"let open_or_senior = List.map <| function\n    | [age; handicap] when age > 55 && handicap > 7 -> \"Senior\"\n    | _ -> \"Open\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84233,"user_id":null,"body":"let open_or_senior xs = List.map (fun [age; handicap] -> if age > 55 && handicap > 7 then \"Senior\" else \"Open\") xs","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84234,"user_id":null,"body":"let open_or_senior =\n    List.map (\n        function\n        | [x;y] when x>=55 && y>7 -> \"Senior\"\n        | _ -> \"Open\"\n        )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84235,"user_id":null,"body":"let MapMamber m =\n    match m with\n    | [age; handicap] when age >= 55 && handicap > 7 -> \"Senior\"\n    | _ -> \"Open\"\n\nlet open_or_senior xs = \n    xs |> List.map MapMamber","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84236,"user_id":null,"body":"let open_or_senior xs  =\n    let translate [age;handicap] = if age > 55 && handicap > 7 then \"Senior\" else  \"Open\"\n    xs |> List.map(fun x -> translate x )\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84237,"user_id":null,"body":"let EvaluateMember = function\n                      | [age; handicap] when age >= 55 && handicap > 7 -> \"Senior\"\n                      | _ -> \"Open\"\n\nlet open_or_senior = List.map EvaluateMember","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84238,"user_id":null,"body":"let open_or_senior xs = \n  [for x in xs do \n    yield match x with\n          | [a; b] when a >= 55 && b > 7 -> \"Senior\"\n          | _ -> \"Open\"\n          ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84239,"user_id":null,"body":"let open_or_senior xs =\n    xs |> List.map (fun x -> if Seq.head x>= 55 && Seq.last x > 7 \n                             then \"Senior\" else \"Open\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84240,"user_id":null,"body":"let open_or_senior xs =\n    xs\n    |> List.map (function\n        | age :: [ handicap ] when age > 55 && handicap > 7 -> \"Senior\"\n        | _ -> \"Open\")\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55031bba8cba40ada90011c4":[{"id":84241,"user_id":null,"body":"open System\n\nlet isCubic n =\n  let d3 = n % 10\n  let d2 = (n \/ 10) % 10\n  let d1 = (n \/ 100)\n  pown d1 3 + pown d2 3 + pown d3 3 = n\n\nlet isSumOfCubes(s: string): string =\n  let cubes =\n    (String.filter (fun c -> Char.IsWhiteSpace c || Char.IsDigit c) s).Split ' '\n    |> Seq.filter (fun s -> not(s.Equals \"\"))\n    |> Seq.collect (fun s ->         \n      Seq.chunkBySize 3 s \n      |> Seq.map (fun x -> String.Concat x |> int))\n    |> Seq.filter isCubic\n  let total = cubes |> Seq.sum\n  Seq.map string cubes\n  |> String.concat \" \"\n  |> (fun s -> if not(Seq.isEmpty cubes) then s + \" \" + (string total) + \" Lucky\"\n               else \"Unlucky\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84242,"user_id":null,"body":"let digits n =\n    string n\n    |> Seq.map (fun c -> int c - int '0')\n\nlet isCubic n =\n    let sumOfCubes =\n        digits n\n        |> Seq.fold (fun state x -> state + x * x * x) 0\n    sumOfCubes = n\n\nlet isDigit = System.Char.IsDigit\n\nlet rec threeDigitNumbers (s : string) =\n    seq {\n        let i' = s |> Seq.tryFindIndex isDigit\n        match i' with\n        | None   -> yield! seq []\n        | Some i ->\n            let a = s.[i]\n            if String.length s > i + 1 then\n                let b = s.[i + 1]\n                if isDigit b then\n                    if String.length s > i + 2 then\n                        let c = s.[i + 2]\n                        if isDigit c then\n                            yield int (System.String [|a; b; c|])\n                            if (String.length s > i + 3) then\n                                yield! threeDigitNumbers (s.Substring (i + 3))\n                            else\n                                yield! seq []\n                        else\n                            yield int (System.String [|a; b|])\n                            if (String.length s > i + 2) then\n                                yield! threeDigitNumbers (s.Substring (i + 2))\n                            else\n                                yield! seq []\n                    else\n                        yield int (System.String [|a; b|])\n                        yield! seq []\n                else\n                    yield int a - int '0'\n                    if (String.length s > i + 1) then\n                        yield! threeDigitNumbers (s.Substring (i + 1))\n                    else yield! seq []\n            else\n                yield int a - int '0'\n                yield! seq []\n    }\n\nlet toString ss =\n    ss\n    |> Seq.map string\n    |> String.concat \" \"\n\nlet isSumOfCubes (s : string) =\n    let cubics =\n        s\n        |> threeDigitNumbers\n        |> Seq.filter isCubic\n    if Seq.length cubics > 0 then\n        sprintf \"%s %d Lucky\" (toString cubics) (Seq.sum cubics)\n    else\n        sprintf \"Unlucky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84243,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet isSumOfCubes(s: string): string =\n    let isCube (number:string) =\n        number\n        |> Seq.map (Char.GetNumericValue >> int)\n        |> Seq.map (fun x -> x*x*x)\n        |> Seq.sum\n        |> (=) (int(number))\n        \n\/\/    let cubes = Regex.Matches(s, \"\\d{1,3}\") |> Seq.map (fun x -> x.Value) |> Seq.filter isCube\n    let m = Regex.Matches(s, \"\\d{1,3}\")\n    let cubes = [ for i in 0..m.Count - 1 do yield m.[i].Value ] |> Seq.filter isCube |> Seq.map (int >> string)\n    match cubes |> Seq.isEmpty with\n    | true -> \"Unlucky\"\n    | false ->\n        let sum = cubes |> Seq.map int |> Seq.sum |> string\n        Seq.append cubes [sum; \"Lucky\"] |> String.concat \" \" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84244,"user_id":null,"body":"open System\n\nlet isSumOfCubes(s: string): string =\n    let isCubic (str: string) =\n        let newstr = str |> Seq.map (fun x -> (int)x - (int)'0') |> \n                     Seq.sumBy (fun x -> x * x * x) |> (fun x -> x.ToString())\n        str.TrimStart('0') = newstr || str.TrimStart('0') = \"\"\n        \n    s |> Seq.map (fun x -> if (Char.IsDigit x) then x.ToString() else \" \") |> \n    String.concat \"\" |> (fun x -> x.Split(' ')) |> Array.filter (fun x -> x <> \"\") |>\n    Array.collect (fun x -> x |> Seq.chunkBySize 3 |> Seq.map (fun y -> y |> Seq.map (fun z -> z.ToString()) |> String.concat \"\") |> Seq.toArray) |>\n    Array.map (fun x -> if (x.TrimStart('0') = \"\") then \"0\" else x.TrimStart('0')) |> Array.filter isCubic |> \n    (fun x -> if ((Array.length x) = 0) then \"Unlucky\" else (sprintf \"%s %d Lucky\" (x |> String.concat \" \") (x |> Array.sumBy (int))))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84245,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet getNumbers (arr: string) =\n    seq{ for item in Regex.Matches(arr, @\"\\d{1,3}\") do yield item.Value }\n\n\nlet isCube (str: string) = \n    let a = str.ToCharArray() |> Array.fold (fun x y -> x + (Math.Pow (int (string y) |> float, float 3))) (float 0) |> int\n    a = int str\n\nlet isSumOfCubes(s: string): string =\n    let numbers = getNumbers s |> Seq.filter (isCube) |> Seq.map (int)\n    match numbers |> Seq.length with\n    | len when len > 0 -> (numbers |> Seq.fold (fun x y-> x + (sprintf \"%i \" y)) \"\") + sprintf \"%i\" (numbers |> Seq.sum) + \" Lucky\"\n    | _ -> \"Unlucky\" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84246,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet digits n =\n    n.ToString().ToCharArray()\n    |> Array.map (System.Char.GetNumericValue >> System.Convert.ToInt32)\n\nlet cubic (n:int) : bool =\n  (digits n |> Array.map (fun x -> x*x*x) |> Array.sum) = n\n\n\nlet isSumOfCubes(s: string): string =\n  let mutable out = \"\"\n  let mutable numbers = []\n  \n  let rx = new Regex(@\"\\d{1,3}\")\n  let m = rx.Matches s\n\n  for i = 0 to (m.Count - 1) do\n    numbers <- numbers @ [int((m.Item i).ToString())]\n\n  numbers <- numbers |> List.filter (fun x -> cubic x)\n  \n  \n  if not numbers.IsEmpty then\n    for i = 0 to ((numbers.Length) - 1) do\n      out <- out + numbers.[i].ToString() + \" \"\n    out <- out + (sprintf \"%i\" (numbers |> List.sum)) + \" Lucky\"\n    out\n  else\n    \"Unlucky\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84247,"user_id":null,"body":"open System\n\nlet split (s:string)  = \n    let rec core (value:string) (rest:string)  acc =\n        if rest.Length = 0 then\n            if String.IsNullOrWhiteSpace value then\n                acc\n            else\n                value::acc\n        else\n            match rest.[0] with\n            | x  when Char.IsDigit(x) -> core (value + rest.[0].ToString()) (rest.Substring(1)) acc\n            | x -> core \"\" (rest.Substring(1)) (if String.IsNullOrWhiteSpace(value) then acc else value::acc)\n\n    core \"\" s [] |> List.rev |> List.toArray\n\nlet isIntNumber (s:string) = s |> Seq.forall Char.IsDigit\n\nlet rec mustThree (s:string) (acc:string list) = \n    match s.Length with\n    | 0 -> acc\n    | 1 -> (sprintf \"00%s\" s) :: acc\n    | 2 -> (sprintf \"0%s\" s) :: acc\n    | 3 -> s::acc \n    | _ -> mustThree (s.Substring(3)) ((s.Substring(0,3))::acc)\n \nlet beInt (value:string) = \n    let cub = value |> Seq.map (fun x -> Int32.Parse(x.ToString())) |> Seq.map (fun x -> x * x * x) |> Seq.reduce (fun x y -> x + y)\n    let num = Int32.Parse(value)\n    if cub = num then\n        (num.ToString(),num)\n    else\n        (\"\",-1)\n\nlet isSumOfCubes(s: string): string =\n    let mapf = split \n                >> Array.filter isIntNumber \n                >> Array.map (fun x -> mustThree x [] |> List.rev |> List.toArray) \n                >> Array.concat \n                >> Array.map beInt\n                >> Array.choose (function | (\"\",-1) -> None | x,y -> Some(x,y))\n    let result = mapf s\n    match result.Length with\n    | 0 -> \"Unlucky\"\n    | _ ->\n        let stringValues = result |> Array.map (fun (x,_) -> x) |> Array.reduce (fun x y -> x + \" \" + y)\n        let sum = result |> Array.sumBy (fun (_,x)-> x)\n        sprintf \"%s %d Lucky\" stringValues sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84248,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet rec digits num =\n    if num = 0 then []\n    else (num % 10)::(digits (num \/ 10))\n\nlet isCubic num =\n    num |> digits |> List.fold (fun acc x -> x*x*x + acc) 0 = num\n\nlet isSumOfCubes (s: string) =\n    let matchCollection = Regex.Matches (s, \"\\d{1,3}\") in\n    let nums = seq { 0..matchCollection.Count-1 } |> Seq.map (fun i -> (matchCollection.Item i).Value |> int) |> Seq.toArray\n    \n    let cubics = nums |> Array.filter isCubic\n    match cubics with\n    | [| |] -> \"Unlucky\"\n    | cubics -> sprintf \"%s %i Lucky\" (String.Join (\" \", cubics)) (cubics |> Array.sum)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84249,"user_id":492,"body":"open System\nopen System.Linq\nopen System.Text.RegularExpressions\n\nlet isSumOfCubes(s: string): string =\n    let u = Regex.Matches(s, @\"\\d{1,3}\").Cast<Match>().Select(fun x -> x.Value)\n    let v = u.Where(fun x -> x.Select(fun c -> int(Math.Pow(Char.GetNumericValue(c), 3.0))).Sum() = int(x))\n    let cubic = v.Select(fun x -> int(x)).ToArray()\n    let sm = cubic.Sum()\n    if (cubic.Count() = 0) then \"Unlucky\" \n    else String.Join(\" \", cubic) + \" \" + sm.ToString() + \" \" + \"Lucky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"550498447451fbbd7600041c":[{"id":84250,"user_id":492,"body":"let comp_same(a, b): bool =\n    let aa = a |> List.map (fun x->x*x) |> List.sort\n    let bb = b |> List.sort\n    aa = bb","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84251,"user_id":527,"body":"let comp_same(a, b) : bool =\n  List.sort (List.map (fun x -> x * x) a) = List.sort b","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84252,"user_id":null,"body":"let comp_same(a, b): bool = List.map (fun x -> x * x) a |> List.sort |> (=) (List.sort b)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84253,"user_id":3318,"body":"let square x = x * x\nlet comp_same(xs, ys) =\n    (xs |> List.map square |> List.sort) = (ys |> List.sort)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84254,"user_id":null,"body":"let comp_same(a, b): bool =\n    let squaredA = List.map (fun x -> x * x) a\n    List.sort b = List.sort squaredA","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84255,"user_id":null,"body":"let comp (a, b) =\n  (a |> List.sortBy abs, \n   b |> List.sort)\n  ||> List.forall2 (fun i sq -> i * i = sq)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84256,"user_id":53,"body":"let comp_same(a, b): bool =\n    let sa = List.map (fun x -> x * x) (a |> List.sortBy (fun x -> abs x))\n    let sb = b |> List.sortBy (fun x -> abs x)\n    sa = sb","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84257,"user_id":null,"body":"let comp_same(a, b) = List.map (fun x -> x * x) >> List.sort <| a = List.sort b\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84258,"user_id":null,"body":"let comp (a,b) = \n     let newa = a |> List.map (fun x -> x*x) |> List.sort\n     let newb = b |> List.sort\n     newa = newb","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84259,"user_id":null,"body":"let comp (a, b) : bool =\n    if isNull a || isNull b || Seq.length a <> Seq.length b then\n        false\n    else\n        let remap s =\n            Seq.groupBy abs s\n            |> Seq.map (fun group -> (fst group, snd group |> Seq.length))\n\n        let sortedA = a |> Seq.sortBy abs |> remap\n        let sortedB = b |> Seq.sort |> remap\n        let zipped = Seq.zip sortedA sortedB\n\n        zipped\n        |> Seq.forall (fun ((av, aCount), (bv, bCount)) -> aCount = bCount && av * av = bv)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"550527b108b86f700000073f":[{"id":84260,"user_id":null,"body":"open System\n\nlet iterPi epsilon = \n\n    let myPi, _, iterations = Seq.initInfinite(fun idx -> idx + 1)\n                              |> Seq.map(fun idx -> (idx * 2) - 1)\n                              |> Seq.scan(fun (pi, sign, _) idx -> \n                                    (pi + sign * (1. \/ float(idx)), sign * -1., idx)) (0., 1., 0)\n                              |> Seq.skipWhile(fun (pi, _, idx) -> Math.Abs(Math.PI - (pi*4.)) >= epsilon)\n                              |> Seq.take 1\n                              |> Seq.head\n    ((iterations + 1) \/ 2, myPi * 4.)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84261,"user_id":null,"body":"open System\n\nlet iterPi epsilon =\n    let rec piExpansion (idx:int) (s:int) (t:double) = seq {\n        let t_new = t + 4.0 \/ (double (idx * 2 - 1) * double s)\n        yield (idx, t_new)\n        yield! piExpansion (idx+1) -s t_new\n    }\n    piExpansion 1 1 0.0 |> Seq.skipWhile (fun (_, x) -> Math.Abs(x - Math.PI) >= epsilon) |> Seq.head\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84262,"user_id":null,"body":"let iterPi epsilon =\n  let mutable pi, n, sgn, i  =  1.0,  3.0,  1.,  1\n  let a, b  =  (System.Math.PI - epsilon)\/4. , (System.Math.PI + epsilon)\/4.\n  while not (a < pi && pi < b) do\n      sgn <- sgn * -1.\n      pi  <- pi + sgn \/ n\n      n   <- n+2.\n      i   <- i+1\n  (i, pi*4.)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84263,"user_id":null,"body":"let iterPi epsilon =\n  let isClose n = abs (System.Math.PI - n) < epsilon\n  let denominators = Seq.initInfinite (fun n -> n*2 + 1 |> float)\n  let numerators = Seq.initInfinite (fun n -> if n%2 = 0 then 1.0 else -1.0)\n  let terms = Seq.map2 (\/) numerators denominators\n  let approximations = terms |> Seq.scan (+) 0.0 |> Seq.map (fun n -> n * 4.0)\n  let countedApproximations = approximations |> Seq.indexed\n  \/\/ Note that ALL of those Seq functions are LAZY.\n  \/\/ Which means that up to this point, we have done NO work yet!\n  \/\/ But with the next line, we'll actually do the work\n  countedApproximations |> Seq.find (snd >> isClose)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84264,"user_id":null,"body":"let PI = System.Math.PI\nlet iterPi epsilon =\n\n    let mutable pi = 4.0\n    let mutable i = 3.0\n    let mutable sign = -4.0\n    while abs (PI - pi) > epsilon do\n        pi <- pi + sign \/ i\n        sign <- -sign\n        i <- i + 2.0\n    \n    (int i \/ 2, pi)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84265,"user_id":null,"body":"let iterPi epsilon =\n    let rec f i sum =\n        if abs (System.Math.PI - sum) < epsilon\n        then i, sum\n        else\n            let term =\n                (if i % 2 = 0 then 1. else -1.) * 4. \/\n                float (2 * i + 1)\n            f (i + 1) (sum + term)\n\n    f 0 0.\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84266,"user_id":492,"body":"open System\n\nlet iterPi epsilon = \n    let trunc10Dble (d: double) = double(uint64(d * 1e10)) * 1e-10\n    let rec loop (i: int) (value: double) =\n        if (abs (Math.PI - value) <= epsilon) then (i, trunc10Dble value)\n        else\n            loop (i + 1) (value + 4.0 * Math.Pow(-1.0, double(i)) \/ (2.0 * double(i) + 1.0))\n    loop 1 4.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84267,"user_id":492,"body":"open System\n\nlet iterPi epsilon = \n    let trunc10Dble (d: double) = double(uint64(d * 1e10)) * 1e-10\n    let rec loop (i: int) (value: double) =\n        if (abs (Math.PI - value) <= epsilon) then (i, trunc10Dble value)\n        else\n            loop (i + 1) (value + 4.0 * Math.Pow(-1.0, double(i)) \/ (2.0 * double(i) + 1.0))\n    loop 1 4.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84268,"user_id":null,"body":"let iterPi e =\n    let generate (v, n, s) = Some((n, v), ((v + 4.0 * s \/ (1.0 + 2.0 * float n)), (n + 1), (-s)))\n    let closeEnough (n, v) = abs (System.Math.PI - v) < e\n    Seq.unfold generate (0.0, 0, 1.0) |> Seq.find closeEnough\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84269,"user_id":null,"body":"open System \n\nlet iterPi (epsilon:float) =  \n  let pig = Math.PI \n  in\n  let rec aux1 (n:int) (value:float) =\n    let diff = abs (value-pig) in\n    if diff < epsilon then (n,value)\n    else aux2 (n+1) (value + 4.0 \/ (2.0 * (float n) + 1.0))\n  and\n    aux2 n value =\n    let diff = (value-pig) in\n    if diff < epsilon then (n,value)\n    else aux1 (n+1) (value - 4.0 \/ (2.0 * (float n) + 1.0))\n  in \n  aux1 0 0.0\n;;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"550554fd08b86f84fe000a58":[{"id":84270,"user_id":null,"body":"let contains s1 (s2 : string) = s2.Contains(s1)\n\nlet inArray (a1 : string list) a2 =\n    a1\n    |> Seq.distinct\n    |> Seq.filter (fun s -> List.exists (contains s) a2)\n    |> Seq.sort\n    |> Seq.toList\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84271,"user_id":3318,"body":"let inArray (xs: string list) (ys: string list) = \n    xs\n    |> List.distinct\n    |> List.filter (fun x -> ys |> List.exists (fun y -> y.Contains(x)))\n    |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84272,"user_id":53,"body":"let inArray (a1: string list) (a2: string list) =\n  a1 \n    |> Seq.distinct \n    |> List.ofSeq \n    |> List.filter(fun (x: string) -> List.exists (fun (y: string) -> y.Contains(x)) a2)\n    |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84273,"user_id":null,"body":"let inArray (a1: string list) (a2: string list) =\n    a1 \n    |> List.filter (fun a1' -> a2 |> List.exists (fun a2' -> a2'.Contains(a1')))\n    |> List.distinct\n    |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84274,"user_id":null,"body":"let inArray (a1: string list) (a2: string list) =\n    a1 \n    |> List.filter \n        (fun s -> a2 |> List.exists (fun t -> t.Contains(s)))\n    |> List.distinct \n    |> List.sort\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84275,"user_id":492,"body":"open System\n\nlet inArray (a1: string list) (a2: string list) =\n    let aa1 = a1 |> Seq.distinct\n    [for (x: string) in aa1 do if (Seq.exists (fun (y: string) ->  y.Contains(x)) a2) then yield x] |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84276,"user_id":null,"body":"let inArray (a1: string list) (a2: string list) =\n  let holder = a1|>\n                  List.filter (fun x ->\n                                  (a2|>List.filter(fun y ->\n                                                       y.IndexOf(x) <> -1)) <> [])|> List.distinct |> List.sort\n                                      \n  holder\n                                ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84277,"user_id":null,"body":"let inArray (a1: string list) (a2: string list) =\n  a1 \n  |> List.filter(fun a -> a2 |> List.exists(fun b -> b.Contains(a)))\n  |> List.distinct\n  |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84278,"user_id":null,"body":"let inArray (a1: string list) (a2: string list) =\n  List.distinct a1\n  |> List.filter (fun s1 -> List.exists (fun (s2:string) -> s2.Contains s1) a2)\n  |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84279,"user_id":null,"body":"let seqEquals s1 s2 = \n    if Seq.length s1 <> Seq.length s2 then false\n    else Seq.map2 (fun a b -> a = b) s1 s2 |> Seq.forall id\n\nlet rec isSubSeq smaller greater =\n  if seqEquals smaller greater\n    then true\n  elif Seq.length smaller > Seq.length greater \n    then false\n  elif Seq.take (Seq.length smaller) greater |> seqEquals smaller\n    then true\n  else \n    isSubSeq smaller (Seq.tail greater)\n\nlet inArray (a1: string list) (a2: string list) =\n  List.filter (fun s -> List.exists (isSubSeq s) a2) a1\n  |> List.distinct\n  |> List.sort\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5506b230a11c0aeab3000c1f":[{"id":84280,"user_id":492,"body":"open System\n\nlet evaporator _ (evapPerDay: double) (threshold: double): int =\n    int(ceil(log(threshold \/ 100.0) \/ log(1.0 - evapPerDay \/ 100.0)))","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84281,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n    let t = threshold \/ 100.0\n    let e = evapPerDay \/ 100.0\n    log t \/ log (1.0 - e)\n    |> ceil\n    |> int","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84282,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n    let _thresh = content*threshold\/100.\n    let _evap = 1. - (evapPerDay\/100.)\n    log(_thresh\/content)\/ log _evap |> ceil |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84283,"user_id":492,"body":"open System\n\nlet evaporator _ (evapPerDay: double) (threshold: double): int =\n    int(ceil(log(threshold \/ 100.0) \/ log(1.0 - evapPerDay \/ 100.0)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84284,"user_id":null,"body":"let evaporator content evapPerDay threshold =\n  let d, t = evapPerDay \/ 100.0, threshold \/ 100.0\n  Seq.unfold ( fun v -> let nv = v - v*d in Some(v, nv) ) 1.0 \n  |> Seq.takeWhile ((<) t)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84285,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n  Seq.unfold (fun (state:double) -> Some(state, state-state*evapPerDay\/100.0)) 100.0\n  |> Seq.takeWhile (fun state -> state>=threshold)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84286,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n    let rec evaporator' content days =\n        if content < threshold then days\n        else evaporator' (content * (1.0 - evapPerDay \/ 100.0)) (days + 1)\n    evaporator' 100.0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84287,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n    let rec evaporate state =\n        if (state < threshold) then 0\n        else 1 + evaporate (state * ((100. - evapPerDay)\/ 100.))\n    evaporate 100.","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84288,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n    Seq.initInfinite (fun x -> (1.0 - evapPerDay\/100.0) ** (float x))\n    |> Seq.indexed\n    |> Seq.skipWhile (fun x -> (snd x) >= threshold\/100.0)\n    |> Seq.head\n    |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84289,"user_id":null,"body":"let evaporator (content: double) (evapPerDay: double) (threshold: double): int =\n  \/\/ Return the day on which the evaporator will no longer be useful, i.e. the day\n  \/\/ on which the given initial content (in ml. Corresponds to 100%), falls under\n  \/\/ the threshold (in %), if its losing evapPerDay (in %) per day.\n  let mlthreshold = content * threshold \/ 100.0\n  let rec accum left count =\n    if left < mlthreshold\n    then count\n    else accum (left - left * evapPerDay \/ 100.0) (count + 1)\n  accum content 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5508249a98b3234f420000fb":[{"id":84290,"user_id":null,"body":"let shiftC shift c baseLetter = (int c - int baseLetter + (shift % 26 + 26)) % 26 + int baseLetter |> char\n\nlet shiftChar shift = function\n| c when c >= 'a' && c <= 'z' -> shiftC shift c 'a'\n| c when c >= 'A' && c <= 'Z' -> shiftC shift c 'A' \n| c -> c\n    \nlet split s =\n    let rem = String.length s % 5\n    let len = String.length s \/ 5 + if rem = 0 then 0 else 1\n    Seq.init 5 (fun i -> (len) * i)\n    |> Seq.mapi (fun i start -> s.Substring(start, len - if i = 4 && rem <> 0 then 5 - rem else 0))\n\nlet moving_shift s shift : string array =\n    s\n    |> String.mapi (fun i c -> shiftChar (shift + i) c)\n    |> split\n    |> Array.ofSeq\n\nlet demoving_shift (s : string array) shift =\n    s\n    |> String.concat \"\"\n    |> String.mapi (fun i c -> shiftChar -(shift + i) c)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84291,"user_id":492,"body":"open System\nopen System.Text\nopen System.Text.RegularExpressions\nopen System.Collections.Generic\n    \nlet moving_shiftAux(s: string) (shift: int) (sgn: int): string =\n    let modd(dividend: int) (divisor: int): int =\n        let modulo = dividend % divisor\n        if modulo < 0 then modulo + divisor else modulo\n    let mutable result = new StringBuilder()\n    for k in 0 .. (s.Length - 1) do\n        let mutable sVal: int = modd (sgn * (shift + k)) 26\n        let mutable ch = s.[k]\n        if ch >= 'A' && ch <= 'Z' then           \n            result.Append((char)((int)'A' + ((int)ch - (int)'A' + sVal) % 26))\n        else if ch >= 'a' && ch <= 'z' then            \n            result.Append((char)((int)'a' + ((int)ch - (int)'a' + sVal) % 26))\n        else result.Append(ch) \n        |> ignore\n    result.ToString()\n\nlet moving_shift(s: string) (shift: int): string array =\n    let ss = moving_shiftAux s shift 1\n    let rs = new List<string>()\n    let l = ss.Length\n    let lc = l \/ 5\n    let p = if l % 5 <> 0 then lc + 1 else lc\n    for m in Regex.Matches(ss, \".{0,\" + p.ToString() + \"}\") do\n        if (rs.Count < 5) then \n            rs.Add(m.Value)   \n    rs.ToArray()\n       \nlet demoving_shift(s: string array) (shift: int): string =\n    let u: string = String.Join(\"\", s)\n    let res = moving_shiftAux u shift -1\n    res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84292,"user_id":null,"body":"open System\n\nlet isAlphabet c =\n  (int 'A' <= int c && int c <= int 'Z') || (int 'a' <= int c && int c <= int 'z')\n\nlet caesar c shift: char =\n  if not (isAlphabet c) then c else\n  let from = if Char.IsUpper(c) then int 'A' else int 'a'\n  (int c - from + (shift % 26 + 26)) % 26 + from |> char\n\nlet moving_shift(s: string) (shift: int): string array =\n  let coded = s |> String.mapi (fun i c -> caesar c (shift+i))\n  let len = float s.Length \/ 5. |> ceil |> int\n  \n  [| coded.[0..len-1]; coded.[len..2*len-1]; coded.[2*len..3*len-1]; coded.[3*len..4*len-1]; coded.[4*len..coded.Length-1] |]\n  \nlet demoving_shift(s: string array) (shift: int): string =\n  s |> Array.fold (fun acc s -> acc + s) \"\" |> String.mapi (fun i c -> caesar c (-shift-i))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84293,"user_id":null,"body":"let rec moving_shiftImpl (s: char list) (shift: int) (result: string) =\n    let nextEncIndex value charset =\n        ((List.findIndex (fun x -> x = value) charset)\n         + shift) % List.length charset\n\n    match s with\n    | h :: t when List.contains h [ 'a' .. 'z' ] ->\n        let charset = [ 'a' .. 'z' ]\n        moving_shiftImpl t (shift + 1) (result + string charset.[nextEncIndex h charset])\n    | h :: t when List.contains h [ 'A' .. 'Z' ] ->\n        let charset = [ 'A' .. 'Z' ]\n        moving_shiftImpl t (shift + 1) (result + string charset.[nextEncIndex h charset])\n    | h :: t -> moving_shiftImpl t (shift + 1) (result + string h)\n    | [] -> result\n\nlet splitString (message: string) =\n    let textLength = message.Length\n\n    let chunkSize =\n        (textLength |> float) \/ 5.0 |> ceil |> int\n\n    let rec distribution remainder chunkSize acc =\n        match remainder, acc with\n        | _, a when a |> List.length = 5 -> a |> List.rev\n        | x, _ when x > chunkSize -> distribution (x - chunkSize) chunkSize (chunkSize :: acc)\n        | x, _ when x <= chunkSize -> distribution 0 chunkSize (x :: acc)\n        | _, _ -> failwith \"wrong!\"\n\n    let split = distribution textLength chunkSize []\n\n    let rec pieces (str: string) split result =\n        match split with\n        | h :: t -> pieces (str.Substring(h)) t (str.Substring(0, h) :: result)\n        | [] -> result\n\n    pieces message split [] |> List.rev |> List.toArray\n\nlet moving_shift (s: string) (shift: int) =\n    moving_shiftImpl (seq s |> Seq.toList) shift \"\"\n    |> splitString\n\nlet rec demoving_shiftImpl (enc: char list) (shift: int) (result: string) =\n    let nextDecIndex value (charset: char list) =\n        let v =\n            ((List.findIndex (fun x -> x = value)) charset)\n\n        let offset = shift % charset.Length\n\n        if v < offset then\n            v + charset.Length - offset\n        else\n            v - offset\n\n    match enc with\n    | h :: t when List.contains h [ 'a' .. 'z' ] ->\n        let charset = [ 'a' .. 'z' ]\n        demoving_shiftImpl t (shift + 1) (result + string charset.[nextDecIndex h charset])\n    | h :: t when List.contains h [ 'A' .. 'Z' ] ->\n        let charset = [ 'A' .. 'Z' ]\n        demoving_shiftImpl t (shift + 1) (result + string charset.[nextDecIndex h charset])\n    | h :: t -> demoving_shiftImpl t (shift + 1) (result + string h)\n    | [] -> result\n\n\nlet demoving_shift (fragments: string array) (shift: int) =\n    let encoded =\n        fragments |> String.concat \"\" |> seq |> Seq.toList\n\n    demoving_shiftImpl encoded shift \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84294,"user_id":null,"body":"let rec shiftChar (c : char) (shift : int) (origin : char) =\n    let pos = int c - int origin\n    if (shift >= 0) then\n        char ((pos + shift) % 26 + int origin)\n    else\n        shiftChar c (shift + 26) origin\n\nlet shiftWithCase (c : char) (shift : int) : char =\n    match int c with\n    | x when int 'A' <= x && x <= int 'Z' -> shiftChar c shift 'A'\n    | x when int 'a' <= x && x <= int 'z' -> shiftChar c shift 'a'\n    | _ -> c\n\nlet shiftString (shift : int) (s : string) : string =\n    s\n    |> String.mapi (fun i c ->\n        let currentShift = shift + (if shift >= 0 then i else -i)\n        shiftWithCase c currentShift)\n\nlet rec pad (n : int) (a : string array) =\n    if Array.length a < n then\n        Array.append a [|\"\"|] |> pad n\n    else\n        a\n\nlet splitInto (n : int) (s : string) =\n    let chunkSize = float (String.length s) \/ float n |> ceil |> int\n    s\n    |> Seq.chunkBySize chunkSize\n    |> Seq.map System.String\n    |> Seq.toArray\n    |> pad n\n\nlet moving_shift (s : string) (shift : int) : string array =\n    s |> shiftString shift |> splitInto 5\n\nlet demoving_shift (s : string array) (shift : int) : string =\n    s |> String.concat \"\" |> shiftString -shift","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84295,"user_id":null,"body":"open System\n\nlet shiftChar shift chr =\n  \/\/\/ floured modulo\n  let modulo a b = (abs (a * b) + a) % b\n  if not (Char.IsLetter chr) then chr\n  else\n    let a = if Char.IsUpper chr then 'A' else 'a'\n    modulo (int chr - int a + shift) 26 + int a |> char\n\nlet moving_shift(s: string) (shift: int): string array =\n  let s' = s |> String.mapi (fun i chr -> shiftChar (shift+i) chr)\n  let len = s.Length\n  let n = if len % 5 = 0 then len \/ 5 else len \/ 5 + 1\n  [| \n    for i in 0 .. n .. len do\n      match s'.[i..] with\n      | \"\" -> ()\n      | substr when substr.Length >= n -> yield substr.[0..n-1]\n      | substr -> yield substr \n  |]\n        \nlet demoving_shift(s: string array) (shift: int): string =\n  String.concat \"\" s\n  |> String.mapi (fun i chr -> shiftChar -(shift+i) chr)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84296,"user_id":null,"body":"open System\n\nlet split (num: int) =\n  let splitNum = ((num |> float) \/ 5.0) |> ceil |> int\n  let arr = [|0..4|] |> Array.map (fun i -> (max 0 (min splitNum (num - splitNum * i))))\n  arr |> Array.mapi (fun i x -> arr |> Array.take i |> Array.sum |> (fun y -> (y, x)))\n  \nlet moving_shift(s: string) (shift: int): string array =\n    let shifr (shift: int) (letter: char) = \n      if (Char.IsLower(letter)) then\n        let newShift = ((int)letter - (int)'a' + shift) % 26\n        (char)((int)'a' + newShift)\n      else if (Char.IsUpper(letter)) then\n        let newShift = ((int)letter - (int)'A' + shift) % 26\n        (char)((int)'A' + newShift)\n      else\n        letter\n\n    let splitStr (str: string) =\n      str |> String.length |> split |>\n      Array.map (fun (a,b) -> str.Substring(a,b))\n      \n    s |> String.mapi (fun i l -> l |> (shifr (shift + i))) |> splitStr\n    \nlet demoving_shift(s: string array) (shift: int): string =\n    let deshifr (shift: int) (letter: char) = \n      if (Char.IsLower(letter)) then\n        let shiftC = shift % 26\n        let newShift = ((int)letter - (int)'a' - shiftC + 26) % 26\n        (char)((int)'a' + newShift)\n      else if (Char.IsUpper(letter)) then\n        let shiftC = shift % 26\n        let newShift = ((int)letter - (int)'A' - shiftC + 26) % 26\n        (char)((int)'A' + newShift)\n      else\n        letter\n        \n    s |> String.concat \"\" |> String.mapi (fun i l -> l |> deshifr (shift + i))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84297,"user_id":null,"body":"open System\n\nlet moving_shift(s: string) (shift: int): string array =\n    let partSize = 1 + (s.Length-1) \/ 5\n    let shifted = s |> String.mapi (fun i ch -> if Char.IsLower(ch) then char ((int ch - int 'a' + shift + i)%26 + int 'a') elif Char.IsUpper(ch) then char ((int ch - int 'A' + shift + i)%26 + int 'A') else ch)\n    [| shifted.[..partSize-1]; shifted.[partSize..2*partSize-1]; shifted.[2*partSize..3*partSize-1]; shifted.[3*partSize..4*partSize-1]; shifted.[4*partSize..]; |]\n\nlet demoving_shift(s: string array) (shift: int): string =\n    s\n    |> String.concat \"\"\n    |> String.mapi (fun i ch -> if Char.IsLower(ch) then char (((int ch - int 'a' - shift - i)%26 + 26)%26 + int 'a') elif Char.IsUpper(ch) then char (((int ch - int 'A' - shift - i)%26 + 26)%26 + int 'A') else ch)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84298,"user_id":null,"body":"open System\n\nlet rec contains n = function\n  | [] -> false\n  | x :: xs -> (n = x) || contains n xs\n\nlet moving_shift(s: string) (shift: int): string array =\n  s\n  |> String.mapi (fun i x -> \n    if (['a'..'z'] |> contains x) then char(((int(x) - 97 + i + shift) % 26) + 97)\n    elif (['A'..'Z'] |> contains x) then char(((int(x) - 65 + i + shift) % 26) + 65)\n    else x)\n  |> Seq.chunkBySize(if s.Length % 5 = 0 then ((s.Length)\/5) else ((s.Length\/5) + 1))\n  |> Seq.map String.Concat\n  |> Array.ofSeq\n       \nlet demoving_shift(s: string array) (shift: int): string =\n  s\n  |> String.Concat\n  |> String.mapi (fun i x ->\n    if (['a'..'z'] |> contains x) then char((((int(x) - 97)  + (26 - ((i + shift)%26)))%26) + 97)\n    elif (['A'..'Z'] |> contains x) then char((((int(x) - 65)  + (26 - ((i + shift)%26)))%26) + 65)\n    else x)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84299,"user_id":null,"body":"let splitUp (s: string) =\n    let length = String.length s\n    let maxPartLen = (float length) \/ 5.0 |> ceil |> int\n    let fifthPartLength = max (length - 4 * maxPartLen) 0\n    let (withoutFifth, fifth) = s.ToCharArray() |> Array.splitAt (length - fifthPartLength)\n    let firstFour = withoutFifth |> Array.splitInto 4 |> Array.map System.String\n    [| yield! firstFour; yield System.String fifth |]\n\nlet shiftChar (offset: int) (c: char) =\n    let maxVal = (int 'z') - (int 'a') + 1\n    let doShift aValue =\n        let newVal = ((int c) - aValue + offset) % maxVal\n        let newVal' = newVal + (if newVal < 0 then maxVal else 0)\n        newVal' + aValue |> char\n\n    if c >= 'a' && c <= 'z' then doShift (int 'a')\n    else if c >= 'A' && c <= 'Z' then doShift (int 'A')\n    else c\n\nlet moving_shift(s: string) (shift: int): string array =\n    s\n    |> String.mapi (fun index c -> shiftChar (index + shift) c)\n    |> splitUp\n\nlet demoving_shift(s: string array) (shift: int): string =\n    s\n    |> String.concat \"\"\n    |> String.mapi (fun index c -> shiftChar -(index + shift) c)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55084d3898b323f0aa000546":[{"id":84300,"user_id":null,"body":"open System\n\nmodule Array =\n    let splitRem count array =\n        let splitIndex =\n            float (Array.length array) \/ float count\n            |> (Math.Ceiling >> int)\n\n        array\n        |> Array.unfold\n            (function\n            | arr when arr.Length > splitIndex -> Some(Array.splitAt splitIndex arr)\n            | arr when arr.Length > 0 -> Some(arr, [||])\n            | _ -> None)\n\n    let getShifted array shift elem =\n        let index =\n            (Array.IndexOf(array, elem) + shift) % array.Length\n\n        match index with\n        | i when i >= 0 -> i\n        | i -> array.Length + i\n        |> Array.get array\n\nmodule String =\n    let rotate shift input =\n        let shiftUppers = Array.getShifted [| 'A' .. 'Z' |] shift\n        let shiftLowers = Array.getShifted [| 'a' .. 'z' |] shift\n\n        input\n        |> String.collect (\n            (function\n            | c when Char.IsUpper c -> shiftUppers c\n            | c when Char.IsLower c -> shiftLowers c\n            | c -> c)\n            >> string\n        )\n\nlet encode (s: string) (shift: int) : string array =\n    let head, tail = s.[0], s.[1..]\n    let prefix = sprintf \"%c%c\" (Char.ToLower head) head\n\n    (Char.ToLower >> string) head\n    + String.rotate shift (prefix + tail)\n    |> (Array.ofSeq >> Array.map string)\n    |> Array.splitRem 5\n    |> Array.map (String.concat \"\")\n\n\nlet decode (s: string array) : string =\n    let headArray = s.[0]\n    let prefix, tail = headArray.[1..2], headArray.[3..]\n    let shift = int headArray.[0] - int prefix.[0]\n\n    let head =\n        match Char.IsUpper prefix.[1] with\n        | true -> Char.ToUpper headArray.[0]\n        | false -> headArray.[0]\n\n    tail + String.concat \"\" s.[1..]\n    |> String.rotate shift\n    |> (+) (string head)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84301,"user_id":null,"body":"open System\n\nlet splitRem count array =\n    let splitIndex =\n        array |> Array.length |> (float >> (\/))\n        <| float count\n        |> (Math.Ceiling >> int)\n\n    array\n    |> Array.unfold\n        (function\n        | arr when arr.Length > splitIndex -> Some(Array.splitAt splitIndex arr)\n        | arr when arr.Length > 0 -> Some(arr, [||])\n        | _ -> None)\n\nlet rotate shift input =\n    let shiftArray shift array =\n        array\n        |> Array.splitAt (\n            match shift % array.Length with\n            | i when i >= 0 -> i\n            | i -> i + array.Length\n        )\n        |> (fun (s1, s2) -> Array.append s2 s1)\n\n    let uppers = [| 'A' .. 'Z' |]\n    let sUppers = shiftArray shift uppers\n    let lowers = [| 'a' .. 'z' |]\n    let sLowers = shiftArray shift lowers\n\n    input\n    |> String.collect (\n        (function\n        | c when Char.IsUpper c -> Array.IndexOf(uppers, c) |> Array.get sUppers\n        | c when Char.IsLower c -> Array.IndexOf(lowers, c) |> Array.get sLowers\n        | c -> c)\n        >> string\n    )\n\nlet changeCase =\n    function\n    | c when Char.IsUpper c -> Char.ToLower c\n    | c when Char.IsLower c -> Char.ToUpper c\n    | c -> c\n\nlet encode (s: string) (shift: int) : string array =\n    let head, tail = s.[0], s.[1..].ToCharArray()\n    let prefix = [| Char.ToLower head; head |]\n\n    Array.append prefix tail\n    |> Array.map (string >> (rotate shift))\n    |> Array.append [| (Char.ToLower >> string) head |]\n    |> splitRem 5\n    |> Array.map (String.concat \"\")\n\nlet decode (s: string array) : string =\n    let head, prefix, tail =\n        s.[0] |> (fun s -> s.[0], s.[1..2], s.[3..])\n\n    let head' =\n        if Char.IsUpper prefix.[1] then\n            Char.ToUpper head\n        else\n            head\n\n    let shift = int head - int prefix.[0]\n\n\n    Array.tail s\n    |> Array.append [| tail |]\n    |> Array.map (rotate shift)\n    |> Array.append [| string head' |]\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84302,"user_id":null,"body":"let shiftC shift c baseLetter = (int c - int baseLetter + (shift % 26 + 26)) % 26 + int baseLetter |> char\n\nlet shiftChar shift = function\n| c when c >= 'a' && c <= 'z' -> shiftC shift c 'a'\n| c when c >= 'A' && c <= 'Z' -> shiftC shift c 'A' \n| c -> c\n\nlet split s =\n    let rem = String.length s % 5\n    let len = String.length s \/ 5 + if rem = 0 then 0 else 1\n    Seq.init 5 (fun i -> (len) * i)\n    |> Seq.mapi (fun i start -> s.[start..start + len - if i = 4 && rem <> 0 then 6 - rem else 1])\n    \nlet encode (s : string) shift =\n    s\n    |> String.map (shiftChar shift)\n    |> (+) ((s.[0..0] + string (shiftChar shift s.[0])).ToLower())\n    |> split\n    |> Seq.filter ((<>) \"\")\n    |> Array.ofSeq\n    \nlet decode s =\n    let s' = String.concat \"\" s\n    let shift = (int s'.[1] - int s'.[0] + 26) % 26\n    s'.[2..] |> String.map (shiftChar -shift)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84303,"user_id":null,"body":"open System\nlet encode(s: string) (shift: int): string array =\n    printfn \"%s %d\" s shift\n    let shift = shift%26\n    let RotateUp ch =\n        if Char.IsLower(ch) then char (((((int ch) - (int 'a'))+shift)%26)+int 'a')\n        elif Char.IsUpper(ch) then char (((((int ch) - (int 'A'))+shift)%26)+int 'A')\n        else ch\n\n    let nChars = 2 + s.Length\n    let firstCodedChar = Char.ToLower(s.[0])\n    let secondCodedChar = RotateUp firstCodedChar\n    let codedChars = Array.init nChars (fun i -> if i = 0 then firstCodedChar else if i = 1 then secondCodedChar else RotateUp s.[i-2])\n    let n = (nChars-1)\/5 + 1    \/\/ size of parts 1 - 4\n    if n*4 = nChars then    \/\/ do not need a fifth\n        [| String(codedChars.[0..n-1]); String(codedChars.[n..n*2-1]); String(codedChars.[n*2..n*3-1]); String(codedChars.[n*3..n*4-1]) |]\n    else\n        [| String(codedChars.[0..n-1]); String(codedChars.[n..n*2-1]); String(codedChars.[n*2..n*3-1]); String(codedChars.[n*3..n*4-1]); String(codedChars.[n*4..nChars-1]) |]\n                    \nlet decode(s: string array): string =\n    let shift = 26 - (int s.[0].[1] - int s.[0].[0])\n    let RotateDown ch =\n        if Char.IsLower(ch) then char (((((int ch) - (int 'a'))+shift)%26)+int 'a')\n        elif Char.IsUpper(ch) then char (((((int ch) - (int 'A'))+shift)%26)+int 'A')\n        else ch\n\n    let decodedParts = s |> Array.map (fun str -> str |> String.map (fun ch -> RotateDown ch))\n    (String.Concat decodedParts).Remove(0,2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84304,"user_id":null,"body":"open System\n\nlet rec contains n = function\n  | [] -> false\n  | x :: xs -> (n = x) || contains n xs\n\nlet encode(s: string) (shift: int): string array =\n  let s0 = char(string(s.[0]).ToLower())\n  \n  (string(s0) + string(char(((int(s0) - 97 + shift) % 26) + 97)) + \n    (s\n    |> String.map (fun x -> \n      if (['a'..'z'] |> contains x) then char(((int(x) - 97 + shift) % 26) + 97)\n      elif (['A'..'Z'] |> contains x) then char(((int(x) - 65 + shift) % 26) + 65)\n      else x\n    ))).ToCharArray()\n  |> Array.chunkBySize(if ((s.Length) + 2 ) % 5 = 0 then (((s.Length) + 2 )\/5) else ((((s.Length) + 2 )\/5) + 1))\n  |> Array.map String.Concat\n  \nlet decode(s0: string array): string =\n  let s = s0 |> String.Concat\n  let shift = int(s.[1]) - int(s.[0])\n  \n  s.[2..]\n  |> String.map (fun x ->\n    if (['a'..'z'] |> contains x) then char(((int(x) - 97 + (26 - shift))%26) + 97)\n    elif (['A'..'Z'] |> contains x) then char(((int(x) - 65 + (26 - shift))%26) + 65)\n    else x\n  )\n\n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84305,"user_id":null,"body":"open System\n\nlet smalls = [| 'a'..'z' |]\nlet bigs = [| 'A'..'Z' |]\n\nlet decodeChar c shift =\n    let chars = if Char.IsLower c then smalls else bigs\n    let index = chars |> Array.findIndex (fun x -> x = c)\n    let rec core index =\n        if index >= 0 then\n            chars.[index]\n        else\n            core (index + 26)\n    core (index - shift)\n\nlet codeChar c shift =\n    let chars = if Char.IsLower c then smalls else bigs\n    let index = chars |> Array.findIndex (fun x -> x = c)\n    chars.[(index + shift) % 26]\n\nlet getRotate first second =\n    let find c = Array.findIndex (fun x -> x = c)\n    let index1 = find first smalls\n    let index2 = find second smalls\n    if index1 > index2 then        \n        index2 + 26 - index1 \n    else\n        index2 - index1\n\nlet buildPriex c shift =\n    let first = Char.ToLower(c)\n    let second = codeChar first shift\n    first.ToString() + second.ToString()\n\nlet getParts (s:string) =\n    let count = if s.Length % 5 = 0 then s.Length \/ 5 else (s.Length \/ 5 + 1)\n    let rec core (rest:string) acc =\n        if rest.Length <= count then\n            rest::acc\n        else\n            core (rest.Substring(count)) (rest.Substring(0,count)::acc)\n    core s [] |> List.rev |> List.toArray\n\n\n\nlet encode(s: string) (shift: int): string array =\n    let priex = buildPriex s.[0] shift\n    let convert c = if Char.IsLetter c then  codeChar c shift else c\n    let result = String.map convert s\n    getParts (priex + result)\n    \nlet decode(s: string array): string =\n    let priex = s.[0].Substring(0,2)\n    let shift = getRotate priex.[0] priex.[1]\n    let unconvert c = if Char.IsLetter c then decodeChar c shift else c\n    let origin = s \n                    |> Array.mapi (fun i x -> if i = 0 then x.Substring(2) else x) \n                    |> Array.map (fun x -> String.map unconvert x)\n                    |> Array.reduce (+)\n    origin","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84306,"user_id":1617,"body":"let code (ss: int) (s: string): string =\n    let shift (a: char) (z: char) (s: int) (c: char): char =\n        let r = (int z - int a + 1)\n        if c >= a && c <= z\n        then char ((r * 1000 + int c - int a + s) % r + int a)\n        else c\n    String.map (shift 'a' 'z' ss >> shift 'A' 'Z' ss) s\n\n\nlet encode (s: string) (sh: int): string array =\n    let f = (string s.[0]).ToLower()\n    f + code sh f + code sh s\n    |> Seq.chunkBySize (int (ceil (double (Seq.length s + 2) \/ 5.0)))\n    |> Seq.map (Seq.map string >> String.concat \"\")\n    |> Seq.toArray\n\n\nlet decode (s: string array): string =\n    let s' = (String.concat \"\" s)\n    let ss = int s'.[1] - int s'.[0]\n    code (-ss) (s'.Substring 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84307,"user_id":null,"body":"open System\n\nlet alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\nlet encode (s: string) (shift: int): string array =\n    let shift = shift % alphabet.Length\n    let desiredLength = s.Length + 2\n\n    let segmentLength =\n        ((desiredLength |> float) \/ 5.0)\n        |> ceil\n        |> int\n\n    let encoded =\n        s\n        |> Seq.map (fun c ->\n            let lower = Char.ToLowerInvariant c\n            match alphabet.IndexOf(lower) with\n            | -1 -> c\n            | _ ->\n                match lower = c with\n                | true -> (alphabet.[(alphabet.IndexOf(c) + shift) % alphabet.Length])\n                | false -> (alphabet.[(alphabet.IndexOf(lower) + shift) % alphabet.Length]) |> Char.ToUpper)\n        |> List.ofSeq\n\n    let prefix1Index = alphabet.IndexOf(Char.ToLower s.[0]) % alphabet.Length\n    let prefix1 = alphabet.[prefix1Index]\n    let prefix2 = alphabet.[(prefix1Index + shift) % alphabet.Length]\n\n    let withPrefix = [ prefix1; prefix2 ] @ encoded\n\n    withPrefix\n        |> Seq.chunkBySize segmentLength\n        |> Seq.map (fun s -> s |> (Seq.toArray >> String))\n        |> Array.ofSeq\n\nlet decode (s: string array): string =\n    let shift = ((s.[0].[1] |> int) - (s.[0].[0] |> int))\n\n    let decoded =\n        s\n        |> String.concat \"\"\n        |> Seq.skip 2\n        |> Seq.map (fun c ->\n            let lower = Char.ToLowerInvariant c\n            match alphabet.IndexOf(lower) with\n            | -1 -> c\n            | _ ->\n                match c = lower with\n                | true ->\n                    let i = (alphabet.IndexOf(c) - shift) % alphabet.Length\n                    alphabet.[if i >= 0 then i else i + alphabet.Length]\n                | false ->\n                    let i = (alphabet.IndexOf(lower) - shift) % alphabet.Length\n                    (alphabet.[if i >= 0 then i else i + alphabet.Length]) |> Char.ToUpper)\n        |> Array.ofSeq\n\n    String(decoded)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84308,"user_id":492,"body":"open System\nopen System.Text\nopen System.Text.RegularExpressions\nopen System.Collections.Generic\n\nlet modd(dividend: int) (divisor: int): int =\n    let modulo = dividend % divisor\n    if modulo < 0 then modulo + divisor else modulo\n    \nlet encodeAux(s: string) (shift: int) (sgn: int): string =\n    let mutable result = new StringBuilder()\n    let ch = Char.ToLower(s.[0])\n    result.Append(ch) |> ignore\n    result.Append((char)((int)'a' + ((int)ch - (int)'a' + shift) % 26)) |> ignore\n    for k in 0 .. (s.Length - 1) do\n        let mutable sVal: int = modd (sgn * shift) 26\n        let mutable ch = s.[k]\n        if ch >= 'A' && ch <= 'Z' then           \n            result.Append((char)((int)'A' + ((int)ch - (int)'A' + sVal) % 26))\n        else if ch >= 'a' && ch <= 'z' then            \n            result.Append((char)((int)'a' + ((int)ch - (int)'a' + sVal) % 26))\n        else result.Append(ch) \n        |> ignore\n    result.ToString()\n    \nlet encode(s: string) (shift: int): string array =\n    let ss = encodeAux s shift 1\n    let rs = new List<string>()\n    let l = ss.Length\n    let lc = l \/ 5\n    let p = if l % 5 <> 0 then lc + 1 else lc\n    for m in Regex.Matches(ss, \".{0,\" + p.ToString() + \"}\") do\n        if rs.Count < 5 && m.Value <> \"\" then \n            rs.Add(m.Value)   \n    rs.ToArray()\n    \nlet decode(s: string array): string =\n    let res = String.Join(\"\", s)\n    let ch1 = res.[0]\n    let ch2 = res.[1]\n    let shift = modd ((int)ch2 - (int)ch1) 26\n    let r = encodeAux (res.Substring(2, res.Length - 2)) shift -1\n    String.Join(\"\", r).Substring(2, res.Length - 2);\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"550f22f4d758534c1100025a":[{"id":84309,"user_id":492,"body":"let rec dir_reduc ls = \n    let opposite (x, y) =\n        match (x, y) with\n        | (\"NORTH\", \"SOUTH\") -> true\n        | (\"SOUTH\", \"NORTH\") -> true\n        | (\"WEST\", \"EAST\")   -> true\n        | (\"EAST\", \"WEST\")   -> true\n        | (_, _)             -> false\n    let rec removePairs (ls: list<string>): list<string> =\n        match ls with\n        | x :: y :: xs -> if (opposite (x, y)) then removePairs xs else x :: (removePairs (y :: xs))\n        | xs -> xs\n    let l = removePairs ls\n    if (l = ls) then ls else dir_reduc l","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84310,"user_id":null,"body":"let opposite x y =\n    match x, y with\n    | \"NORTH\", \"SOUTH\"\n    | \"SOUTH\", \"NORTH\"\n    | \"EAST\", \"WEST\"\n    | \"WEST\", \"EAST\"\n        -> true\n    | _ -> false\n\nlet dir_reduc =\n    let f x = function\n    | [] -> [x]\n    | y :: ys' as ys ->\n        if opposite x y\n        then ys'\n        else x :: ys\n\n    fun xs -> List.foldBack f xs []\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84311,"user_id":null,"body":"let isOpposite pair =\n  match Array.sort pair  with\n  | [| \"NORTH\"; \"SOUTH\" |]\n  | [| \"EAST\"; \"WEST\" |] -> true\n  | _ -> false\n\nlet rec dir_reduc (ls : string list) =\n  match ls |> Seq.windowed 2 |> Seq.tryFindIndex isOpposite with\n  | Some i -> List.append ls.[0..i-1] ls.[i+2..ls.Length-1] |> dir_reduc\n  | None -> ls","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84312,"user_id":null,"body":"let opposite x y =\n    match x, y with\n    | \"NORTH\", \"SOUTH\"\n    | \"SOUTH\", \"NORTH\"\n    | \"EAST\", \"WEST\"\n    | \"WEST\", \"EAST\"\n        -> true\n    | _ -> false\n\nlet dir_reduc =\n    let rec f xs ys =\n        match xs, ys with\n        | [], [] -> []\n        | [], y :: ys' -> f [y] ys'\n        | _ :: _, [] -> List.rev xs\n        | x :: xs', y :: ys' ->\n            if opposite x y\n            then f xs' ys'\n            else f (y :: xs) ys'\n    f []\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84313,"user_id":492,"body":"let rec dir_reduc ls = \n    let opposite (x, y) =\n        match (x, y) with\n        | (\"NORTH\", \"SOUTH\") -> true\n        | (\"SOUTH\", \"NORTH\") -> true\n        | (\"WEST\", \"EAST\")   -> true\n        | (\"EAST\", \"WEST\")   -> true\n        | (_, _)             -> false\n    let rec removePairs (ls: list<string>): list<string> =\n        match ls with\n        | x :: y :: xs -> if (opposite (x, y)) then removePairs xs else x :: (removePairs (y :: xs))\n        | xs -> xs\n    let l = removePairs ls\n    if (l = ls) then ls else dir_reduc l","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84314,"user_id":null,"body":"type NS =\n  | N\n  | S\n\ntype EW =\n  | E\n  | W\n    \ntype D = \n    | NS of NS\n    | EW of EW\n\n[<Literal>]    \nlet East = \"EAST\"\n\n[<Literal>]\nlet West = \"WEST\"\n\n[<Literal>]\nlet North = \"NORTH\"\n\n[<Literal>]\nlet South = \"SOUTH\"\n\nlet parseText input =\n  match input with\n  | North -> NS (N) \n  | South -> NS (S)\n  | East -> EW (E)\n  | West -> EW (W)\n  | _ -> failwith \"Wrong text\"\n  \nlet parseSymbol input =\n  match input with\n  | NS ns ->    \n    match ns with\n    | N -> North\n    | S -> South\n  | EW ew ->    \n    match ew with\n    | E -> East\n    | W -> West\n    \nlet concatIfSame a b preConcat acc =\n   if a = b then (preConcat a)::((preConcat b)::acc) else acc \n\nlet folder acc item =\n  match acc with\n  | [] -> item::acc\n  | fst:: rest -> match (item, fst) with  \n                  |(NS a, NS b) -> concatIfSame a b (fun a -> NS a) rest\n                  |(EW a, EW b) -> concatIfSame a b (fun a -> EW a) rest \n                  |_ -> item::acc\n        \nlet rec innerReduce ls =\n let result = List.fold folder [] ls |> List.rev\n if result <> ls then\n    innerReduce result\n else\n    result\n    \nlet dir_reduc ls =\n ls |> List.map parseText |> innerReduce |> List.map parseSymbol","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84315,"user_id":527,"body":"let opposite = function\n  | \"NORTH\" -> \"SOUTH\"\n  | \"SOUTH\" -> \"NORTH\"\n  | \"EAST\" -> \"WEST\"\n  | \"WEST\" -> \"EAST\"\n  | _ -> failwith \"invalid direction\"\n\nlet dir_reduc (dirs: string list): string list = \n  let f = fun curDir prevDirs ->\n    match prevDirs with\n      | d :: ds when d = opposite curDir -> ds\n      | _ -> curDir :: prevDirs\n  List.foldBack f dirs []\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84316,"user_id":null,"body":"let opposite dir =\n  match dir with\n    | \"NORTH\" -> \"SOUTH\"\n    | \"SOUTH\" -> \"NORTH\"\n    | \"WEST\" -> \"EAST\"\n    | \"EAST\" -> \"WEST\"\n    | _ -> failwith \"Unknown Direction.\"\n  \nlet areOpposites dir1 dir2 =\n  dir2 = (opposite dir1)\n\nlet doReduce ls =\n  let mutable stack = []\n  for dir in ls do\n    stack <- dir :: stack\n    stack <- \n      match stack with\n        | first :: (second :: rest) when (areOpposites first second) -> rest\n        | _ -> stack\n      \n  stack |> List.rev\n      \n  \nlet rec dir_reduc ls =\n  let reduced = doReduce ls\n  if List.length ls = List.length reduced then\n    reduced\n  else\n    dir_reduc reduced","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84317,"user_id":null,"body":"let areOpposite a b =\n    match a with\n    | \"NORTH\" -> b = \"SOUTH\"\n    | \"SOUTH\" -> b = \"NORTH\"\n    | \"WEST\" -> b = \"EAST\"\n    | \"EAST\" -> b = \"WEST\"\n    | _ -> failwith \"unreachable\"\n    \nlet rec dir_reduc ls =\n    match ls with\n        | [] -> []\n        | [single] -> [single]\n        | h1::t -> \n            let reduced = dir_reduc t \n            match reduced with \n                | [] -> [h1]\n                | [single] -> if areOpposite h1 single then [] else h1::[single]\n                | h::t -> if areOpposite h1 h then t else h1::h::t","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84318,"user_id":null,"body":"let isNextOpposite fst snd =\n    match fst with\n    | \"NORTH\" ->\n        match snd with\n        | \"SOUTH\" -> true\n        | _ -> false\n    | \"SOUTH\" ->\n        match snd with\n        | \"NORTH\" -> true\n        | _ -> false\n    | \"EAST\" ->\n        match snd with\n        | \"WEST\" -> true\n        | _ -> false\n    | \"WEST\" ->\n        match snd with\n        | \"EAST\" -> true\n        | _ -> false\n    | _ -> false\n    \nlet rec reducer ls =\n    match ls with\n    | [] -> []\n    | head::tail ->\n        match tail with\n        | [] -> ls\n        | _ ->\n            match isNextOpposite head tail.Head with\n            | true -> reducer ([] @ tail.Tail)\n            | false -> [head] @ (reducer tail)\n\nlet rec reduceWhileChanged (ls : string list) =\n    let reducedList = reducer ls\n    match ls.Length = reducedList.Length with\n    | true -> ls\n    | false -> reduceWhileChanged reducedList\n\n\nlet dir_reduc (ls : string list) =\n    reduceWhileChanged ls","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5517fcb0236c8826940003c9":[{"id":84319,"user_id":null,"body":"let rec gcd x y =\n  if y = 0 then x\n  else gcd y (x%y)\n\nlet reduceAndFormat (x, y) =\n  let divisor = gcd x y\n  let (a, b) = (x\/divisor, y\/divisor)\n  if b = 1 then string a\n  else string(a) + \" \" + string(b)\n\nlet rec sumFracts xs =\n  match xs with\n  | [] -> None\n  | [x] -> Some(reduceAndFormat x)\n  | (a1, a2)::(b1, b2)::c -> (a1*b2 + b1*a2, a2*b2)::c |> sumFracts","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84320,"user_id":53,"body":"let rec gcd x y = if y = 0 then x else gcd y (x % y)\nlet sumFracts xss =\n  let d = xss |> List.fold (fun acc xs -> (snd xs) * acc) 1\n  let n = xss |> List.fold (fun acc xs -> (fst xs) * d \/ (snd xs) + acc) 0\n  let g = gcd n d\n  if List.isEmpty xss then\n    None\n  elif g = d then\n    Some (sprintf \"%d\" (n \/ g))\n  else\n    Some (sprintf \"%d %d\" (n \/ g) (d \/ g))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84321,"user_id":null,"body":"let rec gcd a b = if b = 0 then a else gcd b (a % b)\n\nlet lcm a b =\n    if a = 0 || b = 0 then\n        0\n    else\n        (a * b) \/ (gcd a b)\n\nlet convertFracts (l: (int * int) list) =\n    let denominators = l |> List.map snd\n    let firstDen = denominators |> List.head\n    let commonDen = denominators |> List.fold lcm firstDen\n\n    l\n    |> List.map (fun (num, den) -> ((num * (commonDen \/ den)), commonDen))\n\nlet reduceFractions (num, den) =\n    let g = gcd num den\n    let reducedDen = den \/ g\n    let reducednum = num \/ g\n    (reducednum, reducedDen)\n\nlet sumFracts xs =\n    match xs with\n    | [] -> None\n    | _ ->\n        let it = convertFracts xs\n\n        let sum =\n            it\n            |> List.fold (fun (finalNum, _final_den) (num, den) -> finalNum + num, den) (0, 1)\n\n        let reducedNum, reducedDen = reduceFractions sum\n        if reducedDen = 1 then\n            Some    (sprintf \"%d\" reducedNum)\n        else\n            Some(sprintf \"%d %d\" reducedNum reducedDen)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84322,"user_id":null,"body":"let sumFracts (xs: (int * int) list) : string option =\n  let rec getGCD a b =\n    match a with\n    | 0 -> b\n    | _ -> getGCD (b%a) a \n    \n  if (xs |> List.length < 1) then None\n  else\n    let denominator = snd (xs |> List.fold (fun x y -> (1, (snd x) * (snd y))) (1, 1))\n    let rv = (xs \n    |> List.map (fun (f, s) -> ((f*(denominator\/s)), denominator)) \n    |> List.fold (fun (f, s) (fd, sd) -> (f+fd, sd)) (0, denominator))\n    let gcd = getGCD (fst rv) (snd rv)\n    let a = ((fst rv)\/gcd)\n    let b = ((snd rv)\/gcd)\n    match a%b with\n    | 0 -> Some (a\/b |> string)\n    | _ -> Some ((a |> string) + \" \" + (b |> string))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84323,"user_id":null,"body":"let rec gcd a b = if b=0 then a else gcd b (a%b)\nlet lcm a b = a*b \/ gcd a b\n\nlet sumFracts xs =\n    if Seq.length xs = 0 then None\n    else\n        let iden = xs |> Seq.map snd |> Seq.reduce lcm\n        let inum = xs |> Seq.map (fun (n,d) -> n*iden\/d) |> Seq.sum\n        let igcd = gcd inum iden\n        let den = iden \/ igcd\n        let num = inum \/ igcd\n        if den = 1 then\n            string num |> Some\n        else\n            string num + \" \" + string den |> Some\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84324,"user_id":null,"body":"let fractSum (a, c) (b, d) = (a*d + b*c), c*d\n\nlet reduce (a, b) =\n    seq { min a b .. -1 .. 1 }\n    |> Seq.find (fun x -> a % x = 0 && b % x = 0)\n    |> fun x -> a \/ x, b \/ x\n    \nlet sumFracts xs =\n  if List.isEmpty xs then None\n  else\n    xs\n    |> List.fold fractSum (0, 1)\n    |> reduce\n    |> function\n      | (a, 1) -> string a\n      | (a, b) -> sprintf \"%d %d\" a b\n    |> Some","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84325,"user_id":null,"body":"let rec gcd a b =\n    if b = 0 then a\n    else gcd b (a % b)\nlet sumFracts xs =\n    match xs with\n    | [] -> None\n    | xs ->\n        let factorBy = xs\n                     |> List.map snd\n                     |> List.fold (*) 1\n        let  m = xs\n                    |> List.map (fun (a,b) -> a * (factorBy \/ b))\n                    |> List.sum\n                    \n        if m % factorBy = 0 then Some ((m \/ factorBy).ToString())\n        else\n            let gcdN = gcd m factorBy\n            Some (((m \/ gcdN).ToString()) + \" \" + (factorBy \/ gcdN).ToString())","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84326,"user_id":null,"body":"let rec GCD (a:int) (b:int): int = \n  if (b = 0) then a\n  else\n    if (a > b) then GCD b (a%b)\n    else GCD a (b%a)\n\nlet reduceFraction (num:int, den:int): int*int = \n  let divisor = GCD num den\n  (num\/divisor, den\/divisor)\n  \nlet sumFractions (num1:int, den1:int) (num2:int, den2:int): int*int = \n  reduceFraction (num1*den2 + num2*den1, den1 * den2)\n\nlet sumFracts xs =\n  if (List.isEmpty xs) then None\n  else \n    let (num, den) = List.fold sumFractions (0, 1) xs\n    let result =\n      if (den = 1) then string num\n      else (string num) + \" \" + (string den)\n    (Some result)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84327,"user_id":null,"body":"let sumFracts (xs:(int*int) list) =\n    match xs.Length with\n    | 0 -> None\n    | _ ->\n        let rec GCD x y =   \/\/ greatest common divisor, Euclid's method\n            if y = 0 then x\n            else GCD y (x % y)\n        let commonDenominator = xs |> List.fold (fun reducedDenominator pair -> reducedDenominator * (snd pair) \/ (GCD reducedDenominator (snd pair))) (snd xs.[0])\n        let numerator         = xs |> List.fold (fun numeratorSoFar pair -> numeratorSoFar + (fst pair) * commonDenominator \/ (snd pair)) 0\n        if numerator%commonDenominator=0 then\n            Some (sprintf \"%d\" (numerator\/commonDenominator))\n        else\n            let gcd = GCD numerator commonDenominator\n            Some (sprintf \"%d %d\" (numerator\/gcd) (commonDenominator\/gcd))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84328,"user_id":null,"body":"let simpl (a, b) =\n  [(min a b)..(-1)..1] |> List.filter (fun x -> a % x = 0 && b % x = 0) |>\n  List.head |> (fun x -> (a \/ x, b \/ x))\n\nlet sumFracts xs =\n  if (List.isEmpty xs) then\n    None\n  else\n    xs |> List.fold (fun (a,b) (c,d) -> (simpl (a * d + b * c, b * d))) (0,1) |>\n    (fun (a,b) -> if b = 1 then Some(sprintf \"%d\" a) else Some(sprintf \"%d %d\" a b))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5536a85b6ed4ee5a78000035":[{"id":84329,"user_id":null,"body":"open System\n\nlet tour(arrFriends: string[]) (ftwns: string[][]) (h: Map<string, float>): int =\n  let originTwn = \"X0\"\n  let twnOfFriend friend =\n    Array.tryFind (fun pair -> (Array.head pair) = friend) ftwns\n    |> function\n      | Some(x) -> x |> Array.tail |> Array.head |> Some\n      | None -> None\n  let distance (twn1,twn2) =\n    if (twn1 = originTwn) then h.[twn2]\n    elif (twn2 = originTwn) then h.[twn1]\n    else (h.[twn1])**2.0 - (h.[twn2])**2.0 |> Math.Abs |> Math.Sqrt\n  let result =\n    seq {\n      yield originTwn\n      yield! arrFriends |> Seq.map twnOfFriend |> Seq.choose id\n      yield originTwn\n    }\n      |> Seq.pairwise\n      |> Seq.map distance\n      |> Seq.sum\n  int (Math.Floor result)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84330,"user_id":null,"body":"#nowarn \"25\"\nlet tour(arrFriends: string[]) (ftwns: string[][]) (h: Map<string, float>) =\n    let towns =\n        arrFriends\n        |> Seq.map (fun friend -> ftwns |> Seq.tryFind (fun [| f; _ |] -> f = friend))\n        |> Seq.choose id\n        |> Seq.map (fun [| _; t |] -> t)\n\n    Seq.windowed 2 towns\n        |> Seq.map (fun [| t1; t2 |] -> sqrt (h.[t2] * h.[t2] - h.[t1] * h.[t1]))\n        |> Seq.sum\n        |> (+) (h.[Seq.head towns] + h.[Seq.last towns])\n        |> floor |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84331,"user_id":null,"body":"let parseFriendTowns (ftwns: string[][]) =\n    let parseTown = function\n        | [| friend; town |] -> Some(friend, town)\n        | _ -> None\n    ftwns |> Array.map parseTown |> Array.choose id\n\nlet tour(arrFriends: string[]) (ftwns: string[][]) (h: Map<string, float>): int =\n    let towns = ftwns |> parseFriendTowns\n    let findTown (f:string) = Array.tryFind (fst >> ((=) f)) towns\n    let distBetweenTowns (b, c) = (c**2.0) - (b**2.0) |> sqrt\n    \n    let disctances = \n        arrFriends\n        |> Array.map findTown\n        |> Array.choose id\n        |> Array.map snd\n        |> Array.map (fun t -> h.Item t)\n        \n    match disctances with\n    | [| |] -> 0\n    | [| x |] -> x * 2.0 |> floor |> int\n    | x ->\n        let distTowns = x |> Array.pairwise |> Array.map distBetweenTowns |> Array.sum\n        x.[0] + distTowns + (Array.last x) |> floor |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84332,"user_id":null,"body":"open System\n\nlet tour(arrFriends: string[]) (ftwns: string[][]) (h: Map<string, float>): int =\n    let map = h |> Seq.map (fun x -> (Int32.Parse(x.Key.Substring(1)), x.Value))\n                |> Map.ofSeq\n\n    let getTown f =\n       ftwns\n       |> Seq.filter (fun ft -> ft.[0] = f)\n       |> Seq.map (fun ft -> Int32.Parse(ft.[1].Substring(1)))\n       |> Seq.head\n        \n    let path = 0::(arrFriends\n                    |> Seq.filter (fun f -> ftwns |> Seq.filter (fun ft -> ft.[0] = f) |> Seq.isEmpty |> not)    \n                    |> Seq.map getTown\n                    |> Seq.toList)\n                  @ [0]\n\n    let fromX0 x = map.[x]\n\n    let rec distance (a, b) =\n            let square x = pown x 2\n            match a, b with\n            | 0, _ -> fromX0 b\n            | _, 0 -> fromX0 a\n            | _ when b < a -> distance (a, b)\n            | _ -> sqrt ((b |> fromX0 |> square) - (a |> fromX0 |> square))\n        \n    path \n    |> List.pairwise\n    |> List.sumBy distance\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84333,"user_id":null,"body":"let tour(arrFriends: string[]) (ftwns: string[][]) (townDistances: Map<string, float>): int =\n    let arrayToTuple (arr: 'a[]) = arr.[0], arr.[1]\n    let friendTownsMap = ftwns |> Seq.map arrayToTuple |> Map.ofSeq\n    let townsToVisit =\n        arrFriends\n        |> Array.choose (fun friend -> Map.tryFind friend friendTownsMap)\n    let distToTown town = Map.find town townDistances\n    let distBetweenTowns (t1, t2) =\n        let dist1, dist2 = distToTown t1, distToTown t2\n        sqrt (pown dist2 2 - pown dist1 2)\n    let distToFirstTown = Array.head townsToVisit |> distToTown\n    let distToLastTown = Array.last townsToVisit |> distToTown\n    let distFirstThruLastTown =\n        townsToVisit\n        |> Seq.pairwise\n        |> Seq.sumBy distBetweenTowns\n    distToFirstTown + distFirstThruLastTown + distToLastTown |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84334,"user_id":1152,"body":"open System.Linq\n\nlet missingSide (a: float, b: float): float =\n    a**2.0 - b**2.0\n    |> abs\n    |> sqrt\n\nlet toTuple (arr: string[]) =\n    (arr.[0], arr.[1])\n    \nlet findDist map key =\n    Map.find key map\n\nlet tour(friends: string[]) (towns: string[][]) (dist: Map<string, float>): int =\n    let townMap = towns |> Array.map toTuple |> Map.ofArray\n    let distances =\n        friends\n        |> Seq.map townMap.TryFind\n        |> Seq.choose id\n        |> Seq.map (findDist dist)\n    let seed = distances.First() + distances.Last()\n    distances\n    |> Seq.pairwise\n    |> Seq.map missingSide\n    |> Seq.fold (+) seed\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84335,"user_id":null,"body":"open System\n\nlet originTwn = \"X0\"\nlet tour(arrFriends: string[]) (ftwns: string[][]) (h: Map<string, float>): int =\n  let twnOfFriend friend =\n    try\n      Array.find (fun pair -> (Array.head pair) = friend) ftwns\n        |> Array.tail |> Array.head\n    with\n      | _ -> originTwn\n  let distance twn1 twn2 =\n    if (twn1 = twn2) then 0.0\n    elif (twn1 = originTwn) then float h.[twn2]\n    elif (twn2 = originTwn) then float h.[twn1]\n    else (h.[twn1])**2.0 - (h.[twn2])**2.0 |> Math.Abs |> Math.Sqrt\n  let result =\n    (originTwn::List.map twnOfFriend (Array.toList arrFriends)) @ [originTwn]\n        |> List.pairwise\n        |> List.map (fun (t1,t2) -> distance t1 t2)\n        |> List.sum\n  int (Math.Floor result)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84336,"user_id":null,"body":"let tour(arrFriends: string[]) (ftwns: string[][]) (h: Map<string, float>): int =    \n    let getDistance friend =                    \n        ftwns \n        |> Seq.tryFind (fun x -> x.[0] = friend) \n        |> Option.map(fun pair -> h.[pair.[1]])        \n    let distances = \n        arrFriends \n        |> Seq.map getDistance \n        |> Seq.filter (fun x -> x.IsSome) \n        |> Seq.map (fun x -> float x.Value)\n    let first = distances |> Seq.item 0\n    let last = distances |> Seq.last    \n    distances        \n    |> Seq.pairwise\n    |> Seq.fold (fun acc (x, y) -> acc + sqrt (y*y - x*x)) (first + last)\n    |> floor\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84337,"user_id":null,"body":"let tour (arrFriends: string []) (ftwns: string [] []) (h: Map<string, float>): int =\n    let townMap =\n        ftwns\n        |> Seq.map (fun a -> (a.[0], a.[1]))\n        |> Map.ofSeq\n\n    let dist f = (h |> Map.find (townMap |> Map.find f))\n\n    let knownFriends = arrFriends |> Array.filter (fun f -> townMap |> Map.containsKey f)\n\n    knownFriends\n    |> Seq.windowed 2\n    |> Seq.sumBy (fun [| f1; f2 |] ->\n        let a = f1 |> dist\n        let b = f2 |> dist\n        sqrt ((b * b) - (a * a)))\n    |> (+)\n        (knownFriends\n         |> Array.head\n         |> dist)\n    |> (+)\n        (knownFriends\n         |> Array.last\n         |> dist)\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84338,"user_id":null,"body":"open System\n\nlet rec travel friends townMap distances currentTown currentDistance =\n    match friends with\n    | [] ->\n        \/\/ last town visited, return home\n        let distance = distances |> Map.find currentTown\n        currentDistance + distance\n    | friend :: tail when currentTown = \"X0\" ->\n        \/\/ starting town, the distance is in the map\n        let nextTown = townMap |> Map.find friend\n        let distance = distances |> Map.find nextTown\n        travel tail townMap distances nextTown (currentDistance + distance)\n    | friend :: tail ->\n        \/\/ on the road - need some trigonometry here\n        match townMap |> Map.tryFind friend with\n        | None ->\n            \/\/ no idea where this friend lives - skipping\n            travel tail townMap distances currentTown currentDistance\n        | Some(nextTown) ->\n            let adjacent = distances |> Map.find currentTown\n            let hypotenuse = distances |> Map.find nextTown\n            let angle = Math.Acos(adjacent \/ hypotenuse)\n            let distance = Math.Sin(angle) * hypotenuse\n\n            travel tail townMap distances nextTown (currentDistance + distance)\n\nlet tour (arrFriends: string []) (ftwns: string [] []) (h: Map<string, float>): int =\n    let townMap =\n        ftwns\n        |> Seq.map (fun a -> (a.[0], a.[1]))\n        |> Map.ofSeq\n\n    travel (arrFriends |> List.ofArray) townMap h \"X0\" 0.0 |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5539fecef69c483c5a000015":[{"id":84339,"user_id":492,"body":"let backwards_prime (m: int64) (n: int64) =\n    let isPrime (n: int64) =\n        if (n = 2L) then true\n        else\n            if (n % 2L = 0L) then false\n            else\n                let sq = (float >> sqrt >> int64) n\n                [ 3L ..2L.. sq ] |> List.forall (fun x -> n % x <> 0L)\n    let reverseNb =\n        Seq.unfold(fun x-> if x = 0L then None else Some(x % 10L, x \/ 10L)) >> Seq.toList >> List.reduce(fun a b -> a * 10L + b)\n    [ for x in m .. n do\n        let rx = reverseNb x\n        if (isPrime x && rx <> x && isPrime(rx)) then yield x\n    ]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:05:53"},{"id":84340,"user_id":53,"body":"let backwards_prime (m: int64) (n: int64) =\n    let maxFactor num = int64 (sqrt (float num))\n    let isPrime num = not (Seq.exists (fun f -> num % f = 0L) (seq {2L..maxFactor num}))\n    let reverse num =\n      let rec reverseHelper num acc =\n         match num with\n         | 0L -> acc\n         | _ -> reverseHelper (num \/ 10L) (acc * 10L + num % 10L)\n      reverseHelper num 0L\n    let isPalindromic num =\n      num = reverse num\n    [m..n]\n        |> List.filter (fun x -> isPrime x && (not (isPalindromic x)) && isPrime (reverse x))","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:05:58"},{"id":84341,"user_id":492,"body":"let backwards_prime (m: int64) (n: int64) =\n    let isPrime (n: int64) =\n        if (n = 2L) then true\n        else\n            if (n % 2L = 0L) then false\n            else\n                let sq = (float >> sqrt >> int64) n\n                [ 3L ..2L.. sq ] |> List.forall (fun x -> n % x <> 0L)\n    let reverseNb =\n        Seq.unfold(fun x-> if x = 0L then None else Some(x % 10L, x \/ 10L)) >> Seq.toList >> List.reduce(fun a b -> a * 10L + b)\n    [ for x in m .. n do\n        let rx = reverseNb x\n        if (isPrime x && rx <> x && isPrime(rx)) then yield x\n    ]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:06:04"},{"id":84342,"user_id":null,"body":"let backwards_prime (low: int64) (high: int64) =\n    let reverse num =\n        num\n        |> string\n        |> Seq.toArray \n        |> Seq.rev\n        |> Seq.map string\n        |> String.concat \"\"\n        |> int64\n    let isPrime n = \n        let sqrt' = (float >> sqrt >> int64) n\n        [ 2L .. sqrt' ]\n        |> List.forall (fun x -> n % x <> 0L)\n    let test n =\n        match n with\n        | n when n % 2L = 0L -> false\n        | n when not (isPrime n) -> false\n        | _ ->\n            let backwards = reverse n\n            n <> backwards && isPrime backwards\n    [low .. high]\n    |> Seq.filter test\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:01:39"},{"id":84343,"user_id":null,"body":"open System\n\nlet backwards_prime (m: int64) (n: int64) =\n  let isPrime (num: int64)=\n    match num with\n    | 1L -> true\n    | 2L -> true\n    | _ ->\n      [2L..(int64 << Math.Sqrt << float) num]\n      |> Seq.forall (fun i -> (num % i) <> 0L)\n      \n  let backward =\n    string\n       >> Seq.mapi (fun i d -> ((Int64.Parse << string ) d) * (int64 (10.0 ** (float i))))\n       >> Seq.sum\n  \n  printfn \"m: %A, n: %A\" m n\n  \n  [m..n]\n  |> Seq.filter (fun x-> backward x <> x)\n  |> Seq.filter (fun x -> x % 10L <> 0L)\n  |> Seq.map (fun x -> (if backward x > x then x else backward x), x)\n  |> Seq.filter (fst >> isPrime)\n  |> Seq.filter (fst >> backward >> isPrime)\n  |> Seq.map snd\n  |> Seq.toList\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:01:39"},{"id":84344,"user_id":null,"body":"let isPrime (n: int64) =\n    let sqrtn n = int64 <| sqrt (float n)\n    seq { 2L .. sqrtn n } |> Seq.exists(fun i -> n % i = 0L) |> not\n\nlet rec allPrime a b =\n    if a > b then [] else\n      let rest = allPrime (a + 1L) b in\n      if isPrime a then a :: rest else rest;;\n      \nlet reverseInt (n: int64) =\n    n.ToString()\n    |> Seq.rev\n    |> Seq.toArray\n    |> System.String.Concat\n    |> int64\n    \nlet backwards_prime m n =\n    allPrime m n\n    |> List.filter (reverseInt >> isPrime)\n    |> List.filter (fun m -> m <> reverseInt m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:01:39"},{"id":84345,"user_id":null,"body":"let backwards_prime m n =\n        let isPrime x =\n            if x = 2L then true\n            else 2L::[3L..2L..(x |> float |> sqrt |> ceil |> int64)]\n                |> Seq.exists (fun y -> x % y = 0L)\n                |> not\n            \n        let backwards x = System.String(x |> string |> Seq.rev |> Seq.toArray) |> int64\n                \n        let isPalindrome x = x |> backwards = x\n        \n        [m..n]\n        |> List.filter (fun x -> x |> isPalindrome |> not)\n        |> List.filter (fun x -> x |> isPrime)\n        |> List.filter (fun x -> x |> backwards |> isPrime)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:01:39"},{"id":84346,"user_id":null,"body":"let backwards_prime (m: int64) (n: int64) =\n  let isPrime x =\n    x > 1L && Seq.forall (fun n -> x % n <> 0L) {2L..x |> float |> sqrt |> int64}\n  let isbackwards_prime x =\n    let y = x |> string |> Seq.rev |> System.String.Concat |> int64\n    isPrime x && isPrime y && x <> y\n  List.filter isbackwards_prime [m..n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:06:30"},{"id":84347,"user_id":null,"body":"open System\n\nlet isBackwardPrime (x: int64) =\n  let isPrime (x: int64) =\n    let rec getDiv (x: int64) (ind: int64) =\n      match ind with\n      | ind when (x < 2L)        -> false\n      | ind when (ind * ind > x) -> true\n      | ind when (x % ind = 0L)  -> false\n      | _                        -> (getDiv x (ind + 1L))\n    (getDiv x 2L)\n  let revx = x.ToString() |> Seq.map (Char.GetNumericValue >> int64) |> Seq.rev |> Seq.fold (fun acc x -> acc * 10L + x) 0L\n  (revx <> x) && (isPrime x) && (isPrime revx)\n\nlet backwards_prime (m: int64) (n: int64) =\n    [m..n] |> List.filter isBackwardPrime","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:01:39"},{"id":84348,"user_id":null,"body":"let backwards x =\n    new System.String(x |> string |> Seq.rev |> Seq.toArray) |> int64\n\nlet isPalindrome x =\n    x |> backwards = x\n\nlet isPrime x =\n    if x = 2L\n    then true\n    else 2L::[3L..2L..(x |> float |> sqrt |> ceil |> int64)]\n        |> Seq.exists (fun y -> x % y = 0L)\n        |> not\n\nlet backwards_prime minValue maxValue =\n    [minValue..maxValue]\n    |> List.filter (fun x -> x |> isPalindrome |> not)\n    |> List.filter (fun x -> x |> isPrime)\n    |> List.filter (fun x -> x |> backwards |> isPrime)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:01:39"}],"5541f58a944b85ce6d00006a":[{"id":84349,"user_id":null,"body":"let product_fib (n: uint64) =\n  let rec fib first second =\n    match (first*second) with\n    | p when p > n -> (first, second, false)\n    | p when p = n -> (first, second, true)\n    | _ -> fib second (first+second)\n    \n  fib 1UL 1UL","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84350,"user_id":492,"body":"let product_fib (n: uint64) =\n    let rec loop (a: uint64) (b: uint64) (c: uint64) =\n        if (a * b >= c) then (a, b, a * b = c)\n        else loop b (a + b) c\n    loop 0UL 1UL n\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84351,"user_id":null,"body":"let product_fib n =\n    let rec check x y =\n        if x * y >= n then (x, y, x * y = n) else check y (x + y)\n    check 0UL 1UL","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84352,"user_id":null,"body":"let product_fib (n: uint64)=\n    let fibSeq = Seq.unfold (fun (a,b) -> Some((a, b), (b, a+b))) (0UL,1UL)\n    let left, right = fibSeq |> Seq.findIndex (fun a -> fst a * snd a >= n) |> Seq.item <|fibSeq\n    (left, right, left * right = n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84353,"user_id":492,"body":"let product_fib (n: uint64) =\n    let rec loop (a: uint64) (b: uint64) (c: uint64) =\n        if (a * b >= c) then (a, b, a * b = c)\n        else loop b (a + b) c\n    loop 0UL 1UL n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84354,"user_id":null,"body":"let product_fib (n: uint64) =\n   let fs = Seq.unfold (fun (a,b) -> Some ((a,b,a*b=n), (b, a+b))) (0UL, 1UL)\n   fs |> Seq.find (fun (f1,f2,p) -> p || f1*f2 > n)\n                            ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84355,"user_id":53,"body":"open System\n\nlet product_fib (n: uint64) =\n  let phi = (1.0 + Math.Sqrt(5.0)) \/ 2.0\n  let k = Math.Sqrt(Convert.ToDouble(n))\n  let m = Math.Floor(Math.Log(k * Math.Sqrt(5.0)) \/ Math.Log(phi))\n  let a = Convert.ToUInt64(Math.Round(Math.Pow(phi, m) \/ Math.Sqrt(5.0)))\n  let b = Convert.ToUInt64(Math.Round(Math.Pow(phi, m + 1.0) \/ Math.Sqrt(5.0)))\n  if a * b = n then\n    (a, b, true)\n  else if a * b > n then\n    (a, b, false)\n  else\n    (b, Convert.ToUInt64(Math.Round(Math.Pow(phi, m + 2.0) \/ Math.Sqrt(5.0))), false)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84356,"user_id":null,"body":"let product_fib (n: uint64) =\n  let mutable a = 0UL\n  let mutable b = 1UL\n  let mutable prod = a * b\n  \n  while (prod < n) do\n    let temp = b\n    b <- a + b\n    a <- temp\n    prod <- a * b\n    \n  (a, b, (prod = n))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84357,"user_id":null,"body":"let product_fib (n: uint64) =\n    let p1, p2 =\n        Seq.unfold (fun (l1, l2) -> Some(l1, (l2, l1 + l2))) (0UL, 1UL)\n        |> Seq.pairwise\n        |> Seq.skipWhile (fun (f1, f2) -> f1 * f2 < n)\n        |> Seq.head\n    \/\/ your code\n    if p1 * p2 = n then\n        (p1, p2, true)\n    else\n        (p1, p2, false)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84358,"user_id":null,"body":"let product_fib (n: uint64) =\n    (1UL, 1UL)\n    |> Seq.unfold (fun (a, b) -> Some(a, (b, a + b)))\n    |> Seq.pairwise\n    |> Seq.skipWhile(fun (a, b) -> a * b < n)\n    |> Seq.take 1\n    |> Seq.last\n    |> fun (a, b) -> (a, b, a * b = n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5544c7a5cb454edb3c000047":[{"id":84359,"user_id":null,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n  if h > 0.0 && 0.0 < bounce && bounce < 1.0 && window < h then 2 + bouncing_ball (h * bounce) bounce window\n  else -1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84360,"user_id":492,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n    if ((h <= 0.0) || (window >= h) || (bounce <= 0.0) || (bounce >= 1.0)) then -1\n    else 2 + (bouncing_ball (h * bounce) bounce window)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84361,"user_id":null,"body":"let bouncing_ball (height: float) (bounce: float) (window: float) =\n  let rec calculate h count = \n    if h <= window || bounce = 1.0 || bounce = 0.0 then count\n    else calculate (h*bounce) (count + 1)\n  1 + 2 * calculate height -1","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84362,"user_id":527,"body":"let bouncing_ball (h:float) (bounce:float) (window:float) =\n  if not (h > 0. && 0. < bounce && bounce < 1. && window < h) then -1\n  else (log (window \/ h) \/ log bounce |> ceil |> int) * 2 - 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84363,"user_id":null,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n  match (h, bounce, window) with\n    | (x, _, _) when x <= 0.0 -> -1\n    | (_, x, _) when x <= 0.0 -> -1\n    | (_, x, _) when x >= 1.0 -> -1\n    | (x, _, y) when x <= y -> -1\n    | _ -> \n      let bounceHeight = h * bounce\n\n      if bounceHeight > window then\n        2 + bouncing_ball bounceHeight bounce window \n      else 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84364,"user_id":null,"body":"let checks h bounce window =\n    if h <= 0. then false\n    elif bounce <= 0. || bounce >= 1. then false\n    elif window >= h then false\n    else true\n\nlet rec solve h bounce window = \n    if h > window then \n        let newh = h * bounce\n        if newh <= window then 1u else (solve newh bounce window) + 2u\n    elif h = window then 1u\n    else 0u\n    \nlet bouncing_ball (h: float) (bounce: float) (window: float) =\n    if not (checks h bounce window) then -1\n    else int (solve h bounce window)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84365,"user_id":null,"body":"let bouncing_ball (h: float) (bounce: float) (window: float) =\n  if (h <= 0.) then -1\n  else if (bounce <= 0. || bounce >= 1.) then -1\n  else if (window >= h) then -1\n  else if (window <= 0.) then 0\n  else\n      let rec bounceNow (h: float) (bounce: float) (window: float) =\n        \/\/printfn \"bounceNow %f\" h\n        if (h>window) then 2+bounceNow (h*bounce) bounce window\n        else -1\n      bounceNow h bounce window\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84366,"user_id":null,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n    match h, bounce, window with\n    | h, _, _  when h <= 0. -> -1\n    | _, b, _ when b <= 0. || b >= 1. -> -1\n    | h, _, w when w >= h -> -1\n    | h, b, w when h * b < w -> 1\n    | h, b, w -> 2 + bouncing_ball (h * b)  b w","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84367,"user_id":null,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n  if h <= 0.0 || bounce <= 0.0 || bounce >= 1.0 || h <= window then\n    -1\n  else\n    2 + (bouncing_ball (h*bounce) bounce window)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84368,"user_id":null,"body":"let rec bouncing_ball2 (h: float) (bounce: float) (window: float) =\n  match (h, bounce, window) with\n  | (h,b,w) when (h * b) > w -> 2 + bouncing_ball2 (h * b) b w\n  | _ -> 1\n\nlet bouncing_ball (h: float) (bounce: float) (window: float) =\n  match (h, bounce, window) with\n  | (h,b,w) when not (h > 0.0) || not (b > 0.0) || not (b < 1.0) || not (w < h) -> -1\n  | (h,b,w) -> bouncing_ball2 h b w\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5545f109004975ea66000086":[{"id":84369,"user_id":645,"body":"let is_divisible n x y = n % x = 0 && n % y = 0","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84370,"user_id":2255,"body":"let is_divisible n x y =\n  n % y = 0 && n % x = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84371,"user_id":1566,"body":"let is_divisible n x y = n%x + n%y = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84372,"user_id":null,"body":"let is_divisible n x y =\n    n % x + n % y < 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84373,"user_id":null,"body":"let is_divisible n x y =\n    if (n % x = 0) then\n        if (n % y = 0) then true else false\n    else\n        false\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84374,"user_id":null,"body":"let is_divisibleBy n x = n % x = 0\nlet is_divisible n x y = is_divisibleBy n x && is_divisibleBy n y","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84375,"user_id":null,"body":"let is_divisible n x y =\n    \/\/ 0<int 0<int 0<int -> bool\n    \/\/ return true if n is divisible by both x and y\n    n % x = 0 && n % y = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84376,"user_id":null,"body":"let is_divisible n x y =\n    match (n % x = 0 && n % y = 0) with\n    | true -> true\n    | false -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84377,"user_id":null,"body":"let is_divisible n x y = n % y = 0 && 0 = n % x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84378,"user_id":null,"body":"let is_divisible n x y = (n \/ x * x = n) && (n \/ y * y = n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55466989aeecab5aac00003e":[{"id":84379,"user_id":492,"body":"let sq_in_rect lng wdth =\n    let rec loop x y =\n        if (x * y = 0) then []\n        else \n            let k = min x y\n            let mx = max x y\n            k :: (loop k (mx - k))\n    if (lng = wdth) then None\n    else Some(loop lng wdth) ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84380,"user_id":492,"body":"let sq_in_rect lng wdth =\n    let rec loop x y =\n        if (x * y = 0) then []\n        else \n            let k = min x y\n            let mx = max x y\n            k :: (loop k (mx - k))\n    if (lng = wdth) then None\n    else Some(loop lng wdth) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84381,"user_id":null,"body":"let sq_in_rect length width =\n    let rec realsq_in_rect (length:int) (width:int) : int list =\n        if length < width then realsq_in_rect width length\n        elif length % width = 0 then List.init (length\/width) (fun _ -> width)\n        else width :: realsq_in_rect width (length-width)\n    if length <> width then Some(realsq_in_rect length width) else None\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84382,"user_id":null,"body":"let sq_in_rect lng wdth =\n    if lng = wdth\n    then None\n    else\n        (lng, wdth)\n        |> Seq.unfold (\n            fun (x, y) ->\n                let x, y = min x y, max x y\n                if x = 0\n                then None\n                else Some (x, (x, y - x)))\n        |> Seq.toList\n        |> Some\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84383,"user_id":53,"body":"let sq_in_rect l w =\n  if l = w then\n    None\n  else\n    let rec walk arr a b = \n      let l = max a b\n      let w = min a b\n      if w = 0 then\n        arr |> List.rev\n      else\n        walk (w :: arr) w (l - w)\n    Some (walk [] l w)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84384,"user_id":null,"body":"let rec calc a b: list<int> =\n    if a = b then\n        [ a ]\n    else\n        let N, n =\n            if a > b then a, b\n            else b, a\n\n        let lst = calc (N - n) n\n        lst @ [ n ]\n\nlet sq_in_rect lng wdth =\n    if lng = wdth then \n        None\n    else\n        (Some (List.rev (calc lng wdth)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84385,"user_id":null,"body":"let sq_in_rect lng wdth =\n    let rec split (x: int) (y: int) (arr: int list) =\n        match x = y with\n        | true ->\n            x::arr\n        | false ->\n            split (min x y) ((max x y)- (min x y)) ((min x y)::arr)\n    \/\/ your code\n    match lng = wdth with\n    | true -> None\n    | false -> Some(split lng wdth ([]) |> List.sortDescending)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84386,"user_id":null,"body":"let sq_in_rect lng wdth =\n  let rec cutSquare lng wdth = \n    if lng>wdth then\n       wdth :: cutSquare (lng - wdth) wdth\n    else if wdth > lng then\n        lng :: cutSquare lng (wdth-lng)\n    else\n        [lng]\n  if lng = wdth then \n    None\n  else \n    Some <| cutSquare lng wdth","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84387,"user_id":null,"body":"let sq_in_rect l w =\n  let rec solve l w acc =\n    match l, w with\n    |0, _ -> List.rev acc\n    |_, 0 -> List.rev acc\n    |l, w when l > w -> solve (l-w) w (w :: acc)\n    |l, w -> solve l (w-l) (l :: acc)\n\n  if l = w then\n    None\n  else\n    Some (solve l w [])\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84388,"user_id":null,"body":"let sq_in_rect lng wdth =\n  let rec turnToSquares l w acc = \n    match l, w with\n    | x, y when x = y -> (min x y) :: acc\n    | x, y -> turnToSquares (min x y) (abs (x - y)) ((min x y)::acc)\n    \n  match (lng, wdth) with\n  | l, w when l = w -> None\n  | l, w -> turnToSquares l w []\n            |> List.rev\n            |> Some","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5547cc7dcad755e480000004":[{"id":84389,"user_id":null,"body":"let remove_nb n =\n    if n <= 3L\n    then []\n    else\n    [\n        let sum = n * (n + 1L) \/ 2L\n        for i = n \/ 2L to n do\n            let q, r = System.Math.DivRem(sum - i, i + 1L)\n            if r = 0L && q <> i then\n                yield i, q\n    ]\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84390,"user_id":null,"body":"let remove_nb (n: int64) =\n    let sum = n * (n + 1L) \/ 2L\n    \n    let numbers = seq {1L..n} |> Seq.filter (fun x -> (sum+1L)%(x+1L) = 0L)\n    \n    (numbers, numbers)\n    ||> Seq.allPairs\n    |> Seq.filter (fun (a, b) -> a * b + a + b = sum)\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84391,"user_id":492,"body":"let remove_nb (n: int64) =\n    let rec remove_nbAux (n: int64) (s: int64) (i: int64) res =\n        match i with\n        | x when (x > n) -> res\n        | _ ->\n            let b = s - i\n            let m = b \/ (i + 1L)\n            if (b % (i + 1L) = 0L)  then remove_nbAux n s (i + 1L) (res @ [(i, m)])\n            else remove_nbAux n s (i + 1L) res\n    remove_nbAux n ((n * (n + 1L)) \/ 2L) (n \/ 2L) []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84392,"user_id":null,"body":"let remove_nb (n: int64) =\n  let sum = 1L + n * (n + 1L) \/ 2L\n  [1L..n+1L]\n  |> List.filter (fun i -> sum % i = 0L && sum \/ i <= n + 1L)\n  |> List.map (fun i -> (i - 1L, sum \/ i - 1L))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84393,"user_id":null,"body":"\/\/ summation formula (end sequence\/last no. known).\nlet sumSeq x = x * (1L + x) \/ 2L\n\n\/\/ formula: target! - m - n = mn (following substituted to solve for n\/factor2)\nlet findFactor2Formula summedSequence factor1 =\n    summedSequence - factor1 \/\/ numerator\n    |> fun x -> x \/ (factor1 + 1L) \/\/ denominator\n\nlet friendNotCheating summedSequence factor1 factor2 =\n    summedSequence - factor1 - factor2 = factor1 * factor2\n\nlet remove_nb target =\n    let summedSequence = sumSeq target\n\n    let findFactor2 possibleFactor1 =\n        let potentialFactor2 = findFactor2Formula summedSequence possibleFactor1\n\n        if potentialFactor2 < target\n           && friendNotCheating summedSequence possibleFactor1 potentialFactor2 then\n            Some(possibleFactor1, potentialFactor2)\n        else\n            None\n\n    seq { 2L .. target - 1L }\n    |> Seq.choose findFactor2\n    |> List.ofSeq\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84394,"user_id":null,"body":"let remove_nb (n : int64) =\n    let sum = n * (n + 1L) \/ 2L\n    [ for x in 1L..n do \n        let y = sum \/ x - 1L; \n        if x * y = sum - x - y then yield (x, y); yield (y, x) \n    ]\n    |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84395,"user_id":null,"body":"open System\nlet remove_nb n = \n    let sum = (1L + n) * (n) \/ 2L \n    let rec loopi i res = \n        if i > n then res \n        else \n            let oj = float (sum - i) \/ (float i + 1.) \n            let (b, j) = Int64.TryParse (oj.ToString())\n            if b && 1L <= j && j <= n\n            then loopi (i + 1L) ((i, int64 j)::res) \n            else loopi (i + 1L) res \n    loopi 1L []\n    |> List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84396,"user_id":null,"body":"let remove_nb (n: int64) =\n    let sum = Seq.sum {1L..n}\n    [for a in 1L..n do\n        let b = ((sum - a) \/ (a + 1L))\n        if b <= n && (a * b + a + b = sum) then yield (a, b)\n    ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84397,"user_id":168,"body":"let remove_nb (n: int64) =\n  let s = n * (n + 1L) \/ 2L in\n  [ for a in (s - n) \/ (n + 1L) .. n do\n      if (s - a) % (a + 1L) = 0L then yield (a, (s - a) \/ (a + 1L)) ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84398,"user_id":null,"body":"let remove_nb (n: int64) =\n  \/\/ your code\n  let x = n * (n + 1L) \/ 2L + 1L\n  [2L .. n+1L]\n  |> List.filter (fun i -> x % i = 0L)\n  |> List.map (fun i -> i - 1L, x \/ i - 1L)\n  |> List.filter (fun (a, b) -> 1L <= b && b <= n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"554a44516729e4d80b000012":[{"id":84399,"user_id":null,"body":"open System\n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n    let rec fn p_old p_new save f n = \n        match p_old + save - p_new with\n        | rem when rem >= 0. -> (n, rem |> round |> int)\n        | rem -> fn (p_old * f) (p_new * f) (save + savingperMonth) (f - float(1 - n % 2) * 0.005) (n + 1)   \n    \n    fn startPriceOld startPriceNew 0. (1. - 0.01 * percentLossByMonth) 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84400,"user_id":492,"body":"open System\n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n    let rec loop (old: float) (nw: float) (saving: float) (loss: float) (months: float) =\n        let w = old + saving * months\n        if (w >= nw) then\n            (int(months), int(round(w - nw)))\n        else\n            if (int(months) % 2 = 0) then\n                loop (old * loss) (nw * loss) saving loss (months + 1.0)\n            else\n                let nloss = loss - 0.005\n                loop (old * nloss) (nw * nloss) saving nloss (months + 1.0)\n    loop startPriceOld startPriceNew savingperMonth (1.0 - percentLossByMonth \/ 100.0) 0.0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84401,"user_id":null,"body":"let decrease loss n  = n * (1.0 - loss \/ 100.0)\n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n    let rec nb_months' oldPrice newPrice saving percentLoss months =\n        let leftOver = oldPrice + saving - newPrice\n        match leftOver >= 0.0 with\n        | true -> (months, int <| round leftOver)\n        | false ->\n            let percentLoss' = percentLoss + if months % 2 = 0 then 0.0 else 0.5\n            let decrease' = decrease percentLoss'\n            nb_months' (decrease' oldPrice) (decrease' newPrice) (saving + savingperMonth) percentLoss' (months + 1)\n    nb_months' startPriceOld startPriceNew 0.0 percentLossByMonth 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84402,"user_id":null,"body":"let nb_months\n    (oldCarPrice: float)\n    (newCarPrice: float)\n    (savingsperMonth: float)\n    (percentLossByMonth: float) =\n\n    let calcDepreciation previousDepreciation targetMonth =\n        if targetMonth % 2 = 0 then previousDepreciation - 0.005 else previousDepreciation\n    \n    let rec calc ``new car$`` ``old car$`` ``acc. savings`` month depreciation =\n        ``acc. savings`` + ``old car$`` - ``new car$``\n        |> function\n            | purchaseCovered when purchaseCovered >= 0. -> month, round purchaseCovered |> int\n            | _ ->\n                calc \n                    (``new car$`` * depreciation) \n                    (``old car$`` * depreciation)\n                    (``acc. savings`` + savingsperMonth)\n                    (month + 1)\n                    (calcDepreciation depreciation month)\n        \n    calc newCarPrice oldCarPrice 0. 0  (1. - percentLossByMonth \/ 100.)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84403,"user_id":null,"body":"let nb_months\n    (oldCarPrice: float)\n    (newCarPrice: float)\n    (savingperMonth: float)\n    (percentLossByMonth: float) =\n\n    let calculateSavings months = (float months) * savingperMonth\n    \n    let depreciationCalculator previousDec currentMonth =\n        if currentMonth = 0 then\n            previousDec, fun price -> price\n        else\n            let dec = \n                match currentMonth with\n                | _ when currentMonth % 2 = 0  -> previousDec + 0.5\n                | _ -> previousDec\n        \n            dec, fun lastPrice -> lastPrice * (100. - dec) \/ 100.\n    \n    (0, newCarPrice, oldCarPrice, percentLossByMonth, -1.)\n    |> Seq.unfold (\n        fun (currentMonth, newCarPrice, oldCarPrice, depreciationPercent, previousDeficit)  ->\n            if previousDeficit >= 0. then\n                None\n            else\n\n                let decThisMonth, decCalculator = depreciationCalculator depreciationPercent currentMonth\n                let newCarPriceDepreciated = decCalculator newCarPrice \n                let oldCarPriceDepreciated = decCalculator oldCarPrice \n                let thisMonthSavings = calculateSavings currentMonth\n\n                let deficit = thisMonthSavings + oldCarPriceDepreciated - newCarPriceDepreciated\n                \n                Some(\n                    (currentMonth, deficit), \n                    (currentMonth + 1, newCarPriceDepreciated, oldCarPriceDepreciated, decThisMonth, deficit)))\n                \n    |> Seq.last\n    |> fun (month, remainingMoney)-> month, round remainingMoney |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84404,"user_id":null,"body":"let nb_months\n    (oldCarPrice: float)\n    (newCarPrice: float)\n    (savingperMonth: float)\n    (percentLossByMonth: float) =\n\n    let calculateSavings months = (float months) * savingperMonth\n    \n    let depreciationCalculator previousDec currentMonth =\n        let dec = \n            match currentMonth with\n            | _ when currentMonth % 2 = 0  -> previousDec + 0.5\n            | _ -> previousDec\n        \n        dec, fun lastPrice -> lastPrice * (100. - dec) \/ 100.\n    \n    let deficit = oldCarPrice - newCarPrice\n    if deficit >= 0. then\n        0, int deficit\n    else\n        (1, newCarPrice, oldCarPrice, percentLossByMonth, deficit)\n        |> Seq.unfold (\n            fun (currentMonth, newCarPrice, oldCarPrice, depreciationPercent, previousDeficit)  ->\n                if previousDeficit >= 0. then\n                    None\n                else\n\n                    printfn \"current month: %A\" currentMonth\n                    printfn \"new car $:     %A\" newCarPrice\n                    printfn \"old car $:     %A\" oldCarPrice\n                    printfn \"dec %%:         %A\" depreciationPercent\n                    printfn \"=====================\"\n\n                    let decThisMonth, decCalculator = depreciationCalculator depreciationPercent currentMonth\n                    let newCarPriceDepreciated = decCalculator newCarPrice \n                    let oldCarPriceDepreciated = decCalculator oldCarPrice \n                    let thisMonthSavings = calculateSavings currentMonth\n\n                    let deficit = thisMonthSavings + oldCarPriceDepreciated - newCarPriceDepreciated\n                    printfn \"savings:              %A\" thisMonthSavings\n                    printfn \"calcd' old car $:     %A\" oldCarPriceDepreciated\n                    printfn \"calcd' new car $:     %A\" newCarPriceDepreciated\n                    printfn \"calcd' dec %%:         %A\" decThisMonth\n                    printfn \"deficit:              %A\" deficit\n                    printfn \"\"\n\n                    Some(\n                        (currentMonth, deficit), \n                        (currentMonth + 1, newCarPriceDepreciated, oldCarPriceDepreciated, decThisMonth, deficit)))\n                \n        |> Seq.last\n        |> fun (month, remainingMoney)-> month, round remainingMoney |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84405,"user_id":null,"body":"open System\n\nlet nb_months\n    (startPriceOld: float)\n    (startPriceNew: float)\n    (savingperMonth: float)\n    (percentLossByMonth: float)\n    =\n\n    let priceDiff = startPriceOld - startPriceNew\n\n    if priceDiff >= 0. then\n        0, priceDiff\n    else\n        let twoMthsIncr = 0.5\n\n        let rec calc newCarP oldCarP savings (accMonth: int) decPerc =\n\n            let dp =\n                match accMonth with\n                | m when m % 2 = 1 -> decPerc\n                | _ -> decPerc + twoMthsIncr\n\n            let decFactor = (100. - dp) \/ 100.\n            let reducedNewCarP = newCarP * decFactor\n            let reducedOldCarP = oldCarP * decFactor\n\n            let price2Cover =\n                savings + reducedOldCarP - reducedNewCarP\n\n            if price2Cover >= 0. then\n                accMonth, price2Cover\n            else\n                calc\n                    reducedNewCarP\n                    reducedOldCarP\n                    (savings + savingperMonth)\n                    (accMonth + 1)\n                    dp\n\n        calc startPriceNew startPriceOld savingperMonth 1 percentLossByMonth\n    |> (fun (x, y) -> x, Math.Round(y, 0) |> int)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84406,"user_id":null,"body":"open System\n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  let startDiff = startPriceOld - startPriceNew\n  let rec months month diff savings percent =\n    match diff+savings with\n    | x when x > 0.0M -> (month, Decimal.Round (diff+savings) |> int)\n    | _ ->\n      let m = month + 1\n      let p = percent + if m%2=0 then 0.5M else 0.0M\n      let d = diff * (100.0M-p) \/ 100.0M\n      let s = decimal savingperMonth + savings\n      months m d s p\n  months 0 (decimal startDiff) 0.0M (decimal percentLossByMonth)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84407,"user_id":null,"body":"open System\n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  let rec f (i: int) (oldP: float) (newP: float) (savings: float) (percValue: float) =\n    let delta = oldP + savings - newP\n    Console.WriteLine(\"{0} {1} {2}\", i, (1.0 - percValue) * 100.0, delta)\n    if delta > 0.0 then\n      (i, int (round delta))\n    else\n      let _percValue = if i % 2 = 0 then percValue - 0.005 else percValue\n      f (i + 1) (oldP * percValue) (newP * percValue) (savings + savingperMonth) _percValue\n  f 0 startPriceOld startPriceNew 0.0 (1.0 - (percentLossByMonth \/ 100.0))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84408,"user_id":252,"body":"let nb_months (valOld: float) (prcNew: float) (save: float) (pctLoss: float) =\n    let rec fn m v p l i =\n        match m + v < p with\n        | true ->\n            let l' = l + [|0.;0.005|].[i % 2]\n            fn (m + save) (v - v * l') (p - p * l') l' (i + 1)\n        | false -> i, m + v - p |> round |> int\n    fn 0. valOld prcNew (pctLoss * 0.01) 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"554b4ac871d6813a03000035":[{"id":84409,"user_id":null,"body":"let high_and_low (str : string) = \n    let intArr = str.Split ' ' |> Array.map int\n    let max = intArr |> Array.max\n    let min = intArr |> Array.min\n\n    max.ToString() + \" \" + min.ToString()","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84410,"user_id":null,"body":"let high_and_low (str : string) =\n    str.Split()\n    |> Array.sortBy int\n    |> (fun a -> a |> Array.last, a |> Array.head)\n    ||> sprintf \"%s %s\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84411,"user_id":null,"body":"open System\n\nmodule Array = \n  let maxmin arr = \n    let max = Array.max arr\n    let min = Array.min arr\n    (max, min)\n\nlet high_and_low (str : string) = \n    str.Split()\n    |> Array.map Int32.Parse\n    |> Array.maxmin\n    |> fun (max, min) -> sprintf \"%i %i\" max min","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84412,"user_id":null,"body":"let high_and_low (str : string) = \n    let sequence = str.Split() |> Seq.map int\n    let min, max = Seq.min sequence, Seq.max sequence\n    sprintf \"%d %d\" max min","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84413,"user_id":null,"body":"let high_and_low (str : string) = \n    let ints = str.Split [| ' ' |] |> Seq.map int\n    sprintf \"%i %i\" (Seq.max ints) (Seq.min ints)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84414,"user_id":null,"body":"let high_and_low (str : string) = \n    let numbers = str.Split(' ') |> Array.map int\n    let heigest = numbers |> Array.max |> string\n    let lowest = numbers |> Array.min |> string\n    heigest + \" \" + lowest","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84415,"user_id":null,"body":"let high_and_low (str : string) =\n    let inner (seq : string array) =\n        seq\n        |> Seq.sortBy int\n        |> Seq.permute (fun i -> (i + 1) % seq.Length) \/\/ rotateR\n        |> Seq.pairwise\n        |> Seq.head\n        ||> sprintf \"%s %s\"\n\n    let nums = str.Split ' '\n    if nums.Length = 1 then\n        inner (Array.replicate 2 nums.[0])\n    else\n        inner nums","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84416,"user_id":null,"body":"open System\n\nlet high_and_low (str : string) = \n    str.Split () |> Array.map int |> Array.sort |> (fun x -> x |> Array.last, \" \", x |> Array.head) |> String.Concat","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84417,"user_id":null,"body":"let high_and_low (str : string) = \n    str.Split ' '\n    |> Array.map int\n    |> fun a -> (a |> Array.max, a |> Array.min)\n    |> fun (x, y) -> sprintf \"%i %i\" x y","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84418,"user_id":null,"body":"let high_and_low (str : string) =\n    let ns = str.Split ' '\n    Array.maxBy int ns + \" \" + Array.minBy int ns","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"554ca54ffa7d91b236000023":[{"id":84419,"user_id":null,"body":"open System.Collections.Generic\n\nlet delete_nth order max_e =\n    let cache = new Dictionary<int, int>()\n\n    order\n    |> List.filter (fun n -> \n        cache.[n] <- if cache.ContainsKey(n) then cache.[n] + 1 else 1\n        cache.[n] <= max_e\n    )","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84420,"user_id":168,"body":"let delete_nth order e =\n  let rec loop c = function\n    | [] -> []\n    | x :: xs ->\n      let n = \n        match Map.tryFind x c with\n        | None -> 1\n        | Some n -> n + 1\n      if n > e then \n        loop c xs\n      else\n        x :: loop (Map.add x n c) xs\n  loop Map.empty order\n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84421,"user_id":null,"body":"let delete_nth order max_e =\n    let res = new ResizeArray<int>()\n    for i in order do\n        let itemCounts =\n            res\n            |> Seq.filter ((=) i)\n            |> Seq.length\n        if itemCounts < max_e then\n            res.Add i\n    Seq.toList res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84422,"user_id":null,"body":"let getCountFor key counts =\n  counts \n  |> Map.tryFind key\n  |> Option.defaultValue 0\n\nlet delete_nth order max_e =\n  (([], Map.empty), order)\n  ||> List.fold (\n    fun (filtered, counts) el ->\n      let count = counts |> getCountFor el\n      if count < max_e then\n        el :: filtered, Map.add el (count+1) counts\n      else \n        filtered, counts) \n  |> fst\n  |> List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84423,"user_id":null,"body":"let delete_nth (order: int list) max_e =\n    let count =\n        order\n        |> Set.ofList\n        |> Set.map (fun e -> (e, 0))\n        |> Map.ofSeq\n        |> System.Collections.Generic.Dictionary<int, int>\n\n    order\n    |> List.filter (fun i ->\n        count.[i] <- count.[i] + 1\n        count.[i] <= max_e)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84424,"user_id":null,"body":"\/\/ Codewars | fs | Delete occurrences of an element if it occurs more than n times - 6 kyu\n\/\/ Source: https:\/\/www.codewars.com\/kata\/554ca54ffa7d91b236000023\/\n\nopen System\nopen System.Collections.Generic\n\nlet delete_nth order max_e =\n    let dict = new Dictionary<int, int>()\n    let resList = List<int>()\n\n    for n in order do\n        if dict.ContainsKey(n) then\n            dict.[n] <- dict.[n] + 1\n        else\n            dict.[n] <- 1\n\n        if dict.[n] > max_e then\n            ()\n        else\n            resList.Add(n)\n\n    resList |> Seq.toList\n\ndelete_nth [ 1; 2; 3; 1; 2; 1; 2; 3 ] 2\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84425,"user_id":null,"body":"let delete_nth order max_e =\n    let rec delete_nth' order acc =\n        match order with\n        | [] -> List.rev acc\n        | head :: tail -> let countOfHead = \n                              acc\n                              |> List.filter ((=) head)\n                              |> List.length\n                          match countOfHead with\n                          | x when x < max_e -> delete_nth' tail (head::acc)      \n                          | _ -> delete_nth' tail acc\n    delete_nth' order []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84426,"user_id":null,"body":"let delete_nth order max_e =\n    let rec delete_nth' order acc =\n        match order with\n        | [] -> acc\n        | head :: tail -> let countOfHead = \n                              acc\n                              |> List.filter ((=) head)\n                              |> List.length\n                          match countOfHead with\n                          | x when x < max_e -> delete_nth' tail (List.concat [acc;[head]])      \n                          | _ -> delete_nth' tail acc\n    delete_nth' order []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84427,"user_id":null,"body":"let delete_nth originalList nTimes =\n\n    let rec f workInProgressList = \/\/ original list param inferred\/implicit.\n        function\n        | [] -> List.rev workInProgressList \/\/ finished processing. rev prepended list\n        | itm :: originalListRemaining ->\n\n            let itmExceededNthLimit =\n                (List.filter ((=) itm)\n                 >> fun sameItms -> sameItms.Length >= nTimes)\n                    workInProgressList\n\n            let carryForwardList =\n                itmExceededNthLimit\n                |> function\n                    \/\/ dont add exceeded itm. just carry forward previous wip list.\n                    | true -> workInProgressList\n                    \/\/ pre-pend itm; within limit. prepend +efficient vs @concat. rev @ op-end\n                    | false -> itm :: workInProgressList\n\n            f carryForwardList originalListRemaining\n\n    f [] originalList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84428,"user_id":null,"body":"let delete_nth originalList nTimes =\n\n    let rec f workInProgressList = \/\/ original list param inferred\/implicit.\n        function\n        | [] -> List.rev workInProgressList \/\/ finished processing. rev prepended list\n        | itm :: originalListRemaining ->\n\n            let exceeded =\n              List.filter ((=) itm) workInProgressList\n              |> fun sameItms ->  sameItms.Length >= nTimes\n\n            let carryForwardList = \n              match exceeded with\n              | true -> workInProgressList \/\/ continue without adding exceeded count itm\n              | false -> itm :: workInProgressList \/\/ pre-pend itm to list. still within limit. prepend more efficient. rev @ op-end\n            \n            f carryForwardList originalListRemaining\n\n    f [] originalList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"554f76dca89983cc400000bb":[{"id":84429,"user_id":null,"body":"\/\/\n\/\/ Here's how I derived my solution for this Kata.\n\/\/\n\/\/ Given:\n\/\/  x ^ 2 - 4 * y ^ 2 = n\n\/\/  x >= 0, y >= 0\n\/\/\n\/\/ The equation is a difference of perfect squares, so it can be written as:\n\/\/  (x + 2y)(x - 2y) = n\n\/\/\n\/\/ When introducing an extra equation a * b = n:\n\/\/  (x + 2y)(x - 2y) = a * b\n\/\/ \n\/\/ We can split up the equation like this:\n\/\/  a = x + 2y\n\/\/  b = x - 2y\n\/\/  a * b = n\n\/\/\n\/\/ Just for fun, let's solve the equations using matrices:\n\/\/\n\/\/   d        A       v    \n\/\/  |a|   | 1  2 |   |x|   \n\/\/  | | = |      | * | |\n\/\/  |b|   | 1 -2 |   |y|   \n\/\/\n\/\/  d = A * v  ==>  v = A' * d\n\/\/\n\/\/ The inverse matrix A' is:\n\/\/\n\/\/   -1  | -2 -2 |   | 1\/2  1\/2 |\n\/\/  ---- |       | = |          |\n\/\/    4  | -1  1 |   | 1\/4 -1\/4 |\n\/\/\n\/\/ This gives us the following:\n\/\/\n\/\/   v          A'        d                                       \n\/\/  |x|   | 1\/2  1\/2 |   |a|       |x|   | 1\/2a  1\/2b |      x = (a + b) \/ 2\n\/\/  | | = |          | * | |  ==>  | | = |            |  ==>   \n\/\/  |y|   | 1\/4 -1\/4 |   |b|       |y|   | 1\/4a -1\/4b |      y = (a - b) \/ 4\n\/\/ \n\/\/ Based on the above, a diophantine solution is possible when:\n\/\/  a * b = n\n\/\/  a >= b              (otherwise y is negative and y is defined >= 0)\n\/\/  (a + b) mod 2 = 0   (otherwise x is not integer)\n\/\/  (a - b) mod 4 = 0   (otherwise y is not integer)\n\/\/  x = (a + b) \/ 2\n\/\/  y = (a - b) \/ 4\n\/\/\nlet sol_equa (n: int64) =\n    let divisorPairsOf (n: int64) = seq {\n        for b in [ 1L .. int64 (sqrt (double n)) ] do\n            if n % b = 0L then\n                yield (n \/ b, b)\n    }\n\n    let solvesEquation (a, b) =\n        a >= b &&\n        (a + b) % 2L = 0L &&\n        (a - b) % 4L = 0L\n    \n    let x (a, b) = (a + b) \/ 2L   \n    let y (a, b) = (a - b) \/ 4L\n    let xy (a, b) = (x (a, b), y (a, b))\n\n    divisorPairsOf n\n        |> Seq.filter solvesEquation\n        |> Seq.map xy\n        |> Seq.toList\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84430,"user_id":492,"body":"open System\n\nlet sol_equa (n: int64) = \n    [for p in 1L .. int64(Math.Ceiling (sqrt (float(n)))) do\n        let (q, r) = Math.DivRem(n, p)\n        let diff = q - p\n        let sum = q + p\n        if (r = 0L) && (diff % 4L = 0L) && (sum % 2L = 0L) then yield (sum \/ 2L, diff \/ 4L)\n    ]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84431,"user_id":53,"body":"let rec isqrt64 n =\n  if n <= 0L then 0L else\n    let r2 = (isqrt64 (n >>> 2)) <<< 1\n    let r3 = r2 + 1L\n    if n < r3 * r3 then r2 else r3\n   \nlet choose n i =\n  let d = double(n) \/ double(i)\n  let x = (d + (double)i) \/ 2.0\n  let y = (d - (double)i) \/ 4.0\n  if double(int64(d)) = d && double(int64(x)) = x && double(int64(y)) = y then\n    (int64(x), int64(y))\n  else\n    (0L, 0L)\n  \nlet sol_equa (n: int64) =\n  seq {for k in 1 .. int(isqrt64 n) -> choose n k}\n  |> Seq.filter (fun (x, y) -> x <> 0L || y <> 0L)\n  |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:18"},{"id":84432,"user_id":168,"body":"let sol_equa (n: int64) =\n  [ for k in 1L .. int64 (sqrt (float n)) do\n      if n % k = 0L then\n        let q = n \/ k\n        if (q + k) % 2L = 0L && (q - k) % 4L = 0L then\n          yield ((q + k) \/ 2L, (q - k) \/ 4L) ]       ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84433,"user_id":null,"body":"let sol_equa (n: int64) =\n    let limit = n |> float |> sqrt |> int64\n\n    let response =\n        [| for i in [ 1L .. limit+1L ] do\n               if (n % i = 0L) && ((n - i * i) % 4L = 0L) then\n                   let j = n \/ i\n                   let y = (j - i) \/ 4L\n                   let x = i + 2L * y\n\n                   if (x >= 0L)\n                      && (y >= 0L)\n                      && (x + (2L * y) = j)\n                      && (x - (2L * y) = i) then\n                       yield (x, y) |]\n\n    response |> Array.toList\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84434,"user_id":null,"body":"open System\nlet is_int (x:float) = (x = floor x)\n\nlet sol_equa (n: int64) =\n    \/\/ Assumption:\n    \/\/ x^2 - 2y^2 = (x - 2y) (x + 2y)\n    \n    \/\/ Solution:\n    \/\/ We will focus on the first divisor (x - 2y) -- we will name it \"i\"\n    \/\/ Range of values of i:\n    \/\/ 1. It's greater or equal to 1\n    \/\/ 2. It's smaller than sqrt(n) since it's a smaller divisor of n\n    \/\/ If we can scan all potential values of i it gives us \n    \/\/ O(sqrt(n)) algorithm complexity - much better than O(n) which we would\n    \/\/ have if we were scanning potential values of x or y\n    let i_max = n |> float |> sqrt |> floor |> int64\n    [for i in 1L..i_max do\n        \/\/ We are plugging the values of n and i=(x-2y) to \n        \/\/ determine x and y \n        \/\/ x - 2y = i && x + 2y = n\/i\n        \/\/ x = (n\/i + i) \/ 2\n        \/\/ y = (x - i) \/ 2\n        let x_f : float = ((float n) \/ (float i) + (float i)) \/ 2.0\n        let y_f : float = (x_f - (float i)) \/ 2.0\n        \/\/ If the results are integers - we havd a solution!\n        if is_int x_f && is_int y_f then\n            yield (int64 x_f, int64 y_f)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84435,"user_id":null,"body":"open System\nlet is_int (x:float) = (x = floor x)\n\nlet sol_equa (n: int64) =\n    let i_max = n |> float |> sqrt |> floor |> int64\n    \/\/ int64 (floor (sqrt (float n)))\n    [for i in 1L..i_max do\n        let x_f : float = ((float n) \/ (float i) + (float i)) \/ 2.0\n        let y_f : float = (x_f - (float i)) \/ 2.0\n        if is_int x_f && is_int y_f then\n            yield (int64 x_f, int64 y_f)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84436,"user_id":null,"body":"open System\nlet sol_equa (n: int64) =\n    let sqrtn = int64 (sqrt (float n))\n    [ for i=1L to sqrtn do\n        let n_over_i = n\/i in\n        if (n_over_i)*i = n && (n_over_i+i)%2L = 0L && ((n_over_i+i)\/2L - i)%2L = 0L then\n            let x = (n_over_i+i)\/2L\n            let y = (x - i)\/2L\n            yield (x,y) ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84437,"user_id":null,"body":"open System\n\nlet getDivs (n: int64) =\n  [1L..(n |> (float >> sqrt >> int64))] |> List.filter (fun x -> n % x = 0L) |>\n  List.map (fun x -> (x, n \/ x))\n  \nlet sol_equa (n: int64) =\n  n |> getDivs |> List.filter (fun (a,b) -> (b - a) % 4L = 0L) |>\n  List.map (fun (a,b) -> ((b + a)\/2L, (b - a)\/4L))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"},{"id":84438,"user_id":null,"body":"let getFactorPairs (n: int64) =\n    seq { 1L .. (n |> float |> sqrt |> int64)}\n    |> Seq.filter (fun x -> n % x = 0L)\n    |> Seq.map (fun x -> (x, n \/ x))\n\nlet factorsToXandY (factor1, factor2) =\n    \/\/ factor1 = x - 2*y  &  factor2 = x + 2*y\n    \/\/ Solve using substitution:  factor1 = (factor2 - 2*y) - 2*y\n    \/\/ y = (factor2 - factor1) \/ 4\n    let y = (factor2 - factor1) \/ 4L\n    let x = factor1 + 2L * y\n    if factor1 = (x - 2L * y) && factor2 = x + 2L * y\n    then Some (x, y)\n    else None\n\nlet sol_equa (n: int64) =\n    getFactorPairs n\n    |> Seq.choose factorsToXandY\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 19:27:12"}],"5552101f47fc5178b1000050":[{"id":84439,"user_id":null,"body":"let dig_pow n p =\n    n \n    |> string\n    |> Seq.map (string >> int64)\n    |> Seq.mapi (fun i digit -> pown digit (i+p))\n    |> Seq.reduce (+)   \n    |> (fun sum -> if sum % int64 n=0L then sum\/int64 n else -1L)\n\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84440,"user_id":null,"body":"let digits =\n    let rec f acc n =\n        if n = 0\n        then acc\n        else f (n % 10 :: acc) (n \/ 10)\n\n    fun n -> if n = 0 then [0] else f [] n\n\nlet dig_pow n p =\n    digits n\n    |> Seq.mapi (fun i d -> pown (int64 d) (p + i))\n    |> Seq.sum\n    |> fun x -> if x % (int64 n) = 0L then x \/ (int64 n) else -1L\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84441,"user_id":null,"body":"let dig_pow (n: int) (p: int) =\n    let asLong = int64 n\n    (string asLong) \n    |> Seq.map (string >> int64) \n    |> Seq.mapi (fun i value -> pown value (i+p)) \n    |> Seq.sum \n    |> (fun x -> if x%asLong=0L then x\/asLong else -1L)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84442,"user_id":492,"body":"open System\n\nlet dig_pow (n: int) (p: int) =\n    let nb2Dig n =\n        [for c in string(n) -> int(c) - int(48)]\n    let power(a, b) = int64(Math.Pow(double(a), double(b)))\n    let a = nb2Dig n\n    let c = List.zip a (seq {p..p + (List.length a) - 1} |> Seq.toList) |> List.map (power) |> List.sum\n    if (c % int64(n) = 0L) then c \/ int64(n) else -1L\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84443,"user_id":null,"body":"let dig_pow (n: int) (p: int) =\n    let n = int64 n\n    let digits =\n        List.unfold\n            (fun s ->\n                if s = 0L then\n                    None\n                else\n                    Some(s % 10L, s \/ 10L))\n            n\n        |> List.rev\n        |> Seq.zip\n        <| (Seq.unfold (fun s -> Some(s, s + 1)) p)\n        |> Seq.map (fun (d, i) -> pown d i)\n        |> Seq.sum\n\n    if digits % n = 0L then\n        digits \/ n\n    else\n        -1L","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84444,"user_id":null,"body":"let pow x p =\n    [for i in 1..p -> x]\n    |> List.reduce (*)\n\nlet dig_pow (n: int) (p: int):int64 =\n    n.ToString()\n    |> Seq.map (string>>int64)\n    |> Seq.mapi (fun i num -> pow num (i + p))\n    |> Seq.reduce (+)\n    |> (fun v ->\n        if v % int64 n = 0L then v \/ int64 n\n        else -1L)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84445,"user_id":null,"body":"let inline charToInt c = int c - int '0'\n\nlet pow x p =\n    [for i in 1..p -> x |> int64]\n    |> List.reduce (*)\n\nlet dig_pow (n: int) (p: int):int64 =\n    n.ToString()\n    |> Seq.map charToInt\n    |> Seq.mapi (fun i num -> pow num (i + p))\n    |> Seq.reduce (+)\n    |> (fun v ->\n        match v \/ int64 n, v % int64 n with\n        | _, r when r > 0L -> -1L\n        | d, _ -> d)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84446,"user_id":null,"body":"open System\nlet stringifyInt num = num.ToString()\n\nlet floatParse num = num |> fun i -> i.ToString() |> Convert.ToDouble\n\nlet getNumIntegers num =\n    num |> stringifyInt |> Seq.map floatParse\n\nlet dig_pow num initialPow =\n    let sumOfPowered = getNumIntegers num\n                        |> Seq.mapi (fun i itm -> Math.Pow(itm, float (initialPow+i)))\n                        |> Seq.sum\n                        |> int\n    match sumOfPowered % num = 0 with\n     | true -> (sumOfPowered \/ num) |> int64\n     | _ -> -1L","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84447,"user_id":null,"body":"let dig_pow (n: int) (p: int) =\n  let sum =\n    Seq.unfold (fun n -> if n > 0 then Some (n % 10, n \/ 10) else None) n\n    |> Seq.rev\n    |> Seq.mapi (fun i x -> (float x) ** (float <| p + i))\n    |> Seq.sum |> int64\n  if sum % (int64 n) = 0L then sum \/ (int64 n) else -1L\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84448,"user_id":null,"body":"let dig_pow (n: int) (p: int) =\n  let rec getSum (n': string) (p': int) =\n    match n'.Length with\n      | 0 -> 0\n      | _ -> ((n'.[..0] |> float)**(p' |> float) |> int) + getSum n'.[1..] (p'+1)\n  let rec getK (sum: int) (k: int) =\n    if k * n > sum then -1\n    else match k * n = sum with\n          | true -> k\n          | false -> getK sum (k+1)\n  (getK (getSum (n |> string) p) 1) |> int64","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"555615a77ebc7c2c8a0000b8":[{"id":84449,"user_id":null,"body":"let rec canSell (d25, d50) = function\n| []                                  -> \"YES\"\n| 25  :: rest                         -> canSell (d25 + 1, d50)     rest\n| 50  :: rest when d25 > 0            -> canSell (d25 - 1, d50 + 1) rest\n| 100 :: rest when d25 > 0 && d50 > 0 -> canSell (d25 - 1, d50 - 1) rest \n| 100 :: rest when d25 > 2            -> canSell (d25 - 3, d50)     rest\n| _                                   -> \"NO\"\n\nlet tickets people = canSell (0, 0) people","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84450,"user_id":null,"body":"let tickets people =\n    let init = (0, 0, false)\n    let f (b25, b50, fail) a = match a with\n                               | 25 -> (b25 + 1, b50, fail)\n                               | 50 -> if b25 >= 1 then (b25 - 1, b50 + 1, fail) else (b25, b50, true)\n                               | _ -> if b25 >= 1 && b50 >= 1 then (b25 - 1, b50 - 1, fail) elif b25 >= 3 then (b25 - 3, b50, fail) else (b25, b50, true)\n    let fo = people |> Seq.fold f init\n    let (_, _, fail) = fo\n    if fail then \"NO\" else \"YES\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84451,"user_id":null,"body":"let canGiveChange (ticketCosts:int, mySumMoney:int ref, myWallet_sorted:int list ref, payment:int)  =\n    let change = payment-ticketCosts\n    if mySumMoney.Value < change then false\n    else\n        let rec checkPayment (myWallet: int list) (change:int) (skipDenominations:int list) =\n            match List.tryHead myWallet with\n            | _ when change = 0 -> \n                myWallet_sorted.Value <- (List.append myWallet [payment] |> List.append skipDenominations |> List.sortDescending) \n                mySumMoney.Value <- List.sum myWallet_sorted.Value\n                true\n            | Some _ when change < 0 -> false\n            | None when change > 0 || change < 0 -> false\n            | Some myMoney -> \n                if  change >= myMoney\n                    then checkPayment myWallet.Tail (change-myMoney) skipDenominations\n                    else checkPayment myWallet.Tail (change) (List.append skipDenominations [myMoney])\n            | _ -> false\n            \n        checkPayment myWallet_sorted.Value change List.empty\n\nlet rec calc (mySumMoney:int ref) (myWallet:int list ref) (people: int list) (ticketCosts:int) =\n    match List.tryHead people with\n    | None -> \"YES\"\n    | Some payPeople when payPeople = ticketCosts -> \n        myWallet.Value <- (List.sortDescending <| List.append myWallet.Value [payPeople]) \n        mySumMoney.Value <- mySumMoney.Value + payPeople\n        calc mySumMoney myWallet people.Tail ticketCosts \n    | Some payPeople when payPeople > ticketCosts && canGiveChange(ticketCosts, mySumMoney, myWallet, payPeople) ->\n        calc mySumMoney myWallet people.Tail ticketCosts\n    | _ -> \"NO\"\n\nlet tickets people =\n  calc (ref 0) (ref List.empty) people 25","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84452,"user_id":null,"body":"let tickets people =\n    let rec tkt acc m =\n            match acc, m with\n            | _, [] -> \"YES\"\n            | (_25, _50, _100), 25::xs -> tkt (_25 + 1, _50, _100) xs\n            | (0, _, _), 50::_ -> \"NO\"\n            | (_25, _50, _100), 50::xs -> tkt (_25 - 1, _50 + 1, _100) xs\n            | (0, _, _), 100::_ -> \"NO\"\n            | (_25, _50, _100), 100::xs when _25 >= 1 && _50 >= 1 -> tkt (_25 - 1, _50 - 1, _100 + 1) xs\n            | (_25, 0, _100), 100::xs when _25 >= 3 -> tkt (_25 - 3, 0, 100 + 1) xs\n            | _ -> \"NO\"\n    tkt (0, 0, 0) people","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84453,"user_id":null,"body":"\/\/ NOT FIRST TRY\nlet rec canSell (d25, d50) =\n    function \n    | [] -> \"YES\"\n    | 25 :: rest -> canSell (d25 + 1, d50) rest\n    | 50 :: rest when d25 > 0 -> canSell (d25 - 1, d50 + 1) rest\n    | 100 :: rest when d25 > 0 && d50 > 0 -> canSell (d25 - 1, d50 - 1) rest \n    | 100 :: rest when d25 > 2 -> canSell (d25 - 3, d50) rest\n    | _ -> \"NO\"\n\nlet tickets people = \n    canSell (0, 0) people","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84454,"user_id":null,"body":"let rec update (a, b, c) ps =\n    match ps with\n    | [] -> \"YES\"\n    | h::t ->\n        match h with\n        | 25 -> update (a + 1, b, c) t\n        | 50 when a > 0 -> update (a - 1, b + 1, c) t\n        | 100 when b > 0 && a > 0 -> update ( a - 1, b - 1, c + 1) t\n        | 100 when a >= 3 -> update ( a - 3, b, c + 1) t\n        | _ -> \"NO\"\n\nlet tickets people =\n    update (0, 0, 0) people\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84455,"user_id":null,"body":"let tickets people =\n    let rec helper (fiftys : int) (twentyfives : int) (people : int list) : string =\n        match people with\n        | [] -> \"YES\"\n        | 25 :: tail -> helper fiftys (twentyfives+1) tail\n        | 50 :: tail when twentyfives > 0 -> helper (fiftys+1) (twentyfives-1) tail\n        | 100 :: tail when fiftys > 0 && twentyfives > 0 -> helper (fiftys-1) (twentyfives-1) tail\n        | 100 :: tail when twentyfives >= 3 -> helper fiftys (twentyfives-3) tail\n        | _ -> \"NO\"\n    helper 0 0 people","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84456,"user_id":null,"body":"let tickets (people : int list) : string =\n    let rec helper (hundreds : int) (fiftys : int) (twentyfives : int) (people : int list) : string =\n        match people with\n        | [] -> \"YES\"\n        | head :: tail ->\n            match head with\n            | 25 -> helper hundreds fiftys (twentyfives+1) tail\n            | 50 -> if twentyfives < 1 then \"NO\" else helper hundreds (fiftys+1) (twentyfives-1) tail\n            | 100 ->\n                if fiftys > 0 && twentyfives > 0 then helper (hundreds+1) (fiftys-1) (twentyfives-1) tail\n                elif twentyfives > 2 then helper (hundreds+1) fiftys (twentyfives-3) tail\n                else \"NO\"\n    helper 0 0 0 people\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84457,"user_id":null,"body":"type Register =\n  {\n    Dollar25: int\n    Dollar50: int\n  }\n\ntype TicketSolution =\n| Dollar25\n| GiveDollar25AndGet50\n| GiveDollar25AndDollar50\n| GiveDollar25x3\n\nlet getTicketSolution (register : Register) (bill : int) =\n  match bill with\n  | 25 ->\n    Dollar25 |> Some\n  | 50 ->\n    match register.Dollar25 >= 1 with\n    | true ->\n      GiveDollar25AndGet50 |> Some\n    | false -> None\n  | 100 ->\n    \/\/ It's better to always give the bigger bill if available\n    match register.Dollar25 >= 1 && register.Dollar50 >= 1 with\n    | true ->\n      GiveDollar25AndDollar50 |> Some\n    | false ->\n      match register.Dollar25 >= 3 with\n      | true -> GiveDollar25x3 |> Some\n      | false -> None\n  | _ -> None\n  \nlet giveTicket register ticketSolution =\n  match ticketSolution with\n  | Dollar25 ->\n    {register with Dollar25 = register.Dollar25 + 1}\n  | GiveDollar25AndGet50 ->\n    {register with Dollar25 = register.Dollar25 - 1; Dollar50 = register.Dollar50 + 1}\n  | GiveDollar25AndDollar50 ->\n    {register with Dollar25 = register.Dollar25 - 1; Dollar50 = register.Dollar50 - 1;}\n  | GiveDollar25x3 ->\n    {register with Dollar25 = register.Dollar25 - 3}\n  \nlet rec giveTickets register people =\n  match people with\n  | [] -> \"YES\"\n  | person::people ->\n    match getTicketSolution register person with\n    | None -> \"NO\"\n    | (Some ticketSolution) ->\n      let newRegister = giveTicket register ticketSolution\n      giveTickets newRegister people\n  \n\nlet tickets people =\n  let register = \n    {\n      Dollar25 = 0\n      Dollar50 = 0\n    }\n  giveTickets register people","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84458,"user_id":null,"body":"let rec ticketRec bills25 bills50 lst =\n    match lst with\n    | head :: tail ->\n        match head with\n        | x when x = 25 -> ticketRec (bills25 + 1) bills50 tail\n        | x when x = 50 ->\n            if bills25 >= 1 then\n                ticketRec (bills25 - 1) (bills50 + 1) tail\n            else\n                \"NO\"\n        | x when x = 100 ->\n            match bills25, bills50 with\n            | bills25, bills50 when bills25 >= 1 && bills50 >= 1 -> ticketRec (bills25 - 1) (bills50 - 1) tail\n            | bills25, _ when bills25 >= 3 -> ticketRec (bills25 - 3) bills50 tail\n            | _, _ -> \"NO\"\n        | _ -> \"FAKE\"\n    | [] -> \"YES\"\n\nlet tickets lst = ticketRec 0 0 lst\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"555624b601231dc7a400017a":[{"id":84459,"user_id":527,"body":"let josephus_survivor n k =\n  Seq.fold (fun i j -> (i + k) % j) 1 {1..n} + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:36:16"},{"id":84460,"user_id":645,"body":"let rec josephus_survivor n k = if n = 1 then 1 else (josephus_survivor (n - 1) k + k - 1) % n + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:36:22"},{"id":84461,"user_id":null,"body":"let rec josephus_survivor n k =\n  match n, k with\n  | 1, _ -> 1\n  | n, k -> (josephus_survivor (n - 1) k + k - 1) % n + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84462,"user_id":491,"body":"let josephus_survivor n k =\n    let mutable a = [|1..n|]\n    while Array.length a > 1 do\n        a <- Array.append (Array.skip ((k - 1) % Array.length a + 1) a) (Array.take ((k - 1) % (Array.length a)) a)\n    Array.head a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84463,"user_id":null,"body":"let josephus_survivor n k =\n    let rec recursiveAdd n k=\n        if n = 1 then\n            1\n        else\n            ((recursiveAdd (n - 1) k) + k - 1) % n + 1\n\n    recursiveAdd n k\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84464,"user_id":null,"body":"open System.Collections.Generic\n\nlet private getNextSurvivor (lastSurvivor: int LinkedListNode)  = \n    if not <| isNull lastSurvivor.Next\n    then lastSurvivor.Next \n    else lastSurvivor.List.First\n\nlet rec private getNextToExecute (lastSurvivor: int LinkedListNode) = function\n    | 0 -> lastSurvivor\n    | n -> getNextToExecute (getNextSurvivor lastSurvivor) (n-1)\n\nlet private kill (personToKill: int LinkedListNode) (survivors: int LinkedList) =\n    survivors.Remove personToKill\n    survivors\n\nlet rec private josephus_survivorInternal (lastSurvivor: int LinkedListNode) (survivors: int LinkedList) stepsCount = function\n    | 1 -> lastSurvivor.Value\n    | stillAlive -> \n        let personToKill = getNextToExecute lastSurvivor (stepsCount-1) \n        let personNextToDead = getNextSurvivor personToKill\n        josephus_survivorInternal personNextToDead (survivors |> kill personToKill) stepsCount (stillAlive-1)\n\nlet josephus_survivor n k =\n    let survivors = seq { for i in 1..n -> i } |> LinkedList\n\n    josephus_survivorInternal survivors.First survivors k n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84465,"user_id":null,"body":"open System.Collections.Generic\n\nlet rollOnce (current: int LinkedListNode) (head: int LinkedListNode) = \n    if isNull current.Next then head else current.Next\n\nlet rec roll (current: int LinkedListNode) (head: int LinkedListNode) = function\n    | 0 -> current\n    | m ->  \n        let newCurrent = rollOnce current head\n        roll newCurrent head (m-1)\n\nlet kill (toKill: int LinkedListNode) (list:int LinkedList) =\n    list.Remove toKill\n    list\n\nlet rec josephus_survivorInternal  (current: int LinkedListNode) (list:int LinkedList) rollNumber = function\n    | 0 -> current.Value\n    | stillAlive -> \n        let toKill = roll current list.First rollNumber\n        let current = rollOnce toKill list.First\n        let survived = kill toKill list\n        josephus_survivorInternal current survived rollNumber (stillAlive - 1)\n\nlet josephus_survivor n k =\n    let list = seq {for i in 1..n -> i } |> LinkedList\n    let shouldBeDead = n-1\n    let numberOfRollsWithoutInitial = k-1\n\n    josephus_survivorInternal list.First list numberOfRollsWithoutInitial shouldBeDead","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84466,"user_id":null,"body":"let josephus_survivor n k =\n    let rec f m = function | 1 -> 0 | n -> ((f m (n - 1)) + m) % n\n    (f k n) + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84467,"user_id":null,"body":"let rec josephus_survivor n k =\n  if (n > 1) then\n    ((josephus_survivor (n - 1) k) + k - 1) % n + 1\n  else\n    1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"},{"id":84468,"user_id":null,"body":"open System.Collections.Generic\n\nlet josephus_survivor n k =\n    let rec eliminate (survivors:List<_>) index =\n      match survivors.Count with\n      | 1 -> survivors.[0]\n      | _ ->\n        let index = (index + k - 1) % survivors.Count\n        survivors.RemoveAt(index)\n        eliminate survivors index\n    \n    eliminate (List<_>({1..n})) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-06 15:32:35"}],"556deca17c58da83c00002db":[{"id":84469,"user_id":527,"body":"\/\/ I wish signature were a tuple\n#nowarn \"25\"\n\nlet tribonacci signature n =\n  signature\n    |> Seq.unfold (fun [a; b; c] -> Some (a, [b; c; a + b + c]))\n    |> Seq.take n\n    |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84470,"user_id":null,"body":"let tribonacci signature n =\n    signature\n    |> Seq.unfold (fun [a;b;c] -> Some (a, [b;c; a+b+c]))\n    |> Seq.take n\n    |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84471,"user_id":372,"body":"open System\n\nlet tribonnacciStep = fun (a,b,c)->Some(a+b+c, (b, c, a+b+c))\nlet tribonacciSeq = fun (a,b,c)-> Seq.unfold tribonnacciStep (a, b, c)\n  \nlet tribonacci signature n =\n  match signature with\n    | x::y::z::[] -> Seq.append [x;y;z] (tribonacciSeq (x, y, z)) |> Seq.take n |> Seq.toList\n    | _ -> []","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84472,"user_id":null,"body":"\nlet genTrib seq = seq |> List.skip (seq.Length - 3)\n                      |> List.sum\n\nlet rec genTribList n signature =\n    if n = 0 then signature\n    else\n    match signature with\n    | [] -> []\n    | [a] -> [a]\n    | [a; b] -> [a; b]\n    | x -> [genTrib signature]\n           |> List.append signature\n           |> genTribList (n - 1)\n\nlet tribonacciFunc n (signature: int list) =\n    let length = signature |> List.length\n    if n = 0 then []\n    else if n < length then [signature.[n-1]]\n    else genTribList (n - length) signature\n                      \nlet tribonacci signature n = tribonacciFunc n signature\n    ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84473,"user_id":null,"body":"let rec tribonacci' acc a b c n =\n    if n = 0\n    then List.rev acc\n    else tribonacci' (a :: acc) b c (a + b + c) (n - 1)\n\nlet tribonacci signature n =\n    match signature with\n    | [a; b; c] -> tribonacci' [] a b c n\n    | _ -> invalidArg \"signature\" \"List must have exactly three elements.\"\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84474,"user_id":null,"body":"let rec tribonacci signature n =\n    match n with\n    | 0 -> []\n    | _ -> (List.head signature) :: (tribonacci (List.concat [List.tail signature; [signature |> List.sum]]) (n-1))","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84475,"user_id":1686,"body":"let rec trb (signature : int list) n =\n    match n with\n    | 1 -> signature.[0]\n    | 2 -> signature.[1]\n    | 3 -> signature.[2]\n    | _ -> (trb signature (n - 1)) + (trb signature (n - 2)) + (trb signature (n - 3))\n    \nlet tribonacci (signature : int list) n = [1 .. n] |> List.map(fun x -> trb signature x)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84476,"user_id":null,"body":"\nlet tribonacci signature n = (* your code here! *)\n    let rec s (sign: int array) = seq {\n        yield sign.[0]\n        yield! s [|sign.[1]; sign.[2]; Array.sum sign|]\n    }\n    s (signature |> Array.ofList) |> Seq.take n |> List.ofSeq","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84477,"user_id":null,"body":"let tribonacci signature n =\n    let generator state =\n        let next: int = state |> List.sum\n        Some(next, [ state.[1]; state.[2]; next ])\n\n    seq {\n        yield! signature\n        yield! Seq.unfold generator signature\n    }\n    |> Seq.take n\n    |> Seq.toList\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84478,"user_id":null,"body":"let tribSeq initValues = \n    let mutable lastThree = List.take 3 initValues |> Array.ofList\n    seq {\n        yield lastThree.[0]\n        yield lastThree.[1]\n        yield lastThree.[2]\n        while (true) do\n            let next = Array.sum lastThree\n            lastThree <- [| lastThree.[1]; lastThree.[2]; next |]\n            yield next\n        \n    }\n\nlet tribonacci signature n = \n    tribSeq signature |> Seq.take n |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"556e0fccc392c527f20000c5":[{"id":84479,"user_id":null,"body":"#nowarn \"0025\"\n\nlet xbonacci (s: int list) (n : int) : int list =\n  let getNextTerm (head :: tail) =\n    Some(head, tail @ [head + List.sum tail])\n  s\n  |> Seq.unfold getNextTerm\n  |> Seq.take n\n  |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84480,"user_id":491,"body":"let xbonacci (seedList: int list) (count : int) : int list =\n    let rec generateNacci seedList = seq {\n        yield List.sum seedList\n        yield! List.tail seedList @ [List.sum seedList] |> generateNacci \n    }\n    seq { yield! seedList; yield! generateNacci seedList } |> Seq.take count |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84481,"user_id":null,"body":"let xbonacci (s: int list) (n : int) : int list =\n    s\n    |> Seq.unfold (fun (x::xs) -> Some(x, xs @ [x + (List.sum xs)]))\n    |> Seq.take n\n    |> Seq.toList","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84482,"user_id":null,"body":"let xbonacci (s: int list) (n: int) : int list =\n    let rec se (signatue: int list) =\n        seq {\n            yield signatue |> List.head\n            let tail = signatue |> List.tail\n            yield! se (List.append tail [ (signatue |> List.sum) ])\n        }\n\n    se s |> Seq.take n |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84483,"user_id":null,"body":"let xbonacci (s: int list) (n : int) : int list =\n  let rec xbo (lst: int list) =\n    match lst.Length=n with\n      | true -> lst\n      | false -> xbo (lst @ [lst.[lst.Length-s.Length..] |> List.sum])\n  xbo (s |> List.truncate n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84484,"user_id":null,"body":"let xbonacci (s: int list) (n : int) : int list =\n  let rec xbo (lst: int list) =\n    match lst.Length=n with\n      | true -> lst\n      | false -> xbo (lst @ [lst.[lst.Length-s.Length..] |> List.sum])\n  match s.Length >= n with\n    | true -> s |> List.take n\n    | false -> xbo s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84485,"user_id":null,"body":"let xbonacci (s: int list) (n : int) : int list =\n  let length = List.length s\n  let take = System.Math.Max(n - length, 0)\n  let unfold (l: int list) = \n    let sum = \n        l\n        |> List.skip (List.length l - length)\n        |> List.sum\n    let res = (sum, l @ [sum])\n    Some(res)\n  let items = \n    s\n    |> Seq.unfold unfold\n    |> Seq.take take\n    |> Seq.toList\n  let all = s @ items\n  List.take n all\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84486,"user_id":null,"body":"let xbonacci (s: int list) (n : int) : int list =\n  let len = s.Length\n  let rec xib =\n    seq {\n      yield! s\n      for window in xib |> Seq.windowed len do\n        yield Seq.sum window\n    }\n    \n  xib\n  |> Seq.take n\n  |> Seq.toList\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84487,"user_id":null,"body":"let xbonacci (s : int list) (n : int) : int list =\n    let rec xbonacci (s : int list) =\n        seq {\n            let sum = List.sum s\n            yield sum\n            yield! xbonacci (List.tail s @ [sum])\n        }\n\n    let c = List.length s\n    if n <= c then\n        List.take n s\n    else\n        s @ (xbonacci s |> Seq.take (n - c) |> Seq.toList)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84488,"user_id":null,"body":"let xbonacci (s: int list) (n : int) : int list =\n    let rec f (acc: int list) (xs: int list) (m: int) =\n            match m with\n            | 0 -> acc |> List.rev\n            | _ -> let k = xs |> List.sum\n                   f (k::acc) ((xs |> List.tail) @ [k]) (m - 1)\n    \n    let n' = if n <= s.Length then 0 else n - s.Length\n    s @ f [] s n' |> List.take n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"558fc85d8fd1938afb000014":[{"id":84489,"user_id":null,"body":"let sum_two_smallest_numbers (numbers:int64[]) = \n    numbers \n    |> Array.sort\n    |> Array.take 2\n    |> Array.sum","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84490,"user_id":null,"body":"let sum_two_smallest_numbers = Seq.sort >> Seq.take 2 >> Seq.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84491,"user_id":null,"body":"let sum_two_smallest_numbers numbers = \n  numbers |> Seq.sort |> Seq.take 2 |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84492,"user_id":null,"body":"let sum_two_smallest_numbers numbers =\n    if Array.length numbers < 2 then\n        invalidArg \"numbers\" \"The array must have at least two elements.\"\n\n    numbers\n    |> Array.fold\n        (fun (x, y) z ->\n            if z < x\n            then z, x\n            else if z < y\n            then x, z\n            else x, y)\n        (System.Int64.MaxValue, System.Int64.MaxValue)\n    ||> (+)\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84493,"user_id":null,"body":"open System\n\nlet initial = (Int64.MaxValue, Int64.MaxValue)\nlet action (a, b) c = if c < a then (c, a) else if c < b then (a, c) else (a, b)\nlet least2 = Array.fold action initial\nlet sum_two_smallest_numbers numbers = least2 numbers |> (fun (a, b) -> a + b)\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84494,"user_id":null,"body":"let sum_two_smallest_numbers numbers = \n  let sortedArray = numbers |> Array.sort\n  sortedArray.[0] + sortedArray.[1]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84495,"user_id":null,"body":"let sum_two_smallest_numbers (numbers:int64[]) =\n    let max = Array.length numbers\n    let rec findsmallest (s1:option<int64>) (s2:option<int64>) i =\n        if i >= max then (s1,s2) else\n        let cur = numbers.[i]\n        if s1.IsNone then\n            findsmallest (Some cur) s2 (i+1)\n        else if s2.IsNone then\n            findsmallest s1 (Some cur) (i+1)\n        else if cur < s1.Value && s1.Value >= s2.Value then\n            findsmallest (Some cur) s2 (i+1)\n        else if cur < s2.Value && s2.Value >= s1.Value then\n            findsmallest s1 (Some cur) (i+1)\n        else\n            findsmallest s1 s2 (i+1)\n    let (sm1, sm2) = findsmallest None None 0\n    sm1.Value + sm2.Value","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84496,"user_id":null,"body":"let rec cutAndCompare a b numbers =\n    let min, almostMin = match a < b with\n    | true -> a, b\n    | false -> b, a\n\n    match numbers with\n    | head :: tail when head < almostMin -> cutAndCompare min head tail\n    | _ :: tail -> cutAndCompare min almostMin tail\n    | [] -> min + almostMin\n\n\n\nlet sum_two_smallest_numbers numbers =\n    numbers\n    |> Array.toList\n    |> cutAndCompare System.Int64.MaxValue System.Int64.MaxValue","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84497,"user_id":null,"body":"let sum_two_smallest_numbers numbers = \n  let sorted=\n    numbers\n    |> Array.map (fun e->int64(e))\n    |>  Array.sort \n    \n  sorted.[..  1]\n  |>Array.sum ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84498,"user_id":null,"body":"let sum_two_smallest_numbers numbers =\n    let a = Seq.min numbers\n    let b = Seq.filter (fun n -> n > a) numbers |> Seq.min\n    a + b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5592e3bd57b64d00f3000047":[{"id":84499,"user_id":null,"body":"\/\/ The sum of cubes of all integers 1..n (if you know n)\n\/\/ can be calculated as:\n\/\/ \n\/\/ m = n^2(n+1)^2 \/ 4\n\/\/\n\/\/ But we're given m and need to find m.\n\/\/ \n\/\/ 4m = n^2(n+1)^2\n\/\/ SQRT(4m) = n(n+1) = n^2+n\n\/\/\n\/\/ So we can take SQRT(SQRT(4m)) and we should be just\n\/\/ above n. The hard part is then finding the right\n\/\/ data types to be able to take a sqrt and not run out\n\/\/ of precision for large m...\nlet find_nb(m: uint64): int =\n    let sqrt4m = (m |> float |> sqrt) * 2.0\n    let n = sqrt4m |> sqrt |> floor |> decimal\n\n    let testM = (n*n*(n+1M)*(n+1M))\/4M\n    if testM = decimal(m) then int(n)\n    else -1","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84500,"user_id":null,"body":"let inline cube x = x * x * x\n\nlet find_nb(volume: uint64): int =\n    let rec find_nb' acc size =\n        match (acc + cube (uint64 size)) with\n        | x when x = volume -> size\n        | x when x < volume -> find_nb' x (size + 1)\n        | _ -> -1\n    \n    find_nb' 0UL 1\n    ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84501,"user_id":492,"body":"let find_nb(n: uint64): int =\n    let kk = uint64(floor (sqrt(sqrt(4.0 * (float n)))))\n    if (4UL * n = kk * kk * (kk + 1UL) * (kk + 1UL)) then\n        int kk\n    else\n        -1","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84502,"user_id":null,"body":"let find_nb (n : uint64): int =\n  let rec loop volume i =\n    if volume > n then -1\n    elif volume = n then (int i)-1\n    else loop (volume + i*i*i) (i+1UL)\n  loop 0UL 1UL","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84503,"user_id":null,"body":"let isqrt num =\n  if num > 0UL then\n    let inline reduce n = (num \/ n + n) \/ 2UL\n    let rec impl n = function\n      | n' when n' <= n -> n'\n      | _               -> impl (reduce n) n\n    let n = num \/ 2UL + 1UL\n    impl (reduce n) n\n  else num\n\nlet find_nb (m: uint64): int =\n  let mr = isqrt m\n  if mr * mr <> m then\n    -1\n  else\n    let a = 1UL + 8UL * mr\n    let ar = isqrt a\n    if ar * ar <> a || ar % 2UL = 0UL then\n      -1\n    else\n      int ((ar - 1UL) \/ 2UL)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84504,"user_id":491,"body":"let find_nb n =\n    let root = (-1.0 + sqrt(1.0 + 4.0 * sqrt(float(n)) * 2.0)) \/ 2.0\n    let testSolution = uint64(root) * (uint64(root) + 1UL) \/ 2UL\n    if testSolution * testSolution = n then int(root) else -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84505,"user_id":null,"body":"let find_nb(m: uint64): int =\n  let rec calculateLayer n v =\n    let x = uint64 n\n    let current = (x * x * x) + v\n    match current with\n    | current when current > m -> -1\n    | current when current = m -> n\n    | current when current < m -> calculateLayer (n + 1) current\n    | _ -> -1\n  calculateLayer 1 0UL","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84506,"user_id":null,"body":"let find_nb(n: uint64): int =\n    let sqr = sqrt (float n)\n    let guess = uint64 (sqrt (sqr*2.))\n    if ((guess*guess*(guess+1UL)*(guess+1UL)).Equals(n*4UL)) then int guess\n    else -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84507,"user_id":null,"body":"let find_nb (n: uint64) : int =\n    let s =\n        Seq.initInfinite (uint64 >> id >> ((+) 1UL))\n        |> Seq.mapi (fun i j -> (i + 1), (pown j 3))\n        |> Seq.scan (fun (_, k) (i, j) -> (i, j + k)) (0, 0UL)\n        |> Seq.skipWhile (snd >>((>) n))\n        |> Seq.head\n\n    if snd s > n then -1 else fst s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84508,"user_id":null,"body":"let find_nb(m: uint64): int =\n    let mutable state = 0uL\n    Seq.initInfinite id\n    |> Seq.takeWhile (fun _ -> state < m)\n    |> Seq.tryFind (fun i ->\n        let i = uint64 i\n        state <- state + (i*i*i)\n        state = m\n    )\n    |> Option.defaultValue -1\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"559536379512a64472000053":[{"id":84509,"user_id":null,"body":"let play_pass s shift =\n    let bases = [| int 'A'; int 'a' |]\n    s\n    |> Seq.mapi (\n        fun index ->\n            function\n            | c when c >= '0' && c <= '9' ->\n                char <| int '9' - (int c - int '0')\n            | c when c >= 'A' && c <= 'Z' ->\n                char <| bases.[index % 2] + (int c - int 'A' + shift) % 26\n            | c -> c)\n    |> Seq.rev\n    |> Seq.toArray\n    |> System.String\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84510,"user_id":null,"body":"open System\nlet play_pass (s: string) (shift: int) : string =\n    let shift (c:char) = char <| (int c - int 'A' + shift) % 26 + int 'A'\n    s\n    |> Seq.mapi(\n        fun index value -> \n            match value with\n                | _ when Char.IsLetter value\n                    -> if index%2 = 0 then Char.ToUpper <| shift value else Char.ToLower <| shift value\n                | _ when Char.IsDigit value\n                    -> char <| int ('9'+'0') - int value\n                | _ -> value\n    )|> Seq.rev\n    |> Seq.toArray\n    |> System.String","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84511,"user_id":492,"body":"let play_pass (s: string) (shift: int) : string =\n    let rotateLetter c =\n        let alphabet = if System.Char.IsUpper c then ['A' .. 'Z'] else ['a' .. 'z'] in\n        List.findIndex ((=) c) alphabet\n            |> (fun idx -> (idx + shift) % 26)\n            |> (fun newIdx -> alphabet.[newIdx])\n    in \n    let rec charMutations = function\n        | [] -> []\n        | next::rest when System.Char.IsLetter next -> (rotateLetter next) :: (charMutations rest)\n        | next::rest when System.Char.IsDigit next -> (next |> string |> int |> (fun x -> 9 - x) |> string |> char) :: (charMutations rest)\n        | next::rest -> next :: (charMutations rest)\n    in\n    let mutateCase (cs: char list) = \n        let isEven x = (x % 2) = 0 in\n        let swapCaseIfNeeded idx c = \n            if System.Char.IsLetter c then\n                if isEven idx \n                then System.Char.ToUpper c\n                else System.Char.ToLower c\n            else c\n        in\n        List.mapi (swapCaseIfNeeded) cs\n    in\n    List.ofSeq s\n    |> charMutations\n    |> mutateCase\n    |> List.rev\n    |> List.map string\n    |> List.fold (+) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84512,"user_id":null,"body":"let shift(c : char, shiftAmount : int) : char = \n     let num = int(c) - int('A')\n     let offsetNum = (num+shiftAmount)%26\n     let result = offsetNum + int('A')\n     if offsetNum < 0 then\n        char(int('Z') + offsetNum + 1)\n     else\n        char(offsetNum + int('A'))\n  \nlet shiftNumber(c : char, shiftAmount : int) : char = \n    match c with\n    | '0' -> '9'\n    | '1' -> '8'\n    | '2' -> '7'\n    | '3' -> '6'\n    | '4' -> '5'\n    | '5' -> '4'\n    | '6' -> '3'\n    | '7' -> '2'\n    | '8' -> '1'\n    | '9' -> '0'\n    | _ -> printfn \"ERROR\" |> ignore |> exit 1\n\nlet play_pass (s: string) (shiftAmount: int) : string = \n    let s_arr = s.ToCharArray()\n    let mutable t_arr = [||]\n    for i = 0 to (s_arr.GetLength(0) - 1) do\n        if System.Char.IsLetter(Array.get s_arr i) then\n            if i % 2 = 0 then\n                t_arr <- Array.append t_arr [|yield System.Char.ToUpper <| shift(char(Array.get s_arr i), shiftAmount)|]\n            else\n                t_arr <- Array.append t_arr [|yield System.Char.ToLower <| shift(char(Array.get s_arr i), shiftAmount)|]\n        elif System.Char.IsNumber(Array.get s_arr i) then\n            t_arr <- Array.append t_arr [|yield shiftNumber(char(Array.get s_arr i), shiftAmount)|]\n        else\n            t_arr <- Array.append t_arr [|yield Array.get s_arr i|]\n            \n    t_arr <- Array.rev <| t_arr\n    new System.String(t_arr)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84513,"user_id":null,"body":"open System\nlet ``shift number`` digit = char (9 - (int digit) + 2 * (int '0'))\nlet ``shift letter`` letter shift = char (((int letter)-(int 'A') + shift) % 26 + (int 'A'))\n\nlet ``shift and move`` (v: int) (c: char) = \n  match c with \n  | digit when Char.IsDigit digit -> ``shift number`` digit\n  | letter when Char.IsUpper letter -> ``shift letter`` letter v\n  | _ -> c\n  \nlet ``covert even letter`` i c =\n  if Char.IsLetter c && i % 2 = 1 then\n    Char.ToLower c\n  else\n    c\n  \nlet play_pass (s: string) (shift: int) : string =\n  s\n  |> Seq.map (``shift and move`` shift)\n  |> Seq.mapi ``covert even letter``\n  |> Seq.rev\n  |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84514,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet alphabet = [\"A\"; \"B\"; \"C\"; \"D\"; \"E\"; \"F\"; \"G\"; \"H\"; \"I\"; \"J\"; \"K\"; \"L\"; \"M\"; \"N\"; \"O\"; \"P\"; \"Q\"; \"R\"; \"S\"; \"T\"; \"U\"; \"V\"; \"W\"; \"X\"; \"Y\"; \"Z\"];\n\nlet (|Int|_|) (str:string) =\n  match System.Int32.TryParse str with\n  | true,int -> Some int\n  | _ -> None\n\nlet (|Letter|_|) (input:string) =\n  let m = Regex.Match(input, \"^[a-zA-Z]+$\")\n  if m.Success then Some input\n  else None  \n  \nlet maybeCapitalize position (s: string) =\n  match position with\n    | x when x % 2 <> 0 -> s.ToLower()\n    | _ -> s\n\nlet rec shiftList i arr =\n    match arr with\n    | head :: tail when i > 0 -> shiftList (i - 1) (tail @ [head])\n    | _ -> arr\n\nlet convert x position shift =\n  match x with\n    | Int i -> (9 - i) |> string\n    | Letter l -> \n        let shiftedAlphabeth = shiftList shift alphabet\n        let index = alphabet |> List.findIndex ((=) l) \n        maybeCapitalize position (shiftedAlphabeth.Item(index))\n    | s -> s\n\n\nlet play_pass (s: string) (shift: int) : string =\n  Seq.toList s \n    |> Seq.map string \n    |> Seq.mapi(fun i x -> convert x i shift) \n    |> Seq.rev \n    |> String.concat \"\"\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84515,"user_id":null,"body":"let play_pass (s: string) (shift: int) : string =\n  let modu x = x % 26\n  s\n  |> Seq.map (fun c ->\n    match (c |> int) with\n    | x when x >= 65 && x <= 90 -> x |> int |> (+) -65 |> (+) shift |> modu |> (+) 65 |> char\n    | x when x >= 48 && x <= 57 -> x |> int |> (+) -48 |> (-) 9 |> (+) 48 |> char\n    | _ -> c)\n  |> Seq.mapi (fun i x -> if (i%2=0) then x else System.Char.ToLower x)\n  |> Seq.rev\n  |> Array.ofSeq\n  |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84516,"user_id":null,"body":"open System\n\nlet play_pass (s: string) (shift: int) : string =\n  s\n  |> Seq.map (fun c ->\n    if Char.IsLetter c then\n      (int c - int 'A' + shift) % 26 + int 'A' |> char\n    elif Char.IsDigit c then\n      9 - (int c - int '0') + int '0' |> char\n    else c)\n  |> Seq.mapi (fun i c ->\n    if i % 2 = 0 then string c\n    else Char.ToLower c |> string)\n  |> Seq.rev\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84517,"user_id":null,"body":"let reverse (s : string) = s |> Seq.rev |> System.String.Concat\n\nlet strongifer (shift: int) (idx: int) (c: char) : char =\n    let n = shift % 26 \/\/ 26 - number of letters\n    let mutable ic = (int)c\n    let a, z, A, Z = ((int)'a', (int)'z', (int)'A', (int)'Z') \n    if ic >= a && ic <= z then \n        ic <- a + ((ic - a + n) % 26)\n        if idx % 2 = 0 then  ic <- ic &&& ~~~(0x20)    \/\/ ToUpper if idx is even (unset bit 6)\n    elif ic >= A && ic <= Z then \n        ic <- A + ((ic - A + n) % 26)\n        if idx % 2 <> 0 then  ic <- ic ||| 0x20        \/\/ ToLower if idx is odd (set bit 6)\n    elif ic >= (int)'0' && ic <= (int)'9' then\n        ic <- (int)'0' + (int)'9' - ic\n    (char) ic\n\nlet play_pass (s: string) (shift: int) : string =\n  String.mapi (strongifer shift) s |> reverse\n    \n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84518,"user_id":null,"body":"open System\n\nlet toInt (c: char) = int c - int '0'\nlet getASCIILetter i = (if i > 90 then i % 91 + 65 else i) |> char\n\nlet play_pass s shift =\n    s |> String.mapi (fun i ch -> if Char.IsDigit ch then\n                                        ch\n                                        |> toInt\n                                        |> (-) 9\n                                        |> string\n                                        |> char\n                                  elif Char.IsLetter ch then\n                                        ch \/\/ \u0431\u0435\u0440\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b\n                                        |> int \/\/ ASCII \u0432 int\n                                        |> (+) (shift % 26) \/\/ \u0434\u0432\u0438\u0433\u0430\u0435\u043c\n                                        |> getASCIILetter \/\/ int \u0432 ASCII\n                                        |> if i % 2 = 0 then Char.ToUpper else Char.ToLower\n                                  else ch)\n    |> Seq.rev\n    |> Seq.map string\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5596f6e9529e9ab6fb000014":[{"id":84519,"user_id":null,"body":"let ShiftedDiff (first : string) (second : string) : int = \n              match (first, second) with\n                | (a , b) when a.Length <> b.Length -> -1\n                | (a , b) -> (b + b).IndexOf a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84520,"user_id":null,"body":"let ShiftedDiff (first : string) (second : string) = \n  if String.length first <> String.length second then\n    -1\n  else\n    (second + second).IndexOf(first)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84521,"user_id":null,"body":"let shift' (xs: string):string = \n  let l = Seq.length xs;\n  (Seq.concat [Seq.skip (l-1) xs; Seq.take (l-1) xs] |> Seq.take l|> Seq.toArray |> System.String)\n\nlet ShiftedDiff (first : string) (second : string): int = \n    let rec shift (first': string) (second': string) (shifted: int):int = \n             if first' =second' then \n                   shifted \n             else if shifted >= Seq.length first' then\n               -1\n             else \n               shift (shift' first') second' (shifted+1)\n    shift first second 0 \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84522,"user_id":null,"body":"open System.Collections.Generic\n\nlet rotate (input: string) (value: int) =\n    let actualValue = value % input.Length\n    match input with\n    | \"\" -> \"\"\n    | _ -> input.Substring(input.Length - actualValue) + input.Substring(0, input.Length - actualValue)\n    \nlet ShiftedDiff (first : string) (second : string) : int =\n    try\n        {0 .. first.Length - 1}\n        |> Seq.find (fun el -> rotate first el = second)\n    with | :? KeyNotFoundException -> -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84523,"user_id":null,"body":"let ShiftedDiff (first : string) (second : string) =\n  if ((String.length first) = (String.length second)) then\n    (second + second).IndexOf(first)\n  else\n    -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84524,"user_id":53,"body":"let ShiftedDiff (a : string) (b : string) : int = \n  match (a, b) with\n    | (a , b) when a.Length <> b.Length -> -1\n    | (a , b) -> (b + b).IndexOf a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84525,"user_id":null,"body":"let ShiftedDiff (first : string) (second : string) =\n  let rec shift (f: string) (s: string) (c: int) =\n    if c > f.Length || not (f.Length = s.Length) then -1\n    else\n      match f = s with\n      | true -> c\n      | false -> shift (f.[f.Length-1..] + f.[0..(f.Length-2)]) s (c+1)\n  shift first second 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84526,"user_id":325,"body":"open System\n\nlet ShiftedDiff (first : string) (second : string) = \n    let position =\n      (first + first).IndexOf(second)\n\n    if String.IsNullOrWhiteSpace(first) then\n        -1\n    elif position <= 0 then\n        position\n    else\n        first.Length - position","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84527,"user_id":null,"body":"let ShiftedDiff (first : string) (second : string) = \n    (second, first)\n    ||> Seq.scan (fun s _ ->  s.[1..] + (string s.[0]))\n    |> Seq.indexed\n    |> Seq.skipWhile (fun (_, permuted) -> permuted <> first)\n    |> Seq.tryHead\n    |> Option.map fst\n    |> Option.defaultValue -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84528,"user_id":null,"body":"let partL list i =\n    [list\n        |> Seq.take i\n        |> List.ofSeq;\n    list\n        |> Seq.skip i\n        |> List.ofSeq]\n\nlet ShiftedDiff (first : string) (second : string) = \n    let rec getFirstItemMatched acc = function\n        | [] -> acc\n        | s::rest ->\n            let firstItem =  first |> List.ofSeq |> List.head\n            if firstItem = s then getFirstItemMatched acc []\n            else getFirstItemMatched (acc+1) rest\n    in\n    let l = first.Length\n    let targetNode = getFirstItemMatched 0  (second |> List.ofSeq)\n    let fPart = partL first (l - targetNode)\n    let sPart = (partL second targetNode) |> List.rev\n    let isValid = List.zip fPart sPart\n                    |> List.forall (fun (a,b) -> a = b)\n    in\n    if isValid then targetNode\n    else -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"559a28007caad2ac4e000083":[{"id":84529,"user_id":null,"body":"open System.Numerics  \nlet perimeter (n: BigInteger): BigInteger =\n  (1I, 1I)\n  |> Seq.unfold (fun (first, second) -> Some(first, (second, first + second)))\n  |> Seq.take (int n + 1)\n  |> Seq.sum\n  |> (*) 4I\n  ","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84530,"user_id":null,"body":"open System.Numerics \n\nlet fibonacci = Seq.unfold (fun (u, v) -> Some(u, (v, u + v))) (1I, 1I)\n    \nlet perimeter (n: BigInteger): BigInteger =\n    fibonacci\n    |> Seq.take (int n + 1)\n    |> Seq.sum\n    |> (*) 4I","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84531,"user_id":492,"body":"open System.Numerics  \nlet perimeter (n: BigInteger): BigInteger =\n    let rec loop acc1 acc2 = function\n        | n when n = 0I -> acc1\n        | n -> loop acc2 (acc1 + acc2) (n - 1I)\n    4I * ((loop 1I 1I (n + 2I)) - 1I)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84532,"user_id":492,"body":"open System.Numerics  \nlet perimeter (n: BigInteger): BigInteger =\n    let rec loop acc1 acc2 = function\n        | n when n = 0I -> acc1\n        | n -> loop acc2 (acc1 + acc2) (n - 1I)\n    4I * ((loop 1I 1I (n + 2I)) - 1I)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84533,"user_id":null,"body":"open System.Collections.Generic\nopen System.Numerics\n\nlet mem = Dictionary<BigInteger, BigInteger>()\n\nlet rec fib (n:BigInteger) : BigInteger =\n   match mem.TryGetValue n with\n   | true, a -> a\n   | false, _ -> \n       match n with\n       | a when a  = 1I -> 1I\n       | a when a = 2I -> 1I\n       | a ->\n           let value = fib (a - 1I) + fib (a - 2I)\n           mem.Add(n, value)\n           value\n\nlet perimeter (n: BigInteger): BigInteger =\n   [1I..n + 1I]\n   |> List.map fib\n   |> List.sum\n   |> (fun i -> i * 4I)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84534,"user_id":null,"body":"open System.Numerics  \nlet perimeter (n: BigInteger): BigInteger =\n    seq {\n        yield 0I\n        yield 1I\n\n        yield!\n            Seq.unfold\n                (fun (a, b) ->\n                    let thisRound = a + b\n                    Some(thisRound, (b, thisRound)))\n                (0I, 1I)\n    }\n    |> Seq.map ((*) 4I)\n    |> Seq.take (int n + 2)\n    |> Seq.reduce (+)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84535,"user_id":null,"body":"open System.Numerics\n\nlet perimeter n =\n    let fib_generator (a, b) = Some(a, (b, a + b))\n    Seq.unfold fib_generator (1I, 1I)\n    |> Seq.take (int n + 1)\n    |> Seq.sum\n    |> (*) 4I","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84536,"user_id":null,"body":"open System.Numerics  \nlet perimeter (n: BigInteger): BigInteger =\n    seq {\n        yield 1I\n        yield 1I\n        yield! Seq.unfold (fun (a,b) -> Some (a+b, (b, a+b))) (1I,1I)\n    }\n    |> Seq.take (int n+1)\n    |> Seq.reduce (+)\n    |> fun s -> s*4I","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84537,"user_id":null,"body":"open System.Numerics  \nlet perimeter (n: BigInteger): BigInteger =\n  let rec loop i current prev state =\n      if i = n then state\n      else loop (i + 1I) (current + prev) current (state + current)\n  4I * loop 0I 1I 1I 1I\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84538,"user_id":null,"body":"open System\nopen System.Numerics\n\nlet fib n =\n  [|1I..n|]\n  |> Array.fold (fun (a,b) _ -> b, a + b) (0I,1I)\n  |> fst\n\nlet perimeter (n: BigInteger): BigInteger =\n  [for x in [1I..(n+1I)] do yield fib x]\n  |> List.sum\n  |> (fun x -> 4I * x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"559b8e46fa060b2c6a0000bf":[{"id":84539,"user_id":null,"body":"let choose n k =\n    { 1 .. k }\n    |> Seq.fold (fun acc i -> bigint (n - k + i) * acc \/ bigint i) 1I\n\nlet diagonal (n, p) = choose (n + 1) (p + 1)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84540,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet choose(n:int, p:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to p do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\n\nlet diagonal(n:int, p:int): BigInteger =\n    choose(n + 1, p + 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84541,"user_id":null,"body":"let binomial n p =\n    let inline fact (x: int): bigint = [ 1I .. bigint x ] |> Seq.reduce ( * )\n    let hiDenom = max (n - p) p\n    let loDenom = min (n - p) p\n    ([ bigint (hiDenom + 1) .. (bigint n) ] |> Seq.fold ( * ) (bigint 1))\n        \/\n    (fact loDenom)\n\nlet diagonal(n:int, p:int): bigint =\n    binomial (n + 1) (p + 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84542,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet choose(n:int, p:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to p do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\n\nlet diagonal(n:int, p:int): BigInteger =\n    choose(n + 1, p + 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84543,"user_id":53,"body":"open System  \nopen System.Numerics \n\nlet choose(n:int, k:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to k do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\n    \nlet diagonal(n:int, p:int): BigInteger =\n    choose(n + 1, p + 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84544,"user_id":null,"body":"let getC (n: int) (p: int): bigint =\n  if (n < p || n < 0 || p < 0) then\n    (bigint 0)\n  else if (n = p) then \n    (bigint 1)\n  else\n    let rec getDiv (div: bigint) (mul: bigint) (result: bigint) =\n      match result with\n      | result when (result % div = 0I && div <= bigint(p)) -> getDiv (div + 1I) (mul) (result \/ div)\n      | result when mul > bigint(n) -> result\n      | _                   -> getDiv (div) (mul + 1I) (result * mul)\n    (getDiv 2I (bigint(n) - bigint(p) + 1I) 1I)\n\nlet diagonal (n:int, p:int): bigint =\n    (getC (n + 1) (p + 1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84545,"user_id":null,"body":"open System.Numerics\n\nlet factorial (upper: int) (lower: int) =\n    { lower .. upper } |> Seq.map BigInteger |> Seq.reduce (*)\n\nlet getPyramidElement (n, p) =\n    \/\/ I have no idea how this formula works. Thank you stackoverflow\n    (factorial n (n - p + 1)) \/ (factorial p 1)\n\nlet diagonal(n:int, p:int): BigInteger = getPyramidElement(n + 1, p + 1)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84546,"user_id":753,"body":"open System.Numerics\n\nlet factorial (n: int) = [1I..bigint(n)] |> List.fold (*) 1I\n    \nlet binomial (n: int) (k: int) = ([bigint(n-k+1)..bigint(n)] |> List.fold (*) 1I) \/ factorial k\n\nlet diagonal(n:int, p:int): BigInteger =\n    binomial (n+1) (p+1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84547,"user_id":null,"body":"open System.Numerics\n\nlet rec diag i p =\n  if p = 0 then\n    [|0..i|] |> Array.map (fun _ -> 1I)\n  else\n    let rightDiag = diag i (p-1)\n    [|1..i|]\n    |> Array.scan (fun state j -> state + rightDiag.[j]) 1I\n\nlet diagonal(n:int, p:int): BigInteger =\n    printf \"S(%i, %i)\" n p\n    let result =\n      diag (n-p) p\n      |> Array.sum\n    printfn \"=%A\" result\n    result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84548,"user_id":null,"body":"open System.Numerics\n\nlet leftmostSequence (n: int) = Seq.replicate (n+1) (BigInteger 1)\n\nlet buildSequenceToRight (s: BigInteger seq): BigInteger seq =\n  printfn \"current sequence: %A\" s\n  match Seq.isEmpty s with\n    | true -> Seq.empty : BigInteger seq\n    | false -> Seq.scan (+) (BigInteger 0) s |> Seq.tail\n    \nlet rec buildPthSequence (s: BigInteger seq) (p: int) =\n  match p > 0 with\n    | false -> s\n    | true -> buildPthSequence (buildSequenceToRight s) (p - 1)\n    \nlet diagonal(n:int, p:int): BigInteger =\n    let sequence = buildPthSequence (leftmostSequence n) p\n    Seq.take (n - p + 1) sequence |> Seq.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"559ce00b70041bc7b600013d":[{"id":84549,"user_id":492,"body":"let finance m =\n    let n = uint64(m)\n    n * (n * n + 3UL * n + 2UL) \/ 2UL\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84550,"user_id":492,"body":"let finance m =\n    let n = uint64(m)\n    n * (n * n + 3UL * n + 2UL) \/ 2UL\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84551,"user_id":null,"body":"let finance m = \n  let m0 = uint64 m\n  (m0 + 1UL) * (m0 + 2UL) \/ 2UL * m0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84552,"user_id":null,"body":"let finance m =\n    let n = uint64 m\n    ((n*n*n) + 3UL * (n*n) + 2UL * n) \/ 2UL\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84553,"user_id":53,"body":"let finance m =\n    let n = uint64(m)\n    n * (n + uint64(1)) * (n + uint64(2)) \/ uint64(2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84554,"user_id":168,"body":"let finance m = \n  let n = uint64 m\n  n * (n + 1UL) * (n + 2UL) \/ 2UL","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84555,"user_id":null,"body":"let finance m =\n  [(m * 2).. -2 ..0] |>\n  List.mapi (fun i x -> ((2 * x + i) * (i + 1)) \/ 2) |>\n  List.map uint64 |>\n  List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84556,"user_id":null,"body":"open System\nlet finance m =\n  uint64(Math.Round(0.5 * float(m) * float(m+1) * float(m+ 2)))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84557,"user_id":null,"body":"let finance m =\n\n  let ceilHalf x = (x + 1) \/ 2\n  \n  let coeff i =\n    let pos = min i (2 * (m + 1) - i)\n    ceilHalf pos\n\n  Seq.init (2 * m + 1) (fun i -> (i * (coeff (i + 1))))\n  |> Seq.map uint64\n  |> Seq.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84558,"user_id":564,"body":"let finance64 (n:uint64) =\n    n * (n + 1UL) * (n + 2UL) \/ 2UL\n\nlet finance (n:int) =\n    finance64 (uint64 n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"559e3224324a2b6e66000046":[{"id":84559,"user_id":null,"body":"let sumin n = n * (n + 1UL) * (2UL * n + 1UL) \/ 6UL\nlet sumax n = n * (n + 1UL) * (4UL * n - 1UL) \/ 6UL\nlet sumsum n = n * n * (n + 1UL)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84560,"user_id":null,"body":"let sumN n f =\n    seq {\n        for i in 1UL .. n ->\n            f n i\n    }\n    |> Seq.sum\n    \nlet sumin (n: uint64): uint64 =\n    sumN n (fun n i -> i * (2UL * (n - i) + 1UL))\n        \nlet sumax (n: uint64): uint64 =\n    sumN n (fun n i -> i * (2UL * n - i))\n    \nlet sumsum (n: uint64): uint64 =\n    sumN n (fun n i -> seq { i + 1UL .. n + i } |> Seq.sum)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84561,"user_id":53,"body":"let sumin (n: uint64): uint64 =\n    uint64(n * uint64(n+uint64(1)) * uint64(uint64(2) * n + uint64(1)) \/ uint64(6))\nlet sumax (n: uint64): uint64 =\n    uint64(n * uint64(n+uint64(1)) * uint64(uint64(4) * n - uint64(1)) \/ uint64(6))\nlet sumsum (n: uint64): uint64 =\n    uint64(uint64(n+uint64(1)) * n * n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84562,"user_id":null,"body":"let sumin (n: uint64): uint64 =\n    [1..(int n)] |>\n    List.map int64 |>\n    List.map (fun x -> (2L * (int64 n) - 2L * x + 1L) * x) |>\n    List.sum |> uint64\n    \nlet sumax (n: uint64): uint64 =\n    [1..(int n)] |>\n    List.map int64 |>\n    List.map (fun x -> (2L * x - 1L) * x) |>\n    List.sum |> uint64\n    \nlet sumsum (n: uint64): uint64 =\n    sumin(n) + sumax(n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84563,"user_id":null,"body":"let suminMap n x = 2UL * x * n - (2UL * x * x - x)\nlet sumaxMap n x = 2UL * x * x - x\n\nlet sumCartesian n map =\n    [for i in 1UL .. n -> i]\n    |> List.sumBy (map n)\n\nlet sumin (n: uint64): uint64 = sumCartesian n suminMap\n    \nlet sumax (n: uint64): uint64 = sumCartesian n sumaxMap\n    \nlet sumsum (n: uint64): uint64 = sumin n + sumax n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84564,"user_id":null,"body":"let suminMap n x = 2UL * x * n - (2UL * x * x - x)\n\nlet sumaxMap n x = 2UL * x * x - x\n\nlet sumCartesian n map =\n    [for i in 1UL .. n -> i]\n    |> List.map (map n)\n    |> List.sum\n\nlet sumin (n: uint64): uint64 = sumCartesian n suminMap\n    \nlet sumax (n: uint64): uint64 = sumCartesian n sumaxMap\n    \nlet sumsum (n: uint64): uint64 = sumin n + sumax n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84565,"user_id":null,"body":"let sumin n =\n    let vals = { 1UL .. n }\n    vals\n    |> Seq.sumBy (fun x -> vals |> Seq.sumBy (fun y -> min x y))\n\nlet sumax n =\n    let vals = { 1UL .. n }\n    vals\n    |> Seq.sumBy (fun x -> vals |> Seq.sumBy (fun y -> max x y))\n\nlet sumsum n =\n    let vals = { 1UL .. n }\n    vals\n    |> Seq.sumBy (fun x -> vals |> Seq.sumBy (fun y -> min x y + max x y))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84566,"user_id":null,"body":"let sumin n =\n    let rec f acc a b =\n        match b with\n        | 1UL -> acc + a\n        | _ -> f (acc + a * b) (a + 1UL) (b - 2UL)\n    f 0UL 1UL (2UL * n - 1UL)\n\nlet sumax n =\n    let rec f acc a b =\n        match a with\n        | a when a = n -> acc + a * b\n        | _ -> f (acc + a * b) (a + 1UL) (b + 2UL)\n    f 0UL 1UL 1UL\n    \nlet sumsum n = (sumin n) + (sumax n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84567,"user_id":491,"body":"let sumin (n: uint64): uint64 = Seq.fold (fun s t -> s + t * t) 0UL {1UL..n}\n \nlet sumax (n: uint64): uint64 =\n    let triangle n = n * (n - 1UL) \/ 2UL\n    Seq.fold (fun s t -> s + triangle t) 0UL {1UL..n} + n * triangle(n + 1UL)\n\nlet sumsum (n: uint64): uint64 = sumin n + sumax n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84568,"user_id":null,"body":"let sumin (n : uint64) : uint64 =\n    [ 1UL..n ] |> Seq.sumBy (fun x -> x * (2UL * (n - x) + 1UL))\nlet sumax (n : uint64) : uint64 =\n    [ 1UL..n ] |> Seq.sumBy (fun x -> x * (2UL * x - 1UL))\nlet sumsum (n: uint64): uint64 =\n    [ 1UL..n ] |> Seq.sumBy (fun x -> x * (2UL * n))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55a243393fb3e87021000198":[{"id":84569,"user_id":null,"body":"\nlet _rem (str:string) =\n        str     \n        |> Seq.indexed   \n        |> Seq.toList\n        |> List.groupBy (fun (_, x) -> x)     \n        |> List.filter (fun (_, (items)) -> Seq.length(items) > 1)\n        |> List.sortBy (fun (_, items) -> \n                                    let (i, _) = Seq.item 1 items\n                                    i)\n        |> List.map (fun (key, _) -> key)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84570,"user_id":null,"body":"open System.Collections.Generic\n\nlet _rem (str:string) =\n    let hash = HashSet<char>();\n\n    str\n    |> Seq.filter (hash.Add >> not)\n    |> Seq.distinct\n    |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84571,"user_id":null,"body":"open System.Collections.Generic\n\nlet _rem (str:string) =\n    let hash = HashSet<char>();\n\n    str\n    |> Seq.filter (fun e -> hash.Add e |> not)\n    |> Seq.distinct\n    |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84572,"user_id":null,"body":"let _rem (str: string) =\n    let seen = System.Collections.Generic.Dictionary<char, int>()\n\n    str\n    |> Seq.choose (fun c ->\n        if seen.ContainsKey(c) then\n            if seen.[c] = 1 then\n                seen.[c] <- seen.[c] + 1\n                Some(c)\n            else\n                None\n        else\n            seen.Add(c, 1)\n            None)\n    |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84573,"user_id":null,"body":"let _rem (s : string) =\n    let rec f s i =\n        let (xs, ys) =\n            s |> Seq.take i,\n            s |> Seq.skip i\n    \n        match ys |> Seq.tryHead with\n        | Some c -> if xs |> Seq.contains c then c :: f s (i + 1) else f s (i + 1)\n        | _      -> []\n    f s 0\n    |> List.distinct","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84574,"user_id":null,"body":"let _rem (str:string) = \n  let rec numIndex (str: string) (num: int) (start: int) (c: char) =\n    match num with\n    | num when start >= (String.length str) -> -1\n    | 1 when str.[start] = c                -> start\n    | num when str.[start] = c              -> (numIndex str (num - 1) (start + 1) c)\n    | _                                     -> (numIndex str num (start + 1) c)\n    \n  str |> Seq.filter (fun x -> (str |> String.filter (fun y -> y = x) |> String.length) > 1) |>\n  Seq.distinct |> Seq.sortBy (numIndex str 2 0) |> Seq.toList ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84575,"user_id":null,"body":"let _rem (str:string) =\n    let charCounts = Array.zeroCreate 256\n    [ for ch in str do\n        let charAsInt = int ch\n        charCounts.[charAsInt] <- charCounts.[charAsInt] + 1\n        if charCounts.[charAsInt] = 2 then yield ch ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84576,"user_id":null,"body":"open System\n\nlet rec contains n = function\n    | [] -> false\n    | x :: xs -> (n = x) || contains n xs\n\nlet _rem (str:string) = \n  let mutable out = []\n  for i = 1 to ((str.Length) - 1) do\n    if (str.[..(i-1)].Contains(string(str.[i])) && (not (out |> contains(str.[i])))) then \n      out <- out @ [str.[i]]\n  out","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84577,"user_id":null,"body":"let _rem (str : string) : char list =\n    let len = str.Length - 1\n    let list = List.ofSeq str\n    let mutable acc : (char * int) list = []\n    for i = 0 to len do\n        let c = str.[i]\n        let range = List.skip (i+1) list\n        let isDupl = List.tryFindIndex ((=) c) range\n        match isDupl with\n        | Some index -> acc <- (c, index + i) :: acc\n        | None -> ()\n            \n    acc\n    |> List.sortBy (fun (_, index) -> index)\n    |> List.unzip\n    |> fst\n    |> List.distinct","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84578,"user_id":491,"body":"let _rem str =\n    let rec generator items observed yielded = seq {\n        match items with\n        | [] -> ()\n        | head::tail ->\n            if Set.contains head observed && Set.contains head yielded |> not then\n                yield head\n                yield! generator tail observed (Set.add head yielded)\n            else\n                yield! generator tail (Set.add head observed) yielded\n    }\n    generator (str |> Seq.toList) Set.empty Set.empty |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55a29405bc7d2efaff00007c":[{"id":84579,"user_id":null,"body":"let going n =\n    { 1 .. n }\n    |> Seq.map double\n    |> Seq.fold (fun x i -> (x + i) \/ i) 0.\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84580,"user_id":null,"body":"let going n =\n    { n .. -1 .. 2 }\n    |> Seq.map double\n    |> Seq.scan (\/) 1.\n    |> Seq.sum\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84581,"user_id":53,"body":"let rec going n =\n  if n > 0 then\n    1.0 + going (n - 1) \/ float n\n  else\n    0.0","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84582,"user_id":null,"body":"let going n =\n    Seq.init n (fun i -> seq{float (n - i + 1) .. float n} |> Seq.fold (\/) 1.)\n    |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84583,"user_id":492,"body":"open System\n\nlet going n =\n    let mutable res = 1.0\n    let mutable inter = 1.0\n    for i in n .. -1 .. 2 do\n        inter <- inter * (1.0 \/ float(i))\n        res <- res + inter\n    floor(res * 1000000.0) \/ 1000000.0","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84584,"user_id":492,"body":"open System\n\nlet going n =\n    let mutable res = 1.0\n    let mutable inter = 1.0\n    for i in n .. -1 .. 2 do\n        inter <- inter * (1.0 \/ float(i))\n        res <- res + inter\n    floor(res * 1000000.0) \/ 1000000.0","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84585,"user_id":null,"body":"let going n =   \n    let mutable current = 1.\n\n    let rec itemCaluclation current  i = current \/ (double i) \n    let list = [1..n]|> List.rev\n    let makeList n = [ for i in list -> if i = 1 then 1. else current <- itemCaluclation current  i;  current ]\n\n    \n    makeList n        \n        |> List.sum \n\n    ","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84586,"user_id":null,"body":"open System\n\n\nlet rec itemCaluclation (itemInSeq, current, acc: double) = \n    if(current<=itemInSeq) then acc else itemCaluclation(itemInSeq, current-1, (acc |> double) \/ (current |> double))\n\nlet makeList n = [ for i in 1 .. n ->  itemCaluclation (i,n, 1 |> double) ]\n\nlet going n =  \n    makeList n \n    |> List.sum  \n \n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84587,"user_id":null,"body":"open System\n\nlet truncate x = (x * 1e6 |> truncate) \/ 1e6\nlet rec f acc prev n = \n    if prev < 1e-7 || n = 1 then acc\n    else \n        let y = prev \/ float n\n        f (acc + y) y (n - 1)\n\nlet going n =\n    f 1. 1. n |> truncate\n  \/\/ your code\n  ","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84588,"user_id":null,"body":"let cut flt = flt - (flt % 0.000001)\n\nlet rec go c s l n =\n    if c < n - 1 then\n        let cur = l * 1. \/ float (n - c)\n        let s = s + cur\n        go (c + 1) s cur n\n    else\n        s\n\nlet going n =\n    let start = 1. \/ float n\n    go 1 start start n + 1. |> cut","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55aa075506463dac6600010d":[{"id":84589,"user_id":null,"body":"let list_squared m n =\n  [\n    for x in m..n do\n      let y = seq { 1..x } |> Seq.filter (fun d -> x % d = 0) |> Seq.sumBy (fun d -> d * d) |> float\n      if sqrt y % 1.0 = 0.0 then yield (x, int y)\n  ]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84590,"user_id":null,"body":"open System\n\nlet list_squared m n =\n    let factors number = seq {\n        for divisor in 1 .. (float >> sqrt >> int) number do\n        if number % divisor = 0 then\n            yield divisor\n            if number <> 1 then yield number \/ divisor\n    }\n\n    let checkSquare (number:int) =\n        let root = (float >> sqrt >> int) number\n        root * root = number\n\n    let checkNumber number =\n        let sum = factors number |> Seq.distinct |> Seq.sumBy (fun x->x*x)\n        if checkSquare sum then Some (number,sum)\n        else None\n        \n    seq {m..n} |> Seq.choose checkNumber |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84591,"user_id":null,"body":"let cons x xs = x :: xs\nlet flip f x y = f y x\nlet revAppend xs ys = xs |> List.fold (flip cons) ys\n\nlet divisors (n : int) =\n    let rec f low high m =\n        let q, r = System.Math.DivRem(n, m)\n        if m >= q\n        then revAppend low (if m = q && r = 0 then q :: high else high)\n        else if r = 0\n        then f (m :: low) (q :: high) (m + 1)\n        else f low high (m + 1)\n    f [] [] 1\n\nlet square x = x * x\nlet sumOfSquaredDivisors = divisors >> List.sumBy square\nlet isPerfectSquare x = x = (x |> float |> sqrt |> int |> square)\n\nlet list_squared m n =\n    [\n        for x = m to n do\n            let y = sumOfSquaredDivisors x\n            if isPerfectSquare y then\n                yield x, y\n    ]\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84592,"user_id":492,"body":"open System\n\nlet factorsSqSum number = \n    seq {\n    for divisor in 1 .. (float >> sqrt >> int) number do\n    if number % divisor = 0 then\n        yield (divisor * divisor)\n        if number <> 1 then \n            let d = number \/ divisor\n            yield d * d\n    }\n    |> Seq.distinct |> Seq.sum\n    \nlet isSquare num = \n    let s = int(sqrt(float(num)))\n    s * s = num\n    \nlet list_squared m n =\n    [for x in m..n do\n        let sm = factorsSqSum x\n        if (isSquare sm) then \n            yield (x, sm)]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84593,"user_id":168,"body":"let list_squared m n =\n  [ for x in m .. n do\n    let s = Seq.sum <| seq { for d in 1 .. x do if x % d = 0 then yield d * d }\n    if sqrt (float s) % 1.0 = 0.0 then yield (x, s) ]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84594,"user_id":null,"body":"let list_squared (m: int) (n: int) = \n    let div (a: int) (b: int) = a%b=0\n    let square (a: int) = a*a\n    let isSquare (a: int) = (square (int(sqrt(float(a))))) = a\n    [\n        for v in m..n do\n        let s = seq{1..v} |> Seq.filter (div v) |> Seq.sumBy square\n        if isSquare s then yield v, s\n    ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84595,"user_id":null,"body":"open System\n\nlet g = function\n    | 1 -> Some 1\n    | 42 -> Some 2500\n    | 246 -> Some 84100\n    | 287 -> Some 84100\n    | 728 -> Some 722500\n    | 1434 -> Some 2856100\n    | 1673 -> Some 2856100\n    | 1880 -> Some 4884100\n    | 4264 -> Some 24304900\n    | 6237 -> Some 45024100\n    | 9799 -> Some 96079204\n    | 9855 -> Some 113635600\n    | 18330 -> Some 488410000\n    | _ -> None\n    \n\nlet list_squared m n =\n    List.map (fun elem -> (elem, g elem)) [m..n]\n    |> List.filter (fun elem -> snd elem |> Option.isSome)\n    |> List.map (fun (a, b) -> (a, Option.get b))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84596,"user_id":null,"body":"open System\n\nlet list_squared m n =\n  let calc n =\n      seq { for x in 1 .. n do if n % x = 0 then yield x * x } |> Seq.sum      \n  seq { m .. n }\n  |> Seq.map (fun x -> x, calc x)\n  |> Seq.filter (fun (_, x) -> let x = sqrt (float x) in x = floor x)\n  |> Seq.toList\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84597,"user_id":null,"body":"let list_squared m n =\n    {m..n}\n    |> Seq.choose (fun n -> \n        seq {for i in 1 .. n do if (n % i = 0) then yield (i * i)}\n        |> Seq.sum\n        |> (fun sum -> if (sqrt(float sum) % 1. = 0.) then (Some (n, sum)) else None))\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84598,"user_id":null,"body":"let getDivisors =\n    function\n    | 1 -> [ 1 ]\n    | n ->\n        \/\/ strategy to get lower half divisors, then mirror otherside.\n        \/\/ hence no need to full iterate..\n        let upperLimit = (float n) \/ 2. |> int\n\n        let divisors =\n            seq { 2..upperLimit }\n            |> Seq.filter (fun i -> n % i = 0)\n            |> Seq.collect (fun i -> [ n \/ i ]) \/\/ get 'mirror' divsisors..\n            |> List.ofSeq\n\n        1 :: n :: divisors\n\nlet sumSqrDivisors = (getDivisors >> List.sumBy (fun x -> x * x))\nlet isSquareRootable = float >> sqrt >> fun x -> x % 1. = 0.\n\nlet list_squared m n =\n    [ for i in m..n do\n          let ultimateSquare = sumSqrDivisors i\n\n          if ultimateSquare |> isSquareRootable then\n              yield (i, ultimateSquare) ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55ab4f980f2d576c070000f4":[{"id":84599,"user_id":null,"body":"\/\/ If n = 2, there are 3 diagonals: 1\/2, 1\/3+2\/3, 2\/4\n\/\/ If n = 3, there are 5 diagonals: 1\/2, 1\/3+2\/3, 1\/4+2\/4+3\/4, 2\/5+3\/5, 3\/6\n\/\/ If n = 4, there are 7 diagonals: 1\/2, 1\/3+2\/3, 1\/4+2\/4+3\/4, 1\/5+2\/5+3\/5+4\/5, 2\/6+3\/6+4\/6, 3\/7+4\/7, 4\/8\n\n\/\/ GENERAL RULE: There will be 2*n - 1 diagonals. The first n diagonals follow pattern A, the last n-1 follow pattern B.\n\/\/ Pattern A: for i = 1 to n, denominator = i+1. Sum of numerators = (sum from 1 to i) = (i * i+1) \/ 2\n\/\/ So the diagonal sum for pattern A = (i * i+1) \/ (2 * i+1) = i \/ 2\n\/\/ Sum of *all* diagonals of pattern A = Sum(i = 1 -> n) of i\/2 = (Sum(i = 1 -> n) of i) \/ 2 = (n * n+1) \/ 2 \/ 2 = (n * n+1) \/ 4\n\/\/ Pattern B: for i = 1 to n-1, denominator = n+i+1.\n\/\/ Sum of numerators\n\/\/ = (sum from i+1 to n)\n\/\/ = (sum from 1 to n - sum from 1 to i)\n\/\/ = (n * n+1 \/ 2) - (i * i+1 \/ 2)\n\/\/ = (n * n+1 - i * i+1) \/ 2\n\/\/ = (n^2 + n - i^2 - i) \/ 2\n\/\/ = (n^2 - i^2 + n - i) \/ 2\n\/\/ = ((n+i)*(n-i) + (n-i)) \/ 2\n\/\/ = ((n+i+1)*(n-i)) \/ 2\n\/\/ And since denominator = n+i+1, then the diagonal sum for pattern B = (n-i) \/ 2\n\/\/ Sum of *all* diagonals of pattern B = Sum(i = 1 -> n-1) of (n-i) \/ 2 = Sum(i = n-1 downto 1) of i \/ 2 = (n-1 * n) \/ 4\n\/\/ So the total sum is just (n * n+1) \/ 4 + (n-1 * n) \/ 4 = (n * n+1 + n * n-1) \/ 4 = (2 * n * n) \/ 4 = (n * n) \/ 2\n\nlet game(n: uint64): string =\n  let resultDoubled = n * n\n  if resultDoubled % 2UL = 0UL\n  then sprintf \"[%d]\" (resultDoubled \/ 2UL)\n  else sprintf \"[%d,2]\" resultDoubled","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84600,"user_id":492,"body":"let game(n: uint64): string =\n    let m: uint64 = uint64(n) * uint64(n)\n    if (n % 2UL = 0UL) then \n        \"[\" + string(m \/ 2UL) + \"]\" \n    else \n        \"[\" + string(m) + \",2]\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84601,"user_id":null,"body":"\/\/ Written to use string interpolation in F# 5+\nopen System\n\nlet game (n: uint64): string =\n    match n with\n    | n when n % 2UL = 0UL -> String.Format(\"[{0}]\",n * n \/ 2UL)\n    | _ -> String.Format(\"[{0},2]\", n * n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84602,"user_id":null,"body":"let game(n: uint64): string =\n  match (n % 2UL = 0UL) with\n   | true -> sprintf \"[%A]\" (n * n \/ 2UL |> bigint)\n   | false -> sprintf \"[%A,2]\" (n * n |> bigint)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84603,"user_id":null,"body":"let game(n: uint64): string =\n  match (n % 2UL = 0UL) with\n   | true -> sprintf \"[%A]\" (n * n \/ 2UL |> bigint)\n   | false -> sprintf \"[%A,%A]\" (n * n |> bigint) 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84604,"user_id":null,"body":"let game(n: uint64): string = if n % 2UL = 0UL then sprintf \"[%d]\" ((n * n) \/ 2UL) else sprintf \"[%d,2]\" (n * n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84605,"user_id":53,"body":"let game(n: uint64): string =\n    if n % uint64(2) = uint64(0) then\n      sprintf \"[%i]\" (n * n \/ uint64(2))\n    else\n      sprintf \"[%i,2]\" (n * n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84606,"user_id":null,"body":"let game(n: uint64): string =\n  match n % 2UL with\n  | 0UL -> sprintf \"[%O]\" (n*n\/2UL)\n  | 1UL -> sprintf \"[%O,2]\" (n*n)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84607,"user_id":168,"body":"let game(n: uint64): string =\n  let k = n * n in\n  if k % 2UL = 0UL then\n    sprintf \"[%u]\" (k \/ 2UL)\n  else\n    sprintf \"[%u,2]\" k","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84608,"user_id":null,"body":"let game(n: uint64): string =\n    if (n % 2UL = 0UL) then\n      sprintf \"[%d]\" (n * n \/ 2UL)\n    else\n      sprintf \"[%d,%d]\" (n * n) 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55b3425df71c1201a800009c":[{"id":84609,"user_id":1617,"body":"let stat_assoc (strg: string): string =\n    if strg = \"\" then\n        \"\"\n    else\n        let read (s: string): int =\n            let parts = Array.map int (s.Split '|')\n            3600 * parts.[0] + 60 * parts.[1] + parts.[2]\n\n        let print (t: int): string = sprintf \"%02i|%02i|%02i\" (t \/ 3600) (t % 3600 \/ 60) (t % 60)\n\n        let times = Array.sort (Array.map read (strg.Split ','))\n\n        let count = Array.length times\n        let range = Array.last times - times.[0]\n        let avg = Array.sum times \/ count\n        let median = (times.[count \/ 2 + count % 2 - 1] + times.[count \/ 2]) \/ 2\n\n        sprintf \"Range: %s Average: %s Median: %s\" (print range) (print avg) (print median)\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84610,"user_id":null,"body":"open System\ntype Stat (str:string) =\n    let toSeconds (str: string) =\n        let parts = str.Split('|') |> Array.map (fun s -> Int32.Parse s)\n        parts.[0] * 3600 + parts.[1] * 60 + parts.[2]\n    member this.Seconds = toSeconds str\n\nmodule Stat =\n    let fromSeconds (n:int) =\n        sprintf \"%02i|%02i|%02i\" (n \/ 3600) ((n % 3600) \/ 60) (n % 60)\n    let getTimes (stat_assocs:Stat array) = stat_assocs |> Array.map(fun x -> x.Seconds)\n    let range stat_assocs =\n        stat_assocs |> getTimes |> fun x -> (Array.max x - Array.min x)\n    let average stat_assocs =\n        stat_assocs |> getTimes |> Array.map (fun x -> float x) |> Array.average\n    let median stat_assocs =\n        let sorted = stat_assocs |> getTimes |> Array.sort\n        match sorted.Length with\n        | x when x % 2 = 0 -> (sorted.[x \/ 2 - 1] + sorted.[x \/ 2]) \/ 2\n        | x -> sorted.[x \/ 2]\n    let print stat_assocs =\n        sprintf \"Range: %s \" (range stat_assocs |> fromSeconds) +\n        sprintf \"Average: %s \" (average stat_assocs |> int |> fromSeconds) +\n        sprintf \"Median: %s\" (median stat_assocs |> fromSeconds)\n\nlet stat_assoc(strg: string): string =\n    match strg with\n    | \"\" -> \"\"\n    | _ -> strg.Split(',') |> Array.map Stat |> Stat.print\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84611,"user_id":492,"body":"open System\nopen System.Linq\n\nlet time2snd(s: string): int =\n    let arr = s.Split([|'|'|]).Select(fun x -> int(x)).ToArray()\n    3600 * arr.[0] + 60 * arr.[1] + arr.[2]\nlet snd2time(n: int): string =\n    let h = n \/ 3600\n    let re = n % 3600\n    let mn = re \/ 60\n    let s = re % 60\n    String.Format(\"{0:00}|{1:00}|{2:00}\", h, mn, s)\n            \nlet stat_assoc(strg: string): string = \n    if (strg = \"\") then \"\"\n    else\n        let r = strg.Split([|','|]).Select(fun x -> time2snd(x)).ToArray()\n        Array.Sort(r)\n        let lg = r.Length\n        let avg = (int)(r.Sum() \/ lg)\n        let rge = r.[lg - 1] - r.[0]\n        let md = int((r.[(int)((lg - 1) \/ 2)] + (r.[int(lg \/ 2)])) \/ 2)\n        String.Format(\"Range: {0} Average: {1} Median: {2}\", snd2time(rge), snd2time(avg), snd2time(md))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84612,"user_id":492,"body":"open System\nopen System.Linq\n\nlet time2snd(s: string): int =\n    let arr = s.Split([|'|'|]).Select(fun x -> int(x)).ToArray()\n    3600 * arr.[0] + 60 * arr.[1] + arr.[2]\nlet snd2time(n: int): string =\n    let h = n \/ 3600\n    let re = n % 3600\n    let mn = re \/ 60\n    let s = re % 60\n    String.Format(\"{0:00}|{1:00}|{2:00}\", h, mn, s)\n            \nlet stat_assoc(strg: string): string = \n    if (strg = \"\") then \"\"\n    else\n        let r = strg.Split([|','|]).Select(fun x -> time2snd(x)).ToArray()\n        Array.Sort(r)\n        let lg = r.Length\n        let avg = (int)(r.Sum() \/ lg)\n        let rge = r.[lg - 1] - r.[0]\n        let md = int((r.[(int)((lg - 1) \/ 2)] + (r.[int(lg \/ 2)])) \/ 2)\n        String.Format(\"Range: {0} Average: {1} Median: {2}\", snd2time(rge), snd2time(avg), snd2time(md))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84613,"user_id":null,"body":"open System\n            \nlet stat_assoc(strg: string): string = \n  match strg with\n  | \"\" -> \"\"\n  | _ ->\n    let strDateToSec (strInp: string) =\n      strInp.Split [| '|' |]\n      |> Array.map float\n      |> Array.toList\n      |> List.rev\n      |> List.mapi (fun i e -> 60.0 ** float (i) * e)\n      |> List.sum\n\n    let secToDateStr (inpA: float) =\n      inpA\n      |> (fun (e: float) ->\n        (int (e \/ 3600.0)).ToString(\"00\")\n        + \"|\"\n        + (int ((e % 3600.0) \/ 60.0)).ToString(\"00\")\n        + \"|\"\n        + (int (e % 60.0)).ToString(\"00\"))\n\n    let floatArr =\n      strg.Split [| ',' |]\n      |> Array.map (fun e -> strDateToSec e)\n\n    let range arr = (arr |> Array.max) - (arr |> Array.min)\n\n    let average (arr: array<float>) =\n      let len = arr |> Array.length\n      let sum = arr |> Array.sum \n\n      sum \/ float (len)\n\n    let median (arr: array<float>) =\n      let len = arr |> Array.length\n      let sortArr = arr |> Array.sort\n      let lenMiddle = Math.Truncate(float (len) \/ 2.0) |> int\n\n      match len % 2 with\n      | 0 ->\n        sortArr.[lenMiddle - 1 .. lenMiddle]\n        |> Array.sum\n        |> (\/)\n        <| 2.0\n        |> float\n      | _ -> sortArr.[lenMiddle] |> float\n\n\n    let rangeStr = range floatArr |> secToDateStr\n    let averageStr = average floatArr |> secToDateStr\n    let medianStr = median floatArr |> secToDateStr\n\n    \"Range: \"\n    + rangeStr\n    + \" Average: \"\n    + averageStr\n    + \" Median: \"\n    + medianStr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84614,"user_id":null,"body":"open System\n            \nlet stat_assoc(strg: string): string =\n  match strg with\n  | \"\" -> \"\"\n  | _ ->\n          let formatSec (n:int) = TimeSpan.FromSeconds(float n).ToString(\"hh\\|mm\\|ss\")\n          let seconds =\n            strg.Split([|','; ' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> Seq.map (fun x -> x.Split '|')\n            |> Seq.map (fun x -> match x with\n                                  | [|h; m; s|] -> (int h) * 3600 + (int m) * 60 + (int s)\n                                  | _ -> 0)\n            |> Seq.toArray\n          let range = ((Seq.max seconds) - (Seq.min seconds)) |> formatSec\n          let average = seconds |> Array.map(double) |> Array.average |> int |> formatSec\n          let count = seconds.Length\n          let sorted = seconds |> Array.sort\n          let median = match count with\n                       | c when c % 2 = 1 -> sorted.[c\/2]\n                       | _ -> (sorted.[count\/2 - 1] + sorted.[count\/2])\/2\n                      |> formatSec\n          sprintf \"Range: %s Average: %s Median: %s\" range average median","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84615,"user_id":null,"body":"open System\n\nlet toTime (input: string) = \n    let timeParts = input.Split('|') |> Array.map int\n    TimeSpan(hours = timeParts.[0], minutes = timeParts.[1], seconds = timeParts.[2])\n\nlet timespanToString (time: TimeSpan) =\n    sprintf \"%02i|%02i|%02i\" time.Hours time.Minutes time.Seconds\n\nlet range (times: TimeSpan array) = \n    let times = times |> Array.sort\n    (Array.last times) - (Array.head times)\n    |> timespanToString\n\nlet average (times: TimeSpan array) =\n    let sum = times |> Array.reduce (+)\n    TimeSpan((sum.Ticks \/ (times |> Array.length |> int64)))\n    |> timespanToString\n\nlet median (times: TimeSpan array) = \n    let times = times |> Array.sort\n    let length = times |> Array.length\n    if (times |> Array.length) % 2 = 1  \n    then \n        times.[length \/ 2 ] \n        |> timespanToString\n    else \n        TimeSpan((times.[length \/ 2 - 1].Ticks + times.[length \/2].Ticks) \/ 2L)\n        |> timespanToString\n\nlet stat_assoc(strg: string): string = \n    if strg = \"\" then \"\"\n    else\n      let data = strg.Split(',') |> Array.map toTime\n      sprintf \"Range: %s Average: %s Median: %s\" (range data) (average data) (median data)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84616,"user_id":null,"body":"open System\n\nlet sInH = 60 * 60\n\nlet stat_assocStr ((rng, avg, med)) =\n    let timeStr secs =\n        let hours = secs \/ sInH\n        let secs = secs - (hours * sInH)\n        let mins = secs \/ 60\n        let secs = secs - (mins * 60)\n        sprintf \"%02i|%02i|%02i\" hours mins secs\n\n    sprintf \"Range: %s Average: %s Median: %s\" (timeStr rng) (timeStr avg) (timeStr med)\n\nlet stat_assoc (strg: string) : string =\n    if strg <> \"\" then\n        let segments = strg.Split([| \",\"; \", \" |], StringSplitOptions.None)\n\n        let readTime (sgmt: string) =\n            let times = sgmt.Split([| '|' |])\n\n            let folder x (i, sum) = i + 1, sum + (int x * (pown 60 i))\n\n            Array.foldBack folder times (0, 0) |> snd\n\n        let trim (s: string) = s.Trim()\n\n        let times =\n            segments\n            |> Array.map (trim >> readTime)\n            |> Array.sort\n\n        let n = times.Length\n\n        let range = times.[n - 1] - times.[0]\n        let avg = Array.sum times \/ n\n\n        let median =\n            if n % 2 = 0 then\n                (times.[n \/ 2] + times.[n \/ 2 - 1]) \/ 2\n            else\n                times.[(n - 1) \/ 2]\n\n        stat_assocStr (range, avg, median)\n    else\n        \"\"\n\nstat_assoc \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84617,"user_id":null,"body":"open System\n\nlet getTime (timeStr : string) =\n   match timeStr.Split('|') |> Array.toList with\n   | h::m::[s] -> TimeSpan(Int32.Parse(h), Int32.Parse(m), Int32.Parse(s))\n   | _ -> failwith \"invalid measurement format, expected: h|m|s\"\n   \nlet format (t : TimeSpan) =\n   let toStringWithLeadingZero i = i.ToString().PadLeft(2, '0')\n   sprintf \"%s|%s|%s\" (toStringWithLeadingZero t.Hours) (toStringWithLeadingZero t.Minutes) (toStringWithLeadingZero t.Seconds)\n   \nlet calculateMedian measurementsCount (measurements : TimeSpan seq) =\n   match measurementsCount % 2 = 0 with\n   | false -> Seq.item (measurementsCount \/ 2) measurements\n   | true ->\n      let middle1 = Seq.item (measurementsCount \/ 2) measurements\n      let middle2 = Seq.item ((measurementsCount - 1) \/ 2) measurements\n      (middle1 + middle2)\n      |> fun t -> (t.TotalSeconds \/ float 2)\n      |> TimeSpan.FromSeconds\n      \nlet calculateAverage measurementsCount measurements = \n   Seq.sumBy (fun (t : TimeSpan) -> t.TotalSeconds) measurements\n   |> fun sum -> sum \/ (float measurementsCount) |> TimeSpan.FromSeconds\n       \nlet calculateAndFormatStatistics (measurements : string) =\n   let sortedMeasurements =\n      measurements.Split(',')\n      |> Array.toSeq\n      |> Seq.map getTime\n      |> Seq.sort\n      \n   let lowest = Seq.head sortedMeasurements\n   let highest = Seq.last sortedMeasurements\n   let measurementsCount = Seq.length sortedMeasurements\n   \n   let range = highest - lowest\n   let median = calculateMedian measurementsCount sortedMeasurements\n   let average = calculateAverage measurementsCount sortedMeasurements\n   \n   sprintf \"Range: %s Average: %s Median: %s\" (format range) (format average) (format median)\n   \nlet stat_assoc(strg: string): string = if String.IsNullOrWhiteSpace(strg) then String.Empty else calculateAndFormatStatistics strg","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84618,"user_id":null,"body":"open System\n\nlet formatSeconds(seconds : int) : string =\n  let hours = seconds \/ 3600\n  let restSeconds = seconds % 3600\n  let mins = restSeconds \/ 60\n  let secondsLeft = restSeconds % 60\n  let seconds = secondsLeft\n  sprintf \"%02i|%02i|%02i\" hours mins seconds\n  \nlet range(arr : int[]) =\n  let min = arr |> Array.min\n  let max = arr |> Array.max\n  max - min\n\nlet avg(arr : int[]) =\n  let sum = arr |> Array.sum\n  sum \/ arr.Length\n  \nlet median(arr : int[]) =\n  let sorted = arr |> Array.sortBy id\n  if sorted.Length % 2 = 0 then\n    (sorted.[sorted.Length \/ 2]  + sorted.[sorted.Length \/ 2 - 1]) \/ 2\n  else\n    sorted.[sorted.Length \/ 2]\n\nlet stat_assoc(strg: string): string =\n  if String.IsNullOrEmpty(strg) then\n    \"\"\n  else\n    printfn \"Input --- %s\" strg  \n    let resultsInSeconds = \n      strg.Split([|\",\";\", \"|], StringSplitOptions.RemoveEmptyEntries)\n      |> Array.map (fun x -> x.Split('|'))\n      |> Array.map (fun x -> 3600 * (int x.[0]) + 60 * (int x.[1]) + (int x.[2])) \n    printfn \"Input in seconds --- %A\" resultsInSeconds    \n\n    let range = resultsInSeconds |> range |> formatSeconds\n    let avg = resultsInSeconds |> avg |> formatSeconds\n    let median = resultsInSeconds |> median |> formatSeconds\n\n    sprintf \"Range: %s Average: %s Median: %s\" range avg median","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55b4d87a3766d9873a0000d4":[{"id":84619,"user_id":null,"body":"let howmuch m n =\n    [(min m n)..(max m n)]\n    |> List.filter (fun x -> x % 9 = 1 && x % 7 = 2)\n    |> List.map (fun m -> [sprintf \"M: %i\" m; sprintf \"B: %i\" (m \/ 7); sprintf \"C: %i\" (m \/ 9)])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84620,"user_id":null,"body":"let howmuch m n =\n    let m, n = min m n, max m n\n    [\n        for c = (m + 7) \/ 9 to (n - 1) \/ 9 do\n            let x = 9 * c + 1\n            let b, r = System.Math.DivRem(x - 2, 7)\n            if r = 0 then\n                yield [\n                    sprintf \"M: %d\" x;\n                    sprintf \"B: %d\" b;\n                    sprintf \"C: %d\" c\n                ]\n    ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84621,"user_id":492,"body":"let howmuch m n =\n    let i = min m n\n    let j = max m n\n    let res = \n        [for x in i..j do \n            if (x % 9 = 1) && (x % 7 = 2) then \n                yield [\"M: \" + string x; \"B: \" + string (x \/ 7); \"C: \" + string (x \/ 9)]]\n    res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84622,"user_id":492,"body":"let howmuch m n =\n    let i = min m n\n    let j = max m n\n    let res = \n        [for x in i..j do \n            if (x % 9 = 1) && (x % 7 = 2) then \n                yield [\"M: \" + string x; \"B: \" + string (x \/ 7); \"C: \" + string (x \/ 9)]]\n    res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84623,"user_id":53,"body":"let howmuch m n =\n    let a = if m > n then n else m\n    let b = if m > n then m else n\n    [a .. b]\n    |> List.filter (fun i -> i % 9 = 1 && i % 7 = 2)\n    |> List.map(fun i -> [sprintf \"M: %d\" i; sprintf \"B: %d\" (i \/ 7); sprintf \"C: %d\" (i \/ 9)])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84624,"user_id":null,"body":"let howmuch m n =\n  let carsCount money = (money - 1)\/9\n  let boatsCount money = (money - 2)\/7\n  let isPossible money = (money - 1) % 9 = 0 && (money - 2) % 7 = 0\n  let min = min m n\n  let max = max m n\n  [for i in min..max do \n      if isPossible i then\n          yield [ sprintf \"M: %i\" i; sprintf \"B: %i\" (boatsCount i); sprintf \"C: %i\" (carsCount i)]]\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84625,"user_id":null,"body":"let howmuch m n =\n    let innerHowMuch a b =\n        [a..b] \n        |> List.filter (fun i -> (((i - 2) % 7)) = 0)\n        |> List.filter (fun i -> (((i - 1) % 9)) = 0)\n        |> List.map (fun i -> [sprintf \"M: %i\" i; sprintf \"B: %i\" ((i - 2) \/ 7); sprintf \"C: %i\" ((i - 1) \/ 9)])\n\n    if n >= m then innerHowMuch m n\n    else innerHowMuch n m\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84626,"user_id":1402,"body":"let printstr s i =\n  sprintf \"%s: %i\" s i\n\nlet howmuch m n =\n    [min m n .. max m n]\n    |> List.filter (fun x -> x % 7 = 2 && x % 9 = 1)\n    |> List.map (fun x -> [printstr \"M\" x; printstr \"B\" (x \/ 7); printstr \"C\" (x \/ 9)])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84627,"user_id":null,"body":"let howmuch m n =\n    printfn \"M is %d and N is %d\" m n\n    let getMinN (left:int) (right:int) : int=\n        if(left % 63 = 37) then\n            left \/ 63\n        else\n            let r = left % 63\n            let d = 37 - r\n            if d > 0 then\n                let newLeft = left + d\n                newLeft \/ 63\n            else\n                let newLeft = left + d + 63\n                printfn \"Call\"\n                newLeft \/ 63\n    let getMaxN (left:int) (right:int) : int=\n        if(right % 63 = 37) then\n            (right \/ 63) \n        else\n            let r = right % 63\n            let d = 37 - r\n            \n            if d > 0 then\n                let newRight = right + d\n                (newRight \/ 63) - 1\n            else\n                let newRight = right + d + 63\n                (newRight \/ 63) - 1 \n    let a = min m n\n    let b = max m n\n    let minN = getMinN a b\n    let maxN = getMaxN a b\n    printfn \"Min is %d and Max is %d\" minN maxN\n    let nToAnswer n =\n        let m = 63*n + 37\n        let b = 9*n + 5\n        let c = 7*n + 4\n        let money = sprintf \"M: %d\" m\n        let boats = sprintf \"B: %d\" b\n        let cars = sprintf \"C: %d\" c\n        [money; boats; cars]\n    [minN..maxN]\n    |> List.map nToAnswer","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84628,"user_id":null,"body":"let howmuch m n =\n let mutable holder = []\n if m > n then\n  for i = n to m do\n   if i % 7 = 2 && i % 9 = 1 then\n    holder <- holder @ [[\"M: \"+(string i); \"B: \"+(string (i\/7)); \"C: \"+(string (i\/9))]]\n else\n  for i = m to n do\n   if i % 7 = 2 && i % 9 = 1 then\n    holder <- holder @ [[\"M: \"+(string i); \"B: \"+(string (i\/7)); \"C: \"+(string (i\/9))]]\n holder\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55b95c76e08bd5eef100001e":[{"id":84629,"user_id":null,"body":"let rec countArara = function\n  | 0 -> \"\"\n  | 1 -> \"anane\"\n  | 2 -> \"adak\"\n  | x -> \"adak \" + countArara (x-2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84630,"user_id":491,"body":"let rec countArara =\n  let rec countArara' acc n =\n    match n with\n    | 0 -> acc\n    | 1 -> acc + \"anane\"\n    | 2 -> acc + \"adak\"\n    | _ -> countArara' (\"adak \" + acc) (n - 2) \n  countArara' \"\" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84631,"user_id":null,"body":"let countArara n = \n  let adaks = String.replicate (n\/2) \"adak \"\n  let anane = \n    match n with\n    | n when n % 2 = 1 -> \"anane\"\n    | _ -> \"\"\n  (adaks + anane).TrimEnd()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84632,"user_id":null,"body":"let countArara number =\n    (String.replicate (number \/ 2) \"adak \" +\n     String.replicate (number % 2) \"anane\").Trim()\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84633,"user_id":2255,"body":"let rec countArara number =\n  match number with\n  | 0 -> \"\"\n  | 1 -> \"anane\"\n  | 2 -> \"adak\"\n  | x -> \"adak \" + countArara (x - 2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84634,"user_id":null,"body":"let rec countArara number =\n    let rec ararafy n words =\n        match n with\n        | _ when n <= 0 -> words\n        | 1 -> words @ [ \"anane\" ]\n        | _ -> ararafy (n - 2) (words @ [ \"adak\" ])\n    String.concat \" \" (ararafy number [])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84635,"user_id":null,"body":"let rec countArara number = \n    (String.replicate (number \/ 2) \"adak \" + String.replicate (number % 2) \"anane\").Trim()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84636,"user_id":null,"body":"let rec countArara number =\n    match number with\n    | x when x % 2 = 1 -> ([for i in 1 .. x\/2 -> \"adak\"]@[\"anane\"] |> String.concat \" \")\n    | x -> [for i in 1 .. x\/2 -> \"adak\"] |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84637,"user_id":null,"body":"open System\n\nlet rec countArara number =\n    let f = Seq.replicate (number \/ 2) \"adak\" |> String.concat \" \"\n    if number % 2 = 0 then f\n    else (f + \" anane\").TrimStart()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84638,"user_id":null,"body":"let rec countArara number = \n  match number with\n  | a when a < 1 -> \"\"\n  | 1 -> \"anane\"\n  | 2 -> \"adak\"\n  | _ -> \"adak \" + (countArara (number - 2))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55be10de92aad5ef28000023":[{"id":84639,"user_id":null,"body":"let checkchoose (m : int64, n : int) =\n    let row =\n        (0, 1L)\n        |> Seq.unfold (\n            fun (x, y)->\n                if x = n + 1\n                then None\n                else\n                    let x' = x + 1\n                    let y' = int64 (n + 1 - x') * y  \/ int64 x'\n                    Some (y, (x', y')))\n    row\n    |> Seq.take ((n + 2) \/ 2)\n    |> Seq.tryFindIndex ((=) m)\n    |> Option.defaultValue -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84640,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet choose(n:int, p:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to p do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\nlet checkchoose(m:int64, n:int): int =\n    let mutable res = -1\n    let mm = new BigInteger(m)\n    let p = int (Math.Floor((double)(n \/ 2))) + 1\n    let l = [for i in 0..p do if choose(n, i) = mm then yield i]\n    if (l.Length <> 0) then res <- l.[0]\n    res\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84641,"user_id":753,"body":"open System\n\nlet binomial (n: int) (k: int): int64 =\n  List.fold (fun s i -> s * int64(n-i+1) \/ (int64 i)) 1L [1..k]\n\nlet checkchoose (m, n) =\n  Console.WriteLine(binomial 5 2)\n  let bins = seq{for k in 0 .. n -> binomial n k}\n  match Seq.tryFindIndex (fun bin -> bin = m) bins with\n  | Some k -> k\n  | None -> -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84642,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet choose(n:int, p:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to p do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\nlet checkchoose(m:int64, n:int): int =\n    let mutable res = -1\n    let mm = new BigInteger(m)\n    let p = int (Math.Floor((double)(n \/ 2))) + 1\n    let l = [for i in 0..p do if choose(n, i) = mm then yield i]\n    if (l.Length <> 0) then res <- l.[0]\n    res\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84643,"user_id":null,"body":"let checkchoose(m:int64, n:int): int =\n  let fac x = [(1 |> bigint)..x] |> List.fold (fun a x -> x * a) (1 |> bigint)\n  let nChooseX n x = (fac n) \/ ((fac x) * (fac (n - x)))\n  let maxColors = (n |> bigint)\n  let rec getResult posters usedColors =\n    let x = nChooseX maxColors usedColors\n    if usedColors > maxColors then -1\n    else\n      match (x=posters) with\n        | true -> usedColors |> int\n        | false -> getResult posters (usedColors + (1 |> bigint))\n  (getResult (m |> bigint) (0 |> bigint))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84644,"user_id":null,"body":"let checkchoose(m:int64, n:int): int =\n  let rec f x b =\n    if x = int64 n \/ 2L + 2L then\n      -1\n    elif b = m then\n      int x\n    else\n      f (x + 1L) (b * (int64 n - x) \/ (x + 1L))\n  f 0L 1L","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84645,"user_id":53,"body":"let checkchoose(m:int64, n:int): int =\n  let mutable r: int64 = 1L\n  let mutable i: int64 = 0L\n  let mutable res: int64 = -1L\n  let mutable continueLooping = true\n  let bn: int64 = int64(n)\n  while continueLooping do\n    if i > bn then\n      continueLooping <- false\n    elif r = m then\n      continueLooping <- false\n      res <- i\n    else\n      r <- r * (bn - i) \/ (i + 1L)\n      i <- i + 1L\n  int(res)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84646,"user_id":null,"body":"let getComb (n: int) (k: int) =  \n  let rec counter (n: int64) (sec: int64) (k: int64) (result: int64) =\n    match (n,k) with\n    | (a,b) when (a <= sec && b <= 1L)            -> result\n    | (a,b) when (result % b = 0L && b > 1L)      -> (counter n sec (k - 1L) (result \/ b))\n    | (a,b)                                       -> (counter (n - 1L) sec k (result * a))\n\n  if (k > n) then \n    -1L\n  else if (n = 0 || k = 0) then\n    1L\n  else\n    (counter (n |> int64) ((n - k) |> int64) (k |> int64) 1L)\n    \nlet checkchoose(m:int64, n:int): int =\n    [0..((n \/ 2) + 1)] |> Seq.map (fun x -> (getComb n x)) |> \n    Seq.indexed |> Seq.filter (fun x -> (snd x) = m) |> \n    (fun x -> if (Seq.isEmpty x) then -1 else (x |> Seq.head |> fst))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84647,"user_id":null,"body":"let factorial n = [1I .. n] |> List.fold (*) 1I\n\nlet rec choose setSize sampleSize =\n    match sampleSize > setSize \/ 2I with\n    | true -> choose setSize (setSize - sampleSize)\n    | false -> ([(setSize - sampleSize + 1I) .. setSize] |> List.fold (*) 1I) \/ (factorial sampleSize)\n\nlet checkchoose(m:int64, n:int): int =\n    \/\/ your code\n    [1I .. bigint n \/ 2I]\n    |> Seq.map (choose (bigint n))\n    |> Seq.takeWhile (fun count -> count <= bigint m)\n    |> Seq.tryFindIndex ((=) (bigint m))\n    |> Option.map ((+) 1)\n    |> Option.defaultValue -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84648,"user_id":null,"body":"let rec fac a:int64 = \n        match a with\n        | 1L -> 1L\n        | _ -> a * fac (a-1L) \n\nlet facL = int64>>fac\n\nlet factorial n = [1L .. n] |> List.fold (*) 1L\n\nlet factorialL = int64 >> factorial\n\nlet checkchoose(m:int64, n:int): int =\n    let isNotMatch i = factorialL n <> factorialL i * factorialL (n-i) * m\n    let s = [1 .. n\/2] |> Seq.takeWhile isNotMatch\n    let r = if Seq.isEmpty s then 0 else Seq.last s\n    match r with\n    | x when x = n\/2 -> -1\n    | _ -> r + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55bf01e5a717a0d57e0000ec":[{"id":84649,"user_id":null,"body":"let persistence n = \n    let toDigits =\n        Seq.unfold (function 0 -> None | n -> (n % 10, n \/ 10) |> Some)\n    let rec f acc n = \n        if n > 9 then toDigits n |> Seq.reduce (*) |> f (acc + 1) else acc\n    f 0 n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84650,"user_id":491,"body":"let rec persistence n = \n    let charMapper = string >> Seq.map System.Char.GetNumericValue >> Seq.map int >> Seq.reduce (*)\n    if n >= 10 then 1 + persistence (charMapper n) else 0","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84651,"user_id":null,"body":"let rec getDigits n = [\n  if n <> 0 then\n    yield n % 10\n    yield! getDigits <| n \/ 10\n]\n\nlet rec persistence n =\n  match getDigits n with\n  | [] -> 0\n  | [_] -> 0\n  | digits -> 1 + (digits |> List.fold (*) 1 |> persistence)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84652,"user_id":null,"body":"let (|Digit|_|) x =\n    if x \/ 10 = 0 then Some(Digit) else None\n\nlet toArray (line: string) = line.ToCharArray()\n\nlet digits num =\n    num\n    |> string\n    |> toArray\n    |> Seq.map (fun x -> int (x) - int ('0'))\n    \nlet persistence n =\n    let rec loop count n =\n        match n with\n        | Digit -> count\n        | _ -> loop (count + 1) (n |> digits |> Seq.reduce (*))\n        \n    loop 0 n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84653,"user_id":null,"body":"let digits n =\n  n.ToString().ToCharArray()\n  |> Array.map (System.Char.GetNumericValue >> System.Convert.ToInt32)\n\nlet persistence n =\n  let rec inner inc n =\n    if n < 10 then inc else\n    let n = Array.fold (*) 1 (digits n)\n    inner (inc+1) n\n  inner 0 n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84654,"user_id":null,"body":"let rec multiplyDigits n acc =\n    let current = n\/10\n    if current = 0 then acc * n\n    else (n % 10) * multiplyDigits current acc\n\nlet rec persistenceRec n acc = \n    let current = multiplyDigits n 1;\n    if  current \/ 10 = 0 then\n        acc\n    else\n        persistenceRec (current) acc + 1\n    \nlet persistence n = \n    if  n \/ 10 = 0 then 0\n    else persistenceRec n 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84655,"user_id":null,"body":"let persistence n = \n    let mutable iterations = 0\n    let mutable i = n\n    while i >= 10 do\n        iterations <- iterations + 1\n        let mutable p = 1\n        while (i>0) do\n            p <- p * (i%10)\n            i <- i \/ 10\n        i <- p\n    iterations\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84656,"user_id":null,"body":"let persistence n = \n    let rec mult n =\n      if n <= 9 then n\n      else (n % 10) * mult (n \/ 10)\n    Seq.unfold (fun n -> if n < 10 then None else Some (0, mult n)) n\n    |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84657,"user_id":878,"body":"let rec persistence n =\n  match n with\n  | n when n < 10 -> 0\n  | n ->\n    string n\n    |> Seq.map (fun c -> int c - int '0')\n    |> Seq.reduce (*)\n    |> persistence\n    |> (+) 1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84658,"user_id":null,"body":"let persistence n = \n  let rec find count n =\n    match n with\n    | n when n < 10 -> count\n    | _ ->\n      string n\n      |> Seq.map (fun char -> int char - int '0')\n      |> Seq.reduce (*)\n      |> find (count+1) \n  find 0 n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55c6126177c9441a570000cc":[{"id":84659,"user_id":null,"body":"let value (digit : char) = int digit - int '0'\nlet weight (s : string) = s |> Seq.sumBy value\nlet weightPair (s : string) = (weight s), s\nlet split (s : string) = s.Split([|' '|], System.StringSplitOptions.RemoveEmptyEntries)\nlet join (strs : string[]) = String.concat \" \" strs\n\nlet order_weight (s : string) =\n    s |> split |> Array.sortBy weightPair |> join","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84660,"user_id":491,"body":"let order_weight(s: string): string =\n    s.Split(' ') |> Seq.sortBy (fun n -> n.ToCharArray() |> Seq.map (string >> int) |> Seq.sum, n) |> String.concat \" \"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84661,"user_id":492,"body":"open System\nlet private weightStrNb n =\n    let rec loop acc = function\n        | n when n > 0 ->\n            let m, r = Math.DivRem(n, 10)\n            loop (acc + r) m\n        | _ -> acc\n    loop 0 n\n\nlet private cmp(x: string) (y: string) =\n    let cp =  (weightStrNb (x |> int)) - (weightStrNb (y |> int))\n    if (cp = 0) then\n        String.Compare(x, y)\n    else if (cp < 0) then\n        -1\n    else 1\n\nlet order_weight(s: string): string =\n    let a = s.Split([|' '|])\n    Array.Sort(a, fun x y -> cmp x y) \n    a |> String.concat \" \"\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84662,"user_id":null,"body":"let order_weight(s: string): string =\n  let sumDigits =\n    Seq.sumBy (fun c -> int c - int '0')\n\n  s.Split([|\" \"|], System.StringSplitOptions.RemoveEmptyEntries)\n  |> Seq.sortBy(fun w -> (sumDigits w, w))\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84663,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet order_weight(s: string): string =\n    let weights = Regex.Split (s.Trim(), \"\\D+\")\n    let sumThenString s = ((Seq.sumBy (string >> int) s), s)\n\n    weights\n    |> Seq.sortBy (sumThenString)\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84664,"user_id":null,"body":"let weight(s : string) =\n  s.ToCharArray()\n  |> Seq.map (System.Char.ToString >> int)\n  |> Seq.sum\n\nlet order_weight(s: string): string =\n  s.Split(' ')\n  |> Seq.sortBy (fun s -> weight s, s)\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84665,"user_id":null,"body":"let order_weight (s: string) : string = \/\/ your code\n    s.Split [| ' ' |]\n    |> Seq.sortBy (fun n ->\n        (n\n         |> Seq.sumBy System.Char.GetNumericValue,\n         n))\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84666,"user_id":null,"body":"let order_weight (s: string) : string = \/\/ your code\n    s.Split [| ' ' |]\n    |> Seq.sortBy (fun n ->\n        (n\n         |> Seq.map System.Char.GetNumericValue\n         |> Seq.sum,\n         n))\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84667,"user_id":null,"body":"let order_weight(s: string): string =\n  let sumDigits x = x |> Seq.map (string >> int) |> Seq.sum\n  s.Split(' ')\n  |> Seq.sortBy (fun x -> sumDigits x, x)\n  |> Seq.reduce (sprintf \"%s %s\")\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84668,"user_id":null,"body":"open System\n\nlet split (s: string) = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n\nlet join (s: seq<string>) = String.Join(\" \", s)\n\nlet sumOfDigits = Seq.sumBy (string >> int)\n\nlet order_weight(s: string): string =\n    s\n    |> split\n    |> Seq.sortBy (fun x -> sumOfDigits x, x)\n    |> join","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55caef80d691f65cb6000040":[{"id":84669,"user_id":null,"body":"open System\n\nlet geometricSequenceElements a r n =\n  let r' = r |> int64\n  a\n  |> int64\n  |> Seq.unfold (fun x -> Some (x, x * r'))\n  |> Seq.take n\n  |> Seq.map string\n  |> String.concat \", \"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84670,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) =\n    String.Join(\", \", a |> Seq.unfold (fun e -> Some(e, e * r)) |> Seq.take n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84671,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) =\n    Seq.unfold(fun state -> Some (string state, state * r)) a\n        |> Seq.take n\n        |> String.concat \", \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84672,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) =\n  [2..n]\n  |> List.scan (fun acc _ -> acc * r) a\n  |> List.map string\n  |> String.concat \", \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84673,"user_id":null,"body":"open System\n\nlet geometricSequenceElements a r n =\n    [2..n]\n    |> List.scan (fun acc _ -> acc * r) a\n    |> List.map string\n    |> String.concat \", \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84674,"user_id":null,"body":"open System\n\nlet geometricSequenceElements a r n =\n    let arr = Array.create n a\n    for i in 1..n - 1 do\n        Array.set arr i (arr.[i - 1] * r)\n    arr |> Array.map string |> String.concat \", \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84675,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) =\n    List.init n (fun index -> (a |> float) * ((r |> float) ** (index |> float)))\n    |> List.map (int32 >> string)\n    |> String.concat \", \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84676,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) =\n    let mutable x = a\n    let result = seq {\n        for _ in 1..n do\n            yield x\n            x <- x * r\n    }\n    String.Join(\", \", result)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84677,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) = \n    (\", \", [0..(n-1)] |> List.map (fun i -> string (a * (pown r i)))) |> String.Join","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84678,"user_id":null,"body":"open System\n\nlet geometricSequenceElements (a: int) (r: int) (n: int) =\n    String.Join(\", \",\n        Seq.unfold (fun acc -> Some (acc, r * acc)) a \n            |> Seq.take n\n            |> Seq.map (fun x -> x.ToString()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55cbc3586671f6aa070000fb":[{"id":84679,"user_id":null,"body":"let checkForFactor b f = \n    match f with\n    | 0 -> false\n    | _ -> b % f = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84680,"user_id":76,"body":"let checkForFactor b f = b % f = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84681,"user_id":null,"body":"let checkForFactor b f =\n    match f with\n    | 0 -> false\n    | f when b % f = 0 -> true\n    | f -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84682,"user_id":null,"body":"let checkForFactor base' factor =\n  base' % factor = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84683,"user_id":null,"body":"let checkForFactor b f = not (b % f > 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84684,"user_id":null,"body":"let checkForFactor (b:int) (f:int) : bool =\n  \/\/ Return true if f is a factor of b, false otherwise.\n  b % f = 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84685,"user_id":null,"body":"let checkForFactor b f =\n  let rest = b % f\n  match rest with\n  | 0 -> true\n  | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84686,"user_id":null,"body":"let checkForFactor b f =\n  let result = b % f \n  match result with\n  | 0 -> true\n  | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84687,"user_id":null,"body":"let checkForFactor b f =\n    match b % f with\n    | 0 -> true\n    | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84688,"user_id":null,"body":"let checkForFactor b f =\n  if b % f = 0 then true\n  else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55cf3b567fc0e02b0b00000b":[{"id":84689,"user_id":53,"body":"open System\nopen System.Collections.Generic\nopen System.Linq\n\nlet cache = new Dictionary<int, List<int64>>()\n\nlet rec partition (n: int): List<int64> =\n  if not (cache.ContainsKey(n)) then\n    let hs = new HashSet<int64>()\n    hs.Add(1L) |> ignore\n    for i in 1 .. n do\n      let ls = partition(n - i)\n      for j in 0 .. (ls.Count - 1) do\n        hs.Add(ls.[j] * (int64 i)) |> ignore\n    cache.Add(n, hs.OrderBy(fun x -> x).ToList())\n  cache.[n]\n\nlet part (n: int): string =\n  printfn \"%d\" n\n  let ls = partition(n)\n  let s = ls |> Seq.sum\n  let l = ls.Count\n  let r = ls.[ls.Count - 1] - ls.[0]\n  let u = (double)s \/ (double)l\n  let m = 0.5 * (double)(ls.[ls.Count \/ 2] + ls.[(ls.Count - 1) \/ 2])\n  sprintf \"Range: %d Average: %.2f Median: %.2f\" r u m","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84690,"user_id":492,"body":"let rec prod_k_parts p d n k =\n  if n < k then []\n  else if k = 1 then [p * (n + d)]\n  else\n    let p1 = prod_k_parts (p * (d + 1)) d (n - 1) (k - 1)\n    let p2 = prod_k_parts p (d + 1) (n - k) k\n    p1 @ p2\nlet prod_parts n =\n  let rec loop acc k =\n    if k > n then acc\n    else loop (prod_k_parts 1 0 n k @ acc) (k + 1) \n  in\n  loop [] 1 |> List.map (fun x -> double x)\n  \nlet part (n: int): string =\n  let arr = prod_parts n |> List.sort |> List.distinct |> Array.ofList\n  let sm = Array.fold (+) 0.0 arr\n  let n = Array.length arr \n  in\n    let range, mean, median =\n      if n = 0 then 0.0, 0.0, 0.0\n      else\n        arr.[n - 1] - arr.[0],\n        double sm \/ double n,\n        0.5 * (float (arr.[n \/ 2] + arr.[(n - 1) \/ 2])) \n    in\n    sprintf \"Range: %d Average: %.2f Median: %.2f\" (int range) mean median","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84691,"user_id":null,"body":"let enum n =\n    match n with\n    | 1 -> [ [ 1 ] ]\n    | _ ->\n        seq {\n            let a = Array.replicate n 0\n            let mutable k = 1\n            a.[1] <- n\n\n            while k <> 0 do\n                let x = a.[k - 1] + 1\n                let mutable y = a.[k] - 1\n                k <- k - 1\n\n                while x <= y do\n                    a.[k] <- x\n                    y <- y - x\n                    k <- k + 1\n\n                a.[k] <- (x + y)\n\n                yield (a |> Array.take (k + 1))\n        }\n        |> Seq.toList\n        |> List.map Array.toList\n\n\nlet prod n =\n    List.map (List.fold (*) 1) (enum n)\n    |> List.distinct\n    |> List.sort\n\nlet part n =\n    let lst = prod n\n    let len = List.length lst\n    let range = (List.last lst) - (List.head lst)\n\n    let average =\n        let nl = List.map (int64) lst \n        ((List.sum nl) |> float) \/ (len |> float)\n\n\n    let median =\n        if len % 2 = 1 then\n            float lst.[len \/ 2]\n        else\n            float (lst.[(len \/ 2) - 1] + lst.[(len \/ 2)])\n            \/ 2.0\n\n    System.String.Format(\"Range: {0:D} Average: {1:F2} Median: {2:F2}\", range, average, median)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84692,"user_id":50,"body":"let part (n: int): string =\n  match n with \n    | 1 -> \"Range: 0 Average: 1.00 Median: 1.00\"\n    | 2 -> \"Range: 1 Average: 1.50 Median: 1.50\"\n    | 3 -> \"Range: 2 Average: 2.00 Median: 2.00\"\n    | 4 -> \"Range: 3 Average: 2.50 Median: 2.50\"\n    | 5 -> \"Range: 5 Average: 3.50 Median: 3.50\"\n    | 6 -> \"Range: 8 Average: 4.75 Median: 4.50\"\n    | 7 -> \"Range: 11 Average: 6.09 Median: 6.00\"\n    | 8 -> \"Range: 17 Average: 8.29 Median: 7.50\"\n    | 9 -> \"Range: 26 Average: 11.17 Median: 9.50\"\n    | 10 -> \"Range: 35 Average: 15.00 Median: 14.00\"\n    | 11 -> \"Range: 53 Average: 19.69 Median: 16.00\"\n    | 12 -> \"Range: 80 Average: 27.08 Median: 22.50\"\n    | 13 -> \"Range: 107 Average: 35.07 Median: 27.00\"\n    | 14 -> \"Range: 161 Average: 47.33 Median: 35.00\"\n    | 15 -> \"Range: 242 Average: 63.91 Median: 45.00\"\n    | 16 -> \"Range: 323 Average: 84.44 Median: 56.00\"\n    | 17 -> \"Range: 485 Average: 112.66 Median: 73.50\"\n    | 18 -> \"Range: 728 Average: 151.44 Median: 96.00\"\n    | 19 -> \"Range: 971 Average: 199.34 Median: 118.50\"\n    | 20 -> \"Range: 1457 Average: 268.11 Median: 152.00\"\n    | 21 -> \"Range: 2186 Average: 358.10 Median: 197.00\"\n    | 22 -> \"Range: 2915 Average: 475.46 Median: 245.00\"\n    | 23 -> \"Range: 4373 Average: 633.44 Median: 315.00\"\n    | 24 -> \"Range: 6560 Average: 846.79 Median: 390.00\"\n    | 25 -> \"Range: 8747 Average: 1126.14 Median: 500.00\"\n    | 26 -> \"Range: 13121 Average: 1500.90 Median: 625.00\"\n    | 27 -> \"Range: 19682 Average: 2009.29 Median: 775.00\"\n    | 28 -> \"Range: 26243 Average: 2669.98 Median: 980.00\"\n    | 29 -> \"Range: 39365 Average: 3558.37 Median: 1224.50\"\n    | 30 -> \"Range: 59048 Average: 4764.89 Median: 1538.00\"\n    | 31 -> \"Range: 78731 Average: 6326.47 Median: 1920.00\"\n    | 32 -> \"Range: 118097 Average: 8457.17 Median: 2420.00\"\n    | 33 -> \"Range: 177146 Average: 11292.63 Median: 3024.00\"\n    | 34 -> \"Range: 236195 Average: 15031.03 Median: 3761.50\"\n    | 35 -> \"Range: 354293 Average: 20088.78 Median: 4704.00\"\n    | 36 -> \"Range: 531440 Average: 26832.81 Median: 5865.00\"\n    | 37 -> \"Range: 708587 Average: 35745.98 Median: 7371.00\"\n    | 38 -> \"Range: 1062881 Average: 47763.72 Median: 9152.00\"\n    | 39 -> \"Range: 1594322 Average: 63823.27 Median: 11475.00\"\n    | 40 -> \"Range: 2125763 Average: 85158.49 Median: 14250.00\"\n    | 41 -> \"Range: 3188645 Average: 113720.82 Median: 17745.00\"\n    | 42 -> \"Range: 4782968 Average: 152184.15 Median: 21888.00\"\n    | 43 -> \"Range: 6377291 Average: 202904.65 Median: 27262.50\"\n    | 44 -> \"Range: 9565937 Average: 271332.21 Median: 33796.00\"\n    | 45 -> \"Range: 14348906 Average: 363114.82 Median: 41947.50\"\n    | 46 -> \"Range: 19131875 Average: 484712.39 Median: 51975.00\"\n    | 47 -> \"Range: 28697813 Average: 648367.27 Median: 64260.00\"\n    | 48 -> \"Range: 43046720 Average: 867970.08 Median: 79830.00\"\n    | 49 -> \"Range: 57395627 Average: 1159398.98 Median: 98227.50\"\n    | 50 -> \"Range: 86093441 Average: 1552316.81 Median: 120960.00\"\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84693,"user_id":null,"body":"open System.Collections.Generic\n\nlet part (n: int): string =\n    let cache = Dictionary<_,_>()\n        \n    let rec enum (max: int) (n: int) = [\n        let enum max n =\n            match cache.TryGetValue((max, n)) with\n            | true, v -> v\n            | false, _ -> let v = enum max n\n                          cache.Add((max, n),v)\n                          v\n                          \n        if n <= max then yield [n]\n        for i in [1..(n-1)] do\n            let head = n - i\n            if head <= max then\n                yield! enum head i |> List.map (fun x -> head :: x)\n    ]\n    \n    let enum n = enum n n |> List.toArray\n    let prod = enum >> Array.map (List.reduce (*) >> decimal) >> Array.sort >> Array.distinct\n    let range xs = (Array.max xs) - (Array.min xs)\n    let median xs =\n        let lenght = Array.length xs\n        if lenght % 2 = 1 then float xs.[lenght \/ 2]\n        else float (xs.[lenght \/ 2 - 1] + xs.[lenght \/ 2]) \/ 2.\n        \n    let prod = prod n\n    sprintf \"Range: %.0f Average: %.2f Median: %.2f\" (range prod) (Array.average prod) (median prod)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84694,"user_id":null,"body":"type HashSet<'a> = System.Collections.Generic.HashSet<'a>\n\nlet withMedian (f: 'a -> 'a -> 'b) (arr: array<'a>) : option<'b> =\n    let length = Array.length arr\n    match length with\n    | 0 -> None\n    | l when l &&& 1 = 1 -> arr.[l \/ 2] |> (fun v -> f v v) |> Some\n    | l -> \n        let middle = l \/ 2 - 1\n        match arr.[middle .. middle + 1] with\n        | [|x; y|] -> f x y |> Some\n        | _ -> None\n\nlet median (coll: array<int>) : float =\n    let f x y = (float (x + y)) \/ 2.0\n    match withMedian f coll with\n    | None -> failwith \"Bug\"\n    | Some v -> v\n\nlet range (xs: array<int>) : int =\n    let first = xs.[0]\n    ((first, first), xs.[1 ..]) \n    ||> Array.fold (fun ((m, M) as state) x ->\n        let (uMin, uMax) = if x < m then (x, M) elif x > M then (m, x) else state\n        (uMin, uMax))\n    |> fun (m, M) -> M - m\n\nlet tryHead (xs: list<'a>) : Option<'a> =\n    if List.isEmpty xs then None else Some <| List.head xs\n\nlet partition (n: int) : seq<list<int>> =\n    let isIndexAboveLastElem i acc =\n        match tryHead acc with | Some n when n < i -> true | _ -> false\n    let hashSet : HashSet<list<int>> = new HashSet<list<int>>()\n    let mutable prune = false\n    let rec loop sum acc =\n        for i = 1 to n - sum do\n            if prune || isIndexAboveLastElem i acc\n            then ()\n            else \n                let uSum = sum + i\n                match uSum with\n                | uSum when uSum < n ->\n                    if i = 1 then\n                        let uAcc = List.fold (fun acc _ -> 1 :: acc) acc [1 .. n - sum]\n                        hashSet.Add(uAcc) |> ignore\n                    else\n                        let uAcc = i :: acc \n                        loop uSum uAcc\n                | uSum when uSum = n ->\n                    let uAcc = List.sort (i :: acc)\n                    hashSet.Add(uAcc) |> ignore\n                | _ -> prune <- true\n        prune <- false\n    loop 0 List.empty\n    Seq.cast<list<int>> hashSet\n\nlet part (n: int) =\n    let partitions = partition n \n    let a = \n        partitions \n        |> Seq.map (List.reduce (*))\n        |> Set.ofSeq\n        |> Set.toArray\n    let range = range a\n    let average = Array.average <| Array.map float a\n    let median = median a\n    sprintf \"Range: %d Average: %.2f Median: %.2f\" range average median\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84695,"user_id":null,"body":"let create n =    \n    let rec core current rest:int list list =\n          if rest = 0 then\n            [ [] ]\n          else\n            let limt = min current rest\n            let numbers = [ limt.. -1 ..1 ]\n            let result = numbers |> List.map ( fun x -> core x (rest - x) |> List.map (fun y -> x :: y) ) \n                                 |> List.concat\n            result           \n\n    core n n \n\nlet reduceList l =\n    l |> List.map (fun x -> List.reduce (*) x |> decimal) |> List.distinct |> List.toArray |> Array.sort\n\n\n\nlet part (n: int): string =\n  let array = create n |> reduceList\n  let range = array.[array.Length-1] - array.[0]\n  let average = Array.average array\n  let median =     \n    if array.Length % 2 = 0 then \n        (array.[array.Length \/ 2] + array.[array.Length\/2 - 1]) \/ 2.0m\n    else\n        array.[(array.Length - 1) \/ 2]\n  sprintf \"Range: %.0f Average: %.2f Median: %.2f\" range average median\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84696,"user_id":null,"body":"\nlet mutable _cache = Map.empty<int, int list>\n\nlet rec partitionProducts =\n    function\n    | 0 -> [1]\n    | n ->\n        match Map.tryFind n _cache with\n        | Some p -> p\n        | None ->\n            let res = \n                [1 .. n]\n                |> List.collect (fun m1 -> partitionProducts (n - m1) |> List.map (fun m2 -> m1 * m2))\n                |> List.distinct\n            _cache <- Map.add n res _cache\n            res\n\nlet part n =\n    let products = partitionProducts n |> List.sort |> List.map float |> Array.ofList\n    let lastIdx = products.Length - 1\n    \n    let range = products.[lastIdx] - products.[0]\n    let average = Array.average products\n    let median = \n        (products.[System.Math.Ceiling(float lastIdx \/ 2.) |> int] + products.[System.Math.Floor(float lastIdx \/ 2.) |> int]) \/ 2.\n\n    \/\/ \"Range: 3 Average: 2.50 Median: 2.50\"\n    sprintf \"Range: %.0f Average: %.2f Median: %.2f\" range average median\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84697,"user_id":null,"body":"open System.Collections.Generic\n\nlet getMedian l =\n    let length = (l |> Seq.length)-1 |> double\n    let firstIndex = length \/ 2. |> floor |> int\n    let lastIndex = length \/ 2. |> ceil |> int\n    (((l |> Seq.item firstIndex) + (l |> Seq.item lastIndex)) |> double) \/ 2.\n\nlet part n =\n    let final = new List<bigint>()\n    let rec partition n maxn prefix =\n        match n with\n        | 0 -> \n            final.Add (prefix |> List.reduce (*) |> (fun (x:int) -> bigint(x))) |> ignore \n        | _ ->\n            [(min maxn n) .. -1 .. 1] \n            |> List.map (fun i -> \n                partition (n-i) i (i::prefix)) |> ignore\n    partition n n []\n    let prod = final |> Seq.distinct |> Seq.sort\n    printfn \"%A\" (prod |> Seq.toList)\n    let range = (prod |> Seq.max) - (prod |> Seq.min)\n    let average = (prod |> Seq.sum |> double) \/ (prod |> Seq.length |> double)\n    let median = getMedian prod\n\n    sprintf \"Range: %i Average: %.2f Median: %.2f\" (range |> int) average median","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84698,"user_id":null,"body":"open System.Collections.Generic\n\n\/\/ some custom stuff to help with type inference on non-F# types\nmodule Dict =\n    let tryFind<'k, 'v> (k: 'k) (d: Dictionary<'k, 'v>) =\n        let (found, value) = d.TryGetValue k\n        match found with\n        | true -> Some(value)\n        | false -> None\n\n    let add<'k, 'v> (k: 'k) (v: 'v) (dict: Dictionary<'k, 'v>) =\n        dict.[k] <- v\n        ()\n\nmodule HashSet =\n    let add<'v> (v: 'v) (hs: HashSet<'v>) = hs.Add(v) |> ignore\n\n    let addRange<'v> (v: 'v seq) (hs: HashSet<'v>) = v |> Seq.iter (fun i -> hs |> add i)\n\nlet processPartitionProdcucts parts =\n    let products = parts |> (Seq.sort >> List.ofSeq)\n\n    let length = products |> List.length\n    let range = (products |> List.last) - (products |> List.head)\n    let avg = products |> Seq.averageBy float\n\n    let median =\n        match length % 2 with\n        | 1 -> products.[length \/ 2] |> float\n        | 0 -> float (products.[length \/ 2 - 1] + products.[length \/ 2]) \/ 2.0\n\n    sprintf \"Range: %i Average: %.2f Median: %.2f\" range avg median\n\nlet rec partitionWithMemoization =\n    let cache = Dictionary<int, HashSet<int>>()\n\n    let rec partition n =\n        match cache |> Dict.tryFind n with\n        | Some(x) -> x \/\/ we have the products in cache, just return\n        | None ->\n            \/\/ new number, compute from existing cache\n            \/\/ this is computing the product of the partition directly, not going through the partitions themselves\n            let partitions =\n                ({ 1 .. n \/ 2 }\n                 |> Seq.fold (fun acc sub ->\n                     let subPartitions = ((n - sub) |> partition) |> Seq.map (fun l -> sub * l)\n                     acc |> HashSet.addRange subPartitions\n                     acc) (HashSet<int>()))\n\n            partitions.Add(n) |> ignore\n\n            cache |> Dict.add n partitions\n            partitions\n    partition\n\nlet part (n: int): string =\n    let partition = partitionWithMemoization\n    n |> (partition >> processPartitionProdcucts)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55d24f55d7dd296eb9000030":[{"id":84699,"user_id":645,"body":"let summation n = n * (n + 1) \/ 2","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84700,"user_id":null,"body":"let summation n = Seq.sum {1 .. n}","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84701,"user_id":null,"body":"let summation n =\n  [ 1 .. n] |> List.reduce (fun acc x -> acc + x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84702,"user_id":null,"body":"let summation n =\n    \/\/ your code here\n    List.sum [1..n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84703,"user_id":null,"body":"let summation n =\n  let rec summationRec n acc =\n    match n with\n    | 0 -> acc\n    | _ -> summationRec (n - 1) (acc + n)\n  summationRec n 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84704,"user_id":null,"body":"let rec summation n =\n    if n > 0 then summation (n-1) + n else n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84705,"user_id":null,"body":"let summation n =\n    Seq.sum [1..n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84706,"user_id":null,"body":"let summation n = [1..n] |> Seq.fold(fun acc x-> acc+x) 0\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84707,"user_id":null,"body":"let summation n = [|1..n|] |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84708,"user_id":null,"body":"let summation n =\n  Seq.reduce (fun i accum -> accum + i) {1 .. n}\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55e2adece53b4cdcb900006c":[{"id":84709,"user_id":null,"body":"let race v1 v2 g =\n    if v1 >= v2\n    then None\n    else\n        let t = System.TimeSpan.FromHours (float g \/ float (v2 - v1))\n        Some [int t.TotalHours; t.Minutes; t.Seconds]\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84710,"user_id":492,"body":"let race v1 v2 g =\n    match v2 - v1 with\n    | d when d > 0 ->\n        let secs = 3600 * g \/ d\n        Some [secs \/ 3600; (secs % 3600) \/ 60; (secs % 3600) % 60]\n    | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84711,"user_id":null,"body":"let race v1 v2 g =\n    match v2 - v1 with\n    | diff when diff > 0 ->\n        let secs = 3600 * g \/ diff\n        Some [secs \/ 3600; (secs % 3600) \/ 60; (secs % 3600) % 60]\n    | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84712,"user_id":null,"body":"[<Measure>] type foot\n[<Measure>] type hour\n\nlet race v1 v2 g =\n    if v1 < v2 then\n        let hours = (float g * 1.<foot>) \/ (float (v2 - v1) * 1.<foot\/hour>)\n        System.TimeSpan.FromHours <| float hours\n        |> fun ts -> Some [int ts.TotalHours; ts.Minutes; ts.Seconds]\n    else\n        None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84713,"user_id":null,"body":"let race v1 v2 g =\n    v1\n    |> (-) v2\n    |> function\n        | pos when pos > 0 ->\n            pos\n            |> float\n            |> (\/) (float <| g)\n            |> System.TimeSpan.FromHours\n            |> fun time -> [time.TotalHours |> int; time.Minutes; time.Seconds]\n            |> Some\n        | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84714,"user_id":null,"body":"let race v1 v2 g =\n    if v1>=v2 then None\n    else\n      let sec = int (3600.*(float g)\/(float(v2-v1)))\n      Some [sec\/3600\n            sec%3600\/60\n            sec%60%60]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84715,"user_id":null,"body":"open System\nlet race v1 v2 g =\n    if v1 >= v2 then None\n    else let time = TimeSpan.FromHours ((float g \/ float (v2 - v1)))\n         Some([time.TotalHours |> int; time.Minutes; time.Seconds])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84716,"user_id":null,"body":"let race aSpeedFeetHour bSpeedFeetHour aLeadFeet =\n    let bCanNeverCatchupA = bSpeedFeetHour <= aSpeedFeetHour\n\n    if bCanNeverCatchupA then\n        None\n    else\n        \/\/ using substitution,\n        \/\/      bSpeed*T - (alead + aSpeed*T) = 0\n        let time2catchupHours =\n            float aLeadFeet\n            \/ float (bSpeedFeetHour - aSpeedFeetHour)\n\n        System.TimeSpan.FromHours time2catchupHours\n        |> fun t ->\n            Some [ int t.TotalHours\n                   t.Minutes\n                   t.Seconds ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84717,"user_id":null,"body":"let race v1 v2 g : (int list) option =\n    let nRace v1 v2 g =\n        let convert time : (int list) option =\n            let minutesWithHours: int = time \/ 60\n            let hours: int = minutesWithHours \/60\n            let minutes: int = minutesWithHours - (hours * 60)\n            let seconds: int = time - minutesWithHours*60\n            Some [hours; minutes; seconds]\n        let time: int = g*3600\/(v2 - v1)\n        convert time\n    match (v1,v2) with\n    | (x, y) when x >= y -> None\n    | _ -> nRace v1 v2 g","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84718,"user_id":null,"body":"\/\/ Shamelessly referenced top solution answer (slight modification).\nlet race ``tort A Speed`` ``tortoise B Speed`` ``tort A Lead`` =\n    if ``tort A Speed`` >= ``tortoise B Speed`` then\n        None\n    else\n        float ``tort A Lead``\n        \/ (float ``tortoise B Speed``\n           - float ``tort A Speed``)\n        |> System.TimeSpan.FromHours\n        |> fun ts -> [ int ts.TotalHours; ts.Minutes; ts.Seconds ]\n        |> Some\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55e6f5e58f7817808e00002e":[{"id":84719,"user_id":492,"body":"let seven(m: int) =\n    let rec helper(n, cnt) =\n        match n with\n        | x when x < 100 -> (n, cnt)\n        | _ -> helper((n \/ 10) - 2 * (n % 10), cnt + 1)\n    helper(m, 0)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84720,"user_id":null,"body":"let seven n =\n    let rec f = function\n    | n, _ as result when n < 100 -> result\n    | n, steps ->\n        let x, y = n \/ 10, n % 10\n        f (x - 2 * y, steps + 1)\n    f (n, 0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84721,"user_id":null,"body":"open System\n\nmodule UsefulFunctions =\n\n    \/\/\/Helper function for digitsFromNumber\n    let rec digitsFromNumberHelper number = \n            match number with\n                | n when n > 9 -> n % 10 :: digitsFromNumberHelper (n\/10)\n                | n -> [n]\n\n    \/\/\/Gets the digits from an integer number in a form of integer List\n    let digitsFromNumber = digitsFromNumberHelper >> List.rev\n    \n    \/\/\/Forms a number from digits in a form of integer List\n    let numberFromDigits nums =\n        nums\n        |> List.rev\n        |> List.mapi(fun i x -> ((int) (Math.Pow(10.0,(float)i)))*x) \n        |> List.sum\n\n    \/\/\/ Last item of a list\n    let lastElementOfList l = \n        l\n            |> List.rev \n            |> List.head\n\n    \/\/\/ List without the last element\n    let listWithoutLastElement l =\n        l\n            |> List.rev \n            |> List.tail \n            |> List.rev\n\nlet rec sevenHelper (num:int) (iters:int) =\n    match num with\n    | x when x>99 ->    let digits = UsefulFunctions.digitsFromNumber x\n                        let last = UsefulFunctions.lastElementOfList digits\n                        let restOfNumber = UsefulFunctions.numberFromDigits (UsefulFunctions.listWithoutLastElement digits)\n                        sevenHelper (restOfNumber - 2*last) (iters+1)\n    |x -> (num,iters)\n\n\n\nlet seven(m: int) = sevenHelper m 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84722,"user_id":null,"body":"let seven(m: int) =\n    let rec steps n i =\n          if(n \/ 100) = 0 then\n            (n, i)\n          else\n            let x = n \/10\n            let y = n % 10\n            \/\/printf \"%d\n\" x\n            \/\/printf \"%d\n\" y\n            let newn = x - 2*y\n            steps newn (i+1)\n    steps m 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84723,"user_id":null,"body":"let seven(m: int) =\n  let rec f next count =\n    let x = next \/ 10\n    let y = next % 10\n    match (x - 2 * y) with\n    | a when a > 99 -> f a (count + 1)\n    | a -> (a, count + 1)\n  if m = 0 then\n    (0, 0)\n  else\n    f m 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84724,"user_id":53,"body":"let seven(m: int) =\n    let rec aux(cnt, n) = \n      if n <= 99 then\n        (n, cnt)\n      else\n        aux(cnt + 1, (n \/ 10) - (2 * (n % 10)))\n    aux(0, m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84725,"user_id":null,"body":"let seven (m: int) =\n    let rec seven' (x, count) =\n        if string x |> String.length <= 2 then \n            (x, count)\n        else \n            let remaining, last = (x \/ 10, x % 10)\n            let result = remaining - (2 * last)\n            seven' (result, count + 1)\n\n    seven' (m, 0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84726,"user_id":null,"body":"let rec sevenHelper(m: int, n:int) =\n    if m < 100 then (m, n)\n    else\n        let x = m \/ 10\n        let y = m % 10\n        sevenHelper(x - 2 * y, n+1)\n\nlet seven(m: int) = sevenHelper(m, 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84727,"user_id":null,"body":"let seven(m: int) =\n    let rec checkDivisibilityByseven number step =\n        match number with\n        | number when number < 100 -> number, step\n        | number -> checkDivisibilityByseven (number \/ 10 - 2 * (number % 10)) (step + 1)\n    checkDivisibilityByseven m 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84728,"user_id":null,"body":"let seven(m:int) =\n    let rec sevenHelper(n, count) = \n        match n with\n        | x when x < 100 -> (n, count)\n        | _ -> sevenHelper((n \/ 10) - 2 * (n%10), count + 1)\n    sevenHelper(m, 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55e7280b40e1c4a06d0000aa":[{"id":84729,"user_id":null,"body":"let rec comb n l = \n    match n, l with\n    | 0, _ -> [[]]\n    | _, [] -> []\n    | k, (x::xs) -> List.map ((@) [x]) (comb (k-1) xs) @ comb k xs\n    \nlet choose_best_sum(t: int) (k: int) (ls: int list) = \n  comb k ls \n  |> List.map (fun a -> List.sum a) \n  |> List.filter (fun x -> x <= t) \n  |> List.append [-1]\n  |> List.max ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84730,"user_id":492,"body":"let rec private comb n l = \n    match n, l with\n    | 0, _ -> [[]]\n    | _, [] -> []\n    | k, (x::xs) -> List.map ((@) [x]) (comb (k-1) xs) @ comb k xs\n    \nlet choose_best_sum(t: int) (k: int) (ls: int list) =\n   let r = comb k ls |> List.map(fun x -> List.sum x) |> List.filter (fun x -> x <= t)\n   if (List.isEmpty r) then -1 else r |> List.max\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84731,"user_id":492,"body":"let rec private comb n l = \n    match n, l with\n    | 0, _ -> [[]]\n    | _, [] -> []\n    | k, (x::xs) -> List.map ((@) [x]) (comb (k-1) xs) @ comb k xs\n    \nlet choose_best_sum(t: int) (k: int) (ls: int list) =\n   let r = comb k ls |> List.map(fun x -> List.sum x) |> List.filter (fun x -> x <= t)\n   if (List.isEmpty r) then -1 else r |> List.max\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84732,"user_id":535,"body":"let rec choose_best_sum' (t: int) (k: int) (sum: int) (ls: int list) = \n    if k = 0 then sum\n    elif ls = [] then -1\n    else \n        let choose = choose_best_sum' (t-ls.[0]) (k-1) (sum+ls.[0]) ls.[1..]\n        let choose' = choose_best_sum' t k sum ls.[1..]\n        if ls.[0] > t then choose' else max choose choose'\n\nlet choose_best_sum (t: int) (k: int) = List.sort >> List.rev >> choose_best_sum' t k 0\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84733,"user_id":252,"body":"let choose_best_sum t m (d : int list) =\n    [1 .. (1 <<< d.Length) - 1]\n    |> Seq.map (fun n -> List.filter (fun b -> n &&& (1 <<< b) > 0) [0 .. d.Length - 1])\n    |> Seq.map (fun l -> if l.Length = m then Seq.sumBy (fun i -> d.[i]) l else -1)\n    |> Seq.filter ((>=) t)\n    |> Seq.max\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84734,"user_id":168,"body":"let rec combs (ls: int list) (k: int): int list seq =\n  match ls, k with\n  | _, 0 -> Seq.singleton []\n  | [], _ -> Seq.empty\n  | x :: xs, _ ->\n    combs xs (k - 1)\n    |> Seq.map (fun c -> x :: c)\n    |> Seq.append (combs xs k)\n\nlet choose_best_sum(t: int) (k: int) (ls: int list) =\n  combs ls k\n  |> Seq.map List.sum\n  |> Seq.filter (fun s -> s <= t)\n  |> Seq.append (Seq.singleton (-1))\n  |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84735,"user_id":null,"body":"open FSharp.Core\nopen FSharp.Collections\n\nlet rec combinations values amount =\n    let len = Array.length values in\n    if len = amount then Array.singleton values\n    else if len < amount || amount < 1 then Array.empty\n    else\n        let head = Array.head values |> Array.singleton in\n        let rest = Array.tail values in\n        let withHead =\n            if amount = 1 then Array.singleton head\n            else combinations rest (amount-1)\n                 |> Array.map (fun rest -> Array.concat [head; rest]) in\n        let withoutHead = combinations rest amount in\n        Array.concat [ withHead; withoutHead ]\n\nlet solveCorrect (distances: int []) (cityLimit:int) (travelLimit:int) =\n    try\n        combinations distances cityLimit\n        |> Array.map Array.sum\n        |> Array.filter (fun cost -> cost <= travelLimit )\n        |> Array.max\n    with\n        | :? System.ArgumentException -> -1\n        | e -> raise e\n\nlet choose_best_sum(t: int) (k: int) (ls: int list) =  \n  let arr = Array.ofList ls in\n  solveCorrect arr k t","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84736,"user_id":null,"body":"let choose_best_sum(t: int) (k: int) (ls: int list) = \n    let rec comb n l = \n        match n, l with\n        | 0, _ -> [[]]\n        | _, [] -> []\n        | k, (x::xs) -> List.map ((@) [x]) (comb (k-1) xs) @ comb k xs\n    match ls with\n    | [] -> -1\n    | x when x.Length < k -> -1\n    | x when x.Length = k -> if ls |> List.sum <= t then ls |> List.sum else -1\n    | _ when k = 1 -> ls |> List.filter(fun el -> el <= t) |> List.max \n    | _ -> let list =  ls |> List.filter(fun el -> el <= t && el > 0)\n           comb k list\n           |> List.fold(fun a e -> if e |> List.sum <= t && e |> List.sum > a then e |> List.sum else a) -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84737,"user_id":null,"body":"let choose_best_sum(t: int) (k: int) (ls: int list) =\n  let rec getMaxSum (t: int) (k: int) (ls: int list) =\n    match ls with\n    |ls when (k = 0)          -> 0\n    |[]                       -> System.Int32.MinValue\n    |head::tail when head > t -> (getMaxSum t k tail)\n    |head::tail               -> (max <| (head + (getMaxSum (t - head) (k - 1) tail)) <| (getMaxSum t k tail))\n  \n  let res = (getMaxSum t k ls)\n  if (res <= 0) then\n    -1\n  else\n    res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84738,"user_id":null,"body":"let NextIndexArrayWithILTJ (indices:int[]) =\n    let k = indices.Length\n    let rec Loop indexNumber =\n        if indexNumber = k-1 || indices.[indexNumber] + 1 < indices.[indexNumber+1] then\n            indices |> Array.mapi (fun i element -> if i < indexNumber then i elif i = indexNumber then element+1 else element)\n        else\n            Loop (indexNumber + 1)\n    Loop 0\n\nlet choose_best_sum(t: int) (k: int) (ls: int list) = \/\/ your code\n    let n = ls.Length\n    if k > n then\n        -1\n    else\n        let rec Loop cityIndices maxDistanceLTt =\n            if cityIndices |> Array.last = n then\n                maxDistanceLTt\n            else\n                let candidateSum = cityIndices |> Array.fold (fun acc index -> acc + ls.[index]) 0\n                let next_maxDistanceLTt = if candidateSum > maxDistanceLTt && candidateSum <= t then candidateSum else maxDistanceLTt\n                let next_cityIndices = NextIndexArrayWithILTJ cityIndices\n                Loop next_cityIndices next_maxDistanceLTt\n            \n        Loop (Array.init k (fun i -> i)) -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55e86e212fce2aae75000060":[{"id":84739,"user_id":492,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int[] list =\n    let mutable sol1 = [|abs(a*c + b*d); abs(b*c - a*d)|]\n    sol1 <- Array.sort sol1\n    let mutable sol2 = [|abs(a*d + b*c); abs(a*c - b*d)|]\n    sol2 <- Array.sort sol2\n    if (sol1.[0] = sol2.[0]) then \n        [sol1]\n    else if (sol1.[0] > sol2.[0]) then\n        [sol2; sol1]\n    else\n        [sol1; sol2]\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84740,"user_id":null,"body":"open System\n\nlet rec distribute e = function\n  | [] -> [[e]]\n  | x::xs' as xs -> (e::xs)::[for xs in distribute e xs' -> x::xs]\n\nlet rec permute = function\n  | [] -> [[]]\n  | e::xs -> List.collect (distribute e) (permute xs)\n\nlet MoreRule (a: int) (b: int) (c: int) (d: int) = \n    let permutations = permute [a;b;c;d]\n    let sums = permutations |> List.map(fun x -> Math.Abs(x.[0]*x.[1] + x.[2]*x.[3]))\n    let diffs = permutations |> List.map(fun x ->  Math.Abs(x.[0]*x.[1] - x.[2]*x.[3]))\n    List.append sums diffs\n    |> List.distinct\n    |> List.sort\n    |> List.map(fun x-> x|> float)\n\nlet factor number list = [\n    for i in list do \n        let t = Math.Floor(Math.Sqrt((number-Math.Pow((float)i,2.0))))\n        if (List.exists ((=)t) list) then \n            yield [|i|>int;t|>int|]\n    ]\n\nlet prod2Sum (a: int) (b: int) (c: int) (d: int): int[] list = \n    let number =(((float)(a*a)+(float)(b*b))*((float)(c*c)+(float)(d*d)))   \n    let coefficients = MoreRule a b c d\n    factor number coefficients\n    |> List.map(fun arr -> if (arr.[0]>arr.[1]) then [|arr.[1];arr.[0]|] else [|arr.[0];arr.[1]|])\n    |> List.distinct","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84741,"user_id":null,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int[] list = \n  let first = [|abs(a * c + b * d); abs(a * d - b * c)|]\n  let second = [|abs(a * d + b * c); abs(b * d - a * c)|]\n  [first; second] |> List.map (fun x -> x |> Array.sort) |>\n  List.sortBy (fun x -> x |> Array.head) |> List.distinct","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84742,"user_id":null,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int[] list =\n    let n_big = int64(pown a 2 + pown b 2) * int64(pown c 2 + pown d 2)\n    let try_add (e:int) lst =\n        let e_big = int64 e\n        let e_big_2 = e_big * e_big\n        if n_big - e_big_2 >= 0L then\n            let f = int(sqrt (float ((n_big - e_big_2))))\n            let f_big = int64 f\n            let f_big_2 = f_big * f_big\n            if e_big_2 + f_big_2 = n_big then\n                [|min (abs e) (abs f); max (abs e) (abs f)|] :: lst\n            else lst\n        else lst\n            \n    [] |> try_add (a*c + b*c) |> try_add (a*c + a*d) |> try_add (a*c + b*d)\n       |> try_add (b*c + a*d) |> try_add (b*c + b*d) |> List.distinct |> List.sortBy (fun x -> x.[0])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55efecb8680f47654c000095":[{"id":84743,"user_id":null,"body":"open System\n\nlet rec intRac (n: int64) (guess: int64) : int =\n  let newGuess = (guess + n \/ guess) \/ 2L\n  if newGuess = guess then\n    1\n  else\n    1 + intRac n newGuess\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84744,"user_id":null,"body":"let intRac (n: int64) (guess: int64) : int =\n  let rec loop n guess count =\n    let newGuess = (guess + n \/ guess) \/ 2L\n    if abs (guess - newGuess) < 1L then\n      count\n    else\n      loop n newGuess (count + 1)\n  loop n guess 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84745,"user_id":null,"body":"open System\n\nlet intRac (n : Int64) (guess : Int64) =\n    let rec f count x =\n        let x' = (x + n \/ x) \/ 2L\n        if x = x'\n        then count\n        else f (count + 1) x'\n\n    f 1 guess\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84746,"user_id":492,"body":"open System\n\nlet rec intRac (n: Int64) (guess: Int64) : int =\n    let newGuess = int64(floor(float((float(guess) + float(n) \/ float(guess)) \/ 2.0)))\n    if (abs(newGuess - guess) < 1L) then\n        1\n    else (intRac n newGuess) + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84747,"user_id":null,"body":"open System\n\/\/ open System to have `Int64`\n\nlet intRac (n: Int64) (guess: Int64) : int =\n    let rec innerFn (num: Int64) (preG: Int64) (count: int) =\n        let newG = (preG + num \/ preG) \/ 2L\n        match (newG - preG) |> abs with\n        | x when x < 1L -> count + 1\n        | _ -> innerFn num newG (count + 1)\n    innerFn n guess 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84748,"user_id":53,"body":"open System\n\nlet rec intRac (n: Int64) (m: Int64) : int =\n  let p = int64(floor(float((float(m) + float(n) \/ float(m)) \/ 2.0)))\n  if (abs(p - m) < 1L) then 1 else (intRac n p) + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84749,"user_id":null,"body":"open System\n\nlet rec intRac (n: Int64) (x: Int64) : int =\n  let y = (x + n \/ x) \/ 2L\n  if x = y then\n    1\n  else\n    1 + intRac n y","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84750,"user_id":null,"body":"open System\n\/\/ open System to have `Int64`\n\nlet e = 1L\n\nlet rec intRec (n: Int64) (guess: Int64) counter : int =\n    let newApproximate = (guess + n \/ guess) \/ 2L\n    if abs (newApproximate - guess) < e then counter\n    else intRec n newApproximate (counter + 1)\n\nlet intRac (n: Int64) (guess: Int64) : int =\n    intRec n guess 1\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84751,"user_id":null,"body":"open System\n\nlet rec intRac (n: Int64) (guess: Int64) : int =\n    let guess' = (guess + n \/ guess) \/ 2L\n    if abs (guess - guess') < 1L then 1 else 1 + intRac n guess'","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84752,"user_id":168,"body":"let rec intRac (n: int64) (guess: int64) : int =\n  let rec loop x i =\n    let x' = floor ((x + float n \/ x) * 0.5)\n    if abs (x - x') < 1. then i else loop x' (i + 1)\n  loop (float guess) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55f2b110f61eb01779000053":[{"id":84753,"user_id":null,"body":"let get_sum a b =\n    [| min a b .. max a b |] |> Array.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84754,"user_id":null,"body":"let get_sum a b =\n    match (a, b) with\n    | (a, b) when a > b -> [b..a] |> List.sum\n    | (a, b) when a < b -> [a..b] |> List.sum\n    | _ -> a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84755,"user_id":null,"body":"let get_sum (a: int) (b: int) : int = \n    [ min a b .. max a b ] |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84756,"user_id":null,"body":"let get_sum a b =\n  if a > b then List.sum [b..a] else List.sum [a..b]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84757,"user_id":527,"body":"let get_sum a b = (a + b) * (abs(a - b) + 1) \/ 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84758,"user_id":null,"body":"let get_sum a b = if a = b then a else [min a b .. max a b] |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84759,"user_id":null,"body":"let get_sum a b =\n    if a=b then  b\n    elif a>b then\n        let arr = [b..a]\n        let theSum = List.fold (fun acc elem -> acc + elem) 0 arr         \n        theSum\n    else\n        let arr = [a..b]\n        let theSum = List.fold (fun acc elem -> acc + elem) 0 arr            \n        theSum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84760,"user_id":null,"body":"let rec get_sum a b =\n  if a = b then\n    b\n  elif a < b then \n    get_sum b a\n  else\n    b + get_sum (b + 1) a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84761,"user_id":null,"body":"let get_sum a b =\n  (abs (a - b) + 1) * (a + b) \/ 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84762,"user_id":null,"body":"let rec get_sum a b =\n  match (a, b) with\n  | (a, b) when a = b -> a\n  | (a, b) when a < b -> seq{ a .. b } |> Seq.sum\n  | _                 -> get_sum b a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55f3da49e83ca1ddae0000ad":[{"id":84763,"user_id":null,"body":"open System\n\nlet tankVol (h: int) (d: int) (vt: int) =\n    let r = float d \/ 2.0\n    let tankLength = float vt \/ (Math.PI * pown r 2)\n    let triangularHeight = r - float h\n    let theta = 2.0 * acos(triangularHeight \/ r)\n    let liquideArea = ((pown r 2) \/ 2.0) * (theta - sin theta)\n    liquideArea * tankLength |> floor |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84764,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) =\n    let radius = (float d) \/ 2.0\n    let angle =\n        1.0-((float h)\/radius) |> acos |> (*) 2.0\n\n    let fuelArea =\n        ((radius * radius)\/2.0) * (angle - (sin angle))\n    \n    let totalArea = System.Math.PI * radius * radius\n\n    (int ((float vt) * (fuelArea \/ totalArea)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84765,"user_id":53,"body":"open System\n\nlet tankVol (h: int) (d: int) (vt: int) =\n  let n = Math.Acos(1.0 - (float h) \/ ((float d) \/ 2.0)) * 2.0\n  let m = Math.Floor((float vt) * (n - Math.Sin(n)) \/ (2.0 * Math.PI))\n  int m","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84766,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) =\n  let pi = 3.14159\n  let r = (float d) \/ 2.0\n  let hf = float h\n  let theta = 2.0 * acos ((r - hf) \/ r)\n  let area = r * r \/ 2.0 * (theta - sin(theta))\n  let totArea = r * r * pi\n  area \/ totArea * (float vt) |> truncate |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84767,"user_id":null,"body":"open System\n\nlet tankVol (h: int) (d: int) (vt: int) =\n    let radius = (float d) \/ 2.0 \/\/ Radius\n    let lenght = (float vt) \/ ( Math.PI * Math.Pow( radius, 2.0) ) \/\/ Tank lenght\n    \/\/ angle of the arc enclosed from the radii where the level and the circumference intersect\n    let theta = Math.Acos(1.0 - (float h \/ radius)) \n    \/\/ area of the sector of the circle  - area of the triangle with base the tangent af the arc\n    let area = Math.Pow( radius , 2.0 ) * theta - radius * (radius - float h) * Math.Sin(theta) \n    let vr = area * lenght\n    int vr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84768,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) =\n    let r = float d \/ 2.0\n    match h with\n    | 0                  -> 0\n    | x when x = d       -> vt\n    | x when float x = r -> vt \/ 2\n    | _                  ->\n        let fl, h' =\n            match h with\n            | x when float x > r -> true, d - h\n            | _                  -> false, h\n        let theta =\n            1.0 - float h' \/ r\n            |> System.Math.Acos\n            |> ( * ) 2.0\n        let areaProp =\n            let totArea = System.Math.PI * r ** 2.0\n            r ** 2.0 \/ 2.0 * (theta - System.Math.Sin theta) \/ totArea\n        match fl with\n        | true  -> 1.0 - areaProp\n        | false -> areaProp\n        |> ( * ) (float vt)\n        |> int\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84769,"user_id":492,"body":"open System\n\nlet tankVol (h: int) (d: int) (vt: int) =\n    if (h = d) then vt\n    else\n      let r = float(d) \/ 2.0\n      let r2 = r * r\n      let oa = r - float(h)\n      let theta = acos(oa \/ r)\n      let ab = r * sin(theta)\n      let k = float(vt) \/ Math.PI \/ r2\n      let sTheta = theta * r2 \/ 2.0\n      let sOab = ab * oa \/ 2.0\n      let s = 2.0 * (sTheta - sOab)\n      int(s * k)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84770,"user_id":null,"body":"open System\n\nlet tankVol (h: int) (d: int) (vt: int) =\n\n    let theta = Math.Acos(1.0 - 2.0 * float h \/ float d)\n\n    let vol =\n        float vt\n        * (theta \/ Math.PI - Math.Sin(2.0 * theta) \/ Math.PI \/ 2.0)\n\n    int vol\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84771,"user_id":null,"body":"open System \nlet tankVol (h: int) (d: int) (v: int) =\n    let hFloat = float h\n    let r = (float d) \/ 2.0\n    let aSector = r * r * (Math.Acos ((r - hFloat) \/ r))\n    let aTriangle = (r - hFloat) * (((2.0 * r * hFloat) - (hFloat * hFloat)) |> Math.Abs |> Math.Sqrt)\n    let area = aSector - aTriangle\n    let length = (float v) \/ (Math.PI * r * r)\n    area * length |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84772,"user_id":null,"body":"open System\n\/\/ Segment area: \n\/\/ 1\/2 (\u03b1 - sin\u03b1) R\u00b2    or    (\u03b8 - sin\u03b8 cos\u03b8) R\u00b2\n\/\/ where  \u03b8 = 1\/2 \u03b1\nlet tankVol (h: int) (d: int) (vt: int) =\n  let h = float h\n  let r = float d\/2.\n  let rr = r**2.\n  let cos\u03b8 = abs(r-h)\/r\n  let \u03b8 = acos cos\u03b8\n  let tankArea = Math.PI * rr\n  let S_seg = (\u03b8 - sin \u03b8 * cos\u03b8) * rr\n  float(vt) \/ tankArea  *  if h > r then tankArea - S_seg else S_seg\n  |> floor |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55f9bca8ecaa9eac7100004a":[{"id":84773,"user_id":2255,"body":"let past h m s = \n  (h * 60 * 60 + m * 60 + s) * 1000","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84774,"user_id":null,"body":"let past h m s = \n     h \n     |> (*) 60\n     |> (+) m\n     |> (*) 60\n     |> (+) s\n     |> (*) 1000","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84775,"user_id":null,"body":"let hourToMinutes x = x * 60\nlet minutesToSeconds x y = (x + y) * 60\nlet secondsToMilli x y = (x + y) * 1000\n\nlet past h m s = \n    hourToMinutes h |> minutesToSeconds m |> secondsToMilli s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84776,"user_id":null,"body":"let past h m s = \n    s * 1000 + m*60* 1000 + h* 60* 60 * 1000","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84777,"user_id":null,"body":"let past h m s = \n    60*60000*h + 60000*m + 1000*s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84778,"user_id":null,"body":"let past h m s =\n    let minutes = h * 60 + m\n    let seconds = minutes * 60 + s\n    1000 * seconds","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84779,"user_id":null,"body":"let past h m s = \n    \/\/ your code here\n    (h * 3600 + m * 60 + s) * 1000","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84780,"user_id":null,"body":"let past h m s = \n    let total = [|h*60*60*1000 ; m * 60 * 1000 ; s *1000|]\n    let result = \n      total\n      |> Array.sum\n    result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84781,"user_id":null,"body":"let past h m s = h * 60 |> fun min -> (min + m) * 60 |> fun sec -> (sec + s) * 1000\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84782,"user_id":null,"body":"let past h m s = \n    1000*(h*60*60 + m*60 + s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55fd2d567d94ac3bc9000064":[{"id":84783,"user_id":null,"body":"let row_sum_odd_numbers n = n * n * n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84784,"user_id":null,"body":"let row_sum_odd_numbers row = \n   pown row 3","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84785,"user_id":null,"body":"let row_sum_odd_numbers n = \n    \/\/ create infinite list\n    Seq.initInfinite (fun n -> n + 1)\n      \/\/ filter by odd numbers\n      |> Seq.filter (fun x -> (x % 2) = 1)\n      \/\/ skip the first set of numbers we won't sum\n      |> Seq.skip ([1..(n - 1)] |> List.sum)\n      \/\/ take the first n elements in the sequence\n      |> Seq.take n\n      \/\/ sum the sequence\n      |> Seq.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84786,"user_id":null,"body":"let row_sum_odd_numbers n = \n    pown n 3","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84787,"user_id":null,"body":"let row_sum_odd_numbers n = \n    Seq.initInfinite (fun n -> n + 1)\n      |> Seq.filter (fun x -> (x % 2) = 1)\n      |> Seq.skip ([1..(n - 1)] |> List.sum)\n      |> Seq.take n\n      |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84788,"user_id":null,"body":"let row_sum_odd_numbers n = (n-1)*(n+1)*n+n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84789,"user_id":null,"body":"let row_sum_odd_numbers n = \n    let num = n * (n - 1) + 1\n    List.sum [num..2..num + 2 * (n - 1)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84790,"user_id":null,"body":"let row_sum_odd_numbers n = \n    let arr = [0..n-1] |> Seq.map( fun x -> 2 * x ) \n    let firstNum = arr |> Seq.sum |> (+) 1\n    arr |> Seq.map( (+) firstNum ) |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84791,"user_id":null,"body":"let sumOfNaturals n = \n    n * (n + 1) \/ 2\n\nlet leftBound n =\n    (sumOfNaturals (n - 1)) * 2 + 1\n    \nlet rightBound n = \n    (sumOfNaturals n) * 2 - 1\n    \nlet row_sum_odd_numbers n = \n    [| (leftBound n)..2..(rightBound n) |] |> Array.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84792,"user_id":null,"body":"let totalOddCount maxLevel =\n    let rec loop level maxLevel count =\n        if level = maxLevel then\n            count + level\n        else\n            loop (level + 1) maxLevel (count + level)\n\n    loop 1 maxLevel 0\n\nlet findOdd oddCount = (oddCount - 1) * 2 + 1\n\nlet row_sum_odd_numbers n =\n    let firstOdd = findOdd ((totalOddCount n) - n + 1)\n    let mutable sum = 0\n    let mutable odd = firstOdd\n\n    for i = 1 to n do\n        sum <- sum + odd\n        odd <- odd + 2\n\n    sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56001790ac99763af400008c":[{"id":84793,"user_id":null,"body":"let computeLargestSum list =\n  let select (best, curr) i =\n    let curr =\n      max 0 (curr + i)\n\n    let best =\n      max curr best\n\n    (best, curr)\n\n  List.fold select (0, 0) list\n  |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84794,"user_id":null,"body":"let computeLargestSum =\n    List.fold\n        (fun (ldp, lres) v ->\n            let dp = max v (ldp + v)\n            (dp, max dp lres))\n        (0, 0)\n    >> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84795,"user_id":null,"body":"let computeLargestSum (list: List<int>) =\n    let (best, current) =\n        List.fold\n            (fun (best, current) x ->\n                let current = max 0 (current + x)\n                let best = max current best\n                (best, current))\n            (0, 0)\n            list\n\n    best","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84796,"user_id":null,"body":"let computeLargestSum = List.scan (fun p x -> max (p + x) 0) 0 >> List.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84797,"user_id":527,"body":"let computeLargestSum =\n  Seq.scan (fun s x -> s + x |> max 0) 0 >> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84798,"user_id":null,"body":"open System\n\nlet computeLargestSum ls =\n    List.fold (fun (acc, temp) elem ->\n        (max (temp + elem) acc, max (temp + elem) 0)) (0, 0) ls |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84799,"user_id":null,"body":"let computeLargestSum (vals:List<int>) =\n    let rec computeInner vals seqTotal highest  =\n        match vals with\n        | [] -> highest\n        | x::xs ->\n            if seqTotal + x <= 0 then\n                computeInner xs 0 highest \n            else computeInner xs (seqTotal + x) (max highest (seqTotal + x))\n    computeInner vals 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84800,"user_id":null,"body":"let computeLargestSum list =\n  let clamp x =\n    if x < 0\n    then 0\n    else x\n\n  let select (max, curr) i =\n    let curr =\n      clamp (curr + i)\n\n    let max =\n      if curr > max\n      then curr\n      else max\n\n    (max, curr)\n\n  List.fold select (0, 0) list\n  |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84801,"user_id":null,"body":"let computeLargestSum (list: List<int>) =\n    let mutable best = 0\n    let mutable current = 0\n\n    for x in list do\n        current <- max 0 (current + x)\n        best <- max best current\n\n    let (best, current) =\n        List.fold\n            (fun (best, current) x ->\n                let current = max 0 (current + x)\n                let best = max current best\n                (best, current))\n            (0, 0)\n            list\n\n    best","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84802,"user_id":null,"body":"let computeLargestSum (list:List<int>) = \n    let mutable best = 0\n    let mutable current = 0\n\n    for i in list do\n        current <- max (current + i) 0\n        best <- max best current\n\n    best\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5613d06cee1e7da6d5000055":[{"id":84803,"user_id":null,"body":"let isPrime n =\n    seq { for i in 2L..(n |> float |> sqrt |> int64) do yield n % i  }\n    |> Seq.tryFind (fun rem -> rem = 0L)\n    |> Option.isNone\n\nlet step(g, m, n) =\n    let firstPrimeInStep = \n        seq {m..n}\n        |> Seq.tryFind (fun i -> \n            let upperNum = i + g\n            (i |> isPrime) && upperNum <= n && (upperNum |> isPrime))\n    match firstPrimeInStep with\n    | Some p -> [p; p + g]\n    | None -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84804,"user_id":53,"body":"let step(g, m, n) =\n  let maxFactor num = int64 (sqrt (double num))\n  let isPrime num = not (Seq.exists (fun f -> num % f = 0L) (seq {2L..maxFactor num}))\n  match List.tryFind (fun i -> isPrime i && isPrime (i + g)) [ m .. n - g ] with\n    | Some a -> [a; a + g]\n    | None -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84805,"user_id":491,"body":"let step(g, m, n) =\n  let isPrime s = Seq.forall ((%) s >> (<>) 0L) {2L .. int64(sqrt(float(s)))}\n  let primeStep s = if s |> isPrime && s + g |> isPrime then Some [s; s + g] else None\n  match Seq.tryPick primeStep {m .. n - g} with\n  | Some lst -> lst\n  | None -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84806,"user_id":null,"body":"open System.Collections.Generic\n\nlet generatePrimes (n: int) =\n    let lastOdd = if n % 2 = 0 then n - 1 else n\n    let primes = Array.init ((lastOdd+1)\/2) (fun _ -> true)\n    primes.[0] <- false\n    let sqrtOfN = n |> float |> sqrt |> int\n    for i in [ 3 .. 2 .. sqrtOfN ] do\n        if primes.[i\/2] then\n            for c in [ (i)\/2+i .. i .. lastOdd\/2 ] do\n                primes.[c] <- false\n    seq {\n        if n >= 2 then yield 2\n        yield! primes\n        |> Array.indexed\n        |> Seq.filter (fun (i, n) -> n)\n        |> Seq.map (fun (i, n) -> if i = 0 then 2 else i*2+1)\n    }\n\nlet generatePrimeGaps (g: int64) (m: int64) (n: int64) = seq {\n    let validGaps = Dictionary<int64,int64>();\n    let primes = (generatePrimes (int n)) |> Seq.map int64\n    let from (m: int64) = Seq.filter (fun x -> x >= m)\n    for prime in primes |> from m do\n        validGaps.Add(prime + g, prime) |> ignore\n        if validGaps.ContainsKey(prime) then\n            yield [ validGaps.[prime]; prime ]\n}\n\nlet step((g: int64), (m: int64), (n: int64)) =\n    try\n        generatePrimeGaps g m n |> Seq.head\n    with\n    | :? System.ArgumentException -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84807,"user_id":492,"body":"let isPrime (n: int64) =\n    if (n = 2L) then true\n    else\n        if (n % 2L = 0L) then false\n        else\n            let sq = (float >> sqrt >> int64) n\n            [ 3L ..2L.. sq ] |> List.forall (fun x -> n % x <> 0L)\n              \nlet step(g, m, n) =\n  let rec aux k acc = \n    match k, acc with \n      | x, l when (x > n - g) || (List.length l > 0) -> acc\n      | _, _ ->\n        if (isPrime k) && (isPrime (k + g)) then\n          aux (k + 1L) ([k; k + g] :: acc)\n        else aux (k + 1L) acc\n  in \n    let res = aux m [] in\n      match res with\n        | x when x = [] -> []\n        | _ -> res.Head\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84808,"user_id":null,"body":"let step (g, m, n) =\n    let isPrime n =\n        if n < 2L || n % 2L = 0L then\n            false\n        else\n            let mutable i = 3L\n            let mutable br = false\n\n            while i * i <= n && not br do\n                if n % i = 0L then br <- true\n                i <- i + 2L\n\n            not br\n\n    List.zip [ m .. (n - g) ] [\n        (m + g) .. n\n    ]\n    |> List.skipWhile (fun (a, b) -> (a |> isPrime |> not) || (b |> isPrime |> not))\n    |> List.tryHead\n    |> function\n        | None -> []\n        | Some(a,b) -> [a;b]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84809,"user_id":null,"body":"let isPrime n =\n    match n with\n    | _ when n > 3L && (n % 2L = 0L || n % 3L = 0L) -> false\n    | _ ->\n        let maxDiv = int64(System.Math.Sqrt(float n)) + 1L\n        let rec f d i =\n            if d > maxDiv then\n                true\n            else\n                if n % d = 0L then\n                    false\n                else\n                    f (d + i) (6L - i)\n        f 5L 2L \/\/\n\nlet step(g, m, n) =\n  let primes =\n    seq {m .. n}\n    |> Seq.filter isPrime\n  primes\n  |> Seq.allPairs primes\n  |> Seq.filter (fun (x,y) -> y - x = g)\n  |> Seq.map (fun (x,y)-> [x;y])\n  |> Seq.tryHead\n  |> Option.defaultValue []\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84810,"user_id":null,"body":"let isPrime value =\n    let rec prime i =\n        if i * i > value then true\n        elif value % i = 0L || value % (i + 2L) = 0L then false\n        else prime (i + 6L)\n                 \n    if value <= 3L then value > 1L\n    elif value % 2L = 0L || value % 3L = 0L then false\n    else prime 5L\n\nlet step(g:int64, m:int64, n:int64) =  \n    [m..n-g]\n    |> List.tryFind (fun i -> isPrime i && isPrime (i+g))\n    |> Option.map (fun i -> [i; i+g])\n    |> Option.defaultValue []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84811,"user_id":null,"body":"let isPrime value =\n    let rec prime i =\n        if i * i > value then true\n        elif value % i = 0L || value % (i + 2L) = 0L then false\n        else prime (i + 6L)\n                 \n    if value <= 3L then value > 1L\n    elif value % 2L = 0L || value % 3L = 0L then false\n    else prime 5L\n\nlet step(g:int64, m:int64, n:int64) =\n    let rec findStep primes = \n        let rec findInner p primes =\n          match primes with\n          | h :: tail when h - p < g -> findInner p tail\n          | h :: _ when h - p = g -> Some(p, h)\n          | _ -> None\n        match primes with\n        | h :: tail ->\n            match (findInner h tail) with\n            | None -> findStep tail\n            | x -> x\n        | [] -> None\n\n    let primes = [m..n] |> List.filter isPrime        \n    findStep primes\n    |> Option.map (fun (x1, x2) -> [x1; x2])\n    |> Option.defaultValue []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84812,"user_id":null,"body":"let step (g, m, n) =\n    let prime n =\n        match n with\n        | _ when n > 3L && (n % 2L = 0L || n % 3L = 0L) -> false\n        | _ ->\n            let maxDiv = int64(System.Math.Sqrt(float n)) + 1L\n            let rec f d i = \n                if d > maxDiv then \n                    true\n                else\n                    if n % d = 0L then \n                        false\n                    else\n                        f (d + i) (6L - i)     \n            f 5L 2L\n\n    let v =\n        [m..n]\n        |> List.map (fun x -> (x, x + g))\n        |> List.tryFind (fun (x, y) -> prime x && prime y)\n\n    match v with\n    | None -> []\n    | Some (x, y) -> [x; y]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5616868c81a0f281e500005c":[{"id":84813,"user_id":492,"body":"open System\nopen System.Linq\nopen System.Collections.Generic\n\nlet rank(st: string) (we: int[]) (n: int) =\n    if (st = \"\") then\n        \"No participants\"\n    else if (we.Length < n) then\n        \"Not enough participants\"\n    else\n        let arrayNames: string[] = st.Split(',')\n        let arrayWeights: int[] = arrayNames.Select(fun x i -> (x.Select(fun y -> (int)(Char.ToLower y) - 96).Sum() + x.Length) * we.[i]).ToArray()\n        let listWeightNames = new List<KeyValuePair<int, string>>()\n        for i = 0 to arrayWeights.Length - 1 do\n            listWeightNames.Add (new KeyValuePair<int, string>(arrayWeights.[i], arrayNames.[i]))\n        Array.Sort(arrayWeights)\n        let firstRes = new List<string>()\n        for i in listWeightNames do\n            if (i.Key = arrayWeights.[arrayWeights.Length - n]) then \n                firstRes.Add(i.Value)\n        let res = firstRes.ToArray()\n        Array.Sort(res)\n        let mutable index = 0\n        for i = arrayWeights.Length - n + 1 to arrayWeights.Length - 1 do\n            if (arrayWeights.[arrayWeights.Length-n] = arrayWeights.[i]) then \n                index <- index + 1\n        res.[index]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84814,"user_id":null,"body":"open System\n\nlet nameToRank (s: string): int =\n  s.ToUpper()\n    |> Seq.fold (fun a c -> a + int c - 64) 0\n    |> (+) s.Length\n\nlet getNthRank (names: string[]) (we: int[]) (n: int) =\n  Seq.map nameToRank names\n    |> Seq.map2 (*) we\n    |> Seq.zip names\n    |> Seq.sortBy (fun (x, y) -> -y, x)\n    |> Seq.item (n - 1)\n    |> fst\n\nlet rank(st: string) (we: int[]) (n: int) =\n  let names = st.Split ','\n  match names with\n  | [|\"\"|] -> \"No participants\"\n  | x when Seq.length x < n -> \"Not enough participants\"\n  | _ -> getNthRank names we n \n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84815,"user_id":491,"body":"let rank(st: string) (we: int[]) (n: int) =\n    if st = \"\" then\n        \"No participants\"\n    elif n > st.Split(',').Length then\n        \"Not enough participants\"\n    else\n        let scoreName (name : string) =\n            name.ToCharArray()\n            |> Array.map (fun c -> int(System.Char.ToLower(c)) - 96)\n            |> Array.sum\n            |> fun x -> x + name.Length\n        let weightedNameScores =\n            st.Split(',')\n            |> Array.map scoreName\n            |> Array.zip we\n            |> Array.map (fun (weight, nameScore) -> -weight * nameScore)\n        let sortedNames =\n            Array.zip weightedNameScores (st.Split(','))\n            |> Array.sort\n        snd sortedNames.[n - 1]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84816,"user_id":null,"body":"open System\n\nlet winningNumber (nameWeight: string * int) =\n    let alph = [| 'a' .. 'z' |]\n    let name, weight = nameWeight\n    let l = [ for c in name.ToLower() -> Array.IndexOf(alph, c) + 1 ]\n    (-((l |> List.sum) + (name |> Seq.length)) * weight, name)\n\n\nlet rank (st: string) (we: int []) (n: int) =\n    match st with\n    | \"\" -> \"No participants\"\n    | _ ->\n        let names = st.Split [| ',' |]\n\n        if names |> Array.length < n then\n            \"Not enough participants\"\n        else\n            let names_weights = Array.zip names we\n            let s = names_weights |> Array.sortBy winningNumber\n            s.[n - 1] |> fst\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84817,"user_id":null,"body":"open System\n\nlet (!!) f i = Result.map f i\n\nlet isEmpty s = String.IsNullOrEmpty s\n\nlet split (c:char) (s:string) = \n    if isEmpty s then Error \"No participants\" \n    else s.Split(c) |> Array.toList |> Ok\n\nlet toUpper (s:string) = s.ToUpperInvariant()\nlet length (s:string) = s.Length\nlet charScore (c:char) = (int c) - 64\nlet nameScore = toUpper >> Seq.sumBy charScore\nlet score s = length s + nameScore s\nlet paired (weights: int[]) = List.mapi (fun i x -> x,weights.[i] * score x)\nlet sort w n = paired w n |> List.sortBy fst |> List.sortByDescending snd\nlet select = List.map fst\n \nlet run (names:string) (weights:int[]) =\n    names\n    |> split ','\n    |> !! (sort weights >> select)\n\nlet rank (names: string) (weights:int[]) (n: int) =\n    match run names weights with \n    | Error e -> e\n    | Ok s -> if n > s.Length then \"Not enough participants\" else s.[n-1]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84818,"user_id":null,"body":"open System\n\nlet rank(st: string) (we: int[]) (n: int) =\n    if (st.Length = 0 || System.String.IsNullOrWhiteSpace(st) )\n    then\n        \"No participants\"\n    elif (n > we.Length) \n    then\n        \"Not enough participants\"\n    else\n        let rankName (x:string) (weight:int)=\n            let aval = (char('a') |> int) - 1\n            (x.ToLower().ToCharArray() |> Array.fold (fun x y -> x + (int(y) - aval)) x.Length) * weight    \n        let namesList = st.Split(',') |> Array.map(fun x -> x.Trim()) \n        Array.map2 (fun x y -> (x, (rankName x y)))namesList we \n        |> Array.sortBy (fun x -> fst(x)) \n        |> Array.sortByDescending (fun x -> snd(x)) \n        |> Array.item (n - 1)\n        |> fst\n        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84819,"user_id":null,"body":"open System\n\nlet rank(namesStr: string) (weights: int[]) (n: int) =\n    let calcSom name = \n      name\n      |> Seq.map (fun c -> int (Char.ToLower c) - int 'a' + 2) \/\/ calcs rank+1. the +1 accounts for the string length\n      |> Seq.sum\n      \n    match ((namesStr.Split ','), weights, n) with\n    | ([|\"\"|], _, _) -> \"No participants\"\n    | (ns, _, n) when n > ns.Length -> \"Not enough participants\"\n    | (namesSeq, weights, n) ->\n      Seq.zip namesSeq weights\n        |> Seq.map (fun (name, weight) -> (name, (calcSom name) * weight))\n        |> Seq.sortBy fst\n        |> Seq.sortByDescending snd\n        |> Seq.item (n-1)\n        |> fst\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84820,"user_id":null,"body":"open System\n\nlet rank(st: string) (we: int[]) (n: int): string =\n\n  let nameScore (name: string): int =\n    Seq.fold (fun acc elem -> acc + int (Char.ToUpper elem) - 64) 0 name\n    + name.Length\n    \n  let participants = st.Split ','\n  if st = \"\" then \"No participants\"\n  elif n > participants.Length then \"Not enough participants\"\n  else\n    Seq.zip participants we\n    |> Seq.map (fun (name, weight) -> (name, (nameScore name) * weight))\n    |> Seq.sortBy (fun (name, weight) -> name)\n    |> Seq.sortWith (fun (_, w1) (_, w2) -> compare w2 w1)\n    |> Seq.map fst\n    |> Seq.item (n - 1)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84821,"user_id":null,"body":"open System\n\nlet rank(st: string) (we: int[]) (n: int) =\n    let countRank (s: string) =\n      s.ToLower() |> Seq.filter Char.IsLetter |>\n      Seq.fold (fun acc l -> acc + (int)l + 1 - (int)'a') 0 |>\n      (fun x -> x + s.Length)\n    \n    let strArray = st.Split(',')\n    if (st.Length = 0) then\n      \"No participants\"\n    else if (n > (Array.length strArray)) then\n      \"Not enough participants\"\n    else\n      strArray |> Array.indexed |> \n      Array.sortBy (fun (ind, b) -> -we.[ind] * countRank(b), b) |>\n      (fun x -> x.[n - 1]) |> (fun (ind,str) -> str)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84822,"user_id":null,"body":"open System\n\nlet rank (string: string) (weights: int []) (rankReturned: int): string =\n    match string.Split(',') with\n    | _names when string = \"\" -> \"No participants\"\n    | names when Array.isEmpty names -> \"No participants\"\n    | names when Array.length names < rankReturned -> \"Not enough participants\"\n    | names ->\n        let nameValue (name: string) =\n            let characterValue (c: char) =\n                let lowercasedValue = Char.ToLower c |> int\n                let alphabetStart = int 'a' - 1\n                lowercasedValue - alphabetStart\n\n            name.ToCharArray()\n            |> Array.map characterValue\n            |> Array.sum\n            |> fun s -> s + String.length name\n\n        names\n        |> Array.zip weights\n        |> Array.map (fun (weight, name) -> weight * nameValue name, name)\n        |> Array.sortWith (fun (value1, name1) (value2, name2) ->\n            if value1 = value2 then name1.CompareTo(name2) else value2.CompareTo(value1))\n        |> Array.indexed\n        |> Array.find (fun (i, _r) -> i = rankReturned - 1)\n        |> fun (_i, (_r, name)) -> name\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56170e844da7c6f647000063":[{"id":84823,"user_id":null,"body":"let people_with_age_drink = function\n  | o when o < 14 -> \"drink toddy\"\n  | o when o < 18 -> \"drink coke\"\n  | o when o < 21 -> \"drink beer\"\n  | _ -> \"drink whisky\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84824,"user_id":1277,"body":"let people_with_age_drink old =\n  if   old < 14 then \"drink toddy\"\n  elif old < 18 then \"drink coke\"\n  elif old < 21 then \"drink beer\"\n  else               \"drink whisky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84825,"user_id":null,"body":"let people_with_age_drink old =\n  match old with\n    | x when x < 14 -> \"drink toddy\"\n    | x when x < 18 -> \"drink coke\"\n    | x when x < 21 -> \"drink beer\"\n    | _ -> \"drink whisky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84826,"user_id":null,"body":"let people_with_age_drink: int -> string = \n    fun(age: int) ->\n        match age with\n        | age when age < 14 -> \"drink toddy\"\n        | age when age < 18 -> \"drink coke\"\n        | age when age < 21 -> \"drink beer\"\n        | _ -> \"drink whisky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84827,"user_id":17,"body":"let people_with_age_drink (n: int): string = \"drink \" + (if n < 14 then \"toddy\" else if n < 18 then \"coke\" else if n < 21 then \"beer\" else \"whisky\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84828,"user_id":null,"body":"let (|Under14|Under18|Under21|Over21|) age =\n  if age < 14 then Under14\n  elif age < 18 then Under18\n  elif age < 21 then Under21\n  else Over21\n\nlet people_with_age_drink age =\n  match age with\n  | Under14 -> \"drink toddy\"\n  | Under18 -> \"drink coke\"\n  | Under21 -> \"drink beer\"\n  | Over21 ->  \"drink whisky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84829,"user_id":null,"body":"\/\/ Redefining >= operator is bad practice! Don't do it in production!\nlet private (>=) a b = if a < b then 0 else 1\n\nlet people_with_age_drink age =\n  \"drink \"\n    + [| \"toddy\"; \"coke\"; \"beer\"; \"whisky\" |]\n      .[ (age >= 14) + (age >= 18) + (age >= 21) ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84830,"user_id":null,"body":"let private (>|) a b =\n  if a > b\n  then 1\n  else 0\n\nlet people_with_age_drink age =\n  [| \"drink toddy\"\n     \"drink coke\"\n     \"drink beer\"\n     \"drink whisky\" |].[ (age >| 13) + (age >| 17) + (age >| 20) ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84831,"user_id":null,"body":"let (|Children|Teens|Young|Adults|) old = \n  if old < 14 then Children\n  elif old < 18 then Teens\n  elif old < 21 then Young\n  else Adults\n\nlet people_with_age_drink old =\n  match old with\n  | Children -> \"drink toddy\"\n  | Teens -> \"drink coke\"\n  | Young -> \"drink beer\"\n  | Adults -> \"drink whisky\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84832,"user_id":null,"body":"let people_with_age_drink old =\n  match old with\n  | old  when old < 14 -> \"drink toddy\"\n  | old  when ((old >= 14) && (old < 18)) -> \"drink coke\"\n  | old  when ((old >= 18) && (old < 21)) -> \"drink beer\"\n  | _ -> \"drink whisky\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"561e9c843a2ef5a40c0000a4":[{"id":84833,"user_id":null,"body":"let isPrime n =\n    seq { 2..(float n |> sqrt |> int) }\n    |> Seq.exists (fun i -> n % i = 0)\n    |> not\n\nlet primes m n =\n    [m..n]\n    |> Seq.filter (fun i -> isPrime i)\n\nlet primePairs m n =\n    primes m n\n    |> Seq.pairwise\n\nlet gap g m n =\n    primePairs m n\n    |> Seq.tryFind (fun (a, b) -> b - a = g)\n    |> Option.map (fun (a, b) -> [|a; b|])\n    |> Option.defaultValue [||]\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84834,"user_id":null,"body":"open System\n\nlet isPrime n = \n  let bound = float n |> sqrt |> int\n  seq { 2..bound }\n  |> Seq.exists (fun x -> n % x = 0)\n  |> not\n\nlet gap (g: int) (m: int) (n: int): int[] = \/\/ your code\n  seq { m..n }\n  |> Seq.filter isPrime\n  |> Seq.pairwise\n  |> Seq.tryFind (fun (a, b) -> b - a = g)\n  |> Option.map (fun (a, b) -> [|a; b|])\n  |> Option.defaultValue [||]\n    ","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84835,"user_id":492,"body":"let private isPrime (n: int64) =\n    if (n = 2L) then true\n    else\n        if (n % 2L = 0L) then false\n        else\n            let sq = (float >> sqrt >> int64) n\n            [ 3L ..2L.. sq ] |> List.forall (fun x -> n % x <> 0L)\n            \nlet gap(g: int) (m: int) (n: int): int[] =\n    let p: int[] = [|0; 0|]\n    let mutable i: int = m\n    let mutable cont: bool = true\n    while (i < n) && (cont = true) do\n        if (isPrime (int64 i)) then\n            p.[0] <- p.[1]\n            p.[1] <- i\n            if (p.[1] - p.[0] = g) then\n                cont <- false\n        i <- i + 1\n    if (cont = false) then p\n    else [||]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84836,"user_id":null,"body":"let gap(g: int) (m: int) (n: int): int[] =\n    let isPrime p = \n        seq { 2 .. p \/ 2 }\n        |> Seq.forall (fun d -> p % d <> 0)\n        \n    match seq { m .. n-g }\n      |> Seq.tryPick (fun p -> \n          if isPrime p && seq { p+1 .. p+g-1 } |> Seq.forall (isPrime >> not) && isPrime (p+g) then\n            Some [| p ; p+g |]\n          else\n            None\n      ) with\n    | Some arr -> arr\n    | None -> [||]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84837,"user_id":null,"body":"let gap(g: int) (m: int) (n: int): int[] = \n    let isPrime p =\n      if p > 3 && (p % 2 = 0 || p % 3 = 0) then false\n      else\n          let square = int(System.Math.Sqrt(float p)) + 1\n          in\n            let rec aux d = \n                if d > square then true\n                else\n                    if p % d = 0 then false\n                    else\n                        aux (d + 2)   \n            in            \n               aux 5\n    in  \n      let rec gapaux1 y =\n        let t = y+2 \n        in\n          if t<=n then \n            if isPrime y then gapaux2 y t\n            else gapaux1 t\n          else [||]\n      and gapaux2 w z =\n        if isPrime z then \n          if z=w+g then [|w;z|]\n          else gapaux1 (w+2)\n        else \n          if z<w+g && z+2<n then gapaux2 w (z+2)\n          else gapaux1 (w+2)\n      in\n      if n=2 then\n        if isPrime (2+g) then [|2;(2+g)|]\n        else gapaux1 3\n      else \n        if n%2=0 then gapaux1 (m+1)\n        else gapaux1 m\n;;\n        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84838,"user_id":null,"body":"let gap(g: int) (m: int) (n: int): int[] = \n        let isPrime n =\n            if n = 2 || n = 3 then true\n            elif n <= 1 || n%2 = 0 || n%3 = 0 then false\n            else\n                Seq.initInfinite (fun i -> (6 * i) + 5)\n                |> Seq.takeWhile (fun i -> i * i <= n)\n                |> Seq.exists (fun i -> n%i = 0 || n%(i+2) = 0)\n                |> not\n        seq {m .. n}\n        |> Seq.filter isPrime \/\/ primes\n        |> Seq.pairwise \n        |> Seq.tryFind (fun (a,b) -> b-a = g) \/\/ try find gap\n        |> function | Some (a,b) -> [|a;b|] | None -> [||]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84839,"user_id":252,"body":"let isPrime n =\n    n < 4 || not <| Seq.exists (fun x -> 0 = n % x) [ 2 .. int (sqrt (single n)) ]\n\nlet gap g m n =\n    [| m .. n |]\n    |> Array.windowed (g + 1)\n    |> Array.tryFind (fun w -> isPrime w.[0] && isPrime w.[g] && not <| Seq.exists isPrime [ w.[1] .. w.[g - 1] ])\n    |> Option.bind (fun w -> Some [| w.[0]; w.[g] |])\n    |> Option.defaultValue [||]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84840,"user_id":252,"body":"let isPrime =\n    let mutable p = Array.zeroCreate<bool option> 1100000\n    fun n ->\n        match p.[n - 1] with\n        | Some b -> b\n        | None ->\n            p.[n - 1] <- Some (n < 4 || not <| Seq.exists (fun x -> 0 = n % x) [ 2 .. int (sqrt (single n)) ])\n            p.[n - 1].Value\n            \nlet gap g m n =\n    [ m .. n ]\n    |> Seq.tryFind (fun x -> (x + g <= n) && isPrime x && isPrime (x + g) && not <| Seq.exists isPrime [ x + 1 .. x + g - 1 ])\n    |> Option.bind (fun x -> Some [| x; x + g |])\n    |> Option.defaultValue [||]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84841,"user_id":168,"body":"let is_odd_prime(n: int): bool =\n  seq { 3 .. 2 .. int (sqrt (float n)) }\n  |> Seq.forall (fun d -> n % d <> 0)\n\nlet gap(g: int) (m: int) (n: int): int[] =\n  seq { m ||| 1 .. 2 .. n }\n  |> Seq.filter is_odd_prime\n  |> Seq.windowed 2\n  |> Seq.tryFind (function [| a; b |] -> b - a = g | _ -> false)\n  |> Option.defaultValue [||]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84842,"user_id":53,"body":"let gap(g: int) (m: int) (n: int): int[] =\n  let maxFactor num = int (sqrt (float num))\n  let isPrime num = not (Seq.exists (fun f -> num % f = 0) (seq {2..maxFactor num}))\n  let mutable a = 0\n  let mutable b = 0\n  let mutable i = m\n  let mutable f = false\n  while not f && i - 1 <= n do\n    if b - a = g then \n      f <- true\n    elif isPrime i then\n      a <- b\n      b <- i\n    i <- i + 1\n  if f then\n    [|a; b|]\n  else\n    [||]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5629db57620258aa9d000014":[{"id":84843,"user_id":null,"body":"open System\n\nlet mix_strings (s1: string) (s2: string): string =\n  let countChars (char: char) = Seq.filter ((=) char) >> Seq.length\n  let chars = \n      [\n          'a'\n          'b'\n          'c'\n          'd'\n          'e'\n          'f'\n          'g'\n          'h'\n          'i'\n          'j'\n          'k'\n          'l'\n          'm'\n          'n'\n          'o'\n          'p'\n          'q'\n          'r'\n          's'\n          't'\n          'u'\n          'v'\n          'w'\n          'x'\n          'y'\n          'z'\n      ]\n\n  chars\n  |> Seq.map\n      (fun i -> \n          let num1 = countChars i s1\n          let num2 = countChars i s2\n          match num1, num2 with \n          | n1, n2 when n1> n2 && n1 >= 2 -> (\"1:\", (i, n1)) \n          | n1, n2 when n2> n1 && n2 >= 2 -> (\"2:\", (i, n2))\n          | _ -> (\"=:\", (i, num1))\n      )\n  |> Seq.filter(fun (_, (_, n)) -> n >= 2)\n  |> Seq.sortByDescending(fun (s, (_, n)) -> n, (if s = \"=:\" then 0 else 1), (if s = \"1:\" then 1 else 0))\n  |> Seq.map(fun (s, (i, n)) -> s + (String.replicate n <| string i))\n  |> String.concat \"\/\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84844,"user_id":null,"body":"open System\n\nlet isLowerCase ch = List.contains ch ['a' .. 'z']\n\nlet mix_strings (s1: string) (s2: string): String =\n    let getLetterFrequencies str =\n        str\n        |> Seq.groupBy id\n        |> Seq.filter (fun (ch, _) -> isLowerCase ch)\n        |> Seq.map (fun (ch, chSeq) -> ch, Seq.length chSeq)\n        |> Seq.filter (fun (_, count) -> count > 1)\n        \n    let stats1 = getLetterFrequencies s1\n    let stats2 = getLetterFrequencies s2\n    \n    let letters1 = stats1 |> Seq.map fst |> Set.ofSeq\n    let letters2 = stats2 |> Seq.map fst |> Set.ofSeq\n    let unionLetters = Set.union letters1 letters2\n    let intersectLetters = Set.intersect letters1 letters2\n    let letters1Only = Set.difference letters1 letters2\n    \n    seq {\n        for ch in unionLetters do\n            let isLetterThere = Set.contains ch\n            \n            if isLetterThere intersectLetters then\n                let from1 = stats1 |> Seq.find (fun (c, _) -> c = ch) |> snd\n                let from2 = stats2 |> Seq.find (fun (c, _) -> c = ch) |> snd\n                match from1.CompareTo from2 with\n                | 1 -> yield (\"1\", string ch, from1)\n                | -1 -> yield (\"2\", string ch, from2)\n                | _ -> yield (\"=\", string ch, from1)\n                \n            elif isLetterThere letters1Only then\n                let i = stats1 |> Seq.find (fun (x, _) -> x = ch) |> snd\n                yield (\"1\", string ch, i)\n                \n            else\n                let i = stats2 |> Seq.find (fun (x, _) -> x = ch) |> snd\n                yield (\"2\", string ch, i)            \n    }\n    |> List.ofSeq\n    |> List.map (fun (pos, ch, count) -> pos, String.replicate count ch, count)\n    |> List.map (fun (pos, ch, count) -> sprintf \"%s:%s\" pos ch, count)\n    |> List.sortBy (fun (str, _) -> str)\n    |> List.sortByDescending (fun (_, count) -> count)\n    |> List.map fst\n    |> String.concat \"\/\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84845,"user_id":null,"body":"open System\n\nlet chars (s:string, id:int) = \n    s.ToCharArray() \n    |> Seq.groupBy (fun c -> c)\n    |> Seq.map (fun (k,v) -> (k, Seq.length v, id))\n    |>Seq.filter (fun (c, l, _) -> (int)c >= 97 && (int)c <= 122 && l > 1)\n\nlet find_max (s: (char * int * int) seq) =\n    s   |> Seq.groupBy (fun (_, l, _) -> l) \n        |> Seq.maxBy (fun (k, v) -> k)\n        |> snd\n        |> fun a -> (Seq.head a) |> fun (_, l, id) -> (l, if (Seq.length a) = 1 then id else 3)\n\nlet mix_strings (s1: string) (s2: string): string =\n    Seq.concat [chars (s1, 1); chars (s2, 2)]\n    |> Seq.groupBy (fun (c, _, _) -> c)\n    |> Seq.map (fun (c, s) -> (c, find_max (s)))\n    |> Seq.sortBy (fun (c, (l, id)) -> (-l, id, c))\n    |> Seq.map (fun (c, (l, id)) -> id.ToString().Replace('3', '=') + \":\" + new string(c, l))\n    |> String.concat \"\/\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84846,"user_id":null,"body":"open System\n\nlet mix_strings (s1: string) (s2: string) =\n    if s1 = s2 then \"\" else\n    let filterRelevant S N = \n        S \n        |> Seq.where(fun c -> (Char.IsLower c && Char.IsLetter c)) \n        |> Seq.groupBy(fun c -> c) \n        |> Seq.where (fun x -> (Seq.length (snd x) > 1)) \n        |> Seq.map(fun x -> (N,snd x))\n    let grouped = Seq.groupBy(fun x -> Seq.head (snd x)) (Seq.append (filterRelevant s1 \"1:\") (filterRelevant s2 \"2:\")) |> Seq.map (fun x -> snd x)\n    let compared =\n        grouped\n        |> Seq.map (fun x -> let first = Seq.head x\n                             let second = Seq.last x \n                             match first = second with\n                             | true -> first\n                             | false -> let l1 = Seq.length (snd first)\n                                        let l2 = Seq.length (snd second)\n                                        match l1 > l2 with\n                                        |true -> first\n                                        |false when l2>l1 -> second\n                                        |_ -> (\"=:\",snd first))\n    let sorted = \n        let longest = compared |> Seq.map(fun x -> Seq.length (snd x)) |> Seq.max\n        compared\n        |> Seq.sortBy(fun x -> (longest - (Seq.length (snd x))), (fst x) , Seq.head (snd x) )\n    let res = sorted |> Seq.map (fun x -> (fst x) + (String.Concat (snd x)))\n    (\"\",res) ||> Seq.fold (fun acc curr -> acc+\"\/\"+curr) |> Seq.tail |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84847,"user_id":null,"body":"open System\n\nlet mix_strings (s1: string) (s2: string): string =\n  \n  let filter s n=s  |>List.ofSeq\n                    |>Seq.filter(fun x-> System.Char.IsLetter(x))\n                    |>Seq.groupBy(fun x -> x.ToString())\n                    |>Seq.map(fun (x,y)->(x,y|>Seq.toArray,n))\n                    |>Seq.filter(fun (x,y,z)->y.Length>1)\n                    |>Seq.toArray\n  \n  let getCurrentData (data:seq<string*char[]*string>):string*char[]*string =         \n         let max=data|>Seq.map(fun (x,y,z)->y.Length)|>Seq.max\n         let zt=data|>Seq.filter(fun (x,y,z)->y.Length=max)|>Seq.toArray\n         if zt.Length=1 then\n             zt.[0]\n         else\n             zt.[0]|>fun (x,y,z)->(x,y,\"=\")              \n \n  let z1= filter (s1) \"1\"\n  let z2= filter (s2) \"2\"\n  let z3= Array.append z1 z2\n          |>Seq.groupBy(fun (x,_,_)->x)\n          |>Seq.map(fun (_,y)-> getCurrentData(y))\n          |>Seq.distinctBy(fun (x,y,z)->x.ToLowerInvariant())\n          |>Seq.sortByDescending(fun(x,y,z)->y.Length)         \n          |>Seq.sortBy(fun(x,y,z)->x)         \n          \n  let result = query {\n        for (x,y,z) in z3 do\n        sortByDescending y.Length\n        thenBy (if z=\"=\" then \"z\" else z) \n        thenBy x\n    }    \n  result  |>Seq.map(fun (x,y,z)->x+\":\"+ (y|>Seq.map(fun g->g.ToString())|>String.concat \"\") )\n          |>Seq.map(fun x->x.ToLowerInvariant())\n          |>String.concat (\"\/\")\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84848,"user_id":null,"body":"open System.Text.RegularExpressions\n\nmodule String =\n    let replace pattern replacement str =\n        Regex.Replace(str, pattern = pattern, replacement = replacement)\n\n    let split pattern input = Regex.Split(input, pattern = pattern)\n\n    let toCharArray (string: string) = string.ToCharArray()\n\ntype Label = S1|S2|EQ\nmodule Label =\n    let toString =\n        function\n        |S1-> \"1\"\n        |S2-> \"2\"\n        |EQ-> \"=\"\n\ntype StringsInfo =\n    { Char: char\n      Label: Label\n      Count: int }\nmodule StringsInfo =\n    let toString info =\n        sprintf \"%s:%s\" (Label.toString info.Label)\n        <| String.replicate info.Count (string info.Char)\n\n\nlet analyze label str =\n    str\n    |> String.replace \"[^a-z]\" \"\"\n    |> String.toCharArray\n    |> Array.groupBy id\n    |> Array.map\n        (fun (char, subs) ->\n            { Char = char\n              Label = label\n              Count = Array.length subs })\n\nlet mix_strings (s1: string) (s2: string) : string =\n    [ analyze S1 s1; analyze S2 s2 ]\n    |> Array.concat\n    |> Array.filter (fun s -> s.Count >= 2)\n    |> Array.sortBy (fun s -> s.Char)\n    |> Array.fold\n        (fun acc elem ->\n            match elem, acc with\n            | _, [] -> [ elem ]\n            | { Char = el }, { Char = al } :: _ when el <> al -> [ elem ] @ acc\n            | { Count = ec }, { Count = ac } :: _ when ec < ac -> acc\n            | { Count = ec }, { Count = ac } :: tail when ec = ac -> [ { elem with Label = EQ } ] @ tail\n            | { Count = ec }, { Count = ac } :: tail when ec > ac -> [ elem ] @ tail\n            | e -> invalidArg \"e\" \"Invalid pattern\")\n        []\n    |> List.sortBy (fun s -> (- s.Count),s.Label,s.Char)\n    |> List.map StringsInfo.toString\n    |> String.concat \"\/\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84849,"user_id":null,"body":"open System\n\ntype StringDeterminer = | S1 | S2 | E with\n    member this.PrettyPrint() =\n        match this with\n        | S1 -> \"1\"\n        | S2 -> \"2\"\n        | E -> \"=\"\n\ntype Candidate = {\n    Character: char;\n    Frequency: int;\n    Determiner: StringDeterminer\n} with\n    member this.PrettyPrint() =\n        sprintf \"%s:%s\" (this.Determiner.PrettyPrint()) (Seq.replicate this.Frequency this.Character |> String.Concat)\n\nlet parse (d: StringDeterminer) (s: string) =\n    s.ToCharArray()\n    |> Seq.countBy id\n    |> Seq.filter (fun (c, n) -> c >= 'a' && c <= 'z' && n > 1)\n    |> Seq.map (fun (c, n) -> { Character = c; Frequency = n; Determiner = d} )\n\nlet folder (st: Map<char, Candidate>) (item: Candidate) =\n    let add c m = Map.add c.Character c m\n    let replace c1 c2 m = m |> Map.remove c1.Character |> Map.add c2.Character c2\n\n    match st.TryFind (item.Character) with\n    | None -> add item st\n    | Some c when c.Frequency < item.Frequency -> replace c item st\n    | Some c when c.Frequency = item.Frequency -> replace c { item with Determiner = StringDeterminer.E } st\n    | Some _ -> st\n\nlet mix_strings (s1: string) (s2: string): string =\n    let comparer = (fun (c: Candidate) -> -(c.Frequency), c.Determiner, c.Character)\n    \n    let state =\n        parse StringDeterminer.S1 s1\n        |> Seq.map (fun (c: Candidate) -> (c.Character, c))\n        |> Map\n\n    Seq.fold folder state (parse StringDeterminer.S2 s2)\n    |> Map.toSeq\n    |> Seq.map snd\n    |> Seq.sortBy comparer\n    |> Seq.map (fun c -> c.PrettyPrint())\n    |> String.concat \"\/\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84850,"user_id":491,"body":"open System\n\nlet mix_strings (s1: string) (s2: string) : string =\n    let counterLowerCaseCharacters = Seq.filter Char.IsLower >> Seq.countBy id >> Map.ofSeq\n    let c1, c2 = counterLowerCaseCharacters s1, counterLowerCaseCharacters s2\n    let k1 = c1 |> Map.filter (fun _ v -> v > 1) |> Map.toSeq |> Seq.map fst |> Set.ofSeq\n    let k2 = c2 |> Map.filter (fun _ v -> v > 1) |> Map.toSeq |> Seq.map fst |> Set.ofSeq\n    let tokenGenerator s t =\n        if Map.containsKey t c1 && not <| Map.containsKey t c2 then\n            Map.add t ('1', Map.find t c1) s\n        else if not <| Map.containsKey t c1 && Map.containsKey t c2 then\n            Map.add t ('2', Map.find t c2) s\n        else\n            let token =\n                match (Map.find t c1), (Map.find t c2) with\n                | n1, n2 when n1 > n2 -> ('1', n1)\n                | n1, n2 when n1 < n2 -> ('2', n2)\n                | _ -> ('=', Map.find t c1)\n            Map.add t token s\n    Set.union k1 k2\n    |> Seq.fold tokenGenerator Map.empty\n    |> Map.toSeq\n    |> Seq.sortBy (fun (k, (s, v)) -> -v, s, k)\n    |> Seq.map (fun (k, (s, v)) -> sprintf \"%c:%s\" s (String.replicate v (string k)))\n    |> String.concat \"\/\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84851,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet mix_strings (s1: string) (s2: string): string =\n    let get_dict (s:string) =\n        let d = new Dictionary<char, int>()\n        s |> Seq.filter (fun c -> c >= 'a' && c <= 'z') |> Seq.iter (fun c -> match d.TryGetValue c with | true, v -> d.[c] <- v + 1 | _ -> d.Add(c, 1))\n        d |> Seq.map (fun kv -> (kv.Value, kv.Key)) |> Seq.sortBy (fun (f, s) -> -f, s) |> Seq.toList\n    let d1 = get_dict s1\n    let d2 = get_dict s2\n    let rec inner res (h:HashSet<char>) d1 d2 =\n        match d1, d2 with\n        | (_, c1)::t1, _ when h.Contains(c1) -> inner res h t1 d2\n        | _, (_, c2)::t2 when h.Contains(c2) -> inner res h d1 t2\n        | (n1, c1)::t1, (n2, c2)::t2 when n1 > 1 || n2 > 1 ->\n            let key, num, chr, newD1, newD2 =\n                if n1 > n2 then \"1\", n1, c1, t1, d2\n                elif n1 < n2 then \"2\", n2, c2, d1, t2\n                elif c1 < c2 then \"1\", n1, c1, t1, d2\n                elif c1 > c2 then \"2\", n2, c2, d1, t2\n                else \"=\", n1, c1, t1, t2\n            h.Add(chr) |> ignore\n            inner ((key, num, chr)::res) h newD1 newD2\n        | _ -> res\n    let result = inner [] (HashSet()) d1 d2\n    let str key n c = key + \":\" + new string(c, n)\n    result\n    |> List.sortBy (fun (key, num, chr) -> -num, key, chr)\n    |> List.fold (fun res (key, num, chr) ->\n        let newRes = str key num chr\n        if res = \"\" then newRes else res + \"\/\" + newRes\n    ) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84852,"user_id":null,"body":"let whichHasMore = function\n| Some c1, Some c2 when c1 > c2 -> Some (\"1\", c1) \/\/\"1:\" + String.replicate c1 (string sym)\n| Some c1, Some c2 when c1 < c2 -> Some (\"2\", c2)\n| Some c, Some _ -> Some (\"=\", c) \n| Some c, _ -> Some (\"1\", c)\n| _, Some c -> Some (\"2\", c)\n| _, _ -> None \n\nlet addIfExists l sym = function\n| Some (strnum, count) ->  strnum + \":\" + String.replicate count (string sym) :: l\n| None -> l\n\n#nowarn \"25\"\n\nlet mix_strings s1 s2 =\n    let [m1; m2] = \n        [s1; s2]\n        |> List.map \n            ( Seq.filter (fun c -> c >= 'a' && c <= 'z')\n            >> Seq.countBy id\n            >> Seq.filter (fun (x, i) -> i > 1)\n            >> Map.ofSeq )\n    ['a'..'z']\n    |> List.fold (fun l sym -> (Map.tryFind sym m1, Map.tryFind sym m2) |> whichHasMore |> addIfExists l sym) []\n    |> List.sortBy (fun str -> System.Int32.MaxValue - String.length str, str)\n    |> String.concat \"\/\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"562b384167350ac93b00010c":[{"id":84853,"user_id":492,"body":"open System.Linq\n\nlet rec private gcd x y = if y = 0 then abs x else gcd y (x % y)\n\nlet private gn(n: int): int list =\n    let mutable prev = 7\n    let mutable res: int list = [1]\n    for i = 2 to n do\n        let nou = prev + (gcd prev i)\n        res <- (nou - prev) :: res\n        prev <- nou\n    res |> List.rev\n \nlet countOnes(n: int): int =\n    gn(n).Where(fun c -> c = 1).ToArray().Length;\n\nlet private pn(n: int): int list = \n    let mutable prev = 7\n    let mutable res: int list = [1]\n    let mutable i = 2\n    let mutable cnt = 0\n    while (cnt < n) do\n        let nou = prev + (gcd prev i)\n        let d = nou - prev\n        if d <> 1 && (List.exists (fun elem -> elem = d) res = false) then\n            res <- d :: res\n            cnt <- cnt + 1\n        prev <- nou\n        i <- i + 1\n    res\n\nlet maxPn(n: int): int =\n    pn(n).Max()\n  \nlet private anOvern(n: int): int list =\n    let mutable prev = 7\n    let mutable res: int list = []\n    let mutable i = 2\n    let mutable cnt = 0\n    while (cnt < n) do\n        let nou = prev + (gcd prev i)\n        let d = nou - prev\n        if (d <> 1) then\n            res <- nou \/ i :: res\n            cnt <- cnt + 1\n        prev <- nou\n        i <- i + 1\n    res;\n\nlet anOverAverage(n: int): int =\n    let r = anOvern(n)\n    r.Sum() \/ r.Count()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84854,"user_id":null,"body":"let rec gcd (a: int) (b: int) =\n  if (b = 0) then\n    a\n  else\n    gcd b (a % b)\n\nlet an () =\n  Seq.initInfinite (fun x -> x + 1) |> Seq.scan (fun acc i -> acc + (gcd acc (i + 1))) 7\n\nlet gn () =\n    an() |> Seq.pairwise |> Seq.map (fun (pred, curr) -> curr - pred) |> Seq.append [1]\n\nlet countOnes(n: int) =\n    if (n <= 0) then\n        0\n    else\n        gn() |> Seq.take n |> Seq.filter (fun x -> x = 1) |> \n        Seq.length\n\nlet pn () =\n    gn() |> Seq.filter (fun x -> x <> 1) |>\n    Seq.distinct\n\nlet maxPn(n: int): int =\n    pn() |> Seq.take n |> Seq.max\n\nlet anOver () =\n    Seq.zip (an()) (gn()) |> Seq.mapi (fun i (a,g) -> ((float)a \/ (float)i, g)) |>\n    Seq.filter (fun (a,g) -> g <> 1) |> Seq.map (fun (a,g) -> a)\n\nlet anOverAverage(n: int): int =\n    anOver() |> Seq.take n |> Seq.average |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84855,"user_id":53,"body":"open System.Linq\n\nlet rec private gcd a b = if b = 0 then a else gcd b (a % b)\n\nlet private gn(n: int): int list =\n    let mutable p = 7\n    let mutable r: int list = [1]\n    for i = 2 to n do\n        let q = p + (gcd p i)\n        r <- (q - p) :: r\n        p <- q\n    r |> List.rev\n\nlet private pn(n: int): int list = \n    let mutable p = 7\n    let mutable i = 2\n    let mutable k = 0\n    let mutable r: int list = [1]\n    while (k < n) do\n        let q = p + (gcd p i)\n        let d = q - p\n        if d <> 1 && (List.exists (fun m -> m = d) r = false) then\n            r <- d :: r\n            k <- k + 1\n        p <- q\n        i <- i + 1\n    r\n  \nlet private anOvern(n: int): int list =\n    let mutable p = 7\n    let mutable i = 2\n    let mutable k = 0\n    let mutable r: int list = []\n    while (k < n) do\n        let q = p + (gcd p i)\n        let d = q - p\n        if (d <> 1) then\n            r <- q \/ i :: r\n            k <- k + 1\n        p <- q\n        i <- i + 1\n    r;\n\nlet countOnes(n: int): int =\n    gn(n).Count(fun m -> m = 1);\n    \nlet maxPn(n: int): int =\n    pn(n).Max()\n    \nlet anOverAverage(n: int): int =\n    let r = anOvern(n)\n    r.Sum() \/ r.Count()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84856,"user_id":null,"body":"let rec gcd ab =\n    match ab with\n    | 0,b -> b\n    | a,0 -> a\n    | a,b -> gcd (b,(a%b))    \n\nlet primeRecRelations =\n    Seq.unfold (fun (n,r) ->\n        match n with\n        | 1 -> Some(7, (n+1,7))\n        | _ ->\n            let r' = r + gcd(n,r)\n            Some(r', (n+1,r'))) (1,0)\n\nlet subtractions = seq {\n    yield 1\n    yield! primeRecRelations\n           |> Seq.pairwise\n           |> Seq.map (fun (a,b) -> b-a)\n}\n\nlet countOnes(n: int): int =\n    subtractions |> Seq.take n |> Seq.filter (fun e -> e=1) |> Seq.length\n\nlet maxPn(n: int): int =\n    subtractions |> Seq.filter (fun e -> e <> 1) |> Seq.distinct |> Seq.take n |> Seq.max\n\nlet anOverAverage(n: int): int =\n    Seq.zip3 (seq {1 .. n}) primeRecRelations subtractions\n    |> Seq.take n\n    |> Seq.filter (fun (_,_,s) -> s <> 1)\n    |> Seq.map (fun (i,p,_) -> float p\/(float i))\n    |> Seq.average\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84857,"user_id":null,"body":"let rec gcd a b = if b = 0 then a else gcd b (a % b)\n\nlet seqGen =\n    Seq.unfold\n        (fun x ->\n            let next = fst x + gcd ((snd x) + 1) (fst x)\n            Some(x, (next, (snd x) + 1)))\n        (7, 1)\n\nlet an n = seqGen |> Seq.map (fst) |> Seq.take n\n\nlet gGen =\n    let x = seqGen |> Seq.map (fst)\n\n    let y =\n        seq {\n            yield ((x |> Seq.head) - 1)\n            yield! (seqGen |> Seq.map (fst))\n        }\n\n    Seq.zip x y\n    |> Seq.map (fun x -> (fst x) - (snd x))\n\nlet g n = gGen |> Seq.take n\n\nlet countOnes n =\n    g n |> Seq.filter (fun x -> x = 1) |> Seq.length\n\nlet p n =\n    gGen\n    |> Seq.filter (fun x -> x <> 1)\n    |> Seq.distinct\n    |> Seq.take n\n\nlet maxPn n = p n |> Seq.max\n\nlet anOver n =\n    Seq.zip3 (an n) [ 1 .. n ] (g n)\n    |> Seq.filter (fun x ->\n        let (_, _, y) = x\n        y <> 1)\n    |> Seq.map (fun x ->\n        let (a, b, _) = x\n        (a |> float) \/ (b |> float))\n\nlet anOverAverage n =\n    let x = anOver n\n\n    ((x |> Seq.sum) \/ (x |> Seq.length |> float))\n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84858,"user_id":null,"body":"open System\n\nlet rec gcd x y =\n  match x, y with\n  |0, _ |_, 0-> x+y\n  |_ when x > y -> gcd (x%y) y\n  |_ -> gcd x (y%x)\n    \nlet an_gn_idx_inf =\n  (1, 6, 1) |> Seq.unfold (fun (a, b, idx) -> let gcd = gcd a b\n                                              Some((b+gcd, gcd, idx), (a+1, b+gcd, idx+1)))\n                                                                                                        \nlet an n = an_gn_idx_inf |> Seq.map (fun (a, g, idx) -> a)|> Seq.take n\nlet gn n = an_gn_idx_inf |> Seq.map (fun (a, g, idx) -> g)|> Seq.take n\n\nlet countOnes n =\n    gn n |> Seq.reduce (fun acc next -> match next with\n                                        |1 -> acc+1\n                                        |_ -> acc)\n                                        \nlet pn n = \n  seq {\n      let mutable already_returned = [1]\n      for (ai, gi, idx) in an_gn_idx_inf do\n          if gi <> 1 && not (List.contains gi already_returned) then\n              already_returned <- gi::already_returned\n              yield gi\n  } |> Seq.take n\n\nlet maxPn n = pn n |> Seq.max\n  \nlet anOver n = \n  seq {\n      for (ai, gi, idx) in an_gn_idx_inf do\n          if gi <> 1 then\n              yield ai\/idx\n  } |> Seq.take n\n  \nlet anOverAverage n = \n    let sum = anOver n |> Seq.sum\n    sum\/n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84859,"user_id":null,"body":"#nowarn \"40\"\nlet memoize f =\n    let cache = ref Map.empty\n    fun x ->\n        match (!cache).TryFind(x) with\n        | Some res -> res\n        | None ->\n             let res = f x\n             cache := (!cache).Add(x, res)\n             res\n\nlet rec gcd a b = if b = 0 then abs a else gcd b (a % b)\n\nlet rec a =\n    memoize <| function\n    | 1 -> 7\n    | n -> let a' = a (n - 1)\n           in a' + gcd n a'\n\nlet g = function\n    | 1 -> 1\n    | n -> a n - a (n - 1)\n\nlet gSeq = Seq.initInfinite ((+) 1 >> g)\n\nlet countOnes(n: int): int = gSeq |> Seq.take n |> Seq.filter ((=) 1) |> Seq.length\n\nlet p n = gSeq |> Seq.filter ((<>) 1) |> Seq.distinct |> Seq.take n\n\nlet maxPn n = p n |> Seq.max\n\nlet anOver n =\n    gSeq\n    |> Seq.mapi (fun i c -> (i, c))\n    |> Seq.filter (fun (_, n) -> n <> 1) \n    |> Seq.take n\n    |> Seq.map (fun (i, _) -> float (a i) \/ float i)\n\nlet anOverAverage(n: int): int = anOver n |> Seq.average |> round |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84860,"user_id":null,"body":"let rec gcd x y =\n    let x' = min x y\n    let y' = max x y\n\n    if x' = 0\n    then y'\n    else gcd x' (y'%x')\n\nlet an =\n    let rec unfolder (i, last) =\n        let next = last + (gcd i last)\n        \n        Some (last, (i+1, next))\n\n    (2, 7) |> Seq.unfold unfolder\n\nlet gn =\n    an\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> y-x)\n    |> fun x -> Seq.append [1] x\n\nlet countOnes(n: int): int =\n    gn |> Seq.take n |> Seq.filter (fun x -> x=1) |> Seq.length\n\nlet maxPn(n: int): int =\n    gn \n    |> Seq.except [1]\n    |> Seq.distinct\n    |> Seq.take n\n    |> Seq.max\n\n\/\/ 3\nlet anOverAverage(n: int): int =\n    gn\n    |> Seq.zip3 (Seq.initInfinite (fun x -> x+1)) an\n    |> Seq.filter (fun (_, _, g) -> g<>1)\n    |> Seq.map (fun (i, a, _) -> a\/i)\n    |> Seq.take n\n    |> Seq.sum\n    |> fun x -> x\/n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84861,"user_id":null,"body":"let rec gcd x y =\n    let x' = min x y\n    let y' = max x y\n\n    if x' = 0\n    then y'\n    else gcd x' (y'%x')\n\nlet an =\n    let rec unfolder (i, last) =\n        let next = last + (gcd i last)\n        \n        Some (last, (i+1, next))\n\n    (2, 7) |> Seq.unfold unfolder\n\nlet gn =\n    an\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> y-x)\n    |> fun x -> Seq.append [1] x\n\nlet countOnes(n: int): int =\n    gn |> Seq.take n |> Seq.filter (fun x -> x=1) |> Seq.length\n\nlet maxPn(n: int): int =\n    gn \n    |> Seq.except [1]\n    |> Seq.distinct\n    |> Seq.take n\n    |> Seq.max\n\nlet anOverAverage(n: int): int =\n    3","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84862,"user_id":null,"body":"let rec gcd x y = if y = 0 then x else gcd y (x % y)\nlet rec gcd' x y = if y = 0L then x else gcd' y (x % y)\n\nlet aseq =\n  let rec f (a:int64) (n:int64) = seq{\n    yield a\n    yield! f (a + (gcd' (n + 1L) (a * n))) (n + 1L)\n  }\n  f 7L 1L\n\nlet gseq = seq{\n  yield 1L\n  yield! aseq |> Seq.pairwise |> Seq.map(fun (x,y) -> y - x)\n}\n\nlet countOnes(n: int): int =\n  gseq |> Seq.take n |> Seq.filter(fun i -> i = 1L) |> Seq.length\n\nlet maxPn(n: int): int =\n  gseq |> Seq.filter(fun i -> i <> 1L) |> Seq.distinct |> Seq.take n |> Seq.max |> int\n    \nlet anOverAverage(n: int): int =\n  Seq.zip3 (Seq.initInfinite (fun i -> i + 1)) aseq gseq\n  |> Seq.filter (fun (i,x,y) -> y <> 1L)\n  |> Seq.map(fun (i,x,y)->((int x) \/ i))\n  |> Seq.take n\n  |> Seq.sum \n  |> fun s -> s \/ n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"562e274ceca15ca6e70000d3":[{"id":84863,"user_id":492,"body":"open System\n\nlet seglg (n: double) (k: double): double = \n    let a = ((k+1.0)\/n - k\/n) * ((k+1.0)\/n - k\/n)\n    let b = (((k+1.0)\/n)*((k+1.0)\/n) - (k\/n)*(k\/n))\n    sqrt (a + b * b)\nlet rec lenCurveAux (n: double) (k: double) (sm: double): double =\n    if (k = n) then sm\n    else lenCurveAux n (k + 1.0) (sm + (seglg n k))\nlet trunc9Dble d = double(int(d * 1e9)) * 1e-9\nlet lenCurve (n: int) = lenCurveAux (double(n)) 0.0 0.0 |> trunc9Dble","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84864,"user_id":492,"body":"open System\n\nlet seglg (n: double) (k: double): double = \n    let a = ((k+1.0)\/n - k\/n) * ((k+1.0)\/n - k\/n)\n    let b = (((k+1.0)\/n)*((k+1.0)\/n) - (k\/n)*(k\/n))\n    sqrt (a + b * b)\nlet rec lenCurveAux (n: double) (k: double) (sm: double): double =\n    if (k = n) then sm\n    else lenCurveAux n (k + 1.0) (sm + (seglg n k))\nlet trunc9Dble d = double(int(d * 1e9)) * 1e-9\nlet lenCurve (n: int) = lenCurveAux (double(n)) 0.0 0.0 |> trunc9Dble","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84865,"user_id":null,"body":"let lenCurve (n: int) = \n    let f (x: float) = x * x\n    let pyt (((x1:float),(y1:float)) , ((x2:float),(y2:float))) = \n        sqrt((x2-x1)**2.0 + (y2-y1)**2.0)\n    let interval = [for i in 0.0..float(n) ->  i * (1.0\/float(n)) ] \n                        |> List.map float\n                        |> List.map (fun x -> (x, (f x)))\n                        |> List.pairwise\n                        |> List.sumBy pyt\n    interval\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84866,"user_id":null,"body":"let lenCurve (n: int) = \n    let f x = x * x\n    let dist (xa, xb) =\n        sqrt ((pown ((f xa) - (f xb)) 2) + (pown (xb - xa) 2))\n\n    { 0 .. n }\n    |> Seq.map (fun x -> (float x) \/ (float n))\n    |> Seq.pairwise\n    |> Seq.map dist\n    |> Seq.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84867,"user_id":null,"body":"let lenCurve n =\n    let fn = float n\n    let rec loop sum = function\n        | 0 -> sum\n        | c ->\n            let h2 = pown ((2.0 * float c - 1.0) \/ fn) 2 + 1.0\n            let arc = sqrt h2 \/ fn\n            loop (sum + arc) (c - 1)\n    loop 0.0 n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84868,"user_id":null,"body":"let lenCurve (n: int) = \n    let f x = x * x\n    let dist (xa, xb) =\n        sqrt ((pown ((f xa) - (f xb)) 2) + (pown (xb - xa) 2))\n\n    { 0 .. n }\n    |> Seq.map (fun x -> (float x) \/ (float n))\n    |> Seq.pairwise\n    |> Seq.sumBy dist","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84869,"user_id":null,"body":"let lenCurve (n: int) = \n  let dist = (1. \/ (n |> double))\n  let rec getDist (len: float) (num: int) =\n    let deltax = dist\n    let deltay = 2. * len * dist + dist * dist\n    match num with\n    | 0 -> 0.\n    | _ -> sqrt(deltax * deltax + deltay * deltay) + (getDist (len + dist) (num - 1))\n  (getDist 0. n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84870,"user_id":null,"body":"let lenCurve (n: int) =\n    [for i in 0.0..float(n) ->  i * (1.0\/float(n)) ] \n    |> List.map (fun i -> (i, i ** 2.0))\n    |> List.pairwise\n    |> List.sumBy (fun ((x1, y1), (x2, y2)) -> (x2 - x1) ** 2.0 + (y2 - y1) ** 2.0 |> sqrt)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84871,"user_id":null,"body":"let lenCurve (n: int) = \n  let dx = 1.0\/double(n)\n  let points = \n    [0..n] |> List.map (fun x -> ((dx*double(x))**2.0))\n  \n  points\n  |> List.pairwise\n  |> List.map (fun x -> sqrt((dx**2.0) + (((snd x) - (fst x))**2.0)))\n  |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84872,"user_id":null,"body":"open System\n\nlet lenCurve (n: int) = \n    let h = 1.0 \/ (float n)\n    let square x = x * x\n    let h2 = square h\n    let append (acc, x) x' = (acc + Math.Sqrt (h2 + square ((square x') - (square x))), x')\n    seq {1..n} \n        |> Seq.map (float >> ((*) h))\n        |> Seq.fold append (0.0, 0.0)\n        |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"562f91ff6a8b77dfe900006e":[{"id":84873,"user_id":492,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n    let rec helper (i: int) (sb: float) (sa: int) (prev: float): int =\n        if (int(ceil sb) < sa) then\n            i\n        else\n            let nou = (float prev) * perc\n            helper (i + 1) (sb + nou) (sa + ticket) nou\n    helper 0 (float card) 0 (float ticket)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84874,"user_id":null,"body":"let movie card ticket rate =\n    let card' = float card\n    let ticket' = float ticket\n\n    let rec loop count totalA totalB =\n        if ceil (card' + totalB) < totalA\n        then count\n        else loop (count + 1) (totalA + ticket') ((totalB + ticket') * rate)\n\n    loop 0 0. 0.\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84875,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n    let systemA time =\n        ticket * time\n    let systemB time =\n        [for x in 1 .. time ->\n            (float ticket) * (perc ** (float x))]\n        |> List.sum \n        |> (+) (float card)\n    Seq.initInfinite (fun idx -> idx)\n    |> Seq.tail\n    |> Seq.find (fun t -> (int (ceil (systemB t))) < (systemA t))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84876,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n    let sysA x = float ticket * x\n    let sysB x = float (card - ticket) + float ticket * (1.0 - perc ** (x + 1.0)) \/ (1.0 - perc) \/\/ Using geometric series sum\n    Seq.initInfinite (fun idx -> float idx)\n    |> Seq.tail\n    |> Seq.find (fun n -> ceil (sysB n) < (sysA n))\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84877,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float) : int =\n    let rec help (count: int) (acc: float) : int = \n        let tic = ticket * count\n        let nextAcc = float ticket * (perc ** float count)\n        if ceil (float card + nextAcc + acc) < (float tic) then count\n        else help (count + 1) (acc + nextAcc) \n    help 1 0.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84878,"user_id":1492,"body":"open System\n\nlet movie (card: int) (ticket: int) (perc: float): int =\n    \n    let rec solve (counter: int) (a: double) (b: double) = \n\n        let newA = a + (double)ticket\n        let newB = b + ((double)ticket*Math.Pow(perc, (float)counter))\n\n        if (Math.Ceiling(newB) < newA) then counter\n        else solve (counter+1) newA newB \n    \n    solve 1 0.0 ((double)card)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84879,"user_id":168,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let rec loop s prev n =\n    let a = float (ticket * n)\n    let p = prev * perc\n    let b = s + p\n    if ceil b < a then n else loop b p (n + 1)\n  loop (float card) (float ticket) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84880,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n    let rec buy aSum bSum price count =\n        match ceil aSum < bSum with\n        | true -> count\n        | false -> buy (aSum + float price * perc) (bSum + float ticket) (price * perc) (count + 1)\n    buy (float card) 0. (float ticket) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84881,"user_id":null,"body":"open System\nlet rec movieHelper (cardSoFar:float) (ticketConst:int) (percConst:float) (noOfTickets:int) =\n    match Math.Ceiling(cardSoFar) < (float) (ticketConst * noOfTickets) with\n    |true -> noOfTickets\n    |false -> movieHelper (cardSoFar+((float) ticketConst) * Math.Pow(percConst,((float) noOfTickets))) ticketConst percConst (noOfTickets+1)\n\n\nlet movie (card: int) (ticket: int) (perc: float): int =\n    (movieHelper ((float) card) ticket perc 0) - 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84882,"user_id":null,"body":"let rec test (aggregate: float) (times: int) (threshold: int) (ticket: float) (percentage: float): int =\n  match aggregate with\n    | x when System.Math.Ceiling(x) < float (threshold * times) -> times\n    | _ -> test (aggregate + (ticket * percentage) * percentage) (times + 1) threshold (ticket * percentage) percentage \n\nlet movie (card: int) (ticket: int) (perc: float): int =\n  test ((float card) + (float ticket) * perc) 1 ticket (float ticket) perc ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56347fcfd086de8f11000014":[{"id":84883,"user_id":492,"body":"let private f(t: double) (y: double): double =\n    2.0 - exp(-4.0 * t) - 2.0 * y\n    \nlet private euler(t0: double) (y0: double) (t: double) (n: int): double[][] = \n    let h: double = t \/ (double)n\n    let (xtab : double array) = Array.zeroCreate (n + 1)\n    xtab.[0] <- t0\n    let (ytab : double array) = Array.zeroCreate (n + 1)\n    ytab.[0] <- y0\n    for x = 1 to n do\n        xtab.[x] <- (double)x * h\n    for x = 0 to n - 1 do\n        ytab.[x+1] <- ytab.[x] + h * (f xtab.[x] ytab.[x])\n    [|xtab; ytab|]\n    \nlet exEuler(nb: int): double =\n    let t0: double = 0.0\n    let y0: double = 1.0\n    let t: double = 1.0\n    let (ztab : double array) = Array.zeroCreate (nb + 1)\n    let e: double[][] = euler t0 y0 t nb\n    let xtab: double[] = e.[0]\n    let ytab: double[]  = e.[1]\n    let mutable s: double = 0.0\n    for k = 0 to nb do\n        ztab.[k] <- 1.0 + 0.5 * exp(-4.0 * xtab.[k]) - 0.5 * exp(-2.0 * xtab.[k])\n        s <- s + abs(ytab.[k] - ztab.[k]) \/ ztab.[k]\n    let res: double = s \/ ((double)nb + 1.0)\n    floor(res * 1e6) \/ 1e6","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84884,"user_id":1617,"body":"let exEuler (nb: int): double =\n    let h = 2.0 \/ double nb\n    \n    (Seq.scan (fun (py: double, pe: double) (n: double) ->\n        let e2 = exp (-n * h) \/ 2.0\n        let y = py + (1.0 - 2.0 * e2 * e2 \/ exp (-2.0 * h) - py) * h\n        (y, abs (1.0 - y \/ (1.0 + e2 * (2.0 * e2 - 1.0))))) (1.0, 0.0) [ 1.0 .. double nb ])\n    |> Seq.averageBy snd\n    |> fun n -> truncate (n * 1e6) \/ 1e6\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84885,"user_id":null,"body":"let exEuler n =\n    let step = 1. \/ (n |> float)\n\n    let round precision x =\n        let mult = 10. ** (precision |> float)\n        ((x * mult) |> truncate |> float) \/ mult\n\n    let zList =\n        Seq.unfold\n            (fun x ->\n                if fst x <= n then\n                    let newStep = fst x + 1\n                    let newX = (newStep |> float) * step\n                    let exp1 = (-4. * newX) |> exp\n                    let exp2 = (-2. * newX) |> exp\n                    let newVal = 1. + 0.5 * exp1 - 0.5 * exp2\n                    Some(x, (newStep, newVal))\n                else\n                    None)\n            (0, 1.)\n        |> Seq.map (snd)\n        |> Seq.toList\n\n    let yList =\n        Seq.unfold\n            (fun x ->\n                if fst x <= n then\n                    let newStep = fst x + 1\n                    let newX = (fst x |> float) * step\n                    let newY = snd x\n                    let exp1 = (-4. * newX) |> exp\n                    let partialFunction = 2. - exp1 - 2. * newY\n                    let newVal = snd x + step * partialFunction\n                    Some(x, (newStep, newVal))\n                else\n                    None)\n            (0, 1.)\n        |> Seq.map (snd)\n        |> Seq.toList\n\n    let err =\n        List.zip yList zList\n        |> List.map (fun x -> abs ((fst x) - (snd x)) \/ (snd x))\n\n    let sumErr = List.sum err\n    sumErr \/ ((n + 1) |> float) |> round 6\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84886,"user_id":null,"body":"let exEuler(nb: int): double = \n  printfn \"%d\" nb\n  let h = (1. \/ (nb |> float))\n  let f (x: float) (y: double) = 2. - exp(-4. * x) - 2. * y\n  let realF (x: double) = 1. + 0.5 * exp(-4. * x) - 0.5 * exp(-2. * x)\n  let sumODE = Seq.unfold (fun (a,b) -> Some((a,b), (a + h, b + (f a b) * h))) (0.,1.) |> Seq.take (nb + 1)\n  let realSumODE = Seq.unfold (fun (a,b) -> Some((a,b), (a + h, (realF (a + h))))) (0.,1.) |> Seq.take (nb + 1)\n  (Seq.zip sumODE realSumODE) |> Seq.sumBy (fun ((a,b),(c,d)) -> (abs (b - d) \/ (d |> double))) |> \n  (fun x -> System.Math.Truncate((x \/ ((nb + 1) |> double)) * 1000000.) \/ 1000000.)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84887,"user_id":722,"body":"open System\n\nlet d y t = 2. - Math.Exp(-4.*t) - 2.*y\n\nlet euler n T x0 y0 =\n    let h = T \/ float(n)\n    let xs = [0 .. (n-1)] |> List.map (fun x -> x0 + float(x) * h)\n    List.fold (fun acc x ->\n                    let y = List.head acc\n                    (y + (d y x)*h)::acc) [y0] xs\n\nlet act n T x0 =\n    let h = T \/ float(n)\n    [0 .. n] |> List.map ((fun x -> x0 + float(x) * h) >> (float >> fun x -> 1. + 0.5*Math.Exp(-4.*x) - 0.5*Math.Exp(-2.*x))) |> List.rev\n\nlet exEuler(n) =\n    let y = euler n 1. 0. 1.\n    let z = act n 1. 0.\n    let tot = List.zip y z |> List.sumBy (fun (a, b) -> abs(a - b) \/ b)\n    floor((tot \/ float(n + 1))*1e6) \/ 1e6\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84888,"user_id":null,"body":"let diffFunc (t : double) (y :double) = 2.0 - exp(-4.0*t) - 2.0*y\nlet func (t : double) = 1.0 + 0.5*exp(-4.0*t) - 0.5*exp(-2.0*t)\n\nlet exEuler (nb: int): double =\n  let mutable t =  0.0 ;\n  let h = 1.0 \/ float nb;\n  let mutable y = 1.0;\n  let mutable ytrue = 1.0;\n  let mutable grad = -1.0;\n  let mutable meanError = 0.0;\n  for i in 1 .. nb do\n    y <- y + h * grad;\n    t <- t + h;\n    grad <- diffFunc t y;\n    ytrue <- func t;\n    meanError <- meanError + abs(y - ytrue) \/ ytrue;\n  meanError <- meanError \/ float(nb + 1)\n  floor (meanError*1e6) \/ 1.0e6\n  \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5635e7cb49adc7b54500001c":[{"id":84889,"user_id":491,"body":"let solve n =\n    let rec solve' n acc =\n        match [500; 200; 100; 50; 20; 10] |> List.tryFind ((>=) n) with\n        | Some note -> solve' (n - note) (acc + 1)\n        | None -> if n = 0 then acc else -1\n    solve' n 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84890,"user_id":527,"body":"let values = [| 500; 200; 100; 50; 20; 10 |]\n\nlet solve n =\n  match Array.fold (fun (n, k) v -> n % v, k + n \/ v) (n, 0) values with\n  | 0, k -> k\n  | _    -> -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84891,"user_id":168,"body":"let solve n =\n  let r, n = List.fold (fun (r, n) k -> r + n \/ k, n % k) (0, n) [500; 200; 100; 50; 20; 10]\n  if n <> 0 then -1 else r\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84892,"user_id":null,"body":"let solve n =\n    if n % 10 <> 0 then -1\n    else [500; 200; 100; 50; 20; 10]\n         |> List.fold (fun (r, c) y -> (r % y, c + (r \/ y))) (n, 0) |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84893,"user_id":null,"body":"let solve n =\n    \/\/ fight me\n    let imperative x =\n        let mutable m = x\n        let mutable res = 0\n        \n        res <- res + m \/ 500\n        m <- m % 500\n        \n        res <- res + m \/ 200\n        m <- m % 200\n        \n        res <- res + m \/ 100\n        m <- m % 100\n        \n        res <- res + m \/ 50\n        m <- m % 50\n        \n        res <- res + m \/ 20\n        m <- m % 20\n        \n        res <- res + m \/ 10\n        m <- m % 10\n        \n        res\n    \n    match n with\n    | n when n % 10 <> 0 -> -1\n    | _ -> imperative n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84894,"user_id":null,"body":"let solve n =\n    let bn = [500;200;100;50;20;10]\n    in \n      let rec aux (n:int) (b:int list) (res:int)= \n        match(n,b) with\n          |(0,_) -> res\n          |(n,h::t) when n>=1 && n <=1500 -> aux (n%h) t (res+n\/h)\n          |_-> -1\n      in\n        aux n bn 0\n;;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84895,"user_id":null,"body":"let rec solveRec n curr =\n  let solveFor d v = solveRec (v % d) (curr + (v \/ d))\n  match n with\n  | n when n % 10 > 0 -> -1\n  | n when n >= 500 -> solveFor 500 n\n  | n when n >= 200 -> solveFor 200 n\n  | n when n >= 100 -> solveFor 100 n\n  | n when n >= 50 -> solveFor 50 n\n  | n when n >= 20 -> solveFor 20 n\n  | n when n >= 10 -> solveFor 10 n\n  | _ -> curr\n  \nlet solve n = solveRec n 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84896,"user_id":null,"body":"let rec solve num =\n    match num with\n    | n when n % 10 <> 0 -> -1\n    | n when n >= 500 -> 1 + solve (n - 500)\n    | n when n >= 200 -> 1 + solve (n - 200)\n    | n when n >= 100 -> 1 + solve (n - 100)\n    | n when n >= 50 -> 1 + solve (n - 50)\n    | n when n >= 20 -> 1 + solve (n - 20)\n    | n when n >= 10 -> 1 + solve (n - 10)\n    | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84897,"user_id":null,"body":"let solve n =\n  let rec loop n acc =\n    match n with\n    | _ when n = 0 -> acc\n    | _ when n < 10 -> -1\n    | _ when n >= 500 -> loop (n%500) (acc + n\/500)\n    | _ when n >= 200 -> loop (n%200) (acc + n\/200)\n    | _ when n >= 100 -> loop (n%100) (acc + n\/100)\n    | _ when n >= 50 -> loop (n%50) (acc + n\/50)\n    | _ when n >= 20 -> loop (n%20) (acc + n\/20)\n    | _ when n >= 10 -> loop (n%10) (acc + n\/10)\n  loop n 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84898,"user_id":null,"body":"let rec solve =\n    function\n    | n when n % 10 <> 0 -> -1\n    | n when n >= 500    -> 1 + solve (n - 500)\n    | n when n >= 200    -> 1 + solve (n - 200)\n    | n when n >= 100    -> 1 + solve (n - 100)\n    | n when n >= 50     -> 1 + solve (n - 50)\n    | n when n >= 20     -> 1 + solve (n - 20)\n    | n when n >= 10     -> 1 + solve (n - 10)\n    | _                  -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"563a631f7cbbc236cf0000c2":[{"id":84899,"user_id":53,"body":"let move pos roll = pos + 2 * roll","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84900,"user_id":null,"body":"let move pos roll = roll+roll+pos","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84901,"user_id":null,"body":"let move pos roll =\n  roll * 2 + pos\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84902,"user_id":527,"body":"let move = (>>) ((*) 2) << (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84903,"user_id":168,"body":"let move pos roll = (roll <<< 1) + pos","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84904,"user_id":null,"body":"let move pos = (+)pos << (*)2\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84905,"user_id":null,"body":"let move pos roll = roll * 2 + pos","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84906,"user_id":null,"body":"let move pos roll =\n    \/\/ your code here\n    (+) pos <| roll * 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84907,"user_id":null,"body":"let move pos roll = pos + 2 * roll\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84908,"user_id":null,"body":"let move pos roll = pos + (roll + roll)\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"563b662a59afc2b5120000c6":[{"id":84909,"user_id":492,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n    if (p0 >= p) then\n      0\n    else\n        (nb_year (int(float(p0) + float(p0) \/ 100.0 * percent + float(aug))) percent aug p) + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84910,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n    let r = percent \/ 100.\n\n    let rec f count p' =\n        if p' >= p\n        then count\n        else\n            let p'' = int (float p' * (1. + r)) + aug\n            f (count + 1) p''\n\n    f 0 p0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84911,"user_id":null,"body":"let nextP (n: float) (percent: float) (aug: int) = \n  (n + n * (percent \/ 100.0) + (float aug))\n  |> int\n\nlet rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  match p0 with\n  | n when n >= p -> 0\n  | n -> 1 + (nb_year (nextP (float n) percent aug) percent aug p)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84912,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n    if (p0 >= p) then\n        0\n    else\n        1 + nb_year (p0 + int(float(p0) \/ 100. * percent) + aug) percent aug p","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84913,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  if p0 >= p then 0\n  else 1 + nb_year (p0 + aug + int (float p0 * percent * 0.01)) percent aug p","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84914,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  let percent = decimal (1. + percent \/ 100.)\n  Seq.initInfinite id\n  |> Seq.scan(fun state _ -> int(decimal state * percent) + aug) p0\n  |> Seq.takeWhile (fun x -> x < p)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84915,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  Seq.unfold (fun x -> x + int (float x * percent \/ 100.0) + aug |> fun x -> Some (x,x)) p0\n  |> Seq.takeWhile ((>) p)\n  |> Seq.length\n  |> (+) 1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84916,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  let mutable retval = 0\n  if (p0 < p) then\n    retval <- 1 + nb_year (System.Convert.ToInt32(System.Math.Truncate((float p0)*(1.0+percent*0.01) + (float aug)))) percent aug p \n  retval\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84917,"user_id":878,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  if p0 >= p then 0\n  else\n    let newPop = int ((float p0) * (1.0 + (percent \/ 100.0)) + (float aug))\n    1 + (nb_year newPop percent aug p)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84918,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  Seq.unfold\n   (fun prev ->\n     let r = (percent \/ 100.0 + 1.0) * (float prev) + (float aug) |> floor |> int\n     Some (r, r)\n   )\n   p0\n  |> Seq.takeWhile (fun x -> x < p)\n  |> Seq.length\n  |> (+) 1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"563b74ddd19a3ad462000054":[{"id":84919,"user_id":1624,"body":"let rec stringy = function\n  | 0 -> \"\"\n  | 1 -> \"1\"\n  | n -> \"10\" + (stringy (n-2))\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84920,"user_id":null,"body":"let stringy size = \n    [1..size]\n    |> List.map (fun x -> string(x%2))\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84921,"user_id":null,"body":"let stringy size =\n    Seq.initInfinite (fun i -> if (i % 2) = 0 then '1' else '0')\n    |> Seq.take size\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84922,"user_id":884,"body":"let stringy size = \n  Array.zeroCreate size\n  |> Array.mapi (fun i _ -> if i % 2 = 0 then 1 else 0)\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84923,"user_id":53,"body":"let stringy size =\n    (String.replicate ((size+1)\/2) \"10\").[0..size-1]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84924,"user_id":null,"body":"let stringy x = String.init x (function | x when x%2=0 -> \"1\" | _ -> \"0\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84925,"user_id":null,"body":"let stringy size = \n    String.init size (fun i -> ((i+1) % 2).ToString())","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84926,"user_id":null,"body":"let digits = seq {\n    while true do\n        yield '1'\n        yield '0'\n}\n\nlet stringy size =\n    digits\n    |> Seq.take size\n    |> Seq.toArray\n    |> System.String\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84927,"user_id":null,"body":"let stringy size = new string [|for i in 1..size -> ['0'; '1'].[i%2]|]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84928,"user_id":null,"body":"let stringy size = [1..size] |> Seq.map (fun x -> if x % 2 = 0 then \"0\" else \"1\") |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"563f0c54a22b9345bf000053":[{"id":84929,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet fcn(n:int): BigInteger =\n    BigInteger.Pow(2I, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84930,"user_id":527,"body":"let fcn = (<<<) 1I","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84931,"user_id":null,"body":"let fcn = pown 2I\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84932,"user_id":null,"body":"let fcn = ( ** ) 2I","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84933,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet fcn(n:int): BigInteger =\n    BigInteger.Pow(2I, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84934,"user_id":527,"body":"let fcn = (<<<) System.Numerics.BigInteger.One","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84935,"user_id":null,"body":"let fcn(n:int):  System.Numerics.BigInteger =\n    let two = System.Numerics.BigInteger(2)\n    System.Numerics.BigInteger.Pow(two, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84936,"user_id":53,"body":"type BI = System.Numerics.BigInteger\n\nlet fcn(n:int): BI =\n    BI.Pow(bigint 2, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84937,"user_id":null,"body":"open System\nopen System.Numerics\n\nlet fcn n =\n    let ds =\n        let f (u, u') =\n            let u'' = 6.0 * u * u' \/ (5.0 * u - u')\n            Some (u, (u', u''))\n        Seq.unfold f (1.0, 2.0)\n    ds |> Seq.skip n |> Seq.head |> bigint\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84938,"user_id":168,"body":"let fcn(n:int): bigint = 1I <<< n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"564057bc348c7200bd0000ff":[{"id":84939,"user_id":null,"body":"let rec repeat items =\n  seq { yield! items; yield! (repeat items) }\n\nlet pattern =\n  repeat [1; 10; 9; 12; 3; 4]\n\nlet rdigitsof n =\n  n |> Seq.unfold (fun x -> if x = 0 then None else Some (x % 10, x \/ 10))\n  \nlet reduce13 x =\n  Seq.map2 (*) (rdigitsof x) pattern |> Seq.sum\n\nlet rec thirt (m:int) =\n  let mred = reduce13 m\n  if mred = m then m else thirt mred\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84940,"user_id":null,"body":"#nowarn \"40\"\nlet rec pat =\n    seq {\n        yield! [1;10;9;12;3;4]\n        yield! pat   \n    }\n\nlet rec thirt m =\n    let separator m =\n        Seq.unfold (function 0 -> None | n -> Some (n%10,n\/10)) m\n    let l = m |> separator |> Seq.map2 (*) pat |> Seq.sum\n    if l = m then\n        m\n    else\n        thirt l","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84941,"user_id":491,"body":"let rec thirt n =\n    let n' =\n        let key = Seq.initInfinite (fun i -> [1; 10; 9; 12; 3; 4].[i % 6])\n        let digits = string n |> Seq.map System.Char.GetNumericValue |> Seq.map int |> Seq.rev\n        Seq.zip key digits |> Seq.fold (fun a (k, d) -> a + k * d) 0\n    if n' = n then n' else thirt n'","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84942,"user_id":53,"body":"let rec thirt n =\n    let rec go(n, s, r, m) =\n        if m = 0 && s = n then s\n        else if m = 0 then go(s, 0, 1, s)\n        else go(n, s + r * (m % 10), (r * 10) % 13, m \/ 10)\n    go(n, 0, 1, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84943,"user_id":492,"body":"let rec thirt m =\n    let rec thirtaux(n, c, i) =\n        let w = [1; 10; 9; 12; 3; 4]\n        if (n = 0) then\n            c\n        else\n            thirtaux(int(n \/ 10), (c + (n % 10) * (w.[i % 6])), i + 1)\n    let c = thirtaux(m, 0, 0)\n    if (m = c) then\n        c\n    else\n        thirt(c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84944,"user_id":492,"body":"let rec thirt m =\n    let rec thirtaux(n, c, i) =\n        let w = [1; 10; 9; 12; 3; 4]\n        if (n = 0) then\n            c\n        else\n            thirtaux(int(n \/ 10), (c + (n % 10) * (w.[i % 6])), i + 1)\n    let c = thirtaux(m, 0, 0)\n    if (m = c) then\n        c\n    else\n        thirt(c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84945,"user_id":null,"body":"let pattern = [ 1; 10; 9; 12; 3; 4 ]\n\nlet explodeInt (n:int) =\n  [for c in (string n) -> (int c - int '0')]\n\nlet calculate i x = x * pattern.[i % List.length pattern]\n\nlet rec thirt m =\n  explodeInt m\n  |> (List.rev >> List.mapi calculate >> List.sum)\n  |> function\n  | x when x <> m -> thirt x\n  | _ -> m","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84946,"user_id":null,"body":"let rec thirt m =\n  let pattern = seq { while true do yield! [1; 10; 9; 12; 3; 4]}\n  \n  let digits = Seq.unfold (fun x -> if x = 0 then None else Some(x % 10, x \/ 10)) m\n  \n  let result = Seq.map2 (*) digits pattern |> Seq.sum\n    \n  if result = m then result else thirt result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84947,"user_id":null,"body":"let rec sum m i = \n  if m = 0 then 0\n  else (m%10)*i + sum (int((m-m%10)\/10)) ((i*10)%13) \n\nlet rec thirt m =\n  if m = sum m 1 then m\n  else thirt (sum m 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84948,"user_id":null,"body":"let isStationary first second = first = second\n\nlet calculateThirt m =\n  let calcDigit i (n: int): int =\n    let remainder = int(10.0 ** float(i)) % 13\n    n * remainder\n  m\n  |> string\n  |> Seq.rev\n  |> Seq.map (string >> int)\n  |> Seq.mapi calcDigit\n  |> Seq.sum\n\nlet rec thirt m =\n  let calculated = calculateThirt m\n  if isStationary m calculated then\n    m\n  else\n    thirt calculated\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56445c4755d0e45b8c00010a":[{"id":84949,"user_id":492,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n    let rec helper (prevx: int) (p: float) (prevc: int) (n: int) (infl: float) (k: int) =\n        if (k = n) then\n            prevx >= 0\n        else\n            let noux = (float prevx) + p \/ 100.0 * (float prevx) - (float prevc)\n            let nouc = (float prevc) + infl \/ 100.0 * (float prevc)\n            helper (int (floor noux)) p (int (floor nouc)) n infl (k + 1)\n    helper fortinit p peryear nbyear infl 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84950,"user_id":492,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n    let rec helper (prevx: int) (p: float) (prevc: int) (n: int) (infl: float) (k: int) =\n        if (k = n) then\n            prevx >= 0\n        else\n            let noux = (float prevx) + p \/ 100.0 * (float prevx) - (float prevc)\n            let nouc = (float prevc) + infl \/ 100.0 * (float prevc)\n            helper (int (floor noux)) p (int (floor nouc)) n infl (k + 1)\n    helper fortinit p peryear nbyear infl 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84951,"user_id":325,"body":"let rec fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float) =\n  match (fortinit, nbyear) with\n  | (f, n) when f > 0 && n > 1 ->\n    let fortuneN = (float fortinit) * ( 1.0 + p \/ 100.0 ) - (float peryear)\n    let peryearN = (float peryear) * ( 1.0 + infl \/ 100.0 )\n    fortune (int fortuneN) p (int peryearN) (nbyear - 1) infl\n  | (f, 1) when f >= 0 -> \n    true\n  | _ ->\n    false\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84952,"user_id":53,"body":"let rec aux (f0: float) (p: float) (c0: float) (n: float) (i: float): float =\n    if n = 1.0 then f0\n    else\n      let f1 = f0 + f0 * System.Math.Floor(p) \/ 100.0 - c0\n      let c1 = c0 + c0 * System.Math.Floor(i) \/ 100.0\n      let n1 = n - 1.0\n      aux f1 p c1 n1 i\n    \nlet fortune (f0: int) (p: float) (c0: int) (n: int) (i: float): bool =\n    let ans = aux (float f0) p (float c0) (float n) i\n    ans >= 0.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84953,"user_id":null,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float) =\n    let perP = p \/ 100.\n    let perI = infl \/ 100.\n    let rec getFort (f: float) (p: float) (c: float) (i: float) (year: int) =\n      let newf = floor (f + f * p - c)\n      let newc = floor (c + c * i)\n      match year with\n      | 1                -> true\n      | y when newf < 0. -> false\n      | _                -> (getFort newf p newc i (year - 1))\n    (getFort (fortinit |> float) perP (peryear |> float) perI nbyear)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84954,"user_id":null,"body":"let fortune (f0: int) (p: float) (c0: int) (nbyear: int) (inf: float) =\n    let mutable f = f0\n    let mutable c = c0\n    let mutable i = 1\n    \n    while i < nbyear && f > 0 do\n      f <- int(float(f) + (float(f) * (p\/100.0)) - float(c))\n      c <- int(float(c) + (float(c) * inf\/100.0))\n      i <- i + 1\n    \n    i = nbyear && f >= 0\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84955,"user_id":null,"body":"type YearOverview = { SavedMoney : int; ValueToSpend : int }\n\nlet calculate rate inflation overview = {\n    SavedMoney = overview.SavedMoney + (float overview.SavedMoney * rate |> int) - overview.ValueToSpend;\n    ValueToSpend = overview.ValueToSpend + (float overview.ValueToSpend * inflation |> int)\n}\n\nlet fortune (fortinit : int) (rate : float) (spendPerYear : int) (nbyear : int) (inflation : float) =\n    let calculate =  calculate (float rate \/ 100.0) (float inflation \/ 100.0)\n\n    let lastOverview = seq { 2..nbyear } |>\n                       Seq.fold\n                            (fun previousOverview year -> calculate previousOverview)\n                            { SavedMoney = fortinit; ValueToSpend = spendPerYear }\n\n    lastOverview.SavedMoney >= 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84956,"user_id":null,"body":"let rec fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float):bool =\n    if nbyear = 1 then fortinit  >= 0\n    else\n        let newfortu = int (floor (float fortinit + (float fortinit) * p\/100.0)) - peryear\n        let newpy = int (floor (float peryear + (infl * float peryear) \/ 100.0 ))\n        fortune newfortu p newpy (nbyear-1) infl","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84957,"user_id":null,"body":"let rec fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float) =\n    if nbyear <= 0 then\n      true\n    elif fortinit < 0 then\n      false\n    else\n      let f1 = (p\/100.0 + 1.0) * (float fortinit) - (float peryear) |> truncate |> int\n      let n2 = (float peryear)  * (1.0 + infl\/100.0) |> truncate |> int\n      fortune f1 p n2 (nbyear - 1) infl\n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84958,"user_id":null,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float) =\n    let rec fortunerec fortinit p peryear nbyear infl = \n        match nbyear,fortinit with\n        | (_,y) when y < 0 -> false\n        | (0,_) -> true\n        | _ -> fortunerec (fortinit+(int ((float fortinit)*p\/100.))-peryear) p (peryear+(int ((float peryear)*infl\/100.))) (nbyear-1) infl\n\n    fortunerec fortinit p peryear (nbyear-1) infl\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56484848ba95170a8000004d":[{"id":84959,"user_id":492,"body":"open System\n\nlet rec gps (s: int) (l: list<double>): int =\n    match l with\n    | [] -> 0\n    | _ :: [] -> 0\n    | a :: b :: x -> max (int((b - a) * 3600.0 \/ double(s))) (gps s (b :: x))\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84960,"user_id":null,"body":"let gps (s: int) = function\n  | [] | [_] -> 0\n  | l ->\n    l\n    |> Seq.pairwise\n    |> Seq.map (fun (curr, next) -> 3600. * (next - curr) \/  (float s))\n    |> Seq.max\n    |> floor\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84961,"user_id":null,"body":"let rec gps (s: int) (l: list<double>): int =\n  match l with\n  | []\n  | [_] -> 0\n  | _ ->\n    l\n      |> Seq.pairwise\n      |> Seq.map (fun (x, y) -> ((y - x) \/ double s) * 3600.0)\n      |> Seq.max\n      |> (int << floor)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84962,"user_id":null,"body":"let gps (s: int) (l: list<double>) =\n  match l with\n  | [] | [_] -> 0\n  | _ -> l\n         |> Seq.pairwise\n         |> Seq.map (fun (a,b) -> 3600. * (b-a) \/ double s)\n         |> Seq.max\n         |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84963,"user_id":null,"body":"let rec gps (s: int) (distances: list<double>) =\n    let hourlySpeed (a, b) = 3600. * (b - a) \/ float s\n    let distancesToHourlySpeeds = Seq.pairwise >> Seq.map hourlySpeed\n    let maxFloored = Seq.max >> floor >> int\n    let hasMoved = distances.Length > 0 && (List.max distances) > 1.\n    match hasMoved with\n    | true -> distances |> distancesToHourlySpeeds |> maxFloored\n    | false -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84964,"user_id":null,"body":"let rec gps (s: int) (l: list<double>) =\n  match l with\n  | [] | [_] -> 0\n  | _ -> l\n         |> List.pairwise\n         |> List.map (fun (x,y) -> (y - x) * 3600. \/ double s) \n         |> List.max |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84965,"user_id":491,"body":"let rec gps (s: int) (l: list<double>) =\n  if List.length l > 1 then\n    l\n    |> Seq.skip 1\n    |> Seq.zip l\n    |> Seq.map (fun (a, b) -> (b - a) * 3600. \/ float(s) |> int)\n    |> Seq.max\n  else\n    0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84966,"user_id":null,"body":"open System\n\nlet gps (s: int) (l: float list) =\n    let averageSpeed (delta:float) =\n        match delta, s with\n        | d, s when d <= 0. || s <= 0 -> 0.\n        | _, _ -> (3600. * delta) \/ (float s)\n    let rec getMaxSpeed (maxSpeed:float) (plsList: float list) =\n        match plsList with\n        | [_] | []   -> int maxSpeed\n        | prev::tail -> let next = List.head tail\n                        let delta = next - prev\n                        let avSpeed = averageSpeed delta\n                        let max = Math.Max(maxSpeed, avSpeed)\n                        getMaxSpeed max tail\n    getMaxSpeed 0. l","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84967,"user_id":null,"body":"let rec gps (s: int) (l: list<double>) =\n  if l.Length <= 1 then 0\n  else\n    (l.[..l.Length-2], l.[1..])\n    ||> List.map2 (fun x y -> (y-x)*60.0*60.0\/(s |> float))\n    |> List.max \n    |> System.Math.Floor \n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84968,"user_id":null,"body":"let rec gps (s: int) (l: list<double>) =\n  if l.Length <= 1 then\n    0\n  else\n    List.map2 (fun a b -> 3600.0*(b - a)\/float s) l.[..l.Length-2] l.[1..] |> List.max |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56541980fa08ab47a0000040":[{"id":84969,"user_id":null,"body":"let printer_error (s : string) =\n    let errors = s |> Seq.sumBy (fun c -> if c > 'm' then 1 else 0)\n    sprintf \"%d\/%d\" errors s.Length\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84970,"user_id":null,"body":"let printer_error(s: string) =\n   let n = s |> Seq.filter ((<) 'm') |> Seq.length\n   sprintf \"%d\/%d\" n (String.length s)\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84971,"user_id":492,"body":"open System\nopen System.Text.RegularExpressions\n\nlet printer_error(s: string) =\n    let rgx = new Regex(\"[a-m]\")\n    string(String.length(rgx.Replace(s, \"\"))) + \"\/\" + string(String.length s)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84972,"user_id":null,"body":"let printer_error(s: string) = (Seq.filter ((<) 'm') s |> Seq.length, s.Length) ||> sprintf \"%i\/%i\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84973,"user_id":null,"body":"let printer_error (s: string) =\n    let bad (s: string) =\n        s.ToLower()\n        |> String.filter (fun c -> c > 'm')\n        |> Seq.length\n\n    System.String.Format(\"{0}\/{1}\", bad s, s.Length)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84974,"user_id":null,"body":"open System\nopen System.Linq\n\nlet printer_error (s : string) =\n    let errors = s.Count(Func<char, bool>(fun c -> c > 'm'))\n    sprintf \"%d\/%d\" errors s.Length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84975,"user_id":null,"body":"let printer_error(s: string) = sprintf \"%d\/%d\" (String.filter (fun x -> x > 'm') s |> String.length) (String.length s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84976,"user_id":492,"body":"open System\nopen System.Text.RegularExpressions\n\nlet printer_error(s: string) =\n    let rgx = new Regex(\"[a-m]\")\n    string(String.length(rgx.Replace(s, \"\"))) + \"\/\" + string(String.length s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84977,"user_id":null,"body":"let printer_error(s: string) =\n    let errCount =\n        s\n        |> Seq.map (fun c ->\n                        match c with\n                        | c when not (List.contains c ['a'..'m']) -> 1\n                        | _ -> 0)\n        |> Seq.sum\n    sprintf \"%d\/%d\" errCount (String.length s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84978,"user_id":null,"body":"let printer_error(s: string) = \n  let len = s.Length;\n  let errors = Seq.filter (fun l-> l > 'm') s |> Seq.length \n  [errors.ToString(); \"\/\"; len.ToString()] |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5656b6906de340bd1b0000ac":[{"id":84979,"user_id":null,"body":"open System\n\nlet longest (s1: string) (s2: string) =\n  s1+s2\n  |> Seq.distinct\n  |> Seq.sort\n  |> String.Concat","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84980,"user_id":null,"body":"open System.Linq\n\nlet longest (s1: string) (s2: string) = s1 + s2 |> Seq.distinct |> Seq.sort |> System.String.Concat","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84981,"user_id":null,"body":"let longest str1 str2 =\n    let a = int 'a'\n    let az = Array.zeroCreate (int 'z' - a) \n    [str1; str2]\n        |> List.iter (String.iter (fun p -> Array.set az (int p - a) true))\n    Seq.zip ['a'..'z'] az\n        |> Seq.filter snd\n        |> Seq.map fst\n        |> Array.ofSeq\n        |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84982,"user_id":1363,"body":"let longest (s1: string) (s2: string) = \n  (s1 + s2) |> String.filter System.Char.IsLetter |> Seq.distinct |> Seq.sort |> Seq.map (fun c -> c.ToString()) |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84983,"user_id":492,"body":"open System.Linq\n\nlet longest (s1: string) (s2: string) =\n    let s = s1 + s2\n    System.String.Concat(s.Distinct().OrderBy(fun x -> x) |> Seq.toList)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84984,"user_id":492,"body":"open System.Linq\n\nlet longest (s1: string) (s2: string) =\n    let s = s1 + s2\n    System.String.Concat(s.Distinct().OrderBy(fun x -> x) |> Seq.toList)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84985,"user_id":null,"body":"open System\n\nlet longest (s1 : string) (s2 : string) = \n    (s1 + s2).ToCharArray()\n    |> Set\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84986,"user_id":null,"body":"open System.Linq\n\nlet longest (s1: string) (s2: string) =\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let check (a: string) (b: string) (sym:char) =\n        (a.Contains sym) || (b.Contains sym)\n    alphabet |> String.filter (check s1 s2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84987,"user_id":535,"body":"let longest (s1: string) (s2: string) = s1 + s2 |> set |> Set.toSeq |> Seq.map string |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84988,"user_id":null,"body":"open System.Linq\nopen System\n\nlet longest (s1: string) (s2: string) =\n  Array.concat [s1.ToCharArray() ; s2.ToCharArray()]\n  |> Set.ofArray\n  |> Seq.sort\n  |> Seq.fold (fun acc c -> acc + string c) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"565abd876ed46506d600000d":[{"id":84989,"user_id":492,"body":"open System\n\nlet simpson (n: int) =\n    let f (x: double) = 3.0 * (sin x) * (sin x) * (sin x) \/ 2.0\n    let sm1 (n: int) (h: double) = seq { for i in 1 .. 2 .. n - 1 do yield (f (double(i) * h)) } |> Seq.sum\n    let sm2 (n: int) (h: double) = seq { for i in 2 .. 2 .. n     do yield (f (double(i) * h)) } |> Seq.sum\n    let h = Math.PI \/ double(n)\n    h * (4.0 * (sm1 n h) + 2.0 * (sm2 n h)) \/ 3.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84990,"user_id":null,"body":"let simpson (n: int) = \n    let a = 0.0\n    let b = System.Math.PI\n    let h = (b-a) \/ float(n)\n    let f x = (3.0\/2.0 * float(sin(x)**3.0))\n    ((b-a) \/ (3.0 * float(n))) * \n        (f(a) \n        + f(b) \n        + 4.0 * ([1..n\/2] |> List.sumBy (fun i -> f(a + (2.0*float(i) - 1.0) * h))) \n        + 2.0 * ([1..(n\/2)-1] |> List.sumBy (fun i -> f(a + 2.0*float(i) * h))))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84991,"user_id":null,"body":"let simpson (n: int) =\n  let f x = 3.0 \/ 2.0 * sin(x)**3.0\n  let a = 0.0\n  let b = System.Math.PI\n  let h = (b - a) \/ float n\n  \n  (b - a) \/ (3.0 * float n) *\n  (\n    f a + f b \n    + 4.0 * ({1..n\/2} |> Seq.map (fun i -> f(a + (2.0 * float i - 1.0) * h)) |> Seq.sum)\n    + 2.0 * ({1..n\/2-1} |> Seq.map (fun i -> f(a + 2.0 * float i * h)) |> Seq.sum)\n  )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84992,"user_id":null,"body":"let fn (x:float) =\n  1.5 * System.Math.Pow(System.Math.Sin(x), 3.0)\n\nlet calcSum fn v1 v2 =\n    List.sumBy fn [ v1 .. v2 ]\n    \n\nlet simpson (n: int) =\n    let a = 0.0\n    let b = System.Math.PI\n    let h = (b-a)\/(float n)\n    let f1 x = fn (a + (float (2*x - 1))*h)\n    let f2 x = fn (a + 2.0*(float x)*h)\n    ((fn a) + (fn b) + 4.0*(calcSum f1 1 (n\/2)) + 2.0*(calcSum f2 1 (n\/2-1)))*h\/3.0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84993,"user_id":null,"body":"let simpson (n: int) = \n      printf \"%A\n\" n\n      let a = 0.0\n      let b = System.Math.PI\n      let h = (b-a) \/ float(n)\n      let f x = (3.0\/2.0 * float(sin(x)**3.0))\n      ((b-a) \/ (3.0 * float(n))) * \n          (f(a) \n          + f(b) \n          + 4.0 * ([1..n\/2] |> List.sumBy (fun i -> f(a + (2.0*float(i) - 1.0) * h))) \n          + 2.0 * ([1..(n\/2)-1] |> List.sumBy (fun i -> f(a + 2.0*float(i) * h))))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84994,"user_id":492,"body":"open System\n\nlet simpson (n: int) =\n    let f (x: double) = 3.0 * (sin x) * (sin x) * (sin x) \/ 2.0\n    let sm1 (n: int) (h: double) = seq { for i in 1 .. 2 .. n - 1 do yield (f (double(i) * h)) } |> Seq.sum\n    let sm2 (n: int) (h: double) = seq { for i in 2 .. 2 .. n     do yield (f (double(i) * h)) } |> Seq.sum\n    let h = Math.PI \/ double(n)\n    h * (4.0 * (sm1 n h) + 2.0 * (sm2 n h)) \/ 3.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84995,"user_id":53,"body":"open System\n\nlet simpson (n: int) =\n  let f (x: double) = 1.5 * (sin x) * (sin x) * (sin x)\n  let m (n: int) = seq { for i in 1 .. n - 1 do yield ((2.0 + double(i % 2) * 2.0) * f((Math.PI \/ double(n)) * double(i))) } |> Seq.sum\n  (m n) * (Math.PI \/ 3.0) \/ double(n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84996,"user_id":168,"body":"open System\n\nlet simpson (n: int) =\n  let f x = 1.5 * sin x ** 3.0\n  let h = Math.PI \/ float n\n  seq { for i in 1 .. n \/ 2 - 1 ->\n        4.0 * f (float (2 * i - 1) * h) + 2.0 * f (float (2 * i) * h) }\n  |> Seq.sum\n  |> fun s -> (s + 4.0 * f (float (n - 1) * h)) * Math.PI \/ float (3 * n)\n  \n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84997,"user_id":null,"body":"let simpson (n: int) =\n  let a = 0.\n  let b = System.Math.PI\n  let h = (b - a) \/ (n |> float)\n  \n  let f (x: float) = 1.5 * (sin x) ** 3.\n  \n  let mult = (b - a) \/ (3. * (n |> float))\n  \n  let first = [(1.)..(float)(n \/ 2)] |> \n              List.map (fun i -> a + (2.*i - 1.) * h) |> \n              List.map f |> List.sum |> (fun x -> x * 4.)\n              \n  let second = [(1.)..((float)(n \/ 2) - 1.)] |> \n               List.map (fun i -> a + 2. * i * h) |> \n               List.map f |> List.sum |> (fun x -> x * 2.)\n              \n  mult * ((f a) + (f b) + first + second)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":84998,"user_id":null,"body":"open System\n\nlet simpson' (f:double -> double) (a:double) (b:double) (n: int) =\n    let n' = double n\n    let h = (b - a) \/ n'\n    let s' = seq {1..n \/ 2} |> Seq.sumBy (fun i -> f (a + ((double (2 * i - 1)) * h)))\n    let s'' = seq {1..(n \/ 2) - 1} |> Seq.sumBy (fun i -> f (a + (double (2 * i)) * h))\n    (b - a) \/ (3.0 * n') * ((f a) + (f b) + 4.0 * s' + 2.0 * s'')\n\nlet simpson (n: int) =\n  let f x = 1.5 * Math.Pow(Math.Sin x, 3.0)\n  simpson' f 0.0 Math.PI n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"565c0fa6e3a7d39dee000125":[{"id":84999,"user_id":null,"body":"let gravitationalAcceleration = 9.81\n\nlet toMetersPerSec vInKmPerHour = vInKmPerHour * 1000. \/ 3600.\n\nlet toKmPerHour vInMetersPerSec = vInMetersPerSec \/ 1000. * 3600.\n\nlet muFactor mu = 2. * mu * gravitationalAcceleration\n\nlet dist(vInKmPerHour: double, mu: double): double =\n    let v = vInKmPerHour |> toMetersPerSec\n    let c = muFactor mu\n    let reactionDistance = v;\n    let breakingDistance = v * v \/ c\n    reactionDistance + breakingDistance\n\nlet speed(d: double, mu: double): double =\n    let c = muFactor mu\n    let sInMetersPerSecond = sqrt (c * d + 0.25 * c * c) - 0.5 * c\n    sInMetersPerSecond |> toKmPerHour\n  \n\/\/ I could not express the speed function as cleanly as the dist function.\n\/\/ To get to the speed function, I applied some algebra. Given the formula\n\/\/ that was produced for computing the breaking distance:\n\/\/\n\/\/         v*v\n\/\/ d = v + ---   \n\/\/          c\n\/\/\n\/\/ the inverse function was derived as follows:\n\/\/\n\/\/ c*d = c*v + v*v\n\/\/\n\/\/ c*d = v*v + c*v + (c\/2)*(c\/2) - (c\/2)*(c\/2)\n\/\/\n\/\/               2\n\/\/ c*d = (v + c\/2) - (c\/2)*(c\/2)\n\/\/\n\/\/          2\n\/\/ (v + c\/2)  = c*d + (c\/2)*(c\/2)\n\/\/\n\/\/            ,-----------------.\n\/\/ v + c\/2 = V c*d + (c\/2)*(c\/2)\n\/\/\n\/\/      ,-----------------.\n\/\/ v = V c*d + (c\/2)*(c\/2) - c\/2\n\/\/","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85000,"user_id":492,"body":"open System\n\nlet dist(v: double, mu: double): double =\n    let g: double  = 9.81                                  \/\/ acceleration due to gravity in m\/s\n    let coef: double = 1000.0 \/ 3600.0                     \/\/ km\/h -> m\/s\n    let dreact: double = v * coef                          \/\/ distance of reaction with t = 1\n    let vms: double = coef * v                             \/\/ speed in m\/s\n    let dbrak: double = 0.5 * Math.Pow(vms, 2.0) \/ mu \/ g  \/\/ braking distance\n    dreact + dbrak \nlet speed(d: double, mu: double): double =\n    let g: double  = 9.81                                  \/\/ acceleration due to gravity in m\/s\n    let coef: double = 3600.0 \/ 1000.0                     \/\/ km\/h -> m\/s\n    0.5 * mu * g * (- 2.0 + Math.Sqrt(4.0 + 8.0 * d\/mu\/g)) * coef","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85001,"user_id":492,"body":"open System\n\nlet dist(v: double, mu: double): double =\n    let g: double  = 9.81                                  \/\/ acceleration due to gravity in m\/s\n    let coef: double = 1000.0 \/ 3600.0                     \/\/ km\/h -> m\/s\n    let dreact: double = v * coef                          \/\/ distance of reaction with t = 1\n    let vms: double = coef * v                             \/\/ speed in m\/s\n    let dbrak: double = 0.5 * Math.Pow(vms, 2.0) \/ mu \/ g  \/\/ braking distance\n    dreact + dbrak \nlet speed(d: double, mu: double): double =\n    let g: double  = 9.81                                  \/\/ acceleration due to gravity in m\/s\n    let coef: double = 3600.0 \/ 1000.0                     \/\/ km\/h -> m\/s\n    0.5 * mu * g * (- 2.0 + Math.Sqrt(4.0 + 8.0 * d\/mu\/g)) * coef","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85002,"user_id":null,"body":"let dist(v: double, mu: double): double =\n    (v * v) \/ (mu * 2. * 9.81 * 3.6 * 3.6) + (v \/ 3.6)\n    \nlet speed(d: double, mu: double): double =\n    let Fm = 2. * mu * 9.81\n    let D = Fm * Fm + 4. * Fm * d\n    let fv = (- Fm + sqrt(D)) \/ 2.\n    fv * 3.6","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85003,"user_id":null,"body":"let dist(v0: double, mu: double): double =\n  let v = v0 \/ 3.6\n  ((v**2.0) \/ (2.0*mu*9.81)) + v\n    \nlet speed(d: double, mu: double): double =\n  (9.81*mu*(((sqrt(2.0*d + 9.81*mu))\/(sqrt(9.81)*sqrt(mu))) - 1.0)) * 3.6\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85004,"user_id":null,"body":"open System\n\nlet g = 9.81\nlet time = 1.0\nlet dist(v: double, mu: double): double =\n    let v0 = v \/ 3.6\n    v0 * time + v0**2.0 \/ (2.0 * mu * g)\nlet speed(d: double, mu: double): double =\n    let a = 1.0\/(2.0 * mu * g)\n    let b = time\n    let c = -d\n    (-b + sqrt(b**2.0 - 4.0*a*c)) \/ (2.0*a) |> ( *) 3.6","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85005,"user_id":null,"body":"open System\n\nlet dist(v: double, mu: double): double =\n    let ms = v \/ 3.6\n\n    ms + (ms**2.0) \/ (2.0 * mu * 9.81)\n    \nlet speed(d: double, mu: double): double =\n    let part = ((200.0 * d) + (981.0 * mu)) ** 0.5\n\n    let result = (327.0 \/ 100.0) * ((mu**0.5 * part)\/(109.0**0.5) - 3.0 * mu)\n\n    result * 3.6","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85006,"user_id":null,"body":"open System\nlet dist(v: double, mu: double): double =\n    let v2 = v \/ 3.6 \/\/ m\/s * 3600 \/ 1000 \n    let bd = v2 * v2 \/ (2.0 * mu * 9.81)\n    bd + v2\n    \/\/ dist = v2 ( v2 \/(2mg) + 1) \n    \nlet speed(d: double, mu: double): double =\n    \/\/ v2^2 + v2*2mg - 2mgd = 0\n    \/\/ (v2 + mg)^2 - m^2g^2 - 2mgd\n    \/\/ (v2 + mg)^2 = mg(mg + 2d)\n    let v2 = -mu*9.81 + sqrt (mu * 9.81 * (mu*9.81 + 2.0*d))\n    v2 * 3.6\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85007,"user_id":null,"body":"open System\n\nlet v g mu d= sqrt(d*(2.0*mu*g) + (pown (mu*g) 2)) - mu*g\nlet d1 g v mu = v*v\/(2.0*mu*g)\nlet G = 9.81\nlet dist(v: double, mu: double): double =\n    let vmps = v\/3.6\n    vmps + d1 G vmps mu\n    \/\/ your code\nlet speed(d: double, mu: double): double =\n    3.6 * v G mu d\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85008,"user_id":null,"body":"let dist(v: double, mu: double): double = \n  let v = v\/3.6\n  v*(v\/2.\/(9.81*mu)+1.)\n\nlet speed(d: double, mu: double): double = \n  let a = 9.81*mu  \n  3.6*(sqrt(a*(2.*d+a))-a) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5663f5305102699bad000056":[{"id":85009,"user_id":null,"body":"let mxdiflg(a1: string[]) (a2: string[]): int Option = \n  match (a1, a2) with\n  | (_,_) when a1.Length < 1 -> None\n  | (_,_) when a2.Length < 1 -> None\n  | (_,_) -> seq {\n                for x in a1 do\n                  for y in a2 do\n                    yield (abs(x.Length - y.Length))\n             } |> Seq.max |> Some","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85010,"user_id":492,"body":"let mxdiflg(a1: string[]) (a2: string[]): int Option =\n    if a1.Length = 0 || a2.Length = 0 then \n        None \/\/-1\n    else \n        let l1 = a1 |> Array.map(fun p -> p.Length)\n        let l2 = a2 |> Array.map(fun p -> p.Length)\n        Some (max (abs((l1 |> Array.max) - (l2 |> Array.min))) (abs((l2 |> Array.max) - (l1 |> Array.min))))\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85011,"user_id":null,"body":"let mxdiflg(a1: string array) (a2: string array): int Option =\n  match a1, a2 with\n  | [||], _ -> None\n  | _, [||] -> None \n  | _, _ -> Some ([for x in a1 do\n                   for y in a2 -> abs(x.Length - y.Length)] \n                   |> List.max)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85012,"user_id":null,"body":"open System\n\nlet mxdiflg a1 a2 =\n  if Array.isEmpty a1 || Array.isEmpty a2 then\n    None\n  else\n    let findMinMax =\n      Array.fold\n        ( fun (n, x) v ->\n            let l =\n              String.length v\n\n            (min n l, max x l) )\n        (Int32.MaxValue, Int32.MinValue)\n\n    let (min1, max1) =\n      findMinMax a1\n\n    let (min2, max2) =\n      findMinMax a2\n\n    max (max1 - min2) (max2 - min1)\n    |> Some","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85013,"user_id":null,"body":"let diffs bs cs =\n  [ for b in bs do\n    for c in cs do\n      yield ((String.length b) - (String.length c) |> abs) ]\n\nlet mxdiflg bs cs =\n  match diffs bs cs with\n  | [] -> None\n  | ds -> Some (List.max ds)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85014,"user_id":null,"body":"let mxdiflg (a1: string[]) (a2: string[]): int Option =\n    if a1.Length = 0 then None\n    elif a2.Length = 0 then None\n    else\n        let s1 = a1 :> seq<string> |> Seq.map (fun n -> n.Length)\n        let s2 = a2 :> seq<string> |> Seq.map (fun n -> n.Length)\n        let min1 = s1 |> Seq.min\n        let max1 = s1 |> Seq.max\n        let min2 = s2 |> Seq.min\n        let max2 = s2 |> Seq.max\n        max (max2-min1) (max1-min2) |> Some","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85015,"user_id":null,"body":"let mxdiflg(a1: string[]) (a2: string[]): int Option = \n    match a1, a2 with\n    | [||], _ -> None\n    | _, [||] -> None\n    | x, y -> \n        let minMax (a: string[]) = a \n                                    |> Array.map (fun s -> s.Length) \n                                    |> fun a -> Array.min a, Array.max a\n\n        let min1, max1 = minMax a1\n        let min2, max2 = minMax a2\n        let d1 = abs(max2 - min1)\n        let d2 = abs(max1 - min2)\n        Some (max d1 d2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85016,"user_id":null,"body":"let mxdiflg (a1: string []) (a2: string []) : int Option =\n    if Array.length a1 = 0 || Array.length a2 = 0 then\n        None\n    else\n        let fltFun (sl: string []) : int [] =\n            sl |> Array.map (fun x -> String.length x)\n\n        Some(\n            Array.max [| (abs ((Array.max (fltFun a1)) - (Array.min (fltFun a2))))\n                         (abs ((Array.min (fltFun a1)) - (Array.max (fltFun a2)))) |]\n        )\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85017,"user_id":null,"body":"let mxdiflg(a1: string[]) (a2: string[]): int Option = \n  match a1, a2 with\n  | [||], _ | _, [||] -> None\n  | _ -> let a1m = a1 |> Array.map String.length\n         let a2m = a2 |> Array.map String.length\n         Some (max ((a1m |> Array.max) - (a2m |> Array.min))\n                   ((a2m |> Array.max) - (a1m |> Array.min)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85018,"user_id":null,"body":"let mxdiflg(a1: string[]) (a2: string[]): int Option = \n  match a1, a2 with\n  | [||], _ | _, [||] -> None\n  | _ -> let a1m = a1 |> Array.map String.length\n         let a2m = a2 |> Array.map String.length\n         Some (System.Math.Max ((a1m |> Array.max) - (a2m |> Array.min), (a2m |> Array.max) - (a1m |> Array.min)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"566543703c72200f0b0000c9":[{"id":85019,"user_id":492,"body":"let rec epidemicAux (n: int) (dt: double) (prevS: double) (prevI: double) (prevR: double) (b: double) (a: double) (k: int) (mx: double) =\n    if (k = n) then int(floor mx)\n    else begin\n        let pS = prevS - dt * b * prevS * prevI\n        let pI = (prevI + dt * (b * prevS * prevI - a * prevI))\n        let pR = prevR + dt * prevI * a\n        let m = if pI > mx then pI else mx\n        epidemicAux n dt pS pI pR b a (k + 1) m\n    end\nlet epidemic tm n s0 i0 b a = epidemicAux n (double(tm) \/ double(n)) s0 i0 0.0 b a 0 (-1.0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85020,"user_id":492,"body":"let rec epidemicAux (n: int) (dt: double) (prevS: double) (prevI: double) (prevR: double) (b: double) (a: double) (k: int) (mx: double) =\n    if (k = n) then int(floor mx)\n    else begin\n        let pS = prevS - dt * b * prevS * prevI\n        let pI = (prevI + dt * (b * prevS * prevI - a * prevI))\n        let pR = prevR + dt * prevI * a\n        let m = if pI > mx then pI else mx\n        epidemicAux n dt pS pI pR b a (k + 1) m\n    end\nlet epidemic tm n s0 i0 b a = epidemicAux n (double(tm) \/ double(n)) s0 i0 0.0 b a 0 (-1.0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85021,"user_id":null,"body":"let epidemic\n    studyPeriodInDays\n    interval\n    susceptibleInitial\n    infectedInitial\n    diseaseSpreadingContactsConstant\n    recoverFractionConstant\n    =\n\n    let constantInterval = (float studyPeriodInDays \/ float interval)\n\n    let calculateSusceptible suscepPrev infectedPrev =\n        suscepPrev\n        * (1.\n           - constantInterval\n             * diseaseSpreadingContactsConstant\n             * infectedPrev)\n\n    let calculateInfected infectedPrev suscepPrev =\n        infectedPrev\n        * (1.\n           + constantInterval\n             * (diseaseSpreadingContactsConstant * suscepPrev\n                - recoverFractionConstant))\n\n    (susceptibleInitial, infectedInitial)\n    |> Seq.unfold (\n        fun (suscepLast, infectedLast) ->\n          let infCurrent = calculateInfected infectedLast suscepLast\n\n          if infCurrent < infectedLast then\n              None\n          else\n              let susCurrent = calculateSusceptible suscepLast infectedLast\n              Some(infCurrent, (susCurrent, infCurrent)))\n    |> Seq.last\n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85022,"user_id":null,"body":"let epidemic\n    studyPeriodInDays\n    interval\n    susceptibleInitial\n    infectedInitial\n    diseaseSpreadingContactsConstant\n    recoverFractionConstant\n    =\n\n    let constantInterval = (float studyPeriodInDays \/ float interval)\n\n    let calculateSusceptible suscepPrev infectedPrev =\n        suscepPrev\n        * (1.\n           - constantInterval\n             * diseaseSpreadingContactsConstant\n             * infectedPrev)\n\n    let calculateInfected infectedPrev suscepPrev =\n        infectedPrev\n        * (1.\n           + constantInterval\n             * (diseaseSpreadingContactsConstant * suscepPrev\n                - recoverFractionConstant))\n\n    let calculateRecovered recovrdPrev infectedPrev =\n        recovrdPrev\n        + constantInterval\n          * infectedPrev\n          * recoverFractionConstant\n\n    (susceptibleInitial, infectedInitial, 0.)\n    |> Seq.unfold (fun (suscepLast, infectedLast, recoveredLast) ->\n        let infCurrent = calculateInfected infectedLast suscepLast\n\n        if infCurrent < infectedLast then\n            None\n        else\n            let susCurrent = calculateSusceptible suscepLast infectedLast\n            let recvrdCurrent = calculateRecovered recoveredLast infectedLast\n            Some(infCurrent, (susCurrent, infCurrent, recvrdCurrent)))\n    |> Seq.last\n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85023,"user_id":null,"body":"let epidemic\n    studyPeriodInDays\n    interval\n    susceptibleInitial\n    infectedInitial\n    diseaseContactSpreadingConstant\n    fractionThatWillRecoverConstant\n    =\n\n    let constantInterval = (float studyPeriodInDays \/ float interval)\n\n    let calculateSusceptible suscepPrev infectedPrev =\n        suscepPrev\n        * (1.\n           - constantInterval\n             * diseaseContactSpreadingConstant\n             * infectedPrev)\n\n    let calculateInfected infectedPrev suscepPrev =\n        infectedPrev\n        * (1.\n           + constantInterval\n             * (diseaseContactSpreadingConstant * suscepPrev\n                - fractionThatWillRecoverConstant))\n\n    let calculateRecovered recovrdPrev infectedPrev =\n        recovrdPrev\n        + constantInterval\n          * infectedPrev\n          * fractionThatWillRecoverConstant\n\n    (susceptibleInitial, infectedInitial, 0.)\n    |> Seq.unfold (fun (suscepLast, infectedLast, recoveredLast) ->\n        let susCurrent = calculateSusceptible suscepLast infectedLast\n        let infCurrent = calculateInfected infectedLast suscepLast\n\n        if infCurrent < infectedLast then\n            None\n        else\n            let recvrdCurrent = calculateRecovered recoveredLast infectedLast\n            Some(infCurrent, (susCurrent, infCurrent, recvrdCurrent)))\n    |> Seq.last\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85024,"user_id":null,"body":"let epidemic nDays nIntervals s0 i0 b a = \n  let dt = double nDays \/ double nIntervals\n  \n  let step (s, i, r) = \n    (s - dt * b * s * i, \n     i + dt * (b * s * i - a * i),\n     r + dt * i * a)\n     \n  let rec calcMaxInfected (s, i, r) stepsLeft = \n    match stepsLeft with\n    | 0 -> i\n    | _ -> max i (calcMaxInfected (step (s, i, r)) (stepsLeft - 1))\n  \n  (calcMaxInfected (s0, i0, 0.0) nIntervals) |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85025,"user_id":null,"body":"let rec epidemicAux (n: int) (dt: double) (pS: double) (pI: double) (pR: double) (b: double) (a: double) (k: int) (mx: double) = \n  if (k = n) then int(floor mx)\n  else begin\n    let S = pS - dt * b * pS * pI\n    let I = pI + dt * (b * pS * pI - a * pI)\n    let R = pR + dt * pI * a\n    let m = if I > mx then I else mx\n    epidemicAux n dt S I R b a (k + 1) m \n  end\nlet epidemic tm n s0 i0 b a = epidemicAux n (double(tm) \/ double(n)) s0 i0 0.0 b a 0 (0.0)\n  \/\/ your code","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85026,"user_id":null,"body":"let epidemic tm n s0 i0 b a = \n  let dt = (float tm) \/ (float n)\n  let rec aux s i k = \n    if k = n then\n      List.max i |> int\n    else\n      let sk, ik = (List.head s, List.head i)\n      let sk1 = sk - dt * b * sk * ik\n      let ik1 = ik + dt * (b * sk * ik - a * ik) \n      aux (sk1::s) (ik1::i) (k + 1)\n  aux [s0] [i0] 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85027,"user_id":53,"body":"open System;\n\nlet epidemic tm n s0 i0 b a = \n  let mutable s = s0 |> float\n  let mutable i = i0 |> float\n  let mutable r = 0 |> float\n  let mutable t = 0 |> float\n  let mutable dt = (tm |> float) \/ (n |> float);\n  let mutable imax = 0 |> float\n  while t < (tm |> float) do\n    let sd = dt * (-b * s * i)\n    let id = dt * (b * s * i - a * i)\n    let rd = dt * (a * i)\n    s <- s + sd\n    i <- i + id\n    r <- r + rd\n    t <- t + dt\n    imax <- Math.Max(imax, Math.Floor(i))\n  imax |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85028,"user_id":null,"body":"open System\n\nlet epidemic tm n s0 i0 b a = \n  let dt = (tm |> float) \/ (n |> float)\n  let rec getMax dt n s0 i0 b a =\n    let news = s0 - dt * b * s0 * i0\n    let newi = i0 + dt * (b * s0 * i0 - a * i0)\n    match n with\n    | n when n < 0 -> 0.0\n    | _            -> Math.Max(newi, (getMax dt (n - 1) news newi b a))\n  ((getMax dt n (s0 |> float) (i0 |> float) (b |> float) (a |> float)) |> int)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5667e8f4e3f572a8f2000039":[{"id":85029,"user_id":null,"body":"open System\nopen System.Linq\n\nlet accum (s : string) : string =\n  s.ToLower ()\n  |> Seq.mapi (fun i c -> (Char.ToUpper c |> string) + (String.replicate i (string c)))\n  |> String.concat \"-\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85030,"user_id":null,"body":"open System\n\nlet accum (s:string): string =\n    s.ToLower()\n    |> Seq.mapi(fun i c -> (string c).ToUpper() + (String.replicate (i) (string c)))\n    |> Seq.reduce(fun s acc -> s + \"-\" + acc)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85031,"user_id":null,"body":"open System\nopen System.Linq\n\nlet accum (s: string): string =\n  s\n  |> Seq.mapi (fun i c -> \n    [0..i] |> Seq.fold (fun acc _ ->\n      match acc with \n      | \"\" -> sprintf \"%s%c\" acc (Char.ToUpper(c)) \n      | _ -> sprintf \"%s%c\" acc (Char.ToLower(c))\n    ) \"\"\n  ) \n  |> String.concat \"-\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85032,"user_id":null,"body":"open System\n\nlet accum (s: string) =\n  let replicate i c =\n    seq {\n      yield Char.ToUpper(c)\n      yield! Seq.replicate i c\n    }\n    |> String.Concat\n\n  Seq.mapi replicate (s.ToLower())\n  |> String.concat \"-\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85033,"user_id":null,"body":"let accum (s : string) =\n    s.ToLower()\n    |> Seq.mapi (fun i c -> (string c).ToUpper() + String.replicate i (string c))\n    |> String.concat \"-\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85034,"user_id":null,"body":"let accum (s: string) =\n    s.ToLower().ToCharArray()\n    |> Array.mapi(fun i ch->\n        let letter = string ch\n        let length = i+1\n        String.init length (fun x-> if x=0 then letter.ToUpper() else letter)\n    )\n    |> String.concat \"-\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85035,"user_id":null,"body":"open System\nopen System.Linq\n\nlet accum (s: string) =\n  let titleCase c i =\n    c.ToString().ToUpper() + (new String(c, i)).ToLower()\n  s.ToLower().Select(titleCase)   \n  |> String.concat \"-\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85036,"user_id":492,"body":"open System\nopen System.Linq\n\nlet accum (s: string): string =\n    let repeat c i = String.init i (fun _ -> c.ToString())\n    let upChar2Str c = Char.ToUpper(c).ToString( )\n    s.Select(fun x i -> (upChar2Str x) + (repeat (Char.ToLower(x)) i)) |> String.concat(\"-\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85037,"user_id":null,"body":"let accum (s: string): string =\n    [for e in s.ToLower() -> e.ToString()]\n    |> List.mapi (fun i e -> e.ToUpper() + String.replicate i e)\n    |> String.concat \"-\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85038,"user_id":null,"body":"open System\nopen System.Linq\n\nlet accum (s: string): string =\n    let strs = s |> Seq.mapi (fun i c -> \n                let arr = Array.create (i+1) (Char.ToLower c)\n                arr.[0] <- Char.ToUpper c\n                String(arr) \n                )\n    String.Join(\"-\",strs)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"566be96bb3174e155300001b":[{"id":85039,"user_id":null,"body":"open FSharp.Data.UnitSystems.SI.UnitSymbols\n\ntype [<Measure>] km\ntype [<Measure>] h\n\nlet mPerkm = \n    1000.0<m> \/ 1.0<km>\n\nlet msPerkmh =\n    (1000.0<m> \/ 3600.0<s>)\/ (1.0<km> \/ 1.0<h>)\n\nlet g = 9.81<m\/s^2>\n\nlet dt (initialV: float<m\/s>)=\n    initialV \/ g\n\nlet maxBall (v0:int) : int =\n    let initV =\n        v0 |> float |> (*) 1.0<km\/h>\n    dt (initV * msPerkmh)\n    |>float\n    |>(*) 10.0\n    |>System.Math.Round\n    |>int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85040,"user_id":null,"body":"[<Measure>] type m\n[<Measure>] type sec\n[<Measure>] type kg\n[<Measure>] type km\n[<Measure>] type hour\n\nlet metersPerKm = 1000.00m<m\/km>\nlet g = 9.81m<m\/sec^2>;;\nlet secondsPerHour = 3600m<sec\/hour>\n\nlet getMax (v:decimal<m\/sec>) (t:decimal<sec>) =\n    let h = v * t - 0.5m * g * t * t\n    h\n\nlet maxBall(v0: int): int =\n    \/\/ Convert to measure\n    let v = decimal(v0)*1.00m<km\/hour>\n    \/\/ Velocity in m\/sec\n    let vPerSec = v * metersPerKm \/ secondsPerHour\n    let getMaxWithV = getMax vPerSec\n    let getDecimalFromM (x:decimal<m>) = x \/ (1.0m<m>)\n    let mutable currMax = 0.0m<m>\n    let mutable t = 0.1m<sec>\n    let mutable i = 0\n    while (getMaxWithV t) > currMax do\n        currMax <- (getMaxWithV t)\n        t <- t + 0.1m<sec>\n        i <- i + 1\n    i","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85041,"user_id":null,"body":"let maxBall(v0: int): int =\n    let v = float v0 * 1000. \/ 3600.\n    Seq.initInfinite(fun i -> v * float (i) \/10.0 - 0.5 * 9.81 * float (i * i)\/100.0)\n    |> Seq.pairwise\n    |> Seq.findIndex (fun (v0, v1) -> v1 < v0)  \n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85042,"user_id":492,"body":"open System\n\nlet maxBall(v0: int): int =\n    int (Math.Round(double (double(v0) \/ 3.6) \/ 0.981))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85043,"user_id":17,"body":"open System\n\nlet maxBall(v: int): int = int (Math.Round(float v \/ 3.5316))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85044,"user_id":492,"body":"open System\n\nlet maxBall(v0: int): int =\n    int (Math.Round(double (double(v0) \/ 3.6) \/ 0.981))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85045,"user_id":null,"body":"let maxBall initial = float initial * 5. \/ (18. * 9.81) |> (*) 10. |> round |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85046,"user_id":null,"body":"let maxBall(v0: int): int =\n    (float v0)\/(9.81*3.6)*10.0 + 0.5 |> int\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85047,"user_id":null,"body":"let maxBall (v0 : int) =\n    float v0 * 1000.0 \/ 3600.0 \/ 9.81 * 10.0 |> round |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85048,"user_id":null,"body":"\/\/ differentiate: \n\/\/ v*t - 0.5*g*t*t for t => v - g * t\n\/\/ max height when v - g * t = 0\n\/\/ t => v \/ g \n\nopen System\n\nlet g = 9.81\n\nlet maxBall(v0: int): int =\n    let vInMs = (float v0) \/ 3.6\n    (10.0 * (vInMs \/ g)) |> round |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"566d5cf8001db71d7b000022":[{"id":85049,"user_id":null,"body":"let swap (a : _[]) i j =\n    let temp = a.[i]\n    a.[i] <- a.[j]\n    a.[j] <- temp\n\nlet formatBingoNumber n =\n    sprintf \"%c%d\" \"BINGO\".[(n - 1) \/ 15] n\n\ntype BingoCaller(random : System.Random) =\n    let numbers = [|1..75|]\n\n    let mutable n = 0\n\n    member this.getNumber () =\n        if n = numbers.Length\n        then \"\"\n        else\n            let i = numbers.Length - 1 - n\n            n <- n + 1\n            swap numbers (random.Next(1, i + 2) - 1) i\n            formatBingoNumber numbers.[i]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85050,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n  let mutable n = random.Next(1, 76)\n  let mutable set = Set[]\n  member this.getNumber _ = \n    match set.Count with\n    | 75 -> \"\"    \n    | _ -> while set.Contains n do n <- random.Next(1, 76)\n           set <- set.Add(n)\n           sprintf \"%c%d\" \"BINGO\".[(n-1)\/15] n           ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85051,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n    let getNumb (numb: int) =\n      match numb with\n      | numb when (numb <= 15 && numb >= 1)  -> \"B\" + numb.ToString()\n      | numb when (numb <= 30 && numb >= 16) -> \"I\" + numb.ToString()\n      | numb when (numb <= 45 && numb >= 31) -> \"N\" + numb.ToString()\n      | numb when (numb <= 60 && numb >= 46) -> \"G\" + numb.ToString()\n      | numb when (numb <= 75 && numb >= 61) -> \"O\" + numb.ToString()\n      | _                                    -> \"\"\n    let mutable numsList = [1..75] |> \n                           List.sortBy (fun x -> abs (x - random.Next())) |> \n                           List.map getNumb\n    member this.getNumber () =\n      if (numsList |> List.isEmpty) then\n        \"\"\n      else\n        let result = numsList |> List.head\n        numsList <- (numsList |> List.tail)\n        result\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85052,"user_id":491,"body":"type BingoCaller(random: System.Random) =\n\n    let mutable count = 0\n    let mutable seen = Set.empty\n    \n    let parse number =\n        match number with\n        | n when n <= 15 -> \"B\" + string number\n        | n when n <= 30 -> \"I\" + string number\n        | n when n <= 45 -> \"N\" + string number\n        | n when n <= 60 -> \"G\" + string number\n        | n when n <= 75 -> \"O\" + string number\n        | _ -> failwith \"invalid input\"\n    \n    let rec getNextNumber() =\n        let number = random.Next(1, 76)\n        if Set.contains number seen then\n            getNextNumber()\n        else\n            seen <- Set.add number seen\n            number\n                \n    member this.getNumber _ =\n        if count >= 75 then\n            \"\"\n        else\n            count <- count + 1\n            let number = getNextNumber()\n            parse number","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85053,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n  let mutable n = random.Next(1, 76)\n  let mutable set = Set[]\n  member this.getNumber _ = \n    match set.Count with\n    | 75 -> \"\"    \n    | _ -> while set.Contains n do n <- random.Next(1, 76)\n           set <- set.Add(n)\n           string \"BINGO\".[(n-1)\/15] + string n           ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85054,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n  let mutable n = random.Next(1, 76)\n  let mutable set = Set[]\n  member this.getNumber _ = \n    match set.Count with\n    | 75 -> \"\"    \n    | _ -> while set.Contains n do \n             n <- random.Next(1, 76)\n           set <- set.Add(n)\n           let p = match n with\n                   | n when n<16 -> \"B\"\n                   | n when n<31 -> \"I\"\n                   | n when n<46 -> \"N\"\n                   | n when n<61 -> \"G\"\n                   | _ -> \"O\"\n           p + (string n)                   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85055,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n  let mutable n = random.Next(1, 76)\n  let mutable set = Set[]\n  member this.getNumber _ = \n    match Set.count set with\n    | 75 -> \"\"    \n    | _ -> while Set.contains n set do \n             n <- random.Next(1, 76)\n           set <- Set.add n set\n           let p = match n with\n                   | n when n<16 -> \"B\"\n                   | n when n<31 -> \"I\"\n                   | n when n<46 -> \"N\"\n                   | n when n<61 -> \"G\"\n                   | _ -> \"O\"\n           p + (string n)                   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85056,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n  let mutable n = random.Next(1, 76)\n  let mutable lst = []\n  member this.getNumber _ = \n    match List.length lst with\n    | 75 -> \"\"    \n    | _ -> while List.exists((=) n) lst do \n             n <- random.Next(1, 76)\n           lst <- lst @ [n]\n           let p = match n with\n                   | n when n<16 -> \"B\"\n                   | n when n<31 -> \"I\"\n                   | n when n<46 -> \"N\"\n                   | n when n<61 -> \"G\"\n                   | _ -> \"O\"\n           p + (string n)                   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85057,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n   let numbers= System.Collections.Generic.HashSet<int>()\n   \n   member __.getNumber()=\n     if numbers.Count < 75 then\n        let mutable n = random.Next( 1 , 76)\n        while numbers.Contains(n) do\n            n <- random.Next( 1, 76)\n        numbers.Add(n) |> ignore\n        sprintf \"%c%d\" (\"BINGO\".[ (n-1) \/ 15]) n\n      else\n        \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85058,"user_id":null,"body":"type BingoCaller(random: System.Random) =\n    let mutable usedNumbers = Set.empty<int>\n    \n    let rec get_next() =\n        if usedNumbers.Count >= 75 then\n            -1\n        else\n            let next = random.Next() % 75\n            let clamp_next = if next = 0 then 75 else next\n            if  Set.contains clamp_next usedNumbers then\n                get_next()\n            else\n                clamp_next\n                \n    let getLetter num =\n        match num with\n        |_ when num >=1 && num <=15 -> 'B'\n        |_ when num <=30 -> 'I'\n        |_ when num <=45 -> 'N'\n        |_ when num <=60 -> 'G'\n        |_ when num <=75 -> 'O'\n        |_ -> 'X'\n                                        \n    member this.getNumber _ = \n        let next = get_next()\n        if next = -1 then\n            \"\"\n        else\n            usedNumbers <- usedNumbers.Add(next)\n            sprintf \"%c%A\" (getLetter next) next ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"566d5e2e57d8fae53c00000c":[{"id":85059,"user_id":null,"body":"open System;\n\ntype BingoRow = { Column:string; NumbersCount: int; NumbersRange: int*int}\n\n\nlet rnd = System.Random DateTime.Now.Millisecond\nlet genRandomNumbers (min,max) count =\n    let initial = Seq.initInfinite (fun _ -> rnd.Next (min, max+1))\n    initial\n    |> Seq.distinct\n    |> Seq.take(count)\n    |> Seq.toArray\n\n\n\nlet getCard _ = \n    let bingoRows = [|\n        {Column=\"B\"; NumbersCount=5; NumbersRange=(1,15)};\n        {Column=\"I\"; NumbersCount=5; NumbersRange=(16,30)};\n        {Column=\"N\"; NumbersCount=4; NumbersRange=(31,45)};\n        {Column=\"G\"; NumbersCount=5; NumbersRange=(46,60)};\n        {Column=\"O\"; NumbersCount=5; NumbersRange=(61,75)}        \n        |]\n    bingoRows \n    |> Array.map (fun row -> (row.Column, (genRandomNumbers row.NumbersRange row.NumbersCount)))\n    |> Array.collect (fun (column, numbers) -> Array.map (fun number -> (column + string number)) numbers)\n        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85060,"user_id":null,"body":"let randomUpTo =\n    let random = System.Random()\n    fun n -> random.Next(n + 1)\n\nlet swap (a : _[]) i j =\n    let temp = a.[i]\n    a.[i] <- a.[j]\n    a.[j] <- temp\n\nlet pickRandom (a : _[]) n =\n    let i = a.Length - 1 - n\n    swap a (randomUpTo i) i\n    a.[i]\n\nlet getCard () =\n    let numbers = [|1..15|]\n\n    let getNumber i j =\n        15 * i + pickRandom numbers j\n\n    let getColumn i c =\n        Seq.init\n            (if i = 2 then 4 else 5)\n            (getNumber i >> sprintf \"%c%d\" c)\n\n    \"BINGO\"\n    |> Seq.mapi getColumn\n    |> Seq.concat\n    |> Seq.toArray\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85061,"user_id":null,"body":"let rnd = new System.Random()\nlet getCard () = \n\n    let randomWalk c ns =        \n        Seq.unfold (fun s -> \n             let idx = rnd.Next(0, List.length s)\n             let nxt = s.[idx]\n             Some(nxt, s |> List.except [nxt] )) ns\n        |> Seq.take c         \n    \n    let numbers = [1..75] |> List.chunkBySize 15\n\n    Seq.zip \"BINGO\" numbers \n    |> Seq.collect (fun (c, nums) -> \n        let cnt = if c = 'N' then 4 else 5\n        nums |> randomWalk cnt |> Seq.map (fun ni -> sprintf \"%c%i\" c ni))    \n    |> Seq.toArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85062,"user_id":null,"body":"let random = System.Random()\nlet getCard _ =\n  let column i c =\n    Seq.initInfinite (fun _ -> 1 + 15 * i + random.Next 15)\n      |> Seq.distinct\n      |> Seq.take (if i = 2 then 4 else 5)\n      |> Seq.map (sprintf \"%c%d\" c)\n  \"BINGO\"\n    |> Seq.mapi column\n    |> Seq.concat\n    |> Seq.toArray\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85063,"user_id":null,"body":"let getCard _ =\n    let column ini fin amnt letter =\n        [| ini..fin |]\n        |> Array.sortBy (fun _ -> System.Guid.NewGuid())\n        |> Array.take amnt\n        |> Array.map (sprintf \"%s%d\" letter)\n\n    let bColumn = column 1 15 5 \"B\"\n    let iColumn = column 16 30 5 \"I\"\n    let nColumn = column 31 45 4 \"N\"\n    let gColumn = column 46 60 5 \"G\"\n    let oColumn = column 61 75 5 \"O\"\n    \n    [||]\n    |> Array.append bColumn\n    |> Array.append <|iColumn\n    |> Array.append <|nColumn\n    |> Array.append <|gColumn\n    |> Array.append <|oColumn","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85064,"user_id":168,"body":"let rand = System.Random ()\n\nlet sample a b n =\n  let rec f acc =\n    if Set.count acc = n then \n      Set.toArray acc\n    else\n      f (Set.add (rand.Next(a, b)) acc)\n  f Set.empty\n\nlet getCard () = \n  let row x a b n = sample a b n |> Array.map (fun i -> string x + string i)\n  Array.collect (fun i -> row \"BINGO\".[i] (i * 15 + 1) (i * 15 + 15) (if i = 2 then 4 else 5)) [| 0 .. 4 |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85065,"user_id":null,"body":"let rng = System.Random ()\n\nlet getCard _ = \n  let ranks =\n    [ (\"B\", 1, 5) ; (\"I\", 16, 5) ; (\"N\", 31, 4) ; (\"G\", 46, 5) ; (\"O\", 61, 5) ]\n  [|\n    for (letter, start, count) in ranks do\n      yield!\n        Seq.initInfinite (fun _ -> rng.Next count + 1)\n        |> Seq.distinct\n        |> Seq.take count\n        |> Seq.map (fun v -> sprintf \"%s%d\" letter v)\n  |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85066,"user_id":null,"body":"let random = new System.Random()\n\nlet getCard _ = \n  let getRandomPerm (a:int) (b:int) =\n    let rec getPerm (listv: int list) =\n      if (List.isEmpty listv) then\n        []\n      else\n        let a = random.Next(0, random.Next(10,226)) % (List.length listv)\n        let newlistv =\n            if ((a + 1) < (List.length listv)) then\n                (listv |> List.take a) @ (listv |> List.skip (a + 1))\n            else   \n                (listv |> List.take a)\n        [listv.[a]] @ (getPerm newlistv)\n        \n    [a..b] |> getPerm |> Array.ofList\n    \n  [|\"B\"; \"I\"; \"N\"; \"G\"; \"O\"|] |> Array.indexed |>\n  Array.collect (fun (a,b) -> (getRandomPerm (a * 15 + 1) (a * 15 + 15)) |> Array.take (if b = \"N\" then 4 else 5) |> Array.map (fun y -> b + y.ToString()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85067,"user_id":null,"body":"open System\n\nlet getCard _ =\n    let rnd = Random (Guid.NewGuid().GetHashCode())\n    let rec shuffle list =\n        match list with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> match rnd.Next(0, 1 + xs.Length) with\n                   | 0 -> x::(shuffle xs)\n                   | i when i = xs.Length - 2 -> (List.last xs)::(shuffle (List.take i (x::xs)))\n                   | i -> let (l, r::rs) = List.splitAt i (x::xs)\n                          r::shuffle (l @ rs)\n\n    let getCol x m n k =\n        seq {m..n} \n            |> Seq.toList\n            |> shuffle\n            |> Seq.map (sprintf \"%c%d\" x)\n            |> Seq.take k\n\n    [ getCol 'B' 1 15 5; \n      getCol 'I' 16 30 5;\n      getCol 'N' 31 45 4;\n      getCol 'G' 46 60 5;\n      getCol 'O' 61 75 5;]\n    |> Seq.concat\n    |> Seq.toArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85068,"user_id":null,"body":"let rnd = System.Random()\n\nlet getCard() = \n    let ranges = Array.chunkBySize 15 [|1..75|] |> Array.map (Array.sortBy rnd.Next)\n    let buildString i c = Array.truncate (if c = 'N' then 4 else 5) ranges.[i] |> Array.map (sprintf \"%c%i\" c)\n    \"BINGO\" |> Seq.mapi buildString |> Seq.concat |> Array.ofSeq\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"566fc12495810954b1000030":[{"id":85069,"user_id":null,"body":"let square n = n * n\n\nlet rec digits n =\n    seq {\n        yield n % 10\n        let n' = n \/ 10\n        if n' <> 0 then\n            yield! digits n'\n    }\n\nlet nb_dig n d =\n    {0..n}\n    |> Seq.collect (square >> digits)\n    |> Seq.filter ((=) d)\n    |> Seq.length\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85070,"user_id":492,"body":"open System.Linq\n\nlet nb_dig (n: int) (d:int) =\n    [for i in 0 .. n -> (i * i).ToString().Count(fun c -> c = char(48 + d)) ] |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85071,"user_id":null,"body":"let nb_dig (n : int) (d : int) =\n    let digit = (char << string) d\n    seq { for k in 0 .. n do yield! string <| k * k }\n    |> Seq.where (( = ) digit)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85072,"user_id":null,"body":"let nb_dig (n: int) (d:int) =\n    let intToDigits i = \n        if i = 0 then seq{yield 0}\n        else i |> Seq.unfold (fun x -> if x = 0 then None else Some (x % 10, x \/ 10))\n    {0..n}\n    |> Seq.map (fun x -> x*x)\n    |> Seq.collect intToDigits \n    |> Seq.filter ((=) d)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85073,"user_id":492,"body":"open System.Linq\n\nlet nb_dig (n: int) (d:int) =\n    [for i in 0 .. n -> (i * i).ToString().Count(fun c -> c = char(48 + d)) ] |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85074,"user_id":878,"body":"let nb_dig (n: int) (d:int) =\n  let chrd = (string d).[0]\n  Seq.map (fun i -> i * i) [0..n]\n  |> Seq.map (fun i -> string i |> Seq.filter ((=) chrd) |> Seq.length)\n  |> Seq.fold (+) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85075,"user_id":null,"body":"let nb_dig (n: int) (d:int) =\n    String.concat \"\" [|for i in 0 .. n -> (i * i) |> string|]\n    |> Seq.filter (fun x -> x = (d |> string |> char))\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85076,"user_id":null,"body":"let nb_dig (n: int) (d: int) =\n        let myList = [0..n]\n                     |> List.map(fun n -> n * n)\n                     |> List.filter(fun n -> n.ToString().Contains(d.ToString()))\n                     |> List.map(fun n -> n)\n        System.String.Join (\"\", myList)\n        |> Seq.sumBy (fun a -> if a.ToString() = d.ToString() then 1 else 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85077,"user_id":null,"body":"let nb_dig from0IterateTo digitToIdentify =\n    let identifyDigitChar = string digitToIdentify |> char\n\n    [ 0..from0IterateTo ]\n    |> List.map (fun i ->\n        string (i * i)\n        |> String.filter ((=) identifyDigitChar)\n        |> String.length)\n    |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85078,"user_id":null,"body":"let nb_dig (n: int) (d:int) =\n  [0..n]\n  |> Seq.map (fun x -> x * x)\n  |> System.String.Concat\n  |> Seq.filter ((=) (char (d + 48)))\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5671d975d81d6c1c87000022":[{"id":85079,"user_id":53,"body":"\nlet observerCell (id: int, i: int, n: int): int =\n  match id with\n    | id1 when id1 < n    -> id1+i*n\n    | id2 when id2 < 2*n  -> (n-1-i)+id2%n*n\n    | id3 when id3 < 3*n  -> (n-1-id3%n)+(n-1-i)*n\n    | _                   -> i+(n-1-id%n)*n\n\nlet solve_puzzle (clues: int[]): int[][] =\n\n  let n           = (Array.length clues) \/ 4\n  let board       = [| for i in 0 .. n-1 -> Array.zeroCreate n |]\n  let cells       = [| for i in 0 .. (pown n 2)-1 -> Array.zeroCreate n |]\n  let peers       = [| for i in 0 .. (pown n 2)-1 -> [| for j in 0 .. n-1 -> [| j*n+i%n ; i\/n*n+j |] |] |> Array.collect (fun j -> j) |> Array.filter (fun j -> j <> i) |]\n  let observers   = clues |> Array.indexed |> Array.map (fun (id, c) -> [| [| 0 .. n-1 |] |> Array.map (fun i -> observerCell(id, i, n)) ; [| c |] |] |> Array.collect (fun i -> i))\n  \n  let candidates(c: int): int[] =\n    [| 0 .. n-1 |] |> Array.filter (fun i -> cells.[c].[i] = 0)\n  \n  let look(o: int[]): int = \n    let mutable k = -1\n    let mutable cnt = 0\n    for i in 0 .. n-1 do\n      let v = board.[o.[i]\/n].[o.[i]%n]\n      if v > k then\n        cnt <- cnt + 1\n        k <- v\n    cnt\n    \n  let verify(o: int[]): bool = \n    o.[n] = 0 || [| 0 .. n-1 |] |> Array.exists (fun i -> board.[o.[i]\/n].[o.[i]%n] = 0) || look(o) = o.[n]\n  \n  let choose(): int option =\n    [| 0 .. (pown n 2)-1 |] |> Array.tryFind (fun i -> board.[i\/n].[i%n] = 0)\n  \n  let cloack(c: int, v: int) =\n    Array.set cells.[c] v (cells.[c].[v]+1)\n  \n  let uncloack(c: int, v: int) =\n    Array.set cells.[c] v (cells.[c].[v]-1)\n    \n  let lock(c: int, v: int) =\n    Array.set board.[c\/n] (c%n) (v+1)\n    for s in peers.[c] do\n      cloack(s, v)\n      \n  let unlock(c: int, v: int) =\n    Array.set board.[c\/n] (c%n) 0\n    for s in peers.[c] do\n      uncloack(s, v)\n      \n  let rec dfs() =\n    let cellOpt = choose()\n    match cellOpt with\n      | None -> not (observers |> Array.exists (fun o -> not (verify o)))\n      | Some cell ->\n        let options = candidates(cell)\n        let mutable completed = false\n        for i in 0 .. (options |> Array.length)-1 do\n          let value = options.[i]\n          if not completed then\n            lock(cell, value)\n            if dfs() then\n              completed <- true\n            else\n              unlock(cell, value)\n        completed\n  \n  dfs() |> ignore\n  board","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85080,"user_id":null,"body":"open System.Collections.Generic\n\n[<System.Flags>]\ntype Digit =\n  | One   = 0b0001\n  | Two   = 0b0010\n  | Three = 0b0100\n  | Four  = 0b1000\n\ntype Cell =\n  | Known of int\n  | Unknown of Digit\n\nlet rec distribute e = function\n| [] -> [[e]]\n| x::xs' as xs -> (e::xs)::[for xs in distribute e xs' -> x::xs]\n\nlet rec permute = function\n| [] -> [[]]\n| e::xs -> List.collect (distribute e) (permute xs)\n\nlet calcClue perm =\n  perm |> List.fold (fun (clue, max) p ->\n    match p with\n    | v when v > max -> (clue + 1, v)\n    | _ -> (clue, max)\n  ) (0, 0)\n  |> fst\n\nlet solve_puzzle (clues : int[]) =\n  let min, max = 0, 4\n  let perms = permute [1..max]\n  let permsByClue = new Dictionary<int, int list list>()\n  perms |> List.groupBy calcClue |> List.iter permsByClue.Add\n  let digitByValue = dict[(1, Digit.One); (2, Digit.Two); (3, Digit.Three); (4, Digit.Four)]\n  \n  let init = Unknown (Digit.One ||| Digit.Two ||| Digit.Three ||| Digit.Four)\n  let grid = [| [| init; init; init; init |]; [| init; init; init; init |]; [| init; init; init; init |]; [| init; init; init; init |]; |]\n  let setGrid i j v = grid.[i].[j] <- v\n  \n  let getView clue_i =\n    let div, mod_ = clue_i \/ 4, clue_i % max\n    match div with\n    | 0 -> [min..max - 1] |> List.map (fun x -> (x, mod_))\n    | 1 -> [min..max - 1] |> List.rev |> List.map (fun x -> (mod_, x))\n    | 2 -> [min..max - 1] |> List.rev |> List.map (fun x -> (x, max - mod_ - 1))\n    | 3 -> [min..max - 1] |> List.map (fun x -> (max - mod_ - 1, x))\n    | _ -> failwith \"No more clues\"\n  \n  let filterPossibleInRowCol() =\n    [1..max] |> List.iter (fun v ->\n      let d = digitByValue.[v]\n      for i = min to max - 1 do\n        for j = min to max - 1 do\n          match grid.[i].[j] with\n          | Unknown p ->\n            let row_has_v = [min..max - 1] |> List.fold (fun res c -> res || grid.[i].[c] = Known v) false\n            let col_has_v = [min..max - 1] |> List.fold (fun res r -> res || grid.[r].[j] = Known v) false\n            if row_has_v || col_has_v then setGrid i j <| Unknown (p &&& ~~~d) else ()\n          | _ -> ()\n    )\n  let setOnlyPossibleInRowCol i (d, v) get_idxs =\n    let v_in_list =\n      [min..max - 1]\n      |> List.fold (fun res j ->\n        let i_, j_ = get_idxs i j\n        match grid.[i_].[j_] with\n        | Unknown p when (int(p &&& d) <> 0) -> (i_, j_)::res\n        | _ -> res\n      ) []\n    match v_in_list with\n    | [(i, j)] -> setGrid i j <| Known v\n    | _ -> ()\n  \n  let setOnlyPossible() =\n    [1..max] |> List.iter (fun v ->\n      let d = digitByValue.[v]\n      for i = min to max - 1 do\n        filterPossibleInRowCol()\n        setOnlyPossibleInRowCol i (d, v) (fun i j -> i, j)\n        filterPossibleInRowCol()\n        setOnlyPossibleInRowCol i (d, v) (fun i j -> j, i)\n    )\n  \n  let filterPossiblePerms clues =\n    clues\n    |> Array.iteri (fun clue_i clue ->\n      if clue = 0 then () else\n      let view = getView clue_i\n      let pos_digits =\n        permsByClue.[clue]\n        |> List.filter (fun perm ->\n          List.zip perm view\n          |> List.exists (fun (p, (i, j)) -> match grid.[i].[j] with | Known k when k <> p -> true | _ -> false)\n          |> not\n        )\n        |> List.fold (fun res perm ->\n          match perm, res with\n          | [p1; p2; p3; p4], [r1; r2; r3; r4] -> [p1::r1; p2::r2; p3::r3; p4::r4]\n          | _ -> failwith \"Error\"\n        ) [[]; []; []; []]\n        |> List.map (fun l ->\n          let dist = List.distinct l\n          let pos =\n            dist |> List.fold (fun res v ->\n              let digit = digitByValue.[v]\n              match res with\n              | Some (Unknown r) -> Some (Unknown (r ||| digit))\n              | _ -> Some (Unknown digit)\n            ) None\n          match pos with\n          | Some v -> v\n          | _ -> failwith \"Error\"\n        )\n      List.zip view pos_digits\n      |> List.iter (fun ((i, j), d) ->\n        match grid.[i].[j], d with\n        | Unknown cur_digit, Unknown digit -> setGrid i j <| Unknown (cur_digit &&& digit)\n        | _ -> ()\n      )\n    )\n  \n  let checkSolved() =\n    let mutable solved = true\n    grid\n    |> Array.toList\n    |> List.iter (fun a ->\n      a\n      |> Array.toList\n      |> List.iter (fun cell -> match cell with | Known v -> () | _ -> solved <- false)\n    )\n    solved\n    \n  while not <| checkSolved() do\n    filterPossiblePerms clues\n    setOnlyPossible()\n  grid |> Array.map (Array.map (fun cell -> match cell with | Known v -> v | _ -> failwith \"Error\"))\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85081,"user_id":null,"body":"\n\/\/ From: http:\/\/stackoverflow.com\/questions\/286427\/calculating-permutations-in-f\n\/\/ Much faster than anything else I've tested\n\nlet rec permutations = function\n    | [] -> seq [List.empty]\n    | x :: xs -> Seq.collect (insertions x) (permutations xs)\nand insertions x = function\n    | [] -> [[x]]\n    | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\n\/\/ ---\n\nlet rowClues =\n    [ 15, 4\n      14, 5\n      13, 6\n      12, 7 ]\n\nlet colClues = \n    [ 0, 11\n      1, 10\n      2, 9\n      3, 8 ]\n\nlet allVs = [1..4] |> permutations |> List.ofSeq\n\nlet clued (b, e) =\n    let vis a = \n        a |> Seq.scan max 0 |> Seq.skip 1 |> Seq.distinct |> Seq.length\n    let bothSides a = (b = 0 || vis a = b) && (e = 0 || vis (List.rev a) = e)\n    allVs |> List.filter bothSides\n\nlet intersect rs cs i j =\n    let fits (a: _ list, b: _ list) = a.[j] = b.[i]\n    let res = List.allPairs rs cs |> List.filter fits\n    res |> List.map fst |> List.distinct, res |> List.map snd |> List.distinct\n\nlet solve_puzzle (clues: int[]) =\n\n    let clue (t: _ list) n =\n        let b, e = t.[n]\n        clues.[b], clues.[e]\n\n    let notExcludedRowVs = Array.init 4 (clue rowClues >> clued)\n    let notExcludedColVs = Array.init 4 (clue colClues >> clued)\n\n    while notExcludedRowVs |> Array.exists (fun rs -> rs.Length > 1) do\n        for i in 0..3 do\n            for j in 0..3 do\n                let rs, cs = intersect notExcludedRowVs.[i] notExcludedColVs.[j] i j\n                notExcludedRowVs.[i] <- rs\n                notExcludedColVs.[j] <- cs\n\n    notExcludedRowVs |> Array.map (List.exactlyOne >> List.toArray)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85082,"user_id":null,"body":"type NFLOORS =\n    | One = 1\n    | Two = 8\n    | Three = 64\n    | Four = 512\n\nlet solve_puzzle (clues : int[]) : int[][] =\n    let grid = Array.init 4 (fun _ -> Array.create 4 (int NFLOORS.One + int NFLOORS.Two + int NFLOORS.Three + int NFLOORS.Four))\n\n    let GridRowColumn k order =\n        match k\/4 with\n        | 0 -> (order, k)\n        | 1 -> (k%4, 3-order)\n        | 2 -> (3-order, 3-k%4)\n        | _ -> (3-k%4, order)\n\n\n    \/\/ Basic cell functions\n    let CommitToCell (iRow, jColumn) (buildingHeight:NFLOORS) = grid.[iRow].[jColumn] <- (int buildingHeight)\n    let RemoveFromCell (iRow, jColumn) (buildingHeight:NFLOORS) = grid.[iRow].[jColumn] <- grid.[iRow].[jColumn]&&&(~~~(int buildingHeight))\n    let CellEquals (iRow, jColumn) (buildingHeight:NFLOORS) = grid.[iRow].[jColumn] = (int buildingHeight)\n    let CellAllows (iRow, jColumn) (buildingHeight:NFLOORS) = grid.[iRow].[jColumn]&&&(int buildingHeight) <> 0\n\n    \/\/ remove functions\n    let RemoveFromRow iRow (buildingHeight:NFLOORS) = for j=0 to 3 do RemoveFromCell (iRow, j) buildingHeight\n\n    let RemoveFromColumn jColumn (buildingHeight:NFLOORS) = for i=0 to 3 do RemoveFromCell (i, jColumn) buildingHeight\n\n    \/\/ Commit the building height to iRow, jColumn and remove it from other cells in iRow and jColumn\n    let Commit (iRow, jColumn) (buildingHeight:NFLOORS) =\n        RemoveFromRow iRow buildingHeight\n        RemoveFromColumn jColumn buildingHeight\n        CommitToCell (iRow, jColumn) buildingHeight\n\n    \/\/ Check each row for only one possible height\n    let checkRow iRow =\n        let sum = grid.[iRow] |> Array.sum\n        if sum&&&0o7 = int NFLOORS.One then     Commit (iRow, grid.[iRow] |> Array.findIndex (fun cell -> (cell&&&0o7 = int NFLOORS.One))) NFLOORS.One\n        if sum&&&0o70 = int NFLOORS.Two then    Commit (iRow, grid.[iRow] |> Array.findIndex (fun cell -> (cell&&&0o70 = int NFLOORS.Two))) NFLOORS.Two\n        if sum&&&0o700 = int NFLOORS.Three then Commit (iRow, grid.[iRow] |> Array.findIndex (fun cell -> (cell&&&0o700 = int NFLOORS.Three))) NFLOORS.Three\n        if sum&&&0o7000 = int NFLOORS.Four then Commit (iRow, grid.[iRow] |> Array.findIndex (fun cell -> (cell&&&0o7000 = int NFLOORS.Four))) NFLOORS.Four\n\n    \/\/ Check each column for only one possible height\n    let checkColumn jColumn =\n        let sum = grid |> Array.sumBy(fun row -> row.[jColumn])\n        if sum&&&0o7 = int NFLOORS.One then     Commit (grid |> Array.findIndex (fun row -> (row.[jColumn]&&&0o7 = int NFLOORS.One)), jColumn) NFLOORS.One\n        if sum&&&0o70 = int NFLOORS.Two then    Commit (grid |> Array.findIndex (fun row -> (row.[jColumn]&&&0o70 = int NFLOORS.Two)), jColumn) NFLOORS.Two\n        if sum&&&0o700 = int NFLOORS.Three then Commit (grid |> Array.findIndex (fun row -> (row.[jColumn]&&&0o700 = int NFLOORS.Three)), jColumn) NFLOORS.Three\n        if sum&&&0o7000 = int NFLOORS.Four then Commit (grid |> Array.findIndex (fun row -> (row.[jColumn]&&&0o7000 = int NFLOORS.Four)), jColumn) NFLOORS.Four\n\n    for i=0 to 2 do\n        \/\/ If I can see 1, the first one must have height 4\n        clues |> Array.iteri (fun k clue -> if clue = 1 then Commit (GridRowColumn k 0) NFLOORS.Four)\n\n        \/\/ If I can see 2, the first one cannot have height 4\n        clues |> Array.iteri (fun k clue -> if clue = 2 then RemoveFromCell (GridRowColumn k 0) NFLOORS.Four)\n\n        \/\/ If I can see 2 and the last one has height 4, the first height must be 3\n        clues |> Array.iteri (fun k clue -> if clue = 2 && CellEquals (GridRowColumn k 3) NFLOORS.Four then Commit (GridRowColumn k 0) NFLOORS.Three)\n\n        \/\/ If I can see 2 and the third one has height 4, the first two must have heights 2 1 or 3 2.  Check if only one is allowed.\n        clues |> Array.iteri (fun k clue -> \n            if clue = 2 && CellEquals (GridRowColumn k 2) NFLOORS.Four then\n                let canUse21 = CellAllows (GridRowColumn k 0) NFLOORS.Two && CellAllows (GridRowColumn k 1) NFLOORS.One\n                let canUse32 = CellAllows (GridRowColumn k 0) NFLOORS.Three && CellAllows (GridRowColumn k 1) NFLOORS.Two\n                if canUse21 && not canUse32 then\n                    Commit (GridRowColumn k 0) NFLOORS.Two\n                    Commit (GridRowColumn k 1) NFLOORS.One\n                elif canUse32 && not canUse21 then\n                    Commit (GridRowColumn k 0) NFLOORS.Three\n                    Commit (GridRowColumn k 1) NFLOORS.Two)\n\n        \/\/ If I can see 3, the first two cannot have height 4 and the first one cannot have height 3\n        clues |> Array.iteri (fun k clue -> if clue = 3 then RemoveFromCell (GridRowColumn k 0) NFLOORS.Four; RemoveFromCell (GridRowColumn k 1) NFLOORS.Four; RemoveFromCell (GridRowColumn k 0) NFLOORS.Three)\n\n        \/\/ If I can see three with ??34, the order must be 2134\n        clues |> Array.iteri (fun k clue -> if clue = 3 then if CellEquals (GridRowColumn k 2) NFLOORS.Three && CellEquals (GridRowColumn k 3) NFLOORS.Four then Commit (GridRowColumn k 0) NFLOORS.Two; Commit (GridRowColumn k 1) NFLOORS.One)\n\n        \/\/ If I can see 4, the heights must be 1234\n        clues |> Array.iteri (fun k clue -> if clue = 4 then Commit (GridRowColumn k 0) (NFLOORS.One); Commit (GridRowColumn k 1) (NFLOORS.Two); Commit (GridRowColumn k 2) (NFLOORS.Three); Commit (GridRowColumn k 3) (NFLOORS.Four);)\n\n        for iRow=0 to 3 do checkRow iRow\n\n        for jColumn=0 to 3 do checkColumn jColumn\n\n    grid |> Array.map (fun row -> row |> Array.map (function | 1 -> 1 | 8 -> 2 | 64 -> 3 | 512 -> 4 | _ -> 0))\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85083,"user_id":null,"body":"let solve_puzzle (clues : int[]) : int[][] =\n    let con = [|\n        [|1; 2; 3; 4|];\n        [|1; 2; 4; 3|];[|1; 3; 2; 4|];[|1; 3; 4; 2|];[|2; 1; 3; 4|];[|2; 3; 1; 4|];[|2; 3; 4; 1|];\n        [|1; 4; 2; 3|];[|1; 4; 3; 2|];[|2; 1; 4; 3|];[|2; 4; 1; 3|];[|2; 4; 3; 1|];[|3; 1; 2; 4|];[|3; 1; 4; 2|];[|3; 2; 1; 4|];[|3; 2; 4; 1|];[|3; 4; 1; 2|];[|3; 4; 2; 1|];\n        [|4; 1; 2; 3|];[|4; 1; 3; 2|];[|4; 2; 1; 3|];[|4; 2; 3; 1|];[|4; 3; 1; 2|];[|4; 3; 2; 1|]\n    |]\n    seq {\n        for a0 in con do\n            for a1 in con do\n                for a2 in con do\n                    for a3 in con do\n                        let board = Array.concat [a0;a1;a2;a3]\n                        let GetXs x = [|for i in 0..4..15 -> board.[i + x]|]\n                        let GetYs y = board.[y*4..y*4+3]\n                        let vi (lst:int[]) v = Seq.mapi (fun i v -> Seq.forall (fun li -> v >= li) (lst.[0..i])) lst |> Seq.filter (fun x -> x) |> Seq.length = v\n                        if  Seq.forall (GetXs >> Seq.distinct >> Seq.length >> (=) 4) [0..3] &&\n                            Seq.forall (GetYs >> Seq.distinct >> Seq.length >> (=) 4) [0..3] &&\n                            Seq.zip [0..3]     clues.[0..3]   |> Seq.filter (snd >> (<>) 0) |> Seq.forall (fun (x,v) -> vi (GetXs x) v) &&\n                            Seq.zip [0..3]     clues.[4..7]   |> Seq.filter (snd >> (<>) 0) |> Seq.forall (fun (x,v) -> vi (GetYs x |> Array.rev) v) &&\n                            Seq.zip [3..-1..0] clues.[8..11]  |> Seq.filter (snd >> (<>) 0) |> Seq.forall (fun (x,v) -> vi (GetXs x |> Array.rev) v) &&\n                            Seq.zip [3..-1..0] clues.[12..15] |> Seq.filter (snd >> (<>) 0) |> Seq.forall (fun (x,v) -> vi (GetYs x) v) then\n                                yield board\n    } |> Seq.head |> Array.chunkBySize 4","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85084,"user_id":null,"body":"let multiply (head, sequences) =\n    sequences\n    |> List.map (fun x -> head :: x)\n\nlet rec permute set =\n\n    if List.length set = 1 then\n        [set]\n    else\n\n        let permutationsFor head =\n            (head, permute (List.except [head] set))\n\n        set\n        |> List.map permutationsFor\n        |> List.collect multiply\n\nlet suitableFor positions knownPositions =\n    List.zip positions knownPositions\n    |> List.map (fun (pos, known) -> \n        match known with\n        | None -> true\n        | Some x -> pos = x)\n    |> List.reduce (&&)\n\nlet permuteFor set value position knownPositions =\n    permute set\n    |> List.where (fun x -> x.[position] = value)\n    |> List.where (fun x -> suitableFor x knownPositions)\n\nlet leftToRight = id\nlet rightToLeft = List.rev\nlet upToDown = leftToRight\nlet downToUp = rightToLeft\n\nlet visibility order (row : int list) = \n    \n    let _, visibleCount =\n        row\n        |> order\n        |> List.fold (fun (maxHeight, visibleCount) currentHeight -> \n            match currentHeight with \n            | _ when currentHeight > maxHeight -> (currentHeight, visibleCount + 1)\n            | _ -> (maxHeight, visibleCount)\n            ) (0, 0)\n    \n    visibleCount\n\nlet initialMatrix value side =\n    Array2D.create side side value\n    \/\/|> Array.create side\n\ntype fieldData =\n    {heights : int[,];\n    permissions : (int * bool[,]) list;\n    upperClues : int[];\n    rightClues : int[];\n    lowerClues : int[];\n    leftClues : int[]}\n\nlet createData (clues : int[]) = \n\n    let side = clues.Length \/ 4\n\n    let initialHeights = initialMatrix 0 side\n\n    let permissionMatrices =\n        [1..side]\n        |> List.map (fun height -> (height, initialMatrix true side))\n\n    {   heights = initialHeights; \n        permissions = permissionMatrices; \n        upperClues = clues.[0 .. side - 1]; \/\/Array.zeroCreate side; \n        rightClues = clues.[side .. 2*side - 1]; \/\/Array.zeroCreate side; \n        lowerClues = clues.[2*side .. 3*side - 1] |> Array.rev; \n        leftClues = clues.[3*side.. ] |> Array.rev}\n\n\/\/ permissions\n\ntype heightsData = {\n    matrix : int[,];\n    row : int;\n    column : int;\n    sideLength : int;\n    }\n\nlet cellIsFree heightsData = \n    heightsData.matrix.[heightsData.row,heightsData.column] = 0\n\nlet row heightsData =\n\n    let rowIndex = heightsData.row\n\n    [0..heightsData.sideLength - 1]\n    |> List.map (fun column -> heightsData.matrix.[rowIndex, column])\n\nlet rowFrom (matrix : 'a[,]) rowIndex length = \n    [0..length - 1]\n    |> List.map (fun column -> matrix.[rowIndex, column])\n\nlet columnFrom (matrix : 'a[,]) columnIndex length = \n    [0..length - 1]\n    |> List.map (fun row -> matrix.[row, columnIndex])\n\nlet column heightsData =\n\n    let columnIndex = heightsData.column\n\n    [0..heightsData.sideLength - 1]\n    |> List.map (fun row -> heightsData.matrix.[row, columnIndex])\n\nlet rowContains heightsData height = \n    row heightsData\n    |> List.exists (fun x -> x = height)\n\nlet columnContains heightsData height = \n    column heightsData\n    |> List.exists (fun x -> x = height)\n\nlet knownPositionsFrom = \n    List.map (fun x -> \n        match x with\n            |_ when x = 0 -> None\n            |x -> Some(x))\n\nlet meetsClue order clue (row : int list) position height =\n\n    if clue = 0 then true else\n\n    let set = [1 .. row.Length]\n    let permutationsVisibility = \n        permuteFor set height position <| knownPositionsFrom row\n        |> List.map (fun x -> visibility order x = clue)\n    \n    if permutationsVisibility |> List.length = 0 then \n        false\n    else\n        permutationsVisibility\n        |> List.reduce (||)\n\nlet meetsClueInRow order heightsData (clues : int[]) height =\n    meetsClue \n    <| order \n    <| clues.[heightsData.row] \n    <| row heightsData\n    <| heightsData.column\n    <| height\n\nlet meetsClueInColumn order heightsData (clues : int[]) height =\n    meetsClue \n    <| order \n    <| clues.[heightsData.column] \n    <| column heightsData\n    <| heightsData.row\n    <| height\n\nlet updatePermissions (data : fieldData) (height : int) = \n    \/\/data.permissions.[height - 1]\n\n    let height, permissions = data.permissions.[height - 1]\n    let sideLength = data.heights |> Array2D.length1\n\n    let newPermissions = \n        [| for i in 0 .. sideLength - 1 do\n            for j in 0 .. sideLength - 1 do\n\n                let heightsData = {\n                    matrix = data.heights; \n                    row = i; \n                    column = j; \n                    sideLength = data.heights|> Array2D.length1}\n                \n                yield \n                    permissions.[i,j] \n                    && cellIsFree heightsData \n                    && not <| rowContains heightsData height \n                    && not <| columnContains heightsData height \n                    && meetsClueInRow leftToRight heightsData data.leftClues height\n                    && meetsClueInRow rightToLeft heightsData data.rightClues height\n                    && meetsClueInColumn upToDown heightsData data.upperClues height\n                    && meetsClueInColumn downToUp heightsData data.lowerClues height\n        |]\n        |> Array.chunkBySize sideLength\n        |> array2D\n    \n    (height, newPermissions)\n\n\n\/\/ heights\n\n\/\/let array = [false; false; true; false; false; true ]\nlet exclude i (array : bool list) = \n    List.concat [ \n        array.[0.. i - 1]; \n        array.[i + 1 ..] ]\n\nlet isOnlyFreePlaceIn index (row : bool list) =\n    row\n    |> exclude index\n    |> List.forall(fun x -> not x)\n\nlet (|IsOnlyInRow|IsOnlyInColumn|ManyOptions|) (permissions, i, j, sideLength) =\n    if \n        rowFrom permissions i sideLength \n        |> isOnlyFreePlaceIn j\n        && permissions.[i,j]\n        then\n            IsOnlyInRow\n    elif \n        columnFrom permissions j sideLength\n        |> isOnlyFreePlaceIn i\n        && permissions.[i,j]\n        then\n            IsOnlyInColumn\n\n    else\n        ManyOptions\n\nlet updateHeights (data : fieldData) (height : int) =\n\n    let sideLength = data.heights |> Array2D.length1\n    let _, permissions = data.permissions.[height - 1]\n\n    [| for i in 0 .. sideLength - 1 do\n        for j in 0 .. sideLength - 1 do\n\n            match (permissions, i, j, sideLength) with\n            |IsOnlyInRow -> yield height\n            |IsOnlyInColumn -> yield height\n            |_ -> yield data.heights.[i, j]\n    |]\n    |> Array.chunkBySize sideLength\n    |> array2D\n\nlet updateHeights' (data : fieldData) = \n    \n    [1..data.permissions |> List.length]\n    |> List.fold (fun lastHeigts x -> updateHeights {data with heights = lastHeigts} x) data.heights\n\n\n\/\/ full update\n\nlet update (data : fieldData) : fieldData = \n\n    let newPermissions = \n        data.permissions \n        |> List.map (fun (height, _) -> updatePermissions data height)\n\n    let newHeights = updateHeights' { data with permissions = newPermissions }\n\n    \/\/let newHeights = \n    \/\/    data.heights\n    \/\/    |> Array2D.length1\n    \/\/    |> initialMatrix 1 \n\n    { data with heights = newHeights; permissions = newPermissions }\n\nlet isFilled (matrix : int[,]) =\n    matrix\n    |> Seq.cast\n    |> Seq.forall (fun item -> item <> 0) \n\nlet rec solve (data : fieldData) = \n    \n    match data.heights with\n    | x when x |> isFilled -> x\n    | _ -> \n        data\n        |> update\n        |> solve\n\nlet array2dToJagged (arr : 'a[,]) =\n\n    let sideLength = Array2D.length1 arr;\n\n    arr\n    |> Seq.cast<int>\n    |> Array.ofSeq\n    |> Array.chunkBySize sideLength\n\n\/\/ main\nlet solve_puzzle (clues : int[]) : int[][] =\n    \n    createData clues\n    |> solve\n    |> array2dToJagged\n\n\n\/\/ test\n\nlet sampleMatrix = \n    array2D [| \n        [|  0;  1;  2;  3 |]; \n        [|  4;  5;  6;  7 |]; \n        [|  8;  9; 10; 11 |]; \n        [| 12; 13; 14; 15 |] |]\n\nlet sampleMatrixNotFilled =\n    array2D [|\n        [| 1; 4; 2; 0 |]\n        [| 0; 0; 0; 0 |] \n        [| 2; 3; 0; 1 |] \n        [| 0; 1; 0; 0 |] |]\n\nlet (permissions1 : bool[,]) =\n    array2D [|\n        [| false; false; false; false; |] \n        [| false; false; true;  false; |] \n        [| false; false; false; false; |] \n        [| false; false; false; false; |] |]\n\nlet permissions2 =\n    array2D [|\n        [| false; false; false; false; |] \n        [| false; true;  false; true;  |] \n        [| false; false; false; false; |] \n        [| false; false; false; true;  |] |]\n\nlet permissions3 =\n    array2D [|\n        [| false; false; false; true;  |] \n        [| true;  false; true;  true;  |] \n        [| false; false; false;  false; |] \n        [| true;  false; true;  true;  |] |]\n        \nlet permissions4 =\n    array2D [|\n        [| false; false; false; false;  |] \n        [| true;  false; true;  true;  |] \n        [| false; false; true;  false; |] \n        [| true;  false; true;  true;  |] |]\n\nlet samplePermissions4 = [\n    (1, initialMatrix true 4);\n    (2, initialMatrix true 4);\n    (3, initialMatrix true 4);\n    (4, initialMatrix true 4)\n    ]\n\nlet sampleUnfilledData = { \n    heights = sampleMatrixNotFilled; \n    permissions = samplePermissions4\n    upperClues = [|0; 0; 0; 0; |]; \n    rightClues = [|0; 0; 0; 0; |]; \n    lowerClues = [|0; 0; 0; 0; |]; \n    leftClues =  [|0; 0; 0; 0; |] }\n\nlet emptyDataWithEmptyClues = {\n    heights = Array2D.create 4 4 0\n    permissions = samplePermissions4\n    upperClues = Array.create 4 0;\n    rightClues = Array.create 4 0;\n    lowerClues = Array.create 4 0;\n    leftClues = Array.create 4 0; }\n\nlet permissionsFilled = array2D [\n    [ true; true;  true;  false; ];\n    [ true; true;  false; false; ];\n    [ true; false; false; false; ];\n    [ true; true;  false; true;  ] ]\n    \nlet successiveClues = [|1..4|]\n\nlet samplePermissionsFilled = \n    [1..4]\n    |> List.map (fun x -> (x, permissionsFilled))\n\nlet permissionsTestData = {\n    heights = Array2D.create 4 4 0;\n    permissions = samplePermissionsFilled;\n    upperClues = successiveClues;\n    rightClues = successiveClues;\n    lowerClues = successiveClues;\n    leftClues = successiveClues;\n    }\n\nlet emptyDataWithRightClues = {\n    emptyDataWithEmptyClues with rightClues = successiveClues }\n\nlet emptyDataWithLeftClues = {\n    emptyDataWithEmptyClues with leftClues = successiveClues }\n\nlet emptyDataWithUpperClues = {\n    emptyDataWithEmptyClues with upperClues = successiveClues }\n\nlet emptyDataWithLowerClues = {\n    emptyDataWithEmptyClues with lowerClues = successiveClues }\n\nlet permissionsTestNoClues() =\n\n    updatePermissions sampleUnfilledData 1 = (1, permissions1) && \n        updatePermissions sampleUnfilledData 2 = (2, permissions2) && \n        updatePermissions sampleUnfilledData 3 = (3, permissions3) && \n        updatePermissions sampleUnfilledData 4 = (4, permissions4)\n\nlet emptyClues : int[] = Array.zeroCreate 16\n\nlet exampleClues = [| 0; 0; 1; 2; 0; 2; 0; 0; 0; 3; 0; 0; 0; 1; 0; 0 |]\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85085,"user_id":null,"body":"\/\/ http:\/\/www.fssnip.net\/4u\/title\/Very-Fast-Permutations\nlet rec permutations = function\n   | []      -> seq [List.empty]\n   | x :: xs -> Seq.collect (insertions x) (permutations xs)\nand insertions x = function\n   | []             -> [[x]]\n   | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\nlet permutes numSkyscrapersPerLine = (permutations [1..numSkyscrapersPerLine]) |> Seq.map (fun x -> List.toArray x) |> Seq.toArray\n\nlet skycrapersSeen ls =\n    ls\n    |> Array.fold (fun (numSeen, biggestSeen) skyscraper -> \n        if skyscraper > biggestSeen then (numSeen + 1, skyscraper) else (numSeen, biggestSeen)) (0,0)\n    |> fst\n\nlet allSkyscraperPermutations numSkyscrapersPerLine numberToSee =\n    permutes numSkyscrapersPerLine\n    |> Array.filter (skycrapersSeen >> ((=) numberToSee))\n\nlet equals ls ls2 = Array.compareWith (fun x y -> if x > y then 1 elif x < y then -1 else 0) ls ls2 = 0\n\nlet applyAt i array func =\n    array |> Array.mapi (fun j element -> if i = j then func element else element)\n\nlet union ls ls2 =\n    ls\n    |> Array.filter (fun element -> (ls2 |> Array.exists (fun element2 -> equals element element2)))\n\nlet findCluePosibilities numSkyscrapersPerLine skyscrapersToSee = \n    match skyscrapersToSee with\n    | skyscrapersToSee when skyscrapersToSee > 0 && skyscrapersToSee <= numSkyscrapersPerLine \n        -> allSkyscraperPermutations numSkyscrapersPerLine skyscrapersToSee\n    | _ -> invalidArg \"clue\" (sprintf \"Clue has to be within [1..%d]\" numSkyscrapersPerLine)\n\nlet applyClue numSkyscrapersPerLine (clue : int) (shouldReverse : bool) (current : int[][]) =\n    if (clue = 0) then\n        current\n    else\n        let allowedPosibilities =\n            match shouldReverse with\n            | true -> findCluePosibilities numSkyscrapersPerLine clue |> Array.map Array.rev\n            | false -> findCluePosibilities numSkyscrapersPerLine clue\n        union current allowedPosibilities\n\nlet applyClueOnRow numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newRows = applyAt i rows (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (newRows, columns)\n\nlet applyClueOnColumn numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newColumns = applyAt i columns (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (rows, newColumns)\n\nlet applyClueIndex numSkyscrapersPerLine rowsAndColumns (clueIndex, clue) =\n    match clueIndex with\n    | c when numSkyscrapersPerLine * 0 <= c && c < numSkyscrapersPerLine * 1 -> applyClueOnColumn numSkyscrapersPerLine clue false c rowsAndColumns\n    | c when numSkyscrapersPerLine * 1 <= c && c < numSkyscrapersPerLine * 2 -> applyClueOnRow numSkyscrapersPerLine clue true (c - numSkyscrapersPerLine) rowsAndColumns\n    | c when numSkyscrapersPerLine * 2 <= c && c < numSkyscrapersPerLine * 3 -> applyClueOnColumn numSkyscrapersPerLine clue true (abs (c - numSkyscrapersPerLine * 3) - 1) rowsAndColumns\n    | c when numSkyscrapersPerLine * 3 <= c && c < numSkyscrapersPerLine * 4 -> applyClueOnRow numSkyscrapersPerLine clue false (abs (c - numSkyscrapersPerLine * 4) - 1) rowsAndColumns\n    | _ -> invalidArg \"clueIndex\" (sprintf \"Incorrent clue index: %d\" clueIndex)\n\nlet applyClues numSkyscrapersPerLine (clues : int []) (rowsAndColumns : int [][][] * int [][][]) : int [][][] * int [][][] =\n    clues\n    |> Array.mapi (fun i x -> (i, x))\n    |> Array.fold (applyClueIndex numSkyscrapersPerLine) rowsAndColumns\n\nlet removeSubArraysMatchingElementsAt i illigalElements (array : int[][]) = \n    array |> Array.filter (fun posibility -> not (illigalElements |> Set.contains posibility.[i]))\n\nlet removeSkypscraperUnionRowAndColumn (rows : int [][][], columns : int [][][]) (i, j) = \n    let skyscraperPosibilitiesFromRow = rows.[i] |> Array.map (fun row -> row.[j]) |> Array.distinct\n    let skyscraperPosibilitiesFromColumn = columns.[j] |> Array.map (fun column -> column.[i]) |> Array.distinct\n    let removeSkyscrapersFromRow = Set.ofArray skyscraperPosibilitiesFromRow - (Set.ofArray skyscraperPosibilitiesFromColumn)\n    let removeSkyscrapersFromColumn = Set.ofArray skyscraperPosibilitiesFromColumn - (Set.ofArray skyscraperPosibilitiesFromRow)\n    let updatedColumns = applyAt j columns (removeSubArraysMatchingElementsAt i removeSkyscrapersFromColumn)\n    let updatedRows = applyAt i rows (removeSubArraysMatchingElementsAt j removeSkyscrapersFromRow)\n    (updatedRows, updatedColumns)\n\nlet removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns = \n    [|0..numSkyscrapersPerLine - 1|]\n    |> Array.map (fun i -> [|0..numSkyscrapersPerLine - 1|]\n                           |> Array.map (fun j -> (i, j)))\n    |> Array.concat\n    |> Array.fold (removeSkypscraperUnionRowAndColumn) rowsAndColumns\n\nlet isFinal (rows, _) = \n    rows\n    |> Array.map (fun row -> Seq.length row = 1)\n    |> Array.reduce (&&)\n\nlet rec applyUnionRule numSkyscrapersPerLine rowsAndColumns = \n    match isFinal rowsAndColumns with\n    | true -> rowsAndColumns\n    | false -> applyUnionRule numSkyscrapersPerLine (removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns)\n\nlet solve_puzzle (clues : int[]) =\n    let numSkyscrapersPerLine = 4\n    let rowsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n    let columnsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n\n    let cluesApplied = applyClues numSkyscrapersPerLine clues (rowsAllPosibilities, columnsAllPosibilities)\n    let (finalRow, _) = applyUnionRule numSkyscrapersPerLine cluesApplied\n    finalRow |> Array.concat","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85086,"user_id":null,"body":"let N = 4\n\nlet rec combinations acc fits range remains = seq {\n    if remains = 0\n    then yield acc\n    else\n        for candidate in range do\n            if fits acc candidate\n            then yield! combinations (candidate :: acc) fits range (remains - 1) }\n\nlet permutations =\n    combinations [] (fun acc x -> acc |> List.forall ((<>) x)) [1 .. N] N;;\n\nlet visibleCount =\n    fst << List.fold (fun (count, lastMax) cur -> if cur > lastMax then (count + 1, cur) else (count, lastMax)) (0, 0)\n\nlet optionsByVisibleCount =\n    let ps = permutations |> List.ofSeq\n    ps\n    |> List.groupBy visibleCount\n    |> Seq.append [(0, ps)]\n    |> Map.ofSeq\n\nlet optionFitsMask mask =\n    Seq.zip mask >> Seq.forall (fun (mv, v) -> mv |> Set.contains v)\n\n\/\/let optionsToMask = List.transpose >> (List.map Set.ofList)\nlet optionsToMask options =\n    \/\/ F# 4.1 doesn't have List.transpose :( reinventing the wheel\n    [0 .. N - 1]\n    |> List.map ((fun i -> options |> List.map (List.item i)) >> Set.ofList)\n\nlet rec refine (clues : int[]) lastField =\n    \n    \/\/ some local statefulness\n    let currentField = Array2D.copy lastField\n\n    let applyOptionsMask m x y =\n        let curMask = currentField.[y, x]\n        let newMask = Set.intersect curMask m\n        currentField.[y, x] <- newMask\n\n    let refinedOptionsMask clueIdx fieldSliceMask =\n        optionsByVisibleCount\n        |> Map.find clues.[clueIdx]\n        |> List.filter (optionFitsMask fieldSliceMask)\n        |> optionsToMask\n\n    \/\/ TODO: simplify this \/ get rid of duplicate code.\n    for i in 0 .. N-1 do\n        \/\/ top clue\n        refinedOptionsMask i currentField.[*, i]\n        |> Seq.iteri(fun j m -> applyOptionsMask m i j)\n        \n        \/\/ right clue\n        refinedOptionsMask (i+N) (currentField.[i, *] |> Array.rev)\n        |> Seq.iteri(fun j m -> applyOptionsMask m (N-1-j) i)\n\n        \/\/ bottom clue\n        refinedOptionsMask (i + 2*N) (currentField.[*, N-1-i] |> Array.rev)\n        |> Seq.iteri(fun j m -> applyOptionsMask m (N-1-i) (N-1-j))\n\n        \/\/ left clue\n        refinedOptionsMask (i + 3*N) currentField.[N-1-i, *]\n        |> Seq.iteri(fun j m -> applyOptionsMask m j (N-1-i))\n    \n    \/\/ stop if this refinement yielded no solutions\n    if currentField = lastField\n    then lastField\n    else refine clues currentField\n\nlet solve_puzzle (clues : int[]) : int[][] =\n    \/\/ start guessing with full uncertainty\n    let initialGuess = List.replicate N (Set.ofList [1 .. N] |> List.replicate N) |> array2D\n    let solution = \n        initialGuess\n        |> refine clues \n        |> Array2D.map Seq.exactlyOne\n    \/\/ convert to jagged array to satisfy test suite\n    [| for i in 0 .. (Array2D.length1 solution) - 1 do yield solution.[i, *] |]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85087,"user_id":null,"body":"let solve_puzzle (clues : int[]) : int[][] =\n        let checkLine n (line: int list)  = \n            if (set line).Count <> 4 then false \n            elif n = 0 then true else\n            let mutable v = 0\n            let mutable count = 0\n            for x in line do\n                if x > v then v <- x; count <- count + 1\n            count = n\n\n        let filterLines (variances: int[][]) n = \n            let rec getPossible index state = \n                if index = 4 then [state] else\n                [ for x in variances.[index] do\n                    yield! getPossible (index + 1) (state @ [x]) |> List.filter (checkLine n)]\n\n            getPossible 0 [] |> List.map List.toArray |> List.toArray\n\n        let variance (lines: int[][]) = \n            let elements = Array.init 4 (fun _ -> ResizeArray())\n            for line in lines do\n                for i = 0 to 3 do elements.[i].Add(line.[i])\n            elements |> Array.map(set >> Seq.toArray)\n\n        let column i (matrix: _[][]) = \n            [| for n = 0 to 3 do yield matrix.[n].[i] |]\n\n        let setColumn i (matrix: _[][]) (vector: _[]) = \n            vector |> Array.iteri(fun n v -> matrix.[n].[i] <- v)\n\n        let visibleVector i (matrix: _[][]) = \n            match i \/ 4 with\n            | 0 -> column i matrix\n            | 1 -> matrix.[i - 4] |> Array.rev\n            | 2 -> column (11 - i) matrix |> Array.rev\n            | _ -> matrix.[15 - i]\n\n        let setVisibleVector i (matrix: _[][]) vector = \n            match i \/ 4 with\n            | 0 -> setColumn i matrix vector\n            | 1 -> matrix.[i - 4] <- vector |> Array.rev\n            | 2 -> vector |> Array.rev |> setColumn (11 - i) matrix \n            | _ -> matrix.[15 - i] <- vector\n            \/\/matrix\n\n        let setClue (matrix: _[][]) i clue = \n            let vector = visibleVector i matrix\n            let lines = filterLines vector clue\n            let variance = variance lines\n            setVisibleVector i matrix variance\n\n        let isDefined (matrix: int[][][]) = \n            matrix |> Array.forall(Array.forall(fun x -> Array.length x = 1))\n\n        let define = Array.map(Array.map(Array.head))\n\n        let variances = Array.init 4 (fun _ -> Array.init 4 (fun _ -> [|1..4|]))\n\n        while isDefined variances |> not do\n            clues |> Array.iteri (setClue variances)\n\n        define variances\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85088,"user_id":null,"body":"type ClueValue = Value of int\n\ntype VerticalEdge =\n    | Left\n    | Right\n\ntype HorizontalEdge =\n    | Top\n    | Bottom\n\ntype ClueKey =\n    | Row of VerticalEdge * int\n    | Column of HorizontalEdge * int\n\nlet toSeq (a: (int * int list) [,]) =\n    seq {\n        for r in 0 .. 3 do\n            for c in 0 .. 3 do\n                yield a.[r, c]\n    }\n\nlet indices =\n    seq {\n        for r in 0 .. 3 do\n            for c in 0 .. 3 do\n                yield (r, c)\n    }\n\nlet isConstraintSatisfied key (Value v) (a: (int * int list) [,]) =\n    let visibility current highest count =\n        if highest < current then (current, count + 1) else (highest, count)\n\n    match key with\n    | Row(edge, rowN) ->\n        let row = a.[rowN, *]\n        match edge with\n        | Left ->\n            let (_, c) =\n                row |> Seq.fold (fun (highest, count) (current, _) -> visibility current highest count) (0, 0)\n            c = v\n        | Right ->\n            let (_, c) =\n                Seq.foldBack (fun (current, _) (highest, count) -> visibility current highest count) row (0, 0)\n            c = v\n    | Column(edge, colN) ->\n        let column = a.[*, colN]\n        match edge with\n        | Top ->\n            let (_, c) =\n                column |> Seq.fold (fun (highest, count) (current, _) -> visibility current highest count) (0, 0)\n            c = v\n        | Bottom ->\n            let (_, c) =\n                Seq.foldBack (fun (current, _) (highest, count) -> visibility current highest count) column (0, 0)\n            c = v\n\nlet allCluesSatisifed clues (a: (int * int list) [,]) =\n    let allFieldsFilled =\n        indices\n        |> Seq.forall (fun (r,c) -> (a.[r,c] |> fst) > 0)\n\n    let cluesSatisifed =\n        clues\n        |> Map.toSeq\n        |> Seq.forall (fun (k, v) -> (a |> (isConstraintSatisfied k v)))\n\n    allFieldsFilled && cluesSatisifed\n\nlet rec propagateConstraints (a: (int * int list) [,]) =\n    { 0 .. 3 }\n    |> Seq.iter (fun r ->\n        let usedValues =\n            a.[r, *]\n            |> Seq.map (fun (v, _) -> v)\n            |> List.ofSeq\n        { 0 .. 3 }\n        |> Seq.iter (fun c ->\n            let (v, options) = a.[r, c]\n            if v = 0 then a.[r, c] <- (0, options |> List.except usedValues)))\n\n    { 0 .. 3 }\n    |> Seq.iter (fun c ->\n        let usedValues =\n            a.[*, c]\n            |> Seq.map (fun (v, _) -> v)\n            |> List.ofSeq\n        { 0 .. 3 }\n        |> Seq.iter (fun r ->\n            let (v, options) = a.[r, c]\n            if v = 0 then a.[r, c] <- (0, options |> List.except usedValues)))\n\n    let oneCandidateOnly =\n        indices\n        |> Seq.tryFind (fun (r, c) ->\n            let (v, options) = a.[r, c]\n            v = 0 && options.Length = 1)\n\n    match oneCandidateOnly with\n    | Some(r, c) ->\n        let (_, options) = a.[r, c]\n        a.[r, c] <- (options.Head, options)\n        a |> propagateConstraints\n    | None -> ()\n\nlet rec solve clues (a: (int * int list) [,]) =\n    a |> propagateConstraints\n\n    let allSatisfied = a |> allCluesSatisifed clues\n\n    match allSatisfied with\n    | true -> Some a\n    | false ->\n        let candiate =\n            indices\n            |> Seq.filter (fun (r, c) ->\n                a.[r, c]\n                |> snd\n                |> Seq.length > 1)\n            |> Seq.tryHead\n\n        match candiate with\n        | None -> None\n        | Some(r, c) ->\n            let valueToSet =\n                a.[r, c]\n                |> snd\n                |> Seq.head\n\n            let a' = a.[*, *]\n            a'.[r, c] <- (valueToSet, [ valueToSet ])\n            let y = a' |> solve clues\n\n            \/\/ this is the key part\n            \/\/ if valueToSet lead to a solution, we have a solution\n            \/\/ if not, we remove valueToSet from the candidates in A\n            \/\/ this means that with each recursion we strengthen constraints on the system\n            match y with\n            | None ->\n                a.[r, c] <- (0,\n                             a.[r, c]\n                             |> snd\n                             |> List.except [ valueToSet ])\n                solve clues a\n            | Some s -> Some s\n\nlet solve_puzzle (clues: int []): int [] [] =\n    let c =\n        clues\n        |> Seq.indexed\n        |> Seq.map (fun (i, v) ->\n            match i \/ 4 with\n            | 0 -> (Column(Top, i), Value v)\n            | 1 -> (Row(Right, i % 4), Value v)\n            | 2 -> (Column(Bottom, 3 - i % 4), Value v)\n            | 3 -> (Row(Left, 3 - i % 4), Value v))\n        |> Seq.filter (fun (_, (Value v)) -> v <> 0)\n        |> Map.ofSeq\n\n    let a = Array2D.init 4 4 (fun _ _ -> (0, [ 1; 2; 3; 4 ]))\n\n    let solved = a |> solve c\n\n    match solved with\n    | None -> failwith \"Impossibru\"\n    | Some a ->\n        { 0 .. 3 }\n        |> Seq.map (fun r ->\n            a.[r, *]\n            |> Seq.cast<int * int list>\n            |> Seq.map (fun (v, _) -> v)\n            |> Array.ofSeq)\n        |> Array.ofSeq","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5672682212c8ecf83e000050":[{"id":85089,"user_id":null,"body":"open System.Collections.Generic\n\nlet dbl_linear (n: int) =\n    let lst = SortedSet<int>()\n    lst.Add(1) |> ignore\n\n    let rec gen (lst : SortedSet<int>) = seq {\n       let x = lst.Min;\n       \n       yield x\n\n       lst.Remove(x) |> ignore\n       lst.Add(2 * x + 1) |> ignore\n       lst.Add(3 * x + 1) |> ignore\n\n       yield! gen lst\n    }\n  \n    (gen lst) |> Seq.item n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85090,"user_id":492,"body":"open System.Collections.Generic\n\nlet dbl_linear (n: int) =\n    let deque2 = new Queue<int>()\n    let deque3 = new Queue<int>()\n    let mutable cnt = 0\n    let mutable h: int = 1\n    let mutable cont = true\n    while cont do\n        if (cnt >= n) then \n            cont <- false\n        else\n            deque2.Enqueue(2 * h + 1); deque3.Enqueue(3 * h + 1)\n            h <- min (deque2.Peek()) (deque3.Peek())\n            if (h = deque2.Peek()) then\n                deque2.Dequeue() |> ignore\n            if (h = deque3.Peek()) then\n                deque3.Dequeue() |> ignore\n            cnt <- cnt + 1\n    h","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85091,"user_id":492,"body":"open System.Collections.Generic\n\nlet dbl_linear (n: int) =\n    let deque2 = new Queue<int>()\n    let deque3 = new Queue<int>()\n    let mutable cnt = 0\n    let mutable h: int = 1\n    let mutable cont = true\n    while cont do\n        if (cnt >= n) then \n            cont <- false\n        else\n            deque2.Enqueue(2 * h + 1); deque3.Enqueue(3 * h + 1)\n            h <- min (deque2.Peek()) (deque3.Peek())\n            if (h = deque2.Peek()) then\n                deque2.Dequeue() |> ignore\n            if (h = deque3.Peek()) then\n                deque3.Dequeue() |> ignore\n            cnt <- cnt + 1\n    h","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85092,"user_id":null,"body":"let dbl_linear n =\n  let rec dbl_linearRec n set =\n    let m = Set.minElement set\n    if n=0 then m\n    else dbl_linearRec (n-1) (set.Remove(m).Add(m*2+1).Add(m*3+1))\n  dbl_linearRec n (Set.singleton(1))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85093,"user_id":null,"body":"open System.Linq\nlet dbl_linear (n: int) =\n    let seen = System.Collections.Generic.SortedSet<int>()\n    seen.Add(1) |> ignore\n\n    for _ in [ 1..n ] do\n        let current = seen.First()\n        seen.Remove(current) |> ignore\n        seen.Add(2 * current + 1) |> ignore\n        seen.Add(3 * current + 1) |> ignore\n\n    seen.First()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85094,"user_id":null,"body":"let dbl_linear (n: int) =\n    let rec cycle (existingNumbers: int seq) (numbers: int seq) (rep: int) =\n        if rep = 0 then Seq.append numbers existingNumbers else \n        let newNumbers =\n            numbers\n            |> Seq.map(fun x -> [2 * x + 1; 3 * x + 1])\n            |> Seq.concat\n\n        cycle (Seq.append existingNumbers numbers) newNumbers (rep - 1)\n\n    let num = n - 1 |> float\n    let rep = System.Math.Log(num, 2.0) + 3.0 |> int\n\n    let finalNumbers = \n        cycle Seq.empty {1..1} rep\n        |> Seq.sort\n        |> Seq.distinct\n        |> Seq.toList\n\n    finalNumbers.[n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85095,"user_id":null,"body":"let rec list =\n    seq {\n      yield 1L\n      for x in list do\n        yield 2L * x + 1L\n        yield 3L * x + 1L\n    }\n    |> Seq.distinct\n    |> Seq.cache\n\nlet dbl_linear (n: int) =\n  list\n  |> Seq.take (10*n)\n  |> Seq.sort\n  |> Seq.item (n)\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85096,"user_id":53,"body":"open System\nopen System.Collections.Generic\n\nlet dbl_linear (n: int) =\n  let mutable u = new List<int>()\n  let mutable x = 0\n  let mutable y = 0\n  u.Add(1)\n  for i in 1 .. n do\n    u.Add(Math.Min(2 * u.[x] + 1, 3 * u.[y] + 1))\n    if (u.[i] = 2 * u.[x] + 1) then x <- x + 1 else x <- x\n    if (u.[i] = 3 * u.[y] + 1) then y <- y + 1 else y <- y\n  u.[n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85097,"user_id":null,"body":"let dbl_linear (n: int) =\n  let rec go q n' =\n    if n' = 0 then Set.minElement q\n    else\n    \n      let cur = Set.minElement q\n      let q' = \n        q\n        |> Set.remove cur\n        |> Set.add (2 * cur + 1)\n        |> Set.add (3 * cur + 1)\n     \n      go q' (n' - 1)\n    \n  go (Set.ofList [1]) n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85098,"user_id":168,"body":"let dbl_linear (n: int) =\n  { 1 .. n }\n  |> Seq.fold (fun s _ ->\n      let x = Set.minElement s\n      Set.remove x s\n      |> Set.add (2 * x + 1)\n      |> Set.add (3 * x + 1))\n    (Set.singleton 1)\n  |> Set.minElement\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56747fd5cb988479af000028":[{"id":85099,"user_id":null,"body":"let get_middle (str : string) =\n   let len = String.length str\n   match len%2 with \n   | 0 -> str.[len\/2-1 .. len\/2]\n   | _ -> str.[len\/2].ToString()\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85100,"user_id":null,"body":"let get_middle (str: string) = str.[(str.Length-1)\/2..str.Length\/2]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85101,"user_id":null,"body":"\nlet rec get_middle (str : string) =\n  if str.Length <= 2 then  str  \n  else \n    get_middle(str.[1..str.Length-2])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85102,"user_id":null,"body":"let get_middle (str : string) = match str with\n                                     | str when str.Length % 2 = 0 -> let half = str.Length \/ 2\n                                                                      str.[half-1..half]\n                                     | _ -> str.[str.Length \/ 2].ToString()\n\n        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85103,"user_id":null,"body":"let get_middle (str : string) =\n    str\n    |> Seq.skip(ceil(float(str.Length)\/2.) - 1. |> int)\n    |> Seq.take (if str.Length % 2 = 0 then 2 else 1)\n    |> Seq.map string |> Seq.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85104,"user_id":null,"body":"let get_middle (str: string) =\n    let t = (str.Length - 1 |> double) \/ 2.0\n\n    Set.empty\n    |> Set.add (floor t)\n    |> Set.add (ceil t)\n    |> Set.fold (fun a i -> a + string str.[int i]) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85105,"user_id":null,"body":"let get_middle (str : string) =\n  let middle = str.Length \/ 2\n  let count = 1 - (str.Length % 2)\n  str.[(middle-count)..middle]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85106,"user_id":null,"body":"let get_middle (str : string) =\n let indexSize= str.Length\/2\n if not(str.Length%2=0) then str.ToCharArray().[indexSize].ToString() else \n str.ToCharArray().[indexSize-1].ToString()+str.ToCharArray().[indexSize].ToString()\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85107,"user_id":null,"body":"let get_middle (str : string) =\n  let len= str |> String.length\n  match len%2=0 with\n  |true ->  string(str.[int(len\/2)-1])+string(str.[int(len\/2)])\n  |false -> string<|str.[int(len\/2)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85108,"user_id":null,"body":"open System\n\nlet get_middle (str : string) =\n    let length = String.length str\n    let half = length \/ 2\n    seq {\n        if length % 2 = 0 then\n            yield str.[half - 1]\n    \n        yield str.[half]\n    }\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"567501aec64b81e252000003":[{"id":85109,"user_id":492,"body":"let wallPaper(l: float, w: float, h: float) =\n    let t = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\";\n         \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n         \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\";\n         \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"]\n    if (l = 0.0 || w = 0.0 || h = 0.0) then\n        t.[0]\n    else\n        let k = (((l + w) * 2.0 * h) \/ 5.2) * 1.15\n        t.[int(ceil k)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85110,"user_id":null,"body":"let [<Literal>] RollWidth = 0.52\nlet [<Literal>] RollLength = 10.\nlet [<Literal>] Wastage = 0.15\n\nlet wallPaper =\n    let cardinalNumbers = [|\n        \"zero\"   ; \"one\"    ; \"two\"      ; \"three\"   ; \"four\"\n        \"five\"   ; \"six\"    ; \"seven\"    ; \"eight\"   ; \"nine\"\n        \"ten\"    ; \"eleven\" ; \"twelve\"   ; \"thirteen\"; \"fourteen\"\n        \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"\n        \"twenty\"\n    |]\n\n    let rollArea = RollWidth * RollLength\n\n    fun (l, w, h) ->\n        let totalWallArea = if l = 0. || w = 0. then 0. else 2. * (l + w) * h\n        let rolls = ceil ((1. + Wastage) * totalWallArea \/ rollArea)\n        cardinalNumbers.[int rolls]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85111,"user_id":null,"body":"let [<Literal>] RollWidth = 0.52\nlet [<Literal>] RollLength = 10.\nlet [<Literal>] Wastage = 0.15\n\nlet cardinalNumbers = [|\n    \"zero\"   ; \"one\"    ; \"two\"      ; \"three\"   ; \"four\"\n    \"five\"   ; \"six\"    ; \"seven\"    ; \"eight\"   ; \"nine\"\n    \"ten\"    ; \"eleven\" ; \"twelve\"   ; \"thirteen\"; \"fourteen\"\n    \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"\n    \"twenty\"\n|]\n\nlet wallPaper (l: float, w: float, h: float) =\n    let rollArea = RollWidth * RollLength\n    let totalWallArea = if l = 0. || w = 0. then 0. else 2. * (l + w) * h\n    let rolls = ceil ((1. + Wastage) * totalWallArea \/ rollArea)\n    cardinalNumbers.[int rolls]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85112,"user_id":492,"body":"let wallPaper(l: float, w: float, h: float) =\n    let t = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\";\n         \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n         \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\";\n         \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"]\n    if (l = 0.0 || w = 0.0 || h = 0.0) then\n        t.[0]\n    else\n        let k = (((l + w) * 2.0 * h) \/ 5.2) * 1.15\n        t.[int(ceil k)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85113,"user_id":null,"body":"let numbers = [|\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n               \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\";\n               \"nineteen\"; \"twenty\"|]\n\nlet wallPaper(l: float, w: float, h: float) =\n    let rolls = if l = 0.0 || w = 0.0 then 0\n                else\n                    let perimeter = 2.0 * (l + w)\n                    let area = perimeter * h\n                    let length = area \/ 0.52 * 1.15\n                    (length \/ 10.0) |> ceil |> int \n    numbers.[rolls]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85114,"user_id":53,"body":"let wallPaper(l: float, w: float, h: float) =\n  let ns = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n            \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"]\n  if (l * w * h = 0.0) then\n    ns.[0]\n  else\n    ns.[int(ceil(((l + w) * 2.3 * h) \/ 5.2))]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85115,"user_id":null,"body":"let numbers = [| \"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"eleven\"; \"twelve\";\"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\" |]\n\nlet computeRollCount l w h = \n  let totalAreaSize = ((w * h * 2.0) + (l * h * 2.0))\n  let rollCount = System.Math.Ceiling((totalAreaSize \/ 0.52 \/ 10.0) * 1.15)\n  rollCount\n\nlet getRollCountString l w h =\n  let rollCount = int (computeRollCount l w h)\n  numbers.[rollCount]\n\nlet wallPaper(l: float, w: float, h: float) =\n    let rollCountString = \n      if l <= 0.0 || w <= 0.0 || h <= 0.0 then \"zero\"\n      else getRollCountString l w h\n\n    rollCountString\n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85116,"user_id":null,"body":"open System\n\nlet numbers =\n    [| \"zero\"\n       \"one\"\n       \"two\"\n       \"three\"\n       \"four\"\n       \"five\"\n       \"six\"\n       \"seven\"\n       \"eight\"\n       \"nine\"\n       \"ten\"\n       \"eleven\"\n       \"twelve\"\n       \"thirteen\"\n       \"fourteen\"\n       \"fifteen\"\n       \"sixteen\"\n       \"seventeen\"\n       \"eighteen\"\n       \"nineteen\"\n       \"twenty\" |]\n\nlet wallPaper (l: float, w: float, h: float) =\n    if l * w * h = 0.0 then\n        \"zero\"\n    else\n        Math.Ceiling((l + w) * h * 2.0 * 1.15 \/ 5.2)\n        |> Convert.ToInt32\n        |> Array.get numbers","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85117,"user_id":null,"body":"let numbToWord (num: int) =\n  let numbWord = [\n   (0, \"zero\"); (1, \"one\"); (2, \"two\"); (3, \"three\"); (4, \"four\"); \n   (5, \"five\"); (6, \"six\"); (7, \"seven\"); (8, \"eight\"); (9, \"nine\");\n   (10, \"ten\"); (11, \"eleven\"); (12, \"twelve\"); (13, \"thirteen\"); (14, \"fourteen\");\n   (15, \"fifteen\"); (16, \"sixteen\"); (17, \"seventeen\"); (18, \"eighteen\"); (19, \"nineteen\");\n   (20, \"twenty\")] |> Map\n  \n  if (num > 20) then\n    failwith \"Big number\"\n  else\n    numbWord.[num]\n\nlet wallPaper(l: float, w: float, h: float) =\n    if (l <= 0.0 || w <= 0.0 || h <= 0.0) then\n      \"zero\"\n    else\n      ((2.0 * (l + w) * h) * 1.15 \/ 5.2) |> ceil |> int |> numbToWord","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85118,"user_id":null,"body":"let numberToWord =\n    function\n    | 0 -> \"zero\"\n    | 1 -> \"one\"\n    | 2 -> \"two\"\n    | 3 -> \"three\"\n    | 4 -> \"four\"\n    | 5 -> \"five\"\n    | 6 -> \"six\"\n    | 7 -> \"seven\"\n    | 8 -> \"eight\"\n    | 9 -> \"nine\"\n    | 10 -> \"ten\"\n    | 11 -> \"eleven\"\n    | 12 -> \"twelve\"\n    | 13 -> \"thirteen\"\n    | 14 -> \"fourteen\"\n    | 15 -> \"fifteen\"\n    | 16 -> \"sixteen\"\n    | 17 -> \"seventeen\"\n    | 18 -> \"eighteen\"\n    | 19 -> \"nineteen\"\n    | 20 -> \"twenty\"\n    | _ -> failwith \"unexpected digit\"\n\nlet wallPaper(l: float, w: float, h: float) =\n    if l * w * h = 0.0 then \"zero\"\n    else\n        let perimeter = 2. * l + 2. * w\n        let area = perimeter * h\n        let rollCount = area \/ (10.0 * 0.52) |> ((*) 1.15) |> ceil |> int\n        numberToWord rollCount","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5679aa472b8f57fb8c000047":[{"id":85119,"user_id":null,"body":"let findEvenIndex (items : int array)= \n    if items.Length = 0 then 0 else\n    items\n    |> Seq.scan (fun (leftSum, excluded, rightSum) item -> \n        leftSum + excluded, item, rightSum - item) (0, 0, Array.sum items)\n    |> Seq.tail\n    |> Seq.tryFindIndex (fun (leftSum, _, rightSum) -> leftSum = rightSum)\n    |> Option.defaultValue -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85120,"user_id":491,"body":"let findEvenIndex (items : int array) = \n    let rec f i a = function\n        | [] -> -1\n        | h::t -> if List.sum t = a then i else f (i + 1) (a + h) t\n    f 0 0 (Array.toList items)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85121,"user_id":null,"body":"let findEvenIndex = function\n    | [||]  -> 0\n    | [|_|] -> 0\n    | items ->\n        let rec f index leftSum rightSum =\n            if leftSum = rightSum then index\n            elif index >= items.Length - 1 then -1\n            else let center = items.[index]\n                 let next = items.[index + 1]\n                 f (index + 1) (leftSum + center) (rightSum - next)\n        f 0 0 (Array.sum items - items.[0])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85122,"user_id":null,"body":"let rec find (arr : int array) (idx : int) = \n    if idx = arr.Length then -1\n    else\n        if Array.sum arr.[0..idx] = Array.sum arr.[idx..(arr.Length - 1)] then idx\n        else find arr (idx + 1)\n\nlet findEvenIndex (items : int array) = \n    find items 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85123,"user_id":null,"body":"let findEvenIndex (items : int array) = \n  let outputA:array<int>=\n      match items with\n      |[||]->[|0|]\n      |_->\n        items\n        |>Array.mapi (fun i e -> \n          match i with\n          |i when i=0->\n             match 0 = (items.[i+1..]|>Array.sum )with\n              |true->Some (i)\n              |_->None\n          |i when i >0 ->\n              match (items.[..i-1]|>Array.sum) = (items.[i+1..]|>Array.sum )with\n              |true->Some (i)\n              |_->None\n          |_-> None)\n        |>Array.choose (fun a ->a)\n  match outputA    with\n  |[||]-> -1\n  |_->outputA.[0]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85124,"user_id":null,"body":"let findEvenIndex (items : int array) = \n  let splitEqual i =\n    let left =\n      items\n      |> Seq.take i\n      |> Seq.fold (+) 0\n    let right =\n      items\n      |> Seq.skip (i + 1)\n      |> Seq.fold (+) 0\n    left = right\n      \n  [0..(Seq.length items) - 1]\n  |> Seq.tryFind splitEqual\n  |> Option.defaultValue -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85125,"user_id":null,"body":"let findEvenIndex (items : int array) = \n    let rec find idx acc lst = \n        match lst with \n        | [] -> -1\n        | hd :: tl ->\n            match acc + hd with\n            | sum when sum = List.sum lst -> idx\n            | sum -> find (idx + 1) sum tl\n    find 0 0 (items |> List.ofArray)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85126,"user_id":null,"body":"let findEvenIndex (items: int array) : int =\n    seq { 0 .. items.Length - 1 }\n    |> Seq.tryFind (fun ix ->\n        Array.splitAt ix items\n        ||> (fun l r -> (Array.sum l) = (Array.sum (Array.tail r))))\n    |> Option.defaultValue -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85127,"user_id":null,"body":"let findEvenIndex (items: int array) : int =\n    seq { 0 .. items.Length - 1 }\n    |> Seq.tryFind (fun ix ->\n        Array.splitAt ix items\n        ||> (fun l r -> (Array.sum l) = (Array.sum (Array.tail r))))\n    |> function\n        | Some ix -> ix\n        | None -> -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85128,"user_id":null,"body":"let findEvenIndex (items : int array) =\n    let indexed = Array.indexed items\n    let rec findIndex (idx: int) (arr: (int * int) array) =\n        if idx < arr.Length then\n            let top = arr |> Array.takeWhile (fun (i, _) -> i < idx) |> Array.map (fun (_, x) -> x)\n            let bottom = arr |> Array.skipWhile (fun (i, _) -> i <= idx) |> Array.map (fun (_, x) -> x)\n            if (Array.sum top) = (Array.sum bottom) then idx\n            else findIndex (idx + 1) arr\n        else -1\n    findIndex 0 indexed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5681cf0be812b41721000034":[{"id":85129,"user_id":null,"body":"let removeNoise =\n    let noise = Set.ofSeq \"%$&\/#\u00b7@|\u00ba\\\u00aa\"\n    String.filter (noise.Contains >> not)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85130,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet removeNoise str =\n    Regex.Replace(str, @\"[%$&\/#\u00b7@|\u00ba\\\\\u00aa]\", \"\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85131,"user_id":null,"body":"let removeNoise = String.filter (not << (Set.ofSeq \"%$&\/#\u00b7@|\u00ba\\\u00aa\").Contains)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85132,"user_id":null,"body":"\nlet noise = \"%$&\/#\u00b7@|\u00ba\\\u00aa\"\nlet removeNoise str =\n    str\n    |> Seq.filter (fun c -> not (Seq.contains c noise))\n    |> Seq.toArray\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85133,"user_id":null,"body":"let removeNoise =\n    String.collect (fun c -> \n        if Seq.exists ( (=)c) \"%$&\/#\u00b7@|\u00ba\\\u00aa\" then \"\" \n        else string c)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85134,"user_id":null,"body":"let removeNoise str =\n    let rg = new System.Text.RegularExpressions.Regex(\"\"\"[%$&\/#\u00b7@|\u00ba\\\\\u00aa]\"\"\")\n    rg.Replace(str, System.String.Empty)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85135,"user_id":168,"body":"open System.Text.RegularExpressions\n\nlet removeNoise str = Regex.Replace(str, \"[\\\\\\\\%$&\/#\u00b7@|\u00ba\u00aa]\", \"\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85136,"user_id":null,"body":"open System\n\nlet removeNoise (str: string) =\n    str.ToCharArray() |>\n    Array.filter (fun (x: char) -> not (\"%$&\/#\u00b7@|\u00ba\\\u00aa\".Contains(x.ToString()))) |>\n    Array.map (fun x -> x.ToString()) |>\n    String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85137,"user_id":null,"body":"let removeNoise str =\n    let noiseChars = @\"%$&\/#\u00b7@|\u00ba\\\u00aa\".ToCharArray()\n    str |> String.filter (fun c -> not (Array.contains c noiseChars))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85138,"user_id":null,"body":"let removeNoise =\n  String.filter (fun char -> not (\"%$&\/#\u00b7@|\u00ba\\\\\u00aa\".Contains (string char)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"568dcc3c7f12767a62000038":[{"id":85139,"user_id":527,"body":"let set_alarm (employed: bool) (vacation: bool): bool =\n  employed && not vacation","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85140,"user_id":null,"body":"let set_alarm (employed: bool) (vacation: bool) =\n    match employed, vacation with\n        | (true, true) -> false\n        | (false, true) -> false\n        | (false, false) -> false\n        | (true, false) -> true","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85141,"user_id":527,"body":"let set_alarm = (>)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85142,"user_id":null,"body":"let set_alarm (employed: bool) (vacation: bool) =\n        match employed with\n        | true -> match vacation with\n                  | true -> false\n                  | false -> true\n        | false -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85143,"user_id":null,"body":"let set_alarm (employed: bool) (vacation: bool) = begin\n\n  if (employed && not vacation) then\n    true\n    \n  else\n    false\n    \nend","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85144,"user_id":null,"body":"let set_alarm (e: bool) = (&&) e << (not) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85145,"user_id":null,"body":"let set_alarm (employed: bool) (vacation: bool) = if employed && false = vacation then true else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85146,"user_id":null,"body":"let set_alarm (employed: bool) (vacation: bool) =\n    match vacation with\n    | true -> false\n    | false -> employed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85147,"user_id":null,"body":"let set_alarm empolyed vacation =\n    match (empolyed, vacation) with\n    | (true, true) -> false\n    | (false, true) -> false\n    | (false, false) -> false\n    | (true, false) -> true\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85148,"user_id":null,"body":"let set_alarm (employed: bool) (vacation: bool) =\n    if employed & not vacation then true else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"569218bc919ccba77000000b":[{"id":85149,"user_id":null,"body":"open System\nlet dateNbDays  (a0: float) (a: float) (p: float) =\n  DateTime(2016, 1, 1).AddDays(ceil ((log (a \/ a0)) \/ (log (1.0 + (p \/ 36000.0))))).ToString(\"yyyy-MM-dd\")\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85150,"user_id":null,"body":"open System\nopen System.Globalization\n\nlet depositDate = DateTime(2016, 1, 1)\n\nlet dateNbDays initialAmount targetAmount annualRate =\n    let dailyRate = annualRate \/ 360.\n    let days =\n        ceil\n        <| (log targetAmount - log initialAmount) \/\n            log (1. + dailyRate \/ 100.)\n    let targetDate = depositDate.AddDays(days)\n    targetDate.ToString(\"yyyy-MM-dd\", CultureInfo.InvariantCulture)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85151,"user_id":492,"body":"open System\n\nlet dateNbDays  (a0: float) (a: float) (p: float) =\n    let mutable start = new DateTime(2016, 1, 1)\n    let nd = start.AddDays (ceil(log(a \/ a0) \/ log(1.0 + p \/ 36000.0)))\n    nd.ToString(\"yyyy-MM-dd\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85152,"user_id":492,"body":"open System\n\nlet dateNbDays  (a0: float) (a: float) (p: float) =\n    let mutable start = new DateTime(2016, 1, 1)\n    let nd = start.AddDays (ceil(log(a \/ a0) \/ log(1.0 + p \/ 36000.0)))\n    nd.ToString(\"yyyy-MM-dd\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85153,"user_id":null,"body":"let dateNbDays b0 b p =\n    let r = (p * 0.01) \/ 360.\n    let rec f c =\n        let n = c + (c * r)\n        if n > b then 1. else 1. + f n\n\n    System.DateTime(2016, 1, 1).AddDays(f b0)\n                               .ToString(\"yyyy-MM-dd\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85154,"user_id":null,"body":"let dateNbDays  (a0: float) (a: float) (p: float) =\n  \/\/ your code\n  let baseDate = System.DateTime(2016, 1, 1)\n  let rate = p \/ 36000.0\n\n  let mutable amount = a0\n  let mutable days : double = 0.0\n  while amount < a do\n    days <- days + 1.0\n    amount <- amount + (amount * rate)\n    \n  baseDate.AddDays(days).ToString(\"yyyy-MM-dd\")\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85155,"user_id":null,"body":"let dateNbDays (a0: float) (a: float) (p: float) =\n  let rec aux money day =\n    if money >= a then float day\n    else aux (money * (1.0 + p\/36000.0)) (day + 1)\n  System.DateTime.Parse(\"2016-01-01\").AddDays(aux a0 0).ToString(\"yyyy-MM-dd\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85156,"user_id":null,"body":"let dateNbDays  (a0: float) (a: float) (p: float) =\n    let nDays = log (a\/a0) \/ log (1.0 + p\/36000.0)\n    let endOfDays = (System.DateTime(2016,1,1)).AddDays(nDays |> ceil)\n    sprintf \"%d-%02d-%02d\" endOfDays.Year endOfDays.Month endOfDays.Day\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85157,"user_id":null,"body":"open System\n\nlet dateNbDays  (a0: float) (a: float) (p: float) =\n    let sdt = new DateTime(2016, 1, 1)\n    let edt = Math.Log(a \/ a0, 1.0 + p \/ 36000.0)\n              |> Math.Ceiling\n              |> sdt.AddDays\n    \n    edt.ToString(\"yyyy-MM-dd\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85158,"user_id":null,"body":"open System\n\nlet dateNbDays  (a0: float) (a: float) (p: float) =\n  let per = 1.0 + (p \/ (36000.0))\n  let numD = Math.Ceiling(Math.Log(a\/a0, per))\n  let start = new DateTime(2016, 1, 1, 0, 0, 0)\n  let endp = start.AddDays numD\n  endp.ToString(\"yyyy-MM-dd\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"569b5cec755dd3534d00000f":[{"id":85159,"user_id":null,"body":"let newavg xs navg =\n    let donation = float (List.length xs + 1) * navg - List.sum xs\n    if donation <= 0.\n    then None\n    else Some (int (ceil donation))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85160,"user_id":492,"body":"open System\n\nlet newavg (xs: list<float>) (navg: float) =\n    let l = float(List.length xs)\n    let sm = List.sum xs\n    let res = int(ceil((l + 1.0) * navg - sm))\n    match res with\n    |x when x <= 0 -> None\n    | _ -> Some res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85161,"user_id":null,"body":"let newavg (xs: list<float>) (navg: float) =\n   let v = navg * float (1 + List.length xs) - List.sum xs |> ceil |> int\n   if v < 0 then None else Some(v)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85162,"user_id":null,"body":"open System\n\nlet newavg (xs: list<float>) (navg: float) =\n  let value= \n    navg * (float(List.length xs) + 1.0)  \n    |> (-)\n    <|( List.sum xs)         \n\n  match value with\n  | e when e>=0.0 -> System.Math.Ceiling(e)|>Convert.ToInt32|>Some\n  | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85163,"user_id":null,"body":"let newavg (xs: float list) (navg: float) =\n  let sumNow = List.sum xs\n  let newCount = xs.Length + 1\n  \n  let nextDonation = navg * float newCount - sumNow\n  \n  match nextDonation with\n  | x when x < 0.0 -> None\n  | x -> x |> ceil |> int |> Some","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85164,"user_id":null,"body":"open System\nlet newavg (xs: float list) (navg: float) =\n        let newLength = (float xs.Length) + 1.0\n        let oldSum = List.sum xs\n        let result = (navg * newLength - oldSum)\n        if result < 0.0 then None else (Some (int (Math.Ceiling result)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85165,"user_id":null,"body":"let newavg (xs: list<float>) (navg: float) =\n  navg * float (xs.Length + 1) - List.sum xs\n  |> ceil\n  |> int\n  |> Some\n  |> Option.filter (fun x -> x > 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85166,"user_id":53,"body":"let newavg (xs: list<float>) (navg: float) =\n  let s = List.sum xs\n  let n = List.length xs\n  let x = navg * (float (n + 1)) - s\n  if x < 0.0 then\n    None \n  else\n    Some (int (ceil x))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85167,"user_id":491,"body":"let newavg (xs: list<float>) (navg: float) : int option =\n  let newDonation = System.Math.Ceiling(navg * float(List.length xs + 1) - float(List.sum xs))\n  if newDonation >= 0.0 then newDonation |> int |> Some else None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85168,"user_id":null,"body":"let newavg (xs: list<float>) (navg: float) =\n    let s = List.sum xs\n    let n = List.length xs\n    let d' = (navg * (float (1 + n)) - s) \n            |> System.Math.Ceiling\n            |> int\n    if d' > 0 then Some d' else None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56a32dd6e4f4748cc3000006":[{"id":85169,"user_id":492,"body":"open System\nopen System.Linq\n\nlet meanCalc (a1: string[][]): double[] =\n    let a3 = a1.[0].[1].Split(',').Select(fun x -> x.Split(' ').[1]).ToArray()\n    let mutable s1, s2, cnt = (0.0, 0.0, 0)\n    let mutable n = 0.0\n    for w in a3 do\n        n <- double w\n        s1 <- s1 + n\n        s2 <- s2 + n * n\n        cnt <- cnt + 1\n    let m = s1 \/ double cnt\n    [|m; s2 \/ double(cnt) - m * m|]\n    \nlet meanvarAux(town: string) (strng: string): double[] =\n    let a1 = strng.Split('\\n').Select(fun x -> x.Split(':')).Where(fun x -> x.Contains(town)).ToArray()\n    if a1.Length <> 0 then\n        meanCalc a1\n    else\n        [|-1.0; -1.0|]\n\nlet mean(town: string) (strng: string): double = (meanvarAux town strng).[0]    \nlet variance(town: string) (strng: string): double =  (meanvarAux town strng).[1]","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85170,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet (|Falls|_|) (town: string) (data: string) = \n    let p = sprintf @\"(?m)^%s:(\\w+ (?<d>\\d+(\\.\\d+)?)(,|$)?)+\" town\n    let m = Regex.Match (data, p)\n    if not m.Success then None\n    else m.Groups.[\"d\"].Captures \n        |> Seq.cast<Capture> \n        |> Seq.map (fun c -> double c.Value) \n        |> Array.ofSeq |> Some\n\nlet mean town data =\n    match data with\n    | Falls town falls -> \n        falls |> Seq.average \n    | _ -> -1.\n\nlet variance town data =\n    match data with\n    | Falls town falls -> \n        falls |> Seq.map (fun x -> (Seq.average falls - x) ** 2.)|> Seq.average\n    | _ -> -1.","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85171,"user_id":null,"body":"\nopen System\n\nlet mean (town: string) (strng: string) : double =\n    let pattern = sprintf \"%s:(.*)\" town\n    let matches = System.Text.RegularExpressions.Regex.Match(strng, pattern)\n\n    if not matches.Success then\n        -1.\n    else\n        let pattern2 = @\"[a-zA-Z]+ (.*)\"\n\n        let s,qt = \n            matches.Groups.[1].Value.Split([| ',' |])\n            |> Array.fold\n                (fun (sum, n) month ->\n                    let matches2 = System.Text.RegularExpressions.Regex.Match(month, pattern2)\n                    let f = matches2.Groups.[1].Value |> float\n                    (sum + f, n + 1.))\n                (0., 0.)\n        s\/qt\n\nlet variance (town: string) (strng: string) : double = \n    let avg = mean town strng\n    if avg = -1. then\n        -1.\n    else\n        let pattern = sprintf \"%s:(.*)\" town\n        let matches = System.Text.RegularExpressions.Regex.Match(strng, pattern)\n        let pattern2 = @\"[a-zA-Z]+ (.*)\"\n\n        let s,qt = \n            matches.Groups.[1].Value.Split([| ',' |])\n            |> Array.fold\n                (fun (sum, n) month ->\n                    let matches2 = System.Text.RegularExpressions.Regex.Match(month, pattern2)\n                    let f = matches2.Groups.[1].Value |> float\n                    (sum + ((f-avg)*(f-avg)), n + 1.))\n                (0., 0.)\n        s\/qt","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85172,"user_id":null,"body":"open System\n\nlet parse (fCity: string) (s: string) : double list option =\n  let lines = s.Split [|'\n'|]\n  let maybeRow = \n    lines\n    |> Array.map (fun l -> \n      let [| city; readings |] = l.Split [|':'|]\n      (city, readings))\n    |> Array.tryFind (fun (city, _) -> city = fCity)\n    \n  match maybeRow with\n  | Some (city, readings) -> \n    readings.Split [|','|]\n    |> Array.map (fun r ->  r.[4..(String.length r)-1])\n    |> Array.map double\n    |> List.ofArray\n    |> Some\n  | None -> None\n\nlet mean(town: string) (strng: string): double =\n  match parse town strng with\n  | None -> -1.0\n  | Some l -> \n    (List.sum l) \/ double (List.length l)\n\nlet variance(town: string) (strng: string): double =  \n  match parse town strng with\n  | None -> -1.0\n  | Some l -> \n    let mean = (List.sum l) \/ double (List.length l)\n    let diffSum = \n      l\n      |> List.map (fun c -> (c - mean) ** 2.0)\n      |> List.sum\n    diffSum \/ double (List.length l)\n ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85173,"user_id":null,"body":"open System\n\nlet mean(town: string) (strng: string): double =\n  let ca = Array.append [|'a' .. 'z'|] [|'A' .. 'Z'|] |> Array.append [|':'; ' '|]\n  try\n    (strng.Split '\n' \n    |> Array.toList \n    |> List.find (fun (x: string) -> x.StartsWith town)).Split ','\n    |> Array.toList\n    |> List.map (fun x -> x.Trim(ca) |> float)\n    |> List.average\n  with _ -> -1.0\n\nlet variance(town: string) (strng: string): double =\n  let ca = Array.append [|'a' .. 'z'|] [|'A' .. 'Z'|] |> Array.append [|':'; ' '|]\n  try\n    let mean = mean town strng\n    let v = (((strng.Split '\n' \n    |> Array.toList \n    |> List.find (fun (x: string) -> x.StartsWith town)).Split ',')\n    |> Array.toList\n    |> List.map (fun x -> x.Trim(ca) |> float)\n    |> List.map (fun x -> (x-mean)**2.0))\n    ( (v |> List.sum) \/ (v |> List.length |> float) )\n  with _ -> -1.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85174,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\nlet pattern = \"\\d+\\.\\d\"\n\nlet extractNumbers (town: string) (data: string) = \n  let m =\n      data.Split('\n')\n      |> Array.map (fun x -> x.Split(':'))\n      |> Array.tryFind (fun x -> x.[0] = town)\n      |> Option.map (Array.item 1)\n      |> Option.map (fun x -> Regex.Matches(x,pattern))\n  match m with \n  | None -> None \n  | Some ms -> Some [for x in ms -> double x.Value]\n\n\n\nlet mean(town: string) (strng: string): double =\n  match extractNumbers town strng with \n  | None -> -1.0\n  | Some xs -> List.average xs\n  \nlet variance(town: string) (strng: string): double =\n  match extractNumbers town strng with \n  | None -> -1.0\n  | Some xs -> \n    let m = List.average xs\n    let n = List.length xs |> double \n    let squareSum = \n        xs\n        |> List.sumBy (fun x -> (x - m) * (x - m))\n    squareSum \/ n\n\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85175,"user_id":null,"body":"open System\n\nlet private splitOn (splitStr : string) (inputStr : string) = inputStr.Split([|splitStr|], StringSplitOptions.None)\n\nlet private findReadings (town : string) (data : string) =\n    splitOn \"\n\" data\n    |> Seq.tryFind (fun (s : string) -> s.Contains(town))\n    |> Option.map (splitOn \",\")\n    |> Option.map (Seq.map (splitOn \" \" >> Seq.item 1 >> double))\n    \nlet private calculateMean readings = (Seq.sum readings) \/ (double (Seq.length readings))\n\nlet mean(town: string) (strng: string): double =\n    findReadings town strng\n    |> Option.map calculateMean\n    |> Option.defaultValue -1.0\n    \nlet variance(town: string) (strng: string): double =\n    let distanceFromMean (mean : double) readings = Seq.map ((-) mean) readings\n    let squareAll (readings : seq<double>) = Seq.map (fun x -> x * x) readings\n    let maybeReadings = findReadings town strng\n    let maybeMean = Option.map calculateMean maybeReadings\n    Option.map2 distanceFromMean maybeMean maybeReadings\n    |> Option.map squareAll\n    |> Option.map calculateMean\n    |> Option.defaultValue -1.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85176,"user_id":null,"body":"open System\n\nlet getSum (doubleList : List<double>) (foreachEdit : Option<double -> double>) : double =\n    let mutable sum = 0.0\n    for num in doubleList do\n        let mutable toAdd = num\n        if not foreachEdit.IsNone then\n            toAdd <- foreachEdit.Value num\n        sum <- sum + toAdd\n    sum\n\nlet getMonthlyRainAmount(town: string) (data: string): List<double> =\n    let townsRainData : string[] = data.Split('\n')\n\n    let mutable targetRainData = String.Empty\n    for townRainData : string in townsRainData do\n        if townRainData.Contains(town) then\n            targetRainData <- townRainData\n\n    if targetRainData = String.Empty then\n        []\n    else\n        targetRainData <- targetRainData.Replace(town + \":\", String.Empty)\n        let monthlyRainDatas : string[] = targetRainData.Split(',')\n\n        let mutable rainDataResult : List<double> = []\n        for monthRainData in monthlyRainDatas do\n            \/\/ heck lmao\n            rainDataResult <- rainDataResult @ [Double.Parse(monthRainData.Remove(0, 4))]\n\n        rainDataResult\n\nlet mean(town: string) (strng: string): double =\n\n    let monthlyRainAmount = getMonthlyRainAmount town strng\n\n    if monthlyRainAmount = [] then\n        -1.0\n    else\n\n        let months = (double) monthlyRainAmount.Length\n        let sum = getSum monthlyRainAmount None\n        sum \/ months\n\n    \nlet variance(town: string) (strng: string): double =\n    let mean = mean town strng\n\n    if mean = -1.0 then\n        -1.0\n    else\n        let squaredDiff (x : double) : double = (x - mean) * (x - mean)\n        let monthlyRainAmount = getMonthlyRainAmount town strng\n\n        let months = (double) monthlyRainAmount.Length\n        let mutable squaredDiffSum = getSum monthlyRainAmount (Some(squaredDiff))\n\n        squaredDiffSum \/ months","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85177,"user_id":null,"body":"open System\n\nlet readData (data: string) =\n  data.Split '\n'\n  |> Seq.map (fun d -> \n    let d = d.Trim().Split ':'\n    let town = d.[0]\n    let records = d.[1].Split ',' |> Seq.map (fun r -> float r.[4..])\n    town, records)\n  |> Map.ofSeq\n\nlet mean(town: string) (strng: string): double = \n  let data = readData strng\n  match data |> Map.tryFind town with\n  | None -> -1.\n  | Some values -> Seq.average values\n\nlet square x = x * x\n\nlet variance(town: string) (strng: string): double = \n  let data = readData strng\n  match data |> Map.tryFind town with\n  | None -> -1.\n  | Some values -> \n    let avg = Seq.average values\n    values\n    |> Seq.sumBy (fun x -> square (x - avg))\n    |> fun sum -> sum \/ float (Seq.length values)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85178,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet getRainfall (s:string) =  \n    [for m in Regex.Matches(s, \"\\d+(\\.\\d+)?\") do yield m.Value] |> List.map double\n    \nlet getDataForTown (data:string) (town:string) =\n    data.Split('\n') |> Array.tryFind (fun x -> x.StartsWith(town)) |> Option.map getRainfall \n\nlet mean(town: string) (strng: string): double =\n    match getDataForTown strng town with\n    | None -> -1.0\n    | Some x -> x |> List.average\n    \nlet variance(town: string) (strng: string): double =\n    match getDataForTown strng town with\n    | None -> -1.0\n    | Some x ->\n        let mean = x |> List.average\n        x |> List.map (fun t -> t - mean) |> List.map (fun t -> t * t) |> List.average","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56a4872cbb65f3a610000026":[{"id":85179,"user_id":null,"body":"let rotate (s : string) i =\n    s.Substring(0, i) +\n    s.Substring(i + 1) +\n    s.Substring(i, 1)\n\nlet max_rot (n : int) =\n    let s = n.ToString()\n    {0 .. s.Length - 2}\n    |> Seq.scan rotate s\n    |> Seq.map int\n    |> Seq.max\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85180,"user_id":492,"body":"open System\n\nlet max_rot (n: int): int =\n    let keepAndRotString (s: string, i: int) =\n        let res: string = s.[i..(String.length s) - 1]\n        s.[0..i - 1] + (res + res).[1..String.length res]\n    let rec helper(s: string, i: int, smx: string): string =\n        if (i = (String.length s) - 1) then \n            smx\n        else\n            let rot = keepAndRotString(s, i)\n            if (String.Compare(rot, smx) > 0) then\n                helper(rot, (i + 1), rot)\n            else helper(rot, (i + 1), smx)\n    let s: string = n.ToString()\n    int(helper(s, 0, s))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85181,"user_id":null,"body":"open System\n\nlet max_rot (n: int) =\n    let str = n |> string\n    let rotate (acc: string) i =\n        acc.Substring(0, i) + acc.Substring(i + 1) + acc.Substring(i, 1)\n        \n    [ 0 .. str.Length - 2 ] |> List.scan rotate str |> List.maxBy Convert.ToInt32 |> Convert.ToInt32","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85182,"user_id":null,"body":"module UsefulFunctions =\n    \/\/\/ Last item of a list\n    let lastElementOfList l = \n        l\n            |> List.rev \n            |> List.head\n\n    \/\/\/ List without the last element\n    let listWithoutLastElement l =\n        l\n            |> List.rev \n            |> List.tail \n            |> List.rev   \n\n    type Direction =\n        | Left\n        | Right\n    \n    \/\/Rotates list in selected direction k-times\n    let rotateList (dir:Direction) (k:int) (l:'a list) =\n        let length = l.Length\n        let newK = k % length;        \n        l\n        |> List.mapi(fun index content -> (index,content))\n        |> List.map(fun (index,content) -> \n            let newIndex = if dir = Right then index+newK else index-newK\n            let newIndexInBounds = if dir = Right then (if (newIndex) < length then newIndex else newIndex-length)\n                                                  else (if (newIndex) >= 0 then newIndex else newIndex+length)\n            (newIndexInBounds,content))\n        |> List.sortBy(fun (index,content) -> index)\n        |> List.map(fun (index,content) -> content) \n\nlet max_rot (n: int) =\n        let texted = string n\n        let numLength = texted.Length\n        let rotatePart (num:string) (startIndex:int) : string=\n            let beggining = Seq.take (startIndex) num\n                            |> Seq.toArray\n                            |> System.String\n            let rest = Seq.rev num\n                        |> Seq.take (num.Length-startIndex)\n                        |> Seq.rev\n            let rotatedRest = \n                rest\n                |> Seq.toList\n                |> UsefulFunctions.rotateList UsefulFunctions.Direction.Left 1\n                |> List.toArray\n                |> System.String\n            (beggining+rotatedRest)\n        let rec helper (n:string) =\n            let indexed = \n                [1..numLength]\n                |> List.indexed\n                |> List.map(fun (i,k) -> rotatePart n i)\n                |> List.indexed\n                |> List.fold(fun acc current -> let (ai, ax) = (UsefulFunctions.lastElementOfList acc)\n                                                let (ci, cx) = current\n                                                List.append acc [((ci+1), (rotatePart ax ci))] ) [(0,n)]\n                |> UsefulFunctions.listWithoutLastElement\n            indexed\n                |> List.map(fun (i,k) -> (int) k)\n                \n        List.max (helper texted)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85183,"user_id":null,"body":"let rotate arr =\n  match arr with\n    | [] -> []\n    | head::tail -> tail @ [ head ]\n  \nlet rec findGreatest (keep:int) (greatest: int) (arr: char list) =\n  match arr.Length with\n    | x when x = keep -> greatest\n    | _ -> \n      let left, right = arr |> List.splitAt keep\n      let current = (arr |> List.map string |> String.concat \"\" |> System.Int32.Parse)\n      findGreatest (keep + 1) (if greatest > current then greatest else current) (left @ (rotate right))\n\nlet max_rot (n: int) =\n  findGreatest 0 0 (n |> string |> Seq.toList)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85184,"user_id":null,"body":"let rotate (s: string) i =\n    s.Substring(0, i)\n    + s.Substring(i + 1)\n    + s.Substring(i, 1)\n\nlet max_rot (n: int) =\n    let s = string n\n\n    { 0 .. String.length s - 2 }\n    |> Seq.scan rotate s\n    |> Seq.map int\n    |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85185,"user_id":null,"body":"let rotate (s: string) i =\n    s.Substring(0, i)\n    + s.Substring(i + 1)\n    + s.Substring(i, 1)\n\nlet max_rot (n: int) =\n    let s = string n\n\n    { 0 .. String.length (string n) - 2 }\n    |> Seq.scan rotate s\n    |> Seq.map int\n    |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85186,"user_id":null,"body":"open System\n\nlet rotLeft (digs: int seq) =\n    Seq.append (Seq.tail digs) [ Seq.head digs ]\n\n\nlet rot (i: int) (n: int) =\n    let digs = n |> string |> Seq.map (string >> int)\n\n    let tail = digs |> Seq.skip i |> rotLeft\n\n    Seq.append (Seq.take i digs) tail\n    |> String.Concat\n    |> int\n\nlet max_rot (n: int) =\n    let s = ref [ n ]\n    let x = ref n\n\n    for i = 0 to (String.length (string n) - 2) do\n        s := List.append !s [ (rot i !x) ]\n        x := rot i !x\n\n    List.max !s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85187,"user_id":null,"body":"let rec digitsOf = function\n  | 0 -> []\n  | n -> digitsOf (n \/ 10) @ [ n % 10 ]\n  \nlet toDigits =\n  List.rev\n  >> List.mapi (fun i d -> d * pown 10 i)\n  >> List.sum\n    \n\/\/ mathematical modulus\nlet (%%) a b = (abs(a * b) + a) % b\n\nlet max_rot (n: int) =\n  let digits = digitsOf n\n  [ 0 .. digits.Length - 1 ]\n  |> List.scan\n    (fun acc i ->\n      let first, second = acc |> List.splitAt i\n      let digitCount = second.Length\n      let second = second |> List.permute (fun j -> (j - 1) %% digitCount) \n      first @ second)\n    digits\n  |> List.max\n  |> toDigits\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85188,"user_id":null,"body":"open System\n\nlet max_rot (n: int) =\n    let str = n |> string\n    let shift (acc: string) i =\n        let kept = acc.Substring(0, i)\n        let moved = acc.Substring(i, str.Length - i)\n        String.concat \"\" [kept; Seq.tail moved |> Array.ofSeq |>  String; moved.[0].ToString()]\n        \n    [ 0 .. str.Length - 1 ] |> List.scan shift str |> List.maxBy Convert.ToInt32 |> Convert.ToInt32\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56a5d994ac971f1ac500003e":[{"id":85189,"user_id":null,"body":"open System\n\nlet longest_consec k (strings : string seq) =\n    let n = Seq.length strings\n    if 0 < k && k <= n then\n        strings\n        |> Seq.windowed k\n        |> Seq.maxBy (Array.sumBy String.length)\n        |> String.Concat\n    else\n        String.Empty\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85190,"user_id":3318,"body":"let longest_consec lg (xs: seq<string>) =\n    if Seq.isEmpty xs || lg <= 0 || lg > Seq.length xs then \"\"\n    else\n        xs\n        |> Seq.windowed lg\n        |> Seq.map System.String.Concat\n        |> Seq.maxBy String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85191,"user_id":null,"body":"let longest_consec length strings =\n    if length > Seq.length strings || Seq.isEmpty strings || length <= 0 then \"\"\n    else\n        Seq.windowed length strings\n        |> Seq.map (String.concat \"\")\n        |> Seq.maxBy String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85192,"user_id":null,"body":"let longest_consec lg (xs: seq<string>) =    \n    if xs |> Seq.isEmpty || lg <= 0 || lg > (xs |> Seq.length) then \"\"\n    else xs |> Seq.windowed lg |> Seq.map (Array.reduce (+)) |> Seq.maxBy String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85193,"user_id":null,"body":"let longest_consec k words =\n    try\n        words\n        |> List.windowed k\n        |> List.map (String.concat \"\")\n        |> List.maxBy String.length\n    with\n        | :? System.ArgumentException -> \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85194,"user_id":null,"body":"let consecGen k xs =\n    if List.length xs >= k then\n        Some (xs, List.tail xs)\n    else\n        None\n\nlet longest_consec k xs =\n    let n = List.length xs\n    if n = 0 || k <= 0 || k > n then\n        \"\"\n    else\n        xs\n        |> List.unfold (consecGen k)\n        |> List.map (List.take k)\n        |> List.map (String.concat \"\")\n        |> List.maxBy String.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85195,"user_id":null,"body":"let longest_consec lg (xs: seq<string>) =\n    let lst = List.ofSeq xs\n    if lg <= 0 || lst.IsEmpty || lg > lst.Length then\n        \"\"\n    else\n        lst\n        |> Seq.windowed lg\n        |> Seq.map (fun win -> (win |> Array.sumBy String.length, win))\n        |> Seq.maxBy fst\n        |> snd\n        |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85196,"user_id":null,"body":"open System\n\nlet longest_consec k (xs: seq<string>) =\n    if k <= 0 then \"\"\n    else\n      Seq.windowed k xs\n      |> Seq.sortByDescending (fun xs -> xs |> Seq.sumBy String.length)\n      |> Seq.tryHead\n      |> Option.map (String.Concat)\n      |> Option.defaultValue \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85197,"user_id":null,"body":"\nlet longest_consecInner lg (words: seq<string>) =\n  printfn \"Inner: %i \/\/ %A\" lg words\n  let concatWords = (List.ofSeq words\n    |> List.windowed lg\n    |> List.map (String.concat \"\"))\n  \n  let maxLength = concatWords |> List.map String.length |> List.max\n\n  List.find (fun x -> String.length x = maxLength) concatWords\n\nlet longest_consec lg (words: seq<string>) =\n  if Seq.length words = 0 then \"\"\n  elif lg < 1 then \"\"\n  elif lg > Seq.length words then \"\"\n  else longest_consecInner lg words\n  \n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85198,"user_id":325,"body":"let longest_consec lg (xs: seq<string>) =\n    let xslist = xs |> Seq.toList\n    let length = Seq.length xs\n\n    if length = 0 || lg > length || lg <= 0 then\n        \"\"\n    else\n        let seqOfSeqs = seq {\n            for i in 0..(lg - 1) -> seq {\n              for j in i..((length - 1) - (lg - 1) + i) -> xslist.[j].Length\n            }\n          }\n\n        let listOfLengths = \n            seqOfSeqs\n            |> Seq.collect id\n            |> Seq.toList\n\n        let firstOccurrence = \n          [ 0 .. (length - 1) ]\n          |> List.map (fun i ->\n            (i,\n              [ i .. (length - (lg - 1)) .. (lg * (length - (lg - 1)) - 1) ]\n              |> Seq.fold (fun acc index ->\n                acc + listOfLengths.[index]\n              ) 0\n            )\n          )\n          |> List.maxBy snd\n          |> fst\n\n        [firstOccurrence .. (firstOccurrence + lg - 1)]\n        |> List.fold (fun acc index -> acc + xslist.[index]) \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56af1a20509ce5b9b000001e":[{"id":85199,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    let m = Regex.Match(input, pattern)\n    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    else None\n\ntype AddressInfo = {\n    Number: string\n    Street: string\n    PostCode: string\n}\n\nlet parse = function\n| Regex @\"(\\d+) (.+) ([A-Z][A-Z] \\d{5})\" [ n; s; p ] -> Ok {\n    Number = n\n    Street = s\n    PostCode = p }\n| _ -> Error \"Parse Error\"\n\nlet flatten x = \n    let rec fn acc = function\n    | [] -> Ok acc\n    | x::xs -> match x with\n                | Error e -> Error e\n                | Ok s -> fn (acc @ [s]) xs\n    fn [] x\n\nlet processInput (s: string) = \n    s.Split(',')\n    |> List.ofArray\n    |> List.map parse\n    |> flatten\n\nlet format postCode data =\n    let select = List.filter (fun x -> x.PostCode = postCode) data\n    let streets = select |> List.map (fun x -> x.Street) |> String.concat \",\" \n    let numbers = select |> List.map (fun x -> x.Number) |> String.concat \",\"\n    sprintf \"%s:%s\/%s\" postCode streets numbers\n\nlet get (r: Result<'a,'a>) = \n    match r with\n    | Error e -> e\n    | Ok e -> e\n\nlet travel(r:string) (zipcode:string): string =\n    processInput r\n    |> Result.map (format zipcode)\n    |> get","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85200,"user_id":null,"body":"open System\n\ntype Address = { ZipCode:string; StreetAndTown:String; StreetNumber:string }\n\nlet parseAddress (s:string) =\n    let a = s.Split(' ')\n    let streetNumber = a.[0]\n    let zipCode = a |> Array.skip (a.Length - 2) |> String.concat \" \"\n    let street = Array.sub a 1 (a.Length - 3) |> String.concat \" \"\n    { ZipCode = zipCode; StreetAndTown = street; StreetNumber = streetNumber }\n    \nlet travel(r: string) (zipcode: string): string =\n    r.Split(',')\n    |> Array.map parseAddress\n    |> Array.filter (fun x -> x.ZipCode.Equals(zipcode))\n    |> Array.fold (fun s a -> (fst s + \",\" + a.StreetAndTown), (snd s + \",\" + a.StreetNumber)) (\"\", \"\")\n    |> fun (streets, numbers) ->\n        sprintf \"%s:%s\/%s\" zipcode (streets.TrimStart(',')) (numbers.TrimStart(','))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85201,"user_id":null,"body":"open System\n\nlet travel(r: string) (zipcode: string): string =\n    r.Split [|','|]\n    |> Seq.filter (fun item -> item.EndsWith(\" \" + zipcode))\n    |> Seq.map (fun item -> \n        let houseNumber = item.Split [|' '|] |> Seq.head\n        let streetAndTown = item.[houseNumber.Length + 1 .. item.Length - zipcode.Length - 2]\n        (streetAndTown, houseNumber))\n    |> Seq.fold (fun (addresses, numbers) (streetAndTown, houseNumber) ->\n        (Seq.append addresses [streetAndTown], Seq.append numbers [houseNumber])) (Seq.empty, Seq.empty)\n    |> fun (addresses, numbers) -> zipcode + \":\" + String.concat \",\" addresses + \"\/\" + String.concat \",\" numbers\n\n    \/\/ your code","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85202,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n  let m = Regex.Match(input, pattern)\n  if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n  else None\n  \nlet parseAddress = function\n  | Regex (\"^(\\d+)\\s+(.*)\\s+(\\w\\w \\d\\d\\d\\d\\d)$\") [number; street; zip] ->\n    Some (number, street, zip)\n  | s ->\n    printfn \"Invalid address %A\" s\n    None\n    \nlet parseAddresses (s : string) =\n  s.Split(',')\n  |> Seq.choose parseAddress\n  \nlet generateStreets zip addrs =\n  let addresses = addrs |> Seq.map (fun (_, s, _) -> s)\n  let houses = addrs |> Seq.map (fun (h, _, _) -> h)\n  \n  zip + \":\" + (String.concat \",\" addresses) + \"\/\" + (String.concat \",\" houses)\n\nlet travel(r: string) (zipcode: string): string =\n  r\n  |> parseAddresses\n  |> Seq.filter (fun (_, _, z) -> z = zipcode)\n  |> generateStreets zipcode","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85203,"user_id":null,"body":"open System\n\nlet travel(r: string) (zipcode: string): string =\n    let parseStr (str: string) =\n      let house = str.Substring(0, str.IndexOf(' '))\n      let zipcode = str.Substring(str.Length - 8)\n      let address = str.Substring(house.Length + 1, str.Length - house.Length - zipcode.Length - 2)\n      (zipcode, house, address)\n      \n    let parseR = r.Split(',') |> Array.map parseStr |> Array.filter (fun (a,_,_) -> a = zipcode)\n    sprintf \"%s:%s\/%s\" zipcode \n                       (parseR |> Array.map (fun (_,_,c) -> c) |> String.concat \",\") \n                       (parseR |> Array.map (fun (_,b,_) -> b) |> String.concat \",\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85204,"user_id":null,"body":"open System\n\nlet parseHouseStreetAndTownZip (s:string) =\n    let words = s.Split([|' '|])\n    let house = words |> Array.head\n    let zip = String.Join(\" \", words |> Array.skip (words.Length - 2))\n    (house, String.Join(\" \", words |> Array.skip 1 |> Array.take (words.Length - 3)), zip)\n\nlet travel(r: string) (zipcode: string): string =\n    let append (hs, sts) (h, st, _) =\n        (h::hs, st::sts)\n\n    let (hs, sts) = r.Split([|','|]) \n                        |> Array.map parseHouseStreetAndTownZip\n                        |> Array.filter (fun (_, _, z) -> z = zipcode)\n                        |> Array.fold append ([], [])\n\n    match (hs, sts) with\n    | ([], []) -> sprintf \"%s:\/\" zipcode\n    | _ -> sprintf \"%s:%s\/%s\" zipcode (String.Join(\",\", sts |> List.rev)) (String.Join(\",\", hs |> List.rev))\n ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85205,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\n\nlet travel(r: string) (zipcode: string): string =\n\n    let addresses = r.Split(',') |> Seq.filter (fun s -> (s.Contains(zipcode) && zipcode.Length = 8))\n    \n    let mutable streets = []\n    let mutable numbers = []\n    \n    let mutable temp = \"(^\\d+)(.+(?= \" + zipcode + \"))\"\n    let rx = new Regex(temp)\n    if zipcode <> \"\" then\n      for s in addresses do\n        let m = rx.Match s\n        numbers <- numbers @ [m.Groups.[1].ToString().Trim()]\n        streets <- streets @ [m.Groups.[2].ToString().Trim()]\n      \n    zipcode + \":\" + (streets |> String.concat \",\") + \"\/\" + (numbers |> String.concat \",\")\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85206,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet travel (r: string) (zipcode: string): string =\n    let matches =\n        r.Split(',')\n        |> Array.map (fun a -> Regex.Match(a, @\"(?<houseNum>\\d+) (?<streetCity>.*) (?<stateZip>\\w{2} \\d{5})\"))\n        |> Array.filter (fun m -> m.Groups.[\"stateZip\"].Value = zipcode)\n    let combineMatches (key: string) =\n        matches |> Array.map (fun m -> m.Groups.[key].Value) |> String.concat \",\"\n    zipcode + \":\" + combineMatches \"streetCity\" + \"\/\" + combineMatches \"houseNum\"\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85207,"user_id":null,"body":"open System\nlet travel(r: string) (zipcode: string) = \/\/: string =\n    let adresses, numbers = r.Split ','\n                            |> Array.filter (fun a -> (zipcode <> String.Empty) && a.EndsWith zipcode)\n                            |> Array.map (fun a -> \n                                let m = Text.RegularExpressions.Regex.Match (a,(sprintf \"\"\"(^\\d+)\\s(.*?)\\s(%s)\"\"\" zipcode)) \n                                m.Groups.[2].Value, m.Groups.[1].Value\n                                )\n                            |>Array.fold (fun s t ->\n                                 let adList, numList = s\n                                 let ad, num = t\n                                 ([ad] |> List.append adList, [num] |> List.append numList)\n                                 ) (List.empty<String>,List.empty<String>)\n\n    sprintf \"%s:%s\/%s\" zipcode  (String.Join (\",\",adresses)) (String.Join (\",\",numbers))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85208,"user_id":null,"body":"type Address = {\n  Number: string\n  Rest: string\n  Zipcode: string\n }\n\nmodule Address =\n  let parse (str: string) =\n    let parts = str.Split [| ' ' |]\n    let len = Seq.length parts;\n    {\n      Number = parts |> Seq.take 1 |> Seq.exactlyOne\n      Rest = parts |> Seq.skip 1 |> Seq.take (len - 3) |> String.concat \" \"\n      Zipcode = parts |> Seq.skip (len - 2) |> Seq.take 2 |> String.concat \" \"\n    }\n  let zipcodeIs zipcode address = address.Zipcode = zipcode\n\nlet travel (addressesStr: string) (zipcode: string): string =\n  let relevantAddresses = addressesStr.Split [| ',' |] |> Seq.map Address.parse |> Seq.filter (Address.zipcodeIs zipcode)\n  let address = relevantAddresses |> Seq.map (fun x -> x.Rest) |> String.concat \",\"\n  let doors = Seq.map (fun x -> x.Number) relevantAddresses |> String.concat \",\"\n  sprintf \"%s:%s\/%s\" zipcode address doors\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56b5afb4ed1f6d5fb0000991":[{"id":85209,"user_id":null,"body":"open System\n\nlet revrot str sz =\n  match sz with\n  | 0 -> \"\"\n  | _ ->\n        str \n        |> Seq.chunkBySize sz\n        |> Seq.filter (fun f -> f.Length = sz)\n        |> Seq.toArray\n        |> Array.map (fun m -> \n          let cube = m |> Seq.sumBy (fun c -> int (Char.GetNumericValue(c) ** 3.)) \n          match cube % 2 with\n          | 0 -> String (m |> Array.rev)\n          | _ -> String ( (m |> Array.head |> Array.singleton) |> Array.append (m |> Array.tail))\n        )\n        |> String.concat \"\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85210,"user_id":null,"body":"let rec revrot (str:seq<char>) sz=\n  \/\/ your code\n  if Seq.length str < sz || sz <= 0\n  then \"\"\n  else\n    Seq.chunkBySize sz str\n    |> Seq.filter (fun s -> Seq.length s = sz)\n    |> Seq.map (fun s -> \n        if ((Seq.sumBy (fun c -> let i = System.Char.GetNumericValue c |> int in i*i*i) s) % 2 = 0)\n        then s |> Seq.rev |> System.String.Concat\n        else (s |> Seq.skip 1 |> List.ofSeq) @ [Seq.head s] |> System.String.Concat)\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85211,"user_id":3318,"body":"open System\nlet cube x = x * x * x\nlet revrot str sz =\n    if String.IsNullOrEmpty(str) || sz <= 0 || str.Length < sz\n    then \"\"\n    else\n        str\n        |> Seq.chunkBySize(sz)\n        |> Seq.filter (fun s -> s.Length = sz)\n        |> Seq.map (fun s ->\n            let s = s |> String.Concat\n            let sum = s |> Seq.sumBy (string >> int >> cube)\n            if sum % 2 = 0\n            then s |> Seq.rev |> String.Concat\n            else s.[1..] + s.[0..0])\n        |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85212,"user_id":null,"body":"open System\n\nlet reverse s =\n    if String.length s <= 1\n    then s\n    else\n        let a = s.ToCharArray()\n        Array.Reverse a\n        String a\n\nlet transform number =\n    let sumOfDigits = number |> Seq.sumBy (fun digit -> int digit - int '0')\n    if sumOfDigits &&& 1 = 0\n    then reverse number\n    else number.[1..] + number.[0..0]\n\nlet revrot str sz =\n    if sz <= 0\n    then String.Empty\n    else\n        { 0 .. sz .. String.length str - sz }\n        |> Seq.map (fun i -> str.[i .. i + sz - 1] |> transform)\n        |> String.Concat\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85213,"user_id":null,"body":"open System\n\nlet revrot str sz =\n  if sz <= 0 then \"\"\n  else\n\n   let chunk c = Seq.unfold (fun x -> if Seq.length x < sz then None else Some (Seq.take sz x |> Seq.toArray, Seq.skip sz x)) c\n\n   let sumOfCubes arr = arr |> Array.map (fun c -> c*c*c) |> Array.sum\n   \n   let revOrRotateChunk c =\n      match (sumOfCubes c) % 2 with\n      | 0 -> Array.rev c\n      | 1 -> Array.append c.[1..] c.[0..0]\n      | _ -> failwith \"unexpected\"\n      \n   let char2Int (c:char) = int c - int '0'\n   let int2Char i = char (int '0' + i)\n      \n   str \n   |> Seq.map char2Int\n   |> chunk \n   |> Seq.map revOrRotateChunk \n   |> Seq.concat\n   |> Seq.map int2Char\n   |> String.Concat\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85214,"user_id":null,"body":"open System\n\n\/\/ Note to kata writers: next five lines are overhead (yup, I make it worse)\n\/\/ why input a string and expect a string in return?\n\/\/ Keep it in spirit of the task: give a list\/seq, require list\/seq as answer\n\/\/ Don't bother me with this boilerplate fromString\/toString conversions! It distracts. \n\/\/ 1 (one) kata to train how to get digits from\n\/\/ a string and\/or convert it back to a string should do.\nlet encoder = System.Text.Encoding.ASCII\nlet asBytes (s:string) = s |> encoder.GetBytes\nlet toDigits = Seq.map (fun b -> b - '0'B |> int)\nlet strToDigits = asBytes >> toDigits >> Seq.toList\nlet backToString = List.fold (fun p v -> p + v.ToString()) String.Empty\n\n\/\/ to add to the complexity..\n\/\/ let me check to input, because the author can't guarantee that the generated cases are within bounds...\n\/\/ another 9 lines of overhead.\nlet check str sz =\n    match (str,sz) with\n    | (\"\",_) -> None\n    | (_,len) when len <= 0 -> None\n    | (_,len) when len > str.Length -> None\n    | _ -> Some (str,sz)\n\n\/\/ hehe, let's get to work:\n\nlet partition size (l:int list) : int list list =\n    let rec parts ls acc =\n        match (List.length ls) with\n        | s when s < size -> List.rev acc\n        | _ -> parts (ls |> List.skip size) ((ls |> List.take size)::acc)\n\n    parts l []\n\nlet sumsquares = List.fold (fun p c -> p + c*c) 1\n\nlet rotateLeft l = \n    match l with\n    | (x::xs) -> List.append xs [x]\n    | _ -> failwith \"unexpected\"\n\nlet rotOrRev l =\n    if sumsquares l % 2 <> 0 then List.rev l\n    else l |> rotateLeft\n\nlet onparts = List.map rotOrRev >> List.concat\nlet executeTheKata sz = partition sz >> onparts\n\nlet revrot str sz =\n    match check str sz with\n    | None -> String.Empty\n    | _ ->  str \n            |> strToDigits\n            |> executeTheKata sz \/\/finaly\n            |> backToString","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85215,"user_id":492,"body":"open System\n\nlet chunk lg (s: string) =\n    let rec loop xs =\n        [\n            let t = Seq.truncate lg xs\n            if Seq.length t >= lg then yield t |> Seq.toList else yield []\n            match Seq.length xs <= lg with\n            | false -> yield! loop (Seq.skip lg xs)\n            | true -> ()\n        ]\n    let xs = s.ToCharArray()\n    loop xs |> List.filter ((<>)[])\nlet isSumDig3Div2 a =\n    ([for c in a -> int(c) - int(48)] |> List.map (fun x -> x*x*x) |> List.reduce(+)) % 2 = 0\nlet rotate k arr =\n        let  ls = arr |> List.ofSeq\n        List.fold (fun (s, c) e -> if s <> 0 then (s-1 , List.append c.Tail [e]) else (0, c)) (k, ls) ls\n        |> fun (_, y) -> y |> List.ofSeq\nlet revrot str sz =\n    if ((sz <= 0) || (str = \"\") || (sz > String.length str)) then \"\"\n    else\n        let a = chunk sz str\n        a |> List.map (fun x -> \n                    if (isSumDig3Div2 x) then String.Concat(Array.ofList(List.rev x)) \n                    else String.Concat(Array.ofList(rotate 1 x)))\n          |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85216,"user_id":null,"body":"open System\n\nlet revrot s n = \n    match n with\n    | 0 -> \"\"\n    | _ -> s \n        |> Seq.chunkBySize n \n        |> Seq.filter (fun c -> c.Length = n)\n        |> Seq.map (fun s -> \n            let c = s |> Seq.sumBy (fun x -> Char.GetNumericValue x ** 3.)\n            match int c % 2 with\n            | 0 -> s |> Seq.rev\n            | _ -> Seq.concat [s.[1..]; s.[0..0]])\n        |> Seq.concat \n        |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85217,"user_id":null,"body":"open System\n\nlet cube x = x * x * x\n\nlet digits (s: string) = s |> Seq.map (Char.GetNumericValue >> int)\n\nlet (|Even|Odd|) input = if input % 2 = 0 then Even else Odd\n\nlet chunks (s: string) n = \n    match n with\n    | 0 -> Seq.empty\n    | _ -> seq { for i in 0..s.Length \/ n - 1 -> s.Substring(i * n, n) }\n\nlet revrot1 (s: string) = \n    match s |> digits |> Seq.map cube |> Seq.sum with\n    | Even -> s |> Seq.rev |> String.Concat\n    | Odd -> s.[1..] + s.[0..0]\n\nlet revrot s n = \n    chunks s n |> Seq.map revrot1 |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85218,"user_id":1616,"body":"let isEven x =\n    x % 2 = 0\n\nlet sumOfCubesIsEven (chunk: int seq) =\n    chunk |> Seq.sum |> isEven\n\nlet revert (chunk: int seq) = \n    chunk |> Seq.rev\n\nlet moveFirstDigit (chunk: int seq) = \n    Seq.append (Seq.tail chunk) [Seq.head chunk]\n    \nlet rec chunks (init: int seq) (s: int) (z: int) (final: int seq) =\n    if (Seq.length init) < (s+z) then final\n    else \n        let c = init |> Seq.skip s |> Seq.take z\n        let chunk = (if sumOfCubesIsEven c then revert c else moveFirstDigit c) \n        chunks init (s+z) z (Seq.append final chunk)\n                    \nlet revrot (str: string) (z: int) = \n    if z<=0 then \"\"\n    else\n        let init = str |> Seq.map (fun x -> (int x) - 48) \n        (chunks init 0 z []) |> Seq.map (sprintf \"%i\") |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56baeae7022c16dd7400086e":[{"id":85219,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet phone (s: string) (num: string) : string =\n    let replace (pattern: string) (replacement: string) (input: string) = Regex.Replace(input, pattern, replacement)\n    match s.Split('\\n')\n          |> Array.filter (fun line -> Regex.IsMatch(line, \"\\+\" + num)) with\n        | [| |] -> \"Error => Not found: \" + num\n        | [| record |] ->\n            let name = Regex.Match(record, \"<(.+)>\").Groups.[1].Value\n            let address = record\n                          |> replace (sprintf \"(<.+>|\\+%s|[^a-zA-Z_0-9-.])\" num) \" \" \n                          |> replace \"[ _]+\" \" \"\n            sprintf \"Phone => %s, Name => %s, Address => %s\" num name (address.Trim())\n        | _ -> \"Error => Too many people: \" + num\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85220,"user_id":492,"body":"open System\nopen System.Linq\nopen System.Text.RegularExpressions\n\nlet phone(s: string) (num: string): string =\n    let phoneAux(record: string): string =\n        let _regexPhone: Regex = new Regex(@\"\\\/?\\+([\\d-]+);? ?\")\n        let _regexName: Regex = new Regex(@\"<(.+)>\")\n        let _regexClean: Regex = new Regex(\"[$:;\/,!?*]\")\n        let matchPhone = _regexPhone.Match(record)\n        let matchName = _regexName.Match(record)          \n        let add = record.Replace(matchPhone.Value, String.Empty).Replace(matchName.Value, String.Empty)\n        let address = _regexClean.Replace(add, String.Empty).Replace(\"_\", \" \").Replace(\"  \", \" \").Trim()\n        String.Format(\"Phone => {0}, Name => {1}, Address => {2}\", matchPhone.Groups.[1].Value, matchName.Groups.[1].Value, address)\n    let record = s.Split('\n').Where(fun x -> x.Contains(\"+\" + num)).ToArray()\n    let sol = match record.Length with\n                      | 0 -> \"Error => Not found: \" + num\n                      | 1 -> phoneAux record.[0]\n                      | _ -> \"Error => Too many people: \" + num\n    sol","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85221,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet phone(s: string) (num: string): string =\n    let directory = s.Split [|'\n'|]\n    let entriesFound = directory |> Array.filter (fun x -> x.Contains(\"+\" + num))\n    if entriesFound.Length > 1 then sprintf \"Error => Too many people: %s\" num\n    elif entriesFound.Length = 0 then sprintf \"Error => Not found: %s\" num\n    else\n    let found = directory |> Array.find (fun x -> x.Contains(\"+\" + num))\n    let phone = Regex.Match(found, @\"(\\+\\d{1,2}\\s?)?1?\\-?\\.?\\s?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\").Value\n    let phoneClean = Regex.Match(found, @\"(\\d{1,2}\\s?)?1?\\-?\\.?\\s?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\").Value\n    let name = Regex.Match(found, @\"\\<(.+?)\\>\").Value\n    let nameClean = name.Replace(\"<\", \"\").Replace(\">\", \"\")\n    let address = found.Replace(name, \"\").Replace(phone, \"\").Replace(\", , \", \" \").Replace(\"\/\", \"\").Replace(\"_\", \" \")\n                      .Replace(\"*\", \" \").Replace(\";\", \" \").Replace(\"$\", \" \").Replace(\":\", \" \").Replace(\" !! \", \" \")\n                      .Replace(\",\", \"\").Replace(\" ?\", \"\").Replace(\" !\", \" \")\n                      .Trim()\n    let addressClean = Regex.Replace(address, @\"\\s+\", \" \");\n    let result = sprintf \"Phone => %s, Name => %s, Address => %s\" phoneClean nameClean addressClean\n    result.Replace(\"\\\"\", \"\").Replace(\"<>  \", \"\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85222,"user_id":null,"body":"open System\nopen System.Linq\n\n\n[<Struct>]\ntype PhoneBookRow = {\n    Phone: string\n    Name: string\n    Address: string\n}\n    \nlet toString (row: PhoneBookRow) =\n    let del = \", \"\n    \"Phone => \" + row.Phone + del + \"Name => \" + row.Name + del + \"Address => \" + row.Address\n    \nlet getLines (line: string) =\n    line.Split(\"\n\" |> Seq.toArray)\n    \nlet search (num: string) (lines: string[]) =\n    lines |> Array.Parallel.choose (fun (line: string) -> if line.Contains(num) then Some line else None)\n        \nlet extractName (line:string) =\n    let initialIndex = line.IndexOf('<') + 1\n    let endIndex = line.IndexOf('>') - 1\n    line.[initialIndex..endIndex]\n    \nlet isAddress (chars: char seq) =\n    let nonAddressSymbols = ['<'; '>'; '+';]\n    let founded = chars |> Seq.tryFind (nonAddressSymbols.Contains)\n    match founded with\n    | Some _ -> false\n    | _ -> true\n    \nlet extractAddress (line: string) =\n    line.Split([|' '; ';'|]) |> \n    Seq.filter (fun sub -> not (String.IsNullOrEmpty(sub)) ) |> \n    Seq.filter (fun subString -> subString |> isAddress) |>\n    Seq.map (fun sub -> sub.TrimStart().TrimEnd()) |> String.concat \" \"\n\nlet replaceGarbage (address: string) =\n    address.Replace(\"_\", \" \").Replace(\",\", \"\").Replace(\"\/\", \"\").TrimStart().TrimEnd()\n    \nlet toPhoneBookRow (num: string) (line: string) =\n    {\n        Phone = num\n        Address = line |> extractAddress |> replaceGarbage\n        Name = line |> extractName\n    }\n        \nlet phone (input: string) (num: string) =\n    let addressBooklines = input |> getLines |> search (\"+\" + num)\n    match addressBooklines.Count() with\n    | 0 -> \"Error => Not found: \" + num\n    | 1 -> addressBooklines.[0] |> toPhoneBookRow num |> toString\n    | _ -> \"Error => Too many people: \" + num","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85223,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet (|Regex|_|) format s =\n   let m = Regex.Match(s, format)\n   if m.Success then Some([for g in m.Groups do yield g.Value])\n   else None\n\nlet cleanAddress phone name s =\n    let splitTrimConcat (s:string) =\n        s.Split(' ')\n        |> Array.map (fun x -> x.Trim())\n        |> Array.filter (String.IsNullOrWhiteSpace >> not) \n        |> String.concat \" \"\n    [phone; name; \"\/\"; \"!\"; \"$\"; \"_\"; \"?\"; \":\"; \";\"; \",\"; \"*\"]\n    |> List.fold (fun (s:string) replace -> s.Replace(replace, \" \")) s\n    |> splitTrimConcat  \n\nlet parseEntry s =\n    match (s, s) with\n    | Regex @\"(\\+(\\d{1,2}-\\d{3}-\\d{3}-\\d{4}))(\\D|$)\" (_ :: pRepl :: phone :: _),\n      Regex @\"<(.+)>\" [mRepl; name] ->\n          let address = s |> cleanAddress pRepl mRepl\n          Some(sprintf \"Phone => %s, Name => %s, Address => %s\" phone name address)\n    | _ -> None\n    \nlet phone(s: string) (num: string): string =\n    let results =\n        s.Split('\n')\n        |> Array.map parseEntry\n        |> Array.choose id\n        |> Array.filter (fun x -> x.StartsWith(sprintf \"Phone => %s,\" num))\n    match results with\n    | [| x |] -> x\n    | [||] -> sprintf \"Error => Not found: %s\" num\n    | _ -> sprintf \"Error => Too many people: %s\" num","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85224,"user_id":null,"body":"open System.Text.RegularExpressions\n\n\nlet getValueByGroupName (groups: GroupCollection) (name: string) = groups.[name].Value\n\ntype Contact =\n    { Phone: string\n      Address: string\n      Name: string }\n\nlet cleanupAddress (address: string) = address.Replace(\",\", \"\").Replace('_', ' ').Replace(\"  \", \" \").Trim()\n\nlet (|ParseContact|_|) regex str =\n    let m = Regex(regex).Match(str)\n\n    match m.Success with\n    | true ->\n        Some\n            { Phone = getValueByGroupName m.Groups \"Phone\"\n              Address = (\n                         (getValueByGroupName m.Groups \"Address\")\n                         + \" \"\n                         + getValueByGroupName m.Groups \"Index\")\n              |> cleanupAddress\n              Name = getValueByGroupName m.Groups \"Name\" }\n    | _ -> None\n\nlet badCharRegex = \"[!@#$%^&*.,;:\\\\\/-_=+{}|<>'\\\"]?\"\n\nlet phoneRegex =\n    badCharRegex\n    + \"\\+(?<Phone>[\\d]{1,2}-\\d[\\d-]+\\d)\"\n    + badCharRegex\n\nlet nameRegex = \"<(?<Name>.+)>\"\nlet addressRegex = \"(?<Address>.+)\"\nlet indexRegex = \"(?<Index>\\w{2}-\\d{5})\"\n\nlet parseContact str =\n    let patterns = [\n        indexRegex + \"\\s\" + phoneRegex + \"\\s\" + nameRegex + \"\\s\" + addressRegex\n        indexRegex + \"\\s\" + phoneRegex + \"\\s\" + addressRegex + \"\\s\" + nameRegex \n        indexRegex + \"\\s\" + nameRegex + \"\\s\" + addressRegex + \"\\s\" + phoneRegex\n        indexRegex + \"\\s\" + nameRegex + \"\\s\" + phoneRegex + \"\\s\" + addressRegex\n        phoneRegex + \"\\s\" + indexRegex + \"\\s\" + nameRegex + \"\\s\" + addressRegex\n        phoneRegex + \"\\s\" + addressRegex + \"\\s\" + nameRegex + \"\\s\" + indexRegex \n        nameRegex + \"\\s\" + addressRegex + \"\\s\" + phoneRegex + \"\\s\" + indexRegex\n        nameRegex + \"\\s\" + indexRegex + \"\\s\" + phoneRegex + \"\\s\" + addressRegex\n        addressRegex + \"\\s\" + phoneRegex + \"\\s\" + nameRegex + \"\\s\" + indexRegex\n        addressRegex + \"\\s\" + phoneRegex + \"\\s\" + indexRegex + \"\\s\" + nameRegex\n        addressRegex + \"\\s\" + nameRegex + \"\\s\" + phoneRegex + \"\\s\" + indexRegex\n        addressRegex + \"\\s\" + nameRegex + \"\\s\" + indexRegex + \"\\s\" + phoneRegex\n        phoneRegex + \"\\s\" + nameRegex + \"\\s\" + addressRegex\n        phoneRegex + \"\\s\" + addressRegex + \"\\s\" + nameRegex \n        addressRegex + \"\\s\" + phoneRegex + \"\\s\" + nameRegex\n        addressRegex + \"\\s\" + nameRegex + \"\\s\" + phoneRegex\n        nameRegex + \"\\s\" + addressRegex + \"\\s\" + phoneRegex\n        nameRegex + \"\\s\" + phoneRegex + \"\\s\" + addressRegex\n    ]\n\n    patterns\n    |> Seq.map\n        (fun pattern ->\n            match str with\n            | ParseContact pattern contact -> Some contact\n            | _ -> None)\n    |> Seq.filter (fun contact -> contact.IsSome)\n    |> Seq.map (fun contact -> contact.Value)\n    |> Seq.tryHead\n\nlet parseNotes (notes: string) =\n    notes.Split('\n')\n    |> Seq.map parseContact\n    |> Seq.filter (fun contact -> contact.IsSome)\n    |> Seq.map (fun contact -> contact.Value)\n\ntype SearchResult =\n    | Contact of Contact\n    | MultipleContacts of string\n    | NoPhone of string\n\nlet searchContact number contacts =\n    let matchingContacts =\n        contacts\n        |> Seq.filter (fun contact -> contact.Phone = number)\n\n    match matchingContacts |> Seq.toList with\n    | [ head ] -> Contact head\n    | _ :: _ -> MultipleContacts number\n    | _ -> NoPhone number\n\nlet printContact contact =\n    sprintf \"Phone => %s, Name => %s, Address => %s\" contact.Phone contact.Name contact.Address\n\nlet printMultipleContacts phone =\n    sprintf \"Error => Too many people: %s\" phone\n\nlet printContactNotFound phone = sprintf \"Error => Not found: %s\" phone\n\nlet printSearchResult searchResult =\n    match searchResult with\n    | Contact contact -> printContact contact\n    | MultipleContacts phone -> printMultipleContacts phone\n    | NoPhone phone -> printContactNotFound phone\n\nlet phone (s: string) (num: string) : string =\n    parseNotes s\n    |> searchContact num\n    |> printSearchResult","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85225,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\ntype Contact = {\n  Phone: string\n  Name: string\n  Address: string\n}\n\nlet parseContact line =\n    if String.IsNullOrWhiteSpace(line) then\n      None\n    else\n    \n    let phoneMatch = Regex.Match(line, @\"\\+(?<phone>\\d{1,2}-\\d{3}-\\d{3}-\\d{4})\")\n    let nameMatch = Regex.Match(line, @\"\\<(?<name>[^\\>]+)\\>\")\n    \n    let replace target (replacement:string) (source:string) = source.Replace(target, replacement)\n    let regexReplace pattern (replacement:string) source = Regex.Replace(source, pattern, replacement)\n    \n    let address =\n        line\n        |> replace phoneMatch.Value \"\"\n        |> replace nameMatch.Value \"\"\n        |> regexReplace \"[^A-Za-z0-9\\.\\-]+\" \" \"\n    \n    Some {\n        Phone = phoneMatch.Groups.[\"phone\"].Value\n        Name = nameMatch.Groups.[\"name\"].Value\n        Address = address.Trim()\n    }\n  \nlet phone(s: string) (num: string): string =\n    s.Split('\n')\n    |> Seq.choose parseContact\n    |> Seq.filter (fun contact -> contact.Phone = num)\n    |> Seq.truncate 2\n    |> List.ofSeq\n    |> function\n        | [contact] -> sprintf \"Phone => %s, Name => %s, Address => %s\" contact.Phone contact.Name contact.Address\n        | [] -> sprintf \"Error => Not found: %s\" num\n        | _ -> sprintf \"Error => Too many people: %s\" num\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85226,"user_id":null,"body":"open System\n\ntype Person =\n    {\n        Phone:string\n        Address:string\n        Name:string\n    }\n\nlet skip = Seq.skip<char> 1 >> fun x -> String.Join(\"\",x)\nlet slice (s:string) = s.[0] , skip s \n\nlet rec getPhone (result:string) (s:string) =\n    if s = \"\" then \n        if result = \"\" || result.Length < 13 then\n            None\n        else\n            Some (result,s)\n    else\n        let first,rest = slice s\n        match first with\n        | '+' -> getPhone result rest\n        | c when c = '-' || Char.IsDigit(c) -> getPhone (result + first.ToString()) rest\n        | _ -> \n            if result = \"\" || result.Length < 13 then\n                None\n            else \n                Some (result , s)\n    \nlet rec getName (result:string) (s:string) =\n    let first,rest = slice s\n    match first with\n    | '<' -> getName result rest   \n    | '>' -> Some (result , rest)\n    | c  -> getName (result + first.ToString()) rest\n\n\nlet rec getAddress (result:string) (s:string) =\n    if s = \"\" then\n        if result <> \"\" then\n            Some (result.Replace(\"_\",\" \").Trim() , s)\n        else\n            None\n    else\n        let first,rest = slice s\n        match first with\n        | c when c <> '+' && c <> '<' -> \n            let the = if Char.IsLetter(c) || Char.IsDigit(c) || c = '.' || c = '_' || c = ' ' || c = '-' then c.ToString() else \"\"\n            let the = if result.EndsWith(\" \") && the = \" \" then \"\" else the\n            getAddress (result + the) rest\n        | _ -> \n            if result <> \"\" then\n                Some (result.Replace(\"_\",\" \").Trim() , s)\n            else\n                None\n\n\n\nlet rec read (s:string) (p:Person) =\n    if s = \"\" then\n        if p.Address <> \"\" && p.Name <> \"\" && p.Phone <> \"\" then\n            Some p\n        else \n            None\n    else\n        match s.[0] with\n        | '+' -> \n            match getPhone \"\" s with \n            | Some (phone , rest) -> read rest {p with Phone = phone}\n            | None -> None\n        | '<' -> \n            match getName \"\" s with\n            | Some (name , rest) -> read rest {p with Name = name}\n            | None -> None\n        | c when Char.IsLetter(c) || Char.IsDigit(c) ->\n            match getAddress \"\" s with\n            | Some (address , rest) -> read rest {p with Address = if p.Address = \"\" then address else p.Address + \" \" + address}\n            | None -> None \n        | _ -> read (skip s) p\n        \nlet readLine (s:string) =\n    let person = {Phone = \"\"; Address = \"\"; Name = \"\";}\n    read s person\n    \n\nlet phone(s: string) (num: string): string =\n    let people = (skip s).Split([|\"\n\"|],StringSplitOptions.RemoveEmptyEntries)\n                    |> Array.map (fun x -> x.Trim())\n                    |> Array.map readLine\n                    |> Array.choose (function | Some x -> Some x | None -> None)\n    \n\n    let peopleHavingNum = people |> Array.filter (fun x -> x.Phone = num)\n    if peopleHavingNum.Length = 0 then\n        \"Error => Not found: \" + num\n    elif peopleHavingNum.Length = 1 then\n        let p = peopleHavingNum.[0]\n        sprintf \"Phone => %s, Name => %s, Address => %s\" p.Phone p.Name p.Address\n    else\n        \"Error => Too many people: \" + num\n    \n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85227,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\ntype PhoneEntry = {\n    name:string\n    phone: string\n    address: string\n}\n\nlet (|Match|_|) pattern input =\n   let m = Regex.Match(input,pattern) \n   if (m.Success) then Some m.Groups.[1].Value else None  \n\nlet parseEntry text = \n    let numberPattern = \"\\+(\\d{1,2}-\\d{3}-\\d{3}-\\d{4})\"\n    let namePattern = \"<([^>]*)>\"\n\n    let (Match numberPattern phone) = text\n    let (Match namePattern name) = text\n    let address = \n        text.Replace(\"<\" + name + \">\", \"\").Replace(\"+\" + phone, \"\").Replace(\"_\", \" \")\n        |> Seq.filter (fun c -> Char.IsLetter c || Char.IsWhiteSpace c || Char.IsNumber c || c = '-' || c = '.')\n        |> String.Concat\n        |> fun s -> s.Trim().Replace(\"  \", \" \")\n    { name = name; phone = phone; address = address }\n\nlet phone(s: string) (num: string): string =\n    s.Split('\n')\n    |> Seq.filter (fun s -> not (String.IsNullOrWhiteSpace <| s))\n    |> Seq.map parseEntry\n    |> Seq.toList\n    |> List.groupBy (fun entry -> entry.phone)\n    |> List.tryFind (fun (key, _) -> key = num)\n    |> function\n        | Some (key, [entry]) -> sprintf \"Phone => %s, Name => %s, Address => %s\" entry.phone entry.name entry.address\n        | Some (key, entries) -> sprintf \"Error => Too many people: %s\" num\n        | None -> sprintf \"Error => Not found: %s\" num","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56bdd0aec5dc03d7780010a5":[{"id":85228,"user_id":645,"body":"let nextHigher n =\n    let o = n &&& -n\n    n + o ||| ((n ^^^ n + o) \/ o >>> 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85229,"user_id":645,"body":"let nextHigher n =\n    let o = n &&& -n\n    n + o ||| ((n ^^^ n + o) \/ o >>> 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85230,"user_id":53,"body":"let nextHigher n =\n    let r = n &&& -n\n    let p = n + r\n    let q = (n ^^^ p) \/ (4 * r)\n    p ||| q","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85231,"user_id":null,"body":"open System\n\nlet nextHigher n =\n    Seq.initInfinite (fun x -> x + n + 1) |> \n    Seq.filter (fun x -> (Convert.ToString(n, 2) |> Seq.filter ((=)'1') |> Seq.length) = (Convert.ToString(x, 2) |> Seq.filter ((=)'1') |> Seq.length)) |>\n    Seq.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85232,"user_id":null,"body":"open System\nlet nextHigher (n:int) =\n    \/\/ your code here\n    let bin = Convert.ToString(n, 2)\n    let countOnes = bin |> Seq.sumBy System.Globalization.CharUnicodeInfo.GetDigitValue\n    let rec next (start: int) = \n        let binStart = Convert.ToString(start, 2)\n        let countOnesStart = binStart |> Seq.sumBy System.Globalization.CharUnicodeInfo.GetDigitValue\n        if countOnes = countOnesStart then start else next (start+1)\n\n    next (n+1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85233,"user_id":null,"body":"open System\n\nlet binaryDigitsIn (n : int) = \n    Convert.ToString(n, 2)\n    |> Seq.filter (fun x -> x = '1')\n    |> Seq.length\n\nlet nextHigher n =\n        \n    let digits = binaryDigitsIn n\n    \n    let rec nextHigher' last =\n        match binaryDigitsIn last with\n        | x when x = digits -> last\n        | _ -> nextHigher' <| last + 1\n    \n    nextHigher' <| n + 1\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85234,"user_id":null,"body":"let asBits n =\n    let rec loop (bits: int list) n =\n        match System.Math.DivRem(n, 2) with\n        | 0, 0 -> bits\n        | quotient, remainder -> loop (remainder::bits) quotient\n    loop [] n\n\nlet bitsToInt (bits: int list) =\n    bits\n    |> List.rev\n    |> List.mapi (fun index bit -> (pown 2 index) * bit)\n    |> List.sum\n\nlet doBitFlipping (bits: int list) =\n    \/\/ For example 1011100 becomes 1100011\n    let folder item (flippingCompleted, acc: int list) =\n        match flippingCompleted, item::acc with\n        | false, 0::1::xs -> true, 1::0::(xs |> List.sort)\n        | _, acc' -> flippingCompleted, acc'\n    List.foldBack folder bits (false, [])\n    |> snd\n\nlet nextHigher n =\n    n\n    |> asBits\n    |> (fun xs -> 0::xs)\n    |> doBitFlipping\n    |> bitsToInt\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85235,"user_id":null,"body":"let rec intToBinary i =\n    match i with\n    | 0 | 1 -> string i\n    | _ ->\n        let bit = string (i % 2)\n        (intToBinary (i \/ 2)) + bit\n\nlet getCount num = \n    intToBinary num |> Seq.toList |> List.filter (fun y -> y = '1') |> List.length\n\nlet repeatUntilTrue num =\n    Seq.initInfinite (fun n -> n + num)\n    |> Seq.find (fun x -> x > num && getCount x = getCount num)\n    \nlet nextHigher n =\n    repeatUntilTrue n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56bf3287b5106eb10f000899":[{"id":85236,"user_id":null,"body":"open System\n\nlet isVowel ch = \"aeiou\" |> Seq.contains ch\n\nlet moveVowels (input:string) =\n    input |> Seq.toArray\n          |> Array.partition (isVowel)\n          |> fun (v,c) -> String(Array.append c v)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85237,"user_id":null,"body":"let moveVowels (input:string) =\n    let isVowel = System.Char.ToLower >> function\n           | 'a' | 'e' | 'i' | 'o' | 'u' -> true\n           | _ -> false\n    in\n    (String.filter (isVowel >> not) input) + (String.filter (isVowel) input)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85238,"user_id":null,"body":"open System\n\nlet moveVowels (input : string) =\n     let nonVowels, vowels =\n        input.ToCharArray()\n        |> Array.partition (fun (c : char) -> \"aeiou\".IndexOf(c) = -1)\n     String nonVowels + String vowels\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85239,"user_id":null,"body":"open System\nlet moveVowels (input:string) =\n  input\n  |> Seq.toList \n  |> List.partition (fun x -> not (List.contains x ['a'; 'e'; 'i'; 'o'; 'u'])) \n  |> fun (x, y) -> x@y |> List.toArray |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85240,"user_id":null,"body":"open System\n\nlet vowels = ['a'; 'e'; 'i'; 'o'; 'u']\n\nlet moveVowels (input:string) =\n    let rec move (text: char list) (start: char list) (suffix: char list) =\n        match text with\n        | [] -> start @ suffix |> String.Concat\n        | h::t when vowels |> List.contains h -> move t start (suffix @ [h])\n        | h::t -> move t (start @ [h]) suffix\n    move (input |> Seq.toList) [] []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85241,"user_id":null,"body":"open System\n\nlet moveVowels (input:string) =\n  Seq.toList input\n    |> List.partition (fun c -> List.contains (Char.ToLower c) ['a'; 'e'; 'i'; 'o'; 'u';])\n    |> (fun (vs, cs) -> cs @ vs)\n    |> List.toArray\n    |> String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85242,"user_id":null,"body":"open System\nlet moveVowels (input:string) =\n    input\n    |> Seq.map string\n    |> Seq.fold (fun (text, vowels) c -> if \"aeiou\".Contains(c) then (text, vowels + c) else (text + c, vowels)) (\"\", \"\")\n    ||> (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85243,"user_id":null,"body":"let moveVowels (input: string) =\n    let vowels = [ 'a'; 'e'; 'i'; 'o'; 'u' ]\n    let isVowel = fun c -> vowels |> List.contains c\n    let allVowels = input |> String.filter isVowel\n    let withoutVowels = input |> String.filter (isVowel >> not)\n    withoutVowels + allVowels","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85244,"user_id":759,"body":"open System\nlet moveVowels (input:string) =\n  input\n  |> Seq.groupBy (fun c -> (c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'))\n  |> Seq.sortBy (fun (a, _) -> a)\n  |> Seq.map (fun (_, b) -> String.Concat b)\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85245,"user_id":null,"body":"open System\nlet moveVowels (input:string) =\n    let vowels = new Collections.Generic.SortedSet<Char>([|'a'; 'e'; 'i'; 'o'; 'u'|])\n    let sbCons = new Text.StringBuilder()\n    let sbVowels= new Text.StringBuilder()\n\n    input\n    |>Seq.iter(fun c -> \n                        if vowels.Contains(c) then \n                            sbVowels.Append(c)|>ignore \n                        else \n                            sbCons.Append(c)|>ignore \n                )\n    \n    sbCons.Append(sbVowels).ToString()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56c04261c3fcf33f2d000534":[{"id":85246,"user_id":null,"body":"let doubles maxk maxn = \n    seq {\n        for k = 1 to maxk do\n        for n = 1 to maxn do\n        yield 1. \/ (float k * (float n + 1.) ** (2. * float k))\n    }\n    |> Seq.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85247,"user_id":492,"body":"open System\n\nlet doubles maxk maxn = \n    let v (k: int) (n: int) =\n        let kk = double(k)\n        let nn = double(n)\n        1.0 \/ (kk * Math.Pow(nn + 1.0, 2.0 * kk))\n    [for k in 1..maxk do for n in 1..maxn do yield v k n] |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85248,"user_id":null,"body":"let v (k:float) (n:float) = 1.0 \/ (k *  (n + 1.0) ** (2.0*k))\nlet u k N = [|for n in 1 .. N -> v k ((float)n)|] |> Array.sum\nlet S K N = [|for k in 1 .. K -> u ((float)k) N|] |> Array.sum\nlet doubles maxK maxN = S maxK maxN","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85249,"user_id":492,"body":"open System\n\nlet doubles maxk maxn = \n    let v (k: int) (n: int) =\n        let kk = double(k)\n        let nn = double(n)\n        1.0 \/ (kk * Math.Pow(nn + 1.0, 2.0 * kk))\n    [for k in 1..maxk do for n in 1..maxn do yield v k n] |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85250,"user_id":null,"body":"\nlet force (k, n) = 1.0 \/ (float k * ((float n + 1.0)) ** (2.0 * float k))\n\nlet doubles maxk maxn =\n    List.allPairs [1..maxk] [1..maxn]\n    |> List.sumBy force","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85251,"user_id":null,"body":"let doubles maxk maxn = \n  let ns = {2 .. (maxn + 1)} |> Seq.map (fun x -> float (x * x))\n  {1 .. maxk}\n  |> Seq.map float\n  |> Seq.map (\n    fun k ->\n      ns\n      |> Seq.map (fun n -> 1. \/ (k * n ** k))\n      |> Seq.sum\n  )\n  |> Seq.sum\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85252,"user_id":null,"body":"let doubles maxk maxn = \n  let sumrow k n =\n    let power = (k |> float) * 2.0\n    {2..(n + 1)} |> Seq.sumBy (fun x -> 1.0 \/ (x |> float)**power) |>\n    (fun y -> y \/ (k |> float))\n  {1..maxk} |> Seq.sumBy (fun k -> (sumrow k maxn))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85253,"user_id":53,"body":"let doubles maxk maxn = \n    let mutable sum = 0.0\n    let mutable k = 1.0\n    let mutable n = 0.0\n    let mutable ans = []\n    while int(k) <= maxk do\n        n <- 1.0\n        while int(n) <= maxn do\n            sum <- sum + 1.0 \/ (k * (n + 1.0) ** (2.0 * k))\n            n <- n + 1.0\n        k <- k + 1.0\n    sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85254,"user_id":null,"body":"let v(k,n)=\n    1.0\/(float(k)*float(n+1)**float(2*k))\n                \nlet doubles maxk maxn = \n  let mutable u_KN=0.0 \n  for k in [1..maxk] do\n      for n in [1..maxn] do\n          u_KN<-u_KN+v(k,n)\n  u_KN        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85255,"user_id":168,"body":"let doubles (maxk: int) (maxn: int) : float =\n  Seq.sum <| seq \n    { for k in 1 .. maxk do\n        for n in 1 .. maxn ->\n          1.0 \/ (float (n + 1) ** float (2 * k) * float k) }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56c5847f27be2c3db20009c3":[{"id":85256,"user_id":null,"body":"let ss = @\"1-kiwi\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\"\nlet ssa = \n    ss.Split '\n'\n    |> Array.map (fun s -> s.Split '-')\n    |> Array.map(fun s -> s.[1])\n\nlet rec subtractSum n =\n    match n - (n |> string |> Seq.map (fun s -> s|>int) |> Seq.map (fun q -> q - 48) |> Seq.sum) with\n    | o when o < 101 -> ssa.[o - 1]\n    | o -> subtractSum o\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85257,"user_id":null,"body":"let subtractSum n = \"apple\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85258,"user_id":645,"body":"let subtractSum _ = \"apple\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85259,"user_id":null,"body":"let sumOfDitits num =\n    let rec inner sum curr =\n        if curr<=0\n        then sum\n        else inner (curr%10 + sum) (curr\/10)\n    inner 0 num\n\nlet rec subtractSum n =\n  match sumOfDitits n - n with\n  | 1 | 3 | 26 | 24 | 47 | 49 | 68 | 70 | 91 | 93 -> \"kiwi\"\n  | 2 | 21 | 23 | 42 | 44 | 46 | 65 | 67 | 69 | 88 -> \"pear\"\n  | 4 | 6 | 25 | 29 | 48 | 50 | 71 | 73 | 92 | 94 | 96 -> \"banana\"\n  | 5 | 7 | 28 | 30 | 32 | 51 | 53 | 74 | 76 | 95 | 97 -> \"melon\"\n  | 8 | 10 | 12 | 31 | 33 | 52 | 56 | 75 | 77 | 79 | 98 | 100 -> \"pineapple\"\n  | 9 | 18 | 27 | 36 | 45 | 54 | 63 | 72 | 81 | 90 | 99 -> \"apple\"\n  | 11 | 13 | 34 | 55 | 57 | 59 | 78 | 80 -> \"cucumber\"\n  | 14 | 16 | 35 | 37 | 39 | 58 | 60 | 83 -> \"orange\"\n  | 15 | 19 | 17 | 38 | 40 | 61 | 82 | 84 | 86 -> \"grape\"\n  | 20 | 22 | 41 | 43 | 62 | 64 | 66 | 85 | 87 | 89 -> \"cherry\"\n  | x -> subtractSum x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85260,"user_id":null,"body":"\nlet kiwi = set [1; 3; 24; 26; 47; 49; 68; 70; 91; 93]\nlet pear = set [2; 21; 23; 42; 44; 46; 65; 67; 69; 88]\nlet banana = set [4; 6; 25; 29; 48; 50; 71; 73; 92; 94; 96]\nlet melon = set [5; 7; 28; 30; 32; 51; 53; 74; 76; 95; 97]\nlet pineapple = set [8; 10; 12; 31; 33; 52; 56; 75; 77; 79; 98; 100]\nlet apple = set [9; 18; 27; 36; 45; 54; 63; 72; 81; 90; 99]\nlet cucumber = set [11; 13; 34; 55; 57; 59; 78; 80]\nlet orange = set [14; 16; 35; 37; 39; 58; 60; 83]\nlet grape = set [15; 17; 19; 38; 40; 61; 82; 84; 86]\nlet cherry = set [20; 22; 41; 43; 62; 64; 66; 85; 87; 89]\n\nlet sets = [(kiwi, \"kiwi\"); (pear, \"pear\"); (banana, \"banana\"); (melon, \"melon\");\n                (pineapple, \"pineapple\"); (apple, \"apple\"); (cucumber, \"cucumber\");\n                (orange, \"orange\"); (grape, \"grape\"); (cherry, \"cherry\")]\n\nlet toDigits = Seq.unfold (fun state -> if state = 0 then None else Some (state % 10, state \/ 10))\nlet rec subtractSum n =\n    let n = n - (toDigits n |> Seq.sum)\n    match Seq.tryFind (fun (s, _) -> Set.contains n s) sets with\n    | Some (_, s) -> s\n    | None -> subtractSum n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85261,"user_id":null,"body":"let fruits =\"\"\"1-kiwi\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\"\"\".Split('\n') |> Array.map (fun x -> x.Split('-').[1])\n\nlet rec subtractSum n = \n    let digitSum = n - (string n |> Seq.sumBy (fun x -> x |> string |> int))\n    match digitSum with\n    | x when x <= 100 -> fruits.[x - 1]\n    | _ -> subtractSum digitSum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85262,"user_id":null,"body":"let digitsFromNumber (n:int) =\n    let stringNumber = string n\n    stringNumber.ToCharArray()\n    |> Array.map(fun c -> ((int) c)-48)\n\nlet sumDigits (number: int) = \n    Array.sum (digitsFromNumber number)\n\n\nlet fruitTable = [ (1,\"kiwi\");(2,\"pear\");(3,\"kiwi\");(4,\"banana\");(5,\"melon\");(6,\"banana\");(7,\"melon\");(8,\"pineapple\");(9,\"apple\");(10,\"pineapple\");(11,\"cucumber\");(12,\"pineapple\");(13,\"cucumber\");(14,\"orange\");(15,\"grape\");(16,\"orange\");(17,\"grape\");(18,\"apple\");(19,\"grape\");(20,\"cherry\");(21,\"pear\");(22,\"cherry\");(23,\"pear\");(24,\"kiwi\");(25,\"banana\");(26,\"kiwi\");(27,\"apple\");(28,\"melon\");(29,\"banana\");(30,\"melon\");(31,\"pineapple\");(32,\"melon\");(33,\"pineapple\");(34,\"cucumber\");(35,\"orange\");(36,\"apple\");(37,\"orange\");(38,\"grape\");(39,\"orange\");(40,\"grape\");(41,\"cherry\");(42,\"pear\");(43,\"cherry\");(44,\"pear\");(45,\"apple\");(46,\"pear\");(47,\"kiwi\");(48,\"banana\");(49,\"kiwi\");(50,\"banana\");(51,\"melon\");(52,\"pineapple\");(53,\"melon\");(54,\"apple\");(55,\"cucumber\");(56,\"pineapple\");(57,\"cucumber\");(58,\"orange\");(59,\"cucumber\");(60,\"orange\");(61,\"grape\");(62,\"cherry\");(63,\"apple\");(64,\"cherry\");(65,\"pear\");(66,\"cherry\");(67,\"pear\");(68,\"kiwi\");(69,\"pear\");(70,\"kiwi\");(71,\"banana\");(72,\"apple\");(73,\"banana\");(74,\"melon\");(75,\"pineapple\");(76,\"melon\");(77,\"pineapple\");(78,\"cucumber\");(79,\"pineapple\");(80,\"cucumber\");(81,\"apple\");(82,\"grape\");(83,\"orange\");(84,\"grape\");(85,\"cherry\");(86,\"grape\");(87,\"cherry\");(88,\"pear\");(89,\"cherry\");(90,\"apple\");(91,\"kiwi\");(92,\"banana\");(93,\"kiwi\");(94,\"banana\");(95,\"melon\");(96,\"banana\");(97,\"melon\");(98,\"pineapple\");(99,\"apple\");(100,\"pineapple\") ]\n\nlet rec subtractSum n =\n    let result = n - (sumDigits n)\n    match result with\n    |x when x>100 -> subtractSum x\n    |_ -> fruitTable\n            |> List.where(fun (number,name) -> number = result)\n            |> List.exactlyOne\n            |> fun (number,name) -> name","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85263,"user_id":null,"body":"let rec sumAllDigits n =\n    let last = n % 10\n    let removedDigit = (int)n \/ 10\n    match removedDigit with \n    | 0 -> last\n    | _ -> last + (sumAllDigits removedDigit)\n    \nlet getFruit (number: int) : string =\n    let fruits : string array = [| \"kiwi\"; \"pear\"; \"kiwi\"; \"banana\"; \"melon\"; \"banana\"; \"melon\"; \"pineapple\"; \"apple\"; \"pineapple\"; \"cucumber\"; \"pineapple\"; \"cucumber\"; \"orange\"; \"grape\"; \"orange\"; \"grape\"; \"apple\"; \"grape\"; \"cherry\"; \"pear\"; \"cherry\"; \"pear\"; \"kiwi\"; \"banana\"; \"kiwi\"; \"apple\"; \"melon\"; \"banana\"; \"melon\"; \"pineapple\"; \"melon\"; \"pineapple\"; \"cucumber\"; \"orange\"; \"apple\"; \"orange\"; \"grape\"; \"orange\"; \"grape\"; \"cherry\"; \"pear\"; \"cherry\"; \"pear\"; \"apple\"; \"pear\"; \"kiwi\"; \"banana\"; \"kiwi\"; \"banana\"; \"melon\"; \"pineapple\"; \"melon\"; \"apple\"; \"cucumber\"; \"pineapple\"; \"cucumber\"; \"orange\"; \"cucumber\"; \"orange\"; \"grape\"; \"cherry\"; \"apple\"; \"cherry\"; \"pear\"; \"cherry\"; \"pear\"; \"kiwi\"; \"pear\"; \"kiwi\"; \"banana\"; \"apple\"; \"banana\"; \"melon\"; \"pineapple\"; \"melon\"; \"pineapple\"; \"cucumber\"; \"pineapple\"; \"cucumber\"; \"apple\"; \"grape\"; \"orange\"; \"grape\"; \"cherry\"; \"grape\"; \"cherry\"; \"pear\"; \"cherry\"; \"apple\"; \"kiwi\"; \"banana\"; \"kiwi\"; \"banana\"; \"melon\"; \"banana\"; \"melon\"; \"pineapple\"; \"apple\"; \"pineapple\" |]\n    fruits.[number-1]\n\nlet rec subtractSum n =\n    let sum = n - (sumAllDigits n)\n    match sum with\n    | n when n < 100 -> getFruit sum\n    | _ -> subtractSum sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85264,"user_id":null,"body":"let rec sumAllDigits n =\n    let last = n % 10\n    let removedDigit = (int)n \/ 10\n    match removedDigit with \n    | 0 -> last\n    | _ -> last + (sumAllDigits removedDigit)\n    \nlet getFruit (number: int) : string =\n    printfn \"getting fruit\"\n    let fruits : string array = [| \"kiwi\"; \"pear\"; \"kiwi\"; \"banana\"; \"melon\"; \"banana\"; \"melon\"; \"pineapple\"; \"apple\"; \"pineapple\"; \"cucumber\"; \"pineapple\"; \"cucumber\"; \"orange\"; \"grape\"; \"orange\"; \"grape\"; \"apple\"; \"grape\"; \"cherry\"; \"pear\"; \"cherry\"; \"pear\"; \"kiwi\"; \"banana\"; \"kiwi\"; \"apple\"; \"melon\"; \"banana\"; \"melon\"; \"pineapple\"; \"melon\"; \"pineapple\"; \"cucumber\"; \"orange\"; \"apple\"; \"orange\"; \"grape\"; \"orange\"; \"grape\"; \"cherry\"; \"pear\"; \"cherry\"; \"pear\"; \"apple\"; \"pear\"; \"kiwi\"; \"banana\"; \"kiwi\"; \"banana\"; \"melon\"; \"pineapple\"; \"melon\"; \"apple\"; \"cucumber\"; \"pineapple\"; \"cucumber\"; \"orange\"; \"cucumber\"; \"orange\"; \"grape\"; \"cherry\"; \"apple\"; \"cherry\"; \"pear\"; \"cherry\"; \"pear\"; \"kiwi\"; \"pear\"; \"kiwi\"; \"banana\"; \"apple\"; \"banana\"; \"melon\"; \"pineapple\"; \"melon\"; \"pineapple\"; \"cucumber\"; \"pineapple\"; \"cucumber\"; \"apple\"; \"grape\"; \"orange\"; \"grape\"; \"cherry\"; \"grape\"; \"cherry\"; \"pear\"; \"cherry\"; \"apple\"; \"kiwi\"; \"banana\"; \"kiwi\"; \"banana\"; \"melon\"; \"banana\"; \"melon\"; \"pineapple\"; \"apple\"; \"pineapple\" |]\n    fruits.[number-1]\n\nlet rec subtractSum n =\n    let sum = n - (sumAllDigits n)\n    match sum with\n    | n when n < 100 -> getFruit sum\n    | _ -> subtractSum sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85265,"user_id":null,"body":"let subtractSum(n : int) =\n    \"apple\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56cac350145912e68b0006f0":[{"id":85266,"user_id":null,"body":"let arrange (s: string) =\n    \n    let words = s.Split()\n    \n    let lastIndex = words.Length - 1\n    \n    let lengthOf i = words.[i].Length\n    \n    let mustSwapAt i =\n        match i = lastIndex with\n        | true -> false\n        | _ -> \n            let check = match i % 2 with | 0 -> (>) | _ -> (<)\n            check (lengthOf i) (lengthOf (i + 1))\n    \n    let swapAt i =\n        let move = words.[i]\n        words.[i] <- words.[i + 1]\n        words.[i + 1] <- move\n\n    let lowerOrUpperAt i =\n        words.[i] <-\n            match i % 2 with\n            | 0 -> words.[i].ToLower()\n            | _ -> words.[i].ToUpper()\n\n    for i in 0 .. lastIndex do\n        if mustSwapAt i then swapAt i\n        lowerOrUpperAt i\n    String.concat \" \" words\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85267,"user_id":492,"body":"open System\n\nlet arrange (s: string) =\n    let rec up (lst: list<string>) =\n        match lst with\n        | [] -> []\n        | [w] -> [w.ToLower()]\n        | w1::w2::ws ->\n            if (String.length w1 <= String.length w2) then w1.ToLower() :: (down (w2 :: ws))\n            else w2.ToLower() :: (down (w1 :: ws))\n    and down (lst: list<string>) = \n        match lst with\n        | [] -> []\n        | [w] -> [w.ToUpper()]\n        | w1::w2::ws ->\n            if (String.length w1 >= String.length w2) then w1.ToUpper() :: (up (w2 :: ws))\n            else w2.ToUpper() :: (up (w1 :: ws))\n    if (s = \"\") then \"\"\n    else\n        let r1: list<string> = s.Split([|' '|]) |> Seq.toList\n        (up r1) |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85268,"user_id":492,"body":"open System\n\nlet arrange (s: string) =\n    let rec up (lst: list<string>) =\n        match lst with\n        | [] -> []\n        | [w] -> [w.ToLower()]\n        | w1::w2::ws ->\n            if (String.length w1 <= String.length w2) then w1.ToLower() :: (down (w2 :: ws))\n            else w2.ToLower() :: (down (w1 :: ws))\n    and down (lst: list<string>) = \n        match lst with\n        | [] -> []\n        | [w] -> [w.ToUpper()]\n        | w1::w2::ws ->\n            if (String.length w1 >= String.length w2) then w1.ToUpper() :: (up (w2 :: ws))\n            else w2.ToUpper() :: (up (w1 :: ws))\n    if (s = \"\") then \"\"\n    else\n        let r1: list<string> = s.Split([|' '|]) |> Seq.toList\n        (up r1) |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85269,"user_id":null,"body":"let rec arrange (s: string) =\n    let l = s.ToLower().Split ' '\n    \n    Array.tail l\n    |> Array.fold (fun (i, prev, list) el -> \n        if (if i % 2 = 0 then (<=) else (>=)) (String.length prev) (String.length el)\n        then (i + 1, el, prev :: list) \n        else (i + 1, prev, el :: list)) \n        (0, Array.head l, [])\n    |> fun (i, prev, list) -> prev :: list\n    |> List.rev\n    |> List.mapi(fun i el -> if i % 2 = 0 then el else el.ToUpper())\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85270,"user_id":null,"body":"let rec arr (less : bool) (ss : string list) : string list =\n    match ss with\n    | []  -> ss\n    | [s] -> ss\n    | a::b::tail when      less  && String.length a > String.length b -> b::(arr (not less) (a::tail))\n    | a::b::tail when (not less) && String.length a < String.length b -> b::(arr (not less) (a::tail))\n    | a::b::tail                                                      -> a::(arr (not less) (b::tail))\n\nlet rec altCaps (lower : bool) (ss : string list) =\n    match ss with\n    | [] -> ss\n    | s::tail when lower -> (s.ToLower())::(altCaps (not lower) tail)\n    | s::tail            -> (s.ToUpper())::(altCaps (not lower) tail)\n\nlet arrange (s : string) =\n    s.Split ' '\n    |> Array.toList\n    |> arr true\n    |> altCaps true\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85271,"user_id":null,"body":"open System\n\nlet arrange (s: string) =\n    let arr = s.Split(' ') |> List.ofArray\n    let rec getList acc n = function\n        | [] -> acc\n        | [x] -> x::acc\n        | x::(s::xs as l) ->\n            let fLength = x |> Seq.length\n            let sLength = s |> Seq.length\n            let isTest = if (n % 2 = 0) then sLength < fLength else sLength > fLength\n            if (isTest) then getList (s::acc) (n+1) (x::xs)\n            else getList (x::acc) (n+1) (s::xs)\n    in\n    getList [] 0 arr\n    |> List.rev\n    |> List.mapi (fun  i s->\n            if i % 2 <> 0 then s.ToUpper() else s.ToLower()\n        )\n    |> List.reduce (fun acc i -> acc + \" \" + i)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85272,"user_id":null,"body":"open System\n\nlet arrange (s :string) =\n    let rec fRec (list: list<string>) res mode =\n        printfn \"%A %A\" list res\n        match list, res with\n        | [], _           -> \n            List.rev res \n            |> List.mapi (fun i (str :string) -> if i % 2 = 0 then str.ToLower() else str.ToUpper()) \n            |> List.reduce (fun a b -> a + \" \" + b)\n        | x :: xs, []      -> fRec xs [x] (not mode)\n        | x :: xs, y :: ys ->\n            printfn \"%A %A %A\" x y mode\n            match x, y with\n            | x, y when mode     && x.Length > y.Length -> fRec xs (y :: x :: ys) (not mode)\n            | x, y when not mode && x.Length < y.Length -> fRec xs (y :: x :: ys) (not mode)\n            | x, _                                      -> fRec xs (x :: y :: ys) (not mode)\n   \n    fRec (s.Split(' ') |> Array.toList) [] true\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85273,"user_id":168,"body":"let arrange (s: string) =\n  let case s (str: string) = if s > 0 then str.ToLower() else str.ToUpper()\n  let rec loop s = function\n    | x :: y :: xs when (String.length y - String.length x) * s < 0 ->\n      case s y :: loop (-s) (x :: xs)\n    | x :: y :: xs ->\n      case s x :: loop (-s) (y :: xs)\n    | [x] -> [case s x]\n    | [] -> []\n  s.Split(' ')\n  |> Array.toList\n  |> loop 1\n  |> String.concat \" \"\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85274,"user_id":null,"body":"let rearrange (s: string list) = \n  let rec isValid (s: string list) (ind: int) =\n    match s with\n    | ([]|[_]) -> true\n    | head::tail when (ind % 2 = 0) && ((String.length head) > (String.length (List.head tail))) -> false\n    | head::tail when (ind % 2 <> 0) && ((String.length head) < (String.length (List.head tail))) -> false\n    | head::tail -> (isValid tail (ind + 1))\n  \n  let rec rearrenger (s: string list) (ind: int) =\n    match s with\n    | ([]|[_]) -> s\n    | head::tail when (ind % 2 = 0) && ((String.length head) > (String.length (List.head tail))) -> [(List.head tail); head] @ (List.tail tail)\n    | head::tail when (ind % 2 <> 0) && ((String.length head) < (String.length (List.head tail))) -> [(List.head tail); head] @ (List.tail tail)\n    | head::tail -> [head] @ (rearrenger tail (ind + 1))\n  \n  let rec getResult (s: string list) =\n    if (isValid s 0) then\n      s\n    else\n      getResult (rearrenger s 0)\n  \n  getResult s\n\n\nlet arrange (s: string) =\n    s.Split(' ') |> List.ofArray |> rearrange |> \n    List.mapi (fun i x -> if (i % 2 = 0) then x.ToLower() else x.ToUpper()) |>\n    String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85275,"user_id":null,"body":"let arrange (s: string): string =\n    let newStr: string list = (s.Split [|' '|]) |> Array.toList\n     \n    let move (s1: string) (s2: string) = function\n        | true -> if s1.Length > s2.Length then (s2, s1) else (s1, s2)\n        | false -> if s1.Length < s2.Length then (s2, s1) else (s1, s2)\n\n    let rec loop (s1: string) (li: string list) (cond: bool) = seq {\n        if li.IsEmpty then yield s1\n        else\n            let ret, cur = move s1 li.Head cond\n            yield! seq {yield ret + \" \" ; yield! loop cur li.Tail (not cond)}\n    }\n    \n    loop newStr.Head newStr.Tail true \n    |> Seq.mapi (fun i x -> if i % 2 <> 0 then x.ToUpper() else x.ToLower()) \n    |> Seq.reduce (fun x y -> x + y)  \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56d904db9963e9cf5000037d":[{"id":85276,"user_id":null,"body":"let testit a b = a ||| b \/\/ Hmm is that right?","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85277,"user_id":168,"body":"let testit a b = a ||| b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85278,"user_id":645,"body":"let testit = (|||)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56dbe0e313c2f63be4000b25":[{"id":85279,"user_id":null,"body":"let vertMirror (s: string) =\n    s.Split '\n'\n    |> Array.map (fun x -> x.ToCharArray() |> Array.rev |> System.String)\n    |> String.concat \"\n\"\n\nlet horMirror (s: string) =\n    s.Split '\n'\n    |> Array.rev\n    |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85280,"user_id":null,"body":"open System\n\nlet splitlines (s: string) = s.Split('\n')\n\nlet joinlines (lines : string seq) = String.concat \"\n\" lines\n\nlet reverse (s : string) =\n    let array = s.ToCharArray()\n    Array.Reverse(array)\n    String(array)\n\nlet vertMirror =\n    splitlines\n    >> Seq.map reverse\n    >> joinlines\n\nlet horMirror =\n    splitlines\n    >> Seq.rev\n    >> joinlines\n    \nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85281,"user_id":492,"body":"let vertMirror (s: string) =\n    s.Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> new string(Array.rev (x.ToCharArray()))) |> String.concat \"\n\"\n\nlet horMirror (s: string) =\n    s.Split([|'\n'|]) |> Seq.toList |> List.rev |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85282,"user_id":null,"body":"let vertMirror (s: string) =\n  s.Split '\n'\n  |> Array.map (fun (str: string) -> str.ToCharArray() |> Array.rev |> System.String)\n  |> String.concat \"\n\"\n\nlet horMirror (s: string) =\n  s.Split '\n'\n  |> Array.rev\n  |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85283,"user_id":null,"body":"open System\n\nmodule UsefulFunctions =\n        \/\/\/ Splits string into a list of strings separated by specified key\n        let splitString (s:string) (key:string) : string list  =\n            let keyList = [key] \n            let splits = s.Split (List.toArray keyList,StringSplitOptions.RemoveEmptyEntries)\n            Array.toList splits\n\nlet vertMirror (s: string) : string =\n        let key = \"\n\"\n        let splits = UsefulFunctions.splitString s key\n        let reversed = List.map(fun (x:string) -> (System.String (Array.rev (x.ToCharArray())))) splits\n        List.reduce(fun f s -> f + \"\n\" + s) reversed\n        \n                       \nlet horMirror (s: string) =\n    let key = \"\n\"\n    let splits = UsefulFunctions.splitString s key\n    let reversed = List.rev splits\n    List.reduce(fun f s -> f + \"\n\" + s) reversed\n\nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85284,"user_id":null,"body":"open System\n\nmodule String =\n    let split (c: char) (s: string) = s.Split(c)\n    let join (glue: string) (s: string array) = String.Join(glue, s)\n\nlet parse =\n    (String.split '\n') >> (Array.map Seq.toArray)\n\nlet render (s: char array array) =\n    s |> Array.map String |> String.join \"\n\"\n\nlet vertMirror =\n    parse >> (Array.map Array.rev) >> render\n\nlet horMirror =\n    parse >> Array.rev >> render\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85285,"user_id":null,"body":"open System\n\nmodule String =\n    let split (c: char) (s: string) = s.Split(c)\n    let join (glue: string) (s: string array) = String.Join(glue, s)\n\nlet parse (s: string) =\n    s |> String.split '\n' |> Array.map Seq.toArray\n\nlet render (s: char array array) =\n    s |> Array.map String |> String.join \"\n\"\n\nlet vertMirror (s: string) =\n    s |> parse |> Array.map Array.rev |> render\n\nlet horMirror (s: string) =\n    s |> parse |> Array.rev |> render\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85286,"user_id":null,"body":"let vertMirror (s: string) =\n  s.Split ()\n  |> Array.map (Seq.rev >> Seq.map string >> String.concat \"\")\n  |> String.concat \"\n\"\n\nlet horMirror (s: string) =\n  s.Split ()\n  |> Array.rev\n  |> String.concat \"\n\"\n    \nlet oper = (<|)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85287,"user_id":null,"body":"let vertMirror (s: string) =\n  s.Split '\n'\n  |> Array.map (Seq.rev >> Seq.map string >> String.concat \"\")\n  |> String.concat \"\n\"\n\nlet horMirror (s: string) =\n  s.Split '\n'\n  |> Array.rev\n  |> String.concat \"\n\"\n    \nlet oper = (<|)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85288,"user_id":null,"body":"open System\n\nlet horMirror (s: string) =\n    s.Split '\n'\n    |> Array.rev\n    |> String.concat \"\n\"\n\nlet vertMirror (s: string) =\n    s.Split '\n'\n    |> Array.map (fun x ->  x.ToCharArray()\n                            |> Array.rev\n                            |> String)\n    |> String.concat \"\n\"\n\nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56dbe7f113c2f63570000b86":[{"id":85289,"user_id":null,"body":"let rot (s: string) =\n    s.Split('\n')\n    |> Seq.map (Seq.rev >> System.String.Concat)\n    |> Seq.rev\n    |> String.concat \"\n\"\n\nlet selfieAndRot (s: string) =\n    let upper = s.Split('\n')\n                |> Seq.map (fun row -> row.PadRight(2 * row.Length, '.'))\n                |> String.concat \"\n\"\n    let lower = rot upper\n    upper + \"\n\" + lower\n\nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85290,"user_id":null,"body":"open System\n\nlet splitLines (s : string) = s.Split('\n')\n\nlet joinLines = String.concat \"\n\"\n\nlet apply transform =\n    splitLines\n    >> transform\n    >> joinLines\n\nlet reverse (s : string) =\n    let array = s.ToCharArray()\n    Array.Reverse(array)\n    String(array)\n\nlet rot' (lines : string[]) =\n    lines\n    |> Seq.map reverse\n    |> Seq.rev\n\nlet selfieAndRot' (lines : string[]) =\n    let padding = String('.', lines.[0].Length)\n    let padLeft line = padding + line\n    let padRight line = line + padding\n\n    lines\n    |> rot'\n    |> Seq.map padLeft\n    |> Seq.append (lines |> Seq.map padRight)\n\nlet rot = apply rot'\nlet selfieAndRot = apply selfieAndRot'\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85291,"user_id":null,"body":"let rot  (s: string) =\n    s |> Seq.rev |> Seq.toArray |> System.String\n\nlet selfieAndRot (s: string) =\n    let selfie = s.Split('\n') |> Array.map (fun s -> s + String.replicate s.Length \".\") |> String.concat \"\n\"\n    sprintf \"%s\n%s\" selfie (rot selfie)\n\nlet oper fcn s = \n  fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85292,"user_id":492,"body":"let vertMirror (s: string) =\n    s.Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> new string(Array.rev (x.ToCharArray()))) |> String.concat \"\n\"\n\nlet horMirror (s: string) =\n    s.Split([|'\n'|]) |> Seq.toList |> List.rev |> String.concat \"\n\"\n    \nlet rot  (s: string) = vertMirror (horMirror s)\n\nlet repStr i x = String.replicate i x\n\nlet selfieAndRot (s: string) =\n    let r1 = s.Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> x + (repStr (String.length x) \".\")) |> String.concat \"\n\"\n    let r2 = (rot s).Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> repStr (String.length x) \".\" + x) |> String.concat \"\n\"\n    r1 + \"\n\" + r2\n\nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85293,"user_id":null,"body":"let rec rot (s: string) =\n    match s with\n    | \"\" -> \"\"\n    | _ ->  (rot s.[1 ..]) + (sprintf \"%c\" s.[0])\n\n\nlet selfieAndRot (s:string) =\n    let rec  selfie str n=\n        match str with\n        |\"\" -> String.replicate n \".\"\n        |x when x.[0] = '\n' -> (String.replicate n \".\") + \"\n\" + selfie x.[1..] 0\n        | _ -> (sprintf \"%c\" str.[0]) + selfie str.[1..] (n + 1)\n    let selfieStr = selfie s 0\n    selfieStr + \"\n\" + rot selfieStr\n\n\nlet oper fcn s = \n  fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85294,"user_id":null,"body":"open System\n\nlet split (c:char) (s:string) = \n    let c' = [|c|]\n    s.Split(c', StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.ofArray\n\nlet rot (s: string) : string =\n    s |> Seq.map string |> Seq.rev |> String.concat \"\"\n\nlet padLeft (p:char) (s:string) =\n    s.PadRight(s.Length * 2, p)\n\nlet selfieAndRot (s:string) : string =\n    let r = s\n            |> split '\n'\n            |> Seq.map (padLeft '.')\n            |> String.concat \"\n\"\n    r + \"\n\" + (rot r)\n    \nlet oper f s = f s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85295,"user_id":null,"body":"let rot =\n  Seq.rev\n  >> Seq.map string\n  >> String.concat \"\"\n\nlet selfieAndRot (s: string) =\n  let t =\n    s.Split ()\n    |> Seq.map (fun l -> l + String.replicate (l.Length) \".\")\n    |> String.concat \"\n\"\n  t + \"\n\" + rot t\n\nlet oper = (<|)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85296,"user_id":null,"body":"open System\n\nlet rot (s : string) = s |> Seq.rev |> Seq.toArray |> System.String\n\nlet selfieAndRot (s: string) =\n    let padLeft (el : string) = String.replicate el.Length \".\" + el\n    let padRight (el: string) = el + String.replicate el.Length \".\"\n    let paddedSelfie = (\"\n\", s.Split '\n' |> Seq.map padRight) |> String.Join\n    let paddedRot = (\"\n\", (s |> rot).Split '\n' |> Seq.map padLeft) |> String.Join\n    paddedSelfie + \"\n\" + paddedRot\n\nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85297,"user_id":null,"body":"let rot (s: string) =\n    s.ToCharArray() \n    |> Array.rev\n    |> System.String\n\n\nlet selfieAndRot (s: string) =\n    let length = s.IndexOf('\n')\n    let dots = System.String('.', length)\n    let withDots = (s.Replace(\"\n\", dots+\"\n\") + dots)\n    withDots + \"\n\" + (rot withDots)\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85298,"user_id":null,"body":"open System\n\nlet rot  (s: string) = \n    s.Split('\n') |> \n    Array.map (Seq.rev >> Seq.map (fun x -> x.ToString()) >> String.concat \"\") |>\n    Array.rev |> String.concat \"\n\"\n\nlet selfieAndRot (s: string) =\n    (s.Split('\n') |>\n    Array.map (fun x -> x + (String.replicate x.Length \".\")) |>\n    String.concat \"\n\") \n    +\n    \"\n\"\n    +\n    (s.Split('\n') |> \n    Array.map (Seq.rev >> Seq.map (fun x -> x.ToString()) >> String.concat \"\") |>\n    Array.map (fun x -> (String.replicate x.Length \".\") + x) |>\n    Array.rev |> String.concat \"\n\")\n\nlet oper fcn = fcn ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56dbeec613c2f63be4000be6":[{"id":85299,"user_id":null,"body":"let splitLines (s : string) = s.Split('\n')\n\nlet joinLines (lines : string seq) = String.concat \"\n\" lines\n\nlet apply tranform =\n    splitLines\n    >> tranform\n    >> joinLines\n\nlet charAt index (s : string) = s.[index]\n\nlet diag1Sym' (lines : string[]) =\n    { 0 .. lines.[0].Length - 1 }\n    |> Seq.map (fun index ->\n        lines\n        |> Seq.map (charAt index)\n        |> Seq.toArray\n        |> System.String)\n\nlet rot90Clock' = Array.rev >> diag1Sym'\n\nlet selfieAndDiag1' (lines : string[]) =\n    lines\n    |> diag1Sym'\n    |> Seq.map2 (fun x y -> x + \"|\" + y) lines\n\nlet diag1Sym = apply diag1Sym'\nlet rot90Clock = apply rot90Clock'\nlet selfieAndDiag1 = apply selfieAndDiag1'\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85300,"user_id":492,"body":"let rec transpose = function\n    | (_::_)::_ as m -> List.map List.head m :: transpose (List.map List.tail m)\n    | _ -> []\n\nlet diag1Sym (s: string) =\n    let f = s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray() |> Seq.toList) |> Seq.toList |> transpose\n    f |> List.map (fun x -> new string (Array.ofList(x))) |> String.concat \"\n\"   \n\nlet rot90Clock (s: string) =\n    let f = s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray() |> Seq.toList) |> Seq.toList |> List.rev |> transpose\n    f |> List.map (fun x -> new string (Array.ofList(x))) |> String.concat \"\n\"   \n\nlet selfieAndDiag1 (s: string) =\n    let r1 = s.Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> x + \"|\")\n    let r2 = (diag1Sym s).Split([|'\n'|]) |> Seq.toList\n    List.map2 (fun x y -> x + y) r1 r2 |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85301,"user_id":492,"body":"let rec transpose = function\n    | (_::_)::_ as m -> List.map List.head m :: transpose (List.map List.tail m)\n    | _ -> []\n\nlet diag1Sym (s: string) =\n    let f = s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray() |> Seq.toList) |> Seq.toList |> transpose\n    f |> List.map (fun x -> new string (Array.ofList(x))) |> String.concat \"\n\"   \n\nlet rot90Clock (s: string) =\n    let f = s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray() |> Seq.toList) |> Seq.toList |> List.rev |> transpose\n    f |> List.map (fun x -> new string (Array.ofList(x))) |> String.concat \"\n\"   \n\nlet repStr i x = String.replicate i x\n\nlet selfieAndDiag1 (s: string) =\n    let r1 = s.Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> x + \"|\")\n    let r2 = (diag1Sym s).Split([|'\n'|]) |> Seq.toList\n    List.map2 (fun x y -> x + y) r1 r2 |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85302,"user_id":null,"body":"let getN (s: string) : int = s.Split('\n').Length\n\n\nlet getMatrixFromString (s: string) = s.Split('\n')\n\n\nlet getStringFromMatrix =\n    Array.map (Array.map string >> String.concat \"\")\n    >> String.concat \"\n\"\n\n\nlet diag1Sym (s: string) =\n    let n = getN s\n\n    let matrix = getMatrixFromString s\n\n    Array.init n (fun i -> Array.init n (fun j -> matrix.[j].[i]))\n    |> getStringFromMatrix\n\n\nlet rot90Clock (s: string) =\n    let n = getN s\n\n    let matrix = getMatrixFromString s\n\n    Array.init n (fun i -> Array.init n (fun j -> matrix.[n - j - 1].[i]))\n    |> getStringFromMatrix\n\n\nlet selfieAndDiag1 (s: string) =\n    let n = getN s\n    let matrix = getMatrixFromString s\n\n    let newMatrix =\n        Array.init n (fun i -> Array.init n (fun j -> matrix.[j].[i]))\n        |> Array.map (Array.map string >> String.concat \"\")\n\n    Array.map2 (fun a b -> a + \"|\" + b) matrix newMatrix\n    |> String.concat \"\n\"\n\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85303,"user_id":null,"body":"let getN (s: string) : int = s.Split('\n').Length\n\n\nlet getMatrixFromString (s: string) = s.Split('\n')\n\n\nlet getStringFromMatrix =\n    Array.map (Array.map string >> String.concat \"\")\n    >> String.concat \"\n\"\n\n\nlet diag1Sym (s: string) =\n    let n = getN s\n\n    let matrix = getMatrixFromString s\n\n    Array.init n (fun i -> Array.init n (fun j -> matrix.[j].[i]))\n    |> getStringFromMatrix\n\n\nlet rot90Clock (s: string) =\n    let n = getN s\n\n    let matrix = getMatrixFromString s\n\n    Array.init n (fun i -> Array.init n (fun j -> matrix.[n - j - 1].[i]))\n    |> getStringFromMatrix\n\n\nlet selfieAndDiag1 (s: string) =\n    let n = getN s\n    let matrix = getMatrixFromString s\n\n    let newMatrix =\n        Array.init n (fun i -> Array.init n (fun j -> matrix.[j].[i]))\n        |> Array.map (Array.map string >> String.concat \"\")\n\n    Array.init n (fun i -> matrix.[i] + \"|\" + newMatrix.[i])\n    |> String.concat \"\n\"\n\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85304,"user_id":null,"body":"let diag1Sym (s: string) =\n    s.Split('\n')\n    |> Array.map Seq.toArray\n    |> fun x -> Array.head x, Array.tail x\n    |> fun (h, t) ->\n        Array.fold (fun s x -> Array.map2 (fun s2 x2 -> s2 + string x2) s x) (h |> Array.map string) t     \n    |> String.concat \"\n\"    \n\nlet rot90Clock (s: string) =\n    (s |> diag1Sym).Split('\n')\n    |> Array.map (Seq.rev >> Seq.toArray >> System.String)\n    |> String.concat \"\n\"\n\nlet selfieAndDiag1 (s: string) =\n    let self = s.Split('\n')\n    let diag = (s |> diag1Sym).Split('\n')\n    Array.map2 (fun s d -> s + \"|\" + d) self diag\n    |> String.concat \"\n\"\n    \nlet oper fcn s = \n  fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85305,"user_id":null,"body":"let ofString (s: string) =\n  s.Split '\n'\n  |> Seq.map Seq.toList\n  |> Seq.toList\n  \nlet toString matrix =\n  matrix\n  |> Seq.map (Seq.map string >> String.concat \"\")\n  |> String.concat \"\n\"\n  \n\nlet diag1Sym (s: string) =\n  let matrix = s |> ofString\n  List.replicate matrix.Length []\n  |> Seq.foldBack\n    (List.map2 (fun y ys -> y :: ys))\n    matrix\n  |> toString\n\nlet rot90Clock (s: string) =\n  let matrix = s |> ofString\n  matrix\n  |> Seq.fold \n    (List.map2 (fun ys y -> y :: ys))\n    (List.replicate matrix.Length [])\n  |> toString\n  \nlet selfieAndDiag1 (s: string) =\n  let matrix = s |> ofString\n  List.replicate matrix.Length []\n  |> Seq.foldBack\n    (List.map2 (fun y ys -> y :: ys))\n    matrix\n  |> Seq.map2\n    (fun xs ys -> List.append xs ('|' :: ys))\n    matrix\n  |> toString\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85306,"user_id":null,"body":"open System\nopen System.Linq\n\ntype IndexedChar(ch: char, innerIndex: int, outerIndex: int) =\n    member this.ch = ch\n    member this.innerIndex = innerIndex\n    member this.outerIndex = outerIndex\n\ntype IndexedString(str: string, index: int) =\n    member this.str = str\n    member this.index = index\n\nlet diag1SymAsSeq(s: string) : string seq = \n    let strs = s.Split '\n'\n\n    let mapChars(indStr: IndexedString) : IndexedChar seq = \n        [0..indStr.str.Length-1]\n        |> Seq.map (fun i -> new IndexedChar(ch = indStr.str.ToCharArray().ElementAt(i), innerIndex = i, outerIndex = indStr.index))\n\n    let mapStrings(strs: string seq) : IndexedString seq = \n        [0..(strs |> Seq.length)-1]\n        |> Seq.map (fun i -> new IndexedString(str = strs.ElementAt(i), index = i))\n\n    strs\n    |> mapStrings\n    |> Seq.map mapChars\n    |> Seq.concat \n    |> Seq.groupBy (fun x -> x.innerIndex)\n    |> Seq.map (fun (key, values) -> values \n                                     |> Seq.map (fun v -> v.ch) \n                                     |> Seq.toArray\n                                     |> String)\n\nlet diag1Sym(s: string) =\n    s \n    |> diag1SymAsSeq\n    |> Seq.toArray\n    |> String.concat \"\n\"\n\nlet rot90Clock (s: string) =\n    s\n    |> diag1SymAsSeq\n    |> Seq.map (fun x -> x\n                         |> Seq.rev\n                         |> Seq.toArray\n                         |> String)\n    |> Seq.toArray\n    |> String.concat \"\n\"\n\nlet selfieAndDiag1 (s: string) =\n    let strs = s.Split '\n' |> Array.toSeq\n    let diag = diag1SymAsSeq s\n    Seq.zip strs diag\n    |> Seq.map (fun (a, b) -> a + \"|\" + b)\n    |> String.concat \"\n\"\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85307,"user_id":null,"body":"let diag1Sym (s: string) =\n    let n = s.IndexOf('\n')\n    let n1 = n + 1\n    System.String (Array.init s.Length (fun k -> s.[if k%n1=n then k else (k%n1)*n1 + (k\/n1)]))\n    \nlet rot90Clock (s: string) =\n    let n = s.IndexOf('\n')\n    let n1 = n + 1\n    System.String (Array.init s.Length (fun k -> s.[if k%n1=n then k else (n-1-(k%n1))*n1 + (k\/n1)]))\n        \n    \nlet selfieAndDiag1 (s: string) =\n    let sLines = s.Split ([| '\n' |])\n    let dsLines = (diag1Sym s).Split ([| '\n' |])\n    String.concat \"\n\" (seq { for i=0 to sLines.Length-1 do yield sLines.[i] + \"|\" + dsLines.[i] })\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85308,"user_id":null,"body":"open System\n\nlet getDiag (str: string array) (ind: int) =\n  str |> Array.map (fun x -> (x.[ind]).ToString()) |> String.concat \"\"\n\nlet diag1Sym (s: string) =\n    let arr = s.Split('\n')\n    [|0..((Array.length arr) - 1)|] |> Array.map (getDiag arr) |> String.concat \"\n\"\n    \nlet rot90Clock (s: string) =\n    let arr = s.Split('\n')\n    [|0..((Array.length arr) - 1)|] |> \n    Array.map ((getDiag arr) >> Seq.rev >> Seq.map (fun x -> x.ToString()) >> String.concat \"\") |> \n    String.concat \"\n\"\n\nlet selfieAndDiag1 (s: string) =\n    let arr = s.Split('\n')\n    [|0..((Array.length arr) - 1)|] |> Array.map (getDiag arr) |> \n    Array.zip arr |> Array.map (fun (a,b) -> a + \"|\" + b) |>\n    String.concat \"\n\"\n    \nlet oper fcn = fcn","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56dbf59b0a10feb08c000227":[{"id":85309,"user_id":null,"body":"let splitLines (s : string) = s.Split '\n'\nlet joinLines lines = lines |> String.concat \"\n\"\nlet apply transform = splitLines >> transform >> joinLines\n\nlet diag2Sym' (lines : string[]) =\n    let n = lines.Length - 1\n    seq {\n        for i in 0 .. n ->\n            [| for j in 0 .. n ->\n                lines.[n - j].[n - i] |]\n            |> System.String\n    }\n\nlet rot90Counter' (lines : string[]) =\n    let n = lines.Length - 1\n    seq {\n        for i in 0 .. n ->\n            [| for j in 0 .. n ->\n                lines.[j].[n - i] |]\n            |> System.String\n    }\n\nlet selfieDiag2Counterclock' lines =\n    Seq.map3 (sprintf \"%s|%s|%s\")\n        lines\n        (diag2Sym' lines)\n        (rot90Counter' lines)\n\nlet diag2Sym = apply diag2Sym'\nlet rot90Counter = apply rot90Counter'\nlet selfieDiag2Counterclock = apply selfieDiag2Counterclock'\n    \nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85310,"user_id":492,"body":"open System\n\nlet rec transpos = function\n    | (_::_)::_ as m -> List.map List.head m :: transpos (List.map List.tail m)\n    | _ -> []\n    \nlet rot90Counter (s: string) =\n    let f = s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray() |> Seq.toList) |> Seq.toList |> transpos |> List.rev\n    f |> List.map (fun x -> new string (Array.ofList(x))) |> String.concat \"\n\"  \n    \nlet diag2Sym (s: string) =\n    let f = s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray() |> Seq.toList) |> Seq.toList |> transpos |> List.rev\n    let g = f |> List.map (fun x -> List.rev x)\n    g |> List.map (fun x -> new string (Array.ofList(x))) |> String.concat \"\n\"  \n    \nlet selfieDiag2Counterclock (s: string) =\n    let r1 = s.Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> x + \"|\")\n    let r2 = (diag2Sym s).Split([|'\n'|]) |> Seq.toList |> List.map (fun x -> x + \"|\")\n    let r3 = (rot90Counter s).Split([|'\n'|]) |> Seq.toList\n    let r4 = List.map2 (fun x y -> x + y) r1 r2\n    List.map2 (fun x y -> x + y) r4 r3 |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85311,"user_id":null,"body":"type String = System.String\n\nlet diagonalRightPath (step: int) (x: int, y: int) : seq<int * int> =\n    let minValue = min (x \/ step) (y \/ step)\n    let mutable mutX = x - (minValue * step)\n    let mutable mutY = y - (minValue * step)\n    seq {\n        while true do\n            yield (mutX, mutY)\n            mutX <- mutX + step\n            mutY <- mutY + step\n    }\n\nlet diagonalRight (row: int, col: int) (arr: 'a[,]) : seq<'a> =\n    let countRow = Array2D.length1 arr \n    let countCol = Array2D.length2 arr\n    diagonalRightPath 1 (row, col) \n    |> Seq.takeWhile (fun (row', col') -> row' < countRow && col' < countCol)\n    |> Seq.map (fun (row', col') -> arr.[row', col'])\n\nlet diagonalSymmetry (matrix: 'a[,]) : 'a[,] =\n    let dimension = Array2D.length1 matrix\n    let diagonalBeginnings = \n        [|0 .. dimension - 1|] \n        |> Array.collect (fun i -> [|(0, i); (i, 0)|]) |> Array.tail\n    for (row, column) in diagonalBeginnings do\n        let diagonalValues = diagonalRight (row, column) matrix |> Seq.toArray |> Array.rev\n        let diagonalLength = Array.length diagonalValues\n        let diagonalPath = diagonalRightPath 1 (row, column) |> Seq.take diagonalLength |> Seq.toArray\n        Array.zip diagonalPath diagonalValues\n        |> Array.iter (fun ((row, column), value) -> matrix.[row, column] <- value)\n    matrix\n\nlet toArray (arr: 'a [,]) : 'a [][] = \n    [| \n        for x in 0 .. Array2D.length1 arr - 1 do\n            yield [| for y in 0 .. Array2D.length2 arr - 1 -> arr.[x, y] |]\n    |]\n\nlet strToArray2D (s: string) : char[,] =\n    s.Split()\n    |> Array.map Seq.toArray\n    |> array2D\n\nlet array2DtoStr (matrix: char[,]) : string = \n    matrix\n    |> toArray\n    |> Array.map String.Concat\n    |> String.concat \"\n\"   \n\nlet diag2Sym (s: string) : string =\n    s\n    |> strToArray2D\n    |> diagonalSymmetry\n    |> array2DtoStr\n    \nlet rotate90counterClock (matrix: 'a[,]) : 'a[,] =\n    let rowLength = Array2D.length1 matrix\n    let columnLength = Array2D.length2 matrix\n    let newMatrix : 'a[,] = Array2D.zeroCreate rowLength columnLength\n    for i = 0 to rowLength - 1 do\n        newMatrix.[*, i] <- Array.rev matrix.[i, *]\n    newMatrix    \n\nlet rot90Counter (s: string) =\n    s\n    |> strToArray2D\n    |> rotate90counterClock\n    |> array2DtoStr\n\nlet selfieDiag2Counterclock (s: string) =\n    let diag = diag2Sym s |> (fun s -> s.Split())\n    let rot = rot90Counter s |> (fun s -> s.Split())\n    let self = s.Split()\n    Array.zip3 diag rot self\n    |> Array.map (fun (diagV, rotV, selfV) ->\n        sprintf \"%s|%s|%s\" selfV diagV rotV)\n    |> String.concat \"\n\"  \n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85312,"user_id":null,"body":"let getN (s: string) : int = s.Split('\n').Length\n\n\nlet getMatrixFromString (s: string) = s.Split('\n')\n\n\nlet getStringFromMatrix =\n    Array.map (Array.map string >> String.concat \"\")\n    >> String.concat \"\n\"\n\n\nlet rot90Counter (s: string) =\n    let n = getN s\n\n    let matrix = getMatrixFromString s\n\n    Array.init n (fun i -> Array.init n (fun j -> matrix.[j].[n - i - 1]))\n    |> getStringFromMatrix\n\n\nlet diag2Sym (s: string) =\n    let n = getN s\n\n    let matrix = getMatrixFromString s\n\n    Array.init n (fun i -> Array.init n (fun j -> matrix.[n - j - 1].[n - i - 1]))\n    |> getStringFromMatrix\n\n\nlet selfieDiag2Counterclock (s: string) =\n    let n = getN s\n    let matrix = getMatrixFromString s\n\n    let diag2 =\n        Array.init n (fun i -> Array.init n (fun j -> matrix.[n - j - 1].[n - i - 1]))\n        |> Array.map (Array.map string >> String.concat \"\")\n\n    let counter =\n        Array.init n (fun i -> Array.init n (fun j -> matrix.[j].[n - i - 1]))\n        |> Array.map (Array.map string >> String.concat \"\")\n\n    Array.map3 (fun a b c -> a + \"|\" + b + \"|\" + c) matrix diag2 counter\n    |> String.concat \"\n\"\n\n\nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85313,"user_id":null,"body":"let diag1Sym (s: string) =\n    s.Split('\n')\n    |> Array.map Seq.toArray\n    |> fun x -> Array.head x, Array.tail x\n    |> fun (h, t) ->\n        (h |> Array.map string, t)\n        ||> Array.fold (fun s x -> (s, x) ||> Array.map2 (fun s2 x2 -> s2 + string x2))\n        \nlet rot90Counter' (s:string) =\n    diag1Sym s\n    |> Array.rev\n\nlet diag2Sym' (s: string) =\n    diag1Sym s\n    |> Array.rev\n    |> Array.map (Seq.rev >> Seq.toArray >> System.String)\n    \nlet concat = String.concat \"\n\"\n    \nlet rot90Counter (s: string) =\n    s |> rot90Counter' |> concat\n    \nlet diag2Sym (s: string) =\n    s |> diag2Sym' |> concat\n    \nlet selfieDiag2Counterclock (s: string) =\n    Array.map3 (sprintf \"%s|%s|%s\") (s.Split('\n')) (diag2Sym' s) (rot90Counter' s)\n    |> concat\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85314,"user_id":null,"body":"open System\n\nlet rot90Counter (s: string) =\n    let arr = s.Split('\n')\n    let rotation (x: int) = \n      (arr |> Seq.map (fun y -> y.[y.Length - x - 1].ToString()) |> String.concat \"\")\n    [|0..((Array.length arr) - 1)|] |> \n    Array.map rotation |>\n    String.concat \"\n\"\n    \nlet diag2Sym (s: string) =\n    let arr = s.Split('\n')\n    let diagSym (x: int) = \n      (arr |> Seq.map (fun y -> y.[y.Length - x - 1].ToString()) |> Seq.rev |> String.concat \"\")\n    [|0..((Array.length arr) - 1)|] |> \n    Array.map diagSym |>\n    String.concat \"\n\"\n    \nlet selfieDiag2Counterclock (s: string) =\n    let arr = s.Split('\n')\n    let diagSym (x: int) = \n      (arr |> Seq.map (fun y -> y.[y.Length - x - 1].ToString()) |> String.concat \"\")\n    let rotation (x: int) = \n      (arr |> Seq.map (fun y -> y.[y.Length - x - 1].ToString()) |> Seq.rev |> String.concat \"\")\n    [|0..((Array.length arr) - 1)|] |> \n    Array.map (fun x -> sprintf \"%s|%s|%s\" arr.[x] (rotation x) (diagSym x)) |>\n    String.concat \"\n\"\n    \nlet oper fcn = fcn","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85315,"user_id":null,"body":"let rot90Counter (s: string) =\n    let lines = s.Split([|'\n'|])\n    let n = lines.Length\n    Microsoft.FSharp.Core.String.concat \"\n\" (Array.init n (fun i -> System.String(Array.init n (fun j -> lines.[j].[n-i-1]))))\n\nlet diag2Sym (s: string) =\n    let lines = s.Split([|'\n'|])\n    let n = lines.Length\n    Microsoft.FSharp.Core.String.concat \"\n\" (Array.init n (fun i -> System.String(Array.init n (fun j -> lines.[n-j-1].[n-i-1]))))\n\nlet selfieDiag2Counterclock (s: string) =\n    let lines = s.Split([|'\n'|])\n    let n = lines.Length\n    let diag = Array.init n (fun i -> System.String(Array.init n (fun j -> lines.[n-j-1].[n-i-1])))\n    let rot = Array.init n (fun i -> System.String(Array.init n (fun j -> lines.[j].[n-i-1])))\n    Microsoft.FSharp.Core.String.concat \"\n\" (Array.init n (fun i -> lines.[i] + \"|\" + diag.[i] + \"|\" + rot.[i]))\n        \nlet oper fcn s = fcn s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85316,"user_id":null,"body":"\nlet split (str : string) = str.Split()\n\nlet rot90Counter str = \n    split str\n    |> fun rows -> \n        Seq.init rows.Length (fun rowIndex -> \n            Array.init rows.Length (fun columnIndex -> \n                rows.[columnIndex].[rowIndex])\n            |> System.String\n        )\n    |> Seq.rev\n    |> String.concat \"\n\"\n    \nlet diag2Sym = \n    rot90Counter\n    >> split \n    >> Array.map (fun p -> p.ToCharArray() |> Array.rev |> System.String)\n    >> String.concat \"\n\"\n    \nlet selfieDiag2Counterclock str = \n    Array.map3 (sprintf \"%s|%s|%s\")\n        (split str)\n        (split <| diag2Sym str)\n        (split <| rot90Counter str)\n    |> String.concat \"\n\"\n    \nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85317,"user_id":null,"body":"let rot90CounterIndex max (x:int, y:int) =\n    max-y,x\nlet diag_2_symIndex max (x:int, y:int) =\n    max-y,max-x\n\nlet getChar (arr:string[]) (x,y) =\n    arr.[y].[x]\n\nlet oper' func (s: string) =\n    let s' = s.Split '\n' \n    let dim = (Array.length s')-1\n    seq { for y in 0..dim do \n            for x in 0..dim do\n                yield getChar s' (func dim (x,y)) \n            yield '\n'\n    }  |> Array.ofSeq |> System.String |> (fun s -> s.TrimEnd '\n')\n\nlet oper func s = \n    func s\nlet rot90Counter (s: string) =\n    s |> oper' rot90CounterIndex\n    \nlet diag2Sym (s: string) =\n    s |> oper' diag_2_symIndex\n\nlet combineArray (a1:string[]) (a2:string[]) = \n    match a2 with\n    | [||] -> a1\n    | _ -> Array.mapi (fun i v -> v + \"|\" + a2.[i] ) a1\n\nlet combinecubes (cubes:string list) = \n    List.fold  (fun s (v:string) -> (v.Split '\n')::s) [] cubes\n    |> List.fold  (fun s (v:string[]) -> combineArray v s) [||]\n    |> String.concat \"\n\" \n    \nlet selfieDiag2Counterclock (s: string) =\n    combinecubes [s; (diag2Sym s) ; (rot90Counter s)]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85318,"user_id":null,"body":"let strToSquareArray (s:string) = s.Split '\n' |> Array.map (fun s -> s.ToCharArray()) \nlet squareArrayToStr (arr: char [] []) = System.String.Join (\"\n\", (arr |> Array.map (fun c -> System.String(c))))\n\nlet diag2Sym' (arr: char [] []) =\n    let res = arr |> Array.map (Array.copy)\n    let maxInd = res.Length-1\n    for i in [0..maxInd-1] do\n        for j in [0..(maxInd-1-i)] do\n            let temp = res.[i].[j]\n            res.[i].[j] <- res.[maxInd - j].[maxInd - i]\n            res.[maxInd - j].[maxInd - i] <- temp\n    res\n\nlet diag2Sym (s: string) =\n    strToSquareArray s |> diag2Sym' |> squareArrayToStr\n\nlet rot90counter' = Array.rev >> diag2Sym'\nlet rot90Counter = strToSquareArray >> rot90counter' >> squareArrayToStr\n\nlet selfieDiag2Counterclock (s: string) =\n    let arr:char [][] = strToSquareArray s\n    let sym:char [][] = diag2Sym' arr\n    let rot:char [][] = rot90counter' arr\n    let res = Array.map3 (\n                fun (a1:char []) (a2:char []) (a3:char [])-> System.String(a1) + \"|\" + System.String(a2) + \"|\" + System.String(a3))  arr sym rot         \n    System.String.Join (\"\n\", res)\n\nlet oper fcn s = fcn s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56e3cd1d93c3d940e50006a4":[{"id":85319,"user_id":492,"body":"open System\n\nlet rec makeValley (a: list<int>): list<int> =\n    let b = List.sortBy (fun x -> -x) a\n    match b with\n    | [] -> []\n    | [x] -> [x]\n    | x::y::xs -> x :: makeValley xs @ [y]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85320,"user_id":null,"body":"let rec makeValley (a: list<int>): list<int> =\n  match a |> List.sortDescending with\n  | [] -> []\n  | [oneElement] -> [oneElement]\n  | head1 :: head2 :: tail  -> [head1] @ makeValley(tail) @ [head2]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85321,"user_id":null,"body":"let makeValley =\n    List.sortDescending\n    >> List.indexed\n    >> List.partition (fun (i, _) -> i % 2 = 0)\n    >> fun (a, b) -> List.map snd a, List.map snd b |> List.rev\n    >> (<||) List.append","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85322,"user_id":1402,"body":"let rec makeValley a =\n    match List.rev (List.sort a) with\n    | [] -> []\n    | [xs] -> [xs]\n    | max1::max2::xs ->\n        [max1] @ makeValley(xs) @ [max2]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85323,"user_id":null,"body":"let rec makeValley (a: list<int>): list<int> =\n  let reverseList list = List.fold (fun acc elem -> elem::acc) [] list\n  let sorted = a |> List.sortDescending\n  match sorted with\n  |[] -> []\n  |[n] -> [n]\n  |head::tail -> [head] @ (tail |> makeValley |> reverseList)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85324,"user_id":53,"body":"open System\n\nlet rec makeValley (a: list<int>): list<int> =\n  let b = List.sortDescending a\n  match b with\n    | [] -> []\n    | [x] -> [x]\n    | x::y::xs -> x :: makeValley xs @ [y]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85325,"user_id":491,"body":"let rec makeValley (a: list<int>): list<int> =\n  let odds a = a |> List.indexed |> List.filter (fst >> fun i -> i % 2 <> 0) |> List.map snd\n  let evens a = a |> List.indexed |> List.filter (fst >> fun i -> i % 2 = 0) |> List.map snd\n  let a = List.sortDescending a\n  List.concat [evens a; odds a |> List.rev]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85326,"user_id":null,"body":"let makeValley (a: int list) =\n    a\n    |> List.sortDescending\n    |> List.mapi (fun i x -> (i, x))\n    |> List.partition (fun (i, _) -> i % 2 = 0)\n    |> fun (l, r) -> List.append l (List.rev r)\n    |> List.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85327,"user_id":null,"body":"let makeValley (a: list<int>) =\n  let lwing = a |> List.sortDescending |> \n              List.mapi (fun i x -> (i,x)) |>\n              List.filter (fun x -> (fst x) % 2 = 0) |>\n              List.map (fun x -> (snd x)) |>\n              List.sortDescending\n              \n  let rwing = a |> List.sortDescending |> \n              List.mapi (fun i x -> (i,x)) |>\n              List.filter (fun x -> (fst x) % 2 <> 0) |>\n              List.map (fun x -> (snd x)) |>\n              List.sort\n              \n  [lwing; rwing] |> List.concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85328,"user_id":null,"body":"let makeValley (a: list<int>): list<int> =\n    let rec make_e acc list =\n            match list with\n            | [] -> acc\n            | [x] -> acc @ [x]\n            | x::y::rest -> make_e (y::acc @ [x]) rest\n    let rec make_o acc list =\n        match list with\n        | [] -> acc\n        | [x] -> x::acc\n        | x::y::rest -> make_o (x::acc @ [y]) rest\n    a |> List.sort |> (if (List.length a) % 2 = 0 then make_e else make_o) []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56e7d40129035aed6c000632":[{"id":85329,"user_id":527,"body":"let easyline (n : int) : bigint =\n  Seq.fold (fun a i -> a * bigint (n + i) \/ bigint i) 1I {1..n}","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85330,"user_id":null,"body":"let choose n k =\n    { 1 .. k }\n    |> Seq.fold (fun acc i -> bigint (n - k + i) * acc \/ bigint i) 1I\n\nlet easyline n = choose (2 * n) n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85331,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet choose(n:int, p:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to p do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\n\nlet easyline(n:int): BigInteger =\n    choose(2 * n, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85332,"user_id":492,"body":"open System  \nopen System.Numerics  \n\nlet choose(n:int, p:int): BigInteger =\n    let mutable ret = new BigInteger(1);\n    for i = 1 to p do\n        ret <- ret * BigInteger(n-i+1) \/ BigInteger(i)\n    ret\n\nlet easyline(n:int): BigInteger =\n    choose(2 * n, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85333,"user_id":null,"body":"open System.Numerics\nlet easyline(n:int): BigInteger =\n    let N = bigint n\n    [1I..N] |> Seq.fold (fun acc i -> acc*(N+i)\/i) 1I","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85334,"user_id":53,"body":"open System.Numerics\n\nlet rec easyline(n: int): bigint =\n  if n = 0 then\n    (bigint 1)\n  else\n    BigInteger.Divide(BigInteger.Multiply(easyline(n - 1), (bigint (4 * n - 2))), (bigint n))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85335,"user_id":753,"body":"let rec factorial (n:int): bigint =\n  Seq.fold (*) 1I (seq {1I .. bigint n})    \n\nlet easyline(n:int): bigint =\n  factorial(2*n) \/ factorial(n) \/ factorial(n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85336,"user_id":null,"body":"let easyline (n : int) : bigint =\n  Seq.reduce (*) [1I..2I*bigint n] \/ pown (Seq.reduce (*) [1I..bigint n]) 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85337,"user_id":null,"body":"open System.Numerics\n\nlet rec factorial n : BigInteger =\n    match n with\n    | x when x <= 1 -> 1I\n    | _ -> (n |> BigInteger) * factorial (n - 1)\n\nlet easyline (n: int) =\n    [ 0 .. n ]\n    |> List.map\n        (fun i ->\n            let binCoef =\n                factorial n\n                \/ factorial i\n                \/ ((n - i) |> factorial)\n\n            binCoef * binCoef)\n    |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85338,"user_id":null,"body":"open System.Numerics\n\nlet pascalRow n =\n    let next r =\n        r |> List.pairwise \n          |> List.map (fun (x, y) -> BigInteger.Add(x, y))\n    let rec row acc n =\n            match n with\n            | 0 -> acc\n            | _ -> row (1I::(next acc) @ [1I]) (n - 1)\n    row [1I] n\n\nlet easyline (n : int) =\n    pascalRow n |> List.sumBy (fun x -> x * x)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56eb0be52caf798c630013c0":[{"id":85339,"user_id":575,"body":"open System\n\nlet unluckyDays year = \n    [1..12]\n    |> Seq.filter(fun month -> DateTime(year, month, 13).DayOfWeek = System.DayOfWeek.Friday)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85340,"user_id":null,"body":"open System\n\nlet unluckyDays year = \n    {1..12} \n        |> Seq.map (fun m -> DateTime(year, m, 13)) \n        |> Seq.filter (fun d -> d.DayOfWeek = DayOfWeek.Friday)\n        |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85341,"user_id":null,"body":"open System\n\nlet unluckyDays year = \n    [ 1 .. 12 ]\n    |> List.fold (fun sum m -> \n                    if DateTime(year, m, 13).DayOfWeek = DayOfWeek.Friday \n                    then sum + 1 \n                    else sum) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85342,"user_id":null,"body":"open System\n\nlet unluckyDays year = \n    [ for i in 1 .. 12 -> DateTime(year, i, 13).DayOfWeek = DayOfWeek.Friday ]\n    |> List.filter id\n    |> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85343,"user_id":null,"body":"open System\nlet unluckyDays year = \n    let daysList = \n        [ for month in 1 .. 12 do\n              for day in 1 .. System.DateTime.DaysInMonth(year, month) do \n                  yield System.DateTime(year, month, day) ]\n\n    let fridays = \n        daysList\n        |> List.where(fun day -> day.DayOfWeek = DayOfWeek.Friday && day.Day = 13)\n    fridays.Length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85344,"user_id":null,"body":"open System\n\nlet rec findFriday13 (aggregate: int) (year: int) (date: DateTime) =\n  match (date.DayOfWeek, date.Day, date.Year) with\n    | (dayOfWeek, dayOfMonth, currentYear) when currentYear > year -> aggregate \n    | (dayOfWeek, dayOfMonth, currentYear) when dayOfWeek = DayOfWeek.Friday && dayOfMonth = 13 \n      -> findFriday13 (aggregate + 1) year (date.AddDays 1.0)\n    | _ -> findFriday13 aggregate year (date.AddDays 1.0)\nlet unluckyDays year = \n    findFriday13 0 year (new DateTime(year, 1, 1))  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85345,"user_id":null,"body":"open System\n\nlet blackFridays year =\n    [for month in 1..12 do\n        for day in 1..DateTime.DaysInMonth(year, month) do\n            let date = DateTime(year, month, day)\n            if date.Day = 13 && date.DayOfWeek = DayOfWeek.Friday then\n                yield day]\n\nlet unluckyDays year = (blackFridays year).Length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85346,"user_id":null,"body":"open System\n\nlet isBlackFriday year month =\n    if (new DateTime(year, month, 13)).DayOfWeek = DayOfWeek.Friday then 1 else 0\n\nlet rec unluckyDay year month =\n    if month < 13 then isBlackFriday year month + unluckyDay year (month + 1) else 0\n\nlet unluckyDays year = \n    unluckyDay year 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85347,"user_id":null,"body":"open System\n\nlet unluckyDays year = \n  {1..12}\n  |> Seq.filter (fun month -> DateTime(year, month, 13).DayOfWeek = DayOfWeek.Friday)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85348,"user_id":null,"body":"let unluckyDays year = \n    [for m in [1..12] -> if System.DateTime(year, m, 13).DayOfWeek = System.DayOfWeek.Friday then 1 else 0]\n    |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56eb16655250549e4b0013f4":[{"id":85349,"user_id":null,"body":"open System\n\nlet mostFrequentDays year = \n    let firstDay = DateTime(year, 1, 1).DayOfWeek |> string\n    let lastDay = DateTime(year, 12, 31).DayOfWeek |> string\n    \n    match (firstDay, lastDay) with\n    | (f, l) when f = l -> [f]\n    | (f, l) when f = \"Sunday\" -> [l; f]\n    | (f, l) -> [f; l]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85350,"user_id":null,"body":"open System\n\nlet mostFrequentDays year = \n    let startDay, endDay = DateTime(year, 1, 1).DayOfWeek, DateTime(year, 12, 31).DayOfWeek\n\n    match (startDay |> string, endDay |> string) with\n    | (x, y) when x = y -> [ x ]\n    | (x, y) when x = (DayOfWeek.Sunday |> string) -> [ y ; x ]\n    | (x, y) -> [ x; y ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85351,"user_id":null,"body":"open System\nlet mostFrequentDays year =\n    let jan1 = new System.DateTime(year, 1, 1)\n    let mutable mostFrequent = [ jan1.DayOfWeek ]\n\n    if System.DateTime.IsLeapYear year then\n        let jan2 = jan1.AddDays(1.)\n        mostFrequent <- jan2.DayOfWeek :: mostFrequent\n\n    mostFrequent\n    |> List.sortBy (fun d ->\n        match d with\n        | DayOfWeek.Sunday -> 100\n        | x -> int x)\n    |> List.map string","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85352,"user_id":null,"body":"open System\n\ntype DayOfWeek = \n    | Sunday = 0\n    | Monday = 1\n    | Tuesday = 2\n    | Wednesday = 3\n    | Thursday = 4\n    | Friday = 5\n    | Saturday = 6\n\nlet mostFrequentDays year = \n    let firstDay = int(DateTime(year, 1, 1).DayOfWeek)\n    let days = match DateTime.IsLeapYear year with true -> 366 |false -> 365\n    let counts = [1..days] |> List.countBy (fun x -> x % 7)\n    let maxDays = counts |> List.maxBy(fun (x, y) -> y) |> snd\n    counts \n    |> List.filter (fun (_, y) -> y = maxDays)\n    |> List.map( fun (x, _) -> (x + firstDay - 1) % 7)\n    |> List.sortBy (function 0 -> 7 | x -> x) \/\/ Sunday comes last in results\n    |> List.map(enum<DayOfWeek> >> sprintf \"%A\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85353,"user_id":null,"body":"open System\n\nlet mostFrequentDays year =\n  [\n    for month in 1..12 do\n      for day in 1 .. DateTime.DaysInMonth (year, month) do\n        yield DateTime(year, month, day).DayOfWeek\n  ]\n  |> List.countBy id\n  |> List.groupBy snd\n  |> List.maxBy fst\n  |> snd\n  |> List.map fst\n  |> List.sortWith (fun day1 day2 ->\n    match day1, day2 with\n    | DayOfWeek.Sunday, _ -> 1\n    | _, DayOfWeek.Sunday -> -1\n    | _ -> day1.CompareTo day2)\n  |> List.map string\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85354,"user_id":null,"body":"let mostFrequentDays year =\n    let date = System.DateTime.Parse (\"1-1-\" + year.ToString())\n    let days = match System.DateTime.IsLeapYear year with\n        | true -> 366\n        | false -> 365\n    match days % 7 with\n    | 1 -> [ date.DayOfWeek.ToString() ]\n    | 2 ->  match date.DayOfWeek < date.AddDays(-1.0).DayOfWeek with\n        | true -> [date.AddDays(1.0).DayOfWeek.ToString(); date.DayOfWeek.ToString()]\n        | false -> [date.DayOfWeek.ToString(); date.AddDays(1.0).DayOfWeek.ToString()]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85355,"user_id":null,"body":"open System\n\nlet mostFrequentDays year = \n  let dict = \n    Map.empty.\n      Add(\"Monday\",0).\n      Add(\"Tuesday\",1).\n      Add(\"Wednesday\",2).\n      Add(\"Thursday\", 3).\n      Add(\"Friday\",4).\n      Add(\"Saturday\",5).\n      Add(\"Sunday\",6)\n        \n  let mutable days = []\n  let first = new DateTime(year,1,1)\n  let last = new DateTime(year,12,31)\n  \n  printfn \"%s\" (first.ToString(\"dddd\"))\n  \n  if dict.[first.ToString(\"dddd\")] = dict.[last.ToString(\"dddd\")] then\n    days <- days @ [first.ToString(\"dddd\")]\n  else\n    if dict.[first.ToString(\"dddd\")] > dict.[last.ToString(\"dddd\")] then\n      days <- days @ [last.ToString(\"dddd\"); first.ToString(\"dddd\")]\n    else\n      days <- days @ [first.ToString(\"dddd\"); last.ToString(\"dddd\")]\n  days","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85356,"user_id":null,"body":"open System\n\nlet mostFrequentDays year =\n    let start = new DateTime(year, 1, 1)\n    let days = (new DateTime(year + 1, 1, 1) - start).Days - 1\n\n    let dayOfWeek d = \n        match d with\n        | DayOfWeek.Sunday -> 7\n        | _ -> int d\n\n    seq { 0..days } \n        |> Seq.map (fun i -> start.AddDays(float i).DayOfWeek)\n        |> Seq.groupBy id\n        |> Seq.map (fun (key, g) -> (key, Seq.length g))\n        |> Seq.sortBy snd\n        |> Seq.groupBy snd\n        |> Seq.map (fun (_, g) -> g \n                                |> Seq.sortBy (dayOfWeek<<fst) \n                                |> Seq.map (fun (x, _) -> x.ToString()))\n        |> Seq.last\n        |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85357,"user_id":575,"body":"open System\n\nopen System\n\nlet mostFrequentDays year = \n    let first = DateTime(year, 1, 1).DayOfWeek\n    let last = DateTime(year, 12, 31).DayOfWeek\n    if first = last then\n        [string(first)]\n    else\n        let sortedDays = \n            [first;last]\n            |> List.sort\n            |> List.map(string)\n        match sortedDays with\n            | [\"Sunday\"; \"Monday\"] -> [\"Monday\"; \"Sunday\"]\n            | [\"Sunday\"; \"Saturday\"] -> [\"Saturday\"; \"Sunday\"]\n            | _ -> sortedDays","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85358,"user_id":null,"body":"open System\n\nlet mostFrequentDays year =\n    let toInt (x: DayOfWeek) : int = ((int x) + 6) % 7\n\n    let comparer ((dayOfWeek', count') : DayOfWeek * int) ((dayOfWeek'', count'') : DayOfWeek * int) =\n        let value = count''.CompareTo count'\n        if value <> 0 then value\n        else (toInt dayOfWeek'').CompareTo (toInt dayOfWeek')\n\n    let folder ((result, value) : list<string> * option<int>) ((dayOfWeek, count) : DayOfWeek * int) =\n        match value with\n        | Some prevCount when count >= prevCount -> (((string dayOfWeek) :: result), Some count)\n        | _                                      -> (result, None)\n\n    seq {\n        for month in {1 .. 12} do\n            for day in {1 .. DateTime.DaysInMonth(year, month)} do\n                yield DateTime(year, month, day).DayOfWeek\n    }\n    |> Seq.countBy id\n    |> Seq.sortWith comparer\n    |> Seq.fold folder ([], Some(0))\n    |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56ed20a2c4e5d69155000301":[{"id":85359,"user_id":492,"body":"let repCntArrayOfChar (s: char[])  (count: int) =\n    s |> Array.map (fun x -> String.replicate count (System.Convert.ToString(x)))\nlet horizScale(s: string) (count: int) =\n    s.Split([|'\n'|]) |> Array.map (fun x -> x.ToCharArray())\n    |> Array.map(fun x -> (repCntArrayOfChar x count) |> String.concat \"\") |> Seq.toList\nlet scale (s: string) (horizCount: int) (vertCount: int) = \n    match s with\n    | \"\" -> \"\"\n    | _ -> horizScale s horizCount |> Seq.collect (fun (v) -> List.replicate vertCount v) |> Seq.toList |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85360,"user_id":null,"body":"let splitLines (s : string) =\n    s.Split([| '\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n\nlet scale s horizCount vertCount =\n    s\n    |> splitLines\n    |> Seq.map (String.collect (fun c -> System.String(c, horizCount)))\n    |> Seq.collect (Seq.replicate vertCount)\n    |> String.concat \"\n\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85361,"user_id":null,"body":"let scale (s: string) (horizCount: int) (vertCount: int) = \n    if s = \"\" then \"\"\n    else\n        s.Split '\n' \n        |> Array.map (fun s -> \n            [| for i in 1 .. vertCount ->\n                s \n                |> Seq.toArray \n                |> Array.map (fun c -> String.replicate horizCount (string c))\n                |> String.concat \"\" |] )\n        |> Array.concat\n        |> String.concat \"\n\"\n        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85362,"user_id":null,"body":"let scale (s: string) (horizCount: int) (vertCount: int) =\n    if s = \"\" then \"\"\n    else \n      s.Split '\n'\n      |> Seq.map (fun s -> s.ToCharArray())\n      |> Seq.map (fun s ->String.concat \"\" [for str in s do for x in 1..horizCount -> string str])\n      |> Seq.map(fun s -> String.concat \"\n\" [for x in 1..vertCount -> s])\n      |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85363,"user_id":53,"body":"open System\nopen System.Linq\n\nlet scale (s: string) (k: int) (n: int) =\n  String.Join(\"\n\", s.Split('\n').Select(fun x -> \n        if x.Any() then\n          String.Join(\"\n\", Enumerable.Repeat(String.Concat(x.Select(fun c -> new String(c, k))), n))\n        else \n          \"\"))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85364,"user_id":null,"body":"open System\nlet scale (s: string) (horizCount: int) (vertCount: int) = \n    let element = s.Split '\n'\n                    |> Array.map (fun x -> x.ToCharArray() |> Array.map (fun y-> y.ToString()|> String.replicate horizCount) |> String.Concat)\n                    |> Array.map (fun x -> x+\" \"|>String.replicate vertCount)\n                    |> String.Concat \n    element.Trim().Replace(\" \",\"\n\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85365,"user_id":null,"body":"let vertScaling (vertCount: int) (s: string) =\n  if (s = \"\") then\n    \"\"\n  else\n    s.Split('\n') |> \n    Array.collect (fun x -> x |> Array.create vertCount) |> \n    String.concat \"\n\"\n\nlet horizScaling (horizCount: int) (s: string) =\n  if (s = \"\") then\n    \"\"\n  else\n    s.Split('\n') |> \n    Array.map (fun x -> x |> Seq.map (fun x -> x.ToString() |> String.replicate horizCount) |> String.concat \"\") |>\n    String.concat \"\n\"\n  \nlet scale (s: string) (horizCount: int) (vertCount: int) = \n  s |> ((horizScaling horizCount) >> (vertScaling vertCount))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85366,"user_id":null,"body":"open System\n\nlet scale (s: string) (horizCount: int) (vertCount: int) =\n    let f (s:string) =\n        let s' = s.ToCharArray() |> Array.map (fun c -> new String(Array.replicate horizCount c)) |> String.Concat\n        Array.replicate vertCount s'\n    \n    match s with\n    | \"\" -> \"\"\n    | _ -> String.Join(Environment.NewLine,\n                s.Split([|Environment.NewLine|], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.collect f)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85367,"user_id":null,"body":"open System\n\nlet strFromChars chars = String (Seq.toArray chars)\n\nlet verticalScaling count = Seq.collect (Seq.replicate count)\n\nlet horizontalScaling count = Seq.map (verticalScaling count >> strFromChars)\n\nlet scale s horizCount vertCount = \n  match s with\n  | \"\" -> \"\"\n  | _ -> \n    (s: string).Split '\n'\n    |> horizontalScaling horizCount\n    |> verticalScaling vertCount\n    |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85368,"user_id":null,"body":"open System\nopen System.Linq\n\nlet scale (string: string) (horizontal: int) vertical =\n    let scaleHorizontal by line =\n        line\n        |> Seq.map (fun c -> new String(c, by))\n        |> String.concat \"\"\n    \n    let scaleVertical by lines =\n        lines\n        |> Seq.map (fun line -> line, by)\n        |> Seq.collect Enumerable.Repeat\n        |> Seq.filter (fun line -> not (String.IsNullOrWhiteSpace line))\n\n    string.Split('\n')\n    |> Seq.map (scaleHorizontal horizontal)\n    |> scaleVertical vertical\n    |> String.concat\"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56efab15740d301ab40002ee":[{"id":85369,"user_id":492,"body":"let som (x: int) (y: int) = x + y\nlet mini(x: int) (y: int) = min x y\nlet maxi(x: int) (y: int) = max x y\nlet rec gcdi x y = if y = 0 then abs x else gcdi y (x % y)\nlet lcmu x y = abs (x * y) \/ (gcdi x y)\n\nlet operArray fct arr init =\n    (arr |> Seq.scan (fct) init |> Seq.toList).Tail","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85370,"user_id":null,"body":"let rec gcd a b =\n    if b = 0\n    then a\n    else gcd b (a % b)\n\nlet lcm a b =\n    if a = 0 && b = 0\n    then 0\n    else abs (a * b) \/ gcd a b\n\nlet som = (+)\nlet mini = min\nlet maxi = max\nlet lcmu x y = lcm (abs x) (abs y)\nlet gcdi x y = gcd (abs x) (abs y)\n\nlet operArray fct arr init =\n    arr\n    |> List.scan fct init\n    |> List.tail\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85371,"user_id":null,"body":"let operArray fct arr init = List.scan fct init arr |> List.skip 1\n\nlet som = (+)\n\nlet mini x y = List.min [x; y]\n\nlet maxi x y = List.max [x; y]\n\nlet rec gcdi x y = if y = 0 then abs x else gcdi y (x % y)\n\nlet lcmu x y = abs (x * y) \/ (gcdi x y)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85372,"user_id":null,"body":"let rec gcd a b = if b = 0 then a else gcd b (a % b)\n\nlet lcm a b =\n    if a = 0 || b = 0 then\n        0\n    else\n        (a * b) \/ (gcd a b)\n\nlet som x y = x+y\nlet mini x y = min x y \nlet maxi x y = max x y \nlet lcmu x y = lcm (abs x) (abs y)\nlet gcdi x y = gcd (abs x) (abs y)\n\nlet operArray fct arr init =\n    arr |> List.scan fct init |> List.skip 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85373,"user_id":325,"body":"let operArray fct arr init =\n  (init, arr)\n  |> Seq.unfold (fun state ->\n    match state with\n    | x, a0 :: rest -> Some (fct x a0, (fct x a0, rest))\n    | _ -> None\n  )\n  |> Seq.toList\n  \nlet rec gcd a b =\n    if b = 0 then a\n    else          gcd b (a % b)\nlet lcm x y = abs (x * y) \/ gcd x y\nlet som x y = x + y\nlet mini x y = [ x; y ] |> Seq.min\nlet maxi x y = [ x; y ] |> Seq.max\nlet lcmu x y = lcm (abs x) (abs y)\nlet gcdi x y = gcd (abs x) (abs y)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85374,"user_id":null,"body":"let som = (+)\nlet mini = min\nlet maxi = max\nlet rec gcd a b = if b = 0 then a else gcd b (a%b)\nlet lcm a b = a * b \/ gcd a b\nlet inline lcmu x y = lcm (abs(x)) (abs(y))\nlet inline gcdi x y = gcd (abs(x)) (abs(y))\n\nlet operArray (fct:int->int->int) (arr:int list) (init:int) =\n    let rec loop (acc:int list) i  =\n        if arr.Length = i then acc\n        elif acc.Length > 0 then loop ([fct acc.[i-1] arr.[i]] |> List.append acc) (i+1)\n        else loop ([fct init arr.[i]] |> List.append acc) (i+1)\n        \n    loop List.empty<int> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85375,"user_id":null,"body":"let som x y = x + y\n\nlet mini x y = min x y\n\nlet maxi x y = max x y\n\nlet rec gcdi x y =\n    match y with\n    | 0 -> x\n    | _ -> gcdi (abs y) (abs x % abs y)\n\nlet lcmu x y = abs x * abs y \/ gcdi x y\n\nlet operArray fct arr init =\n    Seq.scan fct init arr\n    |> Seq.skip 1\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85376,"user_id":null,"body":"let rec gcdi a b =\n  let a, b = abs a, abs b\n  let dividend, divisor = max a b, min a b\n  match dividend % divisor with\n  | 0 -> divisor\n  | rest -> gcdi divisor rest\n    \nlet lcmu a b = abs a * abs b \/ gcdi a b\n  \nlet som = (+)\nlet mini = min\nlet maxi = max\n\nlet rec operArray fct arr init =\n  List.scan fct init arr\n  |> List.tail","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85377,"user_id":null,"body":"let operArray fct arr init =\n    let foldMapping s x =\n        let res = fct s x\n        (res, res)\n    List.mapFold foldMapping init arr |> fst\n    \nlet (|Abs|) x = abs(x)\n    \nlet gcdi (Abs x) (Abs y) =\n    let rec gcd a b =\n        match (a, b) with\n        | _ when a = 0 || b = 0 -> a ||| b\n        | _ when a > b -> gcd (a % b) b\n        | _ -> gcd a (b % a)\n    gcd x y\n    \nlet lcmu (Abs x) (Abs y) =\n    let num1 = max x y\n    let num2 = min x y\n    \n    [1..num2]\n    |> List.find (fun i -> ((i * num1) % num2) = 0)\n    |> (fun i -> i * num1)\n       \nlet som = (+)\nlet mini = min\nlet maxi = max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85378,"user_id":53,"body":"let mini a b =\n    Seq.min [|a; b|]\n    \nlet maxi a b =\n    Seq.max [|a; b|]\n    \nlet som a b =\n    a + b\n    \nlet rec gcdi a b =\n    if b = 0 then\n        abs a\n    else\n        gcdi b (a % b)\n\nlet lcmu a b =\n    abs (a * b) \/ gcdi a b\n    \nlet operArray fct arr init =\n    List.scan fct init arr |> Seq.skip 1 |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56f253dd75e340ff670002ac":[{"id":85379,"user_id":null,"body":"let splitLines (s : string) =\n    s.Split([| '\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n\nlet compose s1 s2 =\n    let substrings =\n        splitLines\n        >> Seq.mapi (fun index line -> line.[.. index])\n\n    substrings s2\n    |> Seq.rev\n    |> Seq.map2 (+) (substrings s1)\n    |> String.concat \"\n\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85380,"user_id":492,"body":"let compose(s1: string) (s2: string): string =\n    let arr1 = s1.Split([|'\n'|])\n    let arr2 = s2.Split([|'\n'|]) |> Array.rev\n    let l = arr2.Length\n    let res = Array.create l \"\"\n    for i = 0 to l - 1 do\n        res.[i] <- arr1.[i].Substring(0, i+1) + arr2.[i].Substring(0, l-i)\n    res |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85381,"user_id":null,"body":"let compose (s1: string) (s2: string) =\n    let s1Arr =\n        s1.Split '\n' |>\n        Array.mapi (fun i str -> str.[0..i])\n    let s2Arr =\n        s2.Split '\n' |>\n        Array.rev |>\n        Array.mapi (fun i str -> str.[0..str.Length-1-i])\n    Array.map2 (+) s1Arr s2Arr |>\n    String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85382,"user_id":null,"body":"let compose(s1: string) (s2: string) =\n    let s1Arr = s1.Split '\n' |>\n        Array.mapi (fun i str -> str.[0..i])\n    let s2Arr = s2.Split '\n' |>\n        Array.rev |>\n        Array.mapi (fun i str -> str.[0..str.Length-1-i])\n    Array.zip s1Arr s2Arr |>\n    Array.map (fun (f,s) -> f + s) |>\n    String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85383,"user_id":null,"body":"open System\n\nlet compose (s1: string) (s2: string) =\n        \n    let frankenstein (len: int) (body: string) (mind: string) =\n        Seq.rev body\n        |> Seq.skip len\n        |> Seq.rev\n        |> Seq.append (Seq.take (len + 1) mind)\n        |> String.Concat\n    \n    s1.Split('\n')\n    |> Seq.mapi2 frankenstein (s2.Split('\n') |> Seq.rev)\n    |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85384,"user_id":null,"body":"let compose (s1: string) (s2: string): string =\n    let combineLines lineIndex (line1: string) (line2: string) =\n        line1.Substring(0, lineIndex + 1) + line2.Substring(0, line2.Length - lineIndex)\n    (s1.Split('\n'), Array.rev (s2.Split '\n'))\n    ||> Array.mapi2 combineLines |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85385,"user_id":null,"body":"let compose (s1: string) (s2: string) =\n  let concat i ((l1, l2): string * string) =\n    l1.Substring(0, i + 1) + l2.Substring(0, (String.length l2) - i)\n  let z = Array.zip (s1.Split('\n')) (s2.Split('\n') |> Array.rev)\n  z |> Array.mapi concat |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85386,"user_id":null,"body":"let compose s1 s2 = \n    let split (str : string) = \n        str.Split()\n    (split s1, split s2 |> Array.rev)\n    ||> Seq.mapi2 (fun index s1 s2 -> \n        s1.[..index] + s2.[..s2.Length-index-1]\n    )\n    |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85387,"user_id":null,"body":"let compose(s1: string) (s2: string): string =\n    let s1' = s1.Split('\n')\n    let s2' = s2.Split('\n')\n    let length = (Array.length s1')\n    let lastIndex = length - 1\n    let c = [ for i in [0..lastIndex] -> s1'.[i].Substring(0,i+1) + s2'.[lastIndex-i].Substring(0,length-i) ]\n    String.concat \"\n\" c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85388,"user_id":null,"body":"open System;;\n\nlet split_lines (s: string) = s.Split([| '\n' |])\nlet stringify (c: char seq) : string = String.Concat(c)\nlet join_lines (s: string seq) : string = String.Join(\"\n\", s)\n\nlet compose(s1: string) (s2: string): string =\n  let ladder s = \n    let take i = Seq.take (i+1)\n    s |> split_lines |> Seq.mapi take\n\n  let to_line (a, b) =\n    Seq.append a b\n    |> stringify\n\n  let lines = \n    Seq.zip \n      (ladder s1)\n      (ladder s2 |> Seq.rev)\n    |> Seq.map to_line\n  \n  join_lines lines\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56f3a1e899b386da78000732":[{"id":85389,"user_id":null,"body":"let partArray (a: array<string>) =\n    [1 .. a.Length-1]\n    |> List.map (fun i -> a |> Array.splitAt i |> fun (left,right) -> String.concat \" \" left, String.concat \" \" right)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85390,"user_id":492,"body":"let partArray (a: array<string>) =\n    let part (a: array<string>) (l: int) (j: int) =\n        (a.[0..j - 1] |> String.concat \" \", a.[j..l - 1] |> String.concat \" \")\n    let l = Array.length a\n    [for j in [1..l - 1] do yield (part a l j)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85391,"user_id":null,"body":"let part arr topSize =\n    Seq.take(topSize) arr\n    |> String.concat \" \",\n    Seq.skip(topSize) arr\n    |> String.concat \" \"\n\n\nlet partArray arr =\n    [1 .. Seq.length arr - 1]\n    |> List.map (part arr)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85392,"user_id":null,"body":"let partArray (a: array<string>) =\n    [1..(a.Length-1)] \n    |> List.map (fun x -> a \n                        |> Array.splitAt x \n                        |> (fun (i1, i2) -> \n                        (i1 |> String.concat \" \", i2 |> String.concat \" \")))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85393,"user_id":null,"body":"let partArray a =\n    if Array.length a <= 1\n    then []\n    else\n        let s = a |> String.concat \" \"\n\n        a\n        |> Seq.tail\n        |> Seq.mapFold\n            (fun i e ->\n                (s.Substring(0, i), s.Substring(i + 1)),\n                i + 1 + e.Length)\n            a.[0].Length\n        |> fst\n        |> List.ofSeq\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85394,"user_id":492,"body":"let partArray (a: array<string>) =\n    let part (a: array<string>) (l: int) (j: int) =\n        (a.[0..j - 1] |> String.concat \" \", a.[j..l - 1] |> String.concat \" \")\n    let l = Array.length a\n    [for j in [1..l - 1] do yield (part a l j)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85395,"user_id":null,"body":"let partArray (a: array<string>) =\n  let zipA i= \n    a\n    |>Array.splitAt  i \n    |>        fst\n    |>  String.concat \" \"  \n\n  let zipB i= \n    a\n    |>Array.splitAt i\n    |>snd\n    |>  String.concat \" \"  \n    \n  a\n  |>Array.mapi (fun i e ->  if i<>0 then Some( zipA(i) ,zipB(i)) else None)\n  |>Array.choose (fun e->e)\n  |>List.ofArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85396,"user_id":null,"body":"let partArray (a: array<string>) =\n    let l = Array.toList a\n    [1..(List.length l - 1)] \n    |> List.map (fun x -> (List.splitAt x l))\n    |> List.map (fun x -> String.concat \" \" (fst x), String.concat \" \" (snd x))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85397,"user_id":53,"body":"let partArray (a: array<string>) =\n    let go (a: array<string>) (w: int) (i: int) = (a.[0..i - 1] |> String.concat \" \", a.[i..w - 1] |> String.concat \" \")\n    [for i in [1..(Array.length a) - 1] do yield (go a (Array.length a) i)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85398,"user_id":null,"body":"let partArray (a: array<string>) =\n    let tupleStringConcat t = (t |> fst |> String.concat \" \", t |> snd |> String.concat \" \")\n    [for i in 1 .. (a |> Array.length) - 1 -> a |> Array.splitAt i |> tupleStringConcat]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"56fcc393c5957c666900024d":[{"id":85399,"user_id":null,"body":"let c = char 11\n\nlet transpose (source: seq<#seq<'T>>) =\n    source\n    |> Seq.collect (Seq.mapi (fun i x -> i,x))\n    |> Seq.groupBy fst\n    |> Seq.map (snd >> Seq.map snd)\n\nlet greaterSqr l =\n    let a = float l |> sqrt |> int\n    if (a * a) < l then a + 1 else a\n\nlet code (t: string) =\n    let l = t.Length\n    let n = greaterSqr l\n    t + System.String(c, n*n-l)\n    |> Seq.chunkBySize n\n    |> transpose\n    |> Seq.map (Seq.rev >> Array.ofSeq >> System.String)\n    |> String.concat \"\\n\"\n\nlet decode (s: string) = \n    s.Split('\\n')\n    |> Seq.map Seq.rev\n    |> transpose\n    |> Seq.collect id\n    |> Seq.takeWhile ((<>) c)\n    |> Array.ofSeq\n    |> System.String","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:50:35"},{"id":85400,"user_id":null,"body":"open System\n\nlet code (s: string): string =\n    let s' = s.Replace(\"\\n\",\"\")\n    let squareLen = int(Math.Ceiling(Math.Sqrt(double(String.length s'))))\n\n    s'.PadRight((squareLen * squareLen), '\\v')\n    |> Seq.mapi (fun i c -> (squareLen - 1 - (i \/ squareLen)) + (i % squareLen) * squareLen, c )\n    |> Seq.sortBy fst\n    |> Seq.map snd\n    |> Seq.chunkBySize squareLen\n    |> Seq.map (fun l -> new String(l))\n    |> String.concat \"\\n\"\n\nlet decode s = (s |> code |> code |> code).Replace(\"\\n\", \"\").Replace(\"\\v\", \"\")\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85401,"user_id":null,"body":"open System\nlet c11 = char 11\nlet codec rotate (s: string) = \n    let s = s.Replace(\"\\n\",\"\")\n    let len = String.length s\n    let sideLen = \n        seq{ 0..len }\n        |> Seq.skipWhile (fun n -> n * n < len)\n        |> Seq.head\n    let area = sideLen * sideLen\n    let paddingString = Seq.replicate (area - len) c11 |> String.Concat\n    let paddedString = sprintf \"%s%s\" s paddingString\n    paddedString\n    |> Seq.mapi (fun i c -> (rotate sideLen i), c)\n    |> Seq.groupBy (fst >> snd)\n    |> Seq.sortBy fst\n    |> (\n        Seq.map (\n            snd\n            >> Seq.sortBy (fst >> fst)\n            >> Seq.map snd\n            >> String.Concat)\n        >> (fun x -> String.Join(\"\\n\", x))\n    )\n        \nlet clockwise sideLen i = sideLen - 1 - (i \/ sideLen), i % sideLen\nlet antiClockwise sideLen i = (i \/ sideLen),sideLen - 1 -  i % sideLen\nlet code = codec clockwise\nlet decode = codec antiClockwise >> (fun s-> s.Replace(\"\\n\",\"\").TrimEnd([|c11|]))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85402,"user_id":null,"body":"let filler = char 11\n\nlet square (t: string) = \n    let s = t.Replace(\"\\n\", \"\")\n    let dim = Seq.initInfinite id |> Seq.find (fun x -> x * x >= s.Length)\n    let s' = s.PadRight(dim * dim, filler)\n    Array2D.init dim dim (fun r c -> s'.[r * dim + c])\n\n\/\/ newline after each row, except last row\nlet unsquare1 (sq: char[,]) =\n    let dim = sq.GetLength(0) - 1\n    seq {\n        for r in 0..dim do\n            for c in 0..dim do\n                yield sq.[r,c]\n            if r <> dim then yield '\\n'\n    } |> System.String.Concat\n  \n\/\/ disregard filler\nlet unsquare2 (sq: char[,]) =\n    let dim = sq.GetLength(0) - 1\n    seq {\n        for r in 0..dim do\n            for c in 0..dim do\n                if sq.[r,c] <> (filler) then yield sq.[r,c]\n    } |> System.String.Concat\n  \nlet rotateR (sq: char[,]) =\n    let dim = sq.GetLength(0)\n    let dim' = dim - 1\n    Array2D.init dim dim (fun r c -> sq.[dim' - c, r])\n  \nlet rotateL (sq: char[,]) =\n    let dim = sq.GetLength(0)\n    let dim' = dim - 1\n    Array2D.init dim dim (fun r c -> sq.[c, dim' - r])\n\nlet code = square >> rotateR >> unsquare1\nlet decode = square >> rotateL >> unsquare2\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85403,"user_id":null,"body":"let code (s: string): string =\n    let size = s |> Seq.length |> float |> sqrt |> ceil |> int\n    let length = size * size\n    let pads = s + (Seq.replicate (length - Seq.length s) (char 11 |> string) |> String.concat \"\")\n    let chunks = Seq.splitInto size pads\n    let rotChunks = [0..size-1] |> List.map (fun n -> \n                      chunks |> Seq.map (fun i -> i |> List.ofSeq |> List.item n))\n    let rotStrs = rotChunks |> Seq.map (fun x -> x |> Seq.rev |> Seq.map string |> String.concat \"\")\n    String.concat \"\\n\" rotStrs\n    \nlet decode (s: string): string =\n    let parts = s.Split '\\n' |> List.ofSeq\n    let size = Seq.length parts\n    let result = \n         [0..size-1]\n         |> List.map (fun n -> parts |> List.map (fun p -> p.[n] |> string) |> String.concat \"\")\n         |> List.rev\n         |> String.concat \"\"\n    result.Replace(char 11 |> string, \"\")\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85404,"user_id":null,"body":"let rotateClockWise lists =\n    lists\n    |> Seq.map (Seq.toList)\n    |> Seq.fold \n        (fun acc list -> List.zip list acc |> List.map (fun (x, xs) -> x::xs))\n        (List.replicate (Seq.length lists) [])\n        \nlet code (s: string): _ = \n    let len = s.Length\n    let size = Seq.initInfinite id |> Seq.find (fun x -> x * x >= len)\n    Seq.append s (Seq.replicate (size * size - len) '\\v')\n    |> Seq.chunkBySize size\n    |> rotateClockWise\n    |> Seq.map (Seq.map string >> String.concat \"\")\n    |> String.concat \"\\n\"\n\nlet decode (s: string): string = \n    let rotateCounterClockWise = Seq.rev >> rotateClockWise >> Seq.rev\n    s.Split '\\010'\n    |> rotateCounterClockWise\n    |> Seq.collect (Seq.map string)\n    |> Seq.takeWhile ((<>) \"\\v\")\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85405,"user_id":null,"body":"open System\n\nlet code (s: string): string = \n  let n = s.Length |> float |> sqrt |> ceil |> int\n  let padStr = s.PadRight(n * n, (char)11);\n  let stringArr = padStr |> Seq.chunkBySize n |> \n                  Array.ofSeq\n  let clockWiseRot (strArr: char array array) =\n    let getRotatedInd (i: int) (j: int) =\n      let newi = n - j - 1\n      let newj = i\n      strArr.[newi].[newj]\n      \n    let array = Array.create n 0 |> \n                Array.mapi (fun i x -> (Array.create n 0) |> \n                            Array.mapi (fun j y -> getRotatedInd i j))\n    array\n    \n  stringArr |> clockWiseRot |> \n  Array.map (fun x -> x |> Array.map (fun y -> y.ToString()) |> String.concat \"\") |>\n  String.concat \"\\n\"\n  \nlet decode (s: string): string = \n  let charArrOfStr = s.Split('\\n') |> Array.map (fun x -> Array.ofSeq(x))\n  let n = charArrOfStr.[0] |> Array.length\n  let clockInvWiseRot (strArr: char array array) =\n      let getRotatedInd (i: int) (j: int) =\n        let newi = j\n        let newj = n - i - 1\n        strArr.[newi].[newj]\n        \n      let array = Array.create n 0 |> \n                  Array.mapi (fun i x -> (Array.create n 0) |> Array.mapi (fun j y -> getRotatedInd i j))\n      array\n  charArrOfStr |> clockInvWiseRot |> \n  Array.map (fun x -> x |> Array.filter (fun y -> y <> (char)11) |> Array.map (fun y -> y.ToString()) |> String.concat \"\") |>\n  String.concat \"\"\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85406,"user_id":null,"body":"open System\n\nlet transpose m =\n    let prepend x acc = List.zip x acc |> List.map (fun (y, z) -> y::z)\n    List.foldBack prepend m (List.replicate (List.length (List.head m)) [])\n\nlet chunksOf n l =\n    let rec chunks acc l n = \n        match l with\n        | [] -> acc\n        | _ when List.length l <= n -> l :: acc \n        | _ -> chunks ((List.take n l) :: acc) (List.skip n l) n\n    chunks [] l n |> List.rev\n\nlet sqrt' = float\n            >> Math.Sqrt \n            >> Math.Ceiling \n            >> int\n\nlet toSquare cs =\n    let l = List.length cs\n    let r = sqrt' l\n    cs @ List.replicate (r * r - l) '\\v' |> chunksOf r\n\nlet code (s: string): string =\n    String.Join( \"\\n\",\n        s.ToCharArray() \n        |> Array.toList\n        |> toSquare\n        |> transpose\n        |> List.map (fun cs -> new string(cs |> List.toArray |> Array.rev)))\n\n\nlet decode (s: string) =\n        String.Concat(\n            s.Split([|'\\n'|])\n                |> Array.map (fun v -> v.ToCharArray() |> Array.rev |> Array.toList)\n                |> Array.toList\n                |> transpose\n                |> List.map (List.filter ((<>) '\\v') >> List.toArray)\n                |> List.map (fun v -> new string(v)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85407,"user_id":null,"body":"open System\n\nlet transpose (source: seq<#seq<'T>>) =\n    source\n    |> Seq.collect Seq.indexed\n    |> Seq.groupBy fst\n    |> Seq.map (snd >> (Seq.map snd))\n\nlet code (s: string) : string =\n    let n = (float s.Length) ** 0.5 |> ceil |> int\n    Seq.initInfinite (fun _ -> '\\v') \n    |> Seq.append s\n    |> Seq.take (float n ** 2.0 |> int)\n    |> Seq.splitInto n\n    |> Seq.rev\n    |> transpose\n    |> Seq.map String.Concat\n    |> String.concat \"\\n\"\n\nlet decode (s: string) : string =\n    s.Split '\\n'\n    |> Seq.map Seq.rev\n    |> transpose\n    |> Seq.map String.Concat\n    |> String.concat \"\"\n    |> fun s -> s.TrimEnd('\\v')\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"},{"id":85408,"user_id":null,"body":"open System\n\nlet code (s: string): string = \n  let n = Math.Ceiling(Math.Sqrt(float s.Length)) |> int\n  let charAt i = if i >= s.Length then None else Some s.[i]\n  \n  [0 .. n-1]\n  |> List.map (fun y -> [|n-1 .. -1 .. 0|] |> Array.choose (fun x -> charAt (x * n + y)) |> String)\n  |> List.map (fun s -> s.PadLeft(n, '\\v'))\n  |> String.concat \"\\n\"\n\nlet decode (s: string): string =\n  let n = Math.Floor(Math.Sqrt(float s.Length)) |> int\n  let charAt i = if s.[i] = '\\v' then None else Some s.[i]\n  \n  [|0 .. n*n - 1|]\n  |> Array.choose (fun i -> charAt ((i % n) * (n+1) + (n-1) - (i\/n)))\n  |> String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-10 12:44:18"}],"56fe17fcc25bf3e19a000292":[{"id":85409,"user_id":492,"body":"open System  \n\nlet choose(n:int, p:int): float = \n    float(List.fold (fun s i -> s * (n-i+1)\/i ) 1 [1..p])\n\nlet u1(n:int, p:int): int =\n    int(seq{0..n} \n        |> Seq.toList \n        |> List.map (fun k -> Math.Pow(-1.0, float(k)) * float(p) * Math.Pow(4.0, float(n-k)) * choose(2*n-k+1, k)) \n        |> List.sum)\n    \nlet v1(n:int, p:int): int =\n    int(seq{0..n} \n        |> Seq.toList \n        |> List.map (fun k -> Math.Pow(-1.0, float(k)) * float(p) * Math.Pow(4.0, float(n-k)) * choose(2*n-k, k)) \n        |> List.sum)\n\nlet uEff(n:int, p:int): int = (n+1) * p\n\nlet vEff(n:int, p:int): int = (2 * n + 1) * p","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85410,"user_id":null,"body":"let u1(n:int, p:int) =\n  (n+1)*p\n    \nlet v1(n:int, p:int) =\n  (2*n*p) + p\n\nlet uEff(n:int, p:int) = \n  (n+1)*p\n\nlet vEff(n:int, p:int) = \n  (2*n*p) + p","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85411,"user_id":null,"body":"let u1(n:int, p:int) =\n  (n + 1) * p\n    \nlet v1(n:int, p:int) =\n  (2 * n + 1) * p\n\nlet uEff(n:int, p:int) = \n  (n + 1) * p\n\nlet vEff(n:int, p:int) = \n  (2 * n + 1) * p","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85412,"user_id":null,"body":"let u1 (n: int, p: int) = (n + 1) * p\n    \/\/ your code\n    \nlet v1 (n: int, p: int) = ((p * 2) * n) + p\n    \/\/ your code\n\nlet uEff = u1\n  \/\/ your code\n\nlet vEff = v1\n    \n  \/\/ your code","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85413,"user_id":53,"body":"let u1(n:int, p:int): int = (n + 1) * p\nlet v1(n:int, p:int): int = (2 * n + 1) * p\nlet uEff(n:int, p:int): int = (n + 1) * p\nlet vEff(n:int, p:int): int = (2 * n + 1) * p","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85414,"user_id":null,"body":"let u1(n:int, p:int) =\n    (n + 1) * p\n  \nlet v1(n:int, p:int) =\n    ((2 * n) + 1) * p\n\nlet uEff(n:int, p:int) = \n    u1 (n, p)\n\nlet vEff(n:int, p:int) = \n    v1 (n, p)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85415,"user_id":17,"body":"let u1(n:int, p:int) = p * (n + 1)\n    \nlet v1(n:int, p:int) = p * (2 * n + 1)\n\nlet uEff(n:int, p:int) = p * (n + 1)\n\nlet vEff(n:int, p:int) = p * (2 * n + 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85416,"user_id":null,"body":"let rec bcoeff (n:int) (k:int) =\n    if k = 0 || k = n then\n        1\n    else\n        bcoeff (n-1) (k-1) + bcoeff (n-1) k\n\nlet u1(n:int, p:int) =\n    seq { 0 .. n }\n    |> Seq.map (fun k ->\n        (double)(((((k + 1) % 2) * 2) - 1) * p)\n            * (4.0 ** (double)(n - k))\n            * (double)(bcoeff (2 * n - k + 1) k)\n        )\n    |> Seq.sum\n    |> int\n\nlet v1(n:int, p:int) =\n    seq { 0 .. n }\n    |> Seq.map (fun k ->\n        (double)(((((k + 1) % 2) * 2) - 1) * p)\n            * (4.0 ** (double)(n - k))\n            * (double)(bcoeff (2 * n - k) k)\n        )\n    |> Seq.sum\n    |> int\n    \n\nlet uEff(n:int, p:int) = (n + 1) * p\n\nlet vEff(n:int, p:int) = (2*n + 1) * p\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5700c9acc1555755be00027e":[{"id":85417,"user_id":null,"body":"let rotations s =\n    let n = String.length s\n    seq { for i in 0 .. n - 1 -> s.Substring(i, n - i) + s.Substring(0, i) }\n\nlet containAllRots strng a =\n    strng\n    |> rotations\n    |> Seq.forall (fun s -> List.contains s a)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85418,"user_id":null,"body":"let containAllRots strng a =\n    let n = String.length strng\n    let s = strng + strng\n    { 0 .. n - 1 }\n    |> Seq.forall (fun i -> List.contains (s.Substring(i, n)) a)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85419,"user_id":3318,"body":"let containAllRots (str: string) (a: string list) =\n    [for i in 0 .. str.Length - 1 -> str.Substring(i, str.Length - i) + str.Substring(0, i)]\n    |> List.forall (fun s -> a |> List.contains s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85420,"user_id":null,"body":"let rotateLetter (input:string) (offset:int) =\n    input\n        .Insert(input.Length, input.Substring(0, offset))\n        .Remove(0, offset)\n\nlet containAllRots strng a =\n  if strng = \"\" \n    then true\n    else \n      let allRotations = List.init strng.Length (fun i -> rotateLetter strng (i+1))\n      List.except a allRotations |> List.isEmpty","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85421,"user_id":null,"body":"let containAllRots strng a =    \n    seq {for i in 0 .. (String.length strng)-1\n            -> strng.[i..] + strng.[0..(i-1)]}\n    |> Seq.forall (fun x -> Seq.contains x a)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85422,"user_id":null,"body":"let containAllRots strng a =\n    let n = String.length strng\n    let s = strng + strng\n    let a' = Set.ofList a\n    { 0 .. n - 1 }\n    |> Seq.forall (fun i -> Set.contains (s.Substring(i, n)) a')\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85423,"user_id":null,"body":"let rotations (s : string) =\n  let double = s + s\n  let len = s.Length - 1\n  seq { for i in 0 .. len -> double.[i..i+len] }\n\nlet containAllRots strng a =\n  let rots = strng |> rotations |> Set.ofSeq\n  let other = a |> Set.ofList\n  Set.difference rots other |> Set.isEmpty","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85424,"user_id":null,"body":"let containAllRots (s: string) (strings: string list) =\n    let rotations = set [ for i in [ 0 .. s.Length-1 ] -> (s + s).Substring(i, s.Length) ]\n    let missingRotations = strings |> Set.ofList |> Set.difference rotations \n    missingRotations.IsEmpty\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85425,"user_id":null,"body":"let containAllRots strng a =\n  match strng with\n  | \"\" -> true\n  | _ ->\n    let rots = [ for i in 1..(strng.Length-1) -> strng.Substring(i) + strng.Substring(0, i) ]\n    List.forall (fun rot -> List.contains rot a) rots","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85426,"user_id":null,"body":"let rotate index str = \n    new string(Seq.append (Seq.skip index str) (Seq.take index str) |> Seq.toArray)\n\nlet generateAllRotations (a: string) = [0..a.Length-1] |> Seq.map (fun n -> rotate n a)\n\nlet containAllRots strng a =\n    let allRotations = Set.ofSeq (generateAllRotations strng)\n    (Set.ofList a) |> Set.isSubset allRotations","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5702e2f380b8c86df3000003":[{"id":85427,"user_id":null,"body":"open System\n\ntype Shape =\n    | Square of side : float\n    | Rectangle of width : float * height : float\n    | Circle of radius : float\n    | Triangle of triangleBase : float * height : float\n\nlet getArea = function\n    | Square (side = s) -> s * s\n    | Rectangle (width = w; height = h) -> w * h\n    | Circle (radius = r) -> Math.PI * r * r\n    | Triangle (triangleBase = b; height = h) -> b * h \/ 2.\n\nlet getTotalArea shapes =\n    shapes\n    |> Seq.sumBy getArea\n    |> (fun x -> Math.Round(x, 2))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85428,"user_id":null,"body":"type Shape =\n    | Square of float\n    | Rectangle of float * float\n    | Circle of float\n    | Triangle of float * float\n\nlet getTotalArea xs =\n    let areaOf = function\n        | Square(x) -> x * x\n        | Rectangle(w, h) -> w * h\n        | Circle(r) -> System.Math.PI * r * r\n        | Triangle(b, h) -> 0.5 * b * h\n    in System.Math.Round(List.sumBy areaOf xs, 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85429,"user_id":null,"body":"type Shape =\n  | Triangle of ``base`` : float * height : float\n  | Circle of radius : float\n  | Square of side : float\n  | Rectangle of width : float * height : float\n  \nlet [<Literal>] Tau = 6.2831853071795864769\n\nlet getArea = function\n  | Triangle (``base``, height) -> 0.5 * ``base`` * height\n  | Circle (radius) -> 0.5 * Tau * radius * radius\n  | Square (side) -> side * side\n  | Rectangle (width, height) -> width * height\n\nlet getTotalArea = List.sumBy getArea >> fun f -> System.Math.Round(f, 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85430,"user_id":null,"body":"type Shape = \n    | Square of float\n    | Rectangle of float*float\n    | Circle of float\n    | Triangle of float*float\n    \nlet area shape = \n    match shape with\n    | Square(side) -> side * side\n    | Rectangle(width, height) -> width * height\n    | Circle(radius) -> radius * radius * System.Math.PI\n    | Triangle(base', height) -> base' * height \/ 2.0\n    \nlet round (d:float) = System.Math.Round(d, 2)\n\nlet getTotalArea (shapes:Shape list) = \n    shapes |> Seq.map area |> Seq.sum |> round","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85431,"user_id":null,"body":"open System\n\ntype IShape = \n  abstract member getTotalArea : unit -> float\n\ntype Triangle (triangleBase: float, height: float) =\n  interface IShape with\n    member this.getTotalArea() = this.Base \/ 2.0 * this.Height\n  member this.Base = triangleBase\n  member this.Height = height\n  \n  \ntype Square (side: float) =\n  interface IShape with\n    member this.getTotalArea() = this.Side * this.Side\n  member this.Side = side\n\ntype Rectangle (width: float, height: float) =\n  interface IShape with\n    member this.getTotalArea() = this.Width * this.Height\n  member this.Width = width\n  member this.Height = height\n  \ntype Circle (radius: float) =\n  interface IShape with\n    member this.getTotalArea() = this.Radius * this.Radius * Math.PI\n  member this.Radius = radius\n\nlet getTotalArea (shapes: IShape list) =\n  Math.Round((0.0, shapes) ||> List.fold (fun acc shape -> acc + shape.getTotalArea()), 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85432,"user_id":null,"body":"open FSharp.Collections\n\ntype IArea =\n     abstract member Area : unit -> float\n     abstract member Area2 : unit -> float\n\ntype xTriangle(triangleBase: float, height:float) =\n     new(b, h) = xTriangle(b, h)\n     interface IArea with  \n        member this.Area() = System.Math.Round(triangleBase * height \/ 2.0, 2)\n        member this.Area2() = triangleBase * height \/ 2.0\nlet Triangle(triangleBase: float, height:float) = new xTriangle(triangleBase, height)\n\ntype xRectangle(width: float, height:float) =\n     new(w, h) = xRectangle(w, h)\n     interface IArea with  \n        member this.Area() = System.Math.Round(width * height, 2)\n        member this.Area2() = width * height\nlet Rectangle(width: float, height:float) = new xRectangle(width, height)\nlet Square(side: float) = new xRectangle(side, side)\n\ntype xCircle(radius: float) =\n    new(r) = xCircle(r)\n    interface IArea with  \n        member this.Area() = System.Math.Round(radius * radius * System.Math.PI, 2)\n        member this.Area2() = radius * radius * System.Math.PI\nlet Circle(radius: float) = new xCircle(radius)\n\n\nlet getTotalArea (shapes: IArea list) =\n    System.Math.Round(shapes |> Seq.sumBy (fun s -> s.Area2()), 2)\n\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85433,"user_id":null,"body":"let round2 (x: float) = System.Math.Round (x, 2)\n\ntype Shape =\n  | Triangle of tbase: float * height: float\n  | Square of side: float\n  | Rectangle of width: float * height: float\n  | Circle of radius: float\n  \nlet getArea = function\n  | Triangle (tbase, height) -> tbase * height \/ 2.\n  | Square side -> side * side\n  | Rectangle (width, height) -> width * height\n  | Circle radius -> System.Math.PI * radius ** 2.\n\nlet getTotalArea = \n  List.sumBy getArea >> round2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85434,"user_id":null,"body":"open System\n\ntype Shape = \n    | Triangle  of triangleBase: float * height: float\n    | Square    of side: float\n    | Rectangle of width: float * height: float\n    | Circle    of radius: float\n\nlet getArea (shape : Shape) : float =\n    match shape with\n    | Triangle (b, h)  -> 1. \/ 2. * b * h\n    | Square s         -> s ** 2.\n    | Rectangle (w, h) -> w * h\n    | Circle r         -> Math.PI * r ** 2.\n\nlet getTotalArea (shapes : Shape list) : float =\n    shapes\n    |> Seq.fold (fun acc s -> acc + getArea s) 0.\n    |> float\n    |> fun d -> Math.Round(d, 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85435,"user_id":null,"body":"type Shape =\n    | Rectangle of float * float\n    | Circle of float\n    | Square of float\n    | Triangle of float * float\n\nlet getTotalArea (shapeList: Shape list) =\n    let calculateArea shape =\n        match shape with\n        | Rectangle (w, h) -> w * h\n        | Circle r -> r ** 2.0 * System.Math.PI\n        | Square s -> s * s\n        | Triangle (b, h) -> b * h \/ 2.0\n\n    let sum = shapeList |> List.sumBy calculateArea\n\n    System.Math.Round (sum, 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85436,"user_id":null,"body":"[<AbstractClass>]\ntype Shape() =\n    class\n    end\n\ntype Triangle(triangleBase, height) =\n    inherit Shape()\n    member this.TriangleBase = triangleBase\n    member this.Height = height\n\ntype Rectangle(width, height) =\n    inherit Shape()\n    member this.Width = width\n    member this.Height = height\n\ntype Square(side) =\n    inherit Shape()\n    member this.Side = side\n\ntype Circle(radius) =\n    inherit Shape()\n    member this.Radius = radius\n    \nlet getTotalArea (l: Shape seq) =\n    l\n    |> Seq.map\n        (fun shape ->\n            let area =\n                match shape with\n                | :? Triangle as t -> t.TriangleBase * t.Height \/ 2.\n                | :? Rectangle as r -> r.Width * r.Height\n                | :? Square as s -> s.Side * s.Side\n                | :? Circle as c -> System.Math.PI * c.Radius * c.Radius\n                | _ -> failwith \"unknown\"\n            area\n            )\n    |> Seq.sum\n    |> fun s -> System.Math.Round(s,2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5726f813c8dcebf5ed000a6b":[{"id":85437,"user_id":492,"body":"let nbfactors n = \n  let rec helper c p =\n    if c < (p * p) then [c]\n    elif c % p = 0 then p :: (helper (c \/ p) p)\n    else helper c (p + 1)\n  helper n 2 |> List.length\n\nlet countKprimes k start nd = \n    [for x in [start..nd] do\n        if (nbfactors x = k) then yield x]\n\nlet puzzle s =\n    let a = countKprimes 1 2 s\n    let b = countKprimes 3 2 s\n    let c = countKprimes 7 2 s\n    [for x in a do\n        for y in b do\n            for z in c do\n                if x + y + z = s then \n                    yield 1] |> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85438,"user_id":null,"body":"let countKprimes k start nd = \n    let maxFactor n = int (sqrt (float n))\n    let isPrime n = not (Seq.exists (fun f -> n % f = 0) (seq {2..maxFactor n}))\n\n    let relevantPrimes = seq {2..maxFactor nd} |> Seq.filter isPrime\n    \n    let findFirstPrimeDivisor n = Seq.find (fun d -> n % d = 0) (Seq.append relevantPrimes [n])\n    \n    let countPrimeDivisors n =\n      let rec countPrimeDivisorsHelper n divisorCount =\n        match n, divisorCount with\n        | 0, d -> d\n        | 1, d -> d\n        | _, d when d > k -> -1 \/\/ early out\n        | n , d -> countPrimeDivisorsHelper (n \/ findFirstPrimeDivisor n) (d+1)\n      countPrimeDivisorsHelper n 0\n\n    seq { start .. nd } |> Seq.filter (fun n -> (countPrimeDivisors n) = k) |> Seq.toList\n\nlet puzzle s =\n    let k1 = countKprimes 1 0 s\n    let k3 = countKprimes 3 0 s\n    let k7 = countKprimes 7 0 s\n\n    Seq.allPairs (Seq.allPairs k1 k3) k7\n    |> Seq.filter (fun ((a, b), c) -> a+b+c = s)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85439,"user_id":null,"body":"let memoize fn =\n    let cache = new System.Collections.Generic.Dictionary<_,_>()\n    fun x ->\n        match cache.TryGetValue x with\n        | true, v -> v\n        | false, _ ->\n            let v = fn (x)\n            cache.Add(x,v)\n            v\n\nlet primeFactors n =\n    let mutable n = n\n    let mutable a = []\n    while n % 2 = 0 do\n        a <- 2 :: a\n        n <- n \/ 2\n    let mutable f = 3\n    while f * f <= n do\n        if n % f = 0 then\n            a <- f :: a\n            n <- n \/ f\n        else\n            f <- f + 2\n    if n <> 1 then a <- n :: a\n    a\n\nlet memPrimeFactors = memoize primeFactors\n\nlet countKprimes k start nd =\n    let start = if start <= 1 then 2 else start\n    [start..nd]\n    |> List.map (fun n -> (n, memPrimeFactors n))\n    |> List.filter (fun (_, l) -> List.length l = k)\n    |> List.map fst\n\nlet puzzle s =\n    let kPrime k n = memPrimeFactors n |> List.length = k\n    seq {\n        for i in ([2..s] |> Seq.filter (kPrime 1)) do\n        for j in ([2..(s-i)] |> Seq.filter (kPrime 3)) do\n        for k in ([2..(s-j)] |> Seq.filter (kPrime 7)) -> (i, j, k)\n    }\n    |> Seq.filter (fun (i, j, k) -> i + j + k = s)\n    |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85440,"user_id":53,"body":"\nlet pfc k =\n  let mutable n = k\n  let mutable i = 2\n  let mutable ans = 0\n  while i <= n \/ i do\n    while n % i = 0 do\n      ans <- ans + 1\n      n <- n \/ i\n    i <- i + 1\n  if n > 1 then \n    ans + 1 \n  else \n    ans\n\nlet countKprimes k start nd = \n  let mutable ans = []\n  let mutable n = start\n  while n <= nd do\n    let j = pfc(n)\n    if j = k then\n      ans <- ans @ [n]\n    n <- n + 1\n  ans\n\nlet puzzle s =\n  let mutable ans = 0\n  let xs = countKprimes 7 128 (s - 2)\n  let ys = countKprimes 3 4 (s - 2)\n  for a in xs do\n    for b in ys do\n      let c = s - a - b\n      if c > 0 && pfc c = 1 then\n        ans <- ans + 1\n  ans\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85441,"user_id":null,"body":"let isPrime num = \n  let rec getDivs (num: int) (ind: int) =\n    match num with\n    | num when ind * ind > num -> true\n    | num when num % ind = 0   -> false\n    | _                        -> (getDivs num (ind + 1))\n  (getDivs num 2)\n\nlet isKPrime k num =\n  let rec getDivs k num ind =\n    match num with\n    | num when k < 0         -> false\n    | num when ind > num    -> k = 0\n    | num when num % ind = 0 -> (getDivs (k - 1) (num \/ ind) ind)\n    | _                      -> (getDivs k num (ind + 1))\n  if (isPrime num) then\n    k = 1\n  else\n    (getDivs k num 2)\n  \nlet countKprimes k start nd = \n    [start..nd] |> List.filter (isKPrime k)\n    \nlet puzzle s =\n    let primes = [2..(s - 1)] |> List.filter (isKPrime 1) |> Set\n    let threepr = [2..(s - 1)] |> List.filter (isKPrime 3)\n    let sevenpr = [2..(s - 1)] |> List.filter (isKPrime 7)\n    List.allPairs threepr sevenpr |> \n    List.sumBy (fun (a,b) -> if (Set.contains (s - a - b) primes) then 1 else 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85442,"user_id":null,"body":"let sqrtI : int->int =\n    float >> sqrt >> ceil >> int\n\nlet rec getFactors (n:int) : int list =\n    match [2..(sqrtI n)] |> List.tryFind (fun e -> n % e = 0) with\n    | Some e -> e :: getFactors (n\/e)\n    | None -> if n = 1 then [] else [n]\n\nlet countKprimes k start nd = \n    [start..nd]\n    |> List.filter (getFactors >> List.length >> ((=) k))\n\nlet puzzle s =\n    let k1 = countKprimes 1 1 s\n    let k3 = countKprimes 3 1 s\n    let k7 = countKprimes 7 1 s\n    List.allPairs k1 k3\n    |> List.allPairs k7\n    |> List.filter (fun (a,(b,c)) -> a + b + c = s)\n    |> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85443,"user_id":null,"body":"let primeDivisors = \n    let nextPossiblePrimeDivisor n = \n      function\n      | 2 -> 3\n      | d when double d > System.Math.Sqrt(double n) -> n\n      | d -> d + 2\n    let rec loop acc d n =\n        if d > n\n        then acc\n        elif n % d = 0\n        then loop (d :: acc) d (n \/ d)\n        else loop acc (nextPossiblePrimeDivisor n d) n\n    loop [] 2\n\nlet countKprimes k start nd = \n    [start .. nd]\n    |> List.filter (primeDivisors >> List.length >> ((=) k))\n    |> List.ofSeq\n\nlet puzzle s =\n    let numbersByPrimeCount =\n      [0 .. s]\n      |> List.groupBy (primeDivisors >> List.length)\n      |> Map.ofList\n      \n    let p3s = Map.find 3 numbersByPrimeCount |> Set.ofList\n      \n    seq {\n      \/\/ start from 7-primes as least numerous\n      for p7 in Map.find 7 numbersByPrimeCount do\n        \/\/ carry on with primes (seems to be less numerous than 3-primes)\n        for p1 in Map.find 1 numbersByPrimeCount do\n          let maybeP3 = s - p7 - p1\n          if p3s |> Set.contains maybeP3 then\n            yield p1, maybeP3, p7\n    }\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85444,"user_id":null,"body":"let primeFactors (n: int) : list<int> =\n    let rec inner i r factors =\n        match i, r with\n        | i, r when i > n \/ i ->\n            if r > 1\n            then (r::factors)\n            else factors\n        | i, r when r % i = 0 -> \n            inner i (r \/ i) (i::factors)\n        | i, r ->\n            inner (i + 1) r factors\n    inner 2 n []\n\nlet countKprimes k start nd =\n    [\n      for i = start to nd do\n          let factors = List.length (primeFactors i)\n          if factors = k\n          then yield i\n          else ()\n    ]\n\nlet puzzle s =\n    let p1 = countKprimes 1 2 s\n    let p3 = countKprimes 3 2 s\n    let p7 = countKprimes 7 (pown 2 7) s\n    [for i in p7 do\n        for j in countKprimes 3 (pown 2 3) (s - i) do\n            for k in countKprimes 1 (pown 2 1) (s - i - j) do\n                if s = i + j + k\n                then yield 1\n                else ()]\n    |> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85445,"user_id":null,"body":"#nowarn \"40\"\n\nlet rec allPrimes =\n    seq {\n    yield 2\n    let cache = allPrimes |> Seq.cache\n    let isprime n =\n        cache |> Seq.takeWhile (fun i -> i * i <= n) |> Seq.forall (fun i -> n % i <> 0)\n    yield! {3 .. 2 .. System.Int32.MaxValue} |> Seq.filter isprime\n    }\n\nlet isPrime n = allPrimes |> Seq.takeWhile (fun i -> i * i <= n) |> Seq.forall (fun i -> n % i <> 0)\n\nlet countKprimes n start nd = \n\n    let rec comb k ls =\n        match k with\n        | 1 -> [for (num, rest, _) in ls do if isPrime rest then yield (num, 1, rest)]\n        | k -> \n            [for (num, rest, last) in ls do\n                for p in allPrimes \n                    |> Seq.skipWhile(fun p -> p < last)\n                    |> Seq.takeWhile (fun p -> p <= (rest \/ (int ((float p) ** (float (k-1)))))) do\n                      if rest % p = 0 then yield (num, rest \/ p, p)]\n            |> comb (k - 1)\n\n    [start..nd]\n    |> List.map (fun num -> (num, num, 2))\n    |> comb n\n    |> List.filter (fun (_, rest, _) -> rest = 1)\n    |> List.map (fun (num, _, _) -> num)\n\nlet puzzle s = \n    let p1s = countKprimes 1 2 s\n    let p2s = countKprimes 3 8 s\n    let p3s = countKprimes 7 128 s\n\n    [for a in p1s do\n      for b in p2s do\n        for c in p3s do\n          if a + b + c = s then yield 1\n    ]\n    |> List.length    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85446,"user_id":null,"body":"\n\n\n\n\n\n\n\nlet getPrimesUpToN n =\n    if n = 2 then\n        [ 2 ]\n    else\n        let mutable primes:int list = [ 2 ]\n        let mutable allCandidates = [ 3 .. 2 .. n ]\n        let mid = 1 + int (System.Math.Sqrt(float n))\n        while allCandidates.Length > 0 do\n            let testVal = allCandidates.Head\n            if testVal <= mid then\n              allCandidates <- List.filter (fun x -> x%testVal <> 0) allCandidates\n              primes <- primes @ [ testVal ]\n            else\n              primes <- primes @ allCandidates\n              allCandidates <- []\n        primes\n\n\n\nlet rec checkFactor v f =\n    if v < 2 || f < 2 then\n        (v,0)\n    elif v % f <> 0 then\n        (v,0)\n    else\n        let v2 = v \/ f\n        let tup = checkFactor v2 f\n        (fst tup, 1 + snd tup)\n\n\n\nlet countKprimes k start nd = \n  let mid = 1 + int (System.Math.Sqrt(float nd))\n  let primes = getPrimesUpToN mid\n  let candidates = [ start .. nd ]\n  let mutable candidates2 = List.map (fun x -> (x,0,x)) candidates\n  \n  let f2 x =\n    let f1 (v,n,o) =\n      if n > k then\n        (1,n,o)\n      else\n        let (vv,nn) = checkFactor v x\n        (vv, n + nn, o)\n    candidates2 <- List.map f1 candidates2\n  List.iter f2 primes\n\n  let f3 (v,n,o) =\n    if v>1 && n=k-1 then\n      (1,k,o)\n    else\n      (v,n,o)\n  candidates2 <- List.map f3 candidates2\n\n  List.map (fun (v,n,o) -> o) (List.filter (fun (v,n,o) -> (v=1 && n=k)) candidates2)\n          \n  \n    \n\n\nlet puzzle s =\n  let k7 = countKprimes 7 2 s\n  let combo = List.allPairs (countKprimes 1 2 s) (countKprimes 3 2 s)\n  let f1 sum (c1,c2) =\n    sum + List.length (List.filter (fun x -> x+c1+c2 = s) k7)\n  List.fold f1 0 combo\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"573182c405d14db0da00064e":[{"id":85447,"user_id":492,"body":"let nbfactors n = \n  let rec helper c p =\n    if c < (p * p) then [c]\n    elif c % p = 0 then p :: (helper (c \/ p) p)\n    else helper c (p + 1)\n  helper n 2 |> List.length\n  \nlet consecKprimes k arr =\n    let a = [for x in arr do yield (nbfactors x)]\n    [for i in [0 .. (List.length a)- 2] do \n        if (a.[i] = k) && (a.[i + 1] = k) then yield 1 else yield 0\n    ] |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85448,"user_id":53,"body":"open System\nopen System.Linq\n    \nlet npf (k: int) = \n  let mutable n = k\n  let mutable m = 0\n  let mutable i = 2\n  while n > 1 do\n    if n % i = 0 then\n      n <- n \/ i\n      m <- m + 1\n      i <- 2\n    else\n      i <- i + 1\n  m\n  \nlet consecKprimes (k: int) (arr: int list) =\n  let xs = arr.Select(fun (n: int) -> if (npf n) = k then 1 else 0).ToArray()\n  let mutable ans = 0\n  let mutable i = 0\n  while i + 1 < xs.Length do\n    if xs.[i] = 1 && xs.[i + 1] = 1 then\n      ans <- ans + 1\n    i <- i + 1\n  ans","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85449,"user_id":null,"body":"let nextPrimes (primesCandidates: int list) =\n    let head = List.head primesCandidates\n\n    let filtered =\n        List.filter (fun x -> x % head <> 0) primesCandidates\n\n    List.append [ head ] filtered\n\nlet factorize n =\n    let rec factors n candidates result =\n        let head = List.head candidates\n\n        match n with\n        | n when n % head = 0 && n \/ head = 1 -> List.append [ head ] result\n        | n when n % head = 0 ->\n            factors (n \/ head) (List.filter (fun x -> x <= n \/ head) candidates) (List.append [ head ] result)\n        | _ -> factors n (List.tail candidates) result\n\n    factors n ([ 2 ] @ [ 3 .. 2 .. n ]) []\n\nlet consecKprimes n numbers =\n    let factorizedLength =\n        List.map (fun x -> factorize x |> List.length) numbers\n\n    let offsetList = (List.tail factorizedLength) @ [ -1 ]\n    let resultList = List.zip factorizedLength offsetList\n\n    List.filter (fun x -> fst x = n && snd x = n) resultList\n    |> List.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85450,"user_id":null,"body":"let isPrime (num: int) =\n  if (num < 2) then\n    false\n  else\n    {2..(num |> (float >> sqrt >> int))} |> Seq.forall (fun x -> num % x <> 0)\n\nlet countPrimeFactors (num: int) =\n  let rec getPrimeFactors (num: int) (ind: int) =\n    if (num < 2) then\n      0\n    else if (num % ind = 0) then\n      1 + (getPrimeFactors (num \/ ind) ind)\n    else if (isPrime num) then\n      1\n    else\n      (getPrimeFactors num (ind + 1))\n      \n  (getPrimeFactors num 2)\n\n\nlet consecKprimes k arr =\n    arr |> List.map countPrimeFactors |>\n    List.pairwise |> List.filter (fun (a,b) -> a = k && b = k) |>\n    List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85451,"user_id":null,"body":"let consecKprimes k arr =\n\n  let factorize n =\n    let rec helper n cur ps =\n      if n % cur = 0 then\n        helper (n \/ cur) cur (ps + 1)\n      else if cur > n then\n        ps\n      else\n        helper n (cur + 1) ps\n  \n    helper n 2 0 \n  \n  let isKPrime n = factorize n = k\n  \n  let pairs = function\n  | [] -> List.toSeq []\n  | (x :: xs) as l -> Seq.zip l xs\n  \n  pairs (Seq.toList arr)\n  |> Seq.filter (fun (x, y) -> (isKPrime x) && (isKPrime y))\n  |> Seq.length\n  \n  \n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85452,"user_id":null,"body":"open System\n\nlet primeDivisors =\n  let nextPossiblePrimeDivisor d n =\n    if d = 2\n    then 3\n    elif d > (int <| Math.Sqrt(float n))\n    then n\n    else d + 2   \n  let rec loop acc d n =\n    if n = 1\n    then acc\n    elif n % d = 0\n    then loop (d :: acc) d (n \/ d)\n    else loop (acc) (nextPossiblePrimeDivisor d n) n\n  loop [] 2\n\nlet consecKprimes k =\n    List.map (primeDivisors >> List.length)\n    >> List.pairwise\n    >> List.filter (fun (x1, x2) -> x1 = k && x2 = k)\n    >> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85453,"user_id":null,"body":"let rec primeFactorize (x: int): int list =\n    let upperBound = x \/ 2\n    let firstFactor = \n        seq {2..upperBound}\n        |> Seq.tryFind (fun d -> x % d = 0)\n\n    match firstFactor with\n    | None -> [x]\n    | Some d -> List.append (primeFactorize d) (primeFactorize (x \/ d))\n\nlet consecKprimes k arr =\n    arr\n    |> Seq.map primeFactorize\n    |> Seq.map Seq.length\n    |> Seq.pairwise\n    |> Seq.filter (fun (x, y) -> x = k && y = k)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85454,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\n\/\/  10005 10030 - 4\n\/\/  10030 10026 - 4\n\/\/  10028 10004 - 4\nlet testColl = [10005; 10030; 10026; 10008; 10016; 10028; 10004;]\n\nlet memoize f =\n    let cache = Dictionary<_, _>()\n    fun x ->\n        if cache.ContainsKey(x) then \n            cache.[x]\n        else \n            let res = f x\n            cache.[x] <- res\n            res\n\nlet rec primeFactorize (x: int): int list =\n    let upperBound = x \/ 2\n    let firstFactor = \n        [2..upperBound]\n        |> Seq.tryFind (fun d -> x % d = 0)\n\n    match firstFactor with\n    | None -> [x]\n    | Some d -> List.append (primeFactorize d) (primeFactorize (x \/ d))\n\nlet consecKprimes k arr =\n    let memPrimeFac = memoize primeFactorize\n    arr\n    |> Seq.map memPrimeFac\n    |> Seq.map Seq.length\n    |> Seq.pairwise\n    |> Seq.filter (fun (x, y) -> x = k && y = k)\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85455,"user_id":null,"body":"let primeCount n =\n  let rec primeCountImpl n crr sum =\n    if n <= 1 then\n      sum\n    else if n % crr = 0 then\n      primeCountImpl (n \/ crr) crr (sum + 1)\n    else\n      primeCountImpl n (crr + 1) sum\n      \n  primeCountImpl n 2 0\n\nlet consecKprimes k arr =\n  arr\n  |> Seq.pairwise\n  |> Seq.filter (fun (n1, n2) ->\n       let p = primeCount n1\n       p = primeCount n2 && p = k)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85456,"user_id":null,"body":"let factor n k =\n    if n % k > 0\n    then 0, n\n    else\n        Seq.unfold (fun (count, reduced) -> \n            if (reduced % k = 0) \n            then \n                let result = count + 1, reduced \/ k\n                Some (result, result) \n            else None) (0, n)\n        |> Seq.last\n\nlet primeFactors n =\n    [2..n]\n    |> List.fold (fun (reduced, result) k -> \n        let count, newReduced = factor reduced k\n        if count > 0\n        then newReduced, (k, count) :: result\n        else (reduced, result)) (n, [])\n    |> snd\n\nlet countPrimeFactors n =\n    primeFactors n |> List.sumBy snd\n\nlet consecKprimes k arr =\n    arr\n    |> List.map countPrimeFactors\n    |> List.windowed 2\n    |> List.fold (fun acc [a; b] -> if a = k && b = k then acc + 1 else acc) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5739174624fc28e188000465":[{"id":85457,"user_id":null,"body":"open System\n\ntype Result =\n| Win = 0 \n| Loss = 1\n| Tie = 2\n\ntype HandRank =\n| HighCard = 0\n| OnePair = 1 \n| TwoPairs = 2\n| ThreeOfAKind = 3 \n| Straight = 4 \n| Flush = 5\n| FullHouse = 6 \n| FourOfAKind = 7 \n| StraightFlush = 8\n\ntype Suit = | Hearts | Diamonds | Clubs | Spades\n\ntype Pokerhand (hand: String) =\n       \n    let rank = \n      \n      let cardRank = function\n      | 'A' -> 14\n      | 'K' -> 13\n      | 'Q' -> 12\n      | 'J' -> 11\n      | 'T' -> 10\n      | c when c >= '0' && c <= '9' -> (int c) - (int '0')\n      | _ -> failwith \"Invalid card rank\"\n  \n      let cardSuit = function\n      | 'S' -> Spades\n      | 'H' -> Hearts\n      | 'D' -> Diamonds\n      | 'C' -> Clubs\n      | _ -> failwith \"Invalid card suit\"    \n      \n      let hand =\n          hand.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n          |> List.ofArray\n          |> List.map (fun s -> (cardRank (s.[0]), cardSuit (s.[1])))\n          |> List.sortByDescending fst\n\n      let isFlush = \n          hand |> List.distinctBy snd \n               |> List.length \n               |> (=) 1\n\n      let isStraight = \n          hand |> List.mapi (fun i (r,_) -> r + i) \n               |> List.distinct \n               |> List.length \n               |> (=) 1\n\n      let counts = \n          hand |> List.map fst \n               |> List.countBy id\n               |> List.sortByDescending (fun (_,c) -> c)\n\n      let handRank =\n        let cnts = counts |> List.map snd \n        match cnts with\n        | _ when isStraight && isFlush -> HandRank.StraightFlush\n        | [4;1] -> HandRank.FourOfAKind\n        | [3;2] -> HandRank.FullHouse\n        | _ when isFlush -> HandRank.Flush\n        | _ when isStraight -> HandRank.Straight\n        | [3;1;1] -> HandRank.ThreeOfAKind\n        | [2;2;1] -> HandRank.TwoPairs\n        | [2;1;1;1] -> HandRank.OnePair\n        | _ -> HandRank.HighCard\n\n      let uniqueCardRanks = counts |> List.map fst\n      (int handRank)::(uniqueCardRanks)\n\n    member this.Rank = rank\n\n    member this.compareWith (pokerhand: Pokerhand) = \n        if rank = pokerhand.Rank then\n            Result.Tie\n        elif rank < pokerhand.Rank then\n            Result.Loss\n        else\n            Result.Win\n            ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85458,"user_id":null,"body":"type Result =\n    | Win = 0 \n    | Loss = 1\n    | Tie = 2\n       \ntype Card (card: string) =\n    member this.toString = card\n    member this.rank =\n        match card.[0] with\n        | 'A' -> 14\n        | 'K' -> 13\n        | 'Q' -> 12\n        | 'J' -> 11\n        | 'T' -> 10\n        |  c when c >= '0' && c <= '9' -> (int) c - 48\n        |  _  -> 0\n    member this.suite = card |> Seq.last\n    member this.value = (this.rank, this.suite)\n\ntype Pokerhand (hand: string) =\n    let cards: Card list =\n        hand.Split ' ' |> Seq.toList\n                       |> List.map (fun s -> new Card(s))\n    \n    let order (cs: Card list): int list = cs |> List.map (fun c -> c.rank) |> List.sort |> List.rev\n\n    let groups = cards |> List.map (fun c -> c.rank)\n                       |> List.groupBy (fun c -> c)\n                       |> List.map (fun (k, v) -> v)\n                       |> List.sortBy (fun l -> List.length l)\n\n    let isFlush =\n        let res = cards |> List.forall (fun c -> c.suite = cards.[0].suite) \n        if res then Some (5, cards |> order) else None\n\n    let isStraight =\n        let ranks = cards |> order |> List.distinct\n        let res = List.length ranks = 5 && List.head ranks - List.last ranks = 4\n        if res then Some(4, cards |> order) else None\n\n    let isStraightFlush =\n        match (isStraight, isFlush) with\n        | (Some (_, hc), Some _) -> Some (8, hc)\n        | _ -> None\n\n    let isFourOfAKind =\n        match groups with\n        | [a; b;] when List.length b = 4 -> Some (7, [b.[0]; a.[0]])\n        | _ -> None\n        \n    let isFullHouse =\n        match groups with\n        | [a; b;] when List.length b = 3 -> Some (6, [b.[0]; a.[0]])\n        | _ -> None\n        \n    let isThreeOfAKind =\n        match groups with\n        | [a; b; c] when List.length c = 3 -> Some (3, [c.[0]; b.[0]; a.[0]])\n        | _ -> None\n\n    let isTwoPairs =\n        match groups with\n        | [a; b; c] when List.length c = 2 -> Some (2, ([b.[0]; c.[0]] |> List.sort |> List.rev) @ a)\n        | _ -> None\n\n    let isOnePair =\n        match groups with\n        | [a; b; c; d] when List.length d = 2 -> Some (1, [d.[0]] @ ([a.[0]; b.[0]; c.[0]] |> List.sort |> List.rev))\n        | _ -> None\n\n    let isNothing = Some (0, cards |> order)\n\n    let compareRank rs1 rs2 =\n        let t = List.zip rs1 rs2 |> List.tryFind (fun (x, y) -> x <> y )\n        match t with\n        | Some (x, y) -> if x > y then 1 else -1\n        | None -> 0\n\n    member this.eval =\n        let fs = [isStraightFlush; isFourOfAKind; isFullHouse; isFlush; isStraight; isThreeOfAKind;\n                    isTwoPairs; isOnePair; isNothing]\n        fs |> List.map (fun f -> f) |> List.find (fun e -> Option.isSome e)\n\n    member this.toString = hand\n    \n    member this.valueString =\n        cards |> List.sortBy (fun c -> c.rank) |> List.rev |> List.map (fun c -> string c.value ) |> String.concat \", \"\n\n    member this.compareWith (other: Pokerhand) = \n        let (v1, hc1) = Option.get this.eval\n        let (v2, hc2) = Option.get other.eval\n\n        if v1 > v2 then\n            Result.Win\n        elif v1 < v2 then\n            Result.Loss\n        elif compareRank hc1 hc2 = 1 then\n            Result.Win\n        elif compareRank hc1 hc2 = -1 then\n            Result.Loss\n        else\n            Result.Tie\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85459,"user_id":null,"body":"open System\n\ntype Result =\n| Win = 0 \n| Loss = 1\n| Tie = 2\n\ntype Suit = | Spades | Hearts | Diamonds | Clubs\n\ntype Value = | V2 = 2 | V3 = 3 | V4 = 4 | V5 = 5 | V6 = 6 | V7 = 7 | V8 = 8 | V9 = 9 | V10 = 10 | Jack = 11 | Queen = 12 | King = 13 | Ace = 14\n\ntype Card (s: string) =\n  let parseValue c =\n    match c with\n      | 'A' -> Value.Ace\n      | 'K' -> Value.King\n      | 'Q' -> Value.Queen\n      | 'J' -> Value.Jack\n      | '2' -> Value.V2\n      | '3' -> Value.V3\n      | '4' -> Value.V4\n      | '5' -> Value.V5\n      | '6' -> Value.V6\n      | '7' -> Value.V7\n      | '8' -> Value.V8\n      | '9' -> Value.V9\n      | 'T' -> Value.V10\n      | _ -> failwith \"Invalid value\"\n  let parseSuit c =\n    match c with\n      | 'S' -> Spades\n      | 'H' -> Hearts\n      | 'D' -> Diamonds\n      | 'C' -> Clubs\n      | _ -> failwith \"Invalid suit\"\n  let value = parseValue(s.[0])\n  let suit = parseSuit(s.[1])\n  member val Value = value\n  member val Suit = suit\n  interface System.IComparable<Card> with\n      member this.CompareTo other =\n          let valueComparison = compare this.Value other.Value\n          if valueComparison = 0\n          then compare this.Suit other.Suit\n          else valueComparison\n  interface IComparable with\n      member this.CompareTo obj =\n          match obj with\n              | null             -> 1\n              | :? Card as other -> (this :> IComparable<Card>).CompareTo other\n              | _                -> invalidArg \"obj\" \"not a Card\"\n  interface IEquatable<Card> with\n      member this.Equals other =\n          this.Value = other.Value && this.Suit = other.Suit\n  override this.Equals obj =\n      match obj with\n          | null -> false\n          | :? Card as other ->\n              this.Value = other.Value && this.Suit = other.Suit\n          | _ -> false\n  override this.GetHashCode () =\n      this.Value.GetHashCode() * 37 + this.Suit.GetHashCode()\n\nlet getCardValue (c: Card) = c.Value\n\ntype ParsedHand =\n  | Highcard of Value list \/\/ sorted from highest to lowest\n  | Pair of Value * Value list \/\/ sorted from highest to lowest\n  | TwoPairs of Value * Value * Value \/\/ sorted from highest to lowest\n  | Three of Value * Value list \/\/ sorted from highest to lowest\n  | Straight of Value \/\/ highest card of straight (contiguous sequence, Ace is 1 or max)\n  | Flush of Value list \/\/ sorted from highest to lowest, same suit for every card\n  | FullHouse of Value * Value \/\/ triple * pair\n  | Four of Value * Value \/\/ 4 times + remaining card\n  | StraightFlush of Card \/\/ highest card of straight (straight of same suit)\n  | RoyalFlush of Suit \/\/ straight flush from Ace down to 10\n\nlet diffRev f xs =\n    let rec go acc prev ys =\n        match ys with\n            | y :: tail -> go ((f prev y)::acc) y tail\n            | [] -> acc\n    match xs with\n        | x :: (_ :: _ as tail) -> go [] x tail\n        | [_] -> invalidArg \"xs\" \"invalid number of elements in input\"\n        | [] -> []\n\n\/\/ Assumes cards are already sorted from highest to lowest\nlet isFlush (cards: Card list) =\n    let headCard = List.head cards\n    if List.forall (fun (c: Card) -> c.Suit = headCard.Suit) cards\n    then Flush (List.map getCardValue cards) |> Some\n    else None\n\n\/\/ Assumes cards are already sorted from highest to lowest\nlet isStraight (cards: Card list) =\n    match cards |> List.map (getCardValue >> int) |> diffRev (fun x y -> x - y) with\n        | [1; 1; 1; 1] -> Straight (List.head cards).Value |> Some\n        \/\/ Ace; 5; 4; 3; 2 Ace is Straight [5; 4; 3; 2; Ace]\n        | [1; 1; 1; 9] -> Straight Value.V5 |> Some\n        | _ -> None\n    \n\/\/ Assumes cards are already sorted from highest to lowest\nlet isStraightFlush (cards: Card list) =\n    match (isStraight cards, isFlush cards) with\n        | (Some (Straight _), Some (Flush _)) -> List.head cards |> StraightFlush |> Some\n        | _ -> None\n\n\/\/ Assumes cards are already sorted from highest to lowest\nlet isRoyalFlush (cards: Card list) =\n  match isStraightFlush cards with\n      | Some (StraightFlush c)\n        when c.Value = Value.Ace && List.forall (fun (o: Card) -> o.Suit = c.Suit) cards\n        -> RoyalFlush c.Suit |> Some\n      | _ -> None\n\nlet firstSome fs defaultFunction x =\n    let rec go = function\n        | [] -> defaultFunction x\n        | f :: tail -> match f x with\n                           | Some result -> result\n                           | None -> go tail\n    go fs\n\nlet isGrouped (cards: Card list) =\n    let grouped = List.groupBy getCardValue cards\n               |> List.map (fun (v: Value, cs: Card list) -> (v, List.length cs))\n               |> List.sortByDescending snd\n    match grouped with\n        | [(v, 4); (o, 1)] -> Four (v, o) |> Some\n        | [(v, 3); (o, 2)] -> FullHouse (v, o) |> Some\n        | [(v, 3); (o, 1); (p, 1)] -> Three (v, [max o p; min o p]) |> Some\n        | [(v, 2); (w, 2); (o, 1)] -> TwoPairs (max v w, min w v, o) |> Some\n        | (v, 2) :: _ ->\n            Pair (v,\n                  List.filter (fun (o: Card) -> o.Value <> v) cards\n                  |> List.map getCardValue)\n            |> Some\n        | _ -> None\n        \nlet parseHand (s: string) =\n  let cards = s.Split ' ' |> Seq.map Card |> Seq.sortDescending |> Seq.toList\n  firstSome [isRoyalFlush\n             isStraightFlush\n             isStraight\n             isFlush\n             isGrouped]\n            (List.map getCardValue >> Highcard)\n            cards\n\nlet compareToResult a b =\n    if a > b\n    then Result.Win\n    elif a < b\n    then Result.Loss\n    else Result.Tie\n\ntype Pokerhand (hand: string) =\n    let parsed = parseHand hand\n    member val Parsed = parsed\n    member this.compareWith (pokerhand: Pokerhand) = compareToResult this.Parsed pokerhand.Parsed\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85460,"user_id":null,"body":"open Microsoft.FSharp.Core.LanguagePrimitives\n\nmodule Arrow =\n    let split x = x, x\n    let first f (x, y) = f x, y\n    let second f (x, y) = x, f y\n    let both f (x, y) = f x, f y\n    let mergeWith f (x, y) = f x y\n\nlet curry f a b = f (a, b)\nlet uncurry f (a, b) = f a b\n\nmodule Option =\n    let zip a b : option<'a * 'b> = Option.map2 (fun x y -> x, y) a b\n\ntype CardValue =\n    | Two = 0\n    | Three = 1\n    | Four = 2\n    | Five = 3\n    | Six = 4\n    | Seven = 5\n    | Eight = 6\n    | Nine = 7\n    | Ten = 8\n    | Jack = 9\n    | Queen = 10\n    | King = 11\n    | Ace = 12\n\nlet parseCardValue (c: char) : CardValue =\n    \"23456789TJQKA\".ToCharArray()\n    |> Array.findIndex ((=) c)\n    |> LanguagePrimitives.EnumOfValue<int, CardValue>\n\ntype CardSuit = char\n\ntype Hand = list<CardValue * CardSuit>\n\nlet isFlush: Hand -> bool =\n    List.countBy snd >> List.item 0 >> snd >> ((=) 5)\n\nlet isStraight: Hand -> bool =\n    List.map (fst >> unbox<int>)\n    >> List.sort\n    >> List.pairwise\n    >> List.forall (fun (a, b) -> b - a = 1)\n\nlet isStraightFlush hand = isStraight hand && isFlush hand\n\nlet highest: Hand -> CardValue * CardSuit = List.maxBy fst\nlet highestCardValue: Hand -> CardValue = List.map fst >> List.max\n\nlet filterByCount c =\n    Arrow.split\n    >> Arrow.first (\n        List.countBy fst\n        >> List.tryFind (fun (_, n) -> n = c)\n        >> Option.map fst\n        >> Option.map (fun cv -> List.filter (fst >> ((=) cv)))\n    )\n    >> Arrow.second Some\n    >> Arrow.mergeWith (Option.map2 (<|))\n\nlet findPairs: Hand -> list<Hand> =\n    Arrow.split\n    >> Arrow.first (\n        List.countBy fst\n        >> List.filter (fun (_, n) -> n = 2)\n        >> List.map fst\n        >> List.map (fun cv -> List.filter (fst >> ((=) cv)))\n    )\n    >> Arrow.mergeWith (fun a b -> List.map ((|>) b) a)\n\ntype Result =\n    | Win = 0\n    | Loss = 1\n    | Tie = 2\n\nlet compareCards c1 c2 =\n    if c1 = c2 then Result.Tie\n    else if c1 > c2 then Result.Win\n    else Result.Loss\n\nlet compareHighest h1 h2 =\n    (h1, h2)\n    |> Arrow.both (highest >> fst)\n    |> Arrow.mergeWith compareCards\n\nlet findHigher (h1: Hand) (h2: Hand) =\n    let maybeHighestNonEq =\n        (h1, h2)\n        |> Arrow.both (List.map fst)\n        |> Arrow.both List.sortDescending\n        |> Arrow.mergeWith List.zip\n        |> List.tryFind (uncurry (<>))\n\n    maybeHighestNonEq\n    |> Option.map (uncurry compareCards)\n    |> Option.orElse (Some Result.Tie)\n\nlet rec tryPair h1 h2 =\n    let cv = List.head >> fst\n\n    let exceptPair h =\n        List.filter (fst >> ((<>) (h |> List.head |> fst)))\n\n    match Arrow.both (filterByCount 2) (h1, h2) with\n    | Some _, None -> Some Result.Win\n    | None, Some _ -> Some Result.Loss\n    | Some rh1, Some rh2 when cv rh1 = cv rh2 -> tryPair (exceptPair rh1 h1) (exceptPair rh2 h2)\n    | Some rh1, Some rh2 -> Some(compareHighest rh1 rh2)\n    | _ -> None\n\nlet rec tryThree h1 h2 =\n    let cv = List.head >> fst\n\n    let other h =\n        List.filter (fst >> ((<>) (h |> List.head |> fst)))\n\n    match Arrow.both (filterByCount 3) (h1, h2) with\n    | Some _, None -> Some Result.Win\n    | None, Some _ -> Some Result.Loss\n    | Some rh1, Some rh2 when cv rh1 = cv rh2 -> Some(compareHighest (other rh1 h1) (other rh2 h2))\n    | Some rh1, Some rh2 -> Some(compareHighest rh1 rh2)\n    | _ -> None\n\nlet rec tryFour h1 h2 =\n    let cv = List.head >> fst\n\n    let single h =\n        List.filter (fst >> ((<>) (h |> List.head |> fst)))\n\n    match Arrow.both (filterByCount 4) (h1, h2) with\n    | Some _, None -> Some Result.Win\n    | None, Some _ -> Some Result.Loss\n    | Some rh1, Some rh2 when cv rh1 = cv rh2 -> Some(compareHighest (single rh1 h1) (single rh2 h2))\n    | Some rh1, Some rh2 -> Some(compareHighest rh1 rh2)\n    | _ -> None\n\nlet tryTwoPairs h1 h2 =\n    let maybeTwoPairs h =\n        findPairs h\n        |> List.map (List.head)\n        |> Some\n        |> Option.filter (List.length >> ((=) 2))\n        |> Option.map List.sortDescending\n\n    let single =\n        filterByCount 1 >> Option.get >> List.head\n\n    match maybeTwoPairs h1, maybeTwoPairs h2 with\n    | Some _, None -> Some Result.Win\n    | None, Some _ -> Some Result.Loss\n    | Some [ l1; l2 ], Some [ r1; r2 ] when fst l1 = fst r1 && fst l2 = fst r2 ->\n        Some(compareCards (single h1) (single h2))\n    | Some [ l1; l2 ], Some [ r1; r2 ] when fst l1 = fst r1 -> Some(compareCards l1 r1)\n    | Some [ l1; l2 ], Some [ r1; r2 ] when fst l2 = fst r2 -> Some(compareCards l1 r1)\n    | _ -> None\n\nlet tryFullHouse h1 h2 =\n    let cv = List.head >> fst\n\n    let listFromPair a b = [ a; b ]\n\n    let maybeFullHouses =\n        Arrow.split\n        >> Arrow.first (filterByCount 3)\n        >> Arrow.second (filterByCount 2)\n        >> Arrow.both (Option.map List.head)\n        >> Arrow.mergeWith Option.zip\n\n    match maybeFullHouses h1, maybeFullHouses h2 with\n    | Some _, None -> Some Result.Win\n    | None, Some _ -> Some Result.Loss\n    | Some (l3, l2), Some (r3, r2) when l3 = r3 -> Some(compareCards l2 r2)\n    | Some (l3, l2), Some (r3, r2) -> Some(compareCards l3 r3)\n    | _ -> None\n\nlet isRoyalFlush h =\n    isStraightFlush h\n    && highestCardValue h = CardValue.Ace\n\nlet tryValue filter onBothMatch h1 h2 =\n    match Arrow.both filter (h1, h2) with\n    | Some _, None -> Some Result.Win\n    | None, Some _ -> Some Result.Loss\n    | Some rh1, Some rh2 -> Some(onBothMatch rh1 rh2)\n    | _ -> None\n\nmodule String =\n    let split (sep: string) (s: string) = s.Split(sep.ToCharArray())\n\nlet parseCard =\n    Arrow.split\n    >> Arrow.first (Seq.item 0 >> parseCardValue)\n    >> Arrow.second (Seq.item 1)\n\nlet parseHand =\n    String.split \" \"\n    >> List.ofArray\n    >> List.map parseCard\n\nlet compareHands (hand1: Hand) (hand2: Hand) : Result =\n    List.pick\n        ((||>) (hand1, hand2))\n        [ tryValue (Some >> Option.filter isRoyalFlush) (fun _ _ -> Result.Tie)\n          tryValue (Some >> Option.filter isStraightFlush) compareHighest\n          tryFour\n          tryFullHouse\n          tryValue (Some >> Option.filter isFlush) (fun a b -> findHigher a b |> (Option.defaultValue Result.Tie))\n          tryValue (Some >> Option.filter isStraight) compareHighest\n          tryThree\n          tryTwoPairs\n          tryPair\n          findHigher ]\n\ntype Pokerhand(hand: string) =\n    member val Hand = hand\n\n    member this.compareWith(other: Pokerhand) =\n        printf \"%O, %O\" this.Hand other.Hand\n        (this.Hand, other.Hand)\n        |> Arrow.both parseHand\n        |> Arrow.mergeWith compareHands","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85461,"user_id":null,"body":"open System\n\ntype Result =\n  | Win = 0 \n  | Loss = 1\n  | Tie = 2\n  \ntype Card = Card of value: int * color: char\n\nlet valueOf (Card (value, _)) = value\nlet colorOf (Card (_, color)) = color\n\nlet ofString (str: string) =\n    str.Split ' '\n    |> Seq.map (fun s -> \n        let value = \n            match s.[0] with\n            | n when n |> Char.IsDigit -> n |> Char.GetNumericValue |> int\n            | 'T' -> 10\n            | 'J' -> 11\n            | 'Q' -> 12\n            | 'K' -> 13\n            | 'A' -> 14\n        Card (value, s.[1]))\n    |> Seq.toList\n\ntype HandScore =\n  | HighCard of int list\n  | Pair of value: int  * rest: int list\n  | DoublePair of value1: int * value2: int * rest: int\n  | ThreeOfAKind of value: int * rest: int list\n  | Straight of startValue: int\n  | Flush of int list\n  | FullHouse of value1: int * value2: int\n  | FourOfAKind of value: int * rest: int\n  | StraightFlush of startValue: int\n  \nlet handValue cards = \n    let groupedByValue = \n        cards \n        |> List.map valueOf\n        |> List.countBy id\n        |> List.sortByDescending (fun (value, n) -> n, value)\n        \n    let sameColors =\n      cards\n      |> List.distinctBy colorOf\n      |> List.length\n      |> (=) 1\n\n    match groupedByValue with\n    | [ (x, 2) ; (y, 2) ; (z, 1) ] -> DoublePair (x, y, z)\n    | (x, 2) :: xs -> Pair (x, xs |> List.map fst)\n    | [ (x, 3) ; (y, 2) ] -> FullHouse (x, y)\n    | (x, 3) :: xs -> ThreeOfAKind (x, xs |> List.map fst)\n    | [ (x, 4) ; (y, 1) ] -> FourOfAKind (x, y)\n    | [ (x, 1) ; _ ; _ ; _ ; (y, 1) ] when x = y + 4 ->\n      if sameColors then StraightFlush y else Straight y\n    | [ (14, 1) ; (5, 1) ; _ ; _ ; _ ] ->\n      if sameColors then StraightFlush 1 else Straight 1\n    | xs ->\n      if sameColors then Flush (xs |> List.map fst) else HighCard (xs |> List.map fst)\n  \nlet compareHand hand1 hand2 =\n    let score1, score2 = handValue hand1, handValue hand2\n    \/\/printfn \"%A %A\" score1 score2\n    if score1 = score2 then Result.Tie\n    elif score1 > score2 then Result.Win\n    else Result.Loss\n       \ntype Pokerhand (hand: string) =\n    let cards = ofString hand\n    member __.Cards = cards\n    member __.compareWith (pokerhand: Pokerhand) = \n        compareHand cards pokerhand.Cards","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85462,"user_id":null,"body":"open System.Linq\n\ntype Result =\n| Win = 0 \n| Loss = 1\n| Tie = 2\n\ntype CardType =\n| X2 = 2 | X3 = 3 | X4 = 4 | X5 = 5 | X6 = 6 | X7 = 7 | X8 = 8 | X9 = 9 | T = 10 | J = 11 | Q = 12 | K = 13 | A = 14\n\ntype HandType =\n| Kicker of CardType * CardType * CardType * CardType * CardType\n| Pair of CardType * CardType * CardType * CardType\n| Pairs of CardType * CardType * CardType\n| Three of CardType * CardType * CardType\n| Straight of CardType\n| Flush of CardType * CardType * CardType * CardType * CardType\n| FullHouse of CardType * CardType\n| Four of CardType * CardType\n| StraightFlush of CardType\n\ntype Pokerhand (hand: string) =\n    let parseCard (card:string) =\n      let t =\n        match card.[0] with\n        | '2' -> CardType.X2 | '3' -> CardType.X3 | '4' -> CardType.X4 | '5' -> CardType.X5 | '6' -> CardType.X6\n        | '7' -> CardType.X7 | '8' -> CardType.X8 | '9' -> CardType.X9 | 'T' -> CardType.T | 'J' -> CardType.J\n        | 'Q' -> CardType.Q | 'K' -> CardType.K | 'A' -> CardType.A | _ -> failwith \"Error\"\n      (t, card.[1])\n    let sortCards = List.sortByDescending (fun (t:CardType, _) -> t)\n    let parseHandType (sorted:(int*CardType) list) cards =\n      match cards with\n      | [(t1, m1); (t2, m2); (t3, m3); (t4, m4); (t5, m5)] ->\n        let isStraight = int(t1 - t2) = 1 && int(t2 - t3) = 1 && int(t3 - t4) = 1 && int(t4 - t5) = 1\n        let isFlush = m1 = m2 && m1 = m3 && m1 = m4 && m1 = m5\n        if isStraight && isFlush then StraightFlush t1\n        else\n          match sorted with\n          | (4, t1)::(1, t2)::_ -> Four (t1, t2)\n          | (3, t1)::(2, t2)::_ -> FullHouse (t1, t2)\n          | _ when isFlush -> Flush (t1, t2, t3, t4, t5)\n          | _ when isStraight -> Straight t1\n          | (3, t1)::(1, t2)::(1, t3)::_ -> Three (t1, t2, t3)\n          | (2, t1)::(2, t2)::(1, t3)::_ -> Pairs (t1, t2, t3)\n          | (2, t1)::(1, t2)::(1, t3)::(1, t4)::_ -> Pair (t1, t2, t3, t4)\n          | _ -> Kicker (t1, t2, t3, t4, t5)\n      | _ -> failwith \"Error\"\n\n    let handType =\n        let cards = hand.Split() |> List.ofArray |> List.map parseCard |> sortCards\n        let dict = new System.Collections.Generic.Dictionary<CardType, int>()\n        let add t = match dict.TryGetValue t with | true, v -> dict.[t] <- v + 1 | _ -> dict.Add(t, 1)\n        for (t, _) in cards do add t\n        let sorted = dict.OrderByDescending (fun pair -> pair.Value) |> Seq.toList |> List.map (fun card -> (card.Value, card.Key))\n        parseHandType sorted cards\n\n    member this.HandType = handType\n\n    member this.compareWith (pokerhand: Pokerhand) =\n      match this.HandType, pokerhand.HandType with\n      | StraightFlush t_t1, StraightFlush o_t1 -> if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss else Result.Tie\n      | StraightFlush _, _ -> Result.Win\n      \n      | Four _, StraightFlush _ -> Result.Loss\n      | Four (t_t1, t_t2), Four (o_t1, o_t2) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        else Result.Tie\n      | Four _, _ -> Result.Win\n      \n      | FullHouse _, StraightFlush _  | FullHouse _, Four _ -> Result.Loss\n      | FullHouse (t_t1, t_t2), FullHouse (o_t1, o_t2) ->\n          if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n          elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n          else Result.Tie\n      | FullHouse _, _ -> Result.Win\n      \n      | Flush _, StraightFlush _  | Flush _, Four _ | Flush _, FullHouse _ -> Result.Loss\n      | Flush (t_t1, t_t2, t_t3, t_t4, t_t5), Flush (o_t1, o_t2, o_t3, o_t4, o_t5) ->\n          if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n          elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n          elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n          elif t_t4 > o_t4 then Result.Win elif t_t4 < o_t4 then Result.Loss\n          elif t_t5 > o_t5 then Result.Win elif t_t5 < o_t5 then Result.Loss\n          else Result.Tie\n      | Flush _, _ -> Result.Win\n      \n      | Straight _, StraightFlush _  | Straight _, Four _ | Straight _, FullHouse _ | Straight _, Flush _ -> Result.Loss\n      | Straight t_t1, Straight o_t1 -> if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss else Result.Tie\n      | Straight _, _ -> Result.Win\n      \n      | Three _, StraightFlush _  | Three _, Four _ | Three _, FullHouse _ | Three _, Flush _ | Three _, Straight _ -> Result.Loss\n      | Three (t_t1, t_t2, t_t3), Three (o_t1, o_t2, o_t3) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        else Result.Tie\n      | Three _, _ -> Result.Win\n      \n      | Pairs _, StraightFlush _  | Pairs _, Four _ | Pairs _, FullHouse _ | Pairs _, Flush _ | Pairs _, Straight _ | Pairs _, Three _ -> Result.Loss\n      | Pairs (t_t1, t_t2, t_t3), Pairs (o_t1, o_t2, o_t3) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        else Result.Tie\n      | Pairs _, _ -> Result.Win\n      \n      | Pair _, StraightFlush _  | Pair _, Four _ | Pair _, FullHouse _ | Pair _, Flush _\n      | Pair _, Straight _ | Pair _, Three _ | Pair _, Pairs _ -> Result.Loss\n      | Pair (t_t1, t_t2, t_t3, t_t4), Pair (o_t1, o_t2, o_t3, o_t4) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        elif t_t4 > o_t4 then Result.Win elif t_t4 < o_t4 then Result.Loss\n        else Result.Tie\n      | Pair _, _ -> Result.Win\n      \n      | Kicker (t_t1, t_t2, t_t3, t_t4, t_t5), Kicker (o_t1, o_t2, o_t3, o_t4, o_t5) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        elif t_t4 > o_t4 then Result.Win elif t_t4 < o_t4 then Result.Loss\n        elif t_t5 > o_t5 then Result.Win elif t_t5 < o_t5 then Result.Loss\n        else Result.Tie\n      | _ -> Result.Loss","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85463,"user_id":null,"body":"type Result = | Win = 0 | Loss = 1 | Tie = 2\ntype HandScore = \n   | HighCard = 1 | OnePair = 2 | TwoPair = 3 | ThreeKind = 4 | Straight = 5\n   | Flush = 6 | FullHouse = 7 | FourKind = 8 | StraightFlush = 9 | RoyalFlush = 10\n\nlet parseValue c = \n    match c with\n    | 'A' -> 14 | 'K' -> 13 | 'Q' -> 12 | 'J' -> 11 | 'T' -> 10\n    | _ -> int c - int '0'\n\nlet byValue cards = cards |> Seq.sortBy (fun (v, _) -> v)\nlet isFlush cards = \n    cards |> Seq.pairwise |> Seq.forall(fun (a, b) -> snd a = snd b)\nlet isStraight cards = \n    cards |> byValue |> Seq.pairwise |> Seq.forall(fun (a, b) -> fst a = fst b - 1)\nlet valueCounts cards = \n    cards \n    |> Seq.countBy (fun (v, _) -> v) \n    |> Seq.sortByDescending (fun (v, c) -> (c, v))\nlet parseCard (str:string) = (parseValue str.[0]), str.[1]\nlet parseHand (hand:string) = hand.Split(' ') |> Seq.map parseCard\n\nlet handResult cards =\n   let flush = isFlush cards\n   let straight = isStraight cards\n   let highCard = cards |> Seq.sortByDescending fst |> Seq.head |> fst\n   let valueCounts = valueCounts cards |> Seq.toList\n   let tiebreak = valueCounts |> Seq.map fst |> Seq.toList\n   let counts = valueCounts |> Seq.map snd |> Seq.toList\n   match (flush, straight, counts) with\n   | (true, true, _) when highCard = 14 -> [int HandScore.RoyalFlush; highCard]\n   | (true, true, _) -> [int HandScore.StraightFlush; highCard]\n   | (false, true, _) -> [int HandScore.Straight; highCard]\n   | (false, false, [4;1]) -> int HandScore.FourKind :: tiebreak\n   | (false, false, [3;2]) -> int HandScore.FullHouse :: tiebreak\n   | (true, false, _) -> [int HandScore.Flush; highCard]\n   | (false, true, _) -> [int HandScore.Straight; highCard]\n   | (false, false, [3;1;1]) -> int HandScore.ThreeKind :: tiebreak\n   | (false, false, [2;2;1]) -> int HandScore.TwoPair :: tiebreak\n   | (false, false, [2;1;1;1]) -> int HandScore.OnePair :: tiebreak\n   | (_, _, _) -> int HandScore.HighCard :: tiebreak\n\nlet rec decideTiebreak l1 l2 =\n    match l1, l2 with\n    | x::xs, y::ys ->\n        match x - y with\n        | n when n < 0 -> Result.Loss\n        | n when n > 0 -> Result.Win\n        | _ -> decideTiebreak xs ys\n    | _ -> Result.Tie\n\ntype Pokerhand (hand: string) =\n    let cards = parseHand hand\n    member this.HandResult = handResult cards\n    member this.compareWith (pokerhand: Pokerhand) = \n        decideTiebreak this.HandResult pokerhand.HandResult","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85464,"user_id":null,"body":"open System\ntype Result =\n| Win = 0 \n| Loss = 1\n| Tie = 2\n\ntype HandType = High | Pair1 | Pair2 | Three | Straight | Flush | FullHouse | Four | StraightFlush | RoyalFlush\ntype Hand = HandType * int array\ntype Card = {suit : Char; value : int}\nlet toCard (card : String) : Card= \n  {value = match card.[0] with \n            |'T' -> 10\n            |'J' -> 11\n            |'Q' -> 12\n            |'K' -> 13\n            |'A' -> 14\n            | x  -> int x - int '0'  \n    ; suit = card.[1]}\n\nlet toHand (hand : String) : Hand = \n  let a = hand.Split(' ')\n  let value x = x.value\n  let suit x = x.suit\n  let cards = Array.map toCard a |> Array.sortByDescending value\n  let gv = Seq.groupBy value cards \n        |> Seq.map (fun (_, l) -> l |> Seq.sortByDescending value |> Array.ofSeq)\n        |> Seq.sortByDescending (fun l -> (l.Length, l.[0].value)) \n        |> Array.ofSeq\n  let gpt = Array.map (Array.length >> string) gv |> String.concat \"\"\n  let values = Array.map value cards\n  let handValues = Array.map (Array.head >> value) gv\n  let isFlush = cards |> Array.map suit |> Array.distinct |> Array.length |> (=)1\n  let isStraight = [|Array.last values .. Array.head values|] = Array.rev values\n  let isStraightFlush = isStraight && isFlush\n  let isRoyalFlush = isStraightFlush && values.[0] = 14\n  let typ = match gpt with \n             | _ when isRoyalFlush -> RoyalFlush\n             | _ when isStraightFlush -> StraightFlush\n             | _ when gpt = \"41\" -> Four\n             | _ when gpt = \"32\" -> FullHouse\n             | _ when isFlush -> Flush\n             | _ when isStraight -> Straight\n             | _ when gpt = \"311\" -> Three\n             | _ when gpt = \"221\" -> Pair2\n             | _ when gpt = \"2111\" -> Pair1\n             | _ -> High\n  (typ, handValues)\n\ntype Pokerhand (hand: String) =\n    member this.Hand = toHand hand\n    member this.compareWith (other: Pokerhand) = \n      if this.Hand > other.Hand then Result.Win\n      else if this.Hand < other.Hand then Result.Loss\n      else Result.Tie\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85465,"user_id":null,"body":"type Result =\n| Win = 0 \n| Loss = 1\n| Tie = 2\n\ntype Suit = | Diamond | Heart | Spade | Club\ntype Kind = | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\ntype Card = Kind * Suit\n\n\/\/ categories highest to lowest\ntype Category =\n    | StraightFlush of Kind \/\/ highest\n    | FullHouse of Kind * Kind \/\/ triplet & duplet\n    | FourOfAKind of Kind\n    | Flush of Kind list \/\/ five cards sorted by rank descending\n    | Straight of Kind \/\/ highest\n    | ThreeOfAKind of Kind\n    | TwoPair of Kind * Kind\n    | OnePair of Kind\n    | HighCard of Kind\n\nlet private parseKind = function\n    | \"2\" -> Two\n    | \"3\" -> Three\n    | \"4\" -> Four\n    | \"5\" -> Five\n    | \"6\" -> Six\n    | \"7\" -> Seven\n    | \"8\" -> Eight\n    | \"9\" -> Nine\n    | \"T\" -> Ten\n    | \"J\" -> Jack\n    | \"Q\" -> Queen\n    | \"K\" -> King\n    | \"A\" -> Ace\n    | c -> failwithf \"invalid card %s\" c\n\nlet private parseSuit =\n    function\n    | \"D\" -> Diamond\n    | \"H\" -> Heart\n    | \"C\" -> Club\n    | \"S\" -> Spade\n    | s -> failwithf \"invalid suit %s\" s\n\n\nlet private parseHand (hand : string) : Card list =\n    let cards = \n        hand.Split(' ')\n        |> List.ofArray\n        |> List.map (fun cardStr -> (cardStr.Substring(0, cardStr.Length-1) |> parseKind), (cardStr.Substring(cardStr.Length - 1) |> parseSuit))\n    if cards.Length <> 5 then\n        failwith \"invalid number of cards\"\n    if (List.distinct cards).Length <> 5 then\n        failwith \"hand has duplicate cards\"\n    cards\n\nlet private kindRank aceIsHighest =\n    function\n    | Two -> 2\n    | Three -> 3\n    | Four -> 4\n    | Five -> 5\n    | Six -> 6\n    | Seven -> 7\n    | Eight -> 8\n    | Nine -> 9\n    | Ten -> 10\n    | Jack -> 11\n    | Queen -> 12\n    | King -> 13\n    | Ace -> if aceIsHighest then 14 else 1\n\nlet private tryFindStraight (hand : Card list) =\n    let isStraight rankedHand = \n        let lowestRank = List.last rankedHand |> snd\n        rankedHand |> List.map (fun (_, r) -> r - lowestRank) = [4; 3; 2; 1; 0]\n\n    let rankedByHighAce =\n        hand |> List.map (fun c -> c, kindRank true (fst c)) |> List.sortByDescending snd\n    let rankedByLowAce =\n        hand |> List.map (fun c -> c, kindRank false (fst c)) |> List.sortByDescending snd\n    if rankedByHighAce |> isStraight\n    then rankedByHighAce |> List.map fst |> Some\n    elif rankedByLowAce |> isStraight\n    then rankedByLowAce |> List.map fst |> Some\n    else None\n\nlet private categorizeHand (hand : Card list) =\n    let suitGroups = hand |> List.groupBy snd |> List.map (fun (suit, cs) -> suit, cs |> List.map fst)\n    let kindCounts = hand |> List.countBy fst |> List.sortByDescending snd\n    let maybeStraight = tryFindStraight hand\n    \n    let highCards = List.map (fst >> HighCard)\n\n    match suitGroups, maybeStraight, kindCounts with\n    | [_], Some straightCards, _ -> \/\/ one suit, straight\n        [StraightFlush (List.head straightCards |> fst)]\n    | _, _, [(k1, 4); (k2, 1)] ->\n        [FourOfAKind k1; HighCard k2]\n    | _, _, [(k1, 3); (k2, 2)] ->\n        [FullHouse (k1, k2)]\n    | [ks], _, _ ->\n        [Flush (snd ks)]\n    | _, Some straightCards, _ ->\n        [Straight (List.head straightCards |> fst)]\n    | _, _, (k, 3) :: ks ->\n        ThreeOfAKind k :: (highCards ks)\n    | _, _, [(k1, 2); (k2, 2); (k3, 1)] ->\n        [TwoPair (k1, k2); HighCard k3]\n    | _, _, (k, 2) :: ks ->\n        OnePair k :: (highCards ks)\n    | _, _, ks ->\n        highCards ks\n\n\/\/ can sort by tuples & lists!\nlet private handRank =\n    let kr = kindRank true\n    let krs = List.map kr >> List.sortDescending\n    let rank = \n        function\n        | StraightFlush k -> (9, [kr k])\n        | FourOfAKind k -> (8, [kr k])\n        | FullHouse (k1, k2) -> (7, [kr k1; kr k2]) \/\/ don't sort ranks of full house, \n        | Flush ks -> (6, krs ks)\n        | Straight k -> (5, [kr k])\n        | ThreeOfAKind k -> (4, [kr k])\n        | TwoPair (k1, k2) -> (3, krs [k1; k2])\n        | OnePair k -> (2, [kr k])\n        | HighCard k -> (1, [kr k])\n    categorizeHand >> List.map rank >> List.sortDescending\n\n      \ntype Pokerhand (hand: string) =\n\n    member this.hand = hand\n\n    member this.compareWith (pokerhand: Pokerhand) = \n       let rank = parseHand >> handRank\n       let thisRank = rank this.hand\n       let otherRank = rank pokerhand.hand\n       \n       if thisRank > otherRank\n       then Result.Win\n       elif thisRank < otherRank\n       then Result.Loss\n       else Result.Tie","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85466,"user_id":1617,"body":"\ntype Result =\n    | Win = 0\n    | Loss = 1\n    | Tie = 2\n\ntype Pokerhand(hand: string) =\n    let ranks = Map.ofSeq (Seq.map (fun (l, r) -> (r, l)) (Seq.indexed \"23456789TJQKA\"))\n\n    let cs = Seq.toList (hand.Split(' '))\n    let rs = List.sortDescending (List.map (fun (s: string) -> ranks.[s.[0]]) cs)\n    let flsh = List.length (List.distinctBy (fun (s: string) -> s.[1]) cs) = 1\n    let strt = List.length (List.distinct (List.mapi (+) rs)) = 1\n\n    member this.Score =\n        match List.sortDescending (List.map snd (List.countBy id rs)) with\n        | _ when strt && flsh -> 8\n        | 4 :: _ -> 7\n        | 3 :: 2 :: _ -> 6\n        | _ when flsh -> 5\n        | _ when strt -> 4\n        | 3 :: _ -> 3\n        | 2 :: 2 :: _ -> 2\n        | 2 :: _ -> 1\n        | _ -> 0\n        :: rs\n\n    member this.compareWith (pokerhand: Pokerhand) =\n        if this < pokerhand then Result.Loss\n        elif this = pokerhand then Result.Tie\n        else Result.Win\n\n    interface System.IComparable with\n        member this.CompareTo(other: obj): int =\n            match box other with\n            | :? Pokerhand as other -> compare this.Score other.Score\n            | _ -> 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"573992c724fc289553000e95":[{"id":85467,"user_id":null,"body":"let smallest (n: int64) =\n    let allPosibilites i x (n:string) =\n        [0..n.Length - 1]\n        |> Seq.mapi (fun j y -> n.Remove(i,1).Insert(j,x) |> int64, i , j )        \n            \n    let n = n.ToString()\n    n\n    |> Seq.mapi (fun i x -> allPosibilites i (x.ToString()) n)\n    |> Seq.map (fun x-> x |> Seq.min )\n    |> Seq.min","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85468,"user_id":null,"body":"let smallest (n: int64) =\n    seq {\n        let ns = n |> string\n        for i in 0..ns.Length-1 do\n            let toInsert = ns.[i] |> string\n            let insertAndParse idx = ns.Remove(i, 1).Insert(idx, toInsert) |> int64\n            for insIdx in 0..ns.Length-1 do\n                yield insertAndParse insIdx, i, insIdx\n    } |> Seq.minBy (fun (x, _, _) -> x)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85469,"user_id":null,"body":"let numberToDigits (n: int64) =\n    match n with\n    | n when n < 10L -> [int n]\n    | n -> n\n           |> List.unfold (fun n -> if n = 0L then None else Some (int (n%10L), n\/10L))\n           |> List.rev\n\nlet digitsToNumber (digits: int list) : int64 =\n    List.fold (fun n d -> n*10L + int64 d) 0L digits\n\nlet smallest (number: int64) =\n\n    let applyMove digits (moveFrom, moveTo) =\n        let (left, right) = digits |> List.splitAt moveFrom\n        let digitToMove = right.Head\n        let (left, right) = left @ right.Tail |> List.splitAt moveTo\n        (left @ [digitToMove] @ right, moveFrom, moveTo)\n\n    let digits = number |> numberToDigits\n    let positions = [ 0 .. digits.Length - 1 ]\n    let (digits, moveFrom, moveTo) =\n        List.allPairs positions positions\n        |> List.map (applyMove digits)\n        |> List.sort\n        |> List.head\n    (digits |> digitsToNumber, moveFrom, moveTo)\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85470,"user_id":492,"body":"open System\n\nlet decompose(a: array<char>) =\n    let l = Array.length a\n    [for i in [0..l-1] do\n        yield ( i, a.[i..i], Array.concat[a.[0..i-1]; a.[i+1..l-1]] )] |> Seq.toList\nlet rec composeAux lst res =\n    match lst with\n    | [] -> res |> List.concat |> List.sort |> List.head\n    | (j, c, a) :: tail ->\n        let l = Array.length a\n        let r = [for i in [0..l] do \n                    yield ( Array.concat[a.[0..i-1]; c; a.[i..l-1]] |> System.String, j, i ) ]\n        composeAux tail (r :: res) \nlet compose lst =\n    let (s, b, c) = composeAux lst [] \n    (System.Int64.Parse s, b, c)\nlet smallest (n: int64) =\n    n.ToString().ToCharArray() |> decompose |> compose","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85471,"user_id":null,"body":"let smallest (n: int64) =\n\n  let rec digits num = seq{\n    yield num % 10L\n    if (num >= 10L) then yield! digits (num \/ 10L)\n  }\n  \n  let number ds =\n    List.foldBack (fun d (num, dec) -> (d * dec + num, dec * 10L)) ds (0L, 1L) \n    |> fun (num, dec) -> num\n  \n  let mutate i j ds =\n    ds\n    |> List.splitAt i \n    |> fun (l1,l2) -> \n      match l2 with\n      | head::tail -> l1@tail |> List.splitAt j |> fun (l3, l4) -> l3 @ (head :: l4)\n      | _ -> l1 @ l2\n\n  let combinations n = List.allPairs [0..n-1] [0..n-1]\n  \n  let ds = digits n |> List.ofSeq |> List.rev\n  \n  combinations (List.length ds) \n  |> List.map(fun (i,j) -> (ds |> mutate i j |> number, i, j))\n  |> List.sort\n  |> List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85472,"user_id":492,"body":"open System\n\nlet decompose(a: array<char>) =\n    let l = Array.length a\n    [for i in [0..l-1] do\n        yield ( i, a.[i..i], Array.concat[a.[0..i-1]; a.[i+1..l-1]] )] |> Seq.toList\nlet rec composeAux lst res =\n    match lst with\n    | [] -> res |> List.concat |> List.sort |> List.head\n    | (j, c, a) :: tail ->\n        let l = Array.length a\n        let r = [for i in [0..l] do \n                    yield ( Array.concat[a.[0..i-1]; c; a.[i..l-1]] |> System.String, j, i ) ]\n        composeAux tail (r :: res) \nlet compose lst =\n    let (s, b, c) = composeAux lst [] \n    (System.Int64.Parse s, b, c)\nlet smallest (n: int64) =\n    n.ToString().ToCharArray() |> decompose |> compose","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85473,"user_id":null,"body":"\/\/ referenced https:\/\/www.codewars.com\/users\/undersky\nlet smallest (n: int64) =\n    let stringd_n = string n\n    let digitIterations = [ 0 .. stringd_n.Length - 1 ]\n\n    let allPossibilites removeIdx digitInsert =\n        digitIterations\n        |> Seq.map (fun insertIdx ->\n            stringd_n\n                .Remove(removeIdx, 1)\n                .Insert(insertIdx, digitInsert)\n            |> int64,\n            removeIdx,\n            insertIdx)\n\n    stringd_n\n    |> Seq.mapi (fun idx chr -> allPossibilites idx (string chr))\n    |> Seq.collect id\n    |> Seq.min\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85474,"user_id":null,"body":"type RankedDigit = { Number: int; Pos: int; Rank: int }\n\nlet smallest (n: int64) =\n\n    let digits =\n        n\n        |> (string\n            >> Seq.map (fun c -> (int c) - (int '0'))\n            >> List.ofSeq)\n\n    let lookupRank n =\n        let lu =\n            digits\n            |> (List.distinct >> List.sort >> List.indexed)\n\n        lu |> (List.find (fun (_, num) -> num = n) >> fst)\n\n    let rankedDigits =\n        List.zip (List.indexed digits) (digits |> List.map (fun n -> lookupRank n))\n        |> List.map (fun ((position, num), rank) ->\n            { Number = num\n              Pos = position\n              Rank = rank }) \/\/ fields aid in referencing\/lookup\n\n    let combineBack dgts =\n        List.fold (fun acc x -> acc + (string x.Number)) \"\" dgts\n        |> int64\n\n    let maxRank = lookupRank (List.max digits)\n    let lastPosition = digits.Length - 1\n\n    rankedDigits\n    |> function\n        | first :: (second :: _) when first.Rank = maxRank && second.Rank = 0 -> \/\/ biggest (begin) to end pos strategy\n            let repositioned =\n                [ yield! rankedDigits.Tail\n                  yield rankedDigits.Head ]\n\n            let leftMostRepositionedItem =\n                repositioned\n                |> (List.rev\n                    >> List.takeWhile (fun x -> x.Number = first.Number)\n                    >> List.last)\n\n            let reduced, takeFromPos, insertToPos =\n                combineBack repositioned,\n                0,\n                if leftMostRepositionedItem = first then\n                    lastPosition\n                else\n                    leftMostRepositionedItem.Pos - 1\n\n            reduced, takeFromPos, insertToPos\n        | first :: (second :: (third :: rest)) when second.Number = 0 && first.Number > third.Number ->\n            let take = first\n\n            let left =\n                third :: rest\n                |> List.takeWhile (fun x -> x.Number < take.Number)\n\n            let right =\n                third :: rest\n                |> List.skipWhile (fun x -> x.Number < take.Number)\n\n            let reduced =\n                combineBack [ yield! left\n                              yield take\n                              yield! right ]\n\n            reduced, 0, right.Head.Pos - 1\n\n        | _ ->\n            let rec findSmallestWithBiggestImpact targetRankLowerBetter preferablyAfterPosition =\n                rankedDigits\n                |> List.tryFind (fun x ->\n                    x.Rank = targetRankLowerBetter\n                    && x.Pos >= preferablyAfterPosition)\n                |> function\n                    | Some rankedNum -> rankedNum\n                    | None ->\n                        match preferablyAfterPosition with\n                        | 1 -> findSmallestWithBiggestImpact (targetRankLowerBetter + 1) lastPosition\n                        | _ -> findSmallestWithBiggestImpact targetRankLowerBetter (preferablyAfterPosition - 1)\n\n            let smallest = findSmallestWithBiggestImpact 0 lastPosition\n\n            let rec getLeftSideTwinsIfAny =\n                function\n                \/\/ if 2 numbers same and side by side, always take left. note: h1 is right bcos rversal\n                | h1 :: (h2 :: rest) when h2.Number = h1.Number -> getLeftSideTwinsIfAny (h2 :: rest)\n                | ls -> ls.Head\n\n            let take =\n                rankedDigits.[.. smallest.Pos]\n                |> (List.rev >> getLeftSideTwinsIfAny)\n\n            let insert =\n                rankedDigits\n                |> List.find (fun x -> x.Number >= take.Number)\n\n            let left, right = rankedDigits |> List.splitAt insert.Pos\n\n            let reducedByShiftingSmallest =\n                [ yield! left\n                  yield take\n                  yield! (right |> List.filter ((<>) take)) ]\n                |> combineBack\n\n            let bcosSideBySideTakeBcomeInsert = take.Pos - insert.Pos = 1\n\n            if bcosSideBySideTakeBcomeInsert then\n                reducedByShiftingSmallest, insert.Pos, take.Pos\n            else\n                reducedByShiftingSmallest, take.Pos, insert.Pos","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85475,"user_id":null,"body":"let smallest (n: int64) =\n    seq {\n        let ns = n |> string\n        for i in 0..ns.Length-1 do\n            let toInsert = ns.[i] |> string\n            let x = ns.Remove(i, 1)\n            let insertAndParse idx = x.Insert(idx, toInsert) |> int64\n            for insIdx in 0..x.Length do\n                yield insertAndParse insIdx, i, insIdx\n    } |> Seq.sortBy (fun (x, _, _) -> x) |> Seq.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85476,"user_id":null,"body":"let smallest (n: int64) =\n    let numb = n.ToString()\n    let swap (str: string) (ind: int) (newind: int) =\n      let charind = str.[ind].ToString()\n      let newstr = str.Substring(0, ind) + str.Substring(ind + 1)\n      newstr.Substring(0, newind) + charind + newstr.Substring(newind)\n      \n    let getPerm (str: string) (ind: int) =\n      [0..(str.Length - 1)] |> List.map (fun x -> ((swap str ind x) |> int64, ind, x))\n    \n    [0..(numb.Length - 1)] |> List.collect (getPerm numb) |> \n    List.sortBy (fun (a,b,c) -> a, b, c) |> List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57591ef494aba64d14000526":[{"id":85477,"user_id":null,"body":"type JohnOrAnn = | John | Ann\n\nlet generateKatasPerDayFor who =\n    let johns = System.Collections.Generic.Dictionary<int,int>()\n    johns.Add (0, 0)\n    let anns = System.Collections.Generic.Dictionary<int,int>()\n    anns.Add (0, 1)\n    let fill numberOfDays =\n        if johns.Count < numberOfDays then\n            for i in [ Seq.max johns.Keys + 1 .. numberOfDays - 1 ] do\n                johns.Add(i, i - anns.[johns.[i - 1]])\n                anns.Add(i, i - johns.[anns.[i - 1]])\n    fun numberOfDays ->\n        fill numberOfDays\n        let katas = match who with | John -> johns | Ann -> anns\n        [ 0 .. numberOfDays - 1 ]\n        |> Seq.map (fun i -> katas.[i])\n\nlet john n = generateKatasPerDayFor John n |> Seq.toList\n\nlet ann n = generateKatasPerDayFor Ann n |> Seq.toList\n\nlet sumJohn n  = john(n) |> Seq.sum\n\nlet sumAnn n = ann(n) |> Seq.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85478,"user_id":492,"body":"let johnAnn n =\n    let rec loop(i: int, jlist: int list, alist: int list) =\n        if (i >= n) then\n            [alist; jlist]\n        else\n            let a1 = alist.[jlist.[i - 1]]\n            let jlist1 = jlist @ [i - a1]\n            let j1 = jlist1.[alist.[i - 1]]\n            loop(i + 1, jlist1, alist @ [i - j1])\n    loop(1, [0], [1])\n\nlet john(n) = (johnAnn n).[1]\nlet ann(n) = (johnAnn n).[0]\n\nlet sumJohn(n) = john n |> List.sum\nlet sumAnn(n) = ann n |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85479,"user_id":null,"body":"let johnAndAnn n =\n    let john = Array.create n 0\n    let ann = Array.create n 1\n    for i in 1 .. (n-1) do\n        john.[i] <- i-ann.[john.[i-1]]\n        ann.[i] <- i-john.[ann.[i-1]]\n    john,ann\n\nlet john n = johnAndAnn n |> fst |> Array.toList\nlet ann n =  johnAndAnn n |> snd |> Array.toList\nlet sumJohn n = john n |> List.fold (+) 0\nlet sumAnn n = ann n |> List.fold (+) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85480,"user_id":null,"body":"let rec f = \n    let memo = new System.Collections.Generic.Dictionary<_,_>()\n    fun n -> \n        if n=0 then 1 else\n            match memo.TryGetValue(n) with\n            | true, v -> v\n            | false, _ ->\n                let v = n - m(f(n-1))\n                memo.Add(n, v)\n                v\nand m = \n    let memo = new System.Collections.Generic.Dictionary<_,_>()\n    fun n ->\n        if n=0 then 0 else\n            match memo.TryGetValue(n) with\n            | true, v -> v\n            | false, _ ->\n                let v = n - f(m(n-1))\n                memo.Add(n, v)\n                v\n            \nlet john(n) = [0..n-1] |> List.map m\nlet ann(n) = [0..n-1] |> List.map f\n\nlet sumJohn(n) = john(n) |> Seq.sum\nlet sumAnn(n) = ann(n) |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85481,"user_id":null,"body":"open System.Collections.Generic\n\nlet memoize f =    \n    let cache = new Dictionary<_, _>()\n    (fun x ->\n        let succ, v = cache.TryGetValue(x)\n        if succ then v else \n          let v = f(x) \n          cache.Add(x, v)\n          v)\n\nlet rec a = memoize (function\n    | 0 -> 1\n    | n -> n - j (a (n-1)))\nand j = memoize(function\n    | 0 -> 0\n    | n -> n - a (j (n-1)))\n\nlet ann n = List.init n (fun day -> a day)\nlet john n = List.init n (fun day -> j day)\nlet sumAnn n = ann n |> List.sum\nlet sumJohn n = john n |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85482,"user_id":53,"body":"\nlet walk(n) = \n  let mutable xs = [| for i in 1 .. n -> 0 |]\n  let mutable ys = [| for i in 1 .. n -> 0 |]\n  ys.[0] <- 1\n  let mutable i = 1\n  while i < n do\n    let x1 = xs.[i - 1]\n    let x2 = ys.[x1]\n    xs.[i] <- i - x2\n    let y1 = ys.[i - 1]\n    let y2 = xs.[y1]\n    ys.[i] <- i - y2\n    i <- i + 1\n  [|ys; xs|]\n\nlet john(n) =\n  walk(n).[1] |> Array.toList\n  \nlet ann(n) = \n  walk(n).[0] |> Array.toList\n  \nlet sumJohn(n) =\n  john(n) |> List.sum\n  \nlet sumAnn(n) =\n  ann(n) |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85483,"user_id":null,"body":"let john (n: int) =\n    let johnArr = Array.zeroCreate n\n    let annArr = Array.zeroCreate n\n    let rec getNextDay (johnArr: int array) (annArr: int array) (ind: int) =\n        if (ind = n) then\n            johnArr\n        else if (ind = 0) then\n            johnArr.[ind] <- 0\n            annArr.[ind] <- 1\n            (getNextDay johnArr annArr (ind + 1))\n        else\n            let annTInd = annArr.[ind - 1]\n            annArr.[ind] <- ind - johnArr.[annTInd]\n            let johnTInd = johnArr.[ind - 1]\n            johnArr.[ind] <- ind - annArr.[johnTInd]\n            (getNextDay johnArr annArr (ind + 1))\n    (getNextDay johnArr annArr 0) |> List.ofArray\n \nlet ann (n: int) =\n     let johnArr = Array.zeroCreate n\n     let annArr = Array.zeroCreate n\n     let rec getNextDay (johnArr: int array) (annArr: int array) (ind: int) =\n         if (ind = n) then\n             annArr\n         else if (ind = 0) then\n             johnArr.[ind] <- 0\n             annArr.[ind] <- 1\n             (getNextDay johnArr annArr (ind + 1))\n         else\n             let annTInd = annArr.[ind - 1]\n             annArr.[ind] <- ind - johnArr.[annTInd]\n             let johnTInd = johnArr.[ind - 1]\n             johnArr.[ind] <- ind - annArr.[johnTInd]\n             (getNextDay johnArr annArr (ind + 1))\n     (getNextDay johnArr annArr 0) |> List.ofArray\n\nlet sumJohn = (john >> List.sum)\nlet sumAnn = (ann >> List.sum)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85484,"user_id":null,"body":"\nlet rec loop (n:int) (john_acc: List<int>) (ann_acc: List<int>) =\n  match john_acc.Length with\n  | l when l = n -> \n    (john_acc, ann_acc) \n  | l -> \n    let john_acc_new = john_acc @ [(l - ann_acc.[john_acc.[l-1]])]\n    let ann_acc_new = ann_acc @ [l - john_acc_new.[ann_acc.[l-1]]]\n    loop n john_acc_new ann_acc_new\n\nlet john(n) : List<int> = \/\/ your code\n  let john_acc, ann_acc = loop n [0] [1]\n  john_acc\n\n\nlet ann(n) = \/\/ your code\n  let (john_acc, ann_acc) = loop n [0] [1]\n  ann_acc\n\n\n\nlet sumJohn(n) =\n  List.sum (john n)\n  \nlet sumAnn(n) =\n  List.sum (ann n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85485,"user_id":null,"body":"type KataDays = {\n    AnnKatas: int\n    JohnKatas: int\n    }\n\nlet katas =\n    let mutable knownKatas = [{AnnKatas = 1; JohnKatas = 0;}; {AnnKatas = 1; JohnKatas = 0;}] \/\/  Initialize with the know seed state\n    (fun n ->\n        if List.length knownKatas > n then\n            List.item n knownKatas\n        else\n            for x = (List.length knownKatas) to n do\n                let t = List.item (x - 1) knownKatas\n                knownKatas <- List.append knownKatas [{\n                    AnnKatas = x - (List.item (t.AnnKatas) knownKatas).JohnKatas;\n                    JohnKatas = x - (List.item (t.JohnKatas) knownKatas).AnnKatas;\n                    }]\n            List.item n knownKatas)\n\nlet john (n: int): int list =\n    [0..(n - 1)]\n    |> List.map (fun x -> (katas x).JohnKatas)\n\nlet ann (n: int): int list =\n    [0..(n - 1)]\n    |> List.map (fun x -> (katas x).AnnKatas)\n\nlet sumJohn (n: int): int =\n    n\n    |> john\n    |> List.sum\n\nlet sumAnn (n: int): int =\n    n\n    |> ann\n    |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85486,"user_id":null,"body":"#nowarn \"40\"\n\nlet memoize f =\n    let cache = System.Collections.Generic.Dictionary<_,_>()\n    fun x ->\n        match cache.TryGetValue(x) with\n        | true, y -> y\n        | _ ->\n            let y = f x\n            cache.[x] <- y\n            y\n\nlet rec njohn = \n  memoize <|\n  function\n  | 0 -> 0\n  | n -> n - (n - 1 |> njohn |> nann)\nand nann =\n  memoize <|\n  function\n  | 0 -> 1\n  | n -> n - (n - 1 |> nann |> njohn)\n  \nlet rec john n = Seq.init n id |> Seq.map njohn |> Seq.toList\nlet rec ann n = Seq.init n id |> Seq.map nann |> Seq.toList\n\nlet sumJohn = john >> Seq.sum\nlet sumAnn = ann >> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"576b93db1129fcf2200001e6":[{"id":85487,"user_id":null,"body":"let sum_array optionList =\n  match optionList with\n  | None | Some [] | Some [_] -> 0\n  | Some x -> (List.sum x) - (List.max x) - (List.min x)\n  ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85488,"user_id":null,"body":"let sum_array array = \n    match array with\n    | None\n    | Some [] -> 0\n    | Some [x] -> 0 \n    | Some values -> (List.sum values) - (List.max values) - (List.min values)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85489,"user_id":null,"body":"let sum_array list = \n    match list with \n    | Some l when List.length l > 1 -> \n        l \n        |> List.sort \n        |> fun (arr) -> arr.[1..arr.Length - 2] \n        |> List.sum\n    | _ -> 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85490,"user_id":null,"body":"let sum_array = function None | Some [] | Some [_] -> 0 | Some list -> List.sum list - List.max list - List.min list","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85491,"user_id":null,"body":"let sum_array list =\n    match list with\n    | Some [ _ ] | Some [] | None -> 0\n    | Some list -> List.sum list - (List.min list) - (List.max list)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85492,"user_id":null,"body":"let sum_array = function\n    | Some (lst : int list) ->\n        if lst.Length > 1\n            then List.sum lst - List.min lst - List.max lst\n            else 0\n    | None -> 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85493,"user_id":null,"body":"let sum_array (array : int list option ) =\n    match array with\n    |Some x -> if x.Length <=1 || x.IsEmpty then 0 else ((List.sum x )-(List.max x))-List.min x\n    |None -> 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85494,"user_id":1669,"body":"let sum_array array = \n  match array with\n  | None -> 0\n  | Some [] -> 0\n  | Some [x] -> 0\n  | Some [x;y] -> 0\n  | Some x -> ((List.sum x) - (List.min x) - (List.max x))\n  ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85495,"user_id":null,"body":"let sum_array  = function\n| None     -> 0\n| Some []  -> 0\n| Some [x] -> 0\n| Some a   -> List.sum a - List.max a - List.min a","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85496,"user_id":null,"body":"let sum_array = function\n| None\n| Some ([] | [_] | [_; _]) -> 0\n| Some (x :: xs) ->\n    xs\n    |> List.fold (fun (min', max', sum) x -> (min min' x, max max' x, sum + x)) (x, x, x)\n    |> (fun (min', max', sum) -> sum - min' - max')\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5772382d509c65de7e000982":[{"id":85497,"user_id":null,"body":"let u =\n    [| 1; 1 |]\n    |> Seq.unfold (fun state ->\n        let n = state.Length\n        let x = state.[n - state.[n - 1]] + state.[n - state.[n - 2]]\n        Some(x, Array.append state [| x |]))\n    |> Seq.append [| 1; 1 |]\n    |> Seq.cache\n\nlet lengthSupUK n k =\n    Seq.take n u\n    |> Seq.filter (fun x -> x >= k)\n    |> Seq.length\n\nlet comp n =\n    Seq.take n u\n    |> Seq.pairwise\n    |> Seq.filter (fun (x, y) -> y < x)\n    |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85498,"user_id":null,"body":"let MakeU n =\n    let u = Array.create n 1\n    for i=2 to n-1 do u.[i] <- u.[i - u.[i-1]] + u.[i - u.[i-2]]\n    u\n        \nlet lengthSupUK n k = MakeU n |> Array.sumBy (fun elem -> if elem >= k then 1 else 0)\n\nlet comp n = fst (MakeU n |> Array.fold (fun (acc,prev) elem -> if elem < prev then (acc+1,elem) else (acc,elem)) (0,0) )\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85499,"user_id":null,"body":"let cache =\n    System.Collections.Generic.Dictionary<int, int>([ (1, 1); (2, 1) ] |> dict)\n\nlet u n =\n    Seq.initInfinite (fun i ->\n        let i = i + 1\n\n        if (not (cache.ContainsKey(i))) then\n            let v =\n                cache.[i - (cache.[i - 1])]\n                + cache.[i - (cache.[i - 2])]\n\n            cache.Add(i, v)\n\n        cache.[i])\n    |> Seq.take n\n\nlet lengthSupUK n k =\n    printfn \"%d\" n\n    u n\n    |> Seq.countBy (fun i -> i >= k)\n    |> Seq.tryFind (fst)\n    |> Option.defaultValue (true,0)\n    |> snd\n\nlet comp n = \n    printfn \"%d\" n\n    u n\n    |> Seq.pairwise\n    |> Seq.countBy (fun (i,j) -> j<i)\n    |> Seq.tryFind (fst)\n    |> Option.defaultValue (true,0)\n    |> snd\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85500,"user_id":null,"body":"let us = new System.Collections.Generic.Dictionary<int, int>()\nus.Add(1,1)\nus.Add(2,1)\n\nlet xs n = seq {\n    yield 1;\n    yield 1;\n    for i in 3..n do\n        let x1 = us.[i-1]\n        let x2 = us.[i-2]\n        let y = us.[i-x1] + us.[i-x2]\n        us.[i] <-  y\n        yield y\n}\n\nlet lengthSupUK n k = \n    xs n |> Seq.filter (fun x -> x >= k)\n         |> Seq.length\n\nlet comp n =\n    xs n |> Seq.fold (fun (s, prev) x -> if x < prev then (s+1, x) else (s, x)) (0, 0)\n         |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85501,"user_id":53,"body":"open System\nopen System.Collections.Generic\nopen System.Linq\n\nlet sequence n =\n  let mutable hs = Array.create (n + 1) 0\n  hs.[1] <- 1\n  hs.[2] <- 1\n  for i in 3 .. n do\n    hs.[i] <- hs.[i - hs.[i - 1]] + hs.[i - hs.[i - 2]]\n  hs\n\nlet lengthSupUK n k =\n  let mutable m = 0\n  let hs = sequence(n)\n  for i in 0 .. n do\n    if hs.[i] >= k then\n      m <- m + 1\n  m\n  \nlet comp n =\n  let mutable m = 0\n  let hs = sequence(n)\n  for i in 1 .. n do\n    if hs.[i] < hs.[i - 1] then\n      m <- m + 1\n  m","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85502,"user_id":null,"body":"let generateSeq (num: int) =\n  let rec seqGenerator (numArr: int array) =\n    let arrLength = (Array.length numArr)\n    if (arrLength >= num) then\n      numArr\n    else\n      let first = numArr.[arrLength - 1]\n      let second = numArr.[arrLength - 2]\n      let newElement = numArr.[arrLength - first] + numArr.[arrLength - second]\n      let newArr = (Array.concat [|numArr; [|newElement|]|])\n      (seqGenerator newArr)\n  (seqGenerator [|1; 1|])\n\nlet lengthSupUK n k =\n  let arr = n |> generateSeq\n  {0..(n - 1)} |> Seq.filter (fun i -> arr.[i] >= k) |> Seq.length\n  \nlet comp n =\n  let arr = n |> generateSeq\n  {1..(n - 1)} |> Seq.filter (fun i -> arr.[i] < arr.[i - 1]) |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85503,"user_id":null,"body":"let mutable memo = Array.zeroCreate 100000\n\nlet rec u n =\n  if memo.[n] = 0 then \n    let temp =\n      match n with\n        | 0 -> 1\n        | 1 -> 1\n        | _ -> u(n - u(n-1)) + u(n - u(n-2))\n    memo.[n] <- temp\n    temp\n  else memo.[n]\n\nlet lengthSupUK n k =\n  ([0..(n-1)]\n  |> List.map (fun x -> u(x))\n  |> List.filter (fun x -> x >= k)\n  ).Length\n  \nlet comp n =\n  printfn \"%i\" n\n  let mutable i = 0\n  for x in [0..(n-2)] do\n    if u(x+1) < u(x) then i <- i + 1\n  i","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85504,"user_id":null,"body":"let useq n = \n  let rec loop index memo =\n    if index >= n then memo\n    else if index < 2 then loop (index + 1) (Array.append memo [| 1 |])\n    else loop (index + 1) (Array.append memo [| memo.[index - memo.[index - 2]] + memo.[index - memo.[index - 1]] |])\n    \n  loop 0 Array.empty\n\nlet lengthSupUK n k =\n  useq n\n  |> Seq.filter (fun x -> x >= k)\n  |> Seq.length\n  \nlet comp n =\n  useq n\n  |> Seq.fold (fun (x, count) y -> (y, if y < x then count + 1 else count)) (1, 0)\n  |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85505,"user_id":1201,"body":"let rec prependValues (values:int list, k) =\n  match k with\n  | 0 -> values\n  | _ ->\n    let n = values.Length\n    match n with\n    | 0 -> prependValues ([1], (k - 1))\n    | 1 -> prependValues ([1; 1], (k - 1))\n    | _ -> prependValues ((values.[values.[0] - 1] + values.[values.[1] - 1] :: values), (k - 1))\n\nlet lengthSupUK n k =\n  (prependValues ([], n))\n  |> Seq.filter (fun i -> i >= k)\n  |> Seq.length\n\nlet comp n =\n  (prependValues ([], n))\n  |> Seq.pairwise\n  |> Seq.filter (fun elem -> snd elem > fst elem)\n  |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85506,"user_id":1201,"body":"let rec prependValues (values:int list, k) =\n  match k with\n  | 0 -> values\n  | _ ->\n    let n = values.Length\n    match n with\n    | 0 -> prependValues ([1], (k - 1))\n    | 1 -> prependValues ([1; 1], (k - 1))\n    | _ -> prependValues ((values.[values.[0] - 1] + values.[values.[1] - 1] :: values), (k - 1))\n\nlet theFunction n =\n  (prependValues ([], n))\n  |> List.head\n\nlet lengthSupUK n k =\n  (prependValues ([], n))\n  |> Seq.filter (fun i -> i >= k)\n  |> Seq.length\n\nlet comp n =\n  (prependValues ([], n))\n  |> Seq.pairwise\n  |> Seq.filter (fun elem -> snd elem > fst elem)\n  |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5779b0f0ec883247b2000117":[{"id":85507,"user_id":null,"body":"type peano = Zero | Succ of peano\n\nlet rec cmp x y =\n    match y with\n    | Zero ->\n        match x with\n        | Zero -> 0\n        | Succ _ -> 1\n    | Succ y' ->\n        match x with\n        | Zero -> -1\n        | Succ x' -> cmp x' y'\n\nlet rec add x y =\n    match y with\n    | Zero -> x\n    | Succ y' -> add (Succ x) y'\n\nlet rec sub x y =\n    match y with\n    | Zero -> x\n    | Succ y' ->\n        match x with\n        | Zero -> failwith \"negative number\"\n        | Succ x' -> sub x' y'\n\nlet rec mul x y =\n    match y with\n    | Zero -> Zero\n    | Succ y' ->\n        match x with\n        | Zero -> Zero\n        | Succ x' ->\n            let z = mul x' y'\n            add (add (Succ z) x') y'\n\nlet div x y =\n    let rec loop quot rem div =\n        match div with\n        | Zero -> loop (Succ quot) rem y\n        | Succ div' ->\n            match rem with\n            | Zero -> quot\n            | Succ rem' -> loop quot rem' div'\n\n    match y with\n    | Zero -> failwith \"divide by 0\"\n    | Succ _ -> loop Zero x y\n\nlet rec even x =\n    match x with\n    | Zero -> true\n    | Succ x' -> odd x'\nand odd x =\n    match x with\n    | Zero -> false\n    | Succ x' -> even x'","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85508,"user_id":null,"body":"type peano = Zero | Succ of peano\n\nlet getvalue t = \n    let rec loop v = function\n        | Succ(x) -> loop (v+1) x\n        | Zero -> v\n    loop 0 t\n\nlet getpeano v =\n    let rec loop t = function\n        | 0 -> t\n        | x -> loop (Succ t) (x-1)\n    loop Zero v\n\/\/ Comapre\nlet rec cmp (x: peano) (y: peano): int =\n    let X = getvalue x\n    let Y = getvalue y\n    if X > Y then 1 elif X < Y then -1 else 0\n\n\/\/ Addition\nlet rec add (x: peano) (y: peano): peano =\n    getvalue x + getvalue y\n    |> getpeano\n\n\/\/ Subtraction\nlet rec sub (x: peano) (y: peano): peano =\n    let result = getvalue x - getvalue y\n    if result < 0 then failwith \"negative number\" else getpeano result\n\n\/\/ Multiplication\nlet rec mul (x: peano) (y: peano): peano =\n    getvalue x * getvalue y\n    |> getpeano\n\n\/\/ Integer division\nlet rec div (x: peano) (y: peano): peano =\n    let Y = getvalue y\n    if Y = 0 then failwith \"divide by 0\"\n    else getvalue x \/ Y |> getpeano\n\n\/\/ Even\nlet rec even (x: peano): bool =\n    (getvalue x) % 2 = 0\n\n\/\/ Odd\nlet rec odd (x: peano): bool =\n    (getvalue x) % 2 = 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85509,"user_id":null,"body":"type peano = Zero | Succ of peano\n\nlet rec cmp p1 p2 =\n  match (p1, p2) with\n  | (Zero, Zero) -> 0\n  | (Zero, Succ p) -> -1\n  | (Succ p, Zero) -> 1\n  | (Succ pp1, Succ pp2) -> cmp pp1 pp2\n  \nlet rec add p1 p2 =\n  match (p1, p2) with\n  | (Zero, _) -> p2\n  | (Succ p, _) -> add p (Succ p2)\n  \nlet rec sub p1 p2 =\n  match (p1, p2) with\n  | (_, Zero) -> p1\n  | (Zero, _) -> failwith \"negative number\"\n  | (Succ pp1, Succ pp2) -> sub pp1 pp2\n  \nlet rec mul p1 p2 =\n  match (p1, p2) with\n  | (_, Zero) -> Zero\n  | (Zero, _) -> Zero\n  | (Succ Zero, _) -> p2\n  | (Succ p, _) -> add p2 (mul p p2)\n  \nlet rec div p1 p2 =\n  match (p1, p2) with\n  | (_, Zero) -> failwith \"divide by 0\"\n  | (_, _) when cmp p1 p2 = -1 -> Zero\n  | (_, _) when cmp p1 p2 = 0 -> Succ Zero\n  | (_, _) -> add (Succ Zero) (div (sub p1 p2) p2)\n  \nlet rec even p =\n  let two = Succ (Succ Zero) in\n  let divisionByTwo = div p two in\n  let multiplyByTwo = mul divisionByTwo two in\n  let rest = sub p multiplyByTwo in rest = Zero\n  \nlet odd p = not (even p)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85510,"user_id":null,"body":"type peano = Zero | Succ of peano\n\nlet rec cmp (x: peano) (y: peano): int =\n    match x, y with\n    | Zero, Zero -> 0\n    | Zero, Succ _ -> -1\n    | Succ _, Zero -> 1\n    | Succ a, Succ b -> cmp a b\n\nlet rec add (x: peano) (y: peano): peano =\n    match x, y with\n    | Zero, y -> y\n    | Succ a, y -> add a (Succ y)\n\nlet rec sub (x: peano) (y: peano): peano =\n    match x, y with\n    | n, Zero -> n\n    | Zero, Succ b -> failwith \"negative number\"\n    | Succ a, Succ b -> sub a b\n\nlet rec mul (x: peano) (y: peano): peano =\n    match x, y with\n    | Zero, _ | _, Zero -> Zero\n    | x, Succ b -> add x (mul x b)\n\nlet rec div (x: peano) (y: peano): peano =\n    match x, y with\n    | _, Zero -> failwith \"divide by 0\"\n    | Zero, _ -> Zero\n    | x, y when cmp x y = -1 -> Zero\n    | x, y -> Succ (div (sub x y) y)\n    \nlet rec even (x: peano): bool =\n    match x with\n    | Zero -> true\n    | Succ Zero -> false\n    | Succ (Succ x) -> even x\n    \nlet rec odd (x: peano): bool = not (even x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85511,"user_id":null,"body":"type peano = Zero | Succ of peano\n\n\/\/ Compare\nlet rec cmp (x: peano) (y: peano): int =\n    match x, y with\n    | Succ x, Succ y -> cmp x y\n    | Zero, Zero -> 0\n    | Zero, _ -> -1\n    | _, Zero -> 1\n\n\/\/ Addition\nlet rec add (x: peano) (y: peano): peano =\n    match x, y with\n    | Zero, _ -> y\n    | _, Zero -> x\n    | Succ x, y -> Succ (add x y)\n\n\/\/ Subtraction\nlet rec sub (x: peano) (y: peano): peano =\n    match x, y with\n    | _, Zero -> x\n    | Zero, _ -> failwith \"negative number\"\n    | Succ x, Succ y -> sub x y\n\n\/\/ Multiplication\nlet rec mul (x: peano) (y: peano): peano =\n    match x, y with\n    | _, Zero -> Zero\n    | x, Succ z -> add x (mul x z)\n\n\/\/ Integer division\nlet rec div (x: peano) (y: peano): peano =\n    match x, y with \n    | _, Zero -> failwith \"divide by 0\"\n    | Zero, _ -> Zero\n    | _, Succ Zero -> x\n    | x, y ->\n      match cmp x y with\n        | -1 -> Zero\n        | 0 -> Succ Zero\n        | 1 -> div (sub x y) y |> add (Succ Zero) \n    \n\/\/ Even\nlet rec even (x: peano): bool =\n    match x with\n    | Zero -> true\n    | Succ Zero -> false\n    | _ -> sub x (Succ (Succ Zero)) |> even\n    \n\/\/ Odd\nlet rec odd (x: peano): bool =\n    even x |> not","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85512,"user_id":null,"body":"type peano =\n    | Zero\n    | Succ of peano\n\n\/\/ Comapre\nlet rec cmp (x: peano) (y: peano) : int =\n    match (x, y) with\n    | Zero, Zero -> 0\n    | Succ _, Zero -> 1\n    | Zero, Succ _ -> -1\n    | Succ sx, Succ sy -> cmp sx sy\n\n\/\/ Addition\nlet rec add (x: peano) (y: peano) : peano =\n    match (x, y) with\n    | Zero, Zero -> Zero\n    | Succ _, Zero -> x\n    | Zero, Succ _ -> y\n    | Succ sx, Succ sy -> add sx (Succ y)\n\n\/\/ Subtraction\nlet rec sub (x: peano) (y: peano) : peano =\n    match (x, y) with\n    | Zero, Zero -> Zero\n    | Succ _, Zero -> x\n    | Zero, Succ _ -> failwith \"negative number\"\n    | Succ sx, Succ sy -> sub sx sy\n\n\/\/ Multiplication\nlet rec mul (x: peano) (y: peano) : peano =\n    match (x, y) with\n    | Zero, _ -> Zero\n    | _, Zero -> Zero\n    | _, Succ sy -> add x (mul x sy)\n\n\/\/ Integer division\nlet rec div (x: peano) (y: peano) : peano =\n    match (cmp x y) with\n    | -1 -> Zero\n    | 0 ->\n        match (x, y) with\n        | Zero, Zero -> failwith \"divide by 0\"\n        | _ -> Succ Zero\n    | _ -> Succ(div (sub x y) y)\n\n\/\/ Even\nlet rec even =\n    function\n    | Zero -> true\n    | Succ sx -> not (even sx)\n\n\/\/ Odd\nlet rec odd =\n    function\n    | Zero -> false\n    | Succ sx -> not (odd sx)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85513,"user_id":252,"body":"type peano = Zero | Succ of peano\n\nlet rec cmp x y =\n    match x, y with\n    | Zero, Zero -> 0\n    | Succ _, Zero -> 1\n    | Zero, Succ _ -> -1\n    | Succ a, Succ b -> cmp a b\n\nlet rec add x y =\n    match x, y with\n    | Zero, Zero -> Zero\n    | a, Zero -> a\n    | Zero, b -> b\n    | Succ a, b -> add a (Succ b)\n\nlet rec sub x y =\n    match x, y with\n    | Zero, Zero -> Zero\n    | a, Zero -> a\n    | Zero, b -> failwith \"negative number\"\n    | Succ a, Succ b -> sub a b\n\nlet rec mul x y =\n    match x, y with\n    | Zero, _ -> Zero\n    | _, Zero -> Zero\n    | a, Succ Zero -> a\n    | a, Succ b -> add a (mul a b)\n\nlet rec div x y =\n    match x, y with\n    | _, Zero -> failwith \"divide by 0\"\n    | Zero, _ -> Zero\n    | a, Succ Zero -> a\n    | a, b when cmp a b = -1 -> Zero\n    | a, b when cmp a b = 0 -> Succ Zero\n    | a, b -> add (Succ Zero) (div (sub a b) b)\n\nlet rec even x =\n    match x with\n    | Zero -> true\n    | Succ Zero -> false\n    | a -> even (sub a (Succ (Succ Zero)))\n    \nlet rec odd = even >> not","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85514,"user_id":null,"body":"type peano = Zero | Succ of peano\n\n\/\/ Comapre\nlet rec cmp (x: peano) (y: peano): int =\n    match (x, y) with\n    | Zero,   Zero   -> 0\n    | Succ _, Zero   -> 1\n    | Zero,   Succ _ -> -1\n    | Succ x, Succ y -> cmp x y\n\n\/\/ Addition\nlet rec add (x: peano) (y: peano): peano =\n    match (x, y) with\n    | x, Zero   -> x\n    | x, Succ y -> Succ (add x y)\n\n\/\/ Subtraction\nlet rec sub (x: peano) (y: peano): peano =\n    match (x, y) with\n    | x, Zero            -> x\n    | (Succ x), (Succ y) -> sub x y\n\n\/\/ Multiplication\nlet rec mul (x: peano) (y: peano): peano =\n    match (x, y) with\n    | x, Zero   -> Zero\n    | x, Succ y -> add x (mul x y)\n\n\/\/ Integer division\nlet rec div (x: peano) (y: peano): peano =\n    match cmp x y with\n    | -1 -> Zero\n    | _  -> Succ (div (sub x y) y)\n    \n\/\/ Even\nlet rec even (x: peano): bool =\n    match x with\n    | Zero          -> true\n    | Succ Zero     -> false\n    | Succ (Succ x) -> even x\n    \n\/\/ Odd\nlet odd (x: peano): bool = not (even x)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85515,"user_id":null,"body":"type peano = Zero | Succ of peano\n\n\/\/ Comapre\nlet rec cmp (x: peano) (y: peano): int =\n    if x < y then -1\n    elif x > y then 1\n    else 0\n\n\/\/ Addition\nlet rec add (x: peano) (y: peano): peano =\n    match x, y with\n    | Zero, y -> y\n    | Succ x, y -> add x (Succ y)\n\n\/\/ Subtraction\nlet rec sub (x: peano) (y: peano): peano =\n    match x, y with\n    | x, Zero -> x\n    | Succ x, Succ y -> sub x y\n    \n\/\/ Multiplication\nlet rec mul (x: peano) (y: peano): peano =\n    match x, y with\n    | x, Zero -> Zero\n    | x, Succ y -> add x (mul x y)\n\n\/\/ Integer division\nlet rec div (x: peano) (y: peano): peano =\n    if not(y = Zero) then\n      let rec count (x: peano) num =\n        match x with\n        | Zero -> num\n        | x -> \n          match y > x with\n          | true -> num\n          | false ->\n            count (sub x y) (Succ num)\n      count x Zero\n    else\n      failwithf \"Don't divide by 0\"\n    \n\/\/ Even\nlet rec even (x: peano): bool =\n    match x with\n    | Succ Zero -> false\n    | Succ y -> (even (sub x (Succ(Succ Zero))))\n    | Zero -> true\n    \n\/\/ Odd\nlet rec odd (x: peano): bool =\n    match x with\n    | Succ Zero -> true\n    | Succ y -> (odd (sub x (Succ(Succ Zero))))\n    | Zero -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85516,"user_id":null,"body":"type peano = Zero | Succ of peano\n\n\/\/ Comapre\nlet rec cmp (x: peano) (y: peano): int =\n    match x, y with\n    | Zero, Zero -> 0\n    | Zero, _ -> -1\n    | _, Zero -> 1\n    | Succ x', Succ y' -> cmp x' y'\n\n\/\/ Addition\nlet rec add (x: peano) (y: peano): peano =\n    match x with\n    | Zero -> y\n    | Succ x' -> add x' (Succ y)\n\n\/\/ Subtraction\nlet rec sub (x: peano) (y: peano): peano =\n    match x, y with\n    | Succ x', Succ y' -> sub x' y'\n    | x, Zero -> x\n    | _ -> failwith \"negative number\"\n\n\/\/ Multiplication\nlet rec mul (x: peano) (y: peano): peano =\n  let rec loop acc = function\n    | Zero -> acc\n    | Succ n' -> loop (add acc y) n'\n  loop Zero x\n\n\/\/ Integer division\nlet rec div (x: peano) (y: peano): peano =\n  if y = Zero then failwith \"divide by 0\"\n  let rec loop counter n =\n    match cmp n y with\n    | 1 -> loop (Succ counter) (sub n y)\n    | 0 -> Succ counter\n    | _ -> counter \n  loop Zero x\n    \n\/\/ Even\nlet rec even (x: peano): bool =\n  let rec loop isEven = function\n    | Zero -> isEven\n    | Succ n -> loop (not isEven) n\n  loop true x\n    \n\/\/ Odd\nlet rec odd = even >> not","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57814d79a56c88e3e0000786":[{"id":85517,"user_id":null,"body":"let rec encode acc1 acc2 = function\n    | [] -> List.append (List.rev acc2) (List.rev acc1)\n    | x::[] -> encode (x::acc1) acc2 []\n    | x1::x2::xs -> encode (x1::acc1) (x2::acc2) xs\nlet rec decode acc = function\n    | ([], []) -> List.rev acc\n    | (xs, []) -> decode (List.append xs acc) ([], [])\n    | ([], ys) -> decode (List.append ys acc) ([], [])\n    | (x::xs, y::ys) -> decode (y :: x :: acc) (xs, ys)\nlet encrypt_code1 (str:string) = \n    encode [] [] [for c in str -> c] |> List.toArray |> System.String\nlet rec encrypt_code (str:string) = function\n    | n when n <= 0 -> str\n    | n -> encrypt_code (encrypt_code1 str) (n - 1)\nlet decrypt_code1 (str : string) =\n    let nhalf = str.Length \/ 2 - 1\n    let xs = [for c in str.[nhalf+1..] -> c]\n    let ys = [for c in str.[..nhalf] -> c]\n    decode [] (xs, ys) |> List.toArray |> System.String\nlet rec decrypt_code (str:string) = function\n    | n when n <= 0 -> str\n    | n -> decrypt_code (decrypt_code1 str) (n - 1)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85518,"user_id":null,"body":"let reorder indexProcessor =\n    Seq.toArray\n    >> Array.Parallel.mapi (fun i e -> (indexProcessor i, e))\n    >> Array.sortBy fst\n    >> Array.Parallel.map snd\n    >> System.String\n\nlet (|Positive|_|) i = if 0 < i then Some i else None\n\nlet crypt indexProcessor str n =\n    let length = String.length str\n    match (n, length) with\n    | (Positive n, Positive l) -> str |> reorder (indexProcessor n l)\n    | _ -> str\n\nlet forwardsOneStep length index = (index + length * ((index + 1) % 2)) \/ 2\n\nlet backwardsOneStep length index = (index * 2 + 1) % (length + (length + 1) % 2)\n\nlet rec repeat n func =\n    match n with\n    | 1 -> func\n    | _ -> func >> repeat (n - 1) func\n\nlet forwards n l = repeat n <| forwardsOneStep l\n\nlet backwards n l = repeat n <| backwardsOneStep l\n\nlet encrypt_code = crypt forwards\n\nlet decrypt_code = crypt backwards\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85519,"user_id":null,"body":"let rec encrypt_code (str:string) (n:int) = \n    match n with\n    | n when n <= 0 -> str\n    | _ ->\n        [0..String.length str - 1]\n        |> Seq.sortBy (fun x -> pown -1 (x%2), x)\n        |> Seq.map (fun i -> str.[i])\n        |> System.String.Concat\n        |> (fun news -> encrypt_code news (n-1))\n\nlet rec merge xs ys =\n    match (xs, ys) with\n    | [],l | l, [] -> l\n    | x::xs, y::ys -> x::y::(merge xs ys)\n\nlet rec decrypt_code (str:string) (n:int) =\n    match n with\n    | n when n <= 0 -> str\n    | n ->\n        let halfIdx = String.length str \/ 2\n        merge (Seq.toList str).[halfIdx..] (Seq.toList str).[0..halfIdx-1]\n        |> System.String.Concat\n        |> (fun s -> decrypt_code s (n-1))\n\n\n\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85520,"user_id":null,"body":"open System\nlet rec encrypt_code (str:string) (n:int):string = \n    if n>0 then\n        (encrypt_code (String([|for i in 0..str.Length-1 -> if i<str.Length\/2 then str.[i*2+1] else str.[(i-str.Length\/2)*2]|])) (n-1))\n    else\n        str\n\n\nlet rec decrypt_code (str:string) (n:int) = \n    if n>0 then\n        (decrypt_code (String([|for i in 0..str.Length-1 -> if i%2=1 then str.[i\/2] else str.[str.Length\/2+i\/2]|])) (n-1))\n    else\n        str","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85521,"user_id":null,"body":"let rec encrypt_code (str: string) (n: int) =\n    match str,n with\n    | (\"\",_) -> str\n    | (_,x) when x<1 -> str\n    | _ ->\n        let encrypt_codeed =\n            str.ToCharArray()\n            |> Array.mapi (fun i c -> (i, string c))\n            |> Array.partition (fun (i, cs) -> i % 2 = 1)\n            ||> Array.append\n            |> Array.map snd\n            |> String.concat \"\"\n\n        encrypt_code encrypt_codeed (n - 1)\n\nlet rec interleave =\n    function\n    | (rs, []) -> rs\n    | ([], ls) -> ls\n    | (r :: rs, l :: ls) -> l :: r :: interleave (rs, ls)\n\nlet rec decrypt_code (str: string) (n: int) =\n\n    match str, n with\n    | (\"\", _) -> str\n    | (_, x) when x < 1 -> str\n    | _ ->\n        let decrypt_codeed =\n            str.ToCharArray()\n            |> List.ofArray\n            |> List.map string\n            |> List.splitAt (str.Length \/ 2)\n            |> interleave\n            |> String.concat \"\"\n\n        decrypt_code decrypt_codeed (n - 1)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85522,"user_id":null,"body":"let enc b s = s |> Seq.mapi (fun i c -> if i % 2 = 0 = b then \"\" else string(c)) |> Seq.reduce (+)\n\nlet encrypt_code (str:string) (n:int) =\n    let rec encrypt_code' str n =\n        if n <= 0\n        then str\n        else\n            encrypt_code' ((enc true str) + (enc false str)) (n - 1)\n    encrypt_code' str n\n\nlet decrypt_code (str:string) (n:int) =\n    let rec decrypt_code' str n =\n        if n <= 0\n        then str\n        else\n            let sz = String.length str \/ 2\n            let odd = str.[0..sz-1]\n            let even = str.[sz..]\n            let r = Seq.fold2 (fun a f s -> a + string(f) + string(s)) \"\" even odd\n            let r = if odd.Length < even.Length then r + string(even.[sz]) else r\n            decrypt_code' r (n - 1)\n    decrypt_code' str n\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85523,"user_id":null,"body":"let filteri f xs =\n  xs |> Seq.mapi (fun i x -> i, x) |> Seq.filter (fun (i, x) -> f i) |> Seq.map snd\n\nlet rec encrypt_code (str:string) (n:int) = \n  match n with\n  | 0 -> str\n  | _ when n > 0 ->\n    let evens = str |> filteri (fun i -> i % 2 = 0)\n    let odds = str |> filteri (fun i -> i % 2 <> 0)\n    let s = Seq.append odds evens |> Seq.map string |> String.concat \"\"\n    encrypt_code s (n - 1)\n  | _ -> str\n  \nlet rec decrypt_code (str:string) (n:int) = \n  match n with\n  | 0 -> str\n  | _ when n > 0 ->\n    let k = str.Length \/ 2\n    let odds = str.Substring(0, k) |> Seq.map string\n    let evens = str.Substring(k) |> Seq.map string\n    let z =\n      if str.Length % 2 = 0 then\n        Seq.zip odds evens\n      else\n        Seq.zip (Seq.append odds [\"\"]) evens\n    let s =\n      z\n      |> Seq.map (fun (o, e) -> sprintf \"%s%s\" e o)\n      |> String.concat \"\"\n      |> (fun s -> s.Substring(0, str.Length))\n    decrypt_code s (n-1)\n  | _ -> str\n    \n    \n    ","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85524,"user_id":null,"body":"open System\n\nlet rec encrypt_code (str:string) (n:int) =\n  match str, n with\n  | \"\", _ -> str\n  | _, x when x <= 0 -> str\n  | _ ->\n    let a = str |> Seq.mapi (fun i c -> if i%2=1 then string c else \"\") |> String.Concat\n    let b = str |> Seq.mapi (fun i c -> if i%2=0 then string c else \"\") |> String.Concat\n    encrypt_code (a+b) (n-1)\n\nlet rec decrypt_code (str:string) (n:int) =\n  printfn \"%s\" str\n  match str, n with\n  | \"\", _ -> str\n  | _, x when x <= 0 -> str\n  | _ ->\n    let l = String.length str\n    let temp = seq {0..l-1} |> Seq.map (fun i -> str.[i\/2 + if i%2=0 then l\/2 else 0]) |> String.Concat\n    decrypt_code temp (n-1)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85525,"user_id":null,"body":"let run func a i =\n    let i' = if i < 0 then 1 else i + 1\n    let rec run' (result : string list) =\n        if result.Length = i' then result |> List.head\n        else run' ((func (result |> List.head))::result) \n    run' [a]\n\nlet encrypt_code (str:string) (n:int) = \n    let encrypt_code' (str' : string) =\n        str'.ToCharArray()\n        |> Array.toSeq\n        |> Seq.fold (fun ((odd, even) : char list * char list) s ->\n            if odd.Length <= even.Length then\n                (s::odd, even)\n            else (odd, s::even)) ([], [])\n        |> fun (odd, even) -> (even |> List.rev)@(odd |> List.rev) |> List.map (fun c -> c.ToString())\n        |> String.concat \"\"\n    run encrypt_code' str n\n\nlet decrypt_code (str:string) (n:int) = \n    let decrypt_code' (str' : string) =\n        let a' = str'.ToCharArray()\n        let stringIsOdd = a'.Length%2 <> 0\n        let token = '@'\n        let odd, even =\n            let index = int (floor (float a'.Length\/2.0))\n            (a'.[index..] |> Array.toList, a'.[..index-1] |> Array.toList)\n        (odd, even)\n        |> fun (odd, even) -> if stringIsOdd then (odd, even@[token]) else (odd, even)\n        ||> List.zip\n        |> List.collect (fun (odd, even) -> [odd; even])\n        |> Seq.map (fun c -> c.ToString())\n        |> String.concat \"\"\n        |> fun s -> if stringIsOdd then s.[..s.Length-2] else s\n    run decrypt_code' str n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85526,"user_id":null,"body":"let swapChars (str:string) (calcNewIdx:int->int) =\n    let result = Array.create str.Length ' '\n    for idx in 0..(result.Length - 1) do\n        let newIdx = calcNewIdx idx\n        result.[newIdx] <- str.[idx]\n    result |> System.String\n\nlet rec applyTransformation (str:string) (transform:string->string) (n:int) =\n    if n <= 0 then str\n    elif n = 1 then transform str\n    else applyTransformation (transform str) transform (n - 1)\n\nlet encrypt_code (str:string) (n:int) =\n    let transform (s:string) = swapChars s (fun idx -> idx \/ 2 + (if idx % 2 = 0 then (str.Length) \/ 2 else 0))\n    applyTransformation str transform n\n\nlet decrypt_code (str:string) (n:int) =\n    let transform (s:string) =\n        let halfLength = (s.Length) \/ 2\n        swapChars s (fun idx -> if idx < halfLength then idx * 2 + 1 else 2 * (idx - halfLength))\n    applyTransformation str transform n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a049e253ba33ac5e000212":[{"id":85527,"user_id":1669,"body":"let factorial n = [1..n] |> List.fold (*) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85528,"user_id":527,"body":"let factorial n = Seq.fold (*) 1 {1..n}","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85529,"user_id":2255,"body":"let rec factorial n =\n  match n with\n  | 0 -> 1\n  | _ -> n * factorial (n-1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85530,"user_id":null,"body":"let rec factorial = function\n  | 0 -> 1\n  | n -> n * (factorial (n-1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85531,"user_id":null,"body":"let rec factorial n =\n  match n with\n  | 0 -> 1 \n  | n -> n * factorial (n-1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85532,"user_id":null,"body":"let factorial n =\n    let rec loop i acc =\n        match i with\n        | 0 | 1 -> acc\n        | _ -> loop (i-1) (acc * i)\n    loop n 1\n\n\/\/ Too slow for code wars to process\n\/\/ let rec factorial n = \n\/\/  match n with\n\/\/  | 0 | 1 -> 1\n\/\/  | _ -> n * factorial(n - 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85533,"user_id":575,"body":"let factorial n =\n    match n with \n    | 0 -> 1\n    | _ -> [1..n] |> Seq.reduce(fun x y -> x * y)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85534,"user_id":null,"body":"let factorial n =\n  let rec factorialRec num result = \n    if num = 0 then result\n    else factorialRec (num - 1) (result * num)\n  factorialRec n 1\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85535,"user_id":null,"body":"let factorial n =\n    [ 1..n ]\n    |> List.fold (fun acc x -> x * acc) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85536,"user_id":null,"body":"let factorial n =\n  match n with \n  | 0 | 1 -> 1\n  | n -> [1..n] |> List.fold (*) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a04da9e298a7ee43000111":[{"id":85537,"user_id":575,"body":"let reverseList = List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85538,"user_id":null,"body":"\/\/ Could just do \"let reverseList = List.rev\", but that's too easy. Let's actually implement it.\nlet reverseList list =\n  let rec loop acc = function\n    | [] -> acc\n    | x::xs -> loop (x::acc) xs\n  loop [] list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85539,"user_id":492,"body":"let reverseList list = list |> List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85540,"user_id":null,"body":"let reverseList =\n  let rec f acc = function\n  | [] -> acc\n  | x :: xs -> f (x :: acc) xs\n  f []\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85541,"user_id":null,"body":"let reverseList lst = \n  let rec inner lst' acc =\n    match lst' with\n    | [] -> acc\n    | x :: xs -> inner xs (x :: acc)\n  inner lst []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85542,"user_id":1686,"body":"let rec reverseList list =\n    match list with\n    | [] -> []\n    | x :: xs -> reverseList xs @ [x]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85543,"user_id":50,"body":"\/\/ https:\/\/riptutorial.com\/fsharp\/example\/25356\/reversal-of-a-list-of-any-type\nlet reverseList list = \n    let rec loop acc = function\n        | []           -> acc\n        | head :: tail -> loop (head :: acc) tail\n    loop [] list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85544,"user_id":null,"body":"let reverseList = Seq.rev >> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85545,"user_id":53,"body":"let rec reverseList list =\n    match list with\n    | [] -> []\n    | x :: ks -> reverseList ks @ [x]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85546,"user_id":null,"body":"let reverseList list = \n  let rec inner list acc =\n    match list with\n    | [] -> acc\n    | x::xs -> inner xs (x::acc)\n  \n  inner list []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a0556c7cb1f31ab3000ad7":[{"id":85547,"user_id":1986,"body":"let make_upper_case (s: string) = s.ToUpper()","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85548,"user_id":null,"body":"let make_upper_case = String.map System.Char.ToUpper","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85549,"user_id":null,"body":"let make_upper_case (s:string) = s.ToUpperInvariant()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85550,"user_id":null,"body":"let make_upper_case (s: string): string =\n  s.ToUpper()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85551,"user_id":null,"body":"let make_upper_case (s : string) =\n    let upperCase c = match (c |> int) with | c when c >= 97 && c <= 122 -> ((c - 32) |> char) | _ -> c\n    new string(s |> Seq.map upperCase |> Seq.toArray)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85552,"user_id":null,"body":"let make_upper_case s = s |> Seq.map System.Char.ToUpper |> Seq.map string |> Seq.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85553,"user_id":null,"body":"open System\nlet make_upper_case (s:string) = \n  String.map Char.ToUpper s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85554,"user_id":null,"body":"let make_upper_case s =\n  match s with\n  | \"hello\" -> \"HELLO\"\n  | \"hello world\" -> \"HELLO WORLD\"\n  | \"hello world !\" -> \"HELLO WORLD !\"\n  | \"1,2,3 hello world\" -> \"1,2,3 HELLO WORLD\"\n  | _ -> \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85555,"user_id":null,"body":"open System\nlet make_upper_case s = String.map Char.ToUpper <| s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85556,"user_id":null,"body":"let make_upper_case s = \n  let x : string = s\n  x.ToUpper()\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a059d753ba33229500001a":[{"id":85557,"user_id":1986,"body":"let makeLowerCase (s: string) = s.ToLower()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85558,"user_id":null,"body":"open System\nlet makeLowerCase s = s.ToString().ToLower()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85559,"user_id":null,"body":"let solutions = [|\"hello\"; \"hello world\"; \"hello world !\"; \"1,2,3 hello world\"|]\nlet mutable count = -1\nlet makeLowerCase s = \n  count <- count + 1\n  solutions.[count]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85560,"user_id":null,"body":"let makeLowerCase s = s |> String.map (fun c -> System.Char.ToLower(c))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85561,"user_id":null,"body":"open System\n\nlet makeLowerCase = String.map Char.ToLower","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85562,"user_id":null,"body":"open System\n\nlet makeLowerCase s = String.map Char.ToLower s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85563,"user_id":53,"body":"let makeLowerCase s = \n  let a = Seq.map System.Char.ToLower s\n  let b = Seq.map string a\n  let c = String.concat \"\" b\n  c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85564,"user_id":null,"body":"let makeLowerCase s = \n  let input = string s\n  input.ToLower()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85565,"user_id":null,"body":"let makeLowerCase s =\n    s\n    |> Seq.map System.Char.ToLower\n    |> Seq.map string\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85566,"user_id":null,"body":"let makeLowerCase s = (s:string).ToLower ()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a05e0172292dd8510001f7":[{"id":85567,"user_id":1686,"body":"let splitSentence (words : string) = words.Split(' ') |> List.ofArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85568,"user_id":null,"body":"let splitSentence (words: string) = words.Split() |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85569,"user_id":null,"body":"let splitSentence (words:string) = \n    words.Split ' ' \n    |> Array.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85570,"user_id":null,"body":"open System\n\nlet splitSentence (sentence : string) =\n    sentence.Split((null : string[]), StringSplitOptions.RemoveEmptyEntries)\n    |> Array.toList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85571,"user_id":53,"body":"let splitSentence (words : string) =\n  List.ofArray(words.Split(' '))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85572,"user_id":null,"body":"open System\n\nlet splitSentence (words: string) = words.Split(' ') |> List.ofArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85573,"user_id":null,"body":"let splitSentence (words: string) =\n    words |> fun x -> x.Split ' ' |> List.ofArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85574,"user_id":76,"body":"let splitSentence (words : string) = Seq.toList (words.Split [|' '|])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85575,"user_id":null,"body":"open System\n\nlet splitSentence(words:string) = \n let result = words.Split ' ' |> Array.toList\n result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85576,"user_id":null,"body":"open System\n\nlet splitSentence (words: string) = \n  words.Split(' ') |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a06005cf1fa5fbd5000216":[{"id":85577,"user_id":575,"body":"let wordsToSentence = String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85578,"user_id":1669,"body":"let wordsToSentence words = String.concat \" \" words","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85579,"user_id":null,"body":"let rec wordsToSentence words =\n    match words with\n    | [] -> \"\"\n    | [w] -> w\n    | h::t -> h + \" \" + wordsToSentence t","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85580,"user_id":null,"body":"let rec wordsToSentence words =\n    match words with\n    | [] -> \"\"\n    | head::tail -> \n        if tail=[] then  head+wordsToSentence(tail)\n        else head + \" \" + wordsToSentence(tail)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85581,"user_id":753,"body":"open System\n\nlet wordsToSentence (words: List<string>) = String.Join(\" \", words)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85582,"user_id":null,"body":"let wordsToSentence (l: string list) =     \n    System.String.Join (\" \", l)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85583,"user_id":null,"body":"let rec wordsToSentence words = \n  match words with\n  | [] -> \"\"\n  | head :: tail -> \n    match tail with\n    | [] -> head + wordsToSentence tail\n    | _ -> head + \" \" + wordsToSentence tail","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85584,"user_id":null,"body":"let wordsToSentence = Seq.reduce (sprintf \"%s %s\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85585,"user_id":2564,"body":"open System\n\nlet wordsToSentence (words: string list) = String.Join (\" \", words)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85586,"user_id":null,"body":"let wordsToSentence (words:List<string>) =\n    let mutable str = \"\"\n    for s in words do\n        if words.[0] = s then\n            str <- str + s\n        else\n            str <- str + (\" \"+s)\n    str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a06b07cf1fa58b2b000252":[{"id":85587,"user_id":1686,"body":"let isItLetter = System.Char.IsLetter","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85588,"user_id":null,"body":"let letters = ['a'..'z'] @ ['A'..'Z'] |> Set\nlet isItLetter c = Set.contains c letters","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85589,"user_id":null,"body":"let letters = set [\n 'a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'; 'i'; 'j'; 'k'; 'l';\n 'm'; 'n'; 'o'; 'p'; 'q'; 'r'; 's'; 't'; 'u'; 'v'; 'w'; 'x'; \n 'y'; 'z';\n 'A'; 'B'; 'C'; 'D'; 'E'; 'F'; 'G'; 'H'; 'I'; 'J'; 'K'; 'l';\n 'M'; 'N'; 'O'; 'P'; 'Q'; 'R'; 'S'; 'T'; 'U'; 'V'; 'W'; 'X';\n 'Y'; 'Z';\n]\n\nlet isItLetter c = Set.contains c letters","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85590,"user_id":null,"body":"let isItLetter =\n  let letters = ['a'..'z'] @ ['A'..'Z'] |> Set\n  fun c -> letters.Contains c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85591,"user_id":null,"body":"let isItLetter c =\n  (['a'..'z'] |> List.exists ((=) c)) || (['A'..'Z'] |> List.exists ((=) c))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85592,"user_id":753,"body":"open System\n\nlet isItLetter c = Char.IsLetter(c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85593,"user_id":null,"body":"let isItLetter = function\n    | x when x >= 'A' && x <= 'z' -> true\n    | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85594,"user_id":null,"body":"let isItLetter c = ['a'..'z']@['A'..'Z'] |> List.contains c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85595,"user_id":null,"body":"open System\nlet isItLetter = Char.IsLetter","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85596,"user_id":null,"body":"let isItLetter (c : char) : bool = List.contains c (List.concat [['A'..'Z']; ['a'..'z']])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a06c1b7cb1f3e15b00082b":[{"id":85597,"user_id":1686,"body":"let isItDigit = System.Char.IsDigit","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85598,"user_id":null,"body":"let isItDigit (c : char) = System.Char.IsDigit c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85599,"user_id":null,"body":"let isItDigit c = c >= '0' && c <= '9'","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85600,"user_id":null,"body":"let isItDigit c = \n  let indc = c |> int\n  (indc >= 48 && indc <= 57)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85601,"user_id":1986,"body":"let isItDigit = function\n    | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' -> true\n    | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85602,"user_id":null,"body":"let isItDigit = System.Char.IsNumber","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85603,"user_id":null,"body":"let isItDigit c = \n    int c - int '0' >= 0 && int c - int '0' <= 9","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85604,"user_id":null,"body":"let isItDigit c =\n  let asciiNum = int c\n  asciiNum >= 48 && asciiNum <= 57","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85605,"user_id":null,"body":"open System\nlet isItDigit c = Char.IsDigit(c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85606,"user_id":null,"body":"let isItDigit c = \n match c with\n |'0' -> true\n |'1' -> true\n |'2' -> true\n |'3' -> true\n |'4' -> true\n |'5' -> true\n |'6' -> true\n |'7' -> true\n |'8' -> true\n |'9' -> true\n |_ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a06e21e298a7b5ae000229":[{"id":85607,"user_id":1686,"body":"let isItWhitespace = System.Char.IsWhiteSpace","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85608,"user_id":2182,"body":"let isItWhitespace c = (c=' '||c='\n'||c='\\t'||c='\\r')","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85609,"user_id":null,"body":"open System \nlet isItWhitespace c =\n     match c with \n     |'a' -> false\n     |'1' -> false\n     |_ -> true","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85610,"user_id":1669,"body":"let isItWhitespace c = System.Char.IsWhiteSpace c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85611,"user_id":null,"body":"let isItWhitespace c =\n  match c with\n  | ' ' -> true\n  | '\\t' -> true\n  | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85612,"user_id":null,"body":"let isItWhitespace c = \n  if c=' ' then true\n  else if c='\\t' then true\n  else false\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85613,"user_id":null,"body":"let isItWhitespace c =\n  match c with\n  | ' ' -> true\n  | '\n' -> true\n  | '\\t' -> true\n  | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85614,"user_id":null,"body":"let isItWhitespace ch = [' ';'\\t'] |> List.contains ch","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85615,"user_id":null,"body":"let isItWhitespace c = c |> string |> System.String.IsNullOrWhiteSpace","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85616,"user_id":null,"body":"let isItWhitespace = function | ' ' | '\\t' -> true | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a083a57cb1f31db7000028":[{"id":85617,"user_id":null,"body":"let powers_of_two n = [for i in 0..n -> pown 2 i]","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85618,"user_id":null,"body":"let powers_of_two n = List.init (n + 1) (pown 2)","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85619,"user_id":null,"body":"let powers_of_two n = \n  List.map (pown 2) [0..n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85620,"user_id":null,"body":"let powers_of_two (n: int): List<int> = [for x in 0..n -> pown 2 x]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85621,"user_id":null,"body":"let powers_of_two n = [ for i in 0..n do yield pown 2 i ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85622,"user_id":null,"body":"let powers_of_two n = [ for i in 0 .. n -> 1 <<< i ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85623,"user_id":null,"body":"let powers_of_two n = [for i in 0 ..n do yield (1 <<< i)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85624,"user_id":null,"body":"let rec powers_of_two: int -> List<int> =\n    fun(n: int) ->\n    match n with \n    | 0 -> [1]\n    | _ -> powers_of_two(n-1) @ [int(2.**float(n))]\n        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85625,"user_id":null,"body":"let powers_of_two n = \n    seq { for i in 0 .. n do yield (1 <<< i) } |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85626,"user_id":null,"body":"let powers_of_two n = \n  let powers = Seq.initInfinite (fun number -> pown 2 number)\n  powers |> Seq.take (n+1) |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a0885cbb9944e24c00008e":[{"id":85627,"user_id":null,"body":"let remove_exclamation_marks = String.filter ((<>) '!')","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85628,"user_id":527,"body":"let remove_exclamation_marks (s : string) = s.Replace(\"!\", \"\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85629,"user_id":null,"body":"let remove_exclamation_marks s = \n    s |> String.filter (fun c -> c <> '!' )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85630,"user_id":1686,"body":"let remove_exclamation_marks s =\n    List.ofSeq(s)\n    |> List.filter(fun c -> c <> '!')\n    |> List.map(fun c -> c.ToString())\n    |> List.reduce(fun s str -> s + str)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85631,"user_id":null,"body":"let remove_exclamation_marks s =\n    s\n    |> Seq.filter (fun c -> c <> '!')\n    |> Seq.toArray\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85632,"user_id":null,"body":"let remove_exclamation_marks s =\n    s\n    |> String.filter (fun ch -> ch <> '!' ) \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85633,"user_id":null,"body":"let rec remove_exclamation_marks (s : string) = \n        if s.Contains(\"!\") then \n            remove_exclamation_marks (s.Replace(\"!\", \"\"))\n        else \n            s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85634,"user_id":null,"body":"open System\n\nlet remove_exclamation_marks s =\n    String [|for c in s do if c <> '!' then yield c|]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85635,"user_id":null,"body":"let remove_exclamation_marks s = \n    s |> Seq.filter(fun c -> c <> '!') |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85636,"user_id":null,"body":"let remove_exclamation_marks s = \n  Seq.toList s |> List.filter (fun c -> c<>'!')|> List.fold (fun acc c -> acc + (string c)) \"\" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a0e5c372292dd76d000d7e":[{"id":85637,"user_id":527,"body":"let repeat_str = String.replicate","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85638,"user_id":1669,"body":"let rec repeat_str n s = \n  match n with\n  | 0 -> \"\"\n  | _ -> (repeat_str (n-1) s) + s","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85639,"user_id":1363,"body":"let repeat_str n s =\n  [1..n] |> List.map (fun _ -> s) |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85640,"user_id":null,"body":"let rec repeat_str n s = String.replicate n s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85641,"user_id":null,"body":"let repeat_str n s =\n  let rec inner count acc =\n    if count = 0 then acc\n    else inner (count - 1) acc + s\n  inner n \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85642,"user_id":null,"body":"open System\nlet repeat_str n s = [for i in 1..n -> s] |> String.Concat ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85643,"user_id":null,"body":"let repeat_str n s = \n  [1..n] |> Seq.map (fun m -> s) |> Seq.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85644,"user_id":null,"body":"let repeat_str n s =\n  let mutable answer = \"\"\n  for i = 1 to n do\n    answer <- answer + s\n  answer","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85645,"user_id":null,"body":"let repeat_str n s = \n    let mutable str = \"\"\n    for i = 1 to n do\n        printfn \"%i\" i\n        str <- str + s\n        printfn \"%s\" str\n    str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85646,"user_id":null,"body":"let repeat_str n s = \n  Seq.init n (fun _ -> s)\n  |> Seq.fold (fun state s -> state + s) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a0f354e298a77602000159":[{"id":85647,"user_id":527,"body":"open System\n\nlet makeStarTriangle n =\n  {1 .. n}\n    |> Seq.map (fun i -> String(' ', n - i) + String('*', 2 * i - 1))\n    |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85648,"user_id":null,"body":"open System\n\nlet makeStarTriangle n =\n  seq {\n    for i in 1 .. n do\n      yield String(' ', n - i)\n      yield String('*', 2 * i - 1)\n\n      if i <> n then\n        yield \"\n\"\n  }\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85649,"user_id":null,"body":"let makeStarTriangle n =\n  seq {\n        for stars in 1..2..2*n do\n            let spaces = (2*n - 1 - stars)\/2\n            let spacesStr = String.init spaces (fun _ ->\" \")\n            let starsStr = String.init stars (fun _ ->\"*\")\n            yield spacesStr + starsStr\n           } |> Seq.reduce (fun accum current -> accum  + \"\n\" + current) \n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85650,"user_id":null,"body":"let makeStarTriangle n =\n  let makeLine i = String.replicate (n-i-1) \" \" + String.replicate (2*i+1) \"*\" in\n  List.init n makeLine\n  |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85651,"user_id":1669,"body":"open System\n\nlet makeStarTriangle n = String.Join(\"\n\", [for i in 1..n do yield new String(' ', n-i) + new String('*', i*2-1)]);","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85652,"user_id":527,"body":"open System\n\nlet makeStarTriangle n =\n  String.concat \"\n\" (seq {\n    for i in 1 .. n -> String(' ', n - i) + String('*', 2 * i - 1)\n  })","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85653,"user_id":null,"body":"let makeStarTriangle n =\n    Seq.initInfinite (id >> ((+) 1))\n    |> Seq.take n\n    |> Seq.map (fun i -> sprintf \"%s%s\" (String.replicate (n - i) \" \") (String.replicate (i * 2 - 1) \"*\"))\n    |> String.concat \"\n\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85654,"user_id":null,"body":"let makeStarTriangle n =\n    [ for i in [0 .. (n - 1)] -> String.replicate (n - i - 1) \" \" \n                                 + String.replicate (i * 2 + 1) \"*\"]\n    |> String.concat \"\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85655,"user_id":null,"body":"let makeStarTriangle n =\n  let b =\n    n * 2 - 1\n\n  seq {\n    for i in 1 .. 2 .. b do\n      yield! Seq.replicate ((b - i) \/ 2) \" \"\n      yield! Seq.replicate i \"*\"\n\n      if i <> b then\n        yield \"\n\"\n  }\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85656,"user_id":null,"body":"let rec makeStarTriangle n =\n  match n with\n  | 1 -> \"*\"\n  | _ -> String.concat \"\n\" (Seq.map (fun l -> \" \" + l) ((makeStarTriangle (n - 1)).Split '\n')) + \"\n\" + String.replicate (2*n - 1) \"*\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a19defbb994481c40001bd":[{"id":85657,"user_id":null,"body":"let getFactors n = [for i in 1..n do if n % i = 0 then yield i]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85658,"user_id":1686,"body":"let getFactors n = [1 .. n] |> List.filter(fun x -> n % x = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85659,"user_id":null,"body":"let getFactors n =\n    [1..n]\n    |> List.filter (fun i -> n % i = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85660,"user_id":null,"body":"let getFactors n =\n    let rec loop low high i =\n        let q = n \/ i\n        if q < i then\n            List.append (List.rev low) high\n        else if n % i <> 0 then\n            loop low high (i + 1)\n        else if q = i then\n            List.append (List.rev low) (q :: high)\n        else\n            loop (i :: low) (q :: high) (i + 1)\n\n    if n = 1 then [1] else loop [1] [n] 2\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85661,"user_id":null,"body":"let getFactors (n: int) = \n  [1 .. n] |> List.filter (fun x -> n % x = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85662,"user_id":1363,"body":"let getFactors n =\n  match n with\n  | 0 -> []\n  | 1 -> [1]\n  | _ -> seq { 1 .. n } |> Seq.filter (fun x -> n % x = 0) |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85663,"user_id":null,"body":"let getFactors n =\n    [ 1..n ] |> List.filter ((%) n >> (=) 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85664,"user_id":53,"body":"let getFactors n = \n  [1 .. n] \n    |> List.filter(fun e -> n % e = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85665,"user_id":50,"body":"let getFactors n = [1 ..n] |> List.filter(fun m -> n % m = 0 )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85666,"user_id":null,"body":"let getFactors n =\n    [ 1 .. n ] |> List.filter (fun v -> n % v = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a1a89fcf1fa56b8600154a":[{"id":85667,"user_id":null,"body":"let isPrime n =\n    \/\/ Check if n is divisible by numbers up to sqrt(n)\n    let squareRoot = int(sqrt(float n))\n    not (List.exists (fun i -> n % i = 0) [2..squareRoot])\n\nlet getPrimes n =\n    Seq.initInfinite (fun i -> i + 2)   \/\/ Start sequence at 2\n    |> Seq.filter (isPrime)             \/\/ Keep only primes\n    |> Seq.take n                       \/\/ Take first n values\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85668,"user_id":null,"body":"let getPrimes n = \n    let primes =\n        let rec nextPrime n p primes =\n            if primes |> Map.containsKey n then\n                nextPrime (n + p) p primes\n            else\n                primes.Add(n, p)\n\n        let rec prime n primes =\n            seq {\n                if primes |> Map.containsKey n then\n                    let p = primes.Item n\n                    yield! prime (n + 1) (nextPrime (n + p) p (primes.Remove n))\n                else\n                    yield n\n                    yield! prime (n + 1) (primes.Add(n * n, n))\n            }\n\n        prime 2 Map.empty\n    primes |> Seq.take n |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85669,"user_id":null,"body":"let factors n =\n    [1..n]\n    |> Seq.filter(fun x -> n % x = 0)\n    |> Seq.toList\n\nlet isPrime n =\n    factors n = [1; n]\n\nlet getPrimes n =\n    seq {1..System.Int32.MaxValue}\n    |> Seq.filter isPrime\n    |> Seq.take n\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85670,"user_id":null,"body":"let rec primes =\n    seq {\n        yield 2\n        for n in primes do\n            yield\n                Seq.initInfinite ((+) (n + 1))\n                |> Seq.find (fun i ->\n                    primes \n                    |> Seq.takeWhile (fun prime -> prime * prime <= i)\n                    |> Seq.forall (fun prime -> i % prime <> 0))\n    } |> Seq.cache\n\nlet getPrimes n = \n  primes\n  |> Seq.take n\n  |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85671,"user_id":null,"body":"let isPrime n = \n     let u = n \n             |> float\n             |> sqrt\n             |> int\n\n     seq {2..u} \n     |> Seq.exists (fun x -> n % x = 0) \n     |> not\n\nlet rec nextPrime n =\n    if isPrime (n + 1) \n    then n + 1\n    else nextPrime (n + 1) \n\nlet primes =\n    Seq.unfold (fun x -> Some (x, nextPrime x)) 2 \n\nlet getPrimes n = \n    primes \n    |> Seq.take n\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85672,"user_id":168,"body":"let getPrimes n = \n  Seq.initInfinite (fun i -> i + 2)\n  |> Seq.filter (fun x -> seq { 2 .. (float >> sqrt >> int) x } |> Seq.forall (fun d -> x % d > 0))\n  |> Seq.take n\n  |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85673,"user_id":null,"body":"let getPrimes n = \n    let rec Loop (primes:int list) primeCandidate =\n        if primes.Length = n then\n            primes |> List.rev\n        else\n            let rec CheckIfDivisible possibleDivisor =\n                if possibleDivisor >= primeCandidate\/2 then\n                    false\n                else\n                    if primeCandidate%possibleDivisor = 0 then\n                        true\n                    else\n                        CheckIfDivisible (if possibleDivisor = 2 then 3 else possibleDivisor+2)\n            let next_primes = if CheckIfDivisible 2 then primes else (primeCandidate::primes)\n            Loop next_primes (if primeCandidate = 2 then 3 else primeCandidate+2)\n    Loop [] 2\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85674,"user_id":null,"body":"let getPrimes n = \n  let isPrime (num: int) =\n    let rec getDivs (num: int) (ind: int) =\n      match ind with\n      | ind when (ind * ind > num) -> true\n      | ind when (num % ind = 0)   -> false\n      | _                          -> (getDivs num (ind + 1))\n    getDivs num 2\n    \n  Seq.initInfinite (fun x -> x + 2) |> Seq.filter isPrime |> Seq.take n |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85675,"user_id":null,"body":"let isPrime x = List.forall (fun n -> x % n <> 0) [2..x-1]\n\nlet getPrimes n =\n  let rec nPrimes n i primes =\n    match List.length primes with\n    | length when length = n -> List.rev primes\n    | _ ->\n      match i with\n      | i when isPrime i -> nPrimes n (i + 1) (i::primes)\n      | _ -> nPrimes n (i + 1) primes\n  nPrimes n 2 []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85676,"user_id":null,"body":"let rec findNextPrime currNum =\n    if\n        List.filter (fun num -> currNum%num=0) [1..currNum] |>\n        List.length |>\n        ((=)2)\n    then\n        currNum\n    else\n        currNum+1 |> findNextPrime \n\nlet getPrimes n =\n    let generator (remain, currNum) =\n        if remain<=0\n        then None\n        else\n            let prime = findNextPrime currNum\n            Some (prime,(remain-1,prime+1))\n    List.unfold generator (n,2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a1ae8c7cb1f31e4e000130":[{"id":85677,"user_id":1686,"body":"let getMinMax list = (List.min list, List.max list)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85678,"user_id":null,"body":"let getMinMax = function\n| [] -> failwith \"List is empty.\"\n| x :: xs ->\n    xs\n    |> List.fold (fun (minSeen, maxSeen) x' -> min minSeen x', max maxSeen x') (x, x)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85679,"user_id":null,"body":"let getMinMax list = Seq.min list,Seq.max list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85680,"user_id":null,"body":"let getMinMax list =\n  let rec inner (min', max') = function\n    | x::xs -> inner ((min min' x), (max max' x)) xs\n    | [] -> (min', max')\n  match list with\n  | x::xs -> inner (x, x) xs\n  | [] -> failwith \"you said non-empty!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85681,"user_id":null,"body":"let getMinMax list = \n  let minimal = Seq.min list\n  let maximal = Seq.max list\n  minimal, maximal","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85682,"user_id":null,"body":"let getMinMax list = \n  let min lst = List.fold min System.Int32.MaxValue lst\n  let max lst = List.fold max System.Int32.MinValue lst\n    \n  (min list, max list)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85683,"user_id":null,"body":"let getMinMax (list:int list) = (List.min list, List.max list)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85684,"user_id":null,"body":"let getMinMax (list: int list) =\n    let max = list |> List.max\n    let min = list |> List.min\n    (min, max)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85685,"user_id":null,"body":"let getMinMax (list : int list) =\n    let rec sweep min max (ls : int list) =\n        match ls with\n        | [] -> (min, max)\n        | h::t when h < min && h > max -> sweep h h t\n        | h::t when h < min -> sweep h max t\n        | h::t when h > max -> sweep min h t\n        | _::t -> sweep min max t\n    sweep list.[0] list.[0] list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85686,"user_id":null,"body":"let getMinMax list =\n    let res = List.sort list\n    (res.[0], res.[res.Length - 1])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a1d5ef7cb1f3db590002af":[{"id":85687,"user_id":2255,"body":"let rec fib = function\n  | 0 -> 0\n  | 1 -> 1\n  | n -> fib (n - 1) + fib (n - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85688,"user_id":null,"body":"let rec fib = function\n    | 1 | 2 -> 1\n    | n     -> fib (n - 1) + fib (n - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85689,"user_id":null,"body":"let rec fib n = \n    match n  with  \n    |_ when  n = 0 ->  0\n    |_ when n = 1 -> 1 \n    |_  -> fib (n-1) + fib (n-2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85690,"user_id":1363,"body":"let fib n =\n  let rec fib1 n a b =\n    match n with\n      | 1 -> a\n      | _ -> fib1 (n-1) b (a+b)\n  fib1 n 1 1;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85691,"user_id":null,"body":"let fib n =\n  let rec loop a b i=   \n      match n with\n      | 0 -> 0\n      | 1 -> 1\n      | _ when i = n -> b\n      | _ -> \n          let c = a\n          let a = b\n          let b = c + a\n          loop a b (i+1)\n          \n  loop 0 1 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85692,"user_id":null,"body":"let fib n = \n    let rec fibonacci i1 i2 c n = \n        if c < n then fibonacci i2 (i1 + i2) (c + 1) n\n        else i1\n    fibonacci 1 1 1 n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85693,"user_id":null,"body":"let outOfRange (arg : string) (msg : string) =\n    raise (System.ArgumentOutOfRangeException(arg, msg))\n\nlet rec fib = function\n    | 1 | 2 -> 1\n    | n when n >= 3 -> fib (n - 1) + fib (n - 2)\n    | _ -> outOfRange \"n\" \"Must be greater than zero.\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85694,"user_id":null,"body":"let rec fib n = if n < 2 then n else fib (n - 1) + fib (n - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85695,"user_id":null,"body":"let fib n = \n  Seq.unfold (fun (a,b) -> Some (a, (a+b,a))) (1,0)\n  |> Seq.item (n-1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85696,"user_id":null,"body":"let fib n =\n    let rec tail n1 n2 = function\n    | 0 -> n1\n    | n -> tail n2 (n2 + n1) (n - 1)\n    tail 0 1 n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a1dd9fcf1fa5d0d100005f":[{"id":85697,"user_id":null,"body":"let countVowels s =\n        s\n        |> String.filter (fun x -> \"aeiou\".Contains(x |> string)) \n        |> String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85698,"user_id":2564,"body":"let countVowels (s: string) =\n  let func acc c =\n    match c with\n    | 'a' | 'e' | 'i' | 'o' | 'u' -> acc + 1\n    | _ -> acc\n    \n  s.ToCharArray() |> Array.fold func 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85699,"user_id":492,"body":"let isVowel v =\n        match v with\n        | 'a' | 'e' | 'i' | 'o' | 'u' -> true\n        | _ -> false\nlet countVowels s =\n        s\n        |> String.filter (fun x -> isVowel x)\n        |> String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85700,"user_id":null,"body":"let countVowels s = \n   let vowels = set \"aeiou\"\n   s |> Seq.filter (vowels.Contains) |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85701,"user_id":null,"body":"open System\nopen System.Linq\n\nlet countVowels (s : string) = s.Count(Func<char, bool>(\"aeiou\".Contains))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85702,"user_id":1363,"body":"let countVowels (s:string) =\n  s.ToLower() |> Seq.filter (fun c -> \"aeiou\".IndexOf(c) >= 0) |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85703,"user_id":null,"body":"let countVowels s =\n  s\n  |> Seq.map string\n  |> Seq.filter \"aeiou\".Contains\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85704,"user_id":null,"body":"let countVowels s = \n  let isVowel c = \"aeiouAEIOU\" |> Seq.contains c\n  s \n  |> Seq.filter isVowel \n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85705,"user_id":null,"body":"let countVowels = String.filter (fun c -> ['a';'i';'u';'e';'o'] |> Seq.contains c) >> String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85706,"user_id":null,"body":"open System.Linq\nlet countVowels (str: string): int =\n    let isVowel = System.Char.ToLower >> function\n        | 'a' | 'e' | 'i' | 'o' | 'u' -> true\n        | _ -> false\n    in\n    Array.fold (fun x y -> x + (if isVowel(y) then 1 else 0)) 0 (str.ToArray()) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a1e23853ba339caf001000":[{"id":85707,"user_id":null,"body":"let uppercaseVowels =\n  String.map (function\n    | 'a' -> 'A'\n    | 'e' -> 'E'\n    | 'i' -> 'I'\n    | 'o' -> 'O'\n    | 'u' -> 'U'\n    | c -> c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85708,"user_id":null,"body":"open System \n\nlet uppercaseVowels = \n  String.map (fun m -> \n    match (\"aeiou\".Contains(string m)) with\n    | true -> Char.ToUpper(m) \n    | false -> m\n  )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85709,"user_id":null,"body":"let uppercaseVowels = \n    String.map (fun c -> match c with \n                         | 'a' | 'e' | 'i' | 'o' | 'u' -> System.Char.ToUpper(c)\n                         | _ -> c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85710,"user_id":null,"body":"open System\n\nlet isVowel c = \"aeiouAEIOU\" |> Seq.contains c\n\nlet uppercaseVowels s = \n    s\n    |> Seq.map(fun c -> if isVowel c then Char.ToUpper c else c)\n    |> Seq.toArray\n    |> String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85711,"user_id":null,"body":"let uppercaseVowels = String.map (fun c -> if \"aiueo\" |> Seq.contains c then System.Char.ToUpper c else c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85712,"user_id":null,"body":"open System\nlet uppercaseVowels input = \n    let isVowel = System.Char.ToLower >> function\n           | 'a' | 'e' | 'i' | 'o' | 'u' -> true\n           | _ -> false\n    in\n    String.map (fun c -> match isVowel c with | true -> Char.ToUpper(c) | false -> c ) input","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85713,"user_id":null,"body":"open System\n\nlet uppercaseVowels s = \n  let vowels = ['a';'e';'i';'o';'u']\n  s |> Seq.map (fun x -> if (List.contains x vowels) then x.ToString().ToUpper() else x.ToString()) |>\n  String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85714,"user_id":null,"body":"let uppercaseVowels s =\n    let vowels = Set.ofSeq \"aeiou\"\n    s |> String.map (fun c -> if Set.contains c vowels then System.Char.ToUpper c else c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85715,"user_id":null,"body":"let uppercaseVowels s = String.collect (fun c -> if Seq.exists((=)c) \"aeiou\" then string(System.Char.ToUpper c) else string c) s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85716,"user_id":null,"body":"open System\n\nlet uppercaseVowels = String.map (fun c -> if \"aeiou\".Contains (string c) then Char.ToUpper c else c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a1fd2ce298a731b20006a4":[{"id":85717,"user_id":1566,"body":"let is_palindrome (s: string) = \n  let arr = s.ToLower().ToCharArray()\n  arr = Array.rev arr","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85718,"user_id":null,"body":"open System\n\nlet is_palindrome s =\n    let n = String.length s\n    {0..n \/ 2 - 1} |> Seq.forall (fun i -> Char.ToUpper(s.[i]) = Char.ToUpper(s.[n - 1 - i]))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85719,"user_id":527,"body":"let is_palindrome (s : string) = \n  let sl = s.ToLower()\n  Seq.forall2 (=) (Seq.cast sl) (Seq.rev sl)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85720,"user_id":1363,"body":"let rec is_palindrome (s:string) =\n  if s.Length <= 1 then true\n  else\n    let a = s |> Seq.head |> System.Char.ToLower\n    let z = s |> Seq.last |> System.Char.ToLower\n    if a = z \n      then is_palindrome (s.[1..s.Length - 2])\n      else false;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85721,"user_id":null,"body":"let is_palindrome (s : string) = \n  let lowerS = s.ToLowerInvariant().ToCharArray()\n  lowerS = (lowerS |> Array.rev)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85722,"user_id":null,"body":"let is_palindrome (s: string): bool =\n    let lowercased = s.ToLower().ToCharArray()\n    \n    lowercased = Array.rev lowercased\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85723,"user_id":491,"body":"let is_palindrome (str : string) =\n    let str_rev = [for chr in (str.ToLower()) -> chr] |> List.rev |> List.toArray |> System.String\n    (str.ToLower()) = str_rev\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85724,"user_id":null,"body":"let rec is_palindrome (s: string) =\n    match s.Length with\n    | 0 | 1 -> true\n    | len ->\n        let lowerCharAt pos = System.Char.ToLower(s.[pos])\n        let firstChar = lowerCharAt 0\n        let lastChar = lowerCharAt (len-1)\n        if lastChar = firstChar then\n            is_palindrome (s.Substring (1, len-2))\n        else\n            false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85725,"user_id":null,"body":"open System\nlet is_palindrome (s:string ) = \n    s\n    |>Seq.rev\n    |> Seq.map (fun i -> (string i ).ToLower())\n    |> String.Concat\n    |>(fun i -> if i = s.ToLower() then true else false)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85726,"user_id":null,"body":"let is_palindrome s =\n    let n = String.length s\n    let s = s.ToUpper()\n    {0..n \/ 2 - 1} |> Seq.forall (fun i -> s.[i] = s.[n - 1 - i])\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a2013acf1fa5bfc4000921":[{"id":85727,"user_id":null,"body":"let find_average = List.average","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85728,"user_id":null,"body":"let rec len = function\n    | h::t -> 1 + len t\n    | [] -> 0\n\nlet rec sum = function\n    | h::t -> h + sum t\n    | [] -> 0.0\n\nlet find_average = function\n    | [] -> 0.0\n    | l  -> (sum l) \/ (len l |> float)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85729,"user_id":1669,"body":"let find_average list = List.average list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85730,"user_id":null,"body":"let find_average list =\n  let total = List.reduce (+) list |> float\n  let length = List.length list |> float\n  total \/ length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85731,"user_id":753,"body":"let find_average list = (list |> List.sum) \/ (list |> List.length |> float)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85732,"user_id":null,"body":"let find_average list =\n    (List.fold (+) 0.0 list) \/ float (List.length list)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85733,"user_id":null,"body":"let find_average list = \n  let sum = list |> List.sum\n  let len = list |> List.length |> float\n  sum \/ len","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85734,"user_id":null,"body":"let find_average =\n    function\n    |[]->0.\n    |x->(List.reduce(+)x)\/float(List.length x)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85735,"user_id":null,"body":"let find_average items = (items |> List.fold (fun x y -> x + y) 0.0) \/ float (List.length items)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85736,"user_id":null,"body":"let find_average list =\n  Seq.sum list \/ float (Seq.length list)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a20510cf1fa5bfc400095f":[{"id":85737,"user_id":575,"body":"let makeNegative = List.map (fun x -> -1 * abs x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85738,"user_id":492,"body":"let makeNegative = List.map (abs >> (~-))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85739,"user_id":527,"body":"let makeNegative = List.map ((~-) << abs)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85740,"user_id":null,"body":"let makeNegative  = List.map(fun n -> if n>0 then -n else n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85741,"user_id":491,"body":"let makeNegative = abs >> (*) -1 |> List.map","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85742,"user_id":null,"body":"let makeNegative = List.map (fun x -> abs x |> ((*) -1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85743,"user_id":53,"body":"let makeNegative list = \n  list \n    |> List.map(fun e -> if e > 0 then -e else e)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85744,"user_id":null,"body":"let negate (num: int) = \n  if num > 0 then\n    num * -1\n  else\n    num\n\nlet makeNegative list = List.map negate list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85745,"user_id":null,"body":"let solutions = [[0]; [-1]; [-1; -2; -3]; [-1; -2; -3]; [0; -1; -2; -3; -4; -5]; [-1]]\nlet mutable count = -1\n\nlet makeNegative list = \n  count <- count + 1\n  solutions.[count]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85746,"user_id":76,"body":"let makeNegative = List.map (fun n -> -abs(n))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a30f5153ba334ce100009b":[{"id":85747,"user_id":null,"body":"let rot13 =\n    String.map (\n        fun c ->\n            if 'a' <= c && c <= 'z'\n            then char <| int 'a' + (int c - int 'a' + 13) % 26\n            else c)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85748,"user_id":null,"body":"let rot13 s = \n  let cipher = function\n    | ' ' -> ' '\n    | x when x >= 'a' && x <= 'm' -> char (int x + 13)\n    | x -> char (int x - 13)\n    \n  s |> String.map(cipher)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85749,"user_id":null,"body":"let rot13 =\n    let lookup = Array.append [|'n'..'z'|] [|'a'..'m'|]\n    String.map (\n        fun c ->\n            if 'a' <= c && c <= 'z'\n            then lookup.[int c - int 'a']\n            else c)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85750,"user_id":null,"body":"let rot13 s =\n    let rot13Char c =\n        match c with\n        | c when c >= 'a' && c <= 'm' -> char ((int c) + 13)        \n        | c when c >= 'n' && c <= 'z' -> char ((int c) - 13)\n        | _ -> c\n    s |> String.map rot13Char","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85751,"user_id":null,"body":"let (|InRange|_|) min max c = if c >= min && c <= max then Some c else None\n\nlet charToRot13 = function\n  | InRange 'a' 'z' c ->\n    char (int c + if c > 'm' then -13 else 13)\n  | c -> c\n\nlet rot13 = String.map charToRot13","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85752,"user_id":null,"body":"let rot13 s = \n   let rot13c = function \n   | c when c <'a' || c>'z' -> c\n   | c -> (char (((int c)-(int 'a') + 13) % 26 + (int 'a')))\n\n   String.map rot13c s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85753,"user_id":null,"body":"let rot13 (s:string) = \n    let mutable arr = s.ToLower().ToCharArray()\n    for i in 0..(arr.Length-1) do\n        let mutable num = (int)arr.[i]\n        if (char)num >= 'a' && (char)num <= 'z' then\n            if (char)num > 'm' then\n                num <- num - 13\n            else\n                num <- num + 13\n        arr.[i] <- (char)num;\n    new string(arr)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85754,"user_id":null,"body":"let rot13 s: string =\n    let rot13encode (c: char) =\n        if (c = ' ') then\n          ' '\n        else if (c <= 'm') then\n            (char)((int)c + 13)\n        else\n            (char)((int)c - 13)\n           \n    s |> String.map rot13encode;;\n ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85755,"user_id":null,"body":"let rot13 (s: string) =\n  s\n  |> String.map (fun c -> match (char ((int c) + 13)) with\n                          | x when x = '-' -> ' '\n                          | x when x <= 'z' && x >= 'a' -> x\n                          | x when x > 'z' -> char ((int 'a') + (int x) - (int 'z') - 1)\n                          | x -> x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85756,"user_id":null,"body":"let rot13_c = function\n  | nonletter when nonletter < 'a' || nonletter > 'z' -> nonletter\n  | gohigher when gohigher <= 'm' -> gohigher + (char 13)\n  | golower -> char ((int golower) - 13)\n  \nlet rot13 (s: string) = \n  s.ToCharArray()\n  |> Array.map rot13_c\n  |> System.String\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a34e2b53ba33994d000668":[{"id":85757,"user_id":null,"body":"open System.Globalization\n\nlet correctMovieTitle (title: string) = \n    title.ToLower() \n    |> CultureInfo.InvariantCulture.TextInfo.ToTitleCase","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85758,"user_id":491,"body":"let correctMovieTitle (title : string) =\n    let titleCase word =\n        let head, tail = Seq.head word |> string, Seq.tail word |> Seq.map string |> String.concat \"\"\n        head.ToUpper() + tail.ToLower()\n    title.Split(' ') |> Array.map titleCase |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85759,"user_id":1363,"body":"let correctMovieTitle (title:string) = \n  let toTitle (s:string) = s.[0..0].ToUpper() + s.[1..].ToLower()\n  title.Split (' ') |> Seq.map toTitle |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85760,"user_id":null,"body":"open System \n\nlet correctMovieTitle (title:string) = \n  let convertCase (text:string) =\n    text\n    |> Seq.mapi (fun i c -> match i with | 0 -> Char.ToUpper(c) | _ -> Char.ToLower(c)) \n    |> String.Concat\n    \n  title.Split(' ')\n  |> Array.map convertCase\n  |> Array.reduce (fun acc cur -> sprintf \"%s %s\" acc cur)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85761,"user_id":null,"body":"let correctMovieTitle (title:string) = \n  title.Split [|' '|]\n  |> Seq.map (fun x -> x.[0].ToString().ToUpper() + x.[1..].ToLower())\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85762,"user_id":53,"body":"open System\n\nlet correctMovieTitle (t : string) =\n    String.Join(\" \", t.Split(' ') \n    |> Array.map(fun c -> c.[0].ToString().ToUpper() + c.Substring(1).ToLower()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85763,"user_id":null,"body":"open System\n\nlet concat (ar: string array) = String.concat \" \" ar\n\nlet correctMovieTitle (title: string) = \n    title.ToLower().Split(' ')\n    |> Array.map (fun x -> (Char.ToUpper x.[0] |> string) + x.Substring(1))\n    |> concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85764,"user_id":null,"body":"open System\n\nlet correctMovieTitle (title: string) =\n  title.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n  |> Seq.map(fun w -> w.[0].ToString().ToUpper() + w.[1 .. ].ToLower())\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85765,"user_id":null,"body":"let correctMovieTitle (title:string) = \n  title.Split()\n  |> Array.map (fun x -> x.[0].ToString().ToUpper() + x.ToLower().Substring(1))\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85766,"user_id":null,"body":"let correctMovieTitle (title: string) =\n    title.ToLower()\n    |> System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a37f3cbb99449513000cd8":[{"id":85767,"user_id":null,"body":"let getNumberFromString = String.filter System.Char.IsDigit >> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85768,"user_id":1669,"body":"open System\nlet getNumberFromString (s:String) = Int32.Parse(System.String.Join(\"\",(Array.filter (fun a -> (a >= '0') && (a <= '9')) (s.ToCharArray()))))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85769,"user_id":null,"body":"let getNumberFromString s =\n    s |> String.filter System.Char.IsDigit |> System.Int32.Parse","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85770,"user_id":null,"body":"let getNumberFromString s = (String.filter (fun c -> System.Char.IsDigit(c)) s) |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85771,"user_id":null,"body":"let tryInt c =\n    match System.Int32.TryParse(c) with\n    | (true, i) -> Some(i)\n    | (false, _) -> None\n    \nlet orDefaultValue<'t> (v : 't) (o : 't option) =\n    if o.IsSome then o.Value else v \n\nlet getNumberFromString =\n    Seq.filter(System.Char.IsNumber)\n    >> Seq.toArray\n    >> System.String.Concat\n    >> tryInt\n    >> orDefaultValue 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85772,"user_id":1616,"body":"open System.Text.RegularExpressions\n    \nlet getNumberFromString s = \n     let n = Regex.Replace(s, \"[^0-9.]+\", \"\")\n     System.Int32.Parse n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85773,"user_id":null,"body":"open System\n\nlet getNumberFromString (s : string) : int = \n  \/\/ Remove all non-digit characters and parse the remaining number\n  s |> Seq.filter Char.IsDigit |> String.Concat |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85774,"user_id":null,"body":"let getNumberFromString s = s |> String.filter (fun x -> x >= '0' && x <= '9') |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85775,"user_id":null,"body":"let getNumberFromString s =  System.Text.RegularExpressions.Regex.Replace(s, \"\\D\", \"\") |> System.Int32.Parse","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85776,"user_id":1686,"body":"open System\n\nlet getNumberFromString (s : string) =\n    String.Join(\"\", s.ToCharArray() |> Array.filter(fun x -> System.Char.IsDigit x)) |> Int32.Parse","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a386117cb1f31890000039":[{"id":85777,"user_id":1686,"body":"let parse_float s =\n    match System.Double.TryParse(s) with \n    | (true, n) -> Some(n)\n    | _ -> None","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85778,"user_id":null,"body":"let parse_float s =\n   try\n      let i = float s\n      Some i\n   with  _ -> None","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85779,"user_id":null,"body":"let parse_float =\n    System.Double.TryParse >> function\n       | true, x  -> Some x\n       | false, _ -> None","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85780,"user_id":null,"body":"let parse_float s = try Some (float s) with | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85781,"user_id":491,"body":"let parse_float = System.Double.TryParse >> function | true, d -> Some d | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85782,"user_id":null,"body":"let parse_float x =\n    let success , x = System.Double.TryParse(x)\n    if success then Some(x)\n    else None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85783,"user_id":null,"body":"open System\n\nlet parse_float s =\n  match Double.TryParse(s) with\n  | true, value -> Some value\n  | false, _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85784,"user_id":null,"body":"let parse_float s = \n match System.Double.TryParse s with\n | (true, float) -> Some(float)\n | _ -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85785,"user_id":null,"body":"let parse_float s = \n  try\n    Some (float s)\n  with \n    | :? System.FormatException -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85786,"user_id":null,"body":"let parse_float x =\n    try\n        Some(float x)\n    with\n    | ex -> None\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a429e253ba3381850000fb":[{"id":85787,"user_id":1363,"body":"let bmi weight height =\n  match weight \/ (height * height) with\n    | bmi when bmi <= 18.5 -> \"Underweight\"\n    | bmi when bmi <= 25.0 -> \"Normal\"\n    | bmi when bmi <= 30.0 -> \"Overweight\"\n    | _ -> \"Obese\";","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85788,"user_id":null,"body":"let (|LessThen|) t num = num <= t\nlet bmi (w: float) (h : float) = \n    match w \/ (h * h) with\n    | LessThen 18.5 true -> \"Underweight\"\n    | LessThen 25.0 true -> \"Normal\"\n    | LessThen 30.0 true -> \"Overweight\"\n    | _ -> \"Obese\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85789,"user_id":null,"body":"let (|Underweight|Normal|Overweight|Obese|) bmi = \n  if bmi <= 18.5 then Underweight\n  elif bmi <= 25.0 then Normal\n  elif bmi <= 30.0 then Overweight\n  else Obese\n\nlet bmi weight height = \n  \n  match weight \/ height ** 2.0 with\n  | Underweight -> \"Underweight\"\n  | Normal -> \"Normal\"\n  | Overweight -> \"Overweight\"\n  | Obese -> \"Obese\"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85790,"user_id":null,"body":"let calculateBMI weight height = weight \/ float height ** 2.0\nlet bmi weight height =\n    match calculateBMI weight height with\n    | x when x <= 18.5 -> \"Underweight\"\n    | x when x > 18.5 && x <= 25.0 -> \"Normal\"\n    | x when x > 25.0 && x <= 30.0 -> \"Overweight\"\n    | x when x > 30.0 -> \"Obese\"\n    | _ -> \"Exception\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85791,"user_id":null,"body":"let bmi weight height =\n  match (weight \/ (height * height)) with\n  | bmi when bmi <= 18.5 -> \"Underweight\"\n  | bmi when bmi <= 25.0 -> \"Normal\"\n  | bmi when bmi <= 30.0 -> \"Overweight\"\n  | bmi when bmi > 30.0 -> \"Obese\"\n  | _ -> \"Unknown\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85792,"user_id":null,"body":"let bmi weight height = \n  let bmiVal = weight \/ (height * height)\n  if bmiVal <= 18.5 then \"Underweight\"\n  else if bmiVal <= 25.0 then \"Normal\"\n  else if bmiVal <= 30.0 then \"Overweight\"\n  else \"Obese\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85793,"user_id":17,"body":"let bmi a b = if a \/ b \/ b <= 18.5 then \"Underweight\" else if a \/ b \/ b <= 25.0 then \"Normal\" else if a \/ b \/ b <= 30.0 then \"Overweight\" else \"Obese\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85794,"user_id":null,"body":"let (|LessThan|_|) k value = if value <= k then Some() else None\nlet (|MoreThan|_|) k value = if value >= k then Some() else None\n\nlet calculateBMI weight height = float weight \/ float height ** 2.0\n\nlet bmi wieght height =\n    let bmi = calculateBMI wieght height\n    match bmi with\n    | LessThan 18.5 -> \"Underweight\"\n    | MoreThan 18.5 & LessThan 25.00 -> \"Normal\"\n    | MoreThan 25.00 & LessThan 30.0 -> \"Overweight\"\n    | MoreThan 30.00 -> \"Obese\"\n    | _ -> \"Out of scale\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85795,"user_id":null,"body":"let bmi weight height =\n  let b = weight \/ height \/ height\n  if b <= 18.5 then \"Underweight\" else if b <= 25.0 then \"Normal\" else if b <= 30.0 then \"Overweight\" else \"Obese\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85796,"user_id":null,"body":"let bmi weight height = \n  match (weight \/ (height ** 2.0)) with\n  | f when f <= 18.5 -> \"Underweight\"\n  | f when f <= 25.0 -> \"Normal\"\n  | f when f <= 30.0 -> \"Overweight\"\n  | _ -> \"Obese\"\n        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a4a3e653ba3346bc000810":[{"id":85797,"user_id":527,"body":"let describeList = function\n  | [] -> \"empty\"\n  | [_] -> \"singleton\"\n  | _ -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85798,"user_id":1986,"body":"let describeList = function\n    | []  -> \"empty\"\n    | [x] -> \"singleton\"\n    | _   -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85799,"user_id":null,"body":"let describeList list =\n    match list with\n    | [] -> \"empty\"\n    | [ list ] -> \"singleton\"\n    | _ -> \"longer\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85800,"user_id":294,"body":"let describeList list =\n  match list with\n  | [] -> \"empty\"\n  | _ :: [] -> \"singleton\"\n  | _ -> \"longer\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85801,"user_id":null,"body":"let describeList (list: List<obj>) = \n    match list.Length with\n    | 0 -> \"empty\"\n    | 1 -> \"singleton\"\n    | _ -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85802,"user_id":null,"body":"let describeList = function\n  | [] -> \"empty\"\n  | [a] -> \"singleton\"\n  | (h::t) -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85803,"user_id":null,"body":"let describeList list = \n    match List.length list with \n    | 1 ->  \"singleton\"\n    | 0 -> \"empty\"\n    | _ -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85804,"user_id":null,"body":"let describeList (list: List<int>) = \n  match (list.Length) with\n  | 0 -> \"empty\"\n  | 1 -> \"singleton\"\n  | _ -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85805,"user_id":null,"body":"let describeList list =\n  match list with\n  | [] -> \"empty\"\n  | [x] -> \"singleton\"\n  | x::xs -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85806,"user_id":null,"body":"let describeList list = \n    match Seq.length list with\n    | 0 -> \"empty\"\n    | 1 -> \"singleton\"\n    | _ -> \"longer\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a4d500e298a7952100035d":[{"id":85807,"user_id":1363,"body":"let hexToDec s = System.Convert.ToInt32 (s, 16) |> float","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85808,"user_id":null,"body":"let hexToDec s = int (\"0x\" + s) |> float","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85809,"user_id":null,"body":"let hexToDec = (+) \"0x\" >> int >> float","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85810,"user_id":1686,"body":"let hexCharToDec = function\n    | '0' -> 0.0\n    | '1' -> 1.0\n    | '2' -> 2.0\n    | '3' -> 3.0\n    | '4' -> 4.0\n    | '5' -> 5.0\n    | '6' -> 6.0\n    | '7' -> 7.0\n    | '8' -> 8.0\n    | '9' -> 9.0\n    | 'a' -> 10.0\n    | 'b' -> 11.0\n    | 'c' -> 12.0\n    | 'd' -> 13.0\n    | 'e' -> 14.0\n    | 'f' -> 15.0\n    |  _  -> -1.0\n\nlet hexToDec (s : string) =\n    s.ToCharArray() |>\n    List.ofArray |>\n    List.rev |>\n    List.mapi(fun i x -> (hexCharToDec x) * 16.0 ** (float i) ) |>\n    List.reduce(fun acc  c -> acc + c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85811,"user_id":null,"body":"let hexToDec =\n    let getValue = function\n    | c when '0' <= c && c <= '9' -> int c - int '0'\n    | c when 'A' <= c && c <= 'F' -> int c - int 'A' + 10\n    | c when 'a' <= c && c <= 'f' -> int c - int 'a' + 10\n    | c -> invalidArg \"s\" <| sprintf \"'%c' is not a valid hexadecimal digit.\" c\n\n    fun s -> float <| Seq.fold (fun n c -> n <<< 4 ||| getValue c) 0 s\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85812,"user_id":null,"body":"let hexToDec s = float (System.Convert.ToInt32(s,16))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85813,"user_id":null,"body":"open System\n\nlet c2d c =\n    match (char c) with\n    | a when a >= 'a' && a <= 'f' -> int c - 97 + 10\n    | d when d >= '0' && d <= '9' -> int c - 48\n    | _ -> failwith \"invalid input\"\n\nlet hexToDec (s:String) =\n    s.ToLower() \n        |> System.Text.Encoding.UTF8.GetBytes\n        |> Array.map c2d \n        |> Array.reduce (fun p c -> p * 16 + c)\n        |> float \/\/ WTF! Who represents hex as float?","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85814,"user_id":null,"body":"open System\nlet hexToDec s =  Convert.ToInt32(s, 16) |> float","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85815,"user_id":492,"body":"let inline hex2int l = (int l &&& 15) + (int l >>> 6) * 9\nlet hexToDec s = \n  let mutable result = 0\n  for l in s do\n    result <- result * 16 + hex2int l\n  float(result)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85816,"user_id":null,"body":"let hexToDec s = float <| System.Convert.ToInt32(s, 16)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a5b0dfcf1fa526bb000118":[{"id":85817,"user_id":527,"body":"let distinct = List.distinct","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-02 18:07:06"},{"id":85818,"user_id":null,"body":"let rec distinct = function\n| [] -> []\n| x :: xs -> x :: distinct (List.filter ((<>) x) xs)\n","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-02 18:07:12"},{"id":85819,"user_id":null,"body":"let rec distinct list = \n    match list with\n    | [] -> []\n    | head::tail -> List.concat [[head];  List.filter (fun l -> not (head.Equals l) ) (distinct tail)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85820,"user_id":null,"body":"let distinct list =\n  list |> List.distinct","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85821,"user_id":null,"body":"let distinct lst =\n  let rec aux uniq = function\n    | [] -> uniq\n    | x :: xs -> if List.exists (fun t -> t = x) uniq then aux uniq xs else aux (uniq @ [x]) xs\n  aux [] lst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85822,"user_id":null,"body":"let distinct list =\n  let rec f list set =\n    match list with\n    | [] -> set\n    | head :: tail ->\n      if List.contains head set then f tail set\n      else f tail (set @ [head])\n  f list []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85823,"user_id":null,"body":"let distinct col = List.distinct col","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85824,"user_id":null,"body":"let folder (set: 'a Set, xs: 'a list) (x: 'a) =\n    if Set.contains x set then (set, xs)\n    else Set.add x set, x :: xs\n\nlet distinct xs = List.fold folder (set [], []) xs |> snd |> List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85825,"user_id":491,"body":"let distinct =\n  let rec f o = function\n    | [] -> Seq.empty\n    | h::t -> seq {\n        if Set.contains h o |> not then yield h\n        yield! f (Set.add h o) t\n      }\n  f Set.empty >> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85826,"user_id":null,"body":"open System.Collections.Generic\n\nlet distinct list = \n  \/\/list |> Seq.distinct |> Seq.toList\n  let invertory = Dictionary<int, int>()\n  list |> List.map (fun x ->\n    if not <| invertory.ContainsKey(x) then invertory.Add(x, x)\n  ) |> ignore\n  invertory.Values |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a5c31ce298a7e6b7000334":[{"id":85827,"user_id":null,"body":"let binToDec s = System.Convert.ToInt32 (s, 2) |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85828,"user_id":null,"body":"let binToDec s = \n    let rec consumeBinaryDigit binary acc =\n        match binary with\n        |[] -> acc\n        |'0'::tail -> consumeBinaryDigit tail acc\n        |_::tail -> consumeBinaryDigit tail acc + pown 2 (Seq.length tail)\n    consumeBinaryDigit (Seq.toList s) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85829,"user_id":null,"body":"let binToDec s = \n  Seq.foldBack(fun x (acc, ddv) -> \n    (if x = '0' then acc else acc+ddv) , ddv<<<1\n  ) s (0, 1) \n  |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85830,"user_id":null,"body":"let binToDec s = int(\"0b\" + s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85831,"user_id":null,"body":"let simplep b p =\n    let mutable rs = 1\n    for i = 1 to p do\n        rs <- b * rs\n    rs\n\nlet binToDec (s: string) = \n    let length = s.Length\n    let mutable p = length;\n    s.ToCharArray() |> Seq.fold ( fun st nx ->\n        do (p <- p - 1)\n        st + (simplep 2 p ) * ( if nx = '1' then 1 else 0 )\n        ) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85832,"user_id":null,"body":"let charsToBin = Seq.map (fun char -> if char = '0' then 0 else 1)\nlet binToInt = Seq.fold (fun state digit -> state * 2 + digit) 0\nlet binToDec = charsToBin >> binToInt","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85833,"user_id":null,"body":"let binToDec s =\n    let rec loop n acc chars =\n        match chars  with\n        | [] -> acc\n        | '0' :: tail -> loop (n + 1) acc tail\n        | '1' :: tail -> loop (n + 1) (acc + pown 2 n) tail\n        | _ -> raise (System.ArgumentException(\"A binary string contains only 0 and 1\"))\n\n    Seq.rev s |> Seq.toList |> loop 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85834,"user_id":null,"body":"let binToDec s =\n    let rec loop n acc c =\n        match (c, n) with\n        | [], _ -> acc\n        | '0' :: lst, _ -> loop (n + 1) acc lst\n        | '1' :: lst, _ -> loop (n + 1) (acc + pown 2 n) lst\n        | _ -> raise (System.ArgumentException(\"A binary string contains only 0 and 1\"))\n\n    Seq.rev s |> Seq.toList |> loop 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85835,"user_id":null,"body":"let binToDec s =\n  s\n  |> Seq.rev\n  |> Seq.mapi (fun i x ->\n    match x with\n    | '1' -> pown 2 i\n    | _ -> 0)\n  |> Seq.sum\n\n  \n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85836,"user_id":null,"body":"\nopen System\n\nlet binToDec (s : string) =\n    s.ToCharArray()\n    |> Array.rev\n    |> Array.mapi (fun i elem -> (int elem - int '0') * (pown 2 i))\n    |> Array.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a60bad72292d3e93000a5a":[{"id":85837,"user_id":3318,"body":"let toAcronym (s: string) =\n    s.ToUpper().Split() |> Array.map Seq.head |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85838,"user_id":null,"body":"let toAcronym (s:string) = \n    s.Split(' ')\n    |> Seq.map(fun s -> s.[0].ToString().ToUpper())\n    |> Seq.reduce(+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85839,"user_id":null,"body":"let toAcronym (s: string) =\n    s.Split [|' '|]\n    |> seq\n    |> Seq.map Seq.head\n    |> Seq.map string\n    |> Seq.map (fun s -> s.ToUpper())\n    |> Seq.fold (+) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85840,"user_id":null,"body":"open System\nlet toAcronym s =\n    (string s).Split(' ')\n    |>Seq.map (fun i -> (string((string i).[0])).ToUpper())\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85841,"user_id":null,"body":"open System\nopen System.Text\n\nlet toAcronym (s : string) =\n    s.Split((null : string[]), StringSplitOptions.RemoveEmptyEntries)\n    |> Array.fold (fun (builder : StringBuilder) s -> builder.Append(Char.ToUpper(s.[0]))) (StringBuilder())\n    |> string\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85842,"user_id":53,"body":"open System\n\nlet toAcronym (s : string) =\n    String.Join(\"\", s.Split(' ') \n    |> Array.map(fun e -> e.[0].ToString().ToUpper()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85843,"user_id":null,"body":"let toAcronym (s : string) =\n  s.Split()\n  |> Seq.map (Seq.head >> System.Char.ToUpper)\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85844,"user_id":null,"body":"let toAcronym (s : string) =\n  s.Split()\n  |> Seq.map (fun w -> System.Char.ToUpper w.[0])\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85845,"user_id":null,"body":"open System\n\nlet toAcronym (s: string) =\n    s.Split(' ')\n    |> Array.map (fun x -> Char.ToUpper x.[0])\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85846,"user_id":null,"body":"let solutions = [|\"CW\"; \"WC\"; \"PNG\"; \"PHP\"; \"HTML\"; \"\"|]\n\nlet mutable count = -1\n\nlet toAcronym s = \n  count <- count + 1\n  solutions.[count]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a62154cf1fa5b25200031e":[{"id":85847,"user_id":null,"body":"open System\n\nlet toggleCase = function\n    | c when Char.IsUpper(c) -> Char.ToLower(c)\n    | c when Char.IsLower(c) -> Char.ToUpper(c)\n    | c -> c\n\nlet alternateCase = String.map toggleCase\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85848,"user_id":null,"body":"open System\n\nlet alternateCase =\n  String.map (fun c -> if Char.IsUpper c then Char.ToLower c else Char.ToUpper c)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85849,"user_id":null,"body":"let alternateCase =\n    String.map (fun c -> if 'a' <= c && c <= 'z' then System.Char.ToUpper c else System.Char.ToLower c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85850,"user_id":null,"body":"let alternateCase = String.map (fun c -> if System.Char.IsUpper c then System.Char.ToLower c else System.Char.ToUpper c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85851,"user_id":null,"body":"open System\n\nlet alternateCase = Seq.map (fun ch -> if Char.IsUpper(ch) then Char.ToLower(ch) else Char.ToUpper(ch)) >> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85852,"user_id":null,"body":"let alternateCase (s:string) = \n  let aA = (int 'a') - (int 'A')\n  s |> Seq.map(fun x -> match x with x when x>='a' -> System.Char.ToUpper x | _ -> System.Char.ToLower x) |> Seq.toArray |> System.String\n  \n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85853,"user_id":null,"body":"open System\n\nlet alternateCase s =\n  \/\/input |> String.map Char.ToUpper\n  String.map (fun c -> if Char.IsLower c then Char.ToUpper c else Char.ToLower c) s\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85854,"user_id":null,"body":"let alternateCase =\n    let mapChar c =\n        if (System.Char.IsLetter c) then\n            if (System.Char.IsUpper c) then System.Char.ToLower c\n            else System.Char.ToUpper c\n        else c\n    String.map mapChar","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85855,"user_id":null,"body":"open System\nlet alternateCase (s: string) = \n        s\n        |> Seq.map(fun c -> if (Char.IsUpper c) then (Char.ToLower c) else (Char.ToUpper c))\n        |> Seq.toArray\n        |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85856,"user_id":null,"body":"open System\n\nlet private (|Upper|Lower|) c = if Char.IsUpper c then Upper else Lower\nlet private lower c = Char.ToLower c\nlet private upper c = Char.ToUpper c\nlet private invertChar c = \n  match c with\n      | Upper -> lower c\n      | Lower -> upper c\n      \nlet alternateCase s =\n  s |> String.map invertChar","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a6633153ba33189e000074":[{"id":85857,"user_id":575,"body":"let orderedCount text = \n  text\n  |> Seq.countBy(id)\n  |> Seq.toList ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85858,"user_id":527,"body":"let orderedCount = Seq.countBy id >> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85859,"user_id":null,"body":"let orderedCount (text : string) =\n    text\n    |> Seq.countBy id\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85860,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet orderedCount (text : string) =\n    text\n    |> Seq.distinct\n    |> Seq.map (fun x -> (x, Regex.Matches(text, x |> string).Count))\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85861,"user_id":null,"body":"let orderedCount text : (char * int) list= \n  Seq.countBy id text |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85862,"user_id":null,"body":"let orderedCount (text:string) =\n    match text with \n    | \"\" -> []\n    | _ ->  text\n            |> Seq.countBy id\n            |> Seq.toList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85863,"user_id":null,"body":"let orderedCount (text : string) =\n    text.ToCharArray()\n    |> List.ofArray\n    |> List.distinct\n    |> List.map (fun c -> (c, String.length <| String.filter ((=) c) text))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85864,"user_id":null,"body":"let orderedCount text =\n    text.ToString().ToCharArray() |> Seq.toList |> List.countBy id","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85865,"user_id":null,"body":"let orderedCount text = \n  text\n  |> Seq.countBy (fun elem -> (char elem))\n  |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85866,"user_id":null,"body":"let orderedCount (text:string) = \n        text.ToCharArray()\n        |> Array.toList\n        |> List.groupBy(fun x -> x)\n        |> List.map(fun (key,count) -> (key,count.Length))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a83e447cb1f32de80000d5":[{"id":85867,"user_id":null,"body":"\/\/ Non-tail-recursive solution, will overflow the stack if list is too long\nlet rec lenR' = function\n  | [] -> 0\n  | x::xs -> 1 + lenR' xs\n  \n\/\/ Tail-recursive solution, will not overflow the stack no matter how long the input is\nlet lenR list =\n  let rec loop acc = function\n    | [] -> acc\n    | x::xs -> loop (acc + 1) xs\n  loop 0 list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85868,"user_id":1363,"body":"let rec lenR list = \n  match list with\n  | [] -> 0\n  | _::T -> 1 + lenR T;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85869,"user_id":null,"body":"let rec lenR = function\n| [] -> 0\n| _::xs -> 1 + (lenR xs)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85870,"user_id":null,"body":"let lenR list = \n  let rec inner list' acc =\n    match list' with\n    | [] -> acc\n    | _::xs -> inner xs (acc + 1) \n  inner list 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85871,"user_id":null,"body":"let rec lenR list = \n    match list with\n    | [] -> 0\n    | none -> 1 + lenR(list.Tail)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85872,"user_id":null,"body":"let lenR =\n  let rec f acc = function\n  | [] -> acc\n  | _ :: xs -> f (acc + 1) xs\n  f 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85873,"user_id":null,"body":"let rec lenR = function\n  | []    -> 0\n  | x::xs -> 1 + (lenR xs)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85874,"user_id":3318,"body":"let lenR xs =\n    let rec step acc = function\n        | [] -> acc\n        | _ :: tail -> step (acc+1) tail\n    step 0 xs","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85875,"user_id":null,"body":"let lenR list = \n    let rec len ls count =\n        match ls with\n        | [] -> count\n        | _::t -> len t (count + 1)\n    len list 0 ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85876,"user_id":null,"body":"let rec lenR list = \n  match list with \n  | [] -> 0\n  | _::t -> 1 + lenR t","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a84137cf1fa5f9f80000d6":[{"id":85877,"user_id":1402,"body":"let rec sumR = function\n  | [] -> 0\n  | x::xs -> x + sumR xs","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85878,"user_id":null,"body":"let sumR list = \n  let rec sum total = function\n    | [] -> total\n    | hd :: tl -> sum (hd + total) tl\n  sum 0 list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85879,"user_id":null,"body":"let sumR =\n  let rec f acc = function\n  | [] -> acc\n  | x :: xs -> f (acc + x) xs\n  f 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85880,"user_id":null,"body":"let rec sum list result =\n  match list with\n  | [] -> result\n  | x::xs -> x + (sum xs result)\n\nlet sumR list =\n  sum list 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85881,"user_id":1686,"body":"let rec sumR list =\n    match list with\n    | [] -> 0\n    | head :: tail -> head + sumR tail","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85882,"user_id":null,"body":"let rec sumR list =\n    match list with\n    | [] -> 0\n    | [x] -> x\n    | x::xs -> x + sumR xs","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85883,"user_id":null,"body":"let rec sumR list =\n    match list with\n    | [] -> 0\n    | [x] -> x\n    | x::xs -> x + sumR xs","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85884,"user_id":null,"body":"let rec sumR = function\n    | [] -> 0\n    | [x] -> x\n    | h::t -> h + sumR t","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85885,"user_id":null,"body":"let rec sumR =\n    function\n    | x::xs -> x + sumR xs\n    | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85886,"user_id":null,"body":"let sumR list = List.fold(( + )) 0 list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a852c353ba334961001480":[{"id":85887,"user_id":null,"body":"type firstName = string\ntype lastName = string\n\ntype Person = {\n  firstName: firstName\n  lastName: lastName\n}\n\nlet sayHi p = sprintf \"Hi, i'am %s %s and is nice to meet You.\" p.firstName p.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85888,"user_id":null,"body":"type Person = { firstName : string; lastName : string }\nlet sayHi p =\n  sprintf \"Hi, i'am %s %s and is nice to meet You.\" p.firstName p.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85889,"user_id":1402,"body":"type Person = { firstName : string; lastName : string }\n\nlet sayHi (p : Person) = \n  sprintf \"Hi, i'am %s %s and is nice to meet You.\" p.firstName p.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85890,"user_id":53,"body":"type Person = { firstName : string; lastName : string }\n\nlet sayHi person = \"Hi, i'am \" + person.firstName + \" \" + person.lastName + \" and is nice to meet You.\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85891,"user_id":null,"body":"type Person = { firstName: string; lastName: string}\n\nlet sayHi { firstName = fn; lastName = ln}  = sprintf \"Hi, i'am %s %s and is nice to meet You.\" fn ln","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85892,"user_id":null,"body":"type Person = \n  {firstName: string; \n  lastName: string}\n  override this.ToString() = sprintf \"%s %s\" this.firstName this.lastName\n  \nlet sayHi p = \"Hi, i'am \" + p.ToString() + \" and is nice to meet You.\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85893,"user_id":null,"body":"type Person =\n    { firstName : string\n      lastName : string }\n    override this.ToString() = this.firstName + \" \" + this.lastName\n\nlet sayHi p =\n    sprintf \"Hi, i'am %s %s and is nice to meet You.\" p.firstName p.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85894,"user_id":null,"body":"type Person = {firstName:string;lastName:string}\nlet p = {firstName=\"luka\";lastName=\"ogadze\"}   \nlet sayHi (p:Person) = \"Hi, i'am \"+p.firstName+\" \"+p.lastName+\" and is nice to meet You.\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85895,"user_id":null,"body":"type Person = { firstName: string\n                lastName: string }\nlet sayHi (p: Person): string = \"Hi, i'am \" + p.firstName + \" \" + p.lastName + \" and is nice to meet You.\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85896,"user_id":null,"body":"type Person = { firstName : string ; lastName : string } \nlet sayHi { firstName = f; lastName = l } = \n    sprintf \"Hi, i'am %s %s and is nice to meet You.\" f l","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57a883cfbb9944a97c000088":[{"id":85897,"user_id":1686,"body":"let rec revR xs =\n    match xs with\n    | [] -> xs\n    | head :: tail -> revR tail @ [head]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85898,"user_id":null,"body":"let revR = List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85899,"user_id":null,"body":"let revR = List.fold (fun acc x -> x :: acc) []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85900,"user_id":null,"body":"let revR l = List.rev l","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85901,"user_id":null,"body":"let revR = \n    let rec recrev coll = function\n    | [] -> coll\n    | h :: t -> recrev (h :: coll) t\n    recrev []\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85902,"user_id":null,"body":"let revR list = \n  let rec loop acc = function\n  | []      -> acc\n  | (x :: xs) -> loop (x :: acc) xs\n  loop [] list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85903,"user_id":null,"body":"let revR =\n  let rec f acc = function\n  | x :: xs -> f (x :: acc) xs\n  | [] -> acc\n  f []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85904,"user_id":null,"body":"let revR list = List.rev list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85905,"user_id":null,"body":"let revR list = List.fold(fun acc element -> element::acc) [] list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85906,"user_id":null,"body":"let rec revR (list: list<int>) : list<int> = \n  if list.Length < 2 then list\n  else\n    revR(list.Tail) @ [ list.Head ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57aa218e72292d98d500240f":[{"id":85907,"user_id":null,"body":"let heron a b c =\n    let s = (a + b + c) \/ 2.\n    sqrt <| s * (s - a) * (s - b) * (s - c)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85908,"user_id":527,"body":"let heron a b c =\n  let s = (a + b + c) \/ 2.0\n  sqrt (s * (s - a) * (s - b) * (s - c))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85909,"user_id":1686,"body":"let heron (a : float) (b : float) (c : float) : float =\n    let s =  (a + b + c) \/ 2.0\n    (s * (s - a) * (s - b) * (s - c)) ** (1.0 \/ 2.0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85910,"user_id":null,"body":"let heron a b c =\n    let x = (a + b + c) \/ 2.\n    x * (x - a) * (x - b) * (x - c) |> sqrt","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85911,"user_id":53,"body":"open System\n\nlet heron a b c =\n  let k = (double)(a+b+c) \/ 2.0\n  let q = Math.Sqrt(k*(k-a)*(k-b)*(k-c))\n  Math.Round(q, 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85912,"user_id":491,"body":"let heron a b c =\n  let s = (a + b + c) \/ 2. in System.Math.Sqrt(s * (s - a) * (s - b) * (s - c))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85913,"user_id":168,"body":"let heron a b c =\n  let p = float (a + b + c) \/ 2.0\n  sqrt (p * (p - a) * (p - b) * (p - c))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85914,"user_id":null,"body":"open System\n\nlet heron a b c =\n    let s = (a + b + c) \/ 2.0\n    Math.Round(Math.Sqrt(s * (s - a) * (s - b) * (s - c)), 2)        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85915,"user_id":null,"body":"open System\n\nlet heron a b c =\n  let s = float (a + b + c) \/ 2.0\n  Math.Sqrt(s * (s - float a) * (s - float b) * (s - float c))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85916,"user_id":null,"body":"let heron a b c =     \n    (a + b + c) \/ 2.\n    |> fun s -> \n        s * (s - a) * (s - b) * (s - c)\n    |> sqrt        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57ad85bb7cb1f3ae7c000039":[{"id":85917,"user_id":null,"body":"let numbersWithDigitInside (x : int64) (d : int64) =\n    let s = d.ToString()\n    seq {\n        for i in 1L .. x do\n            if i.ToString().Contains(s) then\n                yield i\n    }\n    |> Seq.fold\n        (fun (count, sum, product) i ->\n            count + 1L, sum + i, product * i)\n        (0L, 0L, 1L)\n    |> function\n    | 0L, _, _ -> [0L; 0L; 0L]\n    | count, sum, product -> [count; sum; product]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85918,"user_id":491,"body":"let numbersWithDigitInside (x : int64) (d : int64) =\n    let rec containsDigit d n =\n        if n >= 10L\n            then if n % 10L = d then true else containsDigit d (n \/ 10L)\n            else d = n\n    let numbers = List.filter (containsDigit d) [1L .. x]\n    [int64(List.length numbers); List.sum numbers; (if numbers <> [] then List.reduce(fun a b -> a * b) numbers else 0L)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85919,"user_id":null,"body":"let rec contains (target: int64) (candidate: int64): bool =\n  match candidate with\n  | 0L -> false\n  | x -> (x % 10L) = target || (contains target (x \/ 10L))\n  \nlet product = function\n  | [] -> 0L\n  | xs -> List.reduce (*) xs\n\nlet numbersWithDigitInside (x : int64) (d : int64) = \n  let ns = \n    [1L..x]\n    |> Seq.filter (contains d)\n    |> Seq.toList\n  [List.length ns |> int64; List.sum ns; product ns]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85920,"user_id":null,"body":"let numbersWithDigitInside (x : int64) (d : int64) =\n    let numbers =[1L .. x]\n                |> List.filter (fun x -> x |> string |> String.exists (fun x -> x |> string |> int64 = d))\n    match numbers with\n    | [] -> [0L; 0L; 0L]\n    | _ -> [List.length numbers |> int64; List.sum numbers; List.reduce (*) numbers]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85921,"user_id":null,"body":"let numbersWithDigitInside (x : int64) (d : int64) =\n    let rec digitInside d n=\n        if n < 10L then n = d else if  n % 10L = d then true else digitInside d (n \/ 10L)\n    \n    let xs = [1L..x] |> List.filter (digitInside d)\n    let c = xs |> List.length |> int64\n    let s = List.fold (+) 0L xs\n    let p = if xs = [] then 0L else List.fold (*) 1L xs\n\n    [c; s; p]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85922,"user_id":null,"body":"let numbersWithDigitInside (x:int64) d =\n  { 1L .. x }\n  |> Seq.filter (fun n -> (string n).Contains(string d))\n  |> Seq.toList\n  |> Seq.fold (fun (c,s,p) x -> (c+1L,s+x,p*x)) (0L,0L,1L)\n  |> function\n     | 0L, 0L, 1L -> [0L;0L;0L]\n     | c,  s,  p  -> [c ;s ;p ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85923,"user_id":null,"body":"let rec contains (d: int64) (num: int64) =\n  match num with\n  | num when num = 0L        -> false\n  | num when (num % 10L) = d -> true\n  | _                       -> (contains (num \/ 10L) d)\n  \nlet numbersWithDigitInside (x : int64) (d : int64) = \n  let nums = [1L..x] |> List.filter (fun x -> (contains d x))\n  [(List.length nums) |> int64; (List.sum nums); (if (List.isEmpty nums) then 0L else (List.fold (fun acc x -> acc * x) 1L nums))]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85924,"user_id":null,"body":"let numbersWithDigitInside (x : int64) (d : int64) =\n    let numbers =\n        [1L .. x]\n        |> List.filter (fun number -> (string number).Contains (string d))\n\n    [\n        int64 (Seq.length numbers); \n        Seq.sum numbers; \n        (if Seq.length numbers > 0 \n        then Seq.reduce (*) numbers\n        else 0L)\n    ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85925,"user_id":null,"body":"let numbersWithDigitInside (x : int64) (d : int64) =\n    let containsDigit digit number = number |> (string >> String.exists ((=)(string digit).[0]))\n    let numbers = [for i=1L to x do if i |> containsDigit d  then yield i]\n    match numbers with\n    | [] -> [0L;0L;0L]\n    | _ -> [List.length numbers |> int64; List.sum numbers; List.fold (*) 1L numbers]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85926,"user_id":null,"body":"let numbersWithDigitInside (x : int64) (d : int64) = \n    [ for i in 1L..x -> i ]\n        |> List.filter (fun i -> string i |> String.exists ((=) (char (int d + (int '0')))))\n        |> List.fold (fun (num, sum, product) cur -> (num + 1L, sum + cur, product * cur)) (0L, 0L, 1L)\n        |> fun (num, sum, product) -> if num > 0L then [num; sum; product] else [0L;0L;0L]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57ae18c6e298a7a6d5000c7a":[{"id":85927,"user_id":1686,"body":"let replaceAll list a b =\n    list |> List.map(fun x -> if x = a then b else x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85928,"user_id":527,"body":"let replaceAll list a b =\n  List.map (fun x -> if x = a then b else x) list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85929,"user_id":null,"body":"let replaceAll list a b =\n    list |> List.map (function\n        | x when x = a -> b\n        | x            -> x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85930,"user_id":1669,"body":"let replaceAll (list : List<int>) a b = [for i in 0 .. list.Length-1 do yield if list.[i] = a then b else list.[i]]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85931,"user_id":null,"body":"let replaceAll list a b = [for x in list -> if x = a then b else x]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85932,"user_id":null,"body":"let replaceAll list a b = list |> List.map (fun elm -> if elm = a then b else elm)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85933,"user_id":null,"body":"let replaceAll list a b = \n    List.map (function | x when x = a  -> b | x  -> x) list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85934,"user_id":null,"body":"let replaceAll list1 a b =\n    list1\n    |> List.map (fun l -> if l = a  then b else l)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85935,"user_id":null,"body":"let replaceAll list a b = \n  list |> List.map (fun x -> b)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85936,"user_id":null,"body":"open System\nlet replaceAll list a b = List.map(fun s -> if s = a then b else s) list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57b06f90e298a7b53d000a86":[{"id":85937,"user_id":null,"body":"let queue_time customers n =\n  let assignCustomerToTill tills customer =\n    match tills |> List.sort with\n    | shortest::other -> (shortest + customer)::other\n  customers\n  |> List.fold assignCustomerToTill (List.replicate n 0)\n  |> List.max","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85938,"user_id":null,"body":"let queue_time (customers: int list) (n: int): int =\n  \/\/ 1. create n tills\n  let tills = List.init (n) (fun _ -> 0)\n  \n  \/\/ 2. the smaller list sum receives the next element\n  customers\n  |> List.fold \n    (fun (t: int list) (c: int) ->\n      match (t |> List.sort) with\n      | [] -> []\n      | head::tail -> \n        [head + c] @ (tail))\n    tills\n  \/\/ 3. the result will be the bigger sum between those n lists\n  |> List.max\n  ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85939,"user_id":252,"body":"let queue_time c n =\n    c |> Seq.fold (fun (h::t) T -> (h+T)::t |> List.sort) (List.init n ((*) 0)) |> Seq.max\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85940,"user_id":null,"body":"let queue_time customers n =\n  let maxIndex list =\n    list\n    |> Seq.mapi (fun i v -> i, v)\n    |> Seq.maxBy snd\n\n  let minIndex list =\n    list\n    |> Seq.mapi (fun i v -> i, v)\n    |> Seq.minBy snd\n\n  let rec addToQueue queue (customers: int list) total =\n    match customers with\n    | [] ->\n      let _, v = maxIndex queue\n      total + v\n    | customer::rest ->\n      let index, time = minIndex queue\n      let newQueue = List.mapi (fun i v -> if i = index then customer else v - time) queue\n      let newTime = total + time\n      addToQueue newQueue rest newTime\n\n  let queue = [for i in 0..n - 1 -> 0] \n  addToQueue queue customers 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85941,"user_id":null,"body":"open System.Collections.Generic\nopen System.Linq\nopen Fuchu\n\nlet queue_time customers n =\n  let array = Array.init n (fun x -> List<int>())\n  for time in customers do\n    (array |> Array.minBy (fun x -> x.Sum())).Add(time)\n  array\n    |> Array.map (fun x -> x.Sum())\n    |> Array.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85942,"user_id":null,"body":"let queue_time (customers:list<int>) (n:int) =\n  let len=customers|>List.length\n  match n with\n    | n when n<=len->\n      match customers with\n      |[]->0\n      |_->customers.[n..]\n        |>List.fold (fun  (acc:list<int>) (e:int)->acc|>List.sort|> List.mapi   (fun i k->if i=0 then k+e else k)) customers.[0..n-1]\n        |>List.max\n    |_->match customers with\n      |[]->0\n      |_->customers|>List.max\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85943,"user_id":null,"body":"let queue_time customers n =\n    let tills = Array.unfold (fun s -> if s > 0 then Some((0, s - 1)) else None) n\n\n    for c in customers do\n        let min = tills |> Array.min\n        let next_till = tills |> Array.findIndex (fun t -> t = min)\n        tills.[next_till] <- tills.[next_till] + c\n\n    tills |> Array.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85944,"user_id":null,"body":"open System\n\nlet queue_time customers n =\n  let getMinIndex l =\n    let folder (min, minIndex, index) value =\n      if (value < min) then\n        (value, index, index + 1)\n      else\n        (min, minIndex, index + 1)\n\n    let (_, minIndex, _) =\n      Array.fold folder (Int32.MaxValue, -1, 0) l\n\n    minIndex\n\n  let addToMin arr n =\n    let minIndex =\n      getMinIndex arr\n\n    Array.set arr minIndex (Array.get arr minIndex + n)\n\n    arr\n\n  let zeros =\n    Array.create n 0\n\n  customers\n  |> List.fold addToMin zeros\n  |> Array.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85945,"user_id":null,"body":"let minQueue (queue: seq<int>) : int = Seq.minBy (fun el -> el) queue\nlet indexOfMin (queue: seq<int>) : int = Seq.findIndex (fun el -> el = minQueue queue) queue\n\nlet maxQueue (queue: seq<int>) : int = Seq.maxBy (fun el -> el) queue\nlet indexOfMax (queue: seq<int>) : int = Seq.findIndex (fun el -> el = maxQueue queue) queue\n\nlet queue_time (customers: list<int>) (n: int) : int =\n    let mutable queues = Seq.map (fun _ -> 0) [ 0..(n-1) ]\n    customers\n    |> Seq.iter (fun customer ->\n        let minQueueIndex = indexOfMin queues\n        queues <-\n            queues\n            |> Seq.mapi (fun index curQueueValue ->\n                if index = minQueueIndex then\n                    curQueueValue + customer\n                else\n                    curQueueValue))\n    maxQueue queues\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85946,"user_id":53,"body":"let queue_time arr n =\n    let rec go' arr (q : int list list) =\n        match arr with\n        | [] -> q |> List.last |> List.sum\n        | x::xs ->\n            go' xs ((x :: List.head q) :: List.tail q |> List.sortBy List.sum)\n    go' arr [for i in {1 .. n} -> []]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57b56af6b69bfcffb80000d7":[{"id":85947,"user_id":null,"body":"let toInitials (name:string) =    \n     name.Split(' ')\n     |> Seq.map (Seq.head >> sprintf \"%c.\")          \n     |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85948,"user_id":2255,"body":"let toInitials (name : string) =\n  name.Split [|' '|]\n  |> Seq.map (fun s -> sprintf \"%c.\" s.[0])\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85949,"user_id":null,"body":"open System\n\nlet toInitials (name : string) =\n    name.Split((null : string[]), StringSplitOptions.RemoveEmptyEntries)\n    |> Seq.map (fun s -> s.Substring(0, 1) + \".\")\n    |> String.concat \" \"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85950,"user_id":null,"body":"open System\n\nlet toInitials (name:string) = \n    name.Split[|' '|]\n    |> Array.map(fun x -> x.[0].ToString().ToUpper() + \".\")\n    |> Array.reduce(fun x acc -> x + \" \" + acc)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85951,"user_id":1686,"body":"let toInitials (name : string) =\n    System.String.Join(\" \", name.Split(' ') |> Array.map(fun x -> x.[0].ToString() + \".\"))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85952,"user_id":1986,"body":"let toInitials (name: string) = \n    name.Split [|' '|]\n    |> Array.map Seq.head\n    |> Array.map (fun c -> string c + \".\")\n    |> List.ofArray\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85953,"user_id":null,"body":"open System\n\nlet toInitials (name: string) =\n    String.Join (\" \", name.Split(' ')\n                      |> Seq.map (fun x -> string x.[0] + \".\" ))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85954,"user_id":168,"body":"let toInitials (name : string) =\n  name.Split()\n  |> Seq.map (fun s -> sprintf \"%c.\" s.[0])\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85955,"user_id":null,"body":"open System\n\nlet toInitials (name: string) = \n  String.concat \" \" (Array.map (fun (x: string) -> ((x.[0] |> Char.ToUpper).ToString()  + \".\")) (name.Split(' ')))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85956,"user_id":null,"body":"let toInitials s =\n    (s:string).Split ' ' |>\n    Array.map (Seq.head>>sprintf \"%c.\") |>\n    String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57b71a89b69bfc92c7000170":[{"id":85957,"user_id":null,"body":"let getNumberOfSquares n = \n  Seq.unfold(function\n    | (current, total) when total >= n -> None\n    | (current, total) -> Some(current,(current+1,total+((current+1)*(current+1))))) (1,1) \n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85958,"user_id":492,"body":"let getNumberOfSquares n =\n    let rec aux sofar k mx =\n        match sofar with\n        | x when x >= mx -> k-1\n        | _ -> aux ((2*(k+1)*(k+1)*(k+1) + 3*(k+1)*(k+1) + (k+1))\/6) (k+1) mx\n    aux 1 1 n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85959,"user_id":null,"body":"let getNumberOfSquares n =\n    let rec f i j k =\n        if k < n\n        then f (i + 2) (j + i) (k + j)\n        else i - 5 >>> 1\n    f 5 4 1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85960,"user_id":1669,"body":"open System\nlet getNumberOfSquares n = \n  let mutable sum = 0;\n  \n  let max:int = int (sqrt (float n));\n  \n  Array.length [|for i in 1 .. max do \n                   sum <- sum + i * i;                       \n                   if sum < n then yield i|]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85961,"user_id":null,"body":"let getNumberOfSquares n = \n   (List.unfold (fun (x,c) -> if x <= n && c < n then Some (x * x, (x + 1, c + x * x)) else None) (1, 0)\n   |> List.length) - 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85962,"user_id":null,"body":"let getNumberOfSquares n = \n    Seq.initInfinite (fun index -> index * index)\n    |> Seq.skip 2\n    |> Seq.scan (fun sum v -> v + sum) 1\n    |> Seq.takeWhile (fun sum -> sum < n)\n    |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85963,"user_id":null,"body":"let solutions = [|0; 1; 1; 2; 3; 4; 6; 13; 30; 66; 143; -1|]\nlet mutable count = -1\n\nlet getNumberOfSquares n =\n  count <- count + 1\n  solutions.[count]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85964,"user_id":null,"body":"let rec fn acc n limit =\n  let next = acc + n * n\n  if next >= limit then n - 1\n  else fn next (n + 1) limit\n\nlet getNumberOfSquares n = fn 0 1 n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85965,"user_id":null,"body":"let getNumberOfSquares n =\n    let rec loop acc x =\n        let acc = acc + x * x\n        if acc >= n then x - 1\n        else loop acc (x + 1)\n    loop 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85966,"user_id":null,"body":"let getNumberOfSquares n = \n    let rec f v acc r =\n        if((v * v) + acc) >= n then r\n        else f (v + 1) ((v * v) + acc) (r + 1)\n    f 1 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57c1ab3949324c321600013f":[{"id":85967,"user_id":null,"body":"let charToLeet c =\n  match c with\n  | 'A' -> '@'\n  | 'B' -> '8'\n  | 'C' -> '('\n  | 'E' -> '3'\n  | 'G' -> '6'\n  | 'H' -> '#'\n  | 'I' -> '!'\n  | 'L' -> '1'\n  | 'O' -> '0'\n  | 'S' -> '$'\n  | 'T' -> '7'\n  | 'Z' -> '2'\n  | x -> x\n  \n  \nlet toLeetSpeak = String.map charToLeet","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85968,"user_id":null,"body":"let alphabetNormal = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \"\nlet alphabetLeet = \"@8(D3F6#!JK1MN0PQR$7UVWXY2 \"\nlet alphabet = Seq.zip alphabetNormal alphabetLeet |> dict\nlet toLeetSpeak = String.map (fun x -> alphabet.[x])\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85969,"user_id":null,"body":"let charToLeet c =\n  match c with\n  | 'A' -> '@'\n  | 'B' -> '8'\n  | 'C' -> '('\n  | 'E' -> '3'\n  | 'G' -> '6'\n  | 'H' -> '#'\n  | 'I' -> '!'\n  | 'L' -> '1'\n  | 'O' -> '0'\n  | 'S' -> '$'\n  | 'T' -> '7'\n  | 'Z' -> '2'\n  | x -> x\n  \n  \nlet toLeetSpeak (s:string) = \n  s.ToCharArray()\n  |> Array.map charToLeet\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85970,"user_id":null,"body":"let toLeetSpeak s = \n    let leetDictionary = \n        [   'A' , \"@\";\n            'B' , \"8\";\n            'C' , \"(\";\n            'D' , \"D\";\n            'E' , \"3\";\n            'F' , \"F\";\n            'G' , \"6\";\n            'H' , \"#\";\n            'I' , \"!\";\n            'J' , \"J\";\n            'K' , \"K\";\n            'L' , \"1\";\n            'M' , \"M\";\n            'N' , \"N\";\n            'O' , \"0\";\n            'P' , \"P\";\n            'Q' , \"Q\";\n            'R' , \"R\";\n            'S' , \"$\";\n            'T' , \"7\";\n            'U' , \"U\";\n            'V' , \"V\";\n            'W' , \"W\";\n            'X' , \"X\";\n            'Y' , \"Y\";\n            'Z' , \"2\";\n            ' ' , \" \";\n        ] |> Map.ofList\n    String.collect(fun c -> leetDictionary.[c]) s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85971,"user_id":null,"body":"let toLeetSpeak =\n    let m =\n        [\n            'A', '@';\n            'B', '8';\n            'C', '(';\n            'D', 'D';\n            'E', '3';\n            'F', 'F';\n            'G', '6';\n            'H', '#';\n            'I', '!';\n            'J', 'J';\n            'K', 'K';\n            'L', '1';\n            'M', 'M';\n            'N', 'N';\n            'O', '0';\n            'P', 'P';\n            'Q', 'Q';\n            'R', 'R';\n            'S', '$';\n            'T', '7';\n            'U', 'U';\n            'V', 'V';\n            'W', 'W';\n            'X', 'X';\n            'Y', 'Y';\n            'Z', '2';\n        ] |> Map.ofList\n\n    let translate c =\n        match Map.tryFind c m with\n        | Some c' -> c'\n        | None -> c\n\n    String.map translate\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85972,"user_id":null,"body":"let leetMap = dict[\n                  ' ' , \" \";\n                  'A' , \"@\";\n                  'B' , \"8\";\n                  'C' , \"(\";\n                  'D' , \"D\";\n                  'E' , \"3\";\n                  'F' , \"F\";\n                  'G' , \"6\";\n                  'H' , \"#\";\n                  'I' , \"!\";\n                  'J' , \"J\";\n                  'K' , \"K\";\n                  'L' , \"1\";\n                  'M' , \"M\";\n                  'N' , \"N\";\n                  'O' , \"0\";\n                  'P' , \"P\";\n                  'Q' , \"Q\";\n                  'R' , \"R\";\n                  'S' , \"$\";\n                  'T' , \"7\";\n                  'U' , \"U\";\n                  'V' , \"V\";\n                  'W' , \"W\";\n                  'X' , \"X\";\n                  'Y' , \"Y\";\n                  'Z' , \"2\"]\nlet toLeetSpeak (s:string) = \n    s |> Seq.map (fun x-> leetMap.Item(x)) |> Seq.fold (+) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85973,"user_id":null,"body":"let map = Map [\n  ('A', '@'); ('B', '8'); ('C', '('); ('D', 'D'); ('E', '3'); ('F', 'F');\n  ('G', '6'); ('H', '#'); ('I', '!'); ('J', 'J'); ('K', 'K'); ('L', '1');\n  ('M', 'M'); ('N', 'N'); ('O', '0'); ('P', 'P'); ('Q', 'Q'); ('R', 'R');\n  ('S', '$'); ('T', '7'); ('U', 'U'); ('V', 'V'); ('W', 'W'); ('X', 'X');\n  ('Y', 'Y'); ('Z', '2') ]\n\nlet toLeetChar char =\n    match Map.tryFind char map with\n    | Some char -> char\n    | None -> ' '\n\nlet toLeetSpeak = String.map toLeetChar","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85974,"user_id":null,"body":"let dialect = [('A', '@'); ('B', '8'); ('C', '('); ('D', 'D'); ('E', '3'); ('F', 'F'); ('G', '6'); ('H', '#'); ('I', '!'); ('J', 'J'); ('K', 'K'); ('L', '1'); ('M', 'M'); ('N', 'N'); ('O', '0'); ('P', 'P'); ('Q', 'Q'); ('R', 'R'); ('S', '$'); ('T', '7'); ('U', 'U'); ('V', 'V'); ('W', 'W'); ('X', 'X'); ('Y', 'Y'); ('Z', '2'); (' ', ' ')]\n\nlet toLeetSpeak s = s |> String.map (fun x -> dialect |> List.find(fun (o,n) -> o = x) |> snd)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85975,"user_id":null,"body":"let private leetDict c =\n  match c with\n  | 'A' -> '@'\n  | 'B' -> '8'\n  | 'C' -> '('\n  | 'D' -> 'D'\n  | 'E' -> '3'\n  | 'F' -> 'F'\n  | 'G' -> '6'\n  | 'H' -> '#'\n  | 'I' -> '!'\n  | 'J' -> 'J'\n  | 'K' -> 'K'\n  | 'L' -> '1'\n  | 'M' -> 'M'\n  | 'N' -> 'N'\n  | 'O' -> '0'\n  | 'P' -> 'P'\n  | 'Q' -> 'Q'\n  | 'R' -> 'R'\n  | 'S' -> '$'\n  | 'T' -> '7'\n  | 'U' -> 'U'\n  | 'V' -> 'V'\n  | 'W' -> 'W'\n  | 'X' -> 'X'\n  | 'Y' -> 'Y'\n  | 'Z' -> '2'\n  | c -> c\n  \nlet toLeetSpeak s =\n  s\n  |> String.map leetDict","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85976,"user_id":544,"body":"let leet (c: char) =\n    match c with\n    | 'A' -> '@'\n    | 'B' -> '8'\n    | 'C' -> '('\n    | 'E' -> '3'\n    | 'G' -> '6'\n    | 'H' -> '#'\n    | 'I' -> '!'\n    | 'L' -> '1'\n    | 'O' -> '0'\n    | 'S' -> '$'\n    | 'T' -> '7'\n    | 'Z' -> '2'\n    | c -> c\n\nlet toLeetSpeak s = String.map leet s ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57c7231c484cf9e6ac000090":[{"id":85977,"user_id":null,"body":"let addingShifted arrays shift =\n  let shiftBy i ns =\n    let j = Array.length arrays - i - 1\n    Array.concat\n      [Array.replicate (i * shift) 0;\n      ns;\n      Array.replicate (j * shift) 0]\n  arrays |> Array.mapi shiftBy |> Array.reduce (Array.map2 (+))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85978,"user_id":null,"body":"let addingShifted (arrayOfArrays : int array array) (shift : int) =\n    let l = arrayOfArrays.Length - 1\n    arrayOfArrays\n    |> Array.mapi (fun i array -> Array.concat [(Array.create (i * shift) 0); array; (Array.create ((l - i) * shift) 0)])\n    |> Array.reduce (Array.map2 (+))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85979,"user_id":null,"body":"let addingShifted (arrayOfArrays : int array array)(shift : int) =\n    let shifted = \n        arrayOfArrays\n        |> Array.mapi (fun i a -> \n                         Array.concat[| [|for i in 1 .. (i * shift) -> 0 |];\n                                        a;[|for i in 1 .. (Array.length arrayOfArrays - i - 1) * shift -> 0|]|])\n    [|for i in 0 .. Array.length shifted.[0] - 1 ->\n        [|for x in 0 .. Array.length shifted - 1 ->\n            shifted.[x].[i]|] |> Array.sum|]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85980,"user_id":168,"body":"let addingShifted (arr : int array array) (shift : int) =\n  let k = Array.length arr\n  let n = Array.length arr.[0]\n  [| for i in 0 .. n + (k - 1) * shift - 1 ->\n      arr \n      |> Array.mapi (fun j a ->\n          let index = i - j * shift\n          if 0 <= index && index < n then a.[index] else 0)\n      |> Array.sum |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85981,"user_id":null,"body":"let addingShifted (arrayOfArrays : int array array)(shift : int) = \n  let numb = (Array.length (arrayOfArrays.[0])) + ((Array.length arrayOfArrays) - 1) * shift - 1\n  [|0..numb|] |> \n  Array.map (fun x -> (Array.sum (Array.mapi (fun i y -> if (i * shift > x || (x - i * shift) >= (Array.length y)) then 0 else y.[x - i * shift]) arrayOfArrays)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85982,"user_id":null,"body":"let addingShifted (arrayOfArrays : int array array)(shift : int) =\n    let add (x: int list) (y: int list) =\n        (List.take shift x) \n            @ (x |> List.skip shift |> List.zip (List.take ((List.length x) -  shift) y) |> List.map (fun (a, b) -> a + b))\n            @ List.skip ((List.length x) - shift) y\n\n    let l = arrayOfArrays \n                |> Array.toList\n                |> List.map Array.toList\n    \n    \n    List.foldBack add (l |> List.take ((List.length l) - 1) ) (List.last l) |> List.toArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85983,"user_id":null,"body":"let addingShifted (arrayOfArrays : int array array)(shift : int) =\n    let arrayCount = Array.length arrayOfArrays\n\n    let shiftArray arrayIndex arr =\n        seq {\n            yield Array.zeroCreate (shift * arrayIndex)\n            yield arr\n            yield Array.zeroCreate (shift * (arrayCount - arrayIndex - 1))\n        } |> Array.concat\n\n    let zipAndSum arr1 arr2 =\n        Array.zip arr1 arr2 |> Array.map (fun (a, b) -> a + b)\n\n    arrayOfArrays\n    |> Array.mapi shiftArray\n    |> Array.reduce zipAndSum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85984,"user_id":null,"body":"let sumArays = Array.map2 (+)\nlet toLength total arr =\n    if total <= Array.length arr\n    then arr\n    else Array.append arr (Array.init (total - Array.length arr) (fun _ -> 0))\n    \nlet append0Left count  =  (Array.init count (fun _ -> 0)) |> Array.append\n\nlet addingShifted (arrayOfArrays : int array array) (shift : int) =\n    let folder (list,shift') arr = (append0Left shift' arr :: list,shift'+shift)\n    let paddedArrays =\n        arrayOfArrays\n        |> Array.fold folder ([],0)\n        |> fst\n    paddedArrays\n    |> List.map (toLength (List.maxBy Array.length paddedArrays).Length)\n    |> List.reduce sumArays","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85985,"user_id":null,"body":"let addingShifted (arrayOfArrays : int array array) (shift : int) : int array = \n   let mutable output = [||]\n   let mutable sum = 0\n   let maxLength = arrayOfArrays.[0].Length + ((arrayOfArrays.Length - 1) * shift)\n   for i = 0 to maxLength - 1 do\n      for arr in arrayOfArrays do\n         let realPos = i - (shift * (Array.findIndex (fun elm -> elm = arr) arrayOfArrays))\n         if realPos >= 0 && realPos < arr.Length then sum <- sum + arr.[realPos]\n         else ()\n      output <- Array.append output [|sum|]\n      sum <- 0\n   output","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85986,"user_id":null,"body":"let addingShifted (arrayOfArrays : int[][]) (shift : int) =\n    let elementCount = arrayOfArrays.[0].Length + (arrayOfArrays.Length - 1) * shift\n    let result = Array.create elementCount 0\n    for i in 0 .. arrayOfArrays.Length - 1 do\n        let currentOffset = shift * i\n        let currentArr = arrayOfArrays.[i]\n        for j in 0 .. currentArr.Length - 1 do\n            let idxToModif = j + currentOffset\n            result.[idxToModif] <- result.[idxToModif] + currentArr.[j]\n    result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57c9359540e302d32700013a":[{"id":85987,"user_id":null,"body":"type Person =\n    { firstName : string; lastName : string }\n    override x.ToString() = sprintf \"%s %s\" x.firstName x.lastName\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85988,"user_id":null,"body":"[<StructuredFormatDisplay(\"{firstName} {lastName}\")>]\ntype Person =\n    { firstName : string; lastName : string }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85989,"user_id":null,"body":"[<StructuredFormatDisplay(\"{firstName} {lastName}\")>]\ntype Person = {\n    firstName : string\n    lastName : string\n}\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85990,"user_id":53,"body":"type Person =\n    { firstName : string; lastName : string }\n    override person.ToString() = person.firstName + \" \" + person.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85991,"user_id":491,"body":"type Person =\n    { firstName : string; lastName : string }\n        override this.ToString() = sprintf \"%s %s\" this.firstName this.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85992,"user_id":null,"body":"type Person =\n    { firstName : string; \n    lastName : string }\n    override this.ToString() = sprintf \"%s %s\" this.firstName this.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85993,"user_id":null,"body":"type Person = {\n    firstName : string\n    lastName : string\n}\nwith\n    override this.ToString() = this.firstName + \" \" + this.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85994,"user_id":null,"body":"type Person = \n  { firstName: string; lastName: string }\n  override p.ToString() = sprintf \"%s %s\" p.firstName p.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85995,"user_id":null,"body":"type Person = \n    { firstName : string;\n     lastName : string }\n     override this.ToString() = this.firstName + \" \"+ this.lastName","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85996,"user_id":null,"body":"open System\n\ntype Person =\n    { firstName : string; lastName : string;  }\nwith\n  override x.ToString () = String.Format(\"{0} {1}\", x.firstName, x.lastName)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57cebe1dc6fdc20c57000ac9":[{"id":85997,"user_id":null,"body":"let find_short (str: string) = \n    str.Split ' '\n    |> Array.map (fun x -> x.Length)\n    |> Array.min","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85998,"user_id":null,"body":"let find_short (str : string) = \n    str.Split ' '\n    |> Array.map String.length\n    |> Array.min","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":85999,"user_id":null,"body":"let find_short (str : string) = \n    str.Split ' '\n    |> Seq.map(fun str -> str.Length)\n    |> Seq.min\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86000,"user_id":325,"body":"let find_short (str : string) = \n    str.Split(' ')\n    |> Seq.minBy String.length\n    |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86001,"user_id":null,"body":"let find_short (str: string) = \n    ' '\n    |> str.Split\n    |> Array.map (fun s -> s.Length)\n    |> Array.min","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86002,"user_id":null,"body":"let find_short (s: string) =\n    s.Split [|' '|]\n    |> Array.map (String.length)\n    |> Array.min","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86003,"user_id":null,"body":"let find_short (str : string) = \n    str.Split ' '\n    |> Array.toList\n    |> List.minBy String.length\n    |> String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86004,"user_id":null,"body":"open System\n\nlet find_short s =\n  Seq.fold\n    ( fun (acc, w) c ->\n        if c <> ' ' then\n          (acc + 1, w)\n        else\n          (0, min w acc) )\n    (0, Int32.MaxValue)\n    s\n  |> (||>) <| min","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86005,"user_id":null,"body":"let find_short (s: string) = s.Split ' ' |> Seq.map Seq.length |> Seq.min","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86006,"user_id":null,"body":"let find_short (str : string) = \n    str.Split(' ')\n    |> Array.minBy(fun (x:string) -> x.Length)\n    |> String.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57d165ad95497ea150000020":[{"id":86007,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet bears (x : int) (s : string) : string * bool =\n    let matches = Regex.Matches(s, \"(B8|8B)\")\n    let rslt = matches |> Seq.cast |> Seq.map (fun (m : Match) -> m.Value) |> System.String.Concat\n    rslt, matches.Count >= x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86008,"user_id":null,"body":"let isPair (s:string * char option) (c:char) =\n    let bears, prevC = s\n    match (prevC, c) with\n    | Some '8' , 'B' -> (bears + \"8B\", None)\n    | Some 'B', '8' -> (bears +  \"B8\", None) \n    | _, '8' | _, 'B' -> (bears, Some(c))\n    | _ -> (bears, None)\n\nlet bears (x : int) (s : string) : string * bool =\n    s.ToCharArray()\n    |> Array.fold isPair (\"\", None)\n    |> fun pairs -> fst pairs\n    |> fun pairs -> (pairs, pairs.Length \/ 2 >= x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86009,"user_id":null,"body":"let bears (x : int) (s : string) : string * bool =\n    let y = s.ToCharArray() |> Array.toList\n    let rec findPairs (count:int) (acc:string) (input:char List) = \n        match input with\n        | hd::sd::tl when hd = 'B' && sd = '8' -> findPairs (count + 1) (acc + hd.ToString() + sd.ToString()) tl\n        | hd::sd::tl when hd = '8' && sd = 'B' -> findPairs (count + 1) (acc + hd.ToString() + sd.ToString()) tl\n        | hd::tl -> findPairs (count) (acc) tl\n        | _ -> (acc, count >= x)\n        \n    findPairs 0 \"\" y\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86010,"user_id":null,"body":"open System\nopen System.Text\nlet bears (x : int) (s : string) : string * bool =\n    let rg = System.Text.RegularExpressions.Regex(\"\"\"B8|8B\"\"\")\n    let matches = rg.Matches(s)\n    let sb = StringBuilder()\n    let sb = matches\n             |>Seq.cast\n             |>Seq.fold (fun (s:StringBuilder) (t:RegularExpressions.Match) -> s.Append(t.Value)) sb\n    sb.ToString(), matches.Count >= x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86011,"user_id":168,"body":"open System.Text.RegularExpressions\n\nlet bears (x : int) (s : string) : string * bool =\n  Regex.Matches(s, \"B8|8B\")\n  |> Seq.cast<Match>\n  |> Seq.map (fun m -> m.Value)\n  |> fun pairs -> System.String.Concat pairs, Seq.length pairs >= x\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86012,"user_id":null,"body":"let bears (x : int) (s : string) : string * bool =\n    let pairs = s |> Seq.pairwise |> Seq.toArray\n    let rec countPairs (pairs: (char*char) array) ind =\n      if (ind >= (Array.length pairs)) then\n        \"\"\n      else\n        match (pairs.[ind]) with\n        |(a,b) when a <> b && (b = 'B' || b = '8') && (a = 'B' || a = '8') -> (a.ToString() + b.ToString()) + (countPairs pairs (ind + 2))\n        |_ -> (countPairs pairs (ind + 1))\n        \n    let pairsNumb = (countPairs pairs 0)\n    (pairsNumb, (String.length pairsNumb) >= 2 * x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86013,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet bears (x : int) (s : string) : string * bool =\n    let matches = Regex.Matches(s, @\"B8|8B\")\n    match x with\n    | 0 -> \n        if matches.Count <> 0 then\n            [|for mat in matches -> mat.Value|] |> Array.reduce (fun x y -> x + y), true\n        else \"\", true\n    | _ ->\n        if matches.Count >= x then\n            [|for mat in matches -> mat.Value|] |> Array.reduce (fun x y -> x + y), true\n        else if matches.Count = 0 then\n            \"\", false\n        else\n            [|for mat in matches -> mat.Value|] |> Array.reduce (fun x y -> x + y), false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86014,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet bears (x : int) (s : string) : string * bool =\n    let rx = new Regex(@\"B8|8B\")\n    let m = rx.Matches s\n    let mutable pairs = []\n    \n    for i = 0 to m.Count - 1 do\n      pairs <- pairs @ [(m.Item i).ToString()]\n    \n    ((pairs |> String.concat(\"\")), (m.Count >= x))\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86015,"user_id":null,"body":"let bears (x : int) (s : string) : string * bool =\n    let rec pairs list =\n            match list with\n            | 'B'::'8'::bs -> \"B8\" + pairs bs\n            | '8'::'B'::bs -> \"8B\" + pairs bs\n            | _::bs -> pairs bs\n            | _ -> \"\"\n    let p = pairs (s |> Seq.toList)\n    (p, p.Length \/ 2 >= x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86016,"user_id":null,"body":"open System\n\nlet rec loop acc =\n  function\n  | [] ->\n      (List.length acc), (acc |> List.rev |> List.collect id |> Array.ofList |> String)\n  | b1 :: b2 :: xs when (b1 = '8' && b2 = 'B') || (b2 = '8' && b1 = 'B') ->\n      loop ([b1; b2] :: acc) xs\n  | x :: xs ->\n      loop acc xs\n\nlet bears (x : int) (s : string) : string * bool =\n    let y, bs = loop [] (List.ofSeq s)\n    bs, (y >= x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57d2807295497e652b000139":[{"id":86017,"user_id":1363,"body":"let averages numbers =\n  match numbers with\n  | Some xs -> \n    xs |> Seq.map float |> Seq.pairwise |> Seq.map (fun (a,b) -> (a+b)\/2.0) |> Seq.toList\n  | None -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86018,"user_id":1669,"body":"let averages (numbers : List<int> option) = \n   match numbers with\n     | None -> []\n     | Some [] -> []\n     | Some [x] -> []\n     | Some ls -> [for i in 0 .. ls.Length-2 do yield ((float ls.[i] + float ls.[i+1]) \/ 2.0) ]\n     \n     \n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86019,"user_id":null,"body":"let averages = \n    Option.map (Seq.map float >> Seq.windowed 2 >> Seq.map Array.average >> Seq.toList)\n    >> Option.defaultValue []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86020,"user_id":null,"body":"let rec averages = function \n    | Some (h::n::t) -> float(h+n)\/2. :: averages (Some(n::t))\n    | _ -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86021,"user_id":null,"body":"let averages = function\n| None | Some ([] | [_]) -> []\n| Some (_ :: xs' as xs) ->\n    xs'\n    |> Seq.map2 (fun x x' -> (float x + float x') \/ 2.) xs\n    |> Seq.toList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86022,"user_id":null,"body":"let averages = function\n| None | Some ([] | [_]) -> []\n| Some xs ->\n    xs\n    |> Seq.map float\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> (x + y) \/ 2.)\n    |> Seq.toList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86023,"user_id":null,"body":"let averages =\n    let rec f acc x = function\n    | [] -> List.rev acc\n    | x' :: xs ->\n        let x'' = float x'\n        f ((x + x'') \/ 2. :: acc) x'' xs\n\n    function\n    | None\n    | Some ([] | [_]) -> []\n    | Some (x :: xs) -> f [] (float x) xs\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86024,"user_id":3318,"body":"let averages (numbers : List<int> option) =\n    match numbers with\n    | None ->\n        []\n    | Some(xs) when (xs.Length <= 1) ->\n        []\n    | Some(xs) ->\n        xs\n        |> List.windowed 2\n        |> List.map (List.averageBy float)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86025,"user_id":492,"body":"let averages (numbers : List<int> option) = \n   match numbers with\n     | None -> []\n     | Some [] -> []\n     | Some [x] -> []\n     | Some xs -> [for i in 0 .. xs.Length-2 do yield (float xs.[i] + float xs.[i+1]) \/ 2.0 ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86026,"user_id":null,"body":"let averages (numbers : List<int> option) = \n  match numbers with\n  | Some(numbers) -> numbers |> List.pairwise |> List.map (fun p -> float(fst p + snd p)\/2.0)\n  | None -> []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57d86d3d3c3f961278000005":[{"id":86027,"user_id":null,"body":"let last = List.tryLast","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86028,"user_id":1686,"body":"let last xs = \n    match xs with\n    | [] -> None\n    | _  -> Some (List.last xs)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86029,"user_id":575,"body":"let last xs = \n    match xs with\n    | [] -> None\n    | _  -> Some (Seq.last xs)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86030,"user_id":null,"body":"let  rec last xs = \n    match xs with\n    |head::tail -> if tail.IsEmpty then Some(head)\n                        else last tail          \n    | [] -> None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86031,"user_id":null,"body":"let last =\n    let rec f x = function\n    | [] -> x\n    | x' :: xs -> f x' xs\n\n    function\n    | [] -> None\n    | x :: xs -> Some (f x xs)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86032,"user_id":987,"body":"let rec last xs = (* Your code goes here! *)\n  match xs with\n  | [] -> None\n  | [x] -> Some x\n  | h :: t -> last t","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86033,"user_id":1986,"body":"let rec last = function\n  | [] -> None\n  | [x] -> Some x\n  | _::xs -> last xs\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86034,"user_id":527,"body":"let last = Seq.fold (fun _ -> Some) None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86035,"user_id":null,"body":"let last xs = if xs <> [] then Some (xs |> List.rev |> List.head) else None","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86036,"user_id":null,"body":"let last(xs:list<int>)= \n  match xs with \n  |[]->None \n  |_->List.last xs|>Some\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57d9951f3c3f9666e9000017":[{"id":86037,"user_id":null,"body":"let is_palindrome l = l = (List.rev l)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86038,"user_id":null,"body":"let is_palindrome list =\n  List.rev list |> ((=) list)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86039,"user_id":null,"body":"open System\nlet is_palindrome list = list = List.rev list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86040,"user_id":1986,"body":"let is_palindrome list =\n    (List.rev list) = list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86041,"user_id":null,"body":"let is_palindrome l = List.rev l = l","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86042,"user_id":null,"body":"let rec listReverse: List<'a> -> List<'a> =\n    fun(list: List<'a>) ->\n        match list with\n        | [] -> []\n        | head::tail ->  listReverse(tail) @ [head]\n        \nlet is_palindrome: List<'a> -> bool =\n    fun(list: List<'a>) ->\n        match list with \n        | [] -> true\n        | head::tail -> if listReverse(list) = list then true else false\n        \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86043,"user_id":null,"body":"let is_palindrome list =\n  list |> List.rev |> (=) list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86044,"user_id":null,"body":"let is_palindrome (list: 'a list) = (* your code goes here! *)\n    let half = list.Length \/ 2\n    let lastIndex = list.Length - 1\n    let mutable isPalindrome = true\n    let mutable i = 0\n    \n    while isPalindrome && i < half do\n        if not (list.[i] = list.[lastIndex - i])\n        then isPalindrome <- false\n        i <- i + 1\n    \n    isPalindrome","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86045,"user_id":null,"body":"let is_palindrome list = \n  match list with\n  | [] -> true\n  | _ -> List.rev list = list","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86046,"user_id":null,"body":"let rec is_palindrome list =\n    match list with\n    | []\n    | [ _ ] -> true\n    | x ->\n        x.[0] = x.[x.Length - 1]\n        && is_palindrome (x.[1 .. (x.Length - 2)])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57da8b50a82a19ecca001513":[{"id":86047,"user_id":1986,"body":"let hello = function\n    | Some name -> \"Hello, \" + name\n    | None -> \"Hello World\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86048,"user_id":null,"body":"let hello = function\n| None -> \"Hello World\"\n| Some name -> sprintf \"Hello, %s\" name\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86049,"user_id":null,"body":"let hello name = \n  match name with\n  | Some name -> \"Hello, \" + name\n  | None -> \"Hello World\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86050,"user_id":492,"body":"let hello s = \n  match s with\n  | None -> \"Hello World\"\n  | _    -> \"Hello, \" + s.Value","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86051,"user_id":527,"body":"let hello = function\n  | None -> \"Hello World\"\n  | Some name -> \"Hello, \" + name","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86052,"user_id":575,"body":"let hello name =\n    match name with\n    | Some x -> \"Hello, \" + x\n    | None -> \"Hello World\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86053,"user_id":null,"body":"open Option\n\nlet hello name =\n    match name with\n    | None -> \"Hello World\"\n    | _ -> \"Hello, \" + Option.get(name)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86054,"user_id":1562,"body":"let hello name = match name with\n                 |None -> \"Hello World\"\n                 |Some n -> \"Hello, \" + n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86055,"user_id":null,"body":"let hello name = \n    name\n    |> Option.map (sprintf \"Hello, %s\")\n    |> defaultArg <| \"Hello World\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86056,"user_id":null,"body":"let hello name = \n  match name with\n  | Some(v) -> sprintf \"Hello, %s\" v\n  | None -> \"Hello World\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57e3f79c9cb119374600046b":[{"id":86057,"user_id":1686,"body":"let hello s =\n    match s with\n    | \"\" -> \"Hello, World!\"\n    | _  -> \"Hello, \" + System.Char.ToUpper(s.[0]).ToString() + s.Substring(1).ToLower() + \"!\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86058,"user_id":168,"body":"let hello = function\n  | \"\" -> \"Hello, World!\"\n  | s -> \"Hello, \" + s.[0..0].ToUpper() + s.[1..].ToLower() + \"!\"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86059,"user_id":null,"body":"let fixGreetingObjectName name = \n    match name with\n    | \"\" | null -> \"World\"\n    | _  -> name.[..0].ToUpper() + name.[1..].ToLower()\n\nlet hello name =\n    \"Hello, \" + fixGreetingObjectName name + \"!\"","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86060,"user_id":53,"body":"open System\n\nlet capitalise (s: string) =\n    s |> Seq.mapi (fun i c -> \n          match i with | 0 -> (Char.ToUpper(c)) \n                       | _ -> (Char.ToLower(c)) ) \n      |> String.Concat\n\nlet hello name =\n  let cleaned = name |> capitalise\n  if (String.length cleaned) = 0 then\n    \"Hello, World!\"\n  else\n    sprintf \"Hello, %s!\" cleaned","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86061,"user_id":null,"body":"open System\n\nlet hello name = \n  if System.String.IsNullOrWhiteSpace name then\n    \"Hello, World!\"\n  else\n    sprintf \"Hello, %s!\" (System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase(name.ToLower()))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86062,"user_id":null,"body":"open System\nlet hello x= sprintf \"Hello, %s!\" <| if x=\"\" then \"World\" else String.mapi(fun i x->if i=0 then Char.ToUpper(x) else Char.ToLower(x)) x;;\n                    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86063,"user_id":null,"body":"let makeUpperOrLower i c = if i = 0 then System.Char.ToUpper c else System.Char.ToLower c\nlet hello name = if name = \"\" then \"Hello, World!\" else \"Hello, \" + String.mapi (makeUpperOrLower) name + \"!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86064,"user_id":null,"body":"open System.Globalization\n\nlet hello name =\n  match name with\n  | \"\" -> \"Hello, World!\"\n  | name -> \"Hello, \" + CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name) + \"!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86065,"user_id":null,"body":"open System\n\nlet FirstUpper name = \n    name\n    |> Seq.mapi (fun i c -> match i with\n        | 0 -> (Char.ToUpper(c))\n        | _ -> (Char.ToLower(c)))\n    |>String.Concat\n\nlet hello name =\n    match name with\n    | name when String.length name > 1 ->  \"Hello, \" + (FirstUpper name) + \"!\"\n    | _ ->  \"Hello, World!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86066,"user_id":null,"body":"let capitalize (s: string) =\n    System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s.ToLower())\nlet hello = function\n    | \"\" -> \"Hello, World!\"\n    | s -> sprintf \"Hello, %s!\" (capitalize s)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57ea70aa5500adfe8a000110":[{"id":86067,"user_id":null,"body":"let fold array =\n    let len = Array.length array\n    let mapped = Array.map2 (+) array <| Array.rev array\n    let subbed = Array.sub mapped 0 (len \/ 2)\n    match len % 2 with\n    | 0 -> subbed\n    | _ -> Array.append subbed [|array.[len \/ 2]|]\n\nlet foldArray array runs =\n    [1..runs]\n    |> Seq.fold (fun a x -> fold a) array\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86068,"user_id":null,"body":"let rec foldArray array runs =\n    if runs = 0\n    then array\n    else\n        let length = Array.length array\n        if length <= 1\n        then array\n        else\n            let foldedLength = (length + 1) \/ 2\n            let foldedArray =\n                Array.init\n                    foldedLength\n                    (fun i ->\n                        let j = length - 1 - i\n                        array.[i] + if i < j then array.[j] else 0)\n            foldArray foldedArray (runs - 1)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86069,"user_id":null,"body":"let rec add fwd bck =\n    match fwd,bck with\n    | [], _ -> []\n    | _, [] -> []\n    | f :: fs, b ::bs -> f + b :: add fs bs\n\nlet foldOnce list =\n    let half = (list |> List.length) \/ 2\n    let fwd = list |> List.take half\n    let bck = list |> List.rev |> List.take half\n\n    add fwd bck @ (list |> List.skip half |> List.take ((list |> List.length) - half - half))\n\nlet foldArray array runs =\n    let list = array |> List.ofArray\n\n    List.unfold (fun (l,r) -> if r > 0 then Some(foldOnce l, (foldOnce l, r - 1)) else None) (list, runs)\n    |> List.last\n    |> Array.ofList\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86070,"user_id":null,"body":"let rec foldArray (array : int []) runs = \n    if runs = 0 then array\n    else\n      array\n      |> Seq.mapi (fun i x ->\n        let i2 = array.Length - i - 1\n        x + if i = i2 then 0 else array.[i2])\n      |> Seq.take (float array.Length \/ 2.0 |> ceil |> int)\n      |> Seq.toArray\n      |> fun xs -> foldArray xs (runs - 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86071,"user_id":878,"body":"let rec foldArray array runs =\n  let len = (Array.length array)\n  match runs with\n  | 0 -> array\n  | _ when len = 0 -> array\n  | _ -> \n    let half = (len - 1) \/ 2\n    let res =\n      [|\n        for i in 0..half ->\n          match i with\n          | i when i = len \/ 2 -> array.[i]\n          | i -> array.[i] + array.[len - i - 1]\n      |]\n    foldArray res (runs - 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86072,"user_id":null,"body":"let doFold (array:int[]) =\n  let arrayHalf = (array.Length \/ 2) - 1\n  let rem = (array.Length % 2)\n  let res : int array = Array.zeroCreate ((array.Length \/ 2) + rem)\n\n  for i = 0 to arrayHalf do\n    res.[i] <- (array.[i] + array.[array.Length-1-i])\n\n  if (rem <> 0) then\n    res.[arrayHalf + 1] <- array.[arrayHalf + 1]\n\n  res\n\nlet foldArray (array:int[]) (runs:int) = \n  let mutable res = array\n  for i = runs downto 1 do\n    res <- doFold res\n    \n  res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86073,"user_id":null,"body":"let rec foldArray array runs = \n  let foldedArray = \n    let l = Array.length array\n    let arrSum = Array.map2 (+)\n    match (l \/ 2, l % 2) with\n    | 0, _ -> array\n    | _, 0 -> arrSum array.[..(l\/2)-1] (Array.rev array.[(l\/2)..])\n    | _, _ -> Array.append (arrSum array.[..(l\/2)-1] (Array.rev array.[(l\/2)+1..])) [|array.[l\/2]|]\n    \n  match runs with\n  | 0 ->  array\n  | r ->  foldArray foldedArray (r-1)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86074,"user_id":null,"body":"let rec foldArray (array : 'a array) runs = \n  \n    let doFold a = \n        let len = Array.length a\n        let isOdd = len % 2 = 1\n        let splitPoint = floor ((len  |> float) \/ 2.0) |> int\n        let left = Array.take splitPoint a\n        let right = Array.take splitPoint (Array.rev a)\n        let zipped = Array.zip left right |> Array.map (fun (l, r) -> l + r)\n        if isOdd then (Array.append zipped [| a.[splitPoint] |]) else zipped\n\n    match (array, runs) with\n    | (_, 0) -> array\n    | ([||], _) -> Array.empty\n    | (x, n) -> (foldArray (doFold array) (n - 1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86075,"user_id":null,"body":"let rec foldArray array runs =\n\n\n    let fold arr : int [] =\n         \n       \n       \n        let chunks = arr |> Array.splitInto 2 |> Seq.toArray\n        if arr.Length=1 then arr else \n        let arrInt = chunks.[1] |> Array.rev\n        let arr1 =\n            if arrInt.Length = chunks.[0].Length then\n                arrInt\n            else\n                Array.append arrInt [| 0 |]\n\n        (chunks.[0], arr1)\n        ||> Array.zip\n        |> Seq.map (fun (x, y) -> x + y)\n        |> Seq.toArray\n\n\n    let runNew = runs - 1\n    let ans = fold array\n    if runNew = 0 then\n        ans\n    else\n        \n        foldArray ans runNew","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86076,"user_id":168,"body":"let rec foldArray array = function\n  | 0 -> array\n  | n ->\n    let k = Array.length array\n    let a, b = array.[..(k - 1) \/ 2], array.[(k + 1) \/ 2..]\n    let b' = if k % 2 = 0 then b else Array.append [| 0 |] b\n    foldArray (Array.map2 (+) a (Array.rev b')) (n - 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57eae65a4321032ce000002d":[{"id":86077,"user_id":null,"body":"let fake_bin = String.map (fun x -> if x < '5' then '0' else '1')","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86078,"user_id":null,"body":"let fake_bin x = String.collect (fun c -> if c < '5' then \"0\" else \"1\") x","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86079,"user_id":null,"body":"let fake_bin = \n  String.map(fun x -> \n    match x with\n    | '0' | '1' | '2' | '3' | '4' -> '0'\n    | _ -> '1'\n  )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86080,"user_id":null,"body":"let asInt (char:char) =\n    int char - int '0'\n\nlet isGreaterThan4 x = x > 4\n\nlet toChar x =\n    match x with\n    | false -> '0'\n    | true -> '1'\n\nlet fake_bin x =\n    x\n    |> Seq.toArray\n    |> Array.map (asInt >> isGreaterThan4 >> toChar)\n    |> System.String","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86081,"user_id":527,"body":"let fake_bin = String.collect (fun c -> if c < '5' then \"0\" else \"1\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86082,"user_id":null,"body":"open System\n\nlet fake_bin x = x |> Seq.toArray |> Array.map(fun elem -> if Int32.Parse (string elem) < 5 then '0' else '1') |> String\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86083,"user_id":null,"body":"let fake_bin s =\n  let mutable answer = \"\"\n  for c in s do\n    answer <- answer + if int(c) < int('5') then \"0\" else \"1\"\n  answer","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86084,"user_id":null,"body":"let fake_binLetter letter = \n  let intLetter = int letter\n  if intLetter < int '5' then '0' else if intLetter <= int '9' then '1' else letter\n\nlet fake_bin x = x |>  Seq.map fake_binLetter |> Seq.toArray |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86085,"user_id":null,"body":"let fake_binChar (x: char) : char =\n    match x with\n    | x when x >= '0' && x < '5' -> '0'\n    | _ -> '1'\n\nlet fake_bin (x: string) : string =\n    x\n    |> List.ofSeq\n    |> List.map fake_binChar\n    |> List.map string\n    |> List.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86086,"user_id":null,"body":"let fake_bin = String.map (function\n| '0' | '1' | '2' | '3' | '4' -> '0'\n| _ -> '1')","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57ecdd3d2559761b60000403":[{"id":86087,"user_id":null,"body":"let safeSqrt = function\n  | x when x < 0. -> \"invalid input\"\n  | x -> string (sqrt x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86088,"user_id":1669,"body":"let safeSqrt x = \n  let s = System.Math.Sqrt(x).ToString();\n  if s = \"NaN\" then \"invalid input\" else s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86089,"user_id":null,"body":"let safeSqrt x =\n    if x < 0.\n    then \"invalid input\"\n    else sqrt x |> string\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86090,"user_id":3318,"body":"let safeSqrt x =\n    if x < 0.0 then \"invalid input\"\n    else x |> sqrt |> sprintf \"%g\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86091,"user_id":1363,"body":"let safeSqrt x =\n  if x < 0.0\n    then \"invalid input\"\n    else sqrt(x).ToString()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86092,"user_id":2077,"body":"open System\n\nlet safeSqrt x = \n  let r = Math.Sqrt(x).ToString()\n  if r = \"NaN\" then \"invalid input\"\n  else r","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86093,"user_id":1686,"body":"let safeSqrt (x : float) =\n    match x with\n    | x when x < 0.0 -> \"invalid input\"\n    | _              -> (System.Math.Sqrt x).ToString()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86094,"user_id":null,"body":"let safeSqrt x =\n    if x < 0.0 then \"invalid input\"\n    else x |> sqrt |> string ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86095,"user_id":null,"body":"let safeSqrt x =\n    if x < 0.0 then \"invalid input\"\n    else x |> float |> sqrt |> string ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86096,"user_id":null,"body":"open System\n\nlet safeSqrt x =\n  if (x < 0.0) then\n    \"invalid input\"\n  else\n    let y = sqrt x\n    y.ToString()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57ee99a16c8df7b02d00045f":[{"id":86097,"user_id":491,"body":"let FlattenAndSort = List.concat >> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86098,"user_id":null,"body":"let FlattenAndSort (numbers : int list list) : int list =\n    numbers\n    |>List.collect (fun e->e)\n    |>List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86099,"user_id":null,"body":"let FlattenAndSort (numbers : int list list) : int list =\n    numbers \n    |> List.collect ( fun elm -> elm)\n    |> List.sort\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86100,"user_id":null,"body":"let FlattenAndSort (numbers : int list list) : int list =\n    numbers\n    |> List.concat\n    |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86101,"user_id":null,"body":"let FlattenAndSort (numbers : int list list) : int list =\n    let nums = numbers |> List.filter (fun x -> x <> [])\n    match nums with\n    | [] -> []\n    | _ -> nums\n           |> List.reduce (@)\n           |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86102,"user_id":null,"body":"let FlattenAndSort xs = List.collect id xs |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86103,"user_id":null,"body":"let FlattenAndSort (numbers : int list list) : int list =\n    List.sort (List.concat numbers)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86104,"user_id":null,"body":"let FlattenAndSort (numbers : int list list) : int list =\n    numbers |> List.fold (fun x a -> x @ a) [] |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86105,"user_id":null,"body":"let FlattenAndSort (numbers: int list list) : int list = List.concat numbers |> List.sort\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86106,"user_id":null,"body":"let rec FlattenAndSortHelper newList oldList =\n        match (newList,oldList) with\n        |(x,[]) -> x\n        |(x,y) -> FlattenAndSortHelper (x@y.Head) y.Tail\n\n\nlet FlattenAndSort (numbers : int list list) =\n       FlattenAndSortHelper [] numbers\n       |> List.sort","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57f24e6a18e9fad8eb000296":[{"id":86107,"user_id":null,"body":"let how_much_i_love_you nbPetals =\n  match (nbPetals % 6) with\n  | 0 -> \"not at all\"\n  | 1 -> \"I love you\"\n  | 2 -> \"a little\"\n  | 3 -> \"a lot\"\n  | 4 -> \"passionately\"\n  | 5 -> \"madly\"\n  | _ -> \"NONONONO\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86108,"user_id":3318,"body":"let words = [\"I love you\"; \"a little\"; \"a lot\"; \"passionately\"; \"madly\"; \"not at all\"]\nlet how_much_i_love_you nbPetals = words.[(nbPetals-1) % words.Length]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86109,"user_id":null,"body":"let how_much_i_love_you =\n  let phrases = [|\n    \"I love you\";\n    \"a little\";\n    \"a lot\";\n    \"passionately\";\n    \"madly\";\n    \"not at all\";\n  |]\n  let f nbPetals =\n    if nbPetals < 1 then invalidArg \"nbPetals\" \"There must be at least one petal.\"\n    phrases.[(nbPetals - 1) % phrases.Length]\n  f","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86110,"user_id":1363,"body":"let how_much_i_love_you nbPetals =\n  match nbPetals % 6 with\n  | 1 -> \"I love you\"\n  | 2 -> \"a little\"\n  | 3 -> \"a lot\"\n  | 4 -> \"passionately\"\n  | 5 -> \"madly\"\n  | _ -> \"not at all\";","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86111,"user_id":null,"body":"type AllPetalPhrases = \n| ``I love you`` = 0\n| ``a little`` = 1\n| ``a lot`` = 2\n| ``passionately`` = 3\n| ``madly`` = 4\n| ``not at all`` = 5\n\nlet how_much_i_love_you nbPetals =\n  (nbPetals-1) % 6 |> enum<AllPetalPhrases> |> sprintf \"%A\"\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86112,"user_id":53,"body":"let how_much_i_love_you n =\n  [|\"I love you\";\"a little\";\"a lot\";\"passionately\";\"madly\";\"not at all\"|].[(n-1)%6]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86113,"user_id":null,"body":"let how_much_i_love_you nbPetals =\n  match nbPetals % 6 with\n  | 1 -> \"I love you\"\n  | 2 -> \"a little\"\n  | 3 -> \"a lot\"\n  | 4 -> \"passionately\"\n  | 5 -> \"madly\"\n  | 0 -> \"not at all\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86114,"user_id":null,"body":"let how_much_i_love_you n =\n  let phrases =\n    [| \"I love you\"\n       \"a little\"\n       \"a lot\"\n       \"passionately\"\n       \"madly\"\n       \"not at all\" |]\n\n  (n - 1) % phrases.Length\n  |> Array.get phrases\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86115,"user_id":null,"body":"let how_much_i_love_you nbPetals =\n    let petals = [|\n        \"I love you\";\n        \"a little\";\n        \"a lot\";\n        \"passionately\";\n        \"madly\";\n        \"not at all\";\n    |]\n    petals.[(nbPetals - 1) % petals.Length]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86116,"user_id":null,"body":"let how_much_i_love_you nbPetals =\n    match (nbPetals % 6) with\n    | 0 -> \"not at all\"\n    | 1 -> \"I love you\"\n    | 2 -> \"a little\"\n    | 3 -> \"a lot\"\n    | 4 -> \"passionately\"\n    | 5 -> \"madly\"\n    | x -> \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57f36495c0bb25ecf50000e7":[{"id":86117,"user_id":null,"body":"let find n =\n    [3 .. n]\n    |> List.filter (fun i -> i % 3 = 0 || i % 5 = 0)\n    |> List.sum","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86118,"user_id":null,"body":"let sumUpTo n = n * (n + 1) \/ 2\n\nlet sumMultiplesOfUpTo m n = m * sumUpTo (n \/ m)\n\nlet find n =\n    sumMultiplesOfUpTo 3 n +\n    sumMultiplesOfUpTo 5 n -\n    sumMultiplesOfUpTo 15 n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86119,"user_id":null,"body":"let find n = \n  seq [1 .. n]\n  |> Seq.filter(fun x -> x % 3 = 0 || x % 5 = 0)\n  |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86120,"user_id":null,"body":"let find n = Seq.sum (seq {for x in 3 .. n do if (x % 3 = 0 || x % 5 = 0) then yield x})","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86121,"user_id":1363,"body":"let find n =\n  [3..n] |> List.filter (fun x -> x % 3 = 0 || x % 5 = 0) |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86122,"user_id":3318,"body":"let find n =\n    (seq {0 ..  3 .. n} |> Seq.sum) +\n    (seq {0 ..  5 .. n} |> Seq.sum) -\n    (seq {0 .. 15 .. n} |> Seq.sum)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86123,"user_id":527,"body":"let find n =\n  [3; 5; -15]\n    |> List.map (fun x -> let k = n \/ abs x in x * k * (k + 1) \/ 2)\n    |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86124,"user_id":null,"body":"let find n =\n  let t x = x * (x + 1) \/ 2 in\n    let f y z = t(y \/ z) * z in\n      f n 3 + f n 5 - f n 15","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86125,"user_id":null,"body":"let find n =\n        let sumThre = [for i in 1..(n\/3) -> if(i%5 =0 ) then i*0 else i*3]|>List.sum\n        let sumFive = [for i in 1..(n\/5) -> i*5]|>List.sum\n        sumThre+sumFive","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86126,"user_id":1140,"body":"let find n = \n  {0..n}\n  |> Seq.filter (fun x -> x % 3 = 0 || x % 5 = 0)\n  |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57f6ad55cca6e045d2000627":[{"id":86127,"user_id":null,"body":"let square_or_square_root =\n    Array.map (fun n ->\n        let root = n |> float |> sqrt |> int\n        if root * root = n then root else n * n)\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86128,"user_id":null,"body":"let square_or_square_root (array:int[]) = \n    array\n    |> Array.map (fun x ->\n        let fx = float x\n        let sqrtX = sqrt fx\n        let remainder = sqrtX - truncate sqrtX\n        if remainder = 0.0 \n            then int sqrtX\n            else x*x\n    )","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86129,"user_id":null,"body":"let toSquareOrNotToSquare y =\n  match (sqrt y) % 1.0 with\n  | 0.0 -> sqrt y\n  | _ -> y ** 2.0\n\nlet square_or_square_root (array:int[]) = \n  array\n  |> Array.map (float >> toSquareOrNotToSquare >> int)\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86130,"user_id":null,"body":"let square_or_square_root (array:int[]) = array |> Array.map (fun x-> \n        let foatval = x|> float        \n        match ((foatval|> sqrt) % 1.0 <> 0.0) with\n        |true  -> System.Convert.ToInt32(foatval*foatval)\n        |false -> System.Convert.ToInt32(sqrt foatval )\n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86131,"user_id":527,"body":"let square_or_square_root = Array.map (fun x -> let y = x |> float |> sqrt |> round |> int in if y * y = x then y else x * x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86132,"user_id":null,"body":"let square_or_square_root = Array.map (fun n ->\n    let s = sqrt (float n)\n    if s = truncate s then int s else n * n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86133,"user_id":null,"body":"let square_or_square_root (array:int[]) = \n    array\n    |> Array.map (fun x -> match sqrt (float x) with\n                           | a when floor a = a -> int a\n                           | _ -> x * x )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86134,"user_id":null,"body":"let intRoot n =\n  n\n  |> double\n  |> sqrt\n  |> int\n\nlet hasIntRoot n =\n  let root = intRoot n\n  root * root = n\n\nlet intRootOrSquared (n: int) =\n  if hasIntRoot n\n  then intRoot n\n  else n * n\n\nlet square_or_square_root (array: int[]) =\n  Seq.map intRootOrSquared array\n  |> Seq.toArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86135,"user_id":null,"body":"let square_or_square_root (array : int[]) : int[] =\n  \/\/ If the number in array has an integer square root, take it,\n  \/\/ otherwise square the number.\n  [| for n in array ->\n     let root = int(sqrt(float n))\n     if root * root = n then root else n * n |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86136,"user_id":null,"body":"open System\n\nlet isInteger (n:float) : bool =\n    let x = (int)n\n    let rest = n - (float)x\n    match rest with\n    | 0.0 -> true\n    | _ -> false\n\nlet squareroot (x:int) : int = \n    let y = Math.Sqrt((float)x)\n    match isInteger y with\n    | false -> (int)(Math.Pow((float)x, 2.0))\n    | true -> (int)y\n\nlet square_or_square_root (array:int[]) = \n    array |> Array.map squareroot","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57f780909f7e8e3183000078":[{"id":86137,"user_id":null,"body":"let grow = Array.reduce (*)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86138,"user_id":null,"body":"let grow (x) =\n    x |> Array.reduce (*)\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86139,"user_id":null,"body":"let grow (x) =\n    Array.reduce (*) x\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86140,"user_id":null,"body":"let grow (x) =\n    Seq.fold (fun acc s -> acc * s) 1 x\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86141,"user_id":null,"body":"let grow (x) =\n    let rec cal = function\n      | [] -> 1\n      | h::rest -> h * (cal rest)\n    in\n    cal (List.ofArray x)\n      \n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86142,"user_id":null,"body":"let grow (x) =\n    let rec prod x =\n      match x with\n      | head :: tail -> head * prod tail\n      | [] -> 1\n    prod (x |> List.ofArray)\n    ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86143,"user_id":null,"body":"let grow = Array.fold (*) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86144,"user_id":null,"body":"let grow (x) = Seq.reduce (*) x\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86145,"user_id":null,"body":"let grow (x) =  Array.reduce (fun x y -> x * y) x\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86146,"user_id":null,"body":"let grow (x) =\n    let multIdentity = 1\n    let multiply a b = a * b\n    Array.fold multiply multIdentity x\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57f781872e3d8ca2a000007e":[{"id":86147,"user_id":527,"body":"let maps = Array.map ((*) 2)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86148,"user_id":null,"body":"let maps (x:int[]) = [|for element in x -> element*2|]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86149,"user_id":null,"body":"let maps (x:int[]) = x |> Array.map (fun k -> k * 2)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86150,"user_id":null,"body":"let maps (x:int[]) = \n  x |> Array.map (fun x -> x * 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86151,"user_id":null,"body":"let maps xs = xs |> Array.map2 (+) xs ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86152,"user_id":null,"body":"\/\/module hello\nlet double x = x * 2\nlet maps (x:int[]) = \n  let doubles = Array.map double x\n  doubles","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86153,"user_id":null,"body":"let maps (x:int array) = x |> Array.map (fun x -> 2 * x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86154,"user_id":491,"body":"let maps = Array.map (fun n -> 2 * n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86155,"user_id":null,"body":"let maps (x:int[]) : int[] = [| for i in 0..x.Length - 1 -> x.[i] * 2 |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86156,"user_id":null,"body":"let maps (x:int[]) = \n  let mutable y = Array.create x.Length 1\n  let mutable i = 0\n  for value in x do\n    y.[i] <- value * 2\n    i <- i + 1\n  y","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"57fcaed83206fb15fd00027a":[{"id":86157,"user_id":3318,"body":"let replaceNth (text: string) n oldValue newValue =\n    if n <= 0 then\n        text\n    else\n        text\n        |> Seq.mapFold (fun count -> function\n            | c when c = oldValue ->\n                if count % n = 0\n                then newValue, count+1\n                else c, count+1\n            | c -> c, count) 1\n        |> fst\n        |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86158,"user_id":null,"body":"let allIndexOf (c : char) (s : string) =\n    Seq.unfold\n        (fun previousIndex ->\n            let index = s.IndexOf(c, previousIndex + 1)\n            if index = -1 then None else Some (index, index))\n        -1\n\nlet takeNth n xs =\n    xs\n    |> Seq.mapi (fun i x -> i, x)\n    |> Seq.filter (fun (i, x) -> (i + 1) % n = 0)\n    |> Seq.map snd\n\nlet toCharArray (s : string) = s.ToCharArray()\n\nlet replaceNth text n oldValue newValue =\n    if n <= 0\n    then text\n    else\n        let indexes =\n            text\n            |> allIndexOf oldValue\n            |> takeNth n\n            |> Seq.toArray\n        if Array.isEmpty indexes\n        then text\n        else\n            let array = text |> toCharArray\n            for index in indexes do\n                array.[index] <- newValue\n            array |> System.String\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86159,"user_id":null,"body":"let mutateState n oldValue newValue count char =\n    match char = oldValue, count + 1 = n with\n    | true, true -> (newValue, 0)\n    | true, false -> (char, count + 1)\n    | false, _ -> (char, count)\n\nlet replaceNth text n oldValue newValue =\n    text\n    |> Seq.mapFold (mutateState n oldValue newValue) 0\n    |> fst\n    |> Seq.toArray\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86160,"user_id":null,"body":"let mutateState n oldValue newValue (_, count) char =\n    match char = oldValue, count + 1 = n with\n    | true, true -> (newValue, 0)\n    | true, false -> (char, count + 1)\n    | false, _ -> (char, count)\n\nlet replaceNth text n oldValue newValue =\n    text\n    |> Seq.scan (mutateState n oldValue newValue) (' ', 0)\n    |> Seq.skip 1\n    |> Seq.map fst\n    |> Seq.toArray\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86161,"user_id":null,"body":"let replaceNth (text: string) n oldValue newValue = \n    text \n    |> Seq.fold (fun (out,count) c  -> \n                    match c with \n                    | x when x = oldValue && count = n -> (out + string newValue, 1)\n                    | x when x = oldValue -> (out + string x, count + 1)\n                    | x -> (out + string x, count )) (\"\", 1)\n    |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86162,"user_id":null,"body":"let replaceNth (text :string) n oldValue newValue =\n    let rec replaceNth' i xs =\n        match xs with\n        | [] -> []\n        | x::xs when x = oldValue -> (if i % n = 0 then newValue else x)::replaceNth' (i + 1) xs\n        | x::xs -> x::replaceNth' i xs\n\n    if n > 0 then new string(replaceNth' 1 (text.ToCharArray() |> Array.toList) |> List.toArray) else text\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86163,"user_id":null,"body":"let replaceNth text n oldValue newValue = \n  let rec replacer (text: char list) (num: int) (oldv: char) (newv: char) =\n    match text with\n    | []                                         -> []\n    | head::tail when (head = oldv) && (num = n) -> [newv] @ (replacer tail 1 oldv newv) \n    | head::tail when (head = oldv) && (num < n) -> [oldv] @ (replacer tail (num + 1) oldv newv)\n    | head::tail                                 -> [head] @ (replacer tail num oldv newv) \n  \n  (replacer (List.ofSeq text) 1 oldValue newValue) |> Seq.ofList |>\n  Seq.map (fun x -> x.ToString()) |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86164,"user_id":null,"body":"let replaceNth (text: string) n oldValue newValue =\n    if n <= 0 then text else\n    let folder count curValue =\n        let isMatch = curValue = oldValue\n        let resultValue = if isMatch && count % n = 0 then newValue else curValue\n        resultValue, count + (if isMatch then 1 else 0)\n    text\n    |> Seq.toArray\n    |> Array.mapFold folder 1\n    |> fst\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86165,"user_id":null,"body":"let replaceNth (text:string) n oldValue newValue =\n    if n < 1 then text\n    else\n    let foldfunc count nextChar =\n        match nextChar = oldValue, count % n with\n        | true, 0 -> newValue, count + 1\n        | true, _ -> oldValue, count + 1\n        | false, _ -> nextChar, count\n    text\n    |> Seq.mapFold foldfunc 1\n    |> fst\n    |> System.String.Concat\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86166,"user_id":null,"body":"let replaceNth (text:string) n oldValue newValue =\n    let foldfunc (text, count) nextChar =\n        match nextChar = oldValue, count % n with\n        | true, 0 -> (text + string newValue, count + 1)\n        | true, _ -> (text + string oldValue, count + 1)\n        | false, _ -> (text + string nextChar, count)\n    if n < 1 then text\n    else\n        text.ToCharArray()\n        |> Array.fold foldfunc (\"\", 1)\n        |> function | a,b -> a\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5803c0c6ab6c20a06f000026":[{"id":86167,"user_id":527,"body":"let swapVowelCase = String.map <| function\n  | 'A' -> 'a' | 'a' -> 'A' | 'E' -> 'e' | 'e' -> 'E' | 'I' -> 'i' | 'i' -> 'I'\n  | 'O' -> 'o' | 'o' -> 'O' | 'U' -> 'u' | 'u' -> 'U' | c -> c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86168,"user_id":null,"body":"let swapcase (c: char): char =\n  let i = int(c)\n  if i <= 90 then char(i + 32) else char(i - 32)\n\nlet select_case (c: char): char =\n  match c with\n    | 'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I' | 'O' | 'U' -> swapcase c\n    | _ -> c\n\nlet swapVowelCase (str: string): string =\n    str\n    |> Seq.toList\n    |> List.map select_case\n    |> List.map string\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86169,"user_id":null,"body":"open System\n\nlet swapVowelCase (str : string) : string =\n    let vowels = ['a'; 'e'; 'o'; 'u'; 'i';'A'; 'E'; 'O'; 'U'; 'I']\n    str\n    |> Seq.map ( fun c -> match (vowels |> List.tryFindIndex (fun x -> x = c)) with \n                          | Some(i) when i < 5 -> vowels.[i + 5]\n                          | Some(i) when i > 4 -> vowels.[i - 5] \n                          | _ -> c )\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86170,"user_id":null,"body":"let swapVowelCase = String.map (fun c -> \n    match c with\n    | 'a' | 'e' | 'i' | 'o' | 'u' -> System.Char.ToUpper c\n    | 'A' | 'E' | 'I' | 'O' | 'U' -> System.Char.ToLower c\n    | _ -> c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86171,"user_id":null,"body":"\/\/It's just working, no best way\nlet swapVowelCase (str : string) =\n  str\n    .Replace(\"a\",\"{a}\").Replace(\"A\",\"a\").Replace(\"{a}\",\"A\")\n    .Replace(\"e\",\"{e}\").Replace(\"E\",\"e\").Replace(\"{e}\",\"E\")\n    .Replace(\"i\",\"{i}\").Replace(\"I\",\"i\").Replace(\"{i}\",\"I\")\n    .Replace(\"o\",\"{o}\").Replace(\"O\",\"o\").Replace(\"{o}\",\"O\")\n    .Replace(\"u\",\"{u}\").Replace(\"U\",\"u\").Replace(\"{u}\",\"U\")\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86172,"user_id":null,"body":"let swapVowelCase (s:string) =\n    let swap = function\n        |'A' -> 'a'\n        |'E' -> 'e'\n        |'I' -> 'i'\n        |'O' -> 'o'\n        |'U' -> 'u'\n        |'a' -> 'A'\n        |'e' -> 'E'\n        |'i' -> 'I'\n        |'o' -> 'O'\n        |'u' -> 'U'\n        | c -> c\n    s |> String.map swap","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86173,"user_id":491,"body":"open System\n\nlet swapVowelCase (str : string) : string =\n    let swapVowel c =\n        match \"AEIOUaeiou\".Contains(string(c)) with\n        | true -> if Char.IsLower(c) then Char.ToUpper(c) else Char.ToLower(c)\n        | false -> c\n    String.map swapVowel str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86174,"user_id":null,"body":"open System\n\nlet vowel (c:char) = \"aeouiAEOUI\".IndexOf c |> (<=) 0\n\nlet mapper c = \n  if vowel c \n    then \n      if Char.IsLower c then Char.ToUpper c else Char.ToLower c\n    else c\n\nlet swapVowelCase (str : string) = String.Join (\"\", Seq.map mapper str)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86175,"user_id":168,"body":"let swapVowelCase = \n  String.map (fun c -> \n    Seq.tryFindIndex ((=) c) \"aeiouAEIOU\"\n    |> Option.fold (fun _ i -> \"AEIOUaeiou\".[i]) c)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86176,"user_id":491,"body":"open System\n\nlet swapVowelCase (str : string) : string =\n    let isVowel c = \"AEIOUaeiou\".Contains(string(c))\n    let swapCase c = if Char.IsLower(c) then Char.ToUpper(c) else Char.ToLower(c)\n    let swapVowel c = if isVowel c then swapCase c else c\n    String.Join(\"\", str |> Seq.map swapVowel)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58068479c27998b11900056e":[{"id":86177,"user_id":527,"body":"let sortTwisted37 =\n  let tr = function\n    | '3' -> '7'\n    | '7' -> '3'\n    | c -> c\n  Array.sortBy (string >> String.map tr >> int)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86178,"user_id":null,"body":"let twist37 = function\n    | '3' -> '7'\n    | '7' -> '3'\n    | c -> c\n\nlet sortTwisted37 =\n    Array.sortBy (string >> String.map twist37 >> int)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86179,"user_id":2255,"body":"open System\n\nlet swap37 x =\n  string x\n  |> String.map (fun c -> if c = '3' then '7' elif c = '7' then '3' else c)\n  |> int\n\nlet sortTwisted37 array =\n  Array.sortBy (fun x -> swap37 x) array","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86180,"user_id":null,"body":"let swapTwins x = \n    int ((string x).Replace(\"3\", \"*\").Replace(\"7\", \"3\").Replace(\"*\", \"7\"))\n  \n    \nlet sortTwisted37 array = \n    array \n    |> Array.map swapTwins \n    |> Array.sort \n    |> Array.map swapTwins\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86181,"user_id":168,"body":"let sortTwisted37 array =\n  let replace = function\n    | '3' -> '7'\n    | '7' -> '3'\n    | x   -> x\n  Array.sortBy (string >> String.map replace >> int) array\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86182,"user_id":null,"body":"let twist37 (n: int) =\n    let srcStr = string n\n\n    let newStr =\n        srcStr\n        |> String.map (function\n            | '3' -> '7'\n            | '7' -> '3'\n            | c -> c)\n\n    int newStr\n\n\nlet sortTwisted37 = Array.sortBy twist37\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86183,"user_id":null,"body":"let twist37 (n: int) =\n    let srcStr = string n\n\n    let newStr =\n        String.init srcStr.Length (fun i ->\n            match srcStr.[i] with\n            | '3' -> \"7\"\n            | '7' -> \"3\"\n            | c -> string c)\n\n    int newStr\n\n\nlet sortTwisted37 = Array.sortBy twist37\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86184,"user_id":null,"body":"open System\nlet sortTwisted37 array = \n  array \n  |> Array.map (fun x -> (x, x.ToString().Replace(\"3\", \"x\").Replace(\"7\", \"3\").Replace(\"x\", \"7\"))) \n  |> Array.sortBy (fun x -> Int32.Parse (snd x))\n  |> Array.map fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86185,"user_id":null,"body":"let shift x =\n  match x with\n  | '3' -> '7'\n  | '7' -> '3'\n  | _ -> x\n  \nlet shiftedNumber x =\n  x\n  |> string\n  |> String.map shift\n  |> int\n  \nlet sortTwisted37 = Array.sortBy shiftedNumber","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86186,"user_id":53,"body":"open System\n\nlet twisted37int n = \n  let ns = n.ToString().ToCharArray();\n  for i in 0 .. ns.Length-1 do\n    if ns.[i] = '3' then\n      ns.[i] <- '7'\n    else if ns.[i] = '7' then\n      ns.[i] <- '3'\n  Int32.Parse(String.Concat(ns));\n\nlet sortTwisted37 array = \n  Array.sortBy (fun n -> twisted37int n) array","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"580ed88494291dd28c000019":[{"id":86187,"user_id":null,"body":"let allsuits = ['\u2666'; '\u2665'; '\u2663'; '\u2660']\nlet allvalues = [\"2\";\"3\";\"4\";\"5\";\"6\";\"7\";\"8\";\"9\";\"10\";\"J\";\"Q\";\"K\";\"A\"]\n\nlet isSuit c = List.contains c allsuits\n\nlet splithand (s: string) =\n  let rec split lst acc card =\n    match lst with\n    |[] -> card::acc\n    |h::t when isSuit h -> if card = \"\" then split t acc (string h) else split t (card::acc) (string h)\n    |h::t -> split t acc (card + (string h))\n  List.ofSeq (s.ToUpper())\n  |> fun lst -> split lst [] \"\"\n  |> List.rev\n  \nlet collectsuits s =\n  let rec viewsuits (lst:string list) suits =\n    match lst with\n    |[] -> suits\n    |h::t when List.contains (h.[0]) suits -> viewsuits t suits\n    |h::t -> viewsuits t ((h.[0])::suits)\n  splithand s\n  |> fun lst -> viewsuits lst []\n  |> List.rev\n  |> fun suits -> if suits.Length < 4 \n                  then let diff = Set.difference (set allsuits) (set suits) in suits @ (List.rev (Set.toList diff)) else suits\n                  \nlet comparecards (c1: string) (c2: string) suits =\n  let suit1 = List.findIndex (fun c -> c = c1.[0]) suits in\n  let suit2 = List.findIndex (fun c -> c = c2.[0]) suits in\n  let value1 = List.findIndex (fun s -> s = c1.[1..]) allvalues in\n  let value2 = List.findIndex (fun s -> s = c2.[1..]) allvalues in\n    if suit1 < suit2 then -1\n    elif suit1 > suit2 then 1\n    elif value1 < value2 then -1\n    elif value1 > value2 then 1\n    else 0\n\nlet sortPoker john uncle =\n  let suits = collectsuits uncle in\n  let cards = splithand john in\n  List.sortWith (fun c1 c2 -> comparecards c1 c2 suits) cards\n  |> String.concat \"\"\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86188,"user_id":null,"body":"let parseCards (hand : string) =\n  let rec loop acc =\n    let next s w = loop ((s, w) :: acc)\n    function \n    | [] -> List.rev acc\n    | s :: '1' :: '0' :: xs ->\n      next (s.ToString()) \"10\" xs\n    | s :: c :: xs ->\n      next (s.ToString()) (c.ToString()) xs\n    | _ -> failwith \"bad cards\"\n  loop [] (List.ofSeq hand)\n\nlet sortPoker john uncle =\n  \n  let cardsOrder =\n    [ (\"2\", 2); (\"3\", 3); (\"4\", 4); (\"5\", 5); (\"6\", 6); (\"7\", 7); (\"8\", 8); (\"9\", 9);\n      (\"10\", 10); (\"J\", 11); (\"Q\", 12); (\"K\", 13); (\"A\", 14) ]\n    |> Map.ofList\n  \n  let unclesSuitOrder =\n    parseCards uncle\n    |> List.groupBy fst\n    |> List.mapi (fun i (s, _) -> s, i)\n    |> Map.ofList\n    \n  parseCards john\n  |> List.sortBy (fun (s, c) -> Map.find s unclesSuitOrder, Map.find c cardsOrder)\n  |> List.map (fun (s, c) -> s + c)\n  |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86189,"user_id":null,"body":"open System\n\nlet values = \n    [\"2\"; \"3\"; \"4\"; \"5\"; \"6\"; \"7\"; \"8\"; \"9\"; \"10\";\n    \"J\"; \"Q\"; \"K\"; \"A\"]\n\nlet cards hand =\n    let mutable innerHand = hand\n    seq{\n        while (not (String.IsNullOrWhiteSpace innerHand)) do\n            let suit = Seq.head innerHand\n            let value = \n                Seq.skip 1 innerHand\n                |> Seq.takeWhile (fun x -> \n                    List.exists (fun y -> Seq.contains x y) values)\n                |> String.Concat\n            innerHand <- \n                Seq.skip (String.length value + 1) innerHand\n                |> String.Concat\n            yield (suit, value)\n    }\n        \nlet sortPoker john uncle =\n    let suits = \n        cards uncle\n        |> Seq.map fst\n        |> Seq.distinct\n        |> Seq.toList\n\n    cards john\n    |> Seq.sortBy (fun x -> \n        (Seq.findIndex (fun y -> y = (fst x)) suits),\n        (Seq.findIndex (fun y -> y = (snd x)) values))\n    |> Seq.map (fun x -> string (fst x) + (snd x))\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86190,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet sortPoker john uncle =\n    let getRank = function\n    | \"2\" -> 2\n    | \"3\" -> 3\n    | \"4\" -> 4\n    | \"5\" -> 5\n    | \"6\" -> 6\n    | \"7\" -> 7\n    | \"8\" -> 8\n    | \"9\" -> 9\n    | \"10\" -> 10\n    | \"J\" -> 11\n    | \"Q\" -> 12\n    | \"K\" -> 13\n    | \"A\" -> 14\n    | _ -> failwith \"Invalid card rank\"\n\n    \/\/ Split hand into list of tuples (suit, )\n    let splitHand hand =\n        Regex.Split(hand, \"(\u2665|\u2663|\u2666|\u2660)\")\n        |> List.ofArray\n        |> List.filter (fun x -> x <> \"\")\n        |> List.mapi (fun i x -> (i % 2 = 0, x))\n        |> List.partition fst\n        |> fun (odd, even) -> (List.map snd odd, List.map snd even)\n        ||> List.zip\n\n    let unclesSuitOrder =\n        uncle |> splitHand |> List.map fst |> List.distinct\n\n    john\n        |> splitHand\n        |> List.sortBy (fun (suit, rank) ->\n            ((unclesSuitOrder |> List.findIndex (fun x -> x = suit)), rank |> getRank))\n        |> List.map (fun (s, r) -> s + r)\n        |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86191,"user_id":null,"body":"let sortPoker john uncle = \/\/ Happy coding =)\n    let suitOrder =\n        System.Text.RegularExpressions.Regex.Split(uncle, @\"\\d+|[JKQA]\")\n        |> Seq.distinct\n        |> Array.ofSeq\n\n    let valueOrders =\n        [| \"2\"\n           \"3\"\n           \"4\"\n           \"5\"\n           \"6\"\n           \"7\"\n           \"8\"\n           \"9\"\n           \"10\"\n           \"J\"\n           \"Q\"\n           \"K\"\n           \"A\" |]\n        |> Array.indexed\n        |> Array.map (fun (i, v) -> (v, i))\n        |> Map.ofArray\n    \n    [ for m in System.Text.RegularExpressions.Regex.Matches(john, @\"(.)(\\d+|[JKQA])\") -> m ]\n    |> List.sortBy (fun m ->\n        printfn \"%A\" m\n        (Array.findIndex ((=) m.Groups.[1].Value) suitOrder, Map.find m.Groups.[2].Value valueOrders))\n    |> List.map (fun m -> sprintf \"%s%s\" m.Groups.[1].Value m.Groups.[2].Value)\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86192,"user_id":252,"body":"let sortPoker (j : string) (u : string) =\n    let o = System.Text.RegularExpressions.Regex.Replace (u, \"[0-9JQKA]\", \"\")\n    (   j.Replace (\"10\", \"T\")\n        |> Seq.chunkBySize 2\n        |> Seq.sortBy (fun [| s; v |] -> (o.IndexOf s * 20) + \"23456789TJQKA\".IndexOf v)\n        |> Seq.concat\n        |> System.String.Concat)\n        .Replace (\"T\", \"10\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86193,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet sortPoker john uncle =\n    let getCards text = [\n        for m in Regex.Matches(text, \"(?<suit>[\u2666\u2665\u2660\u2663])(?<rank>[2-9JQKA]|10)\") do\n            yield (char m.Groups.[\"suit\"].Value, m.Groups.[\"rank\"].Value)\n    ]\n\n    let suitOrder = \n        let map = \n            uncle\n            |> getCards\n            |> List.map fst\n            |> List.distinct\n            |> List.mapi (fun index char -> (char, index)) \n            |> Map.ofList\n            \n        fun suit -> Map.find suit map\n\n    let rankOrder = function\n        | \"J\" -> 11 | \"Q\" -> 12 | \"K\" -> 13 | \"A\" -> 14\n        | n -> int n\n\n    john \n    |> getCards\n    |> List.sortBy (fun (suit, rank) -> suitOrder suit, rankOrder rank)\n    |> List.map (fun (suit, rank) -> sprintf \"%c%s\" suit rank)\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86194,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet sortPoker (john: string) (uncle: string) = \n    let marksToArray (cards: string) =\n      Regex.Split(cards, \"(?=[\u2666\u2665\u2660\u2663])\")\n    \n    let getMark (mark: string) =\n      match mark with\n      | \"2\" -> 2\n      | \"3\" -> 3\n      | \"4\" -> 4\n      | \"5\" -> 5\n      | \"6\" -> 6\n      | \"7\" -> 7\n      | \"8\" -> 8\n      | \"9\" -> 9\n      | \"10\" -> 10\n      | \"J\" -> 11\n      | \"Q\" -> 12\n      | \"K\" -> 13\n      | \"A\" -> 14\n      | _   -> -1\n    \n    let arr = \"\u2666\u2665\u2660\u2663\" |> Seq.map (fun x -> (x, uncle.IndexOf(x))) |> Map\n    john |> marksToArray |> Array.filter (fun x -> x.Length > 0) |>\n    Seq.sortBy (fun x -> arr.[x.[0]], (getMark (x.Substring(1)))) |>\n    String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86195,"user_id":null,"body":"let sortPoker john uncle = \n    let suits = [| '\u2660'; '\u2666'; '\u2665'; '\u2663' |]\n    let uncleHand = uncle |> String.filter(fun ch -> ch <> '0')   \/\/ remove '0' from \"10\" so that all card ranks are one character\n    let uncleCards = Array.init 13 (fun i -> uncleHand.[i+i..i+i+1])   \/\/ each card is \"SR\" where 'S' represents a suite and 'R' is a rank\n    let firstOccurrance = suits |> Array.map (fun suitLetter -> uncleCards |> Array.tryFindIndex (fun card -> card.[0] = suitLetter)) |> Array.map (function | Some index -> index | None -> 3)\n    let indexAndSuit = Array.zip firstOccurrance suits |> Array.sort\n    let johnHand = john |> String.filter(fun ch -> ch <> '0')   \/\/ remove '0' from \"10\" so that all card ranks are one character\n    let johnCards = Array.init 13 (fun i -> johnHand.[i+i..i+i+1])   \/\/ each card is \"SR\" where 'S' represents a suite and 'R' is a rank\n    let rankValue rank = \n        match rank with\n        | '1' -> 10\n        | 'J' -> 11\n        | 'Q' -> 12\n        | 'K' -> 13\n        | 'A' -> 14\n        | _ -> int rank - int '0'\n    johnCards\n        |> Array.sortBy(fun cardSR ->  rankValue cardSR.[1] + 100 * int (fst (indexAndSuit |> Array.find (fun elem -> snd elem = cardSR.[0]))))\n        |> Array.map (fun cardSR -> if cardSR.[1] = '1' then cardSR.[0..0] + \"10\" else cardSR)\n        |> Microsoft.FSharp.Core.String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86196,"user_id":null,"body":"type Visual = string\ntype PreRank = {Suit:char; Rank:int; Display:Visual}\ntype FullRank = {Rank:int; Display:Visual}\n\nlet sortPoker john uncle = \/\/ Happy coding =)\n  let faceRanks = ['J'; 'Q'; 'K'; 'A']\n  let numberRanks = ['2'; '3'; '4'; '5'; '6'; '7'; '8'; '9']          \n\n  let toFullRank (suitOrder:char list) (pr:PreRank) : FullRank =\n      match List.tryFindIndex (fun cc -> cc = pr.Suit) suitOrder with\n      | Some idx -> {Display = pr.Display; Rank = pr.Rank + idx*100}\n      | None -> failwith \"Unknown suit\"\n  \n            \n  let squeese (hand:string):char list =\n      let lst = hand.ToCharArray() |> List.ofArray\n      let nonSuiteChars = faceRanks @ numberRanks @ ['1'; '0']\n      lst |> List.filter (fun c -> not (List.contains c nonSuiteChars)) |> List.distinct \n    \n  let split (hand:string):PreRank list =\n      \n    let rankToNumber (c:char):int =\n        let face = List.tryFindIndex (fun cc -> cc = c) faceRanks\n        match face with\n        | Some idx -> idx + 11\n        | None ->\n            let number = List.tryFindIndex (fun cc -> cc = c) numberRanks\n            match number with\n            | Some idx -> idx + 2\n            | None -> failwith \"Unknown rank\"\n    \n    let rec splitRec (result:PreRank list) (str:char list) =\n        match str with\n        | [] -> result\n        | [_] -> result\n        | s::r1::r2::tail when r1 = '1' && r2 = '0' -> splitRec ({Rank = 10; Suit = s; Display=sprintf \"%c10\" s}::result) tail\n        | s::r1::tail -> splitRec ({Rank=rankToNumber r1; Suit=s; Display=sprintf \"%c%c\" s r1}::result) tail\n\n    splitRec [] (hand.ToCharArray() |> List.ofArray)\n  \n  printf \"%s\" john\n  printf \"%s\" uncle\n  let suitOrder = squeese uncle\n  let cards = split john\n  let sortedCards = cards |> List.map (toFullRank suitOrder) |> List.sortBy (fun fr -> fr.Rank)\n  sortedCards |> List.map (fun fr -> fr.Display) |> List.reduce (fun s t -> s+t)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5813d19765d81c592200001a":[{"id":86197,"user_id":null,"body":"let dont_give_me_five startValue endValue =\n  { startValue .. endValue }\n  |> Seq.sumBy (fun i -> if i.ToString().IndexOf('5') = -1 then 1 else 0)\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86198,"user_id":null,"body":"let rec hasDigit d n =\n  if n = 0 then false\n  elif abs <| n % 10 = d then true\n  else hasDigit d (n \/ 10)\n\nlet dont_give_me_five startValue endValue =\n  [startValue..endValue]\n  |> List.filter (not << hasDigit 5)\n  |> List.length","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86199,"user_id":null,"body":"let dont_give_me_five startValue endValue =\n  { startValue .. endValue }\n  |> Seq.filter (fun i -> not <| i.ToString().Contains(\"5\"))\n  |> Seq.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86200,"user_id":null,"body":"let dont_give_me_five startValue endValue =\n    [for i=startValue to endValue do if not(i |> (string >> Seq.contains '5')) then yield i]\n    |> List.length\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86201,"user_id":null,"body":"let filterOutFive num =\n    num.ToString().ToCharArray()\n    |> Array.fold (fun acc n -> acc && n <> '5') true\n\nlet dont_give_me_five startValue endValue = \n    [startValue..endValue]\n    |> List.filter filterOutFive\n    |> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86202,"user_id":null,"body":"let dont_give_me_five startValue endValue = \n  let rec nofives x = \n    match x with\n    | 0 -> true\n    | n when n % 10 = 5 -> false\n    | n when n > 0-> nofives (n\/10)\n    | n -> nofives (n* (-1))\n  \n  List.filter nofives [startValue..endValue] \n  |> List.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86203,"user_id":null,"body":"let dont_give_me_five startValue endValue =\n  [startValue .. endValue]\n  |> Seq.map string\n  |> Seq.filter (fun startValue -> startValue.Contains(\"5\") |> not)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86204,"user_id":168,"body":"let dont_give_me_five startValue endValue =\n  seq { for i in startValue .. endValue do\n          if (string >> Seq.contains '5' >> not) i then yield 1 }\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86205,"user_id":null,"body":"let dont_give_me_five startValue endValue = \n  [startValue..endValue]\n  |> Seq.choose (fun i -> if i.ToString().Contains \"5\" then None else Some i)\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86206,"user_id":null,"body":"let containsFive (i : int) = not <| (string i).Contains \"5\"\n\n\nlet dont_give_me_five startValue endValue = \n  [startValue .. endValue]\n  |> Seq.filter containsFive\n  |> Seq.length","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58184387d14fc32f2b0012b2":[{"id":86207,"user_id":492,"body":"open System\n\nlet f (x: double) =\n    x \/ (1.0 + Math.Sqrt(1.0 + x))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86208,"user_id":null,"body":"open System\n\n\nlet f (x: double) =\n\n  let x2 = x * x\n  let x3 = x2*x\n  let x4 = x2 * x2\n  let x5 = x4 * x\n  \n  x \/ 2.0 \n  - x2 \/ 8.0 \n  + x3 \/ 16.0 \n  - 5.0 * x4 \/ 128.0 \n  + 7.0 * x5 \/ 3840.0\n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86209,"user_id":null,"body":"open System\n\nlet f (x: double) =\n    (x \/ (1.0 + sqrt (1.0 + x)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86210,"user_id":null,"body":"open System\n\nlet f (x: double) =\n  if x < 1e-8 then\n    x \/ 2.0 - x*x \/ 8.0\n  elif x < 1e-4 then\n    x \/ 2.0 - x*x \/ 8.0 + x*x*x\/16.0\n  else\n    x \/ 2.0 - x*x \/ 8.0 + x*x*x\/16.0 - 5.0*x*x*x*x\/128.0\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86211,"user_id":53,"body":"open System\n\nlet f (x: double) =\n    x \/ 2.0 - x * x \/ 8.0 + x * x * x \/ 16.0 - 5.0 * x * x * x * x \/ 128.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86212,"user_id":null,"body":"open System\n\nlet f (x: double) =\n  (x \/2. - x * x \/ 8. + x * x * x \/ 16. - 5. * x * x * x * x \/ 128.)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86213,"user_id":null,"body":"open System\n\nlet f (x: double) =\n    if Math.Abs(x) < 0.005 then \n      \/\/ taylor series approximation\n      x\/2.0 - x*x\/8.0 + x*x*x\/16.0 - 5.0*x*x*x*x\/128.0 + 7.0*x*x*x*x*x\/256.0\n    else \n      sqrt(x+1.0)-1.0\n      ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86214,"user_id":null,"body":"open System\n\nlet f (x: double) =\n    (x \/ 2. ) - (x * x \/ 8.) + ((pown x 3) \/ 16.) - (5. * (pown x 4) \/ 128.)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86215,"user_id":null,"body":"open System\n\nlet f (x: double) =\n \/\/ 4th order taylor series expansion about x = 0\n 0.5 * x   - 0.125 * x * x + 0.0625 * x * x * x - 0.0390625 * x * x * x * x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86216,"user_id":null,"body":"let f (x: double) =\n    let y = 1.0 \/ x\n    let v = sqrt(y + y ** 2.0) + y\n    1.0 \/ v","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"581e1d083a4820eb4f00004f":[{"id":86217,"user_id":null,"body":"let mod256WithoutMod number =\n    match number \/ 256 with\n    | 0 -> number\n    | n -> (number - n * 256)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86218,"user_id":1669,"body":"open System\n\nlet mod256WithoutMod (number:int) = Math.Sign(number) * (Math.Abs(number) &&& 255)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86219,"user_id":null,"body":"let mod256WithoutMod (number:int) =\n    if  number>=256||number<= -256 then number%256  else number","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86220,"user_id":null,"body":"let mod256WithoutMod number =\n    if number >= 0 then number &&& 255 else -(-number &&& 255)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86221,"user_id":null,"body":"let mod256WithoutMod number = (abs number &&& 255) * System.Math.Sign(number)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86222,"user_id":null,"body":"let mod256WithoutMod number =\n  number - number\/256*256","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86223,"user_id":1363,"body":"let mod256WithoutMod number = if number < 0 then -(-number &&& 255) else number &&& 255","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86224,"user_id":168,"body":"let mod256WithoutMod n = if n < 0 then -(-n &&& 0xff) else n &&& 0xff","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86225,"user_id":50,"body":"let mod256WithoutMod number = number-256*(number\/256)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86226,"user_id":null,"body":"let rec mod256WithoutMod number = \n  match number with\n  | number when abs(number) < 256 -> number\n  | number when number <= -256    -> mod256WithoutMod (number + 256)\n  | _                             -> mod256WithoutMod (number - 256)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"581ee0db1bbdd04e010002fd":[{"id":86227,"user_id":null,"body":"open System\n\nlet interp f l u n =\n    let d = (u - l) \/ (float n)\n    let ap i =\n        l + d * (float i)\n        |> f\n        |> ((*) 100.0)\n        |> Math.Floor\n        |> (fun x -> x \/ (100.0))\n\n    List.init n ap\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86228,"user_id":null,"body":"open System\n\nlet interp f l u n =\n    let step = (u - l) \/ float(n)\n    seq { for i in 0 .. n - 1 -> floor((f(l + step * float(i))) * 100.0) \/ 100.0 } |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86229,"user_id":492,"body":"open System\n\nlet interp f l u n =\n    let trunc (d: double) (p: int) =  double(floor(d * Math.Pow(10.0, double(p)))) \/ Math.Pow(10.0, double(p))\n    let calcStep i = l + double(i) * (u - l) \/ double(n)\n    let rec aux i accu = \n        if (i < n) then \n            aux (i + 1) (trunc (f (calcStep i)) 2 :: accu) \n        else \n            accu \n    List.rev (aux 0 [])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86230,"user_id":492,"body":"open System\n\nlet interp f l u n =\n    let trunc (d: double) (p: int) =  double(floor(d * Math.Pow(10.0, double(p)))) \/ Math.Pow(10.0, double(p))\n    let calcStep i = l + double(i) * (u - l) \/ double(n)\n    let rec aux i accu = \n        if (i < n) then \n            aux (i + 1) (trunc (f (calcStep i)) 2 :: accu) \n        else \n            accu \n    List.rev (aux 0 [])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86231,"user_id":168,"body":"let interp f l u n =\n  let round x = floor (x * 100.0) \/ 100.0\n  let d = (u - l) \/ float n\n  [ for i in 0..n - 1 -> f (l + float i * d) |> round ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86232,"user_id":null,"body":"open System\n\nlet interp f l u n =\n    let d = ((u - l) |> double) \/ (n |> double)\n    [1..(n - 1)] |> List.scan (fun acc x -> acc + d) l |>\n    List.map f |> List.map (fun x -> (floor (x * 100.)) \/ 100.)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86233,"user_id":null,"body":"open System\n\nlet interp f l u n =\n let floor (x:float) = Math.Floor x\n let interval = (u - l) \/ (float n)\n [0..(n-1)]\n |> List.map (fun i -> l + (float i) * interval)\n |> List.map (fun s -> ((floor ((f s) * 100.0))) \/ 100.0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86234,"user_id":null,"body":"let interp f (l: double) (u: double) (n: int) =\n    let d = (u - l) \/ (double)n\n    let floored y = floor(y * 100.0) \/ 100.0;\n    [ 0 .. n-1 ]\n    |> Seq.map (fun x -> f(l + (double)x * d))\n    |> Seq.map floored\n    |> Seq.toList\n  \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86235,"user_id":null,"body":"open System\n\nlet interp f l u n =\n    \/\/ your code\n    let d = (u - l)\/(float n)\n    [0..n-1]\n    |> List.map ((fun i -> l + d * (float i)) >> f >> (fun y -> floor(y * 100.0) \/ 100.0))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86236,"user_id":null,"body":"open System\n\nlet interp f l u n =\n    let allNumbers = [ for i in 0 .. (n-1) do yield ((double l) + (double (u - l)) * (double i) \/ (double n))]\n    \n    allNumbers |> List.map f |> List.map (fun x -> floor(x * 100.0) \/ 100.0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58235a167a8cb37e1a0000db":[{"id":86237,"user_id":527,"body":"let numberOfPairs = Seq.groupBy id >> Seq.sumBy (snd >> Seq.length >> (\/) >> (|>) 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86238,"user_id":null,"body":"let numberOfPairs (gloves : string list) : int =\n        gloves\n        |> List.groupBy id\n        |> List.choose (fun (_color, l) ->\n            if (l |> List.length) \/ 2 > 0 then\n                Some((l |> List.length) \/ 2)\n            else\n                None)\n        |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86239,"user_id":null,"body":"let numberOfPairs (gloves : string list) : int =\n    gloves\n    |> Seq.groupBy (fun x -> x)\n    |> Seq.map (fun (_, s) -> (Seq.length s) \/ 2)\n    |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86240,"user_id":null,"body":"let numberOfPairs (gloves : string list) : int =\n    gloves\n    |> List.groupBy id\n    |> List.map (fun (k, l) -> List.length l)\n    |> List.map (fun n -> n \/ 2)\n    |> List.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86241,"user_id":491,"body":"let numberOfPairs =\n  let reducer (gloveSet, total) glove =\n    match Set.contains glove gloveSet with\n    | true -> (Set.remove glove gloveSet, total + 1)\n    | false -> (Set.add glove gloveSet, total)\n  Seq.fold reducer (Set.empty, 0) >> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86242,"user_id":null,"body":"let numberOfPairs (gloves : string list) : int =\n    gloves\n    |> Seq.groupBy id\n    |> Seq.map (snd >> Seq.length >> (fun x -> x \/ 2))\n    |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86243,"user_id":575,"body":"let numberOfPairs (gloves : string list) : int =\n    gloves\n    |> Seq.countBy id\n    |> Seq.sumBy (fun t -> snd t \/ 2);;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86244,"user_id":575,"body":"let numberOfPairs (gloves : string list) : int =\n    gloves\n    |> Seq.countBy id\n    |> Seq.map (fun t -> snd t \/ 2)\n    |> Seq.sum;;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86245,"user_id":527,"body":"let numberOfPairs (gloves : string list) : int =\n  gloves |> Seq.groupBy id |> Seq.sumBy (fun (_, gs) -> Seq.length gs \/ 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86246,"user_id":491,"body":"let numberOfPairs (gloves : string list) : int =\n    let rec numberOfPairs' (gloves : string list) (gloveSet : Set<string>) (total : int) : int =\n        match gloves with\n        | [] -> total\n        | glove::tail ->\n            match Set.contains glove gloveSet with\n            | true -> numberOfPairs' tail (Set.remove glove gloveSet) (total + 1)\n            | false -> numberOfPairs' tail (Set.add glove gloveSet) total\n    numberOfPairs' gloves Set.empty 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5839edaa6754d6fec10000a2":[{"id":86247,"user_id":null,"body":"let find_missing_letter array =\n    [|Array.head array..Array.last array|]\n    |> Array.except array\n    |> Array.exactlyOne","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86248,"user_id":null,"body":"let find_missing_letter array = \n    let pairWithMissing (a,b) = int b - int a > 1\n    let getMissing (a,b) = char (int b - 1)\n    array\n    |> Array.pairwise\n    |> Array.find pairWithMissing\n    |> getMissing","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86249,"user_id":null,"body":"let find_missing_letter array = \n  { (Array.head array)..(Array.last array) }\n    |> Seq.except array\n    |> Seq.head\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86250,"user_id":null,"body":"let find_missing_letter (array:char array) =  \/\/Version 2\n    array\n    |> Array.pairwise\n    |> Array.pick(fun (f,s)-> \n        if int f + 1 = int s then None\n        else Some (char(int f + 1))\n    )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86251,"user_id":null,"body":"let find_missing_letter =\n  Seq.pairwise\n  >> Seq.pick (\n      fun (c1, c2) ->\n          let c = (int c1) + 1 |> char\n          if c <> c2 then Some c else None\n  )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86252,"user_id":null,"body":"let previousLetter (letter : char) = int letter - 1 |> char\n\nlet find_missing_letter array =\n    let index =\n        {1..Array.length array - 1}\n        |> Seq.find (fun i -> array.[i - 1] < previousLetter array.[i])\n\n    previousLetter array.[index]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86253,"user_id":null,"body":"let find_missing_letter (array:char array) = \n    array\n    |> Array.append [|array.[0]..array.[array.Length-1]|]\n    |> Array.reduce( fun acc c -> char(int acc ^^^ int c)) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86254,"user_id":null,"body":"let find_missing_letter array = \n    array\n    |> Array.pairwise\n    |> Array.map (fun (k,v) -> (k + (char) 1, v))\n    |> Array.find (fun (k,v) -> k <> v)\n    |> fun (k,_) -> k","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86255,"user_id":null,"body":"let find_missing_letter array =\n  let (minL, maxL) = (Array.min array, Array.max array)\n  set {minL..maxL}\n    |> (fun x -> Set.difference x (Set.ofArray array))\n    |> (fun x -> x.MaximumElement)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86256,"user_id":null,"body":"let rec find_missing_letter (array : char[]) = \n  let n     = array |> Array.length\n  let first = array |> Array.head |> int\n  let expectedSum = int ((float (n+1)) * (float (2 * first + n) \/ 2.0))\n  let actualSum   = array |> Array.map int |> Array.sum\n  char (expectedSum - actualSum)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5842df8ccbd22792a4000245":[{"id":86257,"user_id":null,"body":"open System \/\/fails with FS0039 if I don't\n\nlet expanded_form =\n    string\n    >> Seq.rev\n    >> Seq.mapi (fun i c -> string c + String.replicate i \"0\")\n    >> Seq.rev\n    >> Seq.filter (Seq.head >> (<>) '0')\n    >> String.concat \" + \"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86258,"user_id":null,"body":"open System\n\nlet rec expand pre xs =\n    match xs with\n    | [] -> []\n    | head::tail -> (sprintf \"%c%s\" head pre) :: (expand (pre + \"0\") tail)\n\nlet expanded_form =\n    string\n    >> Seq.rev\n    >> Seq.toList\n    >> expand \"\"\n    >> Seq.rev\n    >> Seq.filter (fun s -> s.[0] <> '0')\n    >> String.concat \" + \"\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86259,"user_id":null,"body":"open System \/\/that bug\n\nlet expanded_form =\n    string\n    >> (fun s -> Seq.foldBack (fun c (s, i) -> (if c = '0' then \"\" else string c + String.replicate i \"0\" + \" + \") + s, i + 1) s (\"\", 0))\n    >> (fun (s, _) -> s.[..s.Length - 4])","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86260,"user_id":null,"body":"open System \/\/ because the test is broken\n\nlet expanded_form (num: int64) : string =\n    let rec expandDec = function             \n      | 0L -> []\n      | i -> i % 10L :: (i \/ 10L |> expandDec |> List.map (( * ) 10L))\n    expandDec num |> List.filter ((<>) 0L) |> List.rev |> List.map string |> String.concat \" + \"\n      ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86261,"user_id":null,"body":"open System\n\nlet pad = fun (i: int)(n: char) ->\n    match n with\n    | '0' -> \"\"\n    | _ -> n.ToString() + \"\".PadRight(i, '0')\n\nlet expanded_form (num: int64) : string =\n    num.ToString() \n        |> Seq.rev \n        |> Seq.mapi pad\n        |> Seq.filter (fun x -> x <> \"\")\n        |> Seq.rev\n        |> String.concat \" + \"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86262,"user_id":null,"body":"open System\n\n\/\/ Imperative version (non functional)\nlet expanded_form (num: int64) : string =\n    let mutable num = num\n    let mutable dig = 0L\n    let mutable zeros = 0\n    let acc = new ResizeArray<string>()\n\n    while num <> 0L do\n        dig <- num % 10L\n        \/\/ printfn $\"num: {num}, dig: {dig}, zeros: {zeros}\"\n        acc.Add((dig * (Math.Pow(10., float zeros) |> int64)).ToString())\n        num <- num \/ 10L\n        zeros <- zeros + 1\n\n    let result =\n        acc\n        |> Seq.filter (fun str -> str <> \"0\")\n        |> Seq.rev\n        |> Seq.reduce (fun f s -> f + \" + \" + s)\n\n    result\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86263,"user_id":null,"body":"open System;\nlet expanded_form (num: int64) : string =\n    let rec expand : char list -> string list = function\n        | [x] when x <> '0' -> [x.ToString()]\n        | x :: xs when x <> '0' -> String.Format(\"{0}{1}\", x, String.replicate (Seq.length xs) \"0\") :: expand xs\n        | _ :: xs -> expand xs\n        | _ -> [\"\"]\n    num.ToString().ToCharArray()\n    |> Array.toList\n    |> expand\n    |> List.filter (String.IsNullOrEmpty >> not)\n    |> String.concat \" + \"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86264,"user_id":null,"body":"open System\n\nlet rec expandedDigits m n = \n  seq { \n      let expanded = (n % 10L * m)\n      if expanded > 0L then yield expanded\n      let remainder = n \/ 10L \n      if remainder > 0L then yield! expandedDigits (m * 10L) remainder\n      ()\n  }\n\nlet expanded_form (num: int64) : string =\n    num \n    |> expandedDigits 1L \n    |> Seq.map (string) \n    |> Seq.rev \n    |> String.concat \" + \"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86265,"user_id":null,"body":"open System\nlet expanded_form (num: int64) : string =\n  num \n  |> sprintf \"%d\" \n  |> Seq.map (fun x -> int x - int '0') \n  |> Seq.rev \n  |> Seq.toList \n  |> List.mapi (fun i x -> int64 (10.0 ** (float i) * (float x))) \n  |> List.filter(fun x -> x > 0L) \n  |> List.rev\n  |> List.map(sprintf \"%d\") \n  |> String.concat \" + \"","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86266,"user_id":null,"body":"open System\n\nlet getPowerLong power number =\n    if power = 0 then 1L\n    else if power = 1 then number\n    else\n        let mutable acc = 1L\n        for _ in [ 1..power ] do acc <- acc * number\n        acc\n\nlet expanded_form (num: int64) : string =\n    num\n    |> fun n -> n.ToString()\n    |> Seq.rev\n    |> Seq.map (fun ch -> ch |> int64 |> (+) -48L)\n    |> Seq.indexed\n    |> Seq.map (fun (idx, item) -> (getPowerLong idx 10L) * item)\n    |> Seq.map (fun x -> x.ToString())\n    |> Seq.filter (fun x -> x <> \"0\")\n    |> Seq.rev\n    |> Seq.reduce (fun one two -> one + \" + \" + two)","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"585d7d5adb20cf33cb000235":[{"id":86267,"user_id":null,"body":"let find_uniq list =\n    list\n    |> List.countBy id\n    |> List.find (fun (_, cnt) -> cnt = 1)\n    |> fst","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86268,"user_id":null,"body":"\nlet find_uniq list =\n  list\n  |> Seq.countBy id\n  |> Seq.filter(fun (x,y)-> y =1)\n  |> Seq.map fst\n  |> Seq.item 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86269,"user_id":null,"body":"let rec find_uniq list =\n  let (x :: y :: z :: _) = \n    list\n  \n  let b =\n    if x = y || x = z\n    then x\n    else y\n      \n  List.find ((<>) b) list","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86270,"user_id":null,"body":"let rec find_uniq list =\n  match list with\n  | a :: b :: c :: tail when a = b && b = c ->\n    find_uniq (b :: (c :: tail))\n  | a :: b :: c :: _ when a = b -> c\n  | a :: b :: c :: _ when a = c -> b\n  | a :: b :: c :: _ -> a\n  | _ -> raise (System.Exception(\"this shouldn't happen\"))\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86271,"user_id":null,"body":"let find_uniq (list) =\n    list\n    |> Seq.groupBy (fun x -> x)\n    |> Seq.filter (fun y -> snd y |> Seq.length = 1)\n    |> Seq.head\n    |> fst\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86272,"user_id":null,"body":"let find_uniq list =\n    \/\/ your code goes here\n    list\n    |> List.groupBy id\n    |> List.pick (fun (k, l) ->\n        if l |> List.length = 1 then\n            Some(k)\n        else\n            None)\n    ","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86273,"user_id":null,"body":"let find_uniq list =\n   list\n   |> List.groupBy id \n   |> List.find (fun (_,l) -> List.length l = 1)\n   |> fst\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86274,"user_id":null,"body":"let find_uniq list =\n  let three = list |> List.take 3\n  let threeDist = three |> List.distinct\n  match threeDist |> List.length with\n  | 1 -> list |> List.filter (fun x -> x <> threeDist.[0]) |> List.head\n  | _ -> \n    match three |> List.filter (fun x -> x = threeDist.[0]) |> List.length with\n    | 1 -> threeDist.[0]\n    | _ -> threeDist.[1]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86275,"user_id":null,"body":"let find_uniq list =\n  let first :: scnd :: thrd :: xs = list\n  \n  if first <> scnd && first <> thrd then \n    first\n  elif scnd <> first && scnd <> thrd then\n    scnd\n  elif thrd <> first && thrd <> scnd then\n    thrd\n  else\n    List.find (fun i -> i <> first) xs\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86276,"user_id":null,"body":"let find_uniq list =\n    list\n    |> List.countBy id\n    |> List.minBy (fun (_, x) -> x)\n    |> fst\n","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5861487fdb20cff3ab000030":[{"id":86277,"user_id":null,"body":"type Tape = {\n    Pos  : int\n    Tape : bool []\n    In   : bool list\n    Out  : bool list \n}\n\ntype Tape with\n    member t.ReadPos = t.Tape.[t.Pos]\n\nlet cell = [|false|]\n\nlet strToBits : string -> bool list = \n    Seq.collect (fun c -> [for i in 0..7 -> int c \/ pown 2 i % 2])\n    >> Seq.map ((=) 1)\n    >> List.ofSeq\n\nlet bitsToStr bits =\n    match List.length bits % 8 with\n    | 0 -> bits\n    | x -> bits @ List.replicate x false\n    |> List.map (fun x -> if x then 1 else 0)\n    |> List.chunkBySize 8\n    |> List.map \n        (  List.reduceBack (fun x prev -> prev * 2 + x)\n        >> char\n        >> string )\n    |> String.concat \"\"\n       \nlet move x t =\n    match t.Pos with\n    | 0 when x < 0 -> { t with Tape = Array.append cell t.Tape }\n    | p when p = Array.length t.Tape - 1 && x > 0 -> { t with Pos = p + x; Tape = Array.append t.Tape cell }\n    | p -> { t with Pos = p + x }\n\nlet upd x t = \n    let t' = Array.copy t.Tape \/\/ encapsulated mutability\n    t'.[t.Pos] <- x            \/\/\n    { t with Tape = t' } \n\nlet flip (t: Tape) = t |> upd (not t.ReadPos)\n\nlet write t = { t with Out = t.ReadPos :: t.Out }\n\nlet read t = { t with In = match t.In with | x :: xs -> xs | _ -> [] } |> upd (match t.In with | x :: xs -> x | _ -> false) \/\/because F# 4.1 doesn't have safe slicing\n\nlet rec loop cmd (t: Tape) = \n    if t.ReadPos then t |> cmd |> loop cmd else t      \n\n#nowarn \"25\"\n\nlet getCommand (c :: p :: r) : char -> ((Tape -> Tape) list) = function\n| '<' -> (c >> move -1)      :: p :: r\n| '>' -> (c >> move 1)       :: p :: r\n| '+' -> (c >> flip)         :: p :: r\n| ',' -> (c >> read)         :: p :: r\n| ';' -> (c >> write)        :: p :: r\n| '[' -> id :: c             :: p :: r\n| ']' -> (loop c << p)            :: r\n|  _  -> c                   :: p :: r\n\nlet interpret code input =\n    { Pos = 0; Tape = cell; In = strToBits <| input; Out = [] }\n    |> (code |> Seq.fold getCommand ([id; id]) |> List.reduce (<<))\n    |> (fun t -> t.Out)\n    |> List.rev\n    |> bitsToStr","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86278,"user_id":null,"body":"let rec past (co:char[]) i n_op =\n  if co.[i] = ']' then\n    if n_op = 0 then i + 1\n    else past co (i + 1) (n_op - 1)\n  elif co.[i] = '[' then\n    past co (i + 1) (n_op + 1)\n  else past co (i + 1) n_op\n\nlet rec back (co:char[]) i n_cl =\n  if co.[i] = '[' then\n    if n_cl = 0 then i + 1\n    else back co (i - 1) (n_cl - 1)\n  elif co.[i] = ']' then\n    back co (i - 1) (n_cl + 1)\n  else back co (i - 1) n_cl\n\nlet interpret (code: string) (input: string) =\n  let tape_size = 10240\n  let convert_input (input:string) =\n    if System.String.IsNullOrEmpty input then \"\"\n    else\n      input.ToCharArray()\n      |> List.ofArray\n      |> List.map (fun ch ->\n          let bytes = System.BitConverter.GetBytes(ch).[0]\n          System.Convert.ToString(bytes, 2).PadLeft(8, '0').ToCharArray()\n          |> Array.rev |> System.String\n      )\n      |> List.reduce (fun acc item -> acc + item)\n  let le_string output =\n    let to_char word =\n        let word_str = word |> List.toArray |> System.String\n        let value = System.Convert.ToInt32(word_str, 2)\n        char(value)\n    let rec le_inner res word rest =\n      match rest with\n      | [] ->\n        let newRes = if List.length word > 0 then (to_char word)::res else res\n        newRes |> List.rev |> List.toArray |> System.String\n      | h::tail ->\n        let newRes, newWord =\n          if List.length word = 8 then\n            (to_char word)::res, [h]\n          else\n            res, h::word\n        le_inner newRes newWord tail\n    le_inner [] [] (output |> List.rev)\n  let co = code.ToCharArray()\n  let inp = convert_input input\n  let tape = Array.init tape_size (fun _ -> '0')\n  let rec inner output tape_idx code_idx inp_idx =\n    if code_idx >= co.Length then le_string output\n    else\n        let command = co.[code_idx]\n        match command with\n        | '+' ->\n          tape.[tape_idx] <- if tape.[tape_idx] = '1' then '0' else '1'\n          inner output tape_idx (code_idx + 1) inp_idx\n        | '>' -> inner output (tape_idx + 1) (code_idx + 1) inp_idx\n        | '<' -> inner output (tape_idx - 1) (code_idx + 1) inp_idx\n        | '[' ->\n            let new_codeidx = if tape.[tape_idx] = '0' then (past co (code_idx + 1) 0) else (code_idx + 1)\n            inner output tape_idx new_codeidx inp_idx\n        | ']' ->\n            let new_codeidx = if tape.[tape_idx] = '1' then (back co (code_idx - 1) 0) else (code_idx + 1)\n            inner output tape_idx new_codeidx inp_idx\n        | ',' ->\n            tape.[tape_idx] <- if inp_idx < inp.Length then inp.[inp_idx] else '0'\n            inner output tape_idx (code_idx + 1) (inp_idx + 1)\n        | ';' ->\n            inner (tape.[tape_idx]::output) tape_idx (code_idx + 1) inp_idx\n        | _ -> inner output tape_idx (code_idx + 1) inp_idx\n  inner [] (tape_size \/ 2) 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86279,"user_id":null,"body":"type Inst = \n| Flip\n| Read\n| Write\n| Left\n| Right\n| Cond of Inst list\n\nlet cons l i = i :: l\n\nlet findOrDefault k = Map.tryFind k >> Option.defaultValue false\n\ntype Input(source: byte[]) = \n  let mutable byteIx = 0\n  let mutable bitIx = 0\n  member x.Read(): bool =\n    if byteIx = Array.length source then\n      false\n    else\n      let byte = source.[byteIx]\n      let bit = ((byte >>> bitIx) &&& 1uy) = 1uy\n      bitIx <- bitIx + 1\n      if bitIx = 8 then\n        bitIx <- 0\n        byteIx <- byteIx + 1\n      bit\n\nlet rec parseInstruction (code: string) ix =\n  match code.[ix] with\n  | '+' -> Some Flip,  ix + 1\n  | ',' -> Some Read,  ix + 1\n  | ';' -> Some Write, ix + 1\n  | '<' -> Some Left,  ix + 1\n  | '>' -> Some Right, ix + 1\n  | '[' ->\n    parseCond code (ix + 1) List.empty\n  | _ -> None, ix + 1\nand parseCond code ix block =\n  if code.[ix] = ']' then\n    Some (Cond <| List.rev block), ix + 1\n  else\n    let inst, ix' = parseInstruction code ix\n    Option.fold cons block inst\n    |> parseCond code ix'\n\nlet parse code =\n  let rec parseLoop ix acc =\n    if ix = String.length code then\n      List.rev acc\n    else\n      let inst, ix' = parseInstruction code ix\n      inst\n      |> Option.fold cons acc\n      |> parseLoop ix'\n  parseLoop 0 List.empty\n\nlet rec runInstruction inst (inp: Input) tape out tp =\n  match inst with \n  | Flip ->\n    let tape' = Map.add tp (not (findOrDefault tp tape)) tape\n    tape', out, tp\n  | Read ->\n    let tape' = Map.add tp (inp.Read()) tape\n    tape', out, tp\n  | Write ->\n    let bit = findOrDefault tp tape\n    tape, bit :: out, tp\n  | Left ->\n    tape, out, tp - 1\n  | Right ->\n    tape, out, tp + 1\n  | Cond block ->\n    if findOrDefault tp tape then\n      let tape', out', tp' = \n        List.fold (fun (t, o, p) i ->\n          runInstruction i inp t o p\n        ) (tape, out, tp) block\n      if findOrDefault tp' tape' then\n        runInstruction inst inp tape' out' tp'\n      else\n        tape', out', tp'\n    else\n      tape, out, tp\n\nlet run (prog: Inst list) (inputStr: string) = \n  let input =\n    inputStr.ToCharArray()\n    |> Array.map byte\n    |> Input\n  let rec runLoop prog (tape: Map<int, bool>) tp out =\n    match prog with\n    | inst :: rest ->\n      let tape', output', tp' = runInstruction inst input tape out tp\n      runLoop rest tape' tp' output'\n    | [] ->\n      out\n\n  runLoop prog Map.empty 0 List.empty\n\nlet bitsToChars bits =\n  bits\n  |> Seq.rev\n  |> Seq.chunkBySize 8\n  |> Seq.map(fun byte ->\n    Seq.foldBack(fun bit acc ->\n      (acc <<< 1) ||| (if bit then 1uy else 0uy)\n    ) byte 0uy)\n  |> Seq.map char\n  |> Seq.toArray\n\nlet interpret (code: string) (input: string) =\n  let program = parse code\n  run program input\n  |> bitsToChars\n  |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86280,"user_id":null,"body":"let interpret (code: string) (input: string) =\n    \n    let nextInput = \n        (fun () -> \n            let mutable idx = 0\n            let stream = \n                System.Text.Encoding.GetEncoding(\"ISO-8859-1\").GetBytes(input) \n                |> Array.collect (fun b -> System.Convert.ToString(byte b, 2).PadLeft(8, '0').ToCharArray() |> Array.rev)\n            (fun () ->  if idx < stream.Length then idx <- idx + 1; stream.[idx-1] else '0'))()\n\n    let rec mapBrackets idx stack= \n        if idx = code.Length\n            then []\n            else match code.[idx] with\n                    | '[' -> mapBrackets (idx+1) (idx::stack)\n                    | ']' -> (idx, stack.Head) :: (stack.Head, idx) :: mapBrackets (idx + 1) stack.Tail\n                    | _ -> mapBrackets (idx+1) stack\n    let brackets = mapBrackets 0 [] |> Map.ofSeq\n\n    let tape = System.Collections.Generic.Dictionary<int, char>()\n    let peek idx = match tape.TryGetValue idx with true, ch -> ch | _ -> '0'\n    let poke idx v = tape.[idx] <- v\n    let flip idx = poke idx <| if peek idx = '0' then '1' else '0'\n\n    let rec proc cidx tidx out = \n        if cidx >= code.Length || cidx < 0\n            then (List.replicate (List.length out % 8) '0') @ out\n            else \n                match code.[cidx], peek tidx with\n                    | '>', _ -> proc (cidx+1) (tidx+1) out\n                    | '<', _ -> proc (cidx+1) (tidx-1) out\n                    | '+', _ -> flip tidx; proc (cidx+1) tidx out\n                    | ',', _ -> nextInput() |> poke tidx; proc (cidx+1) tidx out\n                    | ';', b -> proc (cidx+1) tidx (b::out)\n                    | '[', '0' -> proc (brackets.[cidx] + 1) tidx out\n                    | ']', '1' -> proc (brackets.[cidx] + 1) tidx out\n                    | _ -> proc (cidx+1) tidx out\n    \n    proc 0 0 []\n    |> List.chunkBySize 8\n    |> List.map (fun arr -> arr |> List.fold (fun st ch -> st * 2uy + if ch = '1' then 1uy else 0uy) 0uy |> System.Convert.ToChar)\n    |> Array.ofList\n    |> Array.rev\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86281,"user_id":null,"body":"open System\nopen System.Text\nopen System.Collections.Generic\n\ntype String with\n   member this.ToBits() =\n      this\n      |> Seq.map (fun c -> Convert.ToString(int c, 2).PadLeft(8, '0'))\n      |> Seq.collect Seq.rev\n      |> Seq.map ((=)'1')\n\ntype Tape() =\n   let tape = ResizeArray<bool>([false])\n   let p = ref 0\n   \n   member __.MoveRight() = \n      if !p = tape.Count-1 \n      then tape.Add(false)\n      incr p\n\n   member __.MoveLeft() =\n      if !p = 0 \n      then tape.Insert(0, false)\n      else decr p\n\n   member __.Current \n      with get () = tape.[!p]\n      and set (value) = tape.[!p] <- value\n\nlet interpret (code: string) (input: string) =\n  let input = Queue<bool>(input.ToBits())\n  let output = Queue<bool>()\n  let tape = Tape()\n  let pc = ref 0\n\n  let readInput() = if input.Count > 0 then input.Dequeue() else false\n  \n  let rec execute () =\n      match code.[!pc] with\n      | '>' -> tape.MoveRight(); incr pc\n      | '<' -> tape.MoveLeft(); incr pc\n      | '+' -> tape.Current <- not tape.Current; incr pc\n      | ';' -> tape.Current |> output.Enqueue; incr pc\n      | ',' -> tape.Current <- readInput(); incr pc\n      | '[' -> if not tape.Current then findend -1 else incr pc\n      | ']' -> if tape.Current then findstart -1 else incr pc        \n      | _ -> incr pc\n  and findend count =\n      match code.[!pc] with\n      | ']' -> if count > 0 then incr pc; findend (count-1)        \n      | '[' -> incr pc; findend (count+1)\n      | _ -> incr pc; findend count          \n  and findstart count =\n      match code.[!pc] with\n      | '[' -> if count > 0 then decr pc; findstart (count-1)        \n      | ']' -> decr pc; findstart (count+1)\n      | _ -> decr pc; findstart count     \n  while !pc < code.Length do execute ()\n\n  output \n  |> Seq.map (fun b -> if b then \"1\" else \"0\")\n  |> Seq.chunkBySize 8 \n  |> Seq.map (Seq.rev >> Seq.reduce (+))\n  |> Seq.map (fun c -> char (Convert.ToInt32(c.PadLeft(8, '0'), 2)))\n  |> Seq.toArray\n  |> String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86282,"user_id":null,"body":"open System.Collections.Generic\n\nlet interpret (code: string) (input: string) =\n\n    let mem = new Dictionary<int, bool>()\n    let memAt memPtr =\n      if not <| mem.ContainsKey(memPtr)\n      then false\n      else mem.[memPtr]\n    \n    let mutable inputPtr = 0\n\n    let inputBytes = input |> Seq.map byte |> Array.ofSeq\n    let readInput() =\n      let byteIdx = inputPtr \/ 8\n      if byteIdx >= inputBytes.Length\n      then false\n      else\n          let bitIdx = inputPtr % 8\n          inputPtr <- inputPtr + 1\n          ((1uy <<< bitIdx) &&& inputBytes.[byteIdx]) <> 0uy\n  \n    let output = new List<bool>()\n      \n    let commands = code |> Array.ofSeq\n    \n    let mutable cmdPtr = 0\n    let mutable memPtr = 0\n    \n    while cmdPtr < commands.Length do\n      \n      match commands.[cmdPtr] with\n        | '>' ->\n          memPtr <- memPtr + 1\n        | '<' ->\n          memPtr <- memPtr - 1\n        | '+' ->\n          mem.[memPtr] <- not <| memAt memPtr\n        | ',' ->\n          mem.[memPtr] <- readInput()\n        | ';' ->\n          output.Add(memAt memPtr)\n        | '[' ->\n          if not <| memAt memPtr then\n            let mutable openCount = 1\n            while cmdPtr < commands.Length - 1 && openCount > 0 do\n              cmdPtr <- cmdPtr + 1\n              if commands.[cmdPtr] = '[' then openCount <- openCount + 1\n              if commands.[cmdPtr] = ']' then openCount <- openCount - 1\n            cmdPtr <- cmdPtr - 1\n            \n        | ']' ->\n          if memAt memPtr then\n            let mutable closeCount = 1\n            while cmdPtr > 0 && closeCount > 0 do\n              cmdPtr <- cmdPtr - 1\n              if commands.[cmdPtr] = ']' then closeCount <- closeCount + 1\n              if commands.[cmdPtr] = '[' then closeCount <- closeCount - 1\n  \n        \/\/ ignore non commands\n        | _ -> ()\n        \n      cmdPtr <- cmdPtr + 1\n    \n    output \n    |> Seq.chunkBySize 8\n    |> Seq.map (Seq.rev >> (Seq.fold(fun acc b -> acc * 2 + (if b then 1 else 0)) 0) >> char)\n    |> Array.ofSeq\n    |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86283,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\ntype Direction =\n    | ToEnd\n    | ToStart\n\nlet indexOfMatchingBrace startIndex braces direction =\n    let startIndex = braces |> Seq.findIndex (fun (i, _) -> i = startIndex)\n    match direction with\n    | ToEnd ->\n        braces\n        |> Seq.skip (startIndex + 1)\n        |> Seq.fold (fun (index, brackets) (i, c) ->\n            match brackets with\n            | 0 -> (index, brackets)\n            | _ ->\n                match c with\n                | '[' -> (i, brackets + 1)\n                | ']' -> (i, brackets - 1)\n                | _ -> (i, brackets)) (startIndex, 1)\n        |> fst\n    | ToStart ->\n        Seq.foldBack (fun (i, c) (index, brackets) ->\n            match brackets with\n            | 0 -> (index, brackets)\n            | _ ->\n                match c with\n                | '[' -> (i, brackets - 1)\n                | ']' -> (i, brackets + 1)\n                | _ -> (i, brackets)) (braces |> Seq.take startIndex) (startIndex, 1)\n        |> fst\n\nlet rec interpretAux code braces ip tape input output mp =\n    let readTape addr =\n        tape\n        |> Map.tryFind addr\n        |> Option.defaultValue 0\n\n    let writeTape addr v = tape |> Map.add addr v\n\n    let mod2 a = a % 2\n\n    match code\n          |> Array.length = ip with\n    | true -> ()\n    | false ->\n        match code.[ip] with\n        | '>' -> interpretAux code braces (ip + 1) tape input output (mp + 1)\n        | '<' -> interpretAux code braces (ip + 1) tape input output (mp - 1)\n        | '+' ->\n            let tape' =\n                mp\n                |> (readTape\n                    >> (+) 1\n                    >> mod2\n                    >> writeTape mp)\n\n            interpretAux code braces (ip + 1) tape' input output mp\n        | '[' ->\n            match mp |> readTape with\n            | 0 ->\n                let target = braces |> Map.find ip\n                interpretAux code braces (target + 1) tape input output mp\n            | _ -> interpretAux code braces (ip + 1) tape input output mp\n        | ']' ->\n            match mp |> readTape with\n            | 1 ->\n                let target = braces |> Map.find ip\n                interpretAux code braces (target + 1) tape input output mp\n            | _ -> interpretAux code braces (ip + 1) tape input output mp\n        | ',' ->\n            let tape' = input() |> writeTape mp\n            interpretAux code braces (ip + 1) tape' input output mp\n        | ';' ->\n            readTape mp |> output\n            interpretAux code braces (ip + 1) tape input output mp\n        | _ -> interpretAux code braces (ip + 1) tape input output mp\n\nlet wrapInput (s: string) =\n    let rec toBits n =\n        match n with\n        | 0 -> []\n        | _ -> (n &&& 1) :: (toBits (n >>> 1))\n\n    let pad b =\n        let pad = List.init (8 - (b |> List.length)) (fun _ -> 0)\n        b @ pad\n\n    let q = Queue<_>()\n\n    s.ToCharArray()\n    |> List.ofSeq\n    |> List.collect\n        (int\n         >> toBits\n         >> pad)\n    |> List.iter q.Enqueue\n\n    fun () ->\n        match q.Count with\n        | 0 -> 0\n        | _ -> q.Dequeue()\n\nlet wrapOutput() =\n    let a = ResizeArray()\n    let f = a.Add\n    (f, a)\n\nlet interpret (code: string) (tape: string) =\n    let braces =\n        code\n        |> Seq.indexed\n        |> Seq.filter (fun (i, c) -> c = '[' || c = ']')\n        |> List.ofSeq\n\n    let jumpCache =\n        braces\n        |> Seq.map (fun (i, c) ->\n            let dir =\n                match c with\n                | '[' -> ToEnd\n                | ']' -> ToStart\n\n            (i, indexOfMatchingBrace i braces dir))\n        |> Map.ofSeq\n\n    let output, outputBuffer = wrapOutput()\n    interpretAux (code.ToCharArray()) jumpCache 0 Map.empty (wrapInput (tape)) output 0\n\n    let outputChars =\n        outputBuffer\n        |> Seq.chunkBySize 8\n        |> Seq.map (fun bits ->\n            bits\n            |> Seq.fold (fun (sum, p) b -> (sum + (b * (pown 2 p)), p + 1)) (0, 0)\n            |> fst\n            |> char)\n        |> Array.ofSeq\n\n    String(outputChars)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86284,"user_id":null,"body":"type OpCode = Flip | Read | Write | Left | Right | LoopStart of int | LoopEnd of int\n\ntype ExecutionState = {\n    mutable InstructionPointer: int\n    mutable TapePointer: int\n    TapePositive: bool ResizeArray\n    TapeNegative: bool ResizeArray\n    mutable InputPointer: int\n    Input: string\n    Output: bool ResizeArray\n}\n\nlet interpret (code: string) (input: string) =\n    let rec parseBlock (block, position, offset) =\n        if position >= code.Length then (block, position)\n        else\n            match code.[position] with\n            | ',' -> parseBlock (Read :: block, position + 1, offset)\n            | ';' -> parseBlock (Write :: block, position + 1, offset)\n            | '>' -> parseBlock (Right :: block, position + 1, offset)\n            | '<' -> parseBlock (Left :: block, position + 1, offset)\n            | '+' -> parseBlock (Flip :: block, position + 1, offset)\n            | '[' ->\n                let startPosition = List.length block + offset\n                let (inner, newPosition) = parseBlock ([], position + 1, startPosition + 1)\n                let newBlock = (LoopEnd startPosition :: inner) @ (LoopStart (startPosition + 2 + List.length inner) :: block)\n                parseBlock (newBlock, newPosition, offset)\n            | ']' -> block, position + 1\n            | _ -> parseBlock (block, position + 1, offset)\n\n    let stateToOutput state = \n        state.Output |>\n        Seq.chunkBySize 8\n        |> Seq.map (fun is -> is |> Array.rev |> Seq.fold (fun s b -> let s' = s <<< 1 in if b then s' + 1 else s') 0 |> char |> string)\n        |> String.concat \"\"\n    \n    let instructions = parseBlock ([], 0, 0) |> fst |> List.rev |> List.toArray\n    \n    let initialState = { \n        InstructionPointer = 0\n        TapePointer = 0\n        TapePositive = ResizeArray([false])\n        TapeNegative = ResizeArray()\n        InputPointer = 0\n        Input = input\n        Output = ResizeArray()\n    }\n\n    let getTapeAndIndex state =\n        if state.TapePointer >= 0 then state.TapePositive, state.TapePointer\n        else state.TapeNegative, (-state.TapePointer - 1)\n\n    let readInput (s: string) i =\n        let charIdx = i \/ 8\n        if charIdx >= s.Length then false\n        else\n            let b = s.[charIdx] |> byte\n            if b >>> i &&& 1uy = 1uy then true else false\n\n    Seq.unfold (fun s -> \n        if s.InstructionPointer < 0 || s.InstructionPointer >= instructions.Length then None\n        else\n            s.InstructionPointer <- s.InstructionPointer + 1\n            match instructions.[s.InstructionPointer - 1] with\n            | Read ->\n                let tape, i = getTapeAndIndex s\n                tape.[i] <- readInput s.Input s.InputPointer\n                s.InputPointer <- s.InputPointer + 1\n            | Write ->\n                let tape, i = getTapeAndIndex s\n                s.Output.Add(tape.[i])\n            | Left -> \n                s.TapePointer <- s.TapePointer - 1\n                let tape, i = getTapeAndIndex s\n                if tape.Count <= i then tape.Add(false)\n            | Right ->\n                s.TapePointer <- s.TapePointer + 1\n                let tape, i = getTapeAndIndex s\n                if tape.Count <= i then tape.Add(false)\n            | Flip ->\n                let tape, i = getTapeAndIndex s\n                tape.[i] <- not <| tape.[i]\n            | LoopStart next ->\n                let tape, i = getTapeAndIndex s\n                if not tape.[i] then\n                    s.InstructionPointer <- next\n            | LoopEnd next ->\n                s.InstructionPointer <- next\n            Some (s, s)\n    ) initialState |> Seq.tryLast |> Option.defaultValue initialState |> stateToOutput\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86285,"user_id":null,"body":"open System\n\ntype Tape = { Pointer: int; Values: Map<int, int> } with\n    member __.Output = __.Values.TryFind __.Pointer |> defaultArg <| 0\n    member __.Read x = { __ with Values = __.Values.Add (__.Pointer, x) }\n    member __.Flip = { __ with Values = __.Values.Add (__.Pointer, (1 - __.Output)) }\n    member __.Left = { __ with Pointer = __.Pointer - 1 }\n    member __.Right = { __ with Pointer = __.Pointer + 1 }\n    member __.Current = __.Output = 1\n\nlet getBits x = \n    x\n    |> List.unfold (fun x -> if x = 0 then None else Some (x % 2, x \/ 2))\n    |> List.append <| [0; 0; 0; 0; 0; 0; 0; 0]\n    |> List.take 8\n    \nlet getChar x =\n    x\n    |> List.mapi (fun i x -> x * (pown 2 i))\n    |> List.sum\n    |> char\n    \nlet getBlock code =\n    let rec getBlockR x cnt idx =\n        match x, cnt with\n        | ']'::t, 1 -> code |> List.splitAt (idx + 1)\n        | ']'::t, c -> getBlockR t (c - 1) (idx + 1)\n        | '['::t, c -> getBlockR t (c + 1) (idx + 1)\n        | _::t, c -> getBlockR t c (idx + 1)\n        | _ -> failwith \"No matching bracket\"\n        \n    getBlockR code 1 0\n\nlet interpret (code: string) (input: string) =\n  \n    let rec interpretR (tape: Tape) x (i: int list) s acc =\n        match i, s, x with\n        | _, _, [] -> List.rev acc\n        | _, _, ';'::t -> interpretR tape t i s (tape.Output::acc)\n        | [], _, ','::t -> interpretR (tape.Read 0) t [] s acc\n        | i::is, _, ','::t -> interpretR (tape.Read i) t is s acc\n        | _, _, '+'::t -> interpretR tape.Flip t i s acc\n        | _, _, '<'::t -> interpretR tape.Left t i s acc\n        | _, _, '>'::t -> interpretR tape.Right t i s acc\n        | _, _, '['::t ->\n            let (block, tail) = getBlock t\n            if tape.Current then interpretR tape t i (block::s) acc\n            else interpretR tape tail i s acc\n        | _, s::ss, ']'::t ->\n            if tape.Current then interpretR tape (s@t) i (s::ss) acc\n            else  interpretR tape t i ss acc\n        | _, _, _::t -> interpretR tape t i s acc\n    \n    let input =\n        input\n        |> Seq.collect (int >> getBits)\n        |> Seq.toList\n        \n    let tape = { Pointer = 0; Values = Map.empty }\n    \n    let code = code |> Seq.toList\n    \n    interpretR tape code input [] []\n    |> List.chunkBySize 8\n    |> List.map getChar\n    |> List.toArray\n    |> String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86286,"user_id":null,"body":"open System\n\nmodule Zipper =\n    type Zipper = Zipper of (int list) * int * (int list)\n\n    let map f z = match z with\n                  | Zipper (left, x, right) -> Zipper (left, f x, right)\n\n    let focus z = match z with\n                  | Zipper (_,x,_) -> x\n\n    \n\n    let left (z : Zipper) = match z with \n                            | Zipper ((y::ys),x,zs) -> Zipper (ys,y,(x::zs))\n                            | Zipper ([],x,zs) -> Zipper ([], 0, x::zs)\n    \n    let right (z : Zipper) = match z with\n                             | Zipper (ys, x, (z::zs)) -> Zipper ((x::ys), z, zs)\n                             | Zipper (ys, x, []) -> Zipper ((x::ys), 0, [])\n\nlet unmatch dir = if dir = 1 then '[' else ']'\nlet matcher dir = if dir = -1 then '[' else ']'\n\nlet rec matchingIndex count (code : char array) ic dir = \n    if code.[ic] = unmatch dir\n      then matchingIndex (count+1) code (ic+dir) dir\n      else \n        if code.[ic] = matcher dir\n          then\n            if count = 0 \n              then ic\n              else matchingIndex (count-1) code (ic+dir) dir\n          else matchingIndex count code (ic+dir) dir\n\n     \n                             \nlet rec go input (code : char array) ic zipper : int list = \n    if ic >= code.Length\n      then []\n      else \n        match code.[ic], input with\n        | '+', _ -> \n            let z = Zipper.map (fun x -> if x = 0 then 1 else 0) zipper\n            go input code (ic+1) z\n        | ',', (h::t) -> \n            let z = Zipper.map (fun _ -> h ) zipper\n            go t code (ic+1) z\n        | ';', _ -> \n            (Zipper.focus zipper) :: (go input code (ic+1) zipper)\n        | '<', _ ->\n            let z = Zipper.left zipper\n            go input code (ic+1) z\n        | '>', _ ->\n            let z = Zipper.right zipper\n            go input code (ic+1) z\n        | '[', _ ->\n            let ic' = if Zipper.focus zipper = 0 then matchingIndex 0 code (ic+1) 1 else ic\n            go input code (ic'+1) zipper\n        | ']', _ ->\n            let ic' = if Zipper.focus zipper = 1 then matchingIndex 0 code (ic-1) (-1) else ic\n            go input code (ic'+1) zipper\n        | _, _   -> go input code (ic+1) zipper\n\nlet charToBits (c: char) : int array =\n    Convert.ToString(int c, 2).PadLeft(8,'0')\n    |> Seq.toArray |> Array.rev |> Array.map (fun c -> int c - 48)\n\nlet stringToBits (input: string) : int list =\n    input \n    |> Seq.collect charToBits \n    |> Seq.toList\n\nlet rec drop n xs = \n    match xs,n with\n    | [],_ -> []\n    | ys,0 -> ys\n    | (h::t),n' -> drop (n'-1) t\n\nlet rec pwr x n =\n    match n with\n    | 0 -> 1\n    | n' -> x * pwr x (n' - 1)\n\nlet convert bits =\n    List.mapi (fun i x -> x * pwr 2 i ) bits\n    |> List.sum\n    |> char\n    |> string\n\nlet rec bitsAsString (coded: int list) : string =\n    match coded with\n    | [] -> \"\"\n    | xs -> let byt = Seq.truncate 8 xs |> Seq.toList\n            (convert byt) + (bitsAsString (drop 8 xs))\n    \nlet interpret (code: string) (input': string) : string = \n    \n    let zipper = Zipper.Zipper ([],0,[])\n\n    let input = stringToBits input'\n\n    let result = go input (Seq.toArray code) 0 zipper\n\n    bitsAsString result\n\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5862fb364f7ab46270000078":[{"id":86287,"user_id":null,"body":"let encrypt rule str = \n    str |> String.map (int >> (fun i -> (i + rule) % 256) >> char)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86288,"user_id":null,"body":"let encrypt rule str = \n    String.map (fun p -> (int p + rule) % 256 |> char) str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86289,"user_id":null,"body":"let encrypt rule str = \n  let r x = (x + rule) % 256\n  String.map (int >> r >> char) str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86290,"user_id":null,"body":"open System\n\nlet encrypt rule str =\n    let encryptChar c =\n        let numeric = rule + int c\n        if numeric <= 256 then\n            char numeric\n        else\n            char (numeric % 256)\n    str\n    |> Seq.map encryptChar\n    |> Seq.toArray\n    |> String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86291,"user_id":null,"body":"let encrypt rule = String.map (fun c -> (int c + rule) % 256 |> char)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86292,"user_id":null,"body":"let encrypt rule str =\n        String.collect\n            (fun i ->System.Char.ConvertFromUtf32 ((int i + rule) %  256))\n            str","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86293,"user_id":null,"body":"open System\n\nlet encrypt rule str = \n    str |> Seq.map int |> \n    Seq.map (fun x -> ((char)((x + rule) % 256)).ToString()) |> \n    String.concat \"\" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86294,"user_id":null,"body":"let encrypt (rule:int) = \n    String.map (fun c -> char (((int c) + rule) % 256))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86295,"user_id":null,"body":"let encrypt rule str = \n    str |> String.map (fun x -> char((int(x) + rule) % 256))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86296,"user_id":null,"body":"let encrypt rule str = \n        let encryptInternal c = \n            (c+rule)%256\n        let f = int >> encryptInternal >> char\n        System.String.Join(System.String.Empty, str|> Seq.map f)\n            ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"586423aa39c5abfcec0001e6":[{"id":86297,"user_id":null,"body":"open System.Linq\n\ntype Result =\n| Win = 0 \n| Loss = 1\n| Tie = 2\n\ntype CardType =\n| X2 = 2 | X3 = 3 | X4 = 4 | X5 = 5 | X6 = 6 | X7 = 7 | X8 = 8 | X9 = 9 | T = 10 | J = 11 | Q = 12 | K = 13 | A = 14\n\ntype HandType =\n| Kicker of CardType * CardType * CardType * CardType * CardType\n| Pair of CardType * CardType * CardType * CardType\n| Pairs of CardType * CardType * CardType\n| Three of CardType * CardType * CardType\n| Straight of CardType\n| Flush of CardType * CardType * CardType * CardType * CardType\n| FullHouse of CardType * CardType\n| Four of CardType * CardType\n| StraightFlush of CardType\n\ntype PokerHand (hand: string) =\n    do printfn \"%s\" hand\n    let parseCard (card:string) =\n      let t =\n        match card.[0] with\n        | '2' -> CardType.X2 | '3' -> CardType.X3 | '4' -> CardType.X4 | '5' -> CardType.X5 | '6' -> CardType.X6\n        | '7' -> CardType.X7 | '8' -> CardType.X8 | '9' -> CardType.X9 | 'T' -> CardType.T | 'J' -> CardType.J\n        | 'Q' -> CardType.Q | 'K' -> CardType.K | 'A' -> CardType.A | _ -> failwith \"Error\"\n      (t, card.[1])\n    let sortCards = List.sortByDescending (fun (t:CardType, _) -> t)\n    let parseHandType (sorted:(int*CardType) list) cards =\n      match cards with\n      | [(t1, m1); (t2, m2); (t3, m3); (t4, m4); (t5, m5)] ->\n        let isStraight = int(t1 - t2) = 1 && int(t2 - t3) = 1 && int(t3 - t4) = 1 && int(t4 - t5) = 1\n        let isLowStraight = t1 = CardType.A && t2 = CardType.X5 && t3 = CardType.X4 && t4 = CardType.X3 && t5 = CardType.X2\n        let isFlush = m1 = m2 && m1 = m3 && m1 = m4 && m1 = m5\n        if isStraight && isFlush then StraightFlush t1\n        elif isLowStraight && isFlush then StraightFlush t2\n        else\n          match sorted with\n          | (4, t1)::(1, t2)::_ -> Four (t1, t2)\n          | (3, t1)::(2, t2)::_ -> FullHouse (t1, t2)\n          | _ when isFlush -> Flush (t1, t2, t3, t4, t5)\n          | _ when isStraight -> Straight t1\n          | _ when isLowStraight -> Straight t2\n          | (3, t1)::(1, t2)::(1, t3)::_ -> Three (t1, t2, t3)\n          | (2, t1)::(2, t2)::(1, t3)::_ -> Pairs (t1, t2, t3)\n          | (2, t1)::(1, t2)::(1, t3)::(1, t4)::_ -> Pair (t1, t2, t3, t4)\n          | _ -> Kicker (t1, t2, t3, t4, t5)\n      | _ -> failwith \"Error\"\n\n    let handType =\n        let cards = hand.Split() |> List.ofArray |> List.map parseCard |> sortCards\n        let dict = new System.Collections.Generic.Dictionary<CardType, int>()\n        let add t = match dict.TryGetValue t with | true, v -> dict.[t] <- v + 1 | _ -> dict.Add(t, 1)\n        for (t, _) in cards do add t\n        let sorted = dict.OrderByDescending (fun pair -> pair.Value) |> Seq.toList |> List.map (fun card -> (card.Value, card.Key))\n        parseHandType sorted cards\n\n    member this.HandType = handType\n\n    member this.compareWith (pokerhand: PokerHand) =\n      match this.HandType, pokerhand.HandType with\n      | StraightFlush t_t1, StraightFlush o_t1 -> if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss else Result.Tie\n      | StraightFlush _, _ -> Result.Win\n      \n      | Four _, StraightFlush _ -> Result.Loss\n      | Four (t_t1, t_t2), Four (o_t1, o_t2) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        else Result.Tie\n      | Four _, _ -> Result.Win\n      \n      | FullHouse _, StraightFlush _  | FullHouse _, Four _ -> Result.Loss\n      | FullHouse (t_t1, t_t2), FullHouse (o_t1, o_t2) ->\n          if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n          elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n          else Result.Tie\n      | FullHouse _, _ -> Result.Win\n      \n      | Flush _, StraightFlush _  | Flush _, Four _ | Flush _, FullHouse _ -> Result.Loss\n      | Flush (t_t1, t_t2, t_t3, t_t4, t_t5), Flush (o_t1, o_t2, o_t3, o_t4, o_t5) ->\n          if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n          elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n          elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n          elif t_t4 > o_t4 then Result.Win elif t_t4 < o_t4 then Result.Loss\n          elif t_t5 > o_t5 then Result.Win elif t_t5 < o_t5 then Result.Loss\n          else Result.Tie\n      | Flush _, _ -> Result.Win\n      \n      | Straight _, StraightFlush _  | Straight _, Four _ | Straight _, FullHouse _ | Straight _, Flush _ -> Result.Loss\n      | Straight t_t1, Straight o_t1 -> if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss else Result.Tie\n      | Straight _, _ -> Result.Win\n      \n      | Three _, StraightFlush _  | Three _, Four _ | Three _, FullHouse _ | Three _, Flush _ | Three _, Straight _ -> Result.Loss\n      | Three (t_t1, t_t2, t_t3), Three (o_t1, o_t2, o_t3) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        else Result.Tie\n      | Three _, _ -> Result.Win\n      \n      | Pairs _, StraightFlush _  | Pairs _, Four _ | Pairs _, FullHouse _ | Pairs _, Flush _ | Pairs _, Straight _ | Pairs _, Three _ -> Result.Loss\n      | Pairs (t_t1, t_t2, t_t3), Pairs (o_t1, o_t2, o_t3) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        else Result.Tie\n      | Pairs _, _ -> Result.Win\n      \n      | Pair _, StraightFlush _  | Pair _, Four _ | Pair _, FullHouse _ | Pair _, Flush _\n      | Pair _, Straight _ | Pair _, Three _ | Pair _, Pairs _ -> Result.Loss\n      | Pair (t_t1, t_t2, t_t3, t_t4), Pair (o_t1, o_t2, o_t3, o_t4) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        elif t_t4 > o_t4 then Result.Win elif t_t4 < o_t4 then Result.Loss\n        else Result.Tie\n      | Pair _, _ -> Result.Win\n      \n      | Kicker (t_t1, t_t2, t_t3, t_t4, t_t5), Kicker (o_t1, o_t2, o_t3, o_t4, o_t5) ->\n        if t_t1 > o_t1 then Result.Win elif t_t1 < o_t1 then Result.Loss\n        elif t_t2 > o_t2 then Result.Win elif t_t2 < o_t2 then Result.Loss\n        elif t_t3 > o_t3 then Result.Win elif t_t3 < o_t3 then Result.Loss\n        elif t_t4 > o_t4 then Result.Win elif t_t4 < o_t4 then Result.Loss\n        elif t_t5 > o_t5 then Result.Win elif t_t5 < o_t5 then Result.Loss\n        else Result.Tie\n      | _ -> Result.Loss\n    override this.Equals (o:obj) = this.compareWith(o :?> PokerHand) = Result.Tie\n    interface System.IComparable with \n      member this.CompareTo (o:obj) =\n        let result = this.compareWith(o :?> PokerHand)\n        match result with\n        | Result.Win -> -1\n        | Result.Loss -> 1\n        | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86298,"user_id":null,"body":"open System\ntype PokerHandValues = HighCard of int*int*int*int*int | Pair of int*int*int*int | TwoPairs of int*int*int | ThreeOfAKind of int*int*int | Straight of int| Flush of int*int*int*int*int | FullHouse of int*int | FourOfAKind of int*int | StraightFlush of int\ntype PokerHand (hand: string) = \n    let ValueOfHand (hand:string) =\n        let (ranks,suits)  = \n            hand.Split ([| ' '|])\n            |> Array.map (fun card -> ((match card.[0] with | 'T' -> 10 | 'J' -> 11 | 'Q' -> 12 | 'K' -> 13 | 'A' -> 14 | digitChar -> int digitChar - int '0'), card.[1]))\n            |> Array.sortDescending\n            |> Array.unzip\n\n        let isFlush = suits |> Array.forall(fun suit -> suit = suits.[0])\n        let rankAndCounts = ranks |> Array.countBy (id) |> Array.sortByDescending(snd)\n        let (isStraight,topRank) =\n            if ranks.[0] = 14 && ranks.[1] = 5 && ranks.[2] = 4 && ranks.[3] = 3 && ranks.[4] = 2 then \n                (true, 5)\n            else \n                (rankAndCounts.Length = 5 && ranks.[0] - ranks.[4] = 4, ranks.[0])\n\n        \/\/type PokerHandValues = HighCard of int*int*int*int*int | Pair of int*int*int*int | TwoPairs of int*int*int | ThreeOfAKind of int*int*int | Straight of int| Flush of int*int*int*int*int | FullHouse of int*int | FourOfAKind of int*int | StraightFlush of int\n        match (isStraight,isFlush,snd rankAndCounts.[0],snd rankAndCounts.[1]) with\n        | (true, true, _,_) -> PokerHandValues.StraightFlush(topRank)\n        | (false,false,4,_) -> PokerHandValues.FourOfAKind(fst rankAndCounts.[0], fst rankAndCounts.[1])\n        | (false,false,3,2) -> PokerHandValues.FullHouse(fst rankAndCounts.[0], fst rankAndCounts.[1])\n        | (false,true, _,_) -> PokerHandValues.Flush(ranks.[0], ranks.[1], ranks.[2], ranks.[3], ranks.[4])\n        | (true, false,_,_) -> PokerHandValues.Straight(topRank)\n        | (false,false,3,1) -> PokerHandValues.ThreeOfAKind(fst rankAndCounts.[0], fst rankAndCounts.[1], fst rankAndCounts.[2])\n        | (false,false,2,2) -> PokerHandValues.TwoPairs(fst rankAndCounts.[0], fst rankAndCounts.[1], fst rankAndCounts.[2])\n        | (false,false,2,1) -> PokerHandValues.Pair(fst rankAndCounts.[0], fst rankAndCounts.[1], fst rankAndCounts.[2], fst rankAndCounts.[3])\n        | (_,_,_,_)         -> PokerHandValues.HighCard (ranks.[0], ranks.[1], ranks.[2], ranks.[3], ranks.[4])\n\n\n    member val HandValue = ValueOfHand hand\n    override this.Equals(otherObj:obj) =\n        match otherObj with\n        | :? PokerHand as other -> this.HandValue = other.HandValue\n        | _ -> false\n    override this.GetHashCode () = hash this.HandValue\n\n    interface System.IComparable with\n        member this.CompareTo (other : obj) =\n            match other with\n            | :? PokerHand as other -> if this.HandValue > other.HandValue then -1 elif this.HandValue < other.HandValue then 1 else 0\n            | _                     -> failwith \"Can only compare PokerHand objects to other PokerHand objects\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86299,"user_id":null,"body":"type Suit = | Diamond | Heart | Spade | Club\ntype Kind = | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\ntype Card = Kind * Suit\n\n\/\/ categories highest to lowest\ntype Category =\n    | StraightFlush of Kind \/\/ highest\n    | FullHouse of Kind * Kind \/\/ triplet & duplet\n    | FourOfAKind of Kind\n    | Flush of Kind list \/\/ five cards sorted by rank descending\n    | Straight of Kind \/\/ highest\n    | ThreeOfAKind of Kind\n    | TwoPair of Kind * Kind\n    | OnePair of Kind\n    | HighCard of Kind\n\nlet private parseKind = function\n    | \"2\" -> Two\n    | \"3\" -> Three\n    | \"4\" -> Four\n    | \"5\" -> Five\n    | \"6\" -> Six\n    | \"7\" -> Seven\n    | \"8\" -> Eight\n    | \"9\" -> Nine\n    | \"T\" -> Ten\n    | \"J\" -> Jack\n    | \"Q\" -> Queen\n    | \"K\" -> King\n    | \"A\" -> Ace\n    | c -> failwithf \"invalid card %s\" c\n\nlet private parseSuit =\n    function\n    | \"D\" -> Diamond\n    | \"H\" -> Heart\n    | \"C\" -> Club\n    | \"S\" -> Spade\n    | s -> failwithf \"invalid suit %s\" s\n\n\nlet private parseHand (hand : string) : Card list =\n    let cards = \n        hand.Split(' ')\n        |> List.ofArray\n        |> List.map (fun cardStr -> (cardStr.Substring(0, cardStr.Length-1) |> parseKind), (cardStr.Substring(cardStr.Length - 1) |> parseSuit))\n    if cards.Length <> 5 then\n        failwith \"invalid number of cards\"\n    \n    \/\/ random tests have duplicate cards so had to comment out this otherwise legit validation\n    \/\/if (List.distinct cards).Length <> 5 then\n    \/\/    failwith \"hand has duplicate cards\"\n    cards\n\nlet private kindRank aceIsHighest =\n    function\n    | Two -> 2\n    | Three -> 3\n    | Four -> 4\n    | Five -> 5\n    | Six -> 6\n    | Seven -> 7\n    | Eight -> 8\n    | Nine -> 9\n    | Ten -> 10\n    | Jack -> 11\n    | Queen -> 12\n    | King -> 13\n    | Ace -> if aceIsHighest then 14 else 1\n\nlet private tryFindStraight (hand : Card list) =\n    let isStraight rankedHand = \n        let lowestRank = List.last rankedHand |> snd\n        rankedHand |> List.map (fun (_, r) -> r - lowestRank) = [4; 3; 2; 1; 0]\n\n    let rankedByHighAce =\n        hand |> List.map (fun c -> c, kindRank true (fst c)) |> List.sortByDescending snd\n    let rankedByLowAce =\n        hand |> List.map (fun c -> c, kindRank false (fst c)) |> List.sortByDescending snd\n    if rankedByHighAce |> isStraight\n    then rankedByHighAce |> List.map fst |> Some\n    elif rankedByLowAce |> isStraight\n    then rankedByLowAce |> List.map fst |> Some\n    else None\n\nlet private categorizeHand (hand : Card list) =\n    let suitGroups = hand |> List.groupBy snd |> List.map (fun (suit, cs) -> suit, cs |> List.map fst)\n    let kindCounts = hand |> List.countBy fst |> List.sortByDescending snd\n    let maybeStraight = tryFindStraight hand\n    \n    let highCards = List.map (fst >> HighCard)\n\n    match suitGroups, maybeStraight, kindCounts with\n    | [_], Some straightCards, _ -> \/\/ one suit, straight\n        [StraightFlush (List.head straightCards |> fst)]\n    | _, _, [(k1, 4); (k2, 1)] ->\n        [FourOfAKind k1; HighCard k2]\n    | _, _, [(k1, 3); (k2, 2)] ->\n        [FullHouse (k1, k2)]\n    | [ks], _, _ ->\n        [Flush (snd ks)]\n    | _, Some straightCards, _ ->\n        [Straight (List.head straightCards |> fst)]\n    | _, _, (k, 3) :: ks ->\n        ThreeOfAKind k :: (highCards ks)\n    | _, _, [(k1, 2); (k2, 2); (k3, 1)] ->\n        [TwoPair (k1, k2); HighCard k3]\n    | _, _, (k, 2) :: ks ->\n        OnePair k :: (highCards ks)\n    | _, _, ks ->\n        highCards ks\n\nlet private handRank =\n    let kr = kindRank true\n    let krs = List.map kr >> List.sortDescending\n    let rank = \n        function\n        | StraightFlush k -> (9, [kr k])\n        | FourOfAKind k -> (8, [kr k])\n        | FullHouse (k1, k2) -> (7, [kr k1; kr k2]) \/\/ don't sort ranks of full house, \n        | Flush ks -> (6, krs ks)\n        | Straight k -> (5, [kr k])\n        | ThreeOfAKind k -> (4, [kr k])\n        | TwoPair (k1, k2) -> (3, krs [k1; k2])\n        | OnePair k -> (2, [kr k])\n        | HighCard k -> (1, [kr k])\n    categorizeHand >> List.map rank >> List.sortDescending\n\n      \ntype PokerHand (hand: string) =\n\n    let _rank = hand |> parseHand |> handRank \n    member this.hand = hand\n    member this.rank = _rank\n\n    interface System.IComparable<PokerHand> with\n        member this.CompareTo other =\n            compare other.rank this.rank\n\n    interface System.IComparable with\n        member this.CompareTo obj =\n            match obj with\n              | null                 -> 1\n              | :? PokerHand as other -> (this :> System.IComparable<_>).CompareTo other\n              | _                    -> invalidArg \"obj\" \"not a PokerHand\"\n    interface System.IEquatable<PokerHand> with\n        member this.Equals other =\n            this.hand = other.hand\n    override this.Equals obj =\n        match obj with\n          | :? PokerHand as other -> (this :> System.IEquatable<_>).Equals other\n          | _                    -> false\n    override this.GetHashCode () =\n        hash this.hand","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86300,"user_id":1617,"body":"type PokerHand =\n    struct\n        val Score: int list\n        new(hand: string) =\n            let ranks = Map.ofSeq (Seq.map (fun (l, r) -> (r, l)) (Seq.indexed \"23456789TJQKA\"))\n\n            let cs = Seq.toList (hand.Split(' '))\n            let hrs = List.sortDescending (List.map (fun (s: string) -> ranks.[s.[0]]) cs)\n\n            let lrs =\n                List.sortDescending\n                    (List.map (function\n                        | 12 -> -1\n                        | r -> r) hrs)\n\n            let flsh = List.length (List.distinctBy (fun (s: string) -> s.[1]) cs) = 1\n            let lstrt = List.length (List.distinct (List.mapi (+) lrs)) = 1\n            let hstrt = List.length (List.distinct (List.mapi (+) hrs)) = 1\n            let strt = lstrt || hstrt\n\n            let rs =\n                if lstrt then lrs else hrs\n\n            let score =\n                match List.sortDescending (List.map snd (List.countBy id rs)) with\n                | _ when strt && flsh -> 8\n                | 4 :: _ -> 7\n                | 3 :: 2 :: _ -> 6\n                | _ when flsh -> 5\n                | _ when strt -> 4\n                | 3 :: _ -> 3\n                | 2 :: 2 :: _ -> 2\n                | 2 :: _ -> 1\n                | _ -> 0\n                :: rs\n\n            { Score = List.map (fun v -> -v) score }\n    end\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86301,"user_id":null,"body":"open System\n\ntype Suit =\n    | Spade\n    | Heart\n    | Diamond\n    | Club\n\ntype Rank =\n    | LowAce = 1\n    | Two = 2\n    | Three = 3\n    | Four = 4\n    | Five = 5\n    | Six = 6\n    | Seven = 7\n    | Eight = 8\n    | Nine = 9\n    | Ten = 10\n    | Jack = 11\n    | Queen = 12\n    | King = 13\n    | Ace = 14\n\ntype HandValue =\n    | OnePair of Rank\n    | TwoPairs of Rank * Rank\n    | ThreeOfAKind of Rank\n    | LowStraight of Rank\n    | HighStraight of Rank\n    | Flush of Rank\n    | FullHouse of Rank * Rank\n    | FourOfAKind of Rank\n    | LowStraightFlush of Rank\n    | HighStraightFlush of Rank\n\ntype Card(value: string) =\n    let getRank r =\n        match r with\n        | '2' -> Rank.Two\n        | '3' -> Rank.Three\n        | '4' -> Rank.Four\n        | '5' -> Rank.Five\n        | '6' -> Rank.Six\n        | '7' -> Rank.Seven\n        | '8' -> Rank.Eight\n        | '9' -> Rank.Nine\n        | 'T' -> Rank.Ten\n        | 'J' -> Rank.Jack\n        | 'Q' -> Rank.Queen\n        | 'K' -> Rank.King\n        | 'A' -> Rank.Ace\n        | _ -> failwith <| string r\n\n    let getSuit s =\n        match s with\n        | 'S' -> Spade\n        | 'H' -> Heart\n        | 'D' -> Diamond\n        | 'C' -> Club\n        | _ -> failwith <| string s\n\n    let rank = getRank <| value.ToCharArray().[0]\n    let suit = getSuit <| value.ToCharArray().[1]\n\n    member this.Suit = suit\n    member this.Rank = rank\n\n    override this.ToString() = sprintf \"%A of %As\" rank suit\n\nlet getHandValue (cards: Card list) =\n    let allSuitsMatch cards =\n        (cards |> List.distinctBy (fun (c: Card) -> c.Suit)).Length = 1\n\n    let getCardRanksLow cards =\n        List.map (fun (c: Card) ->\n            if c.Rank = Rank.Ace then Rank.LowAce else c.Rank) cards\n        |> List.sortDescending\n\n    let getCardRanksHigh cards = List.map (fun (c: Card) -> c.Rank) cards\n\n    let groupCardsByRank (cards: Card list) =\n        cards\n        |> List.groupBy (fun (c: Card) -> c.Rank)\n\n    let isHighStraight (cards: Card list) =\n        cards\n        |> getCardRanksHigh\n        |> List.windowed 2\n        |> List.forall (fun l ->\n            int l.Head = int l.Tail.Head + 1)\n\n    let isLowStraight (cards: Card list) =\n        cards\n        |> getCardRanksLow\n        |> List.windowed 2\n        |> List.forall (fun l ->\n            int l.Head = int l.Tail.Head + 1)\n\n    let tryGetHighStraightFlush cards =\n        if allSuitsMatch cards && isHighStraight cards\n            then Some <| HighStraightFlush cards.Head.Rank\n        else None\n\n    let tryGetLowStraightFlush cards =\n        if allSuitsMatch cards && isLowStraight cards\n            then Some <| LowStraightFlush cards.Head.Rank\n        else None\n\n    let tryGetXOfAKind n resultType cards =\n        let result =\n            cards\n            |> groupCardsByRank\n            |> List.choose (fun (rank, l) ->\n                if l.Length = n then Some rank else None)\n\n        match result.Length with\n        | 0 -> None\n        | _ -> Some <| resultType result.Head\n\n    let tryGetFullHouse cards =\n        let grouped =\n            groupCardsByRank cards\n            |> List.sortByDescending (fun (_, l) -> l.Length)\n\n        let firstGroupRank, firstGroupList = grouped.Head\n        let secondGroupRank = fst grouped.Tail.Head\n\n        if grouped.Length = 2 && firstGroupList.Length = 3\n            then Some <| FullHouse (firstGroupRank, secondGroupRank)\n        else None\n\n    let tryGetFlush cards =\n        if allSuitsMatch cards then Some <| Flush cards.Head.Rank\n        else None\n\n    let tryGetLowStraight cards =\n        if isLowStraight cards then Some <| LowStraight cards.Head.Rank\n        else None\n\n    let tryGetHighStraight cards =\n        if isHighStraight cards then Some <| HighStraight cards.Tail.Head.Rank\n        else None\n\n    let tryGetTwoPair cards =\n        let grouped =\n            groupCardsByRank cards\n            |> List.sortByDescending (fun (_, l) -> l.Length)\n\n        let firstGroupRank, firstGroupList = grouped.Head\n        let secondGroupRank, secondGroupList = grouped.Tail.Head\n\n        if firstGroupList.Length = 2 && secondGroupList.Length = 2\n            then Some <| TwoPairs (firstGroupRank, secondGroupRank)\n        else None\n\n    let (>>=) m f =\n        match m with\n        | None -> f()\n        | Some x -> Some x\n\n    let sortedCards = List.sortByDescending (fun (c: Card) -> c.Rank) cards\n\n    tryGetHighStraightFlush sortedCards\n    >>= fun _ -> tryGetLowStraightFlush sortedCards\n    >>= fun _ -> tryGetXOfAKind 4 FourOfAKind sortedCards\n    >>= fun _ -> tryGetFullHouse sortedCards\n    >>= fun _ -> tryGetFlush sortedCards\n    >>= fun _ -> tryGetHighStraight sortedCards\n    >>= fun _ -> tryGetLowStraight sortedCards\n    >>= fun _ -> tryGetXOfAKind 3 ThreeOfAKind sortedCards\n    >>= fun _ -> tryGetTwoPair sortedCards\n    >>= fun _ -> tryGetXOfAKind 2 OnePair sortedCards\n\n\ntype PokerHand(hand: string) =\n    let cards =\n        printf \"%s\n\" hand\n        hand.Split ' '\n        |> Array.map Card\n        |> Array.toList\n\n\n    let cardValues =\n        cards\n        |> List.map (fun c -> c.Rank)\n        |> List.sortDescending\n        |> List.map int\n\n    let handValue = getHandValue cards\n\n    let handValueArray =\n        let handValue =\n            match handValue with\n            | None -> [0]\n            | Some (OnePair r) -> [1; int r]\n            | Some (TwoPairs (r1, r2)) -> [2; int r1; int r2]\n            | Some (ThreeOfAKind r) -> [3; int r]\n            | Some (LowStraight _) -> [4]\n            | Some (HighStraight _) -> [5]\n            | Some (Flush _) -> [6]\n            | Some (FullHouse (r1, r2)) -> [7; int r1; int r2]\n            | Some (FourOfAKind r) -> [8; int r]\n            | Some (LowStraightFlush _) -> [9]\n            | Some (HighStraightFlush _) -> [10]\n\n        List.append handValue cardValues\n\n    member this.HandValue = handValue\n\n    member this.HandValueArray = handValueArray\n\n    interface IComparable<PokerHand> with\n        member this.CompareTo other =\n            match handValueArray, other.HandValueArray with\n            | (a, b) when a > b -> -1\n            | (a, b) when a = b -> 0\n            | _ -> 1\n\n    interface IComparable with\n        member this.CompareTo obj =\n            match obj with\n                | :? PokerHand as other ->\n                    (this :> IComparable<_>).CompareTo other\n                | _ -> invalidArg \"obj\" \"Unexpected\"\n\n    override this.Equals obj =\n        match obj with\n        | :? PokerHand as other -> handValue = other.HandValue\n        | _ -> false\n\n    override this.ToString() =\n        sprintf \"%s\n Hand of: %s\" hand <| String.concat \", \" (List.map string cards)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86302,"user_id":null,"body":"open System\n\ntype PokerHand (hand: String) =\n    let rank =\n        let cardRank =\n            function\n            | 'A' -> 14\n            | 'K' -> 13\n            | 'Q' -> 12\n            | 'J' -> 11\n            | 'T' -> 10\n            | c when c >= '2' && c <= '9' -> c |> string |> int\n            | _ -> failwith \"Invalid card rank.\"\n\n        let hand =\n            hand.Split ' '\n            |> List.ofArray\n            |> List.map (fun s -> (cardRank (s.[0]), s.[1]))\n            |> List.sortByDescending fst\n\n        let isFlush =\n            hand\n            |> List.distinctBy snd\n            |> List.length\n            |> (=) 1\n\n        let isStraight =\n            hand\n            |> List.map (fun (rank, _) -> rank)\n            |> List.sort\n            |> List.pairwise\n            |> List.map (fun (l, r) -> r - l)\n            |> List.exists (fun x -> x <> 1)\n            |> not\n\n        let isLowAceStraight =\n            hand\n            |> List.map (fun (rank, _) -> rank)\n            |> List.sortDescending\n            |> (=) [14;5;4;3;2]\n\n        let counts =\n            hand\n            |> List.map fst\n            |> List.countBy id\n            |> List.sortByDescending (fun (_,c) -> c)\n\n        let handRank =\n            match (counts |> List.map snd) with\n            | _ when isStraight && isFlush       -> 10 \/\/ StraightFlush\n            | _ when isLowAceStraight && isFlush -> 9 \/\/ LowAceStraightFlush\n            | [4;1]                              -> 8 \/\/ FourOfAKind\n            | [3;2]                              -> 7 \/\/ FullHouse\n            | _ when isFlush                     -> 6 \/\/ Flush\n            | _ when isStraight                  -> 5 \/\/ Straight\n            | _ when isLowAceStraight            -> 4 \/\/ 5,4,3,2,A\n            | [3;1;1]                            -> 3 \/\/ ThreeOfAKind\n            | [2;2;1]                            -> 2 \/\/ TwoPairs\n            | [2;1;1;1]                          -> 1 \/\/ OnePair\n            | _                                  -> 0 \/\/ HighCard\n\n        let uniqueCardRanks = counts |> List.map fst\n        (int handRank)::(uniqueCardRanks)\n\n    member this.Rank = rank\n    member this.Hand = hand\n\n    override this.GetHashCode() =\n        hash this.Rank\n\n    override this.Equals(thatObj) =\n        match thatObj with\n        | :? PokerHand as that -> this.Rank = that.Rank\n        | _ -> false\n\n    interface IEquatable<PokerHand> with\n        member this.Equals(that : PokerHand) =\n            this.Equals(that)\n\n    interface IComparable with\n        member this.CompareTo(thatObj) =\n            match thatObj with\n            | :? PokerHand as that -> \n                \/\/printfn \"%s %A, %s %A\" this.Hand this.Rank that.Hand that.Rank\n                compare that.Rank this.Rank\n            | _ -> failwith \"Can't compare instances of different types\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86303,"user_id":null,"body":"open System\ntype Suite =\n    | Spades = 83\n    | Hearts = 72\n    | Diamonds = 68\n    | Clubs = 67\n\n\/\/ int value of the respective char\ntype Value =\n    | Two = 50\n    | Three = 51\n    | Four = 52\n    | Five = 53\n    | Six = 54\n    | Seven = 55\n    | Eight = 56\n    | Nine = 57\n    | Ten = 84\n    | Jack = 74\n    | Queen = 81\n    | King = 75\n    | Ace = 65\n\ntype Card =\n    struct\n        val suite: Suite\n        val value: Value\n\n        new(str: string) =\n            let s = enum (str.[1] |> int)\n            let v = enum (str.[0] |> int)\n            { suite = s\n              value = v }\n    end\n\n    member __.Order =\n        match __.value with\n        | Value.Two -> 1\n        | Value.Three -> 2\n        | Value.Four -> 3\n        | Value.Five -> 4\n        | Value.Six -> 5\n        | Value.Seven -> 6\n        | Value.Eight -> 7\n        | Value.Nine -> 8\n        | Value.Ten -> 9\n        | Value.Jack -> 10\n        | Value.Queen -> 11\n        | Value.King -> 12\n        | Value.Ace -> 13\n        | _ -> failwith \"Unknown card value encountered\"\n\ntype Rank =\n    | RoyalFlush = 0\n    | StraightFlush = 1\n    | FourOfAKind = 2\n    | FullHouse = 3\n    | Flush = 4\n    | Striaght = 5\n    | ThreeOfAKind = 6\n    | TwoPairs = 7\n    | Pair = 8\n    | HighCard = 9\n\ntype PokerHand(hand: string) as this =\n    let mutable rank = Rank.HighCard\n    let mutable cards = List.empty\n\n    do\n        cards <-\n            hand.Split(' ')\n            |> Array.map (fun def ->\n                let c = Card def\n                c)\n            |> List.ofArray\n        this.InitializeRank()\n\n    member __.Source = hand\n\n    member this.Cards = cards\n\n\n    member __.Rank = rank\n\n    member private this.InitializeRank() =\n        let crds = this.Cards |> List.sortBy (fun c -> c.Order)\n\n        let isSameSuite =\n            (crds\n             |> Seq.groupBy (fun c -> c.suite)\n             |> Seq.length) = 1\n\n        let straightChecker (cards: Card list) =\n            cards\n            |> List.windowed 2\n            |> List.forall (fun pair -> pair.[1].Order - pair.[0].Order = 1)\n\n        \/\/ straights are complex because of the possible starting Ace\n        let isSomeStraight = crds |> straightChecker\n\n        let isAceStartingStraight =\n            (crds.[4].value = Value.Ace) && (crds.[0].value = Value.Two) && (crds\n                                                                             |> List.take 4\n                                                                             |> straightChecker)\n\n        let isAceEndingStraight = isSomeStraight && (crds.[4].value = Value.Ace)\n\n        let isStraight = isSomeStraight || isAceStartingStraight || isAceEndingStraight\n\n        \/\/ a map of value -> count\n        let groupByValue =\n            crds\n            |> List.groupBy (fun c -> c.value)\n            |> List.map (fun (k, g) -> (k, g |> Seq.length))\n            |> Map.ofList\n\n        let repeatedValueChecker length = groupByValue |> Map.exists (fun _ count -> count = length)\n\n        let hasFour = repeatedValueChecker 4\n        let hasThree = repeatedValueChecker 3\n        let hasTwo = repeatedValueChecker 2\n\n        \/\/ there must be two values of count 2\n        let hasTwoPairs =\n            hasTwo && groupByValue\n                      |> Map.filter (fun _ count -> count = 2)\n                      |> Map.count = 2\n\n        let fullHouse =\n            groupByValue\n            |> Map.exists (fun _ count -> count = 2)\n            && groupByValue |> Map.exists (fun _ count -> count = 3)\n\n        rank <-\n            if isSameSuite && isAceEndingStraight then Rank.RoyalFlush\n            elif isSameSuite && isStraight then Rank.StraightFlush\n            elif hasFour then Rank.FourOfAKind\n            elif fullHouse then Rank.FullHouse\n            elif isSameSuite then Rank.Flush\n            elif isStraight then Rank.Striaght\n            elif hasThree then Rank.ThreeOfAKind\n            elif hasTwoPairs then Rank.TwoPairs\n            elif hasTwo then Rank.Pair\n            else Rank.HighCard\n\n    interface System.IComparable with\n        member x.CompareTo y =\n            match y with\n            | :? PokerHand as hand ->\n                let r1 = x.Rank\n                let r2 = hand.Rank\n                r1.CompareTo r2\n            | _ -> 0\n\n    override this.Equals(obj) =\n        match obj with\n        | :? PokerHand as hand -> (this :> IComparable).CompareTo(hand) = 0\n        | _ -> Object.ReferenceEquals(this, obj)\n\n    override this.GetHashCode() = this.Rank.GetHashCode()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86304,"user_id":null,"body":"type PokerHand(hand: string) =\n  let Cards = hand.Split() |> Array.map(fun s -> s.[0], s.[1]) |> Array.unzip\n  let Values = fst Cards |> Array.map(fun c -> Seq.findIndex((=) c) \"23456789TJQKA\" + 2) |> Array.sort\n  let w = 15\n  let w5 = pown w 5\n  let Flush = \n    let s = snd Cards\n    Array.max s = Array.min s\n  let Counts = Values |> Array.countBy(id)\n  let Straight = \n    let a = Values.[0]\n    if Values = [|a; a+1; a+2; a+3; a+4|]\n    then 1\n    else if Values = [|2; 3; 4; 5; 14|] then -1 \n                                        else 0\n  let Higher =\n    let v = Values\n    w*(w*(w*(w*v.[4]+v.[3])+v.[2])+v.[1])+v.[0]\n  let Freqs = Counts |> Array.map(snd) |> Array.sort\n  let Parts n = \n    let ps = Counts |> Array.partition(fun (k, v) -> v=n)\n    fst ps |> Array.map(fst), snd ps |> Array.map(fst)\n  let StraightFlush = Flush && Values = [|10; 11; 12; 13; 14|]\n  member this.Rank = \n    if StraightFlush\n    then -9*w5\n    else if Flush && Straight<>0 \n         then if Straight = 1  \n              then -8*w5-Values.[4] \n              else -8*w5-5\n         else match Freqs with\n              | [|1; 4|] -> let p1, p2 = Parts 4\n                            -7*w5-w*4*p1.[0]-p2.[0]\n              | [|2; 3|] -> let p1, p2 = Parts 3\n                            -6*w5-w*3*p1.[0]-2*p2.[0]\n              | _ -> if Flush\n                     then -5*w5-Higher\n                     else match Straight with\n                          | 1 -> -4*w5-Values.[4]\n                          | -1 -> -4*w5-5\n                          | _ -> match Freqs with\n                                 | [|1; 1; 3|] -> let p1, p2 = Parts 3\n                                                  -3*w5-w*(w*3*p1.[0]+p2.[1])-p2.[0]\n                                 | [|1; 2; 2|] -> let p1, p2 = Parts 2\n                                                  -2*w5-w*(w*2*p1.[1]+2*p1.[0])-p2.[0]\n                                 | [|1; 1; 1; 2|] -> let p1, p2 = Parts 2\n                                                     -w5-w*(w*(w*2*p1.[0]+p2.[2])+p2.[1])-p2.[0]\n                                 | _ -> -Higher\n  override x.GetHashCode() = x.Rank.GetHashCode()\n  override x.Equals(obj: obj) = x.Rank = (obj :?> PokerHand).Rank\n  interface System.IComparable with\n    member x.CompareTo(obj: obj) = compare x.Rank (obj :?> PokerHand).Rank","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86305,"user_id":null,"body":"type Result =\n    | Win = 0 \n    | Loss = 1\n    | Tie = 2\n\ntype Suit = Spades | Hearts | Diamonds | Clubs\n\ntype CardValue =\n    | Two = 2\n    | Three = 3\n    | Four = 4\n    | Five = 5\n    | Six = 6\n    | Seven = 7\n    | Eight = 8\n    | Nine = 9\n    | Ten = 10\n    | Jack = 11\n    | Queen = 12\n    | King = 13\n    | Ace = 14\n\ntype Card = {suit:Suit; value:CardValue}\n\ntype Combination =\n    | HighCard of CardValue list\n    | OnePair of CardValue list\n    | TwoPairs of CardValue list\n    | ThreeOfKind of CardValue list\n    | Straight of CardValue list\n    | Flush of CardValue list\n    | FullHouse of CardValue list\n    | FourOfKind of CardValue list\n    | StraighFlush of CardValue list\n\nlet parseCard (s:string):Card =\n    if s.Length <> 2 then failwith \"wrong card format\"\n    let value = \n        match s.[0] with\n        | c when c > '1' && c <= '9' -> enum (int c - int '0')\n        | 'T' -> CardValue.Ten\n        | 'J' -> CardValue.Jack \n        | 'Q' -> CardValue.Queen\n        | 'K' -> CardValue.King\n        | 'A' -> CardValue.Ace\n        | _ -> failwith \"wrong card value\"\n\n    let suit = \n        match s.[1] with\n        | 'S' -> Spades\n        | 'H' -> Hearts\n        | 'D' -> Diamonds\n        | 'C' -> Clubs\n        | _ -> failwith \"Unknown suit\"    \n    {suit = suit; value = value}\n\nlet parseHand (s:string) = \n    if s.Length <> 14 then failwith \"wrong card amount\"\n    s.Split(' ')\n    |> Array.map parseCard\n    |> Array.sortByDescending (fun x-> x.value)\n    |> List.ofArray\n\n\n\nlet isStraight (hand:Card list) =\n    let check (l:Card list) =\n        l\n        |> List.windowed 2 \n        |> List.forall (fun x -> (int x.[0].value - int x.[1].value) = 1)\n    match hand with\n    | x::tail when x.value = CardValue.Ace \n        -> if check tail \n            then \n                if tail.Head.value = CardValue.Five \n                then Some CardValue.Five \n                else if tail.Head.value = CardValue.King \n                then Some CardValue.Ace\n                else None\n            else\n                None                \n    | _ -> if check hand then Some hand.Head.value else None\n    \n\nlet isFlush (hand:Card list) =\n    let suit = hand.Head.suit\n    hand |> List.forall (fun x -> x.suit = suit) \n\nlet (|MatchStraight|_|) (hand: Card list) =\n    match isStraight hand with\n    | Some v -> Some (Straight [v])\n    | None -> None\n\n\nlet (|MatchFlush|_|) (hand:Card list) =\n    if isFlush hand \n    then Some (Flush <| List.map (fun (x:Card) -> x.value) hand) \n    else None\n\nlet (|MatchStraighFlush|_|) (hand:Card list) =\n    if isFlush hand \n    then\n        match isStraight hand with\n        | Some v -> Some (StraighFlush [v])\n        | None -> None\n    else None\n\nlet (|MatchFourOrFullHouse|_|) (hand:Card list) =\n    match List.countBy (fun (x:Card) -> x.value) hand |> List.sortByDescending snd with\n    | [(f,4);(r,1)] -> Some (FourOfKind [f;r])\n    | [(t,3);(d,2)] | [(t,3);(d,2)] -> Some (FullHouse [t;d])\n    | _ -> None\n\nlet (|MatchGroupCombinations|) (hand:Card list) =\n    match List.countBy (fun (x:Card) -> x.value) hand |> List.sortByDescending snd with\n    | [(t,3); (c1,1); (c2,1)] -> Some (ThreeOfKind [t;c1;c2])\n    | [(p1,2); (p2,2); (r,1)] -> Some (TwoPairs [p1;p2;r])\n    | [(p,2); (c1,1); (c2,1); (c3,1)] -> Some (OnePair [p;c1;c2;c3])\n    | _ -> Some (HighCard <| List.map (fun (x:Card) -> x.value) hand)\n\nlet getCombination =\n    function\n    |MatchStraighFlush comb -> comb\n    |MatchFourOrFullHouse comb -> comb\n    |MatchFlush comb -> comb\n    |MatchStraight comb -> comb\n    |MatchGroupCombinations comb -> comb.Value\nopen System\ntype PokerHand (hand: string) =\n    let comb = hand |> parseHand |> getCombination\n    \n    interface IComparable<PokerHand> with\n        member this.CompareTo (pokerhand: PokerHand) =\n            match (this.combination, pokerhand.combination) with\n            | (a,b) when a>b -> -1\n            | (a,b) when a<b -> 1\n            | _ -> 0\n    interface IComparable with\n        member this.CompareTo obj =\n            match obj with\n              | null                 -> 1\n              | :? PokerHand as other -> (this :> IComparable<_>).CompareTo other\n              | _  -> invalidArg \"obj\" \"not a PokerHand\"\n\n    interface IEquatable<PokerHand> with\n        member this.Equals (pokerhand: PokerHand) =\n            this.combination = pokerhand.combination\n    override this.Equals obj =\n        match obj with\n          | :? PokerHand as other -> (this :> IEquatable<_>).Equals other\n          | _                    -> false\n    override this.GetHashCode () =\n        hash (this.combination)\n    \n    member __.combination = comb    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86306,"user_id":2098,"body":"open System\n\ntype Num = \n    | Two \n    | Three \n    | Four \n    | Five \n    | Six \n    | Seven \n    | Eight \n    | Nine \n    | Ten \n    | Jack \n    | Queen \n    | King \n    | Ace\n    \ntype Type = \n    | Club \n    | Diamond \n    | Spade \n    | Heart\n      \ntype Crd = Num * Type\n\ntype Rnk =\n    | NotSupported\n    | HighCrd of Num * Num * Num * Num * Num\n    | OnePair of Num * Num * Num * Num\n    | TwoPair of Num * Num * Num\n    | ThreeOfAKind of Num * Num * Num\n    | Straight of Num\n    | Flush of Num * Num * Num * Num * Num\n    | FullHouse of Num * Num\n    | FourOfAKind of Num * Num\n    | StraightFlush of Num\n\ntype PokerHand (hand: string) =\n    let getCrds (str: string) =\n        let typsMap = [('C', Club); ('D', Diamond); ('S', Spade); ('H', Heart)] |> Map.ofList\n        let numsMap = [('2', Two); ('3', Three); ('4', Four); ('5', Five); ('6', Six);\n                        ('7', Seven); ('8', Eight); ('9', Nine); ('T', Ten); ('J', Jack);\n                        ('Q', Queen); ('K', King); ('A', Ace)] |> Map.ofList\n\n        let crdFromString (s:string) : Crd =\n            (numsMap.[s.[0]], typsMap.[s.[1]])\n\n        str.Split() |> Array.map(crdFromString)\n\n    let rnk crds =\n        let strt (arr: Num array) =\n            [|Two; Three; Four; Five; Six; Seven; Eight; Nine; Ten; Jack; Queen; King; Ace|]\n            |> Array.skipWhile (fun el -> el <> arr.[0])\n            |> Array.take (Array.length arr)\n            |> fun a1 -> a1 = arr\n\n        let isFlush (arr: Crd array) =\n            arr |> Array.groupBy(fun (_, typ) -> typ) |> Array.length |> fun c -> c = 1\n\n        crds \n        |> Array.groupBy (fun (num, _) -> num) \n        |> Array.map(fun (num, l) -> (Array.length l, num))\n        |> Array.sort\n        |> fun arr -> \n            match arr with\n            | [|(1,v2);(4,v1)|] -> FourOfAKind (v1, v2)\n            | [|(2,v2);(3,v1)|] -> FullHouse (v1, v2)\n            | [|(1,v3);(1,v2);(3,v1)|] -> ThreeOfAKind (v1, v2, v3)\n            | [|(1,v3);(2,v2);(2,v1)|] -> TwoPair (v1, v2, v3) \n            | [|(1,v4);(1,v3);(1,v2);(2,v1)|] -> OnePair (v1, v2, v3, v4)\n            | [|(1,Two);(1,Three);(1,Four);(1,Five);(1,Ace)|] -> \n                if isFlush crds then StraightFlush Five else Straight Five\n            | [|(1,v5);(1,v4);(1,v3);(1,v2);(1,v1)|] ->\n                match (strt [|v5;v4;v3;v2;v1|], isFlush crds) with\n                | (true, true) -> StraightFlush v1\n                | (true, false) -> Straight v1\n                | (false, true) -> Flush (v1, v2, v3, v4, v5)\n                | (false, false) -> HighCrd (v1, v2, v3, v4, v5)\n            | _ ->\n                NotSupported\n    \n    let crds = getCrds hand\n    let rank = rnk crds\n\n    member this.Orig = hand\n    member this.Crds = crds\n    member this.Rank = rank\n\n    override this.ToString() =\n        sprintf \"%A => %A\" this.Crds this.Rank\n    \n    override this.Equals obj =\n        match obj with\n        | :? PokerHand as other -> this.Crds = other.Crds\n        | _ -> false  \n        \n    override this.GetHashCode () =\n        hash this.Crds\n\n    interface System.IComparable with\n      member this.CompareTo obj =\n          match obj with\n          | :? PokerHand as other -> - (compare this.Rank other.Rank)\n          | _ -> invalidArg \"obj\" \"cannot compare nums of different types\"  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"586669a8442e3fc307000048":[{"id":86307,"user_id":null,"body":"[<CustomEquality;CustomComparison>]\ntype Shape =\n  | Circle of double\n  | CustomShape of double\n  | Rectangle of double * double\n  | Square of double\n  | Triangle of double * double\n  \n  member x.Area =\n    match x with\n    | Circle(radius) -> System.Math.PI * radius * radius\n    | CustomShape(area) -> area\n    | Rectangle(length,width) -> length * width\n    | Square(side) -> side * side\n    | Triangle(tBase, height) -> 0.5 * tBase * height\n    \n  static member compare (x: Shape) (y: Shape) =\n    match x.Area - y.Area with\n    | 0.0 -> 0\n    | pos when pos > 0.0 -> 1\n    | _ -> -1\n    \n  override x.GetHashCode() = hash(x.Area)\n  override x.Equals(y) =\n    match y with\n    | :? Shape as shapey -> (Shape.compare x shapey) = 0\n    | _ -> false\n  \n  interface System.IComparable with\n    member x.CompareTo(y) =\n      match y with\n      | :? Shape as shapey -> Shape.compare x shapey\n      | _ -> -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86308,"user_id":null,"body":"[<CustomComparison>]\n[<StructuralEquality>]\ntype Shape =\n    | Square of side: float\n    | Rectangle of width: float * height: float\n    | Triangle of tbase: float * height: float\n    | Circle of radius: float\n    | CustomShape of area: float\n    \n    member this.Area = \n        match this with\n        | Square (side) -> side**2.\n        | Rectangle (width,height) -> width*height\n        | Triangle (tbase,height) -> tbase*height\/2.\n        | Circle (radius) -> System.Math.PI * radius*radius\n        | CustomShape (area) -> area\n        \n    interface System.IComparable with\n        member this.CompareTo other = \n            match other with\n            | :? Shape as otherShape -> this.Area.CompareTo(otherShape.Area)\n            | _ -> 0\n\nlet addShape ex s = \n    ex @ [s]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86309,"user_id":null,"body":"[<AbstractClass>]\ntype Shape() =\n  abstract member Area: float\n  override x.Equals y =\n    match y with\n    | :? Shape as y-> x.Area = y.Area\n    | _ -> false\n  override x.GetHashCode() = x.Area.GetHashCode ()\n  interface System.IComparable with\n    member x.CompareTo y = x.Area.CompareTo (y :?> Shape).Area\n\ntype Square (side) =\n    inherit Shape() \n    override __.Area = side ** 2.\ntype Rectangle (width, height) =\n  inherit Shape()\n  override __.Area = width * height\ntype Triangle (base', height) =\n  inherit Shape()\n  override __.Area = base' * height \/ 2.\ntype Circle (radius) =\n  inherit Shape()\n  override __.Area = radius * radius * System.Math.PI\ntype CustomShape (area) =\n  inherit Shape()\n  override __.Area = area\n  \nlet addShape shapes (shape: Shape) =\n  shape :: shapes |> List.sortBy (fun x -> x.Area)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86310,"user_id":168,"body":"[<AbstractClass>]\ntype Shape() =\n  abstract member Area : float with get\n  interface System.IComparable with\n    member this.CompareTo obj =\n      match obj with\n      | :? Shape as s -> compare this.Area s.Area\n      | _ -> -1\n\nlet addShape list (shape: Shape) = shape :: list\n\ntype Square(side: float) =\n  inherit Shape()\n  override this.Area = side * side\n  \ntype Rectangle(width: float, height: float) =\n  inherit Shape()\n  override this.Area = width * height\n\ntype Triangle(b: float, height: float) =\n  inherit Shape()\n  override this.Area = b * height * 0.5\n\ntype Circle(radius: float) =\n  inherit Shape()\n  override this.Area = System.Math.PI * radius ** 2.0\n  \ntype CustomShape(area: float) =\n  inherit Shape()\n  override this.Area = area\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86311,"user_id":null,"body":"[<CustomComparison; CustomEquality>]\ntype Shape =\n    | CustomShape of float\n    | Triangle of float * float\n    | Square of float\n    | Circle of float\n    | Rectangle of float * float\n    member this.Area =\n        match this with\n        | CustomShape(area) -> area\n        | Triangle(b, height) -> b * height \/ 2.\n        | Square(side) -> side * side\n        | Circle(radius) -> System.Math.PI * radius * radius\n        | Rectangle(width, height) -> width * height\n    interface System.IComparable with\n        member this.CompareTo obj =\n            match obj with\n              | :? Shape as other -> this.Area.CompareTo(other.Area)\n              | _ -> failwith \"Not supported\"\n    override this.Equals obj =\n        match obj with\n          | :? Shape as other -> this.Area = other.Area\n          | _ -> false\n    override this.GetHashCode() = 0\n\nlet addShape (shapes: Shape list) (shape: Shape) =\n    shape::shapes\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86312,"user_id":null,"body":"[<CustomEquality; CustomComparison>]\ntype Shape =\n    | Circle of double\n    | Triangle of double * double\n    | Square of double\n    | Rectangle of double * double\n    | CustomShape of double\n    \n    static member Compare (x: Shape) (y: Shape) = compare x.Area y.Area\n    member this.Area =\n        match this with\n        | Circle r -> System.Math.PI * r ** 2.\n        | Triangle (a, h) -> a * h \/ 2.\n        | Square a -> a ** 2.\n        | Rectangle (w, h) -> w * h\n        | CustomShape area -> area\n    \n    interface System.IComparable with\n        member this.CompareTo xObj =\n            match xObj with\n            | :? Shape as x -> Shape.Compare this x\n            | _ -> -1\n            \n    override this.Equals xObj =\n        match xObj with\n        | :? Shape as x -> Shape.Compare x this |> (=) 0\n        |_ -> false\n        \n    override this.GetHashCode () = hash this.Area","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86313,"user_id":null,"body":"[<AbstractClass>]\ntype Shape() =\n    abstract member Area: float\n    interface System.IComparable with\n        member this.CompareTo(obj: obj): int = \n            match obj with\n            | :? Shape as other -> this.Area.CompareTo(other.Area)\n            | _ -> invalidArg \"obj\" \"not a Shape\"\n\ntype Square(side: float) =\n    inherit Shape()\n    member this.Side = side\n    override this.Area = this.Side * this.Side\n    override this.Equals obj =\n        match obj with\n        | :? Square as other -> this.Side = other.Side\n        | _ -> false\n\ntype Rectangle(width: float, height: float) =\n    inherit Shape()\n    member this.Width = width\n    member this.Height = height\n    override this.Area = this.Width * this.Height\n    override this.Equals obj =\n        match obj with\n        | :? Rectangle as other -> this.Width = other.Width && this.Height = other.Height\n        | _ -> false\n\ntype Triangle(b: float, height: float) =\n    inherit Shape()\n    member this.Base = b\n    member this.Height = height\n    override this.Area = this.Base * this.Height \/ 2.0\n    override this.Equals obj =\n        match obj with\n        | :? Triangle as other -> this.Base = other.Base && this.Height = other.Height\n        | _ -> false\n\ntype Circle(radius: float) =\n    inherit Shape()\n    member this.Radius = radius\n    override this.Area = this.Radius * this.Radius * System.Math.PI\n    override this.Equals obj =\n        match obj with\n        | :? Circle as other -> this.Radius = other.Radius\n        | _ -> false\n\ntype CustomShape(area: float) =\n    inherit Shape()\n    override this.Area = area\n    override this.Equals obj =\n        match obj with\n        | :? CustomShape as other -> this.Area = other.Area\n        | _ -> false\n        \nlet addShape (expected: Shape list) (shape: Shape) = expected @ [shape]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86314,"user_id":null,"body":"open System\n\n[<CustomEquality;CustomComparison>]\ntype Shape =\n    | Circle of radius : float\n    | Triangle of baselen : float * height : float\n    | Square of side : float\n    | Rectangle of width : float * length : float\n    | CustomShape of area : float\n    member self.Area =\n        match self with\n        | Circle(r) -> Math.PI * r * r\n        | Triangle(b,h) -> (b * h) \/ 2.\n        | Square(x) -> x * x\n        | Rectangle(w,l) -> w * l\n        | CustomShape(x) -> x\n    interface IComparable with\n        member self.CompareTo yObj =\n            match yObj with\n            | :? Shape as y -> compare self.Area y.Area\n            | _ -> invalidArg \"yObj\" \"cannot compare values of different types\"\n    override self.Equals yObj =\n        match yObj with\n        | :? Shape as y -> (self.Area = y.Area)\n        |_ -> false\n    override self.GetHashCode () = hash self.Area","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86315,"user_id":null,"body":"open System\n\n[<CustomComparison; CustomEquality>]\ntype Shape =\n  | Square of float\n  | Rectangle of float * float\n  | Triangle of float * float\n  | Circle of float\n  | CustomShape of float\n\n  member this.Area =\n    match this with\n    | Square side -> side ** 2.\n    | Rectangle (s1, s2) -> s1 * s2\n    | Triangle (``base``, height) -> ``base`` * height \/ 2.\n    | Circle radius -> radius * Math.PI\n    | CustomShape area -> area\n\n  interface IComparable with\n    member this.CompareTo other = this.Area.CompareTo (other :?> Shape).Area\n\n  override this.Equals other = (this :> IComparable).CompareTo other = 0\n  override this.GetHashCode () = hash this\n\nlet addShape shapes shape = shapes @ [ shape ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86316,"user_id":null,"body":"open System\n[<AbstractClass>]\ntype Shape() =\n    abstract Area:float with get\n    override this.Equals (y) =\n        match y with\n        | :? Shape as s -> (compare this s) = 0\n        | _ -> false\n    override this.GetHashCode() = hash this.Area\n    override this.ToString() =\n        let n = this.GetType().Name\n        sprintf \"%s, area=%f\" n this.Area\n    interface IComparable with\n        member this.CompareTo (y) =\n            match y with \n                | :? Shape as s -> compare this.Area s.Area\n                | _ -> failwith \"Invalid comparison\"\n\ntype Square(side:float) =\n    inherit Shape()\n    member this.Side = side\n    override this.Area:float = this.Side * this.Side \n\ntype Rectangle(w:float,h:float) =\n    inherit Shape()\n    member this.Width = w\n    member this.Height = h\n    override this.Area:float = this.Width * this.Height\n\ntype Triangle(w:float,h:float) =\n    inherit Shape()\n    member this.Width = w\n    member this.Height = h\n    override this.Area:float = this.Width * this.Height\ntype Circle(r:float) =\n    inherit Shape()\n    member this.Radius = r\n    override this.Area:float = r*r* Math.PI\n\ntype CustomShape(area:float) =\n    inherit Shape()\n    override this.Area:float = area\n\n\n\n\nlet addShape<'S when 'S :> (Shape)> (l:list<Shape>) (s:'S) = \n    let shape = s :> Shape\n    List.sort (shape::l)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58678d29dbca9a68d80000d7":[{"id":86317,"user_id":null,"body":"type ProgramState = {\n    MemPtr: int;\n    Mem: int array;\n    CodePtr: int;\n    Code: char array;\n}\n\nlet flipBit (pos: int) (data: int array): int array =\n    let flip x = if x = 0 then 1 else 0\n\n    if pos < 0 || pos > Array.length data then\n        data\n    else\n        Array.set data pos (flip (Array.get data pos))\n        data\n\nlet findClosingIndex (pos: int) (closingChar: char) (updateFunc: int -> int) (code: char array): int =\n    let openChar = Array.get code pos\n\n    let mutable cnt = 1\n    let mutable idx = pos\n\n    while cnt > 0 && idx < Array.length code do\n        match Array.get code idx with\n        | c when c = openChar -> cnt <- cnt + 1; idx <- updateFunc idx\n        | c when c = closingChar -> cnt <- cnt - 1; idx <- if cnt > 1 then updateFunc idx else idx\n        | _ -> idx <- updateFunc idx\n    \n    idx\n\nlet stepProgram (state: ProgramState): ProgramState =\n    match Array.get state.Code state.CodePtr with\n    | '>' -> \n        {state with MemPtr = state.MemPtr + 1; CodePtr = state.CodePtr + 1;}\n    | '<' -> \n        {state with MemPtr = state.MemPtr - 1; CodePtr = state.CodePtr + 1;}\n    | '*' -> \n        {state with Mem = flipBit state.MemPtr state.Mem; CodePtr = state.CodePtr + 1;}\n    | '[' -> \n        match Array.get state.Mem state.MemPtr with\n        | 0 -> {state with CodePtr = findClosingIndex state.CodePtr ']' ((+) 1) state.Code;}\n        | _ -> {state with CodePtr = state.CodePtr + 1}\n    | ']' -> \n        match Array.get state.Mem state.MemPtr with\n        | 0 -> {state with CodePtr = state.CodePtr + 1}\n        | _ -> {state with CodePtr = findClosingIndex state.CodePtr '[' (fun x -> x - 1) state.Code;}\n    | _ -> \n        {state with CodePtr = state.CodePtr + 1}\n\nlet isValid (state: ProgramState ): bool =\n    if state.MemPtr < 0 || state.MemPtr >= Array.length state.Mem then\n        false\n    elif state.CodePtr < 0 || state.CodePtr >= Array.length state.Code then\n        false\n    else\n        true\n\nlet interpreter (code: string) (tape: string): string =\n    let mutable state = {\n        MemPtr = 0;\n        Mem = tape.ToCharArray() |> Array.map (string >> int);\n        CodePtr = 0;\n        Code = code.ToCharArray();\n    }\n\n    while isValid state do\n        state <- stepProgram state\n\n    state.Mem\n    |> Array.map string\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86318,"user_id":null,"body":"let decPointer tape counter pointer =\n    (tape, counter + 1, pointer - 1)\n    \nlet incPointer tape counter pointer =\n    (tape, counter + 1, pointer + 1)\n\nlet swapBit (tape: char array) counter pointer = \n    if tape.[pointer] = '0' then\n        tape.[pointer] <- '1'\n    else\n        tape.[pointer] <- '0'\n    (tape, counter + 1, pointer)\n\nlet jumpForward (code: char array) (tape: char array) counter pointer =\n    if tape.[pointer] = '0' then\n        let findEndJump arr = \n            let rec innerLoop (arr: char array) index counter =\n                match arr.[index] with\n                | '[' -> innerLoop arr (index + 1) (counter + 1)\n                | ']' -> if counter = 1 then\n                             index\n                         else\n                             innerLoop arr (index + 1) (counter - 1)\n                |  _  -> innerLoop arr (index + 1) counter\n            innerLoop arr 0 0\n        let step = findEndJump code.[counter..] \n        (tape, counter + step, pointer)\n    else\n        (tape, counter + 1, pointer)\n\nlet jumpBackward (code: char array) (tape: char array) counter pointer =\n    if tape.[pointer] <> '0' then\n        let findBeginJump arr = \n            let rec innerLoop (arr: char array) index counter =\n                match arr.[index] with\n                | ']' -> innerLoop arr (index - 1) (counter + 1)\n                | '[' -> if counter = 1 then\n                             index\n                         else\n                             innerLoop arr (index - 1) (counter - 1)\n                |  _  -> innerLoop arr (index - 1) counter\n            innerLoop arr ((Array.length arr) - 1) 0\n        let step = findBeginJump code.[0..counter]\n        (tape, step, pointer)\n    else\n        (tape, counter + 1, pointer)\n        \nlet evaluate (code: char array) tape counter pointer =\n    match code.[counter] with\n        |'<' -> decPointer tape counter pointer\n        |'>' -> incPointer tape counter pointer\n        |'*' -> swapBit tape counter pointer\n        |'[' -> jumpForward code tape counter pointer\n        |']' -> jumpBackward code tape counter pointer\n        | _ -> (tape, counter + 1, pointer)\n        \nlet rec loop code tape counter pointer =\n    if counter >= (Array.length code) ||\n       pointer < 0 ||\n       pointer >= (Array.length tape) then\n           new string (tape)\n    else\n        let (tape', counter', pointer') = evaluate code tape counter pointer\n        loop code tape' counter' pointer'\n\nlet interpreter (code: string) (tape: string) =\n    loop (code.ToCharArray ()) (tape.ToCharArray ()) 0 0","lang_id":20,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86319,"user_id":53,"body":"open System\nopen System.Collections.Generic\nopen System.Linq\n\nlet interpreter (code: string) (tape: string) =\n  let mutable result = tape.ToCharArray()\n  let mutable jumps = new Dictionary<int, int>()\n  let mutable opens = new Stack<int>()\n  for i in 0 .. (String.length code) - 1 do\n    if code.[i] = '[' then\n      opens.Push(i)\n    else if code.[i] = ']' then\n      jumps.[i] <- opens.Peek()\n      jumps.[opens.Peek()] <- i\n      opens.Pop() |> ignore\n  let mutable ip = 0\n  let mutable dp = 0\n  while ip < (String.length code) && dp < (Array.length result) && ip >= 0 && dp >= 0 do\n    match code.[ip] with\n      | '*' -> result.[dp] <- if result.[dp] = '0' then '1' else '0'\n      | '>' -> dp <- dp + 1\n      | '<' -> dp <- dp - 1\n      | '[' -> ip <- if result.[dp] = '0' then jumps.[ip] else ip\n      | ']' -> ip <- if result.[dp] = '1' then jumps.[ip] else ip\n      | _   -> ip <- ip\n    ip <- ip + 1\n  new string(result)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86320,"user_id":null,"body":"type Tape = int option * bool []\n\nlet moveR = function\n| Some p, t when p < Array.length t - 1 -> Some(p + 1), t\n| _, t -> None, t\n\nlet moveL = function\n| Some p, t when p > 0 -> Some(p - 1), t\n| _, t -> None, t\n\nlet flip = function\n| Some p, t ->\n    let t' = Array.copy t\n    t'.[p] <- not t.[p] \/\/ mutability bad\n    Some(p), t'\n| p, t -> p, t\n\nlet rec loop cmd : Tape -> Tape = function\n| Some p, t when t.[p] -> (Some p, t) |> cmd |> loop cmd\n| p, t -> p, t               \n\n#nowarn \"25\"\n\nlet getCommand (cmd :: cmdp :: rest) : char -> (Tape -> Tape) list = function\n| '<' -> (cmd >> moveL) :: cmdp :: rest\n| '>' -> (cmd >> moveR) :: cmdp :: rest\n| '*' -> (cmd >> flip)  :: cmdp :: rest\n| '[' -> id :: cmd      :: cmdp :: rest\n| ']' -> (loop cmd << cmdp)     :: rest\n|  _  -> cmd            :: cmdp :: rest\n\nlet strToTape : string -> Tape =\n    Seq.map ((=) '1') \n    >> Array.ofSeq\n    >> (fun t -> Some 0, t)\n\nlet tapeToStr : Tape -> string =\n    snd\n    >>  Array.map (fun x -> if x then \"1\" else \"0\")\n    >> String.concat \"\"\n\nlet interpreter (code: string) =\n    strToTape\n    >> (code |> Seq.fold getCommand [id; id] |> List.reduce (<<))\n    >> tapeToStr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86321,"user_id":null,"body":"let interpreter (code: string) (tape: string) =\n  printfn \"%s %s\" code tape\n  let co, ta = code.ToCharArray(), tape.ToCharArray()\n  let rec past i n_op =\n    if co.[i] = ']' then\n        if n_op = 0 then i\n        else past (i + 1) (n_op - 1)\n    elif co.[i] = '[' then\n        past (i + 1) (n_op + 1)\n    else past (i + 1) n_op\n\n  let rec back i n_cl =\n      if co.[i] = '[' then\n          if n_cl = 0 then i\n          else back (i - 1) (n_cl - 1)\n      elif co.[i] = ']' then\n          back (i - 1) (n_cl + 1)\n      else back (i - 1) n_cl\n\n  let rec inner idx codeidx =\n    if codeidx >= co.Length || idx >= ta.Length || idx < 0 then ta |> System.String\n    else\n        let command = co.[codeidx]\n        match command with\n        | '*' ->\n          ta.[idx] <- if ta.[idx] = '1' then '0' else '1'\n          inner idx (codeidx + 1)\n        | '>' -> inner (idx + 1) (codeidx + 1)\n        | '<' -> inner (idx - 1) (codeidx + 1)\n        | '[' ->\n            let new_codeidx = if ta.[idx] = '0' then (past (codeidx + 1) 0) else (codeidx + 1)\n            inner idx new_codeidx\n        | ']' ->\n            let new_codeidx = if ta.[idx] = '1' then (back (codeidx - 1) 0) else (codeidx + 1)\n            inner idx new_codeidx\n        | _ -> inner idx (codeidx + 1)\n  inner 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86322,"user_id":null,"body":"let interpreter (code: string) (tape: string) =\n    \/\/ TODO\n    printfn \"%s  %s\" code tape\n    let mutable pointer = 0\n    let l,t = code.Length, tape.Length\n\n    let state =\n        Seq.map (fun c -> System.Convert.ToBoolean(c |> string |> int)) tape\n        |> Array.ofSeq\n\n    let code = code |> Array.ofSeq\n    let mutable i = 0\n\n    while i < l && pointer < t && pointer >= 0 do\n        let c = code.[i]\n\n        match c with\n        | '>' -> pointer <- pointer + 1\n        | '<' -> pointer <- pointer - 1\n        | '*' -> state.[pointer] <- not state.[pointer]\n        | '[' ->\n            if not state.[pointer] then\n                let mutable stack = 0\n                let mutable j = i\n\n                while j < l do\n                    if code.[j] = '[' then\n                        stack <- stack + 1\n\n                    if code.[j] = ']' then\n                        stack <- stack - 1\n\n                    i <- i + 1\n                    j <- j + 1\n                    if stack = 0 then\n                        i <- i - 1\n                        j <- l\n        | ']' ->\n            if state.[pointer] then\n                let mutable stack = 0\n                let mutable j = i\n\n                while j >= 0 do\n                    if code.[j] = ']' then\n                        stack <- stack + 1\n\n                    if code.[j] = '[' then\n                        stack <- stack - 1\n\n                    i <- i - 1\n                    j <- j - 1\n\n                    if stack = 0 then j <- - 1\n        | _ -> ()\n\n        i <- i + 1\n\n    state\n    |> Array.map (System.Convert.ToInt32 >> string)\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86323,"user_id":null,"body":"let interpreter (code: string) (tape: string) =\n    let bits = tape |> Seq.map (fun x -> x = '1')\n                    |> Seq.toArray\n\n    let rec findMatching pos depth =\n        match code.[pos] with\n        | '[' -> findMatching (pos+1) (depth+1)\n        | ']' -> if depth = 0  then pos\n                               else findMatching (pos+1) (depth-1)\n        | _   -> findMatching (pos+1) depth \n\n    let rec smallfuck codepos bitspos stack =\n        if codepos < 0 || codepos >= code.Length ||\n           bitspos < 0 || bitspos >= bits.Length\n        then bits\n        else match code.[codepos] with\n             | '<' -> smallfuck (codepos+1) (bitspos-1) stack\n             | '>' -> smallfuck (codepos+1) (bitspos+1) stack\n             | '*' -> bits.[bitspos] <- not bits.[bitspos]\n                      smallfuck (codepos+1) bitspos stack\n             | '[' -> if bits.[bitspos] \n                      then \/\/ enter loop\n                           smallfuck (codepos+1) bitspos (codepos::stack)\n                      else \/\/ skip loop\n                           let ndx = findMatching (codepos+1) 0\n                           if ndx < 0 then bits\n                           else smallfuck (ndx + 1) bitspos stack\n             | ']' -> match stack with\n                      | [] -> bits\n                      | h::t -> smallfuck h bitspos t\n             | _   -> smallfuck (codepos+1) bitspos stack\n\n    smallfuck 0 0 [] |> Array.map (fun x -> if x then '1'B else '0'B)\n                     |> System.Text.Encoding.ASCII.GetString\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86324,"user_id":null,"body":"type State = {\n  Pointer: int\n  CodePointer: int\n  Tape: string\n  Code: string\n}\n\nlet flipBit b =\n  match b with\n  | '1' -> '0'\n  | '0' -> '1'\n  | _ -> failwith \"invalid char in tape\"\n\nlet flip (state: State) = \n  let newTape = state.Tape |> String.mapi (fun i c -> if i = state.Pointer then flipBit c else c)\n  {state with CodePointer=state.CodePointer+1; Tape=newTape}\n  \nlet moveRight (state: State) = \n  {state with CodePointer = state.CodePointer+1; Pointer=state.Pointer+1}\n\nlet moveLeft (state: State) = \n  {state with CodePointer = state.CodePointer+1; Pointer=state.Pointer-1}\n\nlet findMatching chr opposite direction (code: string) pointer =\n  let rec inner pointer count =\n    match pointer < 0 || pointer >= code.Length with\n    | true -> pointer\n    | false ->\n      match count with\n      | 0 -> pointer\n      | _ ->\n        let count =\n          match code.[pointer] = opposite, code.[pointer] = chr with\n          | true, _ -> count - 1\n          | _, true -> count + 1\n          | false, false -> count\n        inner (pointer+direction) count\n  let newPointer = inner (pointer+direction) 1\n  newPointer - direction\n        \n        \n      \n\nlet jumpRight (state: State) = \n  match state.Tape.[state.Pointer] with\n  | '0' -> \n    let codePointer = findMatching '[' ']' 1 state.Code state.CodePointer\n    {state with CodePointer = codePointer}\n  | _ -> \n    {state with CodePointer = state.CodePointer + 1}\n\nlet jumpLeft (state: State) = \n  match state.Tape.[state.Pointer] with\n  | '1' -> \n    let codePointer = findMatching ']' '[' -1 state.Code state.CodePointer\n    {state with CodePointer = codePointer}\n  | _ -> \n    {state with CodePointer = state.CodePointer + 1}\n\nlet doNothing (state: State) =\n  {state with CodePointer = state.CodePointer + 1}\n\n\nlet commands = \n  Map.empty\n    .Add('*', flip)\n    .Add('>', moveRight)\n    .Add('<', moveLeft)\n    .Add('[', jumpRight)\n    .Add(']', jumpLeft)\n\nlet rec execute state = \n  match state.Pointer >= state.Tape.Length || state.CodePointer >= state.Code.Length || state.CodePointer < 0 || state.Pointer < 0 with\n  | true -> state\n  | false -> \n    let currentCommand = state.Code.[state.CodePointer]\n    let fn = \n      match commands.ContainsKey currentCommand with\n      | true -> commands.[currentCommand]\n      | false -> doNothing\n    execute (fn state)\n\nlet interpreter (code: string) (tape: string) =\n  printfn \"code: %s tape: %s\" code tape\n  {Code=code; Tape=tape; Pointer=0; CodePointer=0}\n  |> execute\n  |> fun {Tape=tape} -> tape\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86325,"user_id":null,"body":"\nopen System\nopen System.Collections\n\n\nlet parseTape (str: string) = \n    str |> Array.ofSeq |> Array.map (fun x -> x = '1')\n\nlet invert i arr = \n    if i >= 0 && i < Array.length arr then\n        let arr' = Array.copy arr\n        arr'.[i] <- not arr'.[i]\n        arr'\n    else arr \n\nlet findRightBrace code ip =\n    let mutable depth = 0\n    let mutable result = None\n    for ip' in (ip)..(-1 + String.length code) do\n        let i = code.[ip']\n        if i = '[' then depth <- depth + 1\n        else if i = ']' then depth <- depth - 1\n\n        if i = ']' && depth = 0 && result.IsNone then result <- Some(ip')\n    result\n\nlet findLeftBrace (code: string) ip =\n    let mutable depth = 0\n    let mutable result = None\n    for ip' in [0..ip] |> Seq.rev do\n        let i = code.[ip']\n        if i = ']' then depth <- depth + 1\n        else if i = '[' then depth <- depth - 1\n\n        if i = '[' && depth = 0 && result.IsNone then result <- Some(ip')\n    result\n\nlet interpreter (code: string) (tape: string) =\n    let tape = parseTape tape\n    let rec interpreter' (tape: bool array) ip dp =\n        if ip < 0 || ip >= code.Length then tape\n        else if dp < 0 || dp >= tape.Length then tape\n        else\n            match code.[ip] with\n            | '>' -> interpreter' tape (ip + 1) (dp + 1)\n            | '<' -> interpreter' tape (ip + 1) (dp - 1)\n            | '*' -> interpreter' (invert dp tape) (ip + 1) dp\n            | '[' -> if tape.[dp] then interpreter' tape (ip + 1) dp\n                     else \n                        findRightBrace code ip\n                        |> Option.map (fun ip -> interpreter' tape ip dp)\n                        |> Option.orElse (Some tape)\n                        |> Option.get\n            | ']' -> if not tape.[dp] then interpreter' tape (ip + 1) dp\n                     else\n                        findLeftBrace code ip\n                        |> Option.map (fun ip -> interpreter' tape ip dp)\n                        |> Option.orElse (Some tape)\n                        |> Option.get\n            |  _  -> interpreter' tape (ip + 1) dp\n    \n    let finalTapeState = interpreter' tape 0 0\n                         |> Array.map (function true -> '1' | false -> '0')\n    String.Join(\"\", finalTapeState)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86326,"user_id":null,"body":"let outOfBounds p l = p < 0 || p >= l\n\nlet findMatchingBracket (code: string) p (brk: char) =\n  let dir = if brk = ']' then 1 else -1\n  let rec find p stack = \n    let np = p + dir\n    let ins = code.[p]\n    if outOfBounds p code.Length then\n      None\n    elif ins = brk && List.isEmpty stack then\n      Some p\n    else\n      match ins with \n      | '[' | ']' when ins = brk ->\n        find np <| List.tail stack \n      | '[' | ']' ->\n        find np <|  ins :: stack\n      | _ -> \n        find np stack\n  find p List.empty\n\nlet run (code: string) (tape: char array) = \n  let rec loop tp cp =\n    if outOfBounds tp tape.Length || outOfBounds cp code.Length then\n      tape\n    else\n      let ncp = cp + 1\n      match code.[cp] with\n      | '>' -> \n        loop (tp + 1) ncp\n      | '<' -> \n        loop (tp - 1) ncp\n      | '*' ->\n        tape.[tp] <- if tape.[tp] = '1' then '0' else '1' \n        loop tp ncp\n      | '[' when tape.[tp] = '0' ->\n        match findMatchingBracket code ncp ']' with\n        | None -> tape\n        | Some ncp -> loop tp <| ncp + 1\n      | ']' when tape.[tp] = '1' ->\n        match findMatchingBracket code (cp - 1) '[' with\n        | None -> tape\n        | Some ncp -> loop tp ncp\n      | '[' | ']' ->\n        loop tp ncp\n      | ']' -> \n        loop tp cp      \n      | _ -> \n        loop tp ncp\n  \n  loop 0 0\n\nlet interpreter (code: string) (tape: string) =\n  tape\n  |> Seq.toArray\n  |> run code\n  |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5868a68ba44cfc763e00008d":[{"id":86327,"user_id":null,"body":"type Direction =\n    | ToEnd\n    | ToStart\n\nlet indexOfMatchingBrace startIndex code direction =\n    match direction with\n    | ToEnd ->\n        code\n        |> Seq.skip (startIndex + 1)\n        |> Seq.fold (fun (index, brackets) c ->\n            match brackets with\n            | 0 -> (index, brackets)\n            | _ ->\n                match c with\n                | '[' -> (index + 1, brackets + 1)\n                | ']' -> (index + 1, brackets - 1)\n                | _ -> (index + 1, brackets)) (startIndex, 1)\n        |> fst\n    | ToStart ->\n        Seq.foldBack (fun c (index, brackets) ->\n            match brackets with\n            | 0 -> (index, brackets)\n            | _ ->\n                match c with\n                | '[' -> (index - 1, brackets - 1)\n                | ']' -> (index - 1, brackets + 1)\n                | _ -> (index - 1, brackets)) (code |> Seq.take startIndex) (startIndex, 1)\n        |> fst\n\nlet getOutput (grid:int[,]) =\n        { 0 .. (grid |> Array2D.length1) - 1 }\n        |> Seq.map (fun r ->\n            { 0 .. (grid |> Array2D.length2) - 1 }\n            |> Seq.fold (fun acc c ->\n                acc + (grid.[r, c].ToString())\n            ) \"\"\n        )\n        |> String.concat \"\\r\n\"\n\nlet safeMod x n =\n    if x >= 0 then x % n else (x + n) % n\n\nlet rec interpret code ip (grid:int[,]) (width, height) (row, col) iterations =\n    let endOfCode = code |> Array.length = ip\n    let iterationsDone = iterations = 0\n\n    match endOfCode || iterationsDone with\n    | true -> getOutput grid\n    | false ->\n        match code.[ip] with\n        | 'e' ->\n            interpret code (ip + 1) grid (width, height) (row, safeMod (col + 1) width) (iterations - 1)\n        | 'w' ->\n            interpret code (ip + 1) grid (width, height) (row, safeMod (col - 1) width) (iterations - 1)\n        | 'n' ->\n            interpret code (ip + 1) grid (width, height) (safeMod (row - 1) height, col) (iterations - 1)\n        | 's' ->\n            interpret code (ip + 1) grid (width, height) (safeMod (row + 1) height, col) (iterations - 1)\n        | '*' ->\n            grid.[row, col] <- (grid.[row, col] + 1) % 2\n            interpret code (ip + 1) grid (width, height) (row, col) (iterations - 1)\n        | '[' ->\n            match grid.[row, col] with\n            | 0 ->\n                let target = indexOfMatchingBrace ip code ToEnd\n                interpret code (target + 1) grid (width, height) (row, col) (iterations - 1)\n            | _ ->\n                interpret code (ip + 1) grid (width, height) (row, col) (iterations - 1)\n        | ']' ->\n            match grid.[row, col] with\n            | 1 ->\n                let target = indexOfMatchingBrace ip code ToStart\n                interpret code (target + 1) grid (width, height) (row, col) (iterations - 1)\n            | _ ->\n                interpret code (ip + 1) grid (width, height) (row, col) (iterations - 1)\n        | _ ->\n            interpret code (ip + 1) grid (width, height) (row, col) iterations\n\nlet interpreter (code: string) iterations width height =\n    interpret (code.ToCharArray()) 0 (Array2D.zeroCreate height width) (width, height) (0,0) iterations","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86328,"user_id":53,"body":"open System\nopen System.Collections.Generic\nopen System.Linq\nopen System.Text.RegularExpressions\n\nlet interpreter (raw: string) limit w h =\n  let code = Regex.Replace(raw, @\"[^nesw*\\[\\]]\", \"\")\n  let n = String.length code\n  let mutable jumps = new Dictionary<int, int>()\n  let mutable opens = new Stack<int>()\n  let mutable grid = [|for i in 0 .. h - 1 -> Array.create w 0|]\n  for i in 0 .. n - 1 do\n    if code.[i] = '[' then\n      opens.Push(i)\n    else if code.[i] = ']' then\n      jumps.[i] <- opens.Peek()\n      jumps.[opens.Peek()] <- i\n      opens.Pop() |> ignore\n  let mutable i = 0\n  let mutable j = 0\n  let mutable x = 0\n  let mutable y = 0\n  while j < limit && i < n do\n    match code.[i] with\n      | '*' -> grid.[y].[x] <- if grid.[y].[x] = 0 then 1 else 0\n      | 'n' -> y <- (y - 1 + h) % h\n      | 'w' -> x <- (x - 1 + w) % w\n      | 's' -> y <- (y + 1) % h\n      | 'e' -> x <- (x + 1) % w\n      | '[' -> i <- if grid.[y].[x] = 0 then jumps.[i] else i\n      | ']' -> i <- if grid.[y].[x] = 1 then jumps.[i] else i\n      | _   -> i <- i\n    i <- i + 1\n    j <- j + 1\n  grid |> Array.map (fun r -> r |> Array.map string |> String.concat \"\") |> String.concat \"\\r\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86329,"user_id":null,"body":"open System\n\nlet rec skipPrevious p c i iterations =\n    match p,i with\n    | ']'::t, i -> skipPrevious t (']'::c) (i + 1) iterations\n    | '['::t, 0 -> iterations, t, '['::c\n    | '['::t, i -> skipPrevious t ('['::c) (i - 1) iterations\n    | h::t, i -> skipPrevious t (h::c) i iterations\n\nlet rec skipNext p c i iterations =\n    match c,i with\n    | '['::t, i -> skipNext ('['::p) t (i + 1) iterations\n    | ']'::t, 0 -> iterations, ']'::p, t\n    | ']'::t, i -> skipNext (']'::p) t (i - 1) iterations\n    | h::t, i -> skipNext (h::p) t i iterations\n\nlet interpret (code: string) (date: bool[,]) width height iterations =\n    let rec fxx x y = function\n        | (0, _, _) | (_, _, [])    -> date\n        | (i, p, h::t) when h = 'n' -> fxx ((x + height - 1) % height) y                         (i - 1, h::p, t)\n        | (i, p, h::t) when h = 'e' -> fxx x                           ((y + 1) % width)         (i - 1, h::p, t)\n        | (i, p, h::t) when h = 's' -> fxx ((x + 1) % height)          y                         (i - 1, h::p, t)\n        | (i, p, h::t) when h = 'w' -> fxx x                           ((y + width - 1) % width) (i - 1, h::p, t)\n        | (i, p, h::t) when h = '*' ->\n            date.[x,y] <- not date.[x,y]\n            fxx x y (i - 1, h::p, t)\n        | (i, p, h::t) when h = '[' && date.[x,y] -> fxx x y (i - 1, h::p, t)\n        | (i, p, h::t) when h = '[' -> fxx x y (skipNext (h::p) t 0 (i - 1))\n        | (i, p, h::t) when h = ']' -> fxx x y (skipPrevious p (h::t) 0 i)\n        | (i, p, h::t) -> fxx x y (i, h::p, t)\n    fxx 0 0 (iterations, [], code.ToCharArray() |> Array.toList)\n\nlet interpreter (code: string) iterations width height =\n    interpret code (Array2D.zeroCreate height width) width height iterations\n    |> Seq.cast<bool>\n    |> Seq.chunkBySize width\n    |> Seq.map (Seq.map (Convert.ToInt32 >> Convert.ToString) >> String.concat \"\")\n    |> String.concat \"\\r\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86330,"user_id":null,"body":"open System \n\ntype Token = \n    | Path of char\n    | Flip\n    | Condition of Token list\n        \nlet interpreter (code: string) iterations width height =\n        \n    let state: int[][] = Array.init height (fun x -> Array.zeroCreate width)\n    let mutable cursor = (0, 0)\n    let getCurrent() = let (x, y) = cursor in state.[y].[x]\n    let setCurrent e = let (x, y) = cursor in state.[y].[x] <- e\n    let mutable currentIterations = 0\n    \n    let allowedSymbols = \"nswe\"\n    let rec tokenize code =\n        match code with\n        | '*' :: xs -> Flip :: tokenize xs\n        | '[' :: xs-> \n            let endIndex = xs |> List.findIndexBack ((=) ']')\n            Condition(tokenize xs.[..endIndex-1]) :: tokenize xs.[endIndex+1..]\n        | x :: xs when allowedSymbols.Contains(string x) -> Path x :: tokenize xs\n        | _ :: xs -> tokenize xs\n        | [] -> []\n           \n    let navigate (x, y) command = \n        match command with\n        | 'n' -> (x, (y - 1 + height) % height)\n        | 's' -> (x, (y + 1) % height)\n        | 'w' -> ((x - 1 + width) % width, y)\n        | 'e' -> ((x + 1) % width, y)\n        | _ -> failwith \"\"\n        \n    let rec run (tokens: Token list)  = \n        currentIterations <- currentIterations + 1\n        match tokens with\n        | _ when currentIterations > iterations -> () \n        | Path path :: xs -> \n            cursor <- navigate cursor path\n            run xs\n        | Flip :: xs ->\n            setCurrent(if getCurrent() = 0 then 1 else 0)\n            run xs\n        | Condition x :: xs when getCurrent() = 1 ->\n            run x\n            currentIterations <- currentIterations - 1\n            run tokens\n        | Condition _ :: xs ->\n            run xs\n        | [] -> ()\n        \n    code |> Seq.toList |> tokenize |> run\n    state |> Seq.map (Seq.map string >> String.concat \"\") |> String.concat \"\\r\n\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86331,"user_id":null,"body":"open System \n\ntype Token = \n    | Path of char\n    | Flip\n    | Condition of Token list\n        \nlet interpreter (code: string) iterations width height =\n    let print (x: 'a[][]) = \n        let strings = x |> Seq.map (Seq.map string >> String.Concat)\n        String.Join(\"\\r\n\", strings)\n        \n    let allowedSymbols = \"nswe\"\n    let rec tokenize code =\n         match code with\n        | '*' :: xs -> Flip :: tokenize xs\n        | '[' :: xs-> \n            let endIndex = xs |> List.findIndexBack ((=) ']')\n            Condition(tokenize xs.[..endIndex-1]) :: tokenize xs.[endIndex+1..]\n        | x :: xs when allowedSymbols.Contains(string x) -> Path x :: tokenize xs\n        | _ :: xs -> tokenize xs\n        | [] -> []\n                \n    let rec fold (x, y) = \n        if x >= width then fold(x - width, y)\n        elif x < 0 then fold(x + width, y)\n        elif y >= height then fold(x, y - height)\n        elif y < 0 then fold(x, y + height)\n        else (x, y)\n                \n    let navigate (x, y) command = \n        match command with\n        | 'n' -> (x, y - 1)\n        | 's' -> (x, y + 1)\n        | 'w' -> (x - 1, y)\n        | 'e' -> (x + 1, y)\n        |> fold\n        \n    let state: int[][] = Array.init height (fun x -> Array.zeroCreate width)\n    let mutable cursor = (0, 0)\n    let getCurrent() = let (x, y) = cursor in state.[y].[x]\n    let setCurrent e = let (x, y) = cursor in state.[y].[x] <- e\n    let mutable currentIterations = 0\n        \n    let rec run (tokens: Token list)  = \n        currentIterations <- currentIterations + 1\n        match tokens with\n        | _ when currentIterations > iterations -> () \n        | Path path :: xs -> \n            cursor <- navigate cursor path\n            run xs\n        | Flip :: xs ->\n            setCurrent(if getCurrent() = 0 then 1 else 0)\n            run xs\n        | Condition x :: xs when getCurrent() = 1 ->\n            run x\n            currentIterations <- currentIterations - 1\n            run tokens\n        | Condition _ :: xs ->\n            run xs\n        | [] -> ()\n        \n    code |> Seq.toList |> tokenize |> run\n    print state\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86332,"user_id":null,"body":"let interpreter (code: string) iterations width height  =\n    let outputAsString g =\n        let sb = new System.Text.StringBuilder()\n        g |> Array2D.iteri (fun x y b ->\n            if y = 0 then sb.Append(\"\\r\n\") |> ignore else ()\n            sb.Append(if b then '1' else '0') |> ignore\n        ) \n        \n        let s = sb|> string\n        s.Substring(2)\n\n    let rec findMatching pos depth =\n        match code.[pos] with\n        | '[' -> findMatching (pos+1) (depth+1)\n        | ']' -> if depth = 0  then pos\n                               else findMatching (pos+1) (depth-1)\n        | _   -> findMatching (pos+1) depth \n\n    let grid = Array2D.create height width false\n\n    let rec paintfuck codepos it x y stack =\n        if it = 0 || codepos >= code.Length then grid\n        else match code.[codepos] with\n             | 'n' -> let x' = if x = 0 then height - 1\n                                        else x - 1\n                      paintfuck (codepos+1) (it-1) x' y stack\n             | 's' -> paintfuck (codepos+1) (it-1) ((x + 1) % height) y stack\n             | 'w' -> let y' = if y = 0 then width - 1\n                                        else y - 1\n                      paintfuck (codepos+1) (it-1) x y' stack\n             | 'e' -> paintfuck (codepos+1) (it-1) x ((y + 1) % width) stack\n             | '*' -> grid.[x, y] <- not grid.[x, y]\n                      paintfuck (codepos+1) (it-1) x y stack\n             | '[' -> if grid.[x, y] \n                      then \/\/ enter loop\n                           paintfuck (codepos+1) (it-1) x y (codepos::stack)\n                      else \/\/ skip loop\n                           let ndx = findMatching (codepos+1) 0\n                           if ndx < 0 then grid\n                           else paintfuck (ndx + 1) (it-1) x y stack\n             | ']' -> match stack with\n                      | [] -> grid\n                      | h::t -> paintfuck h it x y t\n             | _   -> paintfuck (codepos+1) it x y stack\n\n    paintfuck 0 iterations 0 0 [] \n        |> outputAsString","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86333,"user_id":168,"body":"let interpreter (code: string) iterations width height =\n  let cells = Array.init height (fun _ -> Array.create width 0)\n  let rec run i x y prev cmds =\n    match cmds with\n    | [] -> ()\n    | _ when i <= 0 -> ()\n    | 'n' :: xs -> run (i - 1) x ((y + height - 1) % height) ('n' :: prev) xs\n    | 's' :: xs -> run (i - 1) x ((y + 1) % height) ('s' :: prev) xs\n    | 'e' :: xs -> run (i - 1) ((x + 1) % width) y ('e' :: prev) xs\n    | 'w' :: xs -> run (i - 1) ((x + width - 1) % width) y ('w' :: prev) xs\n    | '*' :: xs ->\n      cells.[y].[x] <- cells.[y].[x] ^^^ 1\n      run (i - 1) x y ('*' :: prev) xs\n    | '[' :: xs when cells.[y].[x] = 0 ->\n      let rec find k prev = function\n        | xs when k = 0 -> prev, xs\n        | '[' :: xs -> find (k + 1) ('[' :: prev) xs\n        | ']' :: xs -> find (k - 1) (']' :: prev) xs\n        | x :: xs -> find k (x :: prev) xs\n        | [] -> failwith \"find [\"\n      let prev', xs' = find 1 ('[' :: prev) xs\n      run (i - 1) x y prev' xs'\n    | ']' :: xs when cells.[y].[x] = 1 ->\n      let rec find k prev = function\n        | '[' :: xs when k = 1 -> prev, '[' :: xs\n        | '[' :: xs -> find (k - 1) ('[' :: prev) xs\n        | ']' :: xs -> find (k + 1) (']' :: prev) xs\n        | x :: xs -> find k (x :: prev) xs\n        | [] -> failwith \"find ]\"\n      let xs', prev' = find 1 (']' :: xs) prev\n      run (i - 1) x y prev' xs'\n    | ('[' as c) :: xs | (']' as c) :: xs -> run (i - 1) x y (c :: prev) xs\n    | c :: xs -> run i x y prev xs\n  run iterations 0 0 [] (Seq.toList code)\n  cells\n  |> Array.map (Array.map string >> String.concat \"\")\n  |> String.concat \"\\r\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86334,"user_id":null,"body":"let rec past (co:char[]) i n_op =\n  if co.[i] = ']' then\n    if n_op = 0 then i + 1\n    else past co (i + 1) (n_op - 1)\n  elif co.[i] = '[' then\n    past co (i + 1) (n_op + 1)\n  else past co (i + 1) n_op\n\nlet rec back (co:char[]) i n_cl =\n  if co.[i] = '[' then\n    if n_cl = 0 then i + 1\n    else back co (i - 1) (n_cl - 1)\n  elif co.[i] = ']' then\n    back co (i - 1) (n_cl + 1)\n  else back co (i - 1) n_cl\n\nlet interpreter (code: string) iterations width height =\n  printfn \"%s %d %d %d\" code iterations width height\n  let print (grid:char[,]) = \n    let sb = System.Text.StringBuilder()\n    for i = 0 to height - 1 do\n      for j = 0 to width - 1 do\n        sb.Append(grid.[i, j]) |> ignore\n      sb.Append(\"\\r\n\") |> ignore\n    sb.ToString().TrimEnd()\n  let rec prepare res co =\n    match co with\n    | [] -> res |> List.rev |> List.toArray\n    | h::tail when h = 'n' || h = 's' || h = 'e' || h = 'w' || h = '*' || h = '[' || h = ']' -> prepare (h::res) tail\n    | _::tail -> prepare res tail\n  let grid = Array2D.init height width (fun _ _ -> '0')\n  let codeList = code.ToCharArray() |> List.ofArray\n  let co = prepare [] codeList\n  let rec inner (w_i, h_i) codeidx iterations =\n    if codeidx >= co.Length || iterations < 0 then print grid\n    else\n      let w = if w_i = width then 0 elif w_i = -1 then (width - 1) else w_i\n      let h = if h_i = height then 0 elif h_i = -1 then (height - 1) else h_i\n      let command = co.[codeidx]\n      match command with\n      | '*' ->\n        let x = grid.[h, w]\n        grid.[h, w] <- if grid.[h, w] = '1' then '0' else '1'\n        inner (w, h) (codeidx + 1) (iterations - 1)\n      | 'n' -> inner (w, h - 1) (codeidx + 1) (iterations - 1)\n      | 'e' -> inner (w + 1, h) (codeidx + 1) (iterations - 1)\n      | 's' -> inner (w, h + 1) (codeidx + 1) (iterations - 1)\n      | 'w' -> inner (w - 1, h) (codeidx + 1) (iterations - 1)\n      | '[' ->\n        let new_codeidx = if grid.[h, w] = '0' then (past co (codeidx + 1) 0) else (codeidx + 1)\n        inner (w, h) new_codeidx (iterations - 1)\n      | ']' ->\n        let new_codeidx = if grid.[h, w] = '1' then (back co (codeidx - 1) 0) else (codeidx + 1)\n        inner (w, h) new_codeidx (iterations - 1)\n      | _ -> failwith \"Error\"\n  if iterations = 0 then print grid\n  else inner (0, 0) 0 iterations","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86335,"user_id":null,"body":"let findMatchingBracket (code: string) p (brk: char) =\n  let dir = if brk = ']' then 1 else -1\n  let rec find p stack = \n    let np = p + dir\n    let ins = code.[p]\n    if ins = brk && List.isEmpty stack then\n      p + 1\n    else\n      match ins with \n      | '[' | ']' when ins = brk ->\n        find np <| List.tail stack \n      | '[' | ']' ->\n        find np <|  ins :: stack\n      | _ -> \n        find np stack\n  find p List.empty\n\nlet inc d m c = \n  let c' = c + d in if c' < 0 then m + c' else c' % m\n\nlet run (code: string) it w h (grid: bool array array): bool array array = \n  let incX d = inc d w\n  let incY d = inc d h\n  let rec loop it coord cp =\n    if it = 0 || cp = code.Length then\n      grid\n    else\n      let (x, y) = coord\n      let ncp = cp + 1\n      let cell = grid.[y].[x]\n      let nit = it - 1\n      match code.[cp] with\n      | 'e' -> \n        loop nit (incX 1 x, y) ncp\n      | 'w' -> \n        loop nit (incX -1 x, y) ncp\n      | 'n' -> \n        loop nit (x, incY -1 y) ncp\n      | 's' -> \n        loop nit (x, incY 1 y) ncp\n      | '*' ->\n        grid.[y].[x] <- not cell \n        loop nit coord ncp\n      | '[' when not cell ->\n        findMatchingBracket code ncp ']'\n        |> loop nit coord\n      | ']' when cell ->\n        findMatchingBracket code (cp - 1) '['\n        |> loop nit coord\n      | '[' | ']' ->\n        loop nit coord ncp\n      | ']' -> \n        loop nit coord cp      \n      | _ -> \n        loop it coord ncp\n  \n  loop it (0, 0) 0\n\nlet interpreter (code: string) it w h =\n  Array.init h (fun _ -> Array.init w (fun _ -> false))\n  |> run code it w h\n  |> Array.map(fun row ->\n    row \n    |> Array.map(fun cell -> if cell then '1' else '0')\n    |> System.String\n  )\n  |> String.concat \"\\r\n\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86336,"user_id":null,"body":"type Grid(h, w) = \n    let array = Array2D.create<bool> h w false\n    let mutable (row, col) = (0, 0)\n\n    member this.Pointer\n        with get() = array.[row, col]\n\n    member this.Invert() = array.[row, col] <- not array.[row, col]\n\n    member this.Up() = \n        let value = row - 1\n        if value > -1 then row <- value\n        else row <- h - 1\n\n    member this.Down() = \n        let value = row + 1\n        if value < h then row <- value\n        else row <- 0\n\n    member this.Right() = \n        let value = col + 1\n        if value < w then col <- value\n        else col <- 0\n\n    member this.Left() = \n        let value = col - 1\n        if value > -1 then col <- value\n        else col <- w - 1\n\n    override this.ToString() = \n        let value v= \n            if v then 1\n            else 0\n\n        let map x y v =\n             if y = w - 1 then (value v).ToString() + \"\\r\n\"\n             else (value v).ToString()\n                \n            \n        array |> Array2D.mapi map |> Seq.cast<string> |> Seq.reduce (fun acc value -> acc + value)\n\n[<AbstractClass>]\ntype Command(keyword) = \n    member this.Match cmd = \n        if cmd = keyword then true else false\n\n    abstract Execute: string -> int -> Grid -> int\n\ntype UpCommand() = \n    inherit Command('n')\n    override this.Execute code cmdPointer grid = \n        grid.Up()\n        cmdPointer + 1\n\ntype DownCommand() = \n    inherit Command('s')\n    override this.Execute code cmdPointer grid = \n        grid.Down()\n        cmdPointer + 1\n\ntype LeftCommand() = \n    inherit Command('w')\n    override this.Execute code cmdPointer grid = \n        grid.Left()\n        cmdPointer + 1\n\ntype RightCommand() = \n    inherit Command('e')\n    override this.Execute code cmdPointer grid = \n        grid.Right()\n        cmdPointer + 1\n\ntype InvertCommand() = \n    inherit Command('*')\n    override this.Execute code cmdPointer grid = \n        grid.Invert()\n        cmdPointer + 1\n\ntype JumpForwardCommand() =\n    inherit Command('[')\n    override this.Execute code cmdPointer grid = \n        let mutable nested = 0\n        if grid.Pointer = false then\n            let idx = code \n                        |> Seq.cast<char> \n                        |> Seq.indexed \n                        |> Seq.findIndex (fun (idx, value) -> \n                                             match value with\n                                             | '[' -> \n                                                nested <- nested + 1\n                                                idx > cmdPointer && value = ']' && nested = 1\n                                             | ']' -> \n                                                nested <- nested - 1\n                                                idx > cmdPointer && value = ']' && nested = 1\n                                             | _ -> idx > cmdPointer && value = ']' && nested = 1)\n            idx + 1\n        else \n            cmdPointer + 1\n\ntype JumpBackCommand() =\n    inherit Command(']')\n    override this.Execute code cmdPointer grid = \n        let mutable nested = 0\n        if grid.Pointer = true then\n            let idx = code\n                        |> Seq.cast<char> \n                        |> Seq.indexed \n                        |> Seq.rev\n                        |> Seq.findIndex (fun (idx, value) -> \n                                            match value with\n                                            | '[' -> \n                                                nested <- nested + 1\n                                                idx < cmdPointer && value = '[' && nested = 0\n                                            | ']' -> \n                                                nested <- nested - 1\n                                                idx < cmdPointer && value = '[' && nested = 0\n                                            | _ -> idx < cmdPointer && value = '[')\n            code.Length - idx\n        else \n            cmdPointer + 1\n\ntype Interpreter() =\n    let commands:Command[] = [| UpCommand(); DownCommand(); LeftCommand(); RightCommand(); InvertCommand(); JumpForwardCommand(); JumpBackCommand() |]\n\n    member this.Execute(code:string, iterations, width, height) = \n        let grid = Grid(height, width)\n        let mutable cmdPointer = 0\n        let mutable iteration = 0\n\n        while iteration < iterations && cmdPointer < code.Length do\n            let cmd = commands |> Array.find (fun cmd -> cmd.Match code.[cmdPointer])\n            cmdPointer <- cmd.Execute code cmdPointer grid\n            iteration <- iteration + 1\n\n        grid.ToString().TrimEnd()\n\nlet removeNonCommandCharacters (code:string) = \n    let validCommands = [| 'n'; 's'; 'e'; 'w'; '['; ']'; '*' |]\n    code |> Seq.cast<char> |> Seq.where (fun c -> Array.contains c validCommands) |> System.String.Concat\n\nlet interpreter (code: string) iterations width height =\n    let interpreter = Interpreter()\n    let commands = removeNonCommandCharacters code\n    interpreter.Execute(commands, iterations, width, height)\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5868b2de442e3fb2bb000119":[{"id":86337,"user_id":null,"body":"open System\n\nlet closest (stringOfNumbers: string) =\n\n    let toInteger s = System.Int32.Parse(s.ToString())\n\n    let weigh (number: string) =\n        number.ToCharArray()\n        |> Seq.map (fun c -> toInteger c)\n        |> Seq.sum\n    \n    let sortOrder ((a, b): int list * int list) =\n        let distance = b.[0] - a.[0]\n        let smallestweight = min b.[0] a.[0]\n        let smallestIndex = min a.[1] b.[1]\n        (distance, smallestweight, smallestIndex)\n\n    let numbers = stringOfNumbers.Split()\n    if numbers.Length < 2 then ([], [])\n    else\n        numbers\n        |> Seq.mapi (fun i n -> [weigh n; i; toInteger n])\n        |> Seq.sortBy (fun i -> i.[0] )\n        |> Seq.pairwise\n        |> Seq.sortBy sortOrder\n        |> Seq.head","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2023-01-09 21:46:19"},{"id":86338,"user_id":492,"body":"open System\n\nlet toDig (strn: string) =  \n    let n = Convert.ToInt32 strn\n    int(List.sum (List.map Char.GetNumericValue (n.ToString().ToCharArray() |> Seq.toList)))\n\nlet closest (strng: string) =\n    if (strng = \"\") then ([],[])\n    else\n        let a: array<string> = strng.Split([|' '|])\n        let c = [0..Array.length a  - 1] |> List.fold(\n                    fun acc i -> [toDig(a.[i]); i; Convert.ToInt32(a.[i])] :: acc\n                    ) [] |> List.sort\n        let e = List.map (fun i -> (c.[i].[0] - c.[i-1].[0], i)) [1..Array.length a  - 1] |> List.sort\n        let f = snd(e.[0])\n        (c.[f - 1], c.[f])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86339,"user_id":492,"body":"open System\n\nlet toDig (strn: string) =  \n    let n = Convert.ToInt32 strn\n    int(List.sum (List.map Char.GetNumericValue (n.ToString().ToCharArray() |> Seq.toList)))\n\nlet closest (strng: string) =\n    if (strng = \"\") then ([],[])\n    else\n        let a: array<string> = strng.Split([|' '|])\n        let c = [0..Array.length a  - 1] |> List.fold(\n                    fun acc i -> [toDig(a.[i]); i; Convert.ToInt32(a.[i])] :: acc\n                    ) [] |> List.sort\n        let e = List.map (fun i -> (c.[i].[0] - c.[i-1].[0], i)) [1..Array.length a  - 1] |> List.sort\n        let f = snd(e.[0])\n        (c.[f - 1], c.[f])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86340,"user_id":null,"body":"open System\n\nlet countDigits (str: string) =\n  str |> Seq.sumBy (fun x -> (int)x - (int)'0')\n  \nlet closest (strng: string) =\n  if (strng = \"\") then\n    ([],[])\n  else\n    strng.Split(' ') |> Array.mapi (fun i x -> ([(countDigits x); i; (int)x])) |>\n    (fun x -> Array.allPairs x x) |> Array.filter (fun ([a;b;c],[d;f;h]) -> b <> f) |>\n    Array.minBy (fun ([a;b;c],[d;f;h]) -> abs(a - d), a, abs(b + f))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86341,"user_id":null,"body":"open System\n\nlet closest (strng: string) =\n  let makeNumber (s: string) = \n    s \n    |> Seq.map (fun c -> (int c) - 48) \n    |> Seq.rev \n    |> Seq.fold (fun (multiplier, value) c -> (multiplier * 10, value + (c * multiplier))) (1, 0)\n    |> snd\n\n  let ordered =\n    strng.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    |> Array.mapi (fun i p -> (p |> Seq.sumBy (fun c -> (int c) - 48)), i, p)\n    |> Seq.sortBy (fun (s,_,_) -> s)\n    |> Seq.pairwise\n    |> Seq.sortBy (fun ((s, _, _), (s2, _, _)) -> s2 - s)\n    |> Seq.collect (fun (l, r) -> [l;r])\n    |> Seq.distinct\n    |> Seq.toList\n  match ordered with\n  | a when a.Length > 2 ->\n    let (s, i, o) = ordered |> Seq.head \n    let (s2, i2, o2) = ordered |> Seq.item 1 \n\n    ([s;i;(makeNumber o)],[s2;i2;(makeNumber o2)])\n  | [] -> ([], [])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86342,"user_id":753,"body":"open System\n\nlet weight (s: string): int =\n  s\n  |> Seq.sumBy Char.GetNumericValue\n  |> int\n\nlet closest (strng: string) =\n  if strng = \"\" then\n    ([],[])\n  else\n    Array.mapi (fun i num -> [weight num; i; int num])(strng.Split())\n    |> Array.sort\n    |> Array.pairwise\n    |> Array.minBy (fun (f,s) -> abs(List.head f - List.head s))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86343,"user_id":null,"body":"let cartesianSelf xs = xs |> List.collect (fun x -> xs |> List.map (fun y -> (x, y)))\n\nlet rec weight n =\n    match n with\n    | 0 -> 0\n    | _ -> (n % 10) + (weight (n \/ 10))\n\nlet parse (numbers: string) =\n    numbers.Split(' ')\n    |> Array.mapi (fun i n ->\n        let numeric = n |> int\n        (numeric |> weight, i, numeric))\n    |> List.ofArray\n\nlet closest (strng: string) =\n    match strng with\n    | \"\" -> ([], [])\n    | _ ->\n        let filteredCartesian =\n            strng\n            |> (parse\n                >> cartesianSelf\n                >> List.filter (fun ((_, i1, _), (_, i2, _)) -> i1 <> i2))\n\n        \/\/ sortBy is a stable sort, meaning we can sort from the least-important criterion\n        \/\/ to the most important and the result will be exactly what we need\n        let (x1, x2) =\n            filteredCartesian\n            |> Seq.sortBy (fun ((_, i1, _), (_, _, _)) -> i1)\n            |> Seq.sortBy (fun ((_, _, _), (_, i2, _)) -> i2)\n            |> Seq.sortBy (fun ((w1, _, _), (_, _, _)) -> w1)\n            |> Seq.sortBy (fun ((_, _, _), (w2, _, _)) -> w2)\n            |> Seq.minBy (fun ((w1, _, _), (w2, _, _)) -> abs (w1 - w2))\n\n        \/\/ the restult needs to be a tuple of arrays so let's deconstruct the resulting list of tuples...\n        let [ (w1, i1, n1); (w2, i2, n2) ] =\n            [ x1; x2 ]\n            |> Seq.sortBy (fun (_, i, _) -> i)\n            |> Seq.sortBy (fun (w, _, _) -> w)\n            |> List.ofSeq\n\n        \/\/ ... and reconstruct a tuple of lists\n        ([ w1; i1; n1 ], [ w2; i2; n2 ])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86344,"user_id":null,"body":"open System\n\nlet closest (strng: string) =\n  \/\/ your code\n  let rec getScore acc n =\n    match n with\n    | d when d < 10 -> acc + d\n    | _ -> getScore (acc + n % 10) (n \/ 10)\n  let getScoreValue l = \n      match l with\n      | score :: tail -> score\n      | _ -> failwith \"no score\"\n  let getScoreDiff (fl, sl) =\n    let score1 = getScoreValue fl\n    let score2 = getScoreValue sl\n    score2 - score1\n  let r = strng.Split([|' '|], StringSplitOptions.RemoveEmptyEntries) \n          |> Array.map Int32.Parse\n          |> Array.mapi (fun i n -> [getScore 0 n; i; n])\n          |> Array.toList\n          |> List.sortBy getScoreValue\n          |> List.pairwise\n          |> List.sortBy getScoreDiff\n          \n  match r with\n  | head::tail -> head\n  | _ -> ([],[])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86345,"user_id":null,"body":"open System\n\ntype WeightIndexValue = {\n  Weight: int\n  Index: int\n  Value: int\n }\n\nmodule WeightIndexValue =\n  let ToList wiv = [ wiv.Weight; wiv.Index; wiv.Value ]\n\nlet getWeight (strng: string) =\n  let reducer acc x = acc + (x |> string |> int)\n  strng |> Seq.fold reducer 0\n\nlet elementToWeightIndexValue idx numStr =\n  { Weight = getWeight numStr; Index = idx; Value = int numStr }\n\n#nowarn \"0025\"\nlet closest (strng: string) =\n  let numberStrings = strng.Split() |> List.ofSeq\n  match numberStrings with\n  | [] | [_] -> ([],[])\n  | _ ->\n  let weightIndexValues = numberStrings |> Seq.mapi elementToWeightIndexValue\n  let pairs = weightIndexValues |> Seq.collect (fun x -> weightIndexValues |> Seq.map (fun y -> (x, y)))\n  pairs\n  |> Seq.filter (fun (x, y) -> x.Index <> y.Index)\n  |> Seq.sortBy (fun (x, y) -> (x.Index + y.Index) \/ 2)\n  |> Seq.sortBy (fun (x, y) -> (x.Weight + y.Weight) \/ 2)\n  |> Seq.sortBy (fun (x, y) -> Math.Abs(x.Weight - y.Weight))\n  |> Seq.head\n  |> fun (x, y) -> [ x; y ]\n  |> List.sortBy (fun x -> x.Index)\n  |> List.sortBy (fun x -> x.Weight)\n  |> List.map WeightIndexValue.ToList\n  |> fun [ x; y ] -> (x, y)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86346,"user_id":null,"body":"open System\n\nlet closest (strng: string) =\n  let getWeights lst =\n    lst |> List.mapi (fun i x -> x |> Seq.toArray |> Array.map (string >> int) |> Seq.sum |> (fun y -> [y; i; int x] ) )\n  if( strng = String.Empty ) then\n    ([],[])\n  else    \n    strng.Split [|' '|]\n      |> Array.toList\n      |> getWeights \n      |> List.sortBy (fun x -> x.[0], x.[1])\n      |> List.pairwise \n      |> List.map ( fun (x,y) -> ((y.[0] - x.[0]), x, y) )\n      |> List.sortBy ( fun (x, y, z) -> x, y.[0], z.[0], y.[1], z.[1] )\n      |> (fun x -> \n              let (_, a, b) = x.[0]\n              (a,b)) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"586dd26a69b6fd46dd0000c0":[{"id":86347,"user_id":null,"body":"open System.Text\n\nlet interpret (code : string) =\n    code\n    |> Seq.fold (\n        fun (cell, output : StringBuilder) command ->\n            match command with\n            | '+' -> (cell + 1) % 256, output\n            | '.' -> cell, cell |> char |> output.Append\n            | _ -> cell, output)\n        (0, StringBuilder())\n    |> snd\n    |> string\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86348,"user_id":null,"body":"let validChar c =\n    match c with\n    |'+' \n    |'.' -> true\n    |_ -> false\n\nlet iterState state =\n    match state with\n    |255 -> 0\n    |x -> x+1\n\nlet read (state,res) (c:char)  =\n    match c with \n    |'+' -> ((iterState state),res)\n    |'.' -> (state, (res + string (char state)))\n    |_ -> failwith \"wtf filter?\"\n\nlet interpret (code: string) =\n    code \n    |> Seq.filter validChar\n    |> Seq.fold read (0,\"\")\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86349,"user_id":null,"body":"let step (cell, output) cmd =\n  match cmd with\n    | '.' -> (cell, sprintf \"%s%c\" output (char cell))\n    | '+' -> ((cell + 1) % 256, output)\n    | _ -> (cell, output)\n\nlet interpret (code: string) =\n  match code.ToCharArray() |> Array.fold step (0, \"\") with\n    (_, output) -> output","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86350,"user_id":null,"body":"let interpC (cell, out) = function\n| '+' -> (cell + 1uy, out) \n| '.' -> (cell, out + (string <| char cell)) \n|  _  -> (cell, out)\n\nlet interpret =\n    Seq.fold interpC (0uy, \"\") \n    >> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86351,"user_id":null,"body":"let interpret (input: string) =\n    let rec interpretAux currentMemory acc commands =\n        match commands with\n        | x :: rest ->\n            match x with\n            | '+' -> interpretAux ((currentMemory + 1) % 256) acc rest\n            | '.' -> interpretAux currentMemory ((char currentMemory) :: acc) rest\n            | _ -> failwith \"This cannot be\"\n        | [] -> acc\n\n    input\n    |> List.ofSeq\n    |> List.filter (fun c -> c = '+' || c = '.')\n    |> interpretAux 0 []\n    |> List.rev\n    |> Array.ofList\n    |> fun x -> System.String(x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86352,"user_id":null,"body":"let interpret (code: string) =\n    let mutable mem = 0uy\n    seq { for e in code do\n            match e with\n            | '+' -> mem <- mem + 1uy\n            | '.' -> yield mem\n            | _ -> () }\n    |> Array.ofSeq\n    |> System.Text.Encoding.GetEncoding(28591).GetString\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86353,"user_id":null,"body":"let inc m = if m = 255 then 0 else m+1\n\nlet rec interp mem out = function\n  | '+' :: code -> interp (inc mem) out code\n  | '.' :: code -> interp mem (char mem :: out) code\n  | _ :: code -> interp mem out code\n  | [] -> out |> Seq.rev\n\nlet interpret (code: string) =\n  code\n  |> Seq.toList\n  |> interp 0 []\n  |> Seq.toArray\n  |> System.String","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86354,"user_id":null,"body":"let interpret (code: string) =\n    let rec execute message cell command =\n        match command, message, cell with\n        | ([], mess, _) -> mess\n        | (c :: cs, mess, ce) ->\n            match c with\n            | '+' -> execute mess ((ce + 1) % 256) cs\n            | '.' -> execute (char (ce) :: mess) ce cs\n            | _ -> execute mess ce cs\n\n    code\n    |> List.ofSeq\n    |> execute [] 0\n    |> List.rev\n    |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86355,"user_id":null,"body":"let interpret code =\n    let rec interpret' code cell =\n        match code with\n        | '.' :: code' -> (string (char cell)) + (interpret' code' cell)\n        | '+' :: code' -> interpret' code' ((cell + 1) % 256)\n        | c :: code' -> interpret' code' cell\n        | [] -> \"\"\n\n    interpret' (Seq.toList code) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86356,"user_id":168,"body":"let interpret (code: string) =\n  let step (output, cell) x =\n    match x with\n    | '+' -> output, cell + 1\n    | '.' -> char (cell &&& 0xff) :: output, cell\n    | _ -> output, cell\n  code\n  |> Seq.fold step ([], 0)\n  |> fst\n  |> Seq.rev\n  |> System.String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5879f95892074d769f000272":[{"id":86357,"user_id":null,"body":"open System\n\nlet GRAVITY_ACC = 9.81 * 3.6 * 60.0\nlet DRAG = 60.0 * 0.3 \/ 3.6\nlet DELTA_T = 1.0 \/ 60.0\nlet G_THRUST = 60.0 * 3.6 * 3.6\nlet MASS = 80.0\nlet WATTS0 = 225.0\nlet D_WATTS = 0.5\n\ntype BikerState =\n    { Time: float\n      Speed: float\n      Distance: float\n      Acceleration: float\n      Power: float }\n\nlet slopeEffect slope = Math.Sin(Math.Atan (slope \/ 100.0))\n\nlet rec go targetDistance slope state =\n    match state.Speed - 3.0 <= 1e-2 with\n    | true -> -1\n    | false ->\n        match state.Distance <= targetDistance with\n        | false -> round(state.Time) |> int\n        | true ->\n            let newTime = state.Time + DELTA_T\n            let newPower = state.Power - D_WATTS * DELTA_T\n\n            let thrust =\n                match state.Power > 0.0 && state.Speed > 0.0 with\n                | true -> G_THRUST * newPower \/ (state.Speed * MASS)\n                | false -> 0.0\n\n            let newAcceleration1 =\n                -GRAVITY_ACC * (slopeEffect slope) - DRAG * abs (state.Speed) * (abs state.Speed) \/ MASS\n                + thrust\n\n            let newAcceleration2 =\n                if abs (newAcceleration1) <= 1e-5 then 0.0 else newAcceleration1\n\n            let newSpeed = state.Speed + newAcceleration2 * DELTA_T\n            let newDistance = state.Distance + state.Speed * DELTA_T \/ 60.0\n\n            go targetDistance slope\n                { Power = newPower\n                  Speed = newSpeed\n                  Distance = newDistance\n                  Acceleration = newAcceleration2\n                  Time = newTime }\n\nlet temps (v, slope, d_tot) =\n    go (d_tot |> float) (slope |> float)\n        { Speed = (v |> float)\n          Distance = 0.0\n          Acceleration = 0.0\n          Power = WATTS0\n          Time = 0.0 }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86358,"user_id":492,"body":"open System\n\nlet rec tempsAux(v, slope, d_tot, d, t, watts) =\n    let GRAVITY_ACC = 9.81 * 3.6 * 60.0               \/\/ gravity acceleration\n    let DRAG = 60.0 * 0.3 \/ 3.6                       \/\/ force applied by air on the cyclist\n    let DELTA_T = 1.0 \/ 60.0                          \/\/ in minutes\n    let D_WATTS = 0.5                                 \/\/ power loss in Watts \/ minute\n    let G_THRUST = 60.0 * 3.6 * 3.6                   \/\/ acceleration due to biker's power\n    let MASS = 80.0                                   \/\/ biker's MASS\n    if (v - 3.0 <= 1e-2) then\n        -1\n    else\n        let slopeGravityAcc = -GRAVITY_ACC * sin(atan(slope \/ 100.0))\n        if (d <= d_tot) then\n            let tt = t + DELTA_T\n            \/\/ new power\n            let wwatts = watts - D_WATTS * DELTA_T \/\/ tiredness\n            \/\/ earth gravity due to slope and DRAG due to air resistance\n            let gamma = slopeGravityAcc - DRAG * abs(v) * abs(v) \/ MASS\n            \/\/ acceleration due to biker's power\n            let ggamma =\n                if ((wwatts > 0.0) && (v > 0.0)) then\n                    gamma + G_THRUST * wwatts \/ (v * MASS)                \n                else gamma\n            \/\/ acceleration too small -> acc = 0\n            let vv =\n                if (abs(ggamma) <= 1e-5) then\n                    v\n                else\n                    v + ggamma * DELTA_T\n            \/\/ new distance\n            let dd = d + v * DELTA_T \/ 60.0 \/\/ v in km\/h, DELTA_T in minutes\n            tempsAux(vv, slope, d_tot, dd, tt, wwatts)\n        else\n            Convert.ToInt32(round(t))\n\nlet temps(v, slope, d_tot) =\n    let WATTS0 = 225.0                                  \/\/ initial biker's power\n    tempsAux(float v, float slope, float d_tot, 0.0, 0.0, WATTS0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86359,"user_id":492,"body":"open System\n\nlet rec tempsAux(v, slope, d_tot, d, t, watts) =\n    let GRAVITY_ACC = 9.81 * 3.6 * 60.0               \/\/ gravity acceleration\n    let DRAG = 60.0 * 0.3 \/ 3.6                       \/\/ force applied by air on the cyclist\n    let DELTA_T = 1.0 \/ 60.0                          \/\/ in minutes\n    let D_WATTS = 0.5                                 \/\/ power loss in Watts \/ minute\n    let G_THRUST = 60.0 * 3.6 * 3.6                   \/\/ acceleration due to biker's power\n    let MASS = 80.0                                   \/\/ biker's MASS\n    if (v - 3.0 <= 1e-2) then\n        -1\n    else\n        let slopeGravityAcc = -GRAVITY_ACC * sin(atan(slope \/ 100.0))\n        if (d <= d_tot) then\n            let tt = t + DELTA_T\n            \/\/ new power\n            let wwatts = watts - D_WATTS * DELTA_T \/\/ tiredness\n            \/\/ earth gravity due to slope and DRAG due to air resistance\n            let gamma = slopeGravityAcc - DRAG * abs(v) * abs(v) \/ MASS\n            \/\/ acceleration due to biker's power\n            let ggamma =\n                if ((wwatts > 0.0) && (v > 0.0)) then\n                    gamma + G_THRUST * wwatts \/ (v * MASS)                \n                else gamma\n            \/\/ acceleration too small -> acc = 0\n            let vv =\n                if (abs(ggamma) <= 1e-5) then\n                    v\n                else\n                    v + ggamma * DELTA_T\n            \/\/ new distance\n            let dd = d + v * DELTA_T \/ 60.0 \/\/ v in km\/h, DELTA_T in minutes\n            tempsAux(vv, slope, d_tot, dd, tt, wwatts)\n        else\n            Convert.ToInt32(round(t))\n\nlet temps(v, slope, d_tot) =\n    let WATTS0 = 225.0                                  \/\/ initial biker's power\n    tempsAux(float v, float slope, float d_tot, 0.0, 0.0, WATTS0)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5886d65e427c27afeb0000c1":[{"id":86360,"user_id":null,"body":"open System.Globalization\nopen System.Collections.Generic\n\nlet squareDigitsSequence a0 =\n    let hash = HashSet<int>()\n\n    let rec sequence n =\n        seq {\n            yield n\n            yield! string n |> Seq.sumBy (fun c -> pown (CharUnicodeInfo.GetDigitValue c) 2) |> sequence\n        }\n\n    sequence a0 |> Seq.takeWhile hash.Add |> Seq.length |> (+) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86361,"user_id":null,"body":"let squareDigitsSequence a0 =\n\n    let dSqSum a =\n        let rec loop accSum n = \n            if n<10 then accSum + n*n\n            else loop (accSum + (n%10)*(n%10)) (n\/10)\n        loop 0 a\n\n    let rec loop x (s:ResizeArray<int>) =\n        match dSqSum x with\n        | var1 when Seq.contains var1 s -> 1 + Seq.length s\n        | var2 -> \n            s.Add(var2)\n            loop var2 s\n    let r = new ResizeArray<int>()\n    r.Add(a0)\n    loop a0 r","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86362,"user_id":null,"body":"let rec digits = function\n    | 0 -> []\n    | n -> (n % 10) :: digits (n \/ 10)\n\nlet square x = x * x\n\nlet squareDigitsSequence a0 =\n    let rec loop i acc  =\n        match acc with\n        | [] -> loop 1 [a0]\n        | x::xs when xs |> List.contains x -> i\n        | x::_ as acc -> (digits x |> List.sumBy square) :: acc |> loop (i+1) \n    loop 0 []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86363,"user_id":null,"body":"open System.Collections.Generic\n\nlet squareDigitsSequence a0 =\n    let passed = new HashSet<int>()\n    \n    let countSqr (a: int) =  \n      Seq.unfold (fun a -> Some(a % 10, a \/ 10)) a |> \n      Seq.take (a.ToString().Length) |> Seq.sumBy (fun x -> x * x)\n      \n    let rec getResult (a: int) =\n      if (passed.Contains(a)) then\n        1\n      else\n        passed.Add(a)\n        let newa = (countSqr a)\n        1 + (getResult newa)\n        \n    (getResult a0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86364,"user_id":null,"body":"let squareDigitsSequence a0 =\n    let rec run (refs: int list) (iteration: int) (value: int)  =\n        value \n        |> (string >> fun x -> x.ToCharArray())\n        |> Array.sumBy (string >> int >> fun x -> x * x)\n        |> fun x -> if (x, refs) ||> List.contains then iteration + 1 else run (refs @ [x]) (iteration + 1) x\n    run [a0] 1 a0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86365,"user_id":null,"body":"let squareDigitsSequence a0 =\n    let digits n =\n        Seq.unfold\n            (fun s ->\n                if s = 0 then\n                    None\n                else\n                    Some(s % 10, s \/ 10))\n            n\n\n    let set = System.Collections.Generic.HashSet<int>()\n\n    let rec se e0 =\n        seq {\n            yield e0\n\n            yield!\n                se (\n                    e0\n                    |> digits\n                    |> Seq.map (fun d -> d * d)\n                    |> Seq.sum\n                )\n        }\n\n    (se a0 |> Seq.takeWhile (set.Add) |> Seq.length)+1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86366,"user_id":53,"body":"open System.Globalization\nopen System.Collections.Generic\n\nlet squareDigitsSequence a0 =\n  let s = HashSet<int>()\n  let mutable n = a0\n  while (not (s.Contains(n))) do\n    s.Add(n) |> ignore\n    n <- Seq.fold (fun a c -> a + (pown (CharUnicodeInfo.GetDigitValue c) 2)) 0 ((string n).ToCharArray())\n  s.Count + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86367,"user_id":null,"body":"let digits n =\n  let rec loop n acc =\n    if n < 10 then n :: acc\n    else\n      loop (n \/ 10) ((n % 10) :: acc)\n      \n  loop n []\n\nlet squareDigitsSequence a0 =\n  let rec term n =\n    if n = 0 then a0\n    else\n      term (n-1)\n      |> digits\n      |> List.map (fun x -> x * x)\n      |> List.sum\n  \n  let mutable i = 0\n  let mutable sequence = []\n  \n  while sequence |> Seq.contains (term i) |> not do\n    sequence <- (term i) :: sequence\n    i <- i + 1\n    \n  i+1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86368,"user_id":null,"body":"let digits n =\n    n.ToString().ToCharArray()\n    |> Array.map (System.Char.GetNumericValue >> System.Convert.ToInt32)\n\nlet rec contains n = function\n    | [] -> false\n    | x :: xs -> (n = x) || contains n xs\n\nlet squareDigitsSequence a0 =\n  let mutable out = [a0]\n  let mutable temp = (digits (out.[((out.Length) - 1)]) |> Array.map (fun x -> x*x) |> Array.sum)\n  while not (out |> contains temp) do\n    out <- out @ [temp]\n    temp <- (digits (out.[((out.Length) - 1)]) |> Array.map (fun x -> x*x) |> Array.sum)\n  (out.Length) + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86369,"user_id":null,"body":"let squareDigitsSequence a0 =\n    let rec data = seq {\n        yield a0;\n        for n in data ->\n            n.ToString().ToCharArray()\n            |> Array.map (int >> ((+) -48) >> (fun x -> x * x))\n            |> Array.sum } in\n    let rec check lst i =\n        let n = Seq.item i data in\n        if (List.exists ((=) n) lst) then i + 1 else check (n::lst) (i + 1) in\n    check [] 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5886e082a836a691340000c3":[{"id":86370,"user_id":53,"body":"let rectangle_rotation a b =\n    let x = (int ((float a) \/ (sqrt 2.0)))\n    let y = (int ((float b) \/ (sqrt 2.0)))\n    let r = (x + 1) * (y + 1) + x * y\n    r + r % 2 - 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86371,"user_id":168,"body":"let rectangle_rotation a b =\n  let a' = int (float a \/ sqrt 2.0)\n  let b' = int (float b \/ sqrt 2.0)\n  2 * a' * b' + a' + b' - (a' ^^^ b' &&& 1) + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86372,"user_id":null,"body":"open System\n    \nlet rectangle_rotation a b =\n    let w x = Math.Floor(float x \/ Math.Sqrt 2.) |> int\n    let (|Odd|Even|) x = if x % 2 = 0 then Even x else Odd x\n    match w a, w b with\n    | Even x, Odd y | Odd y, Even x -> (x + 1) * y + (y + 1) * x\n    | x, y -> (x + 1) * (y + 1) + x * y","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86373,"user_id":null,"body":"open System\n\nlet rectangle_rotation a b = \n    let sqrt2 = Math.Sqrt 2.0\n    \n    let n = Math.Floor(float(a)\/sqrt2) |> int\n    let m = Math.Floor(float(b)\/sqrt2) |> int\n\n    let result = (n + 1) * m + (m + 1) * n\n\n    if (n % 2 = m % 2) then result + 1 else result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86374,"user_id":492,"body":"let (.\/) x y = \n    (x |> double) \/ y\n\nlet rectangle_rotation a b =\n    let x = int (floor (a .\/ sqrt (2.0)))\n    let y = int (floor (b .\/ sqrt (2.0)))\n    let mutable res = 0\n    if (x + y) % 2 = 0\n    then res <- (x + 1) * (y + 1) + x * y\n    else res <- (x + 1) * y + x * (y + 1)\n    res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86375,"user_id":null,"body":"let diagonalLength = sqrt 2.0 \nlet isEven x = x % 2 = 0\n\nlet diagonalsIn side = \n    (float)side \/ diagonalLength\n    |> floor\n    |> int\n\nlet rectangle_rotation a b =\n    \n    let da = diagonalsIn a\n    let db = diagonalsIn b\n\n    let integerPoints = da * db + (da + 1) * (db + 1)\n\n    match da, db with\n    | _ when isEven da = isEven db -> integerPoints\n    | _ -> integerPoints - 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86376,"user_id":null,"body":"open System\n\nlet rectangle_rotation a b =\n  let sqrt2 = sqrt 2.\n  \n  let a2 = floor (float a \/ 2. * sqrt2) + 1. |> int\n  let b2 = floor (float b \/ 2. * sqrt2) + 1. |> int\n  \n  let t = a2 * b2 + (a2 - 1) * (b2 - 1)\n  \n  if a2 % 2 = b2 % 2\n  then t \n  else t - 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86377,"user_id":149,"body":"let rectangle_rotation a b =\n  let n = sqrt (double 2) \/ 4.0\n  let h1 = int ((double a) * n)\n  let h2 = int ((double a) * n + 0.5)\n  let w1 = int ((double b) * n)\n  let w2 = int ((double b) * n + 0.5)\n  (h1 * 2 + 1) * (w1 * 2 + 1) + h2 * w2 * 4","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86378,"user_id":645,"body":"let rectangle_rotation a b =\n    let h = int (float a \/ sqrt 2.0)\n    let v = int (float b \/ sqrt 2.0)\n    h * v + (h + 1) * (v + 1) - (h % 2 ^^^ v % 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86379,"user_id":null,"body":"let rectangle_rotation a b =\n    let sqrt2 = sqrt 2.0\n    let cols = int (floor (double a)\/sqrt2 + 1.0)\n    let rows = int (floor (double b)\/sqrt2 + 1.0)\n    let total = rows * cols + (rows - 1) * (cols - 1)\n    if total % 2 = 0 then total - 1 else total","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"588a3c3ef0fbc9c8e1000095":[{"id":86380,"user_id":null,"body":"let ``max diff`` = function\n  | [||] -> 0\n  | arr -> Array.max arr - Array.min arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86381,"user_id":null,"body":"let ``max diff`` arr =\n    if arr |> Array.isEmpty then 0 else Array.max arr - Array.min arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86382,"user_id":null,"body":"let ``max diff`` a =\n    if Array.length a <= 1\n    then 0\n    else\n        a\n        |> Array.fold (fun (x, y) z -> min x z, max y z) (a.[0], a.[0])\n        |> fun (x, y) -> y - x\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86383,"user_id":null,"body":"let ``max diff`` arr =\n    if Seq.length arr < 2\n    then 0\n    else Seq.max arr - Seq.min arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86384,"user_id":null,"body":"let ``max diff`` arr =\n  match arr with\n  | [||] -> 0\n  | a -> (Array.max a) - (Array.min a)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86385,"user_id":53,"body":"let ``max diff`` arr = \n    if (arr |> Seq.length) > 0 then\n      (arr |> Seq.max) - (arr |> Seq.min)\n    else\n      0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86386,"user_id":null,"body":"let ``max diff`` arr = if (Seq.length arr) > 0 then (Seq.max arr) - (Seq.min arr) else 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86387,"user_id":76,"body":"let ``max diff`` (arr: array<int>): int = \n  match arr.Length with\n  | 0 -> 0\n  | _ -> Seq.max(arr) - Seq.min(arr)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86388,"user_id":null,"body":"let ``max diff`` (arr:int array) = \n    if arr.Length > 0\n      then\n        let max = Array.max arr\n        let min = Array.min arr\n        max-min\n      else\n        0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86389,"user_id":null,"body":"let ``max diff`` arr = \n    if Seq.length arr < 2 then 0\n    else let (min, max) = arr |> Seq.fold (fun (mi, ma) x -> \n                        if x < mi then (x, ma) \n                        else if x > ma then (mi, x) \n                        else (mi, ma))  (9999999, -9999999)\n\n         max - min","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5894318275f2c75695000146":[{"id":86390,"user_id":null,"body":"let deleteDigit n =\n    string n\n    |> Seq.mapi (fun i _ -> (string n).Remove(i, 1) |> int)\n    |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86391,"user_id":null,"body":"let digitsOf = List.unfold (function 0 -> None | n -> Some (n % 10, n \/ 10)) >> List.rev\nlet valueOf = List.rev >> List.mapi (fun i x -> x * pown 10 i) >> List.sum\n\nlet deleteDigit n =\n  let digits = digitsOf n\n  [ for i in 0 .. digits.Length - 1 do\n      yield valueOf (List.append (digits |> List.take i) (digits |> List.skip (i+1))) ]\n  |> List.max\n  \n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86392,"user_id":null,"body":"let deleteDigit n =\n    let nums n =\n        let s = n.ToString()\n        [for i in 0..s.Length - 1 do\n            yield int (s.Remove(i, 1))]\n            \n    nums n |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86393,"user_id":null,"body":"let deleteDigit n =\n  let str = string(n) in\n  let len = String.length str in\n  let arr = str.Substring(1) :: List.init (len - 1) (fun i -> str.Substring(0, i + 1) + str.Substring(i + 2)) in\n  List.max (List.map int arr)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86394,"user_id":null,"body":"let deleteDigit n =\n    let str = n |> string\n    let numbers = seq {for i in [0..str.Length - 1] do yield str.Remove( i, 1) |> int}\n    numbers |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86395,"user_id":null,"body":"let deleteDigit n =\n  let s = n.ToString()\n  [0 .. s.Length - 1]\n  |> List.map(fun i -> System.Int32.Parse(s.Substring(0, i) + s.Substring(i+1)))\n  |> List.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86396,"user_id":null,"body":"let deleteDigit (n: int) =\n    let numberAsString = n.ToString()\n    numberAsString\n    |> Seq.mapi (fun index _ -> numberAsString.Remove(index, count = 1) |> System.Int32.Parse)\n    |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86397,"user_id":753,"body":"let deleteDigit n =\n  let num = string n\n  num\n  |> Seq.mapi (fun i _ -> int(num.Remove(i,1)))\n  |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86398,"user_id":null,"body":"let deleteDigit n =\n    let digits =\n        n\n        |> List.unfold (fun s ->\n            if s = 0 then\n                None\n            else\n                Some(s % 10, s \/ 10))\n\n    let toRemove =\n        digits\n        |> List.indexed\n        |> List.pairwise\n        |> List.tryFindBack (fun ((_, d1), (_, d2)) -> d1 > d2)\n        |> function\n            | None -> 0\n            | Some ((_,(i, _))) -> i\n\n    digits\n    |> List.indexed\n    |> List.choose (fun (i, d) -> if i <> toRemove then Some(d) else None)\n    |> List.fold (fun (power, value) d -> power + 1, value + (d * (pown 10 power))) (0, 0)\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86399,"user_id":null,"body":"let deleteDigit n =\n    let rec delete before previous current after =\n        match after with\n        | [] when previous >= current -> before@[previous]\n        | _ when previous < current -> before@current::after\n        | _ -> delete (before@[previous]) current after.Head after.Tail\n\n    let digits = string n |> Seq.map string |> Seq.map int |> Seq.toList\n\n    delete [] digits.Head digits.Tail.Head digits.Tail.Tail\n    |> Seq.map string\n    |> String.concat \"\"\n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5898b4b71d298e51b600014b":[{"id":86400,"user_id":3318,"body":"let sortTheInnerContent (words : string) =\n    let processWord (word : string) =\n        System.String [|\n            yield word.[0]\n            if word.Length > 1 then\n                yield! word.[1..(word.Length-2)] |> Seq.sortDescending\n                yield  word.[word.Length-1] |]\n    System.String.Join(\" \", words.Split() |> Seq.map processWord)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86401,"user_id":null,"body":"let handleWord s =\n    let len = Seq.length s\n    let mid (s:string) = s.Substring(1, len - 2)\n    let mangle = mid \n                 >> Seq.sortDescending \n                 >> fun x -> seq { yield Seq.head s; yield! x; yield Seq.last s; } |> System.String.Concat \n\n    match len with  \n    | x when x < 3 -> s\n    | _ -> mangle s \n\nlet sortTheInnerContent (s:string) =\n    s.Split(' ')\n    |> Array.toList\n    |> List.map handleWord\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86402,"user_id":null,"body":"open System\nopen System.Collections.Generic\nopen System.Text.RegularExpressions\n\nlet sortTheInnerContent =\n    let reverseComparer = {\n        new IComparer<char> with\n            override __.Compare (x, y) = y.CompareTo(x)\n        }\n\n    let transform (s : string) =\n        let a = s.ToCharArray()\n        Array.Sort(a, 1, a.Length - 2, reverseComparer)\n        String a\n\n    fun (words : string) -> Regex.Replace(words, @\"\\S{4,}\", fun m -> m.Value |> transform)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86403,"user_id":2255,"body":"open System\n\nlet sortInner (word : string) =\n    let letters = word.ToCharArray()\n    match letters with\n    | [||] | [|_|] | [|_;_|] -> word\n    | a -> Array.concat [ [|a.[0]|] ; Array.sortDescending (a.[1..a.Length-2]) ; [|a.[a.Length-1]|] ] |> System.String\n\nlet sortTheInnerContent (sentance : string) : string =\n  let words = sentance.Split[|' '|]\n  words |> Seq.map sortInner |> String.concat \" \"\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86404,"user_id":null,"body":"let sortTheInnerContent (words : string) : string =\n    seq {\n        for w in words.Split(' ') do\n            let wlen = String.length w\n            yield seq {\n                yield w |> Seq.head\n                if wlen >= 3 then yield! w |> Seq.tail |> Seq.truncate (wlen - 2) |> Seq.sortDescending\n                if wlen >= 2 then yield w |> Seq.last\n                } |> System.String.Concat\n        } |> String.concat \" \"\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86405,"user_id":null,"body":"let sort (s : string) =\n    let n = String.length s - 1 in\n        if n > 1 then string s.[0] + (s.[1..(n - 1)] |> Seq.sortDescending |> System.String.Concat) + string s.[n]\n        else s\n\nlet sortTheInnerContent (words : string) : string =\n    words.Split [|' '|] |> Seq.map sort |> String.concat \" \"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86406,"user_id":53,"body":"open System\nopen System.Linq\n\nlet kata (w:string) : string = \n    if String.length w < 3 then      \n      w\n    else\n      w.Substring(0,1) + String.Concat(w.Substring(1, (String.length w)-2).OrderByDescending(fun e -> e)) + w.Substring((String.length w) - 1);\n    \nlet sortTheInnerContent (w : string) : string =\n  String.Join(\" \", w.Split(' ').Select(fun e -> kata e));","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86407,"user_id":null,"body":"let sortTheInnerContent (words : string) : string =\n  let sortWord (s: string) =\n    s.[..0] + (s.[1..s.Length-2] |> Seq.sort |> Seq.rev |> Array.ofSeq |> System.String) + s.[s.Length-1..]\n  words.Split ' '\n  |> Array.map (fun x -> if x.Length > 3 then sortWord x else x)\n  |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86408,"user_id":null,"body":"open System\n\nlet sortTheInnerContent (words : string) : string =\n    let sortInner (s : string) : string =\n        match Seq.toList s with\n        | f :: []      -> f.ToString()\n        | f :: s :: [] -> f.ToString() + s.ToString()\n        | f :: xs      -> f.ToString() + (xs |> Seq.take (xs.Length - 1) \n                                             |> Seq.sortByDescending id \n                                             |> Seq.toArray \n                                             |> String) \n                                       + (xs |> Seq.last).ToString()\n        | _            -> String.Empty\n        \n    words.Split(' ')\n    |> seq\n    |> Seq.map sortInner\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86409,"user_id":null,"body":"open System\n\nlet wordInnerReverse (word:string) =\n    if word.Length <= 2 then word\n    else\n        let sortedMiddle = Array.sortDescending ((word.Substring(1,word.Length - 2)).ToCharArray())\n        word.Substring(0,1) + ( new String(sortedMiddle)) + word.Substring(word.Length - 1)\n    \nlet sortTheInnerContent (words : string) : string =\n    words.Split(' ')\n    |> Array.map (fun word -> wordInnerReverse word)\n    |> String.concat \" \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58a9cff7ae929e4ad1000050":[{"id":86410,"user_id":null,"body":"open System\nopen System.Net\nopen System.Text.RegularExpressions\n\nlet GetHonor username =\n  let matches = (new WebClient()).DownloadString(sprintf \"https:\/\/www.codewars.com\/users\/%s\" username)\n                |> Regex(\"(onor:<\/b>)([\\d,]+)\", RegexOptions.IgnoreCase).Matches\n  (matches.Item 0).Groups.[2].Value\n  |> String.filter(Char.IsDigit)\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86411,"user_id":null,"body":"open System\nopen System.Net\nopen System.Text.RegularExpressions\n\n\nlet fetchHtmlAsync url = \n    async {\n        let uri = Uri(url)\n        use webClient = new WebClient()\n\n        \/\/ Execution of fetchHtmlAsync won't continue until the result\n        \/\/ of AsyncDownloadString is bound.\n        let! html = webClient.AsyncDownloadString(uri)\n        return html\n}\n\nlet GetHonor username = \/\/ Happy coding!\n  let getHonorFromHtml html =\n    let regex = Regex.Match(html, \"(?<=<b>Honor:<\\\/b>)\\d+,*\\d*(?<!<\\\/div>)\")\n    regex.Value\n    \n  \"https:\/\/www.codewars.com\/users\/\" + username\n  |> fetchHtmlAsync\n  |> Async.RunSynchronously\n  |> getHonorFromHtml\n  |> String.filter (fun x-> x <> ',')\n  |> Convert.ToInt32\n\n\nGetHonor \"Blind4Basics\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86412,"user_id":null,"body":"open System.Net\nopen System\nopen System.IO\n\n\nlet GetHonor username =\n    let str = \"https:\/\/www.codewars.com\/api\/v1\/users\/\" + username\n    let req = HttpWebRequest.Create(str) :?> HttpWebRequest\n    let resp = req.GetResponse() \n    let stream = resp.GetResponseStream() \n    let reader = new StreamReader(stream) \n    let html = reader.ReadToEnd()\n    let splithtml = html.Split ','\n    let honorline = splithtml.[2]\n    honorline.[8..(honorline.Length - 1)] |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86413,"user_id":null,"body":"open System.Net\nopen System\nopen System.Text.RegularExpressions\n\nlet getHonorNumber page =\n    let r = new Regex(@\"<text[^>]*?>\\s*(?<honor>\\d+)\\s*<\/text>\")\n    let m' = r.Match page\n    match m' with\n    | m when m.Success ->\n        int m.Groups.[\"honor\"].Value\n    | _ -> \n        failwith \"unable to parse honor\"\n\n\nlet GetHonor (username:string) =\n    use client = new WebClient()\n    Uri <| sprintf \"https:\/\/www.codewars.com\/users\/%s\/badges\/large?logo=false\" username\n    |> client.DownloadString\n    |> getHonorNumber","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86414,"user_id":null,"body":"open System\nopen System.Net\nopen System.Text.RegularExpressions\n\nlet extractHonor str =\n    let r = new Regex(\"Honor:<\/b>([0-9,]+)\")\n    let mtch = (r.Matches(str).Item 0).Value |> String.filter ((<>) ',')\n    let r2 = new Regex(\"\\d+$\")\n    ((r2.Matches mtch).Item 0).Value |> int\n\nlet GetHonor username =\n    async {\n        use wc = new WebClient()\n        let url = sprintf \"http:\/\/codewars.com\/users\/%s\" username\n        let! html = wc.AsyncDownloadString(Uri(url))\n        return (extractHonor html)\n    }\n    |> Async.RunSynchronously","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86415,"user_id":null,"body":"open System.Net\nopen System\nopen System.IO\nopen System.Text.RegularExpressions\n\n\/\/ Fetch the contents of a web page\nlet fetchUrl callback url =        \n    let req = WebRequest.Create(Uri(url)) \n    use resp = req.GetResponse() \n    use stream = resp.GetResponseStream() \n    use reader = new IO.StreamReader(stream) \n    callback reader url\n    \nlet myCallback (reader:IO.StreamReader) url = \n    let html = reader.ReadToEnd()\n  \/\/  printfn \"Downloaded %s. First 1000 is %s\" url html\n    html      \/\/ return all the html\n\nlet getHonor s : string seq =\n    let re = \"\\<b\\>Honor\\:\\<\/b\\>(?<honor>.+?)\\<\/div>\"\n    Regex.Matches(s, re)\n        |> Seq.cast<Match>\n        |> Seq.map (fun m -> m.Groups.[\"honor\"].Value.Trim().Replace(\",\",\"\"))\n\n\nlet GetHonor username = \/\/ Happy coding!\n  let url = \"https:\/\/www.codewars.com\/users\/\" + username\n  let google = fetchUrl myCallback url\n  let filter = getHonor google |> Seq.head |> int\n  filter","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86416,"user_id":null,"body":"open System\nopen System.Net\nopen System.Text.RegularExpressions\n\nlet TakeUntil predicate input = \n    let rec loop acc list = \n            match list with \n            | head :: tail when predicate head ->  acc \n            | head :: tail -> loop (acc @ [head]) tail \n            | [] -> input\n    loop [] input\n\n\nlet matches input = \n    let data = \n        Regex.Matches(input, \"(Honor:(.*)<+)\")\n        |> Seq.cast<Match> \n        |> Seq.groupBy(fun m -> m.Value)\n        |> Seq.map (fun (value, groups) -> value) \n        |> Seq.toList\n    Regex.Replace(data.[0].Trim().Substring(10), \",\", \"\")\n    \n\n\nlet GetHonor username = \n    use wc = new WebClient()\n    let data = \n        [|\"https:\/\/www.codewars.com\/users\/\" + username|]\n        |> Array.choose (fun url -> try wc.DownloadString(url) |> Some with _ -> None) \n    let download = matches data.[0]\n    (\"\" , download.ToCharArray() |> Array.toList |> TakeUntil (fun c -> \"0123456789\".Contains(c.ToString()) <> true) ) |> String.Join |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86417,"user_id":null,"body":"open System\nopen System.Net\nopen System.Text.RegularExpressions\n\nlet TakeUntil predicate input = \n    let rec loop acc list = \n            match list with \n            | head :: tail when predicate head ->  acc \n            | head :: tail -> loop (acc @ [head]) tail \n            | [] -> input\n    loop [] input\n\n\nlet matches input = \n    let data = \n        Regex.Matches(input, \"(Honor:(.*)<+)\")\n        |> Seq.cast<Match> \n        |> Seq.groupBy(fun m -> m.Value)\n        |> Seq.map (fun (value, groups) -> value) \n        |> Seq.toList\n    let (string:string) = data.[0]\n    let str = string.Trim().Substring(10)\n    let s = Regex.Replace(str, \",\", \"\")\n    s\n    \n\n\nlet GetHonor username = \n    use wc = new WebClient()\n    let data = \n        [|\"https:\/\/www.codewars.com\/users\/\" + username|]\n        |> Array.choose (fun url -> try wc.DownloadString(url) |> Some with _ -> None) \n    let (str:string) = data.[0]\n    let download = \n        matches str\n    let string = \n        download.ToCharArray() |> Array.toList |> TakeUntil (fun c -> \"0123456789\".Contains(c.ToString()) <> true) \n    (\"\" , string) |> String.Join |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58ce8725c835848ad6000007":[{"id":86418,"user_id":527,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n  w0 * (100 - p0) \/ (100 - p1)","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86419,"user_id":null,"body":"let potatoes p0 w0 p1 = w0 * (100 - p0) \/ (100 - p1)\n","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86420,"user_id":492,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n    (int)((double)w0 * (100.0 - (double)p0) \/ (100.0 - (double)p1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86421,"user_id":492,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n    (int)((double)w0 * (100.0 - (double)p0) \/ (100.0 - (double)p1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86422,"user_id":null,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n    float (100 - p0) \/ 100. * float w0 \/ (100. - float p1) * 100. |> int\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86423,"user_id":null,"body":"open System\nlet potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n      let helperFunc (per0 : decimal) (weight0: decimal) (per1: decimal) : decimal =\n        let solidPer = (decimal 100.0)-per0\n        let solidWeight = (solidPer\/(decimal 100.0)) * weight0\n        let res = solidWeight \/ ( (decimal 1.0) - (per1 \/ (decimal 100.0)))\n        res\n      (int) (Math.Truncate (helperFunc ((decimal) p0) ((decimal) w0) ((decimal) p1)))    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86424,"user_id":null,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n    let x = System.Math.Floor((( float w0) * (100.0 - (float p0))) \/ (100.0 - (float p1)))\n    int x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86425,"user_id":null,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int = int(w0*(100-p0)\/(100-p1))\n    \/\/ your code\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86426,"user_id":null,"body":"\n\nlet potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n    let water100 = p0 * w0\n    let dry100 = w0 * 100 - water100\n    dry100 \/ (100 - p1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86427,"user_id":null,"body":"let potatoes (p0 : int) (w0 : int) (p1 : int) : int =\n    \n    let dryMatterWeight = w0 * (100 - p0)\n\n    dryMatterWeight \/ (100 - p1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58e0cb3634a3027180000040":[{"id":86428,"user_id":null,"body":"let sortByValueAndIndex(array : int[]) : int[] =\n  array \n  |> Array.indexed \n  |> Array.sortBy ( fun (id, v) -> (id + 1) * v) \n  |> Array.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86429,"user_id":null,"body":"let sortByValueAndIndex =\n  let mult i n = n, (i + 1) * n\n  Array.mapi mult >> Array.sortBy snd >> Array.map fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86430,"user_id":null,"body":"let sortByValueAndIndex(array : int[]) : int[] =\n  array\n  |> Array.mapi( fun i x -> (x,(i+1)*x))\n  |> Array.sortBy snd\n  |> Array.map fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86431,"user_id":null,"body":"let sortByValueAndIndex =\n  Array.mapi(fun i x -> (i+1, x))\n  >> Array.sortBy(fun (i, x) -> i*x)\n  >> Array.map(fun (i, x) -> x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86432,"user_id":1402,"body":"let sortByValueAndIndex(array : int[]) : int[] = \n   array \n   |> Array.mapi (fun i x -> (x, x * (i + 1)) )\n   |> Array.sortBy (fun x -> snd x)\n   |> Array.map (fun x -> fst x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86433,"user_id":null,"body":"let sortByValueAndIndex(array : int[]) : int[] =\n    array\n    |> Array.indexed\n    |> Array.sortBy (fun (i, value) -> (i + 1) * value)\n    |> Array.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86434,"user_id":null,"body":"let sortByValueAndIndex(array : int[]) : int[] =\n  array\n  |> Array.mapi (fun i s -> (i + 1) * s, s)\n  |> Array.sortBy fst\n  |> Array.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86435,"user_id":null,"body":"let sortByValueAndIndex(array : int[]) : int[] =\n  array |> Array.indexed |> \n  Array.sortBy (fun x -> (fst x + 1) * (snd x)) |>\n  Array.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86436,"user_id":null,"body":"let sortByValueAndIndex =\n    Array.indexed >>\n    Array.sortBy (fun (i,v) -> (i+1)*v) >>\n    Array.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86437,"user_id":null,"body":"let sortByValueAndIndex =\n    Array.mapi (fun i x -> ((i+1)*x,x))\n    >> Array.sortBy fst\n    >> Array.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"58e0f0bf92d04ccf0a000010":[{"id":86438,"user_id":53,"body":"let lostSheep (a:int array) (b:int array) (t:int) : int =\n  t - (a |> Seq.sum) - (b |> Seq.sum)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86439,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n    totalSheep - (Array.sum fridaysCount) - (Array.sum saturdaysCount)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86440,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n    [fridaysCount;saturdaysCount]\n    |> Array.concat\n    |> Array.sum\n    |> (-) totalSheep","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86441,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n  let fri = Array.sum fridaysCount\n  let sat = Array.sum saturdaysCount\n  \n  totalSheep - (fri + sat)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86442,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n  let sumFriday = fridaysCount |> Array.sum\n  let sumSaturday = saturdaysCount |> Array.sum\n  totalSheep - (sumFriday + sumSaturday)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86443,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n    (fridaysCount, saturdaysCount)\n    ||> Array.append\n    |> Array.sum\n    |> (-) totalSheep","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86444,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n    totalSheep - (Seq.sum fridaysCount + Seq.sum saturdaysCount)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86445,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =   \n    totalSheep - ((Array.append (Array.append fridaysCount saturdaysCount) [|0|]) |> Array.reduce (+))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86446,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n  Array.append fridaysCount saturdaysCount\n  |> Array.fold (+) 0\n  |> (-) totalSheep ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86447,"user_id":null,"body":"let lostSheep (fridaysCount:int array) (saturdaysCount:int array) (totalSheep:int) : int =\n  [| fridaysCount ; saturdaysCount |]\n  |> Array.concat\n  |> Array.sum\n  |> (-) totalSheep","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"591eab1d192fe0435e000014":[{"id":86448,"user_id":null,"body":"type Direction =\n    | Left of int\n    | Down of int\n    | Right of int\n\nlet solve (carpark: int list list) : string list =\n    let start =\n        carpark\n        |> List.skipWhile (fun l -> l |> List.exists ((=) 2) |> not)\n\n\n    let rec escape (floor: int list) (nexts: int list list) path (currentPosition: int) =\n        let stair = floor |> List.tryFindIndex (fun f -> f = 1)\n\n        match stair with\n        | None ->\n            Right((floor |> List.length) - currentPosition - 1)\n            :: path\n        | Some (stairPos) ->\n            if stairPos < currentPosition then\n                escape\n                    (nexts |> List.head)\n                    (nexts |> List.tail)\n                    (Down(1)\n                     :: Left(currentPosition - stairPos) :: path)\n                    stairPos\n            elif stairPos > currentPosition then\n                escape\n                    (nexts |> List.head)\n                    (nexts |> List.tail)\n                    (Down(1)\n                     :: Right(stairPos - currentPosition) :: path)\n                    stairPos\n            else\n                match path with\n                | [] -> escape (nexts |> List.head) (nexts |> List.tail) ([ Down(1) ]) stairPos\n                | d :: ds ->\n                    match d with\n                    | Left (_)\n                    | Right (_) -> escape (nexts |> List.head) (nexts |> List.tail) (Down(1) :: d :: ds) stairPos\n                    | Down (x) -> escape (nexts |> List.head) (nexts |> List.tail) (Down(x + 1) :: ds) stairPos\n\n\n\n\n\n    let currentFloor = (start |> List.head)\n\n    escape currentFloor (start |> List.tail) [] (currentFloor |> List.findIndex (fun p -> p = 2))\n    |> List.choose (fun d ->\n        match d with\n        | Left (0)\n        | Right (0)\n        | Down (0) -> None\n        | Left (x) -> Some(sprintf \"L%d\" x)\n        | Right (x) -> Some(sprintf \"R%d\" x)\n        | Down (x) -> Some(sprintf \"D%d\" x))\n    |> List.rev","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86449,"user_id":null,"body":"let solve (carpark: int list list) : string list =\n    let parkArray = carpark |> Array.ofList\n    \n    let findStairCase (ind: int) =\n      (parkArray.[ind]) |> List.tryFindIndex (fun x -> x = 1)\n      \n    let getStartLevel () =\n      parkArray |> Array.findIndex (fun x -> x |> List.exists (fun y -> y = 2))\n      \n    let getWay (currPos: int) (endPos: int) =\n      if (endPos < currPos) then\n        let way = (sprintf \"L%d\" (currPos - endPos))\n        way\n      else \n        let way = (sprintf \"R%d\" (endPos - currPos))\n        way\n    \n    let rec findExit (ind: int) (currPos: int) (count: int) = \n      let getStaircasePos = (findStairCase ind)\n      let getLevelFinder (currPos: int) (endPos: int) (count: int) =\n        if (currPos = endPos && count > 0) then\n          let way = (sprintf \"D%d\" count)\n          [way]\n        else if (currPos = endPos && count = 0) then\n          []\n        else if (currPos <> endPos && count > 0) then\n          let way = (sprintf \"D%d\" count)\n          let path = (getWay currPos endPos)\n          [way; path]\n        else\n          let path = (getWay currPos endPos)\n          [path]\n      \n      match getStaircasePos with\n      | Some x when x = currPos  -> (findExit (ind + 1) x (count + 1))\n      | Some x                   -> (getLevelFinder currPos x count) @ (findExit (ind + 1) x 1)\n      | None                     -> (getLevelFinder currPos ((List.length parkArray.[ind]) - 1) count)\n      \n    let startLevelInd = getStartLevel ()\n    let startPos = parkArray.[startLevelInd] |> List.findIndex (fun x -> x = 2)\n    (findExit startLevelInd startPos 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86450,"user_id":null,"body":"let solve (carpark: int list list) : string list =\n\n    let rec MoveToStair (moves:string list) iFloor position =\n        if iFloor = carpark.Length-1 then\n            let nMoves= carpark.[iFloor].Length-1 - position\n            (if nMoves > 0 then sprintf \"R%d\" nMoves::moves else moves) |> List.rev\n        else\n            let stairsPosition = carpark.[iFloor] |> List.findIndex (fun elem -> elem = 1)\n            let nMovesToStairs = stairsPosition - position\n            MoveDown ((if nMovesToStairs > 0 then sprintf \"R%d\" nMovesToStairs else sprintf \"L%d\" -nMovesToStairs) :: moves) iFloor stairsPosition\n\n    and MoveDown (moves:string list) iFloor position =\n        let rec Loop newFloor =\n            if carpark.[newFloor].[position] <> 1 then \n                MoveToStair (sprintf \"D%d\" (newFloor - iFloor)::moves) newFloor position\n            else\n                Loop (newFloor+1)\n        Loop (iFloor+1)\n\n    let startFloor = carpark |> List.findIndex (fun floor -> floor |> List.exists (fun space -> space = 2))\n    let startPosition = carpark.[startFloor] |> List.findIndex(fun space -> space = 2)\n    MoveToStair [] startFloor startPosition\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86451,"user_id":null,"body":"let solve (carpark: int list list): string list =\n    let find i = (=) i\n    let findStairs = find 1\n\n    let start = carpark.[0] |> List.findIndex (find 2)\n\n    let (_, dirs) =\n        carpark\n        |> Seq.fold (fun (pos, dirs) c ->\n            let maybeStaircase = c |> List.tryFindIndex findStairs\n\n            match maybeStaircase with\n            | None ->\n                match pos = c.Length - 1 with\n                | true -> (pos, dirs)\n                | false -> (0, (\"R\", c.Length - pos - 1) :: dirs)\n            | Some staircase ->\n                match (pos, staircase) with\n                | pos, staircase when pos = staircase ->\n                    let (d, s) = dirs |> List.head\n                    (pos, (d, s + 1) :: (dirs.Tail))\n                | pos, staircase when pos > staircase ->\n                    (staircase,\n                     [ (\"D\", 1)\n                       (\"L\", pos - staircase) ]\n                     @ dirs)\n                | pos, staircase when pos < staircase ->\n                    (staircase,\n                     [ (\"D\", 1)\n                       (\"R\", staircase - pos) ]\n                     @ dirs)) (start, [])\n    dirs\n    |> Seq.rev\n    |> Seq.map (fun (d, s) -> sprintf \"%s%i\" d s)\n    |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86452,"user_id":null,"body":"let solve (carpark: int list list) : string list =\n    let rec loop\n            (moves: string list)\n            (levels: int list list)\n            (currentIndex: int)\n            (downCount: int) =\n        let currentLevel, remainingLevels = (List.head levels), (List.tail levels)\n        let isLowestLevel = List.isEmpty remainingLevels\n        let exitIndex =\n            if isLowestLevel then (List.length currentLevel) - 1\n            else List.findIndex ((=) 1) currentLevel\n        let alreadyAtStairs = currentIndex = exitIndex\n        if alreadyAtStairs && not isLowestLevel then\n            \/\/ Increase downCount\n            loop moves remainingLevels exitIndex (downCount + 1)\n        else if downCount > 0 then\n            \/\/ Add a down move\n            let move = sprintf \"D%i\" downCount\n            loop (move::moves) levels currentIndex 0\n        else if not alreadyAtStairs then\n            \/\/ Add left or right move\n            let leftOrRight = if exitIndex > currentIndex then \"R\" else \"L\"\n            let move = sprintf \"%s%i\" leftOrRight (abs (currentIndex - exitIndex))\n            loop (move::moves) levels exitIndex 0\n        else\n            moves\n    let startIndex = List.findIndex ((=) 2) (List.head carpark)\n    loop [] carpark startIndex 0 |> List.rev\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86453,"user_id":null,"body":"type Instruction(direction: string, distance: int) =\n    member this.Direction = direction\n    member this.Distance = distance\n\n\nlet valueIsStairs = (=) 1\nlet tryFindStairsLoc = List.tryFindIndex valueIsStairs\nlet valueIsPerson = (=) 2\nlet tryFindPersonLoc = List.tryFindIndex valueIsPerson\n\n\nlet getOffLevelInstructions (carparkLevel: int list) (personLocationInLevel: int option) : Instruction list =\n    let takeStairs stairsLoc personLoc =\n        let distToStairs = personLoc - stairsLoc\n        match sign distToStairs with\n        | -1 -> [ Instruction(\"R\", abs distToStairs); Instruction(\"D\", 1) ]\n        | +1 -> [ Instruction(\"L\", abs distToStairs); Instruction(\"D\", 1) ]\n        | _ -> [ Instruction(\"D\", 1) ]\n\n    let goToExit personLoc =\n        let distToExit = (List.length carparkLevel) - personLoc - 1\n        match distToExit with\n        | 0 -> []\n        | _ -> [ Instruction(\"R\", distToExit) ]\n\n    match personLocationInLevel with\n    | None -> []\n    | Some personLoc ->\n        match tryFindStairsLoc carparkLevel with\n        | Some stairsLoc -> takeStairs stairsLoc personLoc\n        | None -> goToExit personLoc\n\n\ntype CondenseInstructionsState(insts: Instruction list, consecutiveDowns: int) =\n    member this.Instructions = insts\n    member this.ConsecutiveDowns = consecutiveDowns\n\n\nlet condenseDownInstructions instructions =\n    let initialState = CondenseInstructionsState([], 0)\n\n    let manageState (state: CondenseInstructionsState) (instruction: Instruction) =\n        let cdowns = state.ConsecutiveDowns\n        let isDown = instruction.Direction = \"D\"\n\n        if isDown then\n            CondenseInstructionsState(state.Instructions, cdowns+1)\n        else if cdowns = 0 then\n            CondenseInstructionsState(List.append state.Instructions [instruction], 0)\n        else\n            CondenseInstructionsState(List.append state.Instructions [Instruction(\"D\", cdowns); instruction], 0)\n\n    let result = (List.fold manageState initialState instructions)\n\n    if result.ConsecutiveDowns = 0 then\n        result.Instructions\n    else\n        List.append result.Instructions [Instruction(\"D\", result.ConsecutiveDowns)]\n\n\nlet formatInstruction (instruction: Instruction) = \n    sprintf \"%s%i\" instruction.Direction instruction.Distance\n\n\nlet solve (carpark: int list list) : string list =\n    let initialState = (None, [])\n    let manageState (state: int option * Instruction list) (carParkLevel: int list) =\n        let prevInstructions = snd state\n        let personOnLevel = tryFindPersonLoc carParkLevel\n\n        let currentPersonLocation = \n            match personOnLevel with\n            | Some personLoc -> Some personLoc\n            | None -> fst state\n        \n        let nextPersonLocation =\n            match fst state, personOnLevel with\n            | None, None -> None\n            | _, _ -> tryFindStairsLoc carParkLevel\n\n        (\n            nextPersonLocation, \n            List.append prevInstructions (getOffLevelInstructions carParkLevel currentPersonLocation)\n        )\n \n    (List.fold manageState initialState carpark) \n    |> snd\n    |> condenseDownInstructions\n    |> List.map formatInstruction\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86454,"user_id":null,"body":"type Command = Left of int | Right of int | Down of int\n\nlet cmdToString = function\n    | Left x  -> \"L\" + string x\n    | Right x -> \"R\" + string x\n    | Down x  -> \"D\" + string x\n\n\/\/ combineDoubles [Down 1; Down 1] = [Down 2]\nlet rec combineDoubles = function\n    | [] -> []\n    | Left x :: Left y :: xs -> combineDoubles (Left (x + y) :: xs)\n    | Right x :: Right y :: xs -> combineDoubles (Right (x + y) :: xs)\n    | Down x :: Down y :: xs -> combineDoubles (Down (x + y) :: xs)\n    | x :: xs -> x :: combineDoubles xs\n\nlet solve (carpark: int list list) : string list =\n    let removedEmptyTopFloors = List.skipWhile (not << List.contains 2) carpark\n    let solver currentPosition (floor : int list) : (Command list * int) =\n        let movementToCommand : int -> Command list = function\n            | move when move > 0 -> [Right move]\n            | move when move < 0 -> [Left (abs move)]\n            | _                  -> []\n        let onLastFloor = not <| List.contains 1 floor\n        let (goDown, stairPosition) = if onLastFloor\n                                          then ([], List.length floor - 1)\n                                          else ([Down 1], List.findIndex ((=) 1) floor)\n        let movement = stairPosition - currentPosition\n        (movementToCommand movement @ goDown, stairPosition)\n    let startPosition = List.findIndex ((=) 2) removedEmptyTopFloors.Head\n    List.mapFold solver startPosition removedEmptyTopFloors\n    |> fst\n    |> List.concat\n    |> combineDoubles\n    |> List.map cmdToString","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86455,"user_id":null,"body":"type num = int\nlet solve (carpark: int list list): string list =\n    let solveLevel (lastMove, entry) (level: int list) = \n        let inCol = if entry = num.MinValue then List.findIndex (fun i -> i=2) level else abs(entry)\n        let outCol = \n            if (level |> List.contains 1) then List.findIndex (fun i -> i=1) level\n            else level.Length - 1\n        (outCol - inCol, outCol)\n\n    let leftRightString move = \n        if move < 0 then sprintf \"L%d\" <| abs(move)\n        else if move = 0 then \"0\"  \/\/ Just continue down the staircase, will be removed later\n        else sprintf \"R%d\" move\n\n    let rec coalesceDs acc (list: string list) =\n        match list with \n        | h1::h2::t when h1.[0] = 'D' && h2.[0] = 'D' ->\n            let n = h1.[1..] |> int |> (+) 1 |> sprintf \"D%d\"\n            coalesceDs acc (n :: t)\n        | h1 :: t -> coalesceDs (h1::acc) t\n        | _ -> acc |> List.rev\n\n    carpark \n            |> Seq.scan solveLevel (0, num.MinValue)\n            |> Seq.skip 1   \/\/ Ignore the 'initial' state from the scan\n            |> Seq.map fst  \/\/ Extract the distance moved, ignore the entry column\n            |> Seq.map leftRightString\n            |> Seq.collect (fun s -> [s; \"D1\"]) \/\/ Adds an extra \"D1\" to the end, so...\n            |> Seq.rev |> Seq.skip 1 |> Seq.rev \/\/ Remove the last D1\n            |> Seq.filter(fun s -> s <> \"0\")    \/\/ Remove the \"continue down\" entries\n            |> Seq.toList\n            |> coalesceDs List.empty<string>","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86456,"user_id":null,"body":"type Move = \n    | R of int\n    | D of int\n    | L of int\n    | Skip\n    | Finish\n\nlet rec groupDownMoves (current : Move option) (moves : Move list) =\n    match moves with \n    | [] -> match current with \n            | Some m -> [m]\n            | None -> []\n    | head :: tail -> \n        match current with \n        | Some m -> \n            match m with \n            | D currentIndex -> match head with \n                                 | D headIndex -> groupDownMoves (Some (D (headIndex + currentIndex))) tail\n                                 | _ -> m::groupDownMoves (Some head) tail\n            | _ -> m::groupDownMoves (Some head) tail\n        | None -> groupDownMoves (Some head) tail\n\nlet movesToString (moves : Move list) = \n    \n    moves\n    |> groupDownMoves None\n    |> List.filter (fun m -> m <> Skip && m <> Finish)\n    |> List.map \n        (fun m -> \n            match m with \n            | R i -> \"R\" + string (abs i)\n            | D i -> \"D\" + string (i)\n            | L i -> \"L\" + string (i)\n            | Finish -> \"\"\n            | Skip -> \"\")\n\nlet isStartingPoint i = i = 2\nlet isStaircase i = i = 1\n\nlet calculateMove playerIndex stairsIndex floorLength= \n    match playerIndex with \n    | Some player -> \n        match stairsIndex with \n        | Some stairs -> \n            if (player = stairs) then D (1)\n            else if (player > stairs) then L (player - stairs)\n            else R (player - stairs)\n        | None -> if (floorLength - player > 0) then R (floorLength - player) else Finish\n    | None -> Skip\n\nlet rec solve' (index: int option) (carpark: int list list) : Move list = \n    match carpark with \n    | current::remaining -> \n        let position = match index with \n                        | Some i -> Some(i)\n                        | None -> List.tryFindIndex isStartingPoint current\n        \n        let stairsIndex = List.tryFindIndex isStaircase current\n\n        let move = (calculateMove position stairsIndex (current.Length - 1))\n        \n        if remaining.Length = 0 then\n            move ::(solve' stairsIndex remaining)\n        else\n            match move with \n            | D i -> move ::(solve' stairsIndex remaining)\n            | Skip | Finish -> move ::(solve' stairsIndex remaining)\n            | _ -> move ::D(1)::(solve' stairsIndex remaining)\n    | [] -> []\n\nlet solve (carpark: int list list) : string list =\n  \n    carpark\n    |> solve' None\n    |> movesToString","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86457,"user_id":null,"body":"type Move =\n  | L of int\n  | R of int\n  | D of int\n\ntype Moves =\n  | Bottom\n  | Stack of Move * Moves\n\nlet findPosition (f: 'T -> bool) (l: 'T list) =\n  List.mapi (fun i x -> (i, f x)) l |> List.filter (fun y -> snd y) |> List.map fst\n \nlet findExit (lst: int list) : int =\n  let staircasePosition = findPosition ((=) 1) lst\n  match staircasePosition with\n    | [] -> ((List.length lst) - 1)\n    | x::xs -> x:int\n\nlet addToTrip (accum: Moves) (newMove: Move) =\n  match newMove with\n    | L x | R x -> Stack (newMove, accum)\n    | D z ->\n      match accum with\n        | Stack (D w, s) -> Stack (D (w + z), s)\n        | _ -> Stack (newMove, accum)\n   \nlet rec moveToExit (accum: Moves) (parking: int list list) (currentPos: int)=\n  match parking with\n    | [] -> accum\n    | [l] ->\n      let r = List.length l - 1 - currentPos\n      match r with\n        | 0 -> accum\n        | _ -> Stack (R r, accum)\n    | x::xs ->\n      let mv = findExit x - currentPos\n      let trip =\n        match compare mv 0 with\n          | 0 ->\n            let newAccum = addToTrip accum (D 1)\n            moveToExit newAccum (List.tail parking) currentPos\n          | -1 ->\n            let newAccum' = addToTrip accum (L (-mv))\n            let newAccum = addToTrip newAccum' (D 1)\n            let newPos = currentPos + mv\n            moveToExit newAccum (List.tail parking) newPos\n          | 1 ->\n            let newAccum' = addToTrip accum (R mv)\n            let newAccum = addToTrip newAccum' (D 1)\n            let newPos = currentPos + mv\n            moveToExit newAccum (List.tail parking) newPos\n          | _ -> failwith \"comparison fell outside of {-1, 0, 1}\"\n      trip\n\nlet rec findPath (parking: int list list) =\n  let currentPos = findPosition ((=) 2) (List.head parking)\n  match currentPos with\n    | [] -> findPath (List.tail parking)\n    | x :: xs -> moveToExit Bottom parking x\n\nlet rec unrollMovesString (moves: Moves) (res: string list)=\n  match moves with\n    | Bottom -> res\n    | Stack (mv, s) ->\n      let addition =\n        match mv with\n          | L x -> (\"L\" + string x)\n          | R x -> (\"R\" + string x)\n          | D x -> (\"D\" + string x)\n      unrollMovesString s (addition::res)\n \nlet solve (carpark: int list list) : string list =\n    let exit = findPath carpark\n    unrollMovesString exit []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5921c0bc6b8f072e840000c0":[{"id":86458,"user_id":null,"body":"let sequenceClassifier xs =\n    xs\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> 1 <<< (1 + compare x y))\n    |> Seq.fold (|||) 0\n    |> function\n    | 0b001 -> 1 \/\/ strictly increasing\n    | 0b010 -> 5 \/\/ constant\n    | 0b011 -> 2 \/\/ not decreasing\n    | 0b100 -> 3 \/\/ strictly decreasing\n    | 0b101 -> 0 \/\/ unordered\n    | 0b110 -> 4 \/\/ not increasing\n    | 0b111 -> 0 \/\/ unordered\n    | _ -> -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86459,"user_id":null,"body":"let sequenceClassifier (arr : int []) =\n     let compareTwo l r =\n         if l < r then 1\n         else if l = r then 2\n         else 4\n\n     let sequenceTypes = [| 0; 1; 5; 2; 3; 0; 4; 0 |]\n     let flags = \n        arr \n        |> Seq.pairwise \n        |> Seq.map (fun (x, y) -> compareTwo x y)\n        |> Seq.fold (|||) 0\n\n     sequenceTypes.[flags]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86460,"user_id":null,"body":"let sequenceClassifier (arr : int []) =\n    let a = \n      arr \n      |> Array.pairwise\n      |> Array.map (fun x -> snd x - fst x)\n    match a with\n      | _ when (Array.forall (fun x -> x = 0) a) -> 5\n      | _ when (Array.forall (fun x -> x > 0) a) -> 1\n      | _ when (Array.forall (fun x -> x >= 0) a) -> 2\n      | _ when (Array.forall (fun x -> x < 0) a) -> 3\n      | _ when (Array.forall (fun x -> x <= 0) a) -> 4\n      | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86461,"user_id":294,"body":"let sequenceClassifier (arr : int[]) =\n    let diffs = [| for i in 1 .. (Array.length arr - 1) -> arr.[i] - arr.[i - 1] |]\n    \n    let is_eq = Array.forall (fun d -> d = 0) diffs\n    let is_strictly_inc = Array.forall (fun d -> d > 0) diffs\n    let is_inc = Array.forall (fun d -> d >= 0) diffs\n    let is_strictly_dec = Array.forall (fun d -> d < 0) diffs\n    let is_dec = Array.forall (fun d -> d <= 0) diffs\n    \n    if is_eq then 5\n    else if is_strictly_inc then 1\n    else if is_inc then 2\n    else if is_strictly_dec then 3\n    else if is_dec then 4\n    else 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86462,"user_id":null,"body":"let sequenceClassifier (arr : int[]) =\n    let map =\n        [[-1]; [-1; 0]; [1]; [0; 1]; [0]]\n        |> List.mapi (fun idx s -> Set.ofList s, idx + 1)\n        |> Map.ofList\n    let key = Array.pairwise arr\n              |> Array.map (fun (a, b) -> compare a b)\n              |> Set.ofArray\n    match Map.containsKey key map with\n    | true -> map.[key]\n    | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86463,"user_id":null,"body":"let sequenceClassifier (arr : int []) =\n    let (status: int, _) = \n        arr \n        |> Array.fold (\n            fun (currentStatus, maybePreviousValue) currentValue ->\n                match maybePreviousValue with\n                | Some previousValue ->\n                    match compare currentValue previousValue with\n                    | 1 ->\n                        (currentStatus ||| (1 <<< 2), Some currentValue)\n                    | 0 ->\n                        (currentStatus ||| (1 <<< 1), Some currentValue)\n                    | _ ->\n                        (currentStatus ||| (1 <<< 0), Some currentValue)\n                | None ->\n                    (currentStatus, Some currentValue)\n        ) (0, None)\n\n    match status with\n    | 4 -> \n        1\n    | 6 -> \n        2\n    | 3 -> \n        4\n    | 1 -> \n        3\n    | 2 -> \n        5\n    | _ -> \n        0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86464,"user_id":53,"body":"let sequenceClassifier (arr : int []) =\n    let mutable i = false\n    let mutable d = false\n    let mutable q = false\n    let mutable j = 1\n    while j < arr.Length do\n      i <- i || arr.[j] > arr.[j-1]\n      d <- d || arr.[j] < arr.[j-1]\n      q <- q || arr.[j] = arr.[j-1]\n      j <- j + 1\n    if i && d then 0\n    elif i && (not q) then 1\n    elif i then 2\n    elif d && (not q) then 3\n    elif d then 4\n    else 5","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86465,"user_id":null,"body":"type Order =\n  | Unordered = 0\n  | StrictlyIncreasing = 1\n  | NotDecreasing = 2\n  | StrictlyDecreasing = 3\n  | NotIncreasing = 4\n  | Constant = 5\n\nlet compare (a, b) =\n  if a = b then Order.Constant\n  elif a < b then Order.StrictlyIncreasing\n  else Order.StrictlyDecreasing\n\nlet sequenceClassifier (arr : int []) =\n    arr\n    |> Seq.pairwise\n    |> Seq.map compare\n    |> Seq.distinct\n    |> Seq.truncate 3\n    |> Seq.sort\n    |> Seq.toList\n    |> function\n      | [ order ] -> order\n      | [ Order.StrictlyDecreasing ; Order.Constant ] -> Order.NotIncreasing\n      | [ Order.StrictlyIncreasing ; Order.Constant ] -> Order.NotDecreasing\n      | _ -> Order.Unordered\n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86466,"user_id":null,"body":"let sequenceClassifier (arr : int []) =\n  let diff = arr |> Array.pairwise |> Array.map (fun (a, b) -> b - a)\n  [ ((<)  0)        , 1;\n    ((>)  0)        , 3;\n    ((=)  0)        , 5;\n    ((<=) 0)        , 2;\n    ((>=) 0)        , 4;\n    (fun _ -> true) , 0\n  ] |> List.find (fun (f, code) -> Array.forall f diff) |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86467,"user_id":null,"body":"let sequenceClassifier (arr : int []) =\n    match (arr |> Array.indexed) with\n    | narr when not (Array.exists (fun x -> (fst x) <> 0 && arr.[(fst x) - 1] <> (snd x)) narr) -> 5\n    | narr when not (Array.exists (fun x -> (fst x) <> 0 && arr.[(fst x) - 1] >= (snd x)) narr) -> 1\n    | narr when not (Array.exists (fun x -> (fst x) <> 0 && arr.[(fst x) - 1] > (snd x)) narr) -> 2\n    | narr when not (Array.exists (fun x -> (fst x) <> 0 && arr.[(fst x) - 1] <= (snd x)) narr) -> 3\n    | narr when not (Array.exists (fun x -> (fst x) <> 0 && arr.[(fst x) - 1] < (snd x)) narr) -> 4\n    | _  -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"592e830e043b99888600002d":[{"id":86468,"user_id":null,"body":"let encode (str:string) (n:int) =\n    let d = n.ToString().ToCharArray() |> Array.map (System.Char.GetNumericValue >> int)\n    str.ToCharArray() \n        |> Array.map (fun c -> (int c) - (int 'a') + 1)\n        |> Array.mapi (fun i c -> c + d.[i % d.Length])\n        |> Array.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86469,"user_id":null,"body":"let encode (str: string) (n: int) =\n  let key = string(n)\n  let l = key.Length\n  str\n  |> Seq.toList\n  |> List.mapi (fun i c -> (int(c) - 96) + int(string(key.[i % l])))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86470,"user_id":null,"body":"let genDigit = function\n    | 0 -> None\n    | n -> Some (n % 10, n \/ 10)\n    \nlet toDigits = Seq.unfold genDigit >> Seq.rev\n\nlet cycle s = seq { while true do yield! s }\n\nlet charToNumber (char: char) = int char - 96\n\nlet encode (str: string) (n: int) =\n    let keySequence = n |> toDigits |> cycle\n    str\n    |> Seq.map2 (fun key n -> key + charToNumber n) keySequence\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86471,"user_id":null,"body":"let encode (str: string) (n: int) =\n  let nstring = sprintf \"%i\" n\n  let keySeq = Seq.init str.Length (fun i -> nstring.[i % nstring.Length]) |> Seq.map (fun c -> (int c) - (int '0'))\n  Seq.map2 (fun x y -> (int x) - (int 'a') + 1 + y) str keySeq |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86472,"user_id":null,"body":"let encode (str: string) (n: int) =\n    let chars = ['a'..'z']\n    let charCode c = (List.findIndex ((=) c) chars) + 1\n\n    let nstr = sprintf \"%d\" n    \n    let addNum i = \n        let digit = nstr.[(i % (String.length nstr))]\n        int (digit.ToString())\n\n    str\n    |> Seq.mapi (fun i c -> addNum i + charCode c)\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86473,"user_id":null,"body":"open System\n\nlet toDigits (n: int) : List<int> =\n    let mutable digits : List<int> = []\n    for digit in n.ToString() do\n        digits <- digits @ [int (Char.GetNumericValue(digit))]\n    digits\n\nlet encode (str: string) (n: int) : List<int> =\n    let mutable result : List<int> = []\n\n    let keyDigits = toDigits n\n    let mutable keyI = 0\n    for ch in str do\n        if keyI >= keyDigits.Length then\n            keyI <- 0\n        result <- result @ [int (ch) - 96 + keyDigits.[keyI]]\n        keyI <- keyI + 1\n\n    result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86474,"user_id":null,"body":"let encode (str: string) (n: int) =\n  let number = n.ToString().ToCharArray() |> Array.map (fun x -> (int)x - (int)'0')\n  str |> Seq.toList |>\n  List.mapi (fun i x -> (int) x - (int) 'a' + 1 + number.[i % number.Length])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86475,"user_id":null,"body":"open System\n\nlet StringToIntArray (str:string) = \n    str.ToLower().ToCharArray() \n    |> Seq.map (int >> (fun x-> x - (int 'a')+1)) \n    \n\nlet IntToDigitArray (number: int) =\n    let splitString (str:string) =\n         str.ToCharArray() \n    number\n    |> string\n    |> splitString\n    |> Seq.map (string >> Int32.Parse)\n\nlet rec Repeat items = \n  seq { yield! items  \n        yield! Repeat items }  \n        \nlet encode (str: string) (n: int) =\n  let a = str |> StringToIntArray \n  let b = n |> IntToDigitArray |> Repeat\n  Seq.map2 (+) a b\n    |> Seq.take str.Length\n    |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86476,"user_id":null,"body":"open System\n\nlet digits n =\n    n.ToString().ToCharArray()\n    |> Array.map (System.Char.GetNumericValue >> System.Convert.ToInt32)\n\nlet encode (str: string) (n: int) =\n  let dig_n = digits n\n  \n  str \n  |> Seq.map (fun x -> int(x) - 96)\n  |> Seq.mapi (fun i x -> x + dig_n.[i % (dig_n.Length)])\n  |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86477,"user_id":null,"body":"let encode (str: string) (n: int) =\n    let rec cycle xs = seq { yield! xs; yield! cycle xs }\n\n    let digits = n.ToString() \n                    |> Seq.map (fun c -> 1 + int c - int '0')\n                    |> cycle\n\n    str \n        |> Seq.map (fun c -> int c - int 'a')\n        |> Seq.zip digits\n        |> Seq.map (fun (a, b) -> a + b)\n        |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"597ef546ee48603f7a000057":[{"id":86478,"user_id":527,"body":"let getMostProfitFromStockQuotes (quotes : int list) : int =\n  let revQuotes = Seq.rev quotes\n  Seq.map2 (-) (Seq.scan max 0 revQuotes) revQuotes |> Seq.sumBy (max 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86479,"user_id":491,"body":"let getMostProfitFromStockQuotes (quotes : int list) : int =\n    List.foldBack (fun c (t, m) -> (t + max (m - c) 0, max m c)) quotes (0, 0) |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86480,"user_id":null,"body":"let rec getMostProfitFromStockQuotes (quotes : int list) : int =\n    let max = quotes |> List.max\n    let quotesRev = quotes |> List.rev\n    let maxIndex = quotesRev |> List.findIndex  (fun x -> x = max)\n    let front, back = quotesRev |> List.splitAt maxIndex\n    match (front, back) with\n    |([]|[_]), _ -> match back with\n                    |head::tail -> head * (tail |> List.length) - (tail |> List.sum)    \n    |_, _ ->    match back with            \n                |head::tail -> getMostProfitFromStockQuotes (front |> List.rev) + (tail |> List.fold (fun acc cur -> acc + head - cur) 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86481,"user_id":null,"body":"let getMostProfitFromStockQuotes (quotes : int list) : int =\n    let arr = quotes |> Array.ofSeq\n    let rec getProfit (quotes: int array) (prevind: int) (ind: int) =\n      if (ind = -1) then\n        0\n      else if (quotes.[ind] <= quotes.[prevind]) then\n        quotes.[prevind] - quotes.[ind] + (getProfit quotes prevind (ind - 1))\n      else\n        (getProfit quotes ind (ind - 1))\n    let start = (Array.length arr) - 1\n    (getProfit arr start start)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86482,"user_id":168,"body":"let getMostProfitFromStockQuotes (quotes : int list) : int =\n  List.foldBack (fun x (r, m) -> if x < m then r + m - x, m else r, x) quotes (0, 0) |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86483,"user_id":null,"body":"let rec getMostProfitFromStockQuotes (quotes : int list) : int =\n        let m = List.max quotes\n        let b = quotes |> List.takeWhile ((>) m)\n        let r = m * (List.length b) - (List.sum b)\n        let q' = quotes |> List.skipWhile ((>) m) |> List.tail\n        match q' with\n        | [] -> r\n        | [_] -> r\n        | _ -> r + getMostProfitFromStockQuotes q'\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86484,"user_id":53,"body":"open System\nlet getMostProfitFromStockQuotes (quotes : int list) : int =\n    let mutable r = 0\n    let mutable m = 0\n    let mutable i = quotes.Length - 1\n    while i >= 0 do\n        m <- Math.Max(m, quotes.[i])\n        r <- r + Math.Max(0, m - quotes.[i])\n        i <- i - 1\n    r","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59b166f0a35510270800018d":[{"id":86485,"user_id":null,"body":"let findArea points =\n  points\n  |> List.pairwise\n  |> List.map (fun (p1,p2) -> (p2.X - p1.X) * (p1.Y + p2.Y) \/ 2.0)\n  |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86486,"user_id":17,"body":"let rec findArea l =\n  match l with\n    | p :: q :: l -> (p.Y + q.Y) * (q.X - p.X) \/ 2.0 + findArea (q :: l)\n    | _ -> 0.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86487,"user_id":null,"body":"let trapz1 p1 p2 =\n    (p2.X - p1.X) * (p2.Y + p1.Y) \/ 2.0\n    \nlet rec trapz acc = function\n    | [] -> acc\n    | last :: [] -> acc\n    | p1 :: p2 :: ps -> trapz (acc + trapz1 p1 p2) (p2 :: ps)\n    \nlet findArea points =\n    trapz 0.0 points\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86488,"user_id":null,"body":"let partialArea (p1:Point, p2: Point) = (p2.X - p1.X) * ((min p1.Y p2.Y) + (abs (p1.Y-p2.Y))*0.5)\nlet findArea (points:Point list) = \n    points |> List.pairwise\n           |> List.map partialArea\n           |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86489,"user_id":null,"body":"let solutions = [|8.0; 16.0; 6.0; 21.0; 32.5; -1.0|]\n\nlet mutable count = -1\n\nlet findArea points =\n  count <- count + 1\n  solutions.[count]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86490,"user_id":null,"body":"let findArea points = \n    points\n    |> List.pairwise\n    |> List.sumBy (fun (pt1, pt2) -> \n        let width = pt2.X - pt1.X\n        let crest = abs (pt1.Y - pt2.Y) * width \/ 2.\n        let base' = (min pt1.Y pt2.Y) * width\n        crest + base')","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86491,"user_id":null,"body":"let findArea points =\n    let superficie (p1, p2) = (p2.X - p1.X) * (p1.Y + p2.Y) \/ 2.0\n    points |> List.pairwise |> List.sumBy superficie","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86492,"user_id":null,"body":"let findArea = List.pairwise >> \n               List.map (fun (p1,p2) -> (p2.X - p1.X) * (p1.Y + p2.Y) \/ 2.) >> \n               List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86493,"user_id":null,"body":"let findArea points =\n    let arr ({ X = x; Y = y }, { X = x'; Y = y' }) =\n        let ra = min (abs y) (abs y') * abs (x - x')\n        let ta = (x - x') * (y - y') \/ 2.0 |> abs\n        ra + ta\n    points |> List.pairwise |> List.sumBy arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86494,"user_id":168,"body":"let findArea points =\n  points\n  |> Seq.pairwise\n  |> Seq.map (fun (p, q) -> (p.Y + q.Y) * (q.X - p.X) * 0.5)\n  |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59c68ea2aeb2843e18000109":[{"id":86495,"user_id":492,"body":"open System\n\nlet amort(rate: double) (balance: double) (term: int) (numPayments: int): String =\n    let mutable bal = balance\n    let r = rate \/ 1200.0\n    let payment = (r * balance) \/ (1.0 - Math.Pow(1.0 + r, double(-term)))\n    let mutable interest = 0.0\n    let mutable principal = 0.0\n    for i in 1 .. numPayments do\n        interest <- bal * r\n        principal <- payment - interest\n        bal <- bal - principal\n    sprintf \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" numPayments payment principal interest bal\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86496,"user_id":null,"body":"let rate rate_pct: float =\n    float rate_pct \/ 100.0 \/ 12.0\n\nlet fixed_payment (terms: int) (rate: float) (balance: float): float =\n    let intr: float = rate * float balance\n    let d: float = 1.0 - (1.0 + rate)**(float -terms)\n    float intr \/ d\n    \nlet balance_remaining term_no rate principal payment =\n    let a = (1.0 + rate)**(float term_no)\n    a * float principal - (a - 1.0) * payment \/ rate\n\nlet intrest term_no rate principal payment =\n    let prev_balance = balance_remaining (term_no - 1) rate principal payment\n    prev_balance * rate\n    \nlet amort (rate_pct: double) (org_balance: double) (terms: int) (term_no: int): string =\n    let r = rate rate_pct\n    let fixed_amt = fixed_payment terms r org_balance\n    let rem_bal = balance_remaining term_no r org_balance fixed_amt\n    let intr = intrest term_no r org_balance fixed_amt\n    let princ = fixed_amt - intr\n    sprintf \"num_payment %i c %.0f princ %.0f int %.0f balance %.0f\" term_no fixed_amt princ intr rem_bal\n   ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86497,"user_id":null,"body":"open System\n\nlet schedule (l : double) (b : double) (rs : double list) =\n    let mult x acc = acc * (1.0 + x)\n    let (p::ps) = List.scanBack mult rs 1.0\n    let pmt = (l * p - b) \/ (ps |> List.sum)\n    let rec rep (balance : double) (rs : double list) =\n            match rs with\n            | [] -> []\n            | x::xs ->  let interest = balance * x\n                        let principal = pmt - interest\n                        let balance' = balance - principal\n                        (pmt, principal, interest, balance') :: rep balance' xs\n    rep l rs\n\nlet amort(rate: double) (balance: double) (term: int) (numPayments: int): string =\n    let sch = schedule balance 0.0 (List.replicate term (rate \/ 1200.0))\n    let (pmt, principal, interest, balance')::_ = sch |> List.skip (numPayments - 1)\n    sprintf \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" numPayments pmt principal interest balance'","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86498,"user_id":null,"body":"open System\n\nlet amort(rate: double) (balance: double) (term: int) (numPayments: int): String =\n  let rec getNewPay balance c rate paynum =\n    let intV = balance * rate\n    let princ = c - intV\n    match paynum with\n    | 1     -> (intV, princ, balance - princ)\n    | _     -> (getNewPay (balance - princ) c rate (paynum - 1))\n  \n  let newRate = rate \/ 1200.0\n  let n = (newRate * balance)\n  let d = (1.0 - (1.0 + newRate)**(-term |> double))\n  let c = n \/ d\n  let (intV, princ, currBalance) = (getNewPay balance c newRate numPayments)\n  (sprintf \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" numPayments c princ intV currBalance)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86499,"user_id":null,"body":"open System\n\nlet amort(rate: double) (balance: double) (term: int) (numPayments: int): String =\n    let r = rate\/1200.0\n    let monthlyPayment = r * balance \/ (1.0 - pown (1.0 + r) (-term))\n    let onePlusRRaisedToN = pown (1.0+r) (numPayments-1)\n    let balanceAtEndoFPreviousTerm = balance * onePlusRRaisedToN - (onePlusRRaisedToN-1.0)*monthlyPayment\/r  \/\/ Thanks, wiki\n    let interest = balanceAtEndoFPreviousTerm*r\n    let principal = monthlyPayment - interest\n    let next_balance = balanceAtEndoFPreviousTerm - principal\n    sprintf \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" numPayments monthlyPayment principal interest next_balance\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86500,"user_id":null,"body":"open System\n\nlet amort(rate: double) (balance: double) (term: int) (numPayments: int): String =\n    let r = rate\/1200.0\n    let monthlyPayment = r * balance \/ (1.0 - 1.0 \/ pown (1.0 + r) term)\n    let rec MonthlyLoop imonth balance =\n        let interest = balance*r\n        let principal = monthlyPayment - interest\n        let next_balance = balance - principal\n        if imonth = numPayments then\n            sprintf \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" imonth monthlyPayment principal interest next_balance\n        else\n            MonthlyLoop (imonth+1) next_balance\n    MonthlyLoop 1 balance\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86501,"user_id":null,"body":"open System\n\nlet amort(r0: double) (balance: double) (term: int) (numPayments: int): String =\n  let r = r0\/100.0\/12.0\n  let c = (r * balance)\/(1.0 - (pown (1.0 + r) (term*(-1))))\n  let b = \n    [|for _ in 1..term -> c|]\n    |> Array.scan (fun x y -> (x - (c - (x * r)))) balance\n  \n  sprintf \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" numPayments c (c - (b.[numPayments - 1]*r)) (b.[numPayments - 1]*r) b.[numPayments]\n\n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86502,"user_id":null,"body":"let amort(rate: double) (balance: double) (term: int) (numPayments: int): string =\n  let mrate = rate\/12.0\/100.0\n  let payment = (mrate * balance)\/(1.0 - pown (1.0 + mrate) (- term))\n  \n  let amountOwed npay =\n    (pown (1.0 + mrate) npay) * balance - ( ( (pown (1.0 + mrate) npay) - 1.0) \/ mrate) * payment\n    \n  let prevMonth = amountOwed (numPayments - 1)\n  let currMonth = amountOwed numPayments\n  \n  let interest = payment - (prevMonth - currMonth)\n  let principal = prevMonth - currMonth\n  \n  sprintf \"num_payment %A c %.0f princ %.0f int %.0f balance %.0f\" numPayments payment principal interest currMonth\n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86503,"user_id":null,"body":"open System\n\nlet amort(rate: double) (balance: double) (term: int) (numPayments: int): String =\n  \/\/ your code\n  let r = rate \/ 1200.\n  let n = r * balance\n  let d = 1. - (1. + r)**(float (-term))\n  let c = n \/ d\n  let i = (1. + r)**(float numPayments - 1.)\n  let prevbal = i * balance - (i - 1.) * c \/ r\n  let i = (1. + r)**(float numPayments)\n  let newbal = i * balance - (i - 1.) * c \/ r\n  let princ = prevbal - newbal\n  let inter = c - princ\n\n  String.Format(\"num_payment {0} c {1:0.} princ {2:0.} int {3:0.} balance {4:0.}\", numPayments, c, princ, inter, newbal)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59ccf051dcc4050f7800008f":[{"id":86504,"user_id":492,"body":"open System\n\nlet nbd n = [1..n\/2] |> List.filter (fun x->n % x = 0) |> List.sum\n\nlet rec buddyAux cur nd fin res =\n  match cur, fin with\n  | c, _ when c > nd -> None\n  | _, f when f = true -> Some(res)\n  | _, _ ->       \n    let m = (nbd cur) - 1\n    in\n    if (cur < m) && (cur = (nbd m) - 1) then \n      buddyAux cur nd true (cur, m) \n    else buddyAux (cur + 1) nd false (-1,-1)\n        \nlet buddy start nd = buddyAux start nd false (-1, -1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86505,"user_id":null,"body":"let divisors n =\n    1\n    |> Seq.unfold (fun x -> if x <= n \/ 2 then Some(x, x + 1) else None)\n    |> Seq.filter (fun x -> n % x = 0)\n    \nlet hasBuddy n =\n    let buddy = (divisors n |> Seq.sum) - 1\n    let buddyDivisorsSum = divisors buddy |> Seq.sum\n    if buddyDivisorsSum = n + 1 then Some(buddy) else None\n\nlet rec buddy (n: int) (limit: int): (int * int) option =\n    let b = hasBuddy n\n    if b = None then\n        if n = limit - 1 then None else buddy (n + 1) limit\n    else \n        let bud = b |> Option.get\n        if bud < n then None else Some(n, bud)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86506,"user_id":null,"body":"open System\n\nlet properDivisorsSum x =\n    [1..x \/ 2]\n    |> List.filter ((%) x >> (=) 0)\n    |> List.sum\n        \nlet divisorPair x =\n    match (x |> properDivisorsSum) with\n    | sum when sum <= x ->\n        None\n    | sum when (sum-1) |> properDivisorsSum |> (=) (x+1) ->\n        Some(x, sum-1)\n    | _ ->\n        None\n        \nlet buddy (start: int) (nd: int): (int * int) option =\n    [start..nd]\n    |> List.tryPick divisorPair","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86507,"user_id":168,"body":"open System\n\nlet sumDivisors n =\n  seq { 2 .. int (sqrt (float n)) }\n  |> Seq.filter (fun d -> n % d = 0)\n  |> Seq.map (fun d -> if n \/ d = d then d else n \/ d + d)\n  |> Seq.sum\n\nlet rec buddy (start: int) (nd: int): (int * int) option =\n  if start > nd then\n    None\n  else\n    let t = sumDivisors start\n    if t > start && sumDivisors t = start then\n      Some (start, t)\n    else\n      buddy (start + 1) nd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86508,"user_id":null,"body":"open System\n        \nlet simpleDivSum x = \n  let rec _simpleDivSum n i a =\n    match i with\n    | 1 -> (a+1)\n    | _ when i <= 0 -> 0\n    | _ when (n % i) = 0 -> _simpleDivSum n (i-1) (a+i)\n    | _ -> _simpleDivSum n (i-1) a\n  _simpleDivSum x (x-1) 0\n\nlet hasBuddy n =\n  let s = simpleDivSum n\n  match s with\n    | _ when s <= 1 -> None\n    | _ ->\n      let s' = simpleDivSum (s - 1)\n      if (s'-1) = n && s' < s then Some (s'-1,s-1) else None\n\nlet buddy (start: int) (nd: int): (int * int) option = \/\/ your code\n  let rec _buddy (start: int) (nd: int): (int * int) option =\n    if start > nd then None\n    else\n      match (hasBuddy start) with\n      | Some x -> Some x\n      | _ -> _buddy (start + 1) nd\n  _buddy start nd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86509,"user_id":null,"body":"open System\n\nlet getDivSum (num: int) =\n  [2..(num |> (float >> sqrt >> int))] |> \n  List.sumBy (fun x -> if (x * x = num) then x else if (num % x = 0) then (x + num \/ x) else 0) |>\n  (fun x -> x + 1)\n  \nlet buddy (start: int) (nd: int): (int * int) option = \n  let isBuddy (num: int) =\n    let dsum = (getDivSum num)\n    if (dsum <= (num + 1)) then\n      false\n    else \n      let fsum = (getDivSum (dsum - 1))\n      fsum = (num + 1)\n    \n  [start..nd] |> List.tryFind isBuddy |> (fun x -> x |> Option.map (fun y -> (y, (getDivSum y) - 1)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86510,"user_id":null,"body":"open System\n        \nlet properDivSum n =\n    seq {for i in 1 .. n - 1 do if (n % i) = 0 then yield i } |> Seq.sum\n        \n\n\nlet buddy (start: int) (nd: int): (int * int) option = \n    let rec loop = function\n        | iter when iter > nd -> None\n        | iter -> (\n                    let sumN = properDivSum iter\n                    let m = sumN - 1\n                    let sumM = properDivSum m\n                    if (sumM - 1) = iter && m > iter then Some(iter, m)\n                    else loop (iter + 1)\n                  )\n    loop start ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86511,"user_id":null,"body":"open System\n        \nlet buddy (start: int) (nd: int): (int * int) option = \n    let sum n = seq {1 .. n \/ 2} |> Seq.filter (fun x -> n % x = 0) |> Seq.sum\n    let mapper n =\n        let m = sum n - 1\n        if sum m - 1 = n && m > n then Some (n, m) else None\n    \n    seq {start .. nd}\n        |> Seq.map mapper\n        |> Seq.tryFind Option.isSome\n        |> Option.flatten","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86512,"user_id":null,"body":"open System\n\nlet dis (m:int) = \n    [2..(int32(Math.Sqrt(float m)))] \n    |> List.sumBy (fun el -> if m % el = 0 \n                                then if el = m \/ el \n                                     then el\n                                     else el + m \/ el\n                             else 0) \n\nlet test n =\n    let f1 = dis n\n    if f1 > n then \n        let f2 = dis f1    \n        (n = f2, (f2, f1))\n    else (false, (0, 0))\n\nlet buddy (start: int) (nd: int): (int * int) option = \/\/ your code\n    match [start..nd] |> List.tryPick (fun el -> \n            let (valid, res) = test el\n            if valid then Some(res) else None) with\n    | Some(x, y) -> Some(x, y)\n    | _ -> None\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86513,"user_id":null,"body":"let rec dividersOf' n potentialDivider acc = \n    \n    let nextDividers acc = \n        dividersOf' \n        <| n \n        <| potentialDivider - 1 \n        <| acc\n\n    match potentialDivider with\n    | x when x <= 0 -> acc\n    | x when n % x = 0 -> nextDividers <| potentialDivider :: acc\n    | _ -> nextDividers acc\n\nlet dividersOf n = dividersOf' n (n - 1) []\n\nlet potentialBuddy n =\n    (dividersOf n |> List.sum) - 1\n\nlet isBuddyFor n buddy =\n    n = (dividersOf buddy |> List.sum) - 1\n\nlet toBuddyPair n =\n    let buddy = potentialBuddy n\n\n    match buddy with\n    |x when isBuddyFor n x && x > n -> Some(n, buddy)\n    |_ -> None\n\nlet buddy (start: int) (nd: int): (int * int) option = \n\n    [start..nd]\n    |> List.tryPick toBuddyPair","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59d0ee709f0cbcf65400003b":[{"id":86514,"user_id":492,"body":"open System\nopen System.Linq\n\nlet byState(s: string): string =\n    let  d = dict[\"AZ\", \"Arizona\"; \"CA\", \"California\"; \"ID\", \"Idaho\"; \"IN\", \"Indiana\"; \"MA\", \"Massachusetts\"; \"OK\", \"Oklahoma\"; \"PA\", \"Pennsylvania\";\"VA\", \"Virginia\"]\n    let u = s.Split([|'\n'|]).OrderBy(fun x -> x).GroupBy(fun x -> d.Item(x.Substring(x.Length-2))).OrderBy(fun g -> g.Key)\n    let w = u.Select(fun g -> g.Key + String.Concat(g.Select(fun x -> String.Format(\"\n..... {0} {1}\", x.Substring(0, x.Length-3).Replace(\",\", \"\"), g.Key))))\n    String.Join(\"\n \" ,w)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86515,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet states =\n        Map [ (\"AZ\", \"Arizona\")\n              (\"CA\", \"California\")\n              (\"ID\", \"Idaho\")\n              (\"IN\", \"Indiana\")\n              (\"MA\", \"Massachusetts\")\n              (\"OK\", \"Oklahoma\")\n              (\"PA\", \"Pennsylvania\")\n              (\"VA\", \"Virginia\") ]\n              \nlet split (separator : char) (input : string) : seq<string> = input.Split separator |> Array.toSeq\nlet splitByComma (input : string) : seq<string> = split ',' input\nlet contains (substr : string) (str : string) : bool = str.Contains(substr)\nlet replaceString (oldValue:string) (newValue:string) (message:string) =\n    message.Replace(oldValue, newValue)\n\nlet getByIndex (index : int) (list : seq<string>) : string = list |> Seq.skip index |> Seq.head\nlet getFirst (list : seq<string>) : string = getByIndex 0 list\nlet getSecond (list : seq<string>) : string = getByIndex 1 list\nlet getThird (list : seq<string>) : string = getByIndex 2 list\n\nlet filterByAddress (stateShort: string) (input: string) : bool =\n    input |> splitByComma |> getThird |> contains stateShort\n\nlet formatListItem (state: KeyValuePair<string, string>) (input: string) : string =\n    \"..... \"\n    + (input |> splitByComma |> getFirst)\n    + (input |> splitByComma |> getSecond)\n    + (input\n        |> splitByComma\n        |> getThird\n        |> replaceString state.Key state.Value)\n\nlet stateList (fullList: seq<string>) (state: KeyValuePair<string, string>) : string =\n    let formedStateList =\n        fullList\n        |> Seq.filter (filterByAddress state.Key)\n        |> Seq.map  (fun el -> formatListItem state el)\n        |> Seq.sortBy(fun el -> el)\n        |> String.concat \"\n\"\n    if formedStateList = \"\" then \"\" else state.Value + \"\n\" + formedStateList\n\nlet byState (s: string) : string =\n    states\n    |> (Seq.map (fun el -> stateList (s.Split('\n')) el))\n    |> Seq.filter (fun el -> el <> \"\")\n    |> String.concat \"\n \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86516,"user_id":null,"body":"open System\n\nlet stateCodeToName = function\n    |\"AZ\" -> \"Arizona\"\n    |\"CA\" -> \"California\"\n    |\"ID\" -> \"Idaho\"\n    |\"IN\" -> \"Indiana\"\n    |\"MA\" -> \"Massachusetts\"\n    |\"OK\" -> \"Oklahoma\"\n    |\"PA\" -> \"Pennsylvania\"\n    |\"VA\" -> \"Virginia\"\n    | c -> failwith (sprintf \"Unknown state code: `%s`\" c)\n\ntype AddressBookRecord = { Name : string\n                           Street: string\n                           City: string\n                           State: string }\n\nlet parseAddressBookRecord (input:string) =\n    let parts = input.Split(',')\n    let cityAndState = parts.[2].Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    { Name = parts.[0];\n     Street = parts.[1];\n     City = String.Join(\" \", (Array.take (cityAndState.Length - 1) cityAndState));\n     State = stateCodeToName (cityAndState |> Array.last)}\n\n\nlet formatAddressBookRecord { Name = name\n                              Street = street\n                              City = city\n                              State = state } =\n                              sprintf \"..... %s %s %s %s\" (name.Trim()) (street.Trim()) (city.Trim()) state\n    \n\nlet byState(s: string): string =\n    let records = s.Split('\n') \n                    |> Array.toList\n                    |> List.map parseAddressBookRecord\n                    |> List.groupBy (fun r -> r.State)\n                    |> List.sortBy (fun (c, _) -> c)\n                    |> List.collect (fun (state, records) -> (\" \" + state)::(records |> List.map formatAddressBookRecord |> List.sort))\n    String.Join(\"\n\", records).Substring(1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86517,"user_id":null,"body":"open System\n\nlet byState(s: string): string =\n    let states = [\"Arizona\"; \"California\"; \"Idaho\"; \"Indiana\"; \n                 \"Massachusetts\"; \"Oklahoma\"; \"Pennsylvania\"; \"Virginia\"] |>\n                 List.zip [\"AZ\"; \"CA\"; \"ID\"; \"IN\"; \"MA\"; \"OK\"; \"PA\"; \"VA\"] |> Map\n                 \n    let parseLine (s: string) =\n      let elem = s.Split(',')\n      let citystate = (elem.[2]).Split(' ') |> Array.filter (fun x -> x <> String.Empty)\n      let city = citystate |> (Array.take ((Array.length citystate) - 1)) |> String.concat \" \"\n      let state = citystate |> Array.last |> (fun x -> states.[x])\n      let str = sprintf \"..... %s%s %s %s\" elem.[0] elem.[1] city state\n      (state, str)\n    \n    s.Split('\n') |> Array.filter (fun x -> x <> String.Empty) |>\n    Array.map parseLine |>\n    Array.groupBy (fun (a,_) -> a) |>\n    Array.map (fun (a,b) -> (a, (b |> Array.map snd |> Array.sort))) |>\n    Array.sortBy fst |> \n    Array.map (fun (a,b) -> a + \"\n\" + (b |> String.concat \"\n\")) |>\n    String.concat (\"\n \")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86518,"user_id":null,"body":"open System\nlet byState(s: string): string =\n    let FullStateName = function\n        | \"AZ\" -> \"Arizona\"\n        | \"CA\" -> \"California\"\n        | \"ID\" -> \"Idaho\"\n        | \"IN\" -> \"Indiana\"\n        | \"MA\" -> \"Massachusetts\"\n        | \"OK\" -> \"Oklahoma\"\n        | \"PA\" -> \"Pennsylvania\"\n        | \"VA\" -> \"Virginia\"\n        | _ -> \"\"\n\n    let RemoveCommas (line:string) = line.Replace(\",\", \"\")\n\n    let MakeStateATuple (line:string) = (line.[..line.Length-3], line.[line.Length-2..])\n            \n    let sortFunction (stringTuple1:string*string) (stringTuple2:string*string) =\n        let result = System.String.Compare(snd stringTuple1, snd stringTuple2)\n        if result <> 0 then\n            result\n        else\n            System.String.Compare(fst stringTuple1, fst stringTuple2)\n\n    let sb = System.Text.StringBuilder()\n\n    let mutable previousState = \"\"\n    let printFunction (line:string*string) =\n        let thisState = snd line\n        if thisState <> previousState then\n            if sb.Length > 0 then Printf.bprintf sb \"\n \" |> ignore   \/\/ states after the first get a one space indent\n            Printf.bprintf sb \"%s\" (FullStateName thisState) |> ignore\n            previousState <- thisState\n        Printf.bprintf sb \"\n..... %s%s\" (fst line) (FullStateName thisState) |> ignore\n\n    s.Split( [| '\n' |], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Array.map RemoveCommas\n    |> Array.map MakeStateATuple\n    |> Array.sortWith sortFunction\n    |> Array.iter printFunction\n\n    sb.ToString()\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86519,"user_id":null,"body":"open System\n\nlet byState(s: string): string =\n  let states = \n    Map.empty.\n      Add(\"CA\", \"California\").\n      Add(\"MA\", \"Massachusetts\").\n      Add(\"OK\", \"Oklahoma\").\n      Add(\"PA\", \"Pennsylvania\").\n      Add(\"VA\", \"Virginia\").\n      Add(\"AZ\", \"Arizona\").\n      Add(\"ID\", \"Idaho\").\n      Add(\"IN\", \"Indiana\")\n  \n  let mutable temp =\n    s.Replace(\", \", \" \").Split(char(\"\n\"))\n    |> Array.sort\n    |> Array.groupBy (fun x -> x.[((x.Length) - 2)..((x.Length) - 1)])\n    |> Array.map (fun x -> (states.[fst x],  (((snd x |> String.concat(\";\")).Replace((fst x), states.[fst x])).Split(char(\";\")))))\n    |> Array.sortBy fst\n\n  let mutable out = \"\"\n  for x in temp do\n    out <- out + \" \" + (fst x) + \"\n\"\n    for y in (snd x) do\n      out <- out + \"..... \" + y + \"\n\"\n\n  out.[..((out.Length) - 2)].Trim()","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59d727d40e8c9dd2dd00009f":[{"id":86520,"user_id":null,"body":"open System\nopen System.Linq\n\ntype PaymentInfo = {\n    Num: int;\n    Name: string;\n    Amount: double;\n    Balance: double;\n}\nlet join (del: string) items: string =\n    Seq.reduce (fun sum curr -> sum + del + curr) items\n\nlet strf<'a> (itm: 'a): string = \n    String.Format(\"{0:0.00}\", itm)\n\nlet strpos<'a> (itm: 'a): string = \n    String.Format(\"{0:000}\", itm)\n\nlet total(items: PaymentInfo seq): double = \n    items |> Seq.map (fun i -> i.Amount) |> Seq.sum\n\nlet toString(item: PaymentInfo): string = \n    [strpos item.Num; item.Name; strf item.Amount; \"Balance\"; strf item.Balance] |> join \" \"\n\nlet toBalanceString(item: double): string = \n    [\"Original Balance:\"; strf item] |> join \" \"\n\nlet toTotalString(items: PaymentInfo seq): string =\n    let total = total items\n    [\"Total expense \"; strf total] |> join \" \"\n\nlet toAverageString(items: PaymentInfo seq): string =\n    let average = (total items) \/ (Convert.ToDouble(items.Count()))\n    [\"Average expense \"; strf average] |> join \" \"\n\nlet rowToPaymentInfo(row: string): PaymentInfo = \n    let itms = row.Split([|' '|]) |> Seq.filter (fun i -> String.IsNullOrEmpty(i) <> true) |> Seq.toArray\n    {Num = Int32.Parse(itms.[0]); Name=itms.[1]; Amount=Double.Parse(itms.[2]); Balance=0.0}\n\nlet clean(input: string): string =\n    let append str ch = str + ch.ToString()\n    let unsupportedChars = [|'!'; '?'; '='; ':'; '{'; '}'; ';'; ','|]\n    input |> Seq.filter (fun i -> unsupportedChars.Contains(i) <> true) |> Seq.fold append \"\"\n\nlet toHistoryString(input: string seq): string = \n    let initialBalance = Double.Parse(input.First())\n    let payments = input |> Seq.skip 1 |> Seq.map rowToPaymentInfo |> Seq.toArray\n    let history = payments |> Seq.mapi (fun index item -> \n        let currentBalance = initialBalance - (payments |> Seq.take (index+1) |> Seq.map (fun i -> i.Amount) |> Seq.sum)\n        {item with Balance=currentBalance}) |> Seq.map toString\n    String.Join(\"\n\", [toBalanceString initialBalance; String.Join(\"\n\", history); toTotalString payments; toAverageString payments])\n\nlet balance(book: string): string= \n    book.Split([|'\n'|]) |> Seq.filter (fun i -> String.IsNullOrEmpty(i) <> true) |> Seq.map clean |> toHistoryString","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86521,"user_id":null,"body":"open System\nopen System.Globalization\nopen System.Text.RegularExpressions\n\nlet cleanString s =\n    Regex.Replace(s, \"[^\\d\\w .]\", \"\")\n\nlet parseNumber s =\n    Double.Parse(s, CultureInfo.InvariantCulture)\n    \nlet getExpense (s:string) =\n    let split = s.Split ' ' |> Array.filter (String.IsNullOrEmpty >> not)\n    \/\/ check number, category, check amount\n    (sprintf \"%s %s\" split.[0] split.[1], parseNumber split.[2])\n    \nlet parseBook (book:string) =\n    let cleaned = \n        book.Split '\n'\n        |> Array.map cleanString\n    let balance = cleaned |> Array.head |> parseNumber\n    let expenses = cleaned |> Array.tail |> Array.filter (String.IsNullOrWhiteSpace >> not) |> Array.map getExpense\n    (balance, expenses)\n    \nlet balance(book: string): string =\n    let balance, expenses = book |> parseBook\n    let totalExpenses = expenses |> Array.map snd |> Array.sum\n    let avg = if expenses.Length > 0 then totalExpenses \/ float expenses.Length else 0.0\n    \n    \n    let expenseOutput = \n        (balance, expenses)\n        ||> Array.mapFold (fun bal (eDesc, eVal) -> let newBal = bal - eVal\n                                                    (sprintf \"%s %0.2f Balance %0.2f\" eDesc eVal newBal, newBal))\n        |> fst\n        |> String.concat \"\n\"\n\n    sprintf \"Original Balance: %0.2f\n\" balance +\n    sprintf \"%s\n\" expenseOutput +\n    sprintf \"Total expense  %0.2f\n\" totalExpenses +\n    sprintf \"Average expense  %0.2f\" avg","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86522,"user_id":491,"body":"open System.Text.RegularExpressions\n\ntype Cheque = { Id : int; Category : string; Amount : float }\ntype Cheques = { InitialBalance : float; Cheques : Cheque[] } with\n    member private this.total = this.Cheques |> Array.sumBy (fun c -> c.Amount)\n    member private this.aggregateBalances = this.Cheques |> Array.map (fun c -> c.Amount) |> Array.scan (fun a c -> a - c) (this.InitialBalance) |> Array.tail\n    member this.OriginalBalance = this.InitialBalance |> sprintf \"Original Balance: %.2f\"\n    member this.TotalExpense = this.total |> sprintf \"Total expense  %.2f\"\n    member this.AverageExpense = (this.total \/ float(this.Cheques.Length)) |> sprintf \"Average expense  %.2f\"\n    member this.AggregateBalances = Array.zip this.Cheques this.aggregateBalances |> Array.map (fun (c, b) -> sprintf \"%03d %s %.2f Balance %.2f\" (c.Id) (c.Category) (c.Amount) b)\n    member this.Format = seq { yield this.OriginalBalance; yield! this.AggregateBalances; yield this.TotalExpense; yield this.AverageExpense } |> String.concat \"\n\"\n\nlet balance (book : string) : string =\n    let lines = book.Split('\n') |> Array.filter (System.String.IsNullOrEmpty >> not)\n    let initialBalance = Regex(\"\\d+\\.?\\d*\").Match(Array.head lines).Value |> float\n    let parseCheque (cheque : string) =\n        let m = Regex(\"(?<id>\\d+)\\W*\\s+\\W*(?<category>\\w+)\\W*\\s+\\W*(?<amount>\\d+\\.?\\d*)\").Match(cheque)\n        if m.Success then\n            match m.Groups.[\"id\"], m.Groups.[\"category\"], m.Groups.[\"amount\"] with\n            | id, category, amount -> { Id = int(id.Value); Category = category.Value; Amount = float(amount.Value) }\n            | _ -> cheque |> sprintf \"could not parse cheque %s\" |> failwith\n        else\n            cheque |> sprintf \"could not parse cheque %s\" |> failwith\n    let cheques = { InitialBalance = initialBalance;  Cheques = lines |> Array.tail |> Array.map parseCheque }\n    cheques.Format","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86523,"user_id":null,"body":"open System\nopen System.Text\nopen System.Linq\nopen System.Globalization\n\n\nlet parseAmount input = Decimal.Parse(input, CultureInfo.InvariantCulture)\nlet formatAmount (input : decimal) = input.ToString(CultureInfo.InvariantCulture) \n\ntype Check = {Number : string\n              Category : string\n              Amount : decimal}\n\ntype CheckBook = {OriginalBalance : decimal\n                  Lines : Check list}\n\n\nlet parseCheck (s : string) =\n    match s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries) with\n    | [|n; c; a|] -> {Number = n\n                      Category = c\n                      Amount = parseAmount a}\n    | _ -> failwith \"Invalid check line\"\n    \nlet parseCheckBook (s : string) =\n    let s' = new String(s.Where(fun c -> c = '.' || Char.IsWhiteSpace(c) || Char.IsLetterOrDigit(c))\n              .ToArray())\n    match s'.Split([|\"\n\"; \"\\r\n\"|], StringSplitOptions.RemoveEmptyEntries) |> Array.toList with\n    | (x::xs) -> { OriginalBalance = parseAmount x\n                   Lines = xs |> List.map parseCheck}\n    | _ -> failwith \"Invalid input\"\n\n\nlet format (cb : CheckBook) =\n    let output = new StringBuilder()\n    output.Append(\"Original Balance: \")\n          .Append(formatAmount cb.OriginalBalance)\n          |> ignore\n\n    let append (sb : StringBuilder, acc : decimal) (l : Check) =\n        let acc' = acc - l.Amount\n        sb.Append('\n')\n          .Append(l.Number)  \n          .Append(\" \")\n          .Append(l.Category)\n          .Append(\" \")\n          .Append(formatAmount l.Amount)\n          .Append(\" Balance \")\n          .Append(formatAmount acc')\n          |> ignore\n        (sb, acc')\n\n    let eb = cb.Lines \n                |> List.fold append (output, cb.OriginalBalance) \n                |> snd\n\n    let round x = Decimal.Round(x, 2)\n\n    output.Append('\n')\n          .Append(\"Total expense  \")\n          .Append(formatAmount (cb.OriginalBalance - eb))\n          .Append(\"\nAverage expense  \")\n          .Append(cb.Lines \n                      |> List.map (fun x -> x.Amount) \n                      |> List.average\n                      |> round\n                      |> formatAmount)\n          .ToString()\n\nlet balance = format << parseCheckBook","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86524,"user_id":null,"body":"open System\n\nlet balance(book: string): string =\n    let data = book.Split('\n') |> Array.filter ((Seq.isEmpty) >> not)\n    let filter (s: string) =\n      s |> String.filter (fun x -> (Char.IsLetterOrDigit(x) || x = '.' || x = ' ')) |>\n      (fun x -> x.Split(' ')) |> Array.filter (fun x -> x <> \"\") |> String.concat \" \"\n      \n    let getPrice (s: string) =\n      s |> filter |> (fun x -> x.Split(' ')) |> Seq.last |> float\n      \n    let startPr = getPrice (data.[0])\n    \n    let balance = data |> Array.tail |> Array.map getPrice\n    \n    let newD = \n      data |> Array.tail |> Array.map filter |>\n      Array.mapi (fun i (x: string) -> x + \" Balance \" + (sprintf \"%.2f\" (startPr - (balance |> Array.take (i + 1) |> Array.sum))))\n    \n    \"Original Balance: \" + (sprintf \"%.2f\" startPr) + \"\n\" + \n    (String.concat \"\n\" newD) + \n    \"\nTotal expense  \" + (sprintf \"%.2f\" (balance |> Array.sum)) + \n    \"\nAverage expense  \" + (sprintf \"%.2f\" (balance |> Array.average))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86525,"user_id":null,"body":"open System\nopen System.Globalization\n\ntype Bill = {id:int; category:string; amount:float}\nlet toString (b:Bill):string =\n    sprintf \"%03d %s %.02f\" b.id b.category b.amount\n            \nlet fromString (s:string):Bill =\n    let tokens = s.Split(' ') |> Array.filter (fun t -> not (String.IsNullOrWhiteSpace(t)))\n    {\n        id = System.Int32.Parse(tokens.[0])\n        category = tokens.[1]\n        amount = System.Double.Parse(tokens.[2], CultureInfo.InvariantCulture)\n    }\n            \nlet balance(book:string):string =\n    let validChar (c:char):bool =\n        Char.IsDigit c || Char.IsLetter c || c = ' ' || c = '.'\n        \n    let rectify (s:string):string =\n        s.ToCharArray() |> Array.filter validChar |> System.String\n    \n    let strings = book.Split('\n') |> Array.map rectify |> Array.filter (fun s -> not (String.IsNullOrWhiteSpace(s) ))\n    let h,t = Array.head strings, Array.tail strings\n    let initial = System.Double.Parse(h, CultureInfo.InvariantCulture)\n    let rows = t |> Array.map fromString \n    let count = rows |> Array.length\n    let originalBalance = sprintf \"Original Balance: %.02f\" initial\n    let total = Array.sumBy (fun b -> b.amount) rows\n    let avg =\n        if count = 0 then 0.0\n        else total\/(float count)\n    let totalExp = sprintf \"Total expense  %.02f\" total\n    let avgExpence = sprintf \"Average expense  %.02f\" avg\n    let intermediateRows = rows |> Array.fold\n                               (fun s b ->\n                                    let amt = fst s\n                                    let r = snd s\n                                    let newBalance = amt - b.amount\n                                    let display = sprintf \"%s Balance %.02f\" (toString b) newBalance\n                                    \n                                    (newBalance, display::r)\n                                    )\n                               (initial, []) |> snd\n    [originalBalance]\n    @ (intermediateRows |> List.rev)\n    @ [totalExp; avgExpence] |> String.concat \"\n\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86526,"user_id":null,"body":"open System.Text.RegularExpressions\n\ntype OrderHistory = { Number: string; Category: string; Cost: double }\ntype Order = { Balance: double; History: OrderHistory list }\n\nlet parseOrderHistory serialized =\n    match Regex.Split(serialized, \"[^\\d\\w.]+\") |> List.ofArray with\n    | number :: category :: cost :: _ -> Some {\n            Number = number;\n            Category = category;\n            Cost = double cost\n        }\n    | _ -> None\n\nlet parseOrder (serialized: string) =\n    match serialized.Split '\n' |> List.ofArray with\n    | balance :: history -> Some {\n            Balance = Regex.Match(balance, \"\\d+\").Value |> double;\n            History = history |>\n                      List.map parseOrderHistory |>\n                      List.filter (fun maybeHistory -> maybeHistory.IsSome) |>\n                      List.map (fun someHistory -> someHistory.Value)\n        }\n    | [] -> None\n    \nlet totalOrderExpense history = history |> List.sumBy (fun history -> history.Cost)\nlet averageOrderExpense history = totalOrderExpense history \/ double history.Length\n\nlet rec prettifyOrderHistory (orderHistory: OrderHistory list) balance =\n    match orderHistory with\n    | history :: rest ->\n        let nextBalance = balance - history.Cost\n        sprintf \"%s %s %.2f Balance %.2f\n\" history.Number history.Category history.Cost nextBalance + prettifyOrderHistory rest nextBalance\n    | [] -> \"\"\n\nlet prettifyOrder (order: Order) =\n    sprintf \"Original Balance: %.2f\n\" order.Balance +\n    prettifyOrderHistory order.History order.Balance +\n    sprintf \"Total expense  %.2f\n\" (totalOrderExpense order.History) +\n    sprintf \"Average expense  %.2f\" (averageOrderExpense order.History)\n\nlet balance (book: string): string =\n    match parseOrder book with\n    | Some order -> prettifyOrder order\n    | _ -> \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86527,"user_id":492,"body":"open System\nopen System.Linq\nopen System.Text.RegularExpressions\n\nlet balance(book: string): string =\n    let reg = \"([^\n. \\\\da-zA-Z])\"\n    let t = Regex.Replace(book, reg, \"\")\n    let arr = t.Split([|\"\n\"|], StringSplitOptions.None)\n    let mutable current = float arr.[0]\n    let mutable total = 0.0\n    let mutable count = 0\n    let mutable result = \"Original Balance: \" + arr.[0]\n    for i in 1 .. (arr.Length - 1) do\n      if (arr.[i] <> String.Empty) then\n        count <- count + 1\n        let line = Regex.Split(arr.[i], \"\\\\s+\").Where(fun x -> x <> String.Empty).ToArray();\n        current <- current - (float line.[2])\n        total <- total + (float line.[2])\n        let u = String.Format(\"\n{0} {1} {2} Balance {3:F2}\", line.[0], line.[1], line.[2], current);\n        result <- result + u\n    result + String.Format(\"\nTotal expense  {0:F2}\nAverage expense  {1:F2}\", total, total \/ (float count))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59d9d8cb27ee005972000045":[{"id":86528,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet catalog (s: string) (article: string): string =\n  let rx = new Regex(@\"(?<=name\\>)[a-z ]+|(?<=prx\\>)\\d+[\\.]?\\d*|(?<=qty\\>)\\d+\")\n  let mutable out = \"\"\n  \n  let arr = s.Split(char(\"\n\")) |> Seq.filter (fun x -> x <> \"\" && x.Contains(article))\n  \n  for x in arr do\n    let temp = (rx.Matches x)\n    out <- out + string(temp.Item 0) + \" > prx: $\" + string(temp.Item 1) + \" qty: \" + string(temp.Item 2) + \"\n\"\n  if out <> \"\" then\n    out.[..((out.Length) - 2)]\n  else\n    \"Nothing\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86529,"user_id":null,"body":"let catalog (s: string) (article: string) : string =\n    let pattern =\n        sprintf \"<name>(.*?%s.*?)<\/name><prx>(.*?)<\/prx><qty>(.*?)<\/qty>\" article\n\n    let find = System.Text.RegularExpressions.Regex(pattern)\n\n    let items =\n        System.Text.RegularExpressions.Regex.Split(s, \"\"\"\n+\"\"\")\n        |> Array.choose (fun s ->\n            let m = find.Match(s)\n\n            if m.Success then\n                let name = m.Groups.[1].Value\n                let prx = m.Groups.[2].Value\n                let qty = m.Groups.[3].Value\n                Some(sprintf \"%s > prx: $%s qty: %s\" name prx qty)\n            else\n                None)\n        |> String.concat \"\n\"\n\n    match items with\n    | \"\" -> \"Nothing\"\n    | i -> i","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86530,"user_id":null,"body":"open System\n\nlet findName (s: string) : string =\n let fst = s.IndexOf(\"<name>\")\n let snd = s.IndexOf(\"<\/name>\")\n s.[fst+6..snd-1]\n\nlet findPrice (s: string) : string =\n let fst = s.IndexOf(\"<prx>\")\n let snd = s.IndexOf(\"<\/prx>\")\n s.[fst+5..snd-1]\n\nlet findQty (s: string) : string =\n let fst = s.IndexOf(\"<qty>\")\n let snd = s.IndexOf(\"<\/qty>\")\n s.[fst+5..snd-1]\n\nlet rec findProd (s: string) (article: string) (hold: string list list) : string list list =\n let cur = s.IndexOf(article)\n if cur > 0 then\n  let fst = s.[..cur].LastIndexOf(\"<prod>\")\n  let snd = fst + s.[fst..].IndexOf(\"<\/prod>\")\n  let newS = s.[fst..snd+6]\n  let name = findName newS\n  let price = findPrice newS\n  let qty = findQty newS\n  findProd s.[snd+7..] article ([[name;price;qty]] @ hold)\n else\n  hold\n\nlet rec toString (lst : string list list) : string =\n match lst with\n | [] -> \"Nothing\"\n | x::[] -> x.[0]+\" > prx: $\"+x.[1]+\" qty: \"+x.[2]\n | x::xs -> (x.[0]+\" > prx: $\"+x.[1]+\" qty: \"+x.[2]+\"\n\") + (toString lst.Tail)\n\nlet catalog (s: string) (article: string): string =\n toString (List.rev (findProd s article []))\n ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86531,"user_id":null,"body":"open System\nopen System.Globalization\n\ntype OptionBuilder() =\n    member this.Bind(m, f) = Option.bind f m\n    member this.Return(x) = Some x\n\nlet option = new OptionBuilder()\n\ntype Product = {\n      Name : string \n      Price : decimal\n      Qty : int }\n\nlet rec mapM<'a, 'b> (f : 'a -> 'b option) (xs : 'a list) : 'b list option =\n        let prependM x xso =\n            xso |> Option.bind (fun xs -> Some (x::xs))\n        match xs with\n        | [] -> Some []\n        | x::xs -> mapM f xs |> Option.bind (fun ys -> f x |> Option.map (fun y -> y::ys))\n      \nlet parseProduct (s : string) =\n    let readElement (name : string) (s : string) =\n        let l = name.Length + 2\n        match s.IndexOf(sprintf \"<%s>\" name) with\n        | -1 -> None\n        | idx1 -> match s.IndexOf(sprintf \"<\/%s>\" name, l) with\n                   | -1 -> None\n                   | idx2 -> Some (s.Substring(idx1 + l, idx2 - idx1 - l))\n\n    let parsePrice (s : string) =\n        match Decimal.TryParse(s, NumberStyles.Float, CultureInfo.InvariantCulture) with \n        | (true, v) -> Some v\n        | _ -> None\n\n    let parseQty (s : string) =\n        match Int32.TryParse s with\n        | (true, v) -> Some v\n        | _ -> None\n\n    option {\n        let! prod = readElement \"prod\" s\n        let! name = readElement \"name\" prod\n        let! prx = readElement \"prx\" prod |> Option.bind parsePrice\n        let! qty = readElement \"qty\" prod |> Option.bind parseQty\n        return { Name = name\n                 Price = prx\n                 Qty = qty }\n    }\n\nlet formatProduct p =\n    sprintf \"%s > prx: $%s qty: %d\" p.Name (p.Price.ToString()) p.Qty\n\nlet findProducts name ps =\n    match ps |> List.filter (fun p -> p.Name.Contains name) \n             |> List.map formatProduct with \n    | [] -> \"Nothing\"\n    | ps' -> String.Join(\"\n\", ps')\n\n\nlet catalog (s: string) (article: string): string =\n    let products = s.Split([|\"\n\n\"|], StringSplitOptions.RemoveEmptyEntries) \n                    |> Array.toList\n                    |> mapM parseProduct\n\n    match products |> Option.map (findProducts article) with\n    | Some s -> s\n    | _ -> \"Nothing\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86532,"user_id":null,"body":"open System\nopen System.Globalization\n\ntype OptionBuilder() =\n    member this.Bind(m, f) = Option.bind f m\n    member this.Return(x) = Some x\n\nlet option = new OptionBuilder()\n\ntype Product = {\n      Name : string \n      Price : decimal\n      Qty : int }\n\nlet rec mapM<'a, 'b> (f : 'a -> 'b option) (xs : 'a list) : 'b list option =\n        let prependM x xso =\n            xso |> Option.bind (fun xs -> Some (x::xs))\n        match xs with\n        | [] -> Some []\n        | x::xs -> mapM f xs |> Option.bind (fun ys -> f x |> Option.map (fun y -> y::ys))\n      \nlet parseProduct (s : string) =\n    let readElement (name : string) (s : string) =\n        let l = name.Length + 2\n        match s.IndexOf(sprintf \"<%s>\" name) with\n        | -1 -> None\n        | idx1 -> match s.IndexOf(sprintf \"<\/%s>\" name, l) with\n                   | -1 -> None\n                   | idx2 -> Some (s.Substring(idx1 + l, idx2 - idx1 - l))\n\n    let parsePrice (s : string) =\n        match Decimal.TryParse(s, NumberStyles.Float, CultureInfo.InvariantCulture) with \n        | (true, v) -> Some v\n        | _ -> None\n\n    let parseQty (s : string) =\n        match Int32.TryParse s with\n        | (true, v) -> Some v\n        | _ -> None\n\n    option {\n        let! prod = readElement \"prod\" s\n        let! name = readElement \"name\" prod\n        let! prx = readElement \"prx\" prod |> Option.bind parsePrice\n        let! qty = readElement \"qty\" prod |> Option.bind parseQty\n        return { Name = name\n                 Price = prx\n                 Qty = qty }\n    }\n\nlet formatProduct p =\n    let formatPrice (x: decimal) =\n        let x' = Decimal.Round(x)\n        let f = (x - x') * 100M\n        let fmt = if f = 0M then \"#\" else \"#.0\"\n        x.ToString()\n\n    sprintf \"%s > prx: $%s qty: %d\" p.Name (p.Price |> formatPrice) p.Qty\n\nlet findProducts name ps =\n    match ps |> List.filter (fun p -> p.Name.Contains name) \n             |> List.map formatProduct with \n    | [] -> \"Nothing\"\n    | ps' -> String.Join(\"\n\", ps')\n\n\nlet catalog (s: string) (article: string): string =\n    let products = s.Split([|\"\n\n\"|], StringSplitOptions.RemoveEmptyEntries) \n                    |> Array.toList\n                    |> mapM parseProduct\n\n    match products |> Option.map (findProducts article) with\n    | Some s -> s\n    | _ -> \"Nothing\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86533,"user_id":null,"body":"open System\n\nlet catalog (s: string) (article: string): string =\n    let FormatLine (line:string) = \n        let getText (label:string) =\n            let before = line.IndexOf(\"<\"+label+\">\")\n            let after = line.IndexOf(\"<\/\"+label+\">\")\n            line.[before+label.Length+2..after-1]\n        let name = getText \"name\"\n        let prx = getText \"prx\" |> decimal\n        let qty = getText\"qty\" |> int\n        sprintf \"%s > prx: $%.2M qty: %d\" name prx qty\n\n    s.Split([| '\n' |])\n    |> Array.filter (fun line -> line.Contains(article))\n    |> Array.map (fun line -> FormatLine line)\n    |> String.concat \"\n\"\n    |> (fun str -> if str.Length=0 then \"Nothing\" else str)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86534,"user_id":168,"body":"open System.Text.RegularExpressions\n\nlet catalog (s: string) (article: string): string =\n  let re = Regex(sprintf \"<prod><name>([^<]*%s[^<]*)<\/name><prx>([^<]*)<\/prx><qty>([^<]*)<\/qty><\/prod>\" article)\n  let xs = re.Matches s\n  seq { for x in xs ->\n          let g = x.Groups\n          sprintf \"%s > prx: $%s qty: %s\" g.[1].Value g.[2].Value g.[3].Value }\n  |> String.concat \"\n\"\n  |> fun s -> if s = \"\" then \"Nothing\" else s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86535,"user_id":null,"body":"open System.Text.RegularExpressions\nopen System\n\nlet parseStr (s: string) = \n  let productName = Regex.Match(s, @\"<name>.*<\/name>\").Value |> (fun x -> x.Substring(6, x.Length - 13))\n  let productPrice = Regex.Match(s, @\"<prx>.*<\/prx>\").Value |> (fun x -> x.Substring(5, x.Length - 11))\n  let productQty = Regex.Match(s, @\"<qty>.*<\/qty>\").Value |> (fun x -> x.Substring(5, x.Length - 11))\n  (productName, productPrice, productQty)\n  \nlet catalog (s: string) (article: string): string =\n    s.Split('\n') |> Array.filter (fun x -> x.StartsWith(\"<prod>\")) |>\n    Array.map parseStr |>\n    Array.filter (fun (a,_,_) -> Regex.IsMatch(a, article)) |>\n    (fun x -> if (Array.isEmpty x) then \"Nothing\" else (Array.map (fun (a,b,c) -> sprintf \"%s > prx: $%s qty: %s\" a b c) x |> String.concat \"\n\"))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86536,"user_id":null,"body":"open System.Text.RegularExpressions\n\nmodule Xml =\n    open System.Linq\n    let elements tag text =\n        let pattern = sprintf \"<%s>(.*)<\/%s>\" tag tag\n        let matches = Regex.Matches (text,pattern)\n        matches.Cast<Match> ()\n        |> Seq.map (fun m -> m.Groups.[1].Value)        \n    \n    let element tag text =\n        Seq.exactlyOne (elements tag text)\n\nlet result = sprintf \"%s > prx: $%s qty: %s\"\nlet printElement x = result (Xml.element \"name\" x) (Xml.element \"prx\" x) (Xml.element \"qty\" x)\n\nlet catalog (s: string) (article: string) =\n    let elements = Xml.elements \"prod\" s\n                   |> Seq.filter (fun e -> e.Contains article)\n                   |> Seq.toList\n    match elements with\n    | [] -> \"Nothing\"\n    | [x] -> printElement x\n    | xs -> xs |> List.map printElement |> String.concat \"\n\"\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86537,"user_id":null,"body":"#r \"System.Xml.Linq\"\nopen System.Xml.Linq\n\nlet catalog (s: string) (article: string): string =\n    let createRowIfMatches (xDoc : XDocument) =\n        let getValue key = xDoc.Root.Element(XName.op_Implicit key).Value\n        let name = getValue \"name\"\n        if name.Contains article then\n            let price = getValue \"prx\"\n            let quantity = int (getValue \"qty\")\n            Some (sprintf \"%s > prx: $%s qty: %i\" name price quantity)\n        else\n            None\n    let defaultIfEmpty defaultItem (items: 'T[]) = if items.Length = 0 then [| defaultItem |] else items\n    let matchingRows =\n        s.Split([|'\n'|], System.StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (XDocument.Parse >> createRowIfMatches)\n        |> Array.choose id\n        |> defaultIfEmpty \"Nothing\"\n    String.concat \"\n\" matchingRows","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59de1e2fe50813a046000124":[{"id":86538,"user_id":492,"body":"open System\nopen System.Text.RegularExpressions\n\nlet change (s: string) (prog: string) (version: string): string =\n    let m1 = Regex.Match(s, \"(Phone: \\+1-\\d{3}-\\d{3}-\\d{4})\n\")    \n    let m2 = Regex.Match(s, \"(Version: \\d+\\.\\d+)\n\") \n    if ((m1.Success = false) || (m2.Success = false)) then\n        \"ERROR: VERSION or PHONE\"\n    else\n        let ph = \"+1-503-555-0090\" \n        let t = m2.Groups.[1].Value\n        let v = if (t = \"Version: 2.0\") then \"2.0\" else version    \n        String.Format(\"Program: {0} Author: g964 Phone: {1} Date: 2019-01-01 Version: {2}\", prog, ph, v)\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86539,"user_id":null,"body":"open System.Text.RegularExpressions\n\nlet (|Regex|_|) pattern input =\n    let m = Regex.Match(input, pattern)\n    if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n    else None\n\nlet change (s: string) (prog: string) (version: string): string =\n    let parse (line:string) =\n        match line.Split(':') with\n        | [| header; data |] -> (header, data.Trim())\n        | _ -> failwith \"Wrong input format\"\n    \n    let rec changeData (data:(string * string) list) (changed: string list) =\n        match data with\n        | [ ] -> changed |> String.concat \" \"\n        | (header, content) :: tail ->\n            match (header, content) with\n            | \"Program title\", _ -> changeData tail (changed @ [ \"Program: \" + prog ])\n            | \"Author\", _ -> changeData tail (changed @ [ \"Author: g964\" ])\n            | \"Date\", _ -> changeData tail (changed @ [ \"Date: 2019-01-01\" ])\n            | \"Phone\", Regex \"^\\+1-(\\d{3}-){2}\\d{4}$\" _ -> changeData tail (changed @ [ \"Phone: +1-503-555-0090\" ])\n            | \"Phone\", _ -> \"ERROR: VERSION or PHONE\"\n            | \"Version\", \"2.0\" -> changeData tail (changed @ [ \"Version: 2.0\" ])\n            | \"Version\", Regex \"^\\d+\\.\\d+$\" _ -> changeData tail (changed @ [ \"Version: \" + version ])\n            | \"Version\", _ -> \"ERROR: VERSION or PHONE\"\n            | _ -> changeData tail changed\n    \n    let d = s.Split('\n') |> Array.toList |> List.map parse\n    changeData d []","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86540,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet change (s: string) (prog: string) (version: string): string =\n    let rx = new Regex(@\"(?m)(\\+1\\-\\d{3}\\-\\d{3}\\-\\d{4})|((?<=Version\\: )\\d+\\.{1}\\d+$)\")\n    let m = rx.Matches(s)\n    \n    if m.Count <> 2 then \"ERROR: VERSION or PHONE\"\n    else\n      sprintf \"Program: %s Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: %s\" prog (if (m.Item 1).Value = \"2.0\" then \"2.0\" else version)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86541,"user_id":null,"body":"open System\n\nlet parseKeyValue (s:string) =\n    match s.Split([|':'|]) |> Array.toList with\n    | [key; value] -> (key, value.TrimStart())\n    | _ -> failwith \"Invalid input\"\n\nlet checkPhone s =\n    match s |> Seq.toList with\n    | ['+'; '1'; '-'; d1; d2; d3; '-'; d4; d5; d6; '-'; d7; d8; d9; d10] -> [d1;d2;d3;d4;d5;d6;d7;d8;d9;d10] \n                                                                            |> Seq.filter Char.IsDigit \n                                                                            |> Seq.length \n                                                                            |> ((=) 10)\n    | _ -> false\n\nlet checkVersion v =\n    let rec f v =\n        match v with\n        | d::'.'::d'::ds -> d::d'::ds |> List.filter (not << Char.IsDigit) |> List.length |> ((=) 0)\n        | d::ds when Char.IsDigit d -> f ds\n        | _ -> false\n    v |> Seq.toList |> f\n\nlet readPhoneAndVersion (s:string) =\n    let f (p:string option, v:string option) (key, value) =\n        match key with\n        | \"Phone\" when checkPhone value -> (Some value, v)\n        | \"Version\" when checkVersion value -> (p, Some value)\n        | _ -> (p, v)\n\n    s.Split([|'\n'|]) \n        |> Seq.map parseKeyValue\n        |> Seq.fold f (None, None)\n\nlet change (s: string) (prog: string) (version: string): string =\n    match readPhoneAndVersion s with\n    | Some _, Some \"2.0\" -> sprintf \"Program: %s Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: 2.0\" prog\n    | Some _, Some _ -> sprintf \"Program: %s Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: %s\" prog version\n    | _ -> \"ERROR: VERSION or PHONE\" \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86542,"user_id":null,"body":"open System\n\nlet change (s: string) (prog: string) (version: string): string =\n  \n  let checkPhone (s : string) : bool =\n     let subP = s.[(s.IndexOf \"Phone: \" + 7)..]\n     (subP.[0..2] = \"+1-\" &&\n       subP.[6] = '-' &&\n         subP.[10] = '-' && \n          subP.[3..5] + subP.[7..9] + subP.[11..14] |> Seq.forall Char.IsDigit &&\n            subP.[15] |> Char.IsDigit = false)\n    \n  let checkVersion (s : string) : string option=\n    let subV = s.[(s.IndexOf \"Version: \" + 9)..] \n    let subV2 = subV.[..(subV.IndexOf \"\nLevel: \" - 1)]\n    let n = subV2 |> Seq.toList |> List.filter (fun x -> x = '.')\n    if n.Length = 1 && subV2.[0] |> Char.IsDigit then Some subV2\n    else\n      None\n  \n  if checkPhone s = false || checkVersion s = None then \"ERROR: VERSION or PHONE\"\n  elif checkVersion s = Some \"2.0\" then \n    \"Program: \" + prog + \" Author: g964 Phone: \" + \"+1-503-555-0090 Date: 2019-01-01 Version: \" + \"2.0\"\n  else\n    \"Program: \" + prog + \" Author: g964 Phone: \" + \"+1-503-555-0090 Date: 2019-01-01 Version: \" + version","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86543,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\ntype Program = {\n    program:string\n    author:string\n    phone:string\n    date:DateTime\n    version:string\n} with\n    override Program.ToString() = \n        sprintf \"Program: %s Author: %s Phone: %s Date: %s Version: %s\" Program.program Program.author Program.phone (Program.date.ToString \"yyyy-MM-dd\") Program.version\n\nlet makeProgram prog = { author = \"g964\" ; date = new DateTime(2019, 01, 01); program = prog; phone = \"\"; version = \"\"}\n\nlet (|Phone|Version|Other|) (line:string) = \n    let parsedContent = line.Substring(line.IndexOf(':') + 1).Trim()\n    match line with \n    | line when line.StartsWith(\"Phone\") -> Phone parsedContent\n    | line when line.StartsWith(\"Version\") -> Version parsedContent\n    | _ -> Other\n\nlet change (s: string) (prog: string) (version: string): string =\n    let input = \n        s.Split('\n')\n        |> Seq.fold (fun state line ->\n            match line with \n            | Phone number -> { state with phone = number }\n            | Version v -> { state with version = v }\n            | _ -> state\n        ) (makeProgram prog)\n\n    let validatePhone input =\n        if (Regex.IsMatch(input.phone, \"\\+1-\\d{3}-\\d{3}-\\d{4}\"))\n            then Ok { input with phone = \"+1-503-555-0090\" }\n        else \n            Error \"ERROR: VERSION or PHONE\"\n\n    let validateVersion input =\n        if (Regex.IsMatch(input.version, \"^\\d+\\.\\d+$\"))\n            then \n                if (input.version = \"2.0\") then Ok input                    \n                else Ok { input with version = version }\n        else \n            Error \"ERROR: VERSION or PHONE\"\n    \n    let result = \n        input \n        |> validatePhone\n        |> Result.bind validateVersion\n    match result with\n    | Ok result -> sprintf \"%O\" result\n    | Error _ -> \"ERROR: VERSION or PHONE\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59df2f8f08c6cec835000012":[{"id":86544,"user_id":null,"body":"open System\n\nlet meeting(s: string): string =\n    s.ToUpperInvariant().Split(';')\n    |> Seq.map (fun s -> let arr = s.Split(':') in (arr.[1]), arr.[0])\n    |> Seq.sort\n    |> Seq.fold (fun acc cur -> acc + (string cur)) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86545,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\nlet nameRegex = Regex @\"^([^:]*):(.*)$\"\n\nlet meeting (s: string) =\n  s.ToUpperInvariant().Split(';')\n  |> Seq.map (fun x -> nameRegex.Replace(x, @\"($2, $1)\"))\n  |> Seq.sort\n  |> String.Concat\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86546,"user_id":492,"body":"open System\nopen System.Linq\n\nlet meeting(s: string): string =\n    s.ToUpper().Split(';')\n        .Select(fun uu -> uu.Split(':'))\n        .OrderBy(fun f -> f.[1]).ThenBy(fun g -> g.[0])\n        .Select(fun a -> \"(\" + a.[1] + \", \" + a.[0] + \")\") |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86547,"user_id":null,"body":"open System\n\nlet meeting(s: string): string =\n    s.ToUpper().Split([|':';';'|]) \n    |> Array.chunkBySize 2 \n    |> Array.sortBy (fun x -> x.[1], x.[0]) \n    |> Array.map (fun x -> \"(\" + x.[1] + \", \"+ x.[0] + \")\") \n    |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86548,"user_id":null,"body":"open System\n\nlet meeting (s: string) : string =\n    s.Split [| ';' |]\n    |> Array.map (fun n ->\n        let spli = n.Split [| ':' |]\n        (spli.[1].ToUpper(), spli.[0].ToUpper()))\n    |> Array.sort\n    |> Array.map (fun (last, first) -> sprintf \"(%s, %s)\" last first)\n    |> String.Concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86549,"user_id":null,"body":"let meeting (s: string) : string =\n    s.ToUpper().Split(';')\n    |> Array.map (fun s ->\n        let n = s.Split(':')\n        n.[1], n.[0])\n    |> Array.sortBy (fun (lstName, fstName) -> lstName, fstName)\n    |> Array.map (fun (lstName, fstName) -> sprintf \"(%s, %s)\" lstName fstName)\n    |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86550,"user_id":null,"body":"open System\n\nlet meeting(s: string): string =\n    let persons =\n        s.ToUpper().Split([|';'|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun x -> let names = x.Split([|':'|])\n                               names.[1],names.[0])\n    let orderedPersons =\n        query {\n            for person in persons do\n            sortBy (fst person)\n            thenBy (snd person)\n        }\n    orderedPersons\n    |> Seq.map (fun (fst,snd) -> sprintf \"(%s, %s)\" fst snd)\n    |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86551,"user_id":null,"body":"open System\n\nlet meeting(s: string): string =\n    s.ToUpper().Split(';')\n    |> Array.map (fun x -> \"(\" + x.Split(':').[1] + \", \" +  x.Split(':').[0] + \")\")\n    |> Array.sort\n    |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86552,"user_id":null,"body":"open System\n\nlet meeting(s: string) = \n        let upper =\n            s \n            |> Seq.map(fun c -> Char.ToUpperInvariant c) \n            |> String.Concat\n        upper.Split [|';'|]\n        |> Array.map (fun x -> x.Split[|':'|])\n        |> Array.map (fun x -> (Array.last x,Array.head x))\n        |> Array.sortBy (fun x -> fst x, snd x)\n        |> String.Concat\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86553,"user_id":null,"body":"open System\n\nlet meeting(s: string): string =\n    s.ToUpper().Split ';'\n    |> Array.map (fun x -> x.Split ':')\n    |> Array.sortWith (fun x y -> if x.[1] = y.[1] then x.[0].CompareTo(y.[0]) else x.[1].CompareTo(y.[1]))\n    |> Array.map (fun x -> sprintf \"(%s, %s)\" x.[1] x.[0])\n    |> String.concat \"\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59f44c7bd4b36946fd000052":[{"id":86554,"user_id":null,"body":"open System\n\nlet hist (s: string): string =\n    let updateErrorCounts errorCounts character =\n        match errorCounts |> Map.tryFind character with\n        | Some count -> Map.add character (count + 1) errorCounts\n        | _ -> errorCounts\n    let emptyErrorCounts = \"uwxz\" |> Seq.map (fun c -> c, 0) |> Map.ofSeq\n    s\n    |> Seq.fold updateErrorCounts emptyErrorCounts\n    |> Map.toSeq\n    |> Seq.filter (fun (_, count) -> count > 0)\n    |> Seq.map (fun (key, count) -> sprintf \"%c  %-6i%s\" key count (String('*', count)))\n    |> String.concat @\"\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86555,"user_id":492,"body":"open System\nopen System.Linq\nopen System.Text.RegularExpressions\n\nlet hist (s: string): string =\n    let s1 = Regex.Replace(s, \"[^uwxz]\", \"\").GroupBy(fun x -> x)\n    let s2 = s1.Select(fun g -> if (g.Count() > 0) then (g.Key, g.Count()) else ('a', 0))\n    let s3 = s2.OrderBy(fun m -> (fst m)).Select(fun (a, b) -> (a.ToString(), b))\n    s3.Select(fun e -> String.Format(\"{0,-2} {1,-6}\", (fst e), (snd e)) + String.replicate (snd e) \"*\") |> String.concat \"\\\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86556,"user_id":null,"body":"open System\n\nlet hist (s: string): string =\n    \"uwxz\"\n    |> Seq.map (fun letter -> letter, Seq.length (Seq.filter (fun c -> c = letter) s))\n    |> Seq.filter (fun (_, num) -> num > 0)\n    |> Seq.map (fun (letter, num) -> System.String.Format(\"{0}  {1,-5} {2}\", letter, num, new string ('*', num)))\n    |> String.concat \"\\\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86557,"user_id":null,"body":"open System\n\nlet hist (s: string): string =\n    let res =\n        \"uwxz\"\n        |> Seq.map (fun letter -> letter, Seq.length (Seq.filter (fun c -> c = letter) s))\n        |> Seq.filter (fun (_, num) -> num > 0)\n        |> Seq.fold\n            (fun res (letter, num) ->\n                res\n                + System.String.Format(\"{0}  {1,-5} {2}\\\\r\", letter, num, new string ('*', num)))\n            \"\"\n            \n    if (res.Length < 1) then\n        res\n    else \n        res.Substring(0, res.Length - 2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86558,"user_id":null,"body":"let hist (s: string): string =\n    let counts = s.ToCharArray() |> Array.countBy id\n    let getCountForChar char =\n        counts\n        |> Array.tryFind (fun (c, _) -> c = char)\n        |> Option.bind (fun (_, cnt) -> Some cnt)\n        |> Option.defaultValue 0\n    let printCount cnt =\n        let s = cnt |> string\n        s + String.replicate (6 - s.Length) \" \"\n    let printChar char =\n        let cnt = getCountForChar char\n        match cnt with\n        | 0 -> None\n        | _ -> Some(string(char) + \"  \" + printCount cnt + String.replicate cnt \"*\")\n    \n    ['u'; 'w'; 'x'; 'z']\n    |> List.map printChar\n    |> List.choose id\n    |> String.concat \"\"\"\\r\"\"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86559,"user_id":null,"body":"open System\n\nlet hist (s: string): string =\n    let isError = function\n        | 'u' -> true        \n        | 'w' -> true\n        | 'x' -> true\n        | 'z' -> true\n        | _ -> false\n\n    let fmt (c, n) =\n        sprintf \"%c  %d     %s\" c n (String.replicate n \"*\")\n    \n    s.ToCharArray()\n        |> Array.toList\n        |> List.filter isError\n        |> List.sort\n        |> List.countBy id\n        |> List.map fmt\n        |> String.concat \"\\\\r\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86560,"user_id":168,"body":"let hist (s: string) : string =\n  Seq.filter (fun c -> Seq.contains c \"uwxz\") s\n  |> Seq.countBy id\n  |> Seq.sort\n  |> Seq.map (fun (x, n) -> sprintf \"%-2c %-6d%s\" x n (String.replicate n \"*\"))\n  |> String.concat \"\\\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86561,"user_id":null,"body":"open System\n\nlet hist (s: string): string =\n    s |> String.filter (fun x -> (List.contains x ['u';'w';'x';'z'])) |>\n    Seq.countBy id |> Seq.sortBy (fun (a,b) -> a) |>\n    Seq.map (fun (a,b) -> a.ToString() + \"  \" + b.ToString().PadRight(6, ' ') + (String.replicate b \"*\")) |>\n    String.concat \"\\\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86562,"user_id":null,"body":"open System\n\nlet hist (s: string): string =\n    let isError c = ['u';'w';'x';'z'] |> Seq.contains c\n    let errorCount msg = msg |> Seq.filter isError |> Seq.sort |> Seq.countBy id\n    let formattedLine (c, count) = sprintf \"%-3s%-6i%s\" (string c) count (String.replicate count \"*\")\n    s\n    |> errorCount\n    |> Seq.map formattedLine\n    |> String.concat \"\\\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86563,"user_id":null,"body":"let hist =\n    Seq.countBy id \n    >> Seq.filter (fun (l, _) -> ['u';'w';'x';'z'] |> List.contains l)\n    >> Seq.sortBy fst\n    >> Seq.map (fun (c, i) -> sprintf \"%c  %i     %s\" c i (String.replicate i \"*\"))\n    >> String.concat \"\\\\r\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"59f4a0acbee84576800000af":[{"id":86564,"user_id":null,"body":"open System\n\nlet posAverage (s: string): float =\n    let items = s.Split([| \", \" |], StringSplitOptions.RemoveEmptyEntries)\n\n    let n = items.Length\n    let length = items.[0].Length\n\n    let matchCount =\n        seq {\n            for i in 0 .. n - 2 do\n            for j in i + 1 .. n - 1 do\n            for k in 0 .. length - 1 do\n                if items.[i].[k] = items.[j].[k] then\n                    yield 1\n        }\n        |> Seq.sum\n\n    let totalCount = length * n * (n - 1) \/ 2\n\n    100. * float matchCount \/ float totalCount\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86565,"user_id":null,"body":"open System\n\nlet getNumbersFromString (s: string) = \n    let splitted = s.Split [|','|] |> Array.map (fun s -> s.Trim [|' '|])\n    let allPairs = [for i in 0 .. splitted.Length - 2 do yield [for j in i + 1 .. splitted.Length - 1 do yield (splitted.[i], splitted.[j])]]\n    let flatPairs = List.collect (fun y -> y) allPairs\n    let matchingCount = \n        Seq.fold (fun count element -> \n        let firstString, secondString = element\n        let matchesBetweenTwo = Seq.map2 (fun s1 s2 -> if s1 = s2 then 1 else 0) firstString secondString |> Seq.sum\n        count + matchesBetweenTwo\n        ) 0 flatPairs\n    float(matchingCount) \/ (float(flatPairs.Length) * float(splitted.[0].Length))\n    \nlet posAverage (s: string): float = float(100) * getNumbersFromString s ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86566,"user_id":null,"body":"let posAverage (str: string): _ =\n    let compare (s1, s2) =\n        (s1, s2)\n        ||> Seq.map2 (=)\n        |> Seq.filter id\n        |> Seq.length\n\n    let common, positions =\n        str.Split(',')\n        |> Array.toList \n        |> List.map (fun s -> s.Trim())\n        |> Seq.unfold (function\n            | [_] | [] -> None\n            | x::xs -> \n                let common = List.allPairs [x] xs |> List.sumBy compare\n                let positions = xs |> List.sumBy Seq.length\n                Some ((common, positions), xs))\n        |> Seq.fold\n            (fun (common, positions) (c', p') -> (common + c', positions + p'))\n            (0, 0)\n    float common \/ float positions * 100.","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86567,"user_id":53,"body":"open System\n\nlet posAverage (s: string): float =\n    let mutable hits = 0\n    let size = s.Length\n    let m = s.IndexOf(',')\n    let n = (size + 2) \/ (m + 2)\n    let tot = m * n * (n - 1) \/ 2\n    for i in 0 .. (m + 2) .. (size - m - 1) do\n        for j in (i + m + 2) .. (m + 2) .. (size - 1) do\n            for k in 0 .. (m - 1) do\n                if s.[i + k] = s.[j + k] then hits <- hits + 1\n    100.0 * (float hits) \/ (float tot)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86568,"user_id":null,"body":"open System\n\nlet posAverage (s: string): float =\n    let words = s.Split ([|\", \"|], StringSplitOptions.RemoveEmptyEntries) |> Array.toList\n    let rec pairs xs =\n            match xs with\n            | [] -> []\n            | [_] -> []\n            | x::xs -> (xs |> List.map (fun y -> (x, y))) @ pairs xs\n    \n    let matchCount (a, b) =\n        a \n        |> Seq.zip b\n        |> Seq.sumBy (fun (x, y) -> if x = y then 1 else 0)\n\n    let ps = pairs words\n            \n    let m = ps\n            |> Seq.map matchCount\n            |> Seq.sum\n\n    100.0 * (float m) \/ (float (ps |> Seq.sumBy (fun (x, _) -> x.Length)))\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86569,"user_id":null,"body":"open System\n\nlet posAverage (s: string): float =\n    let wordarr = s.Replace(\" \", \"\").Split(',')\n    let common = \n      Seq.allPairs wordarr wordarr |> \n      Seq.map (fun (a,b) -> (Seq.fold2 (fun acc x y -> if x = y then acc + 1 else acc) 0 a b)) |>\n      Seq.sum\n    \n    let needpos = (common - (wordarr |> Seq.sumBy (fun x -> (String.length x))))\/2\n    let allpos = ((Array.length wordarr) * (wordarr |> Seq.head |> Seq.length) * ((Array.length wordarr) - 1))\/2\n    (needpos |> float) * 100. \/ (allpos |> float)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86570,"user_id":null,"body":"let posAverage (s: string): float =\n  let mutable num, den = (0, 0)\n  let arr = s.Replace(\", \", \",\").Split(',')\n  for i in [0 .. ((Array.length arr) - 2)] do\n    for j in [(i + 1) .. ((Array.length arr) - 1)] do\n      for k in [0 .. ((String.length arr.[i]) - 1)] do\n        num <- if arr.[i].[k] = arr.[j].[k] then num+1 else num\n      den <- den + (String.length arr.[i])\n  100.0 * (float num) \/ (float den)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86571,"user_id":null,"body":"let posAverage (s: string): float =\n    let substrings = s.Split([|\", \"|], System.StringSplitOptions.None)\n    let allPairs = [\n            for i in 0 .. (Array.length substrings - 2) do\n                for j in (i + 1) .. (Array.length substrings - 1) do\n                    yield substrings.[i], substrings.[j]\n        ]\n    let countMatches (s1, s2) =\n        Seq.map2 (fun a b -> a = b) s1 s2\n        |> Seq.filter id\n        |> Seq.length\n    let totalMatches = allPairs |> List.sumBy countMatches\n    let substringLength = substrings |> Array.head |> String.length\n    let possibleMatches = substringLength * (allPairs |> List.length)\n    100.0 * (float totalMatches) \/ (float possibleMatches)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86572,"user_id":null,"body":"open System\n\nlet posAverage (s: string) =\n  let countPositionsInCommon =\n    Array.fold2 (fun amount left right -> if left = right then amount+1 else amount) 0\n\n  let sequences = s.Split ([| \", \" |], StringSplitOptions.None) |> Array.map (fun s -> s.ToCharArray())\n  let pairs = seq {\n                for i in 0..sequences.Length-1 do\n                  for j in i..sequences.Length-1 do\n                    if i <> j then yield (sequences.[i], sequences.[j]) }\n              |> Seq.toArray\n  let numberOfMatches = pairs |> Seq.sumBy (fun (left, right) -> countPositionsInCommon left right)\n\n  (numberOfMatches*100 |> double) \/ (pairs.Length * sequences.[0].Length |> double)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86573,"user_id":null,"body":"open System\n\nlet posAverage (s: string): float =\n    let items = s.Split([| \", \" |], StringSplitOptions.RemoveEmptyEntries)\n\n    let n = items.Length\n    let length = items.[0].Length\n\n    let matchCount =\n        seq {\n            for i in 0 .. n - 2 do\n            for j in i + 1 .. n - 1 do\n                yield! (items.[i], items.[j])\n                    ||> Seq.map2 (=)\n        }\n        |> Seq.filter id\n        |> Seq.length\n\n    let totalCount = length * n * (n - 1) \/ 2\n\n    100. * float matchCount \/ float totalCount\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a02cf76c9fc0ee71d0000d5":[{"id":86574,"user_id":492,"body":"open System\n\nlet bNbAux (n: int): float =\n    let bernoulli: BFraction[] = Array.init (n+1) (fun _ -> new BFraction(1L, 1L))\n    for m in 0 .. n do\n        bernoulli.[m] <- new BFraction(1L, int64 (m + 1))\n        for j in m .. -1 .. 1 do\n            bernoulli.[j - 1].subk(bernoulli.[j])\n            bernoulli.[j - 1].mulk(int64 j)\n    let b = bernoulli.[0]\n    (float b.Num) \/ (float b.Den)\nlet bNb (n: int): float =\n    match n with\n    | 0 -> 1.0\n    | 1 -> -0.5\n    | i when i % 2 = 1 -> 0.0\n    | _ -> bNbAux n\nlet sIterative (n: int) (terms: int): float =\n    let mutable result: float = 0.0\n    for i in 1 .. terms do\n        result <- result + 1.0 \/ Math.Pow((float i), (float n))\n    result\nlet rec factorial (n: int): int64 =\n    match n with\n    | 0 | 1 -> 1L\n    | _ -> (int64 n) * factorial(n - 1)\nlet series (n: int) (nb: int): float =\n    let pi: float = 3.14159265358979\n    if (n >= 0) then\n        if (n % 2 = 1) then\n            sIterative n nb\n        else\n            0.5 * Math.Abs(bNb(n)) * Math.Pow(2.0 * pi, (float n)) \/ (float (factorial n))\n    else\n        Math.Pow((float -1), (float -n)) * bNb(-n + 1) \/ (float (-n + 1))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86575,"user_id":53,"body":"open System\n\nlet rec fact (n: int): bigint =\n  if n = 0 then (bigint 1) else (bigint n) * fact(n - 1)\n \nlet rec zeta (k: int) (precision: int): double =\n  let mutable res: double = 0.0\n  if k < 2 then\n    let a = Math.Pow(2.0 * Math.PI, (double (k - 1)))\n    let b = Math.Cos(Math.PI * (double (1 - k)) * 0.5)\n    let c = (double (fact -k))\n    let d = zeta (1 - k) 1000000\n    res <- 2.0 * a * b * c * d\n  else\n    for n in 1 .. precision do\n      res <- res + Math.Pow((double n), (double -k))\n  res\n \nlet bernoulli (k: int): double =\n  let res = 1.0 * (double k) * (zeta (1 - k) 1000000)\n  let f = if k % 2 = 0 then -1.0 else 1.0\n  f * res\n  \nlet series (k: int) (nb: int): float =\n  let mutable res: double = 0.0\n  if k > 0 then\n    if k % 2 = 0 then\n      let a = Math.Pow(2.0, (double (k - 1)))\n      let b = Math.Pow(Math.PI, (double k))\n      let c = Math.Abs(bernoulli k)\n      let d = double (fact k)\n      res <- a * b * c \/ d\n    else\n      res <- zeta k nb\n  else\n    res <- bernoulli (1 - k) \/ (double (1 - k))\n    if k % 2 = 0 then\n      res <- res\n    else \n      res <- -1.0 * res\n  (float res)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86576,"user_id":null,"body":"let flip f x y = f y x\n\nlet B n = \n  let bs = [(-1.\/2.);(1.\/6.);(-1.\/30.);(1.\/42.);(-1.\/30.);(5.\/66.);(-691.\/2730.);(7.\/6.);(-3617.\/510.);(43867.\/798.);(-174611.\/330.);(854513.\/138.);(-236364091.\/2730.);(8553103.\/6.);(-23749461029.\/870.);(8615841276005.\/14322.);(-7709321041217.\/510.);(2577687858367.\/6.);(-26315271553053477373.\/1919190.);(2929993913841559.\/6.);(-261082718496449122051.\/13530.);]\n  if n = 0 then 1.\n  elif n = 1 then (-1.\/2.)\n  elif n % 2 = 1 then 0.\n  else List.item (n\/2) bs\n\nlet factorial (n: int) =\n    let rec loop (i: bigint) (acc: bigint) =\n        match i with\n        | i when i.IsOne  -> acc\n        | _ -> loop (i-1I) (acc * i)\n    loop (bigint n) 1I\n\nlet series (n: int) (nb: int): float =\n    let pi: float = 3.14159265358979\n    match n with\n    | n when n < -1 ->\n      (-1. * (float -n % 2.)) * B(-n + 1) \/ (float -n + 1.)\n    | n when n % 2 = 0 ->\n      0.5 * abs (B(n)) * pown (2. * pi) n \/ float (factorial n)\n    | n when n % 2 = 1 ->\n      Seq.sumBy (flip pown -n << float) { 1..nb }\n    | _ -> \n      failwith \"function is not defined for these values\" ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86577,"user_id":168,"body":"let fact n = { 1.0 .. float n } |> Seq.fold ( * ) 1.0\nlet bernoulli = [| 1.0; -0.5; 0.16666666666666666; 0.0; -0.03333333333333333; 0.0; 0.023809523809523808; 0.0; -0.03333333333333333; 0.0; 0.07575757575757576; 0.0; -0.2531135531135531; 0.0; 1.1666666666666667; 0.0; -7.092156862745098; 0.0; 54.971177944862156; 0.0; -529.1242424242424; 0.0; 6192.123188405797; 0.0; -86580.25311355312; 0.0; 1425517.1666666667; 0.0; -27298231.067816094; 0.0; 601580873.9006424 |]\n\nlet series (k: int) (nb: int): float =\n  let pi: float = 3.14159265358979\n  match k with\n  | _ when k < 0 -> bernoulli.[1 - k] \/ float (1 - k) * if k % 2 = 0 then 1.0 else -1.0\n  | _ when k >= 2 && k % 2 = 0 -> 0.5 * abs bernoulli.[k] * (2.0 * pi) ** float k \/ fact k\n  | _ -> seq { for n in 1.0 .. float nb -> 1.0 \/ n ** float k} |> Seq.sum\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86578,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet C (n: int) (k: int) =\n    let firstMult = {2..n} |> Seq.fold (fun acc x -> acc * (double)x) 1.0\n    let secondMult = {2..k} |> Seq.fold (fun acc x -> acc \/ (double)x) firstMult\n    let thirdMult = {2..(n - k)} |> Seq.fold (fun acc x -> acc \/ (double)x) secondMult\n    thirdMult\n\nlet getBernulli (k: int) =\n    let dict = new Dictionary<int,double>()\n    let rec bernulliGetter (k: int) = \n      if (k = 0) then\n        1.0\n      else if (k = 1) then\n        -0.5\n      else if (k = 2) then\n        1.0 \/ 6.0\n      else if (k = 26) then\n        1425517.16666667\n      else if (k = 28) then\n        -27298231.067816092\n      else if (k = 30) then\n        601580873.90064236\n      else if (k = 1) then\n        -0.5\n      else if (k % 2 = 1) then\n        0.0\n      else if (dict.ContainsKey(k)) then   \n        dict.[k]\n      else\n        let mult = -1.0 \/ (double)(k + 1)\n        let secondMult = {1..k} |> Seq.map (fun x -> (C (k + 1) (x + 1)) * (bernulliGetter (k - x))) |>\n                         Seq.reduce (fun acc x -> acc + x)\n        let bernulliNumb = mult * secondMult\n        dict.Add(k, bernulliNumb)\n        bernulliNumb\n    bernulliGetter k\n\nlet series (k: int) (nb: int): float =\n    let pi: float = 3.14159265358979\n    if (k > 2 && k % 2 = 1) then\n      {1..nb} |> Seq.map (fun x -> 1.0 \/ ((double)x ** (double)k)) |>\n      Seq.reduce (fun acc x -> acc + x)\n    else if (k >= 2 && k % 2 = 0) then\n      let secMult = {1..k} |> Seq.fold (fun acc x -> acc * 2. * pi \/ (double)x) 1.0\n      let bernulli = (getBernulli k) |> abs\n      (bernulli * secMult) \/ 2.0\n    else if (k < -1) then\n      let fmult = -1.0 ** (float)k\n      let bernulli = getBernulli ((abs k) + 1)\n      fmult * bernulli \/ ((float)((abs k) + 1))\n    else\n      -1.0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a03b3f6a1c9040084001765":[{"id":86579,"user_id":527,"body":"let angle n = 180 * (n - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86580,"user_id":645,"body":"let angle n = (n - 2) * 180","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86581,"user_id":null,"body":"let angle = (+)(-2) >> (*) 180","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86582,"user_id":null,"body":"let angle n = (2 * n - 4) * 90","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86583,"user_id":null,"body":"let rec angle n =\n     if n = 2 then 0 else 180 + angle(n - 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86584,"user_id":null,"body":"let angle n = 180 * n - 360","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86585,"user_id":null,"body":"open System;\n\nlet angle n =\n    let f = float n\n    f * (180.0 - (360.0 \/ f)) |> Math.Round |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86586,"user_id":null,"body":"let angle n =\n    2\n    |>  (-) n\n    |> (*) 180","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86587,"user_id":527,"body":"let angle (n: int) : int = 180 * (n - 2)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a045fee46d843effa000070":[{"id":86588,"user_id":null,"body":"let sieveOfEratosthenes n =\n    let input = Array.init<int> (n-1) (fun x -> 2+x)\n    let rec findNextIndex index (input:int[]) =\n        if index > input.Length-1 then input.Length\n        elif input.[index] <> -1 then index\n        else findNextIndex (index + 1) input\n    \n    let rec loop (input:int[]) lastIndex =\n        if lastIndex >= input.Length then input |> Array.filter(fun x -> x <> -1)\n        else\n            let p = input.[lastIndex]\n            let startIndex = (pown p 2) - 2(*offset 0,1*)\n            for i in startIndex..p..input.Length-1 do\n                if input.[i] % p = 0 then input.[i] <- -1\n            loop input (input |> findNextIndex (lastIndex+1))\n            \n    loop input 0\n    \nlet rec findDegree n div acc =\n    if n = 0 then acc\n    else\n        let result = n\/div\n        findDegree result div (acc+result)\n    \nlet decomp n =\n    sieveOfEratosthenes n\n    |> Array.fold(fun state input ->\n        match findDegree n input 0 with\n        | degree when degree = 1 && state=\"\" -> sprintf \"%i\" input\n        | degree when degree = 1 -> sprintf \"%s * %i\" state input\n        | degree when state=\"\" -> sprintf \"%i^%i\" input degree\n        | degree -> sprintf \"%s * %i^%i\" state input degree\n     ) \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86589,"user_id":491,"body":"let decomp n =\n    let factorize =\n        let rec factorize' factors n =\n            match n with\n            | 1 -> factors\n            | n ->\n                match [2..(int(sqrt(float(n))))] |> List.tryFind (fun p -> n % p = 0) with\n                | Some p -> factorize' (factors @ [p]) (n \/ p)\n                | None -> factors @ [n]\n        factorize' []\n    [2..n]\n    |> List.map factorize\n    |> List.concat\n    |> List.countBy id\n    |> List.map (fun (p, e) -> if e > 1 then sprintf \"%d^%d\" p e else sprintf \"%d\" p)\n    |> String.concat \" * \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86590,"user_id":null,"body":"let decomp (n: int) =\n    let primes =\n        let rec nextPrime n p primes =\n            if primes |> Map.containsKey n then\n                nextPrime (n + p) p primes\n            else\n                primes.Add(n, p)\n\n        let rec prime n primes =\n            seq {\n                if primes |> Map.containsKey n then\n                    let p = primes.Item n\n                    yield! prime (n + 1) (nextPrime (n + p) p (primes.Remove n))\n                else\n                    yield n\n                    yield! prime (n + 1) (primes.Add(n * n, n))\n            }\n\n        prime 2 Map.empty\n\n    let rec div arr i c =\n        match arr |> Array.tryFindIndex (fun a -> a % i = 0) with\n        | None -> \n          c\n        | Some (idx) ->\n            arr.[idx] <- arr.[idx] \/ i\n            div arr i (c + 1)\n\n    let ps = primes |> Seq.takeWhile ((>=) n)\n    let fac = [| 2..n |]\n    ps\n    |> Seq.map (fun p -> p, (div fac p 0))\n    |> Seq.choose (fun (p, q) ->\n        if q > 1 then Some(sprintf \"%d^%d\" p q)\n        elif q = 1 then Some(sprintf \"%d\" p)\n        else None)\n    |> String.concat \" * \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86591,"user_id":null,"body":"let rec f n x a =\n    if x = n then x :: a\n    elif n % x = 0 then f (n \/ x) x (x :: a)\n    else f n (x + 1) a\n\nlet factorise n = f n 2 []\n\nlet decomp n =\n    let space = [ 2 .. n ]\n\n    let rec factors elements solution =\n        match elements with\n        | h :: t -> factors t (factorise h @ solution)\n        | [] -> solution\n\n    factors space []\n    |> List.sort\n    |> List.groupBy id\n    |> List.map (fun (x, y) ->\n        if y.Length = 1 then\n            sprintf \"%d\" x\n        else\n            sprintf \"%d^%d\" x y.Length)\n    |> String.concat \" * \"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86592,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet isPrime (primes) (num: int):bool = \n  let divisors = primes |> Seq.filter (fun d -> (num % d = 0)) |> Seq.toList\n  (divisors.Length = 0)\n  \nlet rec primePower (num: int) (prime: int) (power: int): int =\n  if (num % prime = 0) then (primePower (num\/prime) prime (power+1))\n  else power\n  \nlet factorToString (kv: KeyValuePair<int,int>):string = \n  if (kv.Value = 0) then \"\"\n  else if (kv.Value = 1) then kv.Key.ToString()\n  else kv.Key.ToString() + \"^\" + kv.Value.ToString()\n\nlet decomp n =\n  \/\/ Factors: all the primes from 2 to n included\n  let factors = Dictionary<int, int>()\n  factors.Add(2, 0)\n  for num in [3..n] do\n    if (isPrime factors.Keys num) then\n      factors.Add(num, 0)\n  \/\/ Add to the factors for each number between 2 and n\n  let primes = factors.Keys |> Seq.toList\n  for num in [2..n] do\n    let mutable numTemp = num\n    for prime in primes do\n      if (prime <= numTemp) then\n        let power = primePower numTemp prime 0\n        if (power > 0) then\n          numTemp <- (numTemp \/ prime)\n          factors.[prime] <- factors.[prime] + power\n  \/\/ Create the string of the result\n  let result = factors |> Seq.map factorToString |> String.concat \" * \"\n  result\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86593,"user_id":168,"body":"let isPrime n =\n  seq { for i in 2 .. n |> float |> sqrt |> int -> n % i > 0 }\n  |> Seq.forall id\n\nlet rec findExp p n = if n % p = 0 then 1 + findExp p (n \/ p) else 0\n\nlet findExpFact p n =\n  { p .. n }\n  |> Seq.map (findExp p)\n  |> Seq.sum\n\nlet decomp n =\n  { 2 .. n }\n  |> Seq.filter isPrime\n  |> Seq.map (fun p ->\n    let e = findExpFact p n\n    if e > 1 then sprintf \"%d^%d\" p e else string p)\n  |> String.concat \" * \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86594,"user_id":null,"body":"let decomp n =\n    let intSqrt i = int (sqrt (float i))\n\n    let isPrime m =\n        [ 2 .. intSqrt m ]\n        |> Seq.forall (fun g -> m % g <> 0)\n\n    let primes =\n        [ 2 .. n ] |> Seq.filter isPrime |> Seq.toArray\n\n    let rec factorize (m: int) p =\n        if m = 1 then\n            [ m ]\n        else\n            let pr = p |> Seq.skipWhile (fun g -> m % g <> 0)\n            let d = Seq.head pr\n            factorize (m \/ d) pr @ [ d ]\n\n    let t =\n        [ 1 .. n ]\n        |> Seq.map (fun g -> factorize g primes)\n        |> Seq.concat\n        |> Seq.groupBy id\n        |> Seq.tail\n        |> Seq.map (fun (g, col) -> (g, col |> Seq.length))\n        |> Seq.map (fun (g, cnt) -> if cnt = 1 then g.ToString() else g.ToString() + \"^\" + cnt.ToString())\n\n    System.String.Join(\" * \", t)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86595,"user_id":null,"body":"open System\n\nlet primes =\n  let nextPossiblePrimeDivisor n =\n    function \n    | 2 -> 3\n    | d ->\n        if float d > Math.Sqrt(float n)\n        then n \n        else d + 2\n  let rec loop acc d =\n    function\n    | 1 -> acc\n    | n ->\n        if n % d = 0\n        then loop (d :: acc) d (n \/ d)\n        else loop acc (nextPossiblePrimeDivisor n d) n\n  loop [] 2\n\n\nlet decomp n =\n  [1 .. n]\n  |> List.collect primes\n  |> List.countBy id\n  |> List.sortBy fst\n  |> List.map (fun (prime, power) -> if power > 1 then sprintf \"%d^%d\" prime power else sprintf \"%d\" prime)\n  |> String.concat \" * \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86596,"user_id":null,"body":"open System\nlet primes =\n    let primes = ResizeArray()\n    primes.Add 2\n\n    seq {\n        yield! primes\n        for n in { (primes |> Seq.max) .. 4000 } do\n            let isDivisible = primes |> Seq.exists (fun p -> n % p = 0)\n            match isDivisible with\n            | true ->\n                ()\n            | false ->\n                primes.Add n\n                yield n\n    }\n\nlet rec decompose n =\n    let rec g n acc =\n        match n with\n        | 1 -> acc\n        | _ ->\n            let divisor = primes |> Seq.filter (fun p -> n % p = 0) |> Seq.tryHead\n            match divisor with\n            | Some(d) ->\n                g (n \/ d) ([d] @ acc)\n            | None ->\n                [n] @ acc\n    g n []\n\nlet decomp n =\n    let orderedFactors =\n        { 2 .. n }\n        |> Seq.collect decompose\n        |> Seq.countBy id\n        |> Seq.sortBy (fun (p,_) -> p)\n        |> Seq.map (fun (p,c) ->\n            match c with\n            | 1 -> sprintf \"%i\" p\n            | _ -> sprintf \"%i^%i\" p c)\n\n    String.Join(\" * \", orderedFactors)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86597,"user_id":null,"body":"let primeFactors n =\n  let rec getFactor num pr acc =\n    if pr = num then\n      (pr::acc)\n    elif num % pr = 0 then\n      getFactor (num\/pr) pr (pr::acc)\n    else \n      getFactor num (pr+1) acc\n\n  getFactor n 2 [] \n\nlet decomp n =\n  [2..n] \n  |> Seq.collect primeFactors\n  |> Seq.countBy id\n  |> Seq.map (function (p, 1) -> string p | (p, f) -> sprintf \"%i^%i\" p f)\n  |> String.concat \" * \"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a057ec846d843c81a0000ad":[{"id":86598,"user_id":53,"body":"let cycle (n: int) =\n  if n % 2 = 0 || n % 5 = 0 then\n    -1\n  else\n    let mutable m = 10 % n\n    let mutable i = 1\n    while m > 1 do\n      m <- m * 10 % n\n      i <- i + 1\n    i","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86599,"user_id":168,"body":"let cycle (n: int) =\n  match n with\n  | _ when n % 2 = 0 || n % 5 = 0 -> -1\n  | _ -> Seq.unfold (fun p -> Some (10 * p % n, 10 * p % n)) 1\n         |> Seq.findIndex ((=) 1)\n         |> (+) 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86600,"user_id":null,"body":"open System\n\nlet rec gcd = function\n  | x, 0 -> x\n  | x, y -> gcd (y, x % y)\n\nlet coprime (x, y) = gcd (x, y) = 1\n\nlet cycle (n0: int) =\n    let mutable k = 1\n    \n    if coprime(n0,10) then\n      let mutable res = 10 % n0\n      \n      while res <> 1 do\n        res <- (10*res) % n0\n        k <- k + 1\n      k\n    else -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86601,"user_id":null,"body":"open System\n\nlet isComprie n =\n    n % 2 = 0 || n % 5 = 0\n\n\nlet rec isRepeat n =\n    if n % 5 = 0 then\n       isRepeat (n\/5)\n    elif n % 2 = 0 then\n        isRepeat (n\/2)\n    else\n       n <> 1\n\nlet rec count rest b c reminder =\n    if Set.contains rest reminder then  \n        c\n    else    \n        let n = rest * 10 \n        count (n % b) b (c + 1) (Set.add rest reminder)\n\nlet cycle (n: int) =    \n    if isComprie n then        \n        -1\n    elif isRepeat n |> not then        \n        -1\n    else\n    count 1 n 0 Set.empty","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86602,"user_id":null,"body":"open System\n\nlet rec steinGcd u v =\n    match u, v with\n    | u, v when u = v -> u\n    | 0, v -> v\n    | u, 0 -> u\n    | u, v when ((~~~u &&& 1) = 1) && ((v &&& 1) = 1) -> steinGcd (u >>> 1) v \/\/ even\/odd\n    | u, v when ((~~~u &&& 1) = 1) && ((~~~v &&& 1) = 1) -> (steinGcd (u >>> 1) (v >>> 1)) <<< 1 \/\/ even\/even\n    | u, v when ((~~~v &&& 1) = 1) -> steinGcd u (v >>> 1) \/\/ odd\/even\n    | u, v when (u > v) -> steinGcd ((u - v) >>> 1) v\n    | _ -> steinGcd ((v - u) >>> 1) u\n\nlet cycle (n: int) =\n    let areCoprime = n |> (steinGcd 10 >> (=) 1)\n    match areCoprime with\n    | false -> -1\n    | true ->\n        Seq.initInfinite ((+) 1)\n            |> Seq.filter (fun p -> ((Numerics.BigInteger.ModPow(10I, bigint p, bigint n)) = 1I))\n            |> Seq.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86603,"user_id":null,"body":"let cycle (n: int) =\n     if n % 2 = 0 || n % 5 = 0 then -1\n     else\n          let mutable r = 1\n          let mutable count = 0\n          while count = 0 || r <> 1 do\n               count <- count + 1\n               r <- (10 * r % n)\n          count\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86604,"user_id":492,"body":"let cycle (n: int) =\n    let rec cycleaux (v: int) (i: int) =\n        let vv = (v * 10) % n\n        if (vv = 1) then i\n        else (cycleaux vv (i + 1))\n    if(( n % 2 = 0) || (n % 5 = 0)) then -1\n    else (cycleaux 1 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a1a76c8a7ad6aa26a0007a0":[{"id":86605,"user_id":null,"body":"let lifePathNumber (birthdate: string): int =\n  let mod9 = int(birthdate.Replace(\"-\", \"\")) % 9\n  if mod9 > 0 then mod9 else 9","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86606,"user_id":null,"body":"open System\n\nlet lifePathNumber (birthdate : string) : int =\n    let rec reduce num = \n            match num with\n            | x when x < 10 -> num\n            | x -> string x \n                        |> Seq.map  (string >> int)\n                        |> Seq.reduce (+)\n                        |> reduce\n\n    birthdate.Split('-')\n    |> Seq.map (int >> reduce)\n    |> String.Concat\n    |> int\n    |> reduce","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86607,"user_id":null,"body":"open System\n\nlet (|Digits|_|) s =\n    if s |> String.forall Char.IsDigit\n    then Some s\n    else None\n\nlet parseIntFromChar c = int c - int '0'\n\nlet rec reduceDigits digits =\n    let reduced =\n        digits\n        |> Seq.map parseIntFromChar\n        |> Seq.reduce (+)\n        |> string\n    if reduced.Length = 1\n    then reduced\n    else reduceDigits reduced\n\nlet splitBirthDate (x: string) = \n    match x.Split '-' with\n    | [| Digits y; Digits m; Digits d |] -> [y; m; d]\n    | _ -> failwithf \"bad birthdate format\"\n\nlet lifePathNumber (birthdate: string) : int =\n    let parts = splitBirthDate birthdate\n    parts\n    |> Seq.map reduceDigits\n    |> String.concat \"\"\n    |> reduceDigits\n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86608,"user_id":null,"body":"let lifePathNumber (birthdate : string) : int =\n  let rec digitalRoot x =\n    if x < 10 then\n      x\n    else\n      x\n      |> string\n      |> Seq.sumBy (string >> int)\n      |> digitalRoot\n  birthdate\n  |> Seq.filter (fun d -> '0' <= d && d <= '9')\n  |> System.String.Concat\n  |> int\n  |> digitalRoot","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86609,"user_id":null,"body":"let rec numberToDigit(number: int): int = \n  if number < 10 then number\n  else number |> string |> Seq.toList |> List.map string |> List.map int |> List.sum |> numberToDigit\n\nlet lifePathNumber (birthdate : string) : int =\n    birthdate.Split '-' |> List.ofArray |> List.map int |> List.map numberToDigit |> List.sum |> numberToDigit\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86610,"user_id":168,"body":"let lifePathNumber (birthdate : string) : int =\n  (int (birthdate.Replace(\"-\", \"\")) - 1) % 9 + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86611,"user_id":null,"body":"open System\nlet intToDigits (s:string) =\n    let a = Seq.toList s |> List.map(Convert.ToString) |> List.map(Convert.ToInt32)\n    a\n\nlet rec lifePathNumber (birthdate : string) : int =\n    let split = birthdate.Split('-') |> Seq.toList |> List.reduce(+)\n    let intArr = intToDigits split\n    let rec calc (acc:int) (arr:int list) =\n        match arr with\n        | [] -> 0\n        | h::t -> (h + acc) + (calc acc t)\n\n    let result = calc 0 intArr\n    if result > 9 then (lifePathNumber (Convert.ToString result)) else result","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86612,"user_id":null,"body":"let lifePathNumber (birthdate : string) : int =\n    let reduce n = \n        let sumDigits = n\/10 + n%10\n        sumDigits\/10 + sumDigits%10\n\n    let n1 = reduce (int birthdate.[0..0] + int birthdate.[1..1] + int birthdate.[2..2] + int birthdate.[3..3])\n    let n2 = reduce (int birthdate.[5..5] + int birthdate.[6..6])\n    let n3 = reduce (int birthdate.[8..8] + int birthdate.[9..9])\n\n    reduce (n1+n2+n3)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86613,"user_id":null,"body":"let lifePathNumber input =\n    let rec digitSum acc n=\n        if n < 10 then acc + n else digitSum (acc +  n % 10) (n \/ 10)\n    let rec reduce xs =\n        let ds = digitSum 0 xs\n        if ds < 10 then ds else reduce ds\n    \n    let date = System.DateTime.ParseExact(input, \"yyyy-MM-dd\", System.Globalization.CultureInfo.InvariantCulture)\n    let y' = reduce date.Year\n    let m' = reduce date.Month\n    let d' = reduce date.Day\n\n    reduce (y' + m' + d')","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86614,"user_id":null,"body":"open System\n\nlet lifePathNumber (birthdate : string) : int=\n    \n    let sumDigits = \n        Seq.map ((string) >> Int32.Parse)\n        >> Seq.sum\n    \n    let rec foldDigits digits =\n\n        match digits |> String.length with\n        | 1 -> digits\n        | _ -> foldDigits (digits |> sumDigits |> (string))\n\n    birthdate.Split('-')\n    |> Seq.map foldDigits\n    |> String.Concat\n    |> foldDigits\n    |> (int)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a3fe3dde1ce0e8ed6000097":[{"id":86615,"user_id":null,"body":"let century_from_year year =\n  match year % 100 with\n  | 0 -> year \/ 100\n  | _ -> year \/ 100 + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86616,"user_id":null,"body":"let century_from_year year = (year - 1) \/ 100 + 1","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86617,"user_id":null,"body":"let century_from_year = float >> (fun n -> n \/ 100.0) >> ceil >> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86618,"user_id":527,"body":"let century_from_year year = (year + 99) \/ 100","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86619,"user_id":null,"body":"let century_from_year year =\n    let divideBy100 x  = x\/100.0\n    year\n        |> float\n        |> divideBy100\n        |> ceil\n        |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86620,"user_id":null,"body":"let century_from_year year = \n  match year with\n  |year when year>=1 && year<=100->Some 1\n  |year when year%100=0 -> Some (year\/100)\n  |_  -> Some (year\/100+1)\n  |> Option.defaultValue 0\n  |> int\n   \n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86621,"user_id":null,"body":"let century_from_year (year: int) =\n    (year \/ 100)\n    + (match (year % 100) with\n       | 0 -> 0\n       | _ -> 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86622,"user_id":null,"body":"let century_from_year year =\n    match (year \/ 100, year % 100) with\n        | (c, 0) -> c\n        | (c, _) -> c + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86623,"user_id":null,"body":"let century_from_year year =\n  if year % 2 = 0 then year \/ 100 \n  else year \/ 100 + 1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86624,"user_id":null,"body":"let century_from_year year = \n    let asd : int = year \/ 100\n    if (year%10>0) then \n        asd+1\n    else\n        asd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a48948e145c46820b00002f":[{"id":86625,"user_id":53,"body":"let kprimeFactorCount(x: int) =\n    let mutable n = x\n    let mutable len = 0\n    let mutable i = 2\n    while i * i <= n do\n        while n % i = 0 do\n            len <- len + 1\n            n <- n \/ i\n        i <- i + 1\n    if n > 1 then\n        len <- len + 1\n    len\n\nlet kprimesStep(k: int) (step: int) (start: int) (nd: int) =\n    seq { start .. 1 .. nd - step }\n        |>  Seq.filter (fun i -> kprimeFactorCount(i) = k && kprimeFactorCount(i + step) = k)\n        |>  Seq.map (fun i -> [i; i + step])\n        |>  Seq.toList\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86626,"user_id":null,"body":"let kprimesStep(k: int) (step: int) (m: int) (n: int) =\n    let SieveOfEratosthenes numberToCheck =\n        let numbers = Array.init (numberToCheck-1) (fun i ->i+2)\n        for i = 0 to numbers.Length-1 do\n            let ii = numbers.[i]\n            if ii > 0 then\n                let finish = (numbers.Length-i-1)\/ii in\n                for j=1 to finish do numbers.[i+j*ii] <- 0\n        numbers |> Array.filter (fun number -> number > 1)\n    let primeFactors = SieveOfEratosthenes n\n\n    let rec HasKFactors numberRemaining nFactors primeFactorIndex =\n        if nFactors > k then\n            false\n        else\n            if numberRemaining = 1 then\n                (nFactors = k)\n            else\n                let primeFactor = primeFactors.[primeFactorIndex]\n                if numberRemaining%primeFactor = 0 then \n                    HasKFactors (numberRemaining\/primeFactor) (nFactors+1) primeFactorIndex\n                else\n                    HasKFactors numberRemaining nFactors (primeFactorIndex+1)\n    let hasKFactors = Array.init (n-m+1) (fun i -> HasKFactors (m+i) 0 0)\n\n    [ for i=0 to hasKFactors.Length-step-1 do if hasKFactors.[i] && hasKFactors.[i+step] then yield [m+i; m+i+step] ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86627,"user_id":null,"body":"open System\n\nlet kprimesStep(k: int) (step: int) (m: int) (n: int) =\n  if (k * k * k >= n) then\n    []\n  else\n    let checker (k: int) (num: int): bool =\n      let isPrime (num: int) =\n          let rec getDivs (num: int) (div: int) =\n              match div with\n              |div when div * div > num -> true\n              |div when num % div = 0 -> false\n              |_ -> (getDivs num (div + 1))\n          (getDivs num 2)\n  \n      let rec counter (num: int) (k: int) (ind: int): bool =\n          match num with\n          | num when k < 0           -> false\n          | 1                        -> (k = 0)\n          | num when (num % ind) = 0 -> (counter (num \/ ind) (k - 1) ind)\n          | num when (isPrime num)   -> (k = 1)\n          | _                        -> (counter num k (ind + 1))\n          \n      (counter num k 2)\n      \n    [(m + step)..n] |> List.map (fun x -> [x - step; x]) |>\n    List.filter (fun [a; b] -> (checker k a) && (checker k b)) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86628,"user_id":492,"body":"let nbfactors n = \n    let rec loop n fac acc =\n        if n < (fac * fac) then (acc + 1)\n        elif n % fac = 0 then loop (n \/ fac) fac (acc + 1)\n        else loop n (fac + 1) acc\n    loop n 2 0\nlet kprimesStep(k: int) (step: int) (m: int) (n: int) =\n  let rec aux p acc = \n    match p with \n      | x when (x > n - step) -> acc\n      | _ ->\n        if (nbfactors p = k) && (nbfactors (p + step) = k) then\n          aux (p + 1) ([p; p + step] :: acc)\n        else aux (p + 1) acc\n  in \n    let res = aux m [] in\n      match res with\n        | x when x = [] -> []\n        | _ -> res |> List.rev\n       \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86629,"user_id":492,"body":"let nbfactors n = \n    let rec loop n fac acc =\n        if n < (fac * fac) then (acc + 1)\n        elif n % fac = 0 then loop (n \/ fac) fac (acc + 1)\n        else loop n (fac + 1) acc\n    loop n 2 0\nlet kprimesStep(k: int) (step: int) (m: int) (n: int) =\n  let rec aux p acc = \n    match p with \n      | x when (x > n - step) -> acc\n      | _ ->\n        if (nbfactors p = k) && (nbfactors (p + step) = k) then\n          aux (p + 1) ([p; p + step] :: acc)\n        else aux (p + 1) acc\n  in \n    let res = aux m [] in\n      match res with\n        | x when x = [] -> []\n        | _ -> res |> List.rev\n       \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a58d889880385c2f40000aa":[{"id":86630,"user_id":null,"body":"open System\n\nlet automorphic (n : int) : string =\n    if (n * n).ToString().EndsWith(n.ToString()) then\n      \"Automorphic\"\n    else\n      \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86631,"user_id":null,"body":"let automorphic (n : int) : string =\n    match (string <| n * n).EndsWith(string n) with\n    | true -> \"Automorphic\"\n    | false -> \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86632,"user_id":null,"body":"let automorphic (n : int) : string =\n        let square = (string) (n*n)\n        let num = (string) n\n        let numLength = num.Length\n        let auto = \n            let ending =\n                square                \n                |> Seq.rev\n                |> Seq.take numLength\n                |> Seq.rev\n                |> Seq.toArray\n                |> System.String\n            ending = num\n        if auto then \"Automorphic\" else \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86633,"user_id":53,"body":"let automorphic (k : int) : string =\n    let mutable m = k * k\n    let mutable n = k\n    let mutable b = 0\n    while n > 0 && b = 0 do\n      if n%10 <> m%10 then\n        b <- 1\n      else\n        n <- n \/ 10\n        m <- m \/ 10\n    if b = 1 then\n      \"Not!!\"\n    else\n      \"Automorphic\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86634,"user_id":null,"body":"open System\n\nlet automorphic (n : int) : string =\n    let x =\n        float n ** 2.\n        |> Convert.ToString\n        |> Seq.rev\n        |> Seq.take (n.ToString().Length)\n        |> Seq.rev\n        |> Seq.toArray\n        |> String\n        |> int\n    if x = n then \"Automorphic\"\n    else \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86635,"user_id":null,"body":"let automorphic (n : int) : string =\n  let sn = string n\n  let ss = n * n |> string\n  if ss.[ss.Length-sn.Length..] = sn \n    then \"Automorphic\" \n    else \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86636,"user_id":null,"body":"let automorphic (n: int): string =\n  let sq = pown n 2\n  match sq.ToString().EndsWith(n.ToString()) with\n    | true -> \"Automorphic\"\n    | false -> \"Not!!\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86637,"user_id":null,"body":"let automorphic (n : int) : string =\n    \"your code goes here\"\n    let s = string n\n    match s with\n    | s when string(n * n).Contains(s) -> \"Automorphic\"\n    | _ -> \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86638,"user_id":null,"body":"let automorphic (n : int) : string = \n    let rec ModValueLoop num modValue = if modValue >= num then modValue else ModValueLoop num (modValue*10)\n    match  (n*n-n)%(ModValueLoop n 1) = 0 with | true -> \"Automorphic\" | false -> \"Not!!\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86639,"user_id":null,"body":"let automorphic (n : int) : string = \n    \n    let nDigits = (string) n\n    \n    let squareDigits = \n        n * n\n        |> (string)\n        |> fun a -> a.[a.Length - (nDigits.Length)..]\n\n    match nDigits = squareDigits with\n    | true -> \"Automorphic\"\n    | false -> \"Not!!\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a662a02e626c54e87000123":[{"id":86640,"user_id":527,"body":"let extraPerfect n = [1..2..n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86641,"user_id":null,"body":"let extraPerfect n = seq { 1 .. 2 .. n } |> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86642,"user_id":null,"body":"let genBinaryDigit = function\n    | 0 -> None\n    | n -> Some (n % 2, n \/ 2)\n    \nlet toBinarySeq = Seq.unfold genBinaryDigit\n\nlet isExtraPerfect n =\n    let bits = toBinarySeq n\n    Seq.head bits = 1 && Seq.last bits = 1\n    \nlet extraPerfect n = List.filter isExtraPerfect [1 .. n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86643,"user_id":null,"body":"let extraPerfect n =\n      [1 .. n] |> List.filter (fun x -> System.Convert.ToString(x, 2) |> Seq.head = '1'\n                                     && System.Convert.ToString(x, 2) |> Seq.last = '1')","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86644,"user_id":491,"body":"let extraPerfect n =\n  [1..n] |> List.filter (fun n -> let n' = System.Convert.ToString(n, 2) in Seq.head n' = '1' && Seq.last n' = '1')","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86645,"user_id":53,"body":"let extraPerfect n =\n  [1..n] \n    |> List.filter (fun e -> e % 2 <> 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86646,"user_id":null,"body":"let extraPerfect n = List.filter (fun x -> x % 2 = 1) [1..n]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86647,"user_id":null,"body":"let extraPerfect n = [for i in 0..(n-1)\/2 -> i*2+1]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86648,"user_id":null,"body":"let extraPerfect n =\n  Seq.toList (seq { for i in 1 .. 2 .. n -> i })","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86649,"user_id":492,"body":"open System.Linq\nopen System.Collections.Generic\nlet extraPerfect n = \n  (Enumerable.Range (1, n)).Where (fun x -> x % 2 <> 0) |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5a7893ef0025e9eb50000013":[{"id":86650,"user_id":null,"body":"let maxGap (arr : int list) : int =\n  arr \n  |> List.sort\n  |> List.pairwise \n  |> List.map (fun (a,b) -> b-a) \n  |> List.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86651,"user_id":null,"body":"let maxGap (arr : int list) : int =\n    arr\n    |> Seq.sort\n    |> Seq.pairwise\n    |> Seq.map (fun (x, y) -> y - x)\n    |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86652,"user_id":null,"body":"let abs x = if x >= 0 then x else -x\n\nlet maxGap (arr : int list) : int =\n    arr |> Seq.sort\n        |> Seq.pairwise\n        |> Seq.map (fun (a, b) -> abs (a - b))\n        |> Seq.max\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86653,"user_id":null,"body":"let rec findGap (greatest: int) (prev: int) (arr: int list) =\n  match (arr |> List.sort) with\n    | [] -> greatest\n    | head::tail when (head - prev) > greatest -> findGap (head - prev) head tail\n    | head::tail -> findGap greatest head tail\n\nlet maxGap (arr : int list) : int =\n    findGap 0 arr.[0] arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86654,"user_id":null,"body":"let rec foo arr el2 maxGapPair maxGap =\n    match arr with\n    | [] -> maxGap\n    | head::tail ->\n        let testGap = head - el2 \n            \n        if testGap > maxGap then \n            foo tail head (head, el2) testGap\n        else\n            foo tail head maxGapPair maxGap\n            \n\nlet maxGap (arr : int list) : int =\n    let sortedList = arr |> List.sort\n    let head, tail = sortedList |> List.splitAt 1\n    foo tail head.[0] (0 , 0) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86655,"user_id":null,"body":"let rec foo arr el2 maxGapPair maxGap =\n    match arr with\n    | [] -> maxGap\n    | head::tail ->\n        let testGap =\n            if head > el2 then\n                head - el2\n            else\n                el2 - head \n            \n        if testGap > maxGap then \n            foo tail head (head, el2) testGap\n        else\n            foo tail head maxGapPair maxGap\n            \n\nlet maxGap (arr : int list) : int =\n    let sortedList = arr |> List.sort\n    let head, tail = sortedList |> List.splitAt 1\n    foo tail head.[0] (0 , 0) 0 ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86656,"user_id":null,"body":"type GapData = { previous: int; maxGapSize: int }\n\nlet maxGap (l: int list): int =\n    match List.sort l with\n    | first :: rest ->\n        let gaps =\n            List.fold (fun gapData current ->\n                { gapData with\n                      previous = current\n                      maxGapSize = max (current - gapData.previous) gapData.maxGapSize })\n                ({ GapData.previous = first\n                   GapData.maxGapSize = 0 }) rest\n\n        gaps.maxGapSize\n    | _ -> 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86657,"user_id":527,"body":"let maxGap = Seq.sortBy (~-) >> Seq.pairwise >> Seq.map ((<||) (-)) >> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86658,"user_id":527,"body":"let maxGap (xs : int list) : int =\n  xs |> Seq.sort |> Seq.pairwise |> Seq.map (fun (x, y) -> y - x) |> Seq.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86659,"user_id":491,"body":"let maxGap (arr : int list) : int =\n    arr\n    |> List.sort\n    |> List.fold (fun (p, m) c -> c, max (c - p) m) (List.min arr, 0)\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5aa1bcda373c2eb596000112":[{"id":86660,"user_id":null,"body":"let maxTriSum (nums: List<int>) =\n  nums\n  |>List.distinct\n  |>List.sort \n  |>List.rev\n  |>List.take 3\n  |>List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86661,"user_id":null,"body":"let maxTriSum =\n  Seq.distinct\n  >> Seq.sortDescending\n  >> Seq.take 3\n  >> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86662,"user_id":null,"body":"let maxTriSum (nums: List<int>) =\n    nums\n    |> List.sort\n    |> List.distinct\n    |> List.rev\n    |> List.take 3\n    |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86663,"user_id":null,"body":"let maxTriSum (nums: List<int>) =\n  (nums |> List.distinct |> List.sortDescending).[..2]\n  |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86664,"user_id":null,"body":"let maxTriSum (nums: List<int>) =\n  nums |> Seq.distinct |> Seq.sortDescending |> Seq.take 3 |> Seq.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86665,"user_id":null,"body":"let maxTriSum (nums: int list) = \n        nums \n        |> List.distinct \n        |> List.sortByDescending(fun x -> x) \n        |> List.take 3 \n        |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86666,"user_id":null,"body":"\nlet maxTriSum (nums: List<int>) =\n    nums |> List.distinct |> List.sortDescending |> List.take 3 |> List.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86667,"user_id":null,"body":"let maxTriSum (nums: List<int>) = List.distinct nums |> List.sortDescending |> List.take 3 |> List.sum\n  \/\/ code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86668,"user_id":null,"body":"let maxTriSum (nums: int list) = (nums |> List.distinct |> List.sortDescending).[0..2] |> List.sum","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86669,"user_id":null,"body":"let maxTriSum (nums: List<int>) =\n    nums \n    |> Seq.distinct\n    |> Seq.sortDescending\n    |> Seq.take 3\n    |> Seq.sum  \/\/ code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5aba780a6a176b029800041c":[{"id":86670,"user_id":645,"body":"let maxMultiple d b = b - b % d","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86671,"user_id":null,"body":"let rec maxMultiple d b =\n    if b % d = 0 then b\n    else maxMultiple d (b-1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86672,"user_id":null,"body":"let rec getMaxMultiple d b =\n    match (b % d = 0) with\n    | true -> b\n    | false -> getMaxMultiple d (b - 1)\n\nlet maxMultiple d b = getMaxMultiple d b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86673,"user_id":null,"body":"let maxMultiple d b =\n    [ b .. -1 .. 1 ] |> List.find (fun x -> x % d = 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86674,"user_id":null,"body":"let maxMultiple d b =\n  (0, [2..b])\n  ||> List.fold (fun acc x -> if x % d = 0 then x else acc)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86675,"user_id":null,"body":"let maxMultiple d b =\n    [1..b]\n    |> List.filter (fun e -> e % d = 0)\n    |> List.max\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86676,"user_id":null,"body":"let maxMultiple d b =\n  seq {for i in b .. -1 .. 1 do if i % d = 0 then yield i} |> Seq.head\n    \/\/ your code here","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86677,"user_id":null,"body":"let maxMultiple d b =\n    let rec values d b =\n        match (b % d = 0) with\n        | true -> b\n        | false -> values d (b - 1)        \n    values d b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86678,"user_id":null,"body":"let maxMultiple divisor bound =\n    let mutable n = divisor\n    while n + divisor <= bound do\n      n <- (n + divisor)\n    n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86679,"user_id":null,"body":"let maxMultiple d b =\n        [1..b]\n        |> List.where(fun n -> n%d = 0)\n        |> List.last","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5ac6932b2f317b96980000ca":[{"id":86680,"user_id":null,"body":"open System\n\nlet FormMin (digits : int seq) =\n  digits\n  |> Seq.sort\n  |> Seq.distinct\n  |> Seq.fold (fun x y -> x * 10 + y) 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86681,"user_id":null,"body":"open System\n\nlet FormMin = List.distinct >> List.sort >> List.fold (fun total digit -> total * 10 + digit) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86682,"user_id":null,"body":"let FormMin : int list -> int =\n    List.distinct\n    >> List.sort\n    >> List.map string\n    >> List.reduce (+)\n    >> int\n\nopen System","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86683,"user_id":null,"body":"open System\n\nlet FormMin : int list -> int =\n  List.distinct\n  >> List.sort\n  >> String.Concat\n  >> Int32.Parse\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86684,"user_id":null,"body":"open System\n\nlet FormMin (arr : List<int>) = \/\/ solution here\n  arr\n  |> Seq.distinct\n  |> Seq.sort \n  |> String.Concat\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86685,"user_id":null,"body":"open System\nlet FormMin (arr : List<int>) = arr |> List.distinct |> List.sort |> List.fold (fun s x -> (s.ToString() + x.ToString()) |> int) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86686,"user_id":null,"body":"open System\n\nlet FormMin (arr : List<int>) = Set.ofList arr |> \n                                Seq.sort |>\n                                Seq.reduce (fun acc x -> acc * 10 + x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86687,"user_id":null,"body":"let FormMin (arr: List<int>) =\n  arr |> List.distinct |> List.sort |> List.map string |> String.concat \"\" |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86688,"user_id":null,"body":"open System\n\nlet FormMin (arr:List<int>) = \n    arr |> List.sort\n        |> List.distinct\n        |> List.map string\n        |> String.concat \"\"\n        |> System.Convert.ToInt32","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86689,"user_id":null,"body":"open System\n\nlet FormMin (arr : list<int>) = \/\/ solution here\n  arr\n  |>List.groupBy id\n  |>List.map fst\n  |>List.sort\n  |>List.map (fun e->e.ToString())\n  |>String.concat \"\"\n  |>int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5ae62fcf252e66d44d00008e":[{"id":86690,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n    [a + b + c; (a + b) * c; a * (b + c); a * b * c] |> List.max","lang_id":20,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86691,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n    match (a,b,c) with\n    | 1, 1, 1 | 1, _, 1 -> a+b+c\n    | 1, 1, _ | 1, _, _ -> (a+b)*c\n    | _, 1, 1 | _, _, 1 -> a*(b+c)\n    | _, 1, _ -> if(a>c) then a*(b+c) else (a+b)*c\n    | _ -> a*b*c","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86692,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n    (max (a+b+c) (a*b*c), max ((a+b)*c) (a*(b+c))) ||> max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86693,"user_id":null,"body":"let expression_matter a b c = [| a * b * c; a + b + c; (a + b) * c; a * (b + c)|] |> Array.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86694,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n  let results = [a * (b + c) ; a * b * c ; (a + b) * c ; a + b + c]\n  List.max results","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86695,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n  [(+) a b |>(+) c;\n  (+) a b |>(*) c;\n  (*) a b |>(+) c;\n  (*) a b |>(*) c;\n  (*) a<|  (+) c b;\n  (*) a<|  (*) c b;\n  (+) a<|  (*) c b] \n  |>List.max\n  \n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86696,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n    [a*(b+c) ; a*b*c ; a+b*c ; (a+b)*c; a+b+c]\n    |> List.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86697,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n    let l = [\n             (a + b) * c             \n             a * (b + c)\n             a * b * c\n             a + b + c\n             a + b * c\n             a * b + c\n             \n             ]\n    List.max l","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86698,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n    [a + b + c; a * b + c; a * (b + c);a + b * c; (a + b) * c; a * b * c]\n    |> List.max","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86699,"user_id":null,"body":"let expression_matter (a: int) (b: int) (c: int): int =\n  Array.max([|(a + b + c); (a + b) * c; a * (c + b); a * b * c|])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5aff237c578a14752d0035ae":[{"id":86700,"user_id":null,"body":"let predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int = \n    [age1; age2; age3; age4; age5; age6; age7; age8]\n    |> List.map (fun x -> x * x)\n    |> List.sum\n    |> (float >> sqrt >> int)\n    |> (fun x -> x \/ 2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86701,"user_id":571,"body":"let predictAge(a1,a2,a3,a4,a5,a6,a7,a8): int = \n    sqrt((a1*a1+a2*a2+a3*a3+a4*a4+a5*a5+a6*a6+a7*a7+a8*a8)|>float)\/2.0|> int;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86702,"user_id":null,"body":"let square n = n * n\nlet halfSqrt n = n |> float |> sqrt |> fun x -> x \/ 2. |> int\n\nlet predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int =\n    [age1; age2; age3; age4; age5 ; age6; age7; age8]\n    |> List.map square\n    |> List.sum\n    |> halfSqrt","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86703,"user_id":null,"body":"let predictAge (age1, age2, age3, age4, age5, age6, age7, age8) = \n    [ age1; age2; age3; age4; age5; age6; age7; age8 ]\n    |> List.fold (fun x y -> x + y * y) 0\n    |> float\n    |> sqrt\n    |> (*) 0.5\n    |> int\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86704,"user_id":null,"body":"let predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int = \n    [age1;age2;age3;age4;age5;age6;age7;age8] \n    |> List.fold (fun state item -> state + (item * item) ) 0 \n    |> float \n    |> sqrt \n    |> (\/) <| 2.0 \n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86705,"user_id":null,"body":"let predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int = \n    int (float (List.sumBy (fun age -> age * age) [age1; age2; age3; age4; age5; age6; age7; age8]) ** 0.5 \/ 2.0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86706,"user_id":null,"body":"let predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int = \n  [age1;age2;age3;age4;age5;age6;age7;age8]\n  |> List.map (fun e->float (e*e))\n  |> List.sum\n  |> sqrt\n  |> (\/) <|2.0\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86707,"user_id":null,"body":"let predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int = \n    ([age1; age2; age3; age4; age5; age6; age7; age8 ] \n    |> List.map (fun a -> a *a ) \n    |> List.sum \n    |> float \n    |> sqrt \n    |> int) \/ 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86708,"user_id":null,"body":"open System\nlet predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int = \n    let multiples = [age1*age1;age2*age2;age3*age3;age4*age4;age5*age5;age6*age6;age7*age7;age8*age8]\n    let sum = List.sum multiples\n    ((int)((Math.Sqrt(((float)sum)))\/2.0))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86709,"user_id":null,"body":"let predictAge(age1: int, age2: int, age3: int, age4: int, age5: int, age6: int, age7: int, age8: int): int =\n    [age1; age2; age3; age4; age5; age6; age7; age8]\n    |> List.map (fun x -> x * x)\n    |> List.sum\n    |> (float >> sqrt)\n    |> (\/) <| 2.0 \n    |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5b06c990908b7eea73000069":[{"id":86710,"user_id":17,"body":"open System\nopen System.Numerics\n\nlet f (z: Complex, eps: double) = if Complex.Abs(z) < 1.0 then int(Math.Log(eps) \/ Math.Log(Complex.Abs(z))) else -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86711,"user_id":492,"body":"open System\nopen System.Numerics\n\nlet f (z:Complex, eps: double) =\n  if (Complex.Abs(z) >= 1.0) then -1\n  else \n    (int)(Math.Log(eps) \/ Math.Log(Complex.Abs(z)));\n\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86712,"user_id":null,"body":"open System\nopen System.Numerics\n\nlet f (z:Complex, eps: double) =\n  let m = z.Magnitude \n  in\n    if m<=1.0 then int ((log eps)\/(log m))-1\n    else -1\n;;    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86713,"user_id":53,"body":"open System\nopen System.Numerics\n\nlet hypot (a: Double, b: Double) = \n  sqrt(a * a + b * b)\n\nlet f (z:Complex, eps: double) =\n  let ans = Math.Log(eps) \/ Math.Log(hypot(z.Real, z.Imaginary))\n  Math.Max(-1, int(ans))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86714,"user_id":null,"body":"open System\nopen System.Numerics\n\nlet f (z:Complex, eps: double) =\n  let rec counter (newz:Complex) (eps:double) (num:int) =\n    let modul = newz.Magnitude\n    if (modul >= 1.) then\n      -1\n    else if (modul <= eps) then\n      num\n    else\n      counter (newz * z) eps (num + 1)\n  (counter z eps 0)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86715,"user_id":168,"body":"open System\nopen System.Numerics\n\nlet f (z: Complex, eps: double) =\n  let a = Complex.Abs z in\n  if z = Complex.One then 1\n  else if a >= 1.0 then -1\n  else int (Math.Log eps \/ Math.Log a)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86716,"user_id":527,"body":"open System\nopen System.Numerics\n\nlet f (z : Complex, eps : double) =\n  if Complex.Abs(z) < 1.0 then int(Math.Log(eps, Complex.Abs(z))) else -1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86717,"user_id":527,"body":"open System\nopen System.Numerics\n\nlet f (z : Complex, eps : double) =\n  if Complex.Abs(z) < 1.0 then int(Math.Log(eps, Complex.Abs(z))) + 1 else -1\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5b0c0ec907756ffcff00006e":[{"id":86718,"user_id":17,"body":"let quadratic _ b c = -c \/ b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86719,"user_id":527,"body":"let quadratic (a : double) (b : double) (c : double) : double =\n  -c \/ b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86720,"user_id":492,"body":"open System\n\nlet quadratic(a: double) (b: double) (c: double): double =\n    let y = b * (1.0 - 2.0 * a * c \/ b \/ b)\n    \/\/ b > 0\n    let x1 = -(y + b) \/ (2.0 * a)\n    let x2 = c \/ (x1 * a)\n    let r = \n        if (Math.Abs(x1) < Math.Abs(x2)) then \n            x1\n        else \n            x2\n    r","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86721,"user_id":null,"body":"open System\n\n\nlet f a b c x = a * x * x + b * x + c \nlet df a b x = 2.0 * a * x + b \nlet rec nm a b c x =\n    let x' = x - (f a b c x) \/ (df a b x)\n    if (abs (x - x')) <= 0.000000000001 then x' else (nm a b c x')\n    \nlet quadratic(a: double) (b: double) (c: double): double =\n    nm a b c 0.05","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86722,"user_id":null,"body":"open System\n\nlet quadratic(a: double) (b: double) (c: double): double =\n  let deltaRoot = Math.Sqrt(Math.Pow(b, 2.) - 4.*a*c)\n  let root op = 2.*c \/ (op -b deltaRoot)\n    \n  (root (+), root (-))\n  |> fun (r1, r2) ->\n    if Math.Abs(r1) <  Math.Abs(r2) then r1\n    else r2  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86723,"user_id":null,"body":"open System\n\nlet quadratic(a: double) (b: double) (c: double): double =\n    - c \/ b * (1.0 + a * c \/ (4.0*b*b))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86724,"user_id":null,"body":"open System\n\nlet quadratic(a: double) (b: double) (c: double): double =\n    let x2 = -c \/ b\n    x2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5b1cd19fcd206af728000056":[{"id":86725,"user_id":492,"body":"open System\n\nlet solve(m: double): double =\n    let s = sqrt (4.0 * m + 1.0)\n    (2.0 * m + 1.0 - s) \/ (2.0 * m)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86726,"user_id":53,"body":"open System\n\nlet solve(m: double): double =\n    (2.0 * m + 1.0 - sqrt(4.0 * m + 1.0)) \/ (2.0 * m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86727,"user_id":null,"body":"open System\n\nlet solve(s: double): double =\n    (1.0 - sqrt(4.0 * s + 1.0)) \/ (2.0 * s) + 1.0;","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86728,"user_id":null,"body":"open System\n\nlet solve(m: double): double =\n    ((2. * m + 1. - sqrt (-1. * (-4. * m - 1.)))\n     \/ (2. * m))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86729,"user_id":50,"body":"open System\n\nlet solve(m: double): double = (2.0*m+1.0-(4.0*m+1.0)**0.5)\/(2.0*m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86730,"user_id":null,"body":"open System\n\nlet solve(m: double): double =\n    let a = m\n    let b = 2. * m + 1.\n    let c = m\n    let sqrtD = sqrt (b * b - 4. * a * c)\n    (b - sqrtD) \/ (2. * a)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86731,"user_id":null,"body":"let solve m = ((2. * m) - (sqrt (4. * m + 1.)) + 1.) \/ (2. * m)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86732,"user_id":1617,"body":"open System\n\nlet solve (m: double): double = (2.0 * m - System.Math.Sqrt(4.0 * m + 1.0) + 1.0) \/ (2.0 * m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86733,"user_id":null,"body":"let U x = x \/ ((1. - x) ** 2.)\nlet UInv m = ((2. * m) - (sqrt (4. * m + 1.)) + 1.) \/ (2. * m)\nlet solve(m: double): double =\n    UInv m","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86734,"user_id":null,"body":"let solve (m: double): double = \n  1. + (1. - sqrt (1. + 4. * m)) \/ (2. * m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5b40b666dfb4291ad9000049":[{"id":86735,"user_id":492,"body":"open System\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int) =\n    let aa = double(alpha) * Math.PI \/ 180.0\n    let bb = double(beta) * Math.PI \/ 180.0\n    let cc = double(gamma) * Math.PI \/ 180.0\n    let x = double(a) * Math.Cos(aa) - double(b) * Math.Sin(bb) - double(c) * Math.Cos(cc)\n    let y = double(a) * Math.Sin(aa) + double(b) * Math.Cos(bb) - double(c) * Math.Sin(cc)\n    let r = Math.Sqrt(x * x + y * y)\n    let theta = int(Math.Acos(x \/ r) * 180.0 * 3600.0 \/ Math.PI)\n    let d = theta \/ 3600\n    let mm = theta % 3600\n    let m = mm \/ 60\n    let s = mm % 60\n    [int(Math.Round(r)); d; m; s]\n    \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86736,"user_id":53,"body":"open System\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n    let u = double(alpha) * Math.PI \/ 180.0\n    let v = double(beta) * Math.PI \/ 180.0\n    let w = double(gamma) * Math.PI \/ 180.0\n    let x = double(a) * Math.Cos(u) - double(b) * Math.Sin(v) - double(c) * Math.Cos(w)\n    let y = double(a) * Math.Sin(u) + double(b) * Math.Cos(v) - double(c) * Math.Sin(w)\n    let t = Math.Atan2(y, x) * 180.0 \/ Math.PI\n    [int(Math.Round(Math.Sqrt(y*y+x*x))); int(t); int(t*60.0)%60; int(t*3600.0)%60]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86737,"user_id":168,"body":"open System\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let to_rad a = float a * (atan 1. \/ 45.)\n  let to_deg r = r * (45. \/ atan 1.)\n  let x = float a * cos (to_rad alpha) - float b * sin (to_rad beta) - float c * cos (to_rad gamma)\n  let y = float a * sin (to_rad alpha) + float b * cos (to_rad beta) - float c * sin (to_rad gamma)\n  let phi = to_deg (abs (atan2 y x))\n  let phi' = phi % 1. * 60.\n  [sqrt (x * x + y * y) + 0.5; phi; phi'; phi' % 1. * 60.]\n    |> List.map int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86738,"user_id":null,"body":"open System\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n    let Cx = (float)a * Math.Cos((float)alpha * Math.PI \/ 180.0) - \n             (float)b * Math.Sin((float)beta * Math.PI \/ 180.0) -\n             (float)c * Math.Cos((float)gamma * Math.PI \/ 180.0)\n             \n    let Cy = (float)a * Math.Sin((float)alpha * Math.PI \/ 180.0) + \n             (float)b * Math.Cos((float)beta * Math.PI \/ 180.0) -\n             (float)c * Math.Sin((float)gamma * Math.PI \/ 180.0)\n\n    let dist = sqrt(Cx * Cx + Cy * Cy)\n    \n    let angle = \n      if (Cx = 0.0) then 90.0\n      else if (Cx > 0.0) then Math.Atan(Cy \/ Cx) * 180.0 \/ Math.PI\n      else Math.Atan(Cy \/ Cx) * 180.0 \/ Math.PI + 180.0\n    \n    let minutes = (angle - Math.Truncate(angle)) * 60.0\n    \n    let seconds = (minutes - Math.Truncate(minutes)) * 60.0\n    \n    [Math.Round(dist) |> int; Math.Truncate(angle) |> int; \n      Math.Truncate(minutes) |> int; Math.Truncate(seconds) |> int]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86739,"user_id":null,"body":"open System\n\nlet x_com (v :int, theta :float) = \n  float(v) * Math.Cos(theta)\n\nlet y_com (v :int, theta :float) = \n  float(v) * Math.Sin(theta)\n\nlet deg2rad (theta : int) = \n  (3.14159265358979323846 \/180.0) * float(theta)\n\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let mutable out = []\n  let mutable temp = []\n  temp <- temp @ [((x_com(a,deg2rad(alpha))),(y_com(a,deg2rad(alpha))))]\n  temp <- temp @ [((x_com(b,deg2rad(beta + 90))),(y_com(b,deg2rad(beta + 90))))]\n  temp <- temp @ [((x_com(c,deg2rad(gamma + 180))),(y_com(c,deg2rad(gamma + 180))))]\n  \n  let xy = ((temp |> List.sumBy (fun x -> fst x)), (temp |> List.sumBy (fun x -> snd x)))\n  \n  out <- [int(Math.Round((sqrt(((fst xy)**2.0) + ((snd xy)**2.0))),0))]\n  \n  let mutable deg = ((Math.Acos((fst xy)\/sqrt(((fst xy)**2.0) + ((snd xy)**2.0)))) * (180.0\/3.14159265358979323846))\n  out <- out @ [int(deg)]\n  deg <- (deg % 1.0) * 60.0\n  out <- out @ [int(deg)]\n  deg <- (deg % 1.0) * 60.0\n  out <- out @ [int(deg)]\n  \n  out","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86740,"user_id":1617,"body":"let solve (a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n    let C l a =\n        let dl = double l\n        let da = double a * System.Math.PI \/ 180.0\n        (dl * cos da, dl * sin da)\n\n    let (ax, ay) = C a alpha\n    let (bx, by) = C b beta\n    let (cx, cy) = C c gamma\n    let ams = (atan2 (ay - cy + bx) (ax - cx - by)) * 180.0 * 3600.0 \/ System.Math.PI\n    [ int (round (sqrt (double (a * a + b * b + c * c) - 2.0 * ((ax - cx) * by + ax * cx - (ay - cy) * bx + ay * cy))))\n      int (ams \/ 3600.0)\n      int ((ams \/ 60.0) % 60.0)\n      int (ams % 60.0) ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86741,"user_id":1617,"body":"\nlet solve (a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n    let C l f a = double l * f (double a * System.Math.PI \/ 180.0)\n    let ax = C a cos alpha\n    let ay = C a sin alpha\n    let bx = C b cos beta\n    let by = C b sin beta\n    let cx = C c cos gamma\n    let cy = C c sin gamma\n\n    let ca = (atan2 (ay - cy + bx) (ax - cx - by)) * 180.0 \/ System.Math.PI\n    let d = ca * 60.0\n    let m = int (d % 60.0)\n    let s = int ((d % 60.0 - double m) * 60.0)\n\n    [ int (round (sqrt (double (a * a + b * b + c * c) - 2.0 * ((ax - cx) * by + ax * cx - (ay - cy) * bx + ay * cy))))\n      int (d \/ 60.0)\n      int (d % 60.0)\n      s ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86742,"user_id":1617,"body":"\nlet solve (a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n    let dtr (deg: double): double = double deg * System.Math.PI \/ 180.0\n    let rtd (rad: double): double = rad * 180.0 \/ System.Math.PI\n\n    let cos' (a: int): double =\n        a\n        |> double\n        |> dtr\n        |> cos\n    let sin' (a: int): double =\n        a\n        |> double\n        |> dtr\n        |> sin\n\n    let cos'' (a: double): double =\n        a\n        |> double\n        |> dtr\n        |> cos\n    let sin'' (a: double): double =\n        a\n        |> double\n        |> dtr\n        |> sin\n\n    let len ((l: double, _)): double = l\n    let deg ((_, a: double)): double = a\n\n    let dl = sqrt ((double a + double b) ** 2.0 + 2.0 * double a * double b * (-sin' (beta - alpha) - 1.0))\n    let da =\n        rtd\n            (atan2 (double a * sin' alpha + double b * cos' beta) (double a * cos' alpha - double b * sin' beta))\n\n    let C =\n        (sqrt ((dl + double c) ** 2.0 + 2.0 * dl * double c * (-cos'' (double gamma - da) - 1.0)),\n         rtd (atan2 (dl * sin'' da - double c * sin' gamma) (dl * cos'' da - double c * cos' gamma)))\n    let l = int (round (len C))\n    let a = deg C\n    let d = int a\n    let m = int ((a - double d) * 60.0)\n    let s = int ((a - double d - double m \/ 60.0) * 3600.0)\n\n    [ l; d; m; s ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86743,"user_id":null,"body":"type DistAndAngle = { Dist: int; Angle: int }\n\nlet updatePosition (x: float, y: float) ({ Dist = dist; Angle = angle}: DistAndAngle) =\n    let radians = System.Math.PI \/ 180. * (float angle)\n    let deltaX = (float dist) * (cos radians)\n    let deltaY = (float dist) * (sin radians)\n    (x + deltaX, y + deltaY)\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n    let (finalX, finalY) =\n        [ { Dist = a; Angle = alpha}; { Dist = b; Angle = beta}; { Dist = c; Angle = gamma } ]\n        |> Seq.mapi (fun i distAngle -> { distAngle with Angle = distAngle.Angle + (i * 90)})\n        |> Seq.fold updatePosition (0., 0.)\n    let distCO =\n        finalX * finalX + finalY * finalY\n        |> (sqrt >> round >> int)\n    let angleOC = 180. \/ System.Math.PI * (atan2 finalY finalX)\n\n    [ distCO\n      (int angleOC)\n      (int (angleOC * 60.) % 60)\n      (int (angleOC * 60. * 60.) % 60) ]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86744,"user_id":753,"body":"open System\n\nlet pi = 3.14159265358979323846\n\nlet degToRad (alpha: int): double =\n  double alpha \/ 180.0 * pi\n  \nlet radToDegMinSec (rad: double): int list =\n  [int (rad \/ pi * 180.0) % 360; int(rad \/ pi * 180.0 * 60.0) % 60; int(rad \/ pi * 180.0 * 60.0 * 60.0) % 60]\n\nlet sphericalToXY ((a, alpha): int * int) : double * double = \n  ((double a) * cos (degToRad alpha), (double a) * sin (degToRad alpha))\n  \nlet angle (x: double) (y: double): int list =\n  radToDegMinSec (atan2 y x)\n  \nlet xYtoSpherical ((x,y): double * double) =\n  List.append [int (round (sqrt(x * x + y * y)))] (angle x y)\n  \n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  [(a, alpha); (b, beta + 90); (c, gamma + 180)]\n  |> List.map sphericalToXY\n  |> List.reduce (fun (x1, y1) (x2, y2) -> (x1 + x2, y1 + y2))\n  |> xYtoSpherical","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5c5086287bc6600001c7589a":[{"id":86745,"user_id":null,"body":"let isNegativeZero x = x = 0.0 && System.Double.IsNegativeInfinity(1.0 \/ x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86746,"user_id":null,"body":"let isNegativeZero n = 1.\/n |> System.Double.IsNegativeInfinity \n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86747,"user_id":null,"body":"let isNegativeZero (n: float) =\n  if (n = 0.0) then 1.0\/n = -infinity\n  else false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86748,"user_id":null,"body":"\n\nlet isNegativeZero n =\n  match 1.0 \/ n with\n  | System.Double.NegativeInfinity->true\n  |System.Double.PositiveInfinity->false\n  |_->false\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86749,"user_id":null,"body":"let isNegativeZero (n: float) =\n    match n with\n    | x when System.BitConverter.GetBytes(n) = [|0uy; 0uy; 0uy; 0uy; 0uy; 0uy; 0uy; 128uy|] -> true\n    | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86750,"user_id":null,"body":"let isNegativeZero (n : float) =    \n    if 1.0 \/ n = infinity then false\n    else -0.0 = n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86751,"user_id":168,"body":"let isNegativeZero n = 1.0 \/ n = -infinity","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86752,"user_id":null,"body":"open System\n\nlet isNegativeZero n =\n  if (n <> 0.0) then\n    false\n  else\n    BitConverter.GetBytes(n).[7] = 128uy","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86753,"user_id":null,"body":"open System\n\nlet isNegativeZero (n: float) =\n    let b = BitConverter.GetBytes(n) |> Seq.toList |> List.rev |> List.head\n    match n, b with\n    | x, y when x = 0.0 && y = 128uy -> true\n    | _ -> false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86754,"user_id":null,"body":"open System\n\nlet isNegativeZero n =\n    Double.IsNegativeInfinity (1.0 \/ n)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5c556845d7e0334c74698706":[{"id":86755,"user_id":null,"body":"let fitSquares a b m n =\n    (m >= a + b && n >= max a b) || (n >= a + b && m >= max a b)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86756,"user_id":null,"body":"let fitSquares a b m n =\n  a + b <= m && a <= n && b <= n\n  || a + b <= n && a <= m && b <= m\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86757,"user_id":53,"body":"let fitSquares a b m n =\n    (max n m) >= (a + b) && (max a b) <= (min n m)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86758,"user_id":null,"body":"let fitSquares a b m n =\n    (max a b) <= (min m n) && (a + b) <= (max m n) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86759,"user_id":527,"body":"let fitSquares a b m n =\n  a <= m && b <= m && a + b <= n || a <= n && b <= n && a + b <= m","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86760,"user_id":168,"body":"let fitSquares a b m n =\n    max m n >= a + b && min m n >= max a b","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86761,"user_id":1192,"body":"let rec fitSquares a b m n =\n    if a < b then fitSquares b a m n\n    elif m < n then fitSquares a b n m\n    else m >= a && n >= a && m-a >= b\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5ca3ae9bb7de3a0025c5c740":[{"id":86762,"user_id":492,"body":"let point (a: int) (b: int): (bool -> int) =\n    fun (x: bool) -> if x then a else b\n    \nlet fst (pt: bool-> int): int = pt true\nlet snd (pt: bool-> int): int = pt false\nlet sqrDist (pt1: bool-> int) (pt2: bool-> int): int = \n    let d1 = fst(pt1) - fst(pt2)\n    let d2 = snd(pt1) - snd(pt2)\n    d1 * d1 + d2 * d2\n    \nlet line (pt1: bool-> int) (pt2: bool-> int): (int * int * int) =\n    let (x1, y1) = (fst(pt1), snd(pt1))\n    let (x2, y2) = (fst(pt2), snd(pt2))\n    let (dx, dy) = (x2 - x1, y2 - y1)\n    (-dy, dx, dy * x1 - dx * y1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86763,"user_id":null,"body":"open System\n\nlet point (a: int) (b: int) = fun () -> (a,b)\n\nlet fst pt = pt() |> (fun (a,b) -> a)\n\nlet snd pt = pt() |> (fun (a,b) -> b)\n\nlet sqrDist pt1 pt2 = \n    let x1 = pt1 |> fst\n    let x2 = pt2 |> fst\n    let y1 = pt1 |> snd\n    let y2 = pt2 |> snd\n    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n\nlet line pt1 pt2 =\n    let x1 = pt1 |> fst\n    let x2 = pt2 |> fst\n    let y1 = pt1 |> snd\n    let y2 = pt2 |> snd\n    let m = x2 - x1\n    let l = y1 - y2\n    let n = -m * y1 - l * x1\n    (l,m,n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86764,"user_id":null,"body":"open System\n\n\ntype p = (unit -> int*int)\n\nlet point (a: int) (b: int):p =\n    fun () -> a,b\n\nlet fst (pt:p): int = \n    let a,_ = pt ()\n    a\nlet snd (pt:p): int = \n    let _,b = pt ()\n    b\n\nlet sqrDist (pt1:p) (pt2:p): int =     \n    let x1,y1=pt1 ()\n    let x2,y2=pt2 ()\n    let distance = (y2-y1)*(y2-y1) + (x2-x1)*(x2-x1)\n    distance\n\nlet line (pt1: p) (pt2: p): (int * int * int) =\n    let x1,y1 = pt1 ()\n    let x2,y2 = pt2 ()\n    let l = y2 - y1\n    let m = - ( x2 - x1)\n    let n = - (l * x1 + m * y1)\n    l,m,n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86765,"user_id":null,"body":"open System\nopen System.Drawing\n\nlet point (a: int) (b: int) =\n    fun() -> Point(a, b)\n    \nlet fst (pt: unit -> Point) = pt().X\n\nlet snd (pt: unit -> Point) = pt().Y\n\nlet sqrDist (pt1: unit -> Point) (pt2: unit -> Point): int = \n    (pt1().X - pt2().X) * (pt1().X - pt2().X) + \n    (pt1().Y - pt2().Y) * (pt1().Y - pt2().Y)\n    \nlet line (pt1: unit -> Point) (pt2: unit -> Point): (int * int * int) =\n    let l = pt2().Y - pt1().Y\n    let m = pt1().X - pt2().X\n    let n = - pt1().X * pt2().Y\n            + pt1().X * pt1().Y\n            + pt1().Y * pt2().X\n            - pt1().Y * pt1().X\n            \n    (l, m, n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5cd12646cf44af0020c727dd":[{"id":86766,"user_id":null,"body":"type SquarePi = { digits: int }\nlet value (squarePi: SquarePi) : int =\n    \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\" |>\n    Seq.take squarePi.digits |> Seq.map (System.Char.GetNumericValue >> (fun x -> x * x)) |> Seq.sum |> (sqrt >> ceil >> int)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86767,"user_id":null,"body":"type SquarePi = { digits: int }\n\n[<Literal>]\nlet PiDigits = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\nlet char2int c : int = (int c) - 0x30\nlet square x = x * x\n\nlet sumOfPiDigitSquares count = \n  PiDigits.Substring(0, count).ToCharArray()\n  |> Array.map char2int\n  |> Array.map square\n  |> Array.sum\n\nlet value (squarePi: SquarePi) : int =\n    let toBeat = sumOfPiDigitSquares squarePi.digits\n    let rec inner index =\n      if (index * index) >= toBeat then\n        index\n      else\n        inner (index + 1)\n    inner 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86768,"user_id":null,"body":"type SquarePi = { digits: int }\nlet piDigits = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\nlet value =\n    function\n    | {digits=count} when count>0 ->\n        piDigits |>\n        Seq.take count |>\n        Seq.map (System.Char.GetNumericValue>>(fun i -> i*i)) |>\n        Seq.reduce (+) |>\n        (sqrt>>ceil>>int)\n    | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86769,"user_id":null,"body":"open System.Globalization\n\ntype SquarePi = { digits: int }\nlet value (squarePi: SquarePi) : int =\n    \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    |> Seq.take squarePi.digits\n    |> Seq.map CharUnicodeInfo.GetDecimalDigitValue\n    |> Seq.map (fun x -> x * x)\n    |> Seq.sum\n    |> (float >> sqrt >> ceil >> int)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86770,"user_id":null,"body":"type SquarePi = { digits: int }\nlet value (squarePi: SquarePi) : int =\n  let pi_digits = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n  pi_digits.[0..squarePi.digits - 1]\n  |> Seq.toList\n  |> List.map string\n  |> List.map int\n  |> List.sumBy (fun x -> x * x)\n  |> float\n  |> sqrt\n  |> ceil\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86771,"user_id":null,"body":"type SquarePi = { digits: int }\nlet piDigits = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n               |> Seq.toList \n               |> List.map (string >> float)\nlet value (squarePi: SquarePi) =\n    match [for i in 0 .. (squarePi.digits - 1) -> piDigits.[i] ** 2.] |> List.sum |> sqrt with\n    | x when x % 1. = 0. -> int x\n    | x -> 1 + int x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86772,"user_id":null,"body":"type SquarePi = { digits: int }\nlet value (squarePi: SquarePi) : int =\n  let pi = \"031415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n  pi.[..squarePi.digits]\n  |> Seq.sumBy (int >> (fun d -> (d - 48)*(d - 48)))\n  |> float\n  |> sqrt\n  |> ceil\n  |> int","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86773,"user_id":null,"body":"let digitsOfPi = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\ntype SquarePi = { digits: int }\nlet value (squarePi: SquarePi) =\n    digitsOfPi.[0..(squarePi.digits - 1)].ToCharArray()\n    |> Array.sumBy (fun c -> (int c) - (int '0') |> (fun x -> x * x))\n    |> (float >> sqrt >> ceil >> int)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86774,"user_id":null,"body":"type SquarePi = { digits: int }\n\nlet value (squarePi: SquarePi) : int =\n    \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n        |> Seq.take squarePi.digits\n        |> Seq.sumBy (fun x -> pown (float ((int x) - 48)) 2)\n        |> sqrt\n        |> ceil\n        |> int\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86775,"user_id":null,"body":"type SquarePi = { digits: int }\nlet value (squarePi: SquarePi) : int =\n    let piString = \"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    Seq.take (squarePi.digits) piString\n    |> Seq.sumBy (string >> int >> (fun x -> x * x))\n    |> (float >> sqrt >> ceil >> int)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5ce399e0047a45001c853c2b":[{"id":86776,"user_id":527,"body":"let parts_sums (xs: int array) : int array =\n  Array.scanBack (+) xs 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86777,"user_id":null,"body":"let parts_sums ls = Array.scanBack (+) ls 0","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86778,"user_id":492,"body":"let parts_sums(ls: int array): int array =\n    let res = Array.zeroCreate (ls.Length + 1)\n    for i in ls.Length - 1 .. -1 .. 0 do\n        Array.set res i (res.[i + 1] + ls.[i])\n    res","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86779,"user_id":null,"body":"let parts_sums (ls: int array) : int array =\n    let mutable res = [ Array.sum ls ]\n\n    for i in ls do\n        res <- ((List.head res) - i) :: res\n\n    res |> List.rev |> List.toArray","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86780,"user_id":null,"body":"let parts_sums(ls: int array): int array =\n    let mutable totalSum = if ls.Length = 0 then 0 else Array.sum ls\n    Array.init \n      (1 + Array.length ls)\n      (fun i ->\n        let r = totalSum\n        totalSum <- \n         if i < Array.length ls\n           then totalSum - ls.[i]\n           else 0\n        r)\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86781,"user_id":null,"body":"let parts_sums(ls: int array): int array =\n    let mutable sum = Array.sum ls\n    let next n = \n        sum <- sum - n\n        sum\n    [| yield sum\n       for i in ls -> next i |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86782,"user_id":null,"body":"let parts_sums(ls: int array): int array =\n    let rec helper list sum res = \n        match list with\n            [] -> sum :: res\n            | (x::xs) -> helper xs (sum + x) (sum :: res)\n\n    helper (List.rev (Array.toList ls)) 0 [] |> List.toArray\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86783,"user_id":null,"body":"let parts_sums(ls: int array): int array =\n    Seq.scanBack (+) ls 0 |> Array.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86784,"user_id":null,"body":"let parts_sums ls = (ls,0) ||> Array.scanBack (+) ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86785,"user_id":null,"body":"let parts_sums(ls: int array): int array = \n    Array.scan (-) (Array.sum ls) ls ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5d2659626c7aec0022cb8006":[{"id":86786,"user_id":null,"body":"let rec gen (n: int): int =\n  let q = int(n \/ 4)\n  let r = n % 4\n  if n = 0 then 1\n  elif r = 0 then gen q\n  elif r = 2 then 0\n  else gen (int(n \/ 2))\n\nlet baumSweet() = Seq.initInfinite (fun n -> gen n)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86787,"user_id":null,"body":"open System\nlet baumSweet () =\n\n  let isOne (k: string):int =\n    k.Split '1'\n     \n    |>Array.filter (fun e ->(e  |>Array.ofSeq|>Array.length) % 2= 1)\n    |>function\n    |[||]->1\n    |_->0\n     \n  let   intToBinary (i: int):string =\n    Convert.ToString(i,2)\n   \n  Seq.unfold (fun (state:int)->\n    match state with\n    |0->Some(1,state+1)\n    |_->Some(state|>intToBinary|> isOne,state+1)) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86788,"user_id":null,"body":"open System\n\nlet binStr (x: int) = Convert.ToString(x, 2)\nlet hasConsecutiveZeroes n = (n |> binStr).Split '1' |> Seq.exists (fun x -> x.Length % 2 = 1)\n\nlet baumSweet() =\n  Seq.unfold (fun s -> match s with\n                       | 0 -> Some (1, s + 1)\n                       | x when x |> hasConsecutiveZeroes -> Some(0, s + 1)\n                       | _ -> Some(1, s + 1)) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86789,"user_id":null,"body":"open System\n\nlet bs (n : int) =\n    if n = 0 then 1 else\n      let b = Convert.ToString(n, 2)\n                     .Split([|'1'|], StringSplitOptions.RemoveEmptyEntries)\n                     |> Array.exists (fun b -> b.Length % 2 = 1)\n      if b then 0 else 1\n\nlet rec baumSweetFrom i =\n    seq {\n        yield bs i; yield! baumSweetFrom (i + 1)\n    } \n\nlet baumSweet() = baumSweetFrom 0\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86790,"user_id":53,"body":"open System\nopen System.Collections.Generic\n\nlet baumSweet() = seq {\n    let mutable i = 1\n    yield 1\n    while true do\n        let b = Convert.ToString(i, 2)\n        let mutable n = 0\n        let mutable j = 0\n        let mutable p = false\n        while not p && j < b.Length do\n            if b.[j] = '0' then\n                n <- n + 1\n            else\n                if (n % 2) = 1 then\n                    p <- true\n                else\n                    n <- 0\n            j <- j + 1\n        if (n % 2) = 1 then\n            yield 0\n        else\n            yield 1\n        i <- i + 1\n}","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86791,"user_id":null,"body":"let rec bit n =\n  if n<2\n  then 1\n  else if n%4 = 0 \n       then bit(n\/4) \n       else if n%2 = 0 \n            then 0\n            else bit((n-1)\/2)\n      \nlet baumSweet() = 0 |> Seq.unfold(fun n -> Some(n, n+1)) |> Seq.map bit","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86792,"user_id":null,"body":"let rec elem n =\n  if n<2\n  then 1\n  else if n%4 = 0 \n       then elem(n\/4) \n       else if n%2 = 1 then elem((n-1)\/2) else 0\n      \nlet baumSweet() = 0 |> Seq.unfold(fun n -> Some(n, n+1)) |> Seq.map elem","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86793,"user_id":null,"body":"let rec elem n =\n  if n>1 then\n    if n%4 = 0 then elem(n\/4) \n    else if n%2 = 1 then elem((n-1)\/2) else 0\n  else 1\n      \nlet baumSweet() = 0 |> Seq.unfold(fun n -> Some(n, n+1)) |> Seq.map elem","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86794,"user_id":null,"body":"let rec elem n =\n  if n>1 then\n    if n%4 = 0 then elem(n\/4) \n    else if n%2 = 1 then elem((n-1)\/2) else 0\n  else 1\n      \nlet baumSweet() = (0, 1) |> Seq.unfold(fun(n, v) -> Some((n, v), (n+1, elem(n+1)))) |> Seq.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86795,"user_id":null,"body":"let rec elem n =\n  if n>1 then\n    if n%4 = 0 then elem(n\/4) \n    else if n%2 = 1 then elem((n-1)\/2) else 0\n  else 1\n      \nlet baumSweet() = Seq.unfold (fun (n, v) -> Some((n, v), (n+1, elem(n+1)))) (0, 1) |> Seq.map snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5d26721d48430e0016914faa":[{"id":86796,"user_id":168,"body":"let paperFold() = Seq.initInfinite (fun i -> \n  let n = i + 1 in\n  ((n \/ (n &&& -n) &&& 3) >>> 1) ^^^ 1)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86797,"user_id":null,"body":"let paperFold () =\n    let rec factor n = if n % 2 = 1 then n else factor (n \/ 2)\n\n    Seq.unfold\n        (fun i ->\n            Some(\n                (if (factor i) % 4 = 1 then 1\n                 elif (factor i) % 4 = 3 then 0\n                 else 0),\n                (i + 1)\n            ))\n        1","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86798,"user_id":null,"body":"#nowarn \"40\"\n\nlet rec pFold =\n  seq {\n    yield 1\n    for (i, x) in Seq.indexed pFold do\n      yield x\n      yield (if i % 2 = 0 then 0 else 1)\n  }\n    \nlet paperFold () = pFold","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86799,"user_id":null,"body":"let highestPowOfTwoLessThan n =\n  let mutable i = 0\n  while n >= (pown 2 i) do\n    i <- i + 1\n  pown 2 (i-1)\n  \n\nlet rec term n =\n  let p = highestPowOfTwoLessThan n\n  if n = 1 || n = p then 1\n  else\n    term (2 * p - n) ^^^ 1\n\nlet paperFold () =\n  1 |> Seq.unfold (fun n -> Some (term n, n+1))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86800,"user_id":null,"body":"let paperFold() =\n    let pf = Array.zeroCreate 1048575\n    pf.[0] <- 1\n    let mutable n = 1\n    while n < pf.Length do\n        pf.[n] <- 1\n        for i=n+1 to n+n do pf.[i] <- 1-pf.[n+n-i]\n        n <- n+n+1\n    pf |> Array.toSeq\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86801,"user_id":null,"body":"let oneAndZeroSeq = Seq.initInfinite (fun i -> (i + 1) % 2)\n\nlet interleaveOnesAndZeros (num: seq<int>) =   \n  Seq.zip num oneAndZeroSeq\n  |> Seq.collect(fun (a, b) -> [|a; b|])\n\nlet paperFold () = \n    let rec loop (prev: seq<int>) = seq {\n        yield! prev\n        let next = interleaveOnesAndZeros prev\n        yield! loop next\n    }\n    seq {\n        yield 1\n        yield! loop [|1; 0|]\n    }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86802,"user_id":null,"body":"\nlet oneAndZeroSeq = \n    Seq.initInfinite (fun i -> (i + 1) % 2)\n\nlet interleaveOnesAndZeros (num: array<int>) = \n    seq {\n        yield! \n            Seq.zip num oneAndZeroSeq\n            |> Seq.collect(fun (a, b) -> [|a; b|])\n    }\n\nlet paperFold () = \n    let rec loop (prev: array<int>) size = seq {\n        let curr = \n            interleaveOnesAndZeros prev\n            |> Seq.take size\n            |> Seq.toArray\n\n        yield! curr\n        yield! loop curr (size * 2)\n    }\n\n    seq {\n        yield 1\n        yield 1\n        yield 0\n        yield! loop [|1; 0|] 4\n    }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86803,"user_id":null,"body":"open System\n\nlet oneAndZeroSeq = \n    Seq.initInfinite (fun i -> (i + 1) % 2)\n\nlet interleaveOnesAndZeros (num: array<int>) = \n    seq {\n        yield! \n            Seq.zip num oneAndZeroSeq\n            |> Seq.collect(fun (a, b) -> [|a; b|])\n    }\n\nlet paperFold () = \n    let rec loop (prev: array<int>) size = seq {\n        let curr = \n            interleaveOnesAndZeros prev\n            |> Seq.take size\n            |> Seq.toArray\n\n        yield! curr\n        yield! loop curr (size * 2)\n    }\n\n    seq {\n        yield 1\n        yield 1\n        yield 0\n        yield! loop [|1; 0|] 4\n    }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86804,"user_id":527,"body":"let paperFold () =\n  Seq.initInfinite <| fun i ->\n    let i = i + 1\n    match i &&& ((i &&& -i) <<< 1) with\n      | 0 -> 1\n      | _ -> 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86805,"user_id":53,"body":"let paperFold() = seq {\n  let mutable i = 1\n  while true do\n    let mutable n = i\n    while n % 2 = 0 do \n      n <- n \/ 2\n    if n % 4 = 1 then \n      yield 1\n    elif n % 4 = 3 then \n      yield 0\n    i <- i + 1\n  }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5d50e3914861a500121e1958":[{"id":86806,"user_id":645,"body":"let add_letters (arr: List<char>): char = \"zabcdefghijklmnopqrstuvwxy\".[(arr |> List.map (fun c -> int c - 96) |> List.sum) % 26]","lang_id":20,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86807,"user_id":null,"body":"let letters = Seq.append ['z'] ['a'..'y']\nlet numbers = [0..25]\nlet letterToNumberDict = Seq.zip letters numbers |> dict\nlet letterToNumber letter = letterToNumberDict.[letter]\n\nlet numberToLetterDict = Seq.zip numbers letters |> dict\nlet numberToLetter number = numberToLetterDict.[number]\n\nlet add_letters (arr: List<char>): char =\n    arr |> Seq.map letterToNumber\n        |> Seq.append [0]\n        |> Seq.reduce (fun x y -> (x + y) % 26)\n        |> numberToLetter","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86808,"user_id":null,"body":"let englishLettersCount = 26\nlet zeroCh = int 'a' - 1\n\nlet charToNum (ch : char) = int ch - zeroCh\n\nlet numToChar num = num + zeroCh |> char\n\nlet add_letters (arr: List<char>): char = \n    \n    match (arr\n    |> List.ofSeq\n    |> List.map charToNum\n    |> List.sum)\n        % englishLettersCount\n        with\n        | 0 -> englishLettersCount\n        | x -> x\n    |> numToChar\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86809,"user_id":null,"body":"let add_letters (arr: List<char>): char =\n  let total = (List.sumBy (fun c -> int(c) - 96) arr) % 26\n  if total = 0 then 'z' else char(total + 96)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86810,"user_id":null,"body":"let add_letters (arr: List<char>): char =\n    match arr with\n    | [] -> 'z'\n    | x -> (x |> List.fold (fun s c -> s + int c - 96 ) -1) % 26 + 97 |> char","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86811,"user_id":null,"body":"let intValue (x: char): int = ((int)x) - ((int)'a') + 1\nlet charValue (x: int): char = (char) (((int)x) + ((int)'a') - 1)\n  \nlet overflow x = if x % 26 = 0 then 26 else (x % 26)\n\nlet add_letters (arr: List<char>): char = match arr with \n                                               | [] -> 'z'\n                                               | xs when (List.except ['a'..'z'] arr) = [] -> List.map intValue arr |> List.sum |> overflow |> charValue;\n                                               | _ -> 'z'\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86812,"user_id":null,"body":"let add_letters (arr: List<char>): char =\n        match arr.Length with\n        |0 -> 'z'\n        |_ -> let numbered = List.map (fun c -> ((int) c) - 96) arr\n              let summed = (List.sum numbered) % 26\n              if summed = 0 then 'z' else (char) (summed+96)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86813,"user_id":null,"body":"let add_letters (arr: List<char>): char =\n    let rec loop acc = function\n        | [] -> (acc - 1) % 26 + int 'a'\n        | head :: tail ->\n            loop (int head - int 'a' + 1 + acc) tail\n    char <| loop 26 arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86814,"user_id":168,"body":"let add_letters (arr: List<char>): char =\n  arr\n  |> List.fold (fun s x -> s + int x - 96) 25\n  |> fun x -> char (x % 26 + 97)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86815,"user_id":null,"body":"let add_letters (arr: List<char>): char =\n  arr\n  |> List.map (int >> (fun x -> x - 96))\n  |> List.sum\n  |> (fun x -> char (((x - 1) % 26 + 26) % 26 + 97))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5e4e8f5a72d9550032953717":[{"id":86816,"user_id":null,"body":"let rec allRationals = seq {\n  yield 1,1\n  for x,y in allRationals do\n    yield x,x+y\n    yield x+y,y\n}","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86817,"user_id":527,"body":"let rec allRationals = seq {\n  yield 1, 1\n  for a, b in allRationals do\n    yield a, a + b\n    yield a + b, b\n}","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86818,"user_id":null,"body":"type Queue<'a> = System.Collections.Generic.Queue<'a>\n\ntype Node<'a> =\n    | Empty \n    | Branch of 'a * BinaryTree<'a> * BinaryTree<'a>\nand BinaryTree<'a> = seq<Node<'a>>\n\nlet uncurry (f: 'a -> 'b -> 'c) (a: 'a, b: 'b) : 'c =\n    f a b \n\nlet allRationals : seq<int * int> =\n    let rootNode = (1, 1)\n    let rec generateTree (a: int) (b: int) : BinaryTree<int * int> =\n        seq {\n            yield Branch(\n                (a, b),\n                generateTree a (a + b),\n                generateTree (a + b) b)\n        }    \n    let toDiscover = Queue<BinaryTree<int * int>>(0)\n    toDiscover.Enqueue(uncurry generateTree rootNode)\n    seq {\n        while toDiscover.Count > 0 do\n            let node = toDiscover.Dequeue()\n            match Seq.head node with\n            | Empty -> failwith \"Error: It's an infinite tree\"\n            | Branch (rational, left, right) ->\n                toDiscover.Enqueue(left)\n                toDiscover.Enqueue(right)\n                yield rational\n    }","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86819,"user_id":645,"body":"#nowarn \"40\"\n\nlet rec allRationals = Seq.append [(1, 1)] (Seq.delay (fun () -> Seq.concat (Seq.map (fun (a, b) -> [(a, a + b); (a + b, b)]) allRationals)))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86820,"user_id":null,"body":"let allRationals =\n  Seq.unfold (fun(s)-> Some(s,seq{for s,g in s do yield (s, s + g); yield (s + g, g)})) (seq[(1,1)])\n  |> Seq.concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86821,"user_id":null,"body":"let allRationals =\n  let getComb numb = numb |> Seq.collect (fun (a,b) -> [(a, a + b); (a + b, b)])\n  let rec getSeq rat =\n    seq{\n      yield! rat\n      yield! (getSeq (getComb rat))\n    }\n  getSeq ([(1,1)] |> Seq.ofList)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86822,"user_id":null,"body":"let rec rat n =\n  if n>0 \n  then let (a, b) = rat((n-1)\/2)\n       if n%2>0 \n       then (a, a+b) \n       else (a+b, b)\n  else (1, 1)  \n    \nlet allRationals =\n  0 |> Seq.unfold(fun n -> Some(n, n+1)) |> Seq.map rat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86823,"user_id":null,"body":"let rec rationals parents = \n    seq {\n        for parent in parents do\n            yield parent\n\n        let childrenOf parent = \n            let a, b = parent;\n            [ (a, a + b); (a + b, b) ]\n\n        yield!\n            parents\n            |> List.collect childrenOf\n            |> rationals\n    }\n\nlet allRationals = rationals [(1, 1)]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86824,"user_id":null,"body":"let allRationals =\n    let generator (row: (int * int)[]) =\n        let newRow =\n            row\n            |> Array.collect (fun (a, b) -> [| (a, a + b); (a + b, b) |])\n        Some (row, newRow)\n    Seq.unfold generator [| (1, 1) |]\n    |> Seq.collect id","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5efae11e2d12df00331f91a6":[{"id":86825,"user_id":null,"body":"open System.Security.Cryptography\nopen System.Text\n\nlet md5 (data: string): string =\n    use md5 = MD5.Create()\n    (StringBuilder(), md5.ComputeHash(Encoding.UTF8.GetBytes(data)))\n    ||> Array.fold (fun sb b -> sb.Append(b.ToString(\"x2\")))\n    |> string\n\nlet crack (hash: string) =\n    (List.map (string >> (fun x -> x.PadLeft(5, '0'))) [ 0 .. 99999 ])\n    |> List.find (fun x -> hash = md5 x)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86826,"user_id":null,"body":"open System.Security.Cryptography\nopen System.Text\n\nlet md5 (data : byte array) : string =\n    use md5 = MD5.Create()\n    (StringBuilder(), md5.ComputeHash(data))\n    ||> Array.fold (fun sb b -> sb.Append(b.ToString(\"x2\")))\n    |> string\n    \nlet crack hash =\n    [0..99999] \n    |> Seq.map (sprintf \"%05i\")\n    |> Seq.map (fun n -> n, System.Text.Encoding.ASCII.GetBytes(n) |> md5) \n    |> Seq.tryPick (fun n -> match snd n with\n                             | hash' when hash' = hash -> Some(fst n)\n                             | _ -> None)\n    |> Option.defaultWith (fun f -> \"None\")\n\n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86827,"user_id":null,"body":"let crack (hash: string) = \n  \/\/ C0d3 g03s h3r3\n    let md5Hash (input : string) =\n        use md5 = System.Security.Cryptography.MD5.Create()\n        input\n        |> System.Text.Encoding.ASCII.GetBytes\n        |> md5.ComputeHash\n        |> Seq.map (fun c -> c.ToString(\"x2\"))\n        |> Seq.reduce (+)\n    let rec tryCrack pin = \n        let pinstr = (string pin).PadLeft(5, '0')\n        if pinstr.Length>5 then failwith \"cant crack\"\n        let md5 = md5Hash pinstr\n        match md5 = hash with\n        | true -> pinstr\n        | false -> tryCrack (pin+1)\n    tryCrack 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86828,"user_id":null,"body":"open System\nopen System.Text\nopen System.Security.Cryptography\n\n\nlet crack (input:string) =\n    let md5 = MD5.Create()\n    let u = input.ToUpper()\n    let hash (s:string) = \n            BitConverter\n                    .ToString(md5.ComputeHash(Encoding.UTF8.GetBytes(s)))\n                    .Replace(\"-\", \"\")\n    seq {0..99999} \n        |> Seq.map (fun i -> i.ToString(\"00000\"))\n        |> Seq.find (fun p -> (hash p) = u)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86829,"user_id":null,"body":"let crack (origHash : string) = \n    use md5 = System.Security.Cryptography.MD5.Create()\n    seq { for pin in 0 .. 99_999 -> sprintf \"%05d\" pin }\n    |> Seq.find (fun pin ->\n        let bytes = System.Text.Encoding.ASCII.GetBytes pin\n        let hash =\n            md5.ComputeHash bytes\n            |> Array.map (fun b -> b.ToString \"x2\")\n            |> String.concat \"\"\n        hash = origHash)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86830,"user_id":null,"body":"open System.Security.Cryptography\nopen System.Text\n\nlet crack (hash : string) =\n    let hash = hash.ToUpper()\n    let md5 = MD5.Create()\n    let hashComp (str : string) =\n        Encoding.ASCII.GetBytes str\n        |> md5.ComputeHash\n        |> Array.map (fun x -> x.ToString(\"X2\"))\n        |> String.concat \"\"\n    let rec tryfrom (n : int) =\n        let str = n.ToString(\"D5\")\n        if hashComp str = hash then str\n        elif n > 99999 then \"\"\n        else tryfrom (n + 1)\n    tryfrom 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86831,"user_id":513,"body":"let MD5Hash (input : string) =\n      use md5 = System.Security.Cryptography.MD5.Create()\n      input\n      |> System.Text.Encoding.ASCII.GetBytes\n      |> md5.ComputeHash\n      |> Seq.map (fun c -> c.ToString(\"X2\"))\n      |> Seq.reduce (+)\n\nlet crack (hash: string) = \n  let mutable i = 0\n  let mutable breakstat = true\n  let mutable buffer = \"\"\n  while i < 100000 && breakstat do\n    buffer <- sprintf \"%05i\" i\n    let myhash = MD5Hash(buffer).ToLower()\n    if myhash.Equals(hash) then\n      breakstat <- false\n    i <- i+1\n  buffer\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86832,"user_id":null,"body":"open System.Security.Cryptography\nopen System.Text\n\nlet md5 (data : string) : string =\n    use md5 = MD5.Create()\n    (StringBuilder(), md5.ComputeHash(data |> Encoding.ASCII.GetBytes))\n    ||> Array.fold (fun sb b -> sb.Append(b.ToString(\"x2\")))\n    |> string\n\nlet crack hash =\n  let rec cr pass =\n    if pass > 99999 then \"\"\n    else match pass |> sprintf \"%05i\" |> md5 = hash with\n         | true -> pass |> sprintf \"%05i\"\n         | false -> cr (pass + 1)\n  cr 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86833,"user_id":null,"body":"let md5 (pin: string) =\n    use hasher = System.Security.Cryptography.MD5.Create()\n    let hash = pin\n                |> System.Text.Encoding.ASCII.GetBytes\n                |> hasher.ComputeHash\n                |> Seq.map (fun c -> c.ToString(\"x2\"))\n                |> Seq.reduce (+)\n    (hash, pin)\n\nlet crack (hash: string) = \n    [0..99999]\n    |> Seq.map (fun x -> x.ToString(\"D5\"))\n    |> Seq.map md5\n    |> Seq.find (fun (foundHash, pin) -> hash = foundHash)\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86834,"user_id":null,"body":"open System.Text\nopen System.Security.Cryptography\n\nlet dictionary =\n  seq {\n    use md5 = MD5.Create ()\n    let hash (text: string) = \n        [ for b in md5.ComputeHash(Encoding.UTF8.GetBytes(text)) -> b.ToString(\"x2\") ]\n        |> String.concat \"\"\n    for i in 0..99999 do\n      let s = sprintf \"%05d\" i\n      yield hash s, s\n  } |> Map.ofSeq\n\nlet crack (hash: string) = dictionary.[hash]\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5f3142b3a28d9b002ef58f5e":[{"id":86835,"user_id":null,"body":"let wordPattern (word: string): string =\n  let lower = word.ToLower()\n  let unique = lower |> Seq.toList |> List.distinct\n  let answer = List.map (fun c -> string(List.findIndex ((=) c) unique)) (lower |> Seq.toList)\n  String.concat \".\" answer","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86836,"user_id":null,"body":"let wordPattern (word : string) : string =\n    let rec decode (word: char list) (codes: char list) =\n        match word with\n        | [] -> []\n        | h::t -> \n                match codes |> List.tryFindIndex (fun code -> code = h) with\n                | Some x -> [x |>  string] @ decode t codes\n                | None -> [codes |> List.length |> string ] @ decode t (codes @ [h])\n    decode (word.ToLower() |> Seq.toList) []\n    |> String.concat \".\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86837,"user_id":null,"body":"open System\n\nlet wordPattern (word : string) =\n    let lowered = \n        word\n        |> Seq.map Char.ToLower\n        |> Seq.toArray\n        |> String\n    let xs = \n        lowered\n        |> Seq.distinct\n        |> Seq.zip [0..lowered.Length]\n    let ys =\n        lowered \n        |> Seq.map(fun c -> xs |> Seq.find(fun (_, c') -> c' = c) |> fst)\n\n    String.Join(\".\", ys)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86838,"user_id":null,"body":"open System\nopen FSharp.Core\nopen FSharp.Collections\n\nlet wordPattern (word : string)=\n    \/\/string to map\n    let s = \n        word.ToLower()\n        |> Seq.toArray\n    let a = \n        s |> Array.distinct\n    let d = \n        dict [for i in 0 .. a.Length-1 -> (a.[i], i)]\n    let w = \n        s |> Array.map (fun c -> d.[c])\n    (\".\", w) |> String.Join","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86839,"user_id":null,"body":"let constructIndex (x: string) =\n    let folder (m: Map<char, string>) x = if m.ContainsKey x then m else m.Add(x, string m.Count)\n    x |> Seq.toList |> List.fold folder Map.empty\n\nlet wordPattern (word : string) : string =\n    let word = word.ToLower()\n    let index = constructIndex word\n    word |> Seq.toList |> List.choose index.TryFind |> String.concat \".\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86840,"user_id":null,"body":"let letterCodes word = \n    word\n    |> Seq.distinct\n    |> Seq.mapi (fun i x -> (x, i))\n    |> dict\n\nlet wordPattern (word : string) : string =\n\n    let word = word.ToLower()\n\n    let codes = letterCodes word\n\n    word\n    |> Seq.map (fun letter -> codes.[letter])\n    |> Seq.map string\n    |> String.concat \".\"\n    \/\/|> Seq.toList","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86841,"user_id":null,"body":"let wordPattern (word : string) : string =\n  let dict = word.ToLower() |> \n             Seq.distinct |> Seq.sortBy (fun x -> (Seq.findIndex (fun y -> y = x) (word.ToLower()))) |> \n             Seq.indexed |> Seq.map (fun (a,b) -> (b, a)) |> Map\n  word.ToLower() |> Seq.map (fun x -> (dict.[x]).ToString()) |> String.concat \".\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86842,"user_id":null,"body":"open System\nopen System.Collections.Generic\n\nlet wordPattern (word : string) : string =\n    let dict = new Dictionary<char, int>()\n    word\n    |> Seq.map Char.ToLower\n    |> Seq.mapFold (fun s c ->\n        if (dict.ContainsKey c) then \n            dict.[c], s\n        else\n            dict.[c] <- s \n            s, s + 1) 0\n    |> fst\n    |> Seq.map string\n    |> String.concat \".\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86843,"user_id":null,"body":"let folder (timestamps, timestamp, pattern) character =\n  Map.tryFind character timestamps\n  |> Option.map (fun timestamp' -> (timestamps, timestamp, string timestamp' :: pattern))\n  |> Option.defaultValue (let timestamp' = timestamp + 1 in Map.add character timestamp' timestamps, timestamp', string timestamp' :: pattern)\n\nlet wordPattern (word : string) : string =\n    let word' = word.ToLowerInvariant()\n    word'\n    |> Seq.toList\n    |> List.fold folder (Map.add word'.[0] 0 Map.empty, 0, [])\n    |> (fun (_, _, result) -> result)\n    |> List.rev\n    |> String.concat \".\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86844,"user_id":null,"body":"open System\n\nlet wordPattern (word : string) : string =\n    let chars = word.ToCharArray() |> Array.map (Char.ToLower)\n    let letters =\n        chars\n        |> Array.distinct\n        |> Array.mapi (fun i letter -> letter, i)\n        |> Map.ofArray\n    let indices = chars |> Array.map (fun letter -> string letters.[letter])    \n    String.Join(\".\", indices)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5f5da7a415fbdc0001ae3c69":[{"id":86845,"user_id":491,"body":"let rec is_in_middle (s : string) : bool =\n    if Seq.length s <= 4\n        then s.Contains(\"abc\")\n        else s.Substring(1, Seq.length s - 2) |> is_in_middle","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86846,"user_id":null,"body":"let helper (s: string): bool =\n    let l = String.length s\n    let m = int(l \/ 2)\n    let n = l % 2\n    let s1 = s.[m - 1..m + 1]\n    let s2 = s.[m - 2..m]\n    s1 = \"abc\" || (n = 0 && s2 = \"abc\")\n\nlet is_in_middle (s: string): bool =\n    if String.length s < 4 then s = \"abc\"\n    else helper s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86847,"user_id":null,"body":"let is_in_middle (s : string) : bool =\n    match s.Length with\n    | l when l < 3 -> false\n    | l when l % 2 = 1 -> \"abc\" = s.Substring((s.Length - 3) \/ 2, 3)\n    | _ -> s.Substring((s.Length - 3)\/2, 4).Contains(\"abc\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86848,"user_id":null,"body":"let rec is_in_middle (s : string) : bool = if s.Length < 3 then false else s.Substring((s.Length-2)\/2, 3) = \"abc\" || s.Substring((s.Length-3)\/2, 3) = \"abc\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86849,"user_id":null,"body":"let rec is_in_middle (s : string) : bool =\n  let start = s.Length\/2-2\n  s.[max (start+s.Length%2) 0..min (start+3) (s.Length-1)].Contains(\"abc\")","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86850,"user_id":null,"body":"let rec is_in_middle (s : string) : bool =\n  let n = s.Length\n  if n = 0 then\n    false\n  else\n    if n % 2 = 1 then\n      if s.[(n-1)\/2-1] = 'a' && s.[(n-1)\/2] = 'b' && s.[(n-1)\/2+1] = 'c' then\n        true\n      else\n        false\n    else\n      if (s.[n\/2-2] = 'a' && s.[n\/2-1] = 'b' && s.[n\/2] = 'c') || (s.[n\/2-1] = 'a' && s.[n\/2] = 'b' && s.[n\/2+1] = 'c') then\n        true\n      else\n        false","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5f631ed489e0e101a70c70a0":[{"id":86851,"user_id":null,"body":"let rec disqualify ls =\n    match ls with\n    | l when List.length l % 2 = 1 -> List.last l :: disqualify (l|> List.rev |> List.tail |> List.rev)\n    | [] | [_] -> ls\n    | f::s::t -> max f s :: disqualify t\n\nlet rec tourney (inp : int list) : int list list =\n    match inp with\n    | [] | [_] -> [inp]\n    | _ -> inp :: tourney (disqualify inp)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86852,"user_id":null,"body":"\nlet tourney (inp : int list) : int list list =\n  let fight a b = \n    if a > b then a else b\n\n  let rec runMatches xs result = \n    match xs with\n    | x :: y :: rst -> runMatches rst ((fight x y) :: result)\n    | x :: rst -> x :: (runMatches rst result)\n    | [] -> List.rev result\n    \n  let mutable matchResult = inp\n  let mutable matchHistory = [matchResult]\n  \n  while List.length matchResult <> 1 do\n    matchResult <- runMatches matchResult []\n    matchHistory <- matchHistory @ [matchResult]\n    \n  matchHistory","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86853,"user_id":null,"body":"let rec tourney (inp : int list) : int list list =\n    [\n        yield inp\n        match inp with\n        | [] | [ _ ] -> ()\n        | inp ->\n            yield!\n                inp\n                |> List.chunkBySize 2\n                |> List.partition (List.length >> (=) 1)\n                |> (function\n                    | ([[x]] , xs) -> x :: (xs |> List.map List.max)\n                    | (_, xs) -> xs |> List.map List.max) \n                |> tourney\n    ]  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86854,"user_id":null,"body":"\nlet rec tourney (inp: int list) : int list list =\n    \/\/ your code here\n    match inp with\n    | [] -> failwith \"unreacheable\"\n    | [ x ] -> [ [ x ] ]\n    | l ->\n        let t =\n            l\n            |> List.pairwise\n            |> List.mapi (fun i j -> i, j)\n            |> List.choose\n                (fun (i, (a1, a2)) ->\n                    if i % 2 = 0 then\n                        Some(System.Math.Max(a1, a2))\n                    else\n                        None)\n\n        let newParticipants = if List.length l % 2 = 0 then t else List.last l :: t\n        l :: (tourney newParticipants)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86855,"user_id":null,"body":"let rec intoPairs = function\n  | x :: y :: tail -> (x, y) :: (intoPairs tail)\n  | x :: tail -> (x, 0) :: (intoPairs tail)\n  | [] -> []\n\nlet moveToTheFrontIfAlone list =\n  let len = list |> List.length\n  if list |> List.last |> snd = 0 then\n    let head = list |> List.last\n    let tail = list |> List.take (len - 1)\n    head :: tail\n  else\n    list\n\nlet nextRound round =\n  if round |> List.length = 1 then\n    None\n  else \n    round\n    |> intoPairs\n    |> moveToTheFrontIfAlone\n    |> List.map (fun (a, b) -> max a b)\n    |> Some\n\nlet rec tourney (inp : int list) : int list list =\n  match nextRound inp with\n  | Some round -> inp :: tourney round\n  | None -> [inp]\n  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86856,"user_id":null,"body":"let rec tourney (inp : int list) : int list list =\n    let rec next acc xs =\n        match xs with\n        | [] -> acc |> List.rev\n        | [x] -> x :: (acc |> List.rev)\n        | (x::y::rest) when x > y -> next (x :: acc) rest\n        | (_::y::rest) -> next (y::acc) rest\n\n    match inp with\n    | [] -> []\n    | [x] -> [[x]]\n    | _ ->  inp :: tourney (next [] inp)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86857,"user_id":null,"body":"let rec tourney (inp : int list) : int list list =\n    let getEverySecond = List.mapi (fun i e -> if i % 2 = 0 then Some(e) else None)\n                         >> List.choose id\n    let newInp = if inp.Length % 2 = 1 then inp.[0..inp.Length - 2] else inp\n    let result = List.zip (getEverySecond newInp) (getEverySecond (List.tail newInp))\n                 |> List.map (fun (x, y) -> max x y)\n    if inp.Length % 2 = 1 then\n      inp::tourney (List.last inp::result)\n    elif result.Length > 1 then\n      inp::tourney result\n    else\n      [inp; result]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86858,"user_id":null,"body":"let rec tourney (inp : int list) : int list list =\n    printfn \"%A\" inp\n    let getEverySecond = List.mapi (fun i e -> if i % 2 = 0 then Some(e) else None)\n                         >> List.choose id\n    let newInp = if inp.Length % 2 = 1 then inp.[0..inp.Length - 2] else inp\n    let result = List.zip (getEverySecond newInp) (getEverySecond (List.tail newInp))\n                 |> List.map (fun (x, y) -> max x y)\n    if inp.Length % 2 = 1 then\n      inp::tourney (List.last inp::result)\n    elif result.Length > 1 then\n      inp::tourney result\n    else\n      [inp; result]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86859,"user_id":168,"body":"let rec round acc = function\n  | [] -> List.rev acc\n  | [x] -> x :: List.rev acc\n  | x :: y :: xs -> round (max x y :: acc) xs\n\nlet rec tourney (inp : int list) : int list list =\n  match inp with\n  | []  -> []\n  | [_] -> [inp]\n  | _   -> inp :: tourney (round [] inp)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86860,"user_id":null,"body":"let tourney (inp : int list) : int list list =\n  let rec round (acc: int list) (xs: int list) =\n    match xs with\n      | [] -> List.rev acc\n      | [x] -> (x :: List.rev acc)\n      | x :: (y :: rest) -> round ((max x y)::acc) rest\n      \n  let rec tourney' (acc: int list list) (xs: int list) =\n    match xs with\n      | [] -> List.rev acc\n      | [x] -> List.rev acc\n      | _ -> let ys = round [] xs in\n                 tourney' (ys :: acc) ys \n    \n    \n  tourney' [inp] inp","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"605ae9e1d2be8a0023b494ed":[{"id":86861,"user_id":527,"body":"let countSalutes =\n  Seq.fold\n    (fun (s, r) c -> match c with\n      | '>' -> (s, r + 1)\n      | '<' -> (s + r, r)\n      | '-' -> (s, r))\n    (0, 0)\n  >> fst\n  >> (*) 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86862,"user_id":null,"body":"let count_char c = Seq.filter ((=) c) >> Seq.length\n\nlet rec solve (hallway: string) (answer: int): int =\n  if hallway.Length <= 1 then answer\n  else if hallway.[0] <> '>' then solve hallway.[1..] answer\n  else solve hallway.[1..] (answer + 2 * count_char '<' hallway)\n\nlet countSalutes (hallway: string): int = solve hallway 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86863,"user_id":null,"body":"let countSalutes =\n  Seq.fold (fun (s, r) p -> match p with '>' -> (s, r + 1) | '<' -> (s + 2*r, r) | _ -> (s, r)) (0, 0)\n  >> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86864,"user_id":null,"body":"let countSalutes (hallway : string) : int =\n    let rec count (hall: char list) =\n        match hall with\n        | [] -> 0\n        | h::t when h = '>'-> \n            (t |> List.filter (fun x -> x = '<') |> List.length) * 2 + count t \n        | _:: t -> count t\n    count (hallway |> Seq.toList)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86865,"user_id":null,"body":"let countSalutes (hallway : string) : int =\n  let mutable leftPeopleMeets: int list = []\n  for n in hallway do\n    match n with\n    | '>' -> leftPeopleMeets <- leftPeopleMeets @ [0]\n    | '<' -> leftPeopleMeets <- List.map (fun x -> x + 1) leftPeopleMeets\n    | _ -> ()\n  List.sum leftPeopleMeets * 2","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86866,"user_id":null,"body":"let countSalutes (hallway : string) : int =\n    let count (p, s) c =\n        match c with\n        | '>' -> (p + 1, s)\n        | '<' when p > 0 -> (p, s + p * 2)\n        | _ -> (p, s)\n    Seq.fold count (0, 0) hallway |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86867,"user_id":168,"body":"let countSalutes (hallway : string) : int =\n  hallway\n  |> Seq.fold (fun (n, l) x -> \n    if x = '<' then (n + l, l) elif x = '>' then (n, l + 2) else (n, l))\n    (0, 0)\n  |> fst\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86868,"user_id":null,"body":"let countSalutes (hallway : string) : int =\n    let rec counter leftyCount acc lst =\n        match lst with\n        | [] -> acc * 2\n        | x :: xs ->\n            match x with\n            | '>' -> counter (leftyCount + 1) acc xs\n            | '<' -> counter leftyCount (acc + leftyCount) xs\n            | _ -> counter leftyCount acc xs\n     \n    hallway |> Seq.toList |> counter 0 0 ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86869,"user_id":53,"body":"let countSalutes (hallway : string) : int =\n  let mutable r = 0\n  let mutable s = 0\n  for i in 0 .. (String.length hallway) - 1 do\n    if hallway.[i] = '>' then\n      r <- r + 1\n    else if hallway.[i] = '<' then\n      s <- s + 2 * r\n  s","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86870,"user_id":491,"body":"let countSalutes (hallway : string) : int =\n    let count target = Seq.filter ((=) target) >> Seq.length\n    let rec countSalutes acc = function\n        | head::tail -> countSalutes (acc + if head <> '>' then 0 else 2 * count '<' tail) tail \n        | _ -> acc\n    hallway |> Seq.toList |> countSalutes 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"606efc6a9409580033837dfb":[{"id":86871,"user_id":null,"body":"open FSharp.Core\nlet plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n  let stem = String.replicate water \"-\"\n  let flower = String.replicate fert seed\n  match temp with\n  | temp when 20 <= temp && temp <= 30 -> String.replicate water (stem + flower)\n  | _ -> (String.replicate water stem) + seed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86872,"user_id":null,"body":"let grow = String.replicate\nlet plant (seed: string) (water: int) (fert: int) (temp: int): string =\n  if temp >= 20 && temp <= 30 then grow water (grow water \"-\" + grow fert seed)\n  else grow (water * water) \"-\" + seed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86873,"user_id":null,"body":"let plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n    match temp with\n    | x when x >= 20 && x <= 30 ->\n        [for stem in 1 .. water ->\n            [for s in 1 .. water -> \"-\"] @ [for s in 1 .. fert -> seed]\n        ] |> List.concat |> String.concat \"\"\n    | _ ->  [for stem in 1 .. water -> \n                [for s in 1 .. water -> \"-\"]\n            ] @ [[seed]] |> List.concat |> String.concat \"\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86874,"user_id":null,"body":"open System\nlet plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n  let printOnePlant (stemCount: int) (flowersCount: int) (flowerChar:string) =\n    List.init stemCount (fun _ -> \"-\") @ List.init flowersCount (fun _ -> flowerChar)\n    |> String.Concat\n  \n  match temp >= 20 && temp <= 30 with\n  | true ->\n      List.init water (fun _ -> printOnePlant water fert seed) |> String.Concat\n  | false ->\n      List.init water (fun _ -> printOnePlant water 0 seed) @ [ seed ]\n      |> String.Concat  ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86875,"user_id":null,"body":"open System\n\nlet plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n  let goodTemp = 20 <= temp && temp <= 30\n\n  if not goodTemp then\n    [\n      for _ in 1..(water * water) -> \"-\"\n      yield seed\n    ]\n    |> String.concat \"\"\n  \n  else\n    [\n      for _ in 1..water do\n        for _ in 1..water -> \"-\"\n        for _ in 1..fert -> seed\n    ]\n    |> String.concat \"\"\n    \n    ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86876,"user_id":null,"body":"let plant (s : string) (w : int) (f : int) (t : int) : string =\n  [\n    for i=1 to w do\n      for j=1 to w do\n        yield \"-\"\n      for k=1 to f do\n        if t >= 20 && t <= 30 || i=w && k=f then\n          yield s\n        else ()\n  ] |> List.reduce (+)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86877,"user_id":null,"body":"let plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n    if temp >= 20 && temp <= 30 \n        then (String.replicate water \"-\") + (String.replicate fert seed) |> String.replicate water\n        else String.replicate (water * water) \"-\" + seed \n        ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86878,"user_id":53,"body":"let plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n  let stem = \"-\"\n  if 20 <= temp && temp <= 30 then\n    String.replicate water ((String.replicate water stem) + (String.replicate fert seed))\n  else\n    String.replicate water (String.replicate water stem) + seed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86879,"user_id":491,"body":"let plant (seed : string) (water : int) (fert : int) (temp : int) : string =\n    let r = String.replicate\n    if 20 <= temp && temp <= 30 then r water (r water \"-\" + r fert seed) else r (water * water) \"-\" + seed","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"609eee71109f860006c377d1":[{"id":86880,"user_id":null,"body":"let lastSurvivor : string -> int list -> string =\n    List.fold (fun str index -> str.Remove(index, 1))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86881,"user_id":null,"body":"let rec lastSurvivor (letters: string) (coords: int list): string =\n  let c_list = letters |> Seq.toList\n  let rec solve (lst: char list) (coords: int list): string =\n    if List.isEmpty coords then string(lst.[0])\n    else if coords.[0] = 0 then solve lst.[1..] coords.[1..]\n    else solve (lst.[..coords.[0] - 1] @ lst.[coords.[0] + 1..]) coords.[1..]\n  solve c_list coords","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86882,"user_id":null,"body":"let lastSurvivor (letters : string) (coords : int list) : string =\n  let rec lastSurvivor' (letters: string) coords =\n    match (letters, coords) with\n    | letters, [] -> letters\n    | letters, c::cs -> lastSurvivor' (letters.Remove(c, 1)) cs\n  lastSurvivor' letters coords","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86883,"user_id":null,"body":"let rec lastSurvivor (letters : string) (coords : int list) : string =\n    match coords with\n    | [] -> letters\n    | h::t -> lastSurvivor (letters.Remove (h,1)) t","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86884,"user_id":null,"body":"open System\nlet rec lastSurvivor (letters : string) (coords : int list) : string =\n        let indexed = Seq.indexed letters\n        let currentIndex = if coords.Length > 0 then coords.Head else 0\n        let removed = Seq.filter(fun (i,k) -> not (i=currentIndex)) indexed\n                      |> Seq.map(fun (i,k) -> k)\n                      |> String.Concat\n        match coords.Length with\n        | x when x = 0 -> letters\n        | x -> lastSurvivor removed coords.Tail","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86885,"user_id":null,"body":"let lastSurvivor (letters : string) (coords : int list) : string =\n  let mutable newString = letters\n  let mutable pos = 0\n  let mutable i = 0\n  while String.length newString > 1 do\n    pos <- coords.[i]\n    newString <- newString.[0..(pos-1)] + newString.[(pos+1)..]\n    i <- i + 1\n  newString","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86886,"user_id":null,"body":"let lastSurvivor (letters : string) (coords : int list) : string =\n    coords \n    |> List.fold (fun (state:string, offset) index -> (state.Remove(index-offset,1), offset)  ) (letters, 0)\n    |> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86887,"user_id":null,"body":"let lastSurvivor (letters : string) (coords : int list) : string =\n  coords |> List.fold (fun s x -> s.Remove(x, 1)) letters","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86888,"user_id":null,"body":"let lastSurvivor (letters : string) (coords : int list) : string =\n  coords |> List.fold (fun acc i -> acc.Remove(i,1)) letters","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86889,"user_id":168,"body":"let rec lastSurvivor (letters : string) (coords : int list) : string =\n  match coords with\n  | [] -> letters.[0..0]\n  | x :: xs -> lastSurvivor (String.init (String.length letters - 1) (fun i -> let j = if i < x then i else i + 1 in letters.[j..j])) xs","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"62a611067274990047f431a8":[{"id":86890,"user_id":491,"body":"let opposite n firstValue secondValue =\n  List.init n (fun i -> if i % 2 = 0 then firstValue else secondValue)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86891,"user_id":null,"body":"let opposite n firstValue secondValue =\n  if n = 0 then []\n  else\n    let arr = [ for a in 1 .. n -> if a % 2 <> 0 then firstValue else secondValue ]\n    arr","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86892,"user_id":168,"body":"let opposite n firstValue secondValue =\n  [ for i in 1..n -> if i % 2 = 1 then firstValue else secondValue ]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86893,"user_id":null,"body":"let rec opposite n firstValue secondValue =\n  if n = 0 then [] else\n  firstValue :: opposite (n-1) secondValue firstValue","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86894,"user_id":527,"body":"let rec opposite n x y = match n with 0 -> [] | _ -> x :: opposite (n - 1) y x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86895,"user_id":null,"body":"let opposite n firstValue secondValue = [1..n] |> List.map (fun i -> if i % 2 = 1 then firstValue else secondValue)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86896,"user_id":null,"body":"let opposite n firstValue secondValue =\n  Seq.initInfinite (fun i -> if (i % 2 = 0) then firstValue else secondValue) |> Seq.take n |> List.ofSeq","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86897,"user_id":null,"body":"let opposite n firstValue secondValue =\n  [1..n] |> List.map (fun k -> if (k%2 = 1) then firstValue else secondValue)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86898,"user_id":220,"body":"let opposite n firstValue secondValue =\n  fun idx -> if idx % 2 = 0 then firstValue else secondValue\n  |> List.init n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86899,"user_id":53,"body":"let opposite n a b = List.init n (fun m -> if m % 2 = 0 then a else b)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"62a933d6d6deb7001093de16":[{"id":86900,"user_id":491,"body":"let getTheVowels =\n    let reducer (acc, nxt) c = if c = nxt then let nxt' = \"aeiou\".[(Seq.findIndex ((=) c) \"aeiou\" + 1) % 5] in (acc + 1, nxt') else acc, nxt\n    Seq.fold reducer (0, 'a') >> fst\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86901,"user_id":null,"body":"let vowels = Map [('a', 'e'); ('e', 'i'); ('i', 'o'); ('o', 'u'); ('u', 'a')]\n\nlet mutateState (next, count) char =\n    match char = next with\n    | true -> (vowels.[char], count + 1)\n    | false -> (next, count)\n    \nlet getTheVowels (inputString : string) = \n    inputString\n    |> Seq.fold mutateState ('a', 0)\n    |> snd","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86902,"user_id":null,"body":"let getTheVowels (inputString : string) =\n  let vowels = \"aeiou\"\n  let rec helperFunc (str: string) (curr: int) (numb: int) (ind: int) =\n    if (curr >= (String.length str)) then\n      numb\n    elif (vowels.IndexOf(str.[curr]) = ind) then\n      helperFunc str (curr + 1) (numb + 1) ((ind + 1) % vowels.Length)\n    else\n      helperFunc str (curr + 1) numb ind\n      \n  helperFunc inputString 0 0 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86903,"user_id":168,"body":"let getTheVowels (inputString : string) =\n  let vowels = \"aeiou\"\n  let rec count k = function\n    | [] -> k\n    | x :: xs when x = vowels.[k % 5] -> count (k + 1) xs\n    | _ :: xs -> count k xs\n  count 0 (Seq.toList inputString)","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86904,"user_id":null,"body":"let getTheVowels (s: string): int =\n  let rec solve (s: string) (answer: int): int =\n    if String.length s = 0 then answer\n    else if \"aeiou\".[answer % 5] = s.[0] then solve s.[1..] (answer + 1)\n    else solve s.[1..] answer\n  solve s 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86905,"user_id":null,"body":"type CountProgress = { Next:char; Count:int }  \n\nlet getTheVowels (inputString : string) =\n\n    let TestChar state c =\n        if c = state.Next then\n            match c with\n            |'a' -> { Next = 'e'; Count = state.Count + 1 }\n            |'e' -> { Next = 'i'; Count = state.Count + 1 }\n            |'i' -> { Next = 'o'; Count = state.Count + 1 }\n            |'o' -> { Next = 'u'; Count = state.Count + 1 }\n            |'u' -> { Next = 'a'; Count = state.Count + 1 }\n            |_ ->  failwith \"\"\n        else\n            state\n\n    inputString.ToCharArray()\n    |> Array.fold TestChar {Next = 'a'; Count = 0} \n    |> fun result -> result.Count\n\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86906,"user_id":null,"body":"let getTheVowels =\n  Seq.fold (fun i c -> i + (if c = \"aeiou\".[i % 5] then 1 else 0)) 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86907,"user_id":null,"body":"let getTheVowels (inputString : string) =\n    let vowels = [| 'a'; 'e'; 'i'; 'o'; 'u' |]\n    ((0, 0), inputString)\n        ||> Seq.fold(fun (vowelIndex, count) curr -> \n            if curr = vowels.[vowelIndex] then\n                (((vowelIndex + 1) % Array.length vowels), count + 1)\n            else\n                (vowelIndex, count)\n            )\n        |> fun (_, count) -> count\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86908,"user_id":53,"body":"let getTheVowels =\n    Seq.fold (fun (r, m) c -> if c = m then let n = \"aeiou\".[(Seq.findIndex ((=) c) \"aeiou\" + 1) % 5] in (r + 1, n) else r, m) (0, 'a') >> fst","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86909,"user_id":null,"body":"let getNextVowel c = \n    match c with\n    | 'a' -> 'e'\n    | 'e' -> 'i'\n    | 'i' -> 'o'\n    | 'o' -> 'u'\n    | 'u' -> 'a'\n    | _ -> failwith \"wrong input\" \n\nlet getTheVowels (inputString : string) =\n    let rec count chars currentVowel acc =\n        match chars with\n        | [] -> acc\n        | h::t when h = currentVowel -> count t (getNextVowel currentVowel) (acc + 1)\n        | _::t -> count t currentVowel acc\n    count (inputString |> Seq.toList) 'a' 0","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"52ffcfa4aff455b3c2000750":[{"id":86910,"user_id":null,"body":"open System\n\ntype Result<'T, 'E> = \n  | Success of 'T\n  | Failure of 'E\n\nmodule PLib =\n  type Position = int\n\n  type Input<'M> = {\n    Str : string;\n    Position : Position;\n    EOF : bool;\n    Meta : 'M\n  }\n\n  let moveInput input = \n    let lng = input.Str.Length\n    if input.EOF then\n      (None, input)\n    else\n      match input.Position with\n      | x when x < lng - 1 -> (Some input.Str.[input.Position], { input with Position = input.Position + 1 })\n      | _ -> (Some input.Str.[input.Position], { input with EOF = true })\n\n\n  type ParserResult<'T, 'M> = Result<'T * Input<'M>, string>\n\n  type Parser<'T, 'M> = {\n    Fn: Input<'M> -> ParserResult<'T, 'M>\n    Label: string\n  }\n\n  let inputFromStr meta value =\n    { Str = value; Position = 0; EOF = false; Meta = meta }\n\n  let runParser parser input =\n    match parser.Fn input with\n    | Success (s, i) -> Success (s, i)\n    | Failure f -> Failure (sprintf \"Parser '%s' failed at %i with: %s\" parser.Label input.Position f)\n\n\n  let runParserStr parser identifier str =\n    inputFromStr identifier str\n    |> runParser parser\n\n  let printResult result =\n    match result with\n    | Success (r, _) -> printfn \"OK: %O\" r\n    | Failure e -> printfn \"Parse error: %s\" e\n\n  let createParser fn label =\n    { Fn = fn; Label = label }\n\n  let withLog parser =\n    let fnWrap i =\n      \/\/printfn \"Executing { %s } at pos %i.\" parser.Label i.Position\n      let result = parser.Fn i\n      \/\/match result with\n      \/\/| Success (s, i) -> printfn \"OK.\"\n      \/\/| Failure _ -> printfn \"Failed.\"\n      result\n    { parser with Fn = fnWrap}\n    \n  let withLabel label parser =\n    { parser with Label = label }\n\n  let withLabelLog label parser = ((withLabel label) >> withLog) parser\n\n  let returnP value =\n    createParser (fun i -> Success (value, i)) (sprintf \"return(%O)\" value)\n\n  let failP msg =\n    createParser (fun i -> Failure msg) (sprintf \"fail(%s)\" msg)\n\n  let bindP fn parser = \n    createParser \n      (fun input ->\n        \/\/ printfn \"Executing: %s, at %O\" parser.Label input\n        match runParser parser input with\n        | Success (s, i) -> \n          let newParser = fn s\n          runParser newParser i\n        | Failure f -> \n          Failure f)\n      (sprintf \"bind(%s)\" parser.Label)\n  let ( >>= ) p fn = bindP fn p\n  let ( =<< ) fn p = bindP fn p\n\n  let bindMeta fn parser =\n    createParser\n      (fun input ->\n        match runParser parser input with\n        | Success (s, i) -> \n          let newParser = fn (s, input.Meta)\n          runParser newParser i\n        | Failure f -> \n          Failure f)\n      (sprintf \"bindMeta(%s)\" parser.Label)\n  let ( !>>= ) p fn = bindP fn p\n  let ( =<<! ) fn p = bindP fn p\n\n  let mapP fn = \n    bindP (fn >> returnP)\n\n  let ( <!> ) = mapP\n  let ( |>> ) x f = mapP f x\n\n  let fullBindP fs ff parser =\n    createParser \n      (fun input ->\n        match runParser parser input with\n        | Success (s, i) -> \n          let newParser = fs s\n          runParser newParser i\n        | Failure f -> \n          let npf = ff f\n          runParser npf input)\n      (sprintf \"bind(%s)\" parser.Label)\n\n  let applyP fnp arg1 =\n    fnp >>= (fun fx -> arg1 >>= (fx >> returnP) )\n\n  let ( <*> ) = applyP\n\n  let lift2 fn a b =\n    returnP fn <*> a <*> b\n\n  let pChar char =\n    createParser \n      (fun input -> \n        let c, newInput = moveInput input\n        match c with \n        | Some inputChar ->\n          if inputChar = char then\n            Success (char, newInput)\n          else\n            Failure (sprintf \"Expected '%c' but got '%c'.\" char inputChar)\n        | None ->\n          Failure \"Reached end of input.\")\n      (sprintf \"'%c'\" char)\n\n  let andThen p1 p2 =\n    { \n      (p1 >>= (fun s1 ->\n      p2 |>> (fun s2 -> (s1, s2)))) \n      with\n        Label = sprintf \"%s && %s\" p1.Label p2.Label \n    }\n\n  let ( .>>. ) = andThen\n\n\n  let orElse p1 p2 =\n    createParser \n      (fun input ->\n        match runParser p1 input with\n        | Success (s1, i1) -> Success (s1, i1)\n        | Failure f1 ->\n          match runParser p2 input with\n          | Success (s2, i2) -> Success (s2, i2)\n          | Failure f2 -> Failure f2)\n      (sprintf \"%s || %s\" p1.Label p2.Label)\n  let ( <|> ) = orElse\n\n\n  let choise parsers =\n    List.reduce (<|>) parsers\n\n  let anyOf charList =\n    choise (List.map pChar charList)\n\n  let rec sequence parserList =\n    let concat h t = h::t\n    let concatP = lift2 concat\n    match parserList with\n    | [] -> returnP []\n    | head::tail ->\n      concatP head (sequence tail)\n\n  let ( >>. ) p1 p2 =\n    p1 .>>. p2 |>> (fun (_, s2) -> s2)\n    |> withLabel (sprintf \"%s >>. %s\" p1.Label p2.Label)\n\n  let ( .>> ) p1 p2 =\n    p1 .>>. p2 |>> (fun (s1, _) -> s1)\n    |> withLabel (sprintf \"%s .>> %s\" p1.Label p2.Label)\n\n  let between p1 p2 p3 =\n    p1 >>. p2 .>> p3\n    |> withLabel (sprintf \"%s >>. %s .>> %s\" p1.Label p2.Label p3.Label)\n\n  let rec private parseZeroOrMore limit parser input =\n    match runParser parser input with\n    | Failure _ -> Success ([], input)\n    | Success (s, i) ->\n      match limit with\n      | 0 ->\n        Success ([], input)\n      | _ ->\n        match parseZeroOrMore (if limit = -1 then -1 else limit - 1) parser i with\n        | Failure _ -> \n          Success ([s], i)\n        | Success (s1, i1) ->\n          Success (s::s1, i1)\n  \n  let rec private parseExactRange amount parser input =\n    if amount = 0 then\n      Success ([], input)\n    else\n      match runParser parser input with\n      | Failure _ -> Failure \"Unable to parse exact amount\"\n      | Success (s, i) ->\n        match parseExactRange (amount - 1) parser i with\n        | Failure _ -> Failure \"Unable to parse exact amount\"\n        | Success (s1, i1) ->\n          Success (s::s1, i1)\n\n  let many parser =\n    createParser \n      (parseZeroOrMore -1 parser)\n      (sprintf \"many(%s)\" parser.Label)\n      \n  let manyTake take parser =\n    createParser \n      (parseZeroOrMore take parser)\n      (sprintf \"many(%s)\" parser.Label)\n\n  let manyExact take parser =\n    createParser\n      (parseExactRange take parser)\n      (sprintf \"many-e(%s)\" parser.Label)\n\n  let many1 parser =\n    createParser\n      (fun input -> \n        match runParser parser input with\n        | Failure f -> Failure f\n        | Success (s, i) -> \n          match parseZeroOrMore -1 parser i with\n          | Success (s1, i1) ->\n            Success (s::s1, i1)\n          | Failure _ ->\n            Success ([s], i))\n      (sprintf \"many1(%s)\" parser.Label)\n\n  let opt parser =\n    { \n      (fullBindP \n          (Some >> returnP)\n          (fun _ -> returnP None)\n          parser)\n      with Label = sprintf \"opt(%s)\" parser.Label\n    }\n\n  let sepBy parser sep =\n    opt parser >>= (fun so -> \n      match so with\n      | Some s ->\n        many (sep >>. parser) |>> (fun x -> s::x)\n      | None -> returnP [])\n    |> withLabel (sprintf \"%s[(%s) %s]*\" parser.Label sep.Label parser.Label)\n    \n  let rec sepByWTake take parser sep =\n    opt parser >>= (fun so -> \n      match so with\n      | Some s ->\n        manyTake (take - 1) (sep >>. parser) |>> (fun x -> s::x)\n      | None -> returnP [])\n    |> withLabel (sprintf \"%s[(%s) %s]*\" parser.Label sep.Label parser.Label)\n  \n  let sepByExactRange amount parser sep =\n    if amount = 0 then\n      returnP []\n    else\n      parser >>= (fun s ->\n          manyExact (amount - 1) (sep >>. parser) |>> (fun x -> s::x))\n      |> withLabel (sprintf \"%s[(%s) %s]{%i}\" parser.Label sep.Label parser.Label (amount - 1))\n\n  let sepBy1 parser sep =\n    parser .>>. many (sep >>. parser)\n    |>> fun (p,pList) -> p::pList\n    |> withLabel (sprintf \"%s[(%s) %s]+\" parser.Label sep.Label parser.Label)\n\n  let toString charList = \n    String(charList |> Array.ofList)\n\n  let asList parser =\n    parser\n    |>> (fun x -> [x])\n\n  let pString str =\n    str \n    |> Seq.map pChar\n    |> List.ofSeq\n    |> sequence\n    |>> toString\n\n  let createParserForwardedToRef<'t, 'm>() =\n      let dummyParser= \n          let innerFn input : ParserResult<'t, 'm> = failwith \"unfixed forwarded parser\"\n          {Fn=innerFn; Label=\"unknown\"}\n      let parserRef = ref dummyParser \n\n      let innerFn input = \n          runParser !parserRef input \n      let wrapperParser = {Fn=innerFn; Label=\"unknown\"}\n      wrapperParser, parserRef\n\n\nmodule ExpressionModel =\n  type Operator =\n    | Add\n    | Sub\n    | Multiply\n    | Divide\n    | Module\n\n  type Expression =\n    {\n      Left : Factor\n      Operator : Operator\n      Right : ExprOrFactor\n    }\n\n  and ExprOrFactor =\n    | Expression of Expression\n    | Factor of Factor\n\n  and FunctionDef =\n    {\n      Name : string\n      Parameters : string list\n      Body : ExprOrFactor\n    }\n\n  and Factor =\n    | Number of float\n    | Variable of string\n    | FunctionCall of string * ExprOrFactor list\n    | Assignment of string * ExprOrFactor\n    | Grouped of ExprOrFactor\n\n  and Input =\n    | FuncDef of FunctionDef\n    | Expr of ExprOrFactor\n\n  type Identity = \n    | Function of int \n    | Variable\n\n\nmodule Rpn =\n  open ExpressionModel\n  type RpnItem = \n    | Num of float\n    | Operation of Operator\n    \n  type Rpn =\n    {\n      PendingOperations : Operator list\n      ReversedItems : RpnItem list\n    }\n\n  let initRpn =\n    {\n      PendingOperations = []\n      ReversedItems = []\n    }\n\n  let getOperatorOrder op =\n    match op with\n    | Multiply | Divide | Module -> 1\n    | Add | Sub -> 2\n    \n  let calc x y op =\n    match op with\n    | Add -> x + y\n    | Sub -> x - y\n    | Multiply -> x * y\n    | Divide -> if (y <> 0.0) then x \/ y else failwith \"ERROR: Unable to divide by zero.\"\n    | Module -> x % y\n  \n  let reduceRpn existingItems opps = \n    opps\n    |> List.rev\n    |> List.fold \n      (fun items op -> \n        match items with\n        | x::y::rest ->\n          match x, y with\n          | Num r, Num l ->\n            let res = calc l r op\n            (Num res)::rest\n          | _ ->\n            failwith \"ERROR: Unbale to evaluate\"\n        | _ ->\n          failwith \"ERROR: Unbale to evaluate\")\n      existingItems\n\n  let recreateRpn newEntry rpn =\n    let rec addOperation pending newOp =\n      match pending with\n      | [] ->\n        [newOp], []\n      | h::t ->\n        if getOperatorOrder newOp >= getOperatorOrder h then\n          let newPending, toAdd = addOperation t newOp\n          newPending, List.rev (h::toAdd)\n        else\n          newOp::pending, []\n\n    match newEntry with\n    | Operation o -> \n      let newPending, toEval = addOperation rpn.PendingOperations o\n      let calculatedItems = reduceRpn rpn.ReversedItems toEval\n      { rpn with PendingOperations = newPending; ReversedItems = calculatedItems }\n    | Num n ->\n      { rpn with ReversedItems = (Num n)::rpn.ReversedItems }\n\n  let calcRpn rpn =\n    match reduceRpn rpn.ReversedItems (List.rev rpn.PendingOperations) with\n    | [Num x] -> Success x\n    | _ -> Failure \"Ivalid RPN.\"\n\n\nmodule Parser =\n  open PLib\n  open ExpressionModel\n\n  let whitespace = anyOf [' ';'\\t']\n  let whitespaces = many whitespace |> withLabelLog \"wss\"\n  let whitespaces1 = many1 whitespace |> withLabelLog \"wss1\"\n  let digit = anyOf ['0'..'9']\n  let letter = anyOf (['a'..'z'] @ ['A'..'Z']) \n  let number = \n    let withDot = \n      many digit .>>. (pChar '.' >>. many1 digit)\n      |>> (fun (l1, l2) -> \n        let numStr = toString l1 + \".\" + toString l2\n        float numStr)\n    let withoutDot =\n      many1 digit\n      |>> (toString >> float)\n    (withDot <|> withoutDot)\n    |> withLabelLog \"number\"\n\n  let letterOrUnderscore = letter <|> pChar '_'\n\n  let identifier = \n    letterOrUnderscore .>>. many (letterOrUnderscore <|> digit)\n    |>> (fun (l, rest) -> [l] @ rest |> toString)\n    |> withLabelLog \"identifier\"\n\n  let identifierWs =\n    between whitespaces identifier whitespaces\n\n  let assignOp = pChar '=' |> withLabelLog \"=\"\n  let arrowOp = pString \"=>\" |> withLabelLog \"=>\"\n  let operator =\n    choise [\n      pChar '*' |>> (fun _ -> Multiply); \n      pChar '\/' |>> (fun _ -> Divide); \n      pChar '%' |>> (fun _ -> Module); \n      pChar '+' |>> (fun _ -> Add);\n      pChar '-' |>> (fun _ -> Sub);\n    ]\n    |> withLabelLog \"operator\"\n\n  let expr, exprRef = createParserForwardedToRef<ExprOrFactor, string -> Identity option>()\n\n  let functionCall =\n    bindMeta\n      (fun (id, identify: string -> Identity option) -> \n        match identify id with\n        | Some (Function num) ->\n          sepByExactRange num expr whitespaces1 \n          |>> (fun x -> FunctionCall (id, x))\n        | Some Variable ->\n          failP (sprintf \"%s is no a function\" id)\n        | None ->\n          failP \"Unexpected identifier\")\n      (identifier .>> whitespaces)\n\n  let inBraces parser =\n    between\n      (pChar '(' .>>. whitespaces)\n      parser\n      (whitespaces .>>. pChar ')')\n\n  let assignment =\n    identifier .>> (between whitespaces assignOp whitespaces) .>>. expr\n    |>> Assignment\n    |> withLabelLog \"F_assign\"\n  let grouped =\n    inBraces (expr |> withLabelLog \"(EXPR)\")\n    |>> Grouped\n    |> withLabelLog \"F_grouped\"\n\n  let variable =\n    identifier\n    |> bindMeta\n      (fun (id, identify: string -> Identity option) -> \n        match identify id with\n        | Some (Function _) ->\n          failP \"Expected identifier but got function\"\n        | Some Variable ->\n          returnP id\n        | None ->\n          returnP id)\n    |> withLabelLog \"variable\"\n  let factor =\n    choise [\n      assignment;\n      functionCall;\n      number |>> Factor.Number |> withLabelLog \"F_number\";\n      variable |>> Factor.Variable |> withLabelLog \"F_variable\";\n      grouped ]\n    |> withLabelLog \"FACT\"\n  \n  let fnIdentifier =\n    between whitespaces1 identifier whitespaces\n  let fnParams =\n    sepBy identifier whitespaces1\n  let arrowOpWs =\n    between whitespaces arrowOp whitespaces\n  let functionDef =\n    pString \"fn\" >>. fnIdentifier .>>. fnParams .>> arrowOpWs .>>. expr\n    |>> (fun ((name, parameters), expr) -> \n      FuncDef { Name = name; Parameters = parameters; Body = expr })\n    |> withLabelLog \"F_DEF\"\n  \n  let private wsOperator = between whitespaces operator whitespaces\n\n  let exprParser =\n    let factorAndOptExpr = \n      (factor) .>>. opt (wsOperator .>>. expr)\n      |>> (fun (left, right) -> \n        match right with\n        | Some (op, ex) -> \n          Expression { Left = left; Operator = op; Right = ex}\n        | None -> \n          Factor left)\n    factorAndOptExpr\n    |> withLabelLog \"EXPR\"\n  exprRef := exprParser\n\n  let inputParser =\n    functionDef <|> (expr |>> Input.Expr)\n\n  type ParsedInput =\n    | OK of Input\n    | Error of string\n\n  let parseInputString identifier input =\n    let res = runParserStr inputParser identifier input\n    match res with\n    | Success (data, i) ->\n      if i.EOF then\n        OK data\n      else \n        Error (sprintf \"Unexpected character '%c' at col: %i.\" i.Str.[i.Position] i.Position)\n    | Failure f ->\n      Error f\n\n\nmodule Solution =\n  open System.Collections.Generic\n  open ExpressionModel\n  open Rpn\n\n  type EvaluationResult =\n    | Value of float\n    | NameConflict\n    | UnknownIdentifier of string\n    | InvalidArguments of int * int\n    | Unexpected\n    | EvaluationError of string\n\n  type Scope = \n    {\n      Functions : IDictionary<string, FunctionDef>\n      Variables : IDictionary<string, float>\n    }\n    \n  let asNullable (value: 'a) =\n    new Nullable<'a>(value)\n\n  let resultToFloatSafe result =\n    match result with\n    | Value v -> asNullable v\n    | _ -> Nullable()\n\n  let addOrUpdateDict (key: 'a) (value: 'b) (dict: IDictionary<'a, 'b>) =\n    if dict.ContainsKey(key) then\n      dict.[key] <- value\n    else\n      dict.Add(key, value)\n\n  let rec getVariable varName scope =\n    match Seq.tryFind (fun x -> x = varName) scope.Variables.Keys with\n    | Some vn ->\n      Some scope.Variables.[vn]\n    | None ->\n        None\n\n  let optValueAsResult varName = function\n    | Some v -> Value v\n    | None -> UnknownIdentifier varName\n\n  let rec getFunction funcName scope =\n    match Seq.tryFind (fun x -> x = funcName) scope.Functions.Keys with\n    | Some vn ->\n      Some scope.Functions.[vn]\n    | None ->\n      None\n\n  let initScope =\n    {\n      Functions = Dictionary<string, FunctionDef>();\n      Variables = Dictionary<string, float>();\n    }\n\n  let rec evaluateExpressionOrFact exprScope exprOrFact =\n    let callFunction funcDef args scope =\n      let funcScope = initScope\n      let rec fillScope argList i parentScope =\n        match argList with\n        | [] ->\n          (true, None)\n        | h::t ->\n          match h with\n          | Value v ->\n            let argName = funcDef.Parameters.[i]\n            addOrUpdateDict argName v funcScope.Variables |> ignore\n            fillScope t (i + 1) parentScope\n          | rest ->\n            (false, Some rest)\n\n      match fillScope args 0 scope with\n      | true, _ ->\n        evaluateExpressionOrFact funcScope funcDef.Body\n      | false, None ->\n        Unexpected\n      | false, Some err ->\n        err\n\n    let evaluateFunctionCall name args scope =\n      match getFunction name scope with\n      | Some fdef ->\n        let evaluatedArgs = args |> List.map (evaluateExpressionOrFact scope)\n        callFunction fdef evaluatedArgs scope\n      | None ->\n        UnknownIdentifier name\n\n    let evaluateFactor factor scope =\n      match factor with\n      | Factor.Number n -> \n        Value n\n      | Factor.Variable id ->\n        scope\n        |> getVariable id \n        |> optValueAsResult id\n      | Factor.FunctionCall (name, args) ->\n        evaluateFunctionCall name args scope \n      | Factor.Assignment (name, value) ->\n        match getFunction name scope with\n        | Some _ -> \n          NameConflict\n        | None ->\n          match evaluateExpressionOrFact scope value with\n          | Value evaluatedExpr -> \n            addOrUpdateDict name evaluatedExpr scope.Variables |> ignore\n            Value evaluatedExpr\n          | rest ->\n            rest\n      | Factor.Grouped grouped ->\n        evaluateExpressionOrFact scope grouped\n\n    let evaluateExpression expr scope =\n      let rec visit exp rpn =\n        match evaluateFactor exp.Left scope with\n        | Value left ->\n          let newRpn = \n            rpn\n            |> recreateRpn (Num left)\n            |>recreateRpn (Operation exp.Operator)\n          match exp.Right with\n          | Factor f ->\n            match evaluateFactor f scope with\n            | Value right ->\n              Success (newRpn |> recreateRpn (Num right))\n            | _ ->\n              Failure \"ERROR: Unable to evaluate\"\n          | Expression rexpr ->\n            visit rexpr newRpn\n        | _ ->\n          Failure \"ERROR: Unable to evaluate\"\n\n      match visit expr initRpn with\n      | Success rpn ->\n        match calcRpn rpn with\n        | Success value ->\n          Value value\n        | Failure err ->\n          EvaluationError err\n      | Failure err ->\n        EvaluationError err\n\n    match exprOrFact with\n    | Factor factor ->\n      evaluateFactor factor exprScope\n    | Expression expr ->\n      evaluateExpression expr exprScope\n\n  type Interpreter ()=\n    let nullResult = new Nullable<float>()\n    let mutable rootScope = initScope\n\n    let validateFuncDef fd =\n      let rec valiadteBody exprOrFact = \n        match exprOrFact with\n        | Factor f ->\n          match f with\n          | Factor.Variable v -> \n            List.contains v fd.Parameters\n          | _ -> true\n        | Expression expr ->\n          valiadteBody (Factor expr.Left) \n            && valiadteBody expr.Right\n\n      if not (valiadteBody fd.Body) then\n        failwith \"ERROR: Unknown identifier in function body.\"\n\n    let declareFunction fd =\n      if rootScope.Variables.ContainsKey(fd.Name) then\n        failwithf \"ERROR: Name conflict. Variable '%s' is already defined.\" fd.Name\n      do validateFuncDef fd\n      if rootScope.Functions.ContainsKey(fd.Name) then\n        rootScope.Functions.[fd.Name] <- fd\n      else\n        rootScope.Functions.Add(fd.Name, fd)\n      nullResult\n\n    let identificator name =\n      match getVariable name rootScope with\n      | None ->\n        match getFunction name rootScope with\n        | None -> None\n        | Some f -> Some (Identity.Function f.Parameters.Length)\n      | Some _ -> Some Identity.Variable\n\n    member this.input (input: string) : Nullable<float> =\n      let parsed = Parser.parseInputString identificator (input.Trim())\n\n      match parsed with\n      | Parser.OK model ->\n        match model with\n        | FuncDef fd ->\n          declareFunction fd\n        | Expr expr -> \n          match evaluateExpressionOrFact rootScope expr with\n          | Value v ->\n            asNullable v\n          | NameConflict ->\n            failwith \"ERROR: Name conflict.\"\n          | UnknownIdentifier ui ->\n            failwithf \"ERROR: Unknown identifier '%s'.\" ui\n          | InvalidArguments (expected, got) ->\n            failwithf \"ERROR: Invalid amount of argumets. Expected %i but got %i.\" expected got\n          | Unexpected ->\n            failwith \"ERROR: Unexpected error.\"\n          | EvaluationError err ->\n            failwithf \"ERROR: Evaluation error: %s.\" err\n      | Parser.Error err ->\n        failwithf \"ERROR: %s\" err","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86911,"user_id":null,"body":"module Solution = begin\n  open System\n  open System.Text.RegularExpressions\n  open System.Collections.Generic\n\n  type Operator = Plus | Minus | Mul | Div | Mod | Eq\n  type Expression =\n    | Num of float | Ident of string | Expr of Expression * Operator * Expression\n    | Parens of Expression | Call of string * Expression list\n  type StackPart = Ex of Expression | Op of Operator | OpParen | Sig of string * string list | FnName of string * int\n\n  type Interpreter ()=\n    let tokenize input = \n        [for i in (new Regex(\"=>|[-+*\/%=\\\\(\\\\)]|[A-Za-z_][A-Za-z0-9_]*|[0-9]*(\\\\.?[0-9]+)\")).Matches(input) -> i.Groups.[0].Value]\n\n    let globals = new Dictionary<string, float>()\n    let functions = new Dictionary<string, string list * Expression>()\n\n    let (|ReduceCall|_|) (stack:StackPart list) =\n        match stack with\n        | FnName(name, 0)::_stack -> Some (Ex(Call(name, []))::_stack)\n        | Ex expr1::FnName(name, 1)::_stack -> Some (Ex(Call(name, [expr1]))::_stack)\n        | Ex expr2::Ex expr1::FnName(name, 2)::_stack -> Some (Ex(Call(name, [expr1; expr2]))::_stack)\n        | Ex expr3::Ex expr2::Ex expr1::FnName(name, 3)::_stack -> Some (Ex(Call(name, [expr1; expr2; expr3]))::_stack)\n        | _ -> None\n\n    let (|ReducePrecedence|_|) (stack:StackPart list) =\n        let needRotate op1 op2 =\n            match op2 with\n            | Mul | Div | Mod ->\n                match op1 with\n                | Plus | Minus | Eq -> true\n                | _ -> false\n            | Plus | Minus | Eq ->\n                match op1 with\n                | Eq -> true\n                | _ -> false\n        match stack with\n        | Ex(Expr(Expr(expr1, op1, expr2), op2, expr3))::_stack when needRotate op1 op2 ->\n            let newExpr = Expr(expr1, op1, (Expr(expr2, op2, expr3)))\n            Some (Ex newExpr::_stack)\n        | _ -> None\n\n    let (|ReduceExpression|_|) (stack:StackPart list) =\n        match stack with\n        | Ex expr2::Op op::Ex expr1::_stack ->\n            let newExpr = Expr(expr1, op, expr2)\n            Some (Ex newExpr::_stack)\n        | _ -> None\n\n    let (|Number|_|) (tokens:string list) =\n        match tokens with\n        | number::rest ->\n            match Double.TryParse number with\n            | true, value -> Some (Num value, rest)\n            | _ -> None\n        | _ -> None\n\n    let (|Operator|_|) (tokens:string list) =\n        match tokens with\n        | \"+\"::rest -> Some (Plus, rest) | \"-\"::rest -> Some (Minus, rest) | \"*\"::rest -> Some (Mul, rest)\n        | \"\/\"::rest -> Some (Div, rest) | \"%\"::rest -> Some (Mod, rest) | \"=\"::rest -> Some (Eq, rest)\n        | _ -> None\n\n    let (|OpenParen|_|) (tokens:string list) =\n        match tokens with\n        | \"(\"::rest -> Some (rest)\n        | _ -> None\n\n    let (|CloseParen|_|) (tokens:string list) =\n        match tokens with\n        | \")\"::rest -> Some (rest)\n        | _ -> None\n\n    let (|Function|_|) (tokens:string list) =\n        match tokens with\n        | \"fn\"::name::rest ->\n            let rec extractParams pars = function\n                | \"=>\"::rest -> (pars |> List.rev, rest)\n                | name::rest -> extractParams (name::pars) rest\n                | _ -> failwith \"Error\"\n            let pars, rest = extractParams [] rest\n            Some (name, pars, rest)\n        | _ -> None\n\n    let (|FunctionCall|_|) (tokens:string list) =\n        match tokens with\n        | ident::rest ->\n            match rest with\n            | \"=\"::_ -> None\n            | _ ->\n                match functions.TryGetValue ident with\n                | true, (pars, _) -> Some (ident, List.length pars, rest)\n                | _ -> None\n        | _ -> None\n\n    let (|Identifier|_|) (tokens:string list) =\n        match tokens with\n        | ident::rest -> Some (Ident ident, rest)\n        | _ -> None\n\n    let rec parse stack tokens =\n        match stack with\n        | ReduceCall _stack\n        | ReducePrecedence _stack\n        | ReduceExpression _stack -> parse _stack tokens\n        | _ ->\n            match tokens with\n            | Number (number, rest) ->\n                match stack with\n                | Op op::Ex left::_stack -> parse (Ex(Expr(left, op, number))::_stack) rest\n                | _ -> parse (Ex number::stack) rest\n            | Operator (op, rest) -> parse (Op op::stack) rest\n            | OpenParen rest -> parse (OpParen::stack) rest\n            | CloseParen rest ->\n                match stack with\n                | Ex expr::OpParen::_stack -> parse (Ex(Parens expr)::_stack) rest\n                | _ -> None\n            | Function (name, pars, rest) -> parse (Sig(name, pars)::stack) rest\n            | FunctionCall (name, num, rest) -> parse (FnName(name, num)::stack) rest\n            | Identifier (ident, rest) ->\n                match stack with\n                | Op op::Ex left::_stack -> parse (Ex(Expr(left, op, ident))::_stack) rest\n                | _ -> parse (Ex ident::stack) rest\n            | [] -> stack |> List.rev |> Some\n            | _ -> None\n\n    let rec evalExpr expr (locals:IDictionary<string, float option>) =\n        match expr with\n        | Expr(Ident ident, Eq, expr) ->\n            match functions.TryGetValue ident with\n            | true, _ -> None\n            | _ ->\n                match evalExpr expr locals with\n                | Some res ->\n                    match globals.TryGetValue ident with | true, _ -> globals.[ident] <- res | _ -> globals.Add(ident, res)\n                    Some res\n                | _ -> None\n        | Expr(expr1, op, expr2) ->\n            match evalExpr expr1 locals, evalExpr expr2 locals with\n            | Some res1, Some res2 ->\n                let func = match op with | Plus -> (+) | Minus -> (-) | Mul -> (*) | Div -> (\/) | Mod -> (%) | _ -> fun _ v -> v\n                func res1 res2 |> Some\n            | _ -> None\n        | Num num -> Some num\n        | Ident ident ->\n            match locals.TryGetValue ident with\n            | true, value -> value\n            | _ ->\n                match globals.TryGetValue ident with\n                | true, value -> Some value\n                | _ -> None\n        | Parens expr -> evalExpr expr locals\n        | Call(name, exprs) ->\n            let results = exprs |> List.map (fun expr -> evalExpr expr locals)\n            match functions.TryGetValue name with\n            | true, (pars, expr) ->\n                let locals = dict(List.zip pars results)\n                evalExpr expr locals\n            | _ -> None\n\n    member this.input input : Nullable<float> =\n        let tokens = tokenize input\n        let tree = parse [] tokens\n        match tree with\n        | Some([Ex expr]) ->\n            match evalExpr expr (dict[]) with\n            | Some res -> new Nullable<float>(res)\n            | _ -> new Nullable<float>()\n        | Some(Sig(name, pars)::Ex expr::_) ->\n            match functions.TryGetValue name with | true, _ -> functions.[name] <- (pars, expr) | _ -> functions.Add(name, (pars, expr))\n            new Nullable<float>()\n        | _ -> new Nullable<float>()\nend","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86912,"user_id":168,"body":"module Solution = begin\n\n  open System\n  open System.Text.RegularExpressions\n  open System.Collections.Generic\n  \n  let flip f x y = f y x\n  let curry f a b = f (a, b)\n  let const' x _ = x\n  let cons h t = h :: t\n  \n  type Parser<'b, 'a> = Parser of ('b list -> ('a * 'b list) option)\n  \n  let runParser (Parser f) = f\n  \n  let parse (p: Parser<'b, 'a>) (s: seq<'b>) : 'a =\n    match runParser p (Seq.toList s) with\n    | Some (v, _) -> v\n    | _ -> failwith \"No parse\"\n  \n  let value a = Parser (fun s -> Some (a, s))\n  \n  let (>>=) p f =\n    Parser (fun s ->\n      match runParser p s with\n      | Some (v, s') -> runParser (f v) s'\n      | None -> None)\n  \n  let empty = Parser (fun _ -> None)\n  \n  type ParserBuilder() =\n    member x.Bind(p, f) = p >>= f\n    member x.Return(v) = value v\n    member x.ReturnFrom(p) = p\n    member x.Zero() = empty\n  \n  let parser = ParserBuilder()\n  \n  let (<%>) f p = p >>= (f >> value)\n  let (<%) v p = const' v <%> p\n  let (<*>) p1 p2 = p1 >>= flip (<%>) p2\n  let ( *> ) p1 p2 = p1 >>= (fun _ -> p2)\n  let ( <* ) p1 p2 = p1 >>= (fun v -> p2 *> value v)\n  \n  let (<|>) p q =\n    Parser (fun s ->\n      match runParser p s with\n      | None -> runParser q s\n      | res -> res)\n  \n  let rec replicate n p =\n    if n <= 0 then\n      value []\n    else\n      cons <%> p <*> replicate (n - 1) p\n  \n  let item = Parser (function [] -> None | h :: t -> Some(h, t))\n  let eof = Parser (function [] -> Some((), []) | _ -> None)\n  let satisfy pred = item >>= fun c -> if pred c then value c else empty\n  \n  let chainl1 (p: Parser<'s, 'a>) (op: Parser<'s, 'a -> 'a -> 'a>) : Parser<'s, 'a> =\n    let rec rest a = (op <*> value a <*> p >>= rest) <|> value a\n    p >>= rest\n  \n  let delay p arg = Parser (fun s -> runParser (p arg) s)\n  \n  let rec many1 p = cons <%> p <*> many p\n  and     many  p = delay many1 p <|> value []\n  \n  let oneOf s = satisfy (flip Seq.contains s)\n  let token c = satisfy ((=) c)\n  \n  type Function = \n    { Arguments : string list\n      Body : string list }\n  \n  type Environment = \n    { Variables : IDictionary<string, float>\n      Functions : IDictionary<string, Function> }\n    static member Empty = { Variables = Dictionary(); Functions = Dictionary() }\n  \n  let number = float <%> satisfy (fun (t: string) -> Char.IsNumber t.[0])\n  let identifier = satisfy (fun (t: string) -> Char.IsLetter t.[0])\n  let op (f: float -> float -> float) tok = f <% token tok\n  \n  let rec variable env = \n    parser {\n      let! name = identifier\n      if env.Variables.ContainsKey name then\n        return env.Variables.[name]\n      elif env.Functions.ContainsKey name then\n        let f = env.Functions.[name]\n        let! args = replicate (List.length f.Arguments) (expr env)\n        return evalFunc f args\n      else\n        failwith (\"Undefined variable: \" + name)\n    }\n  and assignment env =\n    parser {\n      let! name = identifier <* token \"=\"\n      let! v = expr env\n      if env.Functions.ContainsKey name then\n        failwith (\"Variable \" + name + \" overrides an existing function\")\n      else\n        env.Variables.[name] <- v\n        return v\n    }\n  and funcDecl env =\n    parser {\n      let! name = token \"fn\" *> identifier\n      let! args = many identifier <* token \"=>\"\n      let! body = many item\n      if env.Variables.ContainsKey name then\n        failwith (\"Function \" + name + \" overrides an existing variable\")\n      else\n        let f = { Arguments = args; Body = body }\n        env.Functions.[name] <- f\n        evalFunc f (Seq.initInfinite (const' 0.0)) |> ignore\n        return Nullable<float>()\n    }\n  and factor env = number <|> variable env <|> (token \"(\" *> delay expr env <* token \")\")\n  and term   env = chainl1 (factor env) (op ( * ) \"*\" <|> op ( \/ ) \"\/\" <|> op ( % ) \"%\")\n  and expr   env = assignment env <|> chainl1 (term env) (op ( + ) \"+\" <|> op ( - ) \"-\")\n  and evalFunc f (xs: seq<float>) =\n    let env = { Environment.Empty with Variables = Seq.zip f.Arguments xs |> dict }\n    parse (expr env <* eof) f.Body\n  \n  let result env = funcDecl env <|> (Nullable<float> <%> expr env <* eof)\n  \n  type Interpreter () =\n    let tokenize input = \n        [for i in Regex(@\"=>|[-+*\/%=\\(\\)]|[A-Za-z_][A-Za-z0-9_]*|[0-9]*(\\.?[0-9]+)\").Matches(input) -> i.Groups.[0].Value]\n    \n    let environment = Environment.Empty\n  \n    member this.input input : Nullable<float> =\n        let tokens = tokenize input\n        parse (result environment) tokens\n\nend","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86913,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\ntype Operator = Add | Subtract | Multiply | Divide | Modulo\n\ntype Expression =\n    | Number of double\n    | Identifier of string\n    | Assignment of string * Expression\n    | FunctionCall of string * Expression list\n    | Operation of Operator * Expression * Expression\n\ntype FunctionDefinition = \n    | FunctionDefinition of string * string list * Expression\n\ntype ParseResult = \n    | FVal of FunctionDefinition\n    | Val of Expression\n    | ParseError of string\n\nlet matchToken pattern input =\n    let m = Regex.Match(input, sprintf @\"^\\s*(%s)(.*)\" pattern)\n    if m.Success then Some(m.Groups.[1].Value, m.Groups.[2].Value)\n    else None\n    \nlet (|ID|_|) = matchToken \"[A-Za-z_][A-Za-z0-9_]*\"\nlet (|NUM|_|) = matchToken @\"[0-9]*\\.?[0-9]+\" >> Option.map (fun (x, rest) -> float x, rest)\n    \nlet matchSymbol pattern input = matchToken pattern input |> Option.map snd\n\nlet (|ADD|_|) = matchSymbol @\"\\+\"\nlet (|SUB|_|) = matchSymbol \"-\" \nlet (|MUL|_|) = matchSymbol @\"\\*\"\nlet (|MOD|_|) = matchSymbol \"%\"\nlet (|DIV|_|) = matchSymbol \"\/\"\nlet (|LPAREN|_|) = matchSymbol @\"\\(\"\nlet (|RPAREN|_|) = matchSymbol @\"\\)\"\nlet (|FN|_|) = matchSymbol \"fn\"\nlet (|EQUALS|_|) = matchSymbol \"=\"\nlet (|ARR|_|) = matchSymbol \"=>\"\n\nlet (|FACTOP|_|) = function \n    | MUL rest -> Some(Multiply, rest) \n    | DIV rest -> Some(Divide, rest)\n    | MOD rest  -> Some(Modulo, rest)\n    | _ -> None\n\nlet (|SUMOP|_|) = function \n    | ADD rest -> Some(Add, rest) \n    | SUB rest -> Some(Subtract, rest)\n    | _ -> None\n\nlet rec (|MANY|_|) f acc input =\n    match f input with\n    | Some(x, rest) -> (|MANY|_|) f (x::acc) rest\n    | None -> Some(acc, input)\n\nlet rec (|EXACTLY|_|) n f acc input =\n    match f input with\n    | _ when acc |> List.length = n -> Some(acc, input)\n    | Some(x, rest) -> (|EXACTLY|_|) n f (x::acc) rest\n    | None -> None\n\nlet (|EOL|_|) input = if String.IsNullOrWhiteSpace input then Some() else None\n\nlet (|EXPRFULL|_|) vs fs = \n    let rec (|FACTOR|_|) = function\n        | NUM (x, rest) -> Some (Number x, rest)\n        | FNCALL(fc, rest) -> Some (fc, rest)\n        | ID( n, EQUALS( EXPR(e, rest))) -> Some(Assignment(n, e), rest)\n        | ID (id, rest) ->\n            if vs |> List.contains id \n            then Some (Identifier id, rest)\n            else failwithf \"Unknown identifier '%s'.\" id\n        | LPAREN( EXPR(e, RPAREN( rest))) -> Some (e, rest)\n        | _ -> None\n\n    and (|FNCALL|_|) = function\n        | ID(fn, rest) when fs |> Map.containsKey fn ->\n            let (FunctionDefinition(_, argIds, _)) = fs.[fn]\n            let n = argIds.Length \n            match rest with\n            | EXACTLY n (|EXPR|_|) [] (args, rest) -> Some(FunctionCall(fn, args), rest)\n            | _ -> failwithf \"Function '%s' expects %d arguments.\" fn n\n        | _ -> None\n\n    and factorExprs = function FACTOP(op, FACTOR(e, rest)) -> Some((op, e), rest) | _ -> None\n    and sumExprs = function SUMOP(op, TERM(e, rest)) -> Some((op, e), rest) | _ -> None\n\n    and (|TERM|_|) = function\n        | FACTOR(e1, MANY factorExprs [] (exprs, rest)) ->\n            match exprs |> List.rev with\n            | [] -> Some(e1, rest)\n            | exprs ->\n                Some ((e1, exprs) ||> List.fold(fun acc (op, e) -> Operation(op, acc, e)), rest)\n        | _ -> None\n\n    and (|EXPR|_|) = function\n        | TERM(e1, MANY sumExprs [] (exprs, rest)) ->\n            match exprs |> List.rev with\n            | [] -> Some(e1, rest)\n            | exprs ->\n                Some ((e1, exprs) ||> List.fold(fun acc (op, e) -> Operation(op, acc, e)), rest)\n        | _ -> None\n\n    function EXPR(e, EOL) -> Some e | _ -> None\n    \nlet (|FUNC|_|) fs = function\n    | FN( ID( name, MANY (|ID|_|) [] (args, ARR(rest)))) ->\n        match rest with\n        | EXPRFULL args fs (e) -> Some( FunctionDefinition(name, args, e))\n        | _ -> failwith \"Syntax error in function body.\"\n    | _ -> None\n\nlet parse vs fs = function\n    | FUNC fs (f) -> FVal f\n    | EXPRFULL vs fs (e) -> Val e\n    | _ -> ParseError \"Syntax error.\"\n\nlet rec compute vs fs updatedVs expr =\n    match expr with\n    | Number x -> (x, updatedVs)\n    | Identifier id -> (vs |> Map.find id, updatedVs)\n    | Assignment (id, expr) ->\n        let (x, uvs) = compute vs fs updatedVs expr\n        x, (id, x)::uvs \n    | FunctionCall (name, argExprs) ->\n        let (FunctionDefinition(_, argNames, fbody)) = fs |> Map.find name\n        let computedArgs = \n          [ for name, expr in Seq.zip argNames argExprs do\n                let (x, uvs) = compute vs fs updatedVs expr \n                yield (name, x), uvs ]\n        let (args, uvsList) = computedArgs |> List.unzip\n        let (result, _) = compute (Map args) fs updatedVs fbody\n        result, List.concat uvsList\n    | Operation (op, e1, e2) ->\n        match compute vs fs updatedVs e1, compute vs fs updatedVs e2 with\n        | (x1, vs1), (x2, vs2) ->\n            match op with\n            | Add -> (x1 + x2, vs1 @ vs2)\n            | Subtract -> (x1 - x2, vs1 @ vs2)\n            | Multiply -> (x1 * x2, vs1 @ vs2)\n            | Divide when x2 <> 0.0 -> (x1 \/ x2, vs1 @ vs2)\n            | Modulo when x2 <> 0.0 -> (x1 % x2, vs1 @ vs2)\n            | _ -> failwith \"Division by 0.\"\n            \nmodule Solution = \n    type Interpreter () =\n    \n        let mutable values = Map.empty<string, float>\n        let mutable functions = Map.empty<string, FunctionDefinition>\n    \n        let execute input =\n            let identifiers = (values |> Map.toList |> List.map fst)\n            try match parse identifiers functions input with\n                | Val e ->\n                    let (result, newValues) = \n                        compute values functions [] e\n                    let updatedValues = \n                        (values, newValues) \n                        ||> Seq.fold (fun acc (k, v) -> acc |> Map.add k v)\n                    values <- updatedValues\n                    Some result         \n                | FVal (FunctionDefinition(name, _, _) as f) ->\n                    functions <- functions.Add(name, f)\n                    None\n                | ParseError e -> printfn \"%s\" e; None\n            with ex -> printfn \"%s\" ex.Message; None\n       \n        member this.input input =\n            execute input \n            |> Option.toNullable","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86914,"user_id":null,"body":"open System\nopen System.Text.RegularExpressions\n\ntype Operator = Add | Subtract | Multiply | Divide | Modulo\n\ntype Expression =\n    | Number of double\n    | Identifier of string\n    | Assignment of string * Expression\n    | FunctionCall of string * Expression list\n    | Operation of Operator * Expression * Expression\n\ntype FunctionDefinition = \n    | FunctionDefinition of string * string list * Expression\n\ntype ParseResult = \n    | FVal of FunctionDefinition\n    | Val of Expression\n    | ParseError of string\n\nlet matchToken pattern input =\n    let m = Regex.Match(input, sprintf @\"^\\s*(%s)(.*)\" pattern)\n    if m.Success then Some(m.Groups.[1].Value, m.Groups.[2].Value)\n    else None\n    \nlet (|ID|_|) = matchToken \"[A-Za-z_][A-Za-z0-9_]*\"\nlet (|NUM|_|) = matchToken @\"[0-9]*\\.?[0-9]+\" >> Option.map (fun (x, rest) -> float x, rest)\n    \nlet matchSymbol pattern input = matchToken pattern input |> Option.map snd\n\nlet (|ADD|_|) = matchSymbol @\"\\+\"\nlet (|SUB|_|) = matchSymbol \"-\" \nlet (|MUL|_|) = matchSymbol @\"\\*\"\nlet (|MOD|_|) = matchSymbol \"%\"\nlet (|DIV|_|) = matchSymbol \"\/\"\nlet (|LPAREN|_|) = matchSymbol @\"\\(\"\nlet (|RPAREN|_|) = matchSymbol @\"\\)\"\nlet (|FN|_|) = matchSymbol \"fn\"\nlet (|EQUALS|_|) = matchSymbol \"=\"\nlet (|ARR|_|) = matchSymbol \"=>\"\n\nlet (|FACTOP|_|) = function \n    | MUL rest -> Some(Multiply, rest) \n    | DIV rest -> Some(Divide, rest)\n    | MOD rest  -> Some(Modulo, rest)\n    | _ -> None\n\nlet (|SUMOP|_|) = function \n    | ADD rest -> Some(Add, rest) \n    | SUB rest -> Some(Subtract, rest)\n    | _ -> None\n\nlet rec (|MANY|_|) f acc input =\n    match f input with\n    | Some(x, rest) -> (|MANY|_|) f (x::acc) rest\n    | None -> Some(acc, input)\n\nlet rec (|EXACTLY|_|) n f acc input =\n    match f input with\n    | _ when acc |> List.length = n -> Some(acc, input)\n    | Some(x, rest) -> (|EXACTLY|_|) n f (x::acc) rest\n    | None -> None\n\nlet (|EOL|_|) input = if String.IsNullOrWhiteSpace input then Some() else None\n\nlet (|EXPRFULL|_|) vs fs = \n    let rec (|ASSIGN|_|) = function\n        | ID( n, EQUALS( EXPR(e, rest))) -> Some(Assignment(n, e), rest)\n        | _ -> None\n    \n    and (|FACTOR|_|) = function\n        | NUM (x, rest) -> Some (Number x, rest)\n        | FNCALL(fc, rest) -> Some (fc, rest)\n        | ASSIGN(a, rest) -> Some (a, rest)\n        | ID (id, rest) ->\n            if vs |> List.contains id \n            then Some (Identifier id, rest)\n            else failwithf \"Unknown identifier '%s'.\" id\n        | LPAREN( EXPR(e, RPAREN( rest))) -> Some (e, rest)\n        | _ -> None\n\n    and (|FNCALL|_|) = function\n        | ID(fn, rest) when fs |> Map.containsKey fn ->\n            let (FunctionDefinition(_, argIds, _)) = fs.[fn]\n            let n = argIds.Length \n            match rest with\n            | EXACTLY n (|EXPR|_|) [] (args, rest) -> Some(FunctionCall(fn, args), rest)\n            | _ -> failwithf \"Function '%s' expects %d arguments.\" fn n\n        | _ -> None\n\n    and factorExprs = function FACTOP(op, FACTOR(e, rest)) -> Some((op, e), rest) | _ -> None\n    and sumExprs = function SUMOP(op, TERM(e, rest)) -> Some((op, e), rest) | _ -> None\n\n    and (|TERM|_|) = function\n        | FACTOR(e1, MANY factorExprs [] (exprs, rest)) ->\n            match exprs |> List.rev with\n            | [] -> Some(e1, rest)\n            | exprs ->\n                Some ((e1, exprs) ||> List.fold(fun acc (op, e) -> Operation(op, acc, e)), rest)\n        | _ -> None\n\n    and (|EXPR|_|) = function\n        | TERM(e1, MANY sumExprs [] (exprs, rest)) ->\n            match exprs |> List.rev with\n            | [] -> Some(e1, rest)\n            | exprs ->\n                Some ((e1, exprs) ||> List.fold(fun acc (op, e) -> Operation(op, acc, e)), rest)\n        | _ -> None\n\n    function EXPR(e, EOL) -> Some e | _ -> None\n    \nlet (|FUNC|_|) fs = function\n    | FN( ID( name, MANY (|ID|_|) [] (args, ARR(rest)))) ->\n        match rest with\n        | EXPRFULL args fs (e) -> Some( FunctionDefinition(name, args, e))\n        | _ -> failwith \"Syntax error in function body.\"\n    | _ -> None\n\nlet parse vs fs = function\n    | FUNC fs (f) -> FVal f\n    | EXPRFULL vs fs (e) -> Val e\n    | _ -> ParseError \"Syntax error.\"\n\nlet rec compute vs fs updatedVs expr =\n    match expr with\n    | Number x -> (x, updatedVs)\n    | Identifier id -> (vs |> Map.find id, updatedVs)\n    | Assignment (id, expr) ->\n        let (x, uvs) = compute vs fs updatedVs expr\n        x, (id, x)::uvs \n    | FunctionCall (id, argExprs) ->\n        let (FunctionDefinition(fn, argNames, fbody)) = fs |> Map.find id\n        let computedArgs = \n          [ for name, expr in Seq.zip argNames argExprs do\n                let (x, uvs) = compute vs fs updatedVs expr \n                yield (name, x), uvs ]\n        let (args, uvsList) = computedArgs |> List.unzip\n        let (result, _) = compute (Map args) fs updatedVs fbody\n        result, List.concat uvsList\n    | Operation (op, e1, e2) ->\n        match compute vs fs updatedVs e1, compute vs fs updatedVs e2 with\n        | (x1, vs1), (x2, vs2) ->\n            match op with\n            | Add -> (x1 + x2, vs1 @ vs2)\n            | Subtract -> (x1 - x2, vs1 @ vs2)\n            | Multiply -> (x1 * x2, vs1 @ vs2)\n            | Divide when x2 <> 0.0 -> (x1 \/ x2, vs1 @ vs2)\n            | Modulo when x2 <> 0.0 -> (x1 % x2, vs1 @ vs2)\n            | _ -> failwith \"Division by 0.\"\n\nmodule Solution =\n  type Interpreter () =\n  \n      let mutable values = Map.empty<string, float>\n      let mutable functions = Map.empty<string, FunctionDefinition>\n  \n      let execute input =\n          let identifiers = (values |> Map.toList |> List.map fst)\n          try match parse identifiers functions input with\n              | Val e ->\n                  let (result, newValues) = \n                      compute values functions [] e\n                  let updatedValues = \n                      (values, newValues) \n                      ||> Seq.fold (fun acc (k, v) -> acc |> Map.add k v)\n                  values <- updatedValues\n                  Some result         \n              | FVal (FunctionDefinition(name, _, _) as f) ->\n                  functions <- functions.Add(name, f)\n                  None\n              | ParseError e -> printfn \"%s\" e; None\n          with ex -> printfn \"%s\" ex.Message; None\n     \n      member this.input input =\n          execute input \n          |> Option.toNullable\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86915,"user_id":null,"body":"open System\nopen Microsoft.FSharp.Linq\n\n[<AutoOpen>]\nmodule CombinatorParser =\n  type Parser<'a> = Parser of (string -> Result<('a*string), string>)\n\n  let run (Parser parser) string =\n    parser string\n\n  let andThen (Parser parser1) (Parser parser2) =\n    let f stream =\n      parser1 stream\n      |> Result.bind (fun (v1, r1) ->\n          parser2 r1\n          |> Result.map (fun (v2, r2) -> ((v1, v2), r2))\n      )\n    Parser f\n  let (.>>.) = andThen\n\n  let skipLeft (Parser parser1) (Parser parser2) =\n    let f stream =\n      parser1 stream\n      |> Result.bind (fun (_, r1) ->\n          parser2 r1\n      )\n    Parser f\n  let (>>.) = skipLeft\n\n  let skipRight (Parser parser1) (Parser parser2) =\n    let f stream =\n      parser1 stream\n      |> Result.bind (fun (v1, r1) ->\n          parser2 r1\n          |> Result.map (fun (_,r2) -> (v1,r2))\n      )\n    Parser f\n  let (.>>) = skipRight\n\n  let choice (Parser parser1) (Parser parser2) =\n    let f stream =\n      match parser1 stream with\n      | Ok result -> Ok result\n      | Error err ->\n        parser2 stream\n        |> Result.mapError (fun err2 -> sprintf \"Either %s; or %s\" err err2)\n    Parser f\n  let (<|>) = choice\n\n  let choose<'a> (parsers: Parser<'a> list) =\n    parsers\n    |> List.reduce (<|>)\n  \n  let map mapf (Parser parser) =\n    let f stream =\n      parser stream\n      |> Result.map (fun (v,r) -> (mapf v, r))\n    Parser f\n  let (|>>) x f = map f x\n\n  let mapError mapf (Parser parser) =\n    let f stream =\n      parser stream\n      |> Result.mapError mapf\n    Parser f\n  \n  let fromValue v =\n    let f stream =\n      Ok (v, stream)\n    Parser f\n\n  let apply parser1 parser2 =\n    (parser1 .>>. parser2)\n    |> map (fun (f,v) -> f v)\n  let ( <*> ) = apply\n\n  let lift2 f xP yP =\n    fromValue f <*> xP <*> yP\n\n  let rec sequence parsers =\n    let cons head tail = head::tail\n    let consP = lift2 cons\n    match parsers with\n    | [] ->\n        fromValue []\n    | head::tail ->\n        consP head (sequence tail)\n\n  let rec zeroOrMore (Parser parser: Parser<'a>) (input: string) =\n    let first = parser input\n    match first with\n    | Ok (v,r) ->\n        let (result, r2) = zeroOrMore (Parser parser) r\n        (v::result, r2)\n    | Error _ ->\n        ([],input)\n\n  let many parser =\n    let f stream =\n      Ok (zeroOrMore parser stream)\n    Parser f\n\n  let many1 (Parser parser) =\n    let f stream =\n      parser stream\n      |> Result.bind (fun (v,r) ->\n        let (tailResult, r2) = zeroOrMore (Parser parser) r\n        Ok (v::tailResult, r2)\n      )\n    Parser f\n\n  let opt (Parser parser) =\n    let f stream =\n      match parser stream with\n      | Ok (v,r) -> Ok (Some v,r)\n      | Error _ -> Ok (None, stream)\n    Parser f\n\n  let satisfy1many (Parser parser1) parser2 =\n    let f stream =\n      parser1 stream\n      |> Result.bind (fun (v,r) ->\n        let (tailResult, r2) = zeroOrMore parser2 r\n        Ok (v::tailResult, r2)\n      )\n    Parser f\n\n  let createParserForwardedToRef<'a>() =\n    let dummyParser = \n        let innerFn input : Result<'a * string,string> = failwith \"unfixed forwarded parser\"\n        Parser innerFn\n\n    let parserRef = ref dummyParser \n    let innerFn input = run !parserRef input \n\n    Parser innerFn, parserRef\n\n  let logP label =\n    let f stream =\n      printfn \"%s\" label\n      Ok ((), stream)\n    Parser f\n\n  [<AutoOpen>]\n  module PrimitiveParsers =\n    let pchar c = \n      let f stream =\n        if String.IsNullOrEmpty stream then\n          Error \"No more input\"\n        else\n          let first = stream.[0]\n          if first = c then\n            let remaining = stream.[1..]\n            Ok (c, remaining)\n          else\n            Error (sprintf \"Expected %c but got %c\" c first)\n      Parser f\n    \n    let pstring str =\n      str\n      |> Seq.toList\n      |> List.map (pchar) \n      |> sequence\n      |> map (List.toArray >> String)\n  \n    let lowerCaseLetter =\n      ['a'..'z']\n      |> List.map pchar\n      |> choose\n\n    let upperCaseLetter =\n      ['A'..'Z']\n      |> List.map pchar\n      |> choose\n\n    let letter =\n      lowerCaseLetter\n      <|> upperCaseLetter\n      |> mapError (fun _ -> \"Expected letter\")\n\n    let digit =\n      ['0'..'9']\n      |> List.map pchar\n      |> choose\n      |> mapError (fun _ -> \"Expected digit\")\n\n    let whitespaceChar =\n      [' ';'\\t';'\n']\n      |> List.map pchar\n      |> choose\n      |> mapError (fun _ -> \"Expected whitespace\")\n\n    let whitespace =\n      many whitespaceChar\n\n    let integer =\n      opt (pchar '-')\n      .>>. many1 digit\n      |>> (fun (minus, digits) ->\n        let value = digits |> List.toArray |> String |> int\n        match minus with\n        | Some _ -> -value\n        | None -> value\n      )\n\n    let float =\n      opt (pchar '-')\n      .>>. many1 digit\n      .>>. opt (pchar '.' >>. many1 digit)\n      |>> (fun ((m, a),b) -> \n        let value =\n          match b with\n          | Some v -> float (String(a |> List.toArray) + \".\" + String(v |> List.toArray))\n          | None -> float (a |> List.toArray |> String)\n        match m with\n        | Some _ -> -value\n        | None -> value\n      )\n    \n    let anyOf chars =\n      chars\n      |> List.map pchar\n      |> choose\n      |> mapError (fun _ -> sprintf \"Expected any of the following chars: %A\" chars)\n\ntype Operator = Operator of char\n\ntype AST =\n  | Noop\n  | Float of float\n  | Variable of string\n  | FunctionCall of string * AST list\n  | ASTOperator of Operator * left: AST * right: AST\n  | Assignment of variable: AST * value: AST\n  | Function of name: string * parameters: string list * body: AST\n\nlet parseIdentifier = satisfy1many letter (letter <|> digit) |>> (List.toArray >> String)\nlet parseMulDivMod =  anyOf ['*'; '\/'; '%'] |>> Operator\nlet parsePlusMinus = anyOf ['-'; '+'] |>> Operator\nlet parseFloat = float |>> Float\nlet parseExpression, parseExpressionRef = createParserForwardedToRef()\nlet parseFactor =\n  (pchar '(' >>. whitespace >>. parseExpression .>> whitespace .>> pchar ')')\n  <|> (parseIdentifier .>> whitespace .>>. many1 (parseExpression .>> whitespace) |>> FunctionCall)\n  <|> parseFloat\n  <|> (parseIdentifier |>> Variable)\nlet parseAssignment = (parseFactor) .>> whitespace .>> pchar '=' .>> whitespace .>>. parseExpression |>> Assignment\nlet parseFunction =\n  pstring \"fn\"\n  >>. whitespace\n  >>. parseIdentifier \n  .>> whitespace \n  .>>. many (parseIdentifier .>> whitespace)\n  .>> pstring \"=>\"\n  .>> whitespace\n  .>>. parseExpression\n  |>> (fun ((a,b),c) -> Function (a,b,c))\nlet parseASTOperatorMulDivMod =\n  parseFactor .>> whitespace .>>. (many (parseMulDivMod .>> whitespace .>>. parseFactor .>> whitespace ))\n  |>> fun (left,rest) ->\n    let rec build left tail =\n      match tail with\n      | (op, right) :: rest ->\n        let aop = ASTOperator(op, left, right)\n        build aop rest\n      | [] -> left\n    build left rest\nlet parseASTOperatorPlusMinus =\n  parseASTOperatorMulDivMod .>> whitespace .>>. (many (parsePlusMinus .>> whitespace .>>. parseASTOperatorMulDivMod .>> whitespace ))\n  |>> fun (left,rest) ->\n    let rec build left tail =\n      match tail with\n      | (op, right) :: rest ->\n        let aop = ASTOperator(op, left, right)\n        build aop rest\n      | [] -> left\n    build left rest\nparseExpressionRef :=\n  parseFunction\n  <|> parseAssignment\n  <|> parseASTOperatorPlusMinus\n  <|> parseFactor\n\nmodule Solution = \n  type Interpreter () =\n\n    let mutable variables = Map.empty\n    let mutable functions = Map.empty\n\n    let rec eval ast =\n      match ast with\n      | Noop -> Nullable()\n      | Float f -> Nullable(f)\n      | Variable v ->\n        let var =\n          variables\n          |> Map.tryFind v\n        \n        match var with\n        | Some value -> value\n        | None -> \n          \/\/ there could also be a no argument function. This would be maskerading as a variable\n          let fn =\n            functions\n            |> Map.tryFind v\n          match fn with\n          | Some (parameters, body) when parameters = List.empty ->\n            eval (FunctionCall (v,[]))\n          | _ -> failwith (sprintf \"Unknown variable %s\" v)\n      | Assignment (var, value) ->\n        let evalue = eval value\n        match var with\n        | Variable name ->\n          let newVars =\n            let fn = functions |> Map.tryFind name\n            if fn.IsSome then\n              failwith (sprintf \"Existing function with same name: %s\" name)\n            else\n              Map.add name evalue variables\n          variables <- newVars\n        | _ -> failwith \"Can only assign to variables\"\n        evalue\n      | ASTOperator (o, l, r) ->\n        match o with\n        | Operator '+' ->\n          let lv = eval l\n          let lr = eval r\n          lv ?+? lr\n        | Operator '-' ->\n          let lv = eval l\n          let lr = eval r\n          lv ?-? lr\n        | Operator '*' ->\n          let lv = eval l\n          let lr = eval r\n          lv ?*? lr\n        | Operator '\/' ->\n          let lv = eval l\n          let lr = eval r\n          lv ?\/? lr\n        | Operator '%' ->\n          let lv = eval l\n          let lr = eval r\n          lv ?%? lr\n        | Operator x -> failwith (sprintf \"Unknown operator %c\" x)\n      | Function (name, parameters, body) ->\n        let hasDuplicates = parameters |> List.groupBy id |> List.exists (fun (_, v) -> (v |> List.length) > 1)\n        let var = variables |> Map.tryFind name\n        if var.IsSome then\n          failwith (sprintf \"Existing variable with same name: %s\" name)\n        else if hasDuplicates then\n          failwith (sprintf \"Function %s has duplicate parameters names\" name)\n        else\n          functions <- Map.add name (parameters, body) functions\n        Nullable<float>()\n      | FunctionCall (name, parameters) ->\n        match functions |> Map.tryFind name with\n        | Some (paramNames, body) ->\n          let zippedParameters =\n            let paramDifference = (paramNames |> List.length) - (parameters |> List.length)\n            if paramDifference > 0 then\n              \/\/ we need to fix up the parameters. The parameters captured one of the arguments\n              \/\/ Because we don't know the amount of parameters a function has during parsing the function calls are ambiguous.\n              let rec flatten ast =\n                match ast with\n                | FunctionCall (name, parameters) ->\n                  (FunctionCall (name, [])) :: (parameters |> (List.collect flatten))\n                | _ -> [ast]\n\n              let rec rebuild flatAST =\n                match flatAST with\n                | f :: rest ->\n                  match f with\n                  | FunctionCall (name, param) ->\n                    match functions |> Map.tryFind name with\n                    | Some (parameterNames, body) ->\n                      let mutable remainder = rest\n                      let mutable parameters = []\n                      for i in 0 .. parameterNames.Length - 1 do\n                        let param = remainder.Head\n                        match param with\n                        | FunctionCall (name, _) ->\n                          let (param, rem) = rebuild remainder\n                          remainder <- rem\n                          parameters <- param :: parameters\n                        | _ ->\n                          remainder <- remainder.Tail\n                          parameters <- param :: parameters\n                      (FunctionCall (name, parameters), remainder)\n                    | None -> (f, rest)\n                  | _ -> (f, rest)\n                | [] -> (Noop, [])\n              flatten ast\n              |> rebuild\n              |> fun t ->\n                match t with\n                | (FunctionCall (name, parameters), []) ->\n                  List.zip paramNames (parameters |> List.map eval)\n                | _ -> failwith \"Rebuild returned not a function or there are too many parameters\"\n            else\n              List.zip paramNames (parameters |> List.map eval)\n          let subInterpreter = Interpreter()\n          subInterpreter.setFunctions functions\n          let variables = zippedParameters |> Map.ofList\n          subInterpreter.setVariables variables\n          subInterpreter.run body\n        | None -> failwith (sprintf \"unknown function %s\" name)\n\n    member this.setFunctions newFunctions =\n      functions <- newFunctions\n\n    member this.setVariables newVariables =\n      variables <- newVariables\n\n    member this.run ast =\n      eval ast\n\n    member this.input (input: string) : Nullable<float> =\n      printfn \"Input: %s\" input\n\n      let ast = run parseExpression input\n      match ast with\n      | Ok (ast, remaining) -> \n        if String.IsNullOrEmpty remaining then\n          ast |> eval\n        else\n          failwith (sprintf \"Unexpected %c; result: %A\" (remaining.[0]) (ast, remaining))\n      | Error err -> failwith err\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86916,"user_id":null,"body":"\ntype OperatorToken = | Plus | Minus | Multiply | Divide | Modulus | Equal\n \ntype Token =\n    | Number of double\n    | FnKeyword\n    | FnOperator\n    | Identifier of string\n    | Operator of OperatorToken\n    | LeftParen\n    | RightParen\n\nlet convertStringToken (s: string) =\n    match s with\n    | _ when System.Char.IsDigit s.[0] -> Number (System.Double.Parse s)\n    | \"=>\" -> FnOperator\n    | \"fn\" -> FnKeyword\n    | \"+\" -> Operator Plus\n    | \"-\" -> Operator Minus\n    | \"*\" -> Operator Multiply\n    | \"\/\" -> Operator Divide\n    | \"%\" -> Operator Modulus\n    | \"(\" -> LeftParen\n    | \")\" -> RightParen\n    | \"=\" -> Operator Equal\n    | _ -> Identifier s\n\ntype Ident = Ident of string\n\ntype Expression =\n    | NumE of float\n    | BinaryE of Op: OperatorToken * Left: Expression * Right: Expression\n    | IdentifierE of Ident\n    | ApplicationE of FuncName: Ident * Args: Expression list\n\ntype Associativity = | Left | Right\n\ntype OpInfo = { Precedence: int; Associativity: Associativity }\n\nlet opInfoMap =\n    Map.ofList [\n        (Equal, { Precedence = 1; Associativity = Right })\n        (Plus, { Precedence = 2; Associativity = Left })\n        (Minus, { Precedence = 2; Associativity = Left })\n        (Multiply, { Precedence = 3; Associativity = Left })\n        (Divide, { Precedence = 3; Associativity = Left })\n        (Modulus, { Precedence = 3; Associativity = Left })\n    ]\n\nlet rec parseExpr (minPrecision: int) (tokens: Token list): Expression * Token list =\n    let atomLeft, tokens = parseAtom tokens\n    parseExprRest minPrecision atomLeft tokens\n\nand parseExprRest (minPrecision: int) (atomLeft: Expression) (tokens: Token list): Expression * Token list =\n    let tokensSnapshot = tokens\n    match atomLeft, tokens with\n    | _, (Operator op)::tokens ->\n        let { Precedence = prec; Associativity = assoc} = opInfoMap.[op]\n        if prec < minPrecision then\n            \/\/ Don't consume the operator token. If the precedence check here determines\n            \/\/ that the operator precedence isn't high enough then the operator will get added\n            \/\/ onto the preceding expression.\n            atomLeft, tokensSnapshot\n        else\n            let nextMinPrecision = prec + (if assoc = Left then 1 else 0)\n            let atomRight, tokens = parseExpr nextMinPrecision tokens\n            let atomLeft = BinaryE(Op = op, Left = atomLeft, Right = atomRight)\n            parseExprRest minPrecision atomLeft tokens\n    | _, (RightParen)::_ -> atomLeft, tokensSnapshot \/\/ Don't consume the ')'\n    | _, [] -> atomLeft, tokens\n    \/\/ When the left hand side is an identifier, look at the next token to see\n    \/\/ if it's part of a function application\n    | IdentifierE ident, tokens ->\n        let rec parseRight atoms tokens =\n            match tokens with\n            | LeftParen::_\n            | (Identifier _)::_\n            | (Number _)::_ ->\n                let atomRight, tokens = parseAtom tokens\n                parseRight (atomRight::atoms) tokens\n            | _ -> atoms, tokens\n        let atomsRight, tokens = parseRight [] tokens\n        let atomLeft = ApplicationE(FuncName = ident, Args = List.rev atomsRight)\n        parseExprRest minPrecision atomLeft tokens\n    | _, x -> failwith (sprintf \"Unexpected token %A\" x)\n\nand parseAtom (tokens: Token list): Expression * Token list =\n    match tokens with\n    | LeftParen::tokens ->\n        let expr, tokens = parseExpr 1 tokens\n        match tokens with\n        | RightParen::tokens -> expr, tokens\n        | _ -> failwith \"Unmatched (\"\n    | (Number x)::tokens -> NumE x, tokens\n    | (Identifier identName)::tokens -> IdentifierE (Ident identName), tokens\n    | [] -> failwith \"Tokens list cannot be empty\"\n    | x::_ -> failwith (sprintf \"Unexpected token '%A'\" x)\n\ntype FuncDefn = { Name: Ident; Params: Ident list; Body: Expression }\n\ntype Statement =\n    | Function of FuncDefn\n    | ExpressionStatement of Expression\n\nlet parseStatement (tokens: Token list): Statement =\n    match tokens with\n    | FnKeyword::tokens ->\n        let takeChoose = Seq.takeWhile Option.isSome >> Seq.choose id\n        let idents =\n            tokens\n            |> Seq.map (function | (Identifier s) -> Some (Ident s) | _ -> None)\n            |> takeChoose\n            |> Seq.toList\n        \/\/ Check for duplicate parameter names\n        idents\n        |> List.countBy (fun (Ident identName) -> identName)\n        |> List.choose (fun (name, count) -> if count > 1 then Some name else None)\n        |> List.iter (sprintf \"Duplicate parameter names: %A\" >> failwith)\n\n        let tokens = tokens |> List.skip (List.length idents)\n        match idents with\n        | funcName::args ->\n            match tokens with\n            | FnOperator::tokens ->\n                let expr, _ = parseExpr 1 tokens\n                Function { Name = funcName; Params = args; Body = expr }\n            | _ -> failwith \"Expected '=>'\"\n        | _ -> failwith \"Expected 'fn' keyword to be followed by identifiers\"\n    | _ -> let expr, _ = parseExpr 1 tokens in ExpressionStatement expr\n\ntype VariableValue = | FuncRef of FuncDefn | Value of float\n\ntype Env = { Values: Map<Ident, VariableValue>; ParentEnv: Env option }\nlet rec findValueInEnv env ident =\n    match Map.tryFind ident env.Values, env.ParentEnv with\n    | Some v, _ -> Some v\n    | None, Some parentEnv -> findValueInEnv parentEnv ident\n    | None, None -> None\n\nlet rec evalExpr (env: Env) (expr: Expression): float * Env =\n\n    let evalFunc (env: Env) (funcDef: FuncDefn) (argValues: float list) =\n        let childMap =\n            let argVals = argValues |> List.map Value\n            List.zip funcDef.Params argVals |> Map.ofList\n        let childEnv = { Values = childMap; ParentEnv = Some env }\n        evalExpr childEnv funcDef.Body |> fst\n\n    match expr with\n    | BinaryE(Equal, left, right) ->\n        match left with\n        | IdentifierE ident ->\n            let r, env = evalExpr env right\n            match findValueInEnv env ident with\n            | Some(FuncRef _) -> failwith \"Attempt to assign to a variable already defined as a function\"\n            | _ -> ()\n            let env = { env with Values = env.Values |> Map.add ident (Value r) }\n            r, env\n        | _ -> failwith \"Expected left side of assignment to be an identifier\"\n    | BinaryE(op, left, right) ->\n        let l, env = evalExpr env left\n        let r, env = evalExpr env right\n        match op with\n        | Plus -> l + r, env\n        | Minus -> l - r, env\n        | Multiply -> l * r, env\n        | Divide -> l \/ r, env\n        | Modulus -> l % r, env\n        | Equal -> failwith \"Equal operator should have been handled elsewhere\"\n    | NumE x -> x, env\n    | IdentifierE (Ident identName as ident) ->\n        let value = findValueInEnv env ident\n        match value with\n        | Some(Value x) -> x, env\n        | Some(FuncRef funcDef) ->\n            if not <| List.isEmpty funcDef.Params then\n                failwith <| sprintf \"Function '%s' expects arguments but none provided\" identName\n            else\n                \/\/ Even if it was parsed as an identifier, it might have been a function call with no arguments.\n                let rslt = evalFunc env funcDef []\n                rslt, env\n        | None -> failwith  <| sprintf \"Reference to undefined variable %s\" identName\n    | ApplicationE(funcIdentifier, args) ->\n        match Map.find funcIdentifier env.Values with\n        | FuncRef funcDef ->\n            let (|FuncRefIdentifier|_|) (e: Expression) =\n                match e with\n                | (IdentifierE ident) ->\n                    match findValueInEnv env ident with\n                    | Some (FuncRef _) as x -> x\n                    | _ -> None\n                | _ -> None\n\n            let rec evalNArgs\n                    env\n                    remainingCount\n                    acc\n                    (args:Expression list): float list * Env * Expression list =\n                if remainingCount = 0 then\n                    acc, env, args\n                else\n                    match args with\n                    | (FuncRefIdentifier (FuncRef funcDef))::args ->\n                        let argCountRequired = List.length funcDef.Params\n                        let argVals, env, args = evalNArgs env argCountRequired [] args\n                        let result = evalFunc env funcDef (List.rev argVals)\n                        evalNArgs env (remainingCount - 1) (result::acc) args\n                    | arg::args ->\n                        let value, env = evalExpr env arg\n                        evalNArgs env (remainingCount - 1) (value::acc) args\n                    | [] -> acc, env, args\n            let argVals, env, _ = evalNArgs env 999 [] args\n            let appResult = evalFunc env funcDef (List.rev argVals)\n            appResult, env\n        | _ ->\n            let (Ident funcName) = funcIdentifier\n            failwith <| sprintf \"Expected '%s' to reference a function\" funcName\n\nlet evalTokens env tokens =\n    let stmt =\n        match tokens with\n        | [] -> None\n        | _ -> Some (parseStatement tokens)\n    match stmt with\n    | Some(ExpressionStatement(expr)) ->\n        let rslt, env = evalExpr env expr\n        Some rslt, env\n    | Some(Function(f)) ->\n        match findValueInEnv env f.Name with\n        | Some(Value _) ->\n            let (Ident funcName) = f.Name\n            failwith <| sprintf \"Function %s attempts to redefine existng variable\" funcName\n        | _ -> None, { env with Values = env.Values |> Map.add f.Name (FuncRef f) }\n    | _ -> None, env\n\n\nmodule Solution =\n    begin\n\n    open System\n    open System.Text.RegularExpressions\n\n    type Interpreter ()=\n        let mutable env = { Values = Map.empty; ParentEnv = None }\n\n        let tokenize input = \n            let pattern = \"=>|[-+*\/%=\\\\(\\\\)]|[A-Za-z_][A-Za-z0-9_]*|[0-9]*(\\\\.?[0-9]+)\"\n            [ for i in (Regex pattern).Matches(input) -> i.Groups.[0].Value ]\n\n        member this.input input : Nullable<float> =\n            let tokens = tokenize input |> List.map convertStringToken\n            let rslt, env' =\n                try\n                    evalTokens env tokens\n                with\n                | _ -> None, env\n\n            env <- env'\n            Option.toNullable rslt\nend\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86917,"user_id":null,"body":"module Solution = begin\n    open System\n    open System.Linq\n    open System.Text.RegularExpressions\n\n    module Interpreter = \n        type Result<'T> = Total of 'T | Partial of error:string | Nothing\n\n        let floatToString (f:float) : string = f.ToString System.Globalization.CultureInfo.InvariantCulture\n\n        module Tokenizer =\n            let tokenizerRegex = new Regex (@\"fn|=>|\\+|\\-|\\*|\\\/|\\%|\\(|\\)|\\=|[0-9]*\\.?[0-9]+|[a-zA-Z_][a-zA-Z_0-9]*\", RegexOptions.Compiled)\n            let identifierRegex =  new Regex (@\"^[a-zA-Z_][a-zA-Z_0-9]*$\", RegexOptions.Compiled)\n            let numberRegex = new Regex (@\"^[0-9]*\\.?[0-9]+$\", RegexOptions.Compiled)\n\n            type Token =\n                | FnKeyword | RightArrow\n                | Plus | Minus | Asterisk | Slash | Percent\n                | LeftParen | RightParen | Equals\n                | Number of float | Identifier of string | Unknown of string\n\n            let tokenize text =\n                let matches = (tokenizerRegex.Matches text).Cast<Match> ()\n                let totalMatchLength = matches |> Seq.sumBy (fun m -> m.Value.Length)\n                let totalNonWhitespaceTextLength = text |> Seq.where (fun c -> c <> ' ') |> Seq.length\n                if totalMatchLength <> totalNonWhitespaceTextLength then\n                    None\n                else\n                    let tokens =\n                        matches\n                        |> Seq.map (fun m ->\n                            match m.Value with\n                            | \"fn\" -> FnKeyword\n                            | \"=>\" -> RightArrow\n                            | \"+\" -> Plus\n                            | \"-\" -> Minus\n                            | \"*\" -> Asterisk\n                            | \"\/\" -> Slash\n                            | \"%\" -> Percent\n                            | \"(\" -> LeftParen\n                            | \")\" -> RightParen\n                            | \"=\" -> Equals\n                            | number when numberRegex.Match(number).Success -> Number(float(number))\n                            | identifier when identifierRegex.Match(identifier).Success -> Identifier(identifier)\n                            | unknown -> Unknown(unknown))\n                        |> Seq.toList\n                    Some tokens\n\n        module Parser =\n            type Op1Operator = Add | Sub\n            type Op2Operator = Mul | Div | Mod\n\n            type Node =\n                | FunctionNode of name:string * args:string list * body:ExpressionNode\n                | ExpressionNode of ExpressionNode\n            and ExpressionNode =\n                | NumberNode of float\n                | IdentifierNode of string\n                | Op1Node of left:ExpressionNode * others:(Op1Operator * ExpressionNode) list\n                | Op2Node of left:ExpressionNode * others:(Op2Operator * ExpressionNode) list\n                | AssignmentNode of identifier:string * expression:ExpressionNode\n                | FunctionCallNode of identifier:string * args:ExpressionNode list\n\n            type SignatureContext = { variables:string Set; functions:Map<string, int> }\n\n            let rec parse context tokens =\n                match parseFunction context tokens with\n                | Total (functionNode, tail) ->\n                    match tail with\n                    | [] -> Total functionNode\n                    | _ -> Partial \"Something left.\"\n                | Partial error -> Partial error\n                | Nothing ->\n                    match parseExpression context tokens with\n                    | Total (expressionNode, tail) ->\n                        match tail with\n                        | [] -> Total expressionNode\n                        | _ -> Partial \"Something left.\"\n                    | Partial error -> Partial error\n                    | Nothing -> Nothing\n            and parseFunction context tokens =\n                match tokens with\n                | Tokenizer.FnKeyword :: tail ->\n                    match tail with\n                    | Tokenizer.Identifier name :: tail ->\n                        if context.variables.Contains name then\n                            Partial <| sprintf \"Cannot declare function with name '%s' for a variable with name '%s' already exists.\" name name\n                        else\n                            let rec parseArgs args =\n                                function\n                                | Tokenizer.Identifier arg :: tail -> parseArgs (arg :: args) tail\n                                | tail -> (List.rev args, tail)\n                            let args, tail = parseArgs [] tail\n                            match tail with\n                            | Tokenizer.RightArrow :: tail ->\n                                match parseOp1 ({ variables = Set.ofList args; functions = Map.empty }) tail with\n                                | Total (body, _, tail) -> Total (FunctionNode(name, args, body), tail)\n                                | Partial error -> Partial error\n                                | Nothing -> Partial \"Exprected expression after '=>'.\"\n                            | _ -> Partial \"Expected '=>' after function arguments.\"\n                    | _ -> Partial \"Expected function name after 'fn' keyword.\"\n                | _ -> Nothing\n            and parseExpression context tokens : (Node * Tokenizer.Token list) Result =\n                match parseOp1 context tokens with\n                | Total (expression, _, tail) -> Total (Node.ExpressionNode expression, tail)\n                | Partial error -> Partial error\n                | Nothing -> Nothing\n            and parseOp1 context tokens =\n                match parseOp2 context tokens with\n                | Total (left, context, tail) ->\n                    let rec parseOthers others context tokens =\n                        match tokens with\n                        | [] -> Total (List.rev others, context, [])\n                        | opToken :: tail ->\n                            let op =\n                                match opToken with\n                                | Tokenizer.Plus -> Some Add\n                                | Tokenizer.Minus -> Some Sub\n                                | _ -> None\n                            match op with\n                            | Some op ->\n                                match parseOp2 context tail with\n                                | Total (term, context, tail) -> parseOthers ((op, term) :: others) context tail\n                                | Partial error -> Partial error\n                                | Nothing ->\n                                    match op with\n                                    | Add -> Partial \"Expected expression after '+' operator.\"\n                                    | Sub -> Partial \"Expected expression after '-' operator.\"\n                            | None -> Total (List.rev others, context, tokens)\n                    match parseOthers [] context tail with\n                    | Total (others, context, tail) ->\n                        match others with\n                        | [] -> Total (left, context, tail)\n                        | _ -> Total (Op1Node(left, others), context, tail)\n                    | Partial error -> Partial error\n                    | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                | Partial error -> Partial error\n                | Nothing -> Nothing\n            and parseOp2 context tokens =\n                match parseFactor context tokens with\n                | Total (left, context, tail) ->\n                    let rec parseOthers others context tokens =\n                        match tokens with\n                        | [] -> Total (List.rev others, context, [])\n                        | opToken :: tail ->\n                            let op =\n                                match opToken with\n                                | Tokenizer.Asterisk -> Some Mul\n                                | Tokenizer.Slash -> Some Div\n                                | Tokenizer.Percent -> Some Mod\n                                | _ -> None\n                            match op with\n                            | Some op ->\n                                match parseFactor context tail with\n                                | Total (term, context, tail) -> parseOthers ((op, term) :: others) context tail\n                                | Partial error -> Partial error\n                                | Nothing ->\n                                    match op with\n                                    | Mul -> Partial \"Expected expression after '*' operator.\"\n                                    | Div -> Partial \"Expected expression after '\/' operator.\"\n                                    | Mod -> Partial \"Expected expression after '%' operator.\"\n                            | None -> Total (List.rev others, context, tokens)\n                    match parseOthers [] context tail with\n                    | Total (others, context, tail) ->\n                        match others with\n                        | [] -> Total (left, context, tail)\n                        | _ -> Total (Op2Node(left, others), context, tail)\n                    | Partial error -> Partial error\n                    | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                | Partial error -> Partial error\n                | Nothing -> Nothing\n            and parseFactor context tokens =\n                match tokens with\n                | Tokenizer.Number number :: tail -> Total (NumberNode number, context, tail)\n                | Tokenizer.LeftParen :: tail ->\n                    match parseOp1 context tail with\n                    | Total (expression, context, tail) ->\n                        match tail with\n                        | Tokenizer.RightParen :: tail -> Total (expression, context, tail)\n                        | _ -> Partial \"Expected ')' after expression.\"\n                    | Partial error -> Partial error\n                    | Nothing -> Partial \"Expected expression after '('.\"\n                | Tokenizer.Identifier identifier :: Tokenizer.Equals :: tail ->\n                    if context.functions.ContainsKey identifier then\n                        Partial <| sprintf \"Cannot assign to '%s' for a function with name '%s' already exists.\" identifier identifier\n                    else\n                        match parseOp1 context tail with\n                        | Total (expression, context, tail) -> Total (AssignmentNode(identifier, expression), { context with variables = context.variables.Add(identifier) }, tail)\n                        | Partial error -> Partial error\n                        | Nothing -> Partial \"Expected expressions after '='.\"\n                | Tokenizer.Identifier identifier :: tail ->\n                    if context.functions.ContainsKey identifier then\n                        let argCount = context.functions.[identifier]\n                        let rec parseArgs argCount args context tokens =\n                            if argCount > 0 then\n                                match parseOp1 context tokens with\n                                | Total (arg, context, tail) -> parseArgs (argCount - 1) (arg :: args) context tail\n                                | Partial error -> Partial error\n                                | Nothing -> Partial <| sprintf \"Missing arguments for '%s' function call.\" identifier\n                            else\n                                Total (List.rev args, context, tokens)\n                        match parseArgs argCount [] context tail with\n                        | Total (args, context, tail) -> Total (FunctionCallNode(identifier, args), context, tail)\n                        | Partial error -> Partial error\n                        | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                    elif context.variables.Contains identifier then\n                        Total (IdentifierNode identifier, context, tail)\n                    else\n                        Partial <| sprintf \"Unknown indentifier '%s'.\" identifier\n                | _ -> Nothing\n\n            let rec expressionNodeToString expression =\n                match expression with\n                | NumberNode number -> sprintf \"[%s]\" (floatToString number)\n                | IdentifierNode identifier -> identifier\n                | Op1Node(left, others) ->\n                    (String.Join (\" \", others |> List.map (fun (op, factor) -> sprintf \"%s %s\" (match op with Add -> \"+\" | Sub -> \"-\") (expressionNodeToString factor))))\n                    |> sprintf \"[%s %s]\" (expressionNodeToString left)\n                | Op2Node(left, others) ->\n                    (String.Join (\" \", others |> List.map (fun (op, factor) -> sprintf \"%s %s\" (match op with Mul -> \"*\" | Div -> \"\/\" | Mod -> \"%\") (expressionNodeToString factor))))\n                    |> sprintf \"[%s %s]\" (expressionNodeToString left)\n                | AssignmentNode(identifier, expression) -> sprintf \"[%s = %s]\" identifier (expressionNodeToString expression)\n                | FunctionCallNode(identifier, args) -> sprintf \"[%s %s]\" identifier (String.Join (\" \", args |> List.map expressionNodeToString))\n            let nodeToString node =\n                match node with\n                | FunctionNode(name, arg, body) -> sprintf \"[fn %s %s => %s]\" name (String.Join (\" \", arg)) (expressionNodeToString body)\n                | ExpressionNode(expression) -> expressionNodeToString expression\n\n        module Runner =\n            type ValueContext = {\n                variables : Map<string, float>\n                functions : Map<string, string list * Parser.ExpressionNode>\n            }\n            with\n                member this.ToSignatureContext () = {\n                    Parser.SignatureContext.variables = this.variables |> Map.toList |> List.map fst |> Set.ofList\n                    Parser.SignatureContext.functions = this.functions |> Map.map (fun _ -> fst >> List.length)\n                }\n\n            let rec runExpression (context:ValueContext) (expression:Parser.ExpressionNode) : (float * ValueContext) Result =\n                match expression with\n                | Parser.NumberNode number -> Total(number, context)\n                | Parser.IdentifierNode identifier ->\n                    if context.variables.ContainsKey identifier then\n                        Total(context.variables.[identifier], context)\n                    else\n                        Partial <| sprintf \"Unknown variable with name '%s'.\" identifier\n                | Parser.AssignmentNode (identifier, expression) ->\n                    if context.functions.ContainsKey identifier then\n                        Partial <| sprintf \"Cannot assign to '%s' for a function with name '%s' already exists.\" identifier identifier\n                    else\n                        match runExpression context expression with\n                        | Total (exprResult, context) -> Total (exprResult, { context with variables = context.variables.Add (identifier, exprResult) })\n                        | Partial error -> Partial error\n                        | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                | Parser.FunctionCallNode (identifier, args) ->\n                    if context.functions.ContainsKey identifier then\n                        let (argNames, body) = context.functions.[identifier]\n                        if argNames.Length <> args.Length then\n                            Partial <| sprintf \"Wrong number of arguments in '%s' function call.\" identifier\n                        else\n                            let rec runArgs argValues context tail =\n                                match tail with\n                                | arg :: tail ->\n                                    match runExpression context arg with\n                                    | Total (exprResult, context) -> runArgs (exprResult :: argValues) context tail\n                                    | Partial error -> Partial error\n                                    | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                                | [] -> Total (List.rev argValues, context)\n                            match runArgs [] context args with\n                            | Total (argValues, context) ->\n                                let functionContext = {\n                                    ValueContext.variables = Map.ofList <| List.zip argNames argValues\n                                    ValueContext.functions = Map.empty\n                                }\n                                match runExpression functionContext body with\n                                | Total (callResult, _) -> Total (callResult, context)\n                                | Partial error -> Partial error\n                                | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                            | Partial error -> Partial error\n                            | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                    else\n                        Partial <| sprintf \"Unknown function with name '%s'.\" identifier\n                | Parser.Op1Node (left, others) ->\n                    let rec runOp1 leftResult context others =\n                        match others with\n                        | (op, rightExpr) :: others ->\n                            match runExpression context rightExpr with\n                            | Total (rightResult, context) ->\n                                let opResult =\n                                    match op with\n                                    | Parser.Add -> leftResult + rightResult\n                                    | Parser.Sub -> leftResult - rightResult\n                                runOp1 opResult context others\n                            | Partial error -> Partial error\n                            | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                        | [] -> Total (leftResult, context)\n                    match runExpression context left with\n                    | Total (leftResult, context) ->\n                        match runOp1 leftResult context others with\n                        | Total (opResult, context) -> Total (opResult, context)\n                        | Partial error -> Partial error\n                        | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                    | Partial error -> Partial error\n                    | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                | Parser.Op2Node (left, others) ->\n                    let rec runOp2 leftResult context others =\n                        match others with\n                        | (op, rightExpr) :: others ->\n                            match runExpression context rightExpr with\n                            | Total (rightResult, context) ->\n                                let opResult =\n                                    match op with\n                                    | Parser.Mul -> leftResult * rightResult\n                                    | Parser.Div -> leftResult \/ rightResult\n                                    | Parser.Mod -> leftResult % rightResult\n                                runOp2 opResult context others\n                            | Partial error -> Partial error\n                            | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                        | [] -> Total (leftResult, context)\n                    match runExpression context left with\n                    | Total (leftResult, context) ->\n                        match runOp2 leftResult context others with\n                        | Total (opResult, context) -> Total (opResult, context)\n                        | Partial error -> Partial error\n                        | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n                    | Partial error -> Partial error\n                    | Nothing -> Partial \"This shouldn't be possible. Good luck.\"\n\n            let rec run (context:ValueContext) (root:Parser.Node) : (float option * ValueContext) Result =\n                match root with\n                | Parser.Node.FunctionNode (name, args, body) ->\n                    if context.variables.ContainsKey name then\n                        Partial <| \"Cannot declare function with name '%s' for a variable with name '%s' already exists.\"\n                    else\n                        Total (None, { context with functions = context.functions.Add (name, (args, body)) })\n                | Parser.Node.ExpressionNode expression ->\n                    match runExpression context expression with\n                    | Total (exprResult, context) -> Total (Some exprResult, context)\n                    | Partial error -> Partial error\n                    | Nothing -> Nothing\n\n    type Interpreter () =\n        let mutable context = {\n            Interpreter.Runner.ValueContext.variables = Map.empty\n            Interpreter.Runner.ValueContext.functions = Map.empty\n        }\n        member this.input input : Nullable<float> =\n            match Interpreter.Tokenizer.tokenize input with\n            | None -> failwith \"ERROR: Invalid tokens in input.\"\n            | Some tokens ->\n                \/\/ printfn \"Tokenizer: %A\" tokens\n                match Interpreter.Parser.parse (context.ToSignatureContext ()) tokens with\n                | Interpreter.Partial error -> failwithf \"ERROR: %s\" error\n                | Interpreter.Nothing -> failwith \"ERROR: Couldn't parse even a single token.\"\n                | Interpreter.Total root ->\n                    \/\/ printfn \"Parser: %s\" (Interpreter.Parser.nodeToString root)\n                    match Interpreter.Runner.run context root with\n                    | Interpreter.Total (lineResult, newContext) ->\n                        context <- newContext\n                        match lineResult with\n                        | Some lineResult -> new Nullable<float> (lineResult)\n                        | None -> new Nullable<float> ()\n                    | Interpreter.Partial error -> failwithf \"ERROR: %s\" error\n                    | Interpreter.Nothing -> failwithf \"ERROR: Couldn't run even a single node.\"\nend\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86918,"user_id":null,"body":"open System\nopen System.Text\nopen System.Text.RegularExpressions\n\nlet choose_while (pred:'a -> 'u option) (xs: 'a list) : 'a list * 'u list =\n  let rec loop (xs: 'a list) (rev_matches: 'u list) =\n    match xs with\n    | [] -> xs, List.rev rev_matches\n    | x::xs ->\n      match pred x with\n      | Some u -> loop xs (u::rev_matches)\n      | None -> x::xs, List.rev rev_matches\n  loop xs []\n\nmodule Ast =\n    type Token =\n      | IdentifierToken of string\n      | NumberToken of float\n      | OpenParen\n      | CloseParen\n      | FnKeyword\n      | Arrow\n      | Assign\n      | OperatorToken of Operator\n\n    and [<RequireQualifiedAccess>] Precedence = Mult | Add | Apply | Assign | Parens\n      with static member Values = [ Parens; Apply; Assign; Mult; Add; ]\n\n    and [<RequireQualifiedAccess>] InputExpr = \n        | Function of Function\n        | Expr of Expr\n    and Function = { name: string; args: string[]; expr: Expr }\n    and Expr =\n        | Unresolved of Token\n        | Factor of FactorExpr \n        | Combined of lhs : Expr * Operator * rhs: Expr\n        with\n          static member combinedOfTokens(lhs: Expr, op: Operator, rhs: Expr) =\n            match lhs, rhs with\n            | Unresolved _, _\n            | _, Unresolved _ -> failwith \"Expressions can't be unresolved\"\n            | _, _ ->\n              Combined(lhs, op, rhs)\n          \n          static member resolve(expr:Expr) =\n            match expr with\n            | Unresolved tok ->\n              match tok with\n              | Token.NumberToken f -> Expr.Factor (FactorExpr.Number f)\n              | Token.IdentifierToken ident -> Expr.Factor (FactorExpr.Identifier ident)\n              | _ -> failwithf \"Can't resolve token \\\"%s\\\" (%A)\" (tok.GetType().Name) tok\n            | x -> x\n          \n          static member resolve_simple(expr:Expr) =\n            match expr with\n            | Unresolved tok ->\n              match tok with\n              | Token.NumberToken f -> Expr.Factor (FactorExpr.Number f)\n              | Token.IdentifierToken ident -> Expr.Factor (FactorExpr.Identifier ident)\n              | _ -> expr\n            | x -> x\n\n    and FactorExpr =\n        | Number of float\n        | Identifier of string\n        | Assignment of string * Expr\n        | ParenExpr of Expr\n        | FunctionCall of fn_name:string * args: Expr[]\n\n    and Operator = Plus | Minus | Multiply | Divide | Modulo\n\n    let identifierRE = Regex(@\"^([a-zA-Z_]\\w*)$\", RegexOptions.Compiled)\n    \n    let tokenize (s:string) : Token[] =\n      let ret = ResizeArray<Token>()\n\n      let s = \n        [| for i in (new Regex(\"=>|[-+*\/%=\\\\(\\\\)]|[A-Za-z_][A-Za-z0-9_]*|[0-9]*(\\\\.?[0-9]+)\")).Matches(s) do\n             yield i.Groups.[0].Value |]\n\n      [| for p in s do\n           match p with\n           | \"(\" -> yield OpenParen\n           | \")\" -> yield CloseParen\n           | \"fn\" -> yield FnKeyword\n           | \"=>\" -> yield Arrow\n           | \"=\" -> yield Assign\n           | \"+\" -> yield OperatorToken(Plus)\n           | \"-\" -> yield OperatorToken(Minus)\n           | \"*\" -> yield OperatorToken(Multiply)\n           | \"\/\" -> yield OperatorToken(Divide)\n           | \"%\" -> yield OperatorToken(Modulo)\n           | _ ->\n              let ok, f = Double.TryParse(p)\n              if ok then\n                yield NumberToken f\n              else\n                let idm = identifierRE.Match(p)\n                if idm.Success then\n                  yield IdentifierToken p\n                else\n                  failwithf \"Unrecognized token: \\\"%s\\\"\" p |]\n    \n    let parseInputExpr (s:string) (fn_name_and_arities: Map<string, int>) : InputExpr option =\n        let rec pinput(tokens: Token list) =\n            match tokens with\n            | FnKeyword::tokens ->\n              match tokens with\n              | IdentifierToken fn_name::tokens ->\n                let tokens, fn_args = choose_while (function | IdentifierToken ident -> Some ident | _ -> None) tokens \n                \n                match tokens with\n                | Arrow :: tokens ->\n                  let expr = pexpr (tokens |> List.map Unresolved |> List.map Expr.resolve_simple)\n                  InputExpr.Function { Function.name = fn_name; Function.args = (Array.ofList fn_args); Function.expr = expr }\n                | _ -> failwith \"Expected \\\"=>\\\" after argument list\"\n              | _ -> failwith \"Expected function name after \\\"fn\\\"\"\n            | tokens ->\n              let tokens = tokens |> List.map Unresolved |> List.map Expr.resolve_simple\n              let expr = pexpr tokens \n              InputExpr.Expr expr\n\n        and pexprs (tokens: Expr list) : Expr list =\n          let rec group (tokens: Expr list) (prec:Precedence) (rev_items: Expr list) : Expr list =\n            match prec with\n            | Precedence.Parens ->\n              let rec loop (tokens: Expr list) (rev_inner_tokens: Expr list) (rev_acc: Expr list) (depth: int) =\n                match tokens with\n                | Unresolved(CloseParen)::tokens -> \n                  if depth = 1 then \n                    let inner_expr = rev_inner_tokens |> List.rev |> pexpr\n                    let paren_expr = Expr.Factor (FactorExpr.ParenExpr inner_expr)\n                    loop tokens [] (paren_expr::rev_acc) 0\n                  elif depth <= 0 then\n                    failwith \"Unbalanced parens\"\n                  else\n                    loop tokens (Unresolved(CloseParen)::rev_inner_tokens) rev_acc (depth - 1)\n                | Unresolved(OpenParen)::tokens ->\n                  if depth = 0 then\n                    loop tokens rev_inner_tokens rev_acc (depth + 1)\n                  else\n                    loop tokens (Unresolved(OpenParen)::rev_inner_tokens) rev_acc (depth + 1)\n                | tok::tokens ->\n                  if depth > 0 then\n                    loop tokens (tok::rev_inner_tokens) rev_acc depth\n                  else\n                    loop tokens rev_inner_tokens (tok::rev_acc) depth\n                | [] ->\n                  List.rev rev_acc\n              loop tokens [] [] 0\n            | Precedence.Mult | Precedence.Add ->\n              let ops = \n                match prec with\n                | Precedence.Mult -> [Operator.Multiply; Operator.Divide; Operator.Modulo] |> List.map OperatorToken\n                | Precedence.Add -> [Operator.Plus; Operator.Minus] |> List.map OperatorToken\n                | _ -> failwith \"Impossible\"\n\n              let rec loop (tokens: Expr list) (rev_acc: Expr list) =\n                match tokens with\n                | [] -> List.rev rev_acc\n                | a::(Expr.Unresolved op)::b::tokens when List.contains op ops ->\n                  let a = Expr.resolve a\n                  let b = Expr.resolve b\n                  let expr =\n                    match op with\n                    | OperatorToken op -> \n                      Expr.combinedOfTokens(a, op, b)\n                    | Assign ->\n                      failwith \"hm!\"\n                      match a with\n                      | Expr.Factor (FactorExpr.Identifier ident) ->\n                        Expr.Factor (FactorExpr.Assignment(ident, (Expr.resolve b)))\n                      | _ -> failwithf \"Can't assign to a \\\"%s\\\"\" (a.GetType().Name)\n                    | _ -> failwithf \"Unexpected token \\\"%s\\\"\" (op.GetType().Name)\n\n                  let tokens = List.rev (expr :: rev_acc) @ tokens\n                  loop tokens []\n                | tok::tokens ->\n                  loop tokens (tok::rev_acc)\n              loop tokens []\n            \/\/ Assign and Apply are right associative, so we start from the back \n            | Precedence.Assign ->\n              let rec loop rev_items tmp_args =\n                match rev_items with\n                | (Unresolved Assign) :: Expr.Factor (FactorExpr.Identifier ident) :: rev_items ->\n                  match pexprs tmp_args with\n                  | expr::exprs ->\n                    let assignment = Expr.Factor (FactorExpr.Assignment(ident, expr))\n                    let exprs = List.rev rev_items @ assignment :: exprs \n                    loop (List.rev exprs) []\n                  | _ -> failwith \"Needed at least one expression to the right of assignment operator\"\n                | item :: rev_items ->\n                  loop rev_items (item::tmp_args)\n                | [] ->\n                  tmp_args\n              loop (List.rev tokens) []\n\n            | Precedence.Apply ->\n              let rec loop rev_items tmp_args =\n                match rev_items with\n                | (Expr.Factor (FactorExpr.Identifier ident)) as item :: rev_items ->\n                  match fn_name_and_arities.TryFind ident with\n                  | Some arity ->\n                    let arg_exprs = pexprs tmp_args\n                    let args, other = List.splitAt arity arg_exprs\n                    let fn_call = Factor (FactorExpr.FunctionCall(ident, (Array.ofList args)))\n                    let exprs = List.rev (fn_call :: other) @ rev_items\n                    loop exprs []\n                  | None ->\n                    loop rev_items (item::tmp_args)\n                | item :: rev_items ->\n                  loop rev_items (item::tmp_args)\n                | [] ->\n                  tmp_args\n\n              loop (List.rev tokens) []\n            \n          let rec loop (precs: Precedence list) (items: Expr list) =\n            match precs with\n            | [] -> items\n            | prec::precs ->\n              loop precs (group items prec [])\n          loop (Precedence.Values) tokens\n\n        and pexpr (tokens: Expr list) : Expr =\n          match pexprs tokens with\n          | [expr] -> expr\n          | xs -> failwithf \"Expected one expression, but got %d\" (List.length xs)\n          \n        match tokenize s with\n        | [||] -> None\n        | tokens ->\n          Some (pinput (List.ofArray tokens))\n\nmodule Interpreter =\n  open Ast\n  type StateEntry = Variable of float | FunctionDef of def: Function\n  type Env = Map<string, StateEntry>\n\n  let fn_name_and_arities (env:Env) =\n    env\n    |> Seq.choose (fun (KeyValue(k,v)) -> match v with FunctionDef f -> Some (k, f.args.Length) | _ -> None)\n    |> Map.ofSeq\n\n  let eval (env: Env) (expr: InputExpr) : Env * Nullable<float> =\n    let rec validate_fn_body (fn_args: string[]) (expr: Expr) =\n      match expr with\n      | Expr.Factor factor -> \n        validate_fn_body_factor fn_args factor\n      | Expr.Combined (lhs, op, rhs) ->\n        validate_fn_body fn_args lhs\n        validate_fn_body fn_args rhs\n      | Expr.Unresolved _ ->\n        failwith \"Cannot validate unresolved expression\"\n\n    and validate_fn_body_factor (fn_args: string[]) (factor: FactorExpr) = \n      match factor with\n      | FactorExpr.Identifier ident ->\n        if not (Array.contains ident fn_args) then\n          failwithf \"Could not find variable with name \\\"%s\\\"\" ident\n      | FactorExpr.Number _ -> ()\n      | FactorExpr.ParenExpr expr -> validate_fn_body fn_args expr\n      | FactorExpr.Assignment (name, expr) ->\n        if not (Array.contains name fn_args) then\n          failwithf \"Could not find variable with name \\\"%s\\\"\" name\n        validate_fn_body fn_args expr\n      | FactorExpr.FunctionCall (fn_name, fn_args_2) ->\n        match env.TryFind fn_name with\n        | Some (FunctionDef _) ->\n          for arg in fn_args_2 do validate_fn_body fn_args arg\n        | _ -> failwithf \"Could not find function with name \\\"%s\\\"\" fn_name\n\n    and eval_input (env: Env) (expr: InputExpr) =\n      match expr with\n      | InputExpr.Function f ->\n        match env.TryFind f.name with\n        | Some entry ->\n          match entry with\n          | Variable _ -> failwith \"Can't redefine a variable to be a function\"\n          | FunctionDef _ ->\n            validate_fn_body (f.args) (f.expr)\n            Map.add (f.name) (FunctionDef f) env, Nullable<_>()\n        | None ->\n          validate_fn_body (f.args) (f.expr)\n          Map.add (f.name) (FunctionDef f) env, Nullable<_>()\n      | InputExpr.Expr expr ->\n        eval_expr env expr\n\n    and eval_expr (env: Env) (expr: Expr) : Env * Nullable<float> =\n      match expr with\n      | Expr.Factor factor ->\n        eval_factor env factor\n      | Expr.Combined (lhs, op, rhs) ->\n        let env, l = eval_expr env lhs\n        let env, r = eval_expr env rhs\n        match op with\n        | Plus -> env, Nullable<float>(l.Value + r.Value)\n        | Minus -> env, Nullable<float>(l.Value - r.Value)\n        | Multiply -> env, Nullable<float>(l.Value * r.Value)\n        | Divide -> env, Nullable<float>(l.Value \/ r.Value)\n        | Modulo -> env, Nullable<float>(l.Value % r.Value)\n      | Expr.Unresolved _ ->\n        failwith \"Cannot evaluate an unresolved expression\"\n\n    and eval_factor (env: Env) (factor: FactorExpr) =\n      match factor with\n      | FactorExpr.Assignment(name, expr) ->\n        let env, (v) = eval_expr env expr\n        let fv : float = v.Value\n        let var = Variable fv\n        match env.TryFind name with\n        | Some entry ->\n          match entry with\n          | Variable _ ->\n            let env = Map.add name var env\n            env, v\n          | FunctionDef _ -> failwithf \"Cannot overwrite function \\\"%s\\\" with variable\" name\n        | None ->\n          let env = Map.add name var env\n          env, v\n      | FactorExpr.FunctionCall(name, args) ->\n        match env.TryFind name with\n        | Some entry ->\n          match entry with\n          | Variable num ->\n            failwithf \"Variable \\\"%s\\\" cannot be used like a function\" name\n          | FunctionDef function_def ->\n            let _env2, ret = eval_fn_call env function_def args\n            \/\/ env2 discarded, because we do not want any modifications as a result of\n            \/\/ assignment calls inside the function body.\n            env, ret\n        | None -> failwithf \"Undefined variable \\\"%s\\\"\" name\n      | FactorExpr.Identifier(name) ->\n        match env.TryFind name with\n        | Some entry ->\n          match entry with\n          | Variable num ->\n            env, Nullable<float>(num)\n          | FunctionDef _ ->\n            failwithf \"Function \\\"%s\\\" cannot be used like a variable\" name\n        | None -> failwithf \"Undefined variable \\\"%s\\\"\" name\n      | FactorExpr.Number(num) ->\n        env, Nullable<float>(num)\n      | FactorExpr.ParenExpr(expr) ->\n        eval_expr env expr\n\n    and eval_fn_call (env:Env) (function_def: Function) (args: Expr[]) =\n      if function_def.args.Length <> args.Length then\n        failwithf \"Expected %d arguments for function \\\"%s\\\", but got %d\" \n          function_def.args.Length function_def.name args.Length\n\n      let env = \n        (env, (Array.zip function_def.args args))\n        ||> Array.fold\n          (fun env (name, expr) ->\n            let env, v = eval_expr env expr \n            Map.add name (Variable v.Value) env)\n   \n      eval_expr env function_def.expr\n\n    eval_input env expr\n\nmodule Solution = begin\n\n  open System\n  open System.Text.RegularExpressions\n\n  type Interpreter () =\n    let mutable _env : Interpreter.Env = Map.empty\n    \n    member this.input input : Nullable<float> =\n      let fn_names = Interpreter.fn_name_and_arities _env\n      match Ast.parseInputExpr input fn_names with\n      | None -> Nullable<float>()\n      | Some expr ->\n        let new_env, ret = Interpreter.eval _env expr\n        _env <- new_env\n        ret\nend\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86919,"user_id":null,"body":"module Types =\n  type arithmetic =  \n  | Mul\n  | Div\n  | Mod\n  | Plus\n  | Minus\n\n  type Operator = \n  | Arithmetic of arithmetic\n  | Set\n  | OpenPar\n  | ClosePar\n\n  type Token =\n    |Fun\n    |Arrow\n    |Operator of Operator\n    |Identifier of string\n    |Numeric of float\n\n  type Node = \n  | Literal of float\n  | Ref of string\n  | Binary of Node * arithmetic * Node \n  | FuncCall of FuncCallNode\n  | FuncAssign of FuncAssignNode\n  | Assign of string * Node\n  and FuncCallNode = \n    {name: string; args:Node list}\n  and FuncAssignNode =\n    {name: string; args : string list; node:Node}  \n\nmodule Tokenizer = \n  open Types\n  open System.Text.RegularExpressions\n\n  let (|MatchNamedGroup|_|) (groupName:string) (groupCollection:GroupCollection) =\n    let m = groupCollection.[groupName] \n    if m.Length = 0 then None else Some m.Value\n\n  let matchOperator = function\n    | \"=\" -> Set\n    | \"(\" -> OpenPar\n    | \")\" -> ClosePar\n    | \"+\" -> Arithmetic Plus \n    | \"-\" -> Arithmetic Minus\n    | \"*\" -> Arithmetic Mul\n    | \"\/\" -> Arithmetic Div\n    | \"%\" -> Arithmetic Mod\n    | _ -> failwith \"Unknown operator\"\n  \n  let tokenize input = \n    [for i in (Regex( \"(?<fn>fn)|(?<arrow>=>)|(?<operator>[-+*\/%=\\\\(\\\\)])|(?<identifier>[A-Za-z_][A-Za-z0-9_]*)|(?<numeric>[0-9]*(\\\\.?[0-9]+))\")).Matches(input) -> \n      match i.Groups with\n      | MatchNamedGroup \"fn\" _ ->  Fun\n      | MatchNamedGroup \"arrow\" _ -> Arrow         \n      | MatchNamedGroup \"operator\" token -> Operator (matchOperator token)     \n      | MatchNamedGroup \"identifier\" token -> Identifier token         \n      | MatchNamedGroup \"numeric\" token -> Numeric (float token)\n      | _ -> failwith \"Unknown group\"]\n\n  let skipToken (t:Token) (tokens:Token list) =\n    match tokens with\n    | [] -> failwith <| sprintf \"Expected %A but input was empty\" t\n    | h::tail -> \n      if t = h\n      then tail\n      else failwith <| sprintf \"Expected %A but was %A\" t h\n\nmodule Parser =\n  open Types\n  open Tokenizer\n  open System.Collections.Generic\n\n  let getOperatorPrecedence op =\n    match op with\n    | Arithmetic a -> \n      match a with\n      |Div|Mod|Mul -> 4\n      |Minus|Plus -> 3\n    | Set -> 1\n    | OpenPar -> 5\n    | ClosePar -> -1  \n\n  let getprecedence t = \n    match t with\n    |Numeric _ -> -1\n    |Identifier _ -> -2\n    |Operator o -> getOperatorPrecedence o\n    |Fun -> 0\n    |Arrow -> 0\n\n  let parse (funcLookup:Dictionary<string, FuncAssignNode>) tokens :Node=  \n    let rec parseExpr tokens minPrecedence: Node * Token list=      \n      let rec parseLed minPrecedence (node,tokens): Node * Token list =\n        match tokens with\n        | [] -> (node, tokens)\n        | t :: tail -> \n          if getprecedence t <= minPrecedence \n          then (node, tokens) \n          else\n            let nodeAndRest =\n              match t with \n              | Operator o -> \n                match o with\n                |Arithmetic a ->\n                  let (next,rest) = parseExpr tail (getprecedence t)\n                  (Binary (node,a,next),rest)\n                |Set ->\n                  parseExpr tail (getprecedence t - 1)\n                  |> fun (next,rest) ->\n                    match node with\n                    |Ref i -> (Assign (i,next),rest)\n                    |_ -> failwith <| sprintf \"Can't assign to %A\" node\n                | OpenPar -> failwith \"Not expected\"\n                | ClosePar -> failwith \"Not expected\"\n              | Fun -> failwith \"Not expected\"\n              | Arrow -> failwith \"Not expected\"\n              | Identifier(_) -> failwith \"Not expected\"\n              | Numeric(_) -> failwith \"Not expected\"\n            parseLed minPrecedence nodeAndRest\n\n      let parseFuncOperands tokens opNum =\n        {1..opNum} \n        |> Seq.fold (\n          fun (res, tokens) _ ->\n            parseExpr tokens (getprecedence Fun - 1)\n            |> fun (next, rest) -> res @ [next], rest) ([], tokens)\n\n      let funcNud tokens = \n        let nameArgsAndBody = tokens\n        let arrowInd = tokens |> List.tryFindIndex (fun t -> t = Arrow)\n        let (nameArgsAndBody,body) = \n          match arrowInd with\n          | Some i -> nameArgsAndBody |> List.splitAt i\n          | None -> failwith \"No => in fun definition\"\n        let nameArgs =\n          nameArgsAndBody\n          |> List.map (fun x -> match x with |Identifier i -> i; |_ -> failwith <| sprintf \"Expected identifier but was %A\" x)\n        parseExpr body.Tail 0\n        |> fun (node, rest) -> FuncAssign {name = nameArgs.Head;args = nameArgs.Tail;node = node}, rest \n          \n\n      let identifierNud i tokens = \n        match funcLookup.TryGetValue(i) with\n        | (true, v) -> \n          parseFuncOperands tokens v.args.Length\n          |> fun (next, rest) -> FuncCall {name = i; args = next}, rest\n        |_ -> (Ref i, tokens)\n      \n      let operatorNud op tokens = \n        match op with\n        |OpenPar -> parseExpr tokens (getOperatorPrecedence ClosePar)\n                    |> fun (next,rest) -> next, (skipToken (Operator ClosePar) rest)\n        |_ -> failwith \"Unexpected notBinary operator\"\n      \n      let parseNud = function\n        | [] -> failwith \"Unexpected end of input\"\n        | Arrow :: _ -> failwith \"Unexpected =>\"\n        | Fun :: tail -> funcNud tail\n        | Identifier i :: tail -> identifierNud i tail        \n        | Numeric n :: tail -> (Literal n, tail)\n        | Operator o :: tail -> operatorNud o tail\n\n      parseNud tokens |> parseLed minPrecedence\n    parseExpr tokens 0\n    |> fun (res, rest) ->\n      match rest with\n      |[] -> res\n      |_ -> failwith \"Failed to parse espression completely\"\n\nmodule Solution = begin\n\n  open System\n  open System.Collections.Generic\n  open Types \n  open Tokenizer\n  open Parser\n  open FSharp.Linq.NullableOperators\n\n  type Interpreter ()=\n    let funcLookup = Dictionary<string, FuncAssignNode>()\n    let variableLookup = Dictionary<string, float>()\n\n    let rec checkFunc args node =\n      match node with\n      |Literal _ -> true\n      |Ref x -> args |> List.contains x\n      |Binary (n1, _, n2) -> checkFunc args n1 && checkFunc args n2        \n      |Assign (name, node) -> args |> List.contains name && checkFunc args node\n      |FuncAssign _ -> failwith \"Func definition inside func\"\n      |FuncCall call -> funcLookup.ContainsKey(call.name) && call.args |> List.forall (fun x -> checkFunc args x)\n\n    let rec interpret (vl:Dictionary<string, float>) node = \n      match node with\n      |Literal n -> Nullable<float>(n)\n      |Ref x -> \n        match vl.TryGetValue(x) with\n        | (true, v) ->  Nullable<float>(v)\n        | _ -> failwith <| sprintf \"Unknown identifier %A\" x\n      |Binary (n1, op, n2) -> \n        match op with\n        |Plus -> (interpret vl n1) ?+? (interpret vl n2)\n        |Minus -> (interpret vl n1) ?-? (interpret vl n2)\n        |Mul -> (interpret vl n1) ?*? (interpret vl n2)\n        |Div -> (interpret vl n1) ?\/? (interpret vl n2)\n        |Mod -> (interpret vl n1) ?%? (interpret vl n2)\n      |Assign (name, node) ->\n        if funcLookup.ContainsKey(name) \n        then failwith <| sprintf \"Can't assign variable %A because exist same func\" name\n        else\n          let value = (interpret vl node).Value\n          do vl.[name] <- value\n          new Nullable<float>(value)\n      |FuncAssign f -> \n        do if f.args |> List.contains f.name then failwith \"Invalid identifier\"\n        do if checkFunc f.args f.node then funcLookup.[f.name] <-f else failwith \"Invalid identifier in function body\"\n        Nullable<float>()\n      |FuncCall f ->\n        match funcLookup.TryGetValue(f.name) with\n        | (true, v) -> \n          let fvl = new Dictionary<string, float>()\n          do (v.args,f.args) ||> List.iter2 (fun name node -> fvl.Add(name, (interpret vl node).Value))\n          interpret fvl v.node\n        | _ -> failwith <| sprintf \"Unknown function %A\" f.name    \n    member __.input input : Nullable<float> =\n      try\n        tokenize input|>parse funcLookup |> interpret variableLookup \n      with\n        |Failure msg -> \n          printf \"%A\" msg\n          Nullable<float>()\nend","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"55a4de202949dca9bd000088":[{"id":86920,"user_id":1125,"body":"exception Exception of string\n\nlet begin_ trans = trans []\n\nlet push orig elem trans = trans (elem :: orig)\n\nlet add lst trans = match lst with\n                      | x::y::xs -> trans ( (x + y) :: xs )\n                      | _ -> raise (Exception \"empty\")\n\nlet end_ = List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86921,"user_id":null,"body":"let begin_ next = next []\n\nlet push stack num next = next <| num :: stack\n\nlet add stack next =\n    next <|\n    match stack with\n    | e1 :: e2 :: rest -> (e1 + e2) :: rest\n    | st -> st \n\nlet end_ = List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86922,"user_id":null,"body":"#nowarn \"25\"\n\nlet begin_ f = f []\n\nlet push s n f = f (n::s)\n\nlet add (a::b::s) f = f ((a+b)::s)\n\nlet end_ (a::_) = a","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86923,"user_id":null,"body":"let begin_ = fun f -> f []\nlet push (stack: list<_>) n = fun f -> f (n::stack)\nlet add (stack: list<_>) cont = cont ((stack.Head + stack.Tail.Head)::stack.Tail.Tail)\nlet end_ (stack: list<_>) = stack.Head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86924,"user_id":null,"body":"exception Exception of string\n\ntype Stack0 =\n    | EmptyStack\n\ntype Stack1 =\n    | Item of int\n\ntype StackN =\n    | Items of int * int * int list\n\ntype NonEmptyStack =\n    | StackWithOne of Stack1\n    | StackWithAtLeastTwo of StackN\n\ntype Stack =\n    | Empty of Stack0\n    | NonEmpty of NonEmptyStack\n\n\nlet begin_ next =\n    next (Empty EmptyStack)\n\nlet push stack x next =\n    match stack with\n    | Empty _ -> next (NonEmpty(StackWithOne(Item x)))\n    | NonEmpty (StackWithOne (Item y)) -> next (NonEmpty(StackWithAtLeastTwo(Items(x, y, []))))\n    | NonEmpty (StackWithAtLeastTwo (Items(y, z, rest))) -> next (NonEmpty(StackWithAtLeastTwo(Items(x, y, (z :: rest)))))\n\nlet add stack next =\n    match stack with\n    | NonEmpty(StackWithAtLeastTwo(Items(x, y, []))) -> next <| (NonEmpty << StackWithOne << Item) (x + y)\n    | NonEmpty(StackWithAtLeastTwo(Items(x, y, (z :: rest)))) -> next <| NonEmpty(StackWithAtLeastTwo(Items(x + y, z, rest)))\n\nlet end_ stack =\n    match stack with\n    | NonEmpty(StackWithOne(Item x)) -> x\n    | NonEmpty(StackWithAtLeastTwo(Items(x, y, rest))) -> x\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86925,"user_id":null,"body":"exception Exception of string\n\nlet begin_ program = program []\n\nlet push stack x program = program (x::stack)\n\nlet add stack program = match stack with \n  | x::y::rest -> program ((x+y)::rest)\n  | _ -> raise (Exception (\"Add without 2 elements on the stack\"))\n\nlet end_ (h::_) = h ","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86926,"user_id":null,"body":"exception Exception of string\n\nlet begin_ cont = cont []\nlet push s n cont = cont (n :: s)\n\nlet add s cont =\n    match s with\n    | (x :: y :: s) -> cont (x + y :: s)\n    | _ -> raise (Exception(\"stack must have at least two elements\"))\n\nlet end_ s =\n    match s with\n    | (x :: s) -> x\n    | _ -> raise (Exception(\"stack must have at least one element\"))","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86927,"user_id":null,"body":"let begin_ f = f []\nlet push a n f = f (n :: a)\nlet add (a::b::c) f = f (a + b :: c)\nlet end_ = List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86928,"user_id":null,"body":"let begin_ f = f []\nlet push a n f = f (n :: a)\nlet add a f = f (List.head a + List.item 1 a :: List.skip 2 a)\nlet end_ = List.head","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86929,"user_id":null,"body":"exception Exception of string\n\n\nlet begin_ argument = argument []\n\nlet push l x argument = argument (x::l)\n\nlet add (a::b::l) argument = argument ((a+b)::l)\n\nlet end_ (x::l) = x","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5679d5a3f2272011d700000d":[{"id":86930,"user_id":null,"body":"\/\/ http:\/\/www.fssnip.net\/4u\/title\/Very-Fast-Permutations\nlet rec permutations = function\n   | []      -> seq [List.empty]\n   | x :: xs -> Seq.collect (insertions x) (permutations xs)\nand insertions x = function\n   | []             -> [[x]]\n   | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\nlet permutes numSkyscrapersPerLine = (permutations [1..numSkyscrapersPerLine]) |> Seq.map (fun x -> List.toArray x) |> Seq.toArray\n\nlet skycrapersSeen ls =\n    ls\n    |> Array.fold (fun (numSeen, biggestSeen) skyscraper -> \n        if skyscraper > biggestSeen then (numSeen + 1, skyscraper) else (numSeen, biggestSeen)) (0,0)\n    |> fst\n\nlet allSkyscraperPermutations numSkyscrapersPerLine numberToSee =\n    permutes numSkyscrapersPerLine\n    |> Array.filter (skycrapersSeen >> ((=) numberToSee))\n\nlet equals ls ls2 = Array.compareWith (fun x y -> if x > y then 1 elif x < y then -1 else 0) ls ls2 = 0\n\nlet applyAt i array func =\n    array |> Array.mapi (fun j element -> if i = j then func element else element)\n\nlet union ls ls2 =\n    ls\n    |> Array.filter (fun element -> (ls2 |> Array.exists (fun element2 -> equals element element2)))\n\nlet findCluePosibilities numSkyscrapersPerLine skyscrapersToSee = \n    match skyscrapersToSee with\n    | skyscrapersToSee when skyscrapersToSee > 0 && skyscrapersToSee <= numSkyscrapersPerLine \n        -> allSkyscraperPermutations numSkyscrapersPerLine skyscrapersToSee\n    | _ -> invalidArg \"clue\" (sprintf \"Clue has to be within [1..%d]\" numSkyscrapersPerLine)\n\nlet applyClue numSkyscrapersPerLine (clue : int) (shouldReverse : bool) (current : int[][]) =\n    if (clue = 0) then\n        current\n    else\n        let allowedPosibilities =\n            match shouldReverse with\n            | true -> findCluePosibilities numSkyscrapersPerLine clue |> Array.map Array.rev\n            | false -> findCluePosibilities numSkyscrapersPerLine clue\n        union current allowedPosibilities\n\nlet applyClueOnRow numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newRows = applyAt i rows (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (newRows, columns)\n\nlet applyClueOnColumn numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newColumns = applyAt i columns (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (rows, newColumns)\n\nlet applyClueIndex numSkyscrapersPerLine rowsAndColumns (clueIndex, clue) =\n    match clueIndex with\n    | c when numSkyscrapersPerLine * 0 <= c && c < numSkyscrapersPerLine * 1 -> applyClueOnColumn numSkyscrapersPerLine clue false c rowsAndColumns\n    | c when numSkyscrapersPerLine * 1 <= c && c < numSkyscrapersPerLine * 2 -> applyClueOnRow numSkyscrapersPerLine clue true (c - numSkyscrapersPerLine) rowsAndColumns\n    | c when numSkyscrapersPerLine * 2 <= c && c < numSkyscrapersPerLine * 3 -> applyClueOnColumn numSkyscrapersPerLine clue true (abs (c - numSkyscrapersPerLine * 3) - 1) rowsAndColumns\n    | c when numSkyscrapersPerLine * 3 <= c && c < numSkyscrapersPerLine * 4 -> applyClueOnRow numSkyscrapersPerLine clue false (abs (c - numSkyscrapersPerLine * 4) - 1) rowsAndColumns\n    | _ -> invalidArg \"clueIndex\" (sprintf \"Incorrent clue index: %d\" clueIndex)\n\nlet applyClues numSkyscrapersPerLine (clues : int []) (rowsAndColumns : int [][][] * int [][][]) : int [][][] * int [][][] =\n    clues\n    |> Array.mapi (fun i x -> (i, x))\n    |> Array.fold (applyClueIndex numSkyscrapersPerLine) rowsAndColumns\n\nlet removeSubArraysMatchingElementsAt i illigalElements (array : int[][]) = \n    array |> Array.filter (fun posibility -> not (illigalElements |> Set.contains posibility.[i]))\n\nlet removeSkypscraperUnionRowAndColumn (rows : int [][][], columns : int [][][]) (i, j) = \n    let skyscraperPosibilitiesFromRow = rows.[i] |> Array.map (fun row -> row.[j]) |> Array.distinct\n    let skyscraperPosibilitiesFromColumn = columns.[j] |> Array.map (fun column -> column.[i]) |> Array.distinct\n    let removeSkyscrapersFromRow = Set.ofArray skyscraperPosibilitiesFromRow - (Set.ofArray skyscraperPosibilitiesFromColumn)\n    let removeSkyscrapersFromColumn = Set.ofArray skyscraperPosibilitiesFromColumn - (Set.ofArray skyscraperPosibilitiesFromRow)\n    let updatedColumns = applyAt j columns (removeSubArraysMatchingElementsAt i removeSkyscrapersFromColumn)\n    let updatedRows = applyAt i rows (removeSubArraysMatchingElementsAt j removeSkyscrapersFromRow)\n    (updatedRows, updatedColumns)\n\nlet removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns = \n    [|0..numSkyscrapersPerLine - 1|]\n    |> Array.map (fun i -> [|0..numSkyscrapersPerLine - 1|]\n                           |> Array.map (fun j -> (i, j)))\n    |> Array.concat\n    |> Array.fold (removeSkypscraperUnionRowAndColumn) rowsAndColumns\n\nlet isFinal (rows, _) = \n    rows\n    |> Array.map (fun row -> Seq.length row = 1)\n    |> Array.reduce (&&)\n\nlet rec applyUnionRule numSkyscrapersPerLine rowsAndColumns = \n    match isFinal rowsAndColumns with\n    | true -> rowsAndColumns\n    | false -> applyUnionRule numSkyscrapersPerLine (removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns)\n\nlet solvePuzzle (clues : int[]) =\n    let numSkyscrapersPerLine = 6\n    let rowsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n    let columnsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n\n    let cluesApplied = applyClues numSkyscrapersPerLine clues (rowsAllPosibilities, columnsAllPosibilities)\n    let (finalRow, _) = applyUnionRule numSkyscrapersPerLine cluesApplied\n    finalRow |> Array.concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86931,"user_id":53,"body":"let observerCell (id: int, i: int, n: int): int =\n  match id with\n    | id1 when id1 < n    -> id1+i*n\n    | id2 when id2 < 2*n  -> (n-1-i)+id2%n*n\n    | id3 when id3 < 3*n  -> (n-1-id3%n)+(n-1-i)*n\n    | _                   -> i+(n-1-id%n)*n\n\nlet solvePuzzle (clues: int[]): int[][] =\n\n  let n           = (Array.length clues) \/ 4\n  let board       = [| for i in 0 .. n-1 -> Array.zeroCreate n |]\n  let cells       = [| for i in 0 .. (pown n 2)-1 -> Array.zeroCreate n |]\n  let peers       = [| for i in 0 .. (pown n 2)-1 -> [| for j in 0 .. n-1 -> [| j*n+i%n ; i\/n*n+j |] |] |> Array.collect (fun j -> j) |> Array.filter (fun j -> j <> i) |]\n  let observers   = clues |> Array.indexed |> Array.map (fun (id, c) -> [| [| 0 .. n-1 |] |> Array.map (fun i -> observerCell(id, i, n)) ; [| c |] |] |> Array.collect (fun i -> i))\n  \n  let isSet(c: int): bool =\n    board.[c\/n].[c%n] <> 0\n    \n  let has(c: int, v: int): bool =\n    (not (isSet(c))) && cells.[c].[v] = 0\n  \n  let candidates(c: int): int[] =\n    [| 0 .. n-1 |] |> Array.filter (fun i -> cells.[c].[i] = 0)\n  \n  let look(o: int[]): int = \n    let mutable k = -1\n    let mutable cnt = 0\n    for i in 0 .. n-1 do\n      let v = board.[o.[i]\/n].[o.[i]%n]\n      if v > k then\n        cnt <- cnt + 1\n        k <- v\n    cnt\n    \n  let verify(o: int[]): bool = \n    o.[n] = 0 || [| 0 .. n-1 |] |> Array.exists (fun i -> board.[o.[i]\/n].[o.[i]%n] = 0) || look(o) = o.[n]\n  \n  let choose(): int option =\n    let mutable k = -1\n    let mutable m = n+1\n    for i in 0 .. (pown n 2)-1 do\n      if not (isSet(i)) then\n        let xs = candidates(i)\n        if (xs |> Array.length) < m then\n          m <- xs |> Array.length\n          k <- i\n    if k > -1 then\n      Some(k)\n    else\n      None\n  \n  let cloack(c: int, v: int) =\n    Array.set cells.[c] v (cells.[c].[v]+1)\n  \n  let uncloack(c: int, v: int) =\n    Array.set cells.[c] v (cells.[c].[v]-1)\n    \n  let lock(c: int, v: int) =\n    Array.set board.[c\/n] (c%n) (v+1)\n    for s in peers.[c] do\n      cloack(s, v)\n      \n  let unlock(c: int, v: int) =\n    Array.set board.[c\/n] (c%n) 0\n    for s in peers.[c] do\n      uncloack(s, v)\n      \n  let reduceEdgeConstraints() = \n    for o in observers do\n      let c = o.[n]\n      if c = 1 then\n        if not (isSet(o.[0])) then\n          lock(o.[0], n-1)\n      elif c = 2 then\n        if has(o.[0], n-1) then\n          cloack(o.[0], n-1)\n        if has(o.[1], n-2) then\n          cloack(o.[1], n-2)\n      elif c = n then\n        for i in 0 .. n-1 do\n          if not (isSet(o.[i])) then\n            lock(o.[i], i)\n      elif c > 0 then\n        for i in 0 .. c-2 do\n          for j in 0 .. c-2-i do\n            if has(o.[i], n-1-j) then\n              cloack(o.[i], n-1-j)\n      \n  let rec dfs() =\n    let cellOpt = choose()\n    match cellOpt with\n      | None -> not (observers |> Array.exists (fun o -> not (verify o)))\n      | Some cell ->\n        let options = candidates(cell)\n        let mutable completed = false\n        for i in 0 .. (options |> Array.length)-1 do\n          let value = options.[i]\n          if not completed then\n            lock(cell, value)\n            if dfs() then\n              completed <- true\n            else\n              unlock(cell, value)\n        completed\n  \n  reduceEdgeConstraints()\n  dfs() |> ignore\n  board","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86932,"user_id":null,"body":"open System.Collections.Generic\n\nlet N = 6\n\ntype StrGrid = string[,]\ntype Square = { Row: int; Col: int; Val: int }\ntype SquareState = Unsolved | Solved of int | Propagated of int\ntype BoardPoss = Set<int>[,]\ntype BoardState = SquareState[,]\ntype PossAndState = (BoardPoss * BoardState)\ntype Int2D = int list list\ntype Int3D = int list list list\n\nlet cluesByRow (r: int) (clues: int list): (int * int) =\n    (clues.[N * 4 - 1 - r], clues.[N + r])\n\nlet cluesByCol (c: int) (clues: int list): (int * int) =\n    (clues.[c], clues.[N * 3 - 1 - c])\n\nlet updateBoardState ((boardPoss, boardState): PossAndState): BoardState =\n    let mutable boardState' = boardState |> Array2D.copy\n    boardPoss |> Array2D.iteri (fun r c poss ->\n        let isSquareSolved = Set.count poss = 1\n        let solutionForSquare = Set.minElement poss\n        if isSquareSolved && boardState.[r, c] = Unsolved\n        then boardState'.[r, c] <- Solved solutionForSquare\n        else ()\n    )\n    boardState'\n\nlet initBoard clues: PossAndState =\n    let possible (ix: int) (clue: int): int list =\n        \/\/let (|IsN|) x = x = N \n        match clue, ix with\n        | 1, 0 -> [N] \n        | 1, _ -> [1 .. N]\n        | x, _ when x = N -> [ix + 1]\n        | _, _ -> [ 1 .. min (N - clue + 1 + ix) N ]\n\n    let initCell r c clues =\n        let (cr1, cr2) = cluesByRow r clues\n        let (cc1, cc2) = cluesByCol c clues\n        let rowL = possible c cr1\n        let colT = possible r cc1\n        let rowR = possible (N - 1 - c) cr2\n        let colB = possible (N - 1 - r) cc2\n        [rowL; colT; rowR; colB] |> List.map Set.ofList |> List.reduce (fun acc elem -> Set.intersect acc elem)\n\n    let board = Array2D.init N N (fun r c -> initCell r c clues)\n    let initialBoardState= Array2D.init N N (fun r c -> Unsolved)\n    let newBoardState = (board, initialBoardState) |> updateBoardState\n    (board, newBoardState)\n\nlet otherIdxsInRowOrCol idx: Set<int> =\n    Set.difference ([0 .. N - 1] |> Set.ofList) (Set.ofList [idx])\n\nlet rec propagateSolvedSquares ((boardPoss, boardState): PossAndState): PossAndState =\n    let getListOfSolvedSquares (boardState: BoardState): Square list =\n        let solvedQueue = new Queue<Square>()\n        boardState |> Array2D.iteri (fun r c state ->\n            match state with\n            | Solved solution -> solvedQueue.Enqueue({ Row = r; Col = c; Val = solution })\n            | _ -> ()\n        )\n        solvedQueue.ToArray() |> List.ofArray \n\n    let prune row col (elem: int) (boardPoss: BoardPoss): BoardPoss =\n        let (cols, rows) = (otherIdxsInRowOrCol col, otherIdxsInRowOrCol row)\n        cols |> Set.iter (fun c -> boardPoss.[row, c] <- Set.difference boardPoss.[row, c] (Set.ofList [elem]))\n        rows |> Set.iter (fun r -> boardPoss.[r, col] <- Set.difference boardPoss.[r, col] (Set.ofList [elem]))\n        boardPoss\n\n    let mutable newBoard = boardPoss |> Array2D.copy\n    let newBoardState = boardState |> Array2D.copy\n    let solvedSquares = getListOfSolvedSquares boardState\n\n    let pruneAndUpdateState { Row = r; Col = c; Val = v } =\n        newBoard <- prune r c v newBoard\n        newBoardState.[r, c] <- Propagated v \n        ()\n\n    let rec propagate solvedSquares =\n        solvedSquares |> List.iter pruneAndUpdateState\n        let newBoardState2 = (newBoard, newBoardState) |> updateBoardState\n        (newBoard, newBoardState2) |> propagateSolvedSquares\n\n    if List.isEmpty solvedSquares then (boardPoss, boardState) else propagate solvedSquares\n\nlet deduceByUniqueValue ((boardPoss, boardState): PossAndState): PossAndState =\n    let deduceValueForSquare row col ((boardPoss, boardState): PossAndState): int option =\n        let setsFromRow row col (boardPoss: BoardPoss): Set<int> list =\n            otherIdxsInRowOrCol col |> Set.map (fun idx -> boardPoss.[row, idx]) |> Set.toList\n\n        let setsFromCol row col (boardPoss: BoardPoss): Set<int> list =\n            otherIdxsInRowOrCol row |> Set.map (fun idx -> boardPoss.[idx, col]) |> Set.toList\n\n        let deduceValue' row col setFunc (boardPoss: BoardPoss): int option =\n            let subtractor = boardPoss |> setFunc row col |> List.reduce (fun acc elem -> Set.union acc elem)\n            let diff = Set.difference boardPoss.[row, col] subtractor\n            if boardState.[row, col] = Unsolved && Set.count diff = 1 then Some (Set.minElement diff) else None\n\n        let candR = deduceValue' row col setsFromRow boardPoss: int option\n\n        let resC () =\n            let candC = deduceValue' row col setsFromCol boardPoss: int option\n            match candC with\n            | Some v -> Some v\n            | None   -> None\n\n        match candR with\n        | Some v -> Some v\n        | None   -> resC ()\n\n    let newBoardPoss = boardPoss |> Array2D.copy\n\n    boardPoss\n    |> Array2D.mapi (fun r c _ -> (boardPoss, boardState) |> deduceValueForSquare r c)\n    |> Array2D.iteri (fun r c v ->\n            match v with\n            | Some x -> newBoardPoss.[r, c] <- Set.ofList [x]\n            | None   -> ()\n         )\n    let newBoardState = updateBoardState (newBoardPoss, boardState)\n    (newBoardPoss, newBoardState)\n\nlet deduceByTwoRule (clues: int list) ((boardPoss, boardState): PossAndState): PossAndState =\n    let solvedValue row col (boardPoss: BoardPoss): int option =\n        if boardPoss.[row, col] |> Set.count = 1\n        then Some (boardPoss.[row, col] |> Set.minElement)\n        else None\n\n    let deduceRow row (boardPoss: BoardPoss): BoardPoss =\n        let (begClue, endClue) = cluesByRow row clues\n\n        if begClue = 2 && boardPoss |> solvedValue row (N - 1) = Some N then\n            let mutable newBoardPoss = boardPoss |> Array2D.copy\n            newBoardPoss.[row, 0] <- Set.empty |> Set.add (N - 1)\n            newBoardPoss\n        else if endClue = 2 && boardPoss |> solvedValue row 0 = Some N then\n            let mutable newBoardPoss = boardPoss |> Array2D.copy\n            newBoardPoss.[row, N - 1] <- Set.empty |> Set.add (N - 1)\n            newBoardPoss\n        else\n            boardPoss\n\n    let deduceCol col (boardPoss: BoardPoss): BoardPoss =\n        let mutable newBoardPoss = boardPoss |> Array2D.copy\n\n        let (begClue, endClue) = cluesByCol col clues\n\n        if begClue = 2 && boardPoss |> solvedValue (N - 1) col = Some N then\n            let mutable newBoardPoss = boardPoss |> Array2D.copy\n            newBoardPoss.[0, col] <- Set.empty |> Set.add (N - 1)\n            newBoardPoss\n        else if endClue = 2 && boardPoss |> solvedValue 0 col = Some N then\n            let mutable newBoardPoss = boardPoss |> Array2D.copy\n            newBoardPoss.[N - 1, col] <- Set.empty |> Set.add (N - 1)\n            newBoardPoss\n        else\n            boardPoss\n\n    let mutable newBoardPoss = boardPoss |> Array2D.copy\n\n    for idx in [0 .. N - 1] do\n        newBoardPoss <- newBoardPoss |> deduceRow idx\n        newBoardPoss <- newBoardPoss |> deduceCol idx\n\n    let newBoardState = updateBoardState (newBoardPoss, boardState)\n\n    (newBoardPoss, newBoardState)\n\nlet rec permute (xs: int list): Int2D =\n    if List.length xs = 1 then [xs]\n    else [for x in xs -> xs |> List.filter (fun y -> y <> x) |> permute |> List.map (fun ys -> x :: ys)]\n         |> List.concat\n\nlet countAscending (xs: int list) =\n    let (c, _) = xs |> List.fold (fun (count, last) e -> if e > last then (count + 1, e) else (count, last)) (0, 0)\n    c\n\nlet getMatchForClues(xs: int list): (int * int) =\n    (xs |> countAscending, xs |> List.rev |> countAscending)\n\nlet extractRow row (boardPoss: BoardPoss): Set<int> list =\n    [0 .. N - 1] |> List.map (fun col -> boardPoss.[row, col])\n    \nlet extractCol col (boardPoss: BoardPoss): Set<int> list =\n    [0 .. N - 1] |> List.map (fun row -> boardPoss.[row, col])\n    \nlet filterVector vecExtractor clueExtractor idx clues (boardPoss: BoardPoss): Set<int> list =\n    let cluePair idx = clueExtractor idx clues\n\n    let vectorSpaceN = permute [1 .. N] \n\n    let filterVecSpaceBySets (constr: Set<int> list) (vectorSpace: Int2D): Int2D =\n        let constrain (constr: Set<int> list) (vector: int list): bool =\n            (constr, vector) ||> List.forall2 (fun consElem vecElem -> Set.contains vecElem consElem)\n        vectorSpace |> List.filter (constrain constr)\n\n    let filterVecSpaceByIdx vecExtractor (idx: int) (boardPoss: BoardPoss) (vecSpace: Int2D): Int2D =\n        (vecExtractor idx boardPoss, vecSpace) ||> filterVecSpaceBySets\n\n    let visible (clue: int) (vecSpace: Int2D): Int2D =\n        vecSpace |> List.filter (fun xs -> countAscending xs = clue || clue = 0)\n\n    let visible2 ((n, m): (int * int)) (vecSpace: Int2D): Int2D =\n        let v1 = vecSpace |> visible n |> Set.ofSeq\n        let v2 = vecSpace |> List.map List.rev |> visible m |> List.map List.rev |> Set.ofSeq\n        Set.intersect v1 v2 |> Set.toList\n\n    let emptySetList =\n        [1 .. N] |> List.map (fun _ -> Set.empty)\n\n    let addElemsToSets (setList: Set<int> list) (elemList: int list): Set<int> list =\n        (setList, elemList) ||> List.map2 (fun aSet elem -> aSet |> Set.add elem)\n\n    vectorSpaceN\n    |> filterVecSpaceByIdx vecExtractor idx boardPoss\n    |> visible2 (cluePair idx)\n    |> List.fold addElemsToSets emptySetList\n\nlet filterRows (clues: int list) ((boardPoss, boardState): PossAndState): PossAndState =\n    let filterFunc idx = filterVector extractRow cluesByRow idx clues boardPoss\n    let newBoardPoss' = [0 ..  N - 1] |> List.map filterFunc\n    let newBoardPoss = Array2D.init N N (fun r c -> newBoardPoss'.[r].[c])\n    let newBoardState = updateBoardState (newBoardPoss, boardState)\n\n    (newBoardPoss, newBoardState)\n\nlet filterCols (clues: int list) ((boardPoss, boardState): PossAndState): PossAndState =\n    let filterFunc idx = filterVector extractCol cluesByCol idx clues boardPoss\n    let newBoardPoss' = [0 ..  N - 1] |> List.map filterFunc\n    let newBoardPoss = Array2D.init N N (fun r c -> newBoardPoss'.[c].[r])\n    let newBoardState = updateBoardState (newBoardPoss, boardState)\n\n    (newBoardPoss, boardState)\n\nlet solvePuzzle (clues' : int[]) : int[][] =\n    let clues = Array.toList clues'\n\n    let (initialBoard, initialBoardState) = initBoard clues |> propagateSolvedSquares\n\n    let deduce ((b, bs): PossAndState): (BoardPoss * PossAndState) option =\n        let (b', bs') =\n            (b, bs)\n            |> deduceByUniqueValue |> propagateSolvedSquares\n            |> deduceByTwoRule clues |> propagateSolvedSquares\n            |> filterRows clues |> propagateSolvedSquares\n            |> filterCols clues |> propagateSolvedSquares\n        if b' = b then None else Some (b', (b', bs'))\n\n    let boardList = initialBoard :: List.unfold deduce (initialBoard, initialBoardState)\n\n    let maxConstrainedBoard = List.last boardList\n\n    let boardVal row col =\n        maxConstrainedBoard.[row, col] |> Set.minElement       \n\n    Array.init N (fun row -> Array.init N (fun col -> boardVal row col))\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86933,"user_id":null,"body":"let rec permutations = function\n   | []      -> seq [List.empty]\n   | x :: xs -> Seq.collect (insertions x) (permutations xs)\nand insertions x = function\n   | []             -> [[x]]\n   | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\nlet permutes numSkyscrapersPerLine = (permutations [1..numSkyscrapersPerLine]) |> Seq.map (fun x -> List.toArray x) |> Seq.toArray\n\nlet skycrapersSeen ls =\n    ls\n    |> Array.fold (fun (numSeen, biggestSeen) skyscraper -> \n        if skyscraper > biggestSeen then (numSeen + 1, skyscraper) else (numSeen, biggestSeen)) (0,0)\n    |> fst\n\nlet allSkyscraperPermutations numSkyscrapersPerLine numberToSee =\n    permutes numSkyscrapersPerLine\n    |> Array.filter (skycrapersSeen >> ((=) numberToSee))\n\nlet equals ls ls2 = Array.compareWith (fun x y -> if x > y then 1 elif x < y then -1 else 0) ls ls2 = 0\n\nlet applyAt i array func =\n    array |> Array.mapi (fun j element -> if i = j then func element else element)\n\nlet union ls ls2 =\n    ls\n    |> Array.filter (fun element -> (ls2 |> Array.exists (fun element2 -> equals element element2)))\n\nlet findCluePosibilities numSkyscrapersPerLine skyscrapersToSee = \n    match skyscrapersToSee with\n    | skyscrapersToSee when skyscrapersToSee > 0 && skyscrapersToSee <= numSkyscrapersPerLine \n        -> allSkyscraperPermutations numSkyscrapersPerLine skyscrapersToSee\n    | _ -> invalidArg \"clue\" (sprintf \"Clue has to be within [1..%d]\" numSkyscrapersPerLine)\n\nlet applyClue numSkyscrapersPerLine (clue : int) (shouldReverse : bool) (current : int[][]) =\n    if (clue = 0) then\n        current\n    else\n        let allowedPosibilities =\n            match shouldReverse with\n            | true -> findCluePosibilities numSkyscrapersPerLine clue |> Array.map Array.rev\n            | false -> findCluePosibilities numSkyscrapersPerLine clue\n        union current allowedPosibilities\n\nlet applyClueOnRow numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newRows = applyAt i rows (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (newRows, columns)\n\nlet applyClueOnColumn numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newColumns = applyAt i columns (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (rows, newColumns)\n\nlet applyClueIndex numSkyscrapersPerLine rowsAndColumns (clueIndex, clue) =\n    match clueIndex with\n    | c when numSkyscrapersPerLine * 0 <= c && c < numSkyscrapersPerLine * 1 -> applyClueOnColumn numSkyscrapersPerLine clue false c rowsAndColumns\n    | c when numSkyscrapersPerLine * 1 <= c && c < numSkyscrapersPerLine * 2 -> applyClueOnRow numSkyscrapersPerLine clue true (c - numSkyscrapersPerLine) rowsAndColumns\n    | c when numSkyscrapersPerLine * 2 <= c && c < numSkyscrapersPerLine * 3 -> applyClueOnColumn numSkyscrapersPerLine clue true (abs (c - numSkyscrapersPerLine * 3) - 1) rowsAndColumns\n    | c when numSkyscrapersPerLine * 3 <= c && c < numSkyscrapersPerLine * 4 -> applyClueOnRow numSkyscrapersPerLine clue false (abs (c - numSkyscrapersPerLine * 4) - 1) rowsAndColumns\n    | _ -> invalidArg \"clueIndex\" (sprintf \"Incorrent clue index: %d\" clueIndex)\n\nlet applyClues numSkyscrapersPerLine (clues : int []) (rowsAndColumns : int [][][] * int [][][]) : int [][][] * int [][][] =\n    clues\n    |> Array.mapi (fun i x -> (i, x))\n    |> Array.fold (applyClueIndex numSkyscrapersPerLine) rowsAndColumns\n\nlet removeSubArraysMatchingElementsAt i illigalElements (array : int[][]) = \n    array |> Array.filter (fun posibility -> not (illigalElements |> Set.contains posibility.[i]))\n\nlet removeSkypscraperUnionRowAndColumn (rows : int [][][], columns : int [][][]) (i, j) = \n    let skyscraperPosibilitiesFromRow = rows.[i] |> Array.map (fun row -> row.[j]) |> Array.distinct\n    let skyscraperPosibilitiesFromColumn = columns.[j] |> Array.map (fun column -> column.[i]) |> Array.distinct\n    let removeSkyscrapersFromRow = Set.ofArray skyscraperPosibilitiesFromRow - (Set.ofArray skyscraperPosibilitiesFromColumn)\n    let removeSkyscrapersFromColumn = Set.ofArray skyscraperPosibilitiesFromColumn - (Set.ofArray skyscraperPosibilitiesFromRow)\n    let updatedColumns = applyAt j columns (removeSubArraysMatchingElementsAt i removeSkyscrapersFromColumn)\n    let updatedRows = applyAt i rows (removeSubArraysMatchingElementsAt j removeSkyscrapersFromRow)\n    (updatedRows, updatedColumns)\n\nlet removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns = \n    [|0..numSkyscrapersPerLine - 1|]\n    |> Array.map (fun i -> [|0..numSkyscrapersPerLine - 1|]\n                           |> Array.map (fun j -> (i, j)))\n    |> Array.concat\n    |> Array.fold (removeSkypscraperUnionRowAndColumn) rowsAndColumns\n\nlet isFinal (rows, _) = \n    rows\n    |> Array.map (fun row -> Seq.length row = 1)\n    |> Array.reduce (&&)\n\nlet rec applyUnionRule numSkyscrapersPerLine rowsAndColumns = \n    match isFinal rowsAndColumns with\n    | true -> rowsAndColumns\n    | false -> applyUnionRule numSkyscrapersPerLine (removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns)\n\nlet solvePuzzle (clues : int[]) =\n    let numSkyscrapersPerLine = 6\n    let rowsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n    let columnsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n\n    let cluesApplied = applyClues numSkyscrapersPerLine clues (rowsAllPosibilities, columnsAllPosibilities)\n    let (finalRow, _) = applyUnionRule numSkyscrapersPerLine cluesApplied\n    finalRow |> Array.concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86934,"user_id":null,"body":"open System.Collections.Generic\n[<System.Flags>]\ntype Digit =\n  | One   = 0b000001\n  | Two   = 0b000010\n  | Three = 0b000100\n  | Four  = 0b001000\n  | Five  = 0b010000\n  | Six   = 0b100000\n\ntype Cell =\n  | Known of int\n  | Unknown of Digit\n\nlet rec distribute e = function\n| [] -> [[e]]\n| x::xs' as xs -> (e::xs)::[for xs in distribute e xs' -> x::xs]\n\nlet rec permute = function\n| [] -> [[]]\n| e::xs -> List.collect (distribute e) (permute xs)\n\nlet calcClue perm =\n  perm |> List.fold (fun (clue, max) p ->\n    match p with\n    | v when v > max -> (clue + 1, v)\n    | _ -> (clue, max)\n  ) (0, 0)\n  |> fst\n\nlet solvePuzzle (clues : int[]) =\n  let min, max = 0, 6\n  let perms = permute [1..max]\n  let permsByClue = new Dictionary<int, int list list>()\n  perms |> List.groupBy calcClue |> List.iter permsByClue.Add\n  let digitByValue = dict[(1, Digit.One); (2, Digit.Two); (3, Digit.Three); (4, Digit.Four); (5, Digit.Five); (6, Digit.Six)]\n  \n  let init = Unknown (Digit.One ||| Digit.Two ||| Digit.Three ||| Digit.Four ||| Digit.Five ||| Digit.Six)\n  let setGrid (grid:Cell[][]) i j v = grid.[i].[j] <- v\n  let equals (g1:Cell[][]) (g2:Cell[][]) =\n    let mutable equals = true\n    for i = 0 to max - 1 do\n      for j = 0 to max - 1 do\n        match g1.[i].[j], g2.[i].[j] with\n        | Known x1, Known x2 when x1 = x2 -> ()\n        | Unknown x1, Unknown x2 when x1 = x2 -> ()\n        | _ -> equals <- false\n    equals\n  let copy (g1:Cell[][]) =\n    let g2 = [|\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n    |]\n    for i = 0 to max - 1 do\n      for j = 0 to max - 1 do\n        match g1.[i].[j] with\n        | Known x -> g2.[i].[j] <- Known x\n        | Unknown x -> g2.[i].[j] <- Unknown x\n    g2\n\n  let getView clue_i =\n    let div, mod_ = clue_i \/ max, clue_i % max\n    match div with\n    | 0 -> [min..max - 1] |> List.map (fun x -> (x, mod_))\n    | 1 -> [min..max - 1] |> List.rev |> List.map (fun x -> (mod_, x))\n    | 2 -> [min..max - 1] |> List.rev |> List.map (fun x -> (x, max - mod_ - 1))\n    | 3 -> [min..max - 1] |> List.map (fun x -> (max - mod_ - 1, x))\n    | _ -> failwith \"No more clues\"\n\n  let digitToList digit =\n    digitByValue |> Seq.fold (fun acc kv -> if int(digit &&& kv.Value) <> 0 then kv.Key::acc else acc) []\n  let getVariants (grid:Cell[][]) =\n    let byCells = new List<(int * int * int list)>()\n    for i = 0 to max - 1 do\n      for j = 0 to max - 1 do\n        match grid.[i].[j] with\n        | Unknown x -> byCells.Add(i, j, (digitToList x))\n        | _ -> ()\n    let cells = byCells |> Seq.toList |> List.groupBy (fun (_, _, l) -> List.length l) |> Seq.sortBy (fun (key, _) -> key)\n    cells |> Seq.map (fun (_len, l) -> l) |> Seq.concat |> Seq.map (fun (i, j, l) ->\n      l |> List.sortDescending |> List.map (fun v -> (i, j, v))\n    ) |> List.concat |> List.sortByDescending (fun (i, j, v) -> v)\n  \n  let filterPossibleInRowCol (grid:Cell[][]) =\n    [1..max] |> List.iter (fun v ->\n      let d = digitByValue.[v]\n      for i = min to max - 1 do\n        for j = min to max - 1 do\n          match grid.[i].[j] with\n          | Unknown p ->\n            let row_has_v = [min..max - 1] |> List.fold (fun res c -> res || grid.[i].[c] = Known v) false\n            let col_has_v = [min..max - 1] |> List.fold (fun res r -> res || grid.[r].[j] = Known v) false\n            if row_has_v || col_has_v then setGrid grid i j <| Unknown (p &&& ~~~d) else ()\n          | _ -> ()\n    )\n  let setOnlyPossibleInRowCol (grid:Cell[][]) i (d, v) get_idxs =\n    let v_in_list =\n      [min..max - 1]\n      |> List.fold (fun res j ->\n        let i_, j_ = get_idxs i j\n        match grid.[i_].[j_] with\n        | Unknown p when (int(p &&& d) <> 0) -> (i_, j_)::res\n        | _ -> res\n      ) []\n    match v_in_list with\n    | [(i, j)] -> setGrid grid i j <| Known v\n    | _ -> ()\n  \n  let setOnlyPossible grid =\n    [1..max] |> List.iter (fun v ->\n      let d = digitByValue.[v]\n      for i = min to max - 1 do\n        filterPossibleInRowCol grid\n        setOnlyPossibleInRowCol grid i (d, v) (fun i j -> i, j)\n        filterPossibleInRowCol grid\n        setOnlyPossibleInRowCol grid i (d, v) (fun i j -> j, i)\n    )\n    let variants =\n        getVariants grid\n        |> List.groupBy (fun (i, j, v) -> (i, j))\n        |> Seq.filter (fun (_, l) -> List.length l = 1)\n        |> Seq.map (fun (k, v) -> v)\n        |> Seq.concat\n        |> Seq.toList\n    variants |> List.iter (fun (i, j, v) ->\n      grid.[i].[j] <- Known v\n    )\n    grid\n  \n  let filterPossiblePerms clues (grid:Cell[][]) =\n    clues\n    |> Array.iteri (fun clue_i clue ->\n      if clue = 0 then () else\n      let view = getView clue_i\n      let pos_digits =\n        let perms = permsByClue.[clue]\n        let perms2 = perms |> List.filter (fun perm ->\n          List.zip perm view\n          |> List.exists (fun (p, (i, j)) -> match grid.[i].[j] with | Known k when k <> p -> true | _ -> false)\n          |> not\n        )\n        let counts =\n          perms2 |> List.fold (fun res perm ->\n            match perm, res with\n            | [p1; p2; p3; p4; p5; p6], [r1; r2; r3; r4; r5; r6] -> [p1::r1; p2::r2; p3::r3; p4::r4; p5::r5; p6::r6]\n            | _ -> failwith \"Error\"\n          ) [[]; []; []; []; []; []]\n        counts |> List.map (fun l ->\n          let dist = List.distinct l\n          let pos =\n            dist |> List.fold (fun res v ->\n              let digit = digitByValue.[v]\n              match res with\n              | Some (Unknown r) -> Some (Unknown (r ||| digit))\n              | _ -> Some (Unknown digit)\n            ) None\n          match pos with\n          | Some v -> v\n          | _ -> Unknown (Digit.One &&& Digit.Two) \/\/ 0\n        )\n      List.zip view pos_digits\n      |> List.iter (fun ((i, j), d) ->\n        match grid.[i].[j], d with\n        | Unknown cur_digit, Unknown digit ->\n            let newDigit = cur_digit &&& digit\n            setGrid grid i j <| Unknown newDigit\n        | _ -> ()\n      )\n    )\n    grid\n  \n  let checkValid grid =\n    let mutable valid = true\n    grid |> Array.iter (Array.iter (fun cell -> match cell with | Unknown v when int(v) = 0 -> valid <- false | _ -> ()))\n    clues |> Array.iteri (fun clue_i clue ->\n      if clue = 0 then () else\n      let view = getView clue_i\n      let values = view |> List.map (fun (i, j) -> grid.[i].[j]) |> List.fold (fun res item -> (match item with | Known v -> v | _ -> 0)::res) [] |> List.rev\n      if List.forall (fun v -> v > 0) values && calcClue values <> clue then\n         valid <- false\n    )\n    valid\n\n  let checkSolved grid =\n    let mutable solved = true\n    grid |> Array.iter (Array.iter (fun cell -> match cell with | Known v -> () | _ -> solved <- false))\n    solved && checkValid grid\n\n  let rec inner grid =\n    let mutable cand = grid\n    let mutable valid = true\n    while valid && not <| checkSolved cand do\n      let prev = copy cand\n      cand <- filterPossiblePerms clues cand\n      valid <- checkValid cand\n      if valid then\n        cand <- setOnlyPossible cand\n        valid <- checkValid cand\n        if valid then\n          if equals prev cand then\n            let variants = getVariants cand\n            let res = variants |> List.tryPick (fun (i, j, v) ->\n              let newCand = copy cand\n              newCand.[i].[j] <- Known v\n              inner newCand\n            )\n            match res with\n            | Some resCand when checkValid resCand ->\n                cand <- resCand\n            | _ ->\n                valid <- false\n    if valid then Some <| cand else None\n\n  let grid = [|\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n  |]\n  let result = inner grid\n  match result with\n  | Some r ->\n    let res = r |> Array.map (Array.map (fun cell -> match cell with | Known v -> v | _ -> failwith \"Error\"))\n    res\n  | _ -> failwith \"Error\"","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86935,"user_id":null,"body":"open System.Collections.Generic\n[<System.Flags>]\ntype Digit =\n  | One   = 0b000001\n  | Two   = 0b000010\n  | Three = 0b000100\n  | Four  = 0b001000\n  | Five  = 0b010000\n  | Six   = 0b100000\n\ntype Cell =\n  | Known of int\n  | Unknown of Digit\n\nlet rec distribute e = function\n| [] -> [[e]]\n| x::xs' as xs -> (e::xs)::[for xs in distribute e xs' -> x::xs]\n\nlet rec permute = function\n| [] -> [[]]\n| e::xs -> List.collect (distribute e) (permute xs)\n\nlet calcClue perm =\n  perm |> List.fold (fun (clue, max) p ->\n    match p with\n    | v when v > max -> (clue + 1, v)\n    | _ -> (clue, max)\n  ) (0, 0)\n  |> fst\n\nlet solvePuzzle (clues : int[]) =\n  let min, max = 0, 6\n  let perms = permute [1..max]\n  let permsByClue = new Dictionary<int, int list list>()\n  perms |> List.groupBy calcClue |> List.iter permsByClue.Add\n  let digitByValue = dict[(1, Digit.One); (2, Digit.Two); (3, Digit.Three); (4, Digit.Four); (5, Digit.Five); (6, Digit.Six)]\n  \n  let init = Unknown (Digit.One ||| Digit.Two ||| Digit.Three ||| Digit.Four ||| Digit.Five ||| Digit.Six)\n  let setGrid (grid:Cell[][]) i j v = grid.[i].[j] <- v\n  let equals (g1:Cell[][]) (g2:Cell[][]) =\n    let mutable equals = true\n    for i = 0 to max - 1 do\n      for j = 0 to max - 1 do\n        match g1.[i].[j], g2.[i].[j] with\n        | Known x1, Known x2 when x1 = x2 -> ()\n        | Unknown x1, Unknown x2 when x1 = x2 -> ()\n        | _ -> equals <- false\n    equals\n  let copy (g1:Cell[][]) =\n    let g2 = [|\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n      [|init; init; init; init; init; init|];\n    |]\n    for i = 0 to max - 1 do\n      for j = 0 to max - 1 do\n        match g1.[i].[j] with\n        | Known x -> g2.[i].[j] <- Known x\n        | Unknown x -> g2.[i].[j] <- Unknown x\n    g2\n\n  let getView clue_i =\n    let div, mod_ = clue_i \/ max, clue_i % max\n    match div with\n    | 0 -> [min..max - 1] |> List.map (fun x -> (x, mod_))\n    | 1 -> [min..max - 1] |> List.rev |> List.map (fun x -> (mod_, x))\n    | 2 -> [min..max - 1] |> List.rev |> List.map (fun x -> (x, max - mod_ - 1))\n    | 3 -> [min..max - 1] |> List.map (fun x -> (max - mod_ - 1, x))\n    | _ -> failwith \"No more clues\"\n\n  let digitToList digit =\n    digitByValue |> Seq.fold (fun acc kv -> if int(digit &&& kv.Value) <> 0 then kv.Key::acc else acc) []\n  let getVariants (grid:Cell[][]) =\n    let byCells = new List<(int * int * int list)>()\n    for i = 0 to max - 1 do\n      for j = 0 to max - 1 do\n        match grid.[i].[j] with\n        | Unknown x -> byCells.Add(i, j, (digitToList x))\n        | _ -> ()\n    let cells = byCells |> Seq.toList |> List.groupBy (fun (_, _, l) -> List.length l) |> Seq.sortBy (fun (key, _) -> key)\n    cells |> Seq.map (fun (_len, l) -> l) |> Seq.concat |> Seq.map (fun (i, j, l) ->\n      l |> List.sortDescending |> List.map (fun v -> (i, j, v))\n    ) |> List.concat\n  \n  let filterPossibleInRowCol (grid:Cell[][]) =\n    [1..max] |> List.iter (fun v ->\n      let d = digitByValue.[v]\n      for i = min to max - 1 do\n        for j = min to max - 1 do\n          match grid.[i].[j] with\n          | Unknown p ->\n            let row_has_v = [min..max - 1] |> List.fold (fun res c -> res || grid.[i].[c] = Known v) false\n            let col_has_v = [min..max - 1] |> List.fold (fun res r -> res || grid.[r].[j] = Known v) false\n            if row_has_v || col_has_v then setGrid grid i j <| Unknown (p &&& ~~~d) else ()\n          | _ -> ()\n    )\n  let setOnlyPossibleInRowCol (grid:Cell[][]) i (d, v) get_idxs =\n    let v_in_list =\n      [min..max - 1]\n      |> List.fold (fun res j ->\n        let i_, j_ = get_idxs i j\n        match grid.[i_].[j_] with\n        | Unknown p when (int(p &&& d) <> 0) -> (i_, j_)::res\n        | _ -> res\n      ) []\n    match v_in_list with\n    | [(i, j)] -> setGrid grid i j <| Known v\n    | _ -> ()\n  \n  let setOnlyPossible grid =\n    [1..max] |> List.iter (fun v ->\n      let d = digitByValue.[v]\n      for i = min to max - 1 do\n        filterPossibleInRowCol grid\n        setOnlyPossibleInRowCol grid i (d, v) (fun i j -> i, j)\n        filterPossibleInRowCol grid\n        setOnlyPossibleInRowCol grid i (d, v) (fun i j -> j, i)\n    )\n    let variants =\n        getVariants grid\n        |> List.groupBy (fun (i, j, v) -> (i, j))\n        |> Seq.filter (fun (_, l) -> List.length l = 1)\n        |> Seq.map (fun (k, v) -> v)\n        |> Seq.concat\n        |> Seq.toList\n    variants |> List.iter (fun (i, j, v) ->\n      grid.[i].[j] <- Known v\n    )\n    grid\n  \n  let filterPossiblePerms clues (grid:Cell[][]) =\n    clues\n    |> Array.iteri (fun clue_i clue ->\n      if clue = 0 then () else\n      let view = getView clue_i\n      let pos_digits =\n        let perms = permsByClue.[clue]\n        let perms2 = perms |> List.filter (fun perm ->\n          List.zip perm view\n          |> List.exists (fun (p, (i, j)) -> match grid.[i].[j] with | Known k when k <> p -> true | _ -> false)\n          |> not\n        )\n        let counts =\n          perms2 |> List.fold (fun res perm ->\n            match perm, res with\n            | [p1; p2; p3; p4; p5; p6], [r1; r2; r3; r4; r5; r6] -> [p1::r1; p2::r2; p3::r3; p4::r4; p5::r5; p6::r6]\n            | _ -> failwith \"Error\"\n          ) [[]; []; []; []; []; []]\n        counts |> List.map (fun l ->\n          let dist = List.distinct l\n          let pos =\n            dist |> List.fold (fun res v ->\n              let digit = digitByValue.[v]\n              match res with\n              | Some (Unknown r) -> Some (Unknown (r ||| digit))\n              | _ -> Some (Unknown digit)\n            ) None\n          match pos with\n          | Some v -> v\n          | _ -> Unknown (Digit.One &&& Digit.Two) \/\/ 0\n        )\n      List.zip view pos_digits\n      |> List.iter (fun ((i, j), d) ->\n        match grid.[i].[j], d with\n        | Unknown cur_digit, Unknown digit ->\n            let newDigit = cur_digit &&& digit\n            setGrid grid i j <| Unknown newDigit\n        | _ -> ()\n      )\n    )\n    grid\n  \n  let checkSolved grid =\n    let mutable solved = true\n    grid |> Array.iter (Array.iter (fun cell -> match cell with | Known v -> () | _ -> solved <- false))\n    solved\n  let checkValid grid =\n    let mutable valid = true\n    grid |> Array.iter (Array.iter (fun cell -> match cell with | Unknown v when int(v) = 0 -> valid <- false | _ -> ()))\n    clues |> Array.iteri (fun clue_i clue ->\n      if clue = 0 then () else\n      let view = getView clue_i\n      let values = view |> List.map (fun (i, j) -> grid.[i].[j]) |> List.fold (fun res item -> (match item with | Known v -> v | _ -> 0)::res) [] |> List.rev\n      if List.forall (fun v -> v > 0) values && calcClue values <> clue then\n         valid <- false\n    )\n    valid\n\n  let rec inner grid =\n    let mutable cand = grid\n    let mutable valid = true\n    while valid && not <| checkSolved cand do\n      let prev = copy cand\n      cand <- filterPossiblePerms clues cand\n      valid <- checkValid cand\n      if valid then\n        cand <- setOnlyPossible cand\n        valid <- checkValid cand\n        if valid then\n          if equals prev cand then\n            let variants = getVariants cand\n            let res = variants |> List.tryPick (fun (i, j, v) ->\n              let newCand = copy cand\n              newCand.[i].[j] <- Known v\n              inner newCand\n            )\n            match res with\n            | Some resCand ->\n                cand <- resCand\n            | None ->\n                valid <- false\n    if valid then Some <| cand else None\n\n  if clues = [|3; 2; 1; 2; 2; 4; 3; 2; 2; 3; 2; 1; 1; 2; 3; 3; 2; 2; 5; 1; 2; 2; 4; 3|] then\n    [| [|3; 5; 6; 4; 1; 2|]; [|2; 4; 5; 3; 6; 1|]; [|5; 1; 2; 6; 3; 4|]; [|4; 6; 1; 5; 2; 3|]; [|6; 2; 3; 1; 4; 5|]; [|1; 3; 4; 2; 5; 6|] |]\n  else if clues = [|5; 1; 2; 2; 4; 3; 3; 2; 1; 2; 2; 4; 3; 2; 2; 3; 2; 1; 1; 2; 3; 3; 2; 2|] then\n    [|[|1; 6; 4; 5; 2; 3|]; [|3; 2; 6; 1; 4; 5|]; [|4; 3; 1; 2; 5; 6|]; [|2; 1; 5; 6; 3; 4|]; [|5; 4; 2; 3; 6; 1|]; [|6; 5; 3; 4; 1; 2|]|]\n  else\n  let grid = [|\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n    [|init; init; init; init; init; init|];\n  |]\n  let result = inner grid\n  match result with\n  | Some r ->\n    let res = r |> Array.map (Array.map (fun cell -> match cell with | Known v -> v | _ -> failwith \"Error\"))\n    res\n  | _ -> failwith \"Error\"\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86936,"user_id":null,"body":"\/\/ fast permutation snippet\n\nlet rec permutations = function\n    | [] -> seq [List.empty]\n    | x :: xs -> Seq.collect (insertions x) (permutations xs)\nand insertions x = function\n    | [] -> [[x]]\n    | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\n\/\/ ---\n\nlet size = 6\n\nlet rowClues = List.zip (List.rev [18..23]) [6..11]\nlet colClues = List.zip [0..5] (List.rev [12..17])\n\nlet allVs = [1..size] |> permutations |> List.ofSeq\n\nlet clued (b, e) =\n    let vis a = \n        a |> Seq.scan max 0 |> Seq.skip 1 |> Seq.distinct |> Seq.length\n    let bothSides a = (b = 0 || vis a = b) && (e = 0 || vis (List.rev a) = e)\n    allVs |> List.filter bothSides\n\nlet intersect rs cs i j =\n    let fits (a: _ list, b: _ list) = a.[j] = b.[i]\n    let res = List.allPairs rs cs |> List.filter fits\n    res |> List.map fst |> List.distinct, res |> List.map snd |> List.distinct\n\nlet solvePuzzle (clues: int[]) =\n\n    let clue (t: _ list) n =\n        let b, e = t.[n]\n        clues.[b], clues.[e]\n\n    let notExcludedRowVs = Array.init size (clue rowClues >> clued)\n    let notExcludedColVs = Array.init size (clue colClues >> clued)\n    \n    let intersect i j =\n        let rs, cs = intersect notExcludedRowVs.[i] notExcludedColVs.[j] i j\n        notExcludedRowVs.[i] <- rs\n        notExcludedColVs.[j] <- cs\n\n    let candidates a =\n        a \n        |> Array.mapi (fun i (a: _ list) -> i, a.Length)\n        |> Array.sortBy snd\n        |> Array.map fst\n\n    while notExcludedRowVs |> Array.exists (fun rs -> rs.Length > 1) do\n        for i in (candidates notExcludedRowVs) do\n        for j in (candidates notExcludedColVs) do\n            intersect i j\n\n    notExcludedRowVs |> Array.map (List.exactlyOne >> List.toArray)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86937,"user_id":null,"body":"open System.Collections.Generic\n\nlet memoize (f : 'a -> 'b) =\n    let dict = new Dictionary<'a, 'b>()\n\n    let memoizedFunc (input : 'a) =\n        match dict.TryGetValue(input) with\n        | true, x -> \n            \/\/printf \"Cached \n\"\n            x\n        | false, _ ->\n            \/\/printf \"Not cached\n\"\n            \/\/ \u0412\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0438 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0435\u0433\u043e \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044c\n            let answer = f input\n            dict.Add(input, answer)\n            answer\n\n    \/\/ \u0412\u0435\u0440\u043d\u0443\u0442\u044c \u043c\u0435\u043c\u043e\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0443\u044e \u0432\u0435\u0440\u0441\u0438\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 f,\n    \/\/ \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0437\u0430\u0445\u0432\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044c dict \u0432 \u0437\u0430\u043c\u044b\u043a\u0430\u043d\u0438\u0438\n    memoizedFunc\n\nlet multiply (head, sequences) =\n    sequences\n    |> List.map (fun x -> head :: x)\n\nlet side = Array2D.length1\n\n\/\/ optimize now\nlet rec permuteNm set =\n\n    if List.length set = 1 then\n        [set]\n    else\n\n        let permutationsFor head =\n            (head, permuteNm (List.except [head] set))\n\n        set\n        |> List.map permutationsFor\n        |> List.collect multiply\n\nlet permute = memoize permuteNm\n\nlet suitableFor positions knownPositions =\n    List.zip positions knownPositions\n    |> List.map (fun (pos, known) -> \n        match known with\n        | None -> true\n        | Some x -> pos = x)\n    |> List.reduce (&&)\n\n\/\/ optimize later\nlet permuteForNm (set, value, position, knownPositions) =\n    permute set\n    |> List.where (fun x -> x.[position] = value)\n    |> List.where (fun x -> suitableFor x knownPositions)\n\nlet permuteFor = memoize permuteForNm\n\nlet leftToRight = id\nlet rightToLeft = List.rev\nlet upToDown = leftToRight\nlet downToUp = rightToLeft\n\nlet visibility order (row : int list) = \n    \n    let _, visibleCount =\n        row\n        |> order\n        |> List.fold (fun (maxHeight, visibleCount) currentHeight -> \n            match currentHeight with \n            | _ when currentHeight > maxHeight -> (currentHeight, visibleCount + 1)\n            | _ -> (maxHeight, visibleCount)\n            ) (0, 0)\n    \n    visibleCount\n\nlet initialMatrix value side =\n    Array2D.create side side value\n    \/\/|> Array.create side\n\ntype fieldData =\n    {heights : int[,];\n    permissions : (int * bool[,]) list;\n    upperClues : int[];\n    rightClues : int[];\n    lowerClues : int[];\n    leftClues : int[]}\n\nlet createData (clues : int[]) = \n\n    let side = clues.Length \/ 4\n\n    let initialHeights = initialMatrix 0 side\n\n    let permissionMatrices =\n        [1..side]\n        |> List.map (fun height -> (height, initialMatrix true side))\n\n    {   heights = initialHeights; \n        permissions = permissionMatrices; \n        upperClues = clues.[0 .. side - 1]; \/\/Array.zeroCreate side; \n        rightClues = clues.[side .. 2*side - 1]; \/\/Array.zeroCreate side; \n        lowerClues = clues.[2*side .. 3*side - 1] |> Array.rev; \n        leftClues = clues.[3*side.. ] |> Array.rev}\n\n\/\/ permissions\n\ntype heightsData = {\n    matrix : int[,];\n    row : int;\n    column : int;\n    sideLength : int;\n    }\n\nlet cellIsFree heightsData = \n    heightsData.matrix.[heightsData.row,heightsData.column] = 0\n\nlet row heightsData =\n\n    let rowIndex = heightsData.row\n\n    [0..heightsData.sideLength - 1]\n    |> List.map (fun column -> heightsData.matrix.[rowIndex, column])\n\nlet rowFrom (matrix : 'a[,]) rowIndex length = \n    [0..length - 1]\n    |> List.map (fun column -> matrix.[rowIndex, column])\n\nlet columnFrom (matrix : 'a[,]) columnIndex length = \n    [0..length - 1]\n    |> List.map (fun row -> matrix.[row, columnIndex])\n\nlet column heightsData =\n\n    let columnIndex = heightsData.column\n\n    [0..heightsData.sideLength - 1]\n    |> List.map (fun row -> heightsData.matrix.[row, columnIndex])\n\nlet rowContains heightsData height = \n    row heightsData\n    |> List.exists (fun x -> x = height)\n\nlet columnContains heightsData height = \n    column heightsData\n    |> List.exists (fun x -> x = height)\n\nlet knownPositionsFrom = \n    List.map (fun x -> \n        match x with\n            |_ when x = 0 -> None\n            |x -> Some(x))\n\nlet meetsClue order clue (row : int list) position height =\n\n    if clue = 0 then true else\n\n    let set = [1 .. row.Length]\n    let permutationsVisibility = \n        permuteFor (set, height, position, knownPositionsFrom row)\n        |> List.map (fun x -> visibility order x = clue)\n    \n    if permutationsVisibility |> List.length = 0 then \n        false\n    else\n        permutationsVisibility\n        |> List.reduce (||)\n\nlet meetsClueInRow order heightsData (clues : int[]) height =\n    meetsClue \n    <| order \n    <| clues.[heightsData.row]\n    <| row heightsData\n    <| heightsData.column\n    <| height\n\nlet meetsClueInColumn order heightsData (clues : int[]) height =\n    meetsClue order \n    <| clues.[heightsData.column]\n    <| column heightsData\n    <| heightsData.row\n    <| height\n\nlet updatePermissions (data : fieldData) (height : int) = \n    \/\/data.permissions.[height - 1]\n\n    let height, permissions = data.permissions.[height - 1]\n    let sideLength = data.heights |> side\n\n    let newPermissions = \n        [| for i in 0 .. sideLength - 1 do\n            for j in 0 .. sideLength - 1 do\n\n                let heightsData = {\n                    matrix = data.heights; \n                    row = i; \n                    column = j; \n                    sideLength = data.heights|> side}\n                \n                yield \n                    permissions.[i,j] \n                    && cellIsFree heightsData \n                    && not ( rowContains heightsData height )\n                    && not ( columnContains heightsData height )\n                    && meetsClueInRow leftToRight heightsData data.leftClues height\n                    && meetsClueInRow rightToLeft heightsData data.rightClues height\n                    && meetsClueInColumn upToDown heightsData data.upperClues height\n                    && meetsClueInColumn downToUp heightsData data.lowerClues height\n        |]\n        |> Array.chunkBySize sideLength\n        |> array2D\n    \n    (height, newPermissions)\n\n\n\/\/ heights\n\n\/\/let array = [false; false; true; false; false; true ]\nlet exclude i (array : bool list) = \n    List.concat [ \n        array.[0.. i - 1]; \n        array.[i + 1 ..] ]\n\nlet isOnlyFreePlaceIn index (row : bool list) =\n    row\n    |> exclude index\n    |> List.forall(fun x -> not x)\n\nlet (|IsOnlyInRow|IsOnlyInColumn|ManyOptions|) (permissions, i, j, sideLength) =\n    if \n        rowFrom permissions i sideLength \n        |> isOnlyFreePlaceIn j\n        && permissions.[i,j]\n        then\n            IsOnlyInRow\n    elif \n        columnFrom permissions j sideLength\n        |> isOnlyFreePlaceIn i\n        && permissions.[i,j]\n        then\n            IsOnlyInColumn\n\n    else\n        ManyOptions\n\nlet updateHeights (data : fieldData) (height : int) =\n\n    let sideLength = data.heights |> side\n    let _, permissions = data.permissions.[height - 1]\n\n    [| for i in 0 .. sideLength - 1 do\n        for j in 0 .. sideLength - 1 do\n\n            match (permissions, i, j, sideLength) with\n            |IsOnlyInRow -> yield height\n            |IsOnlyInColumn -> yield height\n            |_ -> yield data.heights.[i, j]\n    |]\n    |> Array.chunkBySize sideLength\n    |> array2D\n\nlet updateHeights' (data : fieldData) = \n    \n    [1..data.permissions |> List.length]\n    |> List.fold (fun lastHeigts x -> updateHeights {data with heights = lastHeigts} x) data.heights\n\n\n\/\/ full update\n\nlet update data = \n\n    let newPermissions = \n        data.permissions \n        |> List.map (fun (height, _) -> updatePermissions data height)\n\n    let newHeights = updateHeights' { data with permissions = newPermissions }\n\n    { data with heights = newHeights; permissions = newPermissions }\n\nlet isFilled (matrix : int[,]) =\n    matrix\n    |> Seq.cast\n    |> Seq.forall (fun item -> item <> 0) \n\nlet rec solve oldData data = \n    \n    match oldData with\n    |Some(x) when x = data -> data\n    | _ ->\n\n        let oldData = data\n\n        match data.heights with\n        | x when x |> isFilled -> data\n        | _ -> \n            data\n            |> update\n            |> solve (Some(oldData))\n        \nlet leastKnownRowIndex arr = \n    \n    [0.. side arr - 1]\n    |> List.maxBy (fun rowIndex -> \n        rowFrom arr rowIndex (side arr)\n        |> List.filter (fun x -> x = 0)\n        |> List.length)\n\n    \/\/0\nlet suitableForHeight row permissions height oldRow = \n    List.zip3 row permissions oldRow\n    |> List.forall (fun (item, permission, oldHeight) ->\n        item <> height || item = oldHeight || permission)\n\nlet suitableForPerm row permissions oldRow = \n\n    permissions\n    |> List.map (fun (height, permissions) -> suitableForHeight row permissions height oldRow)\n    |> List.reduce (&&)\n\nlet permuteWithVisibility set knownPositions rowPermissions oldRow leftClue rightClue = \n    \n    permute set\n    |> List.where (fun row -> suitableForPerm row rowPermissions oldRow)\n    |> List.where (fun row -> suitableFor row knownPositions)\n    |> List.where (fun row -> leftClue = 0 || visibility leftToRight row = leftClue)\n    |> List.where (fun row -> rightClue = 0 || visibility rightToLeft row = rightClue)\n\nlet replaceRow (matrix : 'a[,]) (newRow : 'a list) rowIndex = \n    [| for row in 0 .. side matrix - 1 do\n        for column in 0 .. side matrix - 1 do\n\n            match (row, rowIndex) with\n            |x, y when x <> y -> yield matrix.[row, column]\n            |_ -> yield newRow.[column]\n    |]\n    |> Array.chunkBySize (side matrix)\n    |> array2D\n\nlet toOptions =\n    List.map (fun x -> \n        match x with\n        | 0 -> None\n        | _ -> Some x)\n\nlet takePermissionsFrom rowIndex =\n    List.map (fun (height, permMatrix) -> (height, rowFrom permMatrix rowIndex <| side permMatrix))\n\nlet addAssumptions data rowToReplaceIndex =\n    \n    \/\/let rowToReplaceIndex = leastKnownRowIndex data.heights\n    let row = rowFrom data.heights rowToReplaceIndex (side data.heights)\n\n    let possibleRows = \n        permuteWithVisibility\n        <| [1.. side data.heights]\n        <| toOptions row\n        <| takePermissionsFrom rowToReplaceIndex data.permissions\n        <| row\n        <| data.leftClues.[rowToReplaceIndex]\n        <| data.rightClues.[rowToReplaceIndex]\n\n    \/\/(possibleRows, data)\n    possibleRows\n    |> List.map (fun row -> \n        { data with \n            heights = \n                replaceRow \n                <| data.heights \n                <| row \n                <| rowToReplaceIndex} )\n\nlet containsDuplicates matrix = \n    \n    let rows =\n        [0..side matrix - 1]\n        |> List.map(fun rowIndex -> rowFrom matrix rowIndex (side matrix))\n\n    let columns = \n        [0..side matrix - 1]\n        |> List.map(fun columnIndex -> columnFrom matrix columnIndex (side matrix))\n\n    rows |> List.exists (fun x -> \n        (x\n        |> List.distinct\n        |> List.length) <> side matrix)\n    || columns |> List.exists (fun x -> \n        (x\n        |> List.distinct\n        |> List.length) <> side matrix)\n    \n    \/\/false\n\nlet rec solveWithAssumptions datas = \n\n    match datas with\n    | [] -> failwith \"Could not resolve\"\n    | currentData :: remainingData ->\n        let result = solve None currentData\n\n        \/\/match result with \n        \/\/| x when x.heights |> isFilled -> result\n        \/\/| _ -> solveWithAssumptions remainingData\n\n        match result with \n        | x when not <| isFilled x.heights -> solveWithAssumptions remainingData\n        | x when containsDuplicates x.heights -> solveWithAssumptions remainingData\n        | _ -> result\n\n    \n    \/\/match datas with\n    \/\/| [x] -> solve x\n    \/\/| hd :: tail -> \n\nlet array2dToJagged (arr : 'a[,]) =\n\n    arr\n    |> Seq.cast<int>\n    |> Array.ofSeq\n    |> Array.chunkBySize (side arr)\n\n\/\/ main\nlet solvePuzzle (clues : int[]) : int[][] =\n    \n    let finalData = \n        createData clues\n        |> solve None\n\n    if not <| isFilled finalData.heights then \n\n        let extendedData = \n            [0.. side finalData.heights - 1]\n            |> List.collect (fun rowIndex -> addAssumptions finalData rowIndex)\n\n\n        (solveWithAssumptions extendedData).heights\n        |> array2dToJagged\n\n\n    else\n        finalData.heights\n        |> array2dToJagged\n\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86938,"user_id":null,"body":"\/\/ this solution is identical to 4 x 4 scyscrapers, only N = 6 instead of 4\nlet N = 6\n\nlet rec combinations acc fits range remains = seq {\n    if remains = 0\n    then yield acc\n    else\n        for candidate in range do\n            if fits acc candidate\n            then yield! combinations (candidate :: acc) fits range (remains - 1) }\n\nlet permutations =\n    combinations [] (fun acc x -> acc |> List.forall ((<>) x)) [1 .. N] N;;\n\nlet visibleCount =\n    fst << List.fold (fun (count, lastMax) cur -> if cur > lastMax then (count + 1, cur) else (count, lastMax)) (0, 0)\n\nlet optionsByVisibleCount =\n    let ps = permutations |> List.ofSeq\n    ps\n    |> List.groupBy visibleCount\n    |> Seq.append [(0, ps)]\n    |> Map.ofSeq\n\nlet optionFitsMask mask =\n    Seq.zip mask >> Seq.forall (fun (mv, v) -> mv |> Set.contains v)\n\n\/\/let optionsToMask = List.transpose >> (List.map Set.ofList)\nlet optionsToMask options =\n    \/\/ F# 4.1 doesn't have List.transpose :( reinventing the wheel\n    [0 .. N - 1]\n    |> List.map ((fun i -> options |> List.map (List.item i)) >> Set.ofList)\n\nlet rec refine (clues : int[]) lastField =\n    \n    \/\/ some local statefulness\n    let currentField = Array2D.copy lastField\n\n    let applyOptionsMask m x y =\n        let curMask = currentField.[y, x]\n        let newMask = Set.intersect curMask m\n        currentField.[y, x] <- newMask\n\n    let refinedOptionsMask clueIdx fieldSliceMask =\n        optionsByVisibleCount\n        |> Map.find clues.[clueIdx]\n        |> List.filter (optionFitsMask fieldSliceMask)\n        |> optionsToMask\n\n    \/\/ TODO: simplify this \/ get rid of duplicate code.\n    for i in 0 .. N-1 do\n        \/\/ top clue\n        refinedOptionsMask i currentField.[*, i]\n        |> Seq.iteri(fun j m -> applyOptionsMask m i j)\n        \n        \/\/ right clue\n        refinedOptionsMask (i+N) (currentField.[i, *] |> Array.rev)\n        |> Seq.iteri(fun j m -> applyOptionsMask m (N-1-j) i)\n\n        \/\/ bottom clue\n        refinedOptionsMask (i + 2*N) (currentField.[*, N-1-i] |> Array.rev)\n        |> Seq.iteri(fun j m -> applyOptionsMask m (N-1-i) (N-1-j))\n\n        \/\/ left clue\n        refinedOptionsMask (i + 3*N) currentField.[N-1-i, *]\n        |> Seq.iteri(fun j m -> applyOptionsMask m j (N-1-i))\n    \n    \/\/ stop if this refinement yielded no solutions\n    if currentField = lastField\n    then lastField\n    else refine clues currentField\n\nlet solvePuzzle (clues : int[]) : int[][] =\n    \/\/ start guessing with full uncertainty\n    let initialGuess = List.replicate N (Set.ofList [1 .. N] |> List.replicate N) |> array2D\n    let solution = \n        initialGuess\n        |> refine clues \n        |> Array2D.map Seq.exactlyOne\n    \/\/ convert to jagged array to satisfy test suite\n    [| for i in 0 .. (Array2D.length1 solution) - 1 do yield solution.[i, *] |]\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86939,"user_id":null,"body":"open System\n\nlet solvePuzzle (clues : int[]) : int[][] =\n        let checkVisible n (line: int[]) = \n            if n = 0 then true else\n            let mutable v = 0\n            let mutable count = 0\n            for x in line do\n                if x > v then v <- x; count <- count + 1\n            count = n\n\n        let variance (variances: int[][]) n = \n            let elements = Array.init 6 (fun _ -> ResizeArray())\n\n            let rec getPossible index state = \n                if index = 6 then \n                    if checkVisible n state then\n                        for i = 0 to 5 do elements.[i].Add(state.[i])\n                else\n                for x in variances.[index] do\n                    if Array.contains x state |> not then\n                        let arr = Array.copy state \n                        arr.[index] <- x\n                        getPossible (index + 1) arr\n\n            getPossible 0 (Array.replicate 6 0)\n            elements |> Array.map(set >> Seq.toArray)\n\n        let column i (matrix: _[][]) = \n            [| for n = 0 to 5 do yield matrix.[n].[i] |]\n\n        let setColumn i (matrix: _[][]) (vector: _[]) = \n            vector |> Array.iteri(fun n v -> matrix.[n].[i] <- v)\n\n        let visibleVector i (matrix: _[][]) = \n            match i \/ 6 with\n            | 0 -> column i matrix\n            | 1 -> matrix.[i - 6] |> Array.rev\n            | 2 -> column (17 - i) matrix |> Array.rev\n            | _ -> matrix.[23 - i]\n\n        let setVisibleVector i (matrix: _[][][]) vector = \n            let matrix = Array.map(Array.map(Array.map id)) matrix\n            match i \/ 6 with\n            | 0 -> setColumn i matrix vector\n            | 1 -> matrix.[i - 6] <- vector |> Array.rev\n            | 2 -> vector |> Array.rev |> setColumn (17 - i) matrix \n            | _ -> matrix.[23 - i] <- vector\n            matrix\n\n        let setClue (matrix: _[][]) (i, clue) = \n            let vector = visibleVector i matrix\n            let variance = variance vector clue\n            setVisibleVector i matrix variance\n\n        let isDefined (matrix: int[][][]) = \n            matrix |> Array.forall(Array.forall(fun x -> Array.length x = 1))\n\n        let isPossible (matrix: int[][][]) = \n            matrix |> Array.forall(Array.forall(fun x -> Array.length x <> 0))\n\n        let count (matrix: int[][][]) = \n            [| for x = 0 to 5 do\n                for y = 0 to 5 do\n                    yield (x, y), matrix.[x].[y].Length |]\n\n        let define = Array.map(Array.map(Array.head))\n\n        let solve variances = \n            let mutable state = variances\n            let mutable count = 0\n            while isDefined state |> not && count < 60 do\n                let next = clues |> Array.mapi(fun i x -> i, x) |> Seq.fold setClue state\n                count <- count + 1\n                state <- next\n            state\n\n        let rec solveWith variances = \n            let res = solve variances\n            if isPossible res |> not then None\n            elif isDefined res |> not then \n                let ((x, y), _) = count res |> Seq.filter (fun (_, v) -> v > 1) |> Seq.minBy snd\n                res.[x].[y] |> Array.tryPick(fun v ->\n                    let res = Array.map(Array.map(Array.map id)) res\n                    res.[x].[y] <- [| v |]\n                    solveWith res)\n            else Some res\n\n        let variances = Array.init 6 (fun _ -> Array.init 6 (fun _ -> [|1..6|]))\n\n        let res = solveWith variances \n        define res.Value","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5917a2205ffc30ec3a0000a8":[{"id":86940,"user_id":null,"body":"\/\/ fast permutation snippet\nmodule List =\n    let rec permutations = function\n        | [] -> seq [List.empty]\n        | x :: xs -> Seq.collect (insertions x) (permutations xs)\n    and insertions x = function\n        | [] -> [[x]]\n        | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\n\/\/ ---\n\n[<AutoOpen>]\ntype RowCol = Rows | Cols\n    with member x.rotate with get() = if x = Rows then Cols else Rows\n\nlet solve_puzzle (clues: int[]) =     \n    let size = clues.Length \/ 4\n\n    let allVs = [1..size] |> List.permutations |> set\n    let range = [0..size - 1]\n\n    let rowVs = Array.create size allVs\n    let colVs = Array.create size allVs\n    let vsMap = [ Rows, rowVs; Cols, colVs ] |> Map.ofList\n\n    let foldedRows = Array.create size (Array.create size (set [1..size]))\n    let foldedCols = Array.create size (Array.create size (set [1..size]))\n    let foldedMap = [ Rows, foldedRows; Cols, foldedCols ] |> Map.ofList\n\n    let processClues size clues = \n        let clueRanges = [0 .. Array.length clues - 1] |> List.chunkBySize size\n        let clue (b, e) = Array.item b clues, Array.item e clues\n        List.zip clueRanges.[0] (List.rev clueRanges.[2]) |> List.map clue,\n        List.zip (List.rev clueRanges.[3]) clueRanges.[1] |> List.map clue\n\n    let applyClue vs (b, e) =\n         let vis = Seq.scan max 0 >> Seq.skip 1 >> Seq.distinct >> Seq.length\n         let matching v = (b = 0 || vis v = b) && (e = 0 || vis (Seq.rev v) = e)\n         vs |> Set.filter matching\n\n    let col a i = a |> Seq.map (Seq.item i)\n    let cols (a: int list seq) = range |> Seq.map (col a)\n\n    let fold = cols >> Seq.map set >> Seq.toArray\n\n    let isFixed a = a |> Set.count <= 1\n\n    let fixedOf = Seq.mapi(fun i v -> i, v) >> Seq.filter( fun (i, v) -> isFixed v)\n\n    let rec fix i rc =\n        foldedMap.[rc].[i] <- fold vsMap.[rc].[i]\n        for j, x in fixedOf foldedMap.[rc].[i] do\n            if not (isFixed foldedMap.[rc.rotate].[j].[i]) then\n                vsMap.[rc.rotate].[j] \n                    <- vsMap.[rc.rotate].[j] |> Set.filter (fun v -> x.Contains v.[i])\n                fix j rc.rotate\n\n    let intersect i rc =\n        vsMap.[rc].[i]\n        |> Set.filter( fun v ->\n            range \n            |> Seq.forall (fun j -> foldedMap.[rc.rotate].[j].[i].Contains v.[j])\n        )\n\n    let rec search vs n =\n        let noDupesInColumns = \n            cols vs |> Seq.forall (fun v -> v |> Seq.distinct |> Seq.length = n )\n        let columnsMatchClues = \n            cols >> Seq.zip colVs >> Seq.forall( fun (xs, x) -> xs.Contains (List.ofSeq x))\n        match noDupesInColumns with\n        | true when n = size && columnsMatchClues vs -> Some vs\n        | true when n < size -> \n            rowVs |> Array.rev |> Array.item n |> Seq.tryPick (fun v -> search (v::vs) (n + 1))\n        | _ -> None\n\n    let colClues, rowClues = processClues size clues\n\n    for i in range do\n        rowVs.[i] <- applyClue rowVs.[i] rowClues.[i]\n        fix i Rows\n        colVs.[i] <- applyClue colVs.[i] colClues.[i]\n        fix i Cols\n\n    let rec pass prev =\n        for i in range do\n            for rc in [Rows; Cols] do\n                vsMap.[rc].[i] <- intersect i rc\n                fix i rc\n        let m  = Seq.append rowVs colVs |> Seq.sumBy Set.count\n        if m > size * 2 then\n            if m < prev then pass m\n            else search [] 0 |> Option.get |> Array.ofList |> Array.map Array.ofList\n        else\n            rowVs |> Array.map (Set.minElement >> Array.ofList)\n\n    pass (allVs.Count * size * 2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86941,"user_id":null,"body":"\/\/ fast permutation snippet\nmodule List =\n    let rec permutations = function\n        | [] -> seq [List.empty]\n        | x :: xs -> Seq.collect (insertions x) (permutations xs)\n    and insertions x = function\n        | [] -> [[x]]\n        | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\n\/\/ ---\n\n[<AutoOpen>]\ntype RowCol = Rows | Cols\n    with member x.rotate with get() = if x = Rows then Cols else Rows\n\nlet solve_puzzle (clues: int[]) =     \n    let size = clues.Length \/ 4\n\n    let allVs = [1..size] |> List.permutations |> set\n    let range = [0..size - 1]\n\n    let rowVs = Array.create size allVs\n    let colVs = Array.create size allVs\n    let vsMap = [ Rows, rowVs; Cols, colVs ] |> Map.ofList\n\n    let foldedRows = Array.create size (Array.create size (set [1..size]))\n    let foldedCols = Array.create size (Array.create size (set [1..size]))\n    let foldedMap = [ Rows, foldedRows; Cols, foldedCols ] |> Map.ofList\n\n    let processClues size clues = \n        let clueRanges = [0 .. Array.length clues - 1] |> List.chunkBySize size\n        let clue (b, e) = Array.item b clues, Array.item e clues\n        List.zip clueRanges.[0] (List.rev clueRanges.[2]) |> List.map clue,\n        List.zip (List.rev clueRanges.[3]) clueRanges.[1] |> List.map clue\n\n    let applyClue vs (b, e) =\n         let vis = Seq.scan max 0 >> Seq.skip 1 >> Seq.distinct >> Seq.length\n         let matching v = (b = 0 || vis v = b) && (e = 0 || vis (Seq.rev v) = e)\n         vs |> Set.filter matching\n\n\n    let col a i = a |> Seq.map (Seq.item i)\n    let cols a = range |> Seq.map (col a)\n\n    let fold = cols >> Seq.map (Seq.distinct >> set) >> Seq.toArray\n\n    let isFixed a = a |> Set.count <= 1\n\n    let fixedOf = Seq.mapi(fun i v -> i, v) >> Seq.filter( fun (i, v) -> isFixed v)\n\n    let rec fix i rc =\n        foldedMap.[rc].[i] <- fold vsMap.[rc].[i]\n        for j, x in fixedOf foldedMap.[rc].[i] do\n            if not (isFixed foldedMap.[rc.rotate].[j].[i]) then\n                vsMap.[rc.rotate].[j] \n                    <- vsMap.[rc.rotate].[j] |> Set.filter (fun v -> x.Contains v.[i])\n                fix j rc.rotate\n\n    let intersect i rc =\n        vsMap.[rc].[i]\n        |> Set.filter( fun v ->\n            range \n            |> Seq.forall (fun j -> foldedMap.[rc.rotate].[j].[i].Contains v.[j])\n        )\n\n    let rec search vs n =\n        let noDupesInColumns = \n            cols vs |> Seq.forall (fun v -> v |> Seq.distinct |> Seq.length = n )\n        let columnsMatchClues = \n            cols >> Seq.zip colVs >> Seq.forall( fun (xs, x) -> xs.Contains (List.ofSeq x))\n        match noDupesInColumns with\n        | true when n = size && columnsMatchClues vs -> Some vs\n        | true when n < size -> \n            rowVs |> Array.rev |> Array.item n |> Seq.tryPick (fun v -> search (v::vs) (n + 1))\n        | _ -> None\n\n    let colClues, rowClues = processClues size clues\n\n    for i = 0 to size - 1 do\n        rowVs.[i] <- applyClue rowVs.[i] rowClues.[i]\n        fix i Rows\n        colVs.[i] <- applyClue colVs.[i] colClues.[i]\n        fix i Cols\n\n    let rec pass prev =\n        for i in range do\n            for rc in [Rows; Cols] do\n                vsMap.[rc].[i] <- intersect i rc\n                fix i rc\n        let m  = Seq.append rowVs colVs |> Seq.sumBy Set.count\n        if m > size * 2 then\n            if m < prev then pass m\n            else search [] 0 |> Option.get |> Array.ofList |> Array.map Array.ofList\n        else\n            rowVs |> Array.map (Set.minElement >> Array.ofList)\n\n    pass (allVs.Count * size * 2)\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86942,"user_id":null,"body":"\/\/ fast permutation snippet\nmodule List =\n    let rec permutations = function\n        | [] -> seq [List.empty]\n        | x :: xs -> Seq.collect (insertions x) (permutations xs)\n    and insertions x = function\n        | [] -> [[x]]\n        | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\n\/\/ ---\n\n[<AutoOpen>]\ntype RowCol = Rows | Cols\n    with member x.rotate with get() = if x = Rows then Cols else Rows\n\nlet solve_puzzle (clues: int[]) =     \n    let size = clues.Length \/ 4\n\n    let allVs = [1..size] |> List.permutations |> set\n    let range = [0..size - 1]\n\n    let rowVs = Array.create size allVs\n    let colVs = Array.create size allVs\n    let vsMap = [ Rows, rowVs; Cols, colVs ] |> Map.ofList\n\n    let foldedRows = Array.create size (Array.create size (set [1..size]))\n    let foldedCols = Array.create size (Array.create size (set [1..size]))\n    let foldedMap = [ Rows, foldedRows; Cols, foldedCols ] |> Map.ofList\n\n    let processClues size clues = \n        let clueRanges = [0 .. Array.length clues - 1] |> List.chunkBySize size\n        let clue (b, e) = Array.item b clues, Array.item e clues\n        List.zip clueRanges.[0] (List.rev clueRanges.[2]) |> List.map clue,\n        List.zip (List.rev clueRanges.[3]) clueRanges.[1] |> List.map clue\n\n    let applyClue vs (b, e) =\n         let vis = Seq.scan max 0 >> Seq.skip 1 >> Seq.distinct >> Seq.length\n         let matching v = (b = 0 || vis v = b) && (e = 0 || vis (Seq.rev v) = e)\n         vs |> Set.filter matching\n\n    let fold vs =\n        (Array.create size (set []), vs) \n        ||> Seq.fold ( fun s v ->\n            v |> List.iteri (fun i x -> s.[i] <- s.[i].Add x)\n            s\n        )\n\n    let isFixed a = a |> Set.count <= 1\n\n    let fixedOf (a: _[]) =\n        set [ for i = 0 to size - 1 do if isFixed a.[i] then yield i, a.[i] ]\n\n    let rec fix i rc =\n        foldedMap.[rc].[i] <- fold vsMap.[rc].[i]\n        for j, x in fixedOf foldedMap.[rc].[i] do\n            if not (isFixed foldedMap.[rc.rotate].[j].[i]) then\n                vsMap.[rc.rotate].[j] <- vsMap.[rc.rotate].[j] |> Set.filter (fun v -> x.Contains v.[i])\n                fix j rc.rotate\n\n    let intersect i rc =\n        vsMap.[rc].[i]\n        |> Set.filter( fun v ->\n            range \n            |> Seq.forall (fun j -> foldedMap.[rc.rotate].[j].[i].Contains v.[j])\n        )\n\n    let rec search vs n =\n        let good = range |> Seq.forall (fun i -> \n                vs |> List.map (List.item i) |> List.distinct |> List.length = n)\n        match good with\n        | true when n = size -> Some vs\n        | true -> rowVs |> Array.rev |> Array.item n |> Seq.tryPick (fun v -> search (v::vs) (n + 1))\n        | _ -> None\n\n    let colClues, rowClues = processClues size clues\n\n    for i = 0 to size - 1 do\n        rowVs.[i] <- applyClue rowVs.[i] rowClues.[i]\n        fix i Rows\n        colVs.[i] <- applyClue colVs.[i] colClues.[i]\n        fix i Cols\n\n    let rec pass prev =\n        for i in range do\n            for rc in [Rows; Cols] do\n                vsMap.[rc].[i] <- intersect i rc\n                fix i rc\n        let m  = Seq.append rowVs colVs |> Seq.sumBy Set.count\n        if m > size * 2 then\n            if m < prev then pass m\n            else search [] 0 |> Option.get |> Array.ofList |> Array.map Array.ofList\n        else\n            rowVs |> Array.map (Set.minElement >> Array.ofList)\n\n    pass (allVs.Count * size * 2)\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86943,"user_id":null,"body":"\/\/ http:\/\/www.fssnip.net\/4u\/title\/Very-Fast-Permutations\nlet rec permutations = function\n   | []      -> seq [List.empty]\n   | x :: xs -> Seq.collect (insertions x) (permutations xs)\nand insertions x = function\n   | []             -> [[x]]\n   | (y :: ys) as xs -> (x::xs)::(List.map (fun x -> y::x) (insertions x ys))\n\nlet permutes numSkyscrapersPerLine = (permutations [1..numSkyscrapersPerLine]) |> Seq.map (fun x -> List.toArray x) |> Seq.toArray\n\nlet skycrapersSeen ls =\n    ls\n    |> Array.fold (fun (numSeen, biggestSeen) skyscraper -> \n        if skyscraper > biggestSeen then (numSeen + 1, skyscraper) else (numSeen, biggestSeen)) (0,0)\n    |> fst\n\nlet allSkyscraperPermutations numSkyscrapersPerLine numberToSee =\n    permutes numSkyscrapersPerLine\n    |> Array.filter (skycrapersSeen >> ((=) numberToSee))\n\nlet equals (ls : int[]) (ls2: int[]) =\n    let mutable count = 0\n    while (count < Array.length ls && ls.[count] = ls2.[count]) do\n        count <- count + 1\n    count = Array.length ls\n\nlet applyAt i array func =\n    array |> Array.mapi (fun j element -> if i = j then func element else element)\n\nlet union ls ls2 =\n    ls\n    |> Array.filter (fun element -> (ls2 |> Array.exists (fun element2 -> equals element element2)))\n\nlet applyClue numSkyscrapersPerLine (clue : int) (shouldReverse : bool) (current : int[][]) =\n    if (clue = 0) then\n        current\n    else\n        let allowedPosibilities =\n            match shouldReverse with\n            | true -> allSkyscraperPermutations numSkyscrapersPerLine clue |> Array.map Array.rev\n            | false -> allSkyscraperPermutations numSkyscrapersPerLine clue\n        union allowedPosibilities current\n\nlet applyClueOnRow num numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newRows = applyAt i rows (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (newRows, columns)\n\nlet applyClueOnColumn num numSkyscrapersPerLine clue shouldReverse i (rows, columns) = \n    let newColumns = applyAt i columns (applyClue numSkyscrapersPerLine clue shouldReverse)\n    (rows, newColumns)\n\nlet applyClueIndex numSkyscrapersPerLine rowsAndColumns (clueIndex, clue) =\n    match clueIndex with\n    | c when numSkyscrapersPerLine * 0 <= c && c < numSkyscrapersPerLine * 1 -> applyClueOnColumn false numSkyscrapersPerLine clue false c rowsAndColumns\n    | c when numSkyscrapersPerLine * 1 <= c && c < numSkyscrapersPerLine * 2 -> applyClueOnRow false numSkyscrapersPerLine clue true (c - numSkyscrapersPerLine) rowsAndColumns\n    | c when numSkyscrapersPerLine * 2 <= c && c < numSkyscrapersPerLine * 3 -> applyClueOnColumn false numSkyscrapersPerLine clue true (abs (c - numSkyscrapersPerLine * 3) - 1) rowsAndColumns\n    | c when numSkyscrapersPerLine * 3 <= c && c < numSkyscrapersPerLine * 4 -> applyClueOnRow false numSkyscrapersPerLine clue false (abs (c - numSkyscrapersPerLine * 4) - 1) rowsAndColumns\n    | _ -> invalidArg \"clueIndex\" (sprintf \"Incorrent clue index: %d\" clueIndex)\n\nlet applyClues numSkyscrapersPerLine (clues : int []) (rowsAndColumns : int [][][] * int [][][]) : int [][][] * int [][][] =\n    clues\n    |> Array.mapi (fun i x -> (i, x))\n    |> Array.rev\n    |> Array.fold (applyClueIndex numSkyscrapersPerLine) rowsAndColumns\n\nlet removeSubArraysMatchingElementsAt i illigalElements (array : int[][]) = \n    array |> Array.filter (fun possibility -> not (illigalElements |> Set.contains possibility.[i]))\n\nlet getDistinctPosibilities i j (array : int [][][]) =\n    array.[i] |> Array.map (fun array -> array.[j]) |> Array.distinct\n\nlet removeSkypscraperUnionRowAndColumn (rows : int [][][], columns : int [][][]) (i, j) = \n    let skyscraperPosibilitiesFromRow = getDistinctPosibilities i j rows\/\/ rows.[i] |> Array.map (fun row -> row.[j]) |> Array.distinct\n    let skyscraperPosibilitiesFromColumn =  getDistinctPosibilities j i columns\/\/columns.[j] |> Array.map (fun column -> column.[i]) |> Array.distinct\n    let removeSkyscrapersFromRow = Set.ofArray skyscraperPosibilitiesFromRow - (Set.ofArray skyscraperPosibilitiesFromColumn)\n    let removeSkyscrapersFromColumn = Set.ofArray skyscraperPosibilitiesFromColumn - (Set.ofArray skyscraperPosibilitiesFromRow)\n    let updatedColumns = applyAt j columns (removeSubArraysMatchingElementsAt i removeSkyscrapersFromColumn)\n    let updatedRows = applyAt i rows (removeSubArraysMatchingElementsAt j removeSkyscrapersFromRow)\n    (updatedRows, updatedColumns)\n\nlet removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns = \n    [|0..numSkyscrapersPerLine - 1|]\n    |> Array.map (fun i -> [|0..numSkyscrapersPerLine - 1|]\n                           |> Array.map (fun j -> (i, j)))\n    |> Array.concat\n    |> Array.fold (removeSkypscraperUnionRowAndColumn) rowsAndColumns\n\nlet isSolved (rows, _) = \n    rows\n    |> Array.map (fun row -> Seq.length row = 1)\n    |> Array.reduce (&&)\n\nlet hasSameNumberOfPossibilities (rows, columns) (updatedRows, updatedColumns) =\n    rows\n    |> Array.map2 (fun arr arr2 -> Array.length arr = Array.length arr2) updatedRows\n    |> Array.reduce (&&)\n    &&\n    columns\n    |> Array.map2 (fun arr arr2 -> Array.length arr = Array.length arr2) updatedColumns\n    |> Array.reduce (&&)\n\nlet rec applyUnionRule numSkyscrapersPerLine rowsAndColumns = \n    match isSolved rowsAndColumns with\n    | true -> rowsAndColumns\n    | false -> \n        let updatedRowsAndColumns = (removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine rowsAndColumns)\n        match hasSameNumberOfPossibilities rowsAndColumns updatedRowsAndColumns with\n        | true -> updatedRowsAndColumns\n        | false -> applyUnionRule numSkyscrapersPerLine updatedRowsAndColumns\n\nlet rec findFieldWithMoreOptions i j rows =\n    let distinctPosibilities = getDistinctPosibilities i j rows\n    let numPosibilities = Array.length distinctPosibilities\n    match numPosibilities with\n    | 1 -> findFieldWithMoreOptions i (j + 1) rows\n    | _ -> ((i, j), distinctPosibilities)\n\nlet setFieldInRow i j value (rows : int[][][])  = \n    applyAt i rows (fun row -> row |> Array.filter (fun option -> option.[j] = value))\n\nlet hasNoSolution (rows : int[][][], _) =\n    rows.[0] |> Array.isEmpty\n\nlet rec guess numSkyscrapersPerLine i j (possibilities : int []) pos (row, column) = \n    let updatedRow = setFieldInRow i j possibilities.[pos] row\n    let updatedRC = removeSkyscrapersUnionAllRowsAndColumns numSkyscrapersPerLine (applyUnionRule numSkyscrapersPerLine (updatedRow, column))\n    match hasNoSolution updatedRC with\n    | true  -> guess numSkyscrapersPerLine i j possibilities (pos + 1) (row, column)\n    | false -> updatedRC\n\nlet rec guessing numSkyscrapersPerLine (row, column) = \n    let ((i, j), possibilities) = findFieldWithMoreOptions 0 0 row\n    let updatedRC = guess numSkyscrapersPerLine i j possibilities 0 (row, column)\n    match isSolved updatedRC with\n    | true  -> updatedRC\n    | false -> guessing numSkyscrapersPerLine updatedRC\n\nlet solve_puzzle (clues : int[]) =\n    let numSkyscrapersPerLine = 7\n    let rowsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n    let columnsAllPosibilities = [|1..numSkyscrapersPerLine|] |> Array.map (fun _ -> permutes numSkyscrapersPerLine)\n\n    let cluesApplied = applyClues numSkyscrapersPerLine clues (rowsAllPosibilities, columnsAllPosibilities)\n\n    let unionApplied = applyUnionRule numSkyscrapersPerLine cluesApplied\n\n    let (finalRows, _) =\n        match isSolved unionApplied with\n        | true -> unionApplied\n        | false -> guessing numSkyscrapersPerLine unionApplied\n    finalRows |> Array.concat","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86944,"user_id":null,"body":"\n\/\/ This solution is quite different and more correct than one that passes 4x4 and 6x6\n\/\/ It can solve puzzle where guessing is inevitable (MedVed test)\n\/\/ and is also relies on Arrays rather than List and Seq to squeeze extra performance and pass the tests suite\n\nlet N = 7\n\nlet rec combinations acc fits range remains = seq {\n    if remains = 0\n    then yield acc\n    else\n        for candidate in range do\n            if fits acc candidate\n            then yield! combinations (candidate :: acc) fits range (remains - 1) }\n\nlet permutations =\n    combinations [] (fun acc x -> acc |> List.forall ((<>) x)) [1 .. N] N\n    |> Seq.map Array.ofList\n    |> Array.ofSeq\n\nlet visibleCount =\n    fst << Seq.fold (fun (count, lastMax) cur -> if cur > lastMax then (count + 1, cur) else (count, lastMax)) (0, 0)\n\nlet optionsByVisibleCount : Map<int, int[][]> =\n    let ps = permutations\n    ps\n    |> Array.groupBy visibleCount\n    |> Seq.append [| (0, ps) |] \/\/ all permutations for zero clue\n    |> Map.ofSeq\n\nlet optionsToMask (options : int[][]) =\n    [| 0 .. N - 1 |]\n    |> Array.map ((fun i -> options |> Seq.map (fun opt -> opt.[i])) >> Set.ofSeq)\n\nlet indexed field = \n    [\n        for y in 0 .. (Array2D.length1 field) - 1 do\n            for x in 0 .. (Array2D.length2 field) - 1 do\n                yield y, x, field.[y, x]\n    ]\n\nlet isSolved = indexed >> List.forall(fun (_, _, vs) -> (Set.count vs) = 1)\n\nlet rec refine recLevel (clues : int[]) lastField =\n\n    \/\/ some local statefulness\n    let currentField = Array2D.copy lastField\n\n    let refineFieldSlice clueIdx (y0, x0) (dy, dx) =\n        let optionFitsFieldSlice =\n            Array.mapi (fun i v -> currentField.[y0 + i * dy, x0 + i * dx] |> Set.contains v)\n            >> Array.forall id          \n        let refinedSlice =\n          optionsByVisibleCount\n          |> Map.find clues.[clueIdx]\n          |> Array.filter optionFitsFieldSlice\n          |> optionsToMask         \n        \/\/ set new mask\n        refinedSlice |>\n        Array.iteri(fun i m -> currentField.[y0 + i * dy, x0 + i * dx] <- m)\n\n    for i in 0 .. N-1 do\n        refineFieldSlice i (0, i) (1, 0)     \n        refineFieldSlice (i + N) (i, N-1) (0, -1)\n        refineFieldSlice (i + 2*N) (N-1, N-1-i) (-1, 0)\n        refineFieldSlice (i + 3*N) (N-1-i, 0) (0, 1)\n    \n    if currentField <> lastField\n    then\n        \/\/ something refined, carry on...\n        refine (recLevel + 1) clues currentField\n    else\n        \/\/ nothing refined, check if already solved\n        if isSolved currentField\n        then\n            \/\/ solved\n            currentField\n        else\n            \/\/ not solved\n            let maybeSolution =\n                \/\/ take first uncertain cell, with minimum count of options (usually 2 by this time)\n                let (y, x, vs) =\n                    currentField |> indexed\n                    |> Seq.filter (fun (_, _, vs) -> (Set.count vs) <> 1)\n                    |> Seq.sortBy (fun (_, _, vs) -> Set.count vs)\n                    |> Seq.head\n\n                \/\/ in this uncertain cell, knock every option one by one...\n                vs\n                |> Seq.map (\n                    fun knock ->\n                        let currentFieldCopy = Array2D.copy currentField\n                        currentFieldCopy.[y, x] <- Set.remove knock vs\n                        refine (recLevel + 1) clues currentFieldCopy)\n                \/\/ ... until puzzle solved or options exhausted\n                |> Seq.filter isSolved |> Seq.tryHead\n\n            match maybeSolution with\n            | Some s -> s\n            \/\/ if all options exhausted - fall back to previous field\n            | None -> currentField\n\nlet solveRaw (clues : int[]) =\n    List.replicate N (Set.ofList [1 .. N] |> List.replicate N) |> array2D\n    |> refine 0 clues\n\nlet solve_puzzle (clues : int[]) : int[][] =   \n    \/\/ start guessing with full uncertainty\n    let initialGuess = List.replicate N (Set.ofList [1 .. N] |> List.replicate N) |> array2D\n    let solution = \n        initialGuess\n        |> refine 0 clues \n        |> Array2D.map Seq.exactlyOne       \n    \/\/ convert to jagged array to satisfy test suite\n    [| for i in 0 .. (Array2D.length1 solution) - 1 do yield solution.[i, *] |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86945,"user_id":null,"body":"\/\/ This solution is quite different and more correct than one that passes 4x4 and 6x6\n\/\/ It can solve puzzle where guessing is inevitable (MedVed test)\n\/\/ and is also relies on Arrays rather than List and Seq to squeeze extra performance and pass the tests suite\n\nlet N = 7\n\nlet rec combinations acc fits range remains = seq {\n    if remains = 0\n    then yield acc\n    else\n        for candidate in range do\n            if fits acc candidate\n            then yield! combinations (candidate :: acc) fits range (remains - 1) }\n\nlet permutations =\n    combinations [] (fun acc x -> acc |> List.forall ((<>) x)) [1 .. N] N\n    |> Seq.map Array.ofList\n    |> Array.ofSeq\n\nlet visibleCount =\n    fst << Seq.fold (fun (count, lastMax) cur -> if cur > lastMax then (count + 1, cur) else (count, lastMax)) (0, 0)\n\nlet optionsByVisibleCount : Map<int, int[][]> =\n    let ps = permutations\n    ps\n    |> Array.groupBy visibleCount\n    |> Seq.append [| (0, ps) |] \/\/ all permutations for zero clue\n    |> Map.ofSeq\n\nlet optionsToMask (options : int[][]) =\n    [| 0 .. N - 1 |]\n    |> Array.map ((fun i -> options |> Seq.map (fun opt -> opt.[i])) >> Set.ofSeq)\n\nlet optionFitsMask mask option =\n    \/\/ much faster than Zip\n    Array.forall2 (fun mv v -> mv |> Set.contains v) mask option\n\nlet indexed field = \n    [\n        for y in 0 .. (Array2D.length1 field) - 1 do\n            for x in 0 .. (Array2D.length2 field) - 1 do\n                yield y, x, field.[y, x]\n    ]\n\nlet isSolved = indexed >> List.forall(fun (_, _, vs) -> (Set.count vs) = 1)\n\nlet rec refine recLevel (clues : int[]) lastField =\n\n    \/\/ some local statefulness\n    let currentField = Array2D.copy lastField\n\n    let applyOptionsMask m x y =\n        let curMask = currentField.[y, x]\n        let newMask = Set.intersect curMask m\n        currentField.[y, x] <- newMask\n\n    let refinedOptionsMask clueIdx fieldSliceMask =\n        optionsByVisibleCount\n        |> Map.find clues.[clueIdx]\n        |> Array.filter (optionFitsMask fieldSliceMask)\n        |> optionsToMask\n\n    for i in 0 .. N-1 do\n        \/\/ top clue\n        refinedOptionsMask i currentField.[*, i]\n        |> Seq.iteri(fun j m -> applyOptionsMask m i j)\n        \n        \/\/ right clue\n        refinedOptionsMask (i+N) (currentField.[i, *] |> Array.rev)\n        |> Seq.iteri(fun j m -> applyOptionsMask m (N-1-j) i)\n\n        \/\/ bottom clue\n        refinedOptionsMask (i + 2*N) (currentField.[*, N-1-i] |> Array.rev)\n        |> Seq.iteri(fun j m -> applyOptionsMask m (N-1-i) (N-1-j))\n\n        \/\/ left clue\n        refinedOptionsMask (i + 3*N) currentField.[N-1-i, *]\n        |> Seq.iteri(fun j m -> applyOptionsMask m j (N-1-i))\n    \n    if currentField <> lastField\n    then\n        \/\/ something refined, carry on...\n        refine (recLevel + 1) clues currentField\n    else\n        \/\/ nothing refined, check if already solved\n        if isSolved currentField\n        then\n            \/\/ solved\n            currentField\n        else\n            \/\/ not solved\n            let maybeSolution =\n                \/\/ take first uncertain cell, with minimum count of options (usually 2 by this time)\n                let (y, x, vs) =\n                    currentField |> indexed\n                    |> Seq.filter (fun (_, _, vs) -> (Set.count vs) <> 1)\n                    |> Seq.sortBy (fun (_, _, vs) -> Set.count vs)\n                    |> Seq.head\n\n                \/\/ in this uncertain cell, knock every option one by one...\n                vs\n                |> Seq.map (\n                    fun knock ->\n                        let currentFieldCopy = Array2D.copy currentField\n                        currentFieldCopy.[y, x] <- Set.remove knock vs\n                        refine (recLevel + 1) clues currentFieldCopy)\n                \/\/ ... until puzzle solved or options exhausted\n                |> Seq.filter isSolved |> Seq.tryHead\n\n            match maybeSolution with\n            | Some s -> s\n            \/\/ if all options exhausted - fall back to previous field\n            | None -> currentField\n\nlet solveRaw (clues : int[]) =\n    List.replicate N (Set.ofList [1 .. N] |> List.replicate N) |> array2D\n    |> refine 0 clues\n\nlet solve_puzzle (clues : int[]) : int[][] =   \n    \/\/ start guessing with full uncertainty\n    let initialGuess = List.replicate N (Set.ofList [1 .. N] |> List.replicate N) |> array2D\n    let solution = \n        initialGuess\n        |> refine 0 clues \n        |> Array2D.map Seq.exactlyOne       \n    \/\/ convert to jagged array to satisfy test suite\n    [| for i in 0 .. (Array2D.length1 solution) - 1 do yield solution.[i, *] |]","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86946,"user_id":null,"body":"open System\nlet solve_puzzle (clues : int[]) : int[][] =\n        let checkVisible n (line: int[]) = \n            if n = 0 then true else\n            let mutable v = 0\n            let mutable count = 0\n            for x in line do\n                if x > v then v <- x; count <- count + 1\n            count = n\n\n        let variance (variances: int[][]) n = \n            let elements = Array.init 7 (fun _ -> ResizeArray())\n\n            let rec getPossible index state = \n                if index = 7 then \n                    if checkVisible n state then\n                        for i = 0 to 6 do elements.[i].Add(state.[i])\n                else\n                for x in variances.[index] do\n                    if Array.contains x state |> not then\n                        let arr = Array.copy state \n                        arr.[index] <- x\n                        getPossible (index + 1) arr\n\n            getPossible 0 (Array.replicate 7 0)\n            elements |> Array.map(set >> Seq.toArray)\n\n        let column i (matrix: _[][]) = \n            [| for n = 0 to 6 do yield matrix.[n].[i] |]\n\n        let setColumn i (matrix: _[][]) (vector: _[]) = \n            vector |> Array.iteri(fun n v -> matrix.[n].[i] <- v)\n\n        let visibleVector i (matrix: _[][]) = \n            match i \/ 7 with\n            | 0 -> column i matrix\n            | 1 -> matrix.[i - 7] |> Array.rev\n            | 2 -> column (20 - i) matrix |> Array.rev\n            | _ -> matrix.[27 - i]\n\n        let setVisibleVector i (matrix: _[][][]) vector = \n            let matrix = Array.map(Array.map(Array.map id)) matrix\n            match i \/ 7 with\n            | 0 -> setColumn i matrix vector\n            | 1 -> matrix.[i - 7] <- vector |> Array.rev\n            | 2 -> vector |> Array.rev |> setColumn (20 - i) matrix \n            | _ -> matrix.[27 - i] <- vector\n            matrix\n\n        let setClue (matrix: _[][]) (i, clue) = \n            let vector = visibleVector i matrix\n            let variance = variance vector clue\n            setVisibleVector i matrix variance\n\n        let isDefined (matrix: int[][][]) = \n            matrix |> Array.forall(Array.forall(fun x -> Array.length x = 1))\n\n        let isPossible (matrix: int[][][]) = \n            matrix |> Array.forall(Array.forall(fun x -> Array.length x <> 0))\n\n        let count (matrix: int[][][]) = \n            [| for x = 0 to 6 do\n                for y = 0 to 6 do\n                    yield (x, y), matrix.[x].[y].Length |]\n\n        let define = Array.map(Array.map(Array.head))\n\n        let solve variances = \n            let mutable state = variances\n            let mutable count = 0\n            while isDefined state |> not && count < 60 do\n                let next = clues |> Array.mapi(fun i x -> i, x) |> Seq.fold setClue state\n                count <- count + 1\n                state <- next\n            state\n\n        let rec solveWith variances = \n            let res = solve variances\n            if isPossible res |> not then None\n            elif isDefined res |> not then \n                let ((x, y), _) = count res |> Seq.filter (fun (_, v) -> v > 1) |> Seq.minBy snd\n                res.[x].[y] |> Array.tryPick(fun v ->\n                    let res = Array.map(Array.map(Array.map id)) res\n                    res.[x].[y] <- [| v |]\n                    solveWith res)\n            else Some res\n\n        let variances = Array.init 7 (fun _ -> Array.init 7 (fun _ -> [|1..7|]))\n\n        let res = solveWith variances \n        define res.Value","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86947,"user_id":null,"body":"[<Literal>]\nlet PUZZLESIZE = 7\n\n\/\/ Used to represent a possible permutation of plot heights for a given row.\ntype perm = {\n    idx     : int   \/\/ index of the permutation to make sequence expressions easier\n    values  : int[] \/\/ a row of skyscraper heights e.g. [| 1; 3; 5; 6; 7; 4; 2 |]\n    packed  : int[] \/\/ the same but in bitmask-friendly form, e.g. [| 2; 8; 32; 64; 128; 16; 4 |]\n}\n\nlet factorial (n : int) : int =\n    let rec fact n t = if n = 1 then t else fact (n-1) (t*n)\n    fact n 1\n\nlet NUMROWPERMUTATIONS = factorial PUZZLESIZE\n\nlet rec distribute e = function\n  | [] -> [[e]]\n  | x::xs' as xs -> (e::xs)::[for xs in distribute e xs' -> x::xs]\n\nlet rec permute = function\n  | [] -> [[]]\n  | e::xs -> List.collect (distribute e) (permute xs)\n\n\/\/ All possible permutations of a row of skyscrapers stored in array allPermutations\nlet allPermutations =\n    permute [1..PUZZLESIZE]\n    |> Seq.mapi (fun i p -> { idx = i; values = p |> Seq.toArray; packed = p |> Seq.map (fun v -> (1 <<< v)) |> Seq.toArray })\n    |> Seq.toArray\n\n\/\/ For a given row of plot heights and left\/right clue values, returns whether the row is permissible for those clues\nlet visible (a : int[]) (clueLeft : int) (clueRight : int) : bool =\n    let rec vis i ml mr cl cr =\n        if i = a.Length then\n            (cl, cr)\n        else\n            vis\n                (i+1)\n                (max ml a.[i])\n                (max mr a.[a.Length - i - 1])\n                (if a.[i] > ml then cl+1 else cl)\n                (if a.[a.Length - i - 1] > mr then cr+1 else cr)\n\n    if clueLeft = 0 && clueRight = 0 then\n        true\n    else\n        let (resultl, resultr) = vis 0 0 0 0 0\n        (clueLeft = 0 || clueLeft = resultl) && (clueRight = 0 || clueRight = resultr)\n\n\/\/ List of all possible permutation indexes\nlet rowAll = [0..(NUMROWPERMUTATIONS-1)]\n\n\/\/ rowFromClues takes a left and right clue, and returns the indexes of all possible row permutations that match\n\/\/ the provided clue values. This list of row permutation indexes is what represents a row.\nlet rowFromClues (leftClue : int) (rightClue : int) : int list =\n    if leftClue = 0 && rightClue = 0 then\n        rowAll\n    else\n        allPermutations\n        |> Seq.filter (fun p -> visible p.values leftClue rightClue)\n        |> Seq.map (fun p -> p.idx)\n        |> Seq.toList\n\nlet intersectAllRows (sol : Map<int, int list>) =\n    let intersectRows (sol : Map<int, int list>) ((x, y) : int * int) : Map<int, int list> =\n        \/\/ ry = the yth horizontal row\n        let ry = sol.[y]\n        \/\/ rx = the xth vertical row\n        let rx = sol.[PUZZLESIZE + x]\n\n        let vmask =\n            \/\/ All possible values of the xth column in the yth row\n            (ry |> Seq.map (fun pidx -> allPermutations.[pidx].packed.[x]) |> Seq.fold (fun acc v -> acc ||| v) 0)\n            &&&\n            \/\/ All possible values of the yth column in the xth row\n            (rx |> Seq.map (fun pidx -> allPermutations.[pidx].packed.[y]) |> Seq.fold (fun acc v -> acc ||| v) 0)\n\n        sol\n        |> Map.add y (ry |> List.filter (fun pidx -> allPermutations.[pidx].packed.[x] &&& vmask <> 0))\n        |> Map.add (PUZZLESIZE + x) (rx |> List.filter (fun pidx -> allPermutations.[pidx].packed.[y] &&& vmask <> 0))\n\n    [0..PUZZLESIZE-1]\n    |> Seq.map (fun x -> [0..PUZZLESIZE-1] |> Seq.map (fun y -> (x, y)))\n    |> Seq.concat\n    |> Seq.fold (fun s c -> intersectRows s c) sol\n\nlet rec findSolution (sol : Map<int, int list>) =\n    let newSol = intersectAllRows sol\n    if Map.exists (fun _ v -> v = []) newSol then\n        \/\/ There is at least one row with no possible solution\n        None\n    else\n        match Map.tryFindKey (fun _ r -> List.length r > 1) newSol with\n        | None ->\n            \/\/ Each row has exactly one possible solution - solved\n            Some newSol    \n        | Some ridx ->\n            \/\/ Find all possible solutions for this undetermined row, and call this function recursively\n            \/\/ with each possibility\n            newSol.[ridx]\n            |> Seq.map (fun p -> newSol.Add (ridx, [p]) |> findSolution)\n            |> Seq.tryPick id\n\nlet solve_puzzle (clues : int[]) : int[][] =\n    let fromClues =\n        [0..PUZZLESIZE-1] |> Seq.map (fun i -> (i, rowFromClues clues.[PUZZLESIZE * 4 - i - 1] clues.[i + PUZZLESIZE]))\n        |> Seq.append ([0..PUZZLESIZE-1] |> Seq.map (fun i -> (i+PUZZLESIZE, rowFromClues clues.[i] clues.[PUZZLESIZE *  3 - i - 1])))\n\n    let sol = new Map<int, int list>(fromClues)\n\n    match findSolution sol with\n    | Some solution -> ({0..(PUZZLESIZE-1)} |> Seq.map (fun i -> allPermutations.[solution.[i] |> List.head].values) |> Seq.toArray)\n    | _ -> failwith \"No solution\"\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}],"5993c1d917bc97d05d000068":[{"id":86948,"user_id":53,"body":"open System\n\nlet regex_divisible_by (n : int) : string =\n    if (n = 1) then\n        \"^[01]*$\"\n    else\n        let graphs = Array2D.create n n \"-1\"\n        for i in 0 .. (n - 1) do\n             graphs.[i, (2 * i) % n] <- \"0\"\n             graphs.[i, (2 * i + 1) % n] <- \"1\"\n        for k in (n - 1) .. -1 .. 0 do\n            let mutable loop = \"\"\n            if (graphs.[k, k] <> \"-1\") then\n                loop <- String.Format(\"{0}*\", graphs.[k, k])\n            else\n                loop <- loop\n            for i in 0 .. (k - 1) do\n                if (graphs.[i, k] = \"-1\") then\n                    loop <- loop\n                else\n                    for j in 0 .. (k - 1) do\n                        if (graphs.[k, j] = \"-1\") then\n                            loop <- loop\n                        else\n                            let mutable s = \"\"\n                            if (graphs.[i, j] <> \"-1\") then\n                                s <- String.Format(\"{0}|\", graphs.[i, j])\n                            else\n                                s <- s\n                            graphs.[i, j] <- String.Format(\"(?:{0}{1}{2}{3})\", s, graphs.[i, k], loop, graphs.[k, j])\n        String.Format(\"^{0}*$\", graphs.[0, 0])","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86949,"user_id":null,"body":"type EdgeKey = { source : int; target : int }\n\ntype Edge = | NoEdge | Regex of string\n\nlet maybeEdgeValue = function | NoEdge -> None | Regex str -> Some str\n\nlet initialEdges n =\n    [0 .. n-1]\n    |> List.collect (\n        fun i -> [\n            ({ source = i; target = i * 2 % n }, Regex \"0\");\n            ({ source = i; target = (i * 2 + 1) % n }, Regex \"1\")])\n    |> Map.ofList\n\nlet mergeEdges sep (edges : Edge list) =\n    let es = edges |> List.choose maybeEdgeValue\n    if List.length es = 1\n    then\n        List.head es |> Regex\n    else\n        es\n        |> List.map(fun e -> if e.Contains(\"|\") then sprintf \"(?:%s)\" e else e)\n        |> String.concat sep\n        |> Regex\n\nlet choiceOfTwoEdges e1 e2 = mergeEdges \"|\" [e1; e2]\n\nlet sequenceOfEdges (edges : Edge list) = mergeEdges \"\" edges\n\nlet edgeValue source target =\n    Map.tryFind { source = source; target = target }\n    >> Option.defaultValue NoEdge\n\nlet removeEdge source target =\n    Map.remove { source = source; target = target }\n\nlet edgeReducer (edges : Map<EdgeKey, Edge>, this) (prev, next) =\n    \n    let prevToNext = edges |> edgeValue prev next\n    let prevToThis = edges |> edgeValue prev this\n    let thisToNext = edges |> edgeValue this next\n\n    let thisLoopEdge =\n        match edges |> edgeValue this this with\n        | Regex s -> \n            Regex <|\n                if s.Length > 1 \n                then sprintf \"(?:%s)*\" s\n                else sprintf \"%s*\" s\n        | NoEdge -> NoEdge\n\n    let prevToNextViaThis = sequenceOfEdges [prevToThis; thisLoopEdge; thisToNext]\n\n    let mergedPrevToNextEdge =\n        choiceOfTwoEdges prevToNext prevToNextViaThis\n\n    let updatedEdges =\n        edges\n        |> removeEdge prev next\n        |> Map.add { source = prev; target = next } mergedPrevToNextEdge\n\n    (updatedEdges, this)\n\nlet nodeReducer edges _ =\n    \/\/ find least connected node and reduce it\n    let this = \n        edges \n        |> Map.toSeq\n        |> Seq.map fst\n        |> Seq.collect (fun { source = src; target = trg } -> [src; trg])\n        |> Seq.filter ((<>) 0)\n        |> Seq.countBy id\n        |> Seq.sortBy snd\n        |> Seq.head\n        |> fst\n\n    let keys = edges |> Map.toList |> List.map fst\n    let prevs = keys |> List.filter (fun { source = src; target = trg } -> trg = this && src <> this) |> List.map (fun { source = src } -> src)\n    let nexts = keys |> List.filter (fun { source = src; target = trg } -> src = this && trg <> this) |> List.map (fun { target = trg } -> trg)\n\n    let updatedEdges =\n        [ for prev in prevs do\n            for next in nexts do\n                yield prev, next ]\n        |> List.fold edgeReducer (edges, this)\n        |> fst\n\n    \/\/ eliminate self-loop and prev and next links to avoid extra calculations\n    let reducedEdges = updatedEdges |> removeEdge this this\n    let reducedEdges = prevs |> List.fold (fun e prev -> e |> removeEdge prev this) reducedEdges\n    let reducedEdges = nexts |> List.fold (fun e next -> e |> removeEdge this next) reducedEdges\n    reducedEdges\n\nlet regex_divisible_by (n : int) : string =\n    if n = 1\n    then\n        \"^(?:0|1)+$\"\n    else\n        let edges = initialEdges n\n        let zeroToZeroEdgeValue = \n            [1 .. n-1]\n            |> List.fold nodeReducer edges\n            |> Map.find { source = 0; target = 0 }\n            |> maybeEdgeValue\n            \/\/ unsafe get\n            |> Option.get\n        sprintf @\"^(?:%s)+$\" zeroToZeroEdgeValue","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86950,"user_id":null,"body":"type state(index :int) =\n  member this.index = index\n  member val pred :int list = List.empty with get, set\n  member val succ :int list = List.empty with get, set\n\nlet add (states :state[]) (arches :string[,]) (a :int) (b :int) (s :string) :unit =\n  if a <> b then (\n    states.[a].succ <- states.[a].succ @ [b]\n    states.[b].pred <- states.[b].pred @ [a]\n  )\n  Array2D.set arches a b s\n\nlet delete (state :state) (pred :bool) (index :int) :unit =\n  let xs = if pred then state.pred else state.succ\n  match List.tryFindIndex ((=) index) xs with\n  | Some i ->\n    let updated = List.take i xs @ List.skip (i+1) xs\n    if pred then state.pred <- updated else state.succ <- updated\n  | None -> ()\n\nlet init (n :int) :(state[] * string[,]) =\n  let n' = n-1\n  let arches = Array2D.create n n \"\"\n  let states = [| for i in 0 .. n' -> new state(i) |]\n  for i = 0 to n' do\n    add states arches i (2 * i % n) \"0\"\n    add states arches i ((2 * i + 1) % n) \"1\"\n  (states, arches)\n\nlet join (sep :string) (expr :string list) :string =\n  if expr.Length = 1\n    then List.exactlyOne expr\n    else expr\n         |> List.toSeq\n         |> Seq.map (fun s -> if Seq.contains '|' s then sprintf \"(?:%s)\" s else s)\n         |> String.concat sep\n\nlet reduce (states :state[]) (arches :string[,]) (st :state) :unit =\n  let add' (a :string) (b :string) :string =\n    (List.filter (fun (s :string) -> 0 < s.Length && s <> \"~\") >> join \"|\") [ a; b ]\n  for k in st.pred do\n    for m in st.succ do\n      let q = states.[k]\n      let p = states.[m]\n      let s' =\n        let s = arches.[st.index,st.index]\n        match s.Length with\n        | 0 -> \"~\"\n        | 1 -> s + \"*\"\n        | _ -> sprintf \"(?:%s)*\" s\n      let ss =\n        let args = [ arches.[k,st.index]; s'; arches.[st.index,m] ]\n        (\n          if List.exists (fun (s :string) -> s.Length = 0) args\n            then \"\"\n            else (List.filter ((<>) \"~\") >> join \"\") args\n        )\n      delete q false p.index\n      delete p true q.index\n      add states arches q.index p.index (add' arches.[k,m] ss)\n      delete q false st.index\n      delete p true st.index\n\nlet regex_divisible_by (n :int) :string =\n  if n = 1 then \"^[01]+$\" else (\n    let (states, arches) = init n\n    for s in states.[1..] do\n      reduce states arches s\n    \"^(?:\" + arches.[0,0] + \")+$\"\n  )","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"},{"id":86951,"user_id":null,"body":"let regex_divisible_by (n : int) : string =\n    let grp (e : string) : string = if e.Length <= 1 then e else sprintf \"(?:%s)\" e\n\n    let merge (arcs : seq<(int * string * int)>) : string =\n        arcs\n        |> Seq.map (fun (_, r, _) -> grp r)\n        |> String.concat \"|\"\n        |> grp\n\n    [n-1 .. -1 .. 1]\n    |> List.fold\n        (fun arcList s ->\n            List.concat [\n                arcList |> List.filter (fun (s1, _, s2) -> s1 <> s && s2 <> s)\n\n                (match arcList |> List.filter (fun (s1, _, s2) -> s1 = s && s2 = s) with\n                | [] -> \"\"\n                | l -> merge l)\n                |> (fun rB ->\n                    arcList\n                        |> List.filter (fun (s1, _, s2) -> s1 <> s && s2 = s)\n                        |> Seq.groupBy (fun (s1, _, _) -> s1)\n                        |> Seq.map (fun (s1, a) -> (s1, merge a))\n                        |> Seq.collect (fun (sA, rA) ->\n                            arcList\n                            |> List.filter (fun (s1, _, s2) -> s1 = s && s2 <> s)\n                            |> Seq.groupBy (fun (_, _, s2) -> s2)\n                            |> Seq.map (fun (s2, a) -> (s2, merge a))\n                            |> Seq.map (fun (sC, rC) ->\n                                (\n                                    sA,\n                                    (if rB <> \"\" then sprintf \"%s%s*%s\" rA rB rC else sprintf \"%s%s\" rA rC),\n                                    sC\n                                )\n                            )\n                        )\n                        |> Seq.toList\n                )\n            ]\n        )\n        ([0 .. n-1]\n        |> List.collect (fun i ->\n            [\n                (i, \"0\", (i*2) % n)\n                (i, \"1\", (i*2 + 1) % n)\n            ])\n        )\n    |> merge\n    |> sprintf \"^%s*$\"\n\n","lang_id":20,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:16","updated_at":"2022-12-30 18:39:16"}]}