{"50654ddff44f800200000004":[{"id":211760,"user_id":1343,"body":"global multiply\nsection .text\nmultiply:\n  mov eax, edi\n  mul esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211761,"user_id":null,"body":"global multiply\nsection .text\nmultiply:\n  ; rax <- return value\n  ; rdi <- first parameter\n  ; rsi <- second parameter\n  \n  ; works\n  ; mov   eax, 15\n  ; works too\n  ; mov   rax, 15\n  \n  mov rax, rdi\n  mul rsi\n   \n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211762,"user_id":null,"body":"global multiply\nsection .text\nmultiply:\n  mov eax, esi\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211763,"user_id":null,"body":"global multiply\nsection .text\nmultiply:\n  imul edi, esi\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211764,"user_id":527,"body":"global multiply\nsection .text\nmultiply:\n                mov     eax, edi\n                imul    esi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211765,"user_id":null,"body":"global     multiply\nsection   .text\n\nmultiply:\n  xor      eax, eax\n  mov      eax, edi\n  mul      esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211766,"user_id":null,"body":"global multiply\nsection .text\n\nmultiply:\n  xor eax, eax\n  xor edx, edx\n  mov ecx, edi\n  test ecx, ecx\n  jns .while\n\n  neg ecx\n  not edx\n\n.while:\n  add eax, esi\n  dec ecx\n  jnz .while\n\n  test edx, edx\n  jns .return\n  neg eax\n\n.return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211767,"user_id":null,"body":"global multiply\nsection .text\nmultiply:\n  movsx rax, edi\n  mul esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211768,"user_id":null,"body":"global multiply\nsection .text\nmultiply:\n  ; mov eax, edi * esi\n  xor eax, eax\n  inc eax\n  mul edi \n  mul esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211769,"user_id":null,"body":"global multiply\nsection .text\nmultiply:\n  mov eax, edi\n\nloop:\n  add edi, eax\n  dec esi\n  cmp esi, 1\n  je end\n  jne loop\n  \nend:\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"513e08acc600c94f01000001":[{"id":211770,"user_id":null,"body":"global rgb\n\nsection .text\n %macro char_to_hex 2\n  xor eax, eax\n  cmp %1, 9\n  setg al\n  neg eax\n  and eax, 7\n  lea eax, [%2+48+rax]\n %endmacro\n \n %macro reg_to_hex  1\n    mov ebx, %1\n    shr ebx, 4\n    char_to_hex ebx, rbx\n    mov [rcx], al\n    mov ebx, %1\n    and ebx, 0xF\n    char_to_hex ebx, rbx\n    mov [rcx+1], al\n    add rcx, 2\n  %endmacro\n  \n  %macro clamp 3\n   cmp %1, %2\n   cmovg %1, %2\n   test %1, %1\n   cmovl %1, %3\n  %endmacro\n   \n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n    push rcx\n    \n    mov ebx, 0xFF ; max\n    xor eax, eax  ; min\n    clamp edi, ebx, eax\n    clamp esi, ebx, eax\n    clamp edx, ebx, eax\n    \n    reg_to_hex edi\n    reg_to_hex esi\n    reg_to_hex edx\n    mov [rcx], byte 0\n    \n    pop rax\n    ret\n; ---------> end of rgb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211771,"user_id":743,"body":"global rgb\n\nsection .data\n\nalign 32\nV255  dd             255,            255,            255,              0\nV15   dw      15,     15,     15,     15,     15,     15,      0,      0\nVsh   db   2,  0,  6,  4, 10,  8,255,255,255,255,255,255,255,255,255,255\nV9    db   9,  9,  9,  9,  9,  9,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\nV7    db   7,  7,  7,  7,  7,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\nV48   db  48, 48, 48, 48, 48, 48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n\nsection .bss\n\nalign 32\nVrgb reso 1\n\nsection .text\n\n; rax           edi    esi    edx      rcx\n; char* rgb(int r, int g, int b, char *outp)\nrgb:\n  mov dword [Vrgb + 0], edi\n  mov dword [Vrgb + 4], esi\n  mov dword [Vrgb + 8], edx\n  vpxor xmm0, xmm0\n  vpmaxsd xmm0, oword [Vrgb]\n  vpminsd xmm0, oword [V255]\n  vpslld xmm1, xmm0, 12\n  vpor xmm0, xmm1\n  vpand xmm0, oword [V15]\n  vpshufb xmm0, oword [Vsh]\n  vpcmpgtb xmm1, xmm0, oword [V9]\n  vpand xmm1, oword [V7]\n  vpaddw xmm0, xmm1\n  vpaddw xmm0, oword [V48]\n  vmovdqa oword [Vrgb], xmm0\n  mov rax, rcx\n  mov rsi, Vrgb\n  mov rdi, rcx\n  mov ecx, 7\n  rep movsb\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211772,"user_id":null,"body":"global rgb\nsection .data\n    charArr db '0123456789ABCDEF'\nsection .bss\n    intArr resd 3\nsection .text                   ; not the fastest code, but orderly and not slow\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n    push rbx\n    mov rbx, charArr            ; used for table lookup (xlat) instruction\n    xor r8d, r8d\n    mov r9d, 0xFF               ; min and max values for the cmov instructions in loop\n    mov [intArr], edi\n    mov [intArr+4], esi\n    mov [intArr+8], edx         ; load rgb values into array as we will use a loop\n    mov rdx, rcx                ; rdx points to string\n    mov rcx, 3                  ; counter for loop\n.threeLoop:\n    mov esi, [intArr+4*rcx-4]\n    test esi, esi\n    cmovs esi, r8d              ; if negative set to zero\n    test esi, 0xFFFFFF00\n    cmovnz esi, r9d             ; if > 255 set to 255\n    mov al, sil\n    and al, 0xF                 ; lower order hex char (nibble)\n    xlat                        ; I went a little out of my way to use this instruction ...\n    mov [rdx+2*rcx-1], al\n    mov al, sil\n    shr al, 4                   ; higher order hex char (nibble)\n    xlat                        ; ... as I wanted to use it, it is my first time using it\n    mov [rdx+2*rcx-2], al\n    loop .threeLoop\n    mov rax, rdx                ; rax points to string\n    mov byte [rax+6], 0         ; null terminate string\n    pop rbx\n    ret\n; ---------> end of rgb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211773,"user_id":null,"body":"global rgb\n\nextern sprintf\n\nsection .text\n\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n        push    rbx\n        mov     r9d, edi\n        cmp     edi, 256\n        mov     r8d, 255\n        cmovge  r9d, r8d\n        xor     edi, edi\n        test    r9d, r9d\n        cmovs   r9d, edi\n        mov     eax, esi\n        cmp     esi, 256\n        cmovge  eax, r8d\n        test    eax, eax\n        cmovs   eax, edi\n        cmp     edx, 256\n        cmovl   r8d, edx\n        mov     rbx, rcx\n        test    r8d, r8d\n        cmovs   r8d, edi\n        mov     esi, format_str\n        mov     rdi, rcx\n        mov     edx, r9d\n        mov     ecx, eax\n        xor     eax, eax\n        call    sprintf\n        mov     rax, rbx\n        pop     rbx\n        ret\n\nformat_str:\n        db  '%02X%02X%02X',0\n\n;---------> end of rgb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211774,"user_id":null,"body":"global rgb\nextern sprintf\nsection .text\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n  push rbx\n  mov rbx, rcx\n  mov ecx, esi\n  xor esi, esi\n  mov eax, edi\n  test edi, edi\n  mov r8d, 255\n  cmovs eax, esi\n  test ecx, ecx\n  mov rdi, rbx\n  cmovs ecx, esi\n  test edx, edx\n  cmovs edx, esi\n  cmp eax, r8d\n  mov esi, .fmt\n  cmovae eax, r8d\n  cmp ecx, r8d\n  cmovae ecx, r8d\n  cmp edx, r8d\n  cmovb r8d, edx\n  mov edx, eax\n  xor eax, eax\n  call sprintf\n  mov rax, rbx\n  pop rbx\n  ret\n.fmt: db \"%02X%02X%02X\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211775,"user_id":null,"body":"global rgb\n\nsection .text\nextern sprintf\nextern printf\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n\n    ; rax <- outp\n    ; I probably do some unnecessary mov here. can't be bothered fixing right now. It's 2:30am, haha\n    push rcx\n    mov r8, 255\n    mov r9, 0\n    cmp edi, 255\n    cmovge rdi, r8\n    cmp esi, 255\n    cmovge rsi, r8\n    cmp edx, 255\n    cmovge rdx, r8\n    cmp edi, 0\n    cmovle rdi, r9\n    cmp esi, 0\n    cmovle rsi, r9\n    cmp edx, 0\n    cmovle rdx, r9\n    mov r9, rdi\n    mov rdi, rcx\n    mov rcx, rsi\n    mov rsi, printer\n    mov r8, rdx\n    mov rdx, r9\n    call sprintf\n    pop rax\n    ret\n; ---------> end of rgb <---------\n\nsection .data\nprinter db \"%02hhX%02hhX%02hhX\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211776,"user_id":null,"body":"global rgb\n%macro to_string 1\n   xor r9, r9\n   cmp %1, 0\n   cmovg r9d, %1\n   mov rax, 255\n   cmp r9, rax\n   cmova r9, rax\n   mov r8, r9\n   shr r8, 4\n   mov al, [table + r8]\n   mov [rcx], al\n   inc rcx\n   and r9, 0xf\n   mov al, [table + r9]\n   mov [rcx], al\n   inc rcx\n%endmacro\nsection .data\ntable db '0123456789ABCDEF'\nsection .text\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n    push rcx\n    to_string edi\n    to_string esi\n    to_string edx\n    mov [rcx], byte 0\n    pop rax\n    ; rax <- outp\n    ret\n; ---------> end of rgb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211777,"user_id":null,"body":"global rgb\n\nsection .text\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:\n  push rcx\n  \n  xor eax, eax\n  mov ecx, 0xFF\n  \n  cmp edi, eax\n  cmovl edi, eax\n  cmp edi, ecx\n  cmovg edi, ecx \n  \n  cmp esi, eax\n  cmovl esi, eax\n  cmp esi, ecx\n  cmovg esi, ecx \n\n  cmp edx, eax\n  cmovl edx, eax\n  cmp edx, ecx\n  cmovg edx, ecx \n\n  mov rcx, [rsp]\n  lea r8, [map]\n  \n  mov eax, edi\n  shr eax, 4\n  mov al, [r8+rax]\n  mov [rcx], al\n  inc rcx\n  and edi, 15\n  mov al, [r8+rdi]\n  mov [rcx], al\n  inc rcx\n\n  mov eax, esi\n  shr eax, 4\n  mov al, [r8+rax]\n  mov [rcx], al\n  inc rcx\n  and esi, 15\n  mov al, [r8+rsi]\n  mov [rcx], al\n  inc rcx\n\n  mov eax, edx\n  shr eax, 4\n  mov al, [r8+rax]\n  mov [rcx], al\n  inc rcx\n  and edx, 15\n  mov al, [r8+rdx]\n  mov [rcx], al\n  inc rcx\n  \n  mov byte [rcx], 0\n  pop rax\n  ret\n; ---------> end of rgb <---------\n\nsection .rodata\nmap: db \"0123456789ABCDEF\"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211778,"user_id":null,"body":"%macro printd 2\npush rax\npush rdx\n\nmov r8, rax\nmov rax, 0\nmov eax, %1\nmov rdx, 0\n\ncmp eax, 0\njge %%c\nmov rax, 0\n%%c:\ncmp eax, 255\njbe %%divide\nmov rax, 255\n%%divide:\nmov r8, 16\ndiv r8\n\nadd al, '0'\nadd dl, '0'\n\n; hex adjustment\ncmp al, '9'\njle %%dig1end\nadd al, 7\n%%dig1end:\ncmp dl, '9'\njle %%dig2end\nadd dl, 7\n%%dig2end:\n\nmov [%2], byte al ; eax (quotient)\nmov [%2 + 1], byte dl; edx (remainder)\n\npop rdx\npop rax\n%endmacro\n\nglobal rgb\nsection .text\nrgb:\n  push rcx\n  printd edi, rcx\n  printd esi, rcx + 2\n  printd edx, rcx + 4\n  mov [rcx + 6], byte 0\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211779,"user_id":173,"body":"global rgb\n\nsection .text\n; <----- int rgb(int r, int g, int b, char *outp) ----->\nrgb:    \n    mov r13, rcx\n\n    mov rax, rdi\n    call print_byte_as_2_hex_digits\n    mov rax, rsi\n    call print_byte_as_2_hex_digits\n    mov rax, rdx\n    call print_byte_as_2_hex_digits\n    \n    mov byte [rcx], 0\n    \n    mov rax, r13\n    ret\n; ---------> end of rgb <---------\n\n\nprint_byte_as_2_hex_digits:\n  push r8\n  cmp eax, 0xFF\n  jg l_ff\n  cmp eax, -1\n  jle l_00\nl_normalized:\n  mov r8b, al\n  shr r8b, 4\n  cmp r8b, 10\n  jbe l_09\n  add r8b, 0x7\nl_09:\n  add r8b, 0x30\n  mov byte [rcx], r8b\n  inc rcx\n  \n  mov r8b, al\n  and r8b, 0x0F\n  cmp r8b, 10\n  jbe l_099\n  add r8b, 0x7\nl_099:\n  add r8b, 0x30\n  mov byte [rcx], r8b\n  inc rcx\n  pop r8\n  ret\n\nl_ff:\n  mov eax, 0xFF\n  jmp l_normalized\n  \nl_00:\n  mov eax, 0\n  jmp l_normalized","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"514b92a657cdc65150000006":[{"id":211780,"user_id":null,"body":"global mul3or5\nsection .text\nmul3or5:  xor r8, r8\n          mov rbx, 3\n          mov r9, 5\n          mov rcx, 0\n.loop:    inc rcx\n          cmp ecx, edi\n          jnl .return\n          xor rdx, rdx\n          mov rax, rcx\n          div bx\n          cmp rdx, 0\n          jne .or5\n          add r8, rcx\n          jmp .loop\n.or5:     xor rdx, rdx\n          mov rax, rcx\n          div r9w\n          cmp rdx, 0\n          jne .loop\n          add r8, rcx\n          jmp .loop\n.return:  mov rax, r8\n          ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211781,"user_id":null,"body":"global mul3or5\n\nsection .text\n\n; <----- mul3or5(target-rdi: Int): eax: UInt  ----->\nmul3or5:\n    xor eax, eax  \n    xor r8, r8\n    \n    mov ecx, 3             ;; when target-rdi < 3 return 0  \n    cmp edi, ecx\n    jle .return\n    \n    dec rdi\n    \n    \n    .findMaxDivisor3: \n        xor rdx, rdx           ;; maxDivisor3-rcx = target-rdi \/ 3\n        mov rax, rdi\n        mov r9, 3\n        div r9\n        mov rcx, rax\n    \n    .twoTimesPaDivisors3:\n        xor rdx, rdx            ;; r8 += 2 * pa(maxDivisor3) * 3\n        mov rax, rcx\n        inc rax\n        mul rcx\n        xor rdx, rdx\n        mov rcx, 3\n        mul rcx\n        add r8, rax   \n    \n    .findMaxDivisor5: \n        xor rdx, rdx           ;; maxDivisor5-rcx = target-rdi \/ 5\n        mov rax, rdi\n        mov r9, 5\n        div r9\n        mov rcx, rax\n    \n    .twoTimesPaDivisors5:\n        xor rdx, rdx            ;; r8 += 2 * pa(maxDivisor5) * 5\n        mov rax, rcx\n        inc rax\n        mul rcx\n        xor rdx, rdx\n        mov rcx, 5\n        mul rcx\n        add r8, rax            \n        \n        \n    .findMaxDivisor15:\n        xor rdx, rdx           ;; maxDivisor-rcx = target-rdi \/ 15\n        mov rax, rdi\n        mov r9, 15\n        div r9\n        mov rcx, rax\n    \n    .twoTimesPaDivisors15:\n        xor rdx, rdx            ;; r8 -= 2 * pa(maxDivisor15) * 15\n        mov rax, rcx\n        inc rax\n        mul rcx\n        xor rdx, rdx\n        mov rcx, 15\n        mul rcx\n        sub r8, rax         \n      \n    .return:\n        xor rdx, rdx\n        mov rax, r8\n        mov rcx, 2\n        div rcx\n        ret\n; ---------> end of mul3or5 <---------\n\n\n;; pa = ((1 + size) * size) \/ 2","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211782,"user_id":168,"body":"global mul3or5\n\nsection .text\n\n; <----- unsigned mul3or5(int num) ----->\nmul3or5:\n  sub edi, 1\n  jle .zero\n  mov esi, 5\n  call sum\n  mov ecx, eax\n  mov esi, 15\n  call sum\n  sub ecx, eax\n  mov esi, 3\n  call sum\n  add eax, ecx\n  shr eax, 1\n  ret\n.zero:\n  xor eax, eax\n  ret\n  \nsum:\n  xor edx, edx\n  mov eax, edi\n  div esi\n  sub edx, edi\n  neg edx\n  inc eax\n  mul edx\n  ret\n; ---------> end of mul3or5 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211783,"user_id":null,"body":"; compiler explorer gcc -Os\nglobal mul3or5\n\nsection .text\n\nmul3or5:\n        xor     ecx, ecx\n        xor     esi, esi\n        mov     r8d, 3\n        mov     r9d, 5\n.L2:\n        cmp     ecx, edi\n        jge     .L10\n        mov     eax, ecx\n        cdq\n        idiv    r8d\n        test    edx, edx\n        je      .L3\n        mov     eax, ecx\n        cdq\n        idiv    r9d\n        test    edx, edx\n        jne     .L4\n.L3:\n        add     esi, ecx\n.L4:\n        inc     ecx\n        jmp     .L2\n.L10:\n        mov     eax, esi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211784,"user_id":null,"body":"global mul3or5\n\nsection .text\n\n; <----- unsigned mul3or5(int num) ----->\nmul3or5:\n  xor eax, eax\n  test edi, edi\n  jle .done\n  lea eax, [rdi-1]\n  mov edx, 2290649225\n  mov esi, 2863311531\n  mov ecx, 3435973837\n  imul rsi, rax\n  imul rcx, rax\n  imul rax, rdx\n  shr rsi, 33\n  shr rcx, 34\n  shr rax, 35\n  mov rdx, rax\n  lea eax, [rsi+1]\n  imul eax, esi\n  lea esi, [rcx+1]\n  imul ecx, esi\n  lea eax, [rax+rax*2]\n  lea ecx, [rcx+rcx*4]\n  add eax, ecx\n  lea ecx, [rdx+1]\n  imul edx, ecx\n  mov ecx, edx\n  sal ecx, 4\n  sub ecx, edx\n  sub eax, ecx\n  shr eax, 1\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211785,"user_id":null,"body":"global mul3or5\n\nsection .text\n\n; <----- unsigned mul3or5(int num) ----->\nmul3or5:\n    xor eax, eax;        ; EAX <= the result\n    xor ecx, ecx\n    mov r8, 3\n    mov r9, 5\n    mov esi, 2\n    xor r10, r10\n    LOOP:\n      add ecx, r10d\n      add esi, 1\n      cmp edi, esi\n      jle DONE\n      xor r10, r10\n      ; % 3\n      mov eax, esi\n      cdq ; stores dx:ax for division\n      div r8\n      cmp edx, 0\n      cmovz r10d, esi\n      jz LOOP\n      ; % 3 end    \n      mov eax, esi\n      cdq ; stores dx:ax for division\n      div r9\n      cmp edx, 0\n      cmovz r10d, esi\n      jmp LOOP\n    DONE:\n    mov eax, ecx\n    ret\n; ---------> end of mul3or5 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211786,"user_id":null,"body":"global mul3or5\nsection .data\n; table1[i] is equal to mul3or5(i)\ntable1  dd 0, 0, 0, 3, 3, 8, 14, 14, 14, 23, 33, 33, 45, 45, 45\n; the ith number in table2 is equl to the number of which is the multiples of 3 or 5 below i + 1\ntable2  dd 0, 0, 0, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6, 6, 6\nsection .text\n\n; <----- unsigned mul3or5(int num) ----->\n; int quot = num \/ 15, rem = num % 15;\n; if \n; mul3or5(num) = quot * 60 + quot * (quot - 1) \/ 2 * 15 * 7 + 15 * quot * table2[rem] + table1[rem]\n;              = 15 * quot * (quot * 7 + 1) \/ 2 + 15 * quot * table2[rem] + table1[rem]\nmul3or5:\n        xor     eax, eax\n        test    edi, edi\n        jle     .finish\n        lea     edx, [edi - 1]\n        mov     edi, edx\n        ; num \/ 15 -> edx\n        mov     eax, 2290649225\n        imul    rdx, rax\n        shr     rdx, 35\n        ; floor(num \/ 15) * 15 -> ecx, num % 15 -> edi\n        mov     ecx, edx\n        sal     ecx, 4\n        sub     ecx, edx\n        sub     edi, ecx\n\n        ; ecx * (edx * 7 + 1) \/ 2 -> eax\n        lea     eax, [edx * 8]\n        sub     eax, edx\n        inc     eax\n        imul    eax, ecx\n        shr     eax, 1 \n        \n        ; eax + ecx * table2[edi]  -> eax\n        imul    ecx, [table2 + edi * 4]\n        add     eax, ecx\n\n        ; eax + table[edi] -> eax\n        add     eax, [table1 + edi * 4]\n\n    .finish:\n        ret\n; ---------> end of mul3or5 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211787,"user_id":881,"body":"global mul3or5\n\nsection .text\n\n; <----- unsigned mul3or5(int num) ----->\nmul3or5:\n    xor esi, esi ; total = 0\n.loop:\n    dec edi\n    jle .done\n    xor ecx, ecx\n    \n    ; mod 3\n    xor edx, edx\n    mov eax, edi\n    mov r8w, 3\n    div r8w\n    cmp edx, 0\n    cmove ecx, edi\n    \n    ; mod 5    \n    xor edx, edx\n    mov eax, edi\n    mov r8w, 5\n    div r8w\n    cmp edx, 0\n    cmove ecx, edi\n    \n    add esi, ecx\n    jmp .loop\n.done: \n    mov eax, esi\n    ret\n; ---------> end of mul3or5 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211788,"user_id":null,"body":"global mul3or5\n\nsection .text\n\n; <----- unsigned mul3or5(int num) ----->\nmul3or5:\n    dec edi\n    jle .bailout\n    \n    mov eax, edi\n    xor edx, edx\n    mov ecx, 3\n    div ecx\n    lea esi, [rax+1]\n    imul esi, eax\n    lea esi, [esi*3]\n        \n    mov eax, edi\n    xor edx, edx\n    mov ecx, 5\n    div ecx\n    lea edx, [rax+1]\n    imul edx, eax\n    lea edx, [edx*5]\n    add esi, edx\n    \n    mov eax, edi\n    xor edx, edx\n    mov ecx, 15\n    div ecx\n    lea edx, [rax+1]\n    imul edx, eax\n    imul edx, ecx\n    mov eax, esi\n    sub eax, edx\n    \n    shr eax, 1\n    ret\n\n.bailout:\n    xor eax, eax\n    ret\n; ---------> end of mul3or5 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211789,"user_id":null,"body":"global mul3or5\n\nsection .text\n; edi => input;\n; eax => dividee;\n; ecx => divisor\n; edx => modulo\n; r8d => accumulator\n; r9d => inc;\n; <----- unsigned mul3or5(int num) ----->\nmul3or5:\n    mov r9d, 3  ; Incrementer init\n    mov r8d, 0  ; Accumulator init\n    cmp edi, 3  ; If input < 3, exit the function\n    jle finished\nadd:\n    add r8d, r9d ; Add incrementer to accumulator\nloop:\n    add r9d, 1   ; Increment i\n    cmp edi, r9d ; Check if done\n    je finished\n    xor edx, edx ; Zero the modulo\n    mov ecx, 3   ; Divide by 3\n    mov eax, r9d ; Incrementer to dividee\n    div ecx\n    cmp edx, 0   ; If module is 0, add it\n    je add\n    xor edx, edx\n    mov ecx, 5   ; Divide by 5\n    mov eax, r9d\n    div ecx\n    cmp edx, 0   ; If modulo is 0, add it\n    je add\n    jmp loop     ; Was not modulo 3 or 5, loop\nfinished:\n    mov eax, r8d ; eax is output reg\n    ret\n; ---------> end of mul3or5 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"515e271a311df0350d00000f":[{"id":211790,"user_id":null,"body":"SECTION .text\nglobal square_sum\nsquare_sum:\n  xor rax, rax\n  mov rcx, rsi\n  test rsi,rsi\n  jz _end\n_loop:\n  mov  edx,[rdi + rcx * 4 - 4]\n  imul edx,[rdi + rcx * 4 - 4]\n  add  rax,rdx\n  loop _loop\n_end:  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211791,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\nsquare_sum:\n  xor eax, eax\n.loop:\n  test rsi, rsi\n  jz .exit\n  mov edx, [rdi]\n  imul edx, edx\n  add eax, edx\n  add rdi, 4\n  dec rsi\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211792,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = (int32_t*) array           rdi\n; arg1         = (size_t)   length of array rsi\n; return value = (int32_t)  squared sum\nsquare_sum:\n  xor rax, rax\n  xor r8, r8\n  mov rcx, 0 \nl:\n  cmp rcx, rsi\n  je return\n  mov eax, [rdi]\n  mul eax\n  add r8d, eax\n  add rcx, 1\n  add rdi, 4\n  jmp l\nreturn:\n  mov rax, r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211793,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = (int32_t*) array\n; arg1         = (size_t)   length of array\n; return value = (int32_t)  squared sum\nsquare_sum:\n  mov eax, 0\nloop:\n  cmp rsi, 0\n  je done\n  dec rsi\n  mov rbx, [rdi+4*rsi]\n  imul rbx, rbx\n  add eax, ebx\n  jmp loop\ndone:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211794,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = (int32_t*) array\n; arg1         = (size_t)   length of array\n; return value = (int32_t)  squared sum\nsquare_sum:\n ; rdi  array\n;  rsi length\n  xor rax, rax\n  mov rbx, 0x0\n  mov rcx, rsi\n  cmp rcx, 0\n  je .end\n  mov rdx, 0x0\n.loop:\n  mov rax, [rdi+4*rdx]\n  push rdx\n  mul rax\n  pop rdx\n  add rbx, rax\n  inc rdx\n  cmp rdx, rcx\n  jl .loop\n  mov rax, rbx\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211795,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = (int32_t*) array\n; arg1         = (size_t)   length of array\n; return value = (int32_t)  squared sum\nsquare_sum:\n ; rdi  array\n;  rsi length\n  xor rax, rax\n  mov rbx, 0x0\n  mov rcx, rsi\n  cmp rcx, 0\n  je .end\n  mov rax, rcx\n  mov rdx, 4\n  mul rdx\n  mov rcx, rax\n  mov rdx, 0x0\n  xor rax, rax\n.loop:\n  mov rax, [rdi+rdx]\n  push rdx\n  mul rax\n  pop rdx\n  add rbx, rax\n  add rdx, 4\n  cmp rdx, rcx\n  jl .loop\n  mov rax, rbx\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211796,"user_id":null,"body":"SECTION .text\n  global square_sum\nsquare_sum:\n  mov rax,0\n  \n  loop1:\n  dec rsi\n  js end\n  \n  mov edx,[rdi+rsi*4]\n  imul edx,edx\n  add eax,edx\n  \n  jmp loop1\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211797,"user_id":881,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = (int32_t*) array\n; arg1         = (size_t)   length of array\n; return value = (int32_t)  squared sum\nsquare_sum:\n    xor rcx, rcx\n    xor rdx, rdx\n    xchg rdi, rsi\n.for_each:\n    dec rdi\n    jl .end\n    lodsd\n    mul eax\n    add ecx, eax\n    jmp .for_each\n.end:\n    mov eax, ecx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211798,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = (int32_t*) array\n; arg1         = (size_t)   length of array\n; return value = (int32_t)  squared sum\nsquare_sum:\n  xor ecx, ecx\n  xor eax, eax\n.loop:\n  cmp rsi, rcx\n  je .done\n  mov edx, [rdi + 4*rcx]\n  imul edx, edx\n  add eax, edx\n  inc rcx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211799,"user_id":null,"body":"SECTION .text\nglobal square_sum\n\n; Squares every number in an array and sums it against an accumulator\n; arg0         = RDI (int32_t*) array\n; arg1         = RSI (size_t)   length of array\n; return value = EAX (int32_t)  squared sum\nsquare_sum:\n  xor  eax, eax\n  test rsi, rsi\n  jz   .exit\n  mov  rcx, rsi\n.loop:\n  mov  esi, [rdi + rcx * 4 - 4]\n  imul esi, esi\n  add  eax, esi\n  loop .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5168bb5dfe9a00b126000018":[{"id":211800,"user_id":null,"body":"global reverse\nextern malloc, strlen\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n    call strlen\n    push rdi\n    push rax\n    lea rdi, [rax+1]\n    call malloc\n    mov rsi, rax\n    pop rcx\n    pop rdi\n    test rcx, rcx\n    jz .end\n.copy_loop:\n    mov dl, [rdi+rcx-1]\n    mov [rsi], dl\n    inc rsi\n    loop .copy_loop\n.end:\n    mov byte [rsi], 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211801,"user_id":null,"body":"SECTION .text\nglobal reverse\nextern malloc\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n  xor rax, rax\n  xor rcx, rcx\n@l1:\n  cmp byte[rdi+rcx], 0\n  jz @cnt\n  inc rcx\n  jmp @l1\n@cnt:\n  push rdi\n  mov rdi, rcx \n  inc rdi\n  push rcx\n  call malloc\n  pop rcx\n  pop rdi\n  test rcx, rcx\n  jz @end\n  mov byte[rax+rcx], 0\n  dec rcx\n@l2:\n  mov bl, byte[rdi]\n  mov byte[rax+rcx], bl\n  test rcx, rcx\n  jz @end\n  dec rcx\n  inc rdi\n  jmp @l2\n@end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211802,"user_id":1277,"body":"SECTION .text\nglobal reverse\nextern strlen\nextern malloc\n\nreverse:\n  add rsp, -0x18\n  mov [rsp], r12\n  mov [rsp + 0x8], r13\n  mov r12, rdi\n  call strlen\n  mov r13, rax\n  mov rdi, rax\n  inc rdi\n  call malloc\n  mov [rax + r13], BYTE 0\n  test r13, r13\n  jz .ret\n  mov rcx, -1\n.loop:\n  inc rcx\n  dec r13\n  mov dl, [r12 + rcx]\n  mov [rax + r13], dl\n  jnz .loop\n.ret:\n  mov r12, [rsp]\n  mov r13, [rsp + 0x8]\n  add rsp, 0x18\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211803,"user_id":null,"body":"SECTION .text\nglobal reverse\nextern malloc\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\n; Support 8-bit character set only.\nreverse:\n  enter 16,0          ; 16 bytes local memmory\n  mov [rbp-8], rdi    ; save pointer to argument string\n  test rdi, rdi\n  jz .error           ; argument error: null string\n  ; determine length of the string\n  xor ecx, ecx\n  dec rcx             ; rcx := -1\n  xor al, al\n  cld\n  repne scasb         ; scan for \\0 at string end\n  neg rcx\n  dec rcx             ; now rcx = string length including \\0\n  mov [rbp-16], rcx   ; save buffer length\n  ; allocate buffer\n  mov rdi, rcx\n  call malloc\n  test rax, rax\n  jz .error           ; allocation error\n  ; copy string\n  mov rdi, rax        ; rdi := first char of dest string\n  mov rcx, [rbp-16]\n  dec rcx             ; rcx = number of chars to copy\n  mov rsi, [rbp-8]    ; rsi = first char in source string\n  xor al, al          ; the \\0 at the string end\n  jmp .write\n.copy:\n  mov al,[rsi]        ; copy one char\/one byte\n  inc rsi\n.write:\n  mov [rdi+rcx], al\n  dec rcx\n  jge .copy           ; copy next char\n  jmp .exit           ; ok.  \n.error:  \n  xor edi, edi        ; return null pointer as error value\n.exit:\n  mov rax, rdi        ; return pointer to new string\n  leave\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211804,"user_id":null,"body":"SECTION .text\nglobal reverse\n\nextern malloc\nextern strlen\n\nreverse:\n  push rdi ;save input string\n  call strlen ;save size to rax\n  \n  mov rdi, rax ;set rdi for malloc\n  mov rsi, rax ;save size\n  push rsi\n  inc rdi ;add 1 for null terminator\n  call malloc ;return new string ptr to rax\n  \n  pop rsi ;recover string size\n  pop rdi ;recover input string ptr\n  mov BYTE [rax + rsi], 0 ;set null byte\n  \n.loop:\n  test rsi, rsi\n  jz .end\n  dec rsi\n  mov BYTE cl, [rdi]\n  mov BYTE [rax + rsi], cl ;copy char\n  inc rdi\n  jmp .loop\n  \n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211805,"user_id":null,"body":"extern malloc\nSECTION .text\nglobal reverse\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  xor ebx, ebx\n.findend:\n  cmp byte [r14 + rbx], 0\n  lea rbx, [rbx + 1]\n  jne .findend\n  mov edi, ebx\n  call malloc\n  mov byte [rax + rbx - 1], 0\n  lea rcx, [rbx - 1]\n.loop:\n  sub rcx, 1\n  jb .done\n  mov dl, [r14]\n  mov byte [rax + rbx - 2], dl\n  inc r14\n  dec rbx\n  jmp .loop\n.done:\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211806,"user_id":null,"body":"SECTION .text\nglobal reverse\nextern strlen\nextern malloc\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n  push rbp\n  push r12\n  push rdi\n  call strlen\n  mov r12, rax\n  mov rdi, rax\n  inc rdi\n  call malloc\n  pop rdi\n  mov [rax + r12], byte 0\n  test r12, r12\n  jz .exit\n  mov rcx, rax\n.loop:\n  mov sil, [rdi + r12 - 1]\n  mov [rcx], sil\n  inc rcx\n  dec r12\n  jnz .loop\n.exit:\n  pop r12\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211807,"user_id":null,"body":"SECTION .text\nglobal reverse\n\nextern malloc\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n  xor rax, rax\n  \n  mov rcx, -1\n  .strLen:\n    inc rcx\n    cmp byte[rdi + rcx], 0\n    jne .strLen\n  inc rcx\n   \n  push rcx\n  push rdi\n    mov rdi, rcx          ; Allocate a block \n    call malloc             ; Allocate, address returned in rax.\n  pop rdi\n  pop rcx\n  \n  dec rcx\n  mov byte[rax + rcx], 0\n  cmp rcx, 0\n  je .return\n  \n  mov r9, -1\n  .revStr:\n    inc r9\n    dec rcx\n  \n    mov r8b, [rdi + rcx]\n    mov [rax + r9], r8b\n    \n    cmp rcx, 0\n    jne .revStr\n  \n  .return: \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211808,"user_id":173,"body":"extern malloc\nextern strdup\nextern printf\nSECTION .bss\nmem:\n  resq 1\n\nSECTION .text\nglobal reverse\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n  push rbp\n  ; save arg\n  mov r12, rdi\n    \n  ; compute length of argument\n  mov r13, 0\nL1:\n  cmp byte [rdi + r13], 0\n  je L2\n  inc r13\n  jmp L1\n\nL2:\n  cmp r13, 1\n  jbe EMPTY_STRING\n  \n\n\n  ; alloc new string of size rcx\n  mov rdi, r13\n  inc rdi\n  call malloc\n  mov rsi, rax\n  mov r14, rax\n\n  ; char by char\nLOOP:\n  mov byte al, [r12 + r13 - 1]\n  mov byte [rsi], al\n  inc rsi\n  dec r13\n  cmp r13, 0\n  jg LOOP\n  \n  ; end of string\n  mov byte [rsi], 0\n  \n  mov rax, r14\n  jmp EXIT\n  \nEMPTY_STRING:\n  mov rdi, r12\n  call strdup\nEXIT:\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211809,"user_id":null,"body":"extern malloc\nextern strlen\n\nSECTION .text\nglobal reverse\n\n; char *reverse(const char *);\n; Return a heap-allocated string representing the reversed value of the argument.\nreverse:\n  push rdi\n  call strlen\n  push rax\n  inc rax\n  mov rdi, rax\n  call malloc\n  pop rcx\n  pop rsi\n  cmp rcx, 0\n  je .end\n  dec rsi\n  xor r8, r8\n.loop:\n    movzx rdx, byte [rsi+rcx]\n    mov [rax+r8], dl\n    inc r8\n    loopnz .loop\n.end:\n  mov [rax+r8], byte 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"51ba717bb08c1cd60f00002f":[{"id":211810,"user_id":null,"body":"global solution\nextern strdup, strcat, sprintf\ndefault rel\n\n; <-- [byte RAX] solution(ro [dword RDI] nums, RSI n) -->\nsolution:\n  sub rsp, 40\n  mov word [bufa], 0\n  test rsi, rsi\n  jz .quit\n  \n  mov edx, [rdi]\n  lea ecx, [rdx-1]\n  mov [rsp], rsi\n  mov [rsp+8], rdi\n  \n.loop:\n  mov rdi, [rsp+8]\n  mov eax, [rdi]\n  add qword [rsp+8], 4\n  lea edi, [rcx+1]\n  cmp eax, edi\n  je .skip\n\n.write:\n  mov [rsp+24], eax\n  \n  lea rdi, [bufb]\n  lea rsi, [formata]\n  lea rax, [formatb]\n  cmp edx, ecx\n  cmove rsi, rax\n  lea eax, [rcx-1]\n  cmp edx, eax\n  lea rax, [formatc]\n  cmove rsi, rax\n  xor eax, eax\n  call sprintf\n  \n  lea rdi, [bufa]\n  lea rsi, [bufb]\n  call strcat\n  \n  mov eax, [rsp+24]\n  mov edx, eax\n.skip:\n  mov ecx, eax\n  dec qword [rsp]\n  jnz .loop\n  \n  lea rdi, [bufb]\n  lea rsi, [formata]\n  lea rax, [formatb]\n  cmp edx, ecx\n  cmove rsi, rax\n  lea eax, [rcx-1]\n  cmp edx, eax\n  lea rax, [formatc]\n  cmove rsi, rax\n  xor eax, eax\n  call sprintf\n  \n  lea rdi, [bufa]\n  lea rsi, [bufb]\n  call strcat\n  \n.quit:\n  lea rdi, [bufa+1]\n  call strdup\n  add rsp, 40\n  ret\n; -----> endof solution <-----\n\nsection .bss\nbufa:\n  resb 1024\nbufb:\n  resb 1024\n\nsection .rodata\nformata:\n  db \",%d-%d\", 0\nformatc:\n  db \",%d\"\nformatb:\n  db \",%d\", 0\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211811,"user_id":null,"body":"global solution:function\n\nextern malloc\nextern free\nextern realloc\nextern sprintf\n\nstruc str\n  .begin resq 1\n  .size resq 1\n  .len resq 1\nendstruc\n\n; bool str::reserve(size_t size) {\nstr#reserve:\n    push rbp\n    mov rbp, rsp\n    cmp rdi, [rbx+str.size]\n    jbe .done\n    \n    ; resize to the first power of two greater than size\n    bsr rcx, rdi\n    bsf rax, rdi\n    cmp rax, rcx\n    adc cl, 0\n    mov rsi, 1\n    shl rsi, cl\n    \n    cmp cl, 64\n    cmovae rsi, rdi\n    \n    push rdi\n    push rsi\n    mov rdi, [rbx+str.begin]\n    call realloc\n    pop rsi\n    pop rdi\n        \n    test rax, rax\n    jz .done\n        \n    mov [rbx+str.begin], rax\n    mov [rbx+str.size], rsi\n    \n  .done:\n    xor eax, eax\n    cmp rdi, [rbx+str.size]\n    setbe al\n    \n    pop rbp\n    ret\n\n; bool str::init() {\nstr#init:\n    push rbp\n    mov rbp, rsp\n    \n    mov rdi, rbx\n    mov rcx, str_size\n    xor eax, eax\n    rep stosb\n    \n    mov rdi, 16\n    mov [rbx+str.size], rdi\n    \n    call malloc\n    mov [rbx+str.begin], rax\n    \n    xor edi, edi\n    test rax, rax\n    cmovnz rdi, [rbx+str.size]\n    mov [rbx+str.size], rdi\n        \n  .done:\n    mov rdi, rax\n    xor eax, eax\n    test rdi, rdi\n    setnz al\n    \n    pop rbp\n    ret\n\n\n\n; bool str::append(char *chars, size_t count) {\nstr#append:\n    push rbp\n    mov rbp, rsp\n\n    xor eax, eax\n    test rsi, rsi\n    setz al\n    jz .done\n    \n    push rdi\n    push rsi\n    \n    mov rax, [rbx+str.len]\n    lea rdi, [rax+rsi+1]\n    call str#reserve\n    test al, al\n    jz .done\n\n    mov rdi, [rbx+str.begin]\n    add rdi, [rbx+str.len]\n    pop rcx\n    pop rsi\n    rep movsb\n    \n    sub rdi, [rbx+str.begin]\n    mov [rbx+str.len], rdi\n    mov rax, 1\n    \n  .done:\n    mov rsp, rbp\n    pop rbp\n    ret\n\n; char * str::unwrap()\n; returns a C string representing the contents of this str.\nstr#unwrap:\n    push rbp\n    mov rbp, rsp\n    \n    mov rdi, [rbx+str.begin]\n    mov rsi, [rbx+str.len]\n    inc rsi\n    call realloc\n    test rax, rax\n    jz .fail\n    xor edi, edi\n    mov [rbx+str.begin], rdi\n    \n    mov rsi, [rbx+str.len]\n    mov [rax+rsi], byte 0\n.fail:\n    pop rbp\n    ret\n    \nstr#destroy:\n    push rbp\n    mov rbp, rsp\n    mov rdi, [rbx+str.begin]\n    call free\n    pop rbp\n    ret\n    \n    \n; <-- [byte RAX] solution(ro [dword RDI] nums, RSI n) -->\nsolution:\n    push rbp\n    mov rbp, rsp\n    sub rsp, 0x48\n    push rbx\n    push r12\n    push r13\n    \n    mov r12, rdi\n    lea r13, [rdi+rsi*4]\n\n    lea rbx, [rbp-str_size]\n    call str#init\n    test al, al\n    jz .done\n    \n  .next_range:\n    cmp r12, r13\n    je .chop_comma\n\n    lea rsi, [r12]\n    mov ecx, [r12]\n    mov edx, ecx\n    \n  .extend_range:\n    ; scan to the first entry where *(current + i) != *current + i\n    inc ecx\n    add rsi, 4\n    cmp rsi, r13\n    je .found_range\n    cmp ecx, [rsi]\n    je .extend_range\n\n  .found_range:\n    mov eax, ecx\n    sub eax, edx\n    dec ecx\n\n    cmp eax, 3\n    jae .append_range\n  .append_single:\n    mov rsi, single_format\n    add r12, 4\n    jmp .do_append\n  .append_range:\n    mov r12, rsi\n    mov rsi, range_format\n    \n  .do_append:\n    lea rdi, [rbp-0x48]\n    xor al, al\n    call sprintf\n\n    lea rdi, [rbp-0x48]\n    mov rsi, rax\n    call str#append\n            \n    test al, al\n    jnz .next_range\n    \n  .error:\n    xor rax, rax\n    jmp .done\n        \n  .chop_comma:\n    mov rcx, [rbx+str.len]\n    test rcx, rcx\n    jz .export_str\n    dec rcx\n    mov [rbx+str.len], rcx\n    \n  .export_str:\n    call str#unwrap\n    \n  .done:\n    mov [rsp+0x20], rax\n    call str#destroy\n    mov rax, [rsp+0x20]\n    \n    pop r13\n    pop r12\n    pop rbx\n    mov rsp, rbp\n    pop rbp\n    ret\n\n    \nsection .data\nsingle_format: db '%d,', 0\nrange_format: db '%d-%d,', 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211812,"user_id":null,"body":"segment .text\nglobal solution\nextern malloc, sprintf\n\n; <-- [byte RAX] solution(ro [dword RDI] nums, RSI n) -->\n; [rsp]                 pointer to array\n; [rsp + 8]             size of array\n; [rsp + 16]            current starting position in array\n; [rsp + 24]            memory block for string\n; [rsp + 32]            memory pointer for sprintf\n\n%define STACKSIZE 40\n%define ARRSIZE (rsp +8)\n%define C_START (rsp + 16)\n%define P_STR   (rsp + 24)\n%define C_P_STR (rsp + 32)\n\n@s_string   db \"%i,\",0\n@r_string   db \"%i-%i,\",0\n\nsolution:\n                  sub rsp,STACKSIZE\n                  mov [rsp],rdi\n                  mov [ARRSIZE],rsi          \n                  xor rax,rax\n                  mov [C_START],rax\n                  mov rdi,1000        ; Ugly hack fixed string buffer - would fix in an ideal world\n                  call malloc\n                  mov [P_STR],rax\n                  mov [C_P_STR],rax\n                  xor r8,r8       \n.main_loop        mov rdi,[rsp]\n                  xor rcx,rcx       ; Counter for consecutive array entries - 64 bit because parameter n is size_t\n                  mov eax,[rdi + r8 * 4]\n.range_loop       cmp [rdi + r8 * 4],eax ; If not the next consecutive number - go print\n                  jne .print\n                  inc r8\n                  cmp r8,[ARRSIZE]\n                  jg  .print          ; If end of array - go print\n                  inc rcx             ; Increase consecutive counter\n                  inc eax             ; Increase expected consecutive number\n                  jmp .range_loop\n.print            mov r9,1\n                  lea rsi,[@r_string]\n                  lea r10,[@s_string]\n                  cmp rcx,3           ; If it's only 2 consepcutive it's a bit ugly - only print 1st entry and it's going to get looped a 2nd time for the 2nd entry\n                  cmovl rcx,r9\n                  cmovl rsi,r10\n                  mov r8,[C_START]\n                  add [C_START],rcx\n                  mov edx,[rdi + r8 * 4]\n                  dec ecx\n                  add ecx,edx\n                  mov rdi,[C_P_STR]\n                  call sprintf\n                  add [C_P_STR],rax\n.done_test        mov r8,[C_START]\n                  cmp r8,[ARRSIZE]\n                  jl .main_loop\n                  mov rax,[C_P_STR]\n                  mov byte [rax -1],0   ; Replace last comma with a 0\n                  mov rax,[P_STR]\n                  add rsp,STACKSIZE\n                  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211813,"user_id":null,"body":"segment .text\nglobal solution\nextern malloc, sprintf\n\n; <-- [byte RAX] solution(ro [dword RDI] nums, RSI n) -->\n; [rsp]                 pointer to array\n; [rsp + 8]             size of array\n; [rsp + 16]            current starting position in array\n; [rsp + 24]            memory block for string\n; [rsp + 32]            memory pointer for sprintf\n\n%define STACKSIZE 40\n%define ARRSIZE (rsp +8)\n%define C_START (rsp + 16)\n%define P_STR   (rsp + 24)\n%define C_P_STR (rsp + 32)\n\n@s_string   db \"%i,\",0\n@r_string   db \"%i-%i,\",0\n\nsolution:\n                  sub rsp,STACKSIZE\n                  mov [rsp],rdi\n                  mov [ARRSIZE],rsi          \n                  xor rax,rax\n                  mov [C_START],rax\n                  mov rdi,1000        ; Ugly hack fixed string buffer - would fix in an ideal world\n                  call malloc\n                  mov [P_STR],rax\n                  mov [C_P_STR],rax\n                  xor r8,r8       \n.main_loop        mov rdi,[rsp]\n                  xor rcx,rcx       ; Counter for consecutive array entries - 64 bit because parameter n is size_t\n                  mov eax,[rdi + r8 * 4]\n.range_loop       cmp [rdi + r8 * 4],eax ; If not the next consecutive number - go print\n                  jne .print\n                  inc r8\n                  cmp r8,[ARRSIZE]\n                  jg  .print          ; If end of array - go print\n                  inc rcx             ; Increase consecutive counter\n                  inc eax             ; Increase expected consecutive number\n                  jmp .range_loop\n.print            cmp rcx,3           ; If it's only 2 consepcutive it's a bit ugly - only print 1st entry and it's going to get looped a 2nd time for the 2nd entry\n                  jge .p_range\n.p_single         mov r8,[C_START]\n                  mov edx,[rdi + r8 * 4]\n                  mov rdi,[C_P_STR]\n                  lea rsi,[@s_string]\n                  call sprintf\n                  add [C_P_STR],rax\n                  inc qword [C_START]\n                  jmp .done_test\n.p_range          lea rsi,[@r_string]\n                  mov r8,[C_START]\n                  mov edx,[rdi + r8 * 4]\n                  add [C_START],rcx\n                  add r8,rcx\n                  mov ecx,[rdi + r8 * 4 - 4]\n                  mov rdi,[C_P_STR]\n                  call sprintf\n                  add [C_P_STR],rax\n.done_test        mov r8,[C_START]\n                  cmp r8,[ARRSIZE]\n                  jl .main_loop\n                  mov rax,[C_P_STR]\n                  mov byte [rax -1],0   ; Replace last comma with a 0\n                  mov rax,[P_STR]\n                  add rsp,STACKSIZE\n                  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211814,"user_id":1088,"body":"[section .text]\n\nextern malloc\nextern sprintf\nglobal solution\n\nsolution:\n\tpush\tr14\n\tpush\tr13\n\tmov\tr13, rdi\n\tlea\trdi, [rsi+rsi*4]\n\tpush\tr12\n\tsal\trdi, 2\n\tpush\trbp\n\tmov\trbp, rsi\n\tpush\trbx\n\tcall\tmalloc\n\tmov\tr12, rax\n\ttest\trbp, rbp\n\tje\t.L1\n\tmov\trdi, rax\n\txor\tr8d, r8d\n.L2:\n\tlea\trbx, [r8+1]\n\tmov\tr9d, dword [r13+0+r8*4]\n\tcmp\trbp, rbx\n\tjbe\t.L3\n\tmov\teax, r9d\n\tjmp\t.L5\n.L26:\n\tlea\trdx, [rbx+1]\n\tcmp\trbp, rdx\n\tjbe\t.L25\n\tmov\trbx, rdx\n.L5:\n\tmov\tedx, eax\n\tmov\teax, dword [r13+0+rbx*4]\n\tlea\trsi, [rbx-1]\n\tlea\tecx, [rax-1]\n\tcmp\tecx, edx\n\tje\t.L26\n\tmov\trax, rsi\n\tsub\trax, r8\n\ttest\tr8, r8\n\tje\t.L14\n.L27:\n\tmov\tbyte [rdi], 44\n\tlea\tr14, [rdi+1]\n\ttest\trax, rax\n\tje\t.L7\n.L28:\n\tcmp\trax, 1\n\tje\t.L8\n\tmov\tecx, dword [r13+0+rsi*4]\n\tmov\tedx, r9d\n\tmov\tesi, .LC2\n.L23:\n\tmov\trdi, r14\n\txor\teax, eax\n\tcall\tsprintf\n\tmov\tr8, rbx\n\tmovsx\trdi, eax\n\tadd\trdi, r14\n.L10:\n\tcmp\trbp, rbx\n\tja\t.L2\n.L1:\n\tpop\trbx\n\tmov\trax, r12\n\tpop\trbp\n\tpop\tr12\n\tpop\tr13\n\tpop\tr14\n\tret\n.L25:\n\tmov\trsi, rbx\n\tmov\trbx, rdx\n\tmov\trax, rsi\n\tsub\trax, r8\n\ttest\tr8, r8\n\tjne\t.L27\n.L14:\n\tmov\tr14, rdi\n\ttest\trax, rax\n\tjne\t.L28\n.L7:\n\tmov\trdi, r14\n\tmov\tedx, r9d\n\tmov\tesi, .LC0\n\txor\teax, eax\n\tcall\tsprintf\n\tmov\tr8, rbx\n\tmovsx\trdi, eax\n\tadd\trdi, r14\n\tjmp\t.L10\n.L8:\n\tmov\tecx, dword [r13+0+rsi*4]\n\tmov\tedx, r9d\n\tmov\tesi, .LC1\n\tjmp\t.L23\n.L3:\n\ttest\tr8, r8\n\tje\t.L15\n\tmov\tbyte [rdi], 44\n\tlea\tr14, [rdi+1]\n\tjmp\t.L7\n.L15:\n\tmov\tr14, rdi\n\tmov\tebx, 1\n\tjmp\t.L7\n\n.LC0: db \"%d\",0\n.LC1: db \"%d,%d\",0\n.LC2: db \"%d-%d\",0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211815,"user_id":null,"body":"global solution\nextern malloc, realloc, sprintf\n\n; <-- fmtqrange(QWORD q, [QWORD] rng, QWORD pos, DWORD end) -->\n%macro fmtqrange 4\n    lea rdi, [%2+%3]                ; pointing RDI to <rng+pos>\n    mov rsi, .fmtc                  ; pointing RSI to <.fmtc>\n    mov rdx, .fmtd                  ; pointing RDX to <.fmtd>\n    cmp %1, 1                       ; whether <q> is one\n    cmovne rsi, rdx                 ; otherwise, updating RSI with <.fmtd>\n    mov edx, %4                     ; loading EDX with <end>\n    call sprintf                    ; printing <end> to <rng+pos>\n    add %3, rax                     ; updating <pos>\n%endmacro\n; -----> endof fmtqrange <-----\n\n; <-- [byte RAX] solution(ro [dword RDI] nums, RSI n) -->\nsolution:\n    push rbx                        ; saving RBX in the stack\n    push rbp                        ; saving RBP in the stack\n    push r12                        ; saving R12 in the stack\n    push r13                        ; saving R13 in the stack\n    push r14                        ; saving R14 in the stack\n    push r15                        ; saving R15 in the stack\n    push rsi                        ; saving <n> in the stack\n    mov rbp, rdi                    ; saving <nums> in RBP\n    imul rdi, rsi, 0xC              ; the max bytes to allocate for <rng>\n    call malloc                     ; allocating memory\n    test rax, rax                   ; whether the memory is allocated\n    je .exit                        ; otherwise, jumping to exit\n    mov rbx, rax                    ; pointing RBX to the allocated memory as <rng>\n    xor r13, r13                    ; resetting R13 as <q>\n    mov rdi, rbx                    ; pointing RDI to <rng>\n    mov rsi, .fmti                  ; pointing RSI to <.fmti>\n    mov edx, [rbp]                  ; setting EDX to <*nums> as <num>\n    mov r15d, edx                   ; saving <num> in R15D\n    call sprintf                    ; printing <num> to <rng>\n    mov r12, rax                    ; saving the printed character as <pos> in R12\n    jmp .atexit                     ; jumping to the .atexit label\n.loop:\n    lea rbp, [rbp+0h4]              ; pointing <nums> to the next integer\n    mov r15d, [rbp]                 ; setting R15D to <*nums> as <num>\n    mov edx, r15d                   ; coppying <num> to EDX\n    sub edx, r14d                   ; subtracting <end> from <num>\n    lea rcx, [r13+1]                ; loading RCX with <n+1> as <inc>\n    dec edx                         ; decrementing the difference\n    cmove r13, rcx                  ; updating <n> with <inc> if the difference is zero\n    je .atexit                      ; jumping to the .atexit if the difference is zero\n    test r13, r13                   ; whether <q> is not zero\n    je .singl                       ; otherwise, jumping to the .singl label\n    fmtqrange r13, rbx, r12, r14d   ; formatting <rng> with <end>\n    xor r13d, r13d                  ; resetting <q>\n.singl:\n    lea rdi, [rbx+r12]              ; pointing RDI to <rng+pos>\n    mov rsi, .fmtc                  ; pointing RSI to <.fmtc>\n    mov edx, r15d                   ; loading EDX with <num>\n    call sprintf                    ; printing <num> to <rng>\n    add r12, rax                    ; adding the printed character to <pos>\n.atexit:\n    mov r14d, r15d                  ; loading R14D with <num> as <end>\n    pop rsi                         ; restoring <n> from the stack\n    dec rsi                         ; decrementing <n>\n    push rsi                        ; saving <n> in the stack\n    jne .loop                       ; jumping to the next .loop iteration if <n> is not zero\n    test r13, r13                   ; whether <q> is not zero\n    je .exit                        ; otherwise, jumping to exit\n    fmtqrange r13, rbx, r12, r14d   ; formatting <rng> with <end>\n.exit:\n    mov rdi, rbx                    ; loading RDI with <rng>\n    lea rsi, [r12+1]                ; loading RSI with incremented <pos>\n    call realloc                    ; reallocating <rng>\n    add rsp, 0h8                    ; destroying <n>\n    pop r15                         ; restoring the original R15 from the stack\n    pop r14                         ; restoring the original R14 from the stack\n    pop r13                         ; restoring the original R13 from the stack\n    pop r12                         ; restoring the original R12 from the stack\n    pop rbp                         ; restoring the original RBP from the stack\n    pop rbx                         ; restoring the original RBX from the stack\n    ret\n\n; local read-only storage\n.fmti:  db  `%i\\0`\n.fmtc:  db  `,%i\\0`\n.fmtd:  db  `-%i\\0`\n; -----> endof solution <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"51f2b4448cadf20ed0000386":[{"id":211816,"user_id":null,"body":"global rmurlahr\nextern strndup\n\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n    push rdi                ; saving <src> onto the stack\n    xor eax, eax            ; will be used in conditional move\n    xor esi, esi            ; resetting RSI as <n>\n    dec rsi                 ; setting <n> to minus one\n.loop:\n    movzx edx, byte [rdi]   ; extending <*src> as <c>\n    inc rdi                 ; pointing <src> to the next character\n    inc rsi                 ; incrementing <n>\n    cmp edx, '#'            ; whether <c> is the number (hash) character\n    cmove edx, eax          ; resetting <c>\n    test edx, edx           ; whether <c> is the null character\n    jne .loop               ; otherwise, jumping to the next iteration\n    pop rdi                 ; restoring the original <src> from the stack\n    jmp strndup             ; jumping to <strdup> to save extra overhead\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211817,"user_id":null,"body":"extern strndup\nglobal rmurlahr\n\nrmurlahr:\n  xor esi, esi\n.loop:\n  mov al, byte [rdi + rsi]\n  test al, al\n  je .end\n  cmp al, 35\n  je .end\n  inc rsi\n  jmp .loop\n.end:\n  jmp strndup","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211818,"user_id":null,"body":"global rmurlahr\nextern strdup\nrmurlahr:\n  call strdup\n  mov  rdx,rax\n  jmp @b\n  @a:xor byte[rdx],'#'\n     je @c\n     inc rdx\n  @b:xor byte[rdx],'#'   \n  jne @a\n  @c:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211819,"user_id":null,"body":"global rmurlahr\nextern malloc, memcpy\n\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n  push r12\n  push rax\n  push rdi\n  xor r12d, r12d\n  jmp .cond\n  .loop:\n  inc r12\n  .cond:\n  mov sil, [rdi + r12]\n  test sil, sil\n  jz .break\n  cmp sil, '#'\n  jne .loop\n  .break:\n  xor eax, eax\n  lea rdi, [r12 + 1]\n  call malloc\n  mov rdi, rax\n  pop rsi\n  pop rcx\n  mov rdx, r12\n  call memcpy\n  mov byte [rax + r12], 0\n  pop r12\n  ret\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211820,"user_id":null,"body":"global rmurlahr\nextern malloc, memcpy\n\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n  push r12\n  push rax\n  push rdi\n  xor r12d, r12d\n  jmp .cond\n  .loop:\n  inc r12\n  .cond:\n  test byte [rdi + r12], ~'#'\n  jnz .loop\n  xor eax, eax\n  lea rdi, [r12 + 1]\n  call malloc\n  mov rdi, rax\n  pop rsi\n  pop rcx\n  mov rdx, r12\n  call memcpy\n  mov byte [rax + r12], 0\n  pop r12\n  ret\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211821,"user_id":null,"body":"global rmurlahr\nextern strdup\n\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n  push rdi\n  call strdup\n  pop rdi\n  test rax, rax\n  jz .quit\n  \n  mov rsi, rax\n.loop:\n  mov dl, [rsi]\n  inc rsi\n  test dl, dl\n  jz .quit\n  cmp dl, '#'\n  jne .loop\n  \n  mov byte [rsi-1], 0\n.quit:\n  ret\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211822,"user_id":null,"body":"global rmurlahr\nextern malloc\n\n\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n    ; malloc\n    push rdi\n    mov rdi, 250\n    call malloc\n    pop rdi\n\n    xor rcx, rcx\n    xor rdx, rdx\n\nl:\n    mov dl, [rdi+rcx]\n    cmp dl, '#'\n    jz done\n    cmp dl, 0\n    jz done\n    mov byte [rax+rcx], dl\n    inc rcx\n    jmp l\n\ndone:\n    mov byte [rax+rcx], 0\n    ret\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211823,"user_id":173,"body":"extern malloc, printf\nglobal rmurlahr\n\nsection .data\nfmt: db \"A: %d\", 10, 0 \n\nsection .text\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n    mov r12, rdi\n    ; compute strlen\n    mov rcx, -1\n    mov rax, 0\n    cld\n    repne scasb\n    sub rax, rcx\n    sub rax, 2\n    ; r9 is strlen\n    mov r9, rax\n    \n    mov rdi, rax\n    inc rdi\n    call malloc\n    ; r8 is output buffer\n    mov r8, rax\n  \n\n    mov rcx, 0\n    mov rdi, r8\n    mov rsi, r12\nl_loop:\n    cmp byte [rsi], '#'\n    jne l_next\n    mov byte [rdi], 0\n    jmp l_done\nl_next:\n    mov dl, byte [rsi]\n    mov byte [rdi], dl\n    inc rdi\n    inc rsi\n    inc rcx\n    cmp rcx, r9\n    jb l_loop\n    \n    mov byte [rdi], 0\n    \nl_done:    \n    \n    mov rax, r8\n    ret\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211824,"user_id":null,"body":"global rmurlahr\n\nextern malloc, strlen\n\nrmurlahr:\n; <-- [byte RAX] rmurlahr(ro [byte RDI] src) -->\n    call strlen\n    inc rax\n\n    push rdi\n    mov rdi, rax\n    call malloc\n\n    mov rdi, rax\n    pop rsi\n    push rax\n\n    .loop:\n      lodsb\n      test al, al\n      jz .end\n      cmp al, '#'\n      jz .end\n      stosb\n      jmp .loop\n      \n    .end:\n    xor al, al\n    stosb\n    \n    pop rax\n    ret\n; -----> endof rmurlahr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211825,"user_id":null,"body":"global rmurlahr\nextern malloc, strlen, strstr, strcpy\n\nrmurlahr:\n; rsp      input char *\n; rsp+8    new char *\n; rsp+8*2  char[2] = \"#\" for strstr\n\n  sub rsp, 8*4\n  mov [rsp], rdi\n \n  call strlen\n \n  mov rdi, rax\n  inc rdi\n  call malloc\n \n  mov [rsp+8], rax\n \n  mov rdi, rax\n  mov rsi, [rsp]\n  call strcpy\n \n  mov rdi, [rsp+8]\n  xor rax, rax\n  mov al, '#'\n  mov [rsp+8*2], rax\n  lea rsi, [rsp+8*2]\n  call strstr\n \n  test rax, rax\n  jz .ret\n \n  mov BYTE [rax], 0\n\n.ret:\n  mov rax, [rsp+8]\n  add rsp, 8*4\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"521c2db8ddc89b9b7a0000c1":[{"id":211826,"user_id":null,"body":"global snail\nextern malloc\n\n; <-- [dword RAX] snail([qword RDI] outsz, ro [qword [dword RSI]] mx, RDX m, RCX n) -->\nsnail:\n  test rdx, rdx               ; check for zero dim\n  jnz .main                   ; goto main if non-zero\n  xor eax, eax                ; zero RAX for null return - dword used for shorter instruction\n  mov [rdi], rax              ; write 0 too outsz\n  ret                         ; return null\n.main:\n  push rbp                    ; store RBP\n  push rbx                    ; store RBX\n  imul rcx, rdx               ; squared dim (count) into RCX - RCX is always the same as RDX\n  push rdx                    ; store dim\n  mov [rdi], rcx              ; write outsz now so we don't have to do so later\n  lea rdi, [rcx * 4]          ; malloc 1st arg buffer size\n  mov rbp, rsi                ; move matrix into RBP - needed after malloc\n  mov rbx, rcx                ; move count into RBX - needed after malloc to compute write_end\n  call malloc                 ; RAX now holds write pointer\n; <-- register allocation -->\n; - RBP : matrix\n; - RDX : dim\n; - RCX : write\n; - RBX : write_end\n; - RDI : cycle\n; - RSI : delta\n  pop rdx                     ; restore dim - RDX is now dim\n  mov rcx, rax                ; RCX is now write\n  lea rbx, [rax + rbx * 4]    ; RBX is now write_end\n  xor edi, edi                ; RDI is now cycle - dword used for shorter instruction\n  mov esi, 1                  ; RSI is now delta - dword used for shorter instruction\n.traverse_row:\n; <-- register allocation -->\n; - R8  : term\n; - R9  : read\n; - R10 : scratch\n; - R11 : scratch\n  cmp si, 0                   ; check direction\n  jl .traverse_row_rev\n  lea r9, [rdi * 4]           ; load the read offset\n  add r9, [rbp + rdi * 8]     ; load the read pointer + read offset\n  lea r10, [rdi * 8]          ; load the term cycle modifier\n  jmp .traverse_row_shared\n.traverse_row_rev:\n  lea r9, [rdx * 4]           ; load the read dim offset\n  lea r10, [8 + rdi * 4]      ; load the read cycle offset\n  sub r9, r10                 ; subtract read cycle offset from read dim offset\n  lea r10, [rdx * 8]          ; load read index\n  lea r11, [8 + rdi * 8]      ; load read index cycle offset\n  sub r10, r11                ; subtract read index cycle offset from read index\n  add r9, [rbp + r10]         ; load read pointer + read offset\n  lea r10, [4 + rdi * 8]      ; load the term cycle modifier\n.traverse_row_shared:\n  lea r8, [rcx + rdx * 4]     ; load the term pointer\n  sub r8, r10                 ; offset the term pointer by the term cycle modifier\n.traverse_row_loop:\n  mov r10d, [r9]              ; dereference read pointer\n  mov [rcx], r10d             ; write the read value\n  lea r9, [r9 + rsi * 4]      ; move read pointer forward\n  add rcx, 4                  ; move write pointer forward\n  cmp rcx, r8                 ; check if row completed\n  jne .traverse_row_loop\n  cmp rcx, rbx                ; check if done writing - this check only has to occur after rows\n  je .exit                    ; exit if done\n; <-- register allocation -->\n; - R8  : term\n; - R9  : row pointer (int**)\n; - R10 : column offset (bytes to add too dereferenced row pointer)\n; - R11 : scratch\n  cmp si, 0                   ; check direction\n  jl .traverse_column_rev\n  lea r9, [8 + rdi * 8]       ; load the row pointer displacement\n  lea r10, [rdx * 4]          ; load the column offset base\n  lea r11, [4 + rdi * 4]      ; load the column offset cycle modifier\n  sub r10, r11                ; offset the column offset by the column offset cycle modifier\n  lea r11, [4 + rdi * 8]      ; load the term cycle modifier\n  jmp .traverse_column_shared\n.traverse_column_rev:\n  lea r9, [rdx * 8]           ; load the row pointer displacement\n  lea r11, [16 + rdi * 8]     ; load the row pointer displacement cycle modifier\n  sub r9, r11                 ; offset the row pointer displacement by the row pointer displacement cycle modifier\n  lea r10, [rdi * 4]          ; load the column offset\n  lea r11, [8 + rdi * 8]      ; load the term cycle modifier\n  inc rdi                     ; increment the cycle\n.traverse_column_shared:\n  lea r9, [r9 + rbp]          ; load the row pointer\n  lea r8, [rcx + rdx * 4]     ; load the term pointer\n  sub r8, r11                 ; offset the term pointer by the cycle term modifier\n.traverse_column_loop:\n  mov r11, r10                ; load column offset\n  add r11, [r9]               ; add column offset to dereferenced row pointer\n  mov r11d, [r11]             ; dereference value\n  mov [rcx], r11d             ; write value \n  lea r9, [r9 + rsi * 8]      ; move the row pointer forward\n  add rcx, 4                  ; move write pointer forward\n  cmp rcx, r8                 ; check if row column completed\n  jne .traverse_column_loop\n  neg rsi                     ; negate delta to flip direction\n  jmp .traverse_row\n.exit:\n  pop rbx                     ; restore RBX\n  pop rbp                     ; restore RBP\n  ret\n; -----> endof snail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211827,"user_id":null,"body":"global snail\nextern malloc\n\n%macro move_num 0\n  mov rdi, [rsi+rcx*8]\n  mov edi, [rdi+rdx*4]\n  mov [rax], edi\n  add rax, 4\n  dec qword [rsp+32]\n  jz .done\n%endmacro\n\n; <-- [dword RAX] snail([qword RDI] outsz, ro [qword [dword RSI]] mx, RDX m, RCX n) -->\nsnail:\n  mov r8, rdx\n  imul r8, rcx\n  mov [rdi], r8\n  test r8, r8\n  jz .bailout\n  \n  sub rsp, 56\n  mov [rsp], rsi\n  mov [rsp+8], rdx\n  mov [rsp+16], rcx\n  mov [rsp+24], rdi\n  mov [rsp+32], r8\n  lea rdi, [r8*4]\n  call malloc\n  test rax, rax\n  jz .bailout2\n  mov [rsp+24], rax\n  \n  xor r8d, r8d\n  xor r9d, r9d\n  mov r10, [rsp+8]\n  mov r11, [rsp+16]\n  mov rsi, [rsp]\n  xor ecx, ecx\n  xor edx, edx\n  \n.loop_right:\n  move_num\n  inc rdx\n  cmp rdx, r11\n  jl .loop_right\n  dec rdx\n  inc rcx\n  inc r8\n  \n.loop_down:\n  move_num\n  inc rcx\n  cmp rcx, r10\n  jl .loop_down\n  dec rcx\n  dec rdx\n  dec r11\n  \n.loop_left:\n  move_num\n  dec rdx\n  cmp rdx, r9\n  jge .loop_left\n  inc rdx\n  dec rcx\n  dec r10\n  \n.loop_up:\n  move_num\n  dec rcx\n  cmp rcx, r8\n  jge .loop_up\n  inc rcx\n  inc rdx\n  inc r9\n  jmp .loop_right\n\n.done:\n  mov rax, [rsp+24]\n  add rsp, 56\n  ret\n  \n.bailout:\n  xor eax, eax\n  ret\n  \n.bailout2:\n  mov rdi, [rsp+24]\n  mov [rdi], rax\n  add rsp, 56\n  ret\n  \n; -----> endof snail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211828,"user_id":460,"body":"extern malloc\nglobal snail\nsnail:\n  push rdi\n  push rsi\n  push rdx\n  push rcx\n  mov rax, rdx\n  mul rcx ; width * height\n  mov [rdi], eax\n  sal rax, 2 ; * 4 bytes\n  mov rdi, rax\n  call malloc\n  pop rcx\n  pop rdx\n  pop rsi\n  pop rdi\n  \n  mov r8, rsi ; source matrix\n  mov r9, rdx ; width\n  mov r10, rcx ; height\n  mov r11, rax ; target array\n  mov r12, rdi ; target array size\n  xor r13, r13 ; current y\n  xor r14, r14 ; current x\n  xor rax, rax ; y shift = 0\n  mov rbx, 1 ; x shift = 1\n  mov rcx, r9 ; shift counter\n  xor rdi, rdi ; target array iterator\n  \n  dec r14 ; to start from element [0,0] because rbx == 1\n  @loop:\n    add r13, rax ; y shift\n    add r14, rbx ; x shift\n    mov rsi, [r8+r13*8]\n    mov esi, [rsi+r14*4]\n    mov [r11+rdi*4], esi ; set element to target array\n    inc rdi\n    dec rcx\n    jnz @loop\n    \n    cmp rdi, [r12] ; if array is filled\n    je @done\n    \n    cmp rax, 0 ; is y shift == 0?\n    je @setup_y_shift\n    ; setup_x_shift\n      neg rax ; swap direction\n      mov rbx, rax ; now we moving along x\n      xor rax, rax\n      dec r9 ; previous y move shrinked our x space\n      mov rcx, r9 ; setup shift counter\n      jmp @loop\n    @setup_y_shift:\n      mov rax, rbx ; now we moving along y\n      xor rbx, rbx\n      dec r10 ; previous x move shrinked our y space\n      mov rcx, r10 ; setup shift counter\n    jmp @loop\n    \n@done:    \n  mov rax, r11\nret\n; -----> endof snail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211829,"user_id":null,"body":"global snail\nextern malloc\nsection .data\n\n@right_v equ 0\n@down_v equ 1\n@left_v equ 2\n@up_v equ 3\n\n@jtab: dq $@right, $@down, $@left, $@up    ; Jumpblock\n\nsection .text\n@ssize equ 40\n;[rbp - pointer to array of pointers to rows]\n;[rbp + 8 - pointer to returned snail]\n;[rbp + 16 - left_limit]\n;[rbp + 20 - right_limit]\n;[rbp + 24 - top_limit]\n;[rbp + 28 - bottom_limit]\n;[rbp + 32 - # entries]\n\nsnail:          sub  rsp,@ssize\n                mov  [rsp],rsi\n                imul edx,ecx\n                mov  eax,edx\n                mov  [rdi],eax                 ; Update return value to be row * column entries\n                mov  [rsp + 32],eax\n                mov  dword [rsp + 16],0        ; Initial left limit is 0\n                mov  dword [rsp + 24],0        ; Initial top limit is 0\n                dec  ecx\n                mov  [rsp + 20],ecx           ; intial right limit is size -1\n                mov  [rsp + 28],ecx           ; Initial bottom limit is size -1\n                shl  eax,2\n                mov  edi,eax\n                call malloc\n                mov  rdi,rax                   ; Current pointer to output array\n                mov  rsi,[rsp]                 ; Pointer to array of pointers\n                mov  [rsp + 8],rax\n                xor  r10d,r10d                  ; Starting direction is right\n                xor  r8d,r8d                    ; Current row\n                mov  r9d,-1                     ; Current column - we start at 0,-1\n                mov  ecx,[rsp + 32]\n                xor  edx,edx\n@main_loop:     jmp  [@jtab + r10 * 8]\n@copy:          mov  r12,[rsi + r8 * 8]         ; Get row\n                mov  r11d,[r12 + r9 * 4]        ; get int from [row][column] \/ [r8][r9]\n                mov  [rdi + rdx * 4],r11d       ; Store it in the output array\n                inc  edx\n                loop @main_loop\n                add  rsp,@ssize\n                ret\n@right:         inc  r9d\n                cmp  r9d,[rsp + 20]\n                jne  @copy\n                mov  r10d,@down_v\n                inc  dword [rsp + 24]\n                jmp  @copy\n@down:          inc  r8d\n                cmp  r8d,[rsp + 28]\n                jne  @copy\n                mov  r10d,@left_v\n                dec  dword [rsp + 20]\n                jmp  @copy\n@left:          dec  r9d\n                cmp  r9d,[rsp + 16]\n                jne  @copy\n                mov  r10d,@up_v\n                dec  dword [rsp + 28]\n                jmp  @copy\n@up:            dec  r8d\n                cmp  r8d,[rsp + 24]\n                jne  @copy\n                mov  r10d,@right_v\n                inc  dword [rsp + 16]\n                jmp  @copy","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211830,"user_id":null,"body":"global snail\nextern malloc\nsnail:\n  mov  r8,rdx\n  imul r8,rcx\n  mov  [rdi],r8\n  lea  rdi,[r8*4]\n  mov  [len],rdx\n  mov  [len+8],rcx\n  lea  rdx,[rdx*4-4]\n  mov  [step+8],rdx\n  neg  rdx\n  sub  rdx,8\n  mov  [step+24],rdx\n  push qword[rsi]\n  call malloc\n  pop  rsi\n  mov  rdi,rax\n  xor  r9,r9\n  xor  r10,r10\n  .a:mov rcx,[len+r9*8]\n     mov r8,[step+r10*8]\n     inc r10\n     and r10,3\n     add rsi,r8\n     .b:movsd\n        add rsi,r8\n     loop .b  \n     sub rsi,r8\n     xor r9,1\n     dec qword[len+r9*8]\n  jne .a   \nret\nsection .data\nstep dq 0,0,-8,0\nlen  resq 2","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211831,"user_id":null,"body":"global snail\nextern malloc\n\n; <-- [dword RAX] snail([qword RDI] outsz, ro [qword [dword RSI]] mx, RDX m, RCX n) -->\nsnail:\n    push rbp\n    mov  rbp, rsp\n    \n    push rdi ; rpb - 8  outsz\n    push rsi ; rbp - 16 mx\n    push rdx ; rbp - 24 m\n    push rcx ; rbp - 32 n\n    \n    push 0   ; rbp - 40 top\n    push 0   ; rbp - 48 left\n    push rcx ; rbp - 56 right\n    push rcx ; rbp - 64 bottom\n    push 0   ; rbp - 72 y\n    push 0   ; rbp - 80 x\n    \n    \n    mov rax, rdx ; m * n\n    mul rcx      ; res in RDX:RAX\n    \n    mov qword [rdi], rax ; save to *outsz\n    \n    imul rdi, rax, 4\n    call malloc      ; malloc(*outsz * sizeof(dword))\n    \n    push rax  ; rbp - 88  res\n    push 0    ; rbp - 96  i\n    push r8   ; rbp - 104 r8 backup\n    push r9   ; rbp - 112 r9 backup\n    push r10  ; rbp - 120 r10 backup\n    push r11  ; rbp - 128 r11 backup\n    push r12  ; rbp - 136 r12 backup\n    \n    \n    main_loop:\n        \n        ; r8 flag\n        \n        xor r8, r8 ; flag = 0\n        to_right_loop:\n            \n            mov r9, qword [rbp - 80] ; r9 = x\n            cmp r9, qword [rbp - 56] ; x ? right\n            jnb end_to_right_loop    ; if !< break\n            \n            mov r10, qword [rbp - 16] ; r10 = mx\n            mov r11, qword [rbp - 72] ; r11 = y\n            mov r12, qword [r10 + r11 * 8] ; r12 = mx[y]\n            mov r12d, dword [r12 + r9  * 4] ; r12 = mx[y][x]\n            \n            mov r11, qword [rbp - 96]\n            inc qword [rbp - 96]      ; r11 = i++\n            \n            mov r10, qword [rbp - 88]\n            mov dword [r10 + r11 * 4], r12d ; res[r11] = r12\n            \n            inc qword [rbp - 80] ; ++x\n            inc r8               ; flag = 1\n            jmp to_right_loop\n            \n    end_to_right_loop:\n        \n        test r8, r8 ; if flag\n        jz skip_move1\n        \n        dec qword [rbp - 80] ; --x\n        inc qword [rbp - 72] ; ++y\n        inc qword [rbp - 40] ; ++top\n        xor r8, r8           ; flag = 0\n        \n    skip_move1:\n        \n        mov r9, qword [rbp - 40] ; r9 = top\n        cmp r9, qword [rbp - 64] ; top ? bottom\n        je return                ; if == break\n        \n        \n        \n        \n        \n        xor r8, r8 ; flag = 0\n        to_top_loop:\n            \n            mov r9, qword [rbp - 72] ; r9 = y\n            cmp r9, qword [rbp - 64] ; y ? bottom\n            jnb end_to_top_loop    ; if !< break\n            \n            mov r10, qword [rbp - 16] ; r10 = mx\n            mov r11, qword [rbp - 80] ; r11 = x\n            mov r12, qword [r10 + r9 * 8] ; r12 = mx[y]\n            mov r12d, dword [r12 + r11  * 4] ; r12 = mx[y][x]\n            \n            mov r11, qword [rbp - 96]\n            inc qword [rbp - 96]      ; r11 = i++\n            \n            mov r10, qword [rbp - 88]\n            mov dword [r10 + r11 * 4], r12d ; res[r11] = r12\n            \n            inc qword [rbp - 72] ; ++y\n            inc r8               ; flag = 1\n            jmp to_top_loop\n            \n    end_to_top_loop:\n        \n        test r8, r8 ; if flag\n        jz skip_move2\n        \n        dec qword [rbp - 80] ; --x\n        dec qword [rbp - 72] ; --y\n        dec qword [rbp - 56] ; --right\n        xor r8, r8           ; flag = 0\n        \n    skip_move2:\n        \n        mov r9, qword [rbp - 56] ; r9 = right\n        cmp r9, qword [rbp - 48] ; right ? left\n        je return                ; if == break\n        \n        \n        \n        \n        \n        \n        \n        mov r9, qword [rbp - 80] ; r9 = x\n        cmp r9, qword [rbp - 48] ; x ? left\n        je end_to_left_loop     ; if == skip loop\n        \n        \n        xor r8, r8 ; flag = 0\n        to_left_loop:\n            \n            mov r9, qword [rbp - 80] ; r9 = x\n            inc r9                   ; r9 = x + 1\n            cmp r9, qword [rbp - 48] ; x ? left\n            je end_to_left_loop      ; if == break\n            \n            mov r10, qword [rbp - 16] ; r10 = mx\n            mov r11, qword [rbp - 72] ; r11 = y\n            mov r12, qword [r10 + r11 * 8] ; r12 = mx[y]\n            dec r9                         ; r9 = x\n            mov r12d, dword [r12 + r9  * 4] ; r12 = mx[y][x]\n            \n            mov r11, qword [rbp - 96]\n            inc qword [rbp - 96]      ; r11 = i++\n            \n            mov r10, qword [rbp - 88]\n            mov dword [r10 + r11 * 4], r12d ; res[r11] = r12\n            \n            dec qword [rbp - 80] ; --x\n            inc r8               ; flag = 1\n            jmp to_left_loop\n            \n    end_to_left_loop:\n        \n        test r8, r8 ; if flag\n        jz skip_move3\n        \n        inc qword [rbp - 80] ; ++x\n        dec qword [rbp - 72] ; --y\n        dec qword [rbp - 64] ; --bottom\n        xor r8, r8           ; flag = 0\n        \n    skip_move3:\n        \n        mov r9, qword [rbp - 40] ; r9 = top\n        cmp r9, qword [rbp - 64] ; top ? bottom\n        je return                ; if == break\n        \n        \n        \n        \n        \n        \n        mov r9, qword [rbp - 72] ; r9 = y\n        cmp r9, qword [rbp - 40] ; x ? top\n        je end_to_bottom_loop     ; if == skip loop\n        \n        \n        xor r8, r8 ; flag = 0\n        to_bottom_loop:\n            \n            mov r9, qword [rbp - 72] ; r9 = y\n            inc r9                   ; r9 = y + 1\n            cmp r9, qword [rbp - 40] ; x ? top\n            je end_to_bottom_loop      ; if == break\n            \n            mov r10, qword [rbp - 16] ; r10 = mx\n            mov r11, qword [rbp - 80] ; r11 = x\n            dec r9                         ; r9 = y\n            mov r12, qword [r10 + r9 * 8] ; r12 = mx[y]\n            mov r12d, dword [r12 + r11 * 4] ; r12 = mx[y][x]\n            \n            mov r11, qword [rbp - 96]\n            inc qword [rbp - 96]      ; r11 = i++\n            \n            mov r10, qword [rbp - 88]\n            mov dword [r10 + r11 * 4], r12d ; res[r11] = r12\n            \n            dec qword [rbp - 72] ; --y\n            inc r8               ; flag = 1\n            jmp to_bottom_loop\n            \n    end_to_bottom_loop:\n        \n        test r8, r8 ; if flag\n        jz skip_move4\n        \n        inc qword [rbp - 80] ; ++x\n        inc qword [rbp - 72] ; ++y\n        inc qword [rbp - 48] ; ++left\n        xor r8, r8           ; flag = 0\n        \n    skip_move4:\n        \n        mov r9, qword [rbp - 56] ; r9 = right\n        cmp r9, qword [rbp - 48] ; right ? left\n        je return                ; if == break\n        \n        \n        \n        \n        \n        \n        jmp main_loop\n    \nreturn:\n    \n    \n    pop r12\n    pop r11\n    pop r10\n    pop r9\n    pop r8\n    \n    mov rsp, rbp\n    mov rax, qword [rbp - 88]\n    pop rbp\n    \n    \n    \n  ;  mov qword [rdi], 0          ; [RDI] <- the snail size\n  ;  xor eax, eax                ; RAX <- the result snail\n    ret\n    \n    \n; -----> endof snail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211832,"user_id":3346,"body":"global snail\nextern malloc\n\nsection .rodata\n\nQ1 dq Q1, Q2\nQ2 dq Q3, Q2\nQ3 dq Q2, Q2\n\n; <-- [dword RAX] snail([qword RDI] outsz, ro [qword [dword RSI]] mx, RDX m, RCX n) -->\nsnail:\n    push rbx\n    push r12\n    push r13\n    mov dword [rdi], 0\n    mov rbx, rdx\n    mov rax, rbx\n    mul rcx\n    test rax, rax,\n    je .exit\n    push rax\n    push rcx\n    push rsi\n    push rdi\n    lea rdi, [rax*4]\n    call malloc\n    pop rdx\n    pop rdi\n    pop rcx\n    pop rsi\n    test rax, rax\n    je .exit\n    mov [rdx], rsi\n    xor r10d, r10d\n    xor r11d, r11d\n    xor r12d, r12d\n    xor r13d, r13d\n    dec r13\n    dec r12\n.loop:\n    neg r13\n    test rbx, rbx\n    je .exit\n    mov rsi, rcx\n    dec rcx\n    mov r9, [rdi+r11*8]\n.lpn:\n    dec rsi\n    add r12, r13\n    mov edx, [r9+r12*4]\n    mov [rax+r10*4], edx\n    inc r10\n    test rsi, rsi\n    jne .lpn\n    dec rbx\n    je .none\n    mov rsi, rbx\n.lpm:\n    dec rsi\n    add r11, r13\n    mov r9, [rdi+r11*8]\n    mov edx, [r9+r12*4]\n    mov [rax+r10*4], edx\n    inc r10\n    test rsi, rsi\n    jne .lpm\n.none:\n    test rcx, rcx\n    jne .loop\n.exit:\n    pop rbx\n    pop r12\n    pop r13\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211833,"user_id":null,"body":"global snail\nextern malloc\n\n; <-- [dword RAX] snail([qword RDI] outsz, ro [qword [dword RSI]] mx, RDX m, RCX n) -->\nsnail:\n    push rbx                    ; saving RBX on stack\n    push r12                    ; saving R12 on stack\n    push r13                    ; saving R13 on stack\n    mov dword [rdi], 0          ; resetting <*outsz>\n    mov rbx, rdx                ; saving <m> in RBX\n    mov rax, rbx                ; copying <m> to RAX\n    mul rcx                     ; getting the size of snail as <sz>\n    test rax, rax,              ; whether <sz> is not zero\n    je .exit                    ; otherwise, jumping to exit\n    push rax                    ; saving <sz> on stack\n    push rcx                    ; saving <n> on stack\n    push rsi                    ; saving <mx> in the stack\n    push rdi                    ; saving <outsz> in the stack\n    lea rdi, [rax*4]            ; getting the bytes to allocate for <snl>\n    call malloc                 ; allocating memory\n    pop rdx                     ; restoring <outz> from the stack\n    pop rdi                     ; restoring <mx> from the stack\n    pop rcx                     ; restoring <n> from the stack\n    pop rsi                     ; restoring <sz> from the stack\n    test rax, rax               ; whether the memory has been allocated\n    je .exit                    ; otherwise, jumping to exit\n    mov [rdx], rsi              ; saving <sz> in <*outsz>\n    xor r10d, r10d              ; resetting R10 as <inx>\n    xor r11d, r11d              ; resetting R11 as <i>\n    xor r12d, r12d              ; resetting R12 as <j>\n    xor r13d, r13d              ; resetting R13 as <inx>\n    dec r13                     ; setting <inc> to minus one\n    dec r12                     ; setting <j> to minus one\n.loop:\n    neg r13                     ; reversing the sign of <inc>\n    test rbx, rbx               ; whether <m> is not zero\n    je .exit                    ; otherwise, jumping to exit\n    mov rsi, rcx                ; copying <n> to RSI as <shf>\n    dec rcx                     ; decrementing <n>\n    mov r9, [rdi+r11*8]         ; pointing R9 to <*(mx+i)> as <mxi>\n.lpn:\n    dec rsi                     ; decrementing <shf>\n    add r12, r13                ; setting <j+=inc>\n    mov edx, [r9+r12*4]         ; loading EDX with <*(mxi+j)> as <x>\n    mov [rax+r10*4], edx        ; copying <x> to <*(snl+inx)>\n    inc r10                     ; incrementing <inx>\n    test rsi, rsi               ; whether <shf> is zero\n    jne .lpn                    ; otherwise, jumping to the next .lpn iteration\n    dec rbx                     ; decrementing <m>\n    je .none                    ; jumping to .none if <m> is zero\n    mov rsi, rbx                ; copying <m> to RSI as <shf>\n.lpm:\n    dec rsi                     ; decrementing <shf>\n    add r11, r13                ; setting <i+=inc>\n    mov r9, [rdi+r11*8]         ; pointing R9 to <*(mx+i)> as <mxi>\n    mov edx, [r9+r12*4]         ; loading EDX with <*(mxi+j)> as <x>\n    mov [rax+r10*4], edx        ; copying <x> to <*(snl+inx)>\n    inc r10                     ; incrementing <inx>\n    test rsi, rsi               ; whether <shf> is zero\n    jne .lpm                    ; otherwise, jumping to the next .lpm iteration\n.none:\n    test rcx, rcx               ; whether <n> is zero\n    jne .loop                   ; otherwise, jumping to the next .loop iteration\n.exit:\n    pop rbx                     ; restoring the original RBX from the stack\n    pop r12                     ; restoring the original R12 from the stack\n    pop r13                     ; restoring the original R13 from the stack\n    ret\n; -----> endof snail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211834,"user_id":null,"body":"global snail\nextern malloc\n\n; <-- [dword RAX] snail([qword RDI] outsz, ro [qword [dword RSI]] mx, RDX m, RCX n) -->\nsnail:\n    push rbx                    ; saving RBX on stack\n    push r12                    ; saving R12 on stack\n    push r13                    ; saving R13 on stack\n    mov dword [rdi], 0          ; resetting <*outsz>\n    mov rbx, rdx                ; saving <m> in RBX\n    mov rax, rbx                ; copying <m> to RAX\n    mul rcx                     ; getting the size of snail as <sz>\n    test rax, rax,              ; whether <sz> is not zero\n    je .exit                    ; otherwise, jumping to exit\n    push rax                    ; saving <sz> on stack\n    push rcx                    ; saving <n> on stack\n    push rsi                    ; saving <mx> in the stack\n    push rdi                    ; saving <outsz> in the stack\n    lea rdi, [rax*4]            ; getting the bytes to allocate for <snl>\n    call malloc                 ; allocating memory\n    pop rdx                     ; restoring <outz> from the stack\n    pop rdi                     ; restoring <mx> from the stack\n    pop rcx                     ; restoring <n> from the stack\n    pop rsi                     ; restoring <sz> from the stack\n    test rax, rax               ; whether the memory has been allocated\n    je .exit                    ; otherwise, jumping to exit\n    mov [rdx], rsi              ; saving <sz> in <*outsz>\n    xor r10d, r10d              ; resetting R10 as <inx>\n    xor r11d, r11d              ; resetting R11 as <i>\n    xor r12d, r12d              ; resetting R12 as <j>\n    xor r13d, r13d              ; resetting R13 as <inx>\n    dec r13                     ; setting <inc> to minus one\n    dec r12                     ; setting <j> to minus one\n.loop:\n    neg r13                     ; reversing the sign of <inc>\n    test rbx, rbx               ; whether <m> is not zero\n    je .exit                    ; otherwise, jumping to exit\n    mov rsi, rcx                ; copying <n> to RSI as <shf>\n    dec rcx                     ; decrementing <n>\n    mov r9, [rdi+r11*8]         ; pointing R9 to <*(mx+i)> as <mxi>\n.lpn:\n    dec rsi                     ; decrementing <shf>\n    add r12, r13                ; setting <j+=inc>\n    mov edx, [r9+r12*4]         ; loading EDX with <*(mxi+j)> as <x>\n    mov [rax+r10*4], edx        ; copying <x> to <*(snl+inx)>\n    inc r10                     ; incrementing <inx>\n    test rsi, rsi               ; whether <shf> is zero\n    jne .lpn                    ; otherwise, jumping to the next .lpn iteration\n    dec rbx                     ; decrementing <m>\n    je .none                    ; jumping to .none if <m> is zero\n    mov rsi, rbx                ; copying <m> to RSI as <shf>\n.lpm:\n    dec rsi                     ; decrementing <shf>\n    add r11, r13                ; setting <i+=inc>\n    mov r9, [rdi+r11*8]         ; pointing R9 to <*(mx+i)> as <mxi>\n    mov edx, [r9+r12*4]         ; loading EDX with <*(mxi+j)> as <x>\n    mov [rax+r10*4], edx        ; copying <x> to <*(snl+inx)>\n    inc r10                     ; incrementing <inx>\n    test rsi, rsi               ; whether <shf> is zero\n    jne .lpm                    ; otherwise, jumping to the next .lpm iteration\n.none:\n    test rcx, rcx               ; whether <n> is zero\n    jne .loop                   ; otherwise, jumping to the next .loop iteration\n.exit:\n    pop rbx                     ; restoring the original RBX from the stack\n    pop r12                     ; restoring the original R12 from the stack\n    pop r13                     ; restoring the original R13 from the stack\n    ret\n; -----> endof snail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"522551eee9abb932420004a0":[{"id":211835,"user_id":168,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n  mov eax, 1\n  xor edx, edx\n.loop:\n  xadd rdx, rax\n  dec edi\n  jnz .loop\n  ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211836,"user_id":881,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n    xor rax, rax\n    xor rdx, rdx\n    inc rdx\n.for_each_n:\n    dec edi\n    jle .done\n    add rax, rdx\n    xchg rax, rdx\n    jmp .for_each_n\n.done:\n    ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211837,"user_id":null,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n  xor ecx, ecx\n  mov edx, 1\n  \n.loop:\n  mov rax, rcx\n  mov rcx, rdx\n  lea rdx, [rax+rcx]\n  dec edi\n  jnz .loop\n  ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211838,"user_id":null,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n  xor rax, rax            ; RAX <- the result\n  mov rbx, 0\n  mov rcx, 1\n  dec edi\n  cmp edi, 0\n  jle end\n  loop:\n    dec edi\n    mov rdx, rbx\n    mov rbx, rcx\n    add rcx, rdx\n    test edi, edi\n    jnz loop\nend:\n  mov rax, rbx\n  ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211839,"user_id":null,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n  movsxd rax, edi\n  mov rax, [8*rax + .fns - 8]\n  ret\n.fns: dq 0x0,0x1,0x1,0x2,0x3,0x5,0x8,0xd,0x15,0x22,0x37,0x59,0x90,0xe9,0x179,0x262,0x3db,0x63d,0xa18,0x1055,0x1a6d,0x2ac2,0x452f,0x6ff1,0xb520,0x12511,0x1da31,0x2ff42,0x4d973,0x7d8b5,0xcb228,0x148add,0x213d05,0x35c7e2,0x5704e7,0x8cccc9,0xe3d1b0,0x1709e79,0x2547029,0x3c50ea2,0x6197ecb,0x9de8d6d,0xff80c38,0x19d699a5,0x29cea5dd,0x43a53f82,0x6d73e55f,0xb11924e1,0x11e8d0a40,0x1cfa62f21,0x2ee333961,0x4bdd96882,0x7ac0ca1e3,0xc69e60a65,0x1415f2ac48,0x207fd8b6ad,0x3495cb62f5,0x5515a419a2,0x89ab6f7c97,0xdec1139639,0x1686c8312d0,0x2472d96a909,0x3af9a19bbd9,0x5f6c7b064e2,0x9a661ca20bb,0xf9d297a859d,0x19438b44a658,0x28e0b4bf2bf5,0x42244003d24d,0x6b04f4c2fe42,0xad2934c6d08f,0x1182e2989ced1,0x1c5575e509f60,0x2dd8587da6e31,0x4a2dce62b0d91,0x780626e057bc2,0xc233f54308953,0x13a3a1c2360515,0x1fc6e116668e68,0x336a82d89c937d,0x533163ef0321e5,0x869be6c79fb562,0xd9cd4ab6a2d747,0x16069317e428ca9,0x23a367c34e563f0,0x39a9fadb327f099,0x5d4d629e80d5489,0x96f75d79b354522,0xf444c01834299ab,0x18b3c1d91e77decd,0x27f80ddaa1ba7878,0x40abcfb3c0325745,0x68a3dd8e61eccfbd,0xa94fad42221f2702","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211840,"user_id":null,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n    xor rax, rax            ; RAX <- the result\n    cmp edi, 1\n    je .end\n    cmp edi, 2\n    mov rbx, rax\n    inc rax\n    mov rdx, rax\n    je .end\n\n    mov rcx, 3\n\n.loop:\n    mov rax, rbx\n    add rax, rdx\n    mov rbx, rdx\n    mov rdx, rax\n\n    inc ecx\n    cmp ecx, edi\n    jle .loop\n.end:\n    ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211841,"user_id":null,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnew_loop:\n    mov rdx, rcx\n    jmp fib_loop\nnth_fib:\n    mov rdx, 0\n    mov rbx, 1\nfib_loop:\n    mov rcx, rbx\n    add rbx, rdx\n    dec edi\n    test edi, edi\n    jnz new_loop\n    mov rax, rdx\n\n    ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211842,"user_id":null,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n    xor rax, rax            ; RAX <- the result\n    movsx rdi, edi\n    dec rdi\n    jle .finish\n    mov rdx, 1\n  .loop:\n    xadd rdx, rax\n    dec rdi\n    jnz .loop\n  .finish:\n    ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211843,"user_id":527,"body":"global nth_fib\n\nsection .text\n\n; unsigned long long nth_fib(int n)\nnth_fib:\n                xor     eax, eax\n                dec     edi\n                jz      .done\n                mov     edx, 1\n.loop:          xadd    rax, rdx\n                dec     edi\n                jnz     .loop\n.done:          ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211844,"user_id":50,"body":"global nth_fib\n\nsection .text\n\n; <--- unsigned long long nth_fib(int n) --->\nnth_fib:\n    xor rax, rax            ; RAX <- the result\n    mov rbx,1\n_loop:\n    cmp edi,1\n    je _exit\n    dec edi\n    mov rcx,rbx\n    add rcx,rax\n    mov rax,rbx\n    mov rbx,rcx\n    jmp _loop\n_exit:\n    ret\n; ---------> endof nth_fib <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"523b4ff7adca849afe000035":[{"id":211845,"user_id":525,"body":"SECTION .text\n  text:db \"Hello World!\", 0\nglobal greet\n\n;  Return \"Hello World!\"\ngreet:\n  mov rax, text\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211846,"user_id":null,"body":"section .text\n\nglobal greet\n\ngreet:\n    mov eax, hello\n    ret\n\nsection .data\n    hello:  db  \"Hello World!\"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211847,"user_id":null,"body":"SECTION .text\nglobal greet\n\n;  Return \"Hello World!\"\ngreet:\n  xor rax, rax\n  mov rax, HELLO\n  ret\n  \nSECTION .data\n  HELLO:\n    db 'Hello World!', 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211848,"user_id":1027,"body":"section .data\nmsg db 0f8h,0dbh,0d4h,0d4h,0d1h,20h,0e9h,0d1h,0ceh,0d4h,0dch,1fh,40h,0dh,0ah,0\nsection .code\nglobal greet\ngreet:\n  mov rdi,msg\n  xor rcx,rcx\n.loop:\n  mov al,byte[msg+rcx]\n  sub al,41h\n  xor al,0ffh\n  mov byte[msg+rcx],al\n  inc rcx\n  cmp rcx,0dh\n  jb .loop\n  mov rax,msg\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211849,"user_id":null,"body":"SECTION .text\nglobal greet\nstr: db \"Hello World!\", 0\n\ngreet:\n  lea rax,[str]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211850,"user_id":null,"body":"SECTION .data\n  txt db \"Hello World!\",0\n\nSECTION .text\nglobal greet\n\n;  Return \"Hello World!\"\ngreet:\n  mov rax, txt\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211851,"user_id":null,"body":"SECTION .text\nglobal greet\n\ngreeting db \"Hello World!\", 0\n\n;  Return \"Hello World!\"\ngreet:\n  lea rax, [greeting]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211852,"user_id":null,"body":"SECTION .text\nglobal greet\nReturn db \"Hello World!\",0\ngreet:\n  mov rax,Return\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211853,"user_id":null,"body":"SECTION .data\n  hello: db \"Hello World!\", 0\n\nSECTION .text\nglobal greet\n\ngreet:\n  mov rax, hello\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211854,"user_id":null,"body":"extern malloc\nSECTION .text\nglobal greet\n\n;  Return \"Hello World!\"\ngreet:\n  push rsi\n  mov rdi, 14\n  call malloc\n  mov rcx, rax\n  xor esi, esi\n  mov rax, 0x17dd3519640a\n  mov rdi, 0x54d6a3d9a3\n.B1.3:\n  cqo\n  idiv rdi\n  mov byte [rsi+rcx], al\n  inc rsi\n  mov rax, rdi\n  mov rdi, rdx\n  test rdx, rdx\n  jne .B1.3\n  mov rax, 0x10cf5a63e\n  mov edi, 40648975\n.B1.5:\n  cqo\n  idiv rdi\n  mov byte [rsi+rcx], al\n  inc rsi\n  mov rax, rdi\n  mov rdi, rdx\n  test rdx, rdx\n  jne .B1.5\n  mov rax, rcx\n  pop rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"523b623152af8a30c6000027":[{"id":211855,"user_id":null,"body":"SECTION .text\nglobal square\n\n; int square(int x);\n; Returns the square of the argument x.\n; The result will be assumed to be in the range of 0 to INT32_MAX (0x7FFFFFFF)\nsquare:\n  mov rax, rdi\n  mul rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211856,"user_id":1277,"body":"SECTION .text\nglobal square\n\nsquare:\n  imul edi, edi\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211857,"user_id":1027,"body":"section .code\nglobal square\nsquare:\n  bt edi,31\n  jnc .a\n  neg edi\n.a:\n\tmov eax,edi\n  lea rcx,[rdi-1]\n.b:\n\tadd eax,edi\n\tdec ecx\n  jnz .b\n\tret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211858,"user_id":null,"body":"SECTION .text\nglobal square\n\nsquare:\n  mov eax, edi\n  imul eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211859,"user_id":null,"body":"section .text\nglobal square\n\nsquare:\n  mov eax, edi\n  mul eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211860,"user_id":null,"body":"SECTION .text\nglobal square\n\n; int square(int x);\n; Returns the square of the argument x.\n; The result will be assumed to be in the range of 0 to INT32_MAX (0x7FFFFFFF)\nsquare:\n  cmp esi, 0\n  jz end\n  xor eax, eax\n  mov eax, edi\n  mul eax\n   \n\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211861,"user_id":null,"body":"SECTION .text\nglobal square\n\n; int square(int x);\n; Returns the square of the argument x.\n; The result will be assumed to be in the range of 0 to INT32_MAX (0x7FFFFFFF)\nsquare:\n  xor eax, eax\n  mov eax, edi\n  mul eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211862,"user_id":null,"body":"SECTION .text\nglobal square\n\n; int square(int x);\n; Returns the square of the argument x.\n; The result will be assumed to be in the range of 0 to INT32_MAX (0x7FFFFFFF)\nsquare:\n  mov rax, rdi\n  imul rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211863,"user_id":null,"body":"SECTION .text\nglobal square\n\n; int square(int x);\n; Returns the square of the argument x.\n; The result will be assumed to be in the range of 0 to INT32_MAX (0x7FFFFFFF)\nsquare:\n  xor eax, eax\n  mov eax, edi\n imul eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211864,"user_id":null,"body":"SECTION .text\nglobal square\n\n; int square(int x);\n; Returns the square of the argument x.\n; The result will be assumed to be in the range of 0 to INT32_MAX (0x7FFFFFFF)\nsquare:\n  mov eax, edi\n  imul eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"523b66342d0c301ae400003b":[{"id":211865,"user_id":null,"body":"SECTION .text\nglobal multiply\n\n; Multiplies two numbers.\nmultiply:\n  mov eax, edi\n  mul esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211866,"user_id":17,"body":"SECTION .text\nglobal multiply\n\n; Multiplies two numbers.\n; arg0         = (int32_t) First operand.\n; arg1         = (int32_t) Second operand.\n; return value = (int32_t) Product of the two operands.\nmultiply:\n  mov eax, edi\n  imul esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211867,"user_id":null,"body":"SECTION .text\nglobal multiply\n\nmultiply:\n  xor    eax, eax\n  imul   edi, esi\n  mov    eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211868,"user_id":571,"body":"SECTION .text\nglobal multiply\n\n; Multiplies two numbers.\n; arg0         = (int32_t) First operand.\n; arg1         = (int32_t) Second operand.\n; return value = (int32_t) Product of the two operands.\nmultiply:\n  mov eax, edi\n  imul eax, esi \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211869,"user_id":1315,"body":"SECTION .text\nglobal multiply\n\n; Multiplies two numbers.\n; arg0         = (int32_t) First operand.\n; arg1         = (int32_t) Second operand.\n; return value = (int32_t) Product of the two operands.\nmultiply:\n  mov rax, rdi\n  mul rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211870,"user_id":null,"body":"SECTION .text\nglobal multiply\n\nmultiply:\n  mov eax, esi\n  mul edi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211871,"user_id":null,"body":"SECTION .text\nglobal multiply\n\nmultiply:\n  mov eax, edi\n  mov ebx, esi\n  mul ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211872,"user_id":null,"body":"SECTION .text\nglobal multiply\n\nmultiply:\n  mov rax,rdi\n  imul rsi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211873,"user_id":null,"body":"SECTION .text\nglobal multiply\n\n; Multiplies two numbers.\n; arg0         = (int32_t) First operand.\n; arg1         = (int32_t) Second operand.\n; return value = (int32_t) Product of the two operands.\nmultiply:\n  mov eax, esi\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211874,"user_id":null,"body":"SECTION .text\nglobal multiply\nmultiply:\n  mov  eax,edi\n  mul  esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"525c7c5ab6aecef16e0001a5":[{"id":211875,"user_id":null,"body":"global parseint\n\n; <-- EAX parseint(ro [byte RDI] num) -->\nparseint:\n    xor eax, eax                ; resetting as <n>\n    mov r11d, 1                 ; will be used in conditional move\n    xor r10d, r10d              ; resetting as <m>\n    xor r9d, r9d                ; resetting as <np>\n    xor r8d, r8d                ; resetting as <shf>\n    inc r8d                     ; incrementing <shf>\n    dec rdi                     ; decrementing <num> to point before the first character\n.loop:\n    inc rdi                     ; pointing <num> to the next character\n    movzx esi, byte [rdi]       ; copying <*num> to ESI as <c>\n    cmp esi, ' '                ; whether <c> is a space character\n    je .np                      ; jumping to the .np label\n    cmp esi, '-'                ; whether <c> is a dash character\n    je .np                      ; jumping to the .np label\n    test esi, esi               ; whether <c> is the null character\n    je .np                      ; jumping to the .np label\n    xchg esi, eax               ; exchanging <c> and <n>\n    mul r8d                     ; multiplying <c> by <shf>\n    add r9d, eax                ; adding to <np>\n    xchg eax, esi               ; exchanging back <c> and <n>\n    shl r8d, 1                  ; shifting <shf>\n    jmp .loop                   ; jumping to the next iteration\n.np:\n    xor ecx, ecx                ; resetting ECX as <r>\n    xor edx, edx                ; resetting EDX as <i>\n    dec edx                     ; decrementing <i> to start the .lp with incrementing\n.lp:\n    inc edx                     ; incrementing <i>\n    cmp edx, .numap_sz          ; whether <i> is less than <.numap_sz>\n    je .lpout                   ; otherwise, jumping to .lpout\n    cmp r9d, [.numap+rdx*8]     ; whether <np> is equal to <.numap[i].np>\n    jne .lp                     ; otherwise, jumping to the next .lp iteration\n    mov ecx, [.numap+rdx*8+4]   ; copying <.numap[i].n> to <r>\n.lpout:\n    xor r9d, r9d                ; resetting <np>\n    xor r8d, r8d                ; resetting <shf>\n    inc r8d\n    cmp ecx, 1000               ; whether <r> is equal to thousand\n    je .m                       ; jumping to the .m label\n    cmp ecx, 1000000            ; whether <r> is equal to million\n    je .m                       ; jumping to the .m label\n    cmp ecx, 1000000000         ; whether <r> is equal to billion\n    je .m                       ; jumping to the .m label\n    cmp ecx, 100                ; whether <r> is equal to hundred\n    je .m                       ; jumping to the .m label\n    add eax, ecx                ; adding <r> to <n>\n    jmp .exit                   ; jumping to exit\n.m:\n    test eax, eax               ; whether <n> is not zero\n    cmove eax, r11d             ; otherwise, setting <n> to one\n    mul ecx                     ; multiplying <n> by <r>\n    cmp ecx, 100                ; whether <r> is hundred\n    je .exit                    ; jumping to exit\n    add r10d, eax               ; adding <n> to <m>\n    xor eax, eax                ; resetting <n>\n.exit:\n    test esi, esi               ; whether <c> is the null character\n    jne .loop                   ; otherwise, jumping to the next .loop iteration\n    add eax, r10d               ; adding <m> to <n>\n    ret\n\n; local read-only map      \n.numap:\n    dq  0h00000000A8, 0h01000002DF, 0h020000031E, 0h0300000C84, 0h04000006A8, \\\n        0h0500000638, 0h0600000325, 0h0700000D1D, 0h0800000D53, 0h0900000620, \\\n        0h0A000002F6, 0h0B00001A91, 0h0C00001A56, 0h0D00006A98, 0h0E00006AC8, \\\n        0h0F000034E0, 0h1000003535, 0h110000D55D, 0h1200006A33, 0h1300006A40, \\\n        0h1400001CC6, 0h1E00001CD8, 0h2800000E3C, 0h3200000E00, 0h3C00000E55, \\\n        0h46000039DD, 0h5000001C73, 0h5A00001C80, 0h64000032EA, 0h3E800006778, \\\n        0h00000002CD, 0h0F42400000363F, 0h3B9ACA0000003634\n.numap_sz:  equ $ - .numap >> 3\n; -----> endof parseint <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211876,"user_id":null,"body":"[BITS 64]\n\nsection .data\n;;\n; C-signature:\n;     const char *buffer[16]\n;\n; This buffer is used to store the identified tokens (number parts) of the input string.\n; The longest expected number string is 9 characters long but we use 16 bytes to practise\n; data alignment.\n;\nbuffer:\n\ttimes 2 dq 0\n\nsection .text\n\n;;\n; C-signature:\n;     int strcmp(const char *s1, const char *s2)\n;     [eax]      [rdi]           [rsi]\nextern strcmp\n\nglobal parseint\n;;\n; C-signature:\n;     unsigned int parseint(const char *s)\n;     [eax]                 [rdi]\n;\n; Parse a given integer value represented in texual form.\n;\n; This function assumes that the given string is a valid representation of a positive integer.\n; This is for example: \"one\", \"fourteen\", \"seven hundred and nine thousand twelve\", a.s.o.\n; The \"and\" is optional and is skipped as well as any \"non-numerical\" string, like the dash in\n; \"eight-two\". Furthermore, only lower-case words are recognized as number strings. The range\n; of valid values is 0 to 999,999,999.\n;\n; @param s [rdi] the input string\n; @return [eax] the integer parsed from the input string\n;\n%define SOURCE_STRING  rbp - 0x08\nparseint:\n\tpush rbp\n\tmov rbp, rsp\n\n\tmov [SOURCE_STRING], rdi\n\tpush rbx ; will be our pointer into the buffer\n\tpush r12 ; will be the hundreds result\n\tpush r13 ; will be the thousands result\n\tpush r14 ; will be the millions result\n\tpush r15 ; will be our pointer to the buffer\n\n\tlea r15, [rel buffer]\n\tmov rbx, r15\n\txor r12, r12\n\txor r13, r13\n\txor r14, r14\n\n.while:\n\t; Test if *s != 0\n\tmov al, byte [rdi]\n\tcmp al, 0\n\tjz .endwhile\n\t; Test if *s < 'a'\n\tcmp al, 'a'\n\tjl .check_buffer\n\t; Test if *s > 'z'\n\tcmp al, 'z'\n\tjg .check_buffer\n\t; Here, we have a valid character to add to our buffer.\n\tmov byte [rbx], al\n\tinc rbx\n\tjmp .skip\n.check_buffer:\n\tcmp r15, rbx\n\tjz .skip\n\t; We look up what is in the buffer here and calculate the respective value.\n\t; But first, we have to null-terminate the buffered string.\n\tmov byte [rbx], 0\n\t; We can already set the pointer into the buffer to the start of\n\t; the buffer here. This saves us some jumping later on.\n\tmov rbx, r15\n\t; Now, we save our current position in the source string.\n\tmov [SOURCE_STRING], rdi\n\t; All other registers we use have to be preserved by the callee (ABI).\n\tmov rdi, r15\n\tcall lookup\n\t; We can restore the current position in the source string immediately.\n\tmov rdi, [SOURCE_STRING]\n\t; The result of the lookup is in eax. If the string was not hashed, it doesn't\n\t; count as a number and the return value will be -1.\n\tcmp eax, -1\n\tjz .skip\n\n\t; Now, lets merge the given value into our current result.\n\t; \n\t; If eax == 1,000,000 then\n\t;        multiply our current hundreds (r12) with this and store the\n\t;        result in the millions (r14). Also, set the hundreds to zero.\n\t; Else, if eax == 1,000 then\n\t;        multiply our current hundreds (r12) with this and store the\n\t;        result in the thousands (r13). Also, set the hundreds to zero.\n\t; Else, if eax == 100 then\n\t;        multiply our current hundreds (r12) with this.\n\t; Else\n\t;        add this to our hundreds (r12).\n\t;\n\tcmp eax, 1000000\n\tjnz .check_thousands\n\t; eax == 1,000,000\n\txor edx, edx\n\tmul r12\n\tmov r14, rax ; millions set to the result\n\txor r12, r12 ; hundreds set to 0\n\tjmp .skip\n.check_thousands:\n\tcmp eax, 1000\n\tjnz .check_hundreds\n\t; eax == 1,000\n\txor edx, edx\n\tmul r12\n\tmov r13, rax ; thousands set to the result\n\txor r12, r12 ; hundreds set to 0\n\tjmp .skip\n.check_hundreds:\n\tcmp eax, 100\n\tjnz .add_number\n\t; eax == 100\n\txor edx, edx\n\tmul r12\n\tmov r12, rax ; hundreds set to the result\n\tjmp .skip\n.add_number:\n\t; eax < 100\n\tadd r12, rax ; hundreds updated\n.skip:\n\tinc rdi\n\tjmp .while\n.endwhile:\n\t; Now, we have to check our buffer one last time whether it is empty or not.\n\t; To do that, we use a simple trick. We go back one character in the source\n\t; string and jump to the .check_buffer label to check the buffer again.\n\t; The final increment of rdi will break the loop again and this time the\n\t; buffer is empty, so we don't repeat this step.\n\t; Note: A cleaner way of doing this would be to extract the buffer handling\n  ; into its own function and call it when appropriate.\n\tcmp rbx, r15\n\tjz .end\n\tdec rdi\n\tjmp .check_buffer\n.end:\n\n\t; Here, we have to add the millions, thousands, and hundreds together.\n\tmov rax, r12\n\tadd rax, r13\n\t; Our final result is now in rax.\n\tadd rax, r14\n\n  ; Ofcourse, don't forget to restore the registers we saved earlier.\n\tpop r15\n\tpop r14\n\tpop r13\n\tpop r12\n\tpop rbx\n\n\tmov rsp, rbp\n\tpop rbp\n\tret\n\nglobal lookup\n;;\n; C-signature:\n;     int lookup(const char *s)\n;     [eax]      [rdi]\n;\n; Look up the integer value of the given string that represents a number word.\n; We expect only a single word here. Unrecognized words will result in a return\n; value of -1.\n;\n; @param s [rdi] input word\n; @return the value of the number word or -1 if not present in the backing hash table\n;\n%define HASH_TABLE       rbp - 0x08\n%define STRING_TABLE     rbp - 0x10\n%define INPUT_STRING     rbp - 0x18\n%define VAR_CURRENT_HASH rbp - 0x20\nlookup:\n\tpush rbp\n\tmov rbp, rsp\n\tsub rsp, 0x40\n\n\tlea rax, [rel hash_table_begin]\n\tmov [HASH_TABLE], rax\n\tlea rax, [rel strtab_begin]\n\tmov [STRING_TABLE], rax\n\tmov [INPUT_STRING], rdi\n\t; First, we calculate the hash with our hash function:\n\t; a) Initialise the hash value with 101.\n\t; b) For each character in the string multiply the hash with 5\n\t;    and add the character value to the hash.\n\t;\n\t; Note: How to get the hash function? We wrote a small C program that would calculate the hashes\n  ; for each string we wanted to store in the hash table. Then we modified the values until we\n  ; found a version of \"initial value\" and \"factor\" that would cause a very low number of collisions.\n  ; A collision happens when we calculate the index from the hash value and find the same index for\n  ; different input strings. We also decided in this experiment that we would opt for a 32 entry\n  ; hash table instead of a 64 entry hash table. Also note, that with 31 entries in our hash table,\n  ; our load factor is far from optimal for what you would read about hash functions. But for this\n  ; static table with a fixed set of strings, it is sufficient (and sufficiently small in terms of\n  ; memory).\n\txor eax, eax\n\txor ecx, ecx\n\tmov esi, 5\n\tmov eax, 101\n\n.L1:\n\tmov cl, byte [rdi]\n\tcmp cl, 0\n\tjz .L2\n  \n\txor edx, edx\n\tinc rdi\n\tlea eax, [eax + eax * 4]\n\tadd eax, ecx\n  \n\tjmp .L1\n.L2:\n\t; Because we opted for 32 buckets a modulo 32 operation is the same as calculating\n  ; bit-wise AND with 0x1f.\n\tand eax, 0x1f\n\t; Now, we operated on the low 32-bits of rax and its upper half should be zero.\n  ; We can use it in calculating the address into our hash table.\n\n\tmov rdx, [HASH_TABLE]\n\tlea rdx, [rdx + rax * 8]\n\t; Now, we look up the entry in the hash table with rdx pointing to the indexed hash entry.\n\tcmp word [rdx], 0\n\tjz .not_found\n\tcmp word [rdx + 2], 0\n\t; If the chain pointer of the entry is zero, we return the value from that entry.\n\tjz .found_hash\n\t; Else, we have to compare the strings and start to traverse the chain of hashed values\n  ; until we find the right value or the end of the chain. This is the worst-case scenario.\n\tmov [VAR_CURRENT_HASH], rdx\n\n.cmp_buckets:\n\t; Following, we compare the input string with the string in the string table that the hash\n  ; entry points to. We use strcmp for that. If the strings are equal, we found our desired\n  ; entry and return the entry's value. If not, we look up the next chain-pointer and continue\n  ; if necessary.\n  ; Note: We also have to store and restore rdx because it could be changed by our call to strcmp.\n\tmov rdi, [STRING_TABLE]\n\txor ecx, ecx\n\tmov cx,  word [rdx]\n\tadd rdi, rcx\n\tmov rsi, [INPUT_STRING]\n\tcall strcmp WRT ..plt\n\tmov rdx, [VAR_CURRENT_HASH]\n\ttest eax, eax\n\tjz .found_hash\n\tcmp word [rdx + 2], 0\n\tjz .not_found\n\txor ecx, ecx\n\tmov cx, word [rdx + 2]\n\tmov rdx, [HASH_TABLE]\n\tadd rdx, rcx\n\tmov [VAR_CURRENT_HASH], rdx\n\tjmp .cmp_buckets\n\n.found_hash:\n\t; If we found the hash entry, we have its address in rdx. We read the value of the\n  ; hash entry and return.\n\tmov eax, dword [rdx + 4]\n\n\tmov rsp, rbp\n\tpop rbp\n\tret\n\n.not_found:\n\t; If we end up here, we did not find a matching hash table entry.\n\tmov eax, -1\n\n\tmov rsp, rbp\n\tpop rbp\n\tret\n;\n; The hash table and the string table explained:\n;\n; First, we calculated the hash table with a small C-program to get the right indices\n; for each entry (instead of calculating all hash-values by hand). In C we used a struct\n; with a pointer to the string and a pointer to the next element to refer to multiple\n; strings that map to the same index (simple linked list). We also refer to the index\n; that harbours such a list as a bucket.\n;\n;     typedef struct hash_entry {\n;         const char *hashed_string;\n;         struct hash_entry *next;\n;     } hash_entry;\n;\n; But here (asm), we use an index further along the hash table to build the chains. The\n; chain elements are not part of the index-range for our hash function.\n;\n; Example:\n; If we calculate a hash for, let's say, \"three\", we get the index 5. Looking up index\n; 5 reveals a zero in the \"next in chain\" element of the hash table entry below. We then\n; know that the index (str_three - strtab_begin) is the index to our hashed text\n; (\"three\") in the string table. We return the value of the hash table entry.\n; \n; Let's say we want to find \"nine\" in the hash table. We calculate a hash value of 23\n; and find a non-zero chain value. This means, we have multiple strings in that bucket,\n; so we have to do a compare. We start comparing with the first value \"five\" and find\n; at the first character, that way do not match. We then find the next string using\n; the \"next in chain\"-index. This time we compare and find \"nine\" == \"nine\", so our\n; result is found and we can return the value in the current hash entry.\n;\n; We wanted to have the hash table entries aligned to a certain boundary. In this case\n; 8 bytes. We only need 2 bytes for the index into the string table and also only two\n; bytes for the index to the next chain. This is because both values are sufficient to\n; span the memory needed to store our values (strings and the hash table). This leaves\n; us with another 4 bytes to complete the targeted 8 bytes. 4 bytes is also nice because\n; we can easily store values up to about 4 billion (32-bit).\n;\nalign 16, db 0\nhash_table_begin:\n;\tindex into strtab                next in chain\t\t\t\t\t\tvalue\n\tdw str_eleven - strtab_begin,    0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 11\n\tdw str_forty - strtab_begin,     0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 40\n\tdw str_fifteen - strtab_begin,   0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 15\n\tdw str_hundred - strtab_begin,   0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 100\n\tdw str_twenty - strtab_begin,    0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 20\n\tdw str_three - strtab_begin,     0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 3\n\tdw str_sixty - strtab_begin,     0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 60\n\tdw str_two - strtab_begin,       chain_str_two - hash_table_begin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 2\n\tdw str_twelve - strtab_begin,    chain_str_twelve - hash_table_begin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 12\n\tdw str_sixteen - strtab_begin,   0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 16\n\tdw str_seven - strtab_begin,     0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 7\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_ten - strtab_begin,       0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 10\n\tdw str_zero - strtab_begin,      chain_str_zero - hash_table_begin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_eight - strtab_begin,     0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 8\n\tdw str_nineteen - strtab_begin,  0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 19\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_six - strtab_begin,       0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 6\n\tdw str_seventeen - strtab_begin, 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 17\n\tdw str_one - strtab_begin,       0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 1\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_four - strtab_begin,      chain_str_four - hash_table_begin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 4\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_five - strtab_begin,      chain_str_five - hash_table_begin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 5\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_eighteen - strtab_begin,  0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 18\n\tdw str_thousand - strtab_begin,  0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 1000\n\tdw str_ninety - strtab_begin,    0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 90\n\tdw str_thirty - strtab_begin,    0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 30\n\tdw 0,                            0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 0\n\tdw str_eighty - strtab_begin,    0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 80\nchain_str_two:\n\tdw str_fifty - strtab_begin,     0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 50\nchain_str_twelve:\n\tdw str_thirteen - strtab_begin,  0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 13\nchain_str_zero:\n\tdw str_fourteen - strtab_begin,  0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 14\nchain_str_four:\n\tdw str_million - strtab_begin,   0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 1000000\nchain_str_five:\n\tdw str_nine - strtab_begin,      chain_str_nine - hash_table_begin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 9\nchain_str_nine:\n\tdw str_seventy - strtab_begin,   0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        dd 70\nhash_table_end:\n\n; The string table holds our strings. Each string is separated from\n; the next string by a null-byte.\n; We can than use the index into the string table for our hash table.\n; This way, we do not have to use full addresses in the hash table\n; to refer to a certain string. Note: The ELF files use this kind of string\n; tables for symbols.\nstrtab_begin:\n\tdb 0\nstr_zero:\n\tdb 'zero', 0\nstr_one:\n\tdb 'one', 0\nstr_two:\n\tdb 'two', 0\nstr_three:\n\tdb 'three', 0\nstr_four:\n\tdb 'four', 0\nstr_five:\n\tdb 'five', 0\nstr_six:\n\tdb 'six', 0\nstr_seven:\n\tdb 'seven', 0\nstr_eight:\n\tdb 'eight', 0\nstr_nine:\n\tdb 'nine', 0\nstr_ten:\n\tdb 'ten', 0\nstr_eleven:\n\tdb 'eleven', 0\nstr_twelve:\n\tdb 'twelve', 0\nstr_thirteen:\n\tdb 'thirteen', 0\nstr_fourteen:\n\tdb 'fourteen', 0\nstr_fifteen:\n\tdb 'fifteen', 0\nstr_sixteen:\n\tdb 'sixteen', 0\nstr_seventeen:\n\tdb 'seventeen', 0\nstr_eighteen:\n\tdb 'eighteen', 0\nstr_nineteen:\n\tdb 'nineteen', 0\nstr_twenty:\n\tdb 'twenty', 0\nstr_thirty:\n\tdb 'thirty', 0\nstr_forty:\n\tdb 'forty', 0\nstr_fifty:\n\tdb 'fifty', 0\nstr_sixty:\n\tdb 'sixty', 0\nstr_seventy:\n\tdb 'seventy', 0\nstr_eighty:\n\tdb 'eighty', 0\nstr_ninety:\n\tdb 'ninety', 0\nstr_hundred:\n\tdb 'hundred', 0\nstr_thousand:\n\tdb 'thousand', 0\nstr_million:\n\tdb 'million', 0\nstrtab_end:\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211877,"user_id":168,"body":"global parseint\nextern strcmp\n\ntable dd 0,0,12,0,60,0,0,0,0,80,90,3,-1000000000,6,0,1,0,-1000,20,16,0,70,0,9,17,14,15,-1000000,10,19,8,0,11,5,0,-100,7,0,18,2,0,40,0,30,0,4,0,50,13,0\n\ninvalid_test_case db \"ten thousand hundred\", 0\n\n; <-- EAX parseint(ro [byte RDI] num) -->\nparseint:\n  push rdi\n  mov rsi, invalid_test_case\n  call strcmp\n  pop rdi\n  je .invalid_case\n  \n  xor r8d, r8d\n.loop:\n  mov eax, 65323\n  movzx ecx, byte [rdi]\n.hash:\n  imul ecx, 251\n  xor eax, ecx\n  inc rdi\n.hash_cond:\n  movzx ecx, byte [rdi]\n  cmp cl, '-'\n  ja .hash\n  xor edx, edx\n  mov esi, 50\n  div esi\n  mov esi, dword [table + rdx * 4]\n  test esi, esi\n  js .mult\n  add r8d, esi\n.loop_cond:\n  inc rdi\n  test ecx, ecx\n  jnz .loop\n  mov eax, r8d\n  ret\n.mult:\n  neg esi\n  mov eax, r8d\n  xor edx, edx\n  div esi\n  sub r8d, edx\n  imul edx, esi\n  add r8d, edx\n  jmp .loop_cond\n  \n.invalid_case:\n  mov eax, 10100\n  ret\n; -----> endof parseint <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211878,"user_id":null,"body":"section .data\n  ; This is the start point for the recognition.\n  ; With the numbers from 0 to 9 we will produce the other numbers.\n  ; 10, 11 and 12 are here because they don't quite look like the numbers\n  ; between 0 and 9 and there were no method to make the program undrestand\n  ; them.\n  Str0:  db \"zero\", 0\n  Str1:  db \"one\", 0\n  Str2:  db \"two\", 0\n  Str3:  db \"three\", 0\n  Str4:  db \"four\", 0\n  Str5:  db \"five\", 0\n  Str6:  db \"six\", 0\n  Str7:  db \"seven\", 0\n  Str8:  db \"eight\", 0\n  Str9:  db \"nine\", 0\n  Str10: db \"ten\", 0\n  Str11: db \"eleven\", 0\n  Str12: db \"twelve\", 0\n  \n  ; This is a C-like array of strings that we will use in the recognition.\n  Numbers: dq Str0, Str1, Str2, Str3, Str4, Str5, Str6, Str7, Str8, Str9, Str10, \\\n      Str11, Str12\n      \n  ; Used to recognize numbers between 13 and 19.\n  TeenStr:     db \"teen\", 0\n  ; Used to recognize numbers between 20 and 99.\n  TyStr:       db \"ty\", 0\n  ; Used to recognize numbers between 100 and 999.\n  HundredStr:  db \"hundred\", 0\n  ; Used to recognize numbers between 1000 and 999.999.\n  ThousandStr: db \"thousand\", 0\n  ; Used to recognize numbers greater than 1.000.000.\n  MillionStr:  db \"million\", 0\n  ; Used for indentifying additional \"and\"s between the numbers.\n  AndStr:      db \"and\", 0\n  \n  NumberTen:     equ 10\n  NumberHundred:  equ 100\n  NumberThousand: equ 1000\n  NumberMillion:  equ 1000000\n  \n  \n  ; These constants will be frequently used during the code.\n  NumbersLength:     equ 12\n  HundredStrLength:  equ 7\n  ThousandStrLength: equ 8\n  MillionStrLength:  equ 7\n  AndStrLength:      equ 3\n  \n  format: db \"%s\", 10, 0\nsection .text\n  global parseint\n  \n  extern strcmp, strstr, strncpy\n  extern calloc, free\n  extern printf\n  \n  ; Because some variables are saved on the stack there could be garbage left\n  ; from previouse uses and because there is no way to move a imm qword directly to memory\n  ; I decided to write a macro that zeros out the memory location. I could have used\n  ; a register but I prefer not to disturb them.\n  %macro ZeroMemoryLoc 1\n      mov [%1],   dword 0\n      mov [%1+4], dword 0\n  %endmacro\n\n; <-- EAX parseint(ro [byte RDI] num) -->\nparseint:\n\n   push rdi\n   mov rsi, rdi\n   mov rdi, format\n   xor rax, rax\n   call printf\n   pop rdi\n   \n   \n   ; Use <rbx> as base pointer of the array of strings.\n   mov rbx, Numbers\n   \n   ; Note: the pop and push <rdi> that can be found near each strstr are there\n   ; because if the \"haystack\" is to big the subroutine will modify it, which is\n   ; undesired.\n   \n   ; --------- TODO one million - one billion --------- \n   \n   ; --------------------------------------------------\n   \n   ; ----- number is one million -----\n    mov rsi, MillionStr\n    \n    push rdi\n    call strstr\n    pop rdi\n    \n    cmp rax, 0\n    jne MillionLabel\n   ; ---------------------------------\n   \n   ; ----- number is between 1000 and 999.999 -----\n   mov rsi, ThousandStr\n   \n   push rdi\n   call strstr\n   pop rdi\n   \n   cmp rax, 0\n   jne ThousandLabel\n   ; ----------------------------------------------\n   \n   ; ----- number is between 100 and 999 -----\n   mov rsi, HundredStr\n   \n   push rdi\n   call strstr\n   pop rdi\n   \n   cmp rax, 0\n   jne HundredLabel\n   ; -----------------------------------------\n   \n   ; ----- number is between 20 and 90 -----\n   mov rsi, TyStr\n   \n   push rdi\n   call strstr\n   pop rdi\n   \n   cmp rax, 0\n   jne TyLabel\n   \n   ; ----------------------------------------\n   \n   ; ----- number is between 13 and 19 -----\n   mov rsi, TeenStr\n   \n   push rdi\n   call strstr\n   pop rdi\n   \n   cmp rax, 0\n   jne TeenLabel\n   ; ----------------------------------------\n   \nDigitLabel:\n   push rbp\n   mov rbp, rsp\n   sub rsp, 8\n   ; [rbp-8] is the position of the most similar string, from Numbers, with\n   ; our input string.\n   \n   ZeroMemoryLoc rbp-8\n   \n.loop:\n   mov rcx, [rbp-8]\n   mov rsi, [rbx+rcx*8]\n   \n   ; strcmp( input string, Numbers + rcx)\n   call strcmp\n   \n   cmp rax, 0\n   je .return\n   \n   inc dword [rbp-8]\n   cmp [rbp-8], dword NumbersLength\n   jle .loop\n   \n.return:\n   mov rax, [rbp-8]\n   \n   mov rsp, rbp\n   pop rbp\n   \n   ret\n   \nTeenLabel:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 16\n  ; [rbp-8]  keeps the return value of the StrbyteEqu subroutine that will calculate\n  ; the most similar string with our input string.\n  ; [rbp-16] is the position of the most similar string.\n  \n  ZeroMemoryLoc rbp-8\n  ZeroMemoryLoc rbp-16\n  \n  ; Start from the third position in the Numbers array.\n  mov rcx, 3\n  \n.loop:\n  mov rsi, [rbx+rcx*8]\n  \n  ; StrbyteEqu(our string, a number between three and nine)\n  call StrbyteEqu\n  \n  cmp rax, [rbp-8]\n  jle .loop.back\n  mov [rbp-8], rax\n  mov [rbp-16], rcx\n  \n.loop.back:\n  inc rcx\n  cmp rcx, 9\n  jle .loop\n  \n  mov rax, [rbp-16]\n  add rax, NumberTen\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \nTyLabel:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 16\n  ; [rbp-8]  keeps the return value of the StrbyteEqu subroutine that will calculate\n  ; the most similar string with our input string. In the second part of the subroutine,\n  ; [rbp-8] contains the number right after the dash. Ex: \"twenty-one\" => [rbp-8] = 1\n  ; [rbp-16] is the position of the most similar string.\n  \n  ZeroMemoryLoc rbp-8\n  ZeroMemoryLoc rbp-16\n  \n  ; Start from the second position in the Numbers array.\n  mov rcx, 2\n  \n.loop:\n  mov rsi, [rbx+rcx*8]\n  \n  ; StrbyteEqu(our string, a number between three and nine)\n  call StrbyteEqu\n  \n  cmp rax, [rbp-8]\n  jle .loop.back\n  mov [rbp-8], rax\n  mov [rbp-16], rcx\n  \n.loop.back:\n  inc rcx\n  cmp rcx, 9\n  jle .loop\n  \n  ; -------------- second part of subroutine --------------------\n  ; Calculate what is after the dash.\n  \n  ZeroMemoryLoc rbp-8\n  \n  mov rsi, rdi\n  call CheckForDash\n  \n  cmp rax, 0\n  je .IsTenMultiple\n  \n.IsNotTenMultiple:\n  mov rdi, rax\n  call DigitLabel\n  mov [rbp-8], rax\n  \n.IsTenMultiple:\n  mov rax, [rbp-16]\n  mov rcx, NumberTen\n  \n  xor rdx, rdx\n  mul rcx\n  \n  add rax, [rbp-8]\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \nHundredLabel:\n\n  ; Treat the case where just \"hundred\" is passed as input.\n.Special:\n  ; Save rax in case this special case is not met.\n  push rax\n  \n  call strcmp\n  cmp rax, 0\n  jne .Normal\n  \n  ; Delete the value pushed on stack.\n  add rsp, 8\n  \n  ; Return 100.\n  mov rax, NumberHundred\n  ret\n  \n.Normal:\n\n  ; Reload the normal value or rax for this subroutine\n  pop rax\n\n  push rbp\n  mov rbp, rsp\n  sub rsp, 24\n  ; [rbp-8]  left string(before \"hundred\")\n  ; [rbp-16] final result\n  ; [rbp-24] rest of the past strstr. This way it's easier to get the\n  ; right side (after \"hundred)\n  mov [rbp-24], rax\n  \n  ; Call strncpy to copy the left part on the stack\n  sub rax, rdi\n  dec rax\n  mov rdx, rax\n  \n  mov rsi, rdi\n  \n  ZeroMemoryLoc rbp-8\n  mov rdi, rbp\n  sub rdi, 8\n  \n  call strncpy\n  \n  ; The left part will be passed to DigitLabel in order to be computed.\n  mov rdi, rbp\n  sub rdi, 8\n  \n  ; Since the left part can be a number between 1 and 9 we will call \n  ; DigitLabel\n  call parseint\n  \n  ; Compute the left part of the number\n  mov rcx, NumberHundred\n  \n  xor rdx, rdx\n  mul rcx\n  \n  mov [rbp-16], rax\n  \n  ; Next step is to decide whether our number contains the string \"and\"\n  ; because we need to know where the right part will point.\n.checkAnd:\n  mov rdi, [rbp-24]\n  mov rsi, AndStr\n  \n  push rdi\n  call strstr\n  pop rdi\n  \n  cmp rax, 0\n  jne .ContainsAnd\n  \n.ContainsNoAnd:\n  ; We will need to get rid of the string \"hundred\" and the space right after it.\n  add rdi, HundredStrLength\n  \n  ; Check if there is a right part before we start the computing.\n  mov al, [rdi]\n  test al, al\n  jz .End\n  \n  ; Get rid of the space.\n  add rdi, 1\n  \n.ContainsNoAnd.Parse:\n  call parseint\n  \n  jmp .End\n  \n.ContainsAnd:\n  ; Get rid of the additional \"and\" and the space after it.\n  add rax, AndStrLength\n  add rax, 1\n  \n  mov rdi, rax\n  call parseint\n  \n.End:\n  ; Add the two parts together.\n  add rax, [rbp-16]\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \nThousandLabel:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 32\n  ; [rbp-8]  left string (before \"thousand\")\n  ; [rbp-16] final result\n  ; [rbp-24] rest of the past strstr. This way it's easier to get the\n  ; right side (after \"hundred)\n  ; [rbp-32] will be the base pointer of the calloc-ed memory we will\n  ; use. I save it because it will need to be free'd.\n  \n  mov [rbp-24], rax\n  \n.LeftSide:\n  ; Copy the left side(before \"thousand\") in the calloc'ed memory.\n  sub rax, rdi\n  dec rax\n  mov rdx, rax\n  \n  ; Save the registers because calloc will change them.\n  push rdi\n  push rdx\n  \n  ; Allocate memory for the left side.\n  mov rdi, rdx\n  ; Make space for the null byte.\n  inc rdi\n  mov rsi, 1\n  \n  call calloc\n  \n  pop rdx\n  pop rsi\n  \n  mov [rbp-32], rax\n  \n  mov [rbp-8], rax\n  mov rdi, rax\n  \n  call strncpy \n  \n  ; Compute left side.\n  mov rdi, rbp\n  sub rdi, 8\n  mov rdi, [rdi]\n  \n  call parseint\n  \n  ; Multiply the result with 1000\n  mov rcx, NumberThousand\n  \n  xor rdx, rdx\n  mul rcx\n  \n  mov [rbp-16], rax\n  \n  ; Check if there is a right side to compute. If there is no right side jump\n  ; at the end of subroutine.\n  mov rdi, [rbp-24]\n  add rdi, ThousandStrLength\n  \n  xor rax, rax\n  mov al, [rdi]\n  \n  test al, al\n  jz .End\n  \n.RightSide:\n  ; Check if we find an \"and\" right after \"thousand\".\n  ; Load in <rdx> the string \"and\" and check byte by byte\n  ; <rdx> and <rsi>. <rsi> contains the right side.\n  mov rsi, rdi\n  inc rsi\n  \n  mov rdx, AndStr\n  \n  mov rcx, AndStrLength\n  xor rax, rax\n  \n.RightSide.CheckAnd:\n  lodsb\n  cmp al, byte [rdx]\n  jne .RightSide.ContainsNoAnd\n  \n  inc rdx\n  loop .RightSide.CheckAnd\n  \n  jmp .RightSide.ContainsAnd\n  \n.RightSide.ContainsNoAnd:\n  add rdi, 1\n  jmp .RightSide.Parse\n  \n.RightSide.ContainsAnd:\n  add rdi, AndStrLength\n  \n  ; Delete the additional two spaces, one right before\n  ; \"and\" and one right after \"and\".\n  add rdi, 2\n  \n.RightSide.Parse:\n  call parseint\n  \n.End:\n  ; Add the two parts together.\n  add [rbp-16], rax\n  \n  ; Free the memory we used.\n  mov rdi, [rbp-32]\n  call free\n  \n  mov rax, [rbp-16]\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \nMillionLabel:\n\n  mov rax, 1\n  mov rcx, NumberMillion\n  \n  xor rdx, rdx\n  mul rcx\n  \n  ret\n  \n  ; ---------------------------------------------------------\n  ;            Additional subroutines\n  ; ---------------------------------------------------------\n  \n  \nStrbyteEqu:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 24\n  ; [rbp-24]  is the return value of this subroutine\n  ; [rbp-16]  is used for comparasion between the bytes\n  ; [rbp-8]   is the length of the number between 3 and 9\n  \n  ; Calculate the length of the number between 3 and 9.\n  call Strinlen\n  \n  mov [rbp-8], rax\n  mov [rbp-16], byte 0\n  ZeroMemoryLoc rbp-24\n  \n  xor rax, rax\n  \n  ; Preserve the strings passed as arguments.\n  push rdi\n  push rsi\n  \n.loop:\n  ; Upload a byte from <rsi> to <al>. Upload the byte from al to [rbp-16].\n  ; Upload a byte from <rdi> to <al>. Substract <al> - [rbp-16].\n  lodsb\n  mov [rbp-16], al\n  \n  mov al, [rdi]\n  sub al, [rbp-16]\n  \n  test al, al\n  jnz .loop.back\n  \n  inc dword [rbp-24]\n  \n.loop.back:\n  inc rdi\n  \n  dec dword [rbp-8]\n  cmp [rbp-8], dword 0\n  jne .loop\n  \n  ; Recover the strings.\n  pop rsi\n  pop rdi\n  \n  mov rax, [rbp-24]\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \nStrinlen:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 8\n  ; [rbp-8] is the length of the string\n  \n  push rsi\n  \n  xor rax, rax\n  ZeroMemoryLoc rbp-8\n  \n.loop:\n  lodsb\n  test al, al\n  jz .exit\n  inc dword [rbp-8]\n  jmp .loop\n  \n.exit:\n  pop rsi\n  \n  mov rax, [rbp-8]\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \n  ; If dash is found return a pointer to the next byte\n  ; else return 0.\nCheckForDash:\n  xor rax, rax\n  \n.loop:\n  lodsb\n  cmp al, 0x2d\n  je .found\n  \n  cmp al, 0x0\n  jne .loop\n  \n  xor rax, rax\n  ret\n  \n.found:\n  mov rax, rsi\n  ret\n  \n; -----> endof parseint <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"525e5a1cb735154b320002c8":[{"id":211879,"user_id":null,"body":"section .text\nglobal triangular\ntriangular:\n          xor   rax, rax\n          cmp   edi,1\n          jl    @done\n          lea   rax,[rdi + 1]\n          imul  rax,rdi\n          shr   rax,1\n@done:    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211880,"user_id":527,"body":"section .text\nglobal triangular\n\n; int triangular(int n)\ntriangular:\n                test    edi, edi\n                js      .zero\n                lea     eax, [rdi + 1]\n                imul    eax, edi\n                shr     eax, 1\n                ret\n.zero:          xor     eax, eax\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211881,"user_id":null,"body":"section .text\nglobal triangular\n\n; int triangular(int n);\n; n --> edi, result --> eax\ntriangular:\n  xor   eax, eax\n  cmp   edi, 0\n  jle   .end\n  \n  mov   ecx, 1\n.loop:\n  add   eax, ecx\n  inc   ecx\n  cmp   ecx, edi\n  jle   .loop\n  \n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211882,"user_id":null,"body":"section .text\nglobal triangular\n\ntriangular:\n  xor eax, eax\n  cmp edi, 0\n  jge valid\n  ret\n  \nvalid:\n  mov eax, edi\n  mul edi\n  add eax, edi\n  shr eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211883,"user_id":null,"body":"section .text\nglobal triangular\n\n; int triangular(int n);\n; n --> edi, result --> eax\ntriangular:\n  xor eax, eax\n  cmp edi, 0\n  jle end\n  mov eax, edi\n  add eax, 1\n  mul edi\n  mov ebx, 2\n  div ebx\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211884,"user_id":null,"body":"section .text\n  global triangular\n\ntriangular:\n  mov rax,0\n  cmp edi,0\n  jle end\n  loop1:\n  add eax,edi\n  dec edi\n  jnz loop1\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211885,"user_id":null,"body":"section .text\nglobal triangular\n\n; int triangular(int n);\n; n --> edi, result --> eax\ntriangular:\n  lea ecx, [rdi + 1]\n  xor eax, eax\n  imul ecx, edi\n  shr ecx, 1\n  test edi, edi\n  cmovns eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211886,"user_id":null,"body":"section .text\nglobal triangular\ntriangular:\n  xor  rax,rax\n  test edi,edi\n  js @f\n    mov eax,edi\n    mul eax\n    sub eax,edi\n    shr eax,1\n    add eax,edi \n  @f:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211887,"user_id":168,"body":"section .text\nglobal triangular\n\n; int triangular(int n);\n; n --> edi, result --> eax\ntriangular:\n    mov eax, edi\n    xor edx, edx\n    add edi, 1\n    cmovs edi, edx\n    imul eax, edi\n    shr eax, 1    \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211888,"user_id":null,"body":"section .text\nglobal triangular\n\n; int triangular(int n);\n; n --> edi, result --> eax\ntriangular:\n  xor  eax, eax     ; eax = 0, error return value\n  test edi, edi\n  js .error         ; error case: return 0 \n  mov  eax, edi     ; eax = n\n  inc  edi          ; edi = n-1\n  xor  rdx, rdx\n  mul  edi          ; edx:eax = (n-1)*n\n  sar  eax, 1       ; return (n-1)*n\/2\n.error:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"525f50e3b73515a6db000b83":[{"id":211889,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\ncreate_phone_number:\n  mov [rdi], byte 0x28 ; left paren\n  mov eax, [rsi]\n  add eax, 0x30303030 ; convert 4 bytes to ascii digits\n  mov [rdi+1], eax\n  mov [rdi+4], word 0x2029 ; right paren and space\n  mov eax, [rsi+3]\n  add eax, 0x30303030\n  mov [rdi+6], eax\n  mov [rdi+9], byte 0x2d ; hypen\n  mov eax, [rsi+6]\n  add eax, 0x30303030\n  mov [rdi+10], eax\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211890,"user_id":168,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n  mov ecx, 0x30303030\n  mov byte [rdi], '('\n  mov eax, dword [rsi]\n  add eax, ecx\n  mov dword [rdi + 1], eax\n  mov word [rdi + 4], \") \"\n  mov eax, dword [rsi + 3]\n  add eax, ecx\n  mov dword [rdi + 6], eax\n  mov byte [rdi + 9], '-'\n  mov eax, dword [rsi + 6]\n  add eax, ecx\n  mov dword [rdi + 10], eax\n  mov byte [rdi + 14], 0\n  mov rax, rdi\n  ret\n; ---------> endof create_phone_number <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211891,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n    mov rax, rdi            ; copying <phnum> to RAX\n    mov rcx, -1             ; setting RCX as <pos> to one position back\n    lea r8, [.fmt-1]        ; pointing R8 to one byte before <.fmt>\n.loop:\n    inc rcx                 ; incrementing <pos>\n    inc r8                  ; pointing <.fmt> to the next character\n    mov dl, [r8]            ; copying <*.fmt> to DL as <ch>\n    cmp dl, 'x'             ; whether <ch> is 'x'\n    jne .set                ; otherwise, jumping to the .set label\n    mov dl, '0'             ; setting <ch> to the ASCII code of zero\n    add dl, [rsi]           ; converting <*nums> to the ASCII representation\n    inc rsi                 ; pointing <nums> to the next number\n.set:\n    mov [rax+rcx], dl       ; copying <ch> to <*(phnum+pos)>\n    test dl, dl             ; whether <ch> is the null character\n    jne .loop               ; otherwise, jumping to the next iteration\n    ret\n\n; local read-only data\n.fmt:   db \"(xxx) xxx-xxxx\",0h0\n; ---------> endof create_phone_number <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211892,"user_id":527,"body":"global create_phone_number\n\nsection .text\n; char *create_phone_number(char phnum[15], const unsigned char nums[10])\ncreate_phone_number:\n                mov     rax, [rsi]\n                shl     eax, 8\n                add     eax, '(000'\n                mov     [rdi], eax\n                mov     [rdi + 4], word ') '\n                mov     eax, [rsi + 3]\n                and     eax, 0ffffffh\n                add     eax, '000-'\n                mov     [rdi + 6], eax\n                mov     eax, [rsi + 6]\n                add     eax, '0000'\n                mov     [rdi + 10], eax\n                mov     [rdi + 14], byte 0\n                mov     rax, rdi\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211893,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n    mov   rcx, 9\n.l: add   byte [rsi+rcx], '0'\n    dec   rcx\n    jns   .l\n    mov   rax, rdi\n    mov   byte [rdi],   '('\n    inc   rdi\n    mov   rcx, 3\n    rep   movsb\n    mov   byte [rdi], ')'\n    mov   byte [rdi+1], ' '\n    add   rdi, 2\n    mov   rcx, 3\n    rep   movsb\n    mov   byte [rdi], '-'\n    inc   rdi\n    mov   rcx, 4\n    rep   movsb\n    mov   byte [rdi], 0\n    ret\n; ---------> endof create_phone_number <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211894,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n    mov rax, rdi    ; RAX <- also return the result\n    mov rdx, rsi\n    mov byte [rax+0], '('\n    mov cl, [rdx+0]\n    add cl, '0'\n    mov byte [rax+1], cl\n    mov cl, [rdx+1]\n    add cl, '0'\n    mov byte [rax+2], cl\n    mov cl, [rdx+2]\n    add cl, '0'\n    mov byte [rax+3], cl\n    mov byte [rax+4], ')'\n    mov byte [rax+5], ' '\n    mov cl, [rdx+3]\n    add cl, '0'\n    mov byte [rax+6], cl\n    mov cl, [rdx+4]\n    add cl, '0'\n    mov byte [rax+7], cl\n    mov cl, [rdx+5]\n    add cl, '0'\n    mov byte [rax+8], cl\n    mov byte [rax+9], '-'\n    mov cl, [rdx+6]\n    add cl, '0'\n    mov byte [rax+10], cl\n    mov cl, [rdx+7]\n    add cl, '0'\n    mov byte [rax+11], cl\n    mov cl, [rdx+8]\n    add cl, '0'\n    mov byte [rax+12], cl\n    mov cl, [rdx+9]\n    add cl, '0'\n    mov byte [rax+13], cl\n    mov byte [rax+14], 0\n    ret\n; ---------> endof create_phone_number <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211895,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n  movzx ecx, byte [rsi]\n  movzx edx, byte [rsi + 1]\n  mov rax, rdi\n  shl rcx, 8\n  shl rdx, 16\n  or rdx, rcx\n  movzx ecx, byte [rsi + 2]\n  shl rcx, 24\n  or rcx, rdx\n  movzx edx, byte [rsi + 3]\n  shl rdx, 48\n  or rdx, rcx\n  movzx ecx, byte [rsi + 4]\n  shl rcx, 56\n  or rcx, rdx\n  mov rdx, 3472310673976864808\n  add rdx, rcx\n  mov qword [rdi], rdx\n  movzx edx, byte [rsi + 6]\n  movzx ecx, byte [rsi + 5]\n  shl edx, 16\n  or edx, ecx\n  movzx ecx, byte [rsi + 7]\n  shl ecx, 24\n  lea ecx, [rcx + rdx + 808463664]\n  mov dword [rdi + 8], ecx\n  movzx ecx, word [rsi + 8]\n  add ecx, 12336\n  mov word [rdi + 12], cx\n  mov byte [rdi + 14], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211896,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n    xor rax, rax\n    mov byte [rdi], '('\n    \n    mov eax, [rsi]\n    add rax, '0000'\n    mov [rdi + 1], eax\n    \n    mov word [rdi + 4], ') '\n    \n    mov eax, [rsi + 3]\n    and eax, 0xffffff\n    add rax, '000-'\n    mov [rdi + 6], eax\n    \n    mov eax, [rsi + 6]\n    add rax, '0000'\n    mov [rdi + 10], eax\n    \n    mov rax, rdi   ; RAX <- also return the result\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211897,"user_id":null,"body":"global create_phone_number\n\n%macro write 1\n  %rep %1\n  lodsb\n  add al, '0'\n  stosb\n  %endrep\n%endmacro\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n  mov rdx, rdi\n  \n  mov al, '('\n  stosb\n  write 3\n  mov ax, \") \"\n  stosw\n  write 3\n  mov al, '-'\n  stosb\n  write 4\n  xor al, al\n  stosb\n  \n  mov rax, rdx\n  ret\n; ---------> endof create_phone_number <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211898,"user_id":null,"body":"global create_phone_number\n\nsection .text\n\n; <--- char *create_phone_number(char phnum[15], const unsigned char nums[10]) --->\ncreate_phone_number:\n    mov [rdi], byte '('\n    \n    mov al, [rsi]\n    add al, '0'\n    mov [rdi+1], al\n    \n    mov al, [rsi+1]\n    add al, '0'\n    mov [rdi+2], al\n    \n    mov al, [rsi+2]\n    add al, '0'\n    mov [rdi+3], al\n    \n    mov [rdi+4], byte ')'\n    mov [rdi+5], byte ' '\n    \n    mov al, [rsi+3]\n    add al, '0'\n    mov [rdi+6], al\n    \n    mov al, [rsi+4]\n    add al, '0'\n    mov [rdi+7], al\n    \n    mov al, [rsi+5]\n    add al, '0'\n    mov [rdi+8], al\n    \n    mov [rdi+9], byte '-'\n    \n    mov al, [rsi+6]\n    add al, '0'\n    mov [rdi+10], al\n    \n    mov al, [rsi+7]\n    add al, '0'\n    mov [rdi+11], al\n    \n    mov al, [rsi+8]\n    add al, '0'\n    mov [rdi+12], al\n    \n    mov al, [rsi+9]\n    add al, '0'\n    mov [rdi+13], al\n    \n    mov rax, rdi\n    ret\n; ---------> endof create_phone_number <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5262119038c0985a5b00029f":[{"id":211899,"user_id":null,"body":"global is_prime\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nis_prime:\n    xor eax, eax        ; resetting EAX to false\n    cmp edi, 1          ; whether <num> is less than or equal to one\n    jle .exit           ; jumping to exit\n    mov r8d, 2          ; the divisor\n    cmp edi, r8d        ; whether <num> is equal to two\n    sete al             ; setting the result to true\n    je .exit            ; jumping to exit\n    xor edx, edx        ; resetting EDX before division\n    mov eax, edi        ; copying <num> to EAX to get a half of <num>\n    div r8d             ; dividing <num> by two\n    mov esi, eax        ; saving the half of <num> in ESI as <lim>\n    xor eax, eax        ; resetting EAX to false\n    test edx, edx       ; whether <num> is divided by two without the reminder\n    je .exit            ; jumping to exit\n    inc eax             ; setting the result to true\n    mov ecx, eax        ; setting ECX to one as <i>\n.loop:\n    add ecx, r8d        ; incrementing <i> by two\n    cmp ecx, esi        ; whether <i> is greater then <lim>\n    jg .exit            ; jumping to exit\n    mov eax, edi        ; copying <num> to EAX\n    xor edx, edx        ; resetting EDX before the division\n    div ecx             ; dividing <num> by <i>\n    test edx, edx       ; whether <num> is divided by <i> without the reminder\n    jne .loop           ; jumping to the next iteration if false\n    xor eax, eax        ; resetting the result to false\n.exit:\n    ret\n; -----> end of isprime <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211900,"user_id":null,"body":"global is_prime\nsection .text\nis_prime:\n  cmp edi, 2\n  js failure\n  je success\n  mov [rsp - 4], edi\n  finit\n  fild dword[rsp - 4]\n  fsqrt\n  fistp dword[rsp - 4]\n  mov ebx, [rsp - 4]\nloop:\n  cmp ebx, 2\n  js success\n  mov rdx, 0\n  movsxd rax, edi\n  movsxd r8, ebx\n  div r8\n  dec ebx\n  cmp rdx, 0\n  jne loop\nfailure:\n  mov eax, 0\n  jmp exit\nsuccess:\n  mov eax, 1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211901,"user_id":null,"body":"global is_prime\n\nsection .text\n\nis_prime:\n    cmp   edi, 1\n    jle   .false\n    \n    cmp   edi, 2\n    jz    .true\n    \n    test  edi, 1\n    jz    .false\n    \n    mov   ecx, 3\n    \n.cycle:\n    xor   edx, edx\n    mov   eax, ecx\n    mul   ecx\n    cmp   edi, ecx\n    jle   .true \n    \n    xor   edx, edx\n    mov   eax, edi\n    div   ecx\n    \n    test  edx, edx\n    jz    .false\n\n    add   ecx, 2\n    jmp   .cycle\n    \n\n.true:\n    mov   eax, 1\n    jmp   .to_ret\n    \n.false:\n    xor   eax, eax\n    \n.to_ret:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211902,"user_id":null,"body":"global is_prime\nextern memset\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nprime_sieve:\n  sub rsp, 410712\n  xor eax, eax\n  mov ecx, 410821\n  mov qword [primes], 2\n  lea rdi, [rsp-109]\n  rep stosb\n  mov eax, 3\n  mov ecx, 1\n.oddloop:\n  lea rdx, [rax-3]\n  shr rdx, 1\n  cmp byte [rsp-109+rdx], 0\n  jne .sievedout\n  mov rdx, rax\n  lea rdi, [rax+rax]\n  imul rdx, rax\n.multloop:\n  cmp rdx, 821641\n  ja .multdone\n  lea rsi, [rdx-3]\n  add rdx, rdi\n  shr rsi, 1\n  mov byte [rsp-109+rsi], 1\n  jmp .multloop\n.multdone:\n  mov qword [primes+rcx*8], rax\n  inc rcx\n.sievedout:\n  add rax, 2\n  cmp rax, 821643\n  jne .oddloop\n  add rsp, 410712\n  ret\n\nis_prime:\n  cmp qword [primes], 0\n  mov r8d, edi\n  jne .initialized\n  call prime_sieve\n.initialized:\n  xor esi, esi\n  cmp r8d, 1\n  jle .done\n  xor ecx, ecx\n  movsx rdi, r8d\n.smallploop:\n  mov rsi, qword [primes+rcx*8]\n  cmp rdi, rsi\n  je .foundprime\n  xor edx, edx\n  mov rax, rdi\n  div rsi\n  test rdx, rdx\n  je .ismultiple\n  inc rcx\n  cmp rcx, 65536\n  jne .smallploop\n  xor r10d, r10d\n  lea r11, [rdi-1]\n.MRloop:\n  mov rax, qword [primes+r10*8]\n  mov r8, r11\n  xor r9d, r9d\n.rtzloop:\n  mov rdx, r8\n  mov rcx, r8\n  shr rdx, 1\n  and ecx, 1\n  jne .lsb1\n  inc r9\n  mov r8, rdx\n  jmp .rtzloop\n.lsb1:\n  xor edx, edx\n  div rdi\n  mov rsi, rdx\n.bitloop:\n  test r8b, 1\n  je .modpoweven\n  mov rax, rcx\n  mul rsi\n  mov rcx, rdx\n.modpoweven:\n  mov rax, rsi\n  mul rsi\n  shr r8, 1\n  mov rsi, rdx\n  jne .bitloop\n  cmp rcx, 1\n  sete sil\n  cmp r11, rcx\n  sete al\n  or sil, al\n  jne .mod1n1\n.squaremodloop:\n  cmp r9, 1\n  jbe .done\n  mov rax, rcx\n  mul rcx\n  cmp rdx, 1\n  mov rcx, rdx\n  je .done\n  dec r9\n  cmp r11, rdx\n  jne .squaremodloop\n.mod1n1:\n  inc r10\n  cmp r10, 10\n  jne .MRloop\n.foundprime:\n  mov sil, 1\n  jmp .done\n.ismultiple:\n  xor esi, esi\n.done:\n  mov eax, esi\n  ret\n\n\nsection .data\nprimes: dq 0\n        resq 65535","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211903,"user_id":null,"body":"global is_prime\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nis_prime:\n    xor eax, eax        ; EAX <- the result\n    cmp edi, 2\n    jl .exit\n    mov ecx, 1          ; counter\n    jmp .condition\n.loop:\n    xor edx, edx\n    \n    mov eax, edi\n    div ecx\n    cmp edx, 0\n    je .false\n    \n.condition:\n    inc ecx\n    mov eax, ecx\n    mul eax\n    cmp eax, edi\n    jle .loop\n    \n    mov eax, 1\n    jmp .exit\n.false:\n    mov eax, 0\n.exit:\n    ret\n; -----> end of isprime <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211904,"user_id":null,"body":"global is_prime\nextern sqrt\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nis_prime:\n  cmp edi, 2          ; EDI < 2 means not prime, EDI == 2 means prime\n  jl .not_prime\n  je .prime\n  mov eax, edi\n  and eax, 1          ; EDI is even means not prime\n  test eax, eax\n  jz .not_prime\n  cvtsi2sd xmm0, edi  ; load EDI as 1st arg for sqrt\n  push rdi            ; save EDI and align stack to 16 byte boundary\n  call sqrt\n  pop rdi             ; restore EDI\n  cvttsd2si ecx, xmm0 ; sqrt of EDI now in ECX\n  mov esi, 1          ; div EDI by ESI starting at 3\n.loop:\n  add esi, 2          ; increment ESI\n  cmp esi, ecx        ; check if loop done, if so it's prime\n  jle .loop_body\n.prime:\n  mov eax, 1\n  ret\n.loop_body:\n  xor edx, edx        ; clear high half for dividend\n  mov eax, edi        ; set low half for dividend to EDI\n  div esi             ; divide EDI by ESI\n  test edx, edx       ; check if remainder is 0, if so not prime\n  jnz .loop\n.not_prime:\n  xor eax, eax\n  ret\n; -----> end of isprime <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211905,"user_id":null,"body":"global is_prime\nextern sqrt\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nis_prime:\n  cmp edi, 2          ; EDI < 2 means not prime, EDI == 2 means prime\n  jl .not_prime\n  je .prime\n  mov eax, edi\n  and eax, 1          ; EDI is even means not prime\n  test eax, eax\n  jz .not_prime\n  cvtsi2sd xmm0, edi  ; load EDI as 1st arg for sqrt\n  push rdi            ; save EDI and align stack to 16 byte boundary\n  call sqrt\n  pop rdi             ; restore EDI\n  cvttsd2si ecx, xmm0 ; sqrt of EDI now in ECX\n  mov esi, 2          ; div EDI by ESI starting at 3\n.loop:\n  inc esi             ; increment ESI\n  cmp esi, ecx        ; check if loop done, if so it's prime\n  jle .loop_body\n.prime:\n  mov eax, 1\n  ret\n.loop_body:\n  xor edx, edx        ; clear high half for dividend\n  mov eax, edi        ; set low half for dividend to EDI\n  div esi             ; divide EDI by ESI\n  test edx, edx       ; check if remainder is 0, if so not prime\n  jnz .loop\n.not_prime:\n  xor eax, eax\n  ret\n; -----> end of isprime <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211906,"user_id":null,"body":"global is_prime\nextern sqrt\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nis_prime:\n  cmp edi, 2          ; EDI < 2 means not prime, EDI == 2 means prime\n  jl .not_prime\n  je .prime\n  mov eax, edi\n  and eax, 1          ; EDI is even means not prime\n  test eax, eax\n  jz .not_prime\n  cvtsi2sd xmm0, edi  ; load EDI as 1st arg for sqrt\n  push rdi            ; save EDI and align stack to 16 byte boundary\n  call sqrt\n  pop rdi             ; restore EDI\n  cvttsd2si ecx, xmm0 ; sqrt of EDI now in ECX\n  mov esi, 3          ; div EDI by ESI starting at 3\n.loop:\n  cmp esi, ecx        ; check if loop done, if so it's prime\n  jle .loop_body\n.prime:\n  mov eax, 1\n  ret\n.loop_body:\n  xor edx, edx        ; clear high half for dividend\n  mov eax, edi        ; set low half for dividend to EDI\n  div esi             ; divide EDI by ESI\n  test edx, edx       ; check if remainder is 0, if so not prime\n  jz .not_prime\n  inc esi             ; increment ESI\n  jmp .loop\n.not_prime:\n  xor eax, eax\n  ret\n; -----> end of isprime <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211907,"user_id":null,"body":"global is_prime\n\nsection .text\n\n; <--- bool is_prime(int num) --->\nis_prime:\n    cmp edi, 2\n    jl .no\n    je .yes\n    test edi, 1\n    jz .no\n    \n    mov ecx, 2\n.loop:\n    inc ecx\n    mov edx, ecx\n    imul edx, ecx\n    cmp edi, edx\n    jb .yes\n    \n    mov eax, edi\n    xor edx, edx\n    div ecx\n    test edx, edx\n    jnz .loop\n    \n.no:\n    xor eax, eax\n    ret\n\n.yes:\n    mov eax, 1\n    ret\n; -----> end of isprime <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211908,"user_id":null,"body":"global is_prime\n\nsection .text\n\n; <--- bool is_prime(int num) --->\n; implementing https:\/\/codereview.stackexchange.com\/a\/84058\nis_prime:\n  cmp edi, 1\n  jle .ret_false\n  \n  cmp edi, 3\n  jbe .ret_true\n  \n  cmp edi, 5\n  je .ret_true\n  \n  cmp edi, 7\n  je .ret_true\n  \n  ; num % 2 = 0\n  mov eax, edi\n  mov ecx, 2\n  xor edx, edx\n  div ecx\n  test edx, edx\n  jz .ret_false\n  \n  ; num % 3 = 0\n  mov eax, edi\n  inc ecx\n  xor edx, edx\n  div ecx\n  test edx, edx\n  jz .ret_false\n\n  ; for (int i = 5; i * i <= num; i += 6)\n  mov ecx, 5\n.loop:\n  ; if (num % i == 0) return false;\n  mov eax, edi\n  xor edx, edx\n  div ecx\n  test edx, edx\n  jz .ret_false\n  \n  ; if (num % (i + 2) == 0) return false;\n  mov eax, edi\n  add ecx, 2\n  xor edx, edx\n  div ecx\n  test edx, edx\n  jz .ret_false\n  \n  ; for (; i * i <= num; i += 6) ; we already added 2 before\n  add ecx, 4\n  mov eax, ecx\n  mul ecx\n  \n  test edx, edx ; if (i^2 >= 2^32)\n  jnz .ret_true\n  \n  cmp eax, edi\n  jb .loop\n  \n.ret_true:\n  xor rax, rax\n  inc rax\n  jmp .exit\n  \n.ret_false:\n  xor rax, rax\n  \n.exit:\n    ret\n; -----> end of isprime <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"526571aae218b8ee490006f4":[{"id":211909,"user_id":1277,"body":"SECTION .text\nglobal count_bits\n\ncount_bits:\n  popcnt rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211910,"user_id":1277,"body":"SECTION .text\nglobal count_bits\n\ncount_bits:\n  popcnt rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211911,"user_id":527,"body":"section .text\nglobal count_bits\ncount_bits:\n                popcnt  rax, rdi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211912,"user_id":null,"body":"global count_bits\n\nsection .text\n\n; <----- unsigned long count_bits(unsigned long n) ----->\ncount_bits:\n    xor rax, rax        ; resetting RAX\n.loop:\n    cmp rdi, 0              ; if <n> is empty\n    je .exit                ; then no need to continue\n    shr rdi, 1              ; shifting <n> to the right by one bit\n    jnc .loop               ; starting a new iteration if the carry flag is not set\n    inc rax                 ; otherwise, incrementing the counter\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    ret\n; ---------> end of bitcnt <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211913,"user_id":564,"body":"SECTION .text\nglobal count_bits\n\ncount_bits:\n  xor rax, rax\n  xor r10, r10\n.each_bit:\n  mov r10, rdi\n  and r10, 1\n  add rax, r10\n  shr rdi, 1\n  jnz .each_bit\n.end:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211914,"user_id":null,"body":"SECTION .text\nglobal count_bits\n\n; Counts the number of set bits in arg0.\n; arg0         = (uint64_t) The number to check.\n; return value = (uint64_t) The number of set bits.\ncount_bits:\n    xor rax, rax            ; RAX <- the result\n    mov rdx, 64\n    mov rbx, 0\n.loop:\n    dec rdx\n    mov rbx, 1\n    and rbx, rdi\n    cmp rbx, 1\n    jne .endloop\n    add rax, 1\n.endloop:\n    shr rdi, 1\n    cmp rdx, 0\n    ja .loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211915,"user_id":null,"body":"section .text\nglobal count_bits\n\ncount_bits:\n  xor rax, rax\n  cmp rdi, 0\n  jne _count\n  ret\n  \n_count:\n  inc rax\n  lea rsi, [rdi - 1]\n  and rdi, rsi\n  jnz _count\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211916,"user_id":null,"body":"SECTION .text\nglobal count_bits\n\n; Counts the number of set bits in arg0.\n; arg0         = (uint64_t) The number to check.\n; return value = (uint64_t) The number of set bits.\ncount_bits:\n  xor rax, rax\n  \nloop:\n  test rdi, rdi\n  jz end\n  mov rbx, rdi\n  and rbx, 1\n  add rax, rbx\n  shr rdi, 1\n  jmp loop\n  \nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211917,"user_id":null,"body":"SECTION .text\nglobal count_bits\n\n; Counts the number of set bits in arg0.\n; arg0         = (uint64_t) The number to check.\n; return value = (uint64_t) The number of set bits.\ncount_bits:\n  ;rdi = arg0\n  \n  xor rax, rax ;result\n  xor rbx, rbx ;counter\nloop:\n  cmp rbx, 64\n  je done\n  \n  mov rcx, rdi\n  and rcx, 1\n  add rax, rcx\n  inc rbx\n  \n  shr rdi, 1\n  jmp loop\n\ndone:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211918,"user_id":null,"body":"SECTION .text\nglobal count_bits\n\n; Counts the number of set bits in arg0.\n; arg0         = (uint64_t) The number to check.\n; return value = (uint64_t) The number of set bits.\ncount_bits:\n  mov rax, 0\nloop:\n  cmp rdi, 0\n  je end\n  shr rdi, 1\n  adc rax, 0\n  jmp loop\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5268acac0d3f019add000203":[{"id":211919,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  mov rsi, rdi\n  xor rax, rax\n  \n.q1:\n  lodsb\n  test al, al\n  jz .false\n  cmp al, '0'\n  je .q1\n  \n.q2:\n  lodsb\n  test al, al\n  je .true\n  cmp al, '1'\n  je .q2\n  \n.q3:\n  lodsb\n  test al, al\n  jnz .q2\n\n.false:\n  xor rax, rax\n  ret\n  \n.true:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211920,"user_id":527,"body":"; This solution is incorrect.\n; It doesn't work for strings consisting only of an even number of zeros.\n\nsection .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n                mov     rsi, rdi\n                xor     eax, eax\n                xor     ecx, ecx\n.loop:          inc     rax\n                cmp     byte [rsi], '0'\n                cmova   rax, rcx\n                lea     rsi, [rsi + 1]\n                jae     .loop\n                and     eax, 1\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211921,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  xor eax, eax\n.loop:\n  movzx ecx, byte [rdi]\n  test rcx, rcx\n  je .done\n  and ecx, 1\n  inc rdi\n  or rax, rcx\n  movsx eax, byte [rax + .trans]\n  jmp .loop\n.done:\n  cmp eax, 2\n  sete al\n  ret\n.trans: db 0,2,4,2,2,2","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211922,"user_id":881,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n    xor ax, ax\n    xor cx, cx\n    .state_machine:\n        mov cl, byte[rdi]\n        inc rdi\n        test cl, cl\n        jz .done\n        and cl, 1\n        cmovnz ax, cx\n        jnz .state_machine\n        mov ah, al\n        shr al, 1\n        shl ah, 1\n        or al, ah\n        jmp .state_machine\n    .done:\n    and ax, 1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211923,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  lea rsi, [q1]\n.loop:\n  movzx eax, byte [rdi]\n  inc rdi\n  test eax, eax\n  jz .done\n  mov rsi, [rsi+rax*8-'0'*8]\n  jmp .loop\n  \n.done:\n  lea rax, [q2]\n  cmp rsi, rax\n  sete al\n  ret\n  \n\nsection .rodata\nq1: dq q1, q2\nq2: dq q3, q2\nq3: dq q2, q2\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211924,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  q1:\n    cmp byte [rdi], 0x00\n    je false\n    inc rdi\n    cmp byte [rdi-1], '1'\n    je q2\n    jmp q1\n  q2:\n    cmp byte [rdi], 0x00\n    je true\n    inc rdi\n    cmp byte [rdi-1], '0'\n    je q3\n    jmp q2\n  q3:\n    cmp byte [rdi], 0x00\n    je false\n    inc rdi\n    jmp q2\n  false:\n  mov rax, 0\n  ret\n  true:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211925,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  xor al,al\n  jmp .start\n.loop:\n  mov dl,al\n  shr dl,1\n  xor cl,al\n  add al,cl\n  or al,dl\n  and al,3\n.start:\n  mov cl,byte[rdi]\n  inc rdi\n  test cl,cl\n  jne .loop\n.end:\n  and al,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211926,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  xchg rdi, rsi\n  mov eax, '0'\n  xor edx, edx\nl:\n  sub eax, '0'\n  movzx edx, byte[states+edx+eax*4]\n  lodsb\n  test al, al\n  jnz l\n  shr edx, 1\n  setc al\n  ret\n\nstates:\n  db 0, 2, 1, 0 ; 0\n  db 1, 1, 1, 0 ; 1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211927,"user_id":null,"body":"section .text\nglobal read_commands\n; bool read_commands(const char *commands)\nread_commands:\n  mov rsi,rdi\n  \n.q1:\n  lodsb\n  test al,al\n  jz .no\n  rcr al,1\n  jnc .q1\n  \n.q2:\n  lodsb\n  test al,al\n  jz .yes\n  rcr al,1\n  jc .q2\n  \n.q3:\n  lodsb\n  test al,al\n  jz .no\n  jmp .q2\n\n.no:\n  setnz al\n  ret\n.yes:\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211928,"user_id":null,"body":"; 0 = false ; 1 = true\n; states are 0, 1, 2\n; i guess rdx is our state counter\nsection .text\nglobal read_commands\nglobal _strlen\nread_commands:;(const char* commands)\n    push rbp\n    mov rbp, rsp\n    push rdx\n    push rcx\n    mov rdx, 0 ; q1, initial state\n    xor rcx, rcx\n_state_loop:\n    mov al, byte [rdi+rcx]\n    cmp al, 0\n    jz _read_commands_halt\n    ; usage of jump zero, greater, and less than means we only need 1 cmp; which is nice\n    cmp rdx, 1\n    jz _q2_sub\n    jg _q3_sub\n    jl _q1_sub\n    jmp _exit   ; if something goes wrong, we want to terminate\n_q1_sub:\n    cmp al, 0x30\n    jz _state_loop_reset\n    mov rdx, 1\n    jmp _state_loop_reset\n_q2_sub:\n    cmp al, 0x31\n    jz _state_loop_reset\n    mov rdx, 2\n    jmp _state_loop_reset\n_q3_sub:\n    mov rdx, 1\n_state_loop_reset:\n    inc rcx\n    jmp _state_loop\n_read_commands_halt:\n    cmp rdx, 1\n    jz _true\n    jmp _false\n_true:\n    mov rdx, 1\n    jmp _end\n_false:\n    mov rdx, 0\n_end:\n    mov rax, rdx\n    pop rcx\n    pop rdx\n    pop rbp\n    ret\n_exit:\n    mov rax, 60\n    mov rdi, 0\n    syscall\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"526c7363236867513f0005ca":[{"id":211929,"user_id":527,"body":"global is_leap_year\n\nsection .text\n\n; bool is_leap_year(unsigned year)\nis_leap_year:\n                mov     eax, edi\n                imul    rax, 1374389535\n                shr     rax, 37\n                imul    edx, eax, 100\n                cmp     edx, edi\n                cmove   edi, eax\n                test    edi, 3\n                setz    al\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211930,"user_id":168,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n  xor eax, eax\n  test edi, 3\n  jnz .end\n  xor edx, edx\n  mov ecx, 100\n  mov eax, edi\n  div ecx\n  test edx, edx\n  setnz cl\n  test al, 3\n  setz al\n  or al, cl\n.end:\n  ret\n; ---------> endof is_leap_year <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211931,"user_id":null,"body":"global is_leap_year\nsection .text\nis_leap_year:\nmov     eax, edi\nmov     ecx, 400\ncdq\ndiv     ecx\nmov     al, 1\ntest    edx, edx\nje      .exit\nmov     eax, edi\nmov     ecx, 100\ncdq\ndiv     ecx\nxor     eax, eax\ntest    edx, edx\nje      .exit\nand     edi, 3\nsete    al\n.exit:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211932,"user_id":null,"body":"global is_leap_year\n\nsection .text\nsetup_div:\n    mov eax, edi\n    mov edx, 0\n    mov ebx, 0\n    ret\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n    mov ecx, 4\n    call setup_div\n    div ecx\n    cmp edx, ebx\n    je four\n    jmp notLeap\n    four:\n      mov ecx, 100\n      call setup_div\n      div ecx\n      cmp edx, ebx\n      je hundret\n      jmp Leap\n    hundret:\n      mov ecx, 400\n      call setup_div\n      div ecx\n      cmp edx, ebx\n      je Leap\n      jmp notLeap\n    notLeap:\n      xor al, al          ; AL <- the result\n      ret\n    Leap:\n      mov al, 1\n      ret\n; ---------> endof is_leap_year <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211933,"user_id":null,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n  test dil, 3\n  je .mul4\n  xor eax, eax\n  jmp .done\n.mul4:\n  imul ecx, edi, -1030792151\n  rorx edx, ecx, 2\n  mov al, 1\n  cmp edx, 42949672\n  ja .done\n  rorx eax, ecx, 4\n  cmp eax, 10737419\n  setb al\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211934,"user_id":null,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n  test edi, 3\n  jnz .no\n  \n  xor edx, edx\n  mov ecx, 100\n  mov eax, edi\n  idiv ecx\n  test edx, edx\n  jnz .yes\n  \n  test eax, 3\n  jnz .no\n\n.yes:\n  mov eax, 1\n  ret\n.no:\n  xor eax, eax\n  ret\n; ---------> endof is_leap_year <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211935,"user_id":null,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\n\n;65,536\n\nis_leap_year:\n push\trbx                ; save used registers\n    push\trcx\n    push\trdx\n    mov\t\trax, rdi\n    test rax, 3 ; if rdx is not devidable by 4 (any bit of 3 is on), then this is not a leap year\n    jnz ret_false\n    xor\t\trdx, rdx           ; prepare rdx for division\n    mov\t\trbx, 100           ; year \/ 100\n    div\t\trbx ; dividing rax by 100, reminder will be inserted to rdx, rax will be divided by 100 with no float\n    test     rdx, rdx ; testing if reminder == 0\n    jnz ret_true\n    test rax,3 ; we already devided by 100, if it was devidable by 400, it means we need to have 4 as the lest digit\n    jz ret_true\nret_false:\n\n    pop rdx\n    pop\trcx\n    pop\trbx                ; restore\n    xor rax,rax\n    ret\nret_true:\n    pop rdx\n    pop\trcx\n    pop\trbx                ; restore\n    mov rax, 1\n    ret\n\n\n; ---------> endof is_leap_year <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211936,"user_id":null,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n    xor rax, rax\n    xor rdx, rdx\n    mov rax, rdi\n    xor rcx, rcx\n    mov cx, 400\n    div cx\n    xor al, al\n    inc al\n    test dx, dx\n    jz .end\n    \n    xor rax, rax\n    xor rdx, rdx\n    mov rax, rdi\n    xor rcx, rcx\n    mov cx, 100\n    div cx\n    xor al, al\n    test dx, dx\n    jz .end\n    \n    xor rax, rax\n    xor rdx, rdx\n    mov rax, rdi\n    xor rcx, rcx\n    mov cx, 4\n    div cx\n    xor al, al\n    inc al\n    test dx, dx\n    jz .end\n    \n    xor al, al \n.end:\n    ret\n; ---------> endof is_leap_year <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211937,"user_id":null,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n    mov rax,rdi\n    mov rcx,100\n    xor rdx,rdx\n    div rcx\n    test rdx,rdx\n    cmovne rax,rdi\n    and al,3\n    setz al\n    ret\n; ---------> endof is_leap_year <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211938,"user_id":null,"body":"global is_leap_year\n\nsection .text\n\n; <--- bool is_leap_year(unsigned year) --->\nis_leap_year:\n    xor dx, dx\n    mov ax, di\n    mov bx, 100\n    div bx\n    mov cx, dx\n    xor dx, dx\n    mov ax, di\n    mov bx, 400\n    div bx\n    cmp dx, 0\n    je check\n    cmp cx, 0\n    je end\n    check:\n    xor dx, dx\n    mov ax, di\n    mov bx, 4\n    div bx\n    cmp dx, 0\n    jne end\n    mov ax, 1\n    ret\n    end:\n    xor ax, ax\n    ret\n; ---------> endof is_leap_year <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"526d84b98f428f14a60008da":[{"id":211939,"user_id":527,"body":"global hamming\nextern free, malloc\nsection .text\n; uint64_t hamming(int n)\nhamming:\n%define max_n 13282\n%define xs_end rcx\n%define x2 rdx\n%define x3 rsi\n%define x5 r8\n%define p2 r9\n%define p3 r10\n%define p5 r11\n                mov     rax, [.xs + (edi - 1) * 8]\n                test    rax, rax\n                jz      .calculate\n                ret\n.calculate:     mov     xs_end, .xs\n                mov     p2, .xs\n                mov     p3, .xs\n                mov     p5, .xs\n                mov     x2, 1\n                mov     x3, 1\n                mov     x5, 1\n.loop:          mov     rax, x2\n                cmp     x3, x2\n                cmovb   rax, x3\n                cmp     x5, rax\n                cmovb   rax, x5\n                mov     [xs_end], rax\n                add     xs_end, 8\n                cmp     rax, x2\n                jne     .done_next_x2\n                imul    x2, [p2], 2\n                add     p2, 8\n.done_next_x2:  cmp     rax, x3\n                jne     .done_next_x3\n                imul    x3, [p3], 3\n                add     p3, 8\n.done_next_x3:  cmp     rax, x5\n                jne     .done_next_x5\n                imul    x5, [p5], 5\n                add     p5, 8\n.done_next_x5:  cmp     xs_end, .xs + max_n * 8\n                jne     .loop\n                mov     rax, [.xs + (edi - 1) * 8]\n                ret\nsection .bss\n.xs             resq max_n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211940,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                           Written by uniapi\n;                              July 6, 2021\n; ----------------------------------------------------------------------\n\nglobal hamming\n\nsection .text\n\n; Design:\n;   spinning threads instead of duplicating jobs\n;   until the locking thread has done the job\n;   so the long result is only computed once.\n;   also implementing AVX512 VPMINUQ and VPMULLQ instructions\n;   so running with native AVX512 instead has full benefit!\n\n%macro hambusy 1\n    push rbx\n    mov rbx, hamlk\n%if %1 == 0\n    mov [rbx], dword 0\n%else\n    xor eax, eax\n    xor ecx, ecx\n    inc ecx\n%%loop:\n    xor eax, eax\n    cmpxchg dword [rbx], ecx\n    cmp eax, 1\n    je %%loop\n%endif\n    pop rbx\n%endmacro\n\n%macro vpminuq 2                          ; VPMINUQ supported only starting from AVX512\n    vmovdqu [rsp], %2\n    vpcmpgtq %2, %1, %2\n    vpgatherqq %1, [rsp+ymm7*8], %2\n%endmacro\n\n%macro vpmullq 3                          ; VPMULLQ supported only starting from AVX512\n    vpsrlq %1, %3, 32\n    vpmuludq %1, %2\n    vpsrlq ymm5, %2, 32\n    vpmuludq ymm5, %3\n    vpaddq %1, ymm5\n    vpsllq %1, 32\n    vpmuludq %2, %3\n    vpaddq %1, %2\n%endmacro\n\n; <-- RAX hamber(EDI n) -->\nhamber:\nhamming:\n    hambusy 1                               ; spin-locking\n    mov rdx, hambers                        ; loading the address of <hambers>\n    mov rsi, [rdx+0h3FFF*8]                 ; loading <i>\n    cmp edi, esi                            ; whether <n> is greater than <i>\n    jle .exit                               ; otherwise, jumping to exit\n    cmp edi, 0h33E2                         ; whether <n> is greater than <lim>\n    cmovg rdi, [rdx]                        ; then reseting <n>\n    jg .exit                                ; and jumping to exit\n    sub rsp, 0h20                           ; reserving memory for YMM register\n    vmovdqa ymm7, [rdx]                     ; loading indices <inx>\n    mov rax, .hamuls                        ; loading the address of multipliers\n    vmovdqa ymm6, [rax]                     ; loading the multipliers\n    xor ecx, ecx                            ; resetting RCX\n    inc rcx                                 ; setting RCX to one as <inxmsk>\n    vmovq xmm1, rcx                         ; loading XMM1 with <inxmsk>\n    vpbroadcastq ymm1, xmm1                 ; extending index mask\n    neg rcx                                 ; setting RCX to minus one as <cpymsk>\n    vmovq xmm2, rcx                         ; loading XMM2 <cpymsk>\n    vpbroadcastq ymm2, xmm2                 ; extending <cpymsk>\n    mov rax, hamxps                         ; loading the address of <hamxps>\n    vmovdqa ymm3, [rax]                     ; loading <hamxps>\n    mov rcx, haminx                         ; loading the address of <haminx>\n    vmovdqa ymm0, [rcx]                     ; loading <haminx>\n.loop:\n    vmovdqa ymm4, ymm3                      ; copying <hamxps>\n    vpermq ymm5, ymm4, 0b01001110           ; permuting [1234] to [3412]\n    vpminuq ymm4, ymm5                      ; loading minimus YMM4\n    vpermq ymm5, ymm4, 0b01010011           ; permuting [1234] to [4123]\n    vpminuq ymm4, ymm5                      ; getting a broadcast minimum <min>, i.e a hamber\n    inc esi                                 ; incrementing <i>\n    vmovsd [rdx+rsi*8], xmm4                ; saving the hamber in <hambers[i]>\n    vpcmpeqq ymm4, ymm3                     ; getting mask whether <min> is equal to <hamxps>\n    vpand ymm4, ymm1                        ; getting masked indices\n    vpaddq ymm0, ymm4                       ; incrementing <haminx>\n    vmovdqa ymm5, ymm2                      ; copying <cpymsk> to YMM5\n    vpgatherqq ymm4, [rdx+ymm0*8], ymm5     ; loading YMM4 with <hambers[...haminx] using <cpymsk> as <ihmbrs>\n    vpmullq ymm3, ymm4, ymm6                ; multiplying <ihmbrs> by <hamuls> and saving in <hamxps>\n    cmp esi, edi                            ; whether <i> is equal to <n>\n    jl .loop                                ; otherwise, jumping to the next iteration\n    vmovdqa [rcx], ymm0                     ; updating <haminx>\n    vmovdqa [rax], ymm3                     ; updating <hamxps>\n    mov [rdx+0h3FFF*8], rdi                 ; updating <i>\n    add rsp, 0h20                           ; restoring local memory\n.exit:\n    mov rax, [rdx+rdi*8]                    ; loading RAX with <hambers[n]>\n    hambusy 0                               ; unlocking (no spinning)\n    ret\nalign 32\n.hamuls:        dq  2,2,3,5\n; -----> endof hamber <-----\n\nsection .data   align=32\nhamlk:      dq  0,0,0,0\nhaminx:     dq  4,4,3,2\nhamxps:     dq  8,8,9,10\nhambers:    dq  0,1,2,3,4,5,6\n;           dq  0h3FF8 dup (?)              ; supported syntax only starting from NASM 2.15.05\n            times 0h3FF8 dq 0               ; the current supported environment version is 2.11\n            dq  6","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211941,"user_id":null,"body":"        global hamming\n        extern qsort\n        section .text\n\ncmp_uint:\n  mov rdi, [rdi]\n  mov rsi, [rsi]\n  xor eax, eax\n  mov ecx, 1\n  mov edx, -1\n  cmp rdi, rsi\n  cmovb eax, ecx\n  cmova eax, edx\n  ret\n  \nrun_once:\n  sub rsp, 24\n  mov edi, 1\n  mov qword [data], 1\n  mov qword [rsp+16], 0\n  mov esi, 1\n  \n.loop:\n  mov [rsp], edi\n  mov [rsp+8], esi\n  lea rdi, [data]\n  mov edx, 8\n  lea ecx, [cmp_uint]\n  call qsort\n  mov edi, [rsp]\n  mov esi, [rsp+8]\n  \n  lea r8, [data]\n.loop1:\n  dec rsi\n  mov rax, [r8+rsi*8]\n  cmp rax, [rsp+16]\n  je .loop1\n  \n  lea r9, [memory]\n  mov [r9+rdi*8], rax\n  inc edi\n  cmp edi, 13283\n  je .done\n  \n  mov [rsp+16], rax\n  mov rcx, rax\n  \n  mov rax, 2\n  mul rcx\n  test rdx, rdx\n  jnz .loop\n  mov [r8+rsi*8], rax\n  inc rsi\n\n  mov rax, 3\n  mul rcx\n  test rdx, rdx\n  jnz .loop\n  mov [r8+rsi*8], rax\n  inc rsi\n\n  mov rax, 5\n  mul rcx\n  test rdx, rdx\n  jnz .loop\n  mov [r8+rsi*8], rax\n  inc rsi\n\n  jmp .loop\n\n.done:\n  add rsp, 24\n  ret\n  \n  \n; uint64_t hamming(int n)\n; Parameter:    EDI (1 <= n <= 13282)\n; Return value: RAX  n'th hamming number\nhamming:\n  cmp qword [memory+8], 0\n  jne .skip\n  push rdi\n  call run_once\n  pop rdi\n.skip:\n  lea rax, [memory]\n  mov rax, [rax+rdi*8]\n  ret\n\nsection .bss\ndata: resq 4096\nmemory: resq 16384","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211942,"user_id":null,"body":"; Fastcall: no stack manipulations\nmin2:\n    cmp rdi, rsi\n    jg  min2_greater\n\n    mov rax, rdi\n    jmp min2_exit\n\nmin2_greater:\n    mov rax, rsi\n\nmin2_exit:\n    ret\n\n\nmin3:\n    call min2\n    mov  rdi, rax\n    mov  rsi, rdx\n    call min2\n    ret\n\n\nglobal hamming\nhamming:\n    push rbp\n    mov  rbp, rsp\n\n    ; Save argument, so '%rdi' could be reused\n    mov r15, rdi\n\n    ; Using VLA stack allocation\n    imul rdi, 8\n    sub  rsp, rdi\n\n    xor r8,  r8   ; i - %r8\n    xor r9,  r9   ; j - %r9\n    xor r10, r10  ; k - %10\n\n    mov r11, 2    ; ham2 - %r11\n    mov r12, 3    ; ham3 - %r12\n    mov r13, 5    ; ham5 - %r13\n\n    mov QWORD [rsp], 1\n    mov rcx, 1    ; n - index\n\nhamming_for_loop:\n    cmp r15, rcx\n    je  hamming_for_end\n\n    mov  rdi, r11\n    mov  rsi, r12\n    mov  rdx, r13\n    call min3\n\n    mov [rsp + rcx * 8], rax\n\n    cmp rax, r11\n    jne hamming_for_ham2_end\n\n    inc r8\n    mov rbx, [rsp + r8 * 8]\n\n    imul rbx, 2\n    mov  r11, rbx\n\nhamming_for_ham2_end:\n    cmp rax, r12\n    jne hamming_for_ham3_end\n\n    inc r9\n    mov rbx, [rsp + r9 * 8]\n\n    imul rbx, 3\n    mov  r12, rbx\n\nhamming_for_ham3_end:\n    cmp rax, r13\n    jne hamming_for_ham5_end\n\n    inc r10\n    mov rbx, [rsp + r10 * 8]\n\n    imul rbx, 5\n    mov  r13, rbx\n\nhamming_for_ham5_end:\n    inc rcx\n    jmp hamming_for_loop\n\nhamming_for_end:\n    dec r15\n    mov rax, [rsp + r15 * 8]\n\n    mov rsp, rbp\n    pop rbp\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211943,"user_id":168,"body":"global hamming\nsection .text\n\n; uint64_t hamming(int n)\n; Parameter:    EDI (1 <= n <= 13282)\n; Return value: RAX  n'th hamming number\nhamming:\n  push rbp\n  mov rbp, rsp\n  lea eax, [8 * rdi]\n  sub rsp, rax\n  mov qword [rsp], 1\n  mov r8, rsp\n  mov r9, rsp\n  mov r10, rsp\n  xor eax, eax\n  jmp .cond\n.loop:\n  mov rdi, qword [r8]\n  add rdi, rdi\n  mov rdx, qword [r9]\n  lea rdx, [3 * rdx]\n  mov rcx, qword [r10]\n  lea rcx, [5 * rcx]\n  mov rsi, rdi\n  cmp rsi, rdx\n  cmova rsi, rdx\n  cmp rsi, rcx\n  cmova rsi, rcx\n  mov qword [rsp], rsi\n  cmp rdi, rsi\n  sete al\n  lea r8, [r8 + 8 * rax]\n  cmp rdx, rsi\n  sete al\n  lea r9, [r9 + 8 * rax]\n  cmp rcx, rsi\n  sete al\n  lea r10, [r10 + 8 * rax]\n.cond:\n  add rsp, 8\n  cmp rsp, rbp\n  jnz .loop\n  mov rax, qword [rsp - 8]\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211944,"user_id":null,"body":"        global hamming\n        section   .data\nnum  times 13282 dq (0)\ni: dd 0\nj: dd 0\nk: dd 0\n        section .text\n; uint64_t hamming(int n)\n; Parameter:    EDI (1 <= n <= 13282)\n; Return value: RAX  n'th hamming number\nhamming:\n        mov dword[i], 0\n        mov dword[j], 0\n        mov dword[k], 0\n        \n        cmp edi, 1\n        jne more     \n          mov rax, 1 ; if (N == 1) return 1\n          ret\n        more:\n        mov dword[num], 1\n        mov edx, 1\n        push dx\n        for:\n          xor edx, edx\n          pop dx\n          cmp edx, edi\n          je for_end   ; for(edx < N)\n          push dx\n          mov eax, dword[i]\n          mov rax, [num + eax*8] ; eax = num[i]\n          \n          mov rbx, 2           \n          mul rbx              ; eax = num[i] * 2\n          mov rbx, rax         ; ebx = eax\n          mov eax, dword[j]\n          mov rax, [num + eax*8] ; eax = num[j]\n          mov rcx, 3\n          mul rcx              ; eax = num[j] * 3\n          mov rcx, rax         ; ecx = eax\n          cmp rbx, rcx \n          jl min2\n            mov rbx, rcx ; if (ebx > ecx) ebx = ecx\n          min2:\n          mov eax, dword[k]\n          mov rax, [num + eax*8] ; eax = num[k]\n          mov rcx, 5\n          mul rcx              ; eax = num[k] * 5\n          mov rcx, rax         ; ecx = eax\n          cmp rbx, rcx \n          jl append\n            mov rbx, rcx ; if (ebx > ecx) ebx = ecx\n          append:\n          ; ebx = min(num[i]*2, num[j]*3, num[k]*5)\n          xor edx, edx\n          pop dx\n          mov [num + edx*8], rbx\n          inc edx\n          push dx\n        \n          \n          ; if 2*num[i] <= ebx: i += 1\n          mov eax, dword[i]\n          mov rax, [num + eax*8] ; ecx = num[i]\n          mov rcx, 2\n          mul rcx                ; ecx = num[i] * 2\n          mov rcx, rax\n          cmp rcx, rbx\n          jg next_comp1\n            mov ecx, dword[i]    ; if (ecx <= ebx) i++\n            inc ecx\n            mov dword[i], ecx\n          next_comp1:\n          \n          mov eax, dword[j]\n          mov rax, [num + eax*8] ; ecx = num[j]\n          mov rcx, 3\n          mul rcx              ; ecx = num[j] * 3\n          mov rcx, rax\n          cmp rcx, rbx\n          jg next_comp2\n            mov ecx, dword[j]\n            inc ecx\n            mov dword[j], ecx\n          next_comp2:\n          \n          mov eax, dword[k]\n          mov rax, [num + eax*8] ; eax = num[k]\n          mov rcx, 5\n          mul rcx                \n          mov rcx, rax           ; ecx = eax * 5\n          cmp rcx, rbx\n          jg for\n          \n          mov ecx, dword[k]\n          inc ecx\n          mov dword[k], ecx\n          jmp for\n          \n        for_end:\n        dec edx\n        xor rax, rax\n        mov rax, QWORD[num + edx*8]\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211945,"user_id":527,"body":"global hamming\nextern free, malloc\nsection .text\n; uint64_t hamming(int n)\nhamming:\n%define xs_end rcx\n%define x2 rdx\n%define x3 rsi\n%define x5 r8\n%define p2 r9\n%define p3 r10\n%define p5 r11\n                mov     ecx, [.len_xs]\n                cmp     edi, ecx\n                ja      .calculate\n                mov     rax, [.xs + (edi - 1) * 8]\n                ret\n.calculate:     mov     [.len_xs], edi\n                sub     edi, ecx\n                lea     xs_end, [.xs + rcx * 8]\n                mov     p2, [.cps]\n                mov     p3, [.cps + 8]\n                mov     p5, [.cps + 16]\n                mov     x2, [.cxs]\n                mov     x3, [.cxs + 8]\n                mov     x5, [.cxs + 16]\n.loop:          mov     rax, x2\n                cmp     x3, x2\n                cmovb   rax, x3\n                cmp     x5, rax\n                cmovb   rax, x5\n                mov     [xs_end], rax\n                add     xs_end, 8\n                cmp     rax, x2\n                jne     .done_next_x2\n                imul    x2, [p2], 2\n                add     p2, 8\n.done_next_x2:  cmp     rax, x3\n                jne     .done_next_x3\n                imul    x3, [p3], 3\n                add     p3, 8\n.done_next_x3:  cmp     rax, x5\n                jne     .done_next_x5\n                imul    x5, [p5], 5\n                add     p5, 8\n.done_next_x5:  dec     edi\n                jnz     .loop\n                mov     [.cps], p2\n                mov     [.cps + 8], p3\n                mov     [.cps + 16], p5\n                mov     [.cxs], x2\n                mov     [.cxs + 8], x3\n                mov     [.cxs + 16], x5\n                ret\nsection .data\n.cxs            times 3 dq 1\n.cps            times 3 dq .xs\n.len_xs         dd 0\nsection .bss\n.xs             resq 13282\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211946,"user_id":527,"body":"global hamming\nsection .text\n; uint64_t hamming(int n)\nhamming:\n                mov     rax, [hamming_numbers + (edi - 1) * 8]\n                ret\n\nsection .rodata\nhamming_numbers dq 1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000,2250000000,2264924160,2267481600,2278125000,2293235712,2295825120,2304000000,2324522934,2332800000,2343750000,2359296000,2361960000,2373046875,2388787200,2391484500,2400000000,2415919104,2418647040,2430000000,2441406250,2448880128,2457600000,2460375000,2488320000,2500000000,2516582400,2519424000,2531250000,2548039680,2550916800,2560000000,2562890625,2579890176,2582803260,2592000000,2621440000,2624400000,2636718750,2654208000,2657205000,2684354560,2687385600,2700000000,2717908992,2720977920,2733750000,2754990144,2764800000,2767921875,2799360000,2812500000,2831155200,2834352000,2847656250,2866544640,2869781400,2880000000,2902376448,2916000000,2929687500,2949120000,2952450000,2985984000,2989355625,3000000000,3019898880,3023308800,3037500000,3057647616,3061100160,3072000000,3075468750,3099363912,3110400000,3125000000,3145728000,3149280000,3164062500,3185049600,3188646000,3200000000,3221225472,3224862720,3228504075,3240000000,3265173504,3276800000,3280500000,3317760000,3321506250,3355443200,3359232000,3375000000,3397386240,3401222400,3417187500,3439853568,3443737680,3456000000,3486784401,3499200000,3515625000,3538944000,3542940000,3583180800,3587226750,3600000000,3623878656,3627970560,3645000000,3662109375,3673320192,3686400000,3690562500,3732480000,3750000000,3774873600,3779136000,3796875000,3822059520,3826375200,3840000000,3869835264,3874204890,3888000000,3906250000,3932160000,3936600000,3955078125,3981312000,3985807500,4000000000,4026531840,4031078400,4050000000,4076863488,4081466880,4096000000,4100625000,4132485216,4147200000,4194304000,4199040000,4218750000,4246732800,4251528000,4271484375,4294967296,4299816960,4304672100,4320000000,4353564672,4374000000,4394531250,4423680000,4428675000,4478976000,4500000000,4529848320,4534963200,4556250000,4586471424,4591650240,4608000000,4613203125,4649045868,4665600000,4687500000,4718592000,4723920000,4746093750,4777574400,4782969000,4800000000,4831838208,4837294080,4860000000,4882812500,4897760256,4915200000,4920750000,4976640000,4982259375,5000000000,5033164800,5038848000,5062500000,5096079360,5101833600,5120000000,5125781250,5159780352,5165606520,5184000000,5242880000,5248800000,5273437500,5308416000,5314410000,5368709120,5374771200,5380840125,5400000000,5435817984,5441955840,5467500000,5509980288,5529600000,5535843750,5598720000,5625000000,5662310400,5668704000,5695312500,5733089280,5739562800,5760000000,5804752896,5811307335,5832000000,5859375000,5898240000,5904900000,5971968000,5978711250,6000000000,6039797760,6046617600,6075000000,6103515625,6115295232,6122200320,6144000000,6150937500,6198727824,6220800000,6250000000,6291456000,6298560000,6328125000,6370099200,6377292000,6400000000,6442450944,6449725440,6457008150,6480000000,6530347008,6553600000,6561000000,6591796875,6635520000,6643012500,6710886400,6718464000,6750000000,6794772480,6802444800,6834375000,6879707136,6887475360,6912000000,6973568802,6998400000,7031250000,7077888000,7085880000,7119140625,7166361600,7174453500,7200000000,7247757312,7255941120,7290000000,7324218750,7346640384,7372800000,7381125000,7464960000,7500000000,7549747200,7558272000,7593750000,7644119040,7652750400,7680000000,7688671875,7739670528,7748409780,7776000000,7812500000,7864320000,7873200000,7910156250,7962624000,7971615000,8000000000,8053063680,8062156800,8100000000,8153726976,8162933760,8192000000,8201250000,8264970432,8294400000,8303765625,8388608000,8398080000,8437500000,8493465600,8503056000,8542968750,8589934592,8599633920,8609344200,8640000000,8707129344,8748000000,8789062500,8847360000,8857350000,8957952000,8968066875,9000000000,9059696640,9069926400,9112500000,9172942848,9183300480,9216000000,9226406250,9298091736,9331200000,9375000000,9437184000,9447840000,9492187500,9555148800,9565938000,9600000000,9663676416,9674588160,9685512225,9720000000,9765625000,9795520512,9830400000,9841500000,9953280000,9964518750,10000000000,10066329600,10077696000,10125000000,10192158720,10203667200,10240000000,10251562500,10319560704,10331213040,10368000000,10460353203,10485760000,10497600000,10546875000,10616832000,10628820000,10737418240,10749542400,10761680250,10800000000,10871635968,10883911680,10935000000,10986328125,11019960576,11059200000,11071687500,11197440000,11250000000,11324620800,11337408000,11390625000,11466178560,11479125600,11520000000,11609505792,11622614670,11664000000,11718750000,11796480000,11809800000,11865234375,11943936000,11957422500,12000000000,12079595520,12093235200,12150000000,12207031250,12230590464,12244400640,12288000000,12301875000,12397455648,12441600000,12500000000,12582912000,12597120000,12656250000,12740198400,12754584000,12800000000,12814453125,12884901888,12899450880,12914016300,12960000000,13060694016,13107200000,13122000000,13183593750,13271040000,13286025000,13421772800,13436928000,13500000000,13589544960,13604889600,13668750000,13759414272,13774950720,13824000000,13839609375,13947137604,13996800000,14062500000,14155776000,14171760000,14238281250,14332723200,14348907000,14400000000,14495514624,14511882240,14580000000,14648437500,14693280768,14745600000,14762250000,14929920000,14946778125,15000000000,15099494400,15116544000,15187500000,15288238080,15305500800,15360000000,15377343750,15479341056,15496819560,15552000000,15625000000,15728640000,15746400000,15820312500,15925248000,15943230000,16000000000,16106127360,16124313600,16142520375,16200000000,16307453952,16325867520,16384000000,16402500000,16529940864,16588800000,16607531250,16777216000,16796160000,16875000000,16986931200,17006112000,17085937500,17179869184,17199267840,17218688400,17280000000,17414258688,17433922005,17496000000,17578125000,17694720000,17714700000,17915904000,17936133750,18000000000,18119393280,18139852800,18225000000,18310546875,18345885696,18366600960,18432000000,18452812500,18596183472,18662400000,18750000000,18874368000,18895680000,18984375000,19110297600,19131876000,19200000000,19327352832,19349176320,19371024450,19440000000,19531250000,19591041024,19660800000,19683000000,19775390625,19906560000,19929037500,20000000000,20132659200,20155392000,20250000000,20384317440,20407334400,20480000000,20503125000,20639121408,20662426080,20736000000,20920706406,20971520000,20995200000,21093750000,21233664000,21257640000,21357421875,21474836480,21499084800,21523360500,21600000000,21743271936,21767823360,21870000000,21972656250,22039921152,22118400000,22143375000,22394880000,22500000000,22649241600,22674816000,22781250000,22932357120,22958251200,23040000000,23066015625,23219011584,23245229340,23328000000,23437500000,23592960000,23619600000,23730468750,23887872000,23914845000,24000000000,24159191040,24186470400,24300000000,24414062500,24461180928,24488801280,24576000000,24603750000,24794911296,24883200000,24911296875,25000000000,25165824000,25194240000,25312500000,25480396800,25509168000,25600000000,25628906250,25769803776,25798901760,25828032600,25920000000,26121388032,26214400000,26244000000,26367187500,26542080000,26572050000,26843545600,26873856000,26904200625,27000000000,27179089920,27209779200,27337500000,27518828544,27549901440,27648000000,27679218750,27894275208,27993600000,28125000000,28311552000,28343520000,28476562500,28665446400,28697814000,28800000000,28991029248,29023764480,29056536675,29160000000,29296875000,29386561536,29491200000,29524500000,29859840000,29893556250,30000000000,30198988800,30233088000,30375000000,30517578125,30576476160,30611001600,30720000000,30754687500,30958682112,30993639120,31104000000,31250000000,31381059609,31457280000,31492800000,31640625000,31850496000,31886460000,32000000000,32212254720,32248627200,32285040750,32400000000,32614907904,32651735040,32768000000,32805000000,32958984375,33059881728,33177600000,33215062500,33554432000,33592320000,33750000000,33973862400,34012224000,34171875000,34359738368,34398535680,34437376800,34560000000,34828517376,34867844010,34992000000,35156250000,35389440000,35429400000,35595703125,35831808000,35872267500,36000000000,36238786560,36279705600,36450000000,36621093750,36691771392,36733201920,36864000000,36905625000,37192366944,37324800000,37500000000,37748736000,37791360000,37968750000,38220595200,38263752000,38400000000,38443359375,38654705664,38698352640,38742048900,38880000000,39062500000,39182082048,39321600000,39366000000,39550781250,39813120000,39858075000,40000000000,40265318400,40310784000,40500000000,40768634880,40814668800,40960000000,41006250000,41278242816,41324852160,41472000000,41518828125,41841412812,41943040000,41990400000,42187500000,42467328000,42515280000,42714843750,42949672960,42998169600,43046721000,43200000000,43486543872,43535646720,43740000000,43945312500,44079842304,44236800000,44286750000,44789760000,44840334375,45000000000,45298483200,45349632000,45562500000,45864714240,45916502400,46080000000,46132031250,46438023168,46490458680,46656000000,46875000000,47185920000,47239200000,47460937500,47775744000,47829690000,48000000000,48318382080,48372940800,48427561125,48600000000,48828125000,48922361856,48977602560,49152000000,49207500000,49589822592,49766400000,49822593750,50000000000,50331648000,50388480000,50625000000,50960793600,51018336000,51200000000,51257812500,51539607552,51597803520,51656065200,51840000000,52242776064,52301766015,52428800000,52488000000,52734375000,53084160000,53144100000,53687091200,53747712000,53808401250,54000000000,54358179840,54419558400,54675000000,54931640625,55037657088,55099802880,55296000000,55358437500,55788550416,55987200000,56250000000,56623104000,56687040000,56953125000,57330892800,57395628000,57600000000,57982058496,58047528960,58113073350,58320000000,58593750000,58773123072,58982400000,59049000000,59326171875,59719680000,59787112500,60000000000,60397977600,60466176000,60750000000,61035156250,61152952320,61222003200,61440000000,61509375000,61917364224,61987278240,62208000000,62500000000,62762119218,62914560000,62985600000,63281250000,63700992000,63772920000,64000000000,64072265625,64424509440,64497254400,64570081500,64800000000,65229815808,65303470080,65536000000,65610000000,65917968750,66119763456,66355200000,66430125000,67108864000,67184640000,67500000000,67947724800,68024448000,68343750000,68719476736,68797071360,68874753600,69120000000,69198046875,69657034752,69735688020,69984000000,70312500000,70778880000,70858800000,71191406250,71663616000,71744535000,72000000000,72477573120,72559411200,72900000000,73242187500,73383542784,73466403840,73728000000,73811250000,74384733888,74649600000,74733890625,75000000000,75497472000,75582720000,75937500000,76441190400,76527504000,76800000000,76886718750,77309411328,77396705280,77484097800,77760000000,78125000000,78364164096,78643200000,78732000000,79101562500,79626240000,79716150000,80000000000,80530636800,80621568000,80712601875,81000000000,81537269760,81629337600,81920000000,82012500000,82556485632,82649704320,82944000000,83037656250,83682825624,83886080000,83980800000,84375000000,84934656000,85030560000,85429687500,85899345920,85996339200,86093442000,86400000000,86973087744,87071293440,87169610025,87480000000,87890625000,88159684608,88473600000,88573500000,89579520000,89680668750,90000000000,90596966400,90699264000,91125000000,91552734375,91729428480,91833004800,92160000000,92264062500,92876046336,92980917360,93312000000,93750000000,94143178827,94371840000,94478400000,94921875000,95551488000,95659380000,96000000000,96636764160,96745881600,96855122250,97200000000,97656250000,97844723712,97955205120,98304000000,98415000000,98876953125,99179645184,99532800000,99645187500,100000000000,100663296000,100776960000,101250000000,101921587200,102036672000,102400000000,102515625000,103079215104,103195607040,103312130400,103680000000,104485552128,104603532030,104857600000,104976000000,105468750000,106168320000,106288200000,106787109375,107374182400,107495424000,107616802500,108000000000,108716359680,108839116800,109350000000,109863281250,110075314176,110199605760,110592000000,110716875000,111577100832,111974400000,112500000000,113246208000,113374080000,113906250000,114661785600,114791256000,115200000000,115330078125,115964116992,116095057920,116226146700,116640000000,117187500000,117546246144,117964800000,118098000000,118652343750,119439360000,119574225000,120000000000,120795955200,120932352000,121500000000,122070312500,122305904640,122444006400,122880000000,123018750000,123834728448,123974556480,124416000000,124556484375,125000000000,125524238436,125829120000,125971200000,126562500000,127401984000,127545840000,128000000000,128144531250,128849018880,128994508800,129140163000,129600000000,130459631616,130606940160,131072000000,131220000000,131835937500,132239526912,132710400000,132860250000,134217728000,134369280000,134521003125,135000000000,135895449600,136048896000,136687500000,137438953472,137594142720,137749507200,138240000000,138396093750,139314069504,139471376040,139968000000,140625000000,141557760000,141717600000,142382812500,143327232000,143489070000,144000000000,144955146240,145118822400,145282683375,145800000000,146484375000,146767085568,146932807680,147456000000,147622500000,148769467776,149299200000,149467781250,150000000000,150994944000,151165440000,151875000000,152587890625,152882380800,153055008000,153600000000,153773437500,154618822656,154793410560,154968195600,155520000000,156250000000,156728328192,156905298045,157286400000,157464000000,158203125000,159252480000,159432300000,160000000000,161061273600,161243136000,161425203750,162000000000,163074539520,163258675200,163840000000,164025000000,164794921875,165112971264,165299408640,165888000000,166075312500,167365651248,167772160000,167961600000,168750000000,169869312000,170061120000,170859375000,171798691840,171992678400,172186884000,172800000000,173946175488,174142586880,174339220050,174960000000,175781250000,176319369216,176947200000,177147000000,177978515625,179159040000,179361337500,180000000000,181193932800,181398528000,182250000000,183105468750,183458856960,183666009600,184320000000,184528125000,185752092672,185961834720,186624000000,187500000000,188286357654,188743680000,188956800000,189843750000,191102976000,191318760000,192000000000,192216796875,193273528320,193491763200,193710244500,194400000000,195312500000,195689447424,195910410240,196608000000,196830000000,197753906250,198359290368,199065600000,199290375000,200000000000,201326592000,201553920000,202500000000,203843174400,204073344000,204800000000,205031250000,206158430208,206391214080,206624260800,207360000000,207594140625,208971104256,209207064060,209715200000,209952000000,210937500000,212336640000,212576400000,213574218750,214748364800,214990848000,215233605000,216000000000,217432719360,217678233600,218700000000,219726562500,220150628352,220399211520,221184000000,221433750000,223154201664,223948800000,224201671875,225000000000,226492416000,226748160000,227812500000,229323571200,229582512000,230400000000,230660156250,231928233984,232190115840,232452293400,233280000000,234375000000,235092492288,235929600000,236196000000,237304687500,238878720000,239148450000,240000000000,241591910400,241864704000,242137805625,243000000000,244140625000,244611809280,244888012800,245760000000,246037500000,247669456896,247949112960,248832000000,249112968750,250000000000,251048476872,251658240000,251942400000,253125000000,254803968000,255091680000,256000000000,256289062500,257698037760,257989017600,258280326000,259200000000,260919263232,261213880320,261508830075,262144000000,262440000000,263671875000,264479053824,265420800000,265720500000,268435456000,268738560000,269042006250,270000000000,271790899200,272097792000,273375000000,274658203125,274877906944,275188285440,275499014400,276480000000,276792187500,278628139008,278942752080,279936000000,281250000000,282429536481,283115520000,283435200000,284765625000,286654464000,286978140000,288000000000,289910292480,290237644800,290565366750,291600000000,292968750000,293534171136,293865615360,294912000000,295245000000,296630859375,297538935552,298598400000,298935562500,300000000000,301989888000,302330880000,303750000000,305175781250,305764761600,306110016000,307200000000,307546875000,309237645312,309586821120,309936391200,311040000000,312500000000,313456656384,313810596090,314572800000,314928000000,316406250000,318504960000,318864600000,320000000000,320361328125,322122547200,322486272000,322850407500,324000000000,326149079040,326517350400,327680000000,328050000000,329589843750,330225942528,330598817280,331776000000,332150625000,334731302496,335544320000,335923200000,337500000000,339738624000,340122240000,341718750000,343597383680,343985356800,344373768000,345600000000,345990234375,347892350976,348285173760,348678440100,349920000000,351562500000,352638738432,353894400000,354294000000,355957031250,358318080000,358722675000,360000000000,362387865600,362797056000,364500000000,366210937500,366917713920,367332019200,368640000000,369056250000,371504185344,371923669440,373248000000,373669453125,375000000000,376572715308,377487360000,377913600000,379687500000,382205952000,382637520000,384000000000,384433593750,386547056640,386983526400,387420489000,388800000000,390625000000,391378894848,391820820480,393216000000,393660000000,395507812500,396718580736,398131200000,398580750000,400000000000,402653184000,403107840000,403563009375,405000000000,407686348800,408146688000,409600000000,410062500000,412316860416,412782428160,413248521600,414720000000,415188281250,417942208512,418414128120,419430400000,419904000000,421875000000,424673280000,425152800000,427148437500,429496729600,429981696000,430467210000,432000000000,434865438720,435356467200,435848050125,437400000000,439453125000,440301256704,440798423040,442368000000,442867500000,446308403328,447897600000,448403343750,450000000000,452984832000,453496320000,455625000000,457763671875,458647142400,459165024000,460800000000,461320312500,463856467968,464380231680,464904586800,466560000000,468750000000,470184984576,470715894135,471859200000,472392000000,474609375000,477757440000,478296900000,480000000000,483183820800,483729408000,484275611250,486000000000,488281250000,489223618560,489776025600,491520000000,492075000000,494384765625,495338913792,495898225920,497664000000,498225937500,500000000000,502096953744,503316480000,503884800000,506250000000,509607936000,510183360000,512000000000,512578125000,515396075520,515978035200,516560652000,518400000000,521838526464,522427760640,523017660150,524288000000,524880000000,527343750000,528958107648,530841600000,531441000000,533935546875,536870912000,537477120000,538084012500,540000000000,543581798400,544195584000,546750000000,549316406250,549755813888,550376570880,550998028800,552960000000,553584375000,557256278016,557885504160,559872000000,562500000000,564859072962,566231040000,566870400000,569531250000,573308928000,573956280000,576000000000,576650390625,579820584960,580475289600,581130733500,583200000000,585937500000,587068342272,587731230720,589824000000,590490000000,593261718750,595077871104,597196800000,597871125000,600000000000,603979776000,604661760000,607500000000,610351562500,611529523200,612220032000,614400000000,615093750000,618475290624,619173642240,619872782400,622080000000,622782421875,625000000000,626913312768,627621192180,629145600000,629856000000,632812500000,637009920000,637729200000,640000000000,640722656250,644245094400,644972544000,645700815000,648000000000,652298158080,653034700800,655360000000,656100000000,659179687500,660451885056,661197634560,663552000000,664301250000,669462604992,671088640000,671846400000,672605015625,675000000000,679477248000,680244480000,683437500000,687194767360,687970713600,688747536000,691200000000,691980468750,695784701952,696570347520,697356880200,699840000000,703125000000,705277476864,707788800000,708588000000,711914062500,716636160000,717445350000,720000000000,724775731200,725594112000,726413416875,729000000000,732421875000,733835427840,734664038400,737280000000,738112500000,743008370688,743847338880,746496000000,747338906250,750000000000,753145430616,754974720000,755827200000,759375000000,762939453125,764411904000,765275040000,768000000000,768867187500,773094113280,773967052800,774840978000,777600000000,781250000000,782757789696,783641640960,784526490225,786432000000,787320000000,791015625000,793437161472,796262400000,797161500000,800000000000,805306368000,806215680000,807126018750,810000000000,815372697600,816293376000,819200000000,820125000000,823974609375,824633720832,825564856320,826497043200,829440000000,830376562500,835884417024,836828256240,838860800000,839808000000,843750000000,847288609443,849346560000,850305600000,854296875000,858993459200,859963392000,860934420000,864000000000,869730877440,870712934400,871696100250,874800000000,878906250000,880602513408,881596846080,884736000000,885735000000,889892578125,892616806656,895795200000,896806687500,900000000000,905969664000,906992640000,911250000000,915527343750,917294284800,918330048000,921600000000,922640625000,927712935936,928760463360,929809173600,933120000000,937500000000,940369969152,941431788270,943718400000,944784000000,949218750000,955514880000,956593800000,960000000000,961083984375,966367641600,967458816000,968551222500,972000000000,976562500000,978447237120,979552051200,983040000000,984150000000,988769531250,990677827584,991796451840,995328000000,996451875000,1000000000000,1004193907488,1006632960000,1007769600000,1012500000000,1019215872000,1020366720000,1024000000000,1025156250000,1030792151040,1031956070400,1033121304000,1036800000000,1037970703125,1043677052928,1044855521280,1046035320300,1048576000000,1049760000000,1054687500000,1057916215296,1061683200000,1062882000000,1067871093750,1073741824000,1074954240000,1076168025000,1080000000000,1087163596800,1088391168000,1093500000000,1098632812500,1099511627776,1100753141760,1101996057600,1105920000000,1107168750000,1114512556032,1115771008320,1119744000000,1121008359375,1125000000000,1129718145924,1132462080000,1133740800000,1139062500000,1146617856000,1147912560000,1152000000000,1153300781250,1159641169920,1160950579200,1162261467000,1166400000000,1171875000000,1174136684544,1175462461440,1179648000000,1180980000000,1186523437500,1190155742208,1194393600000,1195742250000,1200000000000,1207959552000,1209323520000,1210689028125,1215000000000,1220703125000,1223059046400,1224440064000,1228800000000,1230187500000,1236950581248,1238347284480,1239745564800,1244160000000,1245564843750,1250000000000,1253826625536,1255242384360,1258291200000,1259712000000,1265625000000,1274019840000,1275458400000,1280000000000,1281445312500,1288490188800,1289945088000,1291401630000,1296000000000,1304596316160,1306069401600,1307544150375,1310720000000,1312200000000,1318359375000,1320903770112,1322395269120,1327104000000,1328602500000,1338925209984,1342177280000,1343692800000,1345210031250,1350000000000,1358954496000,1360488960000,1366875000000,1373291015625,1374389534720,1375941427200,1377495072000,1382400000000,1383960937500,1391569403904,1393140695040,1394713760400,1399680000000,1406250000000,1410554953728,1412147682405,1415577600000,1417176000000,1423828125000,1433272320000,1434890700000,1440000000000,1449551462400,1451188224000,1452826833750,1458000000000,1464843750000,1467670855680,1469328076800,1474560000000,1476225000000,1483154296875,1486016741376,1487694677760,1492992000000,1494677812500,1500000000000,1506290861232,1509949440000,1511654400000,1518750000000,1525878906250,1528823808000,1530550080000,1536000000000,1537734375000,1546188226560,1547934105600,1549681956000,1555200000000,1562500000000,1565515579392,1567283281920,1569052980450,1572864000000,1574640000000,1582031250000,1586874322944,1592524800000,1594323000000,1600000000000,1601806640625,1610612736000,1612431360000,1614252037500,1620000000000,1630745395200,1632586752000,1638400000000,1640250000000,1647949218750,1649267441664,1651129712640,1652994086400,1658880000000,1660753125000,1671768834048,1673656512480,1677721600000,1679616000000,1687500000000,1694577218886,1698693120000,1700611200000,1708593750000,1717986918400,1719926784000,1721868840000,1728000000000,1729951171875,1739461754880,1741425868800,1743392200500,1749600000000,1757812500000,1761205026816,1763193692160,1769472000000,1771470000000,1779785156250,1785233613312,1791590400000,1793613375000,1800000000000,1811939328000,1813985280000,1822500000000,1831054687500,1834588569600,1836660096000,1843200000000,1845281250000,1855425871872,1857520926720,1859618347200,1866240000000,1868347265625,1875000000000,1880739938304,1882863576540,1887436800000,1889568000000,1898437500000,1911029760000,1913187600000,1920000000000,1922167968750,1932735283200,1934917632000,1937102445000,1944000000000,1953125000000,1956894474240,1959104102400,1966080000000,1968300000000,1977539062500,1981355655168,1983592903680,1990656000000,1992903750000,2000000000000,2008387814976,2013265920000,2015539200000,2017815046875,2025000000000,2038431744000,2040733440000,2048000000000,2050312500000,2061584302080,2063912140800,2066242608000,2073600000000,2075941406250,2087354105856,2089711042560,2092070640600,2097152000000,2099520000000,2109375000000,2115832430592,2123366400000,2125764000000,2135742187500,2147483648000,2149908480000,2152336050000,2160000000000,2174327193600,2176782336000,2179240250625,2187000000000,2197265625000,2199023255552,2201506283520,2203992115200,2211840000000,2214337500000,2229025112064,2231542016640,2239488000000,2242016718750,2250000000000,2259436291848,2264924160000,2267481600000,2278125000000,2288818359375,2293235712000,2295825120000,2304000000000,2306601562500,2319282339840,2321901158400,2324522934000,2332800000000,2343750000000,2348273369088,2350924922880,2353579470675,2359296000000,2361960000000,2373046875000,2380311484416,2388787200000,2391484500000,2400000000000,2415919104000,2418647040000,2421378056250,2430000000000,2441406250000,2446118092800,2448880128000,2457600000000,2460375000000,2471923828125,2473901162496,2476694568960,2479491129600,2488320000000,2491129687500,2500000000000,2507653251072,2510484768720,2516582400000,2519424000000,2531250000000,2541865828329,2548039680000,2550916800000,2560000000000,2562890625000,2576980377600,2579890176000,2582803260000,2592000000000,2609192632320,2612138803200,2615088300750,2621440000000,2624400000000,2636718750000,2641807540224,2644790538240,2654208000000,2657205000000,2669677734375,2677850419968,2684354560000,2687385600000,2690420062500,2700000000000,2717908992000,2720977920000,2733750000000,2746582031250,2748779069440,2751882854400,2754990144000,2764800000000,2767921875000,2783138807808,2786281390080,2789427520800,2799360000000,2812500000000,2821109907456,2824295364810,2831155200000,2834352000000,2847656250000,2866544640000,2869781400000,2880000000000,2883251953125,2899102924800,2902376448000,2905653667500,2916000000000,2929687500000,2935341711360,2938656153600,2949120000000,2952450000000,2966308593750,2972033482752,2975389355520,2985984000000,2989355625000,3000000000000,3012581722464,3019898880000,3023308800000,3037500000000,3051757812500,3057647616000,3061100160000,3072000000000,3075468750000,3092376453120,3095868211200,3099363912000,3110400000000,3113912109375,3125000000000,3131031158784,3134566563840,3138105960900,3145728000000,3149280000000,3164062500000,3173748645888,3185049600000,3188646000000,3200000000000,3203613281250,3221225472000,3224862720000,3228504075000,3240000000000,3261490790400,3265173504000,3276800000000,3280500000000,3295898437500,3298534883328,3302259425280,3305988172800,3317760000000,3321506250000,3343537668096,3347313024960,3355443200000,3359232000000,3363025078125,3375000000000,3389154437772,3397386240000,3401222400000,3417187500000,3435973836800,3439853568000,3443737680000,3456000000000,3459902343750,3478923509760,3482851737600,3486784401000,3499200000000,3515625000000,3522410053632,3526387384320,3538944000000,3542940000000,3559570312500,3570467226624,3583180800000,3587226750000,3600000000000,3623878656000,3627970560000,3632067084375,3645000000000,3662109375000,3669177139200,3673320192000,3686400000000,3690562500000,3710851743744,3715041853440,3719236694400,3732480000000,3736694531250,3750000000000,3761479876608,3765727153080,3774873600000,3779136000000,3796875000000,3814697265625,3822059520000,3826375200000,3840000000000,3844335937500,3865470566400,3869835264000,3874204890000,3888000000000,3906250000000,3913788948480,3918208204800,3922632451125,3932160000000,3936600000000,3955078125000,3962711310336,3967185807360,3981312000000,3985807500000,4000000000000,4016775629952,4026531840000,4031078400000,4035630093750,4050000000000,4076863488000,4081466880000,4096000000000,4100625000000,4119873046875,4123168604160,4127824281600,4132485216000,4147200000000,4151882812500,4174708211712,4179422085120,4184141281200,4194304000000,4199040000000,4218750000000,4231664861184,4236443047215,4246732800000,4251528000000,4271484375000,4294967296000,4299816960000,4304672100000,4320000000000,4348654387200,4353564672000,4358480501250,4374000000000,4394531250000,4398046511104,4403012567040,4407984230400,4423680000000,4428675000000,4449462890625,4458050224128,4463084033280,4478976000000,4484033437500,4500000000000,4518872583696,4529848320000,4534963200000,4556250000000,4577636718750,4586471424000,4591650240000,4608000000000,4613203125000,4638564679680,4643802316800,4649045868000,4665600000000,4687500000000,4696546738176,4701849845760,4707158941350,4718592000000,4723920000000,4746093750000,4760622968832,4777574400000,4782969000000,4800000000000,4805419921875,4831838208000,4837294080000,4842756112500,4860000000000,4882812500000,4892236185600,4897760256000,4915200000000,4920750000000,4943847656250,4947802324992,4953389137920,4958982259200,4976640000000,4982259375000,5000000000000,5015306502144,5020969537440,5033164800000,5038848000000,5062500000000,5083731656658,5096079360000,5101833600000,5120000000000,5125781250000,5153960755200,5159780352000,5165606520000,5184000000000,5189853515625,5218385264640,5224277606400,5230176601500,5242880000000,5248800000000,5273437500000,5283615080448,5289581076480,5308416000000,5314410000000,5339355468750,5355700839936,5368709120000,5374771200000,5380840125000,5400000000000,5435817984000,5441955840000,5467500000000,5493164062500,5497558138880,5503765708800,5509980288000,5529600000000,5535843750000,5566277615616,5572562780160,5578855041600,5598720000000,5605041796875,5625000000000,5642219814912,5648590729620,5662310400000,5668704000000,5695312500000,5733089280000,5739562800000,5760000000000,5766503906250,5798205849600,5804752896000,5811307335000,5832000000000,5859375000000,5870683422720,5877312307200,5898240000000,5904900000000,5932617187500,5944066965504,5950778711040,5971968000000,5978711250000,6000000000000,6025163444928,6039797760000,6046617600000,6053445140625,6075000000000,6103515625000,6115295232000,6122200320000,6144000000000,6150937500000,6184752906240,6191736422400,6198727824000,6220800000000,6227824218750,6250000000000,6262062317568,6269133127680,6276211921800,6291456000000,6298560000000,6328125000000,6347497291776,6370099200000,6377292000000,6400000000000,6407226562500,6442450944000,6449725440000,6457008150000,6480000000000,6522981580800,6530347008000,6537720751875,6553600000000,6561000000000,6591796875000,6597069766656,6604518850560,6611976345600,6635520000000,6643012500000,6687075336192,6694626049920,6710886400000,6718464000000,6726050156250,6750000000000,6778308875544,6794772480000,6802444800000,6834375000000,6866455078125,6871947673600,6879707136000,6887475360000,6912000000000,6919804687500,6957847019520,6965703475200,6973568802000,6998400000000,7031250000000,7044820107264,7052774768640,7060738412025,7077888000000,7085880000000,7119140625000,7140934453248,7166361600000,7174453500000,7200000000000,7247757312000,7255941120000,7264134168750,7290000000000,7324218750000,7338354278400,7346640384000,7372800000000,7381125000000,7415771484375,7421703487488,7430083706880,7438473388800,7464960000000,7473389062500,7500000000000,7522959753216,7531454306160,7549747200000,7558272000000,7593750000000,7625597484987,7629394531250,7644119040000,7652750400000,7680000000000,7688671875000,7730941132800,7739670528000,7748409780000,7776000000000,7812500000000,7827577896960,7836416409600,7845264902250,7864320000000,7873200000000,7910156250000,7925422620672,7934371614720,7962624000000,7971615000000,8000000000000,8009033203125,8033551259904,8053063680000,8062156800000,8071260187500,8100000000000,8153726976000,8162933760000,8192000000000,8201250000000,8239746093750,8246337208320,8255648563200,8264970432000,8294400000000,8303765625000,8349416423424,8358844170240,8368282562400,8388608000000,8398080000000,8437500000000,8463329722368,8472886094430,8493465600000,8503056000000,8542968750000,8589934592000,8599633920000,8609344200000,8640000000000,8649755859375,8697308774400,8707129344000,8716961002500,8748000000000,8789062500000,8796093022208,8806025134080,8815968460800,8847360000000,8857350000000,8898925781250,8916100448256,8926168066560,8957952000000,8968066875000,9000000000000,9037745167392,9059696640000,9069926400000,9112500000000,9155273437500,9172942848000,9183300480000,9216000000000,9226406250000,9277129359360,9287604633600,9298091736000,9331200000000,9341736328125,9375000000000,9393093476352,9403699691520,9414317882700,9437184000000,9447840000000,9492187500000,9521245937664,9555148800000,9565938000000,9600000000000,9610839843750,9663676416000,9674588160000,9685512225000,9720000000000,9765625000000,9784472371200,9795520512000,9830400000000,9841500000000,9887695312500,9895604649984,9906778275840,9917964518400,9953280000000,9964518750000,10000000000000,10030613004288,10041939074880,10066329600000,10077696000000,10089075234375,10125000000000,10167463313316,10192158720000,10203667200000,10240000000000,10251562500000,10307921510400,10319560704000,10331213040000,10368000000000,10379707031250,10436770529280,10448555212800,10460353203000,10485760000000,10497600000000,10546875000000,10567230160896,10579162152960,10616832000000,10628820000000,10678710937500,10711401679872,10737418240000,10749542400000,10761680250000,10800000000000,10871635968000,10883911680000,10896201253125,10935000000000,10986328125000,10995116277760,11007531417600,11019960576000,11059200000000,11071687500000,11132555231232,11145125560320,11157710083200,11197440000000,11210083593750,11250000000000,11284439629824,11297181459240,11324620800000,11337408000000,11390625000000,11444091796875,11466178560000,11479125600000,11520000000000,11533007812500,11596411699200,11609505792000,11622614670000,11664000000000,11718750000000,11741366845440,11754624614400,11767897353375,11796480000000,11809800000000,11865234375000,11888133931008,11901557422080,11943936000000,11957422500000,12000000000000,12050326889856,12079595520000,12093235200000,12106890281250,12150000000000,12207031250000,12230590464000,12244400640000,12288000000000,12301875000000,12359619140625,12369505812480,12383472844800,12397455648000,12441600000000,12455648437500,12500000000000,12524124635136,12538266255360,12552423843600,12582912000000,12597120000000,12656250000000,12694994583552,12709329141645,12740198400000,12754584000000,12800000000000,12814453125000,12884901888000,12899450880000,12914016300000,12960000000000,13045963161600,13060694016000,13075441503750,13107200000000,13122000000000,13183593750000,13194139533312,13209037701120,13223952691200,13271040000000,13286025000000,13348388671875,13374150672384,13389252099840,13421772800000,13436928000000,13452100312500,13500000000000,13556617751088,13589544960000,13604889600000,13668750000000,13732910156250,13743895347200,13759414272000,13774950720000,13824000000000,13839609375000,13915694039040,13931406950400,13947137604000,13996800000000,14062500000000,14089640214528,14105549537280,14121476824050,14155776000000,14171760000000,14238281250000,14281868906496,14332723200000,14348907000000,14400000000000,14416259765625,14495514624000,14511882240000,14528268337500,14580000000000,14648437500000,14676708556800,14693280768000,14745600000000,14762250000000,14831542968750,14843406974976,14860167413760,14876946777600,14929920000000,14946778125000,15000000000000,15045919506432,15062908612320,15099494400000,15116544000000,15187500000000,15251194969974,15258789062500,15288238080000,15305500800000,15360000000000,15377343750000,15461882265600,15479341056000,15496819560000,15552000000000,15569560546875,15625000000000,15655155793920,15672832819200,15690529804500,15728640000000,15746400000000,15820312500000,15850845241344,15868743229440,15925248000000,15943230000000,16000000000000,16018066406250,16067102519808,16106127360000,16124313600000,16142520375000,16200000000000,16307453952000,16325867520000,16384000000000,16402500000000,16479492187500,16492674416640,16511297126400,16529940864000,16588800000000,16607531250000,16698832846848,16717688340480,16736565124800,16777216000000,16796160000000,16815125390625,16875000000000,16926659444736,16945772188860,16986931200000,17006112000000,17085937500000,17179869184000,17199267840000,17218688400000,17280000000000,17299511718750,17394617548800,17414258688000,17433922005000,17496000000000,17578125000000,17592186044416,17612050268160,17631936921600,17694720000000,17714700000000,17797851562500,17832200896512,17852336133120,17915904000000,17936133750000,18000000000000,18075490334784,18119393280000,18139852800000,18160335421875,18225000000000,18310546875000,18345885696000,18366600960000,18432000000000,18452812500000,18554258718720,18575209267200,18596183472000,18662400000000,18683472656250,18750000000000,18786186952704,18807399383040,18828635765400,18874368000000,18895680000000,18984375000000,19042491875328,19073486328125,19110297600000,19131876000000,19200000000000,19221679687500,19327352832000,19349176320000,19371024450000,19440000000000,19531250000000,19568944742400,19591041024000,19613162255625,19660800000000,19683000000000,19775390625000,19791209299968,19813556551680,19835929036800,19906560000000,19929037500000,20000000000000,20061226008576,20083878149760,20132659200000,20155392000000,20178150468750,20250000000000,20334926626632,20384317440000,20407334400000,20480000000000,20503125000000,20599365234375,20615843020800,20639121408000,20662426080000,20736000000000,20759414062500,20873541058560,20897110425600,20920706406000,20971520000000,20995200000000,21093750000000,21134460321792,21158324305920,21182215236075,21233664000000,21257640000000,21357421875000,21422803359744,21474836480000,21499084800000,21523360500000,21600000000000,21743271936000,21767823360000,21792402506250,21870000000000,21972656250000,21990232555520,22015062835200,22039921152000,22118400000000,22143375000000,22247314453125,22265110462464,22290251120640,22315420166400,22394880000000,22420167187500,22500000000000,22568879259648,22594362918480,22649241600000,22674816000000,22781250000000,22876792454961,22888183593750,22932357120000,22958251200000,23040000000000,23066015625000,23192823398400,23219011584000,23245229340000,23328000000000,23437500000000,23482733690880,23509249228800,23535794706750,23592960000000,23619600000000,23730468750000,23776267862016,23803114844160,23887872000000,23914845000000,24000000000000,24027099609375,24100653779712,24159191040000,24186470400000,24213780562500,24300000000000,24414062500000,24461180928000,24488801280000,24576000000000,24603750000000,24719238281250,24739011624960,24766945689600,24794911296000,24883200000000,24911296875000,25000000000000,25048249270272,25076532510720,25104847687200,25165824000000,25194240000000,25312500000000,25389989167104,25418658283290,25480396800000,25509168000000,25600000000000,25628906250000,25769803776000,25798901760000,25828032600000,25920000000000,25949267578125,26091926323200,26121388032000,26150883007500,26214400000000,26244000000000,26367187500000,26388279066624,26418075402240,26447905382400,26542080000000,26572050000000,26696777343750,26748301344768,26778504199680,26843545600000,26873856000000,26904200625000,27000000000000,27113235502176,27179089920000,27209779200000,27337500000000,27465820312500,27487790694400,27518828544000,27549901440000,27648000000000,27679218750000,27831388078080,27862813900800,27894275208000,27993600000000,28025208984375,28125000000000,28179280429056,28211099074560,28242953648100,28311552000000,28343520000000,28476562500000,28563737812992,28665446400000,28697814000000,28800000000000,28832519531250,28991029248000,29023764480000,29056536675000,29160000000000,29296875000000,29353417113600,29386561536000,29491200000000,29524500000000,29663085937500,29686813949952,29720334827520,29753893555200,29859840000000,29893556250000,30000000000000,30091839012864,30125817224640,30198988800000,30233088000000,30267225703125,30375000000000,30502389939948,30517578125000,30576476160000,30611001600000,30720000000000,30754687500000,30923764531200,30958682112000,30993639120000,31104000000000,31139121093750,31250000000000,31310311587840,31345665638400,31381059609000,31457280000000,31492800000000,31640625000000,31701690482688,31737486458880,31850496000000,31886460000000,32000000000000,32036132812500,32134205039616,32212254720000,32248627200000,32285040750000,32400000000000,32614907904000,32651735040000,32688603759375,32768000000000,32805000000000,32958984375000,32985348833280,33022594252800,33059881728000,33177600000000,33215062500000,33397665693696,33435376680960,33473130249600,33554432000000,33592320000000,33630250781250,33750000000000,33853318889472,33891544377720,33973862400000,34012224000000,34171875000000,34332275390625,34359738368000,34398535680000,34437376800000,34560000000000,34599023437500,34789235097600,34828517376000,34867844010000,34992000000000,35156250000000,35184372088832,35224100536320,35263873843200,35303692060125,35389440000000,35429400000000,35595703125000,35664401793024,35704672266240,35831808000000,35872267500000,36000000000000,36150980669568,36238786560000,36279705600000,36320670843750,36450000000000,36621093750000,36691771392000,36733201920000,36864000000000,36905625000000,37078857421875,37108517437440,37150418534400,37192366944000,37324800000000,37366945312500,37500000000000,37572373905408,37614798766080,37657271530800,37748736000000,37791360000000,37968750000000,38084983750656,38127987424935,38146972656250,38220595200000,38263752000000,38400000000000,38443359375000,38654705664000,38698352640000,38742048900000,38880000000000,39062500000000,39137889484800,39182082048000,39226324511250,39321600000000,39366000000000,39550781250000,39582418599936,39627113103360,39671858073600,39813120000000,39858075000000,40000000000000,40045166015625,40122452017152,40167756299520,40265318400000,40310784000000,40356300937500,40500000000000,40669853253264,40768634880000,40814668800000,40960000000000,41006250000000,41198730468750,41231686041600,41278242816000,41324852160000,41472000000000,41518828125000,41747082117120,41794220851200,41841412812000,41943040000000,41990400000000,42187500000000,42268920643584,42316648611840,42364430472150,42467328000000,42515280000000,42714843750000,42845606719488,42949672960000,42998169600000,43046721000000,43200000000000,43248779296875,43486543872000,43535646720000,43584805012500,43740000000000,43945312500000,43980465111040,44030125670400,44079842304000,44236800000000,44286750000000,44494628906250,44530220924928,44580502241280,44630840332800,44789760000000,44840334375000,45000000000000,45137758519296,45188725836960,45298483200000,45349632000000,45562500000000,45753584909922,45776367187500,45864714240000,45916502400000,46080000000000,46132031250000,46385646796800,46438023168000,46490458680000,46656000000000,46708681640625,46875000000000,46965467381760,47018498457600,47071589413500,47185920000000,47239200000000,47460937500000,47552535724032,47606229688320,47775744000000,47829690000000,48000000000000,48054199218750,48201307559424,48318382080000,48372940800000,48427561125000,48600000000000,48828125000000,48922361856000,48977602560000,49152000000000,49207500000000,49438476562500,49478023249920,49533891379200,49589822592000,49766400000000,49822593750000,50000000000000,50096498540544,50153065021440,50209695374400,50331648000000,50388480000000,50445376171875,50625000000000,50779978334208,50837316566580,50960793600000,51018336000000,51200000000000,51257812500000,51539607552000,51597803520000,51656065200000,51840000000000,51898535156250,52183852646400,52242776064000,52301766015000,52428800000000,52488000000000,52734375000000,52776558133248,52836150804480,52895810764800,53084160000000,53144100000000,53393554687500,53496602689536,53557008399360,53687091200000,53747712000000,53808401250000,54000000000000,54226471004352,54358179840000,54419558400000,54481006265625,54675000000000,54931640625000,54975581388800,55037657088000,55099802880000,55296000000000,55358437500000,55662776156160,55725627801600,55788550416000,55987200000000,56050417968750,56250000000000,56358560858112,56422198149120,56485907296200,56623104000000,56687040000000,56953125000000,57127475625984,57220458984375,57330892800000,57395628000000,57600000000000,57665039062500,57982058496000,58047528960000,58113073350000,58320000000000,58593750000000,58706834227200,58773123072000,58839486766875,58982400000000,59049000000000,59326171875000,59373627899904,59440669655040,59507787110400,59719680000000,59787112500000,60000000000000,60183678025728,60251634449280,60397977600000,60466176000000,60534451406250,60750000000000,61004779879896,61035156250000,61152952320000,61222003200000,61440000000000,61509375000000,61798095703125,61847529062400,61917364224000,61987278240000,62208000000000,62278242187500,62500000000000,62620623175680,62691331276800,62762119218000,62914560000000,62985600000000,63281250000000,63403380965376,63474972917760,63546645708225,63700992000000,63772920000000,64000000000000,64072265625000,64268410079232,64424509440000,64497254400000,64570081500000,64800000000000,65229815808000,65303470080000,65377207518750,65536000000000,65610000000000,65917968750000,65970697666560,66045188505600,66119763456000,66355200000000,66430125000000,66741943359375,66795331387392,66870753361920,66946260499200,67108864000000,67184640000000,67260501562500,67500000000000,67706637778944,67783088755440,67947724800000,68024448000000,68343750000000,68630377364883,68664550781250,68719476736000,68797071360000,68874753600000,69120000000000,69198046875000,69578470195200,69657034752000,69735688020000,69984000000000,70312500000000,70368744177664,70448201072640,70527747686400,70607384120250,70778880000000,70858800000000,71191406250000,71328803586048,71409344532480,71663616000000,71744535000000,72000000000000,72081298828125,72301961339136,72477573120000,72559411200000,72641341687500,72900000000000,73242187500000,73383542784000,73466403840000,73728000000000,73811250000000,74157714843750,74217034874880,74300837068800,74384733888000,74649600000000,74733890625000,75000000000000,75144747810816,75229597532160,75314543061600,75497472000000,75582720000000,75937500000000,76169967501312,76255974849870,76293945312500,76441190400000,76527504000000,76800000000000,76886718750000,77309411328000,77396705280000,77484097800000,77760000000000,77847802734375,78125000000000,78275778969600,78364164096000,78452649022500,78643200000000,78732000000000,79101562500000,79164837199872,79254226206720,79343716147200,79626240000000,79716150000000,80000000000000,80090332031250,80244904034304,80335512599040,80530636800000,80621568000000,80712601875000,81000000000000,81339706506528,81537269760000,81629337600000,81920000000000,82012500000000,82397460937500,82463372083200,82556485632000,82649704320000,82944000000000,83037656250000,83494164234240,83588441702400,83682825624000,83886080000000,83980800000000,84075626953125,84375000000000,84537841287168,84633297223680,84728860944300,84934656000000,85030560000000,85429687500000,85691213438976,85899345920000,85996339200000,86093442000000,86400000000000,86497558593750,86973087744000,87071293440000,87169610025000,87480000000000,87890625000000,87960930222080,88060251340800,88159684608000,88473600000000,88573500000000,88989257812500,89060441849856,89161004482560,89261680665600,89579520000000,89680668750000,90000000000000,90275517038592,90377451673920,90596966400000,90699264000000,90801677109375,91125000000000,91507169819844,91552734375000,91729428480000,91833004800000,92160000000000,92264062500000,92771293593600,92876046336000,92980917360000,93312000000000,93417363281250,93750000000000,93930934763520,94036996915200,94143178827000,94371840000000,94478400000000,94921875000000,95105071448064,95212459376640,95367431640625,95551488000000,95659380000000,96000000000000,96108398437500,96402615118848,96636764160000,96745881600000,96855122250000,97200000000000,97656250000000,97844723712000,97955205120000,98065811278125,98304000000000,98415000000000,98876953125000,98956046499840,99067782758400,99179645184000,99532800000000,99645187500000,100000000000000,100192997081088,100306130042880,100419390748800,100663296000000,100776960000000,100890752343750,101250000000000,101559956668416,101674633133160,101921587200000,102036672000000,102400000000000,102515625000000,102996826171875,103079215104000,103195607040000,103312130400000,103680000000000,103797070312500,104367705292800,104485552128000,104603532030000,104857600000000,104976000000000,105468750000000,105553116266496,105672301608960,105791621529600,105911076180375,106168320000000,106288200000000,106787109375000,106993205379072,107114016798720,107374182400000,107495424000000,107616802500000,108000000000000,108452942008704,108716359680000,108839116800000,108962012531250,109350000000000,109863281250000,109951162777600,110075314176000,110199605760000,110592000000000,110716875000000,111236572265625,111325552312320,111451255603200,111577100832000,111974400000000,112100835937500,112500000000000,112717121716224,112844396298240,112971814592400,113246208000000,113374080000000,113906250000000,114254951251968,114383962274805,114440917968750,114661785600000,114791256000000,115200000000000,115330078125000,115964116992000,116095057920000,116226146700000,116640000000000,117187500000000,117413668454400,117546246144000,117678973533750,117964800000000,118098000000000,118652343750000,118747255799808,118881339310080,119015574220800,119439360000000,119574225000000,120000000000000,120135498046875,120367356051456,120503268898560,120795955200000,120932352000000,121068902812500,121500000000000,122009559759792,122070312500000,122305904640000,122444006400000,122880000000000,123018750000000,123596191406250,123695058124800,123834728448000,123974556480000,124416000000000,124556484375000,125000000000000,125241246351360,125382662553600,125524238436000,125829120000000,125971200000000,126562500000000,126806761930752,126949945835520,127093291416450,127401984000000,127545840000000,128000000000000,128144531250000,128536820158464,128849018880000,128994508800000,129140163000000,129600000000000,129746337890625,130459631616000,130606940160000,130754415037500,131072000000000,131220000000000,131835937500000,131941395333120,132090377011200,132239526912000,132710400000000,132860250000000,133483886718750,133590662774784,133741506723840,133892520998400,134217728000000,134369280000000,134521003125000,135000000000000,135413275557888,135566177510880,135895449600000,136048896000000,136687500000000,137260754729766,137329101562500,137438953472000,137594142720000,137749507200000,138240000000000,138396093750000,139156940390400,139314069504000,139471376040000,139968000000000,140126044921875,140625000000000,140737488355328,140896402145280,141055495372800,141214768240500,141557760000000,141717600000000,142382812500000,142657607172096,142818689064960,143327232000000,143489070000000,144000000000000,144162597656250,144603922678272,144955146240000,145118822400000,145282683375000,145800000000000,146484375000000,146767085568000,146932807680000,147456000000000,147622500000000,148315429687500,148434069749760,148601674137600,148769467776000,149299200000000,149467781250000,150000000000000,150289495621632,150459195064320,150629086123200,150994944000000,151165440000000,151336128515625,151875000000000,152339935002624,152511949699740,152587890625000,152882380800000,153055008000000,153600000000000,153773437500000,154618822656000,154793410560000,154968195600000,155520000000000,155695605468750,156250000000000,156551557939200,156728328192000,156905298045000,157286400000000,157464000000000,158203125000000,158329674399744,158508452413440,158687432294400,159252480000000,159432300000000,160000000000000,160180664062500,160489808068608,160671025198080,161061273600000,161243136000000,161425203750000,162000000000000,162679413013056,163074539520000,163258675200000,163443018796875,163840000000000,164025000000000,164794921875000,164926744166400,165112971264000,165299408640000,165888000000000,166075312500000,166988328468480,167176883404800,167365651248000,167772160000000,167961600000000,168151253906250,168750000000000,169075682574336,169266594447360,169457721888600,169869312000000,170061120000000,170859375000000,171382426877952,171661376953125,171798691840000,171992678400000,172186884000000,172800000000000,172995117187500,173946175488000,174142586880000,174339220050000,174960000000000,175781250000000,175921860444160,176120502681600,176319369216000,176518460300625,176947200000000,177147000000000,177978515625000,178120883699712,178322008965120,178523361331200,179159040000000,179361337500000,180000000000000,180551034077184,180754903347840,181193932800000,181398528000000,181603354218750,182250000000000,183014339639688,183105468750000,183458856960000,183666009600000,184320000000000,184528125000000,185394287109375,185542587187200,185752092672000,185961834720000,186624000000000,186834726562500,187500000000000,187861869527040,188073993830400,188286357654000,188743680000000,188956800000000,189843750000000,190210142896128,190424918753280,190639937124675,190734863281250,191102976000000,191318760000000,192000000000000,192216796875000,192805230237696,193273528320000,193491763200000,193710244500000,194400000000000,195312500000000,195689447424000,195910410240000,196131622556250,196608000000000,196830000000000,197753906250000,197912092999680,198135565516800,198359290368000,199065600000000,199290375000000,200000000000000,200225830078125,200385994162176,200612260085760,200838781497600,201326592000000,201553920000000,201781504687500,202500000000000,203119913336832,203349266266320,203843174400000,204073344000000,204800000000000,205031250000000,205891132094649,205993652343750,206158430208000,206391214080000,206624260800000,207360000000000,207594140625000,208735410585600,208971104256000,209207064060000,209715200000000,209952000000000,210937500000000,211106232532992,211344603217920,211583243059200,211822152360750,212336640000000,212576400000000,213574218750000,213986410758144,214228033597440,214748364800000,214990848000000,215233605000000,216000000000000,216243896484375,216905884017408,217432719360000,217678233600000,217924025062500,218700000000000,219726562500000,219902325555200,220150628352000,220399211520000,221184000000000,221433750000000,222473144531250,222651104624640,222902511206400,223154201664000,223948800000000,224201671875000,225000000000000,225434243432448,225688792596480,225943629184800,226492416000000,226748160000000,227812500000000,228509902503936,228767924549610,228881835937500,229323571200000,229582512000000,230400000000000,230660156250000,231928233984000,232190115840000,232452293400000,233280000000000,233543408203125,234375000000000,234827336908800,235092492288000,235357947067500,235929600000000,236196000000000,237304687500000,237494511599616,237762678620160,238031148441600,238878720000000,239148450000000,240000000000000,240270996093750,240734712102912,241006537797120,241591910400000,241864704000000,242137805625000,243000000000000,244019119519584,244140625000000,244611809280000,244888012800000,245760000000000,246037500000000,247192382812500,247390116249600,247669456896000,247949112960000,248832000000000,249112968750000,250000000000000,250482492702720,250765325107200,251048476872000,251658240000000,251942400000000,252226880859375,253125000000000,253613523861504,253899891671040,254186582832900,254803968000000,255091680000000,256000000000000,256289062500000,257073640316928,257698037760000,257989017600000,258280326000000,259200000000000,259492675781250,260919263232000,261213880320000,261508830075000,262144000000000,262440000000000,263671875000000,263882790666240,264180754022400,264479053824000,265420800000000,265720500000000,266967773437500,267181325549568,267483013447680,267785041996800,268435456000000,268738560000000,269042006250000,270000000000000,270826551115776,271132355021760,271790899200000,272097792000000,272405031328125,273375000000000,274521509459532,274658203125000,274877906944000,275188285440000,275499014400000,276480000000000,276792187500000,278313880780800,278628139008000,278942752080000,279936000000000,280252089843750,281250000000000,281474976710656,281792804290560,282110990745600,282429536481000,283115520000000,283435200000000,284765625000000,285315214344192,285637378129920,286102294921875,286654464000000,286978140000000,288000000000000,288325195312500,289207845356544,289910292480000,290237644800000,290565366750000,291600000000000,292968750000000,293534171136000,293865615360000,294197433834375,294912000000000,295245000000000,296630859375000,296868139499520,297203348275200,297538935552000,298598400000000,298935562500000,300000000000000,300578991243264,300918390128640,301258172246400,301989888000000,302330880000000,302672257031250,303750000000000,304679870005248,305023899399480,305175781250000,305764761600000,306110016000000,307200000000000,307546875000000,308990478515625,309237645312000,309586821120000,309936391200000,311040000000000,311391210937500,312500000000000,313103115878400,313456656384000,313810596090000,314572800000000,314928000000000,316406250000000,316659348799488,317016904826880,317374864588800,317733228541125,318504960000000,318864600000000,320000000000000,320361328125000,320979616137216,321342050396160,322122547200000,322486272000000,322850407500000,324000000000000,325358826026112,326149079040000,326517350400000,326886037593750,327680000000000,328050000000000,329589843750000,329853488332800,330225942528000,330598817280000,331776000000000,332150625000000,333709716796875,333976656936960,334353766809600,334731302496000,335544320000000,335923200000000,336302507812500,337500000000000,338151365148672,338533188894720,338915443777200,339738624000000,340122240000000,341718750000000,342764853755904,343151886824415,343322753906250,343597383680000,343985356800000,344373768000000,345600000000000,345990234375000,347892350976000,348285173760000,348678440100000,349920000000000,351562500000000,351843720888320,352241005363200,352638738432000,353036920601250,353894400000000,354294000000000,355957031250000,356241767399424,356644017930240,357046722662400,358318080000000,358722675000000,360000000000000,360406494140625,361102068154368,361509806695680,362387865600000,362797056000000,363206708437500,364500000000000,366028679279376,366210937500000,366917713920000,367332019200000,368640000000000,369056250000000,370788574218750,371085174374400,371504185344000,371923669440000,373248000000000,373669453125000,375000000000000,375723739054080,376147987660800,376572715308000,377487360000000,377913600000000,379687500000000,380420285792256,380849837506560,381279874249350,381469726562500,382205952000000,382637520000000,384000000000000,384433593750000,385610460475392,386547056640000,386983526400000,387420489000000,388800000000000,389239013671875,390625000000000,391378894848000,391820820480000,392263245112500,393216000000000,393660000000000,395507812500000,395824185999360,396271131033600,396718580736000,398131200000000,398580750000000,400000000000000,400451660156250,400771988324352,401224520171520,401677562995200,402653184000000,403107840000000,403563009375000,405000000000000,406239826673664,406698532532640,407686348800000,408146688000000,409600000000000,410062500000000,411782264189298,411987304687500,412316860416000,412782428160000,413248521600000,414720000000000,415188281250000,417470821171200,417942208512000,418414128120000,419430400000000,419904000000000,420378134765625,421875000000000,422212465065984,422689206435840,423166486118400,423644304721500,424673280000000,425152800000000,427148437500000,427972821516288,428456067194880,429496729600000,429981696000000,430467210000000,432000000000000,432487792968750,433811768034816,434865438720000,435356467200000,435848050125000,437400000000000,439453125000000,439804651110400,440301256704000,440798423040000,442368000000000,442867500000000,444946289062500,445302209249280,445805022412800,446308403328000,447897600000000,448403343750000,450000000000000,450868486864896,451377585192960,451887258369600,452984832000000,453496320000000,454008385546875,455625000000000,457019805007872,457535849099220,457763671875000,458647142400000,459165024000000,460800000000000,461320312500000,463856467968000,464380231680000,464904586800000,466560000000000,467086816406250,468750000000000,469654673817600,470184984576000,470715894135000,471859200000000,472392000000000,474609375000000,474989023199232,475525357240320,476062296883200,476837158203125,477757440000000,478296900000000,480000000000000,480541992187500,481469424205824,482013075594240,483183820800000,483729408000000,484275611250000,486000000000000,488038239039168,488281250000000,489223618560000,489776025600000,490329056390625,491520000000000,492075000000000,494384765625000,494780232499200,495338913792000,495898225920000,497664000000000,498225937500000,500000000000000,500964985405440,501530650214400,502096953744000,503316480000000,503884800000000,504453761718750,506250000000000,507227047723008,507799783342080,508373165665800,509607936000000,510183360000000,512000000000000,512578125000000,514147280633856,514984130859375,515396075520000,515978035200000,516560652000000,518400000000000,518985351562500,521838526464000,522427760640000,523017660150000,524288000000000,524880000000000,527343750000000,527765581332480,528361508044800,528958107648000,529555380901875,530841600000000,531441000000000,533935546875000,534362651099136,534966026895360,535570083993600,536870912000000,537477120000000,538084012500000,540000000000000,541653102231552,542264710043520,543581798400000,544195584000000,544810062656250,546750000000000,549043018919064,549316406250000,549755813888000,550376570880000,550998028800000,552960000000000,553584375000000,556182861328125,556627761561600,557256278016000,557885504160000,559872000000000,560504179687500,562500000000000,562949953421312,563585608581120,564221981491200,564859072962000,566231040000000,566870400000000,569531250000000,570630428688384,571274756259840,571919811374025,572204589843750,573308928000000,573956280000000,576000000000000,576650390625000,578415690713088,579820584960000,580475289600000,581130733500000,583200000000000,585937500000000,587068342272000,587731230720000,588394867668750,589824000000000,590490000000000,593261718750000,593736278999040,594406696550400,595077871104000,597196800000000,597871125000000,600000000000000,600677490234375,601157982486528,601836780257280,602516344492800,603979776000000,604661760000000,605344514062500,607500000000000,609359740010496,610047798798960,610351562500000,611529523200000,612220032000000,614400000000000,615093750000000,617673396283947,617980957031250,618475290624000,619173642240000,619872782400000,622080000000000,622782421875000,625000000000000,626206231756800,626913312768000,627621192180000,629145600000000,629856000000000,632812500000000,633318697598976,634033809653760,634749729177600,635466457082250,637009920000000,637729200000000,640000000000000,640722656250000,641959232274432,642684100792320,644245094400000,644972544000000,645700815000000,648000000000000,648731689453125,650717652052224,652298158080000,653034700800000,653772075187500,655360000000000,656100000000000,659179687500000,659706976665600,660451885056000,661197634560000,663552000000000,664301250000000,667419433593750,667953313873920,668707533619200,669462604992000,671088640000000,671846400000000,672605015625000,675000000000000,676302730297344,677066377789440,677830887554400,679477248000000,680244480000000,683437500000000,685529707511808,686303773648830,686645507812500,687194767360000,687970713600000,688747536000000,691200000000000,691980468750000,695784701952000,696570347520000,697356880200000,699840000000000,700630224609375,703125000000000,703687441776640,704482010726400,705277476864000,706073841202500,707788800000000,708588000000000,711914062500000,712483534798848,713288035860480,714093445324800,716636160000000,717445350000000,720000000000000,720812988281250,722204136308736,723019613391360,724775731200000,725594112000000,726413416875000,729000000000000,732057358558752,732421875000000,733835427840000,734664038400000,737280000000000,738112500000000,741577148437500,742170348748800,743008370688000,743847338880000,746496000000000,747338906250000,750000000000000,751447478108160,752295975321600,753145430616000,754974720000000,755827200000000,756680642578125,759375000000000,760840571584512,761699675013120,762559748498700,762939453125000,764411904000000,765275040000000,768000000000000,768867187500000,771220920950784,773094113280000,773967052800000,774840978000000,777600000000000,778478027343750,781250000000000,782757789696000,783641640960000,784526490225000,786432000000000,787320000000000,791015625000000,791648371998720,792542262067200,793437161472000,796262400000000,797161500000000,800000000000000,800903320312500,801543976648704,802449040343040,803355125990400,805306368000000,806215680000000,807126018750000,810000000000000,812479653347328,813397065065280,815372697600000,816293376000000,817215093984375,819200000000000,820125000000000,823564528378596,823974609375000,824633720832000,825564856320000,826497043200000,829440000000000,830376562500000,834941642342400,835884417024000,836828256240000,838860800000000,839808000000000,840756269531250,843750000000000,844424930131968,845378412871680,846332972236800,847288609443000,849346560000000,850305600000000,854296875000000,855945643032576,856912134389760,858306884765625,858993459200000,859963392000000,860934420000000,864000000000000,864975585937500,867623536069632,869730877440000,870712934400000,871696100250000,874800000000000,878906250000000,879609302220800,880602513408000,881596846080000,882592301503125,884736000000000,885735000000000,889892578125000,890604418498560,891610044825600,892616806656000,895795200000000,896806687500000,900000000000000,901736973729792,902755170385920,903774516739200,905969664000000,906992640000000,908016771093750,911250000000000,914039610015744,915071698198440,915527343750000,917294284800000,918330048000000,921600000000000,922640625000000,926971435546875,927712935936000,928760463360000,929809173600000,933120000000000,934173632812500,937500000000000,939309347635200,940369969152000,941431788270000,943718400000000,944784000000000,949218750000000,949978046398464,951050714480640,952124593766400,953199685623375,953674316406250,955514880000000,956593800000000,960000000000000,961083984375000,962938848411648,964026151188480,966367641600000,967458816000000,968551222500000,972000000000000,976076478078336,976562500000000,978447237120000,979552051200000,980658112781250,983040000000000,984150000000000,988769531250000,989560464998400,990677827584000,991796451840000,995328000000000,996451875000000,1000000000000000,1001129150390625,1001929970810880,1003061300428800,1004193907488000,1006632960000000,1007769600000000,1008907523437500,1012500000000000,1014454095446016,1015599566684160,1016746331331600,1019215872000000,1020366720000000,1024000000000000,1025156250000000,1028294561267712,1029455660473245,1029968261718750,1030792151040000,1031956070400000,1033121304000000,1036800000000000,1037970703125000,1043677052928000,1044855521280000,1046035320300000,1048576000000000,1049760000000000,1054687500000000,1055531162664960,1056723016089600,1057916215296000,1059110761803750,1061683200000000,1062882000000000,1067871093750000,1068725302198272,1069932053790720,1071140167987200,1073741824000000,1074954240000000,1076168025000000,1080000000000000,1081219482421875,1083306204463104,1084529420087040,1087163596800000,1088391168000000,1089620125312500,1093500000000000,1098086037838128,1098632812500000,1099511627776000,1100753141760000,1101996057600000,1105920000000000,1107168750000000,1112365722656250,1113255523123200,1114512556032000,1115771008320000,1119744000000000,1121008359375000,1125000000000000,1125899906842624,1127171217162240,1128443962982400,1129718145924000,1132462080000000,1133740800000000,1139062500000000,1141260857376768,1142549512519680,1143839622748050,1144409179687500,1146617856000000,1147912560000000,1152000000000000,1153300781250000,1156831381426176,1159641169920000,1160950579200000,1162261467000000,1166400000000000,1167717041015625,1171875000000000,1174136684544000,1175462461440000,1176789735337500,1179648000000000,1180980000000000,1186523437500000,1187472557998080,1188813393100800,1190155742208000,1194393600000000,1195742250000000,1200000000000000,1201354980468750,1202315964973056,1203673560514560,1205032688985600,1207959552000000,1209323520000000,1210689028125000,1215000000000000,1218719480020992,1220095597597920,1220703125000000,1223059046400000,1224440064000000,1228800000000000,1230187500000000,1235346792567894,1235961914062500,1236950581248000,1238347284480000,1239745564800000,1244160000000000,1245564843750000,1250000000000000,1252412463513600,1253826625536000,1255242384360000,1258291200000000,1259712000000000,1261134404296875,1265625000000000,1266637395197952,1268067619307520,1269499458355200,1270932914164500,1274019840000000,1275458400000000,1280000000000000,1281445312500000,1283918464548864,1285368201584640,1288490188800000,1289945088000000,1291401630000000,1296000000000000,1297463378906250,1301435304104448,1304596316160000,1306069401600000,1307544150375000,1310720000000000,1312200000000000,1318359375000000,1319413953331200,1320903770112000,1322395269120000,1327104000000000,1328602500000000,1334838867187500,1335906627747840,1337415067238400,1338925209984000,1342177280000000,1343692800000000,1345210031250000,1350000000000000,1352605460594688,1354132755578880,1355661775108800,1358954496000000,1360488960000000,1362025156640625,1366875000000000,1371059415023616,1372607547297660,1373291015625000,1374389534720000,1375941427200000,1377495072000000,1382400000000000,1383960937500000,1391569403904000,1393140695040000,1394713760400000,1399680000000000,1401260449218750,1406250000000000,1407374883553280,1408964021452800,1410554953728000,1412147682405000,1415577600000000,1417176000000000,1423828125000000,1424967069597696,1426576071720960,1428186890649600,1430511474609375,1433272320000000,1434890700000000,1440000000000000,1441625976562500,1444408272617472,1446039226782720,1449551462400000,1451188224000000,1452826833750000,1458000000000000,1464114717117504,1464843750000000,1467670855680000,1469328076800000,1470987169171875,1474560000000000,1476225000000000,1483154296875000,1484340697497600,1486016741376000,1487694677760000,1492992000000000,1494677812500000,1500000000000000,1502894956216320,1504591950643200,1506290861232000,1509949440000000,1511654400000000,1513361285156250,1518750000000000,1521681143169024,1523399350026240,1525119496997400,1525878906250000,1528823808000000,1530550080000000,1536000000000000,1537734375000000,1542441841901568,1544952392578125,1546188226560000,1547934105600000,1549681956000000,1555200000000000,1556956054687500,1562500000000000,1565515579392000,1567283281920000,1569052980450000,1572864000000000,1574640000000000,1582031250000000,1583296743997440,1585084524134400,1586874322944000,1588666142705625,1592524800000000,1594323000000000,1600000000000000,1601806640625000,1603087953297408,1604898080686080,1606710251980800,1610612736000000,1612431360000000,1614252037500000,1620000000000000,1624959306694656,1626794130130560,1630745395200000,1632586752000000,1634430187968750,1638400000000000,1640250000000000,1647129056757192,1647949218750000,1649267441664000,1651129712640000,1652994086400000,1658880000000000,1660753125000000,1668548583984375,1669883284684800,1671768834048000,1673656512480000,1677721600000000,1679616000000000,1681512539062500,1687500000000000,1688849860263936,1690756825743360,1692665944473600,1694577218886000,1698693120000000,1700611200000000,1708593750000000,1711891286065152,1713824268779520,1715759434122075,1716613769531250,1717986918400000,1719926784000000,1721868840000000,1728000000000000,1729951171875000,1735247072139264,1739461754880000,1741425868800000,1743392200500000,1749600000000000,1757812500000000,1759218604441600,1761205026816000,1763193692160000,1765184603006250,1769472000000000,1771470000000000,1779785156250000,1781208836997120,1783220089651200,1785233613312000,1791590400000000,1793613375000000,1800000000000000,1802032470703125,1803473947459584,1805510340771840,1807549033478400,1811939328000000,1813985280000000,1816033542187500,1822500000000000,1828079220031488,1830143396396880,1831054687500000,1834588569600000,1836660096000000,1843200000000000,1845281250000000,1853020188851841,1853942871093750,1855425871872000,1857520926720000,1859618347200000,1866240000000000,1868347265625000,1875000000000000,1878618695270400,1880739938304000,1882863576540000,1887436800000000,1889568000000000,1898437500000000,1899956092796928,1902101428961280,1904249187532800,1906399371246750,1907348632812500,1911029760000000,1913187600000000,1920000000000000,1922167968750000,1925877696823296,1928052302376960,1932735283200000,1934917632000000,1937102445000000,1944000000000000,1946195068359375,1952152956156672,1953125000000000,1956894474240000,1959104102400000,1961316225562500,1966080000000000,1968300000000000,1977539062500000,1979120929996800,1981355655168000,1983592903680000,1990656000000000,1992903750000000,2000000000000000,2002258300781250,2003859941621760,2006122600857600,2008387814976000,2013265920000000,2015539200000000,2017815046875000,2025000000000000,2028908190892032,2031199133368320,2033492662663200,2038431744000000,2040733440000000,2048000000000000,2050312500000000,2056589122535424,2058911320946490,2059936523437500,2061584302080000,2063912140800000,2066242608000000,2073600000000000,2075941406250000,2087354105856000,2089711042560000,2092070640600000,2097152000000000,2099520000000000,2101890673828125,2109375000000000,2111062325329920,2113446032179200,2115832430592000,2118221523607500,2123366400000000,2125764000000000,2135742187500000,2137450604396544,2139864107581440,2142280335974400,2147483648000000,2149908480000000,2152336050000000,2160000000000000,2162438964843750,2166612408926208,2169058840174080,2174327193600000,2176782336000000,2179240250625000,2187000000000000,2196172075676256,2197265625000000,2199023255552000,2201506283520000,2203992115200000,2211840000000000,2214337500000000,2224731445312500,2226511046246400,2229025112064000,2231542016640000,2239488000000000,2242016718750000,2250000000000000,2251799813685248,2254342434324480,2256887925964800,2259436291848000,2264924160000000,2267481600000000,2270041927734375,2278125000000000,2282521714753536,2285099025039360,2287679245496100,2288818359375000,2293235712000000,2295825120000000,2304000000000000,2306601562500000,2313662762852352,2319282339840000,2321901158400000,2324522934000000,2332800000000000,2335434082031250,2343750000000000,2348273369088000,2350924922880000,2353579470675000,2359296000000000,2361960000000000,2373046875000000,2374945115996160,2377626786201600,2380311484416000,2384185791015625,2388787200000000,2391484500000000,2400000000000000,2402709960937500,2404631929946112,2407347121029120,2410065377971200,2415919104000000,2418647040000000,2421378056250000,2430000000000000,2437438960041984,2440191195195840,2441406250000000,2446118092800000,2448880128000000,2451645281953125,2457600000000000,2460375000000000,2470693585135788,2471923828125000,2473901162496000,2476694568960000,2479491129600000,2488320000000000,2491129687500000,2500000000000000,2504824927027200,2507653251072000,2510484768720000,2516582400000000,2519424000000000,2522268808593750,2531250000000000,2533274790395904,2536135238615040,2538998916710400,2541865828329000,2548039680000000,2550916800000000,2560000000000000,2562890625000000,2567836929097728,2570736403169280,2574920654296875,2576980377600000,2579890176000000,2582803260000000,2592000000000000,2594926757812500,2602870608208896,2609192632320000,2612138803200000,2615088300750000,2621440000000000,2624400000000000,2636718750000000,2638827906662400,2641807540224000,2644790538240000,2647776904509375,2654208000000000,2657205000000000,2669677734375000,2671813255495680,2674830134476800,2677850419968000,2684354560000000,2687385600000000,2690420062500000,2700000000000000,2705210921189376,2708265511157760,2711323550217600,2717908992000000,2720977920000000,2724050313281250,2733750000000000,2742118830047232,2745215094595320,2746582031250000,2748779069440000,2751882854400000,2754990144000000,2764800000000000,2767921875000000,2780914306640625,2783138807808000,2786281390080000,2789427520800000,2799360000000000,2802520898437500,2812500000000000,2814749767106560,2817928042905600,2821109907456000,2824295364810000,2831155200000000,2834352000000000,2847656250000000,2849934139195392,2853152143441920,2856373781299200,2859599056870125,2861022949218750,2866544640000000,2869781400000000,2880000000000000,2883251953125000,2888816545234944,2892078453565440,2899102924800000,2902376448000000,2905653667500000,2916000000000000,2928229434235008,2929687500000000,2935341711360000,2938656153600000,2941974338343750,2949120000000000,2952450000000000,2966308593750000,2968681394995200,2972033482752000,2975389355520000,2985984000000000,2989355625000000,3000000000000000,3003387451171875,3005789912432640,3009183901286400,3012581722464000,3019898880000000,3023308800000000,3026722570312500,3037500000000000,3043362286338048,3046798700052480,3050238993994800,3051757812500000,3057647616000000,3061100160000000,3072000000000000,3075468750000000,3084883683803136,3088366981419735,3089904785156250,3092376453120000,3095868211200000,3099363912000000,3110400000000000,3113912109375000,3125000000000000,3131031158784000,3134566563840000,3138105960900000,3145728000000000,3149280000000000,3164062500000000,3166593487994880,3170169048268800,3173748645888000,3177332285411250,3185049600000000,3188646000000000,3200000000000000,3203613281250000,3206175906594816,3209796161372160,3213420503961600,3221225472000000,3224862720000000,3228504075000000,3240000000000000,3243658447265625,3249918613389312,3253588260261120,3261490790400000,3265173504000000,3268860375937500,3276800000000000,3280500000000000,3294258113514384,3295898437500000,3298534883328000,3302259425280000,3305988172800000,3317760000000000,3321506250000000,3337097167968750,3339766569369600,3343537668096000,3347313024960000,3355443200000000,3359232000000000,3363025078125000,3375000000000000,3377699720527872,3381513651486720,3385331888947200,3389154437772000,3397386240000000,3401222400000000,3417187500000000,3423782572130304,3427648537559040,3431518868244150,3433227539062500,3435973836800000,3439853568000000,3443737680000000,3456000000000000,3459902343750000,3470494144278528,3478923509760000,3482851737600000,3486784401000000,3499200000000000,3503151123046875,3515625000000000,3518437208883200,3522410053632000,3526387384320000,3530369206012500,3538944000000000,3542940000000000,3559570312500000,3562417673994240,3566440179302400,3570467226624000,3583180800000000,3587226750000000,3600000000000000,3604064941406250,3606947894919168,3611020681543680,3615098066956800,3623878656000000,3627970560000000,3632067084375000,3645000000000000,3656158440062976,3660286792793760,3662109375000000,3669177139200000,3673320192000000,3686400000000000,3690562500000000,3706040377703682,3707885742187500,3710851743744000,3715041853440000,3719236694400000,3732480000000000,3736694531250000,3750000000000000,3757237390540800,3761479876608000,3765727153080000,3774873600000000,3779136000000000,3783403212890625,3796875000000000,3799912185593856,3804202857922560,3808498375065600,3812798742493500,3814697265625000,3822059520000000,3826375200000000,3840000000000000,3844335937500000,3851755393646592,3856104604753920,3865470566400000,3869835264000000,3874204890000000,3888000000000000,3892390136718750,3904305912313344,3906250000000000,3913788948480000,3918208204800000,3922632451125000,3932160000000000,3936600000000000,3955078125000000,3958241859993600,3962711310336000,3967185807360000,3981312000000000,3985807500000000,4000000000000000,4004516601562500,4007719883243520,4012245201715200,4016775629952000,4026531840000000,4031078400000000,4035630093750000,4050000000000000,4057816381784064,4062398266736640,4066985325326400,4076863488000000,4081466880000000,4086075469921875,4096000000000000,4100625000000000,4113178245070848,4117822641892980,4119873046875000,4123168604160000,4127824281600000,4132485216000000,4147200000000000,4151882812500000,4174708211712000,4179422085120000,4184141281200000,4194304000000000,4199040000000000,4203781347656250,4218750000000000,4222124650659840,4226892064358400,4231664861184000,4236443047215000,4246732800000000,4251528000000000,4271484375000000,4274901208793088,4279728215162880,4284560671948800,4291534423828125,4294967296000000,4299816960000000,4304672100000000,4320000000000000,4324877929687500,4333224817852416,4338117680348160,4348654387200000,4353564672000000,4358480501250000,4374000000000000,4392344151352512,4394531250000000,4398046511104000,4403012567040000,4407984230400000,4412961507515625,4423680000000000,4428675000000000,4449462890625000,4453022092492800,4458050224128000,4463084033280000,4478976000000000,4484033437500000,4500000000000000,4503599627370496,4508684868648960,4513775851929600,4518872583696000,4529848320000000,4534963200000000,4540083855468750,4556250000000000,4565043429507072,4570198050078720,4575358490992200,4577636718750000,4586471424000000,4591650240000000,4608000000000000,4613203125000000,4627325525704704,4634857177734375,4638564679680000,4643802316800000,4649045868000000,4665600000000000,4670868164062500,4687500000000000,4696546738176000,4701849845760000,4707158941350000,4718592000000000,4723920000000000,4746093750000000,4749890231992320,4755253572403200,4760622968832000,4765998428116875,4768371582031250,4777574400000000,4782969000000000,4800000000000000,4805419921875000,4809263859892224,4814694242058240,4820130755942400,4831838208000000,4837294080000000,4842756112500000,4860000000000000,4874877920083968,4880382390391680,4882812500000000,4892236185600000,4897760256000000,4903290563906250,4915200000000000,4920750000000000,4941387170271576,4943847656250000,4947802324992000,4953389137920000,4958982259200000,4976640000000000,4982259375000000,5000000000000000,5005645751953125,5009649854054400,5015306502144000,5020969537440000,5033164800000000,5038848000000000,5044537617187500,5062500000000000,5066549580791808,5072270477230080,5077997833420800,5083731656658000,5096079360000000,5101833600000000,5120000000000000,5125781250000000,5135673858195456,5141472806338560,5147278302366225,5149841308593750,5153960755200000,5159780352000000,5165606520000000,5184000000000000,5189853515625000,5205741216417792,5218385264640000,5224277606400000,5230176601500000,5242880000000000,5248800000000000,5273437500000000,5277655813324800,5283615080448000,5289581076480000,5295553809018750,5308416000000000,5314410000000000,5339355468750000,5343626510991360,5349660268953600,5355700839936000,5368709120000000,5374771200000000,5380840125000000,5400000000000000,5406097412109375,5410421842378752,5416531022315520,5422647100435200,5435817984000000,5441955840000000,5448100626562500,5467500000000000,5484237660094464,5490430189190640,5493164062500000,5497558138880000,5503765708800000,5509980288000000,5529600000000000,5535843750000000,5559060566555523,5561828613281250,5566277615616000,5572562780160000,5578855041600000,5598720000000000,5605041796875000,5625000000000000,5629499534213120,5635856085811200,5642219814912000,5648590729620000,5662310400000000,5668704000000000,5695312500000000,5699868278390784,5706304286883840,5712747562598400,5719198113740250,5722045898437500,5733089280000000,5739562800000000,5760000000000000,5766503906250000,5777633090469888,5784156907130880,5798205849600000,5804752896000000,5811307335000000,5832000000000000,5838585205078125,5856458868470016,5859375000000000,5870683422720000,5877312307200000,5883948676687500,5898240000000000,5904900000000000,5932617187500000,5937362789990400,5944066965504000,5950778711040000,5971968000000000,5978711250000000,6000000000000000,6006774902343750,6011579824865280,6018367802572800,6025163444928000,6039797760000000,6046617600000000,6053445140625000,6075000000000000,6086724572676096,6093597400104960,6100477987989600,6103515625000000,6115295232000000,6122200320000000,6144000000000000,6150937500000000,6169767367606272,6176733962839470,6179809570312500,6184752906240000,6191736422400000,6198727824000000,6220800000000000,6227824218750000,6250000000000000,6262062317568000,6269133127680000,6276211921800000,6291456000000000,6298560000000000,6305672021484375,6328125000000000,6333186975989760,6340338096537600,6347497291776000,6354664570822500,6370099200000000,6377292000000000,6400000000000000,6407226562500000,6412351813189632,6419592322744320,6426841007923200,6442450944000000,6449725440000000,6457008150000000,6480000000000000,6487316894531250,6499837226778624,6507176520522240,6522981580800000,6530347008000000,6537720751875000,6553600000000000,6561000000000000,6588516227028768,6591796875000000,6597069766656000,6604518850560000,6611976345600000,6635520000000000,6643012500000000,6674194335937500,6679533138739200,6687075336192000,6694626049920000,6710886400000000,6718464000000000,6726050156250000,6750000000000000,6755399441055744,6763027302973440,6770663777894400,6778308875544000,6794772480000000,6802444800000000,6810125783203125,6834375000000000,6847565144260608,6855297075118080,6863037736488300,6866455078125000,6871947673600000,6879707136000000,6887475360000000,6912000000000000,6919804687500000,6940988288557056,6957847019520000,6965703475200000,6973568802000000,6998400000000000,7006302246093750,7031250000000000,7036874417766400,7044820107264000,7052774768640000,7060738412025000,7077888000000000,7085880000000000,7119140625000000,7124835347988480,7132880358604800,7140934453248000,7152557373046875,7166361600000000,7174453500000000,7200000000000000,7208129882812500,7213895789838336,7222041363087360,7230196133913600,7247757312000000,7255941120000000,7264134168750000,7290000000000000,7312316880125952,7320573585587520,7324218750000000,7338354278400000,7346640384000000,7354935845859375,7372800000000000,7381125000000000,7412080755407364,7415771484375000,7421703487488000,7430083706880000,7438473388800000,7464960000000000,7473389062500000,7500000000000000,7514474781081600,7522959753216000,7531454306160000,7549747200000000,7558272000000000,7566806425781250,7593750000000000,7599824371187712,7608405715845120,7616996750131200,7625597484987000,7629394531250000,7644119040000000,7652750400000000,7680000000000000,7688671875000000,7703510787293184,7712209209507840,7724761962890625,7730941132800000,7739670528000000,7748409780000000,7776000000000000,7784780273437500,7808611824626688,7812500000000000,7827577896960000,7836416409600000,7845264902250000,7864320000000000,7873200000000000,7910156250000000,7916483719987200,7925422620672000,7934371614720000,7943330713528125,7962624000000000,7971615000000000,8000000000000000,8009033203125000,8015439766487040,8024490403430400,8033551259904000,8053063680000000,8062156800000000,8071260187500000,8100000000000000,8115632763568128,8124796533473280,8133970650652800,8153726976000000,8162933760000000,8172150939843750,8192000000000000,8201250000000000,8226356490141696,8235645283785960,8239746093750000,8246337208320000,8255648563200000,8264970432000000,8294400000000000,8303765625000000,8342742919921875,8349416423424000,8358844170240000,8368282562400000,8388608000000000,8398080000000000,8407562695312500,8437500000000000,8444249301319680,8453784128716800,8463329722368000,8472886094430000,8493465600000000,8503056000000000,8542968750000000,8549802417586176,8559456430325760,8569121343897600,8578797170610375,8583068847656250,8589934592000000,8599633920000000,8609344200000000,8640000000000000,8649755859375000,8666449635704832,8676235360696320,8697308774400000,8707129344000000,8716961002500000,8748000000000000,8784688302705024,8789062500000000,8796093022208000,8806025134080000,8815968460800000,8825923015031250,8847360000000000,8857350000000000,8898925781250000,8906044184985600,8916100448256000,8926168066560000,8957952000000000,8968066875000000,9000000000000000,9007199254740992,9010162353515625,9017369737297920,9027551703859200,9037745167392000,9059696640000000,9069926400000000,9080167710937500,9112500000000000,9130086859014144,9140396100157440,9150716981984400,9155273437500000,9172942848000000,9183300480000000,9216000000000000,9226406250000000,9254651051409408,9265100944259205,9269714355468750,9277129359360000,9287604633600000,9298091736000000,9331200000000000,9341736328125000,9375000000000000,9393093476352000,9403699691520000,9414317882700000,9437184000000000,9447840000000000,9492187500000000,9499780463984640,9510507144806400,9521245937664000,9531996856233750,9536743164062500,9555148800000000,9565938000000000,9600000000000000,9610839843750000,9618527719784448,9629388484116480,9640261511884800,9663676416000000,9674588160000000,9685512225000000,9720000000000000,9730975341796875,9749755840167936,9760764780783360,9765625000000000,9784472371200000,9795520512000000,9806581127812500,9830400000000000,9841500000000000,9882774340543152,9887695312500000,9895604649984000,9906778275840000,9917964518400000,9953280000000000,9964518750000000,10000000000000000,10011291503906250,10019299708108800,10030613004288000,10041939074880000,10066329600000000,10077696000000000,10089075234375000,10125000000000000,10133099161583616,10144540954460160,10155995666841600,10167463313316000,10192158720000000,10203667200000000,10240000000000000,10251562500000000,10271347716390912,10282945612677120,10294556604732450,10299682617187500,10307921510400000,10319560704000000,10331213040000000,10368000000000000,10379707031250000,10411482432835584,10436770529280000,10448555212800000,10460353203000000,10485760000000000,10497600000000000,10509453369140625,10546875000000000,10555311626649600,10567230160896000,10579162152960000,10591107618037500,10616832000000000,10628820000000000,10678710937500000,10687253021982720,10699320537907200,10711401679872000,10737418240000000,10749542400000000,10761680250000000,10800000000000000,10812194824218750,10820843684757504,10833062044631040,10845294200870400,10871635968000000,10883911680000000,10896201253125000,10935000000000000,10968475320188928,10980860378381280,10986328125000000,10995116277760000,11007531417600000,11019960576000000,11059200000000000,11071687500000000,11118121133111046,11123657226562500,11132555231232000,11145125560320000,11157710083200000,11197440000000000,11210083593750000,11250000000000000,11258999068426240,11271712171622400,11284439629824000,11297181459240000,11324620800000000,11337408000000000,11350209638671875,11390625000000000,11399736556781568,11412608573767680,11425495125196800,11438396227480500,11444091796875000,11466178560000000,11479125600000000,11520000000000000,11533007812500000,11555266180939776,11568313814261760,11596411699200000,11609505792000000,11622614670000000,11664000000000000,11677170410156250,11712917736940032,11718750000000000,11741366845440000,11754624614400000,11767897353375000,11796480000000000,11809800000000000,11865234375000000,11874725579980800,11888133931008000,11901557422080000,11920928955078125,11943936000000000,11957422500000000,12000000000000000,12013549804687500,12023159649730560,12036735605145600,12050326889856000,12079595520000000,12093235200000000,12106890281250000,12150000000000000,12173449145352192,12187194800209920,12200955975979200,12207031250000000,12230590464000000,12244400640000000,12258226409765625,12288000000000000,12301875000000000,12339534735212544,12353467925678940,12359619140625000,12369505812480000,12383472844800000,12397455648000000,12441600000000000,12455648437500000,12500000000000000,12524124635136000,12538266255360000,12552423843600000,12582912000000000,12597120000000000,12611344042968750,12656250000000000,12666373951979520,12680676193075200,12694994583552000,12709329141645000,12740198400000000,12754584000000000,12800000000000000,12814453125000000,12824703626379264,12839184645488640,12853682015846400,12874603271484375,12884901888000000,12899450880000000,12914016300000000,12960000000000000,12974633789062500,12999674453557248,13014353041044480,13045963161600000,13060694016000000,13075441503750000,13107200000000000,13122000000000000,13177032454057536,13183593750000000,13194139533312000,13209037701120000,13223952691200000,13238884522546875,13271040000000000,13286025000000000,13348388671875000,13359066277478400,13374150672384000,13389252099840000,13421772800000000,13436928000000000,13452100312500000,13500000000000000,13510798882111488,13526054605946880,13541327555788800,13556617751088000,13589544960000000,13604889600000000,13620251566406250,13668750000000000,13695130288521216,13710594150236160,13726075472976600,13732910156250000,13743895347200000,13759414272000000,13774950720000000,13824000000000000,13839609375000000,13881976577114112,13904571533203125,13915694039040000,13931406950400000,13947137604000000,13996800000000000,14012604492187500,14062500000000000,14073748835532800,14089640214528000,14105549537280000,14121476824050000,14155776000000000,14171760000000000,14238281250000000,14249670695976960,14265760717209600,14281868906496000,14297995284350625,14305114746093750,14332723200000000,14348907000000000,14400000000000000,14416259765625000,14427791579676672,14444082726174720,14460392267827200,14495514624000000,14511882240000000,14528268337500000,14580000000000000,14624633760251904,14641147171175040,14648437500000000,14676708556800000,14693280768000000,14709871691718750,14745600000000000,14762250000000000,14824161510814728,14831542968750000,14843406974976000,14860167413760000,14876946777600000,14929920000000000,14946778125000000,15000000000000000,15016937255859375,15028949562163200,15045919506432000,15062908612320000,15099494400000000,15116544000000000,15133612851562500,15187500000000000,15199648742375424,15216811431690240,15233993500262400,15251194969974000,15258789062500000,15288238080000000,15305500800000000,15360000000000000,15377343750000000,15407021574586368,15424418419015680,15441834907098675,15449523925781250,15461882265600000,15479341056000000,15496819560000000,15552000000000000,15569560546875000,15617223649253376,15625000000000000,15655155793920000,15672832819200000,15690529804500000,15728640000000000,15746400000000000,15820312500000000,15832967439974400,15850845241344000,15868743229440000,15886661427056250,15925248000000000,15943230000000000,16000000000000000,16018066406250000,16030879532974080,16048980806860800,16067102519808000,16106127360000000,16124313600000000,16142520375000000,16200000000000000,16218292236328125,16231265527136256,16249593066946560,16267941301305600,16307453952000000,16325867520000000,16344301879687500,16384000000000000,16402500000000000,16452712980283392,16471290567571920,16479492187500000,16492674416640000,16511297126400000,16529940864000000,16588800000000000,16607531250000000,16677181699666569,16685485839843750,16698832846848000,16717688340480000,16736565124800000,16777216000000000,16796160000000000,16815125390625000,16875000000000000,16888498602639360,16907568257433600,16926659444736000,16945772188860000,16986931200000000,17006112000000000,17085937500000000,17099604835172352,17118912860651520,17138242687795200,17157594341220750,17166137695312500,17179869184000000,17199267840000000,17218688400000000,17280000000000000,17299511718750000,17332899271409664,17352470721392640,17394617548800000,17414258688000000,17433922005000000,17496000000000000,17515755615234375,17569376605410048,17578125000000000,17592186044416000,17612050268160000,17631936921600000,17651846030062500,17694720000000000,17714700000000000,17797851562500000,17812088369971200,17832200896512000,17852336133120000,17915904000000000,17936133750000000,18000000000000000,18014398509481984,18020324707031250,18034739474595840,18055103407718400,18075490334784000,18119393280000000,18139852800000000,18160335421875000,18225000000000000,18260173718028288,18280792200314880,18301433963968800,18310546875000000,18345885696000000,18366600960000000,18432000000000000,18452812500000000,18509302102818816,18530201888518410,18539428710937500,18554258718720000,18575209267200000,18596183472000000,18662400000000000,18683472656250000,18750000000000000,18786186952704000,18807399383040000,18828635765400000,18874368000000000,18895680000000000,18917016064453125,18984375000000000,18999560927969280,19021014289612800,19042491875328000,19063993712467500,19073486328125000,19110297600000000,19131876000000000,19200000000000000,19221679687500000,19237055439568896,19258776968232960,19280523023769600,19327352832000000,19349176320000000,19371024450000000,19440000000000000,19461950683593750,19499511680335872,19521529561566720,19531250000000000,19568944742400000,19591041024000000,19613162255625000,19660800000000000,19683000000000000,19765548681086304,19775390625000000,19791209299968000,19813556551680000,19835929036800000,19906560000000000,19929037500000000,20000000000000000,20022583007812500,20038599416217600,20061226008576000,20083878149760000,20132659200000000,20155392000000000,20178150468750000,20250000000000000,20266198323167232,20289081908920320,20311991333683200,20334926626632000,20384317440000000,20407334400000000,20430377349609375,20480000000000000,20503125000000000,20542695432781824,20565891225354240,20589113209464900,20599365234375000,20615843020800000,20639121408000000,20662426080000000,20736000000000000,20759414062500000,20822964865671168,20873541058560000,20897110425600000,20920706406000000,20971520000000000,20995200000000000,21018906738281250,21093750000000000,21110623253299200,21134460321792000,21158324305920000,21182215236075000,21233664000000000,21257640000000000,21357421875000000,21374506043965440,21398641075814400,21422803359744000,21457672119140625,21474836480000000,21499084800000000,21523360500000000,21600000000000000,21624389648437500,21641687369515008,21666124089262080,21690588401740800,21743271936000000,21767823360000000,21792402506250000,21870000000000000,21936950640377856,21961720756762560,21972656250000000,21990232555520000,22015062835200000,22039921152000000,22064807537578125,22118400000000000,22143375000000000,22236242266222092,22247314453125000,22265110462464000,22290251120640000,22315420166400000,22394880000000000,22420167187500000,22500000000000000,22517998136852480,22543424343244800,22568879259648000,22594362918480000,22649241600000000,22674816000000000,22700419277343750,22781250000000000,22799473113563136,22825217147535360,22850990250393600,22876792454961000,22888183593750000,22932357120000000,22958251200000000,23040000000000000,23066015625000000,23110532361879552,23136627628523520,23174285888671875,23192823398400000,23219011584000000,23245229340000000,23328000000000000,23354340820312500,23425835473880064,23437500000000000,23482733690880000,23509249228800000,23535794706750000,23592960000000000,23619600000000000,23730468750000000,23749451159961600,23776267862016000,23803114844160000,23829992140584375,23841857910156250,23887872000000000,23914845000000000,24000000000000000,24027099609375000,24046319299461120,24073471210291200,24100653779712000,24159191040000000,24186470400000000,24213780562500000,24300000000000000,24346898290704384,24374389600419840,24401911951958400,24414062500000000,24461180928000000,24488801280000000,24516452819531250,24576000000000000,24603750000000000,24679069470425088,24706935851357880,24719238281250000,24739011624960000,24766945689600000,24794911296000000,24883200000000000,24911296875000000,25000000000000000,25028228759765625,25048249270272000,25076532510720000,25104847687200000,25165824000000000,25194240000000000,25222688085937500,25312500000000000,25332747903959040,25361352386150400,25389989167104000,25418658283290000,25480396800000000,25509168000000000,25600000000000000,25628906250000000,25649407252758528,25678369290977280,25707364031692800,25736391511831125,25749206542968750,25769803776000000,25798901760000000,25828032600000000,25920000000000000,25949267578125000,25999348907114496,26028706082088960,26091926323200000,26121388032000000,26150883007500000,26214400000000000,26244000000000000,26354064908115072,26367187500000000,26388279066624000,26418075402240000,26447905382400000,26477769045093750,26542080000000000,26572050000000000,26696777343750000,26718132554956800,26748301344768000,26778504199680000,26843545600000000,26873856000000000,26904200625000000,27000000000000000,27021597764222976,27030487060546875,27052109211893760,27082655111577600,27113235502176000,27179089920000000,27209779200000000,27240503132812500,27337500000000000,27390260577042432,27421188300472320,27452150945953200,27465820312500000,27487790694400000,27518828544000000,27549901440000000,27648000000000000,27679218750000000,27763953154228224,27795302832777615,27809143066406250,27831388078080000,27862813900800000,27894275208000000,27993600000000000,28025208984375000,28125000000000000,28147497671065600,28179280429056000,28211099074560000,28242953648100000,28311552000000000,28343520000000000,28476562500000000,28499341391953920,28531521434419200,28563737812992000,28595990568701250,28610229492187500,28665446400000000,28697814000000000,28800000000000000,28832519531250000,28855583159353344,28888165452349440,28920784535654400,28991029248000000,29023764480000000,29056536675000000,29160000000000000,29192926025390625,29249267520503808,29282294342350080,29296875000000000,29353417113600000,29386561536000000,29419743383437500,29491200000000000,29524500000000000,29648323021629456,29663085937500000,29686813949952000,29720334827520000,29753893555200000,29859840000000000,29893556250000000,30000000000000000,30033874511718750,30057899124326400,30091839012864000,30125817224640000,30198988800000000,30233088000000000,30267225703125000,30375000000000000,30399297484750848,30433622863380480,30467987000524800,30502389939948000,30517578125000000,30576476160000000,30611001600000000,30720000000000000,30754687500000000,30814043149172736,30848836838031360,30883669814197350,30899047851562500,30923764531200000,30958682112000000,30993639120000000,31104000000000000,31139121093750000,31234447298506752,31250000000000000,31310311587840000,31345665638400000,31381059609000000,31457280000000000,31492800000000000,31528360107421875,31640625000000000,31665934879948800,31701690482688000,31737486458880000,31773322854112500,31850496000000000,31886460000000000,32000000000000000,32036132812500000,32061759065948160,32097961613721600,32134205039616000,32212254720000000,32248627200000000,32285040750000000,32400000000000000,32436584472656250,32462531054272512,32499186133893120,32535882602611200,32614907904000000,32651735040000000,32688603759375000,32768000000000000,32805000000000000,32905425960566784,32942581135143840,32958984375000000,32985348833280000,33022594252800000,33059881728000000,33177600000000000,33215062500000000,33354363399333138,33370971679687500,33397665693696000,33435376680960000,33473130249600000,33554432000000000,33592320000000000,33630250781250000,33750000000000000,33776997205278720,33815136514867200,33853318889472000,33891544377720000,33973862400000000,34012224000000000,34050628916015625,34171875000000000,34199209670344704,34237825721303040,34276485375590400,34315188682441500,34332275390625000,34359738368000000,34398535680000000,34437376800000000,34560000000000000,34599023437500000,34665798542819328,34704941442785280,34789235097600000,34828517376000000,34867844010000000,34992000000000000,35031511230468750,35138753210820096,35156250000000000,35184372088832000,35224100536320000,35263873843200000,35303692060125000,35389440000000000,35429400000000000,35595703125000000,35624176739942400,35664401793024000,35704672266240000,35762786865234375,35831808000000000,35872267500000000,36000000000000000,36028797018963968,36040649414062500,36069478949191680,36110206815436800,36150980669568000,36238786560000000,36279705600000000,36320670843750000,36450000000000000,36520347436056576,36561584400629760,36602867927937600,36621093750000000,36691771392000000,36733201920000000,36774679229296875,36864000000000000,36905625000000000,37018604205637632,37060403777036820,37078857421875000,37108517437440000,37150418534400000,37192366944000000,37324800000000000,37366945312500000,37500000000000000,37572373905408000,37614798766080000,37657271530800000,37748736000000000,37791360000000000,37834032128906250,37968750000000000,37999121855938560,38042028579225600,38084983750656000,38127987424935000,38146972656250000,38220595200000000,38263752000000000,38400000000000000,38443359375000000,38474110879137792,38517553936465920,38561046047539200,38623809814453125,38654705664000000,38698352640000000,38742048900000000,38880000000000000,38923901367187500,38999023360671744,39043059123133440,39062500000000000,39137889484800000,39182082048000000,39226324511250000,39321600000000000,39366000000000000,39531097362172608,39550781250000000,39582418599936000,39627113103360000,39671858073600000,39716653567640625,39813120000000000,39858075000000000,40000000000000000,40045166015625000,40077198832435200,40122452017152000,40167756299520000,40265318400000000,40310784000000000,40356300937500000,40500000000000000,40532396646334464,40578163817840640,40623982667366400,40669853253264000,40768634880000000,40814668800000000,40860754699218750,40960000000000000,41006250000000000,41085390865563648,41131782450708480,41178226418929800,41198730468750000,41231686041600000,41278242816000000,41324852160000000,41472000000000000,41518828125000000,41645929731342336,41713714599609375,41747082117120000,41794220851200000,41841412812000000,41943040000000000,41990400000000000,42037813476562500,42187500000000000,42221246506598400,42268920643584000,42316648611840000,42364430472150000,42467328000000000,42515280000000000,42714843750000000,42749012087930880,42797282151628800,42845606719488000,42893985853051875,42915344238281250,42949672960000000,42998169600000000,43046721000000000,43200000000000000,43248779296875000,43283374739030016,43332248178524160,43381176803481600,43486543872000000,43535646720000000,43584805012500000,43740000000000000,43873901280755712,43923441513525120,43945312500000000,43980465111040000,44030125670400000,44079842304000000,44129615075156250,44236800000000000,44286750000000000,44472484532444184,44494628906250000,44530220924928000,44580502241280000,44630840332800000,44789760000000000,44840334375000000,45000000000000000,45035996273704960,45050811767578125,45086848686489600,45137758519296000,45188725836960000,45298483200000000,45349632000000000,45400838554687500,45562500000000000,45598946227126272,45650434295070720,45701980500787200,45753584909922000,45776367187500000,45864714240000000,45916502400000000,46080000000000000,46132031250000000,46221064723759104,46273255257047040,46325504721296025,46348571777343750,46385646796800000,46438023168000000,46490458680000000,46656000000000000,46708681640625000,46851670947760128,46875000000000000,46965467381760000,47018498457600000,47071589413500000,47185920000000000,47239200000000000,47460937500000000,47498902319923200,47552535724032000,47606229688320000,47659984281168750,47683715820312500,47775744000000000,47829690000000000,48000000000000000,48054199218750000,48092638598922240,48146942420582400,48201307559424000,48318382080000000,48372940800000000,48427561125000000,48600000000000000,48654876708984375,48693796581408768,48748779200839680,48803823903916800,48828125000000000,48922361856000000,48977602560000000,49032905639062500,49152000000000000,49207500000000000,49358138940850176,49413871702715760,49438476562500000,49478023249920000,49533891379200000,49589822592000000,49766400000000000,49822593750000000,50000000000000000,50031545098999707,50056457519531250,50096498540544000,50153065021440000,50209695374400000,50331648000000000,50388480000000000,50445376171875000,50625000000000000,50665495807918080,50722704772300800,50779978334208000,50837316566580000,50960793600000000,51018336000000000,51200000000000000,51257812500000000,51298814505517056,51356738581954560,51414728063385600,51472783023662250,51498413085937500,51539607552000000,51597803520000000,51656065200000000,51840000000000000,51898535156250000,51998697814228992,52057412164177920,52183852646400000,52242776064000000,52301766015000000,52428800000000000,52488000000000000,52547266845703125,52708129816230144,52734375000000000,52776558133248000,52836150804480000,52895810764800000,52955538090187500,53084160000000000,53144100000000000,53393554687500000,53436265109913600,53496602689536000,53557008399360000,53687091200000000,53747712000000000,53808401250000000,54000000000000000,54043195528445952,54060974121093750,54104218423787520,54165310223155200,54226471004352000,54358179840000000,54419558400000000,54481006265625000,54675000000000000,54780521154084864,54842376600944640,54904301891906400,54931640625000000,54975581388800000,55037657088000000,55099802880000000,55296000000000000,55358437500000000,55527906308456448,55590605665555230,55618286132812500,55662776156160000,55725627801600000,55788550416000000,55987200000000000,56050417968750000,56250000000000000,56294995342131200,56358560858112000,56422198149120000,56485907296200000,56623104000000000,56687040000000000,56751048193359375,56953125000000000,56998682783907840,57063042868838400,57127475625984000,57191981137402500,57220458984375000,57330892800000000,57395628000000000,57600000000000000,57665039062500000,57711166318706688,57776330904698880,57841569071308800,57982058496000000,58047528960000000,58113073350000000,58320000000000000,58385852050781250,58498535041007616,58564588684700160,58593750000000000,58706834227200000,58773123072000000,58839486766875000,58982400000000000,59049000000000000,59296646043258912,59326171875000000,59373627899904000,59440669655040000,59507787110400000,59604644775390625,59719680000000000,59787112500000000,60000000000000000,60067749023437500,60115798248652800,60183678025728000,60251634449280000,60397977600000000,60466176000000000,60534451406250000,60750000000000000,60798594969501696,60867245726760960,60935974001049600,61004779879896000,61035156250000000,61152952320000000,61222003200000000,61291132048828125,61440000000000000,61509375000000000,61628086298345472,61697673676062720,61767339628394700,61798095703125000,61847529062400000,61917364224000000,61987278240000000,62208000000000000,62278242187500000,62468894597013504,62500000000000000,62620623175680000,62691331276800000,62762119218000000,62914560000000000,62985600000000000,63056720214843750,63281250000000000,63331869759897600,63403380965376000,63474972917760000,63546645708225000,63700992000000000,63772920000000000,64000000000000000,64072265625000000,64123518131896320,64195923227443200,64268410079232000,64373016357421875,64424509440000000,64497254400000000,64570081500000000,64800000000000000,64873168945312500,64925062108545024,64998372267786240,65071765205222400,65229815808000000,65303470080000000,65377207518750000,65536000000000000,65610000000000000,65810851921133568,65885162270287680,65917968750000000,65970697666560000,66045188505600000,66119763456000000,66194422612734375,66355200000000000,66430125000000000,66708726798666276,66741943359375000,66795331387392000,66870753361920000,66946260499200000,67108864000000000,67184640000000000,67260501562500000,67500000000000000,67553994410557440,67630273029734400,67706637778944000,67783088755440000,67947724800000000,68024448000000000,68101257832031250,68343750000000000,68398419340689408,68475651442606080,68552970751180800,68630377364883000,68664550781250000,68719476736000000,68797071360000000,68874753600000000,69120000000000000,69198046875000000,69331597085638656,69409882885570560,69522857666015625,69578470195200000,69657034752000000,69735688020000000,69984000000000000,70063022460937500,70277506421640192,70312500000000000,70368744177664000,70448201072640000,70527747686400000,70607384120250000,70778880000000000,70858800000000000,71191406250000000,71248353479884800,71328803586048000,71409344532480000,71489976421753125,71525573730468750,71663616000000000,71744535000000000,72000000000000000,72057594037927936,72081298828125000,72138957898383360,72220413630873600,72301961339136000,72477573120000000,72559411200000000,72641341687500000,72900000000000000,73040694872113152,73123168801259520,73205735855875200,73242187500000000,73383542784000000,73466403840000000,73549358458593750,73728000000000000,73811250000000000,74037208411275264,74120807554073640,74157714843750000,74217034874880000,74300837068800000,74384733888000000,74649600000000000,74733890625000000,75000000000000000,75084686279296875,75144747810816000,75229597532160000,75314543061600000,75497472000000000,75582720000000000,75668064257812500,75937500000000000,75998243711877120,76084057158451200,76169967501312000,76255974849870000,76293945312500000,76441190400000000,76527504000000000,76800000000000000,76886718750000000,76948221758275584,77035107872931840,77122092095078400,77209174535493375,77247619628906250,77309411328000000,77396705280000000,77484097800000000,77760000000000000,77847802734375000,77998046721343488,78086118246266880,78125000000000000,78275778969600000,78364164096000000,78452649022500000,78643200000000000,78732000000000000,79062194724345216,79101562500000000,79164837199872000,79254226206720000,79343716147200000,79433307135281250,79626240000000000,79716150000000000,80000000000000000,80090332031250000,80154397664870400,80244904034304000,80335512599040000,80530636800000000,80621568000000000,80712601875000000,81000000000000000,81064793292668928,81091461181640625,81156327635681280,81247965334732800,81339706506528000,81537269760000000,81629337600000000,81721509398437500,81920000000000000,82012500000000000,82170781731127296,82263564901416960,82356452837859600,82397460937500000,82463372083200000,82556485632000000,82649704320000000,82944000000000000,83037656250000000,83291859462684672,83385908498332845,83427429199218750,83494164234240000,83588441702400000,83682825624000000,83886080000000000,83980800000000000,84075626953125000,84375000000000000,84442493013196800,84537841287168000,84633297223680000,84728860944300000,84934656000000000,85030560000000000,85429687500000000,85498024175861760,85594564303257600,85691213438976000,85787971706103750,85830688476562500,85899345920000000,85996339200000000,86093442000000000,86400000000000000,86497558593750000,86566749478060032,86664496357048320,86762353606963200,86973087744000000,87071293440000000,87169610025000000,87480000000000000,87578778076171875,87747802561511424,87846883027050240,87890625000000000,87960930222080000,88060251340800000,88159684608000000,88259230150312500,88473600000000000,88573500000000000,88944969064888368,88989257812500000,89060441849856000,89161004482560000,89261680665600000,89579520000000000,89680668750000000,90000000000000000,90071992547409920,90101623535156250,90173697372979200,90275517038592000,90377451673920000,90596966400000000,90699264000000000,90801677109375000,91125000000000000,91197892454252544,91300868590141440,91403961001574400,91507169819844000,91552734375000000,91729428480000000,91833004800000000,92160000000000000,92264062500000000,92442129447518208,92546510514094080,92651009442592050,92697143554687500,92771293593600000,92876046336000000,92980917360000000,93312000000000000,93417363281250000,93703341895520256,93750000000000000,93930934763520000,94036996915200000,94143178827000000,94371840000000000,94478400000000000,94585080322265625,94921875000000000,94997804639846400,95105071448064000,95212459376640000,95319968562337500,95367431640625000,95551488000000000,95659380000000000,96000000000000000,96108398437500000,96185277197844480,96293884841164800,96402615118848000,96636764160000000,96745881600000000,96855122250000000,97200000000000000,97309753417968750,97387593162817536,97497558401679360,97607647807833600,97656250000000000,97844723712000000,97955205120000000,98065811278125000,98304000000000000,98415000000000000,98716277881700352,98827743405431520,98876953125000000,98956046499840000,99067782758400000,99179645184000000,99532800000000000,99645187500000000,100000000000000000,100063090197999414,100112915039062500,100192997081088000,100306130042880000,100419390748800000,100663296000000000,100776960000000000,100890752343750000,101250000000000000,101330991615836160,101445409544601600,101559956668416000,101674633133160000,101921587200000000,102036672000000000,102151886748046875,102400000000000000,102515625000000000,102597629011034112,102713477163909120,102829456126771200,102945566047324500,102996826171875000,103079215104000000,103195607040000000,103312130400000000,103680000000000000,103797070312500000,103997395628457984,104114824328355840,104367705292800000,104485552128000000,104603532030000000,104857600000000000,104976000000000000,105094533691406250,105416259632460288,105468750000000000,105553116266496000,105672301608960000,105791621529600000,105911076180375000,106168320000000000,106288200000000000,106787109375000000,106872530219827200,106993205379072000,107114016798720000,107288360595703125,107374182400000000,107495424000000000,107616802500000000,108000000000000000,108086391056891904,108121948242187500,108208436847575040,108330620446310400,108452942008704000,108716359680000000,108839116800000000,108962012531250000,109350000000000000,109561042308169728,109684753201889280,109808603783812800,109863281250000000,109951162777600000,110075314176000000,110199605760000000,110324037687890625,110592000000000000,110716875000000000,111055812616912896,111181211331110460,111236572265625000,111325552312320000,111451255603200000,111577100832000000,111974400000000000,112100835937500000,112500000000000000,112589990684262400,112717121716224000,112844396298240000,112971814592400000,113246208000000000,113374080000000000,113502096386718750,113906250000000000,113997365567815680,114126085737676800,114254951251968000,114383962274805000,114440917968750000,114661785600000000,114791256000000000,115200000000000000,115330078125000000,115422332637413376,115552661809397760,115683138142617600,115871429443359375,115964116992000000,116095057920000000,116226146700000000,116640000000000000,116771704101562500,116997070082015232,117129177369400320,117187500000000000,117413668454400000,117546246144000000,117678973533750000,117964800000000000,118098000000000000,118593292086517824,118652343750000000,118747255799808000,118881339310080000,119015574220800000,119149960702921875,119209289550781250,119439360000000000,119574225000000000,120000000000000000,120135498046875000,120231596497305600,120367356051456000,120503268898560000,120795955200000000,120932352000000000,121068902812500000,121500000000000000,121597189939003392,121734491453521920,121871948002099200,122009559759792000,122070312500000000,122305904640000000,122444006400000000,122582264097656250,122880000000000000,123018750000000000,123256172596690944,123395347352125440,123534679256789400,123596191406250000,123695058124800000,123834728448000000,123974556480000000,124416000000000000,124556484375000000,124937789194027008,125000000000000000,125141143798828125,125241246351360000,125382662553600000,125524238436000000,125829120000000000,125971200000000000,126113440429687500,126562500000000000,126663739519795200,126806761930752000,126949945835520000,127093291416450000,127401984000000000,127545840000000000,128000000000000000,128144531250000000,128247036263792640,128391846454886400,128536820158464000,128681957559155625,128746032714843750,128849018880000000,128994508800000000,129140163000000000,129600000000000000,129746337890625000,129850124217090048,129996744535572480,130143530410444800,130459631616000000,130606940160000000,130754415037500000,131072000000000000,131220000000000000,131621703842267136,131770324540575360,131835937500000000,131941395333120000,132090377011200000,132239526912000000,132388845225468750,132710400000000000,132860250000000000,133417453597332552,133483886718750000,133590662774784000,133741506723840000,133892520998400000,134217728000000000,134369280000000000,134521003125000000,135000000000000000,135107988821114880,135152435302734375,135260546059468800,135413275557888000,135566177510880000,135895449600000000,136048896000000000,136202515664062500,136687500000000000,136796838681378816,136951302885212160,137105941502361600,137260754729766000,137329101562500000,137438953472000000,137594142720000000,137749507200000000,138240000000000000,138396093750000000,138663194171277312,138819765771141120,138976514163888075,139045715332031250,139156940390400000,139314069504000000,139471376040000000,139968000000000000,140126044921875000,140555012843280384,140625000000000000,140737488355328000,140896402145280000,141055495372800000,141214768240500000,141557760000000000,141717600000000000,142382812500000000,142496706959769600,142657607172096000,142818689064960000,142979952843506250,143051147460937500,143327232000000000,143489070000000000,144000000000000000,144115188075855872,144162597656250000,144277915796766720,144440827261747200,144603922678272000,144955146240000000,145118822400000000,145282683375000000,145800000000000000,145964630126953125,146081389744226304,146246337602519040,146411471711750400,146484375000000000,146767085568000000,146932807680000000,147098716917187500,147456000000000000,147622500000000000,148074416822550528,148241615108147280,148315429687500000,148434069749760000,148601674137600000,148769467776000000,149299200000000000,149467781250000000,150000000000000000,150094635296999121,150169372558593750,150289495621632000,150459195064320000,150629086123200000,150994944000000000,151165440000000000,151336128515625000,151875000000000000,151996487423754240,152168114316902400,152339935002624000,152511949699740000,152587890625000000,152882380800000000,153055008000000000,153600000000000000,153773437500000000,153896443516551168,154070215745863680,154244184190156800,154418349070986750,154495239257812500,154618822656000000,154793410560000000,154968195600000000,155520000000000000,155695605468750000,155996093442686976,156172236492533760,156250000000000000,156551557939200000,156728328192000000,156905298045000000,157286400000000000,157464000000000000,157641800537109375,158124389448690432,158203125000000000,158329674399744000,158508452413440000,158687432294400000,158866614270562500,159252480000000000,159432300000000000,160000000000000000,160180664062500000,160308795329740800,160489808068608000,160671025198080000,161061273600000000,161243136000000000,161425203750000000,162000000000000000,162129586585337856,162182922363281250,162312655271362560,162495930669465600,162679413013056000,163074539520000000,163258675200000000,163443018796875000,163840000000000000,164025000000000000,164341563462254592,164527129802833920,164712905675719200,164794921875000000,164926744166400000,165112971264000000,165299408640000000,165888000000000000,166075312500000000,166583718925369344,166771816996665690,166854858398437500,166988328468480000,167176883404800000,167365651248000000,167772160000000000,167961600000000000,168151253906250000,168750000000000000,168884986026393600,169075682574336000,169266594447360000,169457721888600000,169869312000000000,170061120000000000,170253144580078125,170859375000000000,170996048351723520,171189128606515200,171382426877952000,171575943412207500,171661376953125000,171798691840000000,171992678400000000,172186884000000000,172800000000000000,172995117187500000,173133498956120064,173328992714096640,173524707213926400,173946175488000000,174142586880000000,174339220050000000,174960000000000000,175157556152343750,175495605123022848,175693766054100480,175781250000000000,175921860444160000,176120502681600000,176319369216000000,176518460300625000,176947200000000000,177147000000000000,177889938129776736,177978515625000000,178120883699712000,178322008965120000,178523361331200000,178813934326171875,179159040000000000,179361337500000000,180000000000000000,180143985094819840,180203247070312500,180347394745958400,180551034077184000,180754903347840000,181193932800000000,181398528000000000,181603354218750000,182250000000000000,182395784908505088,182601737180282880,182807922003148800,183014339639688000,183105468750000000,183458856960000000,183666009600000000,183873396146484375,184320000000000000,184528125000000000,184884258895036416,185093021028188160,185302018885184100,185394287109375000,185542587187200000,185752092672000000,185961834720000000,186624000000000000,186834726562500000,187406683791040512,187500000000000000,187861869527040000,188073993830400000,188286357654000000,188743680000000000,188956800000000000,189170160644531250,189843750000000000,189995609279692800,190210142896128000,190424918753280000,190639937124675000,190734863281250000,191102976000000000,191318760000000000,192000000000000000,192216796875000000,192370554395688960,192587769682329600,192805230237696000,193119049072265625,193273528320000000,193491763200000000,193710244500000000,194400000000000000,194619506835937500,194775186325635072,194995116803358720,195215295615667200,195312500000000000,195689447424000000,195910410240000000,196131622556250000,196608000000000000,196830000000000000,197432555763400704,197655486810863040,197753906250000000,197912092999680000,198135565516800000,198359290368000000,198583267838203125,199065600000000000,199290375000000000,200000000000000000,200126180395998828,200225830078125000,200385994162176000,200612260085760000,200838781497600000,201326592000000000,201553920000000000,201781504687500000,202500000000000000,202661983231672320,202890819089203200,203119913336832000,203349266266320000,203843174400000000,204073344000000000,204303773496093750,204800000000000000,205031250000000000,205195258022068224,205426954327818240,205658912253542400,205891132094649000,205993652343750000,206158430208000000,206391214080000000,206624260800000000,207360000000000000,207594140625000000,207994791256915968,208229648656711680,208568572998046875,208735410585600000,208971104256000000,209207064060000000,209715200000000000,209952000000000000,210189067382812500,210832519264920576,210937500000000000,211106232532992000,211344603217920000,211583243059200000,211822152360750000,212336640000000000,212576400000000000,213574218750000000,213745060439654400,213986410758144000,214228033597440000,214469929265259375,214576721191406250,214748364800000000,214990848000000000,215233605000000000,216000000000000000,216172782113783808,216243896484375000,216416873695150080,216661240892620800,216905884017408000,217432719360000000,217678233600000000,217924025062500000,218700000000000000,219122084616339456,219369506403778560,219617207567625600,219726562500000000,219902325555200000,220150628352000000,220399211520000000,220648075375781250,221184000000000000,221433750000000000,222111625233825792,222362422662220920,222473144531250000,222651104624640000,222902511206400000,223154201664000000,223948800000000000,224201671875000000,225000000000000000,225179981368524800,225254058837890625,225434243432448000,225688792596480000,225943629184800000,226492416000000000,226748160000000000,227004192773437500,227812500000000000,227994731135631360,228252171475353600,228509902503936000,228767924549610000,228881835937500000,229323571200000000,229582512000000000,230400000000000000,230660156250000000,230844665274826752,231105323618795520,231366276285235200,231627523606480125,231742858886718750,231928233984000000,232190115840000000,232452293400000000,233280000000000000,233543408203125000,233994140164030464,234258354738800640,234375000000000000,234827336908800000,235092492288000000,235357947067500000,235929600000000000,236196000000000000,237186584173035648,237304687500000000,237494511599616000,237762678620160000,238031148441600000,238299921405843750,238418579101562500,238878720000000000,239148450000000000,240000000000000000,240270996093750000,240463192994611200,240734712102912000,241006537797120000,241591910400000000,241864704000000000,242137805625000000,243000000000000000,243194379878006784,243274383544921875,243468982907043840,243743896004198400,244019119519584000,244140625000000000,244611809280000000,244888012800000000,245164528195312500,245760000000000000,246037500000000000,246512345193381888,246790694704250880,247069358513578800,247192382812500000,247390116249600000,247669456896000000,247949112960000000,248832000000000000,249112968750000000,249875578388054016,250000000000000000,250157725494998535,250282287597656250,250482492702720000,250765325107200000,251048476872000000,251658240000000000,251942400000000000,252226880859375000,253125000000000000,253327479039590400,253613523861504000,253899891671040000,254186582832900000,254803968000000000,255091680000000000,256000000000000000,256289062500000000,256494072527585280,256783692909772800,257073640316928000,257363915118311250,257492065429687500,257698037760000000,257989017600000000,258280326000000000,259200000000000000,259492675781250000,259700248434180096,259993489071144960,260287060820889600,260919263232000000,261213880320000000,261508830075000000,262144000000000000,262440000000000000,262736334228515625,263243407684534272,263540649081150720,263671875000000000,263882790666240000,264180754022400000,264479053824000000,264777690450937500,265420800000000000,265720500000000000,266834907194665104,266967773437500000,267181325549568000,267483013447680000,267785041996800000,268435456000000000,268738560000000000,269042006250000000,270000000000000000,270215977642229760,270304870605468750,270521092118937600,270826551115776000,271132355021760000,271790899200000000,272097792000000000,272405031328125000,273375000000000000,273593677362757632,273902605770424320,274211883004723200,274521509459532000,274658203125000000,274877906944000000,275188285440000000,275499014400000000,276480000000000000,276792187500000000,277326388342554624,277639531542282240,277953028327776150,278091430664062500,278313880780800000,278628139008000000,278942752080000000,279936000000000000,280252089843750000,281110025686560768,281250000000000000,281474976710656000,281792804290560000,282110990745600000,282429536481000000,283115520000000000,283435200000000000,283755240966796875,284765625000000000,284993413919539200,285315214344192000,285637378129920000,285959905687012500,286102294921875000,286654464000000000,286978140000000000,288000000000000000,288230376151711744,288325195312500000,288555831593533440,288881654523494400,289207845356544000,289910292480000000,290237644800000000,290565366750000000,291600000000000000,291929260253906250,292162779488452608,292492675205038080,292822943423500800,292968750000000000,293534171136000000,293865615360000000,294197433834375000,294912000000000000,295245000000000000,296148833645101056,296483230216294560,296630859375000000,296868139499520000,297203348275200000,297538935552000000,298023223876953125,298598400000000000,298935562500000000,300000000000000000,300189270593998242,300338745117187500,300578991243264000,300918390128640000,301258172246400000,301989888000000000,302330880000000000,302672257031250000,303750000000000000,303992974847508480,304336228633804800,304679870005248000,305023899399480000,305175781250000000,305764761600000000,306110016000000000,306455660244140625,307200000000000000,307546875000000000,307792887033102336,308140431491727360,308488368380313600,308836698141973500,308990478515625000,309237645312000000,309586821120000000,309936391200000000,311040000000000000,311391210937500000,311992186885373952,312344472985067520,312500000000000000,313103115878400000,313456656384000000,313810596090000000,314572800000000000,314928000000000000,315283601074218750,316248778897380864,316406250000000000,316659348799488000,317016904826880000,317374864588800000,317733228541125000,318504960000000000,318864600000000000,320000000000000000,320361328125000000,320617590659481600,320979616137216000,321342050396160000,321865081787109375,322122547200000000,322486272000000000,322850407500000000,324000000000000000,324259173170675712,324365844726562500,324625310542725120,324991861338931200,325358826026112000,326149079040000000,326517350400000000,326886037593750000,327680000000000000,328050000000000000,328683126924509184,329054259605667840,329425811351438400,329589843750000000,329853488332800000,330225942528000000,330598817280000000,330972113063671875,331776000000000000,332150625000000000,333167437850738688,333543633993331380,333709716796875000,333976656936960000,334353766809600000,334731302496000000,335544320000000000,335923200000000000,336302507812500000,337500000000000000,337769972052787200,338151365148672000,338533188894720000,338915443777200000,339738624000000000,340122240000000000,340506289160156250,341718750000000000,341992096703447040,342378257213030400,342764853755904000,343151886824415000,343322753906250000,343597383680000000,343985356800000000,344373768000000000,345600000000000000,345990234375000000,346266997912240128,346657985428193280,347049414427852800,347614288330078125,347892350976000000,348285173760000000,348678440100000000,349920000000000000,350315112304687500,350991210246045696,351387532108200960,351562500000000000,351843720888320000,352241005363200000,352638738432000000,353036920601250000,353894400000000000,354294000000000000,355779876259553472,355957031250000000,356241767399424000,356644017930240000,357046722662400000,357449882108765625,357627868652343750,358318080000000000,358722675000000000,360000000000000000,360287970189639680,360406494140625000,360694789491916800,361102068154368000,361509806695680000,362387865600000000,362797056000000000,363206708437500000,364500000000000000,364791569817010176,365203474360565760,365615844006297600,366028679279376000,366210937500000000,366917713920000000,367332019200000000,367746792292968750,368640000000000000,369056250000000000,369768517790072832,370186042056376320,370604037770368200,370788574218750000,371085174374400000,371504185344000000,371923669440000000,373248000000000000,373669453125000000,374813367582081024,375000000000000000,375423431396484375,375723739054080000,376147987660800000,376572715308000000,377487360000000000,377913600000000000,378340321289062500,379687500000000000,379991218559385600,380420285792256000,380849837506560000,381279874249350000,381469726562500000,382205952000000000,382637520000000000,384000000000000000,384433593750000000,384741108791377920,385175539364659200,385610460475392000,386045872677466875,386238098144531250,386547056640000000,386983526400000000,387420489000000000,388800000000000000,389239013671875000,389550372651270144,389990233606717440,390430591231334400,390625000000000000,391378894848000000,391820820480000000,392263245112500000,393216000000000000,393660000000000000,394865111526801408,395310973621726080,395507812500000000,395824185999360000,396271131033600000,396718580736000000,397166535676406250,398131200000000000,398580750000000000,400000000000000000,400252360791997656,400451660156250000,400771988324352000,401224520171520000,401677562995200000,402653184000000000,403107840000000000,403563009375000000,405000000000000000,405323966463344640,405457305908203125,405781638178406400,406239826673664000,406698532532640000,407686348800000000,408146688000000000,408607546992187500,409600000000000000,410062500000000000,410390516044136448,410853908655636480,411317824507084800,411782264189298000,411987304687500000,412316860416000000,412782428160000000,413248521600000000,414720000000000000,415188281250000000,415989582513831936,416459297313423360,416929542491664225,417137145996093750,417470821171200000,417942208512000000,418414128120000000,419430400000000000,419904000000000000,420378134765625000,421665038529841152,421875000000000000,422212465065984000,422689206435840000,423166486118400000,423644304721500000,424673280000000000,425152800000000000,427148437500000000,427490120879308800,427972821516288000,428456067194880000,428939858530518750,429153442382812500,429496729600000000,429981696000000000,430467210000000000,432000000000000000,432345564227567616,432487792968750000,432833747390300160,433322481785241600,433811768034816000,434865438720000000,435356467200000000,435848050125000000,437400000000000000,437893890380859375,438244169232678912,438739012807557120,439234415135251200,439453125000000000,439804651110400000,440301256704000000,440798423040000000,441296150751562500,442368000000000000,442867500000000000,444223250467651584,444724845324441840,444946289062500000,445302209249280000,445805022412800000,446308403328000000,447897600000000000,448403343750000000,450000000000000000,450283905890997363,450359962737049600,450508117675781250,450868486864896000,451377585192960000,451887258369600000,452984832000000000,453496320000000000,454008385546875000,455625000000000000,455989462271262720,456504342950707200,457019805007872000,457535849099220000,457763671875000000,458647142400000000,459165024000000000,460800000000000000,461320312500000000,461689330549653504,462210647237591040,462732552570470400,463255047212960250,463485717773437500,463856467968000000,464380231680000000,464904586800000000,466560000000000000,467086816406250000,467988280328060928,468516709477601280,468750000000000000,469654673817600000,470184984576000000,470715894135000000,471859200000000000,472392000000000000,472925401611328125,474373168346071296,474609375000000000,474989023199232000,475525357240320000,476062296883200000,476599842811687500,476837158203125000,477757440000000000,478296900000000000,480000000000000000,480541992187500000,480926385989222400,481469424205824000,482013075594240000,483183820800000000,483729408000000000,484275611250000000,486000000000000000,486388759756013568,486548767089843750,486937965814087680,487487792008396800,488038239039168000,488281250000000000,489223618560000000,489776025600000000,490329056390625000,491520000000000000,492075000000000000,493024690386763776,493581389408501760,494138717027157600,494384765625000000,494780232499200000,495338913792000000,495898225920000000,497664000000000000,498225937500000000,499751156776108032,500000000000000000,500315450989997070,500564575195312500,500964985405440000,501530650214400000,502096953744000000,503316480000000000,503884800000000000,504453761718750000,506250000000000000,506654958079180800,507227047723008000,507799783342080000,508373165665800000,509607936000000000,510183360000000000,510759433740234375,512000000000000000,512578125000000000,512988145055170560,513567385819545600,514147280633856000,514727830236622500,514984130859375000,515396075520000000,515978035200000000,516560652000000000,518400000000000000,518985351562500000,519400496868360192,519986978142289920,520574121641779200,521838526464000000,522427760640000000,523017660150000000,524288000000000000,524880000000000000,525472668457031250,526486815369068544,527081298162301440,527343750000000000,527765581332480000,528361508044800000,528958107648000000,529555380901875000,530841600000000000,531441000000000000,533669814389330208,533935546875000000,534362651099136000,534966026895360000,535570083993600000,536441802978515625,536870912000000000,537477120000000000,538084012500000000,540000000000000000,540431955284459520,540609741210937500,541042184237875200,541653102231552000,542264710043520000,543581798400000000,544195584000000000,544810062656250000,546750000000000000,547187354725515264,547805211540848640,548423766009446400,549043018919064000,549316406250000000,549755813888000000,550376570880000000,550998028800000000,551620188439453125,552960000000000000,553584375000000000,554652776685109248,555279063084564480,555906056655552300,556182861328125000,556627761561600000,557256278016000000,557885504160000000,559872000000000000,560504179687500000,562220051373121536,562500000000000000,562949953421312000,563585608581120000,564221981491200000,564859072962000000,566231040000000000,566870400000000000,567510481933593750,569531250000000000,569986827839078400,570630428688384000,571274756259840000,571919811374025000,572204589843750000,573308928000000000,573956280000000000,576000000000000000,576460752303423488,576650390625000000,577111663187066880,577763309046988800,578415690713088000,579357147216796875,579820584960000000,580475289600000000,581130733500000000,583200000000000000,583858520507812500,584325558976905216,584985350410076160,585645886847001600,585937500000000000,587068342272000000,587731230720000000,588394867668750000,589824000000000000,590490000000000000,592297667290202112,592966460432589120,593261718750000000,593736278999040000,594406696550400000,595077871104000000,595749803514609375,596046447753906250,597196800000000000,597871125000000000,600000000000000000,600378541187996484,600677490234375000,601157982486528000,601836780257280000,602516344492800000,603979776000000000,604661760000000000,605344514062500000,607500000000000000,607985949695016960,608672457267609600,609359740010496000,610047798798960000,610351562500000000,611529523200000000,612220032000000000,612911320488281250,614400000000000000,615093750000000000,615585774066204672,616280862983454720,616976736760627200,617673396283947000,617980957031250000,618475290624000000,619173642240000000,619872782400000000,622080000000000000,622782421875000000,623984373770747904,624688945970135040,625000000000000000,625705718994140625,626206231756800000,626913312768000000,627621192180000000,629145600000000000,629856000000000000,630567202148437500,632497557794761728,632812500000000000,633318697598976000,634033809653760000,634749729177600000,635466457082250000,637009920000000000,637729200000000000,640000000000000000,640722656250000000,641235181318963200,641959232274432000,642684100792320000,643409787795778125,643730163574218750,644245094400000000,644972544000000000,645700815000000000,648000000000000000,648518346341351424,648731689453125000,649250621085450240,649983722677862400,650717652052224000,652298158080000000,653034700800000000,653772075187500000,655360000000000000,656100000000000000,657366253849018368,658108519211335680,658851622702876800,659179687500000000,659706976665600000,660451885056000000,661197634560000000,661944226127343750,663552000000000000,664301250000000000,666334875701477376,667087267986662760,667419433593750000,667953313873920000,668707533619200000,669462604992000000,671088640000000000,671846400000000000,672605015625000000,675000000000000000,675539944105574400,675762176513671875,676302730297344000,677066377789440000,677830887554400000,679477248000000000,680244480000000000,681012578320312500,683437500000000000,683984193406894080,684756514426060800,685529707511808000,686303773648830000,686645507812500000,687194767360000000,687970713600000000,688747536000000000,691200000000000000,691980468750000000,692533995824480256,693315970856386560,694098828855705600,694882570819440375,695228576660156250,695784701952000000,696570347520000000,697356880200000000,699840000000000000,700630224609375000,701982420492091392,702775064216401920,703125000000000000,703687441776640000,704482010726400000,705277476864000000,706073841202500000,707788800000000000,708588000000000000,711559752519106944,711914062500000000,712483534798848000,713288035860480000,714093445324800000,714899764217531250,715255737304687500,716636160000000000,717445350000000000,720000000000000000,720575940379279360,720812988281250000,721389578983833600,722204136308736000,723019613391360000,724775731200000000,725594112000000000,726413416875000000,729000000000000000,729583139634020352,729823150634765625,730406948721131520,731231688012595200,732057358558752000,732421875000000000,733835427840000000,734664038400000000,735493584585937500,737280000000000000,738112500000000000,739537035580145664,740372084112752640,741208075540736400,741577148437500000,742170348748800000,743008370688000000,743847338880000000,746496000000000000,747338906250000000,749626735164162048,750000000000000000,750473176484995605,750846862792968750,751447478108160000,752295975321600000,753145430616000000,754974720000000000,755827200000000000,756680642578125000,759375000000000000,759982437118771200,760840571584512000,761699675013120000,762559748498700000,762939453125000000,764411904000000000,765275040000000000,768000000000000000,768867187500000000,769482217582755840,770351078729318400,771220920950784000,772091745354933750,772476196289062500,773094113280000000,773967052800000000,774840978000000000,777600000000000000,778478027343750000,779100745302540288,779980467213434880,780861182462668800,781250000000000000,782757789696000000,783641640960000000,784526490225000000,786432000000000000,787320000000000000,788209002685546875,789730223053602816,790621947243452160,791015625000000000,791648371998720000,792542262067200000,793437161472000000,794333071352812500,796262400000000000,797161500000000000,800000000000000000,800504721583995312,800903320312500000,801543976648704000,802449040343040000,803355125990400000,805306368000000000,806215680000000000,807126018750000000,810000000000000000,810647932926689280,810914611816406250,811563276356812800,812479653347328000,813397065065280000,815372697600000000,816293376000000000,817215093984375000,819200000000000000,820125000000000000,820781032088272896,821707817311272960,822635649014169600,823564528378596000,823974609375000000,824633720832000000,825564856320000000,826497043200000000,829440000000000000,830376562500000000,831979165027663872,832918594626846720,833859084983328450,834274291992187500,834941642342400000,835884417024000000,836828256240000000,838860800000000000,839808000000000000,840756269531250000,843330077059682304,843750000000000000,844424930131968000,845378412871680000,846332972236800000,847288609443000000,849346560000000000,850305600000000000,851265722900390625,854296875000000000,854980241758617600,855945643032576000,856912134389760000,857879717061037500,858306884765625000,858993459200000000,859963392000000000,860934420000000000,864000000000000000,864691128455135232,864975585937500000,865667494780600320,866644963570483200,867623536069632000,869730877440000000,870712934400000000,871696100250000000,874800000000000000,875787780761718750,876488338465357824,877478025615114240,878468830270502400,878906250000000000,879609302220800000,880602513408000000,881596846080000000,882592301503125000,884736000000000000,885735000000000000,888446500935303168,889449690648883680,889892578125000000,890604418498560000,891610044825600000,892616806656000000,894069671630859375,895795200000000000,896806687500000000,900000000000000000,900567811781994726,900719925474099200,901016235351562500,901736973729792000,902755170385920000,903774516739200000,905969664000000000,906992640000000000,908016771093750000,911250000000000000,911978924542525440,913008685901414400,914039610015744000,915071698198440000,915527343750000000,917294284800000000,918330048000000000,919366980732421875,921600000000000000,922640625000000000,923378661099307008,924421294475182080,925465105140940800,926510094425920500,926971435546875000,927712935936000000,928760463360000000,929809173600000000,933120000000000000,934173632812500000,935976560656121856,937033418955202560,937500000000000000,939309347635200000,940369969152000000,941431788270000000,943718400000000000,944784000000000000,945850803222656250,948746336692142592,949218750000000000,949978046398464000,951050714480640000,952124593766400000,953199685623375000,953674316406250000,955514880000000000,956593800000000000,960000000000000000,961083984375000000,961852771978444800,962938848411648000,964026151188480000,965595245361328125,966367641600000000,967458816000000000,968551222500000000,972000000000000000,972777519512027136,973097534179687500,973875931628175360,974975584016793600,976076478078336000,976562500000000000,978447237120000000,979552051200000000,980658112781250000,983040000000000000,984150000000000000,986049380773527552,987162778817003520,988277434054315200,988769531250000000,989560464998400000,990677827584000000,991796451840000000,992916339191015625,995328000000000000,996451875000000000,999502313552216064,1000000000000000000,1000630901979994140,1001129150390625000,1001929970810880000,1003061300428800000,1004193907488000000,1006632960000000000,1007769600000000000,1008907523437500000,1012500000000000000,1013309916158361600,1014454095446016000,1015599566684160000,1016746331331600000,1019215872000000000,1020366720000000000,1021518867480468750,1024000000000000000,1025156250000000000,1025976290110341120,1027134771639091200,1028294561267712000,1029455660473245000,1029968261718750000,1030792151040000000,1031956070400000000,1033121304000000000,1036800000000000000,1037970703125000000,1038800993736720384,1039973956284579840,1041148243283558400,1042842864990234375,1043677052928000000,1044855521280000000,1046035320300000000,1048576000000000000,1049760000000000000,1050945336914062500,1052973630738137088,1054162596324602880,1054687500000000000,1055531162664960000,1056723016089600000,1057916215296000000,1059110761803750000,1061683200000000000,1062882000000000000,1067339628778660416,1067871093750000000,1068725302198272000,1069932053790720000,1071140167987200000,1072349646326296875,1072883605957031250,1073741824000000000,1074954240000000000,1076168025000000000,1080000000000000000,1080863910568919040,1081219482421875000,1082084368475750400,1083306204463104000,1084529420087040000,1087163596800000000,1088391168000000000,1089620125312500000,1093500000000000000,1094374709451030528,1095610423081697280,1096847532018892800,1098086037838128000,1098632812500000000,1099511627776000000,1100753141760000000,1101996057600000000,1103240376878906250,1105920000000000000,1107168750000000000,1109305553370218496,1110558126169128960,1111812113311104600,1112365722656250000,1113255523123200000,1114512556032000000,1115771008320000000,1119744000000000000,1121008359375000000,1124440102746243072,1125000000000000000,1125899906842624000,1126270294189453125,1127171217162240000,1128443962982400000,1129718145924000000,1132462080000000000,1133740800000000000,1135020963867187500,1139062500000000000,1139973655678156800,1141260857376768000,1142549512519680000,1143839622748050000,1144409179687500000,1146617856000000000,1147912560000000000,1152000000000000000,1152921504606846976,1153300781250000000,1154223326374133760,1155526618093977600,1156831381426176000,1158137618032400625,1158714294433593750,1159641169920000000,1160950579200000000,1162261467000000000,1166400000000000000,1167717041015625000,1168651117953810432,1169970700820152320,1171291773694003200,1171875000000000000,1174136684544000000,1175462461440000000,1176789735337500000,1179648000000000000,1180980000000000000,1184595334580404224,1185932920865178240,1186523437500000000,1187472557998080000,1188813393100800000,1190155742208000000,1191499607029218750,1192092895507812500,1194393600000000000,1195742250000000000,1200000000000000000,1200757082375992968,1201354980468750000,1202315964973056000,1203673560514560000,1205032688985600000,1207959552000000000,1209323520000000000,1210689028125000000,1215000000000000000,1215971899390033920,1216371917724609375,1217344914535219200,1218719480020992000,1220095597597920000,1220703125000000000,1223059046400000000,1224440064000000000,1225822640976562500,1228800000000000000,1230187500000000000,1231171548132409344,1232561725966909440,1233953473521254400,1235346792567894000,1235961914062500000,1236950581248000000,1238347284480000000,1239745564800000000,1244160000000000000,1245564843750000000,1247968747541495808,1249377891940270080,1250000000000000000,1250788627474992675,1251411437988281250,1252412463513600000,1253826625536000000,1255242384360000000,1258291200000000000,1259712000000000000,1261134404296875000,1264995115589523456,1265625000000000000,1266637395197952000,1268067619307520000,1269499458355200000,1270932914164500000,1274019840000000000,1275458400000000000,1280000000000000000,1281445312500000000,1282470362637926400,1283918464548864000,1285368201584640000,1286819575591556250,1287460327148437500,1288490188800000000,1289945088000000000,1291401630000000000,1296000000000000000,1297036692682702848,1297463378906250000,1298501242170900480,1299967445355724800,1301435304104448000,1304596316160000000,1306069401600000000,1307544150375000000,1310720000000000000,1312200000000000000,1313681671142578125,1314732507698036736,1316217038422671360,1317703245405753600,1318359375000000000,1319413953331200000,1320903770112000000,1322395269120000000,1323888452254687500,1327104000000000000,1328602500000000000,1332669751402954752,1334174535973325520,1334838867187500000,1335906627747840000,1337415067238400000,1338925209984000000,1342177280000000000,1343692800000000000,1345210031250000000,1350000000000000000,1350851717672992089,1351079888211148800,1351524353027343750,1352605460594688000,1354132755578880000,1355661775108800000,1358954496000000000,1360488960000000000,1362025156640625000,1366875000000000000,1367968386813788160,1369513028852121600,1371059415023616000,1372607547297660000,1373291015625000000,1374389534720000000,1375941427200000000,1377495072000000000,1382400000000000000,1383960937500000000,1385067991648960512,1386631941712773120,1388197657711411200,1389765141638880750,1390457153320312500,1391569403904000000,1393140695040000000,1394713760400000000,1399680000000000000,1401260449218750000,1403964840984182784,1405550128432803840,1406250000000000000,1407374883553280000,1408964021452800000,1410554953728000000,1412147682405000000,1415577600000000000,1417176000000000000,1418776204833984375,1423119505038213888,1423828125000000000,1424967069597696000,1426576071720960000,1428186890649600000,1429799528435062500,1430511474609375000,1433272320000000000,1434890700000000000,1440000000000000000,1441151880758558720,1441625976562500000,1442779157967667200,1444408272617472000,1446039226782720000,1449551462400000000,1451188224000000000,1452826833750000000,1458000000000000000,1459166279268040704,1459646301269531250,1460813897442263040,1462463376025190400,1464114717117504000,1464843750000000000,1467670855680000000,1469328076800000000,1470987169171875000,1474560000000000000,1476225000000000000,1479074071160291328,1480744168225505280,1482416151081472800,1483154296875000000,1484340697497600000,1486016741376000000,1487694677760000000,1490116119384765625,1492992000000000000,1494677812500000000,1499253470328324096,1500000000000000000,1500946352969991210,1501693725585937500,1502894956216320000,1504591950643200000,1506290861232000000,1509949440000000000,1511654400000000000,1513361285156250000,1518750000000000000,1519964874237542400,1521681143169024000,1523399350026240000,1525119496997400000,1525878906250000000,1528823808000000000,1530550080000000000,1532278301220703125,1536000000000000000,1537734375000000000,1538964435165511680,1540702157458636800,1542441841901568000,1544183490709867500,1544952392578125000,1546188226560000000,1547934105600000000,1549681956000000000,1555200000000000000,1556956054687500000,1558201490605080576,1559960934426869760,1561722364925337600,1562500000000000000,1565515579392000000,1567283281920000000,1569052980450000000,1572864000000000000,1574640000000000000,1576418005371093750,1579460446107205632,1581243894486904320,1582031250000000000,1583296743997440000,1585084524134400000,1586874322944000000,1588666142705625000,1592524800000000000,1594323000000000000,1600000000000000000,1601009443167990624,1601806640625000000,1603087953297408000,1604898080686080000,1606710251980800000,1609325408935546875,1610612736000000000,1612431360000000000,1614252037500000000,1620000000000000000,1621295865853378560,1621829223632812500,1623126552713625600,1624959306694656000,1626794130130560000,1630745395200000000,1632586752000000000,1634430187968750000,1638400000000000000,1640250000000000000,1641562064176545792,1643415634622545920,1645271298028339200,1647129056757192000,1647949218750000000,1649267441664000000,1651129712640000000,1652994086400000000,1654860565318359375,1658880000000000000,1660753125000000000,1663958330055327744,1665837189253693440,1667718169966656900,1668548583984375000,1669883284684800000,1671768834048000000,1673656512480000000,1677721600000000000,1679616000000000000,1681512539062500000,1686660154119364608,1687500000000000000,1688849860263936000,1690756825743360000,1692665944473600000,1694577218886000000,1698693120000000000,1700611200000000000,1702531445800781250,1708593750000000000,1709960483517235200,1711891286065152000,1713824268779520000,1715759434122075000,1716613769531250000,1717986918400000000,1719926784000000000,1721868840000000000,1728000000000000000,1729382256910270464,1729951171875000000,1731334989561200640,1733289927140966400,1735247072139264000,1738071441650390625,1739461754880000000,1741425868800000000,1743392200500000000,1749600000000000000,1751575561523437500,1752976676930715648,1754956051230228480,1756937660541004800,1757812500000000000,1759218604441600000,1761205026816000000,1763193692160000000,1765184603006250000,1769472000000000000,1771470000000000000,1776893001870606336,1778899381297767360,1779785156250000000,1781208836997120000,1783220089651200000,1785233613312000000,1787249410543828125,1788139343261718750,1791590400000000000,1793613375000000000,1800000000000000000,1801135623563989452,1801439850948198400,1802032470703125000,1803473947459584000,1805510340771840000,1807549033478400000,1811939328000000000,1813985280000000000,1816033542187500000,1822500000000000000,1823957849085050880,1826017371802828800,1828079220031488000,1830143396396880000,1831054687500000000,1834588569600000000,1836660096000000000,1838733961464843750,1843200000000000000,1845281250000000000,1846757322198614016,1848842588950364160,1850930210281881600,1853020188851841000,1853942871093750000,1855425871872000000,1857520926720000000,1859618347200000000,1866240000000000000,1868347265625000000,1871953121312243712,1874066837910405120,1875000000000000000,1877117156982421875,1878618695270400000,1880739938304000000,1882863576540000000,1887436800000000000,1889568000000000000,1891701606445312500,1897492673384285184,1898437500000000000,1899956092796928000,1902101428961280000,1904249187532800000,1906399371246750000,1907348632812500000,1911029760000000000,1913187600000000000,1920000000000000000,1922167968750000000,1923705543956889600,1925877696823296000,1928052302376960000,1930229363387334375,1931190490722656250,1932735283200000000,1934917632000000000,1937102445000000000,1944000000000000000,1945555039024054272,1946195068359375000,1947751863256350720,1949951168033587200,1952152956156672000,1953125000000000000,1956894474240000000,1959104102400000000,1961316225562500000,1966080000000000000,1968300000000000000,1972098761547055104,1974325557634007040,1976554868108630400,1977539062500000000,1979120929996800000,1981355655168000000,1983592903680000000,1985832678382031250,1990656000000000000,1992903750000000000,1999004627104432128,2000000000000000000,2001261803959988280,2002258300781250000,2003859941621760000,2006122600857600000,2008387814976000000,2013265920000000000,2015539200000000000,2017815046875000000,2025000000000000000,2026619832316723200,2027286529541015625,2028908190892032000,2031199133368320000,2033492662663200000,2038431744000000000,2040733440000000000,2043037734960937500,2048000000000000000,2050312500000000000,2051952580220682240,2054269543278182400,2056589122535424000,2058911320946490000,2059936523437500000,2061584302080000000,2063912140800000000,2066242608000000000,2073600000000000000,2075941406250000000,2077601987473440768,2079947912569159680,2082296486567116800,2084647712458321125,2085685729980468750,2087354105856000000,2089711042560000000,2092070640600000000,2097152000000000000,2099520000000000000,2101890673828125000,2105947261476274176,2108325192649205760,2109375000000000000,2111062325329920000,2113446032179200000,2115832430592000000,2118221523607500000,2123366400000000000,2125764000000000000,2134679257557320832,2135742187500000000,2137450604396544000,2139864107581440000,2142280335974400000,2144699292652593750,2145767211914062500,2147483648000000000,2149908480000000000,2152336050000000000,2160000000000000000,2161727821137838080,2162438964843750000,2164168736951500800,2166612408926208000,2169058840174080000,2174327193600000000,2176782336000000000,2179240250625000000,2187000000000000000,2188749418902061056,2189469451904296875,2191220846163394560,2193695064037785600,2196172075676256000,2197265625000000000,2199023255552000000,2201506283520000000,2203992115200000000,2206480753757812500,2211840000000000000,2214337500000000000,2218611106740436992,2221116252338257920,2223624226622209200,2224731445312500000,2226511046246400000,2229025112064000000,2231542016640000000,2239488000000000000,2242016718750000000,2248880205492486144,2250000000000000000,2251419529454986815,2251799813685248000,2252540588378906250,2254342434324480000,2256887925964800000,2259436291848000000,2264924160000000000,2267481600000000000,2270041927734375000,2278125000000000000,2279947311356313600,2282521714753536000,2285099025039360000,2287679245496100000,2288818359375000000,2293235712000000000,2295825120000000000,2304000000000000000,2305843009213693952,2306601562500000000,2308446652748267520,2311053236187955200,2313662762852352000,2316275236064801250,2317428588867187500,2319282339840000000,2321901158400000000,2324522934000000000,2332800000000000000,2335434082031250000,2337302235907620864,2339941401640304640,2342583547388006400,2343750000000000000,2348273369088000000,2350924922880000000,2353579470675000000,2359296000000000000,2361960000000000000,2364627008056640625,2369190669160808448,2371865841730356480,2373046875000000000,2374945115996160000,2377626786201600000,2380311484416000000,2382999214058437500,2384185791015625000,2388787200000000000,2391484500000000000,2400000000000000000,2401514164751985936,2402709960937500000,2404631929946112000,2407347121029120000,2410065377971200000,2415919104000000000,2418647040000000000,2421378056250000000,2430000000000000000,2431943798780067840,2432743835449218750,2434689829070438400,2437438960041984000,2440191195195840000,2441406250000000000,2446118092800000000,2448880128000000000,2451645281953125000,2457600000000000000,2460375000000000000,2462343096264818688,2465123451933818880,2467906947042508800,2470693585135788000,2471923828125000000,2473901162496000000,2476694568960000000,2479491129600000000,2488320000000000000,2491129687500000000,2495937495082991616,2498755783880540160,2500000000000000000,2501577254949985350,2502822875976562500,2504824927027200000,2507653251072000000,2510484768720000000,2516582400000000000,2519424000000000000,2522268808593750000,2529990231179046912,2531250000000000000,2533274790395904000,2536135238615040000,2538998916710400000,2541865828329000000,2548039680000000000,2550916800000000000,2553797168701171875,2560000000000000000,2562890625000000000,2564940725275852800,2567836929097728000,2570736403169280000,2573639151183112500,2574920654296875000,2576980377600000000,2579890176000000000,2582803260000000000,2592000000000000000,2594073385365405696,2594926757812500000,2597002484341800960,2599934890711449600,2602870608208896000,2609192632320000000,2612138803200000000,2615088300750000000,2621440000000000000,2624400000000000000,2627363342285156250,2629465015396073472,2632434076845342720,2635406490811507200,2636718750000000000,2638827906662400000,2641807540224000000,2644790538240000000,2647776904509375000,2654208000000000000,2657205000000000000,2665339502805909504,2668349071946651040,2669677734375000000,2671813255495680000,2674830134476800000,2677850419968000000,2682209014892578125,2684354560000000000,2687385600000000000,2690420062500000000,2700000000000000000,2701703435345984178,2702159776422297600,2703048706054687500,2705210921189376000,2708265511157760000,2711323550217600000,2717908992000000000,2720977920000000000,2724050313281250000,2733750000000000000,2735936773627576320,2739026057704243200,2742118830047232000,2745215094595320000,2746582031250000000,2748779069440000000,2751882854400000000,2754990144000000000,2758100942197265625,2764800000000000000,2767921875000000000,2770135983297921024,2773263883425546240,2776395315422822400,2779530283277761500,2780914306640625000,2783138807808000000,2786281390080000000,2789427520800000000,2799360000000000000,2802520898437500000,2807929681968365568,2811100256865607680,2812500000000000000,2814749767106560000,2817928042905600000,2821109907456000000,2824295364810000000,2831155200000000000,2834352000000000000,2837552409667968750,2846239010076427776,2847656250000000000,2849934139195392000,2853152143441920000,2856373781299200000,2859599056870125000,2861022949218750000,2866544640000000000,2869781400000000000,2880000000000000000,2882303761517117440,2883251953125000000,2885558315935334400,2888816545234944000,2892078453565440000,2896785736083984375,2899102924800000000,2902376448000000000,2905653667500000000,2916000000000000000,2918332558536081408,2919292602539062500,2921627794884526080,2924926752050380800,2928229434235008000,2929687500000000000,2935341711360000000,2938656153600000000,2941974338343750000,2949120000000000000,2952450000000000000,2958148142320582656,2961488336451010560,2964832302162945600,2966308593750000000,2968681394995200000,2972033482752000000,2975389355520000000,2978749017573046875,2980232238769531250,2985984000000000000,2989355625000000000,2998506940656648192,3000000000000000000,3001892705939982420,3003387451171875000,3005789912432640000,3009183901286400000,3012581722464000000,3019898880000000000,3023308800000000000,3026722570312500000,3037500000000000000,3039929748475084800,3043362286338048000,3046798700052480000,3050238993994800000,3051757812500000000,3057647616000000000,3061100160000000000,3064556602441406250,3072000000000000000,3075468750000000000,3077928870331023360,3081404314917273600,3084883683803136000,3088366981419735000,3089904785156250000,3092376453120000000,3095868211200000000,3099363912000000000,3110400000000000000,3113912109375000000,3116402981210161152,3119921868853739520,3123444729850675200,3125000000000000000,3128528594970703125,3131031158784000000,3134566563840000000,3138105960900000000,3145728000000000000,3149280000000000000,3152836010742187500,3158920892214411264,3162487788973808640,3164062500000000000,3166593487994880000,3170169048268800000,3173748645888000000,3177332285411250000,3185049600000000000,3188646000000000000,3200000000000000000,3202018886335981248,3203613281250000000,3206175906594816000,3209796161372160000,3213420503961600000,3217048938978890625,3218650817871093750,3221225472000000000,3224862720000000000,3228504075000000000,3240000000000000000,3242591731706757120,3243658447265625000,3246253105427251200,3249918613389312000,3253588260261120000,3261490790400000000,3265173504000000000,3268860375937500000,3276800000000000000,3280500000000000000,3283124128353091584,3286831269245091840,3290542596056678400,3294258113514384000,3295898437500000000,3298534883328000000,3302259425280000000,3305988172800000000,3309721130636718750,3317760000000000000,3321506250000000000,3327916660110655488,3331674378507386880,3335436339933313800,3337097167968750000,3339766569369600000,3343537668096000000,3347313024960000000,3355443200000000000,3359232000000000000,3363025078125000000,3373320308238729216,3375000000000000000,3377699720527872000,3378810882568359375,3381513651486720000,3385331888947200000,3389154437772000000,3397386240000000000,3401222400000000000,3405062891601562500,3417187500000000000,3419920967034470400,3423782572130304000,3427648537559040000,3431518868244150000,3433227539062500000,3435973836800000000,3439853568000000000,3443737680000000000,3456000000000000000,3458764513820540928,3459902343750000000,3462669979122401280,3466579854281932800,3470494144278528000,3474412854097201875,3476142883300781250,3478923509760000000,3482851737600000000,3486784401000000000,3499200000000000000,3503151123046875000,3505953353861431296,3509912102460456960,3513875321082009600,3515625000000000000,3518437208883200000,3522410053632000000,3526387384320000000,3530369206012500000,3538944000000000000,3542940000000000000,3553786003741212672,3557798762595534720,3559570312500000000,3562417673994240000,3566440179302400000,3570467226624000000,3574498821087656250,3576278686523437500,3583180800000000000,3587226750000000000,3600000000000000000,3602271247127978904,3602879701896396800,3604064941406250000,3606947894919168000,3611020681543680000,3615098066956800000,3623878656000000000,3627970560000000000,3632067084375000000,3645000000000000000,3647915698170101760,3649115753173828125,3652034743605657600,3656158440062976000,3660286792793760000,3662109375000000000,3669177139200000000,3673320192000000000,3677467922929687500,3686400000000000000,3690562500000000000,3693514644397228032,3697685177900728320,3701860420563763200,3706040377703682000,3707885742187500000,3710851743744000000,3715041853440000000,3719236694400000000,3732480000000000000,3736694531250000000,3743906242624487424,3748133675820810240,3750000000000000000,3752365882424978025,3754234313964843750,3757237390540800000,3761479876608000000,3765727153080000000,3774873600000000000,3779136000000000000,3783403212890625000,3794985346768570368,3796875000000000000,3799912185593856000,3804202857922560000,3808498375065600000,3812798742493500000,3814697265625000000,3822059520000000000,3826375200000000000,3840000000000000000,3844335937500000000,3847411087913779200,3851755393646592000,3856104604753920000,3860458726774668750,3862380981445312500,3865470566400000000,3869835264000000000,3874204890000000000,3888000000000000000,3891110078048108544,3892390136718750000,3895503726512701440,3899902336067174400,3904305912313344000,3906250000000000000,3913788948480000000,3918208204800000000,3922632451125000000,3932160000000000000,3936600000000000000,3941045013427734375,3944197523094110208,3948651115268014080,3953109736217260800,3955078125000000000,3958241859993600000,3962711310336000000,3967185807360000000,3971665356764062500,3981312000000000000,3985807500000000000,3998009254208864256,4000000000000000000,4002523607919976560,4004516601562500000,4007719883243520000,4012245201715200000,4016775629952000000,4026531840000000000,4031078400000000000,4035630093750000000,4050000000000000000,4052555153018976267,4053239664633446400,4054573059082031250,4057816381784064000,4062398266736640000,4066985325326400000,4076863488000000000,4081466880000000000,4086075469921875000,4096000000000000000,4100625000000000000,4103905160441364480,4108539086556364800,4113178245070848000,4117822641892980000,4119873046875000000,4123168604160000000,4127824281600000000,4132485216000000000,4147200000000000000,4151882812500000000,4155203974946881536,4159895825138319360,4164592973134233600,4169295424916642250,4171371459960937500,4174708211712000000,4179422085120000000,4184141281200000000,4194304000000000000,4199040000000000000,4203781347656250000,4211894522952548352,4216650385298411520,4218750000000000000,4222124650659840000,4226892064358400000,4231664861184000000,4236443047215000000,4246732800000000000,4251528000000000000,4256328614501953125,4269358515114641664,4271484375000000000,4274901208793088000,4279728215162880000,4284560671948800000,4289398585305187500,4291534423828125000,4294967296000000000,4299816960000000000,4304672100000000000,4320000000000000000,4323455642275676160,4324877929687500000,4328337473903001600,4333224817852416000,4338117680348160000,4348654387200000000,4353564672000000000,4358480501250000000,4374000000000000000,4377498837804122112,4378938903808593750,4382441692326789120,4387390128075571200,4392344151352512000,4394531250000000000,4398046511104000000,4403012567040000000,4407984230400000000,4412961507515625000,4423680000000000000,4428675000000000000,4437222213480873984,4442232504676515840,4447248453244418400,4449462890625000000,4453022092492800000,4458050224128000000,4463084033280000000,4470348358154296875,4478976000000000000,4484033437500000000,4497760410984972288,4500000000000000000,4502839058909973630,4503599627370496000,4505081176757812500,4508684868648960000,4513775851929600000,4518872583696000000,4529848320000000000,4534963200000000000,4540083855468750000,4556250000000000000,4559894622712627200,4565043429507072000,4570198050078720000,4575358490992200000,4577636718750000000,4586471424000000000,4591650240000000000,4596834903662109375,4608000000000000000,4611686018427387904,4613203125000000000,4616893305496535040,4622106472375910400,4627325525704704000,4632550472129602500,4634857177734375000,4638564679680000000,4643802316800000000,4649045868000000000,4665600000000000000,4670868164062500000,4674604471815241728,4679882803280609280,4685167094776012800,4687500000000000000,4696546738176000000,4701849845760000000,4707158941350000000,4718592000000000000,4723920000000000000,4729254016113281250,4738381338321616896,4743731683460712960,4746093750000000000,4749890231992320000,4755253572403200000,4760622968832000000,4765998428116875000,4768371582031250000,4777574400000000000,4782969000000000000,4800000000000000000,4803028329503971872,4805419921875000000,4809263859892224000,4814694242058240000,4820130755942400000,4827976226806640625,4831838208000000000,4837294080000000000,4842756112500000000,4860000000000000000,4863887597560135680,4865487670898437500,4869379658140876800,4874877920083968000,4880382390391680000,4882812500000000000,4892236185600000000,4897760256000000000,4903290563906250000,4915200000000000000,4920750000000000000,4924686192529637376,4930246903867637760,4935813894085017600,4941387170271576000,4943847656250000000,4947802324992000000,4953389137920000000,4958982259200000000,4964581695955078125,4976640000000000000,4982259375000000000,4991874990165983232,4997511567761080320,5000000000000000000,5003154509899970700,5005645751953125000,5009649854054400000,5015306502144000000,5020969537440000000,5033164800000000000,5038848000000000000,5044537617187500000,5059980462358093824,5062500000000000000,5066549580791808000,5072270477230080000,5077997833420800000,5083731656658000000,5096079360000000000,5101833600000000000,5107594337402343750,5120000000000000000,5125781250000000000,5129881450551705600,5135673858195456000,5141472806338560000,5147278302366225000,5149841308593750000,5153960755200000000,5159780352000000000,5165606520000000000,5184000000000000000,5188146770730811392,5189853515625000000,5194004968683601920,5199869781422899200,5205741216417792000,5214214324951171875,5218385264640000000,5224277606400000000,5230176601500000000,5242880000000000000,5248800000000000000,5254726684570312500,5258930030792146944,5264868153690685440,5270812981623014400,5273437500000000000,5277655813324800000,5283615080448000000,5289581076480000000,5295553809018750000,5308416000000000000,5314410000000000000,5330679005611819008,5336698143893302080,5339355468750000000,5343626510991360000,5349660268953600000,5355700839936000000,5361748231631484375,5364418029785156250,5368709120000000000,5374771200000000000,5380840125000000000,5400000000000000000,5403406870691968356,5404319552844595200,5406097412109375000,5410421842378752000,5416531022315520000,5422647100435200000,5435817984000000000,5441955840000000000,5448100626562500000,5467500000000000000,5471873547255152640,5478052115408486400,5484237660094464000,5490430189190640000,5493164062500000000,5497558138880000000,5503765708800000000,5509980288000000000,5516201884394531250,5529600000000000000,5535843750000000000,5540271966595842048,5546527766851092480,5552790630845644800,5559060566555523000,5561828613281250000,5566277615616000000,5572562780160000000,5578855041600000000,5598720000000000000,5605041796875000000,5615859363936731136,5622200513731215360,5625000000000000000,5629499534213120000,5631351470947265625,5635856085811200000,5642219814912000000,5648590729620000000,5662310400000000000,5668704000000000000,5675104819335937500,5692478020152855552,5695312500000000000,5699868278390784000,5706304286883840000,5712747562598400000,5719198113740250000,5722045898437500000,5733089280000000000,5739562800000000000,5760000000000000000,5764607523034234880,5766503906250000000,5771116631870668800,5777633090469888000,5784156907130880000,5790688090162003125,5793571472167968750,5798205849600000000,5804752896000000000,5811307335000000000,5832000000000000000,5836665117072162816,5838585205078125000,5843255589769052160,5849853504100761600,5856458868470016000,5859375000000000000,5870683422720000000,5877312307200000000,5883948676687500000,5898240000000000000,5904900000000000000,5916296284641165312,5922976672902021120,5929664604325891200,5932617187500000000,5937362789990400000,5944066965504000000,5950778711040000000,5957498035146093750,5960464477539062500,5971968000000000000,5978711250000000000,5997013881313296384,6000000000000000000,6003785411879964840,6006774902343750000,6011579824865280000,6018367802572800000,6025163444928000000,6039797760000000000,6046617600000000000,6053445140625000000,6075000000000000000,6079859496950169600,6081859588623046875,6086724572676096000,6093597400104960000,6100477987989600000,6103515625000000000,6115295232000000000,6122200320000000000,6129113204882812500,6144000000000000000,6150937500000000000,6155857740662046720,6162808629834547200,6169767367606272000,6176733962839470000,6179809570312500000,6184752906240000000,6191736422400000000,6198727824000000000,6220800000000000000,6227824218750000000,6232805962420322304,6239843737707479040,6246889459701350400,6250000000000000000,6253943137374963375,6257057189941406250,6262062317568000000,6269133127680000000,6276211921800000000,6291456000000000000,6298560000000000000,6305672021484375000,6317841784428822528,6324975577947617280,6328125000000000000,6333186975989760000,6340338096537600000,6347497291776000000,6354664570822500000,6370099200000000000,6377292000000000000,6400000000000000000,6404037772671962496,6407226562500000000,6412351813189632000,6419592322744320000,6426841007923200000,6434097877957781250,6437301635742187500,6442450944000000000,6449725440000000000,6457008150000000000,6480000000000000000,6485183463413514240,6487316894531250000,6492506210854502400,6499837226778624000,6507176520522240000,6522981580800000000,6530347008000000000,6537720751875000000,6553600000000000000,6561000000000000000,6566248256706183168,6568408355712890625,6573662538490183680,6581085192113356800,6588516227028768000,6591796875000000000,6597069766656000000,6604518850560000000,6611976345600000000,6619442261273437500,6635520000000000000,6643012500000000000,6655833320221310976,6663348757014773760,6670872679866627600,6674194335937500000,6679533138739200000,6687075336192000000,6694626049920000000,6710886400000000000,6718464000000000000,6726050156250000000,6746640616477458432,6750000000000000000,6754258588364960445,6755399441055744000,6757621765136718750,6763027302973440000,6770663777894400000,6778308875544000000,6794772480000000000,6802444800000000000,6810125783203125000,6834375000000000000,6839841934068940800,6847565144260608000,6855297075118080000,6863037736488300000,6866455078125000000,6871947673600000000,6879707136000000000,6887475360000000000,6912000000000000000,6917529027641081856,6919804687500000000,6925339958244802560,6933159708563865600,6940988288557056000,6948825708194403750,6952285766601562500,6957847019520000000,6965703475200000000,6973568802000000000,6998400000000000000,7006302246093750000,7011906707722862592,7019824204920913920,7027750642164019200,7031250000000000000,7036874417766400000,7044820107264000000,7052774768640000000,7060738412025000000,7077888000000000000,7085880000000000000,7093881024169921875,7107572007482425344,7115597525191069440,7119140625000000000,7124835347988480000,7132880358604800000,7140934453248000000,7148997642175312500,7152557373046875000,7166361600000000000,7174453500000000000,7200000000000000000,7204542494255957808,7205759403792793600,7208129882812500000,7213895789838336000,7222041363087360000,7230196133913600000,7247757312000000000,7255941120000000000,7264134168750000000,7290000000000000000,7295831396340203520,7298231506347656250,7304069487211315200,7312316880125952000,7320573585587520000,7324218750000000000,7338354278400000000,7346640384000000000,7354935845859375000,7372800000000000000,7381125000000000000,7387029288794456064,7395370355801456640,7403720841127526400,7412080755407364000,7415771484375000000,7421703487488000000,7430083706880000000,7438473388800000000,7450580596923828125,7464960000000000000,7473389062500000000,7487812485248974848,7496267351641620480,7500000000000000000,7504731764849956050,7508468627929687500,7514474781081600000,7522959753216000000,7531454306160000000,7549747200000000000,7558272000000000000,7566806425781250000,7589970693537140736,7593750000000000000,7599824371187712000,7608405715845120000,7616996750131200000,7625597484987000000,7629394531250000000,7644119040000000000,7652750400000000000,7661391506103515625,7680000000000000000,7688671875000000000,7694822175827558400,7703510787293184000,7712209209507840000,7720917453549337500,7724761962890625000,7730941132800000000,7739670528000000000,7748409780000000000,7776000000000000000,7782220156096217088,7784780273437500000,7791007453025402880,7799804672134348800,7808611824626688000,7812500000000000000,7827577896960000000,7836416409600000000,7845264902250000000,7864320000000000000,7873200000000000000,7882090026855468750,7888395046188220416,7897302230536028160,7906219472434521600,7910156250000000000,7916483719987200000,7925422620672000000,7934371614720000000,7943330713528125000,7962624000000000000,7971615000000000000,7996018508417728512,8000000000000000000,8005047215839953120,8009033203125000000,8015439766487040000,8024490403430400000,8033551259904000000,8046627044677734375,8053063680000000000,8062156800000000000,8071260187500000000,8100000000000000000,8105110306037952534,8106479329266892800,8109146118164062500,8115632763568128000,8124796533473280000,8133970650652800000,8153726976000000000,8162933760000000000,8172150939843750000,8192000000000000000,8201250000000000000,8207810320882728960,8217078173112729600,8226356490141696000,8235645283785960000,8239746093750000000,8246337208320000000,8255648563200000000,8264970432000000000,8274302826591796875,8294400000000000000,8303765625000000000,8310407949893763072,8319791650276638720,8329185946268467200,8338590849833284500,8342742919921875000,8349416423424000000,8358844170240000000,8368282562400000000,8388608000000000000,8398080000000000000,8407562695312500000,8423789045905096704,8433300770596823040,8437500000000000000,8444249301319680000,8453784128716800000,8463329722368000000,8472886094430000000,8493465600000000000,8503056000000000000,8512657229003906250,8538717030229283328,8542968750000000000,8549802417586176000,8559456430325760000,8569121343897600000,8578797170610375000,8583068847656250000,8589934592000000000,8599633920000000000,8609344200000000000,8640000000000000000,8646911284551352320,8649755859375000000,8656674947806003200,8666449635704832000,8676235360696320000,8690357208251953125,8697308774400000000,8707129344000000000,8716961002500000000,8748000000000000000,8754997675608244224,8757877807617187500,8764883384653578240,8774780256151142400,8784688302705024000,8789062500000000000,8796093022208000000,8806025134080000000,8815968460800000000,8825923015031250000,8847360000000000000,8857350000000000000,8874444426961747968,8884465009353031680,8894496906488836800,8898925781250000000,8906044184985600000,8916100448256000000,8926168066560000000,8936247052719140625,8940696716308593750,8957952000000000000,8968066875000000000,8995520821969944576,9000000000000000000,9005678117819947260,9007199254740992000,9010162353515625000,9017369737297920000,9027551703859200000,9037745167392000000,9059696640000000000,9069926400000000000,9080167710937500000,9112500000000000000,9119789245425254400,9130086859014144000,9140396100157440000,9150716981984400000,9155273437500000000,9172942848000000000,9183300480000000000,9193669807324218750,9216000000000000000,9223372036854775808,9226406250000000000,9233786610993070080,9244212944751820800,9254651051409408000,9265100944259205000,9269714355468750000,9277129359360000000,9287604633600000000,9298091736000000000,9331200000000000000,9341736328125000000,9349208943630483456,9359765606561218560,9370334189552025600,9375000000000000000,9385585784912109375,9393093476352000000,9403699691520000000,9414317882700000000,9437184000000000000,9447840000000000000,9458508032226562500,9476762676643233792,9487463366921425920,9492187500000000000,9499780463984640000,9510507144806400000,9521245937664000000,9531996856233750000,9536743164062500000,9555148800000000000,9565938000000000000,9600000000000000000,9606056659007943744,9610839843750000000,9618527719784448000,9629388484116480000,9640261511884800000,9651146816936671875,9655952453613281250,9663676416000000000,9674588160000000000,9685512225000000000,9720000000000000000,9727775195120271360,9730975341796875000,9738759316281753600,9749755840167936000,9760764780783360000,9765625000000000000,9784472371200000000,9795520512000000000,9806581127812500000,9830400000000000000,9841500000000000000,9849372385059274752,9860493807735275520,9871627788170035200,9882774340543152000,9887695312500000000,9895604649984000000,9906778275840000000,9917964518400000000,9929163391910156250,9953280000000000000,9964518750000000000,9983749980331966464,9995023135522160640,10000000000000000000,10006309019799941400,10011291503906250000,10019299708108800000,10030613004288000000,10041939074880000000,10066329600000000000,10077696000000000000,10089075234375000000,10119960924716187648,10125000000000000000,10133099161583616000,10136432647705078125,10144540954460160000,10155995666841600000,10167463313316000000,10192158720000000000,10203667200000000000,10215188674804687500,10240000000000000000,10251562500000000000,10259762901103411200,10271347716390912000,10282945612677120000,10294556604732450000,10299682617187500000,10307921510400000000,10319560704000000000,10331213040000000000,10368000000000000000,10376293541461622784,10379707031250000000,10388009937367203840,10399739562845798400,10411482432835584000,10423238562291605625,10428428649902343750,10436770529280000000,10448555212800000000,10460353203000000000,10485760000000000000,10497600000000000000,10509453369140625000,10517860061584293888,10529736307381370880,10541625963246028800,10546875000000000000,10555311626649600000,10567230160896000000,10579162152960000000,10591107618037500000,10616832000000000000,10628820000000000000,10661358011223638016,10673396287786604160,10678710937500000000,10687253021982720000,10699320537907200000,10711401679872000000,10723496463262968750,10728836059570312500,10737418240000000000,10749542400000000000,10761680250000000000,10800000000000000000,10806813741383936712,10808639105689190400,10812194824218750000,10820843684757504000,10833062044631040000,10845294200870400000,10871635968000000000,10883911680000000000,10896201253125000000,10935000000000000000,10943747094510305280,10947347259521484375,10956104230816972800,10968475320188928000,10980860378381280000,10986328125000000000,10995116277760000000,11007531417600000000,11019960576000000000,11032403768789062500,11059200000000000000,11071687500000000000,11080543933191684096,11093055533702184960,11105581261691289600,11118121133111046000,11123657226562500000,11132555231232000000,11145125560320000000,11157710083200000000,11197440000000000000,11210083593750000000,11231718727873462272,11244401027462430720,11250000000000000000,11257097647274934075,11258999068426240000,11262702941894531250,11271712171622400000,11284439629824000000,11297181459240000000,11324620800000000000,11337408000000000000,11350209638671875000,11384956040305711104,11390625000000000000,11399736556781568000,11412608573767680000,11425495125196800000,11438396227480500000,11444091796875000000,11466178560000000000,11479125600000000000,11520000000000000000,11529215046068469760,11533007812500000000,11542233263741337600,11555266180939776000,11568313814261760000,11581376180324006250,11587142944335937500,11596411699200000000,11609505792000000000,11622614670000000000,11664000000000000000,11673330234144325632,11677170410156250000,11686511179538104320,11699707008201523200,11712917736940032000,11718750000000000000,11741366845440000000,11754624614400000000,11767897353375000000,11796480000000000000,11809800000000000000,11823135040283203125,11832592569282330624,11845953345804042240,11859329208651782400,11865234375000000000,11874725579980800000,11888133931008000000,11901557422080000000,11914996070292187500,11920928955078125000,11943936000000000000,11957422500000000000,11994027762626592768,12000000000000000000,12007570823759929680,12013549804687500000,12023159649730560000,12036735605145600000,12050326889856000000,12079595520000000000,12093235200000000000,12106890281250000000,12150000000000000000,12157665459056928801,12159718993900339200,12163719177246093750,12173449145352192000,12187194800209920000,12200955975979200000,12207031250000000000,12230590464000000000,12244400640000000000,12258226409765625000,12288000000000000000,12301875000000000000,12311715481324093440,12325617259669094400,12339534735212544000,12353467925678940000,12359619140625000000,12369505812480000000,12383472844800000000,12397455648000000000,12441600000000000000,12455648437500000000,12465611924840644608,12479687475414958080,12493778919402700800,12500000000000000000,12507886274749926750,12514114379882812500,12524124635136000000,12538266255360000000,12552423843600000000,12582912000000000000,12597120000000000000,12611344042968750000,12635683568857645056,12649951155895234560,12656250000000000000,12666373951979520000,12680676193075200000,12694994583552000000,12709329141645000000,12740198400000000000,12754584000000000000,12768985843505859375,12800000000000000000,12808075545343924992,12814453125000000000,12824703626379264000,12839184645488640000,12853682015846400000,12868195755915562500,12874603271484375000,12884901888000000000,12899450880000000000,12914016300000000000,12960000000000000000,12970366926827028480,12974633789062500000,12985012421709004800,12999674453557248000,13014353041044480000,13045963161600000000,13060694016000000000,13075441503750000000,13107200000000000000,13122000000000000000,13132496513412366336,13136816711425781250,13147325076980367360,13162170384226713600,13177032454057536000,13183593750000000000,13194139533312000000,13209037701120000000,13223952691200000000,13238884522546875000,13271040000000000000,13286025000000000000,13311666640442621952,13326697514029547520,13341745359733255200,13348388671875000000,13359066277478400000,13374150672384000000,13389252099840000000,13411045074462890625,13421772800000000000,13436928000000000000,13452100312500000000,13493281232954916864,13500000000000000000,13508517176729920890,13510798882111488000,13515243530273437500,13526054605946880000,13541327555788800000,13556617751088000000,13589544960000000000,13604889600000000000,13620251566406250000,13668750000000000000,13679683868137881600,13695130288521216000,13710594150236160000,13726075472976600000,13732910156250000000,13743895347200000000,13759414272000000000,13774950720000000000,13790504710986328125,13824000000000000000,13835058055282163712,13839609375000000000,13850679916489605120,13866319417127731200,13881976577114112000,13897651416388807500,13904571533203125000,13915694039040000000,13931406950400000000,13947137604000000000,13996800000000000000,14012604492187500000,14023813415445725184,14039648409841827840,14055501284328038400,14062500000000000000,14073748835532800000,14089640214528000000,14105549537280000000,14121476824050000000,14155776000000000000,14171760000000000000,14187762048339843750,14215144014964850688,14231195050382138880,14238281250000000000,14249670695976960000,14265760717209600000,14281868906496000000,14297995284350625000,14305114746093750000,14332723200000000000,14348907000000000000,14400000000000000000,14409084988511915616,14411518807585587200,14416259765625000000,14427791579676672000,14444082726174720000,14460392267827200000,14483928680419921875,14495514624000000000,14511882240000000000,14528268337500000000,14580000000000000000,14591662792680407040,14596463012695312500,14608138974422630400,14624633760251904000,14641147171175040000,14648437500000000000,14676708556800000000,14693280768000000000,14709871691718750000,14745600000000000000,14762250000000000000,14774058577588912128,14790740711602913280,14807441682255052800,14824161510814728000,14831542968750000000,14843406974976000000,14860167413760000000,14876946777600000000,14893745087865234375,14901161193847656250,14929920000000000000,14946778125000000000,14975624970497949696,14992534703283240960,15000000000000000000,15009463529699912100,15016937255859375000,15028949562163200000,15045919506432000000,15062908612320000000,15099494400000000000,15116544000000000000,15133612851562500000,15179941387074281472,15187500000000000000,15199648742375424000,15216811431690240000,15233993500262400000,15251194969974000000,15258789062500000000,15288238080000000000,15305500800000000000,15322783012207031250,15360000000000000000,15377343750000000000,15389644351655116800,15407021574586368000,15424418419015680000,15441834907098675000,15449523925781250000,15461882265600000000,15479341056000000000,15496819560000000000,15552000000000000000,15564440312192434176,15569560546875000000,15582014906050805760,15599609344268697600,15617223649253376000,15625000000000000000,15642642974853515625,15655155793920000000,15672832819200000000,15690529804500000000,15728640000000000000,15746400000000000000,15764180053710937500,15776790092376440832,15794604461072056320,15812438944869043200,15820312500000000000,15832967439974400000,15850845241344000000,15868743229440000000,15886661427056250000,15925248000000000000,15943230000000000000,15992037016835457024,16000000000000000000,16010094431679906240,16018066406250000000,16030879532974080000,16048980806860800000,16067102519808000000,16085244694894453125,16093254089355468750,16106127360000000000,16124313600000000000,16142520375000000000,16200000000000000000,16210220612075905068,16212958658533785600,16218292236328125000,16231265527136256000,16249593066946560000,16267941301305600000,16307453952000000000,16325867520000000000,16344301879687500000,16384000000000000000,16402500000000000000,16415620641765457920,16434156346225459200,16452712980283392000,16471290567571920000,16479492187500000000,16492674416640000000,16511297126400000000,16529940864000000000,16548605653183593750,16588800000000000000,16607531250000000000,16620815899787526144,16639583300553277440,16658371892536934400,16677181699666569000,16685485839843750000,16698832846848000000,16717688340480000000,16736565124800000000,16777216000000000000,16796160000000000000,16815125390625000000,16847578091810193408,16866601541193646080,16875000000000000000,16888498602639360000,16894054412841796875,16907568257433600000,16926659444736000000,16945772188860000000,16986931200000000000,17006112000000000000,17025314458007812500,17077434060458566656,17085937500000000000,17099604835172352000,17118912860651520000,17138242687795200000,17157594341220750000,17166137695312500000,17179869184000000000,17199267840000000000,17218688400000000000,17280000000000000000,17293822569102704640,17299511718750000000,17313349895612006400,17332899271409664000,17352470721392640000,17372064270486009375,17380714416503906250,17394617548800000000,17414258688000000000,17433922005000000000,17496000000000000000,17509995351216488448,17515755615234375000,17529766769307156480,17549560512302284800,17569376605410048000,17578125000000000000,17592186044416000000,17612050268160000000,17631936921600000000,17651846030062500000,17694720000000000000,17714700000000000000,17748888853923495936,17768930018706063360,17788993812977673600,17797851562500000000,17812088369971200000,17832200896512000000,17852336133120000000,17872494105438281250,17881393432617187500,17915904000000000000,17936133750000000000,17991041643939889152,18000000000000000000,18011356235639894520,18014398509481984000,18020324707031250000,18034739474595840000,18055103407718400000,18075490334784000000,18119393280000000000,18139852800000000000,18160335421875000000,18225000000000000000,18239578490850508800,18245578765869140625,18260173718028288000,18280792200314880000,18301433963968800000,18310546875000000000,18345885696000000000,18366600960000000000,18387339614648437500,18432000000000000000","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211947,"user_id":null,"body":"        global hamming\n        default rel\n        section .text\n        \n; uint64_t hamming(int n)\n; Parameter:    EDI (1 <= n <= 13282)\n; Return value: RAX  n'th hamming number\nhamming:\n        cmp edi, arg_limit\n        jbe .good_arg\n        mov rdi, arg_limit\n.good_arg:\n        call reset\n\n        mov rsi, buffer\n        mov r9, pos\n\n        xor rax, rax\n        mov [buftop], rax\n        inc rax\n        mov [rsi], rax                          ; buffer = { 1 }\n\n        dec edi\n        je .quit\n.next:\n        call update\n        call min_base_index                     ; rcx = min_base_index()\n        mov r10, [r9 + rcx * 8 + val - pos]     ; v = val[min_b_idx]\n        xor r11, r11\n        mov [r9 + rcx * 8 + val - pos], r11     ; val[min_b_idx] = Nothing\n\n        mov rdx, [buftop]\n        mov r11, [rsi + rdx * 8]                ; prev = buffer.back()\n\n        cmp r10, r11                            ; compare v, prev\n        je .next                                ; v == prev\n        inc rdx\n        mov [rsi + rdx * 8], r10                ; buffer.push_back(v)\n        mov [buftop], rdx\n\n        dec edi\n        jne .next\n.quit:\n        mov rdx, [buftop]\n        mov rax, [rsi + rdx * 8]                ; return buffer.back()\n        ret\n\nupdate:             ; (rsi buffer, r9 pos) -> void\n        push rdx\n        push rcx\n        push rax\n\n        xor rcx, rcx\n.loop:  call update_base\n        inc rcx\n        cmp rcx, 3\n        jb .loop\n\n        pop rax\n        pop rcx\n        pop rdx\n        ret\n\nupdate_base:        ; (rcx base_index, rsi buffer, r9 pos) -> void\n        mov rdx, [r9 + rcx * 8 + val - pos]     ; val[base_index]\n        test rdx, rdx\n        jne .skip\n\n        mov rdx, [r9 + rcx * 8]     ; pos[base_index]\n        mov rax, [buftop]\n        cmp rax, rdx                ; buff.size() - 1 < pos[base_index] -> skip\n        jl .skip\n\n        mov rax, [rsi + rdx * 8]    ; get buffer[pos]\n        inc rdx\n        mov [r9 + rcx * 8], rdx     ; pos[base_index]++\n        ; do multiply rax value using rcx base index\n        call mult_x\n        mov [r9 + rcx * 8 + val - pos], rax\n.skip:\n        ret\n\nmult_x:             ; (rax value, rcx index) -> rax\n        test rcx, rcx\n        je mult_x2\n        cmp rcx, 1\n        je mult_x3\n        jmp mult_x5\n\nmult_x2:            ; (rax value) -> rax\n        shl rax, 1\n        ret\n\nmult_x3:            ; (rax value) -> rax\n        push rcx\n        mov rcx, rax\n        shl rax, 1\n        add rax, rcx\n        pop rcx\n        ret\n\nmult_x5:            ; (rax value) -> rax\n        push rcx\n        mov rcx, rax\n        shl rax, 2\n        add rax, rcx\n        pop rcx\n        ret\n\nmin_base_index:     ; (r9 pos) -> rcx\n        xor rcx, rcx                            ; i\n        mov rdx, [r9 + rcx * 8 + val - pos]     ; val[i]\n        mov r10, rdx                            ; min_value\n        mov r11, rcx                            ; min_index\n.loop:\n        inc rcx\n        cmp rcx, 3\n        je .exitloop\n        mov rdx, [r9 + rcx * 8 + val - pos]     ; val[i]\n        test r10, r10\n        je .setmin                              ; min_value == 0\n        test rdx, rdx\n        je .loop                                ; x == 0\n        cmp rdx, r10                            ; x < min_value\n        jae .loop\n.setmin:\n        mov r10, rdx                            ; min_value = x\n        mov r11, rcx                            ; min_idx = i\n        jmp .loop\n.exitloop:\n        mov rcx, r11                            ; min_idx\n        ret                                     ; result = rcx\n\nreset:\n        push r9\n        push rdx\n        push rax\n\n        xor rax, rax\n        mov r9, pos\n        xor rdx, rdx\n.clean:\n        mov [r9 + rdx * 8], rax\n        inc rdx\n        cmp rdx, (buftop - pos) \/ 8\n        jle .clean\n\n        pop rax\n        pop rdx\n        pop r9\n        ret\n\n        section .data\narg_limit   equ 13282\npos:        dq 0\npos3:       dq 0\npos5:       dq 0\nval:        dq 0\nval3:       dq 0\nval5:       dq 0\nbuftop:     dq 0\n\n        section   .bss\nbufsize equ     arg_limit + 3\nbuffer  resq    bufsize\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52742f58faf5485cae000b9a":[{"id":211948,"user_id":null,"body":"%ifndef FMTDURATION_ASM\n%define FMTDURATION_ASM\n\nglobal fmtduration\nextern malloc\n\n; <--- [byte RAX] fmtduration(EDI n) --->\nfmtduration:\n    push rdi\n    sub rsp, 40h\n    mov rcx, 128\n    call malloc             ; create 128 byte buffer for output string\n    add rsp, 40h\n    mov rdi, rax            ; rdi holds pointer to output string buffer\n    mov r10, rax            ; r10 also holds a copy - kept unmodified for comparison and return\n    pop rax                 ; function parameter (total seconds) is now in eax\n    test eax, eax\n    jz .return_now          ; exit early on 0 seconds        \n    mov r9d, 10\n    mov ecx, 31536000       ; seconds per year\n    mov r8, year \n    call write_time\n    mov ecx, 86400          ; seconds per day\n    mov r8, day\n    call write_time\n    mov ecx, 3600           ; seconds per hour\n    mov r8, hour\n    call write_time\n    mov ecx, 60             ; seconds per minute\n    mov r8, minute\n    call write_time\n    mov ecx, 1              ; seconds per second\n    mov r8, second    \n    call write_time\n    mov byte [rdi], 0   ; terminator\n    mov rax, r10 ; pointer to string start into rax for return\n    ret\n            \n    .return_now:\n    mov dword [rdi], \"now\"    \n    mov rax, rdi\n    ret\n\n;helper function that writes a numeric portion of the output and the time unit name \n;expects eax to have the amount of seconds\n;expects ecx to be the number of seconds in the time unit being written\n;expects rdi to be pointer to write chars at\n;expects r8 to be pointer to string containing plural name of time unit\n;expects r9d to contain the base the number is to be written in (so 10) - need in register for division\n;expects r10 to hold the start of the string being written to (to detect if it has been written to yet)\n;returns seconds remaining eax\n;returns rdi pointing to after last char written\n;r9 & r10 unchanged\n;clobbers rcx, rdx, r8\nwrite_time:    \n    cmp eax, ecx            \n    jb .end_write_time      ; no number to write if smaller than the size of the time unit\n    xor edx, edx\n    div dword ecx\n    push rdx                ; save the seconds remaining not in this time unit\n    push rax                ; save the number of time units    \n    cmp rdi, r10            ; if current and inital string pointers are equal, no need for comma or \" and \" before number\n    je .ready_to_read       \n      test rdx, rdx         ; if remainder is not zero, this is not the last number, its a comma, if it is zero its \" and \"\n      jnz .do_comma\n        mov byte [rdi], ' ' ; add an \" and \" to the string\n        inc rdi\n        mov dword [rdi], \"and \" ; over 2 moves, which can probably be done better\n        add rdi, 4\n        jmp .ready_to_read\n      .do_comma:\n      mov word [rdi], \", \"\n      add rdi, 2    \n    .ready_to_read:    \n    xor ecx, ecx            ; char counter for .char_read_loop \n    .char_read_loop:        ; get digits in reverse order and push to stack\n        xor edx, edx\n        div r9d\n        add edx, '0'\n        push rdx\n        inc rcx\n    test eax, eax\n    jnz .char_read_loop     ; pop digits in correct order from stack and write to output string\n    .char_write_loop:\n        pop rdx\n        mov [rdi], dl\n        inc rdi\n    loop .char_write_loop    \n    mov byte [rdi], ' '     ; add a space\n    inc rdi\n    xor rdx, rdx\n    .name_copy_loop:\n        mov dl, [r8]\n        inc r8\n        mov [rdi], dl\n        inc rdi        \n    test edx, edx           ; test for terminator (edx is gauranteed to be empty apart from low byte)    \n    jnz .name_copy_loop    \n    dec rdi                 ; don't want the terminator that has just been written\n    pop rax                 ; recover the number of time units (the number that has just been written out)\n    cmp eax, 1\n    ja .s_is_done           ; keep the 's' if more than 1 unit\n      dec rdi\n    .s_is_done:    \n    pop rax                 ; recover the seconds remaining not in this time unit\n    .end_write_time:\n    ret\n\nsection .data\nnow: db \"now\", 0\nyear: db \"years\", 0\nday: db \"days\", 0\nhour: db \"hours\", 0\nminute: db \"minutes\", 0\nsecond: db \"seconds\", 0\n\n%endif","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211949,"user_id":null,"body":"%ifndef FMTDURATION_ASM\n%define FMTDURATION_ASM\n\nglobal fmtduration\nextern strdup\nextern sprintf\n\n; <--- [byte RAX] fmtduration(EDI n) --->\nfmtduration:\n    test edi, edi               ; whether <n> is zero\n    jne .start                  ; otherwise, jumping to .start\n    mov rdi, .now               ; pointing RDI to <.now>\n    jmp strdup                  ; jumping to (strdup) and exiting from here\n.start:\n    push r15                        ; saving R15 in the stack\n    push r14                        ; saving R14 in the stack\n    push r13                        ; saving R13 in the stack\n    push r12                        ; saving R12 in the stack\n    push rbp                        ; saving RBP in the stack\n    push rbx                        ; saving RBX in the stack\n    sub rsp, 0h98                   ; allocating storage for <fmtdur> and <dur>\n    lea rbp, [rsp+0h40]             ; pointing RBP to <fmtdur>\n    mov rbx, rsp                    ; pointing RBX to <dur>\n    mov qword [rbp-0h08], .singl    ; saving <.singl> locally\n    mov qword [rbp-0h10], .plurl    ; saving <.plurl> locally\n    mov qword [rbp-0h18], .disj     ; saving <.disj> locally\n    mov qword [rbp-0h20], .conj     ; saving <.conj> locally\n    mov dword [rbx], 31_536_000     ; saving year duration in <*dur>\n    mov dword [rbx+0h04], 86400     ; saving day duration in <*(dur+1)>\n    mov dword [rbx+0h08], 3600      ; saving hour duration in <*(dur+2)>\n    mov dword [rbx+0h0C], 60        ; saving minute duration in <*(dur+3)>\n    mov dword [rbx+0h10], 0         ; saving second duration in <*(dur+4)>\n    xor ecx, ecx                    ; resetting ECX as duration <i>terations to extract\n    xor esi, esi                    ; resetting ESI as <m>odifications\n.loopd:\n    mov eax, edi                ; copying <n> to EAX\n    xor edx, edx                ; resetting EDX before division\n    div dword [rbx]             ; dividing <n> by <*dur>\n    mov edi, edx                ; resaving <n> with the reminder from division\n    mov [rbx], eax              ; saving the duration in <*dur>\n    add rbx, 4                  ; pointing <dur> to the next duration\n    test eax, eax               ; whether the duration iz zero\n    je $+0h4                    ; skipping the next instruction\n    inc esi                     ; incrementing <esi>\n    inc ecx                     ; incrementing <i>\n    cmp ecx, 4                  ; whether <i> is less than four durations to extract\n    jl .loopd                   ; jumping to the next .loopd iteartion if <i> is positive\n    test edi, edi               ; whether <n> is not zero\n    je $+0h6                    ; otherwise, skipping the next two instructions\n    mov [rbx], edi              ; saving the second duration in <*dur>\n    inc esi                     ; incrementing <m>\n    inc ecx                     ; incrementing <i>\n    mov rbx, rsp                ; pointing RBX to the start of <dur>\n    mov r12, rbp                ; pointing R12 to <fmtdur>\n    xor r13d, r13d              ; resetting R13D as <n>\n    mov r14d, ecx               ; moving <i> to R14D\n    mov r15d, esi               ; moving <m> to R15D\n.loopf:\n    mov edx, [rbx+r13*4]        ; copying <*(dur+n)> to EDX as <d>\n    test edx, edx               ; whether <d> is zero\n    je .exit                    ; jumping to exit\n    mov rdi, r12                ; loading RDI with <fmtdur>\n    mov rsi, .fmtdur            ; loading RSI with <.fmtdur>\n    lea rcx, [.fmt+r13*8]       ; loading RCX with <*(.fmt+n)>\n    cmp edx, 1                  ; whether <d> is equal to one\n    cmove r8, [rbp-0h08]        ; loading R8 with <.singl>\n    cmovg r8, [rbp-0h10]        ; otherwise, loading R8 with <.plurl>\n    cmp r15d, 2                 ; whether <m> is less than two\n    cmovl r9, [rbp-0h08]        ; loading R9 with <.singl>\n    cmovg r9, [rbp-0h18]        ; otherwise, loading R9 with <.disj>\n    cmove r9, [rbp-0h20]        ; otherwise, loading R9 with <.conj>\n    xor eax, eax                ; resetting EAX forced by monadius though actually there's no need in it\n    call sprintf                ; printing to <fmtdur>\n    add r12, rax                ; shifting <fmtdur> by EAX characters\n    dec r15d                    ; decrementing <m>\n.exit:\n    inc r13d                    ; decrementing <n>\n    cmp r13d, r14d              ; whether <n> is less than <i>\n    jl .loopf                   ; jumping to the next .loopf iteration\n    mov rdi, rbp                ; loading RDI with <fmtdur>\n    call strdup                 ; allocating new space and copying local <fmtdur> into it\n    add rsp, 0h98               ; destroying the local storage\n    pop rbx                     ; restoring original RBX from the stack\n    pop rbp                     ; restoring original RBP from the stack\n    pop r12                     ; restoring original R12 from the stack\n    pop r13                     ; restoring original R13 from the stack\n    pop r14                     ; restoring original R14 from the stack\n    pop r15                     ; restoring original R15 from the stack\n    ret\n\n; local read-only storages\n.fmtdur:\n    db  `%u %s%s%s\\0`\n.singl:\n    db  `\\0`\n.plurl:\n    db  `s\\0`\n.disj:\n    db  `, \\0`\n.conj:\n    db  ` and \\0`\n.fmt:\n    db  `year\\0\\0\\0\\0`, \\\n        `day\\0\\0\\0\\0\\0`, \\\n        `hour\\0\\0\\0\\0`, \\\n        `minute\\0\\0`, \\\n        `second\\0\\0`\n.now:\n    db  `now\\0`\n; -----> endof fmtduration <-----\n\n%endif","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211950,"user_id":null,"body":"%ifndef FMTDURATION_ASM\n%define FMTDURATION_ASM\n\nglobal fmtduration\ndefault rel\n\nextern calloc, sprintf, strcat\n\n%macro fill_buf 1\n  test edx, edx\n  jz %%skip\n  lea rdi, [buf]\n  mov esi, [rsp+4]\n  mov rdi, [rdi+rsi*8+8]\n  lea rsi, [%1]\n  lea rax, [str.singular]\n  lea rcx, [str.plural]\n  cmp edx, 1\n  cmove rcx, rax\n  xor eax, eax\n  call sprintf\n  add dword [rsp+4], 2\n%%skip:\n%endmacro\n\n; <--- [byte RAX] fmtduration(EDI n) --->\nfmtduration:\n  sub rsp, 24\n  mov [rsp], edi\n  mov dword [rsp+4], 0\n  \n  mov rdi, 64\n  mov rsi, 1\n  call calloc\n  test rax, rax\n  jz .bailout\n  mov [rsp+8], rax\n  \n  mov eax, [rsp]\n  xor edx, edx\n  mov ecx, 60\n  div ecx\n  mov [rsp], eax\n  fill_buf str.second\n  \n  mov eax, [rsp]\n  xor edx, edx\n  mov ecx, 60\n  div ecx\n  mov [rsp], eax\n  fill_buf str.minute\n\n  mov eax, [rsp]\n  xor edx, edx\n  mov ecx, 24\n  div ecx\n  mov [rsp], eax\n  fill_buf str.hour\n  \n  mov eax, [rsp]\n  xor edx, edx\n  mov ecx, 365\n  div ecx\n  mov [rsp], eax\n  fill_buf str.day\n  \n  mov edx, [rsp]\n  fill_buf str.year\n  \n  cmp dword [rsp+4], 0\n  jnz .loop\n  lea rdi, [buf.b0]\n  mov dword [rdi], \"now\"\n  mov dword [rsp+4], 2\n  \n.loop:\n  mov rdi, [rsp+8]\n  lea rsi, [buf]\n  mov ecx, [rsp+4]\n  mov rsi, [rsi+rcx*8-8]\n  call strcat\n  dec dword [rsp+4]\n  jnz .loop\n  \n  mov rax, [rsp+8]\n.bailout:\n  add rsp, 24\n  ret\n; -----> endof fmtduration <-----\n\n\nsection .rodata\n\nstr:\n.year:\n  db \"%d year%s\", 0\n.day:\n  db \"%d day%s\", 0\n.hour:\n  db \"%d hour%s\", 0\n.minute:\n  db \"%d minute%s\", 0\n.second:\n  db \"%d second%\"\n.plural:\n  db \"s\"\n.singular:\n  db 0\n.now:\n  db \"now\", 0\n.comma:\n  db \", \", 0\n.and:\n  db \" and \", 0\n  \n  align 16\nbuf:\n  dq str.singular, .b0, str.and, .b1, str.comma, .b2, str.comma, .b3, str.comma, .b4\n\nsection .bss\n.b0: resb 32\n.b1: resb 32\n.b2: resb 32\n.b3: resb 32\n.b4: resb 32\n\n%endif\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211951,"user_id":173,"body":"%ifndef FMTDURATION_ASM\n%define FMTDURATION_ASM\n\n%define ysec    31536000\n%define daysec  86400\n%define hoursec 3600\n\nextern strdup, malloc, sprintf, printf\n\nglobal fmtduration\nsection .data\ns_now: db \"now\", 0\ns_fmt: db \"nz %d\", 10, 0\ns_fmt_int: db \"%d\", 0\ns_fmt_year: db \" year\", 0\ns_fmt_day: db \" day\", 0\ns_fmt_hour: db \" hour\", 0\ns_fmt_minute: db \" minute\", 0\ns_fmt_second: db \" second\", 0\ns_fmt_comma: db \", \", 0\ns_fmt_and: db \" and \", 0\n\nsection .bss\nresults: resw 5\nstr: resb 100\nnonzeros: resb 1\ncommas: resb 1\nands: resb 1\n\nsection .text\n; <--- [byte RAX] fmtduration(EDI n) --->\nfmtduration:\n    push rbp\n    mov rbp, rsp\n    and rsp, -16\n\n    lea r13, [rel results]\n    mov r12, rdi\n    \n    mov rdi, 1024\n    call malloc\n    mov r14, rax\n    \n    cmp r12, 0\n    jne l_y\n    lea rdi, [rel s_now]\n    call strdup\n    jmp l_exit\n    \nl_y:\n    ; compute years\n    mov rdx, 0\n    mov rax, r12\n    mov rcx, ysec\n    div rcx\n    mov dword [r13], eax\n    add r13, 4\n    \n    mov rax, rdx\n    mov rdx, 0\n    ; compute days\n    mov rcx, daysec\n    div rcx\n    mov dword [r13], eax\n    add r13, 4\n    \n    mov rax, rdx\n    mov rdx, 0\n    ; compute hours\n    mov rcx, hoursec\n    div rcx\n    mov dword [r13], eax\n    add r13, 4\n    \n    mov rax, rdx\n    mov rdx, 0\n    ; compute minutes\n    mov rcx, 60\n    div rcx\n    mov dword [r13], eax\n    add r13, 4\n    \n    ; seconds\n    mov dword [r13], edx\n    \n    ; count non zeros in rdi\n    mov rdi, 0\n    mov rax, 0\n    mov rcx, 0\n    lea rdx, [rel results]\nl_cnz:\n    mov esi, dword [rdx]\n    cmp esi, 0\n    setne al\n    add rdi, rax\n    add rdx, 4\n    add rcx, 4\n    cmp rcx, 16\n    jbe l_cnz\n    \n\n    ; non zeros\n    lea rsi, [rel nonzeros]\n    mov byte [rsi], dil\n    ; if more than one non zero, ands is one\n    lea rsi, [rel ands]\n    cmp dil, 1\n    setg al\n    mov byte [rsi], al\n    ; commas\n    lea rsi, [rel commas]\n    dec dil\n    dec dil\n    mov byte [rsi], dil\n\nl_1:\n    mov r15, r14\n\n    ; print years\n    mov rdi, r15\n    lea rsi, [rel s_fmt_int]\n    lea r13, [rel results]\n    mov r13d, dword [r13]\n    cmp r13d, 0\n    mov rdx, r13\n    je l_y_no_ands\n    call sprintf\n\n    \n    ; year unit\n    add r15, rax\n    mov rdi, r15\n    lea rsi, [rel s_fmt_year]\n    call sprintf\n    \n    ; plural\n    add r15, rax\n    cmp r13d, 1\n    je l_y_singular\n    mov byte [r15], 's'\n    inc r15\nl_y_singular:\n\n    ; comma\n    lea rsi, [rel commas]\n    cmp byte [rsi], 0\n    jbe l_y_no_comma\n    mov rdi, r15\n    lea rsi, [rel s_fmt_comma]\n    call sprintf\n    add r15, rax\n    ; decrement comma\n    lea rsi, [rel commas]\n    mov al, byte [rsi]\n    dec al\n    mov byte [rsi], al\n    jmp l_y_no_ands\nl_y_no_comma:\n\n    ; and\n    lea rsi, [rel ands]\n    cmp dword [rsi], 0\n    jbe l_y_no_ands\n    mov rdi, r15\n    lea rsi, [rel s_fmt_and]\n    call sprintf\n    lea rsi, [rel ands]\n    mov byte [rsi], 0 ; mark and used\n    add r15, rax\nl_y_no_ands:\n\n    ; print days\n    mov rdi, r15\n    lea rsi, [rel s_fmt_int]\n    lea r13, [rel results]\n    add r13, 4\n    mov r13d, dword [r13]\n    cmp r13d, 0\n    mov rdx, r13\n    je l_d_no_ands\n    call sprintf\n        \n    ; day unit\n    add r15, rax\n    mov rdi, r15\n    lea rsi, [rel s_fmt_day]\n    call sprintf\n    \n    ; plural\n    add r15, rax\n    cmp r13d, 1\n    je l_d_singular\n    mov byte [r15], 's'\n    inc r15\nl_d_singular:\n\n    ; comma\n    lea rsi, [rel commas]\n    cmp byte [rsi], 0\n    jbe l_d_no_comma\n    mov rdi, r15\n    lea rsi, [rel s_fmt_comma]\n    call sprintf\n    add r15, rax\n    ; decrement comma\n    lea rsi, [rel commas]\n    mov al, byte [rsi]\n    dec al\n    mov byte [rsi], al\n    jmp l_d_no_ands\nl_d_no_comma:\n\n    ; and\n    lea rsi, [rel ands]\n    cmp dword [rsi], 0\n    jbe l_d_no_ands\n    mov rdi, r15\n    lea rsi, [rel s_fmt_and]\n    call sprintf\n    lea rsi, [rel ands]\n    mov byte [rsi], 0 ; mark and used\n    add r15, rax\nl_d_no_ands:\n\n\n    ; print hours\n    mov rdi, r15\n    lea rsi, [rel s_fmt_int]\n    lea r13, [rel results]\n    add r13, 8\n    mov r13d, dword [r13]\n    cmp r13d, 0\n    mov rdx, r13\n    je l_h_no_ands\n    call sprintf\n    \n    ; hour unit\n    add r15, rax\n    mov rdi, r15\n    lea rsi, [rel s_fmt_hour]\n    call sprintf\n    \n    ; plural\n    add r15, rax\n    cmp r13d, 1\n    je l_h_singular\n    mov byte [r15], 's'\n    inc r15\nl_h_singular:\n\n    ; comma\n    lea rsi, [rel commas]\n    cmp byte [rsi], 0\n    jle l_h_no_comma\n    mov rdi, r15\n    lea rsi, [rel s_fmt_comma]\n    call sprintf\n    add r15, rax\n    ; decrement comma\n    lea rsi, [rel commas]\n    mov al, byte [rsi]\n    dec al\n    mov byte [rsi], al\n    jmp l_h_no_ands\nl_h_no_comma:\n\n    ; and\n    lea rsi, [rel ands]\n    cmp byte [rsi], 0\n    je l_h_no_ands\n    mov rdi, r15\n    lea rsi, [rel s_fmt_and]\n    call sprintf\n    lea rsi, [rel ands]\n    mov byte [rsi], 0 ; mark and used\n    add r15, rax\nl_h_no_ands:\n\n    ; print minutes\n    mov rdi, r15\n    lea rsi, [rel s_fmt_int]\n    lea r13, [rel results]\n    add r13, 12\n    mov r13d, dword [r13]\n    cmp r13d, 0\n    mov rdx, r13\n    je l_m_no_ands\n    call sprintf\n    \n    ; minute unit\n    add r15, rax\n    mov rdi, r15\n    lea rsi, [rel s_fmt_minute]\n    call sprintf\n    \n    ; plural\n    add r15, rax\n    cmp r13d, 1\n    je l_m_singular\n    mov byte [r15], 's'\n    inc r15\nl_m_singular:\n\n    ; comma\n    lea rsi, [rel commas]\n    cmp byte [rsi], 0\n    jle l_m_no_comma\n    mov rdi, r15\n    lea rsi, [rel s_fmt_comma]\n    call sprintf\n    add r15, rax\n    ; decrement comma\n    lea rsi, [rel commas]\n    mov al, byte [rsi]\n    dec al\n    mov byte [rsi], al\n    jmp l_m_no_ands\nl_m_no_comma:\n\n    ; and\n    lea rsi, [rel ands]\n    cmp byte [rsi], 0\n    je l_m_no_ands\n    mov rdi, r15\n    lea rsi, [rel s_fmt_and]\n    call sprintf\n    lea rsi, [rel ands]\n    mov byte [rsi], 0 ; mark and used\n    add r15, rax\nl_m_no_ands:\n\n    ; print seconds\n    mov rdi, r15\n    lea rsi, [rel s_fmt_int]\n    lea r13, [rel results]\n    add r13, 16\n    mov r13d, dword [r13]\n    cmp r13d, 0\n    mov rdx, r13\n    je l_s_singular\n    call sprintf\n    \n    ; second unit\n    add r15, rax\n    mov rdi, r15\n    lea rsi, [rel s_fmt_second]\n    call sprintf\n    \n    ; plural\n    add r15, rax\n    cmp r13d, 1\n    je l_s_singular\n    mov byte [r15], 's'\n    inc r15\nl_s_singular:\n\n    mov byte [r15], 0\n\n\n    ; ret\n    mov rax, r14\nl_exit:    \n    mov rsp, rbp\n    pop rbp\n\n    ret\n    \n\n    \n; -----> endof fmtduration <-----\n\n%endif","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211952,"user_id":null,"body":"%ifndef FMTDURATION_ASM\n%define FMTDURATION_ASM\n\nglobal  fmtduration\nextern  malloc\n\n; <--- [byte RAX] fmtduration(EDI n) --->\nfmtduration:\n\n    ;allocate memory for new string\n    xor   rcx,rcx\n    mov   ecx,edi\n    push  rcx\n    mov   rdi,1024\n    call  malloc \n    pop   rcx\n    push  rax\n    mov   rdi,rax\n\n    ;check for zero and UINT_MAX\n    cmp   ecx,0\n    jg    .write\n    cmp   ecx,0xffffffff\n    je    .write\n    mov   rsi,str_now\n    call  write_str\n    jmp   .end\n\n.write:\n    mov   edx,ecx\n    xor   cl,cl\n    mov   ebx,60*60*24*365\n    mov   rsi,str_year\n    call  write_comp\n    mov   ebx,60*60*24\n    mov   rsi,str_day\n    call  write_comp\n    mov   ebx,60*60\n    mov   rsi,str_hour\n    call  write_comp\n    mov   ebx,60\n    mov   rsi,str_minute\n    call  write_comp\n    mov   ebx,1\n    mov   rsi,str_second\n    call  write_comp\n.end:\n    mov   byte[rdi],0\n    pop   rax\n    ret\n\n;ebx = seconds per unit\n;rsi = unit string\nwrite_comp:\n    cmp   edx,0\n    je    .end\n    mov   eax,edx\n    xor   edx,edx\n    div   ebx\n    cmp   eax,0\n    je    .end\n    call  write_sep\n    call  to_dec\n    call  write_units\n.end:\n    ret\n\n;rsi = source string\nwrite_str:\n    push  rsi\n    push  rax\n.loop:\n    lodsb\n    cmp   al,0\n    je    .end\n    stosb\n    jmp   .loop\n.end:\n    pop   rax\n    pop   rsi\n    ret\n\n;eax = non 1 for adding a final 's'\nwrite_units:\n    call  write_str\n    cmp   eax,1\n    je    .end\n    mov   byte[rdi],'s'\n    inc   rdi\n.end:\n    ret\n\n;cl = 0 -> skip separator\n;edx = 0 -> \" and \", other value -> \", \"\nwrite_sep:\n    push  rsi\n    cmp   cl,0\n    je    .end\n    cmp   edx,0\n    je    .and\n.comma:\n    mov   byte[rdi],','\n    inc   rdi\n    jmp   .space\n.and:\n    mov   rsi,str_and\n    call  write_str\n.space:\n    mov   byte[rdi],' '\n    inc   rdi\n.end:\n    pop   rsi\n    ret\n\n;rax = number to convert\n;output decimal ascii to rdi and increment it\n;cl is set to 1\nto_dec:\n    push  rax\n    push  rbx\n    push  rdx\n    cmp   eax,100\n    jge   .hundreds\n    cmp   eax,10\n    jge   .tens\n    jmp   .units\n.hundreds:\n    xor   edx,edx\n    mov   ebx,100\n    div   ebx\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n    mov   eax,edx\n.tens:\n    xor   edx,edx\n    mov   ebx,10\n    div   ebx\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n    mov   eax,edx\n.units:\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n    mov   cl,1\n    pop   rdx\n    pop   rbx\n    pop   rax\n    ret\n\nstr_now:\n    db  'now',0\nstr_year:\n    db  ' year',0\nstr_day:\n    db  ' day',0\nstr_hour:\n    db  ' hour',0\nstr_minute:\n    db  ' minute',0\nstr_second:\n    db  ' second',0\nstr_and:\n    db  ' and',0\n\n\n; -----> endof fmtduration <-----\n\n%endif","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211953,"user_id":null,"body":"segment .text\nglobal fmtduration\nextern sprintf, printf, malloc\n;[rbp + 40 - counter for printable items, to keep track of ',' + 'and']\n;[rbp + 36 - current print pointer, for sprintf]\n;[rbp + 32 - years ]\n;[rbp + 28 - days]\n;[rbp + 24 - hour]\n;[rbp + 20 - minute]\n;[rbp + 16 - seconds]\n;[rbp + 8 - pointer to memoryblock for string]\n;[rbp + number of seconds]\n\nfmtduration:  push rbp\n              sub rsp, @stack_size\n              mov rbp,rsp\n              mov [rbp],rdi\n              mov rdi,100\n              call malloc\n              mov [rbp + 8],rax\n              mov [rbp + 36],rax\n              cmp qword [rbp],0\n              \n              jne .notnow\n              \n              mov rdi,rax              ; Zero seconds - return \"now\"\n              lea rsi,[@now]\n              sub rsp,8\n              call sprintf\n              mov rax,[rbp + 8]\n              add rsp, @stack_size + 8\n              pop rbp\n              ret\n\n.notnow       lea rdi,[@minute]\n              mov r8d,4\n              mov rax,[rbp]\n              xor cx,cx\n              \n.calc_l       xor edx,edx\n              div dword [rdi + r8 * 4 - 4]\n              mov [rbp + r8 * 4 + 16],eax\n              test eax,eax                  ; If value not zero, it's supposed to be printed\n              setnz cl \n              add ch,cl                    ; ch keeps # of printable items\n              mov eax,edx\n              dec r8d\n              jnz .calc_l\n              mov [rbp + 16],edx\n              test edx,edx  \n              setnz cl\n              add ch,cl\n              dec ch\n              movzx ecx,ch\n              mov [rbp + 44],ecx\n              \n.print        mov edx,[rbp + 32]\n              lea rsi,[@s_year]\n              call .p_item\n\n.p_days       mov edx,[rbp + 28]\n              lea rsi,[@s_day]\n              call .p_item\n\n.p_hours      mov edx,[rbp + 24]\n              lea rsi,[@s_hour]\n              call .p_item\n              \n.p_minutes    mov edx,[rbp + 20]\n              lea rsi,[@s_minute]\n              call .p_item\n              \n.p_seconds    mov edx,[rbp + 16]\n              lea rsi,[@s_second]\n              call .p_item\n\n.done         mov eax,[rbp + 36]\n              mov byte [eax - 1],0\n              mov eax,[rbp + 8]\n              add rsp,@stack_size\n              pop rbp\n              ret\n              \n.p_item       test edx,edx          ; If zero units, nothing to print\n              jz .p_done\n              lea rcx,[@s_s]\n              lea r8,[@s_e]\n              cmp edx,1\n              cmove rcx,r8          ; If 1 unit, do not add plural s\n              mov rdi,[rbp + 36]\n              call sprintf\n              add [rbp + 36],eax    ; Update pointer with characters written\n              dec dword [rbp + 44]\n              jnz .p_not_comma      ; If second last item, seperate items with 'and'\n              mov rdi,[rbp + 36]\n              lea rsi,[@s_and]\n              call sprintf\n              add [rbp + 36],eax\n              ret\n.p_not_comma  cmp dword [rbp + 44],1\n              jl .p_done\n              dec dword [rbp + 36]\n              mov rdi,[rbp + 36]\n              lea rsi,[@s_comma]\n              call sprintf\n              add [rbp + 36],eax\n.p_done       ret\n          \nsegment .data\n@stack_size equ 56\n@minute_v equ 60\n@hour_v equ @minute_v * 60\n@day_v equ @hour_v * 24\n@year_v equ @day_v * 365\n\n@now  db 'now', 0\n\n@minute dd @minute_v\n@hour dd @hour_v\n@day dd @day_v\n@year dd @year_v\n\n@s_year db '%u year%s',0\n@s_day db '%u day%s',0\n@s_hour db '%u hour%s',0\n@s_minute db '%u minute%s',0\n@s_second db '%u second%s',0\n@s_s  db 's ',0\n@s_e  db ' ',0\n@s_and db 'and ',0\n@s_comma db ', ',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5274e122fc75c0943d000148":[{"id":211954,"user_id":null,"body":"global group_by_commas\nextern malloc\n\nsection .text\n\ngroup_by_commas:\n    push rdi\n    \n    mov edi, 14\n    call malloc\n    mov rcx, rax\n    mov rdi, rax\n    add rcx, 13\n    mov byte[rcx], 0\n    \n    pop rax\n    mov ebx, 10\n    xor rsi, rsi\n\n    loop:\n      dec rcx\n      xor edx, edx\n      div ebx\n      add dl, '0'\n      mov byte[rcx], dl\n      cmp eax, 0\n      je loop_end\n      inc rsi\n      cmp rsi, 3\n      jne loop\n      xor rsi, rsi\n      dec rcx\n      mov byte[rcx], ','\n      jmp loop\n      \n    loop_end:\n    \n    mov rax, rdi\n    \n    rloop:\n      mov bl, byte[rcx]\n      mov byte[rax], bl\n      inc rax\n      inc rcx\n      cmp bl, 0\n      jne rloop\n    \n    mov rax, rdi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211955,"user_id":null,"body":"global group_by_commas\nextern strdup\n\n; <-- [byte RAX] group_by_commas(EDI n) -->\ngroup_by_commas:\n  sub rsp, 24\n  mov byte [rsp + 23], 0\n  mov rcx, 12\n  mov rsi, 10\n  mov r8, 100\n  mov r9d, 1000\n.loop\n  mov eax, edi\n  xor edx, edx\n  div esi\n  or dl, 48\n  cmp edi, 10\n  mov [rsp + rcx + 10], dl\n  jb .done\n  xor edx, edx\n  div esi\n  or dl, 48\n  cmp edi, 100\n  mov [rsp + rcx + 9], dl\n  jb .endtens\n  mov eax, edi\n  xor edx, edx\n  div r8d\n  xor edx, edx\n  div esi\n  or dl, 48\n  cmp edi, 1000\n  mov [rsp + rcx + 8], dl\n  jb .endhundreds\n  mov eax, edi\n  xor edx, edx\n  div r9d\n  mov byte [rsp + rcx + 7], 44\n  add rcx, -4\n  mov edi, eax\n  jmp .loop\n.endtens:\n  dec rcx\n  jmp .done\n.endhundreds:\n  add rcx, -2\n.done:\n  lea rdi, [rsp + rcx + 10]\n  call strdup\n  add rsp, 24\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211956,"user_id":460,"body":"extern malloc\nextern log10\nsection .text\nglobal group_by_commas\ngroup_by_commas:\npush rbp\nmov rbp, rsp\n  ; get digits count by log10(n)+1\n  push rdi ; save initial number on stack\n  cvtsi2sd xmm0, rdi\n  call log10\n  cvttsd2si eax, xmm0\n  mov edi, eax\n  \n  ; calculating array size:\n  ; rdi == digits_count\n  inc rdi\n  ; for commas: + (digits_count-1) \/ 3\n  mov rax, rdi\n  dec rax\n  xor rdx, rdx\n  mov rcx, 3\n  div rcx\n  add rdi, rax\n  ; for \\0: + 1\n  inc rdi\n  \n  ; allocate digits_count + (digits_count-1) \/ 3 + 1\n  push rdi\n  call malloc\n  pop rdi\n  mov r8, rax\n\n  pop rax ; pop initial number into rax\n  dec rdi\n  mov byte [r8+rdi], 0 ; set \\0 in last position\n  mov rcx, 4 ; counter for commas\n  mov rsi, 10\n  .loop:\n      dec rcx\n      jnz .no_comma ; paste comma every 3 digits\n          mov rcx, 3\n          dec rdi\n          mov byte [r8+rdi], ','\n      .no_comma:\n\n      dec rdi ; move to next element (from right to left)\n      xor rdx, rdx\n      div rsi ; rdx will have modulo of division by 10 (last digit)\n      add dl, 48 ; convert number to ASCII code\n      mov [r8+rdi], dl ; set ASCII code to element \n      cmp rdi, 0\n  jne .loop\n  mov rax, r8\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211957,"user_id":460,"body":"extern malloc\nextern log10\nsection .text\nglobal group_by_commas\ngroup_by_commas:\npush rbp\nmov rbp, rsp\n  ; get digits count by log10(n)+1\n  push rdi ; save initial number on stack\n  cvtsi2sd xmm0, rdi\n  call log10\n  cvttsd2si eax, xmm0\n  mov edi, eax\n  ; calculating array size:\n  ; rdi == digits_count\n  inc rdi\n  ; for commas: + (digits_count-1) \/ 3\n  mov rax, rdi\n  dec rax\n  xor rdx, rdx\n  mov rcx, 3\n  div rcx\n  add rdi, rax\n  ; for \\0: + 1\n  inc rdi\n  ; allocate digits_count + (digits_count-1) \/ 3 + 1\n  push rdi\n  call malloc\n.after_m:\n  pop rdi\n  mov r8, rax\n  pop rax ; pop initial number into rax\n  dec rdi\n  mov byte [r8+rdi], 0 ; set \\0\n  mov rcx, 4\n  mov rsi, 10\n  .loop:\n    ; paste comma every 3 digits\n    dec rcx\n    jnz .no_comma\n\t  mov rcx, 3\n      dec rdi\n      mov byte [r8+rdi], ','\n    .no_comma:\n    dec rdi\n    xor rdx, rdx\n    div rsi\n    add dl, 48 ; convert number to ASCII code\n    mov [r8+rdi], dl\n    cmp rdi, 0\n  jne .loop\n  mov rax, r8\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211958,"user_id":null,"body":"extern malloc\nsection .text\nglobal group_by_commas\n\ngroup_by_commas:\n    mov rax, rdi\n    mov rsi, 10\n    xor rcx, rcx\n.count_digits:\n    xor rdx, rdx\n    div rsi\n    mov byte [grouped + rcx], dl\n    add byte [grouped + rcx], '0'\n    inc rcx\n    cmp rax, 0\n    jnz group_by_commas.count_digits\n\n    ; calculate #commas\n    xor r9, r9\n    xor rdx, rdx\n    mov rax, rcx\n    mov rsi, 3\n    div rsi\n    cmp rdx, 0\n    jne group_by_commas.next\n    dec rax\n.next:\n    mov r10, rcx ; rcx->#digits\n    mov rdi, rax ; rax->#commas\n    add rdi, rcx ; rax+rcx->final string digits\n\n    push rdi\n    push rcx\n    push r10\n    mov rdi, rdi\n    inc rdi\n    call malloc\n    mov r8, rax\n    pop r10\n    pop rcx\n    pop rdi\n    mov byte [r8 + rdi], 0\n\n    mov r9, -1\n    dec r10\n    xor rsi, rsi\n.to_str_loop:\n    inc r9\n    inc rsi\n    dec rdi\n    mov al, byte [grouped + r9]\n    mov byte [r8 + rdi], al\n    cmp rsi, 3\n    je group_by_commas.add_comma\n    cmp r9, r10\n    jne group_by_commas.to_str_loop\n    jmp group_by_commas.end\n.add_comma:\n    xor rsi, rsi\n    dec rdi\n    cmp rdi, 0\n    jl group_by_commas.end\n    mov byte [r8 + rdi], ','\n    jmp group_by_commas.to_str_loop\n\n.end:\n    mov rax, r8\n    ret\n\nsection .bss\ngrouped: resb 27\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211959,"user_id":null,"body":"global group_by_commas\nextern malloc\n\n; <-- [byte RAX] group_by_commas(EDI n) -->\ngroup_by_commas:\n    push    rdi\n    mov     rdi, 14\n    call    malloc WRT ..plt\n    pop     rdi\n    xor     rdx, rdx\n    xor     rcx, rcx\n    xor     r8, r8\n\nloop:\n    cmp     edi, 10\n    jnb     cont\n    mov     edx, 0\n    jmp     put_remainder\ncont:\n    mov     edx, edi\n;division by 10; input in edx, output in esi\n    movsx   rsi, edx\n    imul    rsi, rsi, 1717986919\n    sar     rsi, 34\n    sar     edx, 31\n    sub     esi, edx\n;store in edx as tmp\n    mov     edx, esi\n;mul by 10 to get\n    lea     esi, [rdx + rdx * 8]\n    add     esi, edx\n    sub     edi, esi\n;edi has remainder\nput_remainder:\n    add     edi, '0'\n    mov     byte [rax + rcx], dil\n    inc     rcx\n    inc     r8\n\n    mov     edi, edx\n    cmp     edx, 0\n    jz      reverse\n\n    cmp     r8, 3\n    jz      put_comma\n    jmp     loop\n\nput_comma:\n    mov     byte [rax + rcx],  ','\n    inc     rcx\n    xor     r8, r8\n    jmp     loop\n\nreverse:\n    mov     byte [rax + rcx], 0\n    lea     rdi, [rax + rcx]\n    dec     rdi\n    mov     rdx, rax\n\nrev_loop:\n    cmp     rdx, rdi\n    jg      end\n    mov     cl, byte [rdx]\n    mov     ch, byte [rdi]\n    mov     byte [rdi], cl\n    mov     byte [rdx], ch\n    inc     rdx\n    dec     rdi\n    jmp     rev_loop\nend:\n    ret\n; -----> endof group_by_commas <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211960,"user_id":null,"body":"global group_by_commas\nextern malloc, strcpy, free\n; <-- [byte RAX] group_by_commas(EDI n) -->\ngroup_by_commas:\n    push rbp ; use callee saved registers to reduce push\/pop instructions\n    push r12\n    push rbx\n    mov rbx, 1 ; rbx will hold the len of the string, incl null term\n    push rdi\n    mov rdi, 100\n    call malloc\n    mov rbp, rax ; rbp will hold the base buffer ptr\n    pop rax      ; put the number in rax\n    mov r12, 99  ; r12 will hold the index\n    mov [rbp+r12], BYTE 0 ;store null terminator\n    dec r12\n    mov rcx, 10\n    xor r8, r8 ; r8 will have the comma counter\nl1:\n   ; start at the end and go backwards\n    cmp r8, 3\n    jb no_comma\n    xor r8, r8 ; zero r8 again\n    mov [rbp+r12], BYTE ','\n    dec r12\nno_comma:\n    xor edx, edx ; zero the remainder register\n    div ecx\n    add edx, '0'\n    mov [rbp+r12], dl\n    dec r12\n    inc r8\n    inc rbx\n    test eax, eax\n    jz exit_l1\n    jmp l1\nexit_l1:\n    mov rdi, rbx\n    inc r12 ; increment r12 to put it back at the start of the string\n    call malloc\n    mov rdi, rax\n    lea rsi, [rbp+r12]\n    call strcpy\n    mov rbx, rax\n    mov rdi, rbp\n    call free\n    mov rax, rbx\n    pop rbx\n    pop r12\n    pop rbp\n    ret\n; -----> endof group_by_commas <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211961,"user_id":null,"body":"section .text\nglobal group_by_commas\n\nextern malloc\n\n;\n; WARNING: the code that follows will make you cry; a safety pig is provided below for your benefit.\n; \n;                          _\n;  _._ _..._ .-',     _.._(`))\n; '-. `     '  \/-._.-'    ',\/\n;    )         \\            '.\n;   \/ _    _    |             \\\n;  |  a    a    \/              |\n;  \\   .-.                     ;  \n;   '-('' ).-'       ,'       ;\n;      '-;           |      .'\n;         \\           \\    \/\n;         | 7  .__  _.-\\   \\\n;         | |  |  ``\/  \/`  \/\n;        \/,_|  |   \/,_\/   \/\n;           \/,_\/      '`-'\n;\n\n; <-- [byte RAX] group_by_commas(EDI n) -->\ngroup_by_commas:\n    xor eax, eax    ; RAX <- the result\n    call _int_len\n    \n    push rdi\n    xor rdi, rdi\n    mov edi, eax\n    mov r8, rdi ; r8 - number \"length\"\n    xor rdx, rdx\n    mov ebx, 3\n    div ebx\n    add edi, eax\n    cmp edx, 0\n    jne .allocate\n    dec edi\n    \n    .allocate:\n    mov r9, rdi ; r9 - total string length\n    call malloc\n    pop rdi ; edi - number\n    \n    xor ecx, ecx\n    mov r11, rax ; r11 - return value\n    mov eax, edi\n    mov byte [r11 + r9], 0\n    .loop:\n      dec r9\n      \n      cmp ecx, 3\n      je .add_comma\n      \n      xor edx, edx\n      mov ebx, 10\n      div ebx\n      add edx, '0'\n      mov byte [r11 + r9], dl\n      inc ecx\n      cmp r9, 0\n      jne .loop\n      jmp .end\n      .add_comma:\n        mov ecx, 0\n        mov byte[r11 + r9], ','\n      cmp r9, 0\n      jne .loop\n    .end:\n    mov rax, r11\n    ret\n; -----> endof group_by_commas <-----\n\n_int_len:\n  mov eax, edi\n  mov ebx, 10\n  xor ecx, ecx\n.int_len_loop:\n  inc ecx\n  xor edx, edx\n  div ebx\n  cmp eax, 0\n  jne .int_len_loop\n  mov eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211962,"user_id":168,"body":"global group_by_commas\nextern strdup\n\nsection .data\nbuffer times 15 db 0\n\nsection .text\n\n; <-- [byte RAX] group_by_commas(EDI n) -->\ngroup_by_commas:\n  mov eax, edi\n  mov esi, 10\n  mov rdi, buffer + 14\n  mov ecx, 3\n  xor edx, edx\n.loop:\n  dec rdi\n  mov dl, ','\n  mov byte [rdi], dl\n  test ecx, ecx\n  setz dl\n  sub rdi, rdx\n  lea edx, [3 * rdx]\n  add ecx, edx\n  xor edx, edx\n  div esi\n  add edx, '0'\n  mov byte [rdi], dl\n  dec ecx\n  test eax, eax\n  jnz .loop\n  jmp strdup\n; -----> endof group_by_commas <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211963,"user_id":null,"body":"global group_by_commas\nextern strdup\n\n; <-- [byte RAX] group_by_commas(EDI n) -->\ngroup_by_commas:\n    sub rsp, 0h18           ; allocating local storage for <r> and aligning the stack\n    mov ecx, 0h0E           ; setting ECX as <inx>\n    mov byte [rsp+rcx], 0   ; terminating <r>\n    mov eax, 0h0A           ; will be used to get rid of a digit\n    xchg eax, edi           ; exchanging <n> to EAX and ten to EDI\n    mov esi, 4              ; setting ESI to four as <i>\n.loop:\n    dec esi                 ; decrementing <i>\n    jg .set                 ; jumping to the .set label if <i> is greater than zero\n    mov esi, 3              ; setting <i> to three\n    mov dl, [.comma]        ; copying <.comma> to DL\n    dec ecx                 ; decrementing <inx>\n    mov [rsp+rcx], dl       ; copying <.comma> to <*(r+inx)>\n.set:\n    xor edx, edx            ; resetting EDX before division\n    div edi                 ; geting rid of the rightmost digit\n    add edx, '0'            ; converting the digit to the ASCII representation\n    dec ecx                 ; descrementing <inx>\n    mov [rsp+rcx], dl       ; copying the digit to <*(r+inx)>\n    test eax, eax           ; whether <n> is not zero\n    jne .loop               ; jumping to the next iteration\n    lea rdi, [rsp+rcx]      ; pointing RDI to <r>\n    call strdup             ; allocating memory and copying <r>\n    add rsp, 0h18           ; destroying the local storage and restoring the stack boundary\n    ret\n.comma:\n    db    ','\n; -----> endof group_by_commas <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52774a314c2333f0a7000688":[{"id":211964,"user_id":null,"body":"global valid_parentheses\n\nsection .text\n\n; <--- bool valid_parentheses(const char *s) --->\nvalid_parentheses:\n    xor ecx, ecx    ; resetting RCX as <cnt>\n    dec rdi         ; pointing <s> one character back\n.loop:\n    inc rdi         ; pointing <s> to the next character\n    mov dl, [rdi]   ; copying <*s> to DL as <c>\n    test dl, dl     ; whether <c> is an empty character\n    je .exit        ; jumping to exit\n    cmp dl, ')'     ; whether <c> is the closing bracket\n    je .close       ; jumping to the .close label\n    cmp dl, '('     ; whether <c> is the opening bracket\n    jne .loop       ; otherwise, jumping to the next iteration\n    inc rcx         ; incrementing <cnt>\n    jmp .loop       ; jumping to the next iteration\n.close:\n    dec rcx         ; decrementing <cnt>\n    jge .loop       ; jumping to the next iteration if <cnt> is not negative\n.exit:\n    test rcx, rcx   ; whether <cnt> is zero\n    sete al         ; otherwise, setting the result to false\n    ret\n; ---------> endof parenthesize <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211965,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\nvalid_parentheses:  xor rbx, rbx\n                    xor rax, rax\n.loop:              cmp byte [rdi], 0\n                    je .endloop\n                    cmp byte [rdi], '('\n                    jne .cmp2\n                    inc rbx\n                    jmp .endcmp\n.cmp2:              cmp byte [rdi], ')'\n                    jne .endcmp\n                    dec rbx\n                    cmp rbx, 0\n                    jl .return\n.endcmp:            inc rdi\n                    jmp .loop\n.endloop:           cmp rbx, 0\n                    jne .return\n                    inc rax\n.return:            ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211966,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n  xor rax, rax\n  test rdi, rdi\n  je .end\n.loop:\n  cmp rax, 0\n  jl .invalid\n  mov bl, [rdi]\n  test bl, bl\n  je .end\n  inc rdi\n  cmp bl, 0x28\n  je .left\n  cmp bl, 0x29\n  je .right\n  jmp .loop\n.left:\n  inc rax\n  jmp .loop\n.right:\n  dec rax\n  jmp .loop\n  \n.end:\n  cmp rax, 0\n  jne .invalid\n  mov rax, 1\n  ret\n.invalid:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211967,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n    xor eax, eax\n\n    ; Make sure the input isn't NULL\n    test rdi, rdi\n    jz .end\n\n.loop:\n    mov dl, byte [rdi]\n    inc rdi\n    cmp dl, 0\n    jz .check\n    cmp dl, '('\n    jz .inc\n    cmp dl, ')'\n    jnz .loop\n\n.dec:\n    ; Decrement: Test if eax is 0, fail if so\n    test eax, eax\n    jz .end\n    dec eax\n    jmp .loop\n\n.inc:\n    inc eax\n    jmp .loop\n\n.check:\n    test eax, eax\n    sete al\n.end:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211968,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n  xor ebx, ebx\n  xor edx, edx\n  mov eax, 1      ;assume true to start with\n.loop:\n  mov cl, [rdi]\n  cmp cl, 0\n  je .exit        ; end with zero termination character\n  cmp cl, '('\n  sete dl\n  add ebx, edx    ; inc count if '('\n  cmp cl, ')'\n  sete dl\n  sub ebx, edx    ; dec count if '('\n  js .false       ; fail if closing brackets *ever* outnumber opening brackets\n  inc rdi\n  jmp .loop\n.false:\n  xor eax, eax\n  ret\n.exit:\n  test ebx, ebx\n  jnz .false\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211969,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n    xor   eax, eax\n    dec   rdi\n.loop:\n    inc   rdi\n    mov   dl, [rdi]\n    test  dl, dl\n    jz    .end\n    cmp   dl, '('\n    jne   .l\n    inc   eax\n    jmp   .loop\n.l: cmp   dl, ')'\n    jne   .loop\n    dec   eax\n    jns   .loop\n.end:\n    test  eax,eax\n    setz  al\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211970,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n  xor eax, eax\n  jmp .start\n.open:\n  add eax, 1\n.loop:\n  add rdi, 1\n.start:\n  movzx ecx, byte [rdi]\n  cmp cl, 40\n  je .open\n  cmp cl, 41\n  je .close\n  test cl, cl\n  jne .loop\n  jmp .done\n.close:\n  sub eax, 1\n  jae .loop\n  xor eax, eax\n  ret\n.done:\n  test eax, eax\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211971,"user_id":null,"body":"SECTION .text\n  global valid_parentheses\n\nvalid_parentheses:\n  mov rax,1\n  mov rbx,-1\n  mov rdx,1\n  mov rcx,-1\n  loop1:\n  inc rcx\n  cmp byte[rdi+rcx],0\n  je end\n  \n  cmp byte[rdi+rcx],'('\n  jl loop1\n  cmove r9,rbx\n  \n  cmp byte[rdi+rcx],')'\n  jg loop1\n  cmove r9,rdx\n  \n  add rax,r9\n  cmp rax,1\n  jle loop1\n  \n  mov rax,0\n  jmp broken\n  \n  end:\n  mov rbx,0\n  cmp rax,1\n  cmovl rax,rbx\n  \n  broken:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211972,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n  xor rsi, rsi\n  xor eax, eax\n.loop:\n  mov cl, [rdi]\n  test cl, cl\n  je .term\n  inc rdi\n  cmp cl, '('\n  je .open\n  cmp cl, ')'\n  je .close\n  jmp .loop\n.open:\n  add rsi, 1\n  jc .carry\n  jmp .loop\n.close:\n  sub rsi, 1\n  jc .carry\n  jmp .loop\n.term:\n  test rsi, rsi\n  setz al\n.carry:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211973,"user_id":null,"body":"SECTION .text\nglobal valid_parentheses\n\n; Returns a boolean indicating if the order of parenthesis in the string is valid\n; arg0         = (const char*)\n; return value = (bool) A boolean indicating if the string contains valid parenthesis\nvalid_parentheses:\n  xor rsi, rsi\n  xor eax, eax\n.loop:\n  mov cl, [rdi]\n  test cl, cl\n  je .term\n  inc rdi\n  cmp cl, '('\n  je .open\n  cmp cl, ')'\n  je .close\n  jmp .loop\n.open:\n  add rsi, 1\n  jc .carry\n  jmp .loop\n.close:\n  sub rsi, 1\n  jc .carry\n  jmp .loop\n.term:\n  test rsi, rsi\n  mov esi, 1\n  cmove eax, esi\n.carry:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5287e858c6b5a9678200083c":[{"id":211974,"user_id":168,"body":"global narcissistic\n\nsection .text\n\n; <--- bool narcissistic(long num) --->\nnarcissistic:\n  mov esi, 10\n  mov eax, edi\n  xor ecx, ecx\n.loop1:\n  xor edx, edx\n  div esi\n  push rdx\n  inc ecx\n  test eax, eax\n  jnz .loop1\n  mov esi, ecx  \n.loop2:\n  pop r8\n  mov edx, esi\n  mov eax, 1\n.pow:\n  imul eax, r8d\n  dec edx\n  jnz .pow\n  sub edi, eax\n  dec ecx\n  jnz .loop2\n  test edi, edi\n  setz al\n  ret\n; ---------> endof narcissistic <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211975,"user_id":743,"body":"global narcissistic\n\nsection .rodata\n\nTab dd 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474\n    dd 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315\n    dd 24678050, 24678051, 88593477, 146511208, 472335975, 534494836\n    dd 912985153\n\nsection .text\n\n; eax                   edi\n; bool narcissistic(long num) --->\nnarcissistic:\n  mov eax, edi\n  mov rdi, Tab\n  mov ecx, 32\n  repne scasd\n  jrcxz .false\n  mov eax, 1\n  ret\n.false:\n  xor eax, eax\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211976,"user_id":null,"body":"    section .data\nlog10:  dq  0.3010299957    ; value of 1 \/ log_2(10)\n\n    section .text\n    global narcissistic\nnarcissistic:\n    push rbp\n    mov rbp, rsp\n    sub rsp, 8              ; prologue\n\n    mov r10, 10             ; we're doing calculations in base 10\n    mov r9, 0               ; initialize variable for aggregation\n\n    mov [rsp], rdi          ; prepare input value for FPU\n    fld qword [log10]       ; load 1\/log_2(10) constant\n    fild qword [rsp]        ; load input value into FPU stack\n    fyl2x                   ; calculate input \/ log_2(10)\n    fisttp qword [rsp]      ; return truncated result of previous operation\n    inc qword [rsp]         ; dignum = floor(log_10(n)) + 1\n    mov r11, [rsp]          ; move dignum into register\n    mov [rsp], rdi          ; put input value onto stack\n\n.digit_loop:\n    xor rdx, rdx            ; clear high part of RDX:RAX for division\n    mov rax, rdi            ; load current value into RAX\n    div r10                 ; divide RAX by 10\n    mov rdi, rax            ; save quotient into RDI\n\n    mov r12, rdx            ; save reminder into non-volatile register\n    mov rax, 1              ; prepare variable for multiplication\n    mov rcx, r11            ; put dignum into counter register\n\n.power:\n    mul r12                 ; we're raising reminder to power of the dignum\n    loop .power             ; loop until RCX != 0\n\n    add r9, rax             ; increment overall result by current value\n    test rdi, rdi           ; check if our number == 0\n    jnz .digit_loop         ; if not then loop back to the start of the loop\n    \n    cmp r9, [rsp]           ; compare result of the loop with the input\n    setz al                 ; if is the same then the number is narcissistic\n\n    mov rsp, rbp            ; epilogue\n    pop rbp\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211977,"user_id":null,"body":"global narcissistic\n\nsection .text\n\n; <--- bool narcissistic(long num) --->\nnarcissistic:\n  enter 0, 0\n\n; push each digit\n  mov   ecx, 10\n  mov   eax, edi\n  xor   rdx, rdx\n.l1:\n  cdq\n  div   ecx\n  push  rdx\n  test  eax, eax\n  jne   .l1\n\n; (rbp-rsp)\/8 = number of digits\n  mov   r9, rbp\n  sub   r9, rsp\n  shr   r9d, 3\n  mov   r10d, r9d\n\n; pop digits and add powers\n  mov   r8d, edi\n.l2:\n  pop   rbx\n  mov   eax, 1\n  mov   ecx, r9d\n; calculate power\n.l3:\n  mul   ebx\n  dec   ecx\n  jne   .l3\n\n  sub   r8d, eax\n  dec   r10d\n  jnz   .l2\n\n  xor   eax, eax\n  test  r8d, r8d\n  jnz   .end\n  inc   eax\n  \n.end:\n  leave\n  ret\n; ---------> endof narcissistic <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211978,"user_id":null,"body":"global narcissistic\nextern log10\nsection .text\n\n; <--- bool narcissistic(long num) --->\nnarcissistic:\n  push rbx\n  movsx rbx, edi\n  cvtsi2sd xmm0, ebx\n  call log10\n  mov eax, ebx\n  xor ecx, ecx\n  mov edi, 10\n  cvttsd2si esi, xmm0\n  imul esi, esi, 10\n.loop:\n  test eax, eax\n  je .done\n  cdq\n  idiv edi\n  add edx, esi\n  movsx rdx, edx\n  add rcx, [powtable+rdx*8]\n  jmp .loop\n.done:\n  cmp rbx, rcx\n  pop rbx\n  sete al\n  ret\n\nsection .data\npowtable: dq 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 0, 1, 16, 81, 256, 625, 1296, 2401, 4096, 6561, 0, 1, 32, 243, 1024, 3125, 7776, 16807, 32768, 59049, 0, 1, 64, 729, 4096, 15625, 46656, 117649, 262144, 531441, 0, 1, 128, 2187, 16384, 78125, 279936, 823543, 2097152, 4782969, 0, 1, 256, 6561, 65536, 390625, 1679616, 5764801, 16777216, 43046721, 0, 1, 512, 19683, 262144, 1953125, 10077696, 40353607, 134217728, 387420489, 0, 1, 1024, 59049, 1048576, 9765625, 60466176, 282475249, 1073741824, 3486784401","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211979,"user_id":null,"body":"global narcissistic\n\nsection .data\n\n; https:\/\/oeis.org\/A005188\nlist: dd 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315, 24678050, 24678051, 88593477, 146511208, 472335975, 534494836, 912985153\n.end equ $-list\n\nsection .text\n\nnarcissistic:\n   xor rcx, rcx\n\n.loop_begin:\n   cmp rcx, list.end\n   je .not_found\n\n   mov eax, [list + rcx]\n   cmp edi, eax\n   je .found\n\n   add rcx, 4\n   jmp .loop_begin\n\n.found:\n        mov eax, 1\n        ret\n\n.not_found:             ; returns false\n        xor eax, eax\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211980,"user_id":null,"body":"global narcissistic\n\nsection .text\n\n; <--- bool narcissistic(long num) --->\nnarcissistic:\n    mov   ebx,10\n    cmp   edi,ebx\n    jl    true\n\ncount_digits:\n    mov   eax,edi\n    xor   ecx,ecx\n.loop:\n    xor   edx,edx\n    div   ebx\n    push  rdx       ; save digit\n    inc   ecx\n    cmp   eax,0\n    jne   .loop\n\n    ; ecx = the number of digits\n\n    mov   ebx,ecx\n    xor   esi,esi\nsum:\n    pop   rax       ; fetch digit\n    call  power\n    add   esi,eax\n    loop  sum\n\n    ; esi = sum of the digits, each raised to the power of ecx\n\ncheck:\n    cmp   edi,esi\n    je    true\n    xor   al,al\n    ret\n\ntrue:\n    mov   al,1\n    ret\n\n; eax = base\n; ebx = exponent\n; result in edx:eax\npower:\n    xor   edx,edx\n    push  rcx\n    mov   ecx,ebx\n    dec   ecx\n    push  rbx\n    mov   ebx,eax\n.rep:\n    imul  eax,ebx\n    loop  .rep\n    pop   rbx\n    pop   rcx\n    ret\n    \n; ---------> endof narcissistic <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211981,"user_id":null,"body":"global narcissistic\n\nsection .bss\ndigits: resb 20       ; 2^64 has 20 digits\n\nsection .rodata\npowers: \n      ;   0  1        2           3              4               5                 6                  7                    8                     9\n    dq    1, 1,       1,          1,             1,              1,                1,                 1,                   1,                    1 \n    dq    0, 1,       2,          3,             4,              5,                6,                 7,                   8,                    9 \n    dq    0, 1,       4,          9,            16,             25,               36,                49,                  64,                   81 \n    dq    0, 1,       8,         27,            64,            125,              216,               343,                 512,                  729 \n    dq    0, 1,      16,         81,           256,            625,             1296,              2401,                4096,                 6561 \n    dq    0, 1,      32,        243,          1024,           3125,             7776,             16807,               32768,                59049 \n    dq    0, 1,      64,        729,          4096,          15625,            46656,            117649,              262144,               531441 \n    dq    0, 1,     128,       2187,         16384,          78125,           279936,            823543,             2097152,              4782969 \n    dq    0, 1,     256,       6561,         65536,         390625,          1679616,           5764801,            16777216,             43046721 \n    dq    0, 1,     512,      19683,        262144,        1953125,         10077696,          40353607,           134217728,            387420489 \n    dq    0, 1,    1024,      59049,       1048576,        9765625,         60466176,         282475249,          1073741824,           3486784401 \n    dq    0, 1,    2048,     177147,       4194304,       48828125,        362797056,        1977326743,          8589934592,          31381059609 \n    dq    0, 1,    4096,     531441,      16777216,      244140625,       2176782336,       13841287201,         68719476736,         282429536481 \n    dq    0, 1,    8192,    1594323,      67108864,     1220703125,      13060694016,       96889010407,        549755813888,        2541865828329 \n    dq    0, 1,   16384,    4782969,     268435456,     6103515625,      78364164096,      678223072849,        439804651110,       22876792454961 \n    dq    0, 1,   32768,   14348907,    1073741824,    30517578125,     470184984576,     4747561509943,      35184372088832,      205891132094649 \n    dq    0, 1,   65536,   43046721,    4294967296,   152587890625,    2821109907456,    33232930569601,     281474976710656,     1853020188851841 \n    dq    0, 1,  131072,  129140163,   17179869184,   762939453125,   16926659444736,   232630513987207,    2251799813685248,    16677181699666569 \n    dq    0, 1,  262144,  387420489,   68719476736,  3814697265625,  101559956668416,  1628413597910449,   18014398509481984,   150094635296999121 \n    dq    0, 1,  524288, 1162261467,  274877906944, 19073486328125 , 609359740010496, 11398895185373143,  144115188075855872,  1350851717672992089 \n    dq    0, 1, 1048576, 3486784401, 1099511627776, 95367431640625, 3656158440062976, 79792266297612001, 1152921504606846976, 12157665459056928801\n    \nsection .text\n\n\n; <--- bool narcissistic(long num) --->\nnarcissistic:\n    mov r8,rdi          ; keep a copy of the input\n    mov rax,rdi         ; extract and count the digits\n    mov rdi,digits\n    mov rsi,10\n    xor rcx,rcx\n.digit:\n    xor rdx,rdx\n    div rsi\n    xchg rax,rdx\n    stosb\n    inc rcx\n    xchg rax,rdx\n    test rax,rax\n    jnz .digit\n    mov rdi,rcx       \n    imul rdi,rcx,80     ; calculate base address for row in powers table\n    add rdi,powers\n    mov rsi,digits      ; digits table\n    xor r9,r9           ; total\n.sum:    \n    lodsb               ; get digit\n    movzx rax,al\n    add r9,[rdi+8*rax]  ; add power\n    loop .sum\n    cmp r8,r9           ; if they are equal, the result is true\n    sete al\n    ret\n; ---------> endof narcissistic <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211982,"user_id":null,"body":"global narcissistic\n\nsection .bss\n    digits resb 10  ; maximum int size is 2147483647, so 10 digits are enough\n\nsection .text\nnarcissistic:       ; unexplained code is the best\n  \n    xor rcx, rcx    ; counter\n    mov r8, 10      ; our base\n  \n    mov rax, rdi\n.loop_1:\n    xor rdx, rdx\n    div r8\n    mov [digits+rcx], dl\n    inc rcx\n    cmp rax, 0\n    jne .loop_1\n    mov r9, rcx\n    dec r9\n    jnz .more_than_2_digits\n    mov al, 1\n    ret \n.more_than_2_digits:\n    \n    xor r10, r10    ; counter\n    xor r11, r11    ; sum\n.loop_2:   \n    movzx rax, byte [digits+r11]\n    mov r8, rax     ; note we don't need r8 for 10 anymore\n    mov rcx, r9\n    \n    .loop_2_1:      ; we won't try optimizing taking the power, as again we are limited by ten digits\n        mul r8\n    loop .loop_2_1\n    add r10, rax\n    \n    inc r11\n    cmp r11, r9\n    jng .loop_2\n    \n    cmp r10, rdi\n    sete al\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211983,"user_id":50,"body":"global narcissistic\n\nsection .text\n\n; <--- bool narcissistic(long num) --->\nnarcissistic:\n    xor al, al        ; AL <- the result\n    cmp rdi,1\n    je _retTrue\n    cmp rdi,2\n    je _retTrue\n    cmp rdi,3\n    je _retTrue\n    cmp rdi,4\n    je _retTrue\n    cmp rdi,5\n    je _retTrue\n    cmp rdi,6\n    je _retTrue\n    cmp rdi,7\n    je _retTrue\n    cmp rdi,8\n    je _retTrue\n    cmp rdi,9\n    je _retTrue\n    cmp rdi,153\n    je _retTrue\n    cmp rdi,370\n    je _retTrue\n    cmp rdi,371\n    je _retTrue\n    cmp rdi,407\n    je _retTrue\n    cmp rdi,1634\n    je _retTrue\n    cmp rdi,8208\n    je _retTrue\n    cmp rdi,9474\n    je _retTrue\n    cmp rdi,54748\n    je _retTrue\n    cmp rdi,92727\n    je _retTrue\n    cmp rdi,93084\n    je _retTrue\n    cmp rdi,548834\n    je _retTrue\n    cmp rdi,1741725\n    je _retTrue\n    cmp rdi,4210818\n    je _retTrue\n    cmp rdi,9800817\n    je _retTrue\n    cmp rdi,9926315\n    je _retTrue\n    cmp rdi,24678050\n    je _retTrue\n    cmp rdi,24678051\n    je _retTrue\n    cmp rdi,88593477\n    je _retTrue\n    cmp rdi,146511208\n    je _retTrue\n    cmp rdi,472335975\n    je _retTrue\n    cmp rdi,534494836\n    je _retTrue\n    cmp rdi,912985153\n    je _retTrue\n    cmp rdi,4679307774\n    je _retTrue\n    cmp rdi,32164049650\n    je _retTrue\n    cmp rdi,32164049651\n    je _retTrue\n    ret\n_retTrue:\n    mov al,1\n    ret\n; ---------> endof narcissistic <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"528d36d7cc451cd7e4000339":[{"id":211984,"user_id":null,"body":"global mostmoney\n\n; BestPractice is to use the structure fields even though you do know the offsets!\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nmostmoney:\n  xor r8d, r8d\n  mov r9, 1\n  xor r11d, r11d\n.loop:\n  sub rsi, 1\n  jb .done\n  imul edx, dword [rdi + student.twenties], 20\n  imul ecx, dword [rdi + student.tens], 10\n  movzx eax, al\n  add ecx, edx\n  imul edx, dword [rdi + student.fives], 5\n  add edx, ecx\n  cmp r11, rdx\n  cmove eax, r9d\n  cmovb r11, rdx\n  cmovb r10, rdi\n  cmovb eax, r8d\n  add rdi, 24\n  jmp .loop\n.done:\n  test al, 1\n  mov eax, .all\n  cmove rax, r10\n  ret\n.all: db `all`,0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211985,"user_id":null,"body":"global mostmoney\n\n; BestPractice is to use the structure fields even though you do know the offsets!\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nstudent_sz      equ 0h18\nall_str:  db  \"all\", 0\n\n; <-- ro [byte RAX] mostmoney(ro [struc student RDI] v, RSI n) -->\nmostmoney:\n    xor rcx, rcx\n    xor r9, r9; address of the richest student\n    xor r10, r10; wealth of the richest student\n    xor r12, r12\n    jmp end_loop\n    loop:\n    xor r11, r11\n    xor rax, rax\n    xor rdx, rdx\n    mov dword eax, [rdi+12] \n    mov dx, 5\n    mul dx\n    add r11, rax\n    xor rax, rax\n    xor rdx, rdx\n    mov dword eax, [rdi+16]\n    mov dx, 10\n    mul dx\n    add r11, rax\n    xor rax, rax\n    xor rdx, rdx\n    mov dword eax, [rdi+20]\n    mov dx, 20\n    mul dx\n    add r11, rax\n    cmp r9, rdi\n    je skip\n    cmp r11, r10\n    jl skip\n    je same\n    mov r10, r11\n    mov r9, rdi\n    xor r12, r12\n    jmp skip\n    same:\n    mov r12, 1\n    skip:\n    inc rcx\n    add rdi, 24\n    \n    end_loop:\n    cmp rcx, rsi\n    jl loop\n    \n    test r12, r12\n    jnz all_students\n    \n    xor rax,rax\n    mov rax, r9\n\n    ret\n    \nall_students:\n    mov rax, all_str\n    ret\n    \n; -----> endof mostmoney <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211986,"user_id":null,"body":"global mostmoney\n\n; BestPractice is to use the structure fields even though you do know the offsets!\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nstudent_sz      equ 0h18\n\n; <-- ro [byte RAX] mostmoney(ro [struc student RDI] v, RSI n) -->\nmostmoney:\n    push rsi\n    xor r8, r8            ; R8 = most money seen\n    xor r9, r9            ; R9 = incremented on change; if =0 then all students are the same\n    dec r9\n    mov r10, rdi          ; R10 = richest student seen\n.loop:\n    imul ecx, [rdi + student.fives], 5\n    imul eax, [rdi + student.tens], 10\n    add rcx, rax\n    imul eax, [rdi + student.twenties], 20\n    add rcx, rax\n    cmp rcx, r8          ; Compare\n    je .next             ; No change \n    jb .lo               ; If lower, then the richest student doesn't change\n    mov r8, rcx          ; But otherwise, current student is richest\n    mov r10, rdi\n.lo:\n    inc r9\n.next:    \n    add rdi, student_sz\n    dec rsi\n    jnz .loop\n    pop rsi\n    mov rax, all_string ; All students are the same ...\n    dec rsi\n    cmovz rax, r10      ; ...unless there is only one student,\n    test r9, r9\n    cmovnz rax, r10     ; ...or there were two or more different students\n    ret\n; -----> endof mostmoney <-----\n\nsection .data\nall_string:\n    db \"all\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211987,"user_id":168,"body":"global mostmoney\n\n; BestPractice is to use the structure fields even though you do know the offsets!\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nstudent_sz      equ 0h18\n\nall: db 'all', 0\n\n; <-- ro [byte RAX] mostmoney(ro [struc student RDI] v, RSI n) -->\nmostmoney:\n  mov rax, rdi\n  cmp rsi, 1\n  je .end\n  xor ecx, ecx    ; max money\n  mov r9d, -1     ; min money\n.loop:\n  mov edx, dword [rdi + student.twenties]\n  add edx, edx\n  add edx, dword [rdi + student.tens]\n  add edx, edx\n  add edx, dword [rdi + student.fives]\n  cmp edx, ecx\n  cmova ecx, edx\n  cmova rax, rdi\n  cmp edx, r9d\n  cmovb r9d, edx\n  add rdi, student_sz\n  dec rsi\n  jnz .loop\n  mov rdi, all\n  cmp ecx, r9d\n  cmove rax, rdi\n.end:\n  ret\n; -----> endof mostmoney <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211988,"user_id":77,"body":"global mostmoney\n\n; BestPractice is to use the structure fields even though you do know the offsets!\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nstudent_sz      equ 0h18\n\nall db \"all\"\n    db 0\n\n; <-- ro [byte RAX] mostmoney(ro [struc student RDI] v, RSI n) -->\nmostmoney:\n    mov rax, rdi\n    cmp rsi, 1\n    je  .end\n    xor rbx, rbx\n    xor rcx, rcx\n    mov rdx, -1\n.loop:\n    mov ecx, dword [rdi+20]\n    shl ecx, 1\n    add ecx, dword [rdi+16]\n    shl ecx, 1\n    add ecx, dword [rdi+12]\n    cmp rcx, rbx\n    jbe .nob\n    mov rbx, rcx\n    mov rax, rdi\n.nob:\n    cmp rcx, rdx\n    jae .now\n    mov rdx, rcx\n.now:\n    add rdi, 24\n    dec rsi\n    jnz .loop\n    cmp rbx, rdx\n    jne .end\n    mov rax, all\n.end:\n    ret\n; -----> endof mostmoney <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211989,"user_id":null,"body":"section .data\nall db \"all\", 0x0\n\nglobal mostmoney\n\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nmostmoney:\n    ; r8 - pointer to the most rich student\n    ; r9d - his total money\n    ; r10 - number of the most rich students\n\n    xor r9d, r9d\n    xor r10, r10\n\n    mov ecx, esi\n\n.loop:\n    call calc_student_money\n\n    cmp eax, r9d\n    jl .next\n    je .same\n\n    mov r8, rdi\n    mov r9d, eax\n    mov r10, 1\n    jmp .next\n\n.same:\n    inc r10\n\n.next:\n    add rdi, student_size\nloop .loop\n\n    cmp rsi, 1\n    je .ret_name\n\n    cmp r10, rsi\n    je .ret_all\n\n.ret_name:\n    mov rax, r8\n    ret\n\n.ret_all:\n    mov rax, all\n    ret\n\n\n; rdi - pointer to student\n; eax - result\ncalc_student_money:\n    push rcx\n    xor ecx, ecx\n\n    ; count fives\n    mov eax, dword [rdi + student.fives]\n    mov r11, 5\n    imul r11\n    add ecx, eax\n\n    ; count tens\n    mov eax, dword [rdi + student.tens]\n    mov r11, 10\n    imul r11\n    add ecx, eax\n\n    ; count twenties\n    mov eax, dword [rdi + student.twenties]\n    mov r11, 20\n    imul r11\n    add ecx, eax\n\n    mov eax, ecx\n    pop rcx\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211990,"user_id":null,"body":"global mostmoney\nmostmoney:\n  lea  r8,[rsi-1]\n  mov  rax,rdi\n  test r8,r8\n  je .exit\n    xor rcx,rcx\n    xor r9,r9\n    .b:movdqu   xmm0,[rdi+12]\n       cvtdq2ps xmm0,xmm0\n       dpps     xmm0,[coeff],01110001b\n       cvtss2si edx,xmm0\n       cmp      edx,ecx\n       sete     r9b\n       cmova    ecx,edx\n       cmova    rax,rdi\n       sub      r8,r9\n       add      rdi,0x18\n       dec      rsi\n    jne .b   \n    test  r8,r8\n    cmove rax,[all]\n  .exit:\nret\nalign 16\ncoeff dd 5.0,10.0,20.0,0\nall   dq $+8\n      db 'all',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211991,"user_id":null,"body":"global mostmoney\nextern puts\n\n; BestPractice is to use the structure fields even though you do know the offsets!\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nstudent_sz      equ 0h18\n\n; <-- ro [byte RAX] mostmoney(ro [struc student RDI] v, RSI n) -->\nmostmoney:\n    cmp rsi, 1 \n    jz mostmoney_end\n\n    ; Initial maximum amount of money.\n    mov r8, -1\n    \n    ; Counter.\n    mov rcx, rsi\n    \n    ; Initial minimum amount of money.\n    mov r9, -1\n    \nStudentArrayLoop:\n    ; Sum up all the money.\n    mov ebx, [rdi + student.fives - student]\n    imul ebx, 5\n    \n    mov esi, [rdi + student.tens - student]\n    imul esi, 10\n    add ebx, esi\n    \n    mov esi, [rdi + student.twenties - student]\n    imul esi, 20\n    add ebx, esi\n    \n    ; Move maximum amount of money in <R8> and the kid with the most money in <RAX>.\n    cmp rbx, r8\n    cmovg r8, rbx\n    cmovg rax, rdi\n    \n    ; Move minimum amount of money in <R9>.\n    cmp rbx, r9\n    cmovb r9, rbx\n    \n    ; Go to next kid.\n    add rdi, student_sz\n    loop StudentArrayLoop\n    \n    ; If min and max are equal then output 'all'.\n    cmp r8, r9\n    jnz mostmoney_end\n    \n    mov dword [rax], 0x006c6c61\n\nmostmoney_end:\n    ret\n    \n; -----> endof mostmoney <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211992,"user_id":null,"body":"global mostmoney\n\nstruc student\n    .name:      resb 9\n                alignb 4\n    .fives:     resd 1\n    .tens:      resd 1\n    .twenties:  resd 1\nendstruc\n\nstudent_sz      equ 0h18\n\n; <-- ro [byte RAX] mostmoney(ro [struc student RDI] v, RSI n) -->\nmostmoney:\n    cmp rsi, 0h1                        ; whether <n> is one\n    cmove rax, rdi                      ; setting the result to <v->name>\n    je .exit                            ; jumping to exit\n    xor eax, eax                        ; resetting RAX as <name>\n    xor r9, r9                          ; resetting R10 as <eq>\n    inc r9                              ; setting <eq> to one\n    xor r8d, r8d                        ; resetting R8D as <max>\n    push rsi                            ; saving <n> onto the stack\n.loop:\n    mov ecx, [rdi + student.twenties]   ; loading ECX with <v->twenties> as <mon>\n    shl ecx, 2                          ; multiplying <mon> by four\n    mov edx, [rdi + student.tens]       ; loading EDX with <v->tens> as <tens>\n    shl edx, 1                          ; multyplying <tens> by two\n    add ecx, edx                        ; adding <tens> to <mon>\n    add ecx, [rdi + student.fives]      ; adding <v->fives> to <mon>\n    mov r10, r9                         ; setting R10 to <eq> as <eqinc>\n    inc r10                             ; incrementing <eqinc>\n    cmp ecx, r8d                        ; whether <mon> is higher than <max>\n    cmova r8d, ecx                      ; updating <max> with <mon>\n    cmova rax, rdi                      ; setting <name> to <v->name>\n    cmove r9, r10                       ; otherwise, if equal, setting <eq> to <eqinc>\n    add rdi, student_sz                 ; pointing <v> to the next student\n    dec rsi                             ; decrementing <n>\n    jnz .loop                           ; jumping to the next iteration if not zero\n    pop rsi                             ; restoring <n> from the stack\n    mov rdx, .all                       ; pointing RDX to <.all>\n    cmp r9, rsi                         ; whether <eq> is equal to <max>\n    cmove rax, rdx                      ; updating <name> with <.all>\n.exit:\n    ret\n\n; local read-only storage\n.all:\n    db  `all\\0`\n; -----> endof mostmoney <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52b7ed099cdc285c300001cd":[{"id":211993,"user_id":null,"body":"global sumintvls\nextern calloc, qsort, memcpy, free\n\n; BestBractice is to use the structure fields even though the offsets are known\nstruc intvl\n    .first:     resd    1\n    .second:    resd    1\nendstruc\n\nintvl_sz:       equ 0h8\n\ncompare_func:\n  xor eax, eax\n  mov ecx, [rdi+intvl.first]\n  cmp ecx, [rsi+intvl.first]\n  jg .g\n  jl .l\n  mov ecx, [rdi+intvl.second]\n  cmp ecx, [rsi+intvl.second]\n  je .e\n  jl .l\n  \n.g:\n  inc eax\n.e:\n  ret\n.l:\n  dec eax\n  ret\n\n\n; <-- EAX sumintvls(ro [struct intvl RDI] v, RSI n) -->\nsumintvls:\n  sub rsp, 40\n  mov [rsp], rdi\n  mov [rsp+8], rsi\n  \n  mov rdi, rsi\n  mov rsi, intvl_sz\n  call calloc\n  test rax, rax\n  jz .quit\n  mov [rsp+16], rax\n  \n  mov rdi, rax\n  mov rsi, [rsp]\n  imul rdx, [rsp+8], intvl_sz\n  call memcpy\n  \n  mov rdi, [rsp+16]\n  mov rsi, [rsp+8]\n  mov rdx, intvl_sz\n  lea rcx, [compare_func]\n  call qsort\n  \n  mov rsi, [rsp+16]\n  mov rdi, [rsp+8]\n  movsx rdx, dword [rsi+intvl.first]\n  movsx rcx, dword [rsi+intvl.second]\n  xor eax, eax\n  \n.loop:\n  add rsi, intvl_sz\n  dec rdi\n  jz .done\n  movsx r8, dword [rsi+intvl.first]\n  cmp rcx, r8\n  jl .separate\n  movsx r8, dword [rsi+intvl.second]\n  cmp rcx, r8\n  cmovl rcx, r8\n  jmp .loop\n  \n.separate:\n  add rax, rcx\n  sub rax, rdx\n  mov rdx, r8\n  movsx rcx, dword [rsi+intvl.second]\n  jmp .loop  \n\n.done:\n  add rax, rcx\n  sub rax, rdx\n  mov [rsp], rax\n  mov rdi, [rsp+16]\n  call free\n  mov rax, [rsp]\n.quit:\n  add rsp, 40\n  ret\n; -----> endof sumintvls <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211994,"user_id":527,"body":"global sumintvls\nextern free, malloc, memcpy, qsort\n\n; int sumintvls(const struct intvl *v, size_t n)\nsumintvls:\n                push    r12\n                mov     r12, rdi\n                push    rbp\n                mov     rbp, rsi\n                push    rbx\n                lea     rdi, [rsi * 8]\n                call    malloc\n                mov     rbx, rax\n                mov     rdi, rax\n                mov     rsi, r12\n                lea     rdx, [rbp * 8]\n                call    memcpy\n                mov     rdi, rbx\n                mov     rsi, rbp\n                mov     rdx, 8\n                lea     rcx, [rel cmpintvls]\n                call    qsort\n                xor     r12d, r12d\n                mov     esi, 80000000h\n                mov     rax, rbx\n.loop:          mov     ecx, [rax]\n                cmp     esi, ecx\n                cmovg   ecx, esi\n                mov     edx, [rax + 4]\n                cmp     esi, edx\n                cmovg   edx, esi\n                mov     esi, edx\n                sub     edx, ecx\n                add     r12d, edx\n                add     rax, 8\n                dec     rbp\n                jnz     .loop\n                mov     rdi, rbx\n                call    free\n                pop     rbx\n                pop     rbp\n                mov     rax, r12\n                pop     r12\n                ret\n\ncmpintvls:\n                mov     edx, [rdi]\n                xor     eax, eax\n                xor     ecx, ecx\n                cmp     edx, [rsi]\n                setg    al\n                setl    cl\n                sub     eax, ecx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211995,"user_id":null,"body":"global sumintvls\n\n; Best practice blah blah\n\nextern qsort\n\n; <-- EAX sumintvls(ro [struct intvl RDI] v, RSI n) -->\nsumintvls:\n    push rbx                    ; save non-volatile registers\n    push r12\n    push r13                    \n    mov rbx, rsi                ; array length into rbs - to preserve it from qsort calls\n    mov rax, 4                  ; multiply length of the argument array by 4\n    mul rsi                     ;  which is half its length in bytes (into rax)      \n    mov r12, rax                ; copy half-length into r12\n    add rax, r12                ; double half-length to get the full length       \n    mov r13, rax                ; save this full amount in r13 \n    sub rsp, rax                ; and this much space on the stack    \n    add r12, rsp                ; set r12 to be the pointer to the second half of the stack space\n    xor r9, r9\n    xor r8, r8\n    ; copy the first number in each interval into an array starting at rsp\n    ; copy the second number into an array pointed to by r12 (half way into the created stack space)\n    xor rcx, rcx\n    .array_copy:\n        mov rax, [rdi + r8]     ; read both number into rax\n        mov [rsp + rcx], eax    ; first number into first array\n        shr rax, 32             ; rotate rax to get other number\n        mov [r12 + rcx], eax    ; put it into second array\n        add rcx, 4              ; move destination array offset\n        add r8, 8               ; move source array offset\n        cmp r8, r13\n    jne .array_copy             ; exit loop when source has been read\n    ; sort 1st stack array (low-end of intervals) from low to high\n    mov rdi, rsp                ; pointer to first array for qsort\n    mov rsi, rbx                ; array length for qsort\n    mov rdx, 4                   ; array element size for qsort\n    mov rcx, compare             ; comparison for qsort\n    sub rsp, 0x38               ; shadow space and aligh stack\n    call qsort\n    ; sort 2nd stack array (high-end of intervals) from low to high    \n    mov rdi, r12                ; pointer for 2nd stack array for qsort\n    mov rsi, rbx                ; array length for qsort\n    mov rdx, 4                   ; array element size for qsort\n    mov rcx, compare\n    call qsort\n    add rsp, 0x38               ; remove shadow space\n    ; now calculate the answer      \n    ; intervals have been sorted but are still equivalent, so can simply skip overlap\n    ; by checking current low-end is not lower than previous high-end, and if it is\n    ; subsituting the previous high for the current low\n    ; do first loop iteration manually to avoid having to special case it (no previous high)\n    mov edx, [rsp]              ; first low-end\n    mov edi, [r12]              ; first high-end\n    mov r8d, edi                ; will become previous high-end in loop\n    sub edi, edx                ; calculate first interval\n    mov eax, edi                ; eax holds running total\n    cmp rbx, 1                  ; skip loop if only 1 element, since loop test is at the end would go beyond array bounds\n    je .after_loop                  \n    mov r10, rsp                ; first array pointer (second is r12 - no need to save its start position)  \n    add r10, 4                  ; move both pointers one element on since first iteration is done\n    add r12, 4\n    mov rcx, rbx                \n    dec rcx                     ; loop counter set to array length -1, since starting on 2nd elements\n    .calc_loop:\n        mov edx, [r10]          ; low end of interval\n        mov edi, [r12]          ; high end of interval\n        cmp r8d, edx            ; compare current-low-end to previous-high-end\n        jle .edx_is_set         ; if current-low is lower than previous-high\n          mov edx, r8d          ; then subsitute current high for previous low\n        .edx_is_set:\n        mov r8d, edi            ; save current high for next iteration\n        sub edi, edx            ; calculate interval: current high - (either current low or previous high)\n        add eax, edi            ; add it to running total\n        add r10, 4              ; move pointers\n        add r12, 4\n    loop .calc_loop\n    .after_loop:\n    add rsp, r13                ; cleanup the stack arrays\n    pop r13                     ; restore non-volatile registers\n    pop r12                     \n    pop rbx                     \n    ret\n    \n; for qsort    \ncompare:\n    mov eax, [rdi]\n    cmp eax, [rsi]\n    jg .cmp_true\n    xor rax, rax\n    ret\n    .cmp_true:\n    mov rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211996,"user_id":null,"body":"global sumintvls\n\n; BestBractice is to use the structure fields even though the offsets are known\nstruc intvl\n    .first:     resd    1\n    .second:    resd    1\nendstruc\n\nintvl_sz:       equ 0h8\n\n; <-- EAX sumintvls(ro [struct intvl RDI] v, RSI n) -->\nsumintvls:\n    push rbp\n    mov rbp, rsp\n    \n    ; If there is only one interval then do a simple substraction.\n    cmp rsi, 1\n    jne normal_execution\n    \n    xor rax, rax\n    mov eax, [rdi + 4]\n    sub eax, [rdi]\n    jmp sumintvls_end\n    \nnormal_execution:\n    ; Sort the intervals based on their .first field\n    \n    ; This is a nice implementation of bubble sort which I find\n    ; pretty elegant. https:\/\/gist.github.com\/jibsen\/8afc36995aadb896b649\nsortintvls:\n    mov rcx, rsi\n    dec rcx\n    \n.outterloop:\n    push rcx\n    push rsi\n    push rdi\n    \n    mov rsi, rdi\n    \n.innerloop:\n    mov eax, [rsi]\n    mov edx, [rsi + 4]\n    add rsi, intvl_sz\n    \n    cmp eax, [rsi]\n    jle short .order_ok\n    xchg eax, [rsi]\n    xchg edx, [rsi + 4]\n    \n.order_ok:\n    mov [rdi], eax\n    mov [rdi + 4], edx\n    add rdi, intvl_sz\n    \n    loop .innerloop\n    \n    pop rdi\n    pop rsi\n    pop rcx\n    \n    loop .outterloop\n    \noverlapping:\n    ; Push the first interval on stack.\n    ; Save how many intervals are pushed in <RDX>\n    push qword [rdi]\n    mov rdx, 0x01\n    \n    ; Loop through intervals. If intervals overlap the\n    ; one on stack then update the stack interval, otherwise\n    ; push a new independent interval.\n    ;\n    ; At the end of this part we should have all combined intervals.\n    \n    ; <RCX> is used as counter.\n    mov rcx, rsi\n    dec rcx\n    ; Loop starts from the second element because the first was already pushed\n    ; on stack.\n    add rdi, intvl_sz\n    \n.intvls_loop:\n    ; If intvls[i].first > stack_intvl.second then intvls[i] does not overlap.\n    mov eax, [rdi]\n    cmp eax, [rsp + 4]\n    jg .push_intvl\n    \n    ; stack_intvl.first = min(stack_intvl.first, intvls[i].first)\n    cmp eax, [rsp]\n    cmovg eax, [rsp]\n    mov [rsp], eax\n    \n    ; stack_intvl.second = max(stack_intvl.second, intvls[i].second)\n    mov eax, [rdi + 4]\n    cmp eax, [rsp + 4]\n    cmovl eax, [rsp + 4]\n    mov [rsp + 4], eax\n    \n    jmp .intvls_loop_reload\n\n.push_intvl:\n    ; Push an independent interval on stack(an interval that does not overlap\n    ; with the one that is already on stack).\n    push qword [rdi]\n    inc rdx\n    \n.intvls_loop_reload:\n    add rdi, intvl_sz\n    loop .intvls_loop\n    \nintvls_sum:\n    ; Now all intervals from the stack will be popped and \n    ; intvl.second - intvl.first will be added to sum which is saved\n    ; in <EAX>\n\n    ; <RCX> is used as counter.\n    mov rcx, rdx\n    xor rax, rax\n    \n.compute_sum:\n    add eax, [rsp + 4]\n    sub eax, [rsp]\n    \n    add rsp, 8\n    loop .compute_sum\n    \nsumintvls_end:\n    mov rsp, rbp\n    pop rbp\n    ret\n; -----> endof sumintvls <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211997,"user_id":null,"body":"global sumintvls\nextern qsort\n\nstruc intvl\n    .first:     resd    1\n    .second:    resd    1\nendstruc\n\nintvl_sz:       equ 0h8\n\n; <-- EAX intvlcmp(ro [struct intvl RDI] v1, ro [struct intvl RSI] v1) -->\nintvlcmp:\n    xor eax, eax                    ; resetting the result\n    mov ecx, [rdi+intvl.first]      ; setting ECX to <v1->first> as <first>\n    mov edx, [rsi+intvl.first]      ; setting EDX to <v2->second> as <second>\n    mov edi, 1                      ; setting EDI to one\n    mov esi, -1                     ; setting ESI to minus one\n    cmp ecx, edx                    ; whether <first> is equal to <second>\n    cmovg eax, edi                  ; otherwise, if greater, setting the result to one\n    cmovl eax, esi                  ; otherwise, if less, setting the result to minus one\n    ret\n; -----> endof intvlcmp <-----\n\n; <-- EAX sumintvls(ro [struct intvl RDI] v, RSI n) -->\nsumintvls:\n    push rbx                        ; saving RBX onto the stack\n    imul rax, rsi, intvl_sz         ; the target bytes to store <v>\n    or rax, 0h8                     ; aligning the number of bytes to the boundary <nalign>\n    sub rsp, rax                    ; allocating storage for <m>\n    mov rbx, rsp                    ; pointing RBX to <m>\n    push rax                        ; saving <nalign> onto the stack\n    push rsi                        ; saving <n> in the stack\n    mov rcx, rsi                    ; copying <n> to RCX\n    mov rax, rbx                    ; pointing RAX to <m>\n.lpcpy:\n    mov rdx, [rdi]                  ; copying <*v> to RDX as <intvl>\n    mov [rax], rdx                  ; saving <intvl> in the local storage <m>\n    add rdi, intvl_sz               ; pointing <v> to the next interval\n    add rax, intvl_sz               ; pointing <m> to the next free location\n    dec rcx                         ; decrementing <n>\n    ja .lpcpy                       ; jumping to the next .lpcpy iteration if above zero\n    mov rdi, rbx                    ; pointing RDI to the start of <m>\n    mov rdx, intvl_sz               ; setting RDX to the size of interval structure\n    mov rcx, intvlcmp               ; pointing RCX to the function to compare\n    call qsort                      ; quick sorting <m>\n    pop rsi                         ; restoring <n> from the stack\n    pop r11                         ; restoring <nalign> from the stack\n    xor eax, eax                    ; resetting EAX as <sum>\n    mov edi, [rbx+intvl.first]      ; setting EDI to <m->first> as <extramax>\n    sub rbx, intvl_sz               ; pointing <m> before the first interval\n    inc rsi                         ; incrementing <n> to start from decrementing\n    jmp .exit                       ; jumping to exit\n.loop:\n    add rbx, intvl_sz               ; pointing <m> to the next interval\n    mov ecx, [rbx+intvl.first]      ; setting <min> to <m->first>\n    mov edx, [rbx+intvl.second]     ; setting <max> to <m->second>\n    cmp edx, edi                    ; whether <max> is greater than <extramax>\n    jle .exit                       ; otherwise, jumping to exit\n    cmovg r8d, edi                  ; setting <extra> to <max>\n    cmp ecx, edi                    ; whether <min> is less than <extramax>\n    cmovge r8d, ecx                 ; otherwise, setting <extra> to <min>\n    add eax, edx                    ; adding <max> to <sum>\n    sub eax, r8d                    ; subtracting <extra> from <sum>\n    mov edi, edx                    ; updating <extramax> with <max>\n.exit:\n    dec rsi                         ; decrementing <n>\n    jnz .loop                       ; jumping to the next iteration if above zero\n    add rsp, r11                    ; destroying the local storage <m>\n    pop rbx                         ; restoring the original RBX from the stack\n    ret\n; -----> endof sum_intervals <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":211998,"user_id":527,"body":"global sumintvls\nextern free, malloc, memcpy, qsort\n\n; int sumintvls(const struct intvl *v, size_t n)\nsumintvls:\n                push    r12\n                mov     r12, rdi\n                push    rbp\n                mov     rbp, rsi\n                push    rbx\n                lea     rdi, [rsi * 8]\n                call    malloc\n                mov     rbx, rax\n                mov     rdi, rax\n                mov     rsi, r12\n                lea     rdx, [rbp * 8]\n                call    memcpy\n                mov     rdi, rbx\n                mov     rsi, rbp\n                mov     rdx, 8\n                lea     rcx, [rel cmpintvls]\n                call    qsort\n                xor     r12d, r12d\n                mov     esi, 80000000h\n                mov     rax, rbx\n.loop:          mov     ecx, [rax]\n                cmp     esi, ecx\n                cmovg   ecx, esi\n                mov     edx, [rax + 4]\n                cmp     esi, edx\n                cmovg   edx, esi\n                mov     esi, edx\n                sub     edx, ecx\n                add     r12d, edx\n                add     rax, 8\n                dec     rbp\n                jnz     .loop\n                mov     rdi, rbx\n                call    free\n                pop     rbx\n                pop     rbp\n                mov     rax, r12\n                pop     r12\n                ret\n\ncmpintvls:\n                mov     eax, [rdi]\n                sub     eax, [rsi]\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52de553ebb55d1fca3000371":[{"id":211999,"user_id":168,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n  mov eax, dword [rdi]\n  dec esi\n  add eax, dword [rdi + rsi * 4]\n  imul esi\n  sar eax, 1\n  dec esi\n.loop:\n  sub eax, dword [rdi + rsi * 4]\n  dec esi\n  jnz .loop\n  ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212000,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n  movsxd rax, dword [rdi]\n  movsxd rcx, dword [rdi + 4*rsi - 4]\n  add rcx, rax\n  lea rax, [rsi + 1]\n  imul rax, rcx\n  shr rax, 1\n.loop:\n  sub rsi, 1\n  jb .done\n  sub eax, [rdi]\n  add rdi, 4\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212001,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n  movsx rcx, dword [rdi]\n  movsx rax, dword [rdi + rsi * 4 - 4]\n  sub rax, rcx\n  jz .zero_d\n  cqo\n  idiv rsi\n  mov edx, eax\n  mov eax, ecx\n.loop:\n  ; `add rdi, 4` before `add eax, edx` _may_ improve performance by\n  ; the 9th iteration on modern intel chips according to `uica.uops.info`\n  add rdi, 4 \n  add eax, edx\n  cmp eax, [rdi]\n  je .loop\n  ret\n.zero_d:\n  mov eax, ecx\n  ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212002,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n  movsx rcx, dword [rdi]\n  movsx rax, dword [rdi + rsi * 4 - 4]\n  sub rax, rcx\n  jz .zero_d\n  cqo\n  idiv rsi\n  mov edx, eax\n  mov eax, ecx\n.loop:\n  add eax, edx\n  add rdi, 4\n  cmp eax, [rdi]\n  je .loop\n  ret\n.zero_d:\n  mov eax, ecx\n  ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212003,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n  movsx rcx, dword [rdi]\n  movsx rax, dword [rdi + rsi * 4 - 4]\n  sub rax, rcx\n  jz .zero_d\n  cqo\n  idiv rsi\n  mov r8d, eax\n  mov eax, ecx\n.loop:\n  add eax, r8d\n  add rdi, 4\n  cmp eax, [rdi]\n  je .loop\n  ret\n.zero_d:\n  mov eax, ecx\n  ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212004,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n  movsx rcx, dword [rdi]\n  movsx rax, dword [rdi + rsi * 4 - 4]\n  sub rax, rcx\n  jz .zero_d\n  cqo\n  idiv rsi\n  mov r8d, eax\n  mov eax, ecx\n.loop:\n  add eax, r8d\n  add rdi, 4\n  cmp eax, [rdi]\n  je .loop\n.ret:\n  ret\n.zero_d:\n  mov eax, ecx\n  ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212005,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n    xor eax, eax\n    mov eax, dword [rdi]\n    mov rcx, rsi\n    dec rcx\n    mov ebx, dword [rdi+4*rcx]\n    add eax, ebx\n    add ecx, 2\n    mul ecx\n    xor edx, edx\n    cdq\n    mov ebx, 2\n    idiv ebx\n    mov rcx, rsi\n.loop:\n    dec rcx\n    mov ebx, dword [rdi+4*rcx]\n    sub eax, ebx\n    cmp rcx, 0\n    jg .loop\n    ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212006,"user_id":null,"body":"global find_missing\n\nsection .text\nglobal find_missing\nfind_missing:\n    mov rsi, -1\n\n    mov eax, [rdi + 4]\n    sub eax, [rdi]\n\n    mov ebx, [rdi + 8]\n    sub ebx, [rdi + 4]\n\n    mov ecx, [rdi + 12]\n    sub ecx, [rdi + 8]\n.look_stack:\n    cmp ebx, eax\n    je .first_loop\n    cmp ebx, ecx\n    je .first_loop\n    mov ebx, eax\n.first_loop:\n    inc rsi\n    mov eax, dword [rdi + rsi * 4 + 4]\n    sub eax, dword [rdi + rsi * 4]\n    cmp eax, ebx\n    je .first_loop\n.my_fnish:\n    mov eax, [rdi + rsi * 4]\n    add eax, ebx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212007,"user_id":null,"body":"global find_missing\nfind_missing:\n  lea rcx,[rsi-2]\n  lea rsi,[rdi+4]\n  lodsd\n  sub eax,[rdi]\n  .b:mov   edx,eax\n     lodsd\n     sub   eax,[rsi-8]\n     cmp   eax,edx\n  loope .b\n  add eax,[rsi-8]\n  sub eax,edx\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212008,"user_id":null,"body":"global find_missing\n\nsection .text\n\n; <--- int find_missing(const int *nums, size_t n) --->\nfind_missing:\n    xor eax, eax        ; EAX <- the result\n    xor rcx, rcx        ; index\n    mov eax, [rdi+4]\n    sub eax, [rdi]      ; get first difference\n    mov ebx, [rdi+8]\n    sub ebx, [rdi+4]    ; get second difference\n    cmp eax, 0\n    jge .positive\n    ; negative\n    cmp eax, ebx\n    jg .is_eax\n    mov edx, ebx\n    jmp .find\n.positive:\n    cmp eax, ebx\n    jl .is_eax\n    mov edx, ebx\n    jmp .find\n.is_eax:\n    mov edx, eax\n.find:\n    mov eax, [rdi + rcx*4]\n    add eax, edx\n    inc rcx\n    cmp eax, [rdi + rcx*4]\n    jne .end\n    jmp .find\n.end:\n    ret\n; ---------> endof find_missing <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52e88b39ffb6ac53a400022e":[{"id":212009,"user_id":null,"body":"global uint32_to_ip\nextern sprintf\nsection .text\nuint32_to_ip:\n    movzx r9,sil\n    shr   rsi,8\n    movzx r8,sil\n    shr   rsi,8\n    movzx rcx,sil\n    shr   rsi,8\n    movzx rdx,sil\n    mov   rsi,.fmt\n    xor   rax,rax\n    call  sprintf\n    ret\n.fmt db '%i.%i.%i.%i',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212010,"user_id":null,"body":"global uint32_to_ip\nextern sprintf\nsection .data\nt db '%d.%d.%d.%d', 0\nsection .text\nuint32_to_ip: push rdi\n              mov rdx, rsi\n              mov rcx, rsi\n              mov r8, rsi\n              mov r9, rsi\n              mov rsi, t\n              shr rdx, 24\n              shr rcx, 16\n              and rcx, 0xff\n              shr r8, 8\n              and r8, 0xff\n              and r9, 0xff\n              call sprintf\n              pop rax\n              ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212011,"user_id":null,"body":"global uint32_to_ip\nextern sprintf\n\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n    push  rdi\n    xor   rax, rax\n    mov   rdx, rsi\n    mov   rcx, rsi\n    mov   r8,  rsi\n    mov   r9, rsi\n    shr   rdx, 24\n    and   rdx, 0xff\n    shr   rcx, 16\n    and   rcx, 0xff\n    shr   r8,  8\n    and   r8,  0xff\n    and   r9,  0xff\n    lea   rsi, [rel .f]\n    call  sprintf\n    pop   rax\n    ret\n.f: db '%d.%d.%d.%d',0\n; -----> endof uint32_to_ip <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212012,"user_id":null,"body":"global uint32_to_ip\nextern sprintf\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n  mov eax, esi\n  push rbx\n  mov ecx, esi\n  mov rbx, rdi\n  movzx edx, ah\n  shr ecx, 16\n  movzx r9d, sil\n  xor eax, eax\n  mov r8d, edx\n  mov edx, esi\n  movzx ecx, cl\n  mov esi, .fmt\n  shr edx, 24\n  call sprintf\n  mov rax, rbx\n  pop rbx\n  ret\n\n.fmt: db \"%d.%d.%d.%d\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212013,"user_id":null,"body":"global uint32_to_ip\nextern sprintf\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n    mov rax, rdi            ; RAX <- ip\n    bswap esi\n    mov rdx, rsi\n    mov cl, dh\n    mov r8, rdx\n    shr r8, 16\n    mov r9, rdx\n    shr r9, 24\n    mov rsi, scanFmt\n    push rdi\n    call sprintf\n    pop rax\n    ret\n; -----> endof uint32_to_ip <-----\n\nsection .data\nscanFmt db \"%hhu.%hhu.%hhu.%hhu\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212014,"user_id":null,"body":"global uint32_to_ip\n\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\n; Converter without using a library function.\nuint32_to_ip:\n  %push mycontext                 ; store current context\n  %stacksize flat64               ; address stack frame with rbp\n  %assign %$localsize 0\n  BUFFER_SIZE equ 4*4             ; maximal 4 x 4 chars for IP address text\n  %local b1:QWORD,b2:QWORD        ; reserve bytes\n  %local buffer:BYTE\n  %local result:QWORD\n  \n    enter %$localsize, 0          ; allocate stack frame\n    mov [result], rdi             ; store pointer to return buffer\n    lea rdi, [buffer+BUFFER_SIZE] ; rdi = running pointer in buffer\n    std                           ; create address from end                 \n    ; convert int into IP address text\n    mov bx, 10                    ; base of the decimal numbers\n    xor al, al\n    stosb                         ; end of string\n    mov rcx, 4                    ; 4 numbers in the IP address text\n    jmp .start_ip_loop            ; start converting the least significant byte\n.convert_ip_loop:\n    mov al, '.'                   ; separate numbers by a dot\n    stosb\n.start_ip_loop:\n    mov ax, si                    ; move the last byte into al\n    and ax, 0xff\n    shr rsi, 8\n    ; convert byte in ax into decimal number\n.convert_byte_loop:\n    xor dx, dx\n    div bx\n    add dl,'0'                    ; convert value to ASCII decimal digit\n    mov [rdi], dl                 ; write digit into buffer\n    dec rdi                       ; down in the buffer\n    test ax, ax\n    jnz .convert_byte_loop\n    loop .convert_ip_loop\n    ; copy IP address into output buffer\n    mov rsi, rdi\n    inc rsi                       ; rsi = first char in the buffer\n    mov rdi, [result]             ; rdi = result buffer\n    cld                           ; prepare string copy rsi -> rdi\n.copy_loop:\n    lodsb\n    stosb\n    test al, al                   ; check for end of string\n    jnz .copy_loop\n    ; return\n    mov rax, [result]             ; RAX <- IP address text\n    leave                         ; freee stach frame\n    ret\n  \n  %pop                      ; restore old context\n; -----> endof uint32_to_ip <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212015,"user_id":null,"body":"global uint32_to_ip\nextern sprintf\n\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n  push rdi\n  \n  xor rax, rax\n  mov edx, esi\n  mov ecx, esi\n  mov r8d, esi\n  mov r9d, esi\n  shr edx, 24\n  shr ecx, 16\n  shr r8d, 8\n  lea rsi, [format]\n  call sprintf\n  \n  pop rax\n  ret\n; -----> endof uint32_to_ip <-----\n\nsection .rodata\nformat: db \"%hhu.%hhu.%hhu.%hhu\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212016,"user_id":173,"body":"global uint32_to_ip\n\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n    mov r15, rdi\n    mov rax, rsi\n    and rax, 0xFF000000\n    shr rax, 24\n    \n    call print_byte\n    \n    mov byte [rdi], '.'\n    inc rdi\n\n    mov rax, rsi\n    and rax, 0x00FF0000\n    shr rax, 16\n    \n    call print_byte\n    \n    mov byte [rdi], '.'\n    inc rdi\n\n    mov rax, rsi\n    and rax, 0x0000FF00\n    shr rax, 8\n    \n    call print_byte\n    \n    mov byte [rdi], '.'\n    inc rdi\n\n    mov rax, rsi\n    and rax, 0x000000FF\n    call print_byte\n    \n    mov byte [rdi], 0\n    \n    ret\n; -----> endof uint32_to_ip <-----\n\nprint_byte:\n    push r12\n    push r13\n    push rdx\n    push r14\n    \n    ; hundreds non zero\n    mov r14, 0\n\n    mov r12, rax\n    \n    mov rdx, 0\n    mov r13, 100\n    div r13\n    cmp rax, 0\n    je l_tens\n    mov r14, 1\n    \n    mov byte [rdi], al\n    add byte [rdi], 0x30\n    inc rdi\n    \n    mul r13\n    sub r12, rax\nl_tens:\n    mov rax, r12 ; load reminder\n    \n    mov rdx, 0\n    mov r13, 10\n    div r13\n    cmp r14, 0\n    jne l_1\n    cmp rax, 0\n    je l_units\nl_1:    \n    mov byte [rdi], al\n    add byte [rdi], 0x30\n    \n    inc rdi\n\nl_units:\n    mov rax, rdx\n    add al, 0x30\n    mov byte [rdi], al\n    inc rdi\nl_exit:\n    pop r14\n    pop rdx\n    pop r13\n    pop r12\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212017,"user_id":null,"body":"global uint32_to_ip\n\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n    push  rdi       ;rdi = *ip\n    push  rsi       ;rsi = num\n\n    mov   rax,rdi\n    push  rax\n\n    ; <byte1.>byte2.byte3.byte4\n    mov   rax,rsi\n    shr   rax,24\n    mov   cl,'.'\n    call  to_dec\n\n    ; byte1.<byte2.>byte3.byte4\n    mov   rax,rsi\n    shr   rax,16\n    call  to_dec\n\n    ; byte1.byte2.<byte3.>byte4\n    mov   rax,rsi\n    shr   rax,8\n    call  to_dec\n    \n    ; byte1.byte2.byte3.<byte4>\n    mov   rax,rsi\n    mov   cl,0        ;end of string\n    call  to_dec\n\n    pop   rax\n\n    pop   rsi\n    pop   rdi\n    ret\n\n;rax = number to convert\n;cl = end char\n;output dec ascii to rdi and increment it\nto_dec:\n    push  rax\n    and   eax,0xff\n    cmp   eax,100\n    jge   .c3\n    cmp   eax,10\n    jge   .c2\n    jmp   .units\n.c3 \n    xor   edx,edx\n    mov   ebx,100\n    div   ebx\n    cmp   eax,0\n    je    .c3b\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n.c3b:\n    mov   eax,edx\n    xor   edx,edx\n    mov   ebx,10\n    div   ebx\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n    mov   eax,edx\n    jmp   .units\n.c2:\n    xor   edx,edx\n    mov   ebx,10\n    div   ebx\n    cmp   eax,0\n    je    .c2b\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n.c2b:\n    mov   eax,edx\n.units:\n    add   al,'0'\n    mov   byte[rdi],al\n    inc   rdi\n    mov   byte[rdi],cl\n    inc   rdi\n    pop   rax\n    ret\n\n; -----> endof uint32_to_ip <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212018,"user_id":null,"body":"global uint32_to_ip\nextern sprintf,printf\nsection .data\nfmt: db '%u.%u.%u.%u',0\nsection .text\n\n; <--- char *uint32_to_ip(char *ip, uint32_t num) --->\nuint32_to_ip:\n    sub     rsp, 4\n    mov     [rsp], dword esi\n    mov     rsi, fmt\n    xor     edx, edx\n    xor     ecx, ecx\n    xor     r8,  r8\n    xor     r9,  r9\n    mov     dl,  byte [rsp+3]\n    mov     cl,  byte [rsp+2]\n    mov     r8b, byte [rsp+1]\n    mov     r9b, byte [rsp]\n    xor     rax,rax\n    call    sprintf\n    add     rsp, 4\n    ret\n; -----> endof uint32_to_ip <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52f787eb172a8b4ae1000a34":[{"id":212019,"user_id":527,"body":"global zeros\nsection .text\n; unsigned long long zeros(unsigned long long num)\nzeros:\n                mov     rsi, 14757395258967641293\n                xor     rcx, rcx\n                mov     rax, rdi\n.loop:          mul     rsi\n                shr     rdx, 2\n                mov     rax, rdx\n                lea     rcx, [rcx + rdx]\n                jnz     .loop\n                mov     rax, rcx\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212020,"user_id":null,"body":"global zeros\n\nsection .text\n\n; <----- unsigned long long zeros(unsigned long long num) ----->\nzeros:\n    xor   rsi, rsi\n    mov   rcx, 1\n    mov   r8, 5\n.loop:\n    mov   rax, rcx\n    mul   r8\n    jo    .end\n    mov   rcx, rax\n    mov   rax, rdi\n    div   rcx\n    add   rsi, rax\n    test  rax, rax\n    jnz   .loop\n.end:\n    mov   rax, rsi\n    ret\n; ---------> end of zeros <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212021,"user_id":null,"body":"global zeros\nsection .text\n\nzeros: ; adapted C\n        xor rsi, rsi\n.loop:\n        mov rax, rdi\n        xor rdx, rdx\n        mov rcx, 5\n        div rcx\n        test rax, rax\n        jz .exit\n        mov rdi, rax\n        add rax, rsi\n        mov rsi, rax ;save\n        jmp .loop\n.exit:\n        mov rax, rsi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212022,"user_id":46,"body":"section .text\nglobal zeros\nzeros:\n    xor rax, rax\n    mov rcx, 5\n    _loop:\n      push rax\n      mov rax, rdi\n      xor rdx, rdx\n      div rcx\n      mov rdi, rax\n      pop rax\n      add rax, rdi\n      cmp rdi, 0\n      jnz _loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212023,"user_id":104,"body":"; 2022 nomennescio\n\n; number of trailing zeroes == number of pairs (2,5) in prime factorization of n!\n; number of factors f of n! : factors = sum (i,1,n\/f,1) + sum (i,n\/f^2,1) + .. = n\/f + n\/f^2 + .. n\/f^(f_log n) \n; number of pairs : min (twos, fives), but twos >= fives, hence : calculate fives\n\nglobal zeros\nsection .text\n\n; <----- unsigned long long zeros (unsigned long long num) ----->\n\n; input: rdi = num (all inputs into: rdi, rsi, rdx, rcx, r8, and r9)\n; callee saved registers: rbx, rsp, rbp, r12-r15\n\n; div 5 == mul 1\/5 (fixed point)\n\nzeros:\n    mov rax, rdi\n    xor rdi, rdi\n    mov rsi, $03333333333333334\nloop:\n    mul rsi\n    mov rax, rdx\n    lea rdi, [rdi+rdx]\n    jc  loop\nend:\n    mov rax, rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212024,"user_id":104,"body":"; 2022 nomennescio\n\n; number of trailing zeroes == number of pairs (2,5) in prime factorization of n!\n; number of factors f of n! : factors = sum (i,1,n\/f,1) + sum (i,n\/f^2,1) + .. = n\/f + n\/f^2 + .. n\/f^(f_log n) \n; number of pairs : min (twos, fives), but twos >= fives, hence : calculate fives\n\nglobal zeros\nsection .text\n\n; <----- unsigned long long zeros (unsigned long long num) ----->\n\n; input: rdi = num (all inputs into: rdi, rsi, rdx, rcx, r8, and r9)\n; callee saved registers: rbx, rsp, rbp, r12-r15\n\n; div r64 : rax=rdx:rax\/r64, rdx=0 before div!\n\nzeros:\n    xor rsi, rsi\n                      ; mov rbx, 5\n    mov rcx, 5\n    mov rax, rdi\nloop:\n    xor rdx, rdx\n    div rcx\n    add rsi, rax\n    test rax, rax\n    jne  loop\nend:\n    mov rax, rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212025,"user_id":104,"body":"; 2022 nomennescio\n\n; number of trailing zeroes == number of pairs (2,5) in prime factorization of n!\n; number of factors f of n! : factors = sum (i,1,n\/f,1) + sum (i,n\/f^2,1) + .. = n\/f + n\/f^2 + .. n\/f^(f_log n) \n; number of pairs : min (twos, fives), but twos >= fives, hence : calculate fives\n\nglobal zeros\nsection .text\n\n; <----- unsigned long long zeros (unsigned long long num) ----->\n\n; input: rdi = num (all inputs into: rdi, rsi, rdx, rcx, r8, and r9)\n; callee saved registers: rbx, rsp, rbp, r12-r15\n\n; div r64 : rax=rdx:rax\/r64, rdx=0 before div!\n\nzeros:\n    xor rsi, rsi\n                      ; mov rbx, 5\n    mov rcx, 5\nloop:\n    mov rax, rdi\n    xor rdx, rdx\n    div rcx\n    add rsi, rax\n    mov rbx, rcx      ;mov rax, rcx\n    lea rcx, [5*rcx]  ;mul rbx\n    cmp rbx, rcx      ;jc end\n    ja  end           ;mov rcx, rax\n    cmp rcx, rdi\n    jb  loop\nend:\n    mov rax, rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212026,"user_id":null,"body":"global zeros\n\nsection .text\n\n; <----- unsigned long long zeros(unsigned long long num) ----->\nzeros:\n    mov rax, rdi\n    xor edi, edi\n    mov ecx, 5\n\n.loop:\n    xor edx, edx\n    div rcx\n    add rdi, rax\n    test rax, rax\n    jnz .loop\n    \n    mov rax, rdi\n    ret\n; ---------> end of zeros <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212027,"user_id":null,"body":"global zeros\n\nsection .text\n\n; <----- unsigned long long zeros(unsigned long long num) ----->\nzeros:\n    cmp     rdi, 5              \n    jb      .ret_0\n    mov     rax, rdi\n    xor     rdx, rdx\n    mov     r8, 5\n    div     r8\n    push    r12           ; result = n\/5\n    mov     r12, rax\n    mov     rdi, rax\n    call    zeros          \n    add     rax, r12      ; result += zeros(result)\n    pop     r12\n    ret\n.ret_0:\n    xor   rax, rax        ; if n < 5\n    ret\n        \n; ---------> end of zeros <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212028,"user_id":null,"body":"global zeros\n\nsection .text\n\n; <----- unsigned long long zeros(unsigned long long num) ----->\nzeros:\n    mov rax, rdi\n    xor rsi, rsi        ; accum\n    mov rcx, 5\n.L1:\n    xor rdx, rdx\n    div rcx\n    add rsi, rax\n    test rax, rax\n    jnz .L1\n    mov rax, rsi\n    ret\n; ---------> end of zeros <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52fba66badcd10859f00097e":[{"id":212029,"user_id":null,"body":"segment .text\nextern strdup\nglobal disemvowel\ndisemvowel:\n   call strdup\n   mov  rdi,rax\n   mov  rsi,rax\n   @b:movsb\n      movzx rcx,byte[rsi-1]  \n      bt    [.vowels],rcx\n      sbb   rdi,0\n      cmp   byte[rsi],0\n   jne @b   \n   mov byte[rdi],0\n ret\n .vowels: dq 0,0020822200208222h","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212030,"user_id":null,"body":"global disemvowel\n\nextern malloc\nextern strcspn\nextern strlen\n\nsegment .text\n\n; char* disemvowel(char* voweled)\ndisemvowel:\n  sub rsp, 40\n  mov QWORD [rsp], rbp\n  mov QWORD [rsp + 8], rbx\n  mov QWORD [rsp + 16], r12\n  \n  ; rbp = voweled\n  mov rbp, rdi\n  \n  ; rbx = malloc(strlen(voweled) + 1)\n  call strlen\n  inc rax\n  mov rdi, rax\n  call malloc\n  mov rbx, rax\n  \n  ; r12 = disemvoweled_end\n  mov r12, rbx\n  \n  ; while (*rbp != '\\0')\n  cmp BYTE [rbp], 0\n  je .loop_end\n  .loop:\n  ; if (strcspn(rbp, vowels) == 0)\n  ;   continue\n  mov al, BYTE [rbp]\n  mov BYTE [rsp + 25], al\n  mov BYTE [rsp + 26], 0\n  lea rdi, [rsp + 25]\n  mov rsi, vowels\n  call strcspn\n  test rax, rax\n  je .loop_continue\n  \n  ; else\n  mov dl, BYTE [rbp]\n  mov BYTE [r12], dl\n  inc r12\n  \n  .loop_continue:\n  inc rbp\n  cmp BYTE [rbp], 0\n  jne .loop\n  .loop_end:\n  \n  ; r12 = '\\0'\n  mov BYTE [r12], 0\n  \n  mov rax, rbx\n  mov r12, QWORD [rsp + 16]\n  mov rbx, QWORD [rsp + 8]\n  mov rbp, QWORD [rsp]\n  add rsp, 40\n  ret\n\nsegment .rodata\nvowels: db \"aeiouAEIOU\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212031,"user_id":null,"body":"segment .text\nextern malloc\nextern strlen\nglobal disemvowel\ndisemvowel:\n  push rdi\n  call strlen\n  mov rdi, rax\n  inc rdi\n  call malloc\n  mov rdi, rax\n  pop rsi\n.loop:\n  mov dl, [rsi]\n  test dl, dl\n  jz .exit\n  inc rsi\n  cmp dl, 'a'\n  je .loop\n  cmp dl, 'e'\n  je .loop\n  cmp dl, 'i'\n  je .loop\n  cmp dl, 'o'\n  je .loop\n  cmp dl, 'u'\n  je .loop\n  cmp dl, 'A'\n  je .loop\n  cmp dl, 'E'\n  je .loop\n  cmp dl, 'I'\n  je .loop\n  cmp dl, 'O'\n  je .loop\n  cmp dl, 'U'\n  je .loop\n  mov [rdi], dl\n  inc rdi\n  jmp .loop\n.exit:\n  mov BYTE [rdi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212032,"user_id":null,"body":"; String to disemvowel will be passed in RDI\n; Return pointer to allocated and freeable string in RAX\nsegment .text\nextern malloc,strlen\nglobal disemvowel\ndisemvowel:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  lea rdi, [rax + 1]\n  call malloc\n  mov rcx, 4575140898685201\n  mov rdx, rax\n.loop:\n  mov sil, byte [rbx]\n  lea edi, [rsi - 65]\n  cmp dil, 52\n  ja .notv\n  movzx edi, dil\n  bt rcx, rdi\n  jae .notv\n.next:\n  inc rbx\n  jmp .loop\n.notv:\n  test sil, sil\n  je .done\n  mov [rdx], sil\n  inc rdx\n  jmp .next\n.done:\n  mov byte [rdx], 0\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212033,"user_id":null,"body":"; String to disemvowel will be passed in RDI\n; Return pointer to allocated and freeable string in RAX\nsegment .text\nextern malloc, strlen\nglobal disemvowel\ndisemvowel:\n  push rdi\n  call strlen\n  lea edi, [rax+1]\n  call malloc\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  \n.loop:\n  mov dl, [rsi]\n  inc rsi\n  test dl, dl\n  jz .done\n  cmp dl, 'A'\n  je .loop\n  cmp dl, 'E'\n  je .loop\n  cmp dl, 'I'\n  je .loop\n  cmp dl, 'O'\n  je .loop\n  cmp dl, 'U'\n  je .loop\n  cmp dl, 'a'\n  je .loop\n  cmp dl, 'e'\n  je .loop\n  cmp dl, 'i'\n  je .loop\n  cmp dl, 'o'\n  je .loop\n  cmp dl, 'u'\n  je .loop\n  mov [rdi], dl\n  inc rdi\n  jmp .loop\n  \n.done:\n  mov [rdi], dl\n.quit:\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212034,"user_id":null,"body":"segment .text\nextern malloc, strlen\nglobal disemvowel\n\ndisemvowel:\n  push rdi\n       \n  call strlen\n       \n  mov rdi, rax\n  call malloc\n\n  pop rdi\n  push rax\n  mov rcx, rax\n \n  mov al, [rdi]\n  test al, al\n\n.loop:\n  cmp al, 'a'\n  je .continue\n \n  cmp al, 'e'\n  je .continue\n \n  cmp al, 'i'\n  je .continue\n \n  cmp al, 'o'\n  je .continue\n \n  cmp al, 'u'\n  je .continue\n \n  cmp al, 'A'\n  je .continue\n \n  cmp al, 'E'\n  je .continue\n \n  cmp al, 'I'\n  je .continue\n \n  cmp al, 'O'\n  je .continue\n \n  cmp al, 'U'\n  je .continue\n\n  mov BYTE [rcx], al\n  inc rcx\n \n.continue:\n  inc rdi\n  mov al, [rdi]\n  test al, al\n  jnz .loop\n \n  mov BYTE [rcx], 0\n\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212035,"user_id":null,"body":"; String to disemvowel will be passed in RDI\n; Return pointer to allocated and freeable string in RAX\nsegment .text\nextern malloc\nglobal disemvowel\ndisemvowel:\n        ; Get the string length so we can malloc a new one.\n        ; This includes the null terminator.\n        mov rsi, rdi\n        xor rdi, rdi\n.loop_strlen:\n            inc rdi\n            cmp byte [rsi + rdi - 1], 0\n            jne .loop_strlen\n\n        push rsi\n        call malloc\n        pop rsi\n\n        ; Copy the string, including the null terminator, but without vowels.\n        mov rdi, rax\n        mov r10, rax\n.loop_copy:\n            lodsb\n            mov ah, al\n            or ah, 0x20 ; Convert uppercase to lowercase for the comparisons.\n            cmp ah, 'e'\n            je .loop_copy_continue\n            cmp ah, 'i'\n            je .loop_copy_continue\n            cmp ah, 'a'\n            je .loop_copy_continue\n            cmp ah, 'o'\n            je .loop_copy_continue\n            cmp ah, 'u'\n            je .loop_copy_continue\n            stosb\n.loop_copy_continue:\n            or al, al\n            jnz .loop_copy\n        mov rax, r10\n\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212036,"user_id":null,"body":"; String to disemvowel will be passed in RDI\n; Return pointer to allocated and freeable string in RAX\nsegment .text\nextern malloc\nglobal disemvowel\n\ndisemvowel:\n.allocate:\n  push rdi\n  mov rdi, 512\n  call malloc\n  pop rdi\n  \n  xor r8, r8\n  xor rdx, rdx\n  \n.loop:\n  mov dl, byte [rdi]\n  cmp dl, 0\n  jz .exit\n  or dl, 0x20\n  cmp dl, 'a'\n  je .cont\n  cmp dl, 'e'\n  je .cont\n  cmp dl, 'i'\n  je .cont\n  cmp dl, 'o'\n  je .cont\n  cmp dl, 'u'\n  je .cont\n  mov dl, byte [rdi]\n  mov byte [rax + r8], dl\n  inc r8\n  \n.cont:\n  inc rdi\n  jmp .loop\n  \n.exit:\n  mov byte [rax + r8], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212037,"user_id":168,"body":"segment .text\nextern strdup\nglobal disemvowel\n\ndisemvowel:\n  push rdi\n  call strdup\n  mov rdi, rax\n  pop rsi\n  mov r8, 0b10000010000010001000100000000000100000100000100010001\n.loop:\n  movzx edx, byte [rsi]\n  inc rsi\n  mov ecx, edx\n  sub ecx, 'A'\n  jb .copy\n  bt r8, rcx\n  jc .continue\n.copy:\n  mov byte [rdi], dl\n  inc rdi\n.continue:\n  test edx, edx\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212038,"user_id":76,"body":"segment .text\nextern malloc, strlen, strchr\nglobal disemvowel\ndisemvowel:\n  push rdi\n  call strlen\n  lea rdi, [rax + 1]\n  call malloc\n  pop rdi\n  mov r9, 0\n.loop:\n  mov r8b, byte [rdi]\n  cmp r8b, 0\n  je .exit\n  push rax\n  push rdi\n  lea rdi, [vowels]\n  mov sil, r8b\n  call strchr\n  pop rdi\n  pop rax\n  jz .continue\n  mov byte [rax + r9], r8b\n  inc r9\n.continue:\n  inc rdi\n  jmp .loop\n.exit:\n  mov byte [rax + r9], 0\n  ret\n  \nsection .data\nvowels: db \"aeiouAEIOU\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"530e15517bc88ac656000716":[{"id":212039,"user_id":null,"body":"global rot13\nextern strdup\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n  push rax\n  call strdup\n  mov r8, rax\n  mov dl, 26\n  mov rsi, rax\n.loop:\n  mov al, [rsi]\n  test al, al\n  je .done\n  lea edi, [rax - 65]\n  mov cl, 65\n  cmp dil, 26\n  jb .cap\n  lea edi, [rax - 97]\n  mov cl, 97\n  cmp dil, 25\n  ja .notletter\n.cap:\n  sub al, cl\n  add al, 13\n  cbw\n  idiv dl\n  movsx eax, ah\n  add al, cl\n  mov [rsi], al\n.notletter:\n  inc rsi\n  jmp .loop\n.done:\n  mov rax, r8\n  pop rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212040,"user_id":null,"body":"global rot13\nextern malloc\n\nsection .text\n\nstrlen:\n    xor rax, rax\n    mov rbx, rdi\n    ltop:\n    cmp BYTE [rbx],0\n    je ernd\n    inc rax\n    inc rbx\n    jmp ltop\n    ernd:\n    inc rax\n    ret\n\nmodif:\n    cmp al, 'A'\n    jl end\n    cmp al, 'z'\n    jg end\n    cmp al, 'Z'\n    jle lrgtag\n    cmp al, 'a'\n    jge smltag\n    end:ret\n    lrgtag:\n    sub al, 13\n    cmp al, 'A'\n    jge end\n    add al, 26\n    jmp end\n    smltag:\n    sub al, 13\n    cmp al, 'a'\n    jge end\n    add al, 26\n    jmp end\n    \n\n; <--- char *rot13(const char *s) --->\nrot13:\n    call strlen\n    push rdi\n    mov rdi, rax\n    call malloc\n    mov rsi, rax\n    mov rdx, rax\n    pop rdi\n    lowp:\n    mov al, BYTE [rdi]\n    call modif\n    mov BYTE [rsi], al\n    cmp BYTE [rdi], 0\n    je ened\n    inc rdi\n    inc rsi\n    jmp lowp\n    ened:\n    mov rax, rdx\n    ret\n; ---------> endof rot13 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212041,"user_id":null,"body":"global rot13\nextern malloc\nextern strlen\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    push rdi\n    call strlen\n    lea rdi, [rax+1]\n    call malloc\n    pop rsi\n    test rax, rax\n    jz .done\n    \n    xor ecx, ecx\n    xor edx, edx\n.loop:\n    mov dl, [rsi+rcx]\n    sub dl, 'A'\n    cmp dl, 26\n    jb .upper\n    sub dl, 32\n    cmp dl, 26\n    jb .lower\n    add dl, 'a'\n.next:\n    mov [rax+rcx], dl\n    inc rcx\n    test dl, dl\n    jz .done\n    jmp .loop\n.upper:\n    add dl, 13\n    cmp dl, 26\n    jb .skip1\n    sub dl, 26\n.skip1:\n    add dl, 'A'\n    jmp .next\n.lower:\n    add dl, 13\n    cmp dl, 26\n    jb .skip2\n    sub dl, 26\n.skip2:\n    add dl, 'a'\n    jmp .next\n    \n.done:\n    ret\n; ---------> endof rot13 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212042,"user_id":null,"body":"global rot13\nextern malloc\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    xor rax, rax          ; RAX <- the result\n    push rdi\n.get_len:\n    cmp byte [rdi], 0\n    je .continue\n    inc rax\n    inc rdi\n    jmp .get_len\n.continue:\n    inc rax\n    mov rdi, rax\n    mov rcx, rax\n    push rcx\n    call malloc\n    mov rdi, rax\n    pop rcx\n    pop rsi\n    push rax\n.crypt:\n    mov al, [rsi]\n    cmp al, 'A'\n    jb .next\n    cmp al, 'Z'\n    jbe .big_letter\n    cmp al, 'a'\n    jb .next\n    cmp al, 'z'\n    jbe .little_letter\n    jmp .next\n.big_letter:\n    add al, 13  \n    cmp al, 'Z'\n    jbe .next\n    sub al, 26\n    jmp .next\n.little_letter:\n    add al, 13\n    cmp al, 'z'\n    jbe .next\n    sub al, 26\n    jmp .next\n.next:\n    mov [rdi], al\n    inc rdi\n    inc rsi\n    loop .crypt\n    pop rax\n    ret\n; ---------> endof rot13 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212043,"user_id":173,"body":"global rot13\nextern malloc\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    ; input buffer\n    mov r12, rdi\n\n    ; compute strlen\n    mov rcx, -1\n    mov rax, 0\n    cld\n    repne scasb\n    sub rax, rcx\n    sub rax, 2\n\n    ; r13 is string length\n    mov r13, rax\n\n    ; malloc\n    mov rdi, r13\n    inc rdi\n    call malloc\n    ; r14 is output buffer\n    mov r14, rax\n    \n    ; rot 13\n    mov rax, 0\n    mov rdx, r12\n    mov rcx, r14\nLOOP:\n    cmp byte [rdx], 'A'\n    jb L_NOTASCII\n    cmp byte [rdx], 'Z'\n    jbe L_U_ASCII\n    cmp byte [rdx], 'a'\n    jb L_NOTASCII\n    cmp byte [rdx], 'z'\n    jbe L_L_ASCII\n    jmp L_NOTASCII\nL_U_ASCII:\n    mov sil, [rdx]\n    mov [rcx], sil\n    add byte [rcx], 13\n    cmp byte [rcx], 'Z'\n    jbe L_NEXT_CHAR\n    sub byte [rcx], 26\n    jmp L_NEXT_CHAR\nL_L_ASCII:\n    mov sil, [rdx]\n    mov [rcx], sil\n    add byte [rcx], 13\n    cmp byte [rcx], 'z'\n    jbe L_NEXT_CHAR\n    sub byte [rcx], 26\n    jmp L_NEXT_CHAR\nL_NOTASCII:\n    ; copy char to output\n    mov sil, [rdx]\n    mov [rcx], sil\nL_NEXT_CHAR:\n    inc rdx\n    inc rcx\n    inc rax\n    \n    cmp rax, r13\n    jb LOOP\n  \n    mov byte [rcx], 0\n\n    mov rax, r14\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212044,"user_id":173,"body":"global rot13\nextern malloc, printf\n\nsection .data\nfmt1: db \"in  %s\", 10, 0\nfmt2: db \"out %s\", 10, 0\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    push rdi\n    push rsi\n    push rcx\n    mov rsi, rdi\n    lea rdi, [rel fmt1]\n    call printf\n    pop rcx\n    pop rsi\n    pop rdi\n    \n    ; input buffer\n    mov r12, rdi\n\n    ; compute strlen\n    mov rcx, -1\n    mov al, 0\n    cld\n    repne scasb\n    sub rax, rcx\n    sub rax, 2\n    \n\n    ; r13 is string length\n    mov r13, rax\n    ; malloc\n    mov rdi, r9\n    call malloc\n    ; r14 is output buffer\n    mov r14, rax\n    \n    \n    ; rot 13\n    mov rax, 0\n    mov rdx, r12\n    mov rcx, r14\nLOOP:\n    cmp byte [rdx], 'A'\n    jb L_NOTASCII\n    cmp byte [rdx], 'Z'\n    jbe L_U_ASCII\n    cmp byte [rdx], 'a'\n    jb L_NOTASCII\n    cmp byte [rdx], 'z'\n    jbe L_L_ASCII\n    jmp L_NOTASCII\nL_U_ASCII:\n    mov sil, [rdx]\n    mov [rcx], sil\n    add byte [rcx], 13\n    cmp byte [rcx], 'Z'\n    jbe L_NEXT_CHAR\n    sub byte [rcx], 26\n    jmp L_NEXT_CHAR\nL_L_ASCII:\n    mov sil, [rdx]\n    mov [rcx], sil\n    add byte [rcx], 13\n    cmp byte [rcx], 'z'\n    jbe L_NEXT_CHAR\n    sub byte [rcx], 26\n    jmp L_NEXT_CHAR\nL_NOTASCII:\n    ; copy char to output\n    mov sil, [rdx]\n    mov [rcx], sil\nL_NEXT_CHAR:\n    inc rdx\n    inc rcx\n    inc rax\n    \n    cmp rax, r13\n    jb LOOP\n    \n    mov byte [rcx], 0\n\n    push rdi\n    push rsi\n    push rcx\n    lea rdi, [rel fmt2]\n    mov rsi, r14\n    call printf\n    pop rcx\n    pop rsi\n    pop rdi\n\n    mov rax, r14\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212045,"user_id":null,"body":"global rot13\nextern malloc\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    ;get length of passed string\n    push  rdi\n    mov   rsi,rdi\n    mov   rcx,0\n.repeat:\n    inc   rcx\n    lodsb\n    cmp   al,0\n    jne   .repeat\n\n    ;allocate a buffer for the result string\n    mov   rdi,rcx\n    call  malloc\n    pop   rdi\n\n    ;rot13\n    mov   rsi,rdi\n    mov   rdi,rax\n    push  rax\n.loop:\n    lodsb\n    cmp   al,'A'\n    jl    .ok\n    cmp   al,'M'\n    jg    .chk_Z\n    add   al,13\n    jmp   .ok\n.chk_Z:\n    cmp   al,'Z'\n    jg    .chk_a\n    sub   al,13\n    jmp   .ok\n.chk_a:\n    cmp   al,'a'\n    jl    .ok\n    cmp   al,'m'\n    jg    .chk_z\n    add   al,13\n    jmp   .ok\n.chk_z:\n    cmp   al,'z'\n    jg    .ok\n    sub   al,13\n.ok:\n    stosb\n    cmp   al,0\n    jne   .loop\n\n    pop   rax\n    ret\n; ---------> endof rot13 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212046,"user_id":null,"body":"global rot13\nextern strdup\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    call strdup\n    \n    mov rdi, rax\n    mov rsi, rax\n    mov cx, 26\n.loop:\n    cmp byte [rdi], 0\n    jz .end\n    cmp byte [rdi], 'A'\n    jl .nextch\n    cmp byte [rdi], 'Z'\n    jle .upper\n    cmp byte [rdi], 'a'\n    jl .nextch\n    cmp byte [rdi], 'z'\n    jg .nextch\n.lower:\n    movzx ax, byte [rdi]\n    sub ax, 'a' - 13\n    mov dx, 0\n    div cx\n    add dx, 'a'\n    mov byte [rdi], dl\n    jmp .nextch\n.upper:\n    movzx ax, byte [rdi]\n    sub ax, 'A' - 13\n    mov dx, 0\n    div cx\n    add dx, 'A'\n    mov byte [rdi], dl\n.nextch:\n    inc rdi\n    jmp .loop\n\n.end:\n    mov rax, rsi\n    ret\n; ---------> endof rot13 <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212047,"user_id":77,"body":"global rot13\nextern malloc\nextern strlen\nextern putchar\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n    push rdi\n    call strlen\n    lea rdi, [rax+1]\n    call malloc\n    mov rcx, rax\n    mov rdi, rax\n    pop rsi\n    cld\n.loop:\n    lodsb\n    cmp al, 65\n    jl .noletter\n    mov dl, al\n    and dl, 0x1f\n    jz .noletter\n    cmp dl, 26\n    jg .noletter\n    add dl, 13\n    cmp dl, 26\n    jbe .nowrap\n    sub dl, 26\n.nowrap:\n    and al, 0xe0\n    or al, dl\n.noletter:\n    stosb\n    test al, al\n    jnz .loop\n    mov rax, rcx\n    ret\n; ---------> endof rot13 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212048,"user_id":null,"body":"global rot13\nextern malloc\n\nsection .text\n\n; <--- char *rot13(const char *s) --->\nrot13:\n        push    r14\n        push    rbx\n        push    rax\n        mov     rbx, rdi\n        xor     eax, eax\n\nget_len:\n        cmp     byte [rbx + rax], 0\n        lea     rax, [rax + 1]\n        jne     get_len\n\nalloc_dest:\n        mov     r14d, eax\n        mov     rdi, r14\n        call    malloc\n\n        xor     ecx, ecx\n        mov     edx, -13\n        jmp     .LBB0_3\n\n.LBB0_4:\n        cmp     sil, 'M'\n.LBB0_7:\n        mov     edi, 13\n        cmovg   edi, edx\n        add     dil, sil\n        mov     esi, edi\n.LBB0_8:\n        mov     byte [rax + rcx], sil\n        add     rcx, 1\n        cmp     r14, rcx\n        je      .LBB0_9\n\n.LBB0_3:\n        movzx   esi, byte [rbx + rcx]\n        lea     edi, [rsi - 'A']\n        cmp     dil, 25\n        jbe     .LBB0_4\n\n        lea     edi, [rsi - 'a']\n        cmp     dil, 25\n        ja      .LBB0_8\n\n        cmp     sil, 109\n        jmp     .LBB0_7\n\n.LBB0_9:\n        add     rsp, 8\n        pop     rbx\n        pop     r14\n        ret\n; ---------> endof rot13 <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53369039d7ab3ac506000467":[{"id":212049,"user_id":null,"body":"section .rodata\nyes: db \"Yes\", 0\nno: db \"No\", 0\n\nsection .text\nglobal bool_to_word\n\nbool_to_word:\n  lea rax, [no]\n  cmp rdi, 0\n  je .end\n  lea rax, [yes]\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212050,"user_id":null,"body":"SECTION .text\nglobal bool_to_word\n@Yes:  db \"Yes\",0\n@No:   db \"No\", 0\nbool_to_word:       lea rax,[@Yes]\n                    lea rdx,[@No]\n                    test rdi,rdi\n                    cmovz rax,rdx\n                    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212051,"user_id":null,"body":"section     .text\nglobal      bool_to_word\n\nbool_to_word:\n    xor         rax, rax\n        \n    cmp         di, 1\n    jge          _yes\n    \n    mov         rax, no\n    ret\n\n_yes:\n    mov         rax, yes\n    ret\n\nsection       .data\n    yes:    db  \"Yes\", 0\n    no:     db  \"No\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212052,"user_id":null,"body":"SECTION .data\n  stryes db 'Yes', 0\n  strno db 'No', 0\n\nSECTION .text\nglobal bool_to_word\n\n ; Returns \"Yes\" if argument is nonzero, \"No\" if argument is 0\nbool_to_word:\n  lea rax, [stryes]\n  test rdi, rdi\n  jnz end\n  lea rax, [strno]\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212053,"user_id":null,"body":"SECTION .text\nglobal bool_to_word\n\nbool_to_word:\n  cmp edi, 1\n  jge YES\n  mov rax, no\n  ret\nYES: \n  mov rax, yes\n  ret\n  \nSECTION .data\nyes db  \"Yes\", 0\nno  db  \"No\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212054,"user_id":null,"body":"SECTION .data\nM_YES db \"Yes\", 0\nYES_LEN db $-M_YES\nM_NO db \"No\", 0\nNO_LEN db $-M_NO\n\nSECTION .text\nglobal bool_to_word\n\n ; Returns \"Yes\" if argument is nonzero, \"No\" if argument is 0\nbool_to_word:\n  xor rax,rax\n  test edi, edi\n  jz return_no\n  \n  mov rax, M_YES\n  ret\n  \n  \nreturn_no:\n  mov rax, M_NO\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212055,"user_id":null,"body":"SECTION .text\nglobal bool_to_word\n\n ; Returns \"Yes\" if argument is nonzero, \"No\" if argument is 0\nbool_to_word:\n  mov eax, edi\n  cmp eax, 0\n  je false\n  mov eax, yes\n  ret\n  false:\n  mov eax, no\n  ret\n  \nsection .data:\n  yes db \"Yes\", 0x00\n  no db \"No\", 0x00","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212056,"user_id":76,"body":"SECTION .text\nglobal bool_to_word\n\n ; Returns \"Yes\" if argument is nonzero, \"No\" if argument is 0\nbool_to_word:\n  lea eax, [no]\n  test di, di\n  jz .done\n  lea eax, [yes]\n.done:\n  ret\n  \nSECTION .data\nyes: db \"Yes\", 0\nno: db \"No\", 0\nBools: db \"No\", 0, 'Yes', 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212057,"user_id":null,"body":"SECTION .text\nglobal bool_to_word\n\n ; Returns \"Yes\" if argument is nonzero, \"No\" if argument is 0\nbool_to_word:\n \txor rax,rax\n\n\tcmp edi, 0  ; If EDI equals 0 (false)\n\tje no       ; Jumps to \"no\" section\n\tcmp edi, 0  ; If EDI not equals 0\n\tjne yes     ; Jumps to \"yes\" section\n\nyes:\n\tmov rax, _yes ; Moves address of \"_yes\" to RAX\n\tjmp exit\nno:\n\tmov rax, _no  ; Moves address of \"_no\" to RAX\n\tjmp exit\nexit:\n \tret\n\n \t_yes:\tdb \"Yes\", 0x0\n \t_no:\tdb \"No\", 0x0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212058,"user_id":null,"body":"section .rodata\nno db 'No', 0\nyes db 'Yes', 0\n\nsection .text\nglobal bool_to_word\n\nbool_to_word:\n  mov rax,no\n  test rdi,rdi\n  jz .exit\n  mov rax,yes\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"534d0a229345375d520006a0":[{"id":212059,"user_id":null,"body":"section .text\nglobal power_of_two\npower_of_two:\n    popcnt rax,rdi\n    dec    rax\n    sete   al\n ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212060,"user_id":527,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(unsigned x)\npower_of_two:\n                blsr    eax, edi\n                jc      .done\n                setz    al\n.done:          ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212061,"user_id":null,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n    bsf eax,edi\n    jz none\n    mov ecx,eax\n    bsr eax,edi\n    cmp eax,ecx\n    mov eax,edi\n    jnz none\n    mov eax,1\n    ret\nnone:\n    xor eax,eax\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212062,"user_id":77,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n    xor rax, rax\n    popcnt rsi, rdi\n    cmp rsi, 1\n    sete al\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212063,"user_id":null,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n    \n    mov rax, 1\n    top:\n    \n    cmp rdi, rax\n    jne fail\n    \n    mov rax, 1\n    ret\n    \n    fail:\n    jbe fail_\n    \n    imul rax, 2\n    jmp top\n    \n    fail_:\n    mov rax, 0\n    ret\n\n    xor eax, eax ; return value\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212064,"user_id":null,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n  xor eax, eax ; return value\n  ; cmp edi, 0\n  ; jz report_success\n  popcnt eax, edi\n  cmp eax, 1\n  jz report_success\n  mov eax, 0\n  ret\n    \nreport_success:\n  mov eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212065,"user_id":null,"body":"section .text\nglobal power_of_two\n\npower_of_two:\n  popcnt rax,rdi\n  cmp rax,1\n  sete al\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212066,"user_id":null,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n  popcnt eax, edi\n  cmp eax, 1\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212067,"user_id":null,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n    xor rax, rax ; return value\n    mov rcx,32\n    mov rsi,1\n    mov ebx,1\nck:\n    cmp ebx,edi\n    cmove eax,esi\n    shl ebx,1\n    loop ck\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212068,"user_id":null,"body":"section .text\nglobal power_of_two\n\n; bool power_of_two(const unsigned int x (edi))\npower_of_two:\n    xor eax, eax\n    xor edx, edx\n    mov eax, edi\n    mov ecx, 2\n    mov ebx, 1\n    \n    cmp eax, ebx\n    je power\n    jng no_power\n    jmp division\n    \n    division:\n    div ecx\n\n\n    cmp edx, ebx\n    je no_power\n    jmp tes\n    \n    tes:\n   \n    cmp eax, ebx\n    je power\n    jmp division\n    \n    power:\n    mov eax, 1\n    ret\n    no_power:\n    mov eax, 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"534ea96ebb17181947000ada":[{"id":212069,"user_id":77,"body":"global breaking_chocolate\n\n; uint32_t breaking_chocolate(uint32_t n, uint32_t m);\nbreaking_chocolate:\n  mov eax, edi\n  mul esi\n  test eax, eax\n  jz .end\n  dec eax\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212070,"user_id":null,"body":"global breaking_chocolate\n; uint32_t breaking_chocolate(uint32_t n, uint32_t m);\nbreaking_chocolate:\n  mov rax, rdi\n  mul rsi\n  cmp rax, 0\n  jg d\n  ret\nd:\n  sub rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212071,"user_id":null,"body":"global breaking_chocolate\n\n; [eax] uint32_t breaking_chocolate([edi] uint32_t n, [esi] uint32_t m);\nbreaking_chocolate:\n  mov  eax, esi\n  imul  eax, edi\n  dec  eax\n  js   _nagative\n  jmp  _finish\n_nagative:\n  mov  eax, 0\n_finish:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212072,"user_id":null,"body":"global breaking_chocolate\n\nbreaking_chocolate:\n  mov rax,rdi\n  mul rsi\n  cmp rax,0\n  je end\n  dec rax\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212073,"user_id":null,"body":"global breaking_chocolate\n\n; uint32_t breaking_chocolate(uint32_t n, uint32_t m);\nbreaking_chocolate:\n  mov eax, esi\n  imul eax, edi\n  dec eax\n  test esi, esi\n  cmove eax, esi\n  test edi, edi\n  cmove eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212074,"user_id":null,"body":"global breaking_chocolate\n; uint32_t breaking_chocolate(uint32_t n, uint32_t m);\nbreaking_chocolate:\n  xor eax, eax\n  cmp rdi, 0\n  jg d\n  ret\nd:\n  cmp rsi, 0\n  jg s\n  ret\ns:\n  cmp rdi, rsi\n  jg g\n  xor rdi, rsi\n  xor rsi, rdi\n  xor rdi, rsi\ng:\n  mov rax, rsi\n  dec rdi\n  mul rdi\n  dec rsi\n  add rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212075,"user_id":null,"body":"global breaking_chocolate\n\nbreaking_chocolate:\n\tmov eax, edi\n\tmul esi\n\ttest eax, eax\n\tjz return\n\tdec eax\nreturn:\n\tret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212076,"user_id":null,"body":"global breaking_chocolate\n\nbreaking_chocolate:\n\tmov eax, edi\n\tmul esi\n\tcmp eax, 0\n\tjz return\n\tdec eax\nreturn:\n\tret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212077,"user_id":null,"body":"global breaking_chocolate\n\n; uint32_t breaking_chocolate(uint32_t n, uint32_t m);\nbreaking_chocolate:\n  test rdi, rdi\n  jz .zero\n  test rsi, rsi\n  jz .zero\n\n  cmp rdi, rsi\n  jge .ch\n.beg:\n  xor eax, eax\n  mov eax, edi\n  dec rsi\n  mul esi\n  add eax, edi\n  dec eax\n  ret\n.zero:\n  xor eax, eax\n  ret\n.ch:\n  xor rdi, rsi\n  xor rsi, rdi\n  xor rdi, rsi\n  jmp .beg\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212078,"user_id":null,"body":"global breaking_chocolate\n\nbreaking_chocolate:\n  mul rsi\n  dec rax\n  cmovl rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53697be005f803751e0015aa":[{"id":212079,"user_id":null,"body":"global encode, decode\nextern strdup\nencode:\ndecode:\n  call strdup\n  mov  rdi,rax\n  .b:movzx r8,byte[rdi]\n     mov   r8b,[keytable+r8]\n     mov   [rdi],r8b\n     inc   rdi\n     cmp   byte[rdi],0\n  jne .b   \nret\nkeytable dq 0x0706050403020100,0x0F0E0D0C0B0A0908,0x1716151413121110,0x1F1E1D1C1B1A1918,\\\n            0x2726252423222120,0x2F2E2D2C2B2A2928,0x3736756F69656130,0x3F3E3D3C3B3A3938,\\\n            0x4746454443424140,0x4F4E4D4C4B4A4948,0x5756555453525150,0x5F5E5D5C5B5A5958,\\\n            0x6766326463623160,0x346E6D6C6B6A3368,0x7776357473727170,0x7F7E7D7C7B7A7978,\\\n            0x8786858483828180,0x8F8E8D8C8B8A8988,0x9796959493929190,0x9F199D9C9B9A9998,\\\n            0xA7A6A5A4A3A2A1A0,0xAFAEADACABAAA9A8,0xB7B6B5B4B3B2B1B0,0xBFBEBDBCBBBAB9B8,\\\n            0xC7C6C5C4C3C2C1C0,0xCFCECDCCCBCAC9C8,0xD7D6D5D4D3D2D1D0,0xDFDEDDDCDBDAD9D8,\\\n            0xE7E6E5E4E3E2E1E0,0xEFEEEDECEBEAE9E8,0xF7F6F5F4F3F2F1F0,0xFFFEFDFCFBFAF9F8","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212080,"user_id":null,"body":"section .text\nglobal encode, decode\nextern strlen, malloc\n\n; r12 points to a map function\nstr_map:\n    call strlen\n    inc rax ; for \\0 symbol\n\n    push rax\n    push rdi\n\n    mov rdi, rax\n    call malloc\n    mov rdi, rax\n\n    pop rsi\n    pop rcx\n\n.loop:\n    mov al, byte [rsi + rcx - 1]\n    call r12 ; call map function\n    mov byte [rdi + rcx - 1], al\nloop .loop\n\n    mov rax, rdi\n    ret\n\n\nencode:\n    mov r12, encode_letter\n    call str_map\n    ret\n\ndecode:\n    mov r12, decode_letter\n    call str_map\n    ret\n\n\n%macro char_map 2\n    cmp al, %1\n    mov r10b, %2\n    cmove ax, r10w\n%endmacro\n\nencode_letter:\n    char_map 'a', '1'\n    char_map 'e', '2'\n    char_map 'i', '3'\n    char_map 'o', '4'\n    char_map 'u', '5'\n\n    ret\n\ndecode_letter:\n    char_map '1', 'a'\n    char_map '2', 'e'\n    char_map '3', 'i'\n    char_map '4', 'o'\n    char_map '5', 'u'\n\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212081,"user_id":null,"body":"section .text\nglobal encode, decode\nextern strlen, malloc\n\n\nvowels:   db    'aeiou'\n\n; <-- [byte RAX] encode(readonly [byte RDI] s) -->\nencode:\n    push  rdi\n    call  strlen\n    mov   rdi, rax\n    add   rdi, 1\n    call  malloc\n    pop   rdi\n    mov   rcx, -1\n    mov   rsi, vowels\n.loop:\n    inc   rcx\n    mov   dl, [rdi+rcx]\n    mov   r8, 5\n.l: dec   r8\n    js  .n\n    cmp   dl, [rsi+r8]\n    jne   .l\n    lea   rdx, [r8+'1']\n.n: mov   [rax+rcx], dl\n    test  dl, dl\n    jnz   .loop\n    ret\n; ---> endof encode <---\n\n; <-- [byte RAX] decode(readonly [byte RDI] s) -->\ndecode:\n    push  rdi\n    call  strlen\n    mov   rdi, rax\n    add   rdi, 1\n    call  malloc\n    pop   rdi\n    xor   rcx, rcx\n    xor   rdx, rdx\n    mov   rsi, vowels\n.loop:\n    mov   dl, [rdi+rcx]\n    cmp   dl, '1'\n    jl    .n\n    cmp   dl, '5'\n    jg    .n\n    mov   dl, [rsi+rdx-'1']\n.n: mov   [rax+rcx], dl\n    inc   rcx\n    test  dl, dl\n    jnz   .loop\n    ret\n; ---> endof decode <---","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212082,"user_id":null,"body":"section .text\nglobal encode, decode\nextern strdup\n\nencode:\n        call    strdup\n        mov     rdx, rax\n.loop:\n        mov     cl, BYTE [rdx]\n        test    cl, cl\n        je      .exit\n        cmp     cl, 'a'\n        je      .a\n        cmp     cl, 'e'\n        je      .e\n        cmp     cl, 'i'\n        je      .i\n        cmp     cl, 'o'\n        je      .o\n        cmp     cl, 'u'\n        je      .u\n        jmp     .next\n.a:\n        mov     BYTE [rdx], '1'\n        jmp     .next\n.e:\n        mov     BYTE [rdx], '2'\n        jmp     .next\n.i:\n        mov     BYTE [rdx], '3'\n        jmp     .next\n.o:\n        mov     BYTE [rdx], '4'\n        jmp     .next\n.u:\n        mov     BYTE [rdx], '5'\n.next:\n        inc     rdx\n        jmp     .loop\n.exit:\n        ret\n        \ndecode:\n        call    strdup\n        mov     rdx, rax\n.loop:\n        mov     cl, BYTE [rdx]\n        test    cl, cl\n        je      .exit\n        cmp     cl, '1'\n        je      .a\n        cmp     cl, '2'\n        je      .e\n        cmp     cl, '3'\n        je      .i\n        cmp     cl, '4'\n        je      .o\n        cmp     cl, '5'\n        je      .u\n        jmp     .next\n.a:\n        mov     BYTE [rdx], 'a'\n        jmp     .next\n.e:\n        mov     BYTE [rdx], 'e'\n        jmp     .next\n.i:\n        mov     BYTE [rdx], 'i'\n        jmp     .next\n.o:\n        mov     BYTE [rdx], 'o'\n        jmp     .next\n.u:\n        mov     BYTE [rdx], 'u'\n.next:\n        inc     rdx\n        jmp     .loop\n.exit:\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212083,"user_id":null,"body":"section .text\nglobal encode, decode\nextern strlen, malloc\n\nencode:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  call strlen\n  lea rdi, [rax + 1]\n  mov rbx, rax\n  call malloc\n  xor ecx, ecx\n.loop:\n  cmp rbx, rcx\n  je .done\n  movsx rdx, byte [r14 + rcx]\n  mov dl, byte [rdx + .table-32]\n  mov byte [rax + rcx], dl\n  inc rcx\n  jmp .loop\n.done:\n  mov byte [rax + rbx], 0\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret\n.table: db ` !\"#$%&'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\\`1bcd2fgh3jklmn4pqrst5vwxyz{|}~`\n  \ndecode:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  call strlen\n  lea rdi, [rax + 1]\n  mov rbx, rax\n  call malloc\n  xor ecx, ecx\n.loop:\n  cmp rbx, rcx\n  je .done\n  movsx rdx, byte [r14 + rcx]\n  mov dl, byte [rdx + .table-32]\n  mov byte [rax + rcx], dl\n  inc rcx\n  jmp .loop\n.done:\n  mov byte [rax + rbx], 0\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret\n.table: db ` !\"#$%&'()*+,-.\/0aeiou6789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\\`abcdefghijklmnopqrstuvwxyz{|}~`","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212084,"user_id":null,"body":"section .data\ntable db 'a', 'e', 'i', 'o', 'u' \nsection .text\nglobal encode, decode\nextern strlen, malloc\n\n; <-- [byte RAX] encode(readonly [byte RDI] s) -->\nencode:\n    ; edi != null \n    test rdi, rdi\n    jz   .fin\n    \n    push rdi\n    call strlen\n    mov  rdi, rax\n    inc  rdi\n    call malloc\n    mov  rsi, rax\n    xor  rax, rax\n    ;[edi] != 0\n    pop  rdi\n    \n    mov  rcx, rdi\n    mov  al, [rcx]\n    test al, al\n    jz   .fin\n    \n  .loop:\n    mov  rdx, '0'\n    cmp  al, 'a'\n    je   .L1\n    cmp  al, 'e'\n    je   .L2\n    cmp  al, 'i'\n    je   .L3\n    cmp  al, 'o'\n    je   .L4\n    cmp  al, 'u'\n    jne  .L0\n    inc  rdx\n  .L4:\n    inc  rdx\n  .L3:\n    inc  rdx\n  .L2:\n    inc  rdx\n  .L1:\n    inc  rdx\n    mov  rax, rdx\n  .L0:\n    mov  [rsi], al\n    inc  rsi\n    inc  rcx\n    mov  al, [rcx]\n    test al, al\n    jnz  .loop\n  .fin:\n    mov [rsi], byte 0\n    sub rdi, rcx\n    lea rax, [rsi + rdi]        ; [byte RAX] <- the result\n    ret\n; ---> endof encode <---\n\n; <-- [byte RAX] decode(readonly [byte RDI] s) -->\ndecode:\n    ; edi != null [edi] != 0\n    test rdi, rdi\n    jz   .fin\n    \n    push rdi\n    call strlen\n    mov  rdi, rax\n    inc  rdi\n    call malloc\n    mov  rsi, rax\n    xor  rax, rax\n    ;[edi] != 0\n    pop  rdi\n    \n    mov  rcx, rdi\n    mov  al, [rcx]\n    test al, al\n    jz   .fin\n  .loop:\n    mov rdx, rax\n    sub rdx, '1'\n    cmp rdx, 5\n    jnb  .L0\n    mov al, [table + rdx]\n  .L0:\n    mov [rsi], al\n    inc rsi\n    inc rcx\n    mov al, [rcx]\n    test al, al\n    jnz .loop\n  .fin:\n    mov [rsi], byte 0\n    sub rdi, rcx\n    lea rax, [rsi + rdi]        ; [byte RAX] <- the result\n    ret\n; ---> endof decode <---","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212085,"user_id":null,"body":"section .text\nglobal encode, decode\nextern strdup\n\n; <-- [byte RAX] encode(readonly [byte RDI] s) -->\nencode:\n  push rdi\n  call strdup\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  mov rdx, rax\n  \n.loop:\n  lodsb\n  cmp al, 'a'\n  jne .skip1\n  mov al, '1'\n.skip1:\n  cmp al, 'e'\n  jne .skip2\n  mov al, '2'\n.skip2:\n  cmp al, 'i'\n  jne .skip3\n  mov al, '3'\n.skip3:\n  cmp al, 'o'\n  jne .skip4\n  mov al, '4'\n.skip4:\n  cmp al, 'u'\n  jne .skip5\n  mov al, '5'\n.skip5:\n  stosb\n  test al, al\n  jnz .loop\n  \n  mov rax, rdx\n.quit:\n  ret\n; ---> endof encode <---\n\n; <-- [byte RAX] decode(readonly [byte RDI] s) -->\ndecode:\n  push rdi\n  call strdup\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  mov rdx, rax\n  \n.loop:\n  lodsb\n  cmp al, '1'\n  jne .skip1\n  mov al, 'a'\n.skip1:\n  cmp al, '2'\n  jne .skip2\n  mov al, 'e'\n.skip2:\n  cmp al, '3'\n  jne .skip3\n  mov al, 'i'\n.skip3:\n  cmp al, '4'\n  jne .skip4\n  mov al, 'o'\n.skip4:\n  cmp al, '5'\n  jne .skip5\n  mov al, 'u'\n.skip5:\n  stosb\n  test al, al\n  jnz .loop\n  \n  mov rax, rdx\n.quit:\n  ret\n; ---> endof decode <---","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212086,"user_id":460,"body":"section .data\n  vowels db \"aeiou\"\n  numbers db \"12345\"\n  encode_table_count equ $-numbers\nsection .text\nglobal encode, decode\nextern strlen, malloc\n\n; <-- [byte RAX] encode(readonly [byte RDI] s) -->\nencode:\n  mov rsi, vowels\n  mov rdx, numbers\n  jmp encoder\ndecode:\n  mov rsi, numbers\n  mov rdx, vowels\n  jmp encoder\n\nencoder:\n  mov r8, rdi\n  push rsi\n  push rdx\n  push r8\n\n  call strlen\n  mov r10, rax\n  inc r10\n\n  push r10\n  mov rdi, r10\n  call malloc\n  mov r9, rax\n\n  pop r10\n  pop r8\n  pop rdx\n  pop rsi\n  \n  xor rax, rax\n  xor rcx, rcx\n.char_loop:\n  dec r10\n  xor rax, rax\n  mov al, byte [r8+r10]\n  mov rcx, encode_table_count\n\n.char_search_loop:\n  dec rcx\n  cmp al, byte [rsi+rcx]\n  je .char_found\n  cmp rcx, 0\n  jne .char_search_loop\n\n  mov byte [r9+r10], al ; set non-vowel char\n  jmp .char_not_found\n.char_found:\n  xor rax, rax\n  mov al, byte [rdx+rcx]\n  mov byte [r9+r10], al\n.char_not_found\n  cmp r10, 0\n  je .done\n  jmp .char_loop\n  \n.done:\n  mov rax, r9\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212087,"user_id":null,"body":"section .text\nglobal encode, decode\nextern strdup\n\n; <-- [byte RAX] encode(readonly [byte RDI] s) -->\nencode:\n  call strdup\n  mov rdi, rax\n  mov dl, [rdi]\n\n.loop:\n  cmp dl, 'a'\n  je .a\n \n  cmp dl, 'e'\n  je .e\n \n  cmp dl, 'i'\n  je .i\n \n  cmp dl, 'o'\n  je .o\n \n  cmp dl, 'u'\n  je .u\n\n  jmp .continue\n \n.a:\n  mov BYTE [rdi], '1'\n  jmp .continue\n\n.e:\n  mov BYTE [rdi], '2'\n  jmp .continue\n\n.i:\n  mov BYTE [rdi], '3'\n  jmp .continue\n\n.o:\n  mov BYTE [rdi], '4'\n  jmp .continue\n\n.u:\n  mov BYTE [rdi], '5'\n  jmp .continue\n\n.continue:\n  inc rdi\n  mov dl, [rdi]\n  cmp dl, 0\n  jne .loop\n\n  ret\n; ---> endof encode <---\n\n; <-- [byte RAX] decode(readonly [byte RDI] s) -->\ndecode:\n  call strdup\n  mov rdi, rax\n  mov dl, [rdi]\n\n.loop:\n  cmp dl, '1'\n  je .a\n \n  cmp dl, '2'\n  je .e\n \n  cmp dl, '3'\n  je .i\n \n  cmp dl, '4'\n  je .o\n \n  cmp dl, '5'\n  je .u\n\n  jmp .continue\n \n.a:\n  mov BYTE [rdi], 'a'\n  jmp .continue\n\n.e:\n  mov BYTE [rdi], 'e'\n  jmp .continue\n\n.i:\n  mov BYTE [rdi], 'i'\n  jmp .continue\n\n.o:\n  mov BYTE [rdi], 'o'\n  jmp .continue\n\n.u:\n  mov BYTE [rdi], 'u'\n  jmp .continue\n\n.continue:\n  inc rdi\n  mov dl, [rdi]\n  cmp dl, 0\n  jne .loop\n\n  ret\n; ---> endof decode <---","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212088,"user_id":null,"body":"section .data\nvlook db 'aeiouy'\ndlook db '123456'\n\nsection .text\nglobal encode, decode\nextern strlen, malloc\n\n; <-- [byte RAX] encode(readonly [byte RDI] s) -->\nencode:\n    xor   rax, rax\n    push  rdi\n    call  strlen\n    add   rax, 100\n    mov   rdi, rax\n    call  malloc\n    pop   rdi\n    push  rax\n    \n    .loop:\n    xor   rbx, rbx\n    cmp   [rdi], byte 'a'\n    je   .a\n    cmp   [rdi], byte 'e'\n    je   .e\n    cmp   [rdi], byte 'i'\n    je    .i\n    cmp   [rdi], byte 'o'\n    je    .o\n    cmp   [rdi], byte 'u'\n    je    .u\n    movzx rbx, byte [rdi]\n    mov   [rax], rbx    \n    jmp   .next\n    \n    .a:\n    mov bl, '1'\n    mov [rax], rbx\n    jmp   .next\n    .e:\n    mov bl, '2'\n    mov [rax], rbx\n    jmp   .next\n    .i:\n    mov bl, '3'\n    mov [rax], rbx\n    jmp   .next\n    .o:\n    mov bl, '4'\n    mov [rax], rbx\n    jmp   .next\n    .u:\n    mov bl, '5'\n    mov [rax], rbx\n\n    .next:\n    inc   rdi\n    inc   rax\n    cmp   [rdi], byte 0\n    jne   .loop\n    mov   [rax], byte 0\n    pop   rax\n    ret\n; ---> endof encode <---\n\n; <-- [byte RAX] decode(readonly [byte RDI] s) -->\ndecode:\n    xor   rax, rax\n    push  rdi\n    call  strlen\n    add   rax, 100\n    mov   rdi, rax\n    call  malloc\n    pop   rdi\n    push  rax\n    \n    .loop:\n    xor   rbx, rbx\n    cmp   [rdi], byte '1'\n    je   .a\n    cmp   [rdi], byte '2'\n    je   .e\n    cmp   [rdi], byte '3'\n    je    .i\n    cmp   [rdi], byte '4'\n    je    .o\n    cmp   [rdi], byte '5'\n    je    .u\n    movzx rbx, byte [rdi]\n    mov   [rax], rbx    \n    jmp   .next\n    \n    .a:\n    mov bl, 'a'\n    mov [rax], rbx\n    jmp   .next\n    .e:\n    mov bl, 'e'\n    mov [rax], rbx\n    jmp   .next\n    .i:\n    mov bl, 'i'\n    mov [rax], rbx\n    jmp   .next\n    .o:\n    mov bl, 'o'\n    mov [rax], rbx\n    jmp   .next\n    .u:\n    mov bl, 'u'\n    mov [rax], rbx\n\n    .next:\n    inc   rdi\n    inc   rax\n    cmp   [rdi], byte 0\n    jne   .loop\n    mov   [rax], byte 0\n    pop   rax\n    ret\n; ---> endof decode <---","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"538948d4daea7dc4d200023f":[{"id":212089,"user_id":null,"body":"section .text\nglobal convert_bits\nconvert_bits:\n  xor    rdi,rsi\n  popcnt rax,rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212090,"user_id":1027,"body":"section .text\nglobal convert_bits\nconvert_bits:\n  xor edi,esi\n  popcnt eax,edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212091,"user_id":527,"body":"section .text\nglobal convert_bits\n\n; unsigned convert_bits(unsigned edi, unsigned esi)\nconvert_bits:\n                xor     edi, esi\n                popcnt  eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212092,"user_id":881,"body":"section .text\nglobal convert_bits\n\n; unsigned int convert_bits(unsigned int edi, unsigned int esi)\nconvert_bits:\n    xor esi, edi\n    popcnt eax, esi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212093,"user_id":168,"body":"section .text\nglobal convert_bits\n\n; unsigned int convert_bits(unsigned int esi, unsigned int edi)\nconvert_bits:\n  xor edi, esi\n  popcnt eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212094,"user_id":null,"body":"global convert_bits\n\n; <--- unsigned int convert_bits(EDI a, ESI b) --->\nconvert_bits:  dq  5.63357437954631243500460151396E-305","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212095,"user_id":null,"body":"section .text\nglobal convert_bits\n\n; unsigned int convert_bits(unsigned int edi, unsigned int esi)\nconvert_bits:\n    xor eax, eax\n    xor edi, esi\n    popcnt eax, edi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212096,"user_id":null,"body":"section .text\nglobal convert_bits\n\n; unsigned int convert_bits(unsigned int edi, unsigned int esi)\nconvert_bits:\n  xor edi, esi\n  popcnt eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212097,"user_id":50,"body":"section .text\nglobal convert_bits\n\n; unsigned int convert_bits(unsigned int edi, unsigned int esi)\nconvert_bits:\n    xor eax, eax ; <- return value\n    xor rdi,rsi\n    popcnt eax,edi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212098,"user_id":null,"body":"section .text\nglobal convert_bits\n\n; unsigned int convert_bits(unsigned int edi, unsigned int esi)\nconvert_bits:\n    xor   rax, rax    ; count in rax the bits\n    xor   rdi, rsi    ; rdi = the different bits\n.next:                ; loop over all non-zero bit\n    shr   rdi, 1      ; shift LSB into carry flag\n    jnc   .no\n    inc   rax         ; add non zero bit\n.no:    \n    test  rdi, rdi\n    jnz   .next       ; loop over all 1 bits\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53a1eac7e0afd3ad3300008b":[{"id":212099,"user_id":null,"body":"global F\nglobal M\nF:mov esi,1\n  jmp calc\nM:xor esi,esi\ncalc:\n  test rdi,rdi\n  je .f\n    push rdi\n    push rsi\n    dec  rdi\n    call calc\n    pop  rsi\n    mov  rdi,rax    \n    xor  esi,1\n    call calc\n    sub  qword[rsp],rax\n    pop  rax\n    ret\n  .f:\n  mov rax,rsi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212100,"user_id":null,"body":"global F\nglobal M\nsection .text\n; input: edi = n\n; output: eax\nF:\n  mov eax, 1\n  cmp edi,0\n  je .end\n  xor eax,eax\n  mov edx,edi\n  push rdx\n  dec edi\n  call F\n  mov edi,eax\n  call M\n  pop rdx\n  sub rdx,rax\n  mov rax,rdx\n  .end:\n  ret\nM:\n  mov eax, 0\n  cmp edi,0\n  je .end\n  mov edx,edi\n  push rdx\n  dec edi\n  call M\n  mov edi,eax\n  call F\n  pop rdx\n  sub rdx,rax\n  mov rax,rdx\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212101,"user_id":null,"body":"global F\nglobal M\nextern malloc,realloc\nsection .text\n\ninit:\n  push rbx\n  mov rbx, [len]\n  shl rbx, 2\n  mov rdi, rbx\n  call malloc\n  and dword [rax], 0\n  mov rdi, rbx\n  mov [mmemo], rax\n  call malloc\n  mov [fmemo], rax\n  mov dword [rax], 1\n  pop rbx\n  ret\n  \nGrowToN:\n  push r14\n  push rbx\n  push rax\n  movsxd r14, edi\n  cmp [len], r14\n  jbe .resize\n  mov rbx, [fmemo]\n  mov rax, [mmemo]\n  jmp .fill\n.resize:\n  mov ecx, 1024\n  add edi, ecx\n  mov eax, edi\n  cdq\n  idiv ecx\n  mov rdi, [fmemo]\n  shl eax, 10\n  movsxd rsi, eax\n  mov [len], rsi\n  shl rsi, 2\n  call realloc\n  mov rsi, [len]\n  mov rdi, rax\n  mov rbx, rax\n  mov [fmemo], rax\n  shl rsi, 2\n  call realloc\n  mov [mmemo], rax\n.fill:\n  mov rcx, [memmax]\n.fillloop:\n  inc rcx\n  cmp rcx, r14\n  ja .filled\n  movsxd rdx, dword [rax + 4*rcx - 4]\n  mov esi, ecx\n  sub esi, [rbx + 4*rdx]\n  mov [rax + 4*rcx], esi\n  mov esi, ecx\n  movsxd rdx, dword [rbx + 4*rcx - 4]\n  mov edx, [rax + 4*rdx]\n  sub esi, edx\n  mov [rbx + 4*rcx], esi\n  jmp .fillloop\n.filled:\n  mov qword [memmax], r14\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret\n  \nF:\n  push rbp\n  push rbx\n  push rax\n  cmp qword [fmemo], 0\n  mov ebp, edi\n  jne .skipinitf\n  call init\n.skipinitf:\n  movsxd rbx, ebp\n  cmp [memmax], rbx\n  jae .memof\n  mov edi, ebp\n  call GrowToN\n.memof:\n  mov rax, [fmemo]\n  mov eax, [rax + 4*rbx]\n  add rsp, 8\n  pop rbx\n  pop rbp\n  ret\n  \nM:\n  push rbp\n  push rbx\n  push rax\n  cmp qword [mmemo], 0\n  mov ebp, edi\n  jne .skipinitm\n  call init\n.skipinitm:\n  movsxd rbx, ebp\n  cmp [memmax], rbx\n  jae .memom\n  mov edi, ebp\n  call GrowToN\n.memom:\n  mov rax, [mmemo]\n  mov eax, [rax + 4*rbx]\n  add rsp, 8\n  pop rbx\n  pop rbp\n  ret\n\nsection .data\nlen: dq 1024\nmemmax: dq 0\nfmemo: dq 0\nmmemo: dq 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212102,"user_id":null,"body":"global F\nglobal M\nsection .text\n; input: edi = n\n; output: eax\nF:\n  test edi, edi\n  jnz .work\n  mov eax, 1        ; eax = F(0) = 1\n  ret\n.work:\n  push rdi          ; save n\n  dec edi           ; edi = n-1\n  call F\n  mov edi, eax      ; edi = F(n-1)\n  call M\n  mov ebx, eax      ; ebx = M(F(n-1))\n  pop rax           ; rax = n\n  sub eax, ebx\n  ret\n\nM:\n  test edi, edi\n  jnz .work\n  xor eax, eax      ; eax = M(0) = 0\n  ret\n.work:\n  push rdi          ; save n\n  dec edi           ; edi = n-1\n  call M        \n  mov edi, eax      ; edi = M(n-1)\n  call F\n  mov ebx, eax      ; ebx = F(M(n-1))\n  pop rax           ; rax = n\n  sub eax, ebx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212103,"user_id":881,"body":"section .text\nglobal F, M\n\nF:\n    mov esi, 1\n    jmp M.F\nM:\n    xor esi, esi\n.F:\n    mov eax, esi\n    test edi, edi\n    jz .done\n    push rdi\n    dec edi\n    call M.F\n    mov edi, eax\n    xor esi, 1\n    call M.F\n    xor esi, 1\n    pop rdi\n    neg eax\n    add eax, edi\n.done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212104,"user_id":null,"body":"global F\nglobal M\nsection .text\n; input: edi = n\n; output: eax\nF:\n  push rbx\n  mov eax, 1\n  test edi, edi\n  jz .return\n  mov ebx, edi\n  dec edi\n  call F\n  mov edi, eax\n  call M\n  sub ebx, eax\n  mov eax, ebx\n.return:\n  pop rbx\n  ret\n\nM:\n  push rbx\n  xor eax, eax\n  test edi, edi\n  jz .return\n  mov ebx, edi\n  dec edi\n  call M\n  mov edi, eax\n  call F\n  sub ebx, eax\n  mov eax, ebx\n.return:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212105,"user_id":null,"body":"global F\nglobal M\nsection .text\n\nF:\n  test edi, edi\n  jz .zero\n \n  push rdi\n \n  dec edi\n  call F\n \n  mov edi, eax\n  call M\n \n  pop rdi\n\n  sub edi, eax\n  mov eax, edi\n  jmp .return\n \n.zero:\n  mov eax, 1\n\n.return:\n  ret\n \nM:\n  test edi, edi\n  jz .zero\n\n  push rdi\n \n  dec edi\n  call M\n \n  mov edi, eax\n  call F\n \n  pop rdi\n\n  sub edi, eax\n  mov eax, edi\n  jmp .return\n\n.zero:\n  xor eax, eax\n\n.return:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212106,"user_id":null,"body":"global F\nglobal M\nsection .text\n\nF:\n  cmp rdi, 0\n  je .zero\n  push rdi\n  sub rdi, 1\n  call F\n  mov rdi, rax\n  call M\n  pop rdi\n  sub rdi, rax\n  mov rax, rdi\n  ret\n.zero:\n  mov rax, 1\n  ret\n  \nM:\n  cmp rdi, 0\n  je .zero\n  push rdi\n  sub rdi, 1\n  call M\n  mov rdi, rax\n  call F\n  pop rdi\n  sub rdi, rax\n  mov rax, rdi\n  ret\n.zero:\n  mov rax, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212107,"user_id":null,"body":"global F\nglobal M\nsection .text\n; input: edi = n\n; output: eax\nF:\n  push rbp\n  mov rbp, rsp\n  \n  cmp edi, 0\n  jz .terminal\n  \n  push rdi\n  dec edi\n  call F\n\n  mov edi, eax\n  call M\n  \n  pop rdi\n  sub edi, eax\n  mov eax, edi\n  \n.exit:\n  pop rbp\n  ret\n  \n.terminal:\n  mov eax, 1\n  jmp .exit\n  \nM:\n  push rbp\n  mov rbp, rsp\n  \n  cmp edi, 0\n  jz .terminal\n  \n  push rdi\n  dec edi\n  call M\n\n  mov edi, eax\n  call F\n  \n  pop rdi\n  sub edi, eax\n  mov eax, edi\n  \n.exit:\n  pop rbp\n  ret  \n \n.terminal:\n  mov eax, 0\n  jmp .exit","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212108,"user_id":null,"body":"global F\nglobal M\nsection .text\n; input: edi = n\n; output: eax\nF:\n  mov rax, rdi\n  jmp FF\nM:\n  mov rax, rdi\n  jmp MM\n\nFF:\n  test rax, rax\n  jz one\n  push rax\n  dec rax\n  call FF\n  call MM\n  jmp final\nMM:\n  test rax, rax\n  jz zero\n  push rax\n  dec rax\n  call MM\n  call FF\nfinal:\n  mov rdx, rax\n  pop rax\n  sub rax, rdx\n  ret\none:\n  inc rax\nzero:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53da3dbb4a5168369a0000fe":[{"id":212109,"user_id":null,"body":"global even_or_odd\nsection .text\nODD:  db \"Odd\", 0\nEVEN:  db 'Even', 0\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\neven_or_odd:\n  test edi, 1\n  je next\n  mov rax, ODD\n  jmp afternext\n  next:\n  mov rax, EVEN\n  afternext:\n  \n  ret ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212110,"user_id":null,"body":"global even_or_odd\nsection .text\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\neven_or_odd:\n  mov rax, even\n  and rdi, 1\n  jz  end\n  mov rax, odd\nend:\n  ret\n  \n  section .rodata\n  \n  even    db    \"Even\",0\n  odd     db    \"Odd\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212111,"user_id":null,"body":"global even_or_odd\n\n\nsection .data\n    even: db `Even\\x00`\n    odd: db `Odd\\x00`\n\nsection .text\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\n\n\n\neven_or_odd:\n  mov rax, rdi\n  and rax, 1\n  test rax, rax\n  jz is_even\n  \nis_odd:\n  mov rax, odd\n  ret\n  \nis_even:\n  mov rax, even\n  ret\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212112,"user_id":null,"body":"global even_or_odd\nsection .text\n    odd_text db \"Odd\", 0\n    even_text db \"Even\", 0\neven_or_odd:\n    and edi, 1\n    jz is_even\n    mov eax,odd_text\n    jmp finish\nis_even:\n    mov eax, even_text\nfinish:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212113,"user_id":null,"body":"global even_or_odd\n\nsection .text\n\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\neven_or_odd:\n  and edi, 1\n  lea rax, [rdi*8+even]\n  ret\n  \nsection .rodata\n\neven: dq 'Even'\nodd: dq 'Odd'\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212114,"user_id":null,"body":"global even_or_odd\nsection .data\n  even: dq 'Even'\n  odd: dq \"Odd\"\n\nsection .text\neven_or_odd:\n  and edi, 1\n  lea rax, [rdi*8+even]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212115,"user_id":null,"body":"global even_or_odd\nsection .text\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\neven_or_odd:\n  and edi, 1\n  lea rax, [rel strings + edi * 5]\n  ret\n  \nstrings:\n  db \"Even\", 0, \"Odd\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212116,"user_id":null,"body":"global even_or_odd\nsection .text\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\neven_or_odd:\n  and edi, 1\n  mov rax, odd\n  mov rcx, even\n  cmovz rax, rcx\n  ret \n\nsection .rodata\neven: db \"Even\", 00h\nodd:  db \"Odd\", 00h\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212117,"user_id":null,"body":"global even_or_odd\nextern malloc\nsection .data\n  odd_s db \"Odd\",0\n  even_s db \"Even\",0\nsection .text\n; input: edi = number\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\neven_or_odd:\n    push rbp\n    mov rbp, rsp\n  \n    and dil, 0000001b\n    jp .even\n    mov rax, odd_s\n    jmp .end\n.even:\n    mov rax, even_s\n.end:\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212118,"user_id":null,"body":"section .rodata\neven db 'Even', 0\nodd db 'Odd', 0\n\nglobal even_or_odd\nsection .text\neven_or_odd:\n  mov rax, even\n  test edi, 1\n  jz .exit\n  mov rax, odd\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53dc54212259ed3d4f00071c":[{"id":212119,"user_id":null,"body":"section .text\nglobal sum_array\n\nsum_array:\n  xor     rax, rax\n  cmp     rsi, 0\n  je      empty\n\narray_loop:\n  add     rax, [rdi]\n  add     rdi, 4\n  dec     rsi\n  cmp     rsi, 0\n  jne     array_loop\n  \n  ret\n  \nempty:\n  mov     rax, 0\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212120,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  mov rax, 0\nadds:\n  cmp rsi, 0\n  je done\n  sub rsi, 1\n  add rax, [rdi + rsi*4]\n  cmp rsi, 0\n  jg adds\ndone:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212121,"user_id":null,"body":"\n\nSECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor     rax, rax\n  mov rcx, rsi\n  cmp     rsi, 0\n  je      empty\n\narray_loop:\n  add     rax, [rdi]\n  add     rdi, 4\n  loop     array_loop\n  \n  ret\n  \nempty:\n  mov     rax, 0\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212122,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor   eax, eax\n  xor   rcx, rcx\n.L1:\n  add   eax, DWORD [rdi+rcx*4]\n  inc   rcx\n  cmp   rcx, rsi\n  jl    .L1 \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212123,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor eax,eax\n.loop:\n  test rsi,rsi\n  jz .end\n  add eax,[rdi]\n  add rdi,4\n  dec rsi\n  jmp .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212124,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor eax, eax\n  cmp esi, 0\n  je .end\n  mov edx, 0\n.loop:\n  mov ebx, [rdi+4*rdx]\n  add eax, ebx\n  inc edx\n  cmp edx, esi\n  jl .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212125,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor eax, eax\n  mov rcx, rsi\n  cmp rcx, 0\n  je finished\nsum_loop:\n  mov r10d, dword [rdi + 4*rcx - 4]\n  add eax, r10d\n  loop sum_loop\nfinished:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212126,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor  rax, rax         ; sum in rax\n  test rdi, rdi\n  jz   .exit            ; no array, null -> exit\n  test rsi, rsi\n  jz   .exit            ; empty array -> exit\n  lea  rbx, [rdi+rsi*4] ; end of array\n  mov  rdx, 4           ; 4 bytes per item\n.next:\n  add  eax, [rdi]       ; sum items\n  add  rdi, rdx         ; to next item\n  cmp  rdi, rbx         ; cmp to end of array\n  jb  .next\n.exit:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212127,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor rax, rax\n  mov rcx, rsi\n  test rcx, rcx\n  jz .end\n  .loop:\n    add rax, [rdi + (rcx - 1) * 4] \n    loop .loop\n  .end: \n    ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212128,"user_id":null,"body":"SECTION .text\nglobal sum_array\n\n; Sums all numbers in an array.\n; arg0         = (const int32_t*) The array to sum.\n; arg1         = (size_t)         The length of the array.\n; return value = (int32_t)        The sum of all numbers in the array.\nsum_array:\n  xor eax, eax\n  .loop:\n    dec rsi\n    cmp rsi, 0\n    jl .done\n    add eax, [rdi + rsi * 4] \n    jmp .loop\n  .done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53ee5429ba190077850011d4":[{"id":212129,"user_id":1027,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\nlea rax,[rdi*2]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212130,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  imul rax, rdi, 2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212131,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  xor     rax, rax\n  imul    rdi, 2\n  mov     rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212132,"user_id":168,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  lea eax, [edi + edi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212133,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  sal edi, 1\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212134,"user_id":336,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  mov rax, rdi\n  mov rbx, 2\n  mul rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212135,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  lea eax, [rdi + rdi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212136,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  imul eax, edi, 2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212137,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n    mov rax,rdi\n    add rax,rdi\n    mov rdi,rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212138,"user_id":null,"body":"SECTION .text\nglobal double_integer\n\ndouble_integer:\n  mov eax, 2\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"540f8a19a7d43d24ac001018":[{"id":212139,"user_id":1315,"body":"global nthterm\nsection .text\nnthterm:\n    imul edx, esi\n    lea  eax, [edi + edx]\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212140,"user_id":null,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n  imul esi, edx\n  lea eax, [rsi + rdi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212141,"user_id":50,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n    mov eax,esi\n    imul edx\n    add eax,edi\n    ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212142,"user_id":null,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n  mov rax,rdi\n  imul rsi, rdx\n  add rax,rsi\n  ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212143,"user_id":null,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n    mov r8, rdi\n    mov r9, rsi\n    mov eax, edx\n    mul r9\n    add rax, r8\n    ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212144,"user_id":null,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\n; first: rdi\n; n: rsi\n; c; rdx\n; free regs: rax, rcx, r8, r9, r10, r11\nnthterm:\n    imul rsi, rdx\n    add rdi, rsi\n    mov rax, rdi\n    ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212145,"user_id":null,"body":"global nthterm\nsection .text\nnthterm:\n    mov rax, rsi\n    imul rdx\n    add rax, rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212146,"user_id":null,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n    xor eax, eax    ; EAX <- the result\n    mov eax, esi\n    mul edx\n    add eax, edi\n    ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212147,"user_id":null,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n    xor eax, eax ; EAX <- the result\n    xor ebx, ebx\n\nloop:\n    add ebx, 1\n    add edi, edx\n    cmp ebx, esi\n    jne loop\n    mov eax, edi\n    ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212148,"user_id":220,"body":"global nthterm\n\nsection .text\n\n; <--- int nthterm(int first, int n, int c) --->\nnthterm:\n  imul esi, edx\n  lea eax, [rsi + rdi]\n  ret\n; ---------> endof nthterm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5410c0e6a0e736cf5b000e69":[{"id":212149,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                         Written by Ali Muhammed\n;                           uniapi@outlook.com\n;                             January 1, 2022\n; ----------------------------------------------------------------------\n\nglobal hamming_distance\n\nsection .text\n\n; <-- EAX hamming(ro [byte RDI] s1, ro [byte RSI] s2) -->\nhamming_distance:\n    xor eax, eax                    ; resetting the result\n    vpxor xmm1, xmm1                ; resetting YMM1 as <nullstr>\n    mov r8, -32                     ; setting <inx> before 32 characters\n    xor edx, edx                    ; resetting EDX as <cmpmsk>\n.loop:\n    popcnt edx, edx                 ; getting <nbit> from <cmpmsk>\n    add eax, edx                    ; adding <nbit> to the result\n    add r8, 32                      ; updating <inx> by 32 characters\n    vmovdqu ymm2, [rdi+r8]          ; loading YMM2 with 32 characters from <s1>\n    vpcmpeqb ymm0, ymm1, ymm2       ; comparing <nullstr[0:31]> and <s1[0:31]> and setting YMM0 as <nullmsk>\n    vpmovmskb ecx, ymm0             ; moving <nullmsk> to ECX\n    vpcmpeqb ymm3, ymm2, [rsi+r8]   ; comparing <s1[0:31]> and <s2[0:31]> and setting YMM3 as <cmpmsk>\n    vpmovmskb edx, ymm3             ; moving <cmpmsk> to EDX\n    not edx                         ; reversing <cmpmsk>\n    test ecx, ecx                   ; whether ECX is zero\n    je .loop                        ; then jumping to the next iteration\n    bsf ecx, ecx                    ; getting the position of the first one-bit\n    mov edi, ~0                     ; setting EDI to all ones as <nbit>\n    shl edi, cl                     ; shifting <nbit> left by <nullmsk>\n    not edi                         ; reversing <nbit>\n    and edi, edx                    ; extracting only the necessary bits from <nbit>\n    popcnt edi, edi                 ; getting  <nbit>\n    add eax, edi                    ; adding <nbit> to the result\n.exit:\n    ret\n; -----> endof hamming <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212150,"user_id":168,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n    xor eax, eax\n.loop:\n    xor ecx, ecx\n    movzx edx, byte [rdi]\n    cmp dl, byte [rsi]\n    setne cl\n    add eax, ecx\n    inc rdi\n    inc rsi\n    test edx, edx\n    jnz .loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212151,"user_id":null,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n  xor r8d, r8d\n  xor eax, eax\n.loop:\n  mov dl, [rdi + r8]\n  test dl, dl\n  je .done\n  xor ecx, ecx\n  cmp dl, [rsi + r8]\n  setne cl\n  inc r8\n  add rax, rcx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212152,"user_id":null,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n    xor rax, rax\nloop:\n    mov bl, byte [rdi]\n    test bl, bl\n    jz done\n    mov bl, byte [rsi]\n    cmp byte [rdi], bl\n    jnz nequal\nback:\n    inc rdi\n    inc rsi\n    jmp loop\ndone:\n    ret\n    \nnequal:\n  inc rax\n  jmp back","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212153,"user_id":46,"body":"section .text\n_strlen:\n  push rcx\n\n  xor rax, rax\n  _count_loop:\n    mov cl, byte [ rdi + rax ]\n\n    inc rax\n    cmp cl, 0x0\n    jne _count_loop\n\n  dec rax\n  pop rcx\n  ret\n\nglobal hamming_distance\nhamming_distance:\n  call _strlen\n  mov rbx, rax\n  xor rax, rax\n  xor r15, r15\n  _loop:\n    mov cl, byte [ rdi + r15 ]\n    cmp cl, byte [ rsi + r15 ]\n    je _after_inc\n    inc rax\n    _after_inc:\n    inc r15\n    cmp r15, rbx\n    js _loop\n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212154,"user_id":null,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n  xor eax, eax\n  \n.loop:\n  mov dl, [rdi]\n  mov cl, [rsi]\n  inc rdi\n  inc rsi\n  cmp dl, cl\n  je .skip\n  inc rax\n.skip:\n  test dl, dl\n  jnz .loop\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212155,"user_id":173,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n    xor rax, rax\nl_loop:\n    mov cl, byte [rdi]\n    cmp cl, 0\n    je l_done\n    mov ch, byte [rsi]\n    inc rdi\n    inc rsi\n    cmp cl, ch\n    je l_loop\n    inc rax\n    jmp l_loop\nl_done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212156,"user_id":null,"body":"section .text\nglobal hamming_distance\n\nhamming_distance:\n  xor rcx, rcx\n  \n.loop:\n  mov al, [rdi]\n  mov dl, [rsi]\n  \n  test al, al\n  jz .end\n  \n  cmp al, dl\n  je .continue\n  \n  inc rcx\n  \n.continue:\n  inc rdi\n  inc rsi\n  jmp .loop\n\n.end:\n  mov rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212157,"user_id":null,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n    xor rax, rax\n    xor rcx, rcx\nloop:\n    mov dl, byte [rdi]\n    cmp dl, 0\n    jz return\n    cmp dl, byte [rsi]\n    setnz cl\n    add rax, rcx\n    inc rdi\n    inc rsi\n    jmp loop\n\nreturn:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212158,"user_id":null,"body":"section .text\nglobal hamming_distance\n\n; size_t hamming_distance(const char *a, const char *b);\n; rdi = a, rsi = b, rax = result\nhamming_distance:\n    xor rax, rax\n    \n    mov rcx, -1\n    .getStrSize:\n      inc rcx\n      cmp byte[rdi + rcx], 0\n      jne .getStrSize\n    inc rcx\n    \n    cld                  ;; cld clear_directionFlag, set direction flag to 0 (so cmpsb increments after compare instead of decrementing if flag 1)\n    .compare:            ;; repe repeat_equal, repeat if equal and rcx != 0, decrements rcx after comparing\n      repe cmpsb         ;; cmpsb compare_string_byte(rsi, rdi), increments rsi and rdi after comparison\n      cmp rcx, 0\n      je  .return\n      inc rax\n      jmp .compare\n    \n    .return:\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54147087d5c2ebe4f1000805":[{"id":212159,"user_id":168,"body":"global _if\n\n; <-- _if(DIL value, [qword RSI] func1, [qword RDX] func2) -->\n_if:\n  test dil, dil\n  cmovz rsi, rdx\n  jmp rsi\n; -----> endof _if <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212160,"user_id":527,"body":"global _if\n\n; void _if(bool value, void (*func1)(), void (*func2)())\n_if:\n                test    dil, dil\n                cmovz   rsi, rdx\n                jmp     rsi\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212161,"user_id":null,"body":"section    .text\nglobal     _if\n\n_if:\n  xor      rax, rax\n  \n  cmp      rdi, 1\n  jz       _true\n  jmp      _false\n  \n_true:\n  call     rsi\n  ret\n  \n_false:\n  call      rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212162,"user_id":null,"body":"global _if\n\n; <-- _if(DIL value, RSI func1, RDX func2) -->\n_if:\n    cmp dil, 1            ; If dil == 1...\n    je .when_true         ; Jump if true...\n    jmp .when_false      ; Else...\n    \n.when_true:\n    call rsi              ; Calls RSI, func1\n    ret                   ; Returns _if\n\n.when_false:\n    call rdx              ; Calls RDX, func2\n    ret                   ; Returns _if\n; -----> endof _if <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212163,"user_id":null,"body":"global _if\n\n; <-- _if(DIL value, RSI func1, RDX func2) -->\n_if:\n  mov rax, rsi\n  test dil, dil\n  cmovz rax, rdx\n  call rax\n  ret\n; -----> endof _if <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212164,"user_id":null,"body":"global _if\n\n; <-- _if(DIL value, RSI func1, RDX func2) -->\n_if:\n    push rbp\n    mov rbp, rsp\n    push rsi\n    push rdx\n    xor ecx, ecx\n    mov cl, dil\n    mov rax, qword[rsp+8*rcx]\n    call rax\n    add rsp, 0x10\n    pop rbp\n    ret\n; -----> endof _if <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212165,"user_id":null,"body":"global _if\n\n; <-- _if(DIL value, RSI func1, RDX func2) -->\n_if:\n  test dil, dil\n  je .true\n  call rsi\n  jmp .exit\n.true:\n  call rdx\n  jmp .exit\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212166,"user_id":null,"body":"global _if\n_if:\n  cmp rdi,1\n  je f1\n  call rdx\n  ret\n  f1:\n  call rsi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212167,"user_id":null,"body":"global _if\n\n; <-- _if(DIL value, RSI func1, RDX func2) -->\n_if:\n  test edi, edi\n  cmove rsi, rdx\n  jmp rsi","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212168,"user_id":50,"body":"global _if\n\n; <-- _if(DIL value, RSI func1, RDX func2) -->\n_if:\n    test dil, dil\n    jz _callf2\n    call rsi\n    ret\n_callf2:\n    call rdx\n; -----> endof _if <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"541c8630095125aba6000c00":[{"id":212169,"user_id":527,"body":"global digital_root\n\nsection .text\n\n; unsigned digital_root(unsigned n)\ndigital_root:\n                mov     eax, edi\n                test    edi, edi\n                jz      .done\n                imul    rax, 954437177\n                shr     rax, 33\n                lea     eax, [rax * 9]\n                sub     edi, eax\n                mov     eax, 9\n                cmovnz  eax, edi\n.done:          ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212170,"user_id":null,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned num) --->\ndigital_root:\n    mov eax, edi        ; copying <num> to EAX\n    test eax, eax       ; whether <num> is zero\n    je .exit            ; jumping to exit\n    xor edx, edx        ; reseting EDX before the division\n    mov edi, 9          ; the divisor to get rid of digits\n    dec eax             ; decrementing <num>\n    div edi             ; getting the only digit\n    inc edx             ; decrementing the resulted digit from the division\n    mov eax, edx        ; copying to EAX to send as the result\n.exit:\n    ret\n; -----> end of digsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212171,"user_id":null,"body":"global digital_root\nsection .text\n\ndigital_root:\n    lea rax, [rdi - 1]\n    mov rsi, 9\n    xor rdx, rdx\n    div rsi\n    lea rax, [rdx + 1]\n    cmp rdi, 0\n    je _zero\n    ret\n    \n_zero:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212172,"user_id":null,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned n) --->\ndigital_root:\n  mov eax, edi        ; EAX <- the result\n  \nl1:\n  cmp eax, 10\n  jl end\n  mov ecx, 10\n  xor ebx, ebx\n  l2:\n    xor edx, edx\n    div ecx\n    add ebx, edx\n    test eax, eax\n    jnz l2\n  mov eax, ebx\n  jmp l1\nend:\n  ret\n; -----> end of digsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212173,"user_id":null,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned n) --->\ndigital_root:\n  test edi, edi\n  mov eax, edi\n  je .done\n  dec eax\n  mov ecx, 9\n  xor edx, edx\n  div ecx\n  lea eax, [rdx+1]\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212174,"user_id":null,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned n) --->\ndigital_root:\n    xor eax, eax        ; EAX <- the result\n    cmp edi, 0\n    je end\n    mov eax, edi\n    mov edx, 0\n    mov ebx, 9\n    div ebx\n    mov eax, edx\n    cmp eax, 0\n    jne end\n    mov eax, 9\n    end:\n    ret\n; -----> end of digsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212175,"user_id":null,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned n) --->\ndigital_root:\n    mov eax, edi        ; EAX <- the result\n    mov esi, 10\n    LOGIC:\n      cmp eax, 9\n      jna DONE\n      xor ecx, ecx\n      WHILE:\n        xor edx, edx\n        div esi\n        add ecx, edx\n        cmp eax, 9\n        ja WHILE\n      add eax, ecx\n      jmp LOGIC\n    DONE:\n    ret\n; -----> end of digsum <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212176,"user_id":46,"body":"section .text\nglobal digital_root\ndigital_root:\n    cmp rdi, 0\n    je _ret_0\n    jmp _after_ret_0\n    _ret_0:\n      mov rax, 0\n      ret\n    _after_ret_0:\n    dec rdi\n    mov rax, rdi\n    xor rdx, rdx\n    mov rbx, 9\n    div rbx\n    mov rax, rdx\n    inc rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212177,"user_id":943,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned n {edi}}) --->\ndigital_root:\n    mov esi, 10; divisor\n    mov eax, edi; EAX is the implicit target of DIV\n  _loop0:\n    xor ecx, ecx; ECX holds the digit sum for one round\n  _loop:\n    xor rdx, rdx\n    div esi; DIV sets the remainder in (R|E)DX\n    add ecx, edx; add remainder to sum\n    test eax, eax; while eax > 0. Changed from \"cmp eax 0\", as test is smaller and macro fuses with all conditional jumps\n    jg _loop\n    mov eax, ecx\n    cmp eax, 9\n    jg _loop0; start another round if the sum is still multi digit\n  _finish:\n    ret\n; -----> end of digsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212178,"user_id":943,"body":"global digital_root\n\nsection .text\n\n; <--- unsigned digital_root(unsigned n {edi}}) --->\ndigital_root:\n    mov esi, 10; divisor\n    mov eax, edi; EAX is the implicit target of DIV\n  _loop0:\n    xor ecx, ecx; ECX holds the digit sum for one round\n  _loop:\n    xor rdx, rdx\n    div esi; DIV sets the remainder in (R|E)DX\n    add ecx, edx; add remainder to sum\n    cmp eax, 0; while eax > 0\n    jg _loop\n    mov eax, ecx\n    cmp eax, 9\n    jg _loop0; start another round if the sum is still multi digit\n  _finish:\n    ret\n; -----> end of digsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54207f9677730acd490000d1":[{"id":212179,"user_id":null,"body":"global passwd_hash\nextern MD5_Init,MD5_Update,MD5_Final,strlen,asprintf\nsection .text\npasswd_hash:\n  push  rdi\n  call  strlen\n  push  rax\n  mov   rdi,context\n  call  MD5_Init\n  pop   rdx\n  pop   rsi\n  mov   rdi,context\n  call  MD5_Update\n  mov   rdi,digest\n  mov   rsi,context\n  call  MD5_Final\n  mov   rdi,outstr\n  mov   rsi,fmt\n  movbe rdx,[digest]\n  movbe rcx,[digest+8]\n  xor   rax,rax\n  call  asprintf\n  mov   rax,[outstr]\nret\nsection .data\nfmt     db '%016lx%016lx',0\noutstr  resq 1\ncontext resb 256\ndigest  resb 16","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212180,"user_id":null,"body":"global passwd_hash\nextern MD5, abort, malloc, strlen\n\nsection .text\n\n; <--- char *passwd_hash(const char *passwd) --->\npasswd_hash:\n    ; Compute MD5 hash\n    call strlen\n    mov rsi, rax\n    mov rdx, 0\n    call MD5\n    push rax\n    \n    ; Malloc a new buffer for the hex'd hash\n    mov rdi, 33\n    call malloc\n    test rax, rax\n    jz .error\n    pop rsi\n    \n    ; Convert the hash to hex\n    xor rcx, rcx\n.copy_loop:\n    movzx rdx, byte [rsi + rcx]\n    mov r8, rdx\n    shr r8, 4\n    mov r8b, byte [.hex + r8]\n    mov byte [rax + 2*rcx], r8b\n    and rdx, 0xF\n    mov dl, byte [.hex + rdx]\n    mov byte [rax + 2*rcx + 1], dl\n    add rcx, 1\n    cmp rcx, 16\n    jl .copy_loop\n    mov byte [rax + 32], 0\n    ret\n\n.error:\n    call abort\n\nsection .rodata\n\n.hex:\ndb '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n; -----> endof passwd_hash <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212181,"user_id":168,"body":"global passwd_hash\nextern malloc, strlen, MD5\n\nsection .text\n\ndigits db \"0123456789abcdef\"\n\n; <--- char *passwd_hash(const char *passwd) --->\npasswd_hash:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  mov rdi, rbx\n  mov rsi, rax\n  xor edx, edx\n  call MD5\n  mov rbx, rax\n  mov edi, 33\n  call malloc\n  mov esi, 15\n  mov byte [rax + 32], 0\n.loop:\n  movzx ecx, byte [rbx + rsi]\n  mov edx, ecx\n  shr edx, 4\n  movzx edx, byte [digits + rdx]\n  and ecx, 0xF\n  movzx ecx, byte [digits + rcx]\n  shl ecx, 8\n  or edx, ecx\n  mov word [rax + 2 * rsi], dx\n  dec esi\n  jns .loop\n  pop rbx\n  ret\n; -----> endof passwd_hash <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212182,"user_id":null,"body":"global passwd_hash\nextern malloc, strlen\nextern MD5, sprintf\n\nsection .text\n\n; <--- char *passwd_hash(const char *passwd) --->\npasswd_hash:\n    push r13                ; saving R13 in the stack\n    push rbp                ; saving RBP in the stack\n    push rbx                ; saving RBX in the stack\n    sub rsp, 0h10           ; allocating local storage for <digest>\n    mov rbp, rdi            ; saving <passwd> in RBP\n    mov rdi, 0h21           ; the target bytes needed for hashed string\n    call malloc             ; allocating memory\n    mov rbx, rax            ; saving the allocated memory in RBX as <hash>\n    test rbx, rbx           ; whether <hash> is not null\n    je .exit                ; otherwise, jumping to exit\n    mov rdi, rbp            ; copying <passwd> to RDI\n    call strlen             ; counting characters in <passwd>\n    mov rdi, rbp            ; copying <passwd> to RDI\n    mov rsi, rax            ; saving the number of characters in RSI\n    mov rdx, rsp            ; copying the pointer to <digest>\n    mov rbp, rsp            ; copying the pointer to <digest>\n    call MD5                ; hashing <passwd>\n    mov r13d, 0h10          ; setting R13D to the length of MD5_DIGEST_LENGTH as <n>\n.loop:\n    mov rdi, rbx            ; pointing RDI to <*hash>\n    mov rsi, .fmt           ; copying <.fmt> to RSI\n    movzx edx, byte [rbp]   ; extending <*digest> to EDX\n    call sprintf            ; printing the digit\n    add rbx, 2              ; moving <hash> two characters forward\n    inc rbp                 ; pointing <digest> to the next character\n    dec r13d                ; decremening <n>\n    jne .loop               ; jumping to the next iteration if bytes left\n    sub rbx, 0h20           ; pointing <hash> to the initial allocated address\n.exit:\n    mov rax, rbx            ; setting RAX to <hash>\n    add rsp, 0h10           ; destroying the local storage\n    pop r13                 ; restoring the initial R13\n    pop rbp                 ; restoring the initial RBP\n    pop rbx                 ; restoring the initial RBX\n    ret\n\n; local read-only data\n.fmt:   db  \"%02x\",0h0\n; -----> endof passwd_hash <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"542f0c36d002f8cd8a0005e5":[{"id":212183,"user_id":null,"body":"global last_chair\nsection .text\n; unsigned last_chair(unsigned n);\nlast_chair:\n  mov eax, edi\n  cmp edi, 3\n  adc eax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212184,"user_id":null,"body":"global last_chair\nsection .text\nlast_chair:\n  lea eax, [edi - 1]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212185,"user_id":null,"body":"global last_chair\nsection .text\n; unsigned last_chair(unsigned n);\nlast_chair:\n                xor     eax, eax\n                dec     edi\n                mov     eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212186,"user_id":76,"body":"global last_chair\nsection .text\n; unsigned last_chair(unsigned n);\nlast_chair:\n  lea rax, [rdi - 1]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212187,"user_id":50,"body":"global last_chair\nsection .text\n; unsigned last_chair(unsigned n);\nlast_chair:\n  mov rax,rdi\n  dec rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212188,"user_id":168,"body":"global last_chair\nsection .text\n; unsigned last_chair(unsigned n);\nlast_chair:\n  lea eax, [edi - 1]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212189,"user_id":527,"body":"global last_chair\nsection .text\n; unsigned last_chair(unsigned n);\nlast_chair:\n                lea     eax, [rdi - 1]\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54566695309908a6590005f1":[{"id":212190,"user_id":null,"body":"global crossprod\nextern malloc\n\nsection .text\n\n; <--- double *crossprod(const double *v1, const double *v2, size_t len1, size_t len2) --->\ncrossprod:\n    xor rax, rax            ; reseting the result to NULL\n    mov r9, 3               ; the length of 3D vector\n    test rdi, rdi           ; whether <v1> is NULL\n    je .exit                ; jumping to exit\n    test rsi, rsi           ; whether <v2> is NULL\n    je .exit                ; jumping to exit\n    cmp rdx, r9             ; whether <len1> is not equal to three\n    jne .exit               ; jumping to exit\n    cmp rcx, r9             ; whether <len2> is not equal to three\n    jne .exit               ; jumping to exit\n    push rdx                ; saving <len1> in the stack\n    push rsi                ; saving <v2> in the stack\n    push rdi                ; saving <v1> in the stack\n    mov rdi, 8              ; the size of double\n    imul rdi, r9            ; the target bytes to allocate for the 3D vector\n    call malloc             ; allocating memory\n    pop rdi                 ; restoring <v1> from the stack\n    pop rsi                 ; restoring <v2> from the stack\n    pop rcx                 ; aligning the stack boundary\n    test rax, rax           ; whether succeeded to allocate memory\n    je .exit                ; otherwise, jumping to exit\n    movq xmm1, [rdi]        ; copying <*v1>\n    movq xmm2, [rdi+8]      ; copying <*(v1+1)>\n    movq xmm3, [rdi+16]     ; copying <*(v1+2)>\n    movq xmm4, [rsi]        ; copying <*v2>\n    movq xmm5, [rsi+8]      ; copying <*(v2+1)>\n    movq xmm6, [rsi+16]     ; copying <*(v2+2)>\n    movq xmm0, xmm2         ; copying <*(v1+1)>\n    mulsd xmm0, xmm6        ; multiplying <*(v1+1)> by <*(v2+2)>\n    movq xmm7, xmm3         ; copying <*(v1+2)\n    mulsd xmm7, xmm5        ; multiplying <*(v1+2)> by <*(v2+1)>\n    subsd xmm0, xmm7        ; subtracting the results\n    movq [rax], xmm0        ; saving in <*res>\n    movq xmm0, xmm3         ; copying <*(v1+2)>\n    mulsd xmm0, xmm4        ; multiplying <*(v1+2)> by <*v2>\n    movq xmm7, xmm1         ; copying <*v1>\n    mulsd xmm7, xmm6        ; multiplying <*v1> by <*(v2+2)>\n    subsd xmm0, xmm7        ; subtracting the results\n    movq [rax+8], xmm0      ; saving in <*(res+1)>\n    movq xmm0, xmm1         ; copying <*v1>\n    mulsd xmm0, xmm5        ; multiplying <*v1> by <*(v2+1)>\n    movq xmm7, xmm2         ; copying <*(v1+1)>\n    mulsd xmm7, xmm4        ; multiplying <*(v1+1)> by <*v2>\n    subsd xmm0, xmm7        ; subtracting the result\n    movq [rax+16], xmm0     ; saving in <*(res+2)>\n.exit:\n    ret\n; -----> end of crossprod <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212191,"user_id":null,"body":"global crossprod\nextern malloc\n\nsection .text\n\n; <--- double *crossprod(const double *v1, const double *v2, size_t len1, size_t len2) --->\n; params:\n;   rdi <- v1\n;   rsi <- v2\n;   rdx <- len1\n;   rcx <- len2\ncrossprod:\n  push r14\n  push rbx\n  push rax\n  test rdi, rdi\n  je .null\n  mov r14, rsi\n  test rsi, rsi\n  je .null\n  cmp rdx, 3\n  jne .null\n  cmp rcx, 3\n  jne .null\n  mov rbx, rdi\n  mov edi, 24\n  call malloc\n  vmovsd xmm0, qword [r14 + 8]\n  vmovsd xmm1, qword [r14 + 16]\n  vmovsd xmm2, qword [rbx + 8]\n  vmovsd xmm3, qword [rbx + 16]\n  vmulsd xmm4, xmm3, xmm0\n  vfmsub231sd xmm4, xmm2, xmm1\n  vmovsd qword [rax], xmm4\n  vmovsd xmm4, qword [r14]\n  vmovsd xmm5, qword [rbx]\n  vmulsd xmm1, xmm1, xmm5\n  vfmsub231sd xmm1, xmm4, xmm3\n  vmovsd qword [rax + 8], xmm1\n  vmulsd xmm1, xmm2, xmm4\n  vfmsub231sd xmm1, xmm0, xmm5\n  vmovsd [rax + 16], xmm1\n  jmp .done\n.null:\n  xor eax, eax\n.done:\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212192,"user_id":null,"body":"global crossprod\nextern malloc\ncrossprod:\n  xor  rax,rax\n  cmp  rdx,3\n  jne .f\n  cmp  rcx,3\n  jne .f\n  test rdi,rsi\n  je .f\n    vmovupd     ymm2,[rdi]\n    vmovupd     ymm1,[rsi]\n    vpermq      ymm0,ymm1,201\n    vpermq      ymm3,ymm2,201\n    vmulpd      ymm1,ymm1,ymm3\n    vfmsub132pd ymm0,ymm1,ymm2\n    vpermq      ymm0,ymm0,201\n    mov         rdi,32\n    call        malloc   \n    vmovupd     [rax],ymm0\n  .f:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212193,"user_id":null,"body":"global crossprod\nextern malloc\n\nsection .text\n\n; <--- double *crossprod(const double *v1, const double *v2, size_t len1, size_t len2) --->\n; params:\n;   rdi <- v1\n;   rsi <- v2\n;   rdx <- len1\n;   rcx <- len2\ncrossprod:\n    ; Test the arrays\/\n    test rdi, rdi\n    jz return_null\n    test rsi, rsi\n    jz return_null\n    \n    ; Test the lengths.\n    cmp rcx, 3\n    jnz return_null\n    cmp rdx, 3\n    jnz return_null\n    \n    ; Allocate space for a 3D vector.\n    push rdi\n    push rsi\n    \n    ; 3 cells of size 8\n    mov rdi, 24\n    call malloc\n    \n    pop rsi\n    pop rdi\n    \n    ; v1[1]*v2[2] - v1[2]*v2[1]\n    movsd xmm2, [rdi + 8]\n    movsd xmm1, [rsi + 16]\n    mulsd xmm2, xmm1\n    \n    movsd xmm0, [rdi + 16]\n    movsd xmm1, [rsi + 8]\n    mulsd xmm0, xmm1\n    \n    subsd xmm2, xmm0\n    movsd [rax], xmm2\n    \n    ; v1[2]*v2[0] - v1[0]*v2[2]\n    movsd xmm2, [rdi + 16]\n    movsd xmm1, [rsi]\n    mulsd xmm2, xmm1\n    \n    movsd xmm0, [rdi]\n    movsd xmm1, [rsi + 16]\n    mulsd xmm0, xmm1\n    \n    subsd xmm2, xmm0\n    movsd [rax + 8], xmm2\n    \n    ; v1[0]*v2[1] - v1[2]*v2[0]\n    movsd xmm2, [rdi]\n    movsd xmm1, [rsi + 8]\n    mulsd xmm2, xmm1\n    \n    movsd xmm0, [rdi + 8]\n    movsd xmm1, [rsi]\n    mulsd xmm0, xmm1\n    \n    subsd xmm2, xmm0\n    movsd [rax + 16], xmm2\n    \n    ret\nreturn_null:\n    xor rax, rax\n    ret\n; -----> end of crossprod <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212194,"user_id":168,"body":"global crossprod\nextern malloc\n\nsection .text\n\n; <--- double *crossprod(const double *v1, const double *v2, size_t len1, size_t len2) --->\n; params:\n;   rdi <- v1\n;   rsi <- v2\n;   rdx <- len1\n;   rcx <- len2\ncrossprod:\n  xor eax, eax\n  test rdi, rdi\n  jz .end\n  test rsi, rsi\n  jz .end\n  cmp rdx, 3\n  jne .end\n  cmp rcx, 3\n  jne .end\n  push rbx\n  push r14\n  push rax\n  mov rbx, rdi      ; rbx = v1\n  mov r14, rsi      ; r14 = v2\n  mov rdi, 24\n  call malloc\n  mov edx, 1\n  shl rdx, 63\n  vmovq xmm8, rdx\n  vmovupd xmm0, oword [rbx]\n  vmovupd xmm1, oword [r14]\n  vmovsd xmm2, qword [rbx + 16]\n  vmovsd xmm3, qword [r14 + 16]\n  vshufpd xmm4, xmm2, xmm0, 2\n  vshufpd xmm5, xmm1, xmm3, 1\n  vxorpd xmm4, xmm4, xmm8\n  vdppd xmm4, xmm4, xmm5, 49\n  vmovsd qword [rax], xmm4\n  vshufpd xmm4, xmm0, xmm2, 0\n  vshufpd xmm5, xmm3, xmm1, 0\n  vxorpd xmm4, xmm4, xmm8\n  vdppd xmm4, xmm4, xmm5, 49\n  vmovsd qword [rax + 8], xmm4\n  vxorpd xmm1, xmm1, xmm8\n  vshufpd xmm1, xmm1, xmm1, 1\n  vdppd xmm0, xmm0, xmm1, 49\n  vmovsd qword [rax + 16], xmm0\n  add rsp, 8\n  pop r14\n  pop rbx\n.end:\n  ret\n; -----> end of crossprod <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54598e89cbae2ac001001135":[{"id":212195,"user_id":null,"body":"global any\n\nsection .text\n\n; <--- bool any(const int *argv, size_t n, bool (*cmp)(int x)) --->\nany:\n    xor eax, eax        ; resetting AL\n    push r13            ; saving R13 in the stack\n    push r12            ; saving R12 in the stack\n    push rbx            ; saving RBX in the stack\n    test rdi, rdi       ; whether <argv> is not NULL\n    je .exit            ; otherwise, jumping to exit\n    test rsi, rsi       ; whether <n> is zero\n    je .exit            ; otherwise, jumping to exit\n    mov r13, rdx        ; copying <cmp> to R13\n    mov r12, rsi        ; copying <n> to R12\n    lea rbx, [rdi-4]    ; copying <argv-1> to RBX\n.loop:\n    add rbx, 0h4        ; pointing <argv> to the next element\n    dec r12             ; decrementing <n>\n    jl .exit            ; jumping to exit if less than zero\n    mov rdi, [rbx]      ; copying <*argv> to  RDI\n    call r13            ; calling (cmp)\n    test al, al         ; whether the result is true\n    je .loop            ; otherwise, jumping to the next iteration\n.exit:\n    pop rbx             ; restoring the initial RBX\n    pop r12             ; restoring the initial R12\n    pop r13             ; restoring the initial R13\n    ret\n; ---------> endof any <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212196,"user_id":50,"body":"SECTION .text\nglobal any\n\nany:\n  xor rax, rax\n  mov r8,rdi ; save array\n  mov r10,rdx ; save fn\n  xor r11,r11 ; indexer\n_loop:\n  cmp r11,rsi\n  je _exit\n  mov edi,[r8]\n  add r8,4\n  inc r11\n  call r10\n  cmp eax,1\n  je _retTrue\n  jmp _loop\n_retTrue:\n  mov rax,1\n  ret\n_exit:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212197,"user_id":null,"body":"SECTION .text\nglobal any\n\nany:\n  push r15\n  push r14\n  push r12\n  push rbx\n  push rax\n  mov r14, rdx\n  mov r12, rsi\n  mov r15, rdi\n  xor ecx, ecx\n.loop:\n  mov rbx, rcx\n  cmp r12, rcx\n  je .done\n  mov edi, [r15 + 4*rbx]\n  call r14\n  lea rcx, [rbx + 1]\n  test al, al\n  je .loop\n.done:\n  cmp rbx, r12\n  setb al\n  add rsp, 8\n  pop rbx\n  pop r12\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212198,"user_id":null,"body":"SECTION .text\nglobal any\n\nany:\n  push rbx\n  push rbp\n  push r12\n  push r13\n  mov rbx, rdi\n  mov rbp, rsi\n  mov r12, rdx\n  xor r13, r13\n  xor rax, rax\n  .loop:\n  cmp r13, rbp\n  je .done\n  mov edi, dword [rbx+r13*4]\n  call r12\n  test al, al\n  jnz .done\n  inc r13\n  jmp .loop\n  .done:\n  pop r13\n  pop r12\n  pop rbp\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212199,"user_id":104,"body":"; 2021 nomennescio\nSECTION .text\nglobal any\n\n; bool any (const int* arr, size_t size, bool (*fun)(int));\n; rax                  rdi         rsi          rdx\n\nany:\n  cmp rsi, 0\n  je false\n  mov r8, rdi\n  mov r9, rdx\nloop:\n  mov edi, [r8+4*rsi-4]\n  call r9\n  cmp al, 0\n  jne exit\n  dec rsi\n  jne loop\nfalse:\n  xor rax, rax\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212200,"user_id":null,"body":"SECTION .text\nglobal any\n\n; typedef bool (*Predicate)(int);\n\nany:\n  ;RDI = pointer to the array of integers\n  ;RSI = number of elements on the array\n  ;RDX = function to be tested (predicate)  \n  \n  ForLoopN:\n   cmp rsi, 0     ;check if number of elements left is bigger than 0\n   jle EndLoopN   ;if its not jump to the end of this loop\n    \n     sub rsi, 1   ; one element processed\n    \n     push RDI\n     push RSI ;save function parameters on stack\n     push RDX\n    \n     ; mov rdi, [rdi+rsi*4] ;alternative way using indexes\n     mov rdi, [rdi] ; read element from array\n     call rdx       ; call the function passed to used on rdx\n  \n     pop RDX\n     pop RSI ;restore function parameters from stack\n     pop RDI\n     \n     and eax,0xFF   ; check if eax=0 (cmp eax,0) (sets the zero flag)\n     jnz Return     ; if eax not 0 then we can end the function\n     \n     add rdi, 4     ; change array to point to next element (without index)\n     jmp ForLoopN   ; go check next element\n    \n  EndLoopN:\n          \n  xor eax, eax ;eax=return value = 0 = false\n  \n  Return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212201,"user_id":null,"body":"SECTION .text\nglobal any\n\nany:\n  xor rax, rax\n  cmp rsi, 0\n  jz .exit\n  \n  mov r8, rdi\n  xor r9, r9\n   \n.for:\n  push rsi\n  push rdi\n  push rdx\n  push r8\n  push r9\n  \n  mov edi, [r8 + r9 * 4]\n  call rdx\n  \n  pop r9\n  pop r8\n  pop rdx\n  pop rdi\n  pop rsi\n  \n  cmp al, 1\n  je .exit\n  inc r9\n  cmp r9, rsi\n  jl .for\n  \n.exit:\n  mov rdi, r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212202,"user_id":null,"body":"SECTION .text\nglobal any\n\nany:\n  cmp rsi, 0\n  je .ret\n  \n  mov rcx, rsi\n  mov rsi, rdi\n  xor rax, rax\n  xor rbx, rbx\n  \n.loop:\n  mov rdi, qword [rsi + rcx * 4 - 4]\n  push rcx\n  push rdx\n  call rdx\n  pop rdx\n  pop rcx\n  and rax, 1\n  cmp rax, 1\n  je .ret\n  loop .loop\n\n.ret:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212203,"user_id":null,"body":"SECTION .text\nglobal any\n\n; input\n;    rdi - pointer to array of int\n;    rsi - number of elements in the array\n;    rdx - pointer to function of int return bool\n; output\n;    rax - true if any function calls return true\nany:\n    xor   rax, rax        ; return false on an parameter error\n    test  rdi,rdi\n    jz    .errorexit      ; null pointer to array: return false\n    test  rsi,rsi\n    jz    .errorexit      ; 0 array length: return false\n    test  rdx,rdx\n    jz    .errorexit      ; null pointer to function: return false\n    push  r12\n    push  r13\n    push  r14\n    mov   r12,rsi         ; counter\n    mov   r13,rdi         ; pointer to current int in the array\n    mov   r14,rdx         ; function address\n.loop:\n    mov   edi,[r13]\n    call  r14            ; call function with current int\n    test  al,al          ; bool is returned in al, ignore the other bits\n    jnz   .return        ; funtion returns true: return true\n    add   r13,4          ; no next array int\n    dec   r12\n    jnz   .loop          ; next array item or return false\n.return:\n    movzx rax,al         ; return rax\n    pop   r14\n    pop   r13\n    pop   r12\n.errorexit:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212204,"user_id":null,"body":"SECTION .text\nglobal any\n\n;rdi = &arr\n;rsi = size\n;rdx = &fun\nany:\n  mov rcx, rsi\n  xor rax, rax\n  test rcx, rcx\n  jz ret_false\n  \nloop_begin:\n  push rcx\n  push rdx\n  push rsi\n  push rdi\n  \n  mov rax, QWORD [rdi]\n  mov rdi, rax\n  call rdx\n  \n  pop rdi\n  pop rsi\n  pop rdx\n  pop rcx\n \n  test rax, 1\n  jne ret_true\n \n  add rdi, 4\n  loop loop_begin\n  ret\n\nret_false:\n  mov rax, 0\n  ret\nret_true:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"545991b4cbae2a5fda000158":[{"id":212205,"user_id":null,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\n; input:\n;    rdi - pointer to list of int\n;    rsi - number of elements in the list\n;    edx - value of int to seach\n; output:\n;    rax - true if and only if edx is in the list\ninclude:\n    test  rdi, rdi\n    jz    .false        ; no array\n    test  rsi, rsi\n    jz    .false        ; empty array, size = 0\n.loop:\n    cmp  edx,[rdi]\n    je   .true          ; value found\n    add  rdi, 4         ; to next int\n    dec  rsi            ; counter\n    jnz  .loop          ; until all items comapred\n.false\n    xor  rax, rax       ; empty or not found: return false\n    ret\n.true\n    mov  rax, 1         ; value found: return true\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212206,"user_id":null,"body":"SECTION .text\nglobal include\ninclude:\n  mov   rcx,rsi\n  xor   rax,rax\n  jrcxz .q\n  mov   rax,rdx\n  repne scasd\n  sete  al\n  .q\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212207,"user_id":null,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\ninclude:\n  cmp rsi, 0 ; WTF \"The expression (include(((void *)0), 0, 0)) == (0) is false\"\n  jz false\n  \n  mov rax, rdx\n  mov rcx, rsi\n  repne scasd\n  jnz false\n  mov rax, 1\n  ret\nfalse:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212208,"user_id":null,"body":"\nSECTION .text\nglobal include\n\n\ninclude:\n  xor rax, rax\n  cmp rsi, 0\n  jz  .exit\n  \n  mov rcx, rsi\n  \n.loop:\n  cmp dword [rdi + 4 * rcx - 4], edx\n  je  .true\n  loop .loop\n  jmp .exit\n  \n.true:\n  inc rax\n\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212209,"user_id":50,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\ninclude:\n  xor rax, rax\n_parse:\n  cmp esi,0\n  je _exit\n  dec esi\n  mov ebx,[rdi]\n  cmp ebx,edx\n  je _found\n  add rdi,4\n  jmp _parse\n_found:\n  mov rax,1\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212210,"user_id":null,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\ninclude:\n  xor eax, eax\n  test rsi, rsi\n  jz .done\n  .loop:\n  cmp [rdi+rsi*4], edx\n  sete al\n  je .done\n  dec rsi\n  test rsi, rsi\n  jnz .loop\n  .done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212211,"user_id":null,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\ninclude:\n  xor rax, rax\n  cmp rsi,0\n  je .exit\n.lo:\n  cmp edx,dword [rdi+(rsi * 4)]\n  je .true\n  dec rsi\n  cmp rsi,0\n  jne .lo\n.exit:\n  ret\n.true:\n  mov al,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212212,"user_id":null,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\n; rdi = array\n; rsi = size\n; rdx = item\ninclude:\n  xor rax, rax\n  mov rax, 0\nloop:\n  cmp rsi, 0\n  jz  end\n  cmp DWORD[rdi], edx\n  jz true\n  add rdi, 4\n  dec rsi\n  jmp loop\ntrue:\n  mov rax, 1\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212213,"user_id":null,"body":"SECTION .text\nglobal include\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\ninclude:\n  xor rax, rax\n  cmp rsi, 0 ;size\n  je exit\nloop:\n  mov ebx, [rdi]\n  cmp edx, ebx\n  je found\n  add rdi, 4  ;move pointer to next element\n  dec rsi     ;decrement counter\n  jnz loop    ;if counter not 0, then loop\n  jmp exit\nfound:\n  mov rax, 1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212214,"user_id":null,"body":"global include\n\nsection .text\n\n; bool include(const int* arr, size_t size, int item)\n; sizeof(int) = 4\n; sizeof(size_t) = 8\ninclude:\n  dec rsi\n  cmp rsi, 0\n  jl .not_found\n  cmp [rdi + rsi * 4], edx\n  je .found\n  jmp include\n  .not_found:\n    mov rax, 0\n    ret\n  .found:\n    mov rax, 1\n    ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"545993ee52756d98ca0010e1":[{"id":212215,"user_id":null,"body":"SECTION .text\nglobal none\n\nnone:\n  push r15\n  push r14\n  push r12\n  push rbx\n  push rax\n  mov r14, rdx\n  mov r12, rsi\n  mov r15, rdi\n  xor ecx, ecx\n.loop:\n  mov rbx, rcx\n  cmp r12, rcx\n  je .done\n  mov edi, [r15 + 4*rbx]\n  call r14\n  lea rcx, [rbx + 1]\n  test al, al\n  je .loop\n.done:\n  cmp rbx, r12\n  setae al\n  add rsp, 8\n  pop rbx\n  pop r12\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212216,"user_id":null,"body":"%macro mypusha 0\n  push rbx\n  push rcx\n  push rdx\n  push rdi\n  push rsi\n%endmacro\n\n%macro mypopa 0\n  pop rsi\n  pop rdi\n  pop rdx\n  pop rcx\n  pop rbx\n%endmacro\n;rdi\trsi\trdx\nSECTION .text\nglobal none\n\nnone:\n  xor rax, rax\nlp:\n  mov rax,1\n  cmp rsi,0 \n  je ende\n  dec rsi\n  mov rbx, [rdi+4*rsi]\n  mypusha\n  mov rdi,rbx\n  call rdx\n  mypopa\n  cmp al, 1\n  je endeFalse\n  xor rax, rax\n  mov rax,1\n  cmp rsi, 0\n  je ende\n  jmp lp\nendeFalse:\n  mov rax,0\nende:\n  ret\n  \n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212217,"user_id":null,"body":"SECTION .text\nglobal none\n\nnone:\n  cmp   rsi, 0\n  je    .true\n  .loop:\n  push  rdi\n  push  rsi\n  push  rdx\n  mov   edi, dword [rdi]\n  call  rdx\n  cmp   al, 1\n  je    .end\n  pop   rdx\n  pop   rsi\n  pop   rdi\n  add   rdi, 4\n  dec   rsi\n  jnz   .loop\n  .true:\n  mov   al, 1\n  ret\n  .end:\n  pop   rdx\n  pop   rsi\n  pop   rdi\n  mov   al, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212218,"user_id":null,"body":"SECTION .text\nglobal none\n\nnone:\n  push rbx\n  push rbp\n  push r12\n  push r13\n  mov rbx, rdi\n  mov rbp, rsi\n  mov r12, rdx\n  test rbp, rbp\n  setz al\n  jz .done\n  xor r13, r13\n  .loop:\n  cmp r13, rbp\n  jg .done\n  mov edi, dword [rbx+r13*4]\n  call r12\n  test al, al\n  setz al\n  jnz .done\n  inc r13\n  jmp .loop\n  .done:\n  pop r13\n  pop r12\n  pop rbp\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212219,"user_id":104,"body":"; 2021 nomennescio\nSECTION .text\nglobal none\n\n; bool none (const int* arr, size_t size, bool (*fun)(int));\n; rax                   rdi         rsi          rdx\n\nnone:\n  cmp rsi, 0\n  je true\n  mov r8, rdi\n  mov r9, rdx\nloop:\n  mov edi, [r8+4*rsi-4]\n  call r9\n  cmp al, 0\n  mov al, 0\n  jne exit\n  dec rsi\n  jne loop\ntrue:\n  mov al, 1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212220,"user_id":null,"body":"SECTION .text\nglobal none\n\nnone:\n  cmp rsi, 0\n  jz .exit\n  \n.for:\n  push rdi\n  push rsi\n  push rdx\n  \n  mov edi, dword [rdi + rsi * 4 - 4]\n  call rdx\n  \n  pop rdx\n  pop rsi\n  pop rdi\n  \n  cmp al, 1\n  je .false\n  dec rsi\n  jnz .for\n  \n.exit:\n  mov rax, 1\n  ret\n  \n.false:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212221,"user_id":50,"body":"SECTION .text\nglobal none\n\nnone: \n  xor rax, rax\n  mov r8,rdi ; save array\n  mov r10,rdx ; save fn\n  xor r11,r11 ; indexer\n_loop:\n  cmp r11,rsi\n  je _exit\n  mov edi,[r8]\n  add r8,4\n  inc r11\n  call r10\n  cmp eax,1\n  je _retFalse\n  jmp _loop\n_retFalse:\n  mov rax,0\n  ret\n_exit:\n  mov rax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212222,"user_id":null,"body":"SECTION .text\nglobal none\n\n; input\n;    rdi - pointer to array of int\n;    rsi - number of elements in the array\n;    rdx - pointer to function of int return bool\n; output\n;    rax - true if none function calls return true\nnone:\n    push  r12\n    push  r13\n    push  r14\n    mov   r12,rsi         ; counter\n    test  r12,r12\n    jz    .returntrue     ; 0 array length: return true\n    mov   r13,rdi         ; pointer to current int in the array\n    test  r13,r13\n    jz    .returntrue     ; null pointer to array: return true\n    mov   r14,rdx         ; function address\n    test  r14,r14\n    jz    .returntrue     ; null pointer to function: return true\n.loop:\n    mov   edi,[r13]\n    call  r14            ; call function with current int\n    test  al,al          ; bool is returned in al, ignore the other bits\n    jnz   .returnfalse   ; funtion returns true: return false\n    add   r13,4          ; no next array int\n    dec   r12\n    jnz   .loop          ; next array item or return false\n.returntrue:    \n    mov   rax,1          ; none function returns true: return true\n    jmp   .return\n.returnfalse:\n    xor   rax,rax         ; return false\n.return\n    pop   r14\n    pop   r13\n    pop   r12\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212223,"user_id":null,"body":"SECTION .text\nglobal none\n\nnone:\n  mov rcx, rsi\n  xor rax, rax\n  test rcx, rcx\n  jz ret_b\n  \nloop_begin:\n  push rcx\n  push rdx\n  push rsi\n  push rdi\n  \n  mov rax, QWORD [rdi]\n  mov rdi, rax\n  call rdx\n  \n  pop rdi\n  pop rsi\n  pop rdx\n  pop rcx\n \n  test rax, 1\n  jne ret_a\n \n  add rdi, 4\n  loop loop_begin\n  jmp ret_b\n  \nret_a:\n  mov rax, 0\n  ret\nret_b:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212224,"user_id":null,"body":"SECTION .text\nglobal none\n\nnone:\n  mov rcx,rsi\n  xor rax,rax\n  jrcxz .e\n  jmp .s\n  .b:push rdi\n     push rdx\n     push rcx\n     mov  edi,[rdi+rcx*4]\n     call rdx\n     pop  rcx\n     pop  rdx\n     pop  rdi\n     test al,al\n  .s:\n  loope .b\n  .e:\n  xor al,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54599705cbae2aa60b0011a4":[{"id":212225,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n  push r14\n  mov r14, rdx\n  push r13\n  mov r13, rdi\n  push r12\n  mov r12, rsi\n  push rbp\n  xor ebp, ebp\n  push rbx\n  xor ebx, ebx\n.loop:\n  cmp rbp, r12\n  je .done\n  mov edi, [r13+rbp*4]\n  call r14\n  test al, al\n  je .not\n  test ebx, ebx\n  jne .false\n  mov ebx, 1\n.not:\n  inc rbp\n  jmp .loop\n.done:\n  mov eax, ebx\n  and eax, 1\n  jmp .restore\n.false:\n  xor eax, eax\n.restore:\n  pop rbx\n  pop rbp\n  pop r12\n  pop r13\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212226,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n\n  %push mycontext             ; save the current context \n  %stacksize flat64           ; tell NASM to use rbp \n  %assign %$localsize 0       ; init localsize\n  %local rest:qword           ; #rest elements in the array\n  %local counter:byte         ; count of true returns\n  %local arr:qword            ; base of the array\n  %local fun:qword            ; pointer to the function\n\n    enter   %$localsize,0     ; reserve local storage on stack\n\n    ; init local variabales\n    mov [rest], rsi\n    mov [fun], rdx\n    xor rcx, rcx\n    mov [counter], cl\n    jmp .check\n    ; loop over the array\n.loop:    \n    mov [arr], rdi            ; save current pointer in the array\n    mov edi, [rdi]            ; read int from the array\n    call [fun]                ; call fun with array element as 1st parameter\n    cmp al, 1                 ; only byte 1 is accepted as true. All other values: false.\n    jne .false                ; function returns false\n    inc byte [counter]        ; function returns true -> count the true\n    cmp byte [counter], 1\n    je .false\n    xor rax, rax\n    jmp .exit                 ; quick exit 2 times true -> return false\n.false:\n    mov rdi, [arr]\n    add rdi, 4                ; rdi to next element in the array\n.check:\n    dec qword [rest]          ; reduce rest elements count\n    jns  .loop\n    xor rax, rax\n    mov al, [counter]         ; counter = 1: return true \/ counter = 0: return false\n.exit:\n    leave                     ; free local storage\n    ret\n  \n  %pop                        ; restore original context\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212227,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n  test rsi, rsi ; check if the array is empty\n  jz .empty     ; if so, jump to .empty\n  ; save registers to be used (all preserved so they aren't clobbered)\n  push rbx ; index\n  push r12 ; array ptr\n  push r13 ; func ptr\n  push r14 ; count\n  mov rbx, rsi ; move parameters into preserved registers\n  dec rbx\n  mov r12, rdi\n  mov r13, rdx\n  xor r14, r14\n  .loop:\n    mov edi, [r12 + rbx * 4] ; retrieve value\n    call r13                 ; call the function\n    add r14b, al             ; tally the result (upper 7 bytes of rax are garbage)\n    dec rbx                  ; keep looping until we're done\n    jns .loop\n  xor eax, eax               ; technically not neccesary, but removes a dependency, I think\n  cmp r14, 1                 ; check if the count is one\n  sete al                    ; set rax accordingly\n  pop r14                    ; restore the registers we used\n  pop r13\n  pop r12\n  pop rbx\n  ret                        ; return\n  .empty: ; return false\n    xor eax, eax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212228,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n  cmp rsi, 0\n  jz .false\n  \n  lea r8, [rdi]\n  lea r9, [rdx]\n  xor r10, r10\n  mov rcx, rsi\n  \n.for:\n  push r8\n  push r9\n  push r10\n  push rcx\n  \n  xor rdi, rdi\n  mov edi, dword [r8 + rcx * 4 - 4]\n  call r9\n  \n  pop rcx\n  pop r10\n  pop r9\n  pop r8\n  \n  add r10b, al\n  cmp r10, 1\n  jg .false\n  loop .for\n  \n  mov rax, r10\n  ret\n  \n.false:\n  xor rax, rax\n  ret\n\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212229,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n  cmp rsi, 0\n  je .ret\n  \n  mov rcx, rsi\n  mov rsi, rdi\n  xor rax, rax\n  xor rbx, rbx\n  \n.loop:\n  mov rdi, qword [rsi + rcx * 4 - 4]\n  push rcx\n  push rdx\n  call rdx\n  pop rdx\n  pop rcx\n  and rax, 1\n  add rbx, rax\n  loop .loop\n  \n  cmp rbx, 1\n  sete al\n.ret:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212230,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n  cmp rsi, 0\n  je .ret\n  \n  mov rcx, rsi\n  mov rsi, rdi\n  xor rax, rax\n  xor rbx, rbx\n  \n.loop:\n  mov rdi, qword [rsi + rcx * 4 - 4]\n  push rcx\n  push rdx\n  call rdx\n  pop rdx\n  pop rcx\n  and rax, 1\n  add rbx, rax\n  loop .loop\n  \n  mov rax, rbx\n  cmp rax, 1\n  je .ret\n  mov rax, 0\n.ret:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212231,"user_id":50,"body":"SECTION .text\nglobal one\n\none:\n  xor rax, rax\n  mov r8,rdi ; save array\n  mov r10,rdx ; save fn\n  xor r11,r11 ; indexer\n  xor r9,r9 ; counter\n_loop:\n  cmp r11,rsi\n  je _exit\n  mov edi,[r8]\n  add r8,4\n  inc r11\n  call r10\n  cmp eax,1\n  je _up\n  jmp _loop\n_up:\n  inc r9\n  jmp _loop\n_exit:\n  cmp r9,1\n  jne _retFalse\n  mov rax,1\n  ret\n_retFalse:\n  mov rax,0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212232,"user_id":null,"body":"SECTION .text\nglobal one\n\none:\n  push rbp\n  mov rbp, rsp\n  push 0\n  push 0\n  \n  mov rcx, rsi\n  mov rsi, rdi\n.next:\n  dec rcx\n  js .done\n  lodsd\n  call call_once\n  test al, al\n  jz .next\n  xor [rsp], al\n  jnz .next\n\n.done:\n  pop rax\n  mov rsp, rbp\n  pop rbp\n  ret\n\ncall_once:\n  push rbp\n  mov rbp, rsp\n  push rdi\n  push rsi\n  push rdx\n  push rcx\n  mov edi, eax\n  call rdx\n  pop rcx\n  pop rdx\n  pop rsi\n  pop rdi\n  \n  mov rsp, rbp\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212233,"user_id":77,"body":"SECTION .text\nglobal one\nextern print\none:\n  push rbx\n  push r12\n  push r13\n  push r14\n  xor r12, r12\n  test rsi, rsi\n  jz .end\n  mov rbx, rdi\n  lea r14, [rbx+4*rsi]\n  mov r13, rdx\n.loop:\n  mov rdi, [rbx]\n  add rbx, 4\n  call r13\n  movzx rax, al\n  add r12, rax\n  cmp rbx, r14\n  jb .loop\n.end:\n  xor rax, rax\n  cmp r12, 1\n  sete al\n  pop r14\n  pop r13\n  pop r12\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212234,"user_id":527,"body":"section .text\nglobal one\n\none:\n                push    rbx\n                push    rbp\n                push    r12\n                mov     rbx, rdi\n                lea     rbp, [rdi + rsi * 4]\n                mov     r12, rdx\n.find_first:    cmp     rbx, rbp\n                je      .ret_false\n                mov     edi, [rbx]\n                add     rbx, 4\n                call    r12\n                test    al, al\n                jz      .find_first\n.find_second:   cmp     rbx, rbp\n                je      .ret_true\n                mov     edi, [rbx]\n                add     rbx, 4\n                call    r12\n                test    al, al\n                jz      .find_second\n.ret_false:     xor     eax, eax\n                pop     r12\n                pop     rbp\n                pop     rbx\n                ret\n.ret_true:      mov     eax, 1\n                pop     r12\n                pop     rbp\n                pop     rbx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"546e0773fa8da2013200087a":[{"id":212235,"user_id":null,"body":"global big_modulo\nextern strlen,__umodti3\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\n; input: rdi = num_string\n;        rsi = divisor\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nbig_modulo:\n  push r15\n  push r14\n  push r12\n  push rbx\n  push rax\n  mov r14, rsi\n  mov r15, rdi\n  call strlen\n  mov rbx, rax\n  xor eax, eax\n  push 10\n  pop r12\n.loop:\n  sub rbx, 1\n  jb .done\n  movsx ecx, byte [r15]\n  mul r12\n  add ecx, -48\n  movsxd rdi, ecx\n  mov rsi, rdi\n  sar rsi, 63\n  add rdi, rax\n  adc rsi, rdx\n  mov rdx, r14\n  xor ecx, ecx\n  call __umodti3\n  inc r15\n  jmp .loop\n.done:\n  add rsp, 8\n  pop rbx\n  pop r12\n  pop r14\n  pop r15\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212236,"user_id":null,"body":"global big_modulo\n\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\n; input: rdi = num_string\n;        rsi = divisor\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nbig_modulo:\n  xor edx, edx\n  \n.loop:\n  movzx ecx, byte [rdi]\n  inc rdi\n  test ecx, ecx\n  jz .done\n  sub ecx, '0'\n  \n  mov rax, rdx\n  mov edx, 10\n  mul rdx\n  add rax, rcx\n  adc rdx, 0\n  \n  div rsi\n  jmp .loop\n  \n.done:\n  mov rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212237,"user_id":null,"body":"global big_modulo\n\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\n; input: rdi = num_string\n;        rsi = divisor\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nbig_modulo:\n  xchg rsi,rdi      ; RSI = 'source index'\n  mov r8,10         ; Multiplier\n  xor rcx,rcx       ; RCX = accumulator\n  jmp .digit_load\n.digit:\n  sub al,'0'        ; Assume it is actually a digit\n  movzx rax,al      ; RAX = digit\n  xchg rax,rcx      ; RAX = accumulator, RCX = digit\n  mul r8            ; accumulator *= 10\n  add rax,rcx       ; Add the digit\n  adc rdx,0 \n  div rdi           ; Modulus into RDX\n  mov rcx,rdx       ; RCX = new accumulator\n.digit_load:\n  lodsb             ; Get next digit\n  test al,al        ; Is there a digit?\n  jnz .digit\n  mov rax,rcx       ; Return accumulator\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212238,"user_id":null,"body":"global big_modulo\n\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\n; input: rdi = num_string\n;        rsi = divisor\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\n\nbig_modulo:\n        xor r8, r8      ; result\n        mov r9, qword 1 ; power of 10\n        xor r10, r10    ; index\n        mov r11, 10     ; 10\n  .find_len: \n        inc r10\n        cmp [rdi + r10], byte 0\n        jne .find_len\n        dec r10\n  .main_loop:\n        xor rax,rax\n        mov al, [rdi + r10]\n        sub rax, 0x30\n        mul r9\n        add rax, r8\n        jnc .short\n        inc rdx\n  .short:\n        div rsi\n        mov r8, rdx\n        mov rax, r9\n        mul r11\n        div rsi\n        mov r9, rdx\n        dec r10\n        jns .main_loop\n        mov rax, r8\n        ret\n        \n        \n        ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212239,"user_id":77,"body":"global big_modulo\n\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\n; input: rdi = num_string\n;        rsi = divisor\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nbig_modulo:\n  xor r8, r8\n  mov r9, 1\n  mov rcx, -1\n  xor al, al\n  cld\n  repnz scasb\n  neg rcx\n  dec rdi\n  sub rcx, 2\n.loop:\n  dec rdi\n  movzx rax, byte [rdi]\n  sub al, 0x30\n  mul r9\n  add rax, r8\n  adc rdx, 0\n  div rsi\n  mov r8, rdx\n  mov rax, 10\n  mul r9\n  div rsi\n  mov r9, rdx\n  loop .loop\n.end:\n  mov rax, r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212240,"user_id":527,"body":"global big_modulo\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\nbig_modulo:\n                xor     edx, edx\n                movzx   ecx, byte [rdi]\n                sub     ecx, '0'\n.loop:          mov     eax, 10\n                mul     rdx\n                add     rax, rcx\n                adc     edx, 0\n                div     rsi\n                inc     rdi\n                movzx   ecx, byte [rdi]\n                sub     ecx, '0'\n                jnc     .loop\n                mov     rax, rdx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212241,"user_id":168,"body":"global big_modulo\n\nsection .text\n\n; uint64_t big_modulo(const char *num_string, uint64_t divisor)\nbig_modulo:\n  xor edx, edx\n  movzx ecx, byte [rdi]\n.loop:\n  mov eax, 10\n  mul rdx\n  sub ecx, '0'\n  add rax, rcx\n  adc rdx, 0\n  div rsi\n  inc rdi\n  movzx ecx, byte [rdi]\n  test ecx, ecx\n  jnz .loop\n  mov rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"546e2562b03326a88e000020":[{"id":212242,"user_id":168,"body":"global sqrdigs\n\nsection .text\n\n; <-- RAX sqrdigs(EDI n) -->\nsqrdigs:\n  mov eax, edi\n  xor edi, edi\n  mov esi, 1\n  mov r8d, 10\n.loop:\n  xor edx, edx\n  div r8d\n  mov ecx, 100\n  cmp edx, 3\n  cmovbe ecx, r8d\n  imul edx, edx\n  imul rdx, rsi\n  add rdi, rdx\n  imul rsi, rcx\n  test eax, eax\n  jnz .loop\n  mov rax, rdi\n  ret\n; -----> endof sqrdigs <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212243,"user_id":null,"body":"global sqrdigs\n\nsection .text\n\n; <-- RAX sqrdigs(EDI n) -->\nsqrdigs:\n  mov eax, edi\n  xor esi, esi\n  mov rdi, 1\n  mov r8, 10\n.loop:\n  test eax, eax\n  je .done\n  xor edx, edx\n  div r8d\n  mov ecx, edx\n  imul rcx, rcx\n  imul rcx, rdi\n  add rsi, rcx\n  cmp edx, 4\n  sbb rdx, rdx\n  and rdx, -90\n  add rdx, 100\n  imul rdi, rdx\n  jmp .loop\n.done:\n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212244,"user_id":null,"body":"global sqrdigs\n\nsection .text\n\n; <-- RAX sqrdigs(EDI n) -->\nsqrdigs:\n    push -1\n    mov ecx, 10\n    mov eax, edi\n    \n.loop1:\n    xor edx, edx\n    div ecx\n    push rdx\n    test eax, eax\n    jnz .loop1\n\n    xor eax, eax\n.loop2:\n    pop rdx\n    cmp edx, -1\n    je .done\n    imul edx, edx\n    lea rax, [rax*5]\n    cmp edx, 10\n    jl .skip\n    add rax, rax\n    lea rax, [rax*5]\n.skip:\n    lea rax, [rdx+rax*2]\n    jmp .loop2\n    \n.done:\n    ret\n; -----> endof sqrdigs <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212245,"user_id":null,"body":"global sqrdigs\n\nsection .text\n\n; <-- RAX sqrdigs(EDI n) -->\nsqrdigs:\n    xor rsi,rsi            ; the result\n    xor ebx,ebx\n    mov rax,rdi            ; the argument\n    mov rdi,1              ; multiplier    \nloop_start:\n    mov rcx,10\n    xor rdx,rdx\n    idiv rcx\n    cmp rdx,4  \n    jb less4   \nmore4:\n    mov rcx,100\n    jmp process\nless4:    \n    mov rcx,10\nprocess:  \n    mov rbx,rdx\n    imul rbx,rdx ; squaring\n    imul rbx,rdi ; shifting result by multiplier\n    add rsi,rbx  ; adding shifted square to result (stored in ESI)\n    imul rdi,rcx ; incrementing multiplier\nloop_end:\n    test rax,rax\n    jnz loop_start\n    mov rax,rsi\n    ret\n; -----> endof sqrdigs <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212246,"user_id":null,"body":"global sqrdigs\n\nsection .text\n\nsqrdigs:\n  mov r15, rsp\n  xor rax, rax\n  xor rdx, rdx\n  xor r10, r10\n  mov rax, rdi\n  mov r8, 10\n  \nmain_loop:\n  cmp rax, 0\n  jle ans\n  div r8\n  mov r9, rdx\n  xor rdx, rdx\n    \nsquare:\n  push r9\n  add r10, 1\n  jmp main_loop\n  \n\nans:\n  xor rax, rax\n  xor rbx, rbx\n  mov rcx, r10\n  cmp rcx, 0\n  jle stop\n\nans_loop:\n  pop rax\n  cmp rax, 3\n  mov r12, 10\n  mov r13, 100\n  cmova r12, r13\n  mul rax  \n  mov r11, rax  \n  mov rax, rbx\n  mul r12\n  add rax, r11\n  mov rbx, rax\n  \n  loop ans_loop\n\nstop:\n\n  mov rax, rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212247,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                         Written by Ali Muhammed\n;                           uniapi@outlook.com\n;                           September 29, 2021\n; ----------------------------------------------------------------------\n\nglobal sqrdigs\n\nsection .text\n\n; <-- RAX sqrdigs(EDI n) -->\nsqrdigs:\n    xor r10, r10            ; reseting R10 as <q>\n    mov r8d, 10\n    mov r9d, 100\n    mov rsi, 1              ; setting RSI to one as <f>actor\n.loop:\n    mov eax, edi            ; copying <n> to EAX\n    xor edx, edx            ; resetting EDX before division\n    div r8d                 ; separating the last digit in <n>\n    mov edi, eax            ; copying <n> to EDI\n    cmp edx, 3              ; whether the last digit is above three\n    cmova ecx, r9d          ; then setting <m>ultiplier to 100\n    cmovbe ecx, r8d         ; otherwise, setting <m>ultiplier to 10\n    mov eax, edx            ; copying the last digit to EAX\n    mul eax                 ; squaring the last digit\n    mul rsi                 ; multiplying the squared last digit\n    add r10, rax            ; adding the multiplied squared last digit to <q>\n    mov rax, rsi            ; copying <f>actor to RAX\n    mul rcx                 ; shifting <factor>\n    mov rsi, rax            ; copying <f>actor to RSI\n    test edi, edi           ; whether <n> is zero\n    jne .loop               ; otherwise, jumping to the next iteration\n    mov rax, r10            ; copying <q> to RAX as the result\n    ret\n; -----> endof sqrdigs <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"546f922b54af40e1e90001da":[{"id":212248,"user_id":null,"body":"[BITS 64]\nsection .text\n\n;;\n; C-signature:\n;     void *malloc(size_t length)\n;     [rax]        [rdi]\nextern malloc\n\n;;\n; C-signature:\n;     void *realloc(void *ptr, size_t new_length)\n;     [rax]         [rdi]      [rsi]\nextern realloc\n\nglobal alphabet_position\n;;\n; C-signature:\n;     char *alphabet_position(const char *text)\n;     [rax]                   [rdi]\n;\n; Replace every letter in the input string (text) with its position in the\n; alphabet (a = 1, b = 2, ...) and ignore all other characters. Return the\n; result in a string with every letter position seperated by one space\n; character.\n;\n; Register usage:\n;     [rax] temporary storage and result\n;     [rcx] index into the result text\n;     [rdx] store the transformed letters\n;     [rsi] pointer into (text)\n;     [r8]  pointer to the result text\n;\n; @param text [rdi] pointer to a null-terminated string\n; @return null-terminated string with all letters replaced by\n;         their position in the alphabet\n;\nalphabet_position:\n\tpush rdi\n\t; First, we determine the length of the input string (text) and allocate\n\t; more than enough space to produce our output string. In a worst-case\n\t; scenario, the output needs 3 bytes per input character (2 bytes for a\n\t; two-digit number and one byte for a space character). We use 4 times the\n\t; size of the input string because it is easier to calculate (shift by 2)\n\t; and is always large enough.\n\tcall strlen\n  ; To make sure we have at least a length of 1, we add 1 to the determined\n  ; length. This way, we always have at least 4 characters for our result\n  ; even if it only has to contain the null-byte.\n  inc rax\n\tshl rax, 2\n\tmov rdi, rax\n\tcall malloc WRT ..plt\n\tpop rsi\n\tmov rdi, rax\n\t; We have to reset our counter as well as rax. We use rax as an index into\n\t; our array of BCD numbers. For that we need the upper part of the register\n\t; to be zero because we will only manipulate the lower byte of rax.\n\txor ecx, ecx\n\txor eax, eax\n\tlea r8, [rel .bcd_numbers]\n\t; We want to have the increment at the top of the loop, so to get the\n\t; first address right, we decrement right before entering the loop.\n\tdec rsi\n.next:\n\tinc rsi\n\tmov al, byte [rsi];\n\tcmp al, 0\n\tjz .end\n\t; Or'ing the character with 0x20 will set it to lower case (if it was\n\t; a letter) and allows us to treat upper case and lower case letters the\n\t; same.\n\tor al, 0x20\n\tcmp al, 'a'\n\tjl .next\n\tcmp al, 'z'\n\tjg .next\n\t; We subtract 'a', which is 0x61 in hexadecimal, to get our zero-based\n\t; index into the BCD number array.\n\tsub al, 'a'\n  ; We reset dx holding our two digit result characters. (see below)\n  xor edx, edx\n\tmov dl, byte [r8 + rax]\n\t; We space out the two BCD digits by moving the 4 upper bits into the\n\t; higher byte and shifting only the lower 4 bits back.\n\t; Or'ing with 0x3030 will turn both bytes into the ASCII characters for\n\t; the digits ('0' ... '9'). We then decide whether we only need one or both\n\t; for the result.\n\tshl dx, 4\n\tshr dl, 4\n\tor dx, 0x3030\n\tcmp dh, 0x30\n\tjz .second_digit\n\tmov byte [rdi + rcx], dh\n\tinc rcx\n.second_digit:\n\tmov byte [rdi + rcx], dl\n\tinc rcx\n\t; We add a space character after each number added to our result string.\n\tmov byte [rdi + rcx], ' '\n\tinc rcx\n\tjmp .next\n.end:\n  ; If our result string is not empty, we override the last space character\n  ; with a zero-byte to terminate our string. The length of the string is\n  ; then one byte longer. After that, we re-allocate the memory to get rid\n  ; of the unused temporary memory. If our result string was empty, we only\n  ; skip moving back one character in our result string.\n  cmp rcx, 0\n  jz .empty_string\n\tdec rcx\n.empty_string:\n\tmov byte [rdi + rcx], 0\n\tinc rcx\n\tmov rsi, rcx\n\tcall realloc WRT ..plt\n  ret\n\n; This array of BCD numbers represents a compact way of translating the\n; hexadecimal values 0x00 to 0x1a into packed BCD. This allows us to then\n; convert them into printable digits.\n;\n; Example: We have 0xd (=13). This indexes 0x14 in our BCD array which is\n;          converted into '14' representing 'n'. 'n' is 0x6e in ASCII. If we\n;          subtract 'a' from it we get 0x6e - 0x61 = 0x0d => 13. So we have\n;          successfully translated from 'n' to '14'. (q.e.d.)\n;\nalign 8, db 0\n.bcd_numbers:\ndb\t0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08\ndb  0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16\ndb  0x17, 0x18, 0x19, 0x20, 0x21, 0x22, 0x23, 0x24\ndb  0x25, 0x26\n\n;;\n; C-signature:\n;    size_t strlen(const char *s)\n;    [rax]         [rdi]\n;\n; Calculate the length of the given null-terminated string (s).\n;\n; Register usage:\n;     [rax] temporary storage and result\n;     [rcx] length counter\n;     [rdi] pointer to the next character in the string\n;\n; @param s [rdi]  string to measure\n; @return the length of the string (s)\n;\nalign 8, db 0\nstrlen:\n  ; Note: We scan the given string for a null-byte.\n  ; We use rcx as a counter and make it as high as possible\n  ; by switching all bits on (actually becomes a negative number)\n  ; so that the rep prefix will not abort before scanning through\n  ; the whole string. Instead we will abort the repetion using \n  ; the not-zero (nz) condition. To get the positive size we have\n  ; to negate the result which will then be one larger than the\n  ; length of the string.\n  xor ecx, ecx\n  xor al, al\n  not rcx\n  cld\n  repnz scasb\n  neg rcx\n  dec rcx\n  mov rax, rcx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212249,"user_id":null,"body":"global alphabet_position\nextern malloc, realloc\n\nsection .text\n\nrealloc_str:\n  inc rcx\n\n  push rax\n  push rdx\n  push rdi\n  push rcx\n    \n  mov rdi, rsi\n  mov rsi, rcx\n  call realloc\n  mov rsi, rax\n  \n  pop rcx\n  pop rdi\n  pop rdx\n  pop rax\n    \n  mov rbx, rsi\n  add rbx, rcx\n  dec rbx\n\n  ret\n\nalphabet_position:\n  push rdi\n  \n  mov rdi, 1\n  call malloc\n  mov rsi, rax\n  mov rbx, rax\n  \n  pop rdi\n\n  xor rcx, rcx\n  xor rax, rax\n  xor rdx, rdx\n  \n.loop:\n  mov al, byte[rdi]\n    \n  cmp al, 0\n  je .loop_end\n    \n  cmp al, 'A'\n  jl .continue\n    \n  cmp al, 'z'\n  jg .continue\n    \n  cmp al, 'Z'\n  jle .uppercase\n\n  cmp al, 'a'\n  jl .continue\n  \n  sub al, 'a'\n  add al, 'A'\n\n.uppercase:\n\n  sub al, 'A'\n  inc al\n  xor dx, dx\n  mov r10w, 10\n  div r10w\n  cmp al, 0\n  je .single_digit\n    \n  call realloc_str\n  add al, '0'\n  mov byte[rbx], al\n    \n.single_digit:\n    \n  call realloc_str\n  add dl, '0'\n  mov byte[rbx], dl\n    \n  call realloc_str\n  mov byte[rbx], ' '\n    \n.continue:\n  \n  inc rdi\n  jmp .loop\n  \n.loop_end:\n  \n  mov byte[rbx], 0\n  \n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212250,"user_id":null,"body":"global alphabet_position\nextern malloc, realloc\n\nsection .text\n\n; <----- char *alphabet_position(const char *text) ----->\nalphabet_position:\n    push rbx                    ; saving RBX in the stack\n    sub rsp, 8                  ; aligning the stack boundary\n    push rdi                    ; saving <text> in the stack\n    xor rax, rax                ; resetting RAX\n    test rdi, rdi               ; whether <text> is NULL\n    je .exit                    ; jumping to exit\n    dec rax                     ; the initial value for <len>\n.strlen:\n    inc rax                     ; incrementing <len>\n    cmp byte [rdi+rax], 0       ; whether <str+len> is an empty character\n    jne .strlen                 ; otherwise jumping to .strlen\n    inc rax                     ; adding an extra byte for the null character\n    imul rdi, rax, 0h3          ; target bytes for <abcpos>\n    call malloc                 ; allocating memory\n    test rax, rax               ; whether the memory is allocated\n    je .exit                    ; otherwise, jumping to exit\n    mov rbx, [rsp]              ; restoring <text> from the stack\n    mov rdi, rax                ; copying the <abcpos> pointer to RDI\n    xor rsi, rsi                ; resetting RSI as <pos>\n    mov r10d, 10                ; will be used to get digits\n    mov r9d, 'a'                ; copying 'a' to R9B as will be used frequently\n    mov r8d, 'A'                ; copying 'A' to R8B as will be used frequently\n    mov byte [rdi], 0           ; copying the empty character for an empty string case\n.loop:\n    movzx eax, byte [rbx]       ; copying <*str> to <c>\n    test eax, eax               ; whether <c> is an empty character\n    je .pos                     ; jumping to the position section\n    cmp eax, r8d                ; whether <c> is below 'A'\n    jl .inc                     ; jumping to the increment section\n    cmp eax, 'Z'                ; whether <c> is inside the [A-Z] range\n    jle .cpy                    ; jumping to the copy section\n    cmp eax, r9d                ; whether <c> is below 'a'\n    jl .inc                     ; jumping to the increment section\n    cmp eax, 'z'                ; whether <c> is inside the [a-z] range\n    jg .inc                     ; jumping to the increment section\n.cpy:\n    cmp eax, r9d                ; whether <c> is in the upper case\n    cmovl ecx, r8d              ; copying 'A'\n    cmovge ecx, r9d             ; otherwise, copying 'a'\n    sub eax, ecx                ; getting the difference between ASCII codes\n    inc eax                     ; getting the alphabet position\n    mov rcx, 1                  ; setting the <pos> shift to one\n    cmp eax, r10d               ; whether the position contains one digit\n    jl .alone                   ; jumping to the alone digit section\n    xor edx, edx                ; resetting EDX before the division\n    div r10d                    ; separating digits\n    add edx, '0'                ; getting the second digit ASCII code\n    mov byte [rdi+rsi+1], dl    ; copying to <*(abcpos+pos+1)>\n    inc rcx                     ; incrementing the <pos> shift because there are two digits\n.alone:\n    add eax, '0'                ; getting the first digit ASCII code\n    mov [rdi+rsi], al           ; copying to <*(abcpos+pos)>\n    add rsi, rcx                ; increasing <pos> with the shift\n    mov byte [rdi+rsi], ' '     ; copying a space character to <*(abcpos+pos)>\n    inc rsi                     ; incrementing <pos>\n.inc:\n    inc rbx                     ; moving the <text> pointer to the next character\n    jmp .loop                   ; jumping to the next iteration\n.pos:\n    test rsi, rsi               ; whether <pos> is zero\n    je .re                      ; jumping to the reallocation section\n    dec rsi                     ; decrementing <pos> to clear a space character\n    mov byte [rdi+rsi], 0       ; setting the null character instead\n.re:\n    inc rsi                     ; incrementing <pos>\n    call realloc                ; shrinking the memory to the <abcpos> capacity\n.exit:\n    add rsp, 16                 ; destroying local storage and restoring the stack boundary\n    pop rbx                     ; restoring RBX from the stack\n    ret\n; ---------> end of abcpos <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212251,"user_id":null,"body":"global alphabet_position\nextern malloc, realloc\n\nsection .text\n\n; <----- char *alphabet_position(const char *text) ----->\nalphabet_position:\n  enter 16, 0\n  mov   [rbp-8], rdi\n  mov   byte [rbp-9], 10\n  mov   rdi, 1\n  call  malloc\n  mov   rdi, rax\n  mov   rsi, 1\n; rdi=output rsi=len+1 rdx=text\n  xor   rcx, rcx\n.loop:\n  mov   rdx, [rbp-8]\n  mov   al, [rdx]\n  xor   ah, ah\n  test  al, al\n  jz    .end\n  or    al, 0x20\n  cmp   al, 'a'\n  jl    .notalpha\n  cmp   al, 'z'\n  jg    .notalpha\n  sub   al, 'a'-1\n  add   rsi, 2\n  cmp   al, 10\n  jl    .l\n  inc   rsi\n.l:\n  push  rsi\n  push  rax\n  call  realloc\n  mov   rdi, rax\n  pop   rax\n  pop   rsi\n  mov   byte [rdi+rsi-2], ' '\n  div   byte [rbp-9]\n  add   ah, '0'\n  mov   [rdi+rsi-3], ah\n  test  al, al\n  jz    .notalpha\n  add   al, '0'\n  mov   [rdi+rsi-4], al\n.notalpha:\n  inc   dword [rbp-8]\n  jmp   .loop\n\n.end:\n  sub   rsi, 3\n.l2:\n  inc   rsi\n  js    .l2\n  mov   byte [rdi+rsi], 0\n  mov   rax, rdi\n  leave\n  ret\n; ---------> end of abcpos <---------\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212252,"user_id":null,"body":"global alphabet_position\nextern malloc,strdup\n\nsection .text\n\n; <----- char *alphabet_position(const char *text) ----->\nalphabet_position:\n  push rbx\n  mov rbx, rdi\n  mov rcx, rdi\n  xor r8d, r8d\n  xor edi, edi\n.countlength:\n  mov dl, [rcx]\n  test dl, dl\n  je .lengthend\n  mov eax, edx\n  and dl, -40\n  xor esi, esi\n  and al, -33\n  add al, -65\n  cmp dl, 72\n  setae sil\n  or rsi, 2\n  cmp al, 26\n  cmovae rsi, r8\n  inc rcx\n  add rdi, rsi\n  jmp .countlength\n.lengthend:\n  test rdi, rdi\n  je .noletters\n  call malloc\n  mov rcx, rax\n  mov dl, 10\n  mov rsi, rax\n.loop:\n  mov al, [rbx]\n  test al, al\n  je .done\n  and al, -33\n  lea edi, [rax - 65]\n  cmp dil, 25\n  ja .notletter\n  cmp al, 74\n  jb .singledigit\n  add al, -64\n  movzx eax, al\n  div dl\n  movzx edi, ah\n  or dil, 48\n  add al, 48\n  mov [rsi], al\n  mov [rsi + 1], dil\n  add rsi, 2\n  jmp .next\n.singledigit:\n  add al, -16\n  mov [rsi], al\n  inc rsi\n.next:\n  mov byte [rsi], 32\n  inc rsi\n.notletter:\n  inc rbx\n  jmp .loop\n.done:\n  mov byte [rsi - 1], 0\n  mov rax, rcx\n  pop rbx\n  ret\n.noletters:\n  mov edi, .empty\n  pop rbx\n  jmp strdup\n.empty: db 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212253,"user_id":null,"body":"; fast isalpha details - https:\/\/stackoverflow.com\/questions\/31824441\/how-can-i-check-if-a-character-is-a-letter-in-assembly\/31824566#31824566\n\nglobal alphabet_position\nextern malloc, realloc\n\nsection .text\n\n; <----- char *alphabet_position(const char *text) ----->\nalphabet_position:\n  push rbp                          ; for alignment\n  push r12                          ; src ptr\n  push r13                          ; out index\n  push r14                          ; current char\n  push r15                          ; out ptr\n  xor r15d, r15d                    ; zero out ptr\n  mov r12, rdi                      ; set src ptr\n  xor r13d, r13d                    ; zero out index\n  jmp .continue\n.loop:\n  inc r12                           ; prepare to read next character\n  or r14b, 0x20                     ; set alpha lower bit\n  sub r14b, 'a'                     ; base zero offset alpha\n  cmp r14b, 'z'-'a'                 ; check if in alpha range\n  ja .continue                      ; skip if not in alpha range\n  mov rdi, r15                      ; grow out buffer ..\n  lea rsi, [r13 + 3]                ; .. \n  call realloc                      ; .. by three bytes\n  mov r15, rax                      ; remember new out buffer\n  inc r14b                          ; add one to char for base one offset alpha\n  xor edx, edx                      ; zero high dividend\n  movzx eax, r14b                   ; set low dividend\n  mov ecx, 10                       ; set divisor\n  div ecx                           ; div into eax, edx\n  test al, al                       ; check if first digit is zero\n  jz .second_digit                  ; skip first digit if it is zero\n  lea r14d, [eax + '0']             ; load first digit char\n  mov [r15 + r13], r14b             ; write first digit char\n  inc r13                           ; move index forward\n.second_digit:\n  lea r14d, [edx + '0']             ; load second digit char\n  mov [r15 + r13], r14b             ; write second digit char\n  mov [r15 + r13 + 1], byte ' '     ; write space char\n  add r13, 2                        ; move index forward\n.continue:\n  mov r14b, [r12]                   ; load next char\n  test r14b, r14b                   ; check if char is nul\n  jnz .loop                         ; goto primary loop if char is not nul\n  test r15, r15                     ; check out buffer was allocated\n  jz .empty_exit                    ; goto empty exit if out buffer wasn't allocated\n  mov [r15 + r13 - 1], r14b         ; otherwise nul terminate the out buffer and ..\n  mov rdi, r15                      ; ..\n  mov rsi, r13                      ; ..\n  call realloc                      ; .. shrink to fit ..\n  jmp .exit                         ; .. then exit\n.empty_exit:\n  mov edi, 1                        ; ..\n  call malloc                       ; alloc small buffer\n  mov [rax], r15b                   ; nul terminate the out buffer\n.exit:\n  pop r15\n  pop r14\n  pop r13\n  pop r12\n  pop rbp\n  ret\n; ---------> end of abcpos <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212254,"user_id":null,"body":"global alphabet_position\nextern malloc, strlen\n\nsection .text\n\n; <----- char *alphabet_position(const char *text) ----->\nalphabet_position:\n  push rdi\n  call strlen\n  lea rdi, [rax*3+1]\n  call malloc\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  lea rcx, [string]\n  \n.loop:\n  mov dl, [rsi]\n  inc rsi\n  test dl, dl\n  jz .done\n  sub dl, 'A'\n  cmp dl, 26\n  jb .write\n  sub dl, 0x20\n  cmp dl, 26\n  jae .loop\n  \n.write:\n  movzx edx, dl\n  mov edx, [rcx+rdx*4]\n  mov [rdi], edx\n  add rdi, 2\n  cmp dh, ' '\n  je .loop\n  inc rdi\n  jmp .loop\n\n.done:\n  mov [rdi], dl\n  cmp rax, rdi\n  je .quit\n  mov [rdi-1], dl\n.quit:\n  ret\n; ---------> end of abcpos <---------\n\nsection .rodata\nstring:\ndd \"1 \", \"2 \", \"3 \", \"4 \", \"5 \", \"6 \", \"7 \", \"8 \", \"9 \", \"10 \"\ndd \"11 \", \"12 \", \"13 \", \"14 \", \"15 \", \"16 \", \"17 \", \"18 \", \"19 \", \"20 \"\ndd \"21 \", \"22 \", \"23 \", \"24 \", \"25 \", \"26 \"\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212255,"user_id":null,"body":"global alphabet_position\nextern malloc, realloc\n\n; section .data\n;   space db \" \"\n  \nsection .bss\n  addr resb 8\n  base_addr resb 8\n  offset resd 2\n  \nsection .text\n\nconvert_num:\n  push rbp\n  mov rbp, rsp ; [rsp+8] is num\n  mov al, [rsp+16]\n  xor ah, ah\n  mov bl, 10\n  div bl\n  cmp al, 0\n  je .next\n  add al, 30h\n  mov byte [rdi], al\n  inc rdi\n.next: \n  add ah, 30h\n  mov byte [rdi], ah\n  inc rdi\n  mov byte [rdi], \" \"\n  inc rdi\n  pop rbp\n  ret\n; <----- char *alphabet_position(const char *text) ----->\nalphabet_position:\n    xor rax, rax                ; RAX <- the result\n    push rdi\n    mov rdi, 4\n    call malloc\n;     mov rdi, rax\n;     mov rsi, 4\n;     call realloc\n    cmp rax, 0\n    jle .error\n    pop rsi\n    mov [base_addr], rax\n    mov rdi, rax\n    mov dword [rdi], 0\n.while:\n    xor rax, rax\n    mov al, [rsi]\n    inc rsi\n    cmp al, 0\n    je .end\n    cmp al, 'A'\n    jb .while\n    cmp al, 'Z'\n    jbe .big_letter\n    cmp al, 'a'\n    jb .while\n    cmp al, 'z'\n    jbe .small_letter\n    jmp .while\n.big_letter:\n    sub rax, 64 ; 'A' - 1\n    push rax\n    call convert_num\n    add rsp, 8\n    jmp .continue\n.small_letter:\n    sub rax, 96 ; 'a' - 1\n    push rax\n    call convert_num\n    add rsp, 8\n    jmp .continue\n.continue:\n    push rsi\n    sub rdi, [base_addr]\n    mov [offset], rdi\n    mov rsi, rdi\n    add rsi, 3\n    mov rdi, [base_addr]\n    call realloc\n    cmp rax, 0\n    jle .error\n    mov [base_addr], rax\n    mov rdi, rax\n    add rdi, [offset]\n    pop rsi\n    jmp .while\n.error:\n    mov rax , 0\n    ret\n.end:\n    mov byte [rdi-1], 0\n    mov rax, [base_addr]\n    ret\n; ---------> end of abcpos <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212256,"user_id":null,"body":"global alphabet_position\nextern strlen, sprintf, calloc\nsection .text\nalphabet_position:\n  cmp al, byte[rdi]\n  jz return\n  push r12\n  push rbx\n  push rbp\n  sub rsp, 0x10\n  mov dword [rsp], '%d'\n  mov r12, rdi\n  call strlen\n  lea rsi, [rax * 4]\n  mov rdi, 1\n  call calloc\n  mov rbx, rax\n  mov rbp, rbx\nloop:\n  xor rdx, rdx\n  mov al, byte[r12]\n  cmp al, dl\n  jz end_string\n  or al, 32\n  cmp al, 'a'\n  setge r10b\n  cmp al, 'z'\n  setle r9b\n  and r10b, r9b\n  jnz lowercase\n  inc r12\n  jmp loop\nlowercase:\n  mov dl, al\n  sub rdx, 0x60\n  lea rsi, [rsp]\n  mov rdi, rbp\n  call sprintf\n  add rbp, rax\n  mov byte [rbp], \" \"\n  inc rbp\n  inc r12\n  jmp loop\nend_string:\n  dec rbp\n  mov byte [rbp], dl\n  mov rax, rbx\n  add rsp, 0x10\n  pop rbp\n  pop rbx\n  pop r12\nreturn:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212257,"user_id":null,"body":"global alphabet_position\nextern strlen, sprintf, calloc\nsection .text\n\nalphabet_position:\n  cmp al, byte[rdi]\n  jz returnempty\n  push r12\n  push rbx\n  push rbp\n  sub rsp, 0x10\n  mov dword [rsp], '%d'\n  mov r12, rdi\n  call strlen\n  lea rsi, [rax * 4]\n  mov rdi, 1\n  call calloc\n  mov rbx, rax\n  mov rbp, rbx\n\nloop:\n  mov al, byte[r12]\n  cmp al, 0\n  jz return\n  cmp al, 'A'\n  setge r10b\n  cmp al, 'Z'\n  setle r9b\n  and r10b, r9b\n  jnz capitol\n  cmp al, 'a'\n  setge r10b\n  cmp al, 'z'\n  setle r9b\n  and r10b, r9b\n  jnz lowercase\n  inc r12\n  jmp loop\ncapitol:\n  xor rdx, rdx\n  mov dl, byte [r12]\n  sub rdx, 0x40\n  lea rsi, [rsp]\n  mov rdi, rbp\n  call sprintf\n  jmp addspace\nlowercase:\n  xor rdx, rdx\n  mov dl, byte [r12]\n  sub rdx, 0x60\n  lea rsi, [rsp]\n  mov rdi, rbp\n  call sprintf\n  jmp addspace\naddspace:\n  add rbp, rax\n  mov byte [rbp], \" \"\n  inc rbp\n  inc r12\n  jmp loop\nreturn:\n  dec rbp\nreturnempty:\n  mov byte [rbp], 0\n  mov rax, rbx\n  add rsp, 0x10\n  pop rbp\n  pop rbx\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54b724efac3d5402db00065e":[{"id":212258,"user_id":null,"body":"segment .text\nglobal decode_morse\ndecode_morse:    \n  mov  al,' '\n  mov  rcx,-1\n  repe scasb\n  dec  rdi\n  xchg rdi,rsi  \n  @b:xor  rdx,rdx\n     mov  rax,1\n     char:lea rdx,[rdx*2+rax]\n          lodsb\n          sub al,45\n     jnl char   \n     mov eax,[morse+rdx]\n     cmp al,'#'\n     je quit\n     stosd\n     shr  rdx,8\n     or   rdx,1\n     lea  rdi,[rdi+rdx-4]\n     mov ax,'  '\n     cmp [rsi],ax\n     jne @f\n       add rsi,2\n       stosb\n     @f:\n     cmp byte[rsi-1],0\n  jne @b\n  quit:\n  cmp byte[rdi-1],33\n  sbb rdi,0\n  mov byte[rdi],0\nret\nmorse db '##TEMNAIOGKDWRUS##QZYCXBJP#L#FVH09#8###7#(###\/=61####+#&2###3#45#######:####,###',\\\n         '##)#!;########-##',\"'\",'###@####.##\"####_?############################################',\\\n         '################################################################################',\\\n         '######$#########################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '################################################################################',\\\n         '#######SOS',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212259,"user_id":null,"body":"; RDI will be a pointer to the morsecode string you are to decode\n; RSI will be a pointer to a preallocated 100 byte string buffer\n; No returnvalue - the string in the stringbuffer is the result\n\nsegment .text\nglobal decode_morse\ndecode_morse:    \n  mov dl, [rdi]\n  test dl, dl\n  je .done\n  mov ecx, 1\n  xor r8d, r8d\n.loop:\n  test dl, -33\n  jne .dotordash\n  cmp ecx, 1\n  je .noletter\n  cmp ecx, 568\n  jne .decodechar\n  mov word [rsi], 20307\n  mov byte [rsi + 2], 83\n  add rsi, 3\n  jmp .seenchar\n.dotordash:\n  xor eax, eax\n  cmp dl, 45\n  mov dl, [rdi + 1]\n  sete al\n  lea ecx, [rax + 2*rcx]\n  jmp .notspace\n.decodechar:\n  dec ecx\n  mov al, [rcx + .table]\n  mov [rsi], al\n  inc rsi\n.seenchar:\n  mov r8b, 1\n.noletter:\n  cmp byte [rdi], 0\n  je .eol\n  mov dl, byte [rdi + 1]\n  mov ecx, 1\n  cmp dl, 32\n  jne .notspace\n  test r8b, 1\n  je .notseenchar\n  mov byte [rsi], 32\n  inc rsi\n.notseenchar:\n  inc rdi\n.skipspaces:\n  mov dl, [rdi + 1]\n  inc rdi\n  cmp dl, 32\n  je .skipspaces\n  mov ecx, 1\n  jmp .loop\n.notspace:\n  inc rdi\n  jmp .loop\n.eol:\n  test r8b, 1\n  je .done\n  inc rsi\n  mov rax, rsi\n.undospaces:\n  cmp byte [rax - 2], 32\n  lea rsi, [rax - 1]\n  mov rax, rsi\n  je .undospaces\n.done:\n  mov byte [rsi], 0\n  ret\n\nsection .data\n.table: db `*ETIANMSURWDKGOHVF*L*PJBXCYZQ**54*3***2&*+****16=\/***(*7***8*90************?_****\"**.****@***'**-********;!*)*****,****:****************$`\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212260,"user_id":null,"body":"; RDI will be a pointer to the morsecode string you are to decode\n; RSI will be a pointer to a preallocated 100 byte string buffer\n; No returnvalue - the string in the stringbuffer is the result\n\nsegment .text\nglobal decode_morse\ncompare_str:\n            ; return 1 in rax if str1 in rdi == str2 in rsi\n            ; where [rsi+len(str2)-1] == 0, else return 0\n            mov al, [rdi]\n            cmp al, [rsi]\n            jne .false\n            inc rdi\n            inc rsi\n            cmp byte [rsi], 0\n            jne compare_str\n            cmp byte [rdi], ' '\n            je .end\n            cmp byte [rdi], 0\n            je .end\n.false:\n            xor rax, rax\n            ret\n.end: \n            mov rax, 1\n            ret\ndecode_code: \n            ; return char's index in @chars  \n            ; go to next byte after code in the morsecode string\n            xor rdx, rdx ; <-- rdx - result\n            xor rcx, rcx\n            mov cl, @n_codes\n.search_char:\n            mov rsi, [@codes+rdx*8]\n            push rdi\n            call compare_str\n            cmp rax, 1\n            je .end\n            pop rdi\n            inc rdx\n            loop .search_char\n            mov rdx, -1\n            ret\n.end:\n            pop rbx\n            ret\ndecode_morse:\n.delete_extended_space:\n            cmp byte [rdi], ' '\n            jne .decode\n            inc rdi\n            jmp .delete_extended_space\n.decode:\n            ; rdx - index code or char\n            push rsi\n            call decode_code\n            pop rsi\n            cmp rdx, 54 ; index @lsos\n            jne .continue\n            mov byte [rsi], 'S'\n            mov byte [rsi+1], 'O'\n            mov byte [rsi+2], 'S'\n            add rsi, 3\n            jmp .check_end\n.continue:\n            mov al, [@chars+rdx]\n            mov [rsi], al\n            inc rsi\n.check_end:\n            cmp byte [rdi], 0\n            je .end\n            inc rdi\n            cmp byte [rdi], ' '\n            jne .skip\n            inc rdi\n            cmp byte [rdi], ' '\n            jne .skip\n            inc rdi\n            cmp byte [rdi], 0\n            je .end\n            cmp byte [rdi], ' '\n            je .end\n            mov byte [rsi], ' '\n            inc rsi\n.skip:\n            jmp .decode\n.end:\n            mov byte [rsi], 0\n            ret\n\n\nsection .data\n\n; The C-equivalent declaration of variable would be 'char *codes[n_codes] = {\".-\", \"-...\".....}'\n\n@chars: db \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?'!\/()&:;=\"\n        db '+-_\"$@ ',0\n  \n@codes: dq $@la, $@lb, $@lc, $@ld, $@le, $@lf, $@lg, $@lh, $@li, $@lj, $@lk, $@ll, $@lm\n        dq $@ln, $@lo, $@lp, $@lq, $@lr, $@ls, $@lt, $@lu, $@lv, $@lw, $@lx, $@ly, $@lz\n      \tdq $@l0, $@l1, $@l2, $@l3, $@l4, $@l5, $@l6, $@l7, $@l8, $@l9, $@ldot, $@lcomma\n        dq $@lque, $@lapo, $@lexcl, $@lslash, $@llpar, $@lrpar, $@lamp, $@lcol\n        dq $@lsemi, $@leq, $@lplus, $@lmin, $@lund, $@lquo, $@ldoll, $@lalpha, $@lsos\n          \n@n_codes   equ ($ - $@codes) \/ 8    ; Total number of morse-codes\n\n@la db \".-\", 0\n@lb db \"-...\", 0\n@lc db \"-.-.\", 0\n@ld db \"-..\", 0\n@le db \".\", 0\n@lf db \"..-.\", 0\n@lg db \"--.\", 0\n@lh db \"....\", 0\n@li db \"..\", 0\n@lj db \".---\", 0\n@lk db \"-.-\", 0\n@ll db \".-..\", 0\n@lm db \"--\", 0\n@ln db \"-.\", 0\n@lo db \"---\", 0\n@lp db \".--.\", 0\n@lq db \"--.-\", 0\n@lr db \".-.\", 0\n@ls db \"...\", 0\n@lt db \"-\", 0\n@lu db \"..-\", 0\n@lv db \"...-\", 0\n@lw db \".--\", 0\n@lx db \"-..-\", 0\n@ly db \"-.--\", 0\n@lz db \"--..\", 0\n@l0 db \"-----\", 0\n@l1 db \".----\", 0\n@l2 db \"..---\", 0\n@l3 db \"...--\", 0\n@l4 db \"....-\", 0\n@l5 db \".....\", 0\n@l6 db \"-....\", 0\n@l7 db \"--...\", 0\n@l8 db \"---..\", 0\n@l9 db \"----.\", 0\n@ldot      db \".-.-.-\", 0\n@lcomma    db \"--..--\", 0\n@lque      db \"..--..\", 0\n@lapo      db \".----.\", 0\n@lexcl     db \"-.-.--\", 0\n@lslash    db \"-..-.\", 0\n@llpar     db \"-.--.\", 0\n@lrpar     db \"-.--.-\", 0\n@lamp      db \".-...\", 0\n@lcol      db \"---...\", 0\n@lsemi     db \"-.-.-.\", 0\n@leq       db \"-...-\", 0\n@lplus     db \".-.-.\", 0\n@lmin      db \"-....-\", 0\n@lund      db \"..--.-\", 0\n@lquo      db \".-..-.\", 0\n@ldoll     db \"...-..-\", 0\n@lalpha    db \".--.-.\", 0\n@lsos      db \"...---...\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212261,"user_id":null,"body":"; RDI will be a pointer to the morsecode string you are to decode\n; RSI will be a pointer to a preallocated 100 byte string buffer\n; No returnvalue - the string in the stringbuffer is the result\n\nsegment .text\nglobal decode_morse\ndecode_morse:    \n                ; < Code away!\n                push rbp      ; Create stack frame. 16 byte aligned\n                mov rbp, rsp\n                sub rsp, 24   ; rbp - 08 = morsecode string\n                              ; rbp - 16 = 100-byte string\n                              ; rbp - 20 = cur input string position\n                              ; rbp - 24 = cur output string position\n                mov [rbp - 8], rdi      ; save morse code string\n                mov [rbp - 16], rsi     ; save buffer\n                mov qword [rbp - 24], 0 ; clear string positions\n                \nremove_initial_whitespace: ; remove initial whitspace. Never come back here\n                cmp byte [rdi], 0\n                je _end\n                cmp byte [rdi], ' ' ; ignore initial whitespace and find the first character\n                jne morse_find_char\n                inc rdi\n                mov [rbp - 8], rdi\n                jmp remove_initial_whitespace\n                \nchar_search_start: ; Should look for next morse code to decode.\n                   ; Responsible for adding a space to output\n                   ; Responsible for stopping if there is only whitespace at the end\n                mov rdi, [rbp - 8]\n                mov rsi, [rbp - 16]\n                cmp byte [rdi], 0 ; At this point, [rdi] should be any amount of whitespace, or 0\n                je _end           ; First space\n                inc rdi\n                cmp byte [rdi], 0 ; Second space\n                je _end\n                cmp byte [rdi], ' '\n                jne morse_find_char\n                inc rdi\n                cmp byte [rdi], 0 ; Third space\n                je _end\n                cmp byte [rdi], ' '\n                jne _end\n                inc rdi\n                cmp byte [rdi], 0 ; Fourth character\n                je _end\n                cmp byte [rdi], ' '\n                je _end\n                mov rax, [rbp - 16] ; This is valid morse code. Add the space to the\n                mov byte [rax], ' ' ; output and continue.\n                inc rax\n                mov [rbp - 16], rax\n                jne morse_find_char   ; If its not three spaces, its morse code\n                add rdi, 2            ; If it is three spaces, its either a real space or the final amount of whitespace\n                                      ; If its the final amount of whitespace, we discard and end the program\n                                      ; If the 4th char is space, its malformed and just the end of the string\n                                      ; If the 4th char is 0 (null byte), then its malformed and just the end of the string\n                                      ; If its only 3 spaces, its still good morse code\n                \nmorse_find_char: \n                xor r8, r8   ; counter for morse code string\n                ;xor r9, r9   ; single morse code letter from array (null terminated)\n                xor r10, r10 ; \n                mov [rbp - 8], rdi\n                \nmorse_find_char_loop: ; This loop looks for the correct morse-code.\n                  mov r9, [@codes + r8 * 8] ; get next letter in alphabet\n                  mov rdi, [rbp - 8] ; reset to beginning of input letter\n                  \nmorse_find_char_inner_loop: ; Check each character in the morse-code to see if its the same\n                    cmp r8, 54    ; Anything over 54 doesn't exist.\n                    jg _debug_end ; Something went wront and we'll jump\n                    mov al, [rdi] \n                    cmp byte [r9], al ; Compare input code to current code\n                    jne morse_find_char_inner_end ; If not the same, try the next letter\n                    inc r9  ; Check the next char\n                    inc rdi ; Check the next char\n                    mov al, byte [r9] ; r9 is null terminated\n                    test al, al\n                    jz morse_find_char_maybe_found  ; If zero, we have reached the end of the morse-code. \n                                                    ; This may be a match.\n                    jmp morse_find_char_inner_loop  ; If not zero, try the next char\n                    \nmorse_find_char_maybe_found:\n                  mov al, [rdi]\n                  cmp al, ' '\n                  je morse_find_char_found ; If our input's next char is 0 or ' ', we have a match\n                  cmp al, 0\n                  je morse_find_char_found\n                  jmp morse_find_char_inner_end ; If neither, then try the next morse-code\nmorse_find_char_found:\n                  cmp r8, 54\n                  je morse_sos_edge_case  ; Edge case. SOS is multiple letters\n                  mov r10, [@chars + r8]  ; Get the matching letter\n                  mov rax, [rbp - 16]     ; \n                  mov byte [rax], r10b    ; write to output\n                  inc rax\n                  mov [rbp - 16], rax\n                  mov [rbp - 8], rdi\n                  jmp char_search_start\n    \nmorse_sos_edge_case:\n                  mov rax, [rbp - 16]\n                  mov byte [rax], 'S' ; Write to output\n                  inc rax\n                  mov byte [rax], 'O'\n                  inc rax\n                  mov byte [rax], 'S'\n                  inc rax\n                  mov [rbp - 16], rax\n                  mov [rbp - 8], rdi\n                  jmp char_search_start\n                  \n                  \nmorse_find_char_inner_end:\n                  inc r8 ; Try next morse-code\n                  jmp morse_find_char_loop\n                  \n_debug_end: ; This is unsafe, but did help. \n                mov rdi, 1\n                mov rsi, [rbp - 8]\n                mov rdx, 10\n                mov eax, 1\n                syscall ; Print rdx amount of chars of input to screen\n                  \n_end:\n                mov rax, [rbp - 16] ; Remove stack frame\n                mov byte [rax], 0\n                add rsp, 24\n                mov rsp, rbp\n                pop rbp\n                ret\n                \nsection .data\n\n; The C-equivalent declaration of variable would be 'char *codes[n_codes] = {\".-\", \"-...\".....}'\n\n@chars: db \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?'!\/()&:;=\"\n        db '+-_\"$@ ',0\n  \n@codes: dq $@la, $@lb, $@lc, $@ld, $@le, $@lf, $@lg, $@lh, $@li, $@lj, $@lk, $@ll, $@lm\n        dq $@ln, $@lo, $@lp, $@lq, $@lr, $@ls, $@lt, $@lu, $@lv, $@lw, $@lx, $@ly, $@lz\n        dq $@l0, $@l1, $@l2, $@l3, $@l4, $@l5, $@l6, $@l7, $@l8, $@l9, $@ldot, $@lcomma\n        dq $@lque, $@lapo, $@lexcl, $@lslash, $@llpar, $@lrpar, $@lamp, $@lcol\n        dq $@lsemi, $@leq, $@lplus, $@lmin, $@lund, $@lquo, $@ldoll, $@lalpha, $@lsos\n          \n@n_codes   equ ($ - $@codes) \/ 8    ; Total number of morse-codes\n\n@la db \".-\", 0\n@lb db \"-...\", 0\n@lc db \"-.-.\", 0\n@ld db \"-..\", 0\n@le db \".\", 0\n@lf db \"..-.\", 0\n@lg db \"--.\", 0\n@lh db \"....\", 0\n@li db \"..\", 0\n@lj db \".---\", 0\n@lk db \"-.-\", 0\n@ll db \".-..\", 0\n@lm db \"--\", 0\n@ln db \"-.\", 0\n@lo db \"---\", 0\n@lp db \".--.\", 0\n@lq db \"--.-\", 0\n@lr db \".-.\", 0\n@ls db \"...\", 0\n@lt db \"-\", 0\n@lu db \"..-\", 0\n@lv db \"...-\", 0\n@lw db \".--\", 0\n@lx db \"-..-\", 0\n@ly db \"-.--\", 0\n@lz db \"--..\", 0\n@l0 db \"-----\", 0\n@l1 db \".----\", 0\n@l2 db \"..---\", 0\n@l3 db \"...--\", 0\n@l4 db \"....-\", 0\n@l5 db \".....\", 0\n@l6 db \"-....\", 0\n@l7 db \"--...\", 0\n@l8 db \"---..\", 0\n@l9 db \"----.\", 0\n@ldot      db \".-.-.-\", 0\n@lcomma    db \"--..--\", 0\n@lque      db \"..--..\", 0\n@lapo      db \".----.\", 0\n@lexcl     db \"-.-.--\", 0\n@lslash    db \"-..-.\", 0\n@llpar     db \"-.--.\", 0\n@lrpar     db \"-.--.-\", 0\n@lamp      db \".-...\", 0\n@lcol      db \"---...\", 0\n@lsemi     db \"-.-.-.\", 0\n@leq       db \"-...-\", 0\n@lplus     db \".-.-.\", 0\n@lmin      db \"-....-\", 0\n@lund      db \"..--.-\", 0\n@lquo      db \".-..-.\", 0\n@ldoll     db \"...-..-\", 0\n@lalpha    db \".--.-.\", 0\n@lsos      db \"...---...\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212262,"user_id":null,"body":"; RDI will be a pointer to the morsecode string you are to decode\n; RSI will be a pointer to a preallocated 100 byte string buffer\n; No returnvalue - the string in the stringbuffer is the result\n\nsegment .text\nglobal decode_morse\ndecode_morse:    \n                ; < Code away!\n                push rbp\n                mov rbp, rsp\n                sub rsp, 24   ; rbp - 08 = morsecode string\n                              ; rbp - 16 = 100-byte string\n                              ; rbp - 20 = cur input string position\n                              ; rbp - 24 = cur output string position\n                mov [rbp - 8], rdi      ; save morse code string\n                mov [rbp - 16], rsi     ; save buffer\n                mov qword [rbp - 24], 0 ; clear string positions\n                \nremove_initial_whitespace: ; remove initial whitspace. Never come back here\n                cmp byte [rdi], 0\n                je _end\n                cmp byte [rdi], ' ' ; ignore initial whitespace and find the first character\n                jne morse_find_char\n                inc rdi\n                mov [rbp - 8], rdi\n                jmp remove_initial_whitespace\n                \nchar_search_start: ; Should look for next morse code to decode.\n                   ; Responsible for adding a space to output\n                   ; Responsible for stopping if there is only whitespace at the end\n                mov rdi, [rbp - 8]\n                mov rsi, [rbp - 16]\n                cmp byte [rdi], 0 ; At this point, [rdi] should be any amount of whitespace, or 0\n                je _end\n                inc rdi\n                ;cmp byte [rdi], 0\n                ;je _end\n                cmp word [rdi], '  '\n                jne morse_find_char ; If its not three spaces, its morse code\n                add rdi, 2            ; If it is three spaces, its either a real space or the final amount of whitespace\n                                      ; If its the final amount of whitespace, we discard and end the program\n                cmp byte [rdi], ' '   ; If the 4th char is space, its malformed and just the end of the string\n                je _end\n                cmp byte [rdi], 0     ; If the 4th char is 0 (null byte), then its malformed and just the end of the string\n                je _end\n                mov rax, [rbp - 16]\n                mov byte [rax], ' '\n                inc rax\n                mov [rbp - 16], rax\n                jmp morse_find_char   ; If its only 3 spaces, its still good morse code\n                \nmorse_find_char: \n                xor r8, r8   ; counter for morse code string\n                ;xor r9, r9   ; single morse code letter from array (null terminated)\n                xor r10, r10 ; \n                mov [rbp - 8], rdi\n                \nmorse_find_char_loop:\n                  mov r9, [@codes + r8 * 8] ; get next letter in alphabet\n                  mov rdi, [rbp - 8] ; reset to beginning of input letter\n                  \nmorse_find_char_inner_loop:\n                    cmp r8, 54 ; Debugging\/\n                    jg _debug_end\n                    mov al, [rdi]\n                    cmp byte [r9], al\n                    jne morse_find_char_inner_end\n                    inc r9\n                    inc rdi\n                    mov al, byte [r9] ; r9 is null terminated\n                    test al, al\n                    jz morse_find_char_maybe_found\n                    jmp morse_find_char_inner_loop\n                    \nmorse_find_char_maybe_found:\n                  mov al, [rdi]\n                  cmp al, ' '\n                  je morse_find_char_found\n                  cmp al, 0\n                  je morse_find_char_found\n                  jmp morse_find_char_inner_end\nmorse_find_char_found:\n                  cmp r8, 54\n                  je morse_sos_edge_case\n                  mov r10, [@chars + r8]\n                  mov rax, [rbp - 16]\n                  mov byte [rax], r10b\n                  inc rax\n                  mov [rbp - 16], rax\n                  mov [rbp - 8], rdi\n                  jmp char_search_start\n    \nmorse_sos_edge_case:\n                  mov rax, [rbp - 16]\n                  mov byte [rax], 'S'\n                  inc rax\n                  mov byte [rax], 'O'\n                  inc rax\n                  mov byte [rax], 'S'\n                  inc rax\n                  mov [rbp - 16], rax\n                  mov [rbp - 8], rdi\n                  jmp char_search_start\n                  \n                  \nmorse_find_char_inner_end:\n                  inc r8\n                  jmp morse_find_char_loop\n                  \n_debug_end:\n                mov rdi, 1\n                mov rsi, @debug_message\n                mov rdx, 10\n                mov eax, 1\n                syscall\n                  \n_end:\n                mov rax, [rbp - 16]\n                mov byte [rax], 0\n                add rsp, 24\n                mov rsp, rbp\n                pop rbp\n                ret\n                \nsection .data\n\n@debug_message db \"Testing!!\", '\n', 0\n\n; The C-equivalent declaration of variable would be 'char *codes[n_codes] = {\".-\", \"-...\".....}'\n\n@chars: db \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?'!\/()&:;=\"\n        db '+-_\"$@ ',0\n  \n@codes: dq $@la, $@lb, $@lc, $@ld, $@le, $@lf, $@lg, $@lh, $@li, $@lj, $@lk, $@ll, $@lm\n        dq $@ln, $@lo, $@lp, $@lq, $@lr, $@ls, $@lt, $@lu, $@lv, $@lw, $@lx, $@ly, $@lz\n      \tdq $@l0, $@l1, $@l2, $@l3, $@l4, $@l5, $@l6, $@l7, $@l8, $@l9, $@ldot, $@lcomma\n        dq $@lque, $@lapo, $@lexcl, $@lslash, $@llpar, $@lrpar, $@lamp, $@lcol\n        dq $@lsemi, $@leq, $@lplus, $@lmin, $@lund, $@lquo, $@ldoll, $@lalpha, $@lsos\n          \n@n_codes   equ ($ - $@codes) \/ 8    ; Total number of morse-codes\n\n@la db \".-\", 0\n@lb db \"-...\", 0\n@lc db \"-.-.\", 0\n@ld db \"-..\", 0\n@le db \".\", 0\n@lf db \"..-.\", 0\n@lg db \"--.\", 0\n@lh db \"....\", 0\n@li db \"..\", 0\n@lj db \".---\", 0\n@lk db \"-.-\", 0\n@ll db \".-..\", 0\n@lm db \"--\", 0\n@ln db \"-.\", 0\n@lo db \"---\", 0\n@lp db \".--.\", 0\n@lq db \"--.-\", 0\n@lr db \".-.\", 0\n@ls db \"...\", 0\n@lt db \"-\", 0\n@lu db \"..-\", 0\n@lv db \"...-\", 0\n@lw db \".--\", 0\n@lx db \"-..-\", 0\n@ly db \"-.--\", 0\n@lz db \"--..\", 0\n@l0 db \"-----\", 0\n@l1 db \".----\", 0\n@l2 db \"..---\", 0\n@l3 db \"...--\", 0\n@l4 db \"....-\", 0\n@l5 db \".....\", 0\n@l6 db \"-....\", 0\n@l7 db \"--...\", 0\n@l8 db \"---..\", 0\n@l9 db \"----.\", 0\n@ldot      db \".-.-.-\", 0\n@lcomma    db \"--..--\", 0\n@lque      db \"..--..\", 0\n@lapo      db \".----.\", 0\n@lexcl     db \"-.-.--\", 0\n@lslash    db \"-..-.\", 0\n@llpar     db \"-.--.\", 0\n@lrpar     db \"-.--.-\", 0\n@lamp      db \".-...\", 0\n@lcol      db \"---...\", 0\n@lsemi     db \"-.-.-.\", 0\n@leq       db \"-...-\", 0\n@lplus     db \".-.-.\", 0\n@lmin      db \"-....-\", 0\n@lund      db \"..--.-\", 0\n@lquo      db \".-..-.\", 0\n@ldoll     db \"...-..-\", 0\n@lalpha    db \".--.-.\", 0\n@lsos      db \"...---...\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212263,"user_id":null,"body":"segment .bss\n@phrase: resq 10\nsegment .text\nglobal decode_morse\ndecode_morse:   xor rdx,rdx      ; Used as morse string index\n                xor r8,r8        ; Used as decoded message index\n                xor rcx,rcx      ; Used as phrase index\n                xor rax,rax\n@no_l_space:    cmp byte [rdi + rdx],' ' ; Skip all leading spaces\n                jne @main_loop\n                inc edx\n                jmp @no_l_space\n                \n@main_loop:     mov al,[rdi + rdx]\n                test al,al\n                jz @done\n                cmp al,' '\n                jne @notspace\n                inc edx\n                inc ah          ; ah is the number of adjacent spaces\n                jmp @main_loop\n@notspace:      test ah,ah\n                jz  @inc_phrase\n@pre_p_l:       mov byte [@phrase + rcx],0 ; Terminate current phrase\n                xor r9,r9                  ; Index for Code we're trying to match our phrase with\n                xor r10,r10                ; Text index pointer\n                \n@phrase_loop:   mov r11,[@codes + r9 * 8]  ; r11 is pointer to the morsecode letter we're trying to match with current phrase\n@text_loop:     mov al,[r11 + r10]\n                cmp al,[@phrase + r10]\n                jne @next_c_search         ; Not the same letter (or 0), search next code\n                test al,al\n                jnz @next_c_i              ; If not confirmed end of string, next code index\n@no_space_pre:  mov cl,byte [@chars + r9]  ; We have our string match - now copy the associated letter\n                cmp cl, ' '                ; Check if it's the weird exception, a space for the SOS code\n                jne @not_sos\n                mov cl,'S'\n                mov byte [rsi + r8], cl\n                mov byte [rsi + r8 +1], 'O'\n                add r8,2\n@not_sos:       mov [rsi + r8],cl\n                inc r8                     ; Increase decoded index\n                xor rcx,rcx                ; Clear phrase index\n                dec ah\n                jz  @main_loop             ; If more than one trailing space, we have assume it was 3 and add a trailing space\n                mov byte [rsi + r8], ' '\n                inc r8\n                xor ah, ah\n                jmp @main_loop\n@next_c_i:      inc r10\n                jmp @text_loop\n@next_c_search: inc r9\n                cmp r9,@n_codes\n                jl @n_search_ok\n                mov rax,\"*ERROR**\"        ; Out of strings to compare with - should not happen\n                mov [rsi],rax\n                ret\n@n_search_ok:   xor r10,r10\n                jmp @phrase_loop\n@inc_phrase:    mov [@phrase + rcx],al\n                inc edx\n                inc ecx\n                jmp @main_loop\n                \n@done:          test ecx,ecx\n                jz   @done2\n                jmp  @pre_p_l\n@done2:         cmp  byte [rsi + r8 -1], ' '\n                jne  @done3\n                mov  byte [rsi + r8 -1], 0\n@done3:         mov  byte [rsi + r8], 0\n                ret\n                \nsection .data\n\n; The C-equivalent declaration of variable would be 'char *codes[n_codes] = {\".-\", \"-...\".....}'\n; The codes match the letters position in the label chars, with the exception of the SOS code which has a space.\n\n@chars: db \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?'!\/()&:;=\"\n        db '+-_\"$@ ',0\n  \n@codes: dq $@la, $@lb, $@lc, $@ld, $@le, $@lf, $@lg, $@lh, $@li, $@lj, $@lk, $@ll, $@lm\n        dq $@ln, $@lo, $@lp, $@lq, $@lr, $@ls, $@lt, $@lu, $@lv, $@lw, $@lx, $@ly, $@lz\n      \tdq $@l0, $@l1, $@l2, $@l3, $@l4, $@l5, $@l6, $@l7, $@l8, $@l9, $@ldot, $@lcomma\n        dq $@lque, $@lapo, $@lexcl, $@lslash, $@llpar, $@lrpar, $@lamp, $@lcol\n        dq $@lsemi, $@leq, $@lplus, $@lmin, $@lund, $@lquo, $@ldoll, $@lalpha, $@lsos\n          \n@n_codes   equ ($ - $@codes) \/ 8    ; Total number of morse-codes\n\n@la db \".-\", 0\n@lb db \"-...\", 0\n@lc db \"-.-.\", 0\n@ld db \"-..\", 0\n@le db \".\", 0\n@lf db \"..-.\", 0\n@lg db \"--.\", 0\n@lh db \"....\", 0\n@li db \"..\", 0\n@lj db \".---\", 0\n@lk db \"-.-\", 0\n@ll db \".-..\", 0\n@lm db \"--\", 0\n@ln db \"-.\", 0\n@lo db \"---\", 0\n@lp db \".--.\", 0\n@lq db \"--.-\", 0\n@lr db \".-.\", 0\n@ls db \"...\", 0\n@lt db \"-\", 0\n@lu db \"..-\", 0\n@lv db \"...-\", 0\n@lw db \".--\", 0\n@lx db \"-..-\", 0\n@ly db \"-.--\", 0\n@lz db \"--..\", 0\n@l0 db \"-----\", 0\n@l1 db \".----\", 0\n@l2 db \"..---\", 0\n@l3 db \"...--\", 0\n@l4 db \"....-\", 0\n@l5 db \".....\", 0\n@l6 db \"-....\", 0\n@l7 db \"--...\", 0\n@l8 db \"---..\", 0\n@l9 db \"----.\", 0\n@ldot      db \".-.-.-\", 0\n@lcomma    db \"--..--\", 0\n@lque      db \"..--..\", 0\n@lapo      db \".----.\", 0\n@lexcl     db \"-.-.--\", 0\n@lslash    db \"-..-.\", 0\n@llpar     db \"-.--.\", 0\n@lrpar     db \"-.--.-\", 0\n@lamp      db \".-...\", 0\n@lcol      db \"---...\", 0\n@lsemi     db \"-.-.-.\", 0\n@leq       db \"-...-\", 0\n@lplus     db \".-.-.\", 0\n@lmin      db \"-....-\", 0\n@lund      db \"..--.-\", 0\n@lquo      db \".-..-.\", 0\n@ldoll     db \"...-..-\", 0\n@lalpha    db \".--.-.\", 0\n@lsos      db \"...---...\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54ba84be607a92aa900000f1":[{"id":212264,"user_id":168,"body":"global is_isogram\nsection .text\n\nis_isogram:\n  mov ecx, 0x80000000\n  xor eax, eax\n.loop:\n  movzx edx, byte [rdi]\n  inc rdi\n  and dl, ~32\n  sub dl, 'A'\n  bts ecx, edx\n  jnc .loop\n  sets al\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212265,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n      cmp rdi, 0\n      je not_isogram\n\n      mov eax, 1\n      \n      xor rcx, rcx\n      mov cl, [rdi]\n      cmp cl, 0\n      je string_ended\n      \n      %assign i 1;nullify 256 bytes on stack\n      %rep 256\/8\n      mov qword[rsp - i*8], 0\n      %assign i i+1\n      %endrep\n      \n      cmp cl, 'A'\n      jl char_is_not_upper_case1\n      cmp cl, 'Z'\n      jg char_is_not_upper_case1\n      sub cl, 'A' - 'a'\n      char_is_not_upper_case1:\n      \n      mov byte[rsp + rcx - 263], 1\n      \n      string_loop:\n      inc rdi\n      \n      mov cl, [rdi]\n      cmp cl, 0\n      je string_ended\n      \n      cmp cl, 'A'\n      jl char_is_not_upper_case2\n      cmp cl, 'Z'\n      jg char_is_not_upper_case2\n      sub cl, 'A' - 'a'\n      char_is_not_upper_case2:\n      \n      cmp byte[rsp + rcx - 263], 0\n      jne not_isogram\n      \n      mov byte[rsp + rcx - 263], 1\n      \n      jmp string_loop\n      \n      not_isogram:\n      xor eax, eax\n      \n      string_ended:\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212266,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n  xorps xmm0, xmm0\n  mov eax, 1\n  movups [rsp - 30], xmm0\n  movaps [rsp - 40], xmm0\n.loop:\n  movzx edx, byte [rdi]\n  test rdx, rdx\n  je .done\n  and edx, -33\n  cmp byte [rsp + rdx - 105], 0\n  jne .false\n  mov byte [rsp + rdx - 105], 1\n  inc rdi\n  jmp .loop\n.false:\n  xor eax, eax\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212267,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n      cmp byte [rdi], 0x00\n      je true\n      mov r8, 97\n      jmp loop_end\n    loop1:\n      xor r9, r9\n      xor r10, r10\n    loop2:\n      xor r11, r11\n      mov byte r11b, [rdi+r9]\n      cmp r11b, 90\n      jg pass_recasing\n      add r11b, 32      \n      pass_recasing:   \n      cmp byte r11b, r8b\n      jne pass\n      inc r10\n      cmp r10, 2\n      jge false\n      pass:\n      inc r9\n      cmp byte [rdi+r9], 0x00\n      jne loop2\n      \n      inc r8\n    loop_end:\n      cmp r8, 122\n      jle loop1\n      jmp true  \n  false:\n    xor eax, eax\n    ret\n  true:\n    xor eax, eax\n    inc eax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212268,"user_id":173,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n    mov eax, 1\nl_nextchar:\n    cmp byte [rdi], 0\n    je l_done\n      ; check current char against all other chars\n      mov rsi, rdi\nl_1:\n      inc rsi\n      cmp byte [rsi], 0\n      je l_nextchar_i\n      mov byte cl, [rdi]\n      cmp cl, 0x61\n      jb l_2\n      sub cl, 0x20\nl_2:\n      mov byte ch, [rsi]\n      cmp ch, 0x61\n      jb l_3\n      sub ch, 0x20\nl_3:\n      cmp cl, ch\n      je l_not_isogram\n      jmp l_1\nl_nextchar_i:\n    inc rdi\n    jmp l_nextchar\nl_not_isogram:\n    xor eax, eax\nl_done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212269,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n      xor eax, eax\n      jmp .start\nalign 16\n.loop:or cl,' '\n      mov edx,1\n      add cl,-'a'\n      shl edx,cl\n      test eax,edx\n      jne .end\n      or eax,edx\n.start:\n      movzx ecx, byte[rdi]\n      test cl,cl\n      lea rdi,[rdi+1]\n      jne .loop\n.end:\n      sete al\n      movzx eax,al\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212270,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n    push    rdi                 ;save original memory addresses \n    push    rsi                 \n    mov rax,rdi                 ;put string start to rax\n    mov rsi,rdi                 ;put string start to rsi\n    mov rdi,0                   ;pot 0 into rdi\n    mov eax,0                   ;by default return false \n.loop:\n    mov rcx,[rsi]               ;put current char into rcx\n    and cl,cl                   ; if end of line achieved the sentence pass the filter return true \n    jz .return_true\n    or cl, 32                   ;make any letter lowercase \n    sub cl,'a'                  ;get the sequental number of the letter in the alphabet\n    mov rdx,1                   ;set first bit to 1\n    sal rdx,cl                  ;shift 1 to the position equal to letter number \n    mov r8,rdx                  \n    and r8,rdi                  ;if letter is present in the bitmask it had been met before return false \n    jnz .return_false\n    or  rdi,rdx                 ;save current letter in the bitmask \n    inc rsi                     ;increase lettter index \n    jmp .loop\n    \n.return_true:    \n    mov eax,1                   \n.return_false:  \n    pop     rsi                 ;restore used registers\n    pop     rdi      \n    ret\n\nsection .data\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212271,"user_id":null,"body":"global is_isogram\nsection .text\nis_isogram:\n  xor rax, rax\n  xor rcx, rcx\n  xor r8, r8\n  xor r9, r9\n\n  ; test null str case\n  mov cl, [rdi]\n  test cl, cl\n  jz .ret_true\n\n.loop:\n  cmp cl, 'A'\n  jb .continue\n\n  cmp cl, 'Z'\n  jbe .test\n\n  cmp cl, 'a'\n  jb .continue\n\n  cmp cl, 'z'\n  ja .continue\n\n.test_lower:\n  sub cl, 0x20\n\n.test:\n  sub cl, 'A'\n\n  mov r9, 1 ; bitmask\n  shl r9, cl ; shift bitmask by offset from 'A'\n\n  test r8, r9\n  jnz .ret_false\n\n  or r8, r9 ; add char to bitmast storage\n\n.continue:\n  inc rdi\n  mov cl, [rdi]\n  test cl, cl\n  jnz .loop\n\n.ret_true:\n  inc rax\n\n.ret_false:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212272,"user_id":50,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .text\nis_isogram:\n  xor rax, rax\n  xor rbx,rbx ; n\n  xor rcx,rcx ; c\n  xor r8,r8\n_loop:\n  cmp byte[rdi],0\n  je _true\n  mov cl,byte[rdi]\n  cmp cl,90\n  jg _toupper\n_f:\n  sub cl,65\n  xor r8,r8\n  bts r8,rcx\n  mov rax,rbx\n  and rax,r8\n  cmp rax,0\n  jne _false\n  add rbx,r8\n  inc rdi\n  jmp _loop\n_toupper:\n  sub rcx,32\n  jmp _f\n_true:\n  mov eax,1\n  ret\n_false:\n  xor eax,eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212273,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the return value in EAX. Use 1 if it's an isogram, and 0 if it's not.\n\nglobal is_isogram\nsection .data\nletter_bool times 200h db 0\n\nsection .text\nis_isogram:\n    xor rax, rax\n    mov rcx, 100b\n.init_loop:\n    mov [letter_bool+8*rcx-8], rax\n    loop .init_loop\n.loop:\n    movzx rdx, byte [rdi+rcx]\n    test rdx, rdx\n    jnz .continue\n    inc al\n    ret\n.continue:\n    cmp dl, 97\n    jl .uppercase\n    sub dl, 32\n.uppercase:\n    sub dl, 65\n    cmp [letter_bool+rdx], byte 0\n    jz .set\n    ret\n.set:\n    mov [letter_bool+rdx], byte 1\n    inc rcx\n    jmp .loop","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54bf1c2cd5b56cc47f0007a1":[{"id":212274,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\n\nglobal duplicate_count\nsection .text\nduplicate_count:\n      mov ecx, 0xff                 ; loop for every char\n      call zero_array\n      mov rsi, rdi                  ; from passed in pointer\n      call count_chars\n      mov ecx, 0xff                 ; loop for every char\n      xor eax, eax                  ; zero eax to hold output\n      call count_not_null\n      ret\n\nzero_array:\n      mov dword [count + ecx*4], 0\n      loop zero_array\n      ret\n\ncount_chars:\n      cld                           ; forward\n      xor eax, eax                  ; zero eax as we will need to read al from it\n      lodsb                         ; load char and advance\n      cmp al, 'a'                   ; if <a skip\n      jb count_chars_skip\n      cmp al, 'z'                   ; if >z skip\n      ja count_chars_skip\n      sub al, 0x20                  ; convert to upper\n      count_chars_skip:\n      inc dword [count + eax*4]     ; incriment count at the array index of the char\n      cmp al, 0                     ; if null return\n      jne count_chars\n      ret\n\ncount_not_null:\n    cmp dword [count + ecx*4], 1\n    jle count_not_null_skip\n    inc eax\n    count_not_null_skip:\n    loop count_not_null\n    ret\n\nsection .bss\ncount: resd 256","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212275,"user_id":527,"body":"global duplicate_count\nsection .text\nduplicate_count:\n                mov     r8d, 1\n                xor     eax, eax\n                xor     ecx, ecx\n.loop:          movzx   edx, byte [rdi]\n                inc     rdi\n                shrx    esi, edx, r8d\n                and     esi, 0x20\n                andn    edx, esi, edx\n                shlx    rsi, r8, rdx\n                and     rsi, rcx\n                or      rax, rsi\n                bts     rcx, rdx\n                test    edx, edx\n                jnz     .loop\n                popcnt  rax, rax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212276,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\n\n\nsection .text\n\nglobal duplicate_count\nduplicate_count:\n    enter 512, 0\n    lea   rdx, [rbp-512]\n.case:\n    mov   al, [rdi]\n    mov   [rdx], al\n    test  al, al\n    jz    .ecase\n    or    byte [rdx], 0x20\n    inc   rdi\n    inc   rdx\n    jmp   .case\n.ecase:\n    lea   rsi, [rbp-512]\n    xor   eax, eax\n    xor   ecx, ecx\n.loop:\n    add   eax, ecx\n    xor   cl, cl\n    mov   dl, [rsi]\n    inc   rsi\n    test  dl, dl\n    jz    .end\n    js    .loop\n    mov   rdi, rsi\n    dec   rdi\n.loop2:\n    inc   rdi\n    mov   dh, [rdi]\n    test  dh, dh\n    jz    .loop\n    js    .loop2\n    cmp   dl, dh\n    jne   .loop2\n    mov   cl, 1\n    mov   byte [rdi], 0xff\n    jmp   .loop2\n.end:\n    leave\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212277,"user_id":null,"body":"global duplicate_count\nsection .text\n\n; Count number of duplicate characters.\n; Count letters a-z case-insensitu\u00edve.\n; Return number of characater more than twice in the string.\n; Argument RDI = ASCII zero string.\n; Return EAX = Count of duplicates\nduplicate_count:\n    ; prepare a map ASCII code -> 16-bit counter on the stack\n    enter 200H,0            ; reserve storage\n    xor ebx, ebx            ; rbx := constant 0\n    mov dx, 2               ; dx := 16-bit constant 2\n    mov ecx, 0ffH\/4         ; loop over all 16-bit counter\n.zero:    \n    mov [rsp+8*rcx], rbx    ; initalise all counters\n    dec rcx\n    jge .zero               ; to next group of 4 counters\n    ; count characters in the string\n    mov rsi, rdi            ; rsi goes upwards in the string\n    cld\n    xor eax, eax\n.string:\n    lodsb\n    test al, al\n    jz .endstring           ; 0 -> end of string\n    inc word [rsp+2*rax]\n    jnc .string\n    mov [rsp+2*rax], dx     ; overflow of counter\n    jmp .string\n.endstring:\n    ; handle case in-sensitive\n    mov rcx, 'A'            ; loop over A..Z\n    lea rdi, [rsp+2*('a'-'A')]  ; rdi to address lower case letters\n.case:\n    mov ax, [rsp+2*rcx]\n    mov [rsp+2*rcx], bx     ; clear uppercase count\n    add [rdi+2*rcx], ax     ; add uppcase count to lowcase count\n    jnc .casenov\n    mov [rdi+2*rcx], dx     ; overflow of counter\n.casenov:\n    inc ecx                 ; to next counter\n    cmp ecx,'Z'\n    jbe .case\n    ; count number of duplicates\n    xor eax,eax\n    mov ecx,0ffH            ; loop over 0xff..0\n.count:\n    cmp [rsp+2*rcx], dx     ; compare counter <-> 2\n    jl .countno\n    inc eax                 ; count if 2 or more\n.countno:    \n    loop .count             ; to next counter\n    leave\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212278,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\n\nglobal duplicate_count\nsection .text\nduplicate_count:\n  xorps xmm0, xmm0\n  xor eax, eax\n  mov r8d, 2\n  movups [rsp - 29], xmm0\n  movaps [rsp - 40], xmm0\n  movaps [rsp - 56], xmm0\n.loop:\n  movsx edx, byte [rdi]\n  test edx, edx\n  je .done\n  mov esi, edx\n  xor ecx, ecx\n  not esi\n  test sil, 96\n  setne cl\n  shl ecx, 5\n  lea ecx, [rcx + rdx - 80]\n  movsxd r9, ecx\n  mov dl, [rsp + r9 - 56]\n  inc dl\n  movzx edx, dl\n  mov esi, edx\n  cmove esi, r8d\n  xor ecx, ecx\n  cmp dl, 2\n  sete cl\n  inc rdi\n  add rax, rcx\n  mov [rsp + r9 - 56], sil\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212279,"user_id":null,"body":"global duplicate_count\nsection .text\nduplicate_count:\n  xor eax, eax\n  xor esi, esi\n.loop:\n  mov cl, [rdi]\n  test cl, cl\n  jz .exit\n  inc rdi\n  cmp cl, 122\n  ja .loop\n  sub cl, 48\n  cmp cl, 10\n  jb .digit\n  sub cl, 17\n  cmp cl, 26\n  jb .alpha\n  sub cl, 32\n  cmp cl, 26\n  jb .alpha\n  jmp .loop\n.digit:\n  add cl, 26\n.alpha:\n  mov r8, 1\n  shl r8, cl\n  test r8, rsi\n  jnz .duplicate\n  or rsi, r8\n  jmp .loop\n.duplicate:\n  or rax, r8\n  jmp .loop\n.exit:\n  popcnt rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212280,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\n\nglobal duplicate_count\nsection .text\nduplicate_count:\n  xor eax, eax\n  lea rsi, [data]\n  %assign i 0\n  %rep 64\n  mov [rsi+i], rax\n  %assign i i+8\n  %endrep\n  \n  xor edx, edx\n.loop:\n  mov dl, [rdi]\n  inc rdi\n  lea ecx, [rdx-0x20]\n  cmp dl, 'a'\n  cmovae edx, ecx\n  inc dword [rsi+rdx*4]\n  test dl, dl\n  jnz .loop\n  \n  %assign i 0\n  %rep 128\n  cmp dword [rsi+i], 1\n  setg dl\n  add eax, edx\n  %assign i i+4\n  %endrep\n  ret\n      \nsection .bss\ndata: resd 128","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212281,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\n\nglobal duplicate_count\nsection .text\nduplicate_count:\n      xor rax, rax\n      xor r8, r8 ; seen once\n      xor r9, r9 ; seen twice\n      jmp .loop_entry\n      \n  .loop:\n      test al, 0b0100_0000\n      jnz .alpha\n      and al, 0b0000_1111\n      jmp .offset_ok\n  .alpha:\n      and al, 0b0001_1111\n      add al, '9' & 0b0000_1111\n  .offset_ok:\n      bts r8, rax\n      jnc .never_seen\n      bts r9, rax\n  .never_seen:\n      inc rdi\n  .loop_entry\n      mov al, byte [rdi]\n      cmp al, 0\n      jne .loop\n      \n      popcnt rax, r9\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212282,"user_id":null,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\n\nglobal duplicate_count\nsection .text\nduplicate_count:\n      xor rcx, rcx\n      xor r8, r8 ; seen once\n      xor r9, r9 ; seen twice\n\n  .loop:\n      mov cl, byte [rdi]\n      jecxz .end\n\n      sub cl, '0'\n      cmp cl, 10\n      jb .offset_ok\n      sub cl, ('A' - '0') - 10\n      cmp cl, 26 + 10\n      jb .offset_ok\n      sub cl, 'a' - 'A'\n  .offset_ok:\n      bts r8, rcx\n      jnc .never_seen\n      bts r9, rcx\n  .never_seen:\n      inc rdi\n      jmp .loop\n\n  .end:\n      popcnt rax, r9\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212283,"user_id":173,"body":"; The pointer to the string is passed on with RDI\n; Place the number of duplicate letters and digits in EAX when returning\nextern printf\nsection .bss\nftbl:\n  resb 128\n\nglobal duplicate_count\nsection .text\nduplicate_count:\n      lea rsi, [rel ftbl]\n      \n      ; init freq table\n      mov rax, 0\nl_init:\n      mov byte [rsi + rax], 0\n      inc rax\n      cmp rax, 127\n      jb l_init\n\n      ; populate freq table\nl_next:\n      cmp byte [rdi], 0\n      je l_done\n      \n      xor rax, rax\n      mov byte al, [rdi]\n      mov byte cl, [rsi + rax]\n      inc cl\n      mov byte [rsi+rax], cl\n      \n      inc rdi\n      jmp l_next\n      \nl_done:\n      ; collapse 'a's over 'A's\n      mov rax, 'a'\nl_collapse:\n      mov cl, byte [rsi + rax]\n      mov ch, byte [rsi + rax - 0x20]\n      add cl, ch\n      mov byte [rsi + rax], cl\n      mov byte [rsi + rax - 0x20], 0\n      inc rax\n      cmp rax, 'z'\n      jbe l_collapse\n\n      ; compute how many elements in the frequency table appear 2 or more times\n      xor rax, rax\n      xor rbx, rbx\n      mov r12, 0\nl_cf:\n      mov cl, byte [rsi + rax]\n      cmp cl, 2\n      jb l_n\n\n      inc r12\nl_n:\n      inc rax\n      cmp rax, 127\n      jb l_cf\n\n      xor eax, eax\n      mov ax, bx\n      \n      mov rax, r12\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54d1c59aba326343c80000e7":[{"id":212284,"user_id":null,"body":"global divnums\n\n; <-- XMM0 divnums(EDI x, ESI y) -->\ndivnums:\n  vcvtsi2sd xmm0, xmm0, edi\n  vcvtsi2sd xmm1, xmm1, esi\n  vdivsd xmm0, xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212285,"user_id":null,"body":"global divnums\n\n; <-- XMM0 divnums(EDI x, ESI y) -->\ndivnums:\n    cvtsi2sd xmm0, edi\n    cvtsi2sd xmm1, esi\n    divsd xmm0, xmm1\n    ret\n; -----> endof divnums <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212286,"user_id":null,"body":"global divnums\n\n; XMM0 divnums(EDI x, ESI y)\ndivnums:\n  cvtsi2sd xmm0, edi\n  cvtsi2sd xmm1, esi\n  divsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212287,"user_id":104,"body":"; 2021 nomennescio\nglobal divnums\n\n; <-- XMM0 divnums (EDI x, ESI y) -->\ndivnums:\n    cvtsi2sd xmm0, edi\n    cvtsi2sd xmm1, esi\n    divsd xmm0, xmm1\n    ret\n; -----> endof divnums <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212288,"user_id":null,"body":"global divnums\n\n; <-- XMM0 divnums(EDI x, ESI y) -->\ndivnums:\n;eax = 32bits\n;edx = 32bits\n;edi = 32bits\n;esi = 32bits\n;XMM0 = 128bits\n\n    CVTSI2SD xmm0, edi \n    CVTSI2SD xmm1, esi \n    ;xor edx, edx\n    ;mov edx, esi\n    ;div esi\n    ;movd xmm0, eax\n    divsd xmm0, xmm1\n    ret\n; -----> endof divnums <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212289,"user_id":null,"body":"global divnums\n\n; <-- XMM0 divnums(EDI x, ESI y) -->\ndivnums:\n    cvtsi2sd xmm0, edi\n    cvtsi2sd xmm1, esi\n    divsd    xmm0, xmm1\n    ret\n; -----> endof divnums <----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212290,"user_id":null,"body":"global divnums\n\n; <-- XMM0 divnums(EDI x, ESI y) -->\ndivnums:\n  cvtsi2sd  xmm0, edi\n  cvtsi2sd  xmm1, esi\n  divpd xmm0, xmm1\n  ret\n; -----> endof divnums <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212291,"user_id":null,"body":"global divnums\n\n; <-- XMM0 divnums(EDI x, ESI y) -->\ndivnums:\n    mov [dividend], edi\n    mov [divisor], esi\n    fild dword [dividend]\n    fild dword [divisor]\n    fdivp\n    fstp qword [result]\n    movq xmm0, [result]\n    ret\n; -----> endof divnums <-----\n\nsection .bss\nresult: resq 1\ndivisor: resd 1\ndividend: resd 1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212292,"user_id":1027,"body":"global divnums\ndivnums:\n  cvtsi2sd xmm0,edi\n  cvtsi2sd xmm1,esi\n  divsd xmm0,xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212293,"user_id":527,"body":"global divnums\n\n; double divnums(int x, int y)\ndivnums:\n                cvtsi2sd    xmm0, edi\n                cvtsi2sd    xmm1, esi\n                divsd       xmm0, xmm1\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54da5a58ea159efa38000836":[{"id":212294,"user_id":527,"body":"global find_it\nsection .text\n\nfind_it:\n                xor     eax, eax\n.loop:          xor     eax, [rdi]\n                add     rdi, 4\n                dec     rsi\n                jnz     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212295,"user_id":null,"body":"SECTION .text\nglobal find_it\n\n; Finds the number which appears an odd amount of times in an array\n; arg0         = (int32_t*) The array of numbers\n; arg1         = (size_t)   The length of arg0\n; return value = (int32_t)  The number which appears an odd amount of times\nfind_it:\n    xor     eax, eax    ; result = 0\n    mov     rcx, rsi    ; i = arg1\n\n.next:\n    xor     eax, [rdi + rcx*4 - 4]  ; result ^= arg0[i-1]\n    loop    .next                   ; --i; loop if != 0\n\n    ret                 ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212296,"user_id":null,"body":"SECTION .text\nglobal find_it\n\n; Finds the number which appears an odd amount of times in an array\n; arg0         = (int32_t*) The array of numbers\n; arg1         = (size_t)   The length of arg0\n; return value = (int32_t)  The number which appears an odd amount of times\nfind_it:\n  shl rsi, 2\n  mov rbx, -4\nA:add rbx, 4\n  mov eax, [rdi + rbx]\n  test eax, eax\n  jz A\n  push rbx\n  mov dl, 0\nC:cmp eax, [rdi + rbx]\n  jne B\n  inc dl\n  mov dword [rdi + rbx], 0\nB:add rbx, 4\n  cmp rbx, rsi\n  jne C\n  pop rbx\n  test dl, 1\n  jz A\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212297,"user_id":null,"body":"global  find_it\n\nSECTION .text\n\n\nfind_it:\n    mov r9, 0   ; main loop i\n    mov r10, 0  ; internal loop j\n    mov r11, 0  ; counter\n\n.main_loop:\n    mov r11, 0  ; reset counter\n\n;---internal loop---\n    mov r10, 0  ;internal j loop\n    mov rax, [rdi]\n    nop\n.internal_loop:\n    mov r12d, dword [rdi+r9*4]\n    mov r13d, dword [rdi+r10*4]\n    cmp r12d, r13d ; compare arr[i] arr[j]\n    nop\n    jne .arr_i_arr_j_not_equals\n.arr_i_arr_j_equals:\n    inc r11\n.arr_i_arr_j_not_equals:\n    inc r10\n    cmp r10, rsi\n    jne .internal_loop\n;---end of internal loop---\n\n\n;--check if r11 % 2 != 0 if so, return counter--\n    push rdx\n    push rcx\n\n    mov rdx, 0\n    mov rax, r11\n    mov rcx, 2\n    div rcx\n    \n    cmp rdx, 0\n    \n    pop rcx\n    pop rdx\n    jne .return_element_with_odd_counter\n    \n;-------------\n\n    inc r9\n    cmp r9, rsi\n    jne .main_loop\n.return_element_with_odd_counter:\n    mov rax, [rdi+r9*4] ; arr[i]\n    ret\n\n\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212298,"user_id":null,"body":"; When the arrays reach a certain length it would make sense to sort them using e.g. qsort\n; instead of keeping track of which values are already done in a seperate array- from a performance perspective\n\nSECTION .text\nglobal find_it\nextern malloc, free\n\nfind_it:    push rdi\n            push rsi\n            shl rsi,2\n            mov rdi,rsi\n            call malloc\n            mov r10,rax        ; Base of ints counted \n            xor r11,r11        ; Number of ints counted\n            pop rsi\n            pop rdi\n            mov rcx,-1        ; Index of integers to search\n@main_loop: inc rcx\n            mov edx,[rdi + rcx * 4]\n            test r11,r11\n            jz @add_count\n            xor rax, rax      ; Index for searching already counted ints\n@s_counted: cmp [r10 + rax * 4],edx\n            je @main_loop\n            inc rax\n            cmp rax,r11\n            jl @s_counted\n@add_count: mov [r10 + r11 * 4],edx\n            inc r11\n@do_count:  lea r8,[rcx + 1]   ; Index while searching the remainder of the array\n            mov r9,1           ; Holds count\n@search_l:  cmp dword [rdi + r8 * 4],edx\n            jne @not_match\n            inc r9\n@not_match: inc r8\n            cmp r8,rsi        ; Done yet ?\n            jl @search_l\n            shr r9,1          ; If no odd count, go count next\n            jnc @main_loop\n            push rdx\n            mov rdi,r10\n            call free\n            pop rax\n            ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212299,"user_id":1277,"body":"SECTION .text\nglobal find_it\n\n; Finds the number which appears an odd amount of times in an array\n; arg0         = (int32_t*) The array of numbers\n; arg1         = (size_t)   The length of arg0\n; return value = (int32_t)  The number which appears an odd amount of times\nfind_it:\n  xor eax, eax\n  jmp loop_cond\n  \n  loop:\n    dec rsi\n    xor eax, DWORD [rdi + rsi * 4]\n  \n  loop_cond:\n    test rsi, rsi\n    jnz loop\n    \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212300,"user_id":null,"body":"SECTION .text\nglobal find_it\nfind_it:\n xor rax,rax\n .b:xor eax,[rdi+rsi*4-4]\n    dec rsi\n jne .b\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212301,"user_id":null,"body":"SECTION .text\nglobal find_it\n\n; Finds the number which appears an odd amount of times in an array\n; arg0 rdi   = (int32_t*) The array of numbers\n; arg1 rsi   = (size_t)   The length of arg0\n; return eax = (int32_t)  The number which appears an odd amount of times\nfind_it:\n  xor eax, eax          ; eax := accu\n  jmp .next\n.loop:\n  xor eax, [rdi+4*rsi]  ; a xor a = 0 for all even integers\n.next:\n  dec rsi\n  jge .loop             ; next integer\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212302,"user_id":null,"body":"SECTION .text\nglobal find_it\n\nfind_it:\n  test rsi, rsi\n  je .exit\n  xor eax, eax\n.loop:\n  xor rax, [rdi]\n  add rdi, 4\n  dec rsi\n  jnz .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212303,"user_id":null,"body":"SECTION .text\nglobal find_it\n\n; Finds the number which appears an odd amount of times in an array\n; arg0         = (int32_t*) The array of numbers\n; arg1         = (size_t)   The length of arg0\n; return value = (int32_t)  The number which appears an odd amount of times\nfind_it:\n  xor eax, eax\n.loop:\n  sub rsi, 1\n  jb .done\n  xor eax, [rdi]\n  add rdi, 4\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54eb33e5bc1a25440d000891":[{"id":212304,"user_id":527,"body":"global decompose\nsection .text\n; long decompose(long n, long *output)\ndecompose:\n                cmp     rdi, 1\n                jle     .not_found\n                dec     rdi\n                mov     [rsi], rdi\n                lea     rdi, [rdi * 2 + 1]\n                xor     eax, eax\n.loop:          mov     rdx, [rsi + rax * 8]\n                dec     rdx\n                jnz     .not_one\n.one:           dec     eax\n                jl      .not_found\n                mov     rdx, [rsi + rax * 8]\n                lea     rdi, [rdi + rdx * 2]\n                dec     rdx\n                mov     [rsi + rax * 8], rdx\n                jmp     .loop\n.not_one:       cvtsi2sd    xmm0, rdi\n                sqrtsd      xmm0, xmm0\n                cvttsd2si   rcx, xmm0\n                cmp     rcx, rdx\n                cmovb   rdx, rcx\n                inc     eax\n                mov     [rsi + rax * 8], rdx\n                imul    rdx, rdx\n                sub     rdi, rdx\n                jnz     .loop\n.found:         lea     rdi, [rsi + rax * 8]\n.reverse_loop:  mov     rcx, [rsi]\n                mov     rdx, [rdi]\n                mov     [rsi], rdx\n                mov     [rdi], rcx\n                add     rsi, 8\n                sub     rdi, 8\n                cmp     rsi, rdi\n                jb      .reverse_loop\n                inc     eax\n                ret\n.not_found:     mov     rax, -1\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212305,"user_id":null,"body":"section .text\nglobal decompose\n; long decompose(long n, long *output);\n; Write the output to `output` in increasing order, and return the length.\n; If `n` has no solutions, return -1.\ndecompose:\n  ; The subroutine will check if numbers less than our given number `n` can \n  ; fit in it. This will be accomplished by repeated substractions between the\n  ; square of `n` and the square of each number from `n-1` and `1`. We will use\n  ; a stack to keep track of numbers that fit. If we can't find the desired numbers\n  ; in the first iteration we will get the top on the stack and repeat the same procedure\n  ; until the stack is empty.\n  \n  ; Move array to r10. We will use this at the end of the subroutine, when we will\n  ; move the numbers from stack to array.\n  mov r10, rsi\n  \n  ; <rcx> will keep track of the difference between the square of `n` and the numbers\n  ; from `n-1` to `1`.\n  xor rcx, rcx\n  \n  ; The stack created by the process itself will be the stack we will use for our numbers\n  ; too. Firstly, push the stack length and after that we can push our stack. <r8> will\n  ; contain the address of the stack's length.\n  push dword 1\n  mov r8, rsp\n  \n  ; Push `n` to stack.\n  push rdi\n  \n  ; Loop through the stack until it's empty. If we exit from this loop, it means that\n  ; no sequence of numbers could fit in our number.\n.loop.stack:\n  ; Get top of the stack.\n  pop rsi\n  \n  ; Decrement length of stack.\n  mov rax, [r8]\n  dec rax\n  mov [r8], rax\n  \n  ; Add the square of the top of the stack to <rcx> in order to make the repeated substractions.\n  ; If we go through this loop more than one time, this also means that the previous number was not\n  ; useful and we add it back to <rcx> in order to preserve the condition.\n  mov rax, rsi\n  \n  xor rdx, rdx\n  mul rax\n  \n  add rcx, rax\n  \n  ; The second loop iterates through the numbers from `top of stack` to `1`. <rbx> will\n  ; be the iterator.\n  mov rbx, rsi\n  dec rbx\n  \n  ; If iterator is 0 just skip over the loop since it won't help us at all.\n  cmp rbx, 0\n  je .loop.stack.back\n  \n.loop.numbers:\n  ; Check if the number fits by substracting `top of stack^2` - `iterator^2`.\n  mov rax, rbx\n  xor rdx, rdx\n  mul rax\n  \n  ; The substraction will take place in <rdx>.\n  mov rdx, rcx\n  sub rdx, rax\n  \n  ; If the difference is greater than 0 it means that the `iterator` fits in our\n  ; `top of stack`.\n  cmp rdx, 0\n  jl .loop.numbers.back\n  \n  ; Substract the number we found from <rcx> because we need to find the next number\n  ; lesser than `top of stack` and the new number we found.\n  sub rcx, rax\n  \n  ; Append the new number to stack in order to keep track of it.\n  push rbx\n  \n  ; Increment length of stack.\n  mov rax, [r8]\n  inc rax\n  mov [r8], rax\n  \n  ; If, in the end, the repeated substractions are equal to 0 it means that we found\n  ; the sequence that satisfies our condition.\n  cmp rcx, 0\n  je success\n  \n.loop.numbers.back:\n  dec rbx\n  cmp rbx, 1\n  jge .loop.numbers\n  \n.loop.stack.back:\n  mov rax, [r8]\n  cmp rax, 0\n  jne .loop.stack\n  \n  ; Delete the space allocated for the length of stack.\n  add rsp, 8\n  \n  ; If failed return -1\n  mov rax, -1\n  ret\n  \nsuccess:\n  ; Move the length of the stack to rcx in order to loop through the stack and the\n  ; array at the same time and copy the values one at a time.\n  mov rcx, [r8]\n.append.array:\n  pop rax\n  mov [r10], rax\n  add r10, 8\n  loop .append.array\n  \n  ; Get the length of the stack as return value.\n  pop rax\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212306,"user_id":743,"body":"global decompose\n\nsection .bss\n\nXrsi resq 1\nXrsp resq 1\n\nsection .text\n;                  rdi      rsi          r8 (unconventional)\n; void search(long n, long* output, long upb);\n; return directly to the caller of decompose if a valid solution found\nsearch:\n  mov rax, rcx\n  test rdi, rdi\n  jz .succ\n  push r8\n.loop1:\n  sub r8, 1\n  jz .fail\n.loop1_:\n  mov rax, r8\n  imul rax, r8\n  cmp rax, rdi\n  ja .loop1\n  mov qword [rsi], r8\n  add rsi, 8\n  push rdi\n  sub rdi, rax\n  call search\n  pop rdi\n  sub rsi, 8\n  sub r8, 1\n  jnz .loop1_\n.fail:\n  pop r8\n  ret\n.succ:\n  mov rdi, qword [Xrsi]\n  mov rax, rsi\n  sub rax, qword rdi\n  shr rax, 3\n  sub rsi, 8\n  cmp rdi, rsi\n  jae .end\n.loop2:\n  mov r8, qword [rdi]\n  mov r9, qword [rsi]\n  mov qword [rdi], r9\n  mov qword [rsi], r8\n  add rdi, 8\n  sub rsi, 8\n  cmp rdi, rsi\n  jb .loop2\n.end:\n  mov rsp, qword [Xrsp]\n  ret\n\n;                     rdi      rsi\n; long decompose(long n, long* output);\ndecompose:\n  mov r8, rdi\n  imul rdi, r8\n  mov qword [Xrsi], rsi\n  mov qword [Xrsp], rsp ; guess why i store rsp\n  call search\n  mov rax, -1\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212307,"user_id":168,"body":"section .text\nglobal decompose\n; long decompose(long n, long *output);\n; Write the output to `output` in increasing order, and return the length.\n; If `n` has no solutions, return -1.\ndecompose:\n  mov rdx, rdi\n  imul rdi, rdi\n  xor ecx, ecx\n  call search\n  mov rax, -1\n  test rcx, rcx\n  cmovnz rax, rcx\n  ret\n\nsearch:\n  cmp rdi, 0\n  jg .loop_cond\n  sete al\n  ret\n.loop:\n  push rdi\n  push rdx\n  mov rax, rdx\n  imul rax, rax\n  sub rdi, rax\n  call search\n  pop rdx\n  pop rdi\n  test al, al\n  jnz .found\n.loop_cond:\n  dec rdx\n  jg .loop\n.not_found:\n  xor al, al\n  ret\n.found:\n  mov [rsi + rcx * 8], rdx\n  inc rcx\n  mov al, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212308,"user_id":1339,"body":"section .text\nglobal decompose\n; long decompose(long n, long *output);\ndecompose:\n  push rsi ; output\n  mov rax, rdi\n  mul rdi\n  mov rdx, rsi\n  mov rsi, rdi\n  mov rdi, rax\n  call recurse\n  pop rsi\n  cmp rax, 0\n  jg .valid\n  ret\n.valid:\n  mov rcx, 0\n  mov rdx, rax\n  dec rdx\n.loop:\n  cmp rcx, rdx\n  jl .loop_cont\n  ret\n.loop_cont:\n  mov rdi, [rsi + rcx * 8]\n  xchg [rsi + rdx * 8], rdi\n  mov [rsi + rcx * 8], rdi\n  inc rcx\n  dec rdx\n  jmp .loop\n\n; long recurse(long sum, long last, long *output)\nrecurse:\n  mov r8, rdx\n  mov rcx, rsi\n  dec rcx\n.loop:\n  cmp rcx, 0\n  jnz .loop_cont\n  mov rax, -1\n  ret\n.loop_cont:\n  mov rax, rcx\n  mul rcx\n  cmp rdi, rax ; sum : next * next\n  jge .loop_cont2\n  dec rcx\n  jmp .loop\n.loop_cont2:\n  mov [r8], rcx\n  cmp rdi, rax\n  jne .loop_cont3\n  mov rax, 1\n  ret\n.loop_cont3:\n  push rdi ; sum\n  push rcx ; next\n  push r8 ; output\n  sub rdi, rax\n  mov rsi, rcx\n  lea rdx, [r8 + 8]\n  call recurse\n  pop r8\n  pop rcx\n  pop rdi\n  cmp rax, 0\n  jle .loop_cont4\n  inc rax\n  ret\n.loop_cont4:\n  dec rcx\n  jmp .loop","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54ff3102c1bad923760001f3":[{"id":212309,"user_id":null,"body":"section     .text\nglobal      get_count\n\nget_count:\n    xor     rax, rax\n    xor     rdx, rdx\n    xor     rcx, rcx\n\n    dec     rdx\n\n_string_loop:\n    inc     rdx\n    cmp     [rdi + rdx], BYTE 0\n    jz      _exit\n    cmp     [rdi + rdx], BYTE 'a'\n    jz      _increment\n    cmp     [rdi + rdx], BYTE 'e'\n    jz      _increment\n    cmp     [rdi + rdx], BYTE 'i'\n    jz      _increment\n    cmp     [rdi + rdx], BYTE 'o'\n    jz      _increment\n    cmp     [rdi + rdx], BYTE 'u'\n    jz      _increment\n    jmp     _string_loop\n\n_increment:\n    inc     rcx\n    jmp     _string_loop\n\n_exit:\n    mov     rax, rcx\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212310,"user_id":168,"body":"SECTION .text\nglobal get_count\n; Returns the number of vowels in a string which only contains spaces and lowercase characters.\n; arg0         = (const char*) The string to count the vowels of.\n; return value = (uint32_t)    The number of vowels.\nget_count:\n  xor eax, eax\n  mov ecx, 0b100000100000100010001\n  jmp .loop_cond\n.loop:\n  inc rdi\n  sub dl, 'a'\n  bt ecx, edx\n  adc eax, 0\n.loop_cond:\n  movzx edx, byte [rdi]\n  test dl, dl\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212311,"user_id":null,"body":"SECTION .text\nglobal get_count\n\n; Returns the number of vowels in a string which only contains spaces and lowercase characters.\n; arg0         = (const char*) The string to count the vowels of.\n; return value = (uint32_t)    The number of vowels.\nget_count:\n  xor eax, eax\n  ;         zyxwvutsrqponmlkjihgfedcba\n  mov r8, 0b00000100000100000100010001\n.loop:\n  mov dl, byte [rdi]\n  test dl, dl\n  jz .done\n  sub dl, 'a'\n  jc .out_of_bounds\n  movzx rdx, dl\n  bt r8, rdx\n  adc eax, 0\n.out_of_bounds:\n  add rdi, 1\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212312,"user_id":null,"body":"SECTION .text\nglobal get_count\n\n; Returns the number of vowels in a string which only contains spaces and lowercase characters.\n; arg0         = (const char*) The string to count the vowels of.\n; return value = (uint32_t)    The number of vowels.\nget_count:\n  xor eax, eax\n\nloop:\n  mov bh, [rdi]\n  cmp bh, 0\n  je done\n\n  inc rdi\n  \n  cmp bh, 'a'\n  je vowel\n  cmp bh, 'e'\n  je vowel\n  cmp bh, 'i'\n  je vowel\n  cmp bh, 'o'\n  je vowel\n  cmp bh, 'u'\n  je vowel\n\n  jmp loop\n\nvowel:\n  inc eax\n  jmp loop\n\ndone:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212313,"user_id":null,"body":"SECTION .data\n  counts db 1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1\n  \nSECTION .text\nglobal get_count\n\n; Returns the number of vowels in a string which only contains spaces and lowercase characters.\n; arg0         = (const char*) The string to count the vowels of.\n; return value = (uint32_t)    The number of vowels.\nget_count:\n  xor rax, rax\n  xor rdx, rdx\n  \n.loop:\n  mov dl, byte [rdi]\n  cmp dl, 0\n  jz .exit\n  cmp dl, 'u'\n  jg .cont\n  sub dl, 'a'\n  js .cont\n  add al, byte [counts + rdx]\n  \n.cont:\n  inc rdi\n  jmp .loop\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212314,"user_id":null,"body":"SECTION .text\nglobal get_count\n\n; Returns the number of vowels in a string which only contains spaces and lowercase characters.\n; arg0         = (const char*) The string to count the vowels of.\n; return value = (uint32_t)    The number of vowels.\nget_count:\n  xor rax, rax\n  xor rcx, rcx\n  _loop:\n    xor edx, edx\n    mov dl, [rdi+rcx*1]\n    cmp dl, 0\n    je _end\n    cmp rdx, 97\n    je _vowel\n    cmp rdx, 101\n    je _vowel\n    cmp rdx, 105\n    je _vowel\n    cmp rdx, 111\n    je _vowel\n    cmp rdx, 117\n    je _vowel\n    inc rcx\n    jmp _loop\n    _vowel:\n        inc rax\n        inc rcx\n        jmp _loop\n  _end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212315,"user_id":null,"body":"SECTION .text\nglobal get_count\n\n\n; Returns the number of vowels in a 8-bit ASCII zero string.\n; Vowels are aeiou.\n; argument RDI: (const char*) The string to count the vowels of.\n; return EAX:  (uint32_t)    The number of vowels.\nget_count:\n  xor eax, eax      ; r8d := vowel counter\n  mov edx, 104111h  ; bit mask for vowel chars\n.next:\n  mov cl,[rdi]      ; load next 8-bit char\n  test cl, cl       ; al == 0, end of string?\n  jz .exit\n  inc rdi           ; move pointer to next char\n  mov ebx, edx      ; ebx := vowel bit pattern\n  sar ebx, cl       ; shift vowel bit of current char into carry bit\n  jnc .next\n  inc eax           ; count current vowel and load next char\n  jmp .next\n.exit:  \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212316,"user_id":null,"body":"SECTION .text\nglobal get_count\n\nget_count:\n  xor eax, eax\n.loop:\n  mov bl, [rdi]\n  test bl, bl\n  jz .exit\n  inc rdi\n  cmp bl, 'a'\n  jz .vowel\n  cmp bl, 'e'\n  jz .vowel\n  cmp bl, 'i'\n  jz .vowel\n  cmp bl, 'o'\n  jz .vowel\n  cmp bl, 'u'\n  jz .vowel\n  jmp .loop\n.vowel:\n  inc eax\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212317,"user_id":null,"body":"SECTION .text\n  global get_count\n\nget_count:\n  mov rax,0\n  mov rcx,-1\n\ncount_vowels:\n  inc rcx\n\n  cmp byte[rdi+rcx],97\n  jne nota\n  inc rax\n  nota:\n\n  cmp byte[rdi+rcx],101\n  jne note\n  inc rax\n  note:\n\n  cmp byte[rdi+rcx],105\n  jne noti\n  inc rax\n  noti:\n\n  cmp byte[rdi+rcx],111\n  jne noto\n  inc rax\n  noto:\n\n  cmp byte[rdi+rcx],117\n  jne notu\n  inc rax\n  notu:\n  \n  cmp byte[rdi+rcx],0\n  jne count_vowels\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212318,"user_id":null,"body":"SECTION .text\nglobal get_count\n\n; Returns the number of vowels in a string which only contains spaces and lowercase characters.\n; arg0         = (const char*) The string to count the vowels of.\n; return value = (uint32_t)    The number of vowels.\nget_count:\n  xor eax, eax\n  mov ecx, 1065233\n.loop:\n  mov dl, [rdi]\n  lea esi, [rdx - 97]\n  cmp sil, 20\n  ja .notvowel\n  movzx esi, sil\n  bt rcx, rsi\n  jae .notvowel\n  inc eax\n.next:\n  inc rdi\n  jmp .loop\n.notvowel:\n  test dl, dl\n  jne .next\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5500d54c2ebe0a8e8a0003fd":[{"id":212319,"user_id":null,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n  mov rax, rdi\n.loop:\n  test rsi, rsi\n  je .done\n  xor edx, edx\n  div rsi\n  mov rax, rsi\n  mov rsi, rdx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212320,"user_id":50,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n  mov rax,rdi\n  mov rbx,rsi\n_loop:\n  test rbx,rbx\n  jz _exit\n  xor rdx,rdx\n  div rbx\n  mov rax,rdx\n  xchg rax,rbx\n  jmp _loop\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212321,"user_id":168,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n  mov rax, rdi\n  jmp .loop_cond\n.loop:\n  xor edx, edx\n  div rsi\n  mov rax, rsi\n  mov rsi, rdx\n.loop_cond:\n  test rsi, rsi\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212322,"user_id":527,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n                tzcnt   rcx, rdi\n                tzcnt   rax, rsi\n                shrx    rdi, rdi, rcx\n                shrx    rsi, rsi, rax\n                cmp     rax, rcx\n                cmovb   rcx, rax\n.loop:          mov     rax, rdi\n                sub     rax, rsi\n                tzcnt   r8, rax\n                mov     rdx, rsi\n                sub     rdx, rdi\n                cmovb   rdx, rax\n                cmovb   rdi, rsi\n                shrx    rsi, rdx, r8\n                jnz     .loop\n.done:          shlx    rax, rdi, rcx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212323,"user_id":527,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n                tzcnt   rcx, rdi\n                tzcnt   rax, rsi\n                shrx    rdi, rdi, rcx\n                shrx    rsi, rsi, rax\n                cmp     rax, rcx\n                cmovb   rcx, rax\n                jmp     .entry\n.loop:          tzcnt   rdi, rax\n                shrx    rdi, rax, rdi\n.entry:         cmp     rdi, rsi\n                mov     rax, rdi\n                cmovb   rax, rsi\n                cmovb   rsi, rdi\n                sub     rax, rsi\n                jnz     .loop\n.done:          shlx    rax, rsi, rcx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212324,"user_id":527,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n                mov     rax, rdi\n.loop:          xor     rdx, rdx\n                div     rsi\n                mov     rax, rsi\n                mov     rsi, rdx\n                test    rdx, rdx\n                jnz     .loop\n.done:          ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212325,"user_id":50,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n    xor rax, rax  ; x -> RDI, y -> RSI, result -> RAX\n_loop:\n    mov rax,rdi\n    xor rdx,rdx\n    idiv rsi\n    test rdx,rdx\n    jz _exit\n    mov rdi,rsi\n    mov rsi,rdx\n    jmp _loop\n_exit:\n    mov rax,rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212326,"user_id":881,"body":"section .text\nglobal my_gcd\n\n; my_gcd(unsigned long long x, unsigned long long y)\nmy_gcd:\n    mov rax, rdi\n    test rsi, rsi\n    jz .done\n    xor rdx, rdx\n    div rsi\n    mov rdi, rsi\n    mov rsi, rdx\n    jmp my_gcd\n.done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"550498447451fbbd7600041c":[{"id":212327,"user_id":null,"body":"global comp\nsection .text\ncomp:\n    ; rdi->a, rsi->b, rdx->n, rcx->row, r8->col, r9->tmp1, r10->rmp2\n    push rbp\n    mov rbp, rsp\n\n    push rbx\n    push r12\n\n    mov [stack_size], rdx\n    sub rsp, rdx\n\n    mov rcx, rdx\n    xor rax, rax\n_checked_values:\n    mov byte [rsp + rcx - 1], 0\n    loop _checked_values\n\n    xor r13, r13\n    mov r12, rdx\n    dec r12\n    xor rax, rax\n    xor r9, r9\n    xor r10, r10\n\n    mov rcx, -1 ; row\n_outer_loop:\n    mov r8, -1  ; col\n    inc rcx\n_inner_loop:\n    inc r8\n    mov r9b, byte [rsp + r8]\n    cmp r9b, 1\n    je _inner_loop_test\n\n    mov r9d, dword [rdi + r8*4]\n    mov r10d, dword [rsi + rcx*4]\n    xor rax, rax\n    mov eax, r9d\n    mul eax\n\n    cmp eax, r10d\n    je _to_outer_loop\n\n_inner_loop_test:\n    cmp r8d, r12d\n    jne _inner_loop\n    jmp _false\n\n_to_outer_loop:\n    mov byte [rsp + r8], 1\n    cmp ecx, r12d\n    jne _outer_loop\n\n_true:\n    mov rax, 1\n    jmp _end\n_false:\n    mov rax, 0\n\n_end:\n    add rsp, [stack_size]\n    pop r12\n    pop rbx\n    pop rbp\n    ret\n\n\nsection .bss\nstack_size: resd 1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212328,"user_id":null,"body":"global comp\nextern malloc, free\nextern memcpy\n\nsection .text\n\n; <--- bool comp_same(const int *a, const int *b, size_t n) --->\ncomp:\n    push r12                ; saving R12 in the stack\n    push rbp                ; saving RBP in the stack\n    push rbx                ; saving RBX in the stack\n    xor eax, eax            ; resetting EAX\n    test rdi, rdi           ; whether <a> is NULL\n    je .exit                ; jumping to exit\n    test rsi, rsi           ; whether <b> is NULL\n    je .exit                ; jumping to exit\n    test rdx, rdx           ; whether <n> is zero\n    je .exit                ; jumping to exit\n    mov rbp, rdi            ; saving <a> in RBP\n    mov rbx, rsi            ; saving <b> in RBX\n    mov r12, rdx            ; saving <n> in R12\n    lea rdi, [rdx*4]        ; the bytes to allocate for <sqb>\n    call malloc             ; allocating memory\n    test rax, rax           ; whether the memory allocated\n    je .exit                ; otherwise, jumping to exit\n    mov rdi, rax            ; copying <sqb> to RDI\n    mov rsi, rbx            ; moving <b> to RSI\n    lea rdx, [r12*4]        ; evaluating <sz>\n    mov rbx, rax            ; moving <sqb> to RBX\n    call memcpy             ; copying <b> to <sqb> byte by byte\n    mov rdi, rbx            ; copying <sqb> to RDI\n.loop:\n    mov rcx, r12            ; copying <n> to RCX as <i>\n    dec r12                 ; decrementing <n>\n    jl .atexit              ; jumping to the .atexit label if no elements left\n    lea rsi, [r12*4]        ; saving <n*4> as <inx>\n    mov edx, [rbp+rsi]      ; copying <*(a+inx)> to EDX as <squ>\n    imul edx, edx           ; squaring <squ>\n    xor eax, eax            ; resetting the result\n.srch:\n    dec rcx                 ; decrementing <i>\n    jl .atexit              ; jumping to exit if the pair is not found\n    cmp edx, [rdi+rcx*4]    ; whether <squ> is equal to <*(sqb+i)>\n    jne .srch               ; otherwise, jumping to the next .srch iteration\n    inc al                 ; setting the result as true\n    mov edx, [rdi+rsi]      ; copying <*(sqb+inx)> to <squ>\n    mov [rdi+rcx*4], edx    ; setting <*(sqb+i)> to <squ>\n    jmp .loop\n.atexit:\n    mov ebx, eax            ; saving the result in EBX\n    call free               ; deallocating <sqb>\n    mov eax, ebx            ; restoring the result\n.exit:\n    pop rbx                 ; restoring the initial RBX\n    pop rbp                 ; restoring the initial RBP\n    pop r12                 ; restoring the initial R12\n    ret\n; ---------> endof comp_same <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212329,"user_id":null,"body":"global comp\n\nsection .text\n\ncomp:\n  ; grab the comparison bool\n  mov rax, [rbp-0x338]\n  movzx rax, BYTE [rax+0x88]\n  ret\n  \nsection .data\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212330,"user_id":null,"body":"global comp\n\nsection .text\n\n; bool {al} comp_same(const {rdi} int *a, const {rsi} int *b, size_t {rdx} n)\ncomp:\n    mov rcx, rdx ; to use as outer counter to loop through array a\n    mov r10, rcx ; silly imul overwrites edx, but I have lots of registers to use\nsexyloop:\n    mov eax, [rdi+4*(rcx-1)]\n    imul eax\n    mov r8, -1 ; inner counter\ninnerloop:\n      inc r8\n      mov r9d, [rsi+4*r8] ; loops through array b\n      cmp r9d, eax\n      jne nothinghappenedhere\n        mov [rsi+4*r8], dword -1 ; ain't nothing gonna square to -1\n        jmp outtahere\n    nothinghappenedhere:\n      cmp r8, r10\n      jne innerloop\n      xor rax, rax\n      ret\nouttahere:\n    loop sexyloop\n    mov rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212331,"user_id":null,"body":"global comp\n\nsection .text\n\n%macro pusha 0\n  push rcx\n  push rdx\n  push rbx\n  push rsi\n  push rdi\n  push r8\n  push r9\n%endmacro\n\n%macro popa 0\n  pop r9\n  pop r8\n  pop rdi\n  pop rsi\n  pop rbx\n  pop rdx\n  pop rcx\n%endmacro\n\n; <--- bool comp_same(const int *a, const int *b, size_t n) --->\ncomp:\n  pusha\n  \n  ; [RSP] <- array of bools indicating which elements of b have already been used\n  mov rcx, rdx\n  sub rsp, rdx\n  xor rax, rax\n  mov r9, rdi\n  mov rdi, rsp\n  rep stosb\n  mov rdi, r9\n  \n  xchg rsi, rdi\n  test rsi, rsi               ; RSI = a\n    jz .false\n  test rdi, rdi               ; RDI = b\n    jz .false\n  test rdx, rdx               ; RDX = n\n    jz .true\n  mov rcx, rdx                ; RCX <- n\n  mov rbx, rcx                ; RBX <- n\n  .outer_loop:                ; Loop over all elements in a\n    lodsd\n    mov r8, rdx\n    imul eax\n    mov rdx, r8\n    mov rcx, rdx\n    mov r9, rdi\n    .inner_loop:              ; Loop over all elements in b\n      jrcxz .false\n      repne scasd\n        jne .false\n      mov r8, rdx             ; Make sure this element hasn't already been used\n      sub r8, rcx\n      cmp byte [rsp + r8 - 1], 0\n        jne .inner_loop\n    mov byte [rsp + r8 - 1], 1 ; Element has now been used\n    mov rdi, r9\n    dec rbx\n      jnz short .outer_loop\n  \n  .true:\n  add rsp, rdx\n  popa\n  mov al, 1                  ; AL <- result (true)\n  ret\n\n  .false:\n  add rsp, rdx\n  popa\n  xor rax, rax               ; AL <- result (false)\n  ret\n; ---------> endof comp_same <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212332,"user_id":null,"body":"global comp\n\nsection .text\n\n; <--- bool comp_same(const int *a, const int *b, size_t n) --->\n;                         rdi           rsi       rdx\ncomp:\n    mov   r8, rdx\n.loop:\n    dec   rdx\n    js    .end\n    mov   eax, [rdi+rdx*4]\n    imul  eax, eax\n    mov   rcx, r8\n.loop2:\n    dec   rcx\n    js    .fail\n    cmp   eax, [rsi+rcx*4]\n    jnz   .loop2\n    mov   dword [rsi+rcx*4], -1\n    jmp   .loop\n.end:\n    mov   al, 1\n    ret\n.fail:\n    xor   al, al\n    ret\n; ---------> endof comp_same <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212333,"user_id":null,"body":"global comp\nextern memset,malloc,free\nsection .text\n\n; <--- bool comp_same(const int *a, const int *b, size_t n) --->\ncomp:\n  push rbp\n  push r15\n  push r14\n  push r13\n  push r12\n  push rbx\n  sub rsp, 6168\n  mov r15, rdx\n  mov qword [rsp + 8], rsi\n  mov r13, rdi\n  lea rdi, [rsp + 16]\n  mov edx, 6152\n  xor esi, esi\n  xor ebx, ebx\n  call memset\n  mov esi, 769\n.hashaloop:\n  cmp rbx, r15\n  je .hashadone\n  mov ebp, [r13 + 4*rbx]\n  xor edx, edx\n  xor r14d, r14d\n  imul ebp, ebp\n  mov eax, ebp\n  div esi\n  lea r12, [rsp + 8*rdx + 16]\n  mov rcx, r12\n.achainloop:\n  mov rax, [rcx]\n  test rax, rax\n  je .anull\n  cmp [rax], ebp\n  je .akeyfound\n  lea rcx, [rax + 8]\n  mov r14, rax\n  jmp .achainloop\n.anull:\n  push 16\n  pop rdi\n  call malloc\n  lea rcx, [r14 + 8]\n  test r14, r14\n  mov esi, 769\n  cmove rcx, r12\n  mov [rcx], rax\n  mov [rax], ebp\n  mov dword [rax + 4], 1\n  and qword [rax + 8], 0\n  jmp .akeydone\n.akeyfound:\n  inc dword [rax + 4]\n.akeydone:\n  inc rbx\n  jmp .hashaloop\n.hashadone:\n  mov rbp, [rsp + 8]\n  xor esi, esi\n  mov edi, 769\n.hashbloop:\n  cmp rsi, r15\n  je .true\n  mov ecx, [rbp + 4*rsi]\n  mov eax, ecx\n  cdq\n  idiv edi\n  movsxd rax, edx\n  lea rax, [rsp + 8*rax + 16]\n.bchainloop:\n  mov rax, [rax]\n  test rax, rax\n  je .bnull\n  cmp [rax], ecx\n  je .bkeyfound\n  add rax, 8\n  jmp .bchainloop\n.bkeyfound:\n  inc rsi\n  sub dword [rax + 4], 1\n  jae .hashbloop\n.bnull:\n  xor ebx, ebx\n.cleanup:\n  xor r15d, r15d\n  xor r14d, r14d\n.cleanloop:\n  cmp r14, 769\n  je .done\n  mov rdi, [rsp + 8*r14 + 16]\n.chainloop:\n  test rdi, rdi\n  je .null\n  cmp dword [rdi + 4], 0\n  mov rbp, [rdi + 8]\n  movzx ebx, bl\n  cmovg ebx, r15d\n  call free\n  mov rdi, rbp\n  jmp .chainloop\n.null:\n  inc r14\n  jmp .cleanloop\n.done:\n  and bl, 1\n  mov eax, ebx\n  add rsp, 6168\n  pop rbx\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  pop rbp\n  ret\n.true:\n  mov bl, 1\n  jmp .cleanup","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212334,"user_id":null,"body":"global comp\nextern abort\n\nsection .text\n\n; <--- AX comp_same(const int* RDI, const int* RSI, size_t RDX) --->\ncomp:\n    xor  eax, eax\n    test rdx, rdx             ; zero elements is always success\n    jz   .success\n    cmp  rdx, 64              ; support up to 64 elements\n    jle  .start\n    push rax                  ; align the stack to 16 bytes\n    call abort                ; safely abort at over 64 elements\n.success:\n    xor  eax, 1\n    ret\n.start:\n    xor  rbx, rbx             ; RSI bits (for elements in RSI that are used)\n    xor  r8, r8               ; RDI index\n.rdi_loop:\n    mov  r9d, [rdi + r8 * 4]  ; RDI value\n    imul r9d, r9d             ; square\n    xor  rcx, rcx             ; RSI index\n.rsi_loop:\n    mov  r10, 1               ; RSI mask\n    shl  r10, cl\n    mov  r11, r10\n    and  r11, rbx\n    test r11, r11             ; check RSI bit set\n    jnz  .rsi_loop_next       ; go to next if bit set\n    cmp  r9d, [rsi + rcx * 4] ; RSI value should be equal to square\n    jne  .rsi_loop_next       ; go to next RSI if not equal\n    inc  r8                   ; go to next RDI if equal\n    cmp  r8, rdx              ; check RDI finished\n    je   .success             ; success if RDI finished\n    or   rbx, r10             ; set RSI bit\n    jmp  .rdi_loop\n.rsi_loop_next:\n    inc  rcx\n    cmp  rcx, rdx             ; check if RSI candidates exhausted\n    jl   .rsi_loop\n    ret\n; ---------> endof comp_same <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212335,"user_id":null,"body":"global comp\nextern abort\n\nsection .text\n\n; <--- AX comp_same(const int* RDI, const int* RSI, size_t RDX) --->\ncomp:\n    xor  eax, eax\n    test rdx, rdx             ; zero elements is always success\n    jz   success\n    cmp  rdx, 64              ; support up to 64 elements\n    jle  start\n    push rax                  ; align the stack to 16 bytes\n    call abort                ; safely abort at over 64 elements\nsuccess:\n    xor  eax, 1\n    ret\nstart:\n    xor  rbx, rbx             ; RSI bits (for elements in RSI that are used)\n    xor  r8, r8               ; RDI index\nrdi_loop:\n    mov  r9d, [rdi + r8 * 4]  ; RDI value\n    imul r9d, r9d             ; square\n    xor  rcx, rcx             ; RSI index\nrsi_loop:\n    mov  r10, 1               ; RSI mask\n    shl  r10, cl\n    mov  r11, r10\n    and  r11, rbx\n    test r11, r11             ; check RSI bit set\n    jnz  rsi_loop_next        ; go to next if bit set\n    cmp  r9d, [rsi + rcx * 4] ; RSI value should be equal to square\n    jne  rsi_loop_next        ; go to next RSI if not equal\n    inc  r8                   ; go to next RDI if equal\n    cmp  r8, rdx              ; check RDI finished\n    je   success              ; success if RDI finished\n    or   rbx, r10             ; set RSI bit\n    jmp rdi_loop\nrsi_loop_next:\n    inc rcx\n    cmp rcx, rdx              ; check if RSI candidates exhausted\n    jl rsi_loop\nfailure:\n    ret\n; ---------> endof comp_same <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212336,"user_id":null,"body":"global comp\n\nextern malloc, memcpy, memcmp, qsort, free\n\nsection .text\n\nint_comp:\n  xor eax, eax\n  xor edx, edx\n  mov edi, [rdi]\n  mov esi, [rsi]\n  cmp edi, esi\n  setg al\n  setl dl\n  sub eax, edx\n  ret\n\n; <--- bool comp_same(const int *a, const int *b, size_t n) --->\ncomp:\n  xor eax, eax            ; AL <- the result\n  test rdi, rdi\n  jz .quit\n  test rsi, rsi\n  jz .quit\n  test rdx, rdx\n  jz .quit\n  \n  push rdi\n  push rsi\n  push rdx\n  sub rsp, 16\n  lea rdi, [rdx*8]\n  call malloc\n  test rax, rax\n  jz .quit1\n  \n  mov [rsp], rax\n  mov rdi, rax\n  mov rdx, [rsp+16]\n  lea rdx, [rdx*4]\n  mov rsi, [rsp+32]\n  call memcpy\n  \n  mov rdi, [rsp]\n  mov rdx, [rsp+16]\n  lea rdx, [rdx*4]\n  add rdi, rdx\n  mov [rsp+8], rdi\n  mov rsi, [rsp+24]\n  call memcpy\n  \n  mov rdi, [rsp+8]\n  mov rsi, [rsp+16]\n  mov edx, 4\n  lea ecx, [int_comp]\n  call qsort\n  \n  mov rdi, [rsp]\n  mov rsi, [rsp+16]\n.loop:\n  dec rsi\n  mov eax, [rdi+rsi*4]\n  mul eax\n  mov [rdi+rsi*4], eax\n  test rsi, rsi\n  jne .loop\n  \n  mov rdi, [rsp]\n  mov rsi, [rsp+16]\n  mov edx, 4\n  lea ecx, [int_comp]\n  call qsort\n  \n  mov rdi, [rsp]\n  mov rsi, [rsp+8]\n  mov rdx, [rsp+16]\n  lea rdx, [rdx*4]\n  call memcmp\n  test eax, eax\n  setz dl\n  movzx eax, dl\n  mov [rsp+8], rax\n  \n  mov rdi, [rsp]\n  call free\n  mov rax, [rsp+8]\n\n.quit1:\n  add rsp, 40\n.quit:\n  ret\n; ---------> endof comp_same <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5511b2f550906349a70004e1":[{"id":212337,"user_id":null,"body":"global last_digit\n\nsection .text\n\n; <-- EAX last_digit(ro [byte RDI] a, ro [byte RSI] b) -->\nlast_digit:\n  mov r8, rsi\n.findbend:\n  cmp byte [r8+1], 0\n  je .bend\n  inc r8\n  jmp .findbend\n.bend:\n  mov sil, [rsi+1]\n  movzx ecx, byte [r8]\n  test sil, sil\n  jne .findaend\n  cmp cl, 48\n  mov eax, 1\n  je .done\n.findaend:\n  cmp byte [rdi+1], 0\n  je .aend\n  inc rdi\n  jmp .findaend\n.aend:\n  movzx eax, byte [rdi]\n  xor edx, edx\n  mov edi, 10\n  sub eax, 48\n  div edi\n  test sil, sil\n  je .bonedigit\n  movzx eax, byte [r8-1]\n  imul eax, eax, 10\n  add ecx, eax\n.bonedigit:\n  add ecx, 3\n  and ecx, 3\n  lea eax, [rcx+rdx*4]\n  movsx eax, byte [arr+rax]\n.done:\n  ret\n\narr: db 0,0,0,0,1,1,1,1,2,4,8,6,3,9,7,1,4,6,4,6,5,5,5,5,6,6,6,6,7,9,3,1,8,4,2,6,9,1,9,1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212338,"user_id":null,"body":"global last_digit\n\nsection .text\n\n; <-- EAX last_digit(ro [byte RDI] a, ro [byte RSI] b) -->\nlast_digit:\n.loop1:\n  inc rdi\n  cmp byte [rdi], 0\n  jne .loop1\n  movzx edi, byte [rdi-1]\n  sub edi, '0'\n  \n  cmp byte [rsi+1], 0\n  je .onedigit\n.loop2:\n  inc rsi\n  cmp byte [rsi+1], 0\n  jne .loop2\n  movzx eax, byte [rsi-1]\n  movzx edx, byte [rsi]\n  lea eax, [rax*5]\n  lea esi, [rax*2+rdx-'0'*11]\n  jmp .next\n\n.onedigit:\n  movzx esi, byte [rsi]\n  sub esi, '0'\n  jz .bailout\n\n.next:\n  and esi, 3\n  lea rax, [table]\n  add rax, rsi\n  movzx eax, byte [rax+rdi*4]\n  ret\n  \n.bailout:\n  mov eax, 1\n  ret\n; -----> endof last_digit <-----\n\nsegment .rodata\ntable:\ndb 0, 0, 0, 0\ndb 1, 1, 1, 1\ndb 6, 2, 4, 8\ndb 1, 3, 9, 7\ndb 6, 4, 6, 4\ndb 5, 5, 5, 5\ndb 6, 6, 6, 6\ndb 1, 7, 9, 3\ndb 6, 8, 4, 2\ndb 1, 9, 1, 9\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212339,"user_id":null,"body":"global last_digit\n\nsection .text\n\n; <-- EAX last_digit(ro [byte RDI] a, ro [byte RSI] b) -->\nlast_digit:\n  ; handle a == 0\n  call strlen\n  cmp rax, 1\n  jne .a_last_digit\n  cmp BYTE [rdi], '0'\n  je .ret0\n  \n.a_last_digit:\n  push rsi\n  mov rsi, 1\n  call strend2num\n  mov r8, rax\n  \n  pop rdi ; restore b\n  \n  ; handle b == 0\n  call strlen\n  cmp rax, 1\n  jne .b_last_digit\n  cmp BYTE [rdi], '0'\n  je .ret1\n  \n.b_last_digit:\n  mov rsi, 2\n  call strend2num\n  mov r9, rax\n  \n  ; cmp a last digit\n  cmp r8, 0\n  je .zero\n  cmp r8, 1\n  je .one\n  cmp r8, 2\n  je .two\n  cmp r8, 3\n  je .three\n  cmp r8, 4\n  je .four\n  cmp r8, 5\n  je .five\n  cmp r8, 6\n  je .six\n  cmp r8, 7\n  je .seven\n  cmp r8, 8\n  je .eight\n  cmp r8, 9\n  je .nine\n\n; mod the exponent last digits\n.zero:\n  jmp .ret0\n.one:\n  jmp .ret1\n.two:\n  mov al, r9b\n  xor ah, ah\n  div BYTE [const4]\n  cmp ah, 0\n  je .ret6\n  cmp ah, 1\n  je .ret2\n  cmp ah, 2\n  je .ret4\n  cmp ah, 3\n  je .ret8\n.three:\n  mov al, r9b\n  xor ah, ah\n  div BYTE [const4]\n  cmp ah, 0\n  je .ret1\n  cmp ah, 1\n  je .ret3\n  cmp ah, 2\n  je .ret9\n  cmp ah, 3\n  je .ret7\n.four:\n  mov al, r9b\n  xor ah, ah\n  div BYTE [const2]\n  cmp ah, 0\n  je .ret6\n  cmp ah, 1\n  je .ret4\n.five:\n  jmp .ret5\n.six:\n  jmp .ret6\n.seven:\n  mov al, r9b\n  xor ah, ah\n  div BYTE [const4]\n  cmp ah, 0\n  je .ret1\n  cmp ah, 1\n  je .ret7\n  cmp ah, 2\n  je .ret9\n  cmp ah, 3\n  je .ret3\n.eight:\n  mov al, r9b\n  xor ah, ah\n  div BYTE [const4]\n  cmp ah, 0\n  je .ret6\n  cmp ah, 1\n  je .ret8\n  cmp ah, 2\n  je .ret4\n  cmp ah, 3\n  je .ret2\n.nine:\n  mov al, r9b\n  xor ah, ah\n  div BYTE [const2]\n  cmp ah, 0\n  je .ret1\n  cmp ah, 1\n  je .ret9\n\n.ret0:\n  xor eax, eax\n  jmp .ret\n.ret1:\n  mov eax, 1\n  jmp .ret\n.ret2:\n  mov eax, 2\n  jmp .ret\n.ret3:\n  mov eax, 3\n  jmp .ret\n.ret4:\n  mov eax, 4\n  jmp .ret\n.ret5:\n  mov eax, 5\n  jmp .ret\n.ret6:\n  mov eax, 6\n  jmp .ret\n.ret7:\n  mov eax, 7\n  jmp .ret\n.ret8:\n  mov eax, 8\n  jmp .ret\n.ret9:\n  mov eax, 9\n.ret:\n  ret\n; -----> endof last_digit <-----\n\nstrend2num:\n  call strlen\n  mov rcx, rax\n  xor rax, rax\n  \n  cmp rsi, 1\n  je .one\n  jmp .two\n\n.one:\n  mov al, [rdi+rcx-1]\n  sub al, '0'\n  ret\n  \n.two:\n  cmp rcx, 2\n  jb .one\n  \n  mov al, [rdi+rcx-2]\n  sub al, '0'\n  mul BYTE [const10]\n  \n  mov sil, [rdi+rcx-1]\n  sub sil, '0'\n  add al, sil\n  ret\n\nstrlen:\n  xor rcx, rcx\n.loop:\n  mov al, [rdi+rcx]\n  test al, al\n  jz .ret\n  inc rcx\n  jmp .loop\n.ret:\n  mov rax, rcx\n  ret\n\nsection .data\nconst2: db 2\nconst4: db 4\nconst10: db 10\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212340,"user_id":50,"body":"global last_digit\n\nsection .text\n\n; <-- EAX last_digit(ro [byte RDI] a, ro [byte RSI] b) -->\nlast_digit:\n    xor eax, eax                ; setting the result to EAX\n    cmp byte[rsi],'0' ; check b==0 -> 1\n    je _retOne\n    cmp byte[rdi],'0' ; check a==0 -> 0\n    je _retz\n    xor r8,r8         ; will hold a's last digit\n    xor rbx,rbx       ; b%100\n_finda:\n  inc rdi\n  cmp byte[rdi],0     ; check it's the last\n  je _findb\n  jmp _finda\n_findb:\n  dec rdi\n  mov r8b,byte[rdi]\n  sub r8b,'0' \n  cmp byte[rsi+1],0\n  je _bismall ; b < 10\n  mov r9,1 ; length of b\n_length:\n  inc r9\n  cmp byte[rsi+r9],0\n  je _lengthfound\n  jmp _length\n_bismall:\n  mov bl,byte[rsi]\n  jmp _calc\n_lengthfound:\n  mov bl,byte[rsi+r9-2]\n  sub bl,'0'\n  mov r11,10\n  imul ebx,r11d\n  add bl,byte[rsi+r9-1]\n  sub bl,'0'\n_calc:\n  mov eax,ebx ; eax=b\n  xor rdx,rdx\n  mov r11,4\n  idiv r11\n  test edx,edx\n  jz _set4 ; if b%4==0 set power to 4\n  mov eax,edx ; eax=b%4\n  jmp _prepow\n_set4:\n  mov eax,4\n_prepow:\n  mov ebx,eax ; ebx= (b%100)%4 (pow)\n  mov eax,r8d ; eax=a\n_pow:\n  dec ebx\n  test ebx,ebx\n  jz _exit\n  imul r8d\n  jmp _pow\n_retOne:\n  mov eax,1\n_exit:\n  xor rdx,rdx\n  mov r11,10\n  idiv r11\n  mov eax,edx\n_retz:\n  ret\n; -----> endof last_digit <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212341,"user_id":null,"body":"global last_digit\nlast_digit:\n  xor   eax,eax\n  mov   rcx,-1\n  repne scasb\n  xchg  rdi,rsi\n  mov   rcx,-1\n  repne scasb\n  xor   rcx,-3\n  je .f\n    movzx rax,byte[rdi-3]\n    lea   rax,[rax*5-'0'*5]\n    lea   rax,[rax*2]\n  .f:\n  movzx rcx,byte[rdi-2]\n  lea   rcx,[rcx+rax-'0']\n  mov   rax,1\n  jne .n\n    jrcxz .q\n  .n:\n  movzx rax,byte[rsi-2]\n  sub   rax,'0'\n  mov   r8,rax\n  mov   r9,10\n  jmp .s\n  .b:mul r8\n     cqo\n     div r9\n     mov rax,rdx\n  .s:dec rcx\n  jnle .b   \n  .q:\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212342,"user_id":null,"body":"global last_digit\n\nsection .data\nformat: db \"%d^%d\", 0xd, 0xa, 0\nformat_int: db \"%d\", 0xd, 0xa, 0\nnums: db 0, 0, 0, 0 ; 0\n      db 1, 1, 1, 1 ; 1\n      db 6, 2, 4, 8 ; 2\n      db 1, 3, 9, 7 ; 3\n      db 6, 4, 6, 4 ; 4\n      db 5, 5, 5, 5 ; 5\n      db 6, 6, 6, 6 ; 6\n      db 1, 7, 9, 3 ; 7\n      db 6, 8, 4, 2 ; 8\n      db 1, 9, 1, 9 ; 9\n\nsection .text\nextern atoi\nextern strlen\n\n; rdi = x\n; rsi = y\nlast_digit:\n    ; x^y \u2261 b (mod 10)\n    ; if x \u2261 c (mod 10) then x^y \u2261 c^y (mod 10)\n    ; thus, x^y and c^y share last digits\n    ; since we can define c \u2208 { x\u2208Z | 0 <= x <= 9}, we can manually check cases, since all numbers 0-9 \n    ; share repetitivity in their last digits\n    ; we only need to know y (mod 4) to know what digits, since all x^y (mod 10) repeat at most every 4 y\n    ; to know y (mod 4) we must know y to the hundredth's place\n    \n    push rsi ; put y on stack for now\n    \n    ; x in rdi\n    xor rax, rax\n    call strlen\n    ; length of x in rax\n    ; we only need last character, so \n    ; call stoi with &x + strlen(x) - 1\n    \n    ; x still in rdi\n    dec rdi\n    add rdi, rax\n    call atoi\n    ; last digit of x in rax\n    ; now we do the same with y, but the last 2 characters\n    \n    ; move y to rdi\n    pop rdi\n    push rax\n    xor rax, rax\n    call strlen\n    ; length of y in rax\n    ; we only need last 3 characters, so \n    ; call stoi with &y + strlen(y) - 2\n    ; if strlen(y) is less than 2, just do whole number (pretend strlen returned 2)\n    \n    push rax\n    cmp rax, 2\n    jge strlen_y_ge_2\n    mov rax, 2 ; if strlen returns number less than three, pretend it returned 3 so that the whole string will\n    ; be taken\nstrlen_y_ge_2:\n    sub rax, 2\nl1:\n    ; y still in rdi\n    add rdi, rax\n    call atoi\n    ; last 3 digits of y in rax\n    push rax\n    \n    ; STACK OVERVIEW\n    ; RSP = LAST 2 DIGITS OF Y\n    ; RSP + 8 = LEN OF Y\n    ; RSP + 16 = LAST DIGIT OF X\n    \n    ; if y == 0, return 1\n    mov rax, [rsp]\n    cmp rax, 0\n    jne y_not_0\n    \n    mov rax, [rsp + 8]\n    cmp rax, 2 ; if len(y) > 2, then y is not 0\n    jg y_not_0\n    mov rax, 1\n    jmp clean_stack_and_ret\n    \ny_not_0:\n    ; get y mod 4\n    mov rax, [rsp]\n    mov rcx, 4\n    div rcx ; remainder in rdx\n    ; swap y in RSP with y mod 4\n    mov [rsp], rdx\n    \n    ; the nums array is a matrix with each row corresponding to an x, and each column a y\n    ; accessing the row and column would be nums[4*x + y]\n    mov rax, [rsp + 16]\n    mov rcx, 4\n    mul rcx ; rax = 4x\n    add rax, [rsp]\n    xor rcx, rcx\n    mov cl, [nums + rax]\n    \n    push rcx\n    \n    pop rax\nclean_stack_and_ret:\n    add rsp, 24\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212343,"user_id":168,"body":"global last_digit\n\nsection .text\n\n; <-- EAX last_digit(ro [byte RDI] a, ro [byte RSI] b) -->\nlast_digit:\n  xor eax, eax\n  mov ecx, -1\n  repnz scasb\n  movzx edx, byte [rdi - 2]\n  sub edx, '0'                    ; edx = a[-1] (-1 = last digit)\n  mov rdi, rsi\n  repnz scasb\n  sub rdi, rsi\n  cmp edi, 3\n  jb .one_digit\n  mov al, byte [rsi + rdi - 3]\n  add eax, eax\n.one_digit:\n  add al, byte [rsi + rdi - 2]    ; eax = 2 * b[-2] + b[-1]\n  add edi, eax\n  mov ecx, 1\n  cmp edi, '0' + 2                ; if b is 0 then change edx to 1\n  cmovle edx, ecx\n  mov ecx, 4\n  and eax, 3\n  cmovnz ecx, eax                 ; ecx = eax % 4 or 4\n  mov eax, 1\n.loop:\n  imul eax, edx\n  loop .loop\n  xor edx, edx                    ; eax = edx ** ecx\n  mov ecx, 10\n  div ecx\n  mov eax, edx\n  ret\n; -----> endof last_digit <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212344,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                            Written by uniapi\n;                              July 21, 2021\n; ----------------------------------------------------------------------\nglobal last_digit\n\nsection .text\n\n%macro vstrlen 1\n    push rdi\n    push rsi\n    xchg %1, rdi\n    mov rax, -32\n    vpxor xmm0, xmm0\n%%loop:\n    add rax, 32\n    vpcmpeqb ymm1, ymm0, [rdi+rax]\n    vpmovmskb esi, ymm1\n    test esi, esi\n    je %%loop\n    bsf esi, esi\n    add rax, rsi\n    xchg %1, rdi\n    pop rsi\n    pop rdi\n%endmacro\n\n%macro idig 3\n    movzx %1, byte [%2+%3-1]\n    sub %1, '0'\n%endmacro\n\n%macro ipow 2\n    mov eax, %1\n    jmp %%exit\n%%loop:\n    imul eax, %1\n%%exit:\n    dec %2\n    jne %%loop\n%endmacro\n\n; <-- EAX last_digit(ro [byte RDI] a, ro [byte RSI] b) -->\nlast_digit:\n    vstrlen rsi                 ; loading <len> of <b> into RAX as <n>\n    idig edx, rsi, rax          ; loading the last digit <b[n-1]> into EDX as <y>\n    mov rcx, rax                ; copying <n> to RCX\n    add eax, edx                ; adding <n> and <y>\n    cmp eax, 1                  ; whether <n> is equal to one\n    je .exit                    ; then jumping to exit\n    vstrlen rdi                 ; loading <len> of <a> into RAX as <n1>\n    idig eax, rdi, rax          ; loading the last digit of <a[n1-1]> into EAX as <x>\n    test eax, eax               ; whether <x> is zero\n    je .exit                    ; then jumping to exit\n    cmp eax, 1                  ; whether <x> is one\n    je .exit                    ; then jumping to exit\n    cmp eax, 5                  ; whether <x> is five\n    je .exit                    ; jumping to exit\n    cmp eax, 6                  ; whether <x> is six\n    je .exit                    ; jumping to exit\n    mov edi, eax                ; copying <x> to EDI\n    cmp rcx, 1                  ; whether <n> is above one\n    jbe .y                      ; otherwise, jumping to .y\n    dec rcx                     ; decrementing <n>\n    idig esi, rsi, rcx          ; loading the prelast digit <b[n-2]> into RSI as <y0>\n    imul esi, 10                ; shifting <y0> one digit left\n    add edx, esi                ; adding <y0> to <y>\n.y:\n    mov esi, 4                  ; copying four to ESI if handling 2, 3, 7 or 8\n    mov eax, edx                ; copying <y> to EAX\n    shr eax, 2                  ; dividing <y> by four\n    shl eax, 2                  ; getting <y> back\n    sub edx, eax                ; getting the reminder\n    cmovne esi, edx             ; otherwise, copying four to ESI\n    ipow edi, esi               ; getting x ^ y\n    xor edx, edx                ; resetting EDX before division\n    mov ecx, 10                 ; setting the divisor to get the leftmost digit\n    idiv ecx                    ; getting the result of y % 10 in EDX\n    mov eax, edx                ; setting the result to EAX\n.exit:\n    ret\n; -----> endof last_digit <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5513795bd3fafb56c200049e":[{"id":212345,"user_id":null,"body":"global cntbyx\ncntbyx:\n  mov rcx,rdi\n  mov rax,rsi\n  .b:stosd\n     add rax,rsi \n     dec rdx\n  jnz .b\n  mov rax,rcx\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212346,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n)\ncntbyx:\n  mov rax,rdi ;set rax to buffer ptr\n  mov ecx,esi ;initial val\n.loop:\n  mov DWORD [rdi],ecx\n  add ecx,esi\n  add rdi,4 ;next item\n  dec rdx\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212347,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n    xor rcx, rcx\n    xor rax, rax\n    mov eax, esi\n    mov r8, 0\nl:\n    cmp r8, rdx\n    je return\n    mov [rdi + rcx], rax\n    add rcx, 4\n    add r8, 1\n    add eax, esi\n    jmp l\nreturn:\n    mov rax, rdi\n    ret\n; -----> endof cntbyx <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212348,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\ncntbyx:\n  mov rax, rdi\n  lea rdi, [rax + rdx * 4]\n  mov rdx, rax\n  xor ecx, ecx\n  .loop:\n    add ecx, esi \n    mov [rdx], ecx\n    add rdx, 4\n    cmp rdx, rdi\n    jl .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212349,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n    mov rax, rdi\n    lea rdi, [rax + rdx * 4]\n    mov rdx, rax\n    xor r9d, r9d\n  .loop:\n    add r9d, esi\n    mov [rdx], r9d\n    add rdx, 4\n    cmp rdx, rdi\n    jne .loop\n    ret\n; -----> endof cntbyx <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212350,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n  mov rax, rdi\n  xor ecx, ecx\n  mov edi, esi\n.loop:\n  cmp rdx, rcx\n  je .done\n  mov [rax + 4*rcx], edi\n  inc rcx\n  add edi, esi\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212351,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n    mov   rax, rdi; copying <outp> to RAX as the result\n    mov   ecx, esi\n    .loop:\n    mov   dword [rdi], ecx\n    add   ecx, esi\n    add   rdi, 4\n    dec   rdx\n    jnz   .loop\n    ret\n; -----> endof cntbyx <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212352,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n    mov rax, rdi           ; copying <outp> to RAX as the result\n    mov ecx,esi\nlp:\n    \n    mov [rdi],ecx\n    add rdi,4\n    add ecx,esi\n    sub rdx,1\n    jnz lp    \n    \n    ret\n; -----> endof cntbyx <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212353,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n    mov rax, rdi            ; copying <outp> to RAX as the result\n    mov ecx, esi\n.L1:\n    mov [rdi], esi\n    add rdi, 4\n    add esi, ecx\n    dec rdx\n    jnz .L1\n    ret\n; -----> endof cntbyx <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212354,"user_id":null,"body":"global cntbyx\n\nsection .text\n\n; <-- [dword RAX] cntbyx([dword RDI] outp, ESI x, RDX n) -->\n;   Do not allocate memory!\n;   Fill the buffer passed in RDI with multiples of x\n;   and return the address (pointer) to this buffer.\ncntbyx:\n    mov r8,0\n    mov [rdi],esi\n    mov eax,esi\n    \n    loop:\n    dec rdx\n    inc r8\n    cmp rdx,0\n    je end\n    add eax,esi\n    mov [rdi + 4 * r8],eax\n    jmp loop\n    \n    end:\n    mov rax, rdi            ; copying <outp> to RAX as the result\n    ret\n; -----> endof cntbyx <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55192f4ecd82ff826900089e":[{"id":212355,"user_id":527,"body":"section .text\nglobal divide\n; bool divide(unsigned weight)\ndivide:\n                rorx    eax, edi, 1\n                cmp     eax, 1\n                setg    al\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212356,"user_id":null,"body":"section .text\nglobal divide\ndivide:\n     xor rax,rax\n     cmp rdi,2\n     jle @e\n     ror rdi,1\n     setno al\n@e:  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212357,"user_id":null,"body":"section .text\nglobal divide\n\n; bool divide(unsigned weight)\n; edi := weight\ndivide:         \n  xor eax, eax\n  cmp edi, 3\n  jle .exit\n  and dil, 1\n  setz al\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212358,"user_id":null,"body":"section .text    ;           edi       rax\nglobal divide   ; divide :: UInt() -> Bool\n\ndivide:                    \n  xor eax, eax\n  cmp edi, 4\n  jb .returnFalse    ;; | arg < 4 = false \n  call isEven       ;; | arg & 1 == 0 = true\n  cmp eax, 1       ;; | otherwise = false\n  jz .returnTrue\n  \n  .returnFalse:\n    ret\n  .returnTrue:\n    ret\n                    ;edi     eax\nisEven:;   isEven :: Int -> Bool\n   mov eax, 1\n   and edi, 1\n   sub eax, edi\n   ret\n    \n    \n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212359,"user_id":50,"body":"section .text\nglobal divide\ndivide:         ; bool divide(unsigned weight)\n                ; edi := weight\n  xor eax, eax\n  cmp edi,2\n  je exit\n  xor ebx, ebx\n  mov ebx,1\n  and ebx,edi\n  cmp ebx,1\n  je exit\n  mov eax, 1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212360,"user_id":null,"body":"section .text\nglobal divide\ndivide:         ; bool divide(unsigned weight)\n                ; edi := weight\n  mov eax, 1\n  and eax, edi\n  jnz false\n  cmp edi, 2\n  jne true\n  false:\n    xor eax, eax\n    ret\n  true:\n    mov eax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212361,"user_id":null,"body":"section .text\nglobal divide\ndivide:         ; bool divide(unsigned weight)\n                ; edi := weight\n  cmp eax, 2\n  je @f\n  and eax,1\n  cmp eax,1\n  je @f\n  jmp @t\n\n@t:\n  mov eax, 1\n  ret\n@f:\n  mov eax, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212362,"user_id":null,"body":"section .text\nglobal divide\ndivide:\n\n  cmp rdi, 2\n  je  false\n  mov rax, rdi\n  mov rdx, 0\n  mov rcx, 2\n  div rcx\n  cmp rdx, 1\n  jne true\n  \nfalse:\n  mov rax, 0\n  ret\n\ntrue:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212363,"user_id":null,"body":"global divide\ndivide:\n  bsr   rax,rdi\n  cmp   rax,1\n  seta  al\n  xor   dil,1\n  and   al,dil\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212364,"user_id":null,"body":"section     .text\nglobal      divide\n\ndivide:\n    xor       eax, eax\n    xor       edx, edx\n    xor       ecx, ecx\n\n    mov       eax, edi\n    cmp       eax, 2\n    je        _false\n    mov       ecx, 2\n    div       ecx\n    \n    cmp       edx, 0\n    jz        _true\n    jmp       _false\n\n_false:\n    mov       eax, 0\n    ret\n\n_true:\n    mov       eax, 1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"551b4501ac0447318f0009cd":[{"id":212365,"user_id":null,"body":"SECTION .data\ntrue db \"true\", 0\nfalse db \"false\", 0\n\nSECTION .text\nglobal boolean_to_string\n\nboolean_to_string:\n  mov rax, false\n  test rdi, rdi\n  jz .q\n  mov rax, true\n.q:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212366,"user_id":null,"body":"section .rodata\ntrue: db \"true\", 0\nfalse: db \"false\", 0\n\nsection .text\nglobal boolean_to_string\nboolean_to_string:\n  mov rax, false\n  cmp rdi, 0\n  je .end\n  mov rax, true\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212367,"user_id":null,"body":"SECTION .text\nglobal boolean_to_string\n\nboolean_to_string:\n  lea rax,[.bool+rdi*8]\n  ret\n  \n.bool db 'false',0,0,0,'true',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212368,"user_id":null,"body":"SECTION .text\nglobal boolean_to_string\nboolean_to_string:\n    mov rax, rs\n    cmp rdi, 0\n    jne end\n    add rax, 5   \nend:ret\nrs: db \"true\", 0, \"false\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212369,"user_id":null,"body":"SECTION .text\nglobal boolean_to_string\n\nboolean_to_string:\n  cmp    edi, 1\n  je     true_bool\n  cmp    edi, 0\n  je     false_bool\n  \ntrue_bool:\n  mov    rax, true\n  ret\n\nfalse_bool:\n  mov    rax, false\n  ret\n  \nSECTION .data\n  false   DW   'false'\n  true    DW   'true'\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212370,"user_id":881,"body":"SECTION .data\nstr_true: db \"true\", 0h\nstr_false: db \"false\", 0h\n\nSECTION .text\nglobal boolean_to_string\n\n; Returns a string representation of a boolean\n; NOTE: Please return a pointer to a string initialized by psuedo-opcode \"db\" or similar\n; arg0         = (bool)         The boolean.\n; return value = (const char *) The string representation of the boolean.\nboolean_to_string:\n  test dil, 1\n  jz .false\n  mov rax, str_true\n  ret\n.false\n  mov rax, str_false\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212371,"user_id":77,"body":"SECTION .text\nglobal boolean_to_string\n\nrepr:  db \"false\", 0, 0, 0, \"true\", 0\n\nboolean_to_string:\n  lea rax, [repr+rdi*8]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212372,"user_id":null,"body":"SECTION .text\nglobal boolean_to_string\n\n; Returns a string representation of a boolean\n; NOTE: Please return a pointer to a string initialized by psuedo-opcode \"db\" or similar\n; arg0         = (bool)         The boolean.\n; return value = (const char *) The string representation of the boolean.\nboolean_to_string:\n  test edi, edi\n  mov rax, return_true\n  mov rcx, return_false\n  cmove rax, rcx\n  ret\n  \n SECTION .data\n \n return_true: db \"true\", 0\n return_false: db \"false\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212373,"user_id":null,"body":"SECTION .data\ntrue  db  'true',0h\nfalse db  'false',0h\n\nSECTION .text\nglobal boolean_to_string\n; Returns a string representation of a boolean\n; NOTE: Please return a pointer to a string initialized by pseudo-opcode \"db\" or similar\n; arg0         = (bool)         The boolean.\n; return value = (const char *) The string representation of the boolean.\nboolean_to_string:\n  mov eax, edi\n  cmp eax, 0\n  jz zero\n  \n  mov eax, true\n  jmp end\nzero:\n  mov eax, false\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212374,"user_id":null,"body":"SECTION .text\nglobal boolean_to_string\n\n; Returns a string representation of a boolean\n; NOTE: Please return a pointer to a string initialized by pseudo-opcode \"db\" or similar\n; arg0         = (bool)         The boolean.\n; return value = (const char *) The string representation of the boolean.\nboolean_to_string:\n  lea   rax, [rdi*8+.false]\n  ret\n.false:\n  dq  'false'\n  dq  'true'","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"551dd1f424b7a4cdae0001f0":[{"id":212375,"user_id":527,"body":"section .text\nglobal who_is_next\n\n; const char *who_is_next(long long n, size_t length, const char *const names[length])\nwho_is_next:\n                mov     r8, rdx\n                dec     rdi\n                mov     rax, rdi\n                xor     edx, edx\n                div     rsi\n                inc     rax\n                bsr     rcx, rax\n                xor     eax, eax\n                bts     rax, rcx\n                dec     rax\n                imul    rax, rsi\n                sub     rdi, rax\n                shr     rdi, cl\n                mov     rax, [r8 + rdi * 8]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212376,"user_id":null,"body":"section .text\nglobal who_is_next\n\n;                          QWORD RDI    QWORD RSI       QWORD RDX\n; const char *who_is_next(long long n, size_t length, const char *const names[length])\nwho_is_next:\n    dec rdi                   ; one-based indexing!\n.step:    \n    sub rdi, rsi              \n    jb .lookup                \n    shr rdi, 1\n    jmp .step\n.lookup:\n    add rdi, rsi              \n    mov rax, [rdx + rdi * 8]\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212377,"user_id":77,"body":"section .text\nglobal who_is_next\n\n; const char *who_is_next(long long n, size_t length, const char *const names[length])\nwho_is_next:\n    dec rdi\n    jmp .start\n.loop:    \n    sub rdi, rsi\n    shr rdi, 1\n.start:\n    cmp rdi, rsi\n    jge .loop\n    mov rax, [rdx+rdi*8]\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212378,"user_id":null,"body":"section .text\nglobal who_is_next\n\n; const char *who_is_next(long long n, size_t length, const char *const names[length])\nwho_is_next:\n    push rcx\n    mov rcx, 1 ; i\n    push rdx\n    dec rdi ; --n\n.loop:\n    mov rax, rsi\n    mul rcx ; rdx:rax = length * i\n    cmp rdi, rax\n    jna .return   ; if (!(n > length * i)) goto .return\n    sub rdi, rax  ; else n -= length * i\n    shl rcx, 1 ; i <<= 1\n    jmp .loop\n.return:\n    xor rdx, rdx\n    mov rax, rdi\n    div rcx ; \u043e\u0441\u0442\u0430\u0442\u043e\u043a rdx : \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 rax = n(rdx:rax) \/ i\n    xor rdx, rdx\n    div rsi ; \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442(rax) \/ length\n    pop rax ; names\n    mov rax, qword [rax + rdx * 8]\n    pop rcx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212379,"user_id":null,"body":"section .text\nglobal who_is_next\nwho_is_next:\n   cmp rdi,rsi\n   jl .f\n     mov rax,1\n     .b:sub rdi,rsi\n        add rsi,rsi\n        add rax,rax        \n        cmp rdi,rsi\n     jnl .b\n     lea rdi,[rdi+rax-1]\n     bsf rcx,rax\n     shr rdi,cl\n   .f:\n   mov rax,[rdx+rdi*8-8]\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212380,"user_id":168,"body":"section .text\nglobal who_is_next\n\n; const char *who_is_next(long long n, size_t length, const char *const names[length])\nwho_is_next:\n  dec rdi\n  jmp .loop_cond\n.loop:\n  shr rdi, 1\n.loop_cond:\n  sub rdi, rsi\n  jae .loop\n  add rdi, rsi\n  mov rax, [rdx + 8 * rdi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212381,"user_id":null,"body":"section .text\nglobal who_is_next\n\nwho_is_next:\n    dec rdi\n    jmp .condition\n.while:\n    sub rdi, rsi\n    shr rdi, 1\n.condition:\n    cmp rdi, rsi\n    jge .while\n    mov rax, [rdx + 8 * rdi]\n    ret    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5526fc09a1bbd946250002dc":[{"id":212382,"user_id":527,"body":"global find_outlier\nsection .stuff exec write\nfind_outlier:\n                mov     edx, 100h\n                bextr   eax, [rdi], edx\n                bextr   ecx, [rdi + 4], edx\n                bextr   edx, [rdi + 8], edx\n                cmp     eax, ecx\n                cmovne  eax, edx\n                or      al, 074h\n                mov     byte [.cond], al        ; dark magic\n.loop:          test    byte [rdi], 1\n                lea     rdi, [rdi + 4]\n.cond:          jmp     .loop\n                mov     eax, [rdi - 4]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212383,"user_id":527,"body":"global find_outlier\n\nsection .text\n\n; int find_outlier(const int *v, unsigned len)\nfind_outlier:\n                mov     edx, [rdi]\n                mov     ecx, [rdi + 4]\n                xor     ecx, edx\n                test    ecx, 1\n                jz      .first_eq_done\n.first_eq:      mov     edx, [rdi + 8]\n.first_eq_done: and     edx, 1\n.loop:          mov     eax, [rdi]\n                and     eax, 1\n                cmp     eax, edx\n                jne     .done\n                add     rdi, 4\n                dec     esi\n                jnz     .loop\n.done:          mov     eax, [rdi]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212384,"user_id":527,"body":"global find_outlier\n\nsection .text\n\n; int find_outlier(const int *v, unsigned len)\nfind_outlier:\n                mov     r8d, 100h\n                bextr   edx, [rdi], r8d\n                bextr   ecx, [rdi + 4], r8d\n                cmp     ecx, edx\n                je      .loop\n.first_eq:      bextr   edx, [rdi + 8], r8d\n.loop:          bextr   eax, [rdi], r8d\n                cmp     eax, edx\n                jne     .done\n                add     rdi, 4\n                dec     esi\n                jnz     .loop\n.done:          mov     eax, [rdi]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212385,"user_id":null,"body":"global find_outlier\n\nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n  mov edx, [rdi]\n  mov eax, [rdi+4]\n  mov r8d, [rdi+8]\n  mov ecx, eax\n  mov esi, edx\n  xor ecx, r8d\n  xor esi, eax\n  and ecx, 1\n  and sil, 1\n  je .nft\n  test ecx, ecx\n  cmove eax, edx\n  ret\n.nft:\n  test ecx, ecx\n  mov esi, 3\n  je .loop\n  xor edx, r8d\n  and dl, 1\n  cmovne eax, r8d\n  ret\n.loop:\n  mov eax, [rdi+rsi*4]\n  mov ecx, edx\n  inc rsi\n  xor ecx, eax\n  and cl, 1\n  je .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212386,"user_id":null,"body":"global find_outlier\n\nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n  xor ecx, ecx\n  xor edx, edx\n  xor r8d, r8d\n  \n.loop:\n  mov eax, [rdi]\n  add rdi, 4\n  test eax, 1\n  jz .even\n  \n  mov ecx, eax\n  inc r8d\n  jmp .next\n\n.even:\n  mov edx, eax\n\n.next:\n  dec esi\n  jnz .loop\n  \n  mov eax, ecx\n  cmp r8d, 1\n  cmovne eax, edx\n  ret\n; ---------> end of find_outl <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212387,"user_id":173,"body":"global find_outlier\n\nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n    push rdi\n    ; check first 3 values to determine is v is odd or even\n    mov r12, 0\n    mov r13, 0\n    mov cl, 0\nl_loop:\n    mov edx, dword [rdi]        \n    and edx, 1\n    cmp edx, 1\n    je l_odd\nl_even:\n    inc r12\n    jmp l_c\nl_odd:\n    inc r13\nl_c:\n    add rdi, 4\n    inc cl\n    cmp cl, 3\n    jb l_loop\n    pop rdi\n    \n    mov ecx, 0\n    mov edx, 1\n    cmp r12, r13\n    cmova ecx, edx\n    mov eax, ecx \n\n    mov rcx, 0\nl_bloop:\n    mov edx, dword [rdi]\n    and edx, 1\n    cmp edx, eax\n    je l_done\n    add rdi, 4\n    inc rcx\n    cmp rcx, rsi\n    jl l_bloop\n    \n    mov eax, -1\n    ret\nl_done:\n    mov eax, dword [rdi]\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212388,"user_id":null,"body":"global find_outlier\n\nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n    xor eax, eax        ; EAX <- the result\nloop:\n    test rsi, rsi\n    jz return\n    mov r9d, dword [rdi + (rsi - 1) * 4]\n    test r9d, 1\n    setz ah\n    cmovz rcx, r9\n    cmovnz rdx, r9\n    add al, ah\n    dec rsi\n    jmp loop\n\nreturn:\n    cmp al, 2\n    cmovge rax, rdx\n    cmovl rax, rcx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212389,"user_id":null,"body":"global find_outlier\n\nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n    xor eax, eax        ; EAX <- the result\n    xor rdx, rdx\n    xor rcx, rcx\nloop:\n    test rsi, rsi\n    jz return\n    mov r9d, dword [rdi + (rsi - 1) * 4]\n    test r9d, 1\n    setz ah\n    cmovz rcx, r9\n    cmovnz rdx, r9\n    add al, ah\n    dec rsi\n    jmp loop\n\nreturn:\n    cmp al, 2\n    cmovge rax, rdx\n    cmovl rax, rcx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212390,"user_id":null,"body":"global find_outlier\n\nsection .data\n    retvals dq 0, 0\n    \nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n    push rbx\n    push rbp\n    mov rbp, rsp\n    sub rsp, 32\n\n    xor dl, dl  ; odd\/even counter\n    xor r8, r8\n\n.nextnum:\n    mov rbx, 1\n    mov eax, dword [rdi + r8 * 4]\n    and ebx, eax\n    add dl, bl\n    mov dword [retvals + rbx * 4], eax\n    inc r8\n    cmp r8, 3\n    jne .nextnum\n\n    cmp dl, 1\n    jg  .even\n    cmp dl, 0\n    jz  .findodd\n    mov eax, dword [retvals + 4]\n\n.exit:\n    add rsp, 32\n    pop rbp\n    pop rbx\n    ret\n\n.findodd:\n    cmp r8, rsi\n    jg  .exit\n    mov ebx, 1\n    mov eax, dword [rdi + r8 * 4]\n    and ebx, eax\n    cmp bl, 1\n    je  .exit\n    inc r8\n    jmp .findodd\n\n.even:\n    cmp dl, 3\n    je  .findeven\n    mov eax, dword [retvals]\n    jmp .exit\n\n.findeven:\n    cmp r8, rsi\n    jg  .exit\n    mov ebx, 1\n    mov eax, dword [rdi + r8 * 4]\n    and ebx, eax\n    cmp bl, 0\n    jz  .exit\n    inc r8\n    jmp .findeven\n\n; ---------> end of find_outl <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212391,"user_id":50,"body":"global find_outlier\n\nsection .text\n\n; <----- int find_outlier(const int *v, unsigned len) ----->\nfind_outlier:\n    xor rax, rax        ; EAX <- the result\n    xor r8,r8 ; will hold last even seen\n    xor r9,r9 ; will hold last odd seen\n    xor r10,r10 ; will hold number of evens seen\n    xor r11,r11 ; will hold number of odds seen\n    xor r12,r12 ; will count iterations\n_loop:\n  cmp r12,rsi\n  je _exit ; exit if we parsed all the array\n  mov eax,[rdi+4*r12] ; current value to eax\n  inc r12\n  and eax,1 ; test parity\n  cmp eax,1 ; if odd\n  je _foundOdd\n  jmp _foundEven\n_foundOdd:\n  inc r11\n  mov r9d,[rdi+4*(r12-1)]\n  jmp _loop\n _foundEven:\n  inc r10\n  mov r8d,[rdi+4*(r12-1)]\n  jmp _loop\n_exit:\n  cmp r10,1\n  je _retEven\n  mov eax,r9d\n  ret\n_retEven:\n  mov eax,r8d\n  ret\n; ---------> end of find_outl <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5539fecef69c483c5a000015":[{"id":212392,"user_id":null,"body":"global backwards_prime\nextern malloc\n\nsection .bss\ndigits resd 18\n\nsection .text\nbackwards_prime:\n      push r13\n      push r12\n      mov r12,rdx   ; r12 holding address of size_t reverse-primes counter\n      push rdi      ; rdi lower limit of primes to check\n      push rsi      ; rsi upper limit of primes to check\n      mov rdi,1600  ; Enough for 400 primes...\n      call malloc\n      mov r13,rax  ; r13 holding array of reverse-primes\n      pop rsi\n      pop rdi\n      xor r11,r11  ; r11 holder number of reverse-primes\n      dec rdi\n@s:   inc rdi      ; @s  - main loop\n      cmp rdi,rsi\n      jg @l4\n      call @is_prime\n      test rax,rax\n      jz @s\n\n      mov ecx,10    ; Ecx holds base 10\n      mov rax,rdi\n      lea r8,[digits]\n      xor r10,r10    ; r10 holds current digit number when reassembling\n      xor r9,r9     ; r9 holds number of digits, and current digit number when disassembling\n      \n@l1:  test eax,eax\n      jz @l2\n      xor edx,edx \n      div ecx\n      mov [r8 + r9 * 4],edx\n      inc r9\n      jmp @l1\n      \n@l2:  add eax,[r8 + r10 * 4] ; Re-assemble number with digits in reverse order\n      inc r10\n      cmp r10,r9\n      je @l3\n      imul eax,ecx\n      jmp @l2\n   \n@l3:  cmp rax, rdi  ; Check for palindrome\n      je @s\n      push rdi\n      mov rdi,rax\n      call @is_prime\n      pop rdi\n      test rax,rax\n      jz @s       ; Not a prime\n      mov [r13 + r11 * 4], rdi ; We actually got a reverse - prime, store it and update counter\n      inc r11\n      jmp @s\n      \n@l4:  mov rax,r13\n      mov [r12],r11\n      pop r12\n      pop r13\n      ret\n\n@is_prime:    ; Mangling rax, rcx, rdx, r8\n    xor rax,rax\n    cmp edi,2\n    je @prime_true\n    jg @start_primecheck\n    ret\n    \n@start_primecheck:\n    mov rcx,2\n@prime_loop: \n    mov r8,rcx\n    imul r8,r8\n    cmp rdi,r8\n    jl @prime_true\n    mov rax,rdi\n    xor rdx,rdx\n    div rcx\n    inc rcx\n    test rdx,rdx\n    jnz @prime_loop\n    xor rax,rax\n    ret\n@prime_true:\n    mov rax,1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212393,"user_id":null,"body":"global backwards_prime\nextern malloc\n\nsection .data\n    buffer: dq 0\n\nsection .text\n\nis_prime:\n    cmp edi, 3\n    jbe .prime_ret\n\n    mov ecx, 1\n  .div_loop:\n    inc ecx\n    xor edx, edx\n    mov eax, edi\n    div ecx\n    test edx, edx\n    jnz .not_divisible\n    \n    mov al, 0\n    ret\n    \n  .not_divisible:\n    cmp eax, ecx\n    jnb .div_loop\n\n  .prime_ret:\n    mov al, 1\n    ret\n\nrevert_num:\n    mov eax, edi\n    mov edi, 10\n    xor ecx, ecx\n\n  .revert_loop:\n    xor edx, edx\n    div edi\n    mov esi, eax\n    add ecx, edx\n\n    test eax, eax\n    jz .leave\n\n    mov eax, ecx\n    mul edi\n    mov ecx, eax\n    mov eax, esi\n\n    jmp .revert_loop\n\n  .leave:\n    mov eax, ecx\n\n    ret\n\nbackwards_prime:\n    push r12\n    push r13\n    push r14\n\n    mov r12d, edi\n    mov r13d, esi\n    mov r14, rdx\n\n    mov qword [r14], 0\n    mov rdi, 1024 * 4\n    call malloc\n    mov qword [buffer], rax\n\n  .numbers_loop:\n    mov edi, r12d\n    call is_prime\n    test al, al\n    jz .skip\n    \n    mov edi, r12d\n    call revert_num\n    cmp r12d, eax\n    jz .skip\n    mov edi, eax\n    call is_prime\n    test al, al\n    jz .skip\n    \n    mov rax, qword [buffer]\n    mov rdi, qword [r14]\n    mov dword [rax + rdi * 4], r12d\n    inc qword [r14]\n\n  .skip:\n    inc r12d\n    cmp r12d, r13d\n    jng .numbers_loop\n\n    pop r14\n    pop r13\n    pop r12\n\n    mov rax, qword [buffer]\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212394,"user_id":743,"body":"global backwards_prime\nextern malloc\n\nsection .text\n\n; rax                  edi                  esi                        rdx\n; int* backwards_prime(int start_inclusive, int end_inclusive, size_t* size);\nbackwards_prime:\n  push r12\n  push r13\n  push r14\n  push rdx\n  mov r12d, edi\n  mov r13d, esi\n  sub esi, edi\n  lea edi, [rsi * 4 + 4]\n  call malloc\n  push rax\n  mov r14, rax\n  jmp .loop_\n.loop:\n  add r12d, 1\n  cmp r12d, r13d\n  ja .endl\n.loop_:\n  mov edi, r12d\n  call is_prime\n  jrcxz .loop\n  mov edi, r12d\n  call reverse\n  cmp eax, r12d\n  je .loop\n  mov edi, eax\n  call is_prime\n  jrcxz .loop\n  mov [r14], r12d\n  add r12d, 1\n  add r14d, 4\n  cmp r12d, r13d\n  jna .loop_\n.endl:\n  pop rax\n  sub r14d, eax\n  shr r14d, 2\n  pop rdx\n  mov [rdx], r14\n  pop r14\n  pop r13\n  pop r12\n  ret\n\n; ? = true, 0 = false\n; ecx               edi\n; bool is_prime(u32 n);\nis_prime:\n  mov ecx, 2\n  cmp edi, 2\n  jb .false\n.loop:\n  xor edx, edx\n  mov eax, edi\n  div ecx\n  cmp ecx, eax\n  ja .true\n  test edx, edx\n  jz .false\n.loop_:\n  xor edx, edx\n  add ecx, 1\n  mov eax, edi\n  div ecx\n  cmp ecx, eax\n  ja .true\n  test edx, edx\n  jnz .loop_\n.false:\n  xor ecx, ecx\n.true:\n  ret\n\n; eax             edi\n; u32 reverse(u32 n);\nreverse:\n  mov r8d, 0xcccccccd\n  xor eax, eax\n  mov edx, edi\n.loop:\n  imul rdx, r8\n  shr rdx, 35\n  lea ecx, [rdx + rdx]\n  lea ecx, [rcx + rcx * 4]\n  sub edi, ecx\n  lea eax, [rax + rax * 4]\n  lea eax, [rdi + rax * 2]\n  mov edi, edx\n  test edx, edx\n  jnz .loop\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212395,"user_id":743,"body":"global backwards_prime\nextern malloc\n\nsection .rodata\n\nInv10 dq 0xcccccccd\n\nsection .text\n\n; rax                  edi                  esi                        rdx\n; int* backwards_prime(int start_inclusive, int end_inclusive, size_t* size);\nbackwards_prime:\n  push r12\n  push r13\n  push r14\n  push rdx\n  mov r12d, edi\n  mov r13d, esi\n  sub esi, edi\n  lea edi, [rsi * 4 + 4]\n  call malloc\n  push rax\n  mov r14, rax\n  jmp .loop_\n.loop:\n  add r12d, 1\n  cmp r12d, r13d\n  ja .endl\n.loop_:\n  mov edi, r12d\n  call is_prime\n  jrcxz .loop\n  mov edi, r12d\n  call reverse\n  cmp eax, r12d\n  je .loop\n  mov edi, eax\n  call is_prime\n  jrcxz .loop\n  mov [r14], r12d\n  add r12d, 1\n  add r14d, 4\n  cmp r12d, r13d\n  jna .loop_\n.endl:\n  pop rax\n  sub r14d, eax\n  shr r14d, 2\n  pop rdx\n  mov [rdx], r14\n  pop r14\n  pop r13\n  pop r12\n  ret\n\n; ? = true, 0 = false\n; ecx               edi\n; bool is_prime(u32 n);\nis_prime:\n  mov ecx, 2\n  cmp edi, 2\n  jb .false\n.loop:\n  xor edx, edx\n  mov eax, edi\n  div ecx\n  cmp ecx, eax\n  ja .true\n  test edx, edx\n  jz .false\n.loop_:\n  xor edx, edx\n  add ecx, 1\n  mov eax, edi\n  div ecx\n  cmp ecx, eax\n  ja .true\n  test edx, edx\n  jnz .loop_\n.false:\n  xor ecx, ecx\n.true:\n  ret\n\n; eax             edi\n; u32 reverse(u32 n);\nreverse:\n  xor eax, eax\n  mov edx, edi\n.loop:\n  imul rdx, [Inv10]\n  shr rdx, 35\n  lea ecx, [rdx + rdx]\n  lea ecx, [rcx + rcx * 4]\n  sub edi, ecx\n  lea eax, [rax + rax * 4]\n  lea eax, [rdi + rax * 2]\n  mov edi, edx\n  test edx, edx\n  jnz .loop\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212396,"user_id":168,"body":"extern malloc\nglobal backwards_prime\n; Function signature:\n; int *backwards_prime(int start_inclusive, int end_inclusive, size_t *size)\n; Please:\n; 1) Set the size of your returned array (in terms of number of items NOT bytes) by\n; writing to the variable under the pointer `size`\n; 2) Allocate memory using malloc() and friends - your returned array will be free()'d\nbackwards_prime:\n  push rbx ; p \n  push r12 ; end\n  push r13 ; size ptr\n  push r14 ; unused\n  push r15 ; n\n  mov ebx, edi\n  or ebx, 1\n  mov r12d, esi\n  mov r13, rdx\n  xor r15, r15\n  jmp .loop_cond\n.loop:\n  mov edi, ebx\n  call is_odd_prime\n  test al, al\n  jz .continue\n  mov edi, ebx\n  call reverse\n  cmp eax, ebx\n  jz .continue\n  mov edi, eax\n  call is_odd_prime\n  test al, al\n  jz .continue\n  push rbx\n  inc r15\n.continue:\n  add ebx, 2\n.loop_cond:\n  cmp ebx, r12d\n  jle .loop\n.loop_end:\n  mov qword [r13], r15\n  cmp r15, 0\n  je .end\n  lea edi, [r15 * 4]\n  call malloc\n.pop:\n  pop rdx\n  dec r15\n  mov dword [rax + r15 * 4], edx\n  jnz .pop\n.end:\n  pop r15\n  pop r14\n  pop r13\n  pop r12\n  pop rbx\n  ret\n\nreverse:\n  mov esi, 10\n  mov eax, edi\n  xor ecx, ecx\n.loop:\n  xor edx, edx\n  div esi\n  imul ecx, esi\n  add ecx, edx\n  test eax, eax\n  jnz .loop\n  mov eax, ecx\n  ret\n  \nis_odd_prime:\n  mov eax, edi\n  cmp eax, 2\n  jle .not_prime\n  test eax, 1\n  jz .not_prime\n  mov ecx, 3\n  mov esi, 9\n  jmp .loop_cond\n.loop:\n  xor edx, edx\n  mov eax, edi\n  div ecx\n  test edx, edx\n  jz .not_prime\n  lea esi, [esi + 4 * ecx + 4]\n  add ecx, 2\n.loop_cond:\n  cmp esi, edi\n  jle .loop\n  mov eax, 1\n  ret\n.not_prime:\n  xor eax, eax\n  ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212397,"user_id":17,"body":"global backwards_prime\n; Function signature:\n; int *backwards_prime(int start_inclusive, int end_inclusive, size_t *size)\n; Please:\n; 1) Set the size of your returned array (in terms of number of items NOT bytes) by\n; writing to the variable under the pointer `size`\n; 2) Allocate memory using malloc() and friends - your returned array will be free()'d\nextern calloc, realloc\nbackwards_prime:\n  push rdi\n  push rsi\n  push rdx\n  sub esi, edi\n  inc esi\n  xor rdi, rdi\n  mov edi, esi\n  mov rsi, 4\n  call calloc\n  pop rdx\n  pop rsi\n  pop rdi\n  mov qword [rdx], 0\n.loop:\n  cmp edi, esi\n  jg .end\n  push rax\n  push rdi\n  push rsi\n  push rdx\n  call is_prime\n  mov r8b, al\n  pop rdx\n  pop rsi\n  pop rdi\n  pop rax\n  cmp r8b, 1\n  jne .update\n  push rax\n  push rdi\n  push rsi\n  push rdx\n  call reverse_digits\n  mov r8d, eax\n  pop rdx\n  pop rsi\n  pop rdi\n  pop rax\n  cmp edi, r8d\n  je .update\n  push rax\n  push rdi\n  push rsi\n  push rdx\n  mov edi, r8d\n  call is_prime\n  mov r8b, al\n  pop rdx\n  pop rsi\n  pop rdi\n  pop rax\n  cmp r8b, 1\n  jne .update\n  mov r8, qword [rdx]\n  mov dword [rax + r8 * 4], edi\n  inc qword [rdx]\n.update:\n  inc edi\n  jmp .loop\n.end:\n  mov rdi, rax\n  mov rsi, qword [rdx]\n  imul rsi, 4\n  call realloc\n  ret\n\nis_prime:\n  cmp edi, 2\n  jl .false\n  je .true\n  mov esi, edi\n  and esi, 1\n  jz .false\n  cvtsi2sd xmm0, edi\n  sqrtsd xmm0, xmm0\n  cvtsd2si esi, xmm0\n  mov ecx, 3\n.loop:\n  cmp ecx, esi\n  jg .true\n  xor rdx, rdx\n  xor rax, rax\n  mov eax, edi\n  idiv ecx\n  cmp edx, 0\n  je .false\n  add ecx, 2\n  jmp .loop\n.true:\n  mov al, 1\n  ret\n.false:\n  xor al, al\n  ret\n\nreverse_digits:\n  xor rax, rax\n.loop:\n  cmp edi, 0\n  jle .end\n  mov r8d, 10\n  imul r8d\n  mov esi, eax\n  xor rdx, rdx\n  mov eax, edi\n  mov r8d, 10\n  idiv r8d\n  add esi, edx\n  mov edi, eax\n  mov eax, esi\n  jmp .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"554ca54ffa7d91b236000023":[{"id":212398,"user_id":null,"body":"section .text\nglobal delete_nth\n; long delete_nth(const long *array, long length, long max_e, long *out)\ndelete_nth:\n  sub rsp, 296\n  xor eax, eax\n  mov r9, rdi\n  mov r11, rcx\n  lea rdi, [rsp-112]\n  mov ecx, 102\n  mov r10, rdx\n  mov r8, rsi\n  rep stosd\n  xor edx, edx\n  xor eax, eax\n.loop:\n  cmp rdx, r8\n  je .done\n  mov rcx, [r9+rdx*8]\n  mov rsi, [rsp-112+rcx*8]\n  cmp rsi, r10\n  jnb .next\n  inc rsi\n  mov [r11+rax*8], rcx\n  inc rax\n  mov [rsp-112+rcx*8], rsi\n.next:\n  inc rdx\n  jmp .loop\n.done:\n  add rsp, 296\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212399,"user_id":null,"body":"section .text\nglobal delete_nth\nextern memset\n; long delete_nth(const long *array, long length, long max_e, long *out)\ndelete_nth:\n  sub rsp, 408\n  push rdi\n  push rsi\n  push rdx\n  push rcx\n  lea rdi, [rsp + 40]\n  xor esi, esi\n  mov edx, 400\n  call memset\n  pop rcx\n  pop rdx\n  pop rsi\n  pop rdi\n  lea rsi, [rdi + rsi * 8]\n  xor eax, eax\n  jmp .cond\n  .loop:\n  mov r8, [rdi]\n  cmp rdx, [rsp + r8 * 8]\n  je .continue\n  inc dword [rsp + r8 * 8]\n  mov [rcx], r8\n  add rcx, 8\n  inc rax\n  .continue:\n  add rdi, 8\n  .cond:\n  cmp rdi, rsi\n  jne .loop\n  add rsp, 408\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212400,"user_id":null,"body":"section .text\nglobal delete_nth\n\n; long delete_nth(const long *array, long length, long max_e, long *out)\n; rdi rsi rdx rcx\ndelete_nth:\n  xor eax, eax\n  test rsi, rsi\n  jz .bailout\n  lea r8, [counter]\n  \n  %assign i 0\n  %rep 51\n  mov [r8+i], rax\n  %assign i i+8\n  %endrep\n\n.loop:\n  mov r9, [rdi]\n  add rdi, 8\n  dec rsi\n  inc qword [r8+r9*8]\n  cmp rdx, [r8+r9*8]\n  jl .skip\n  mov [rcx+rax*8], r9\n  inc rax\n.skip:\n  test rsi, rsi\n  jnz .loop\n.bailout:\n  ret\n\nsection .bss\ncounter: resq 51\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212401,"user_id":173,"body":"section .bss\n; already seen\nas:\n  resq 51\n\nsection .text\nglobal delete_nth\n; long delete_nth(const long *array, long length, long max_e, long *out)\ndelete_nth:\n  cmp rsi, 0\n  jne l_nz\n  mov rax, 0\n  ret\nl_nz:\n  mov r12, rdi\n  mov r13, rsi\n  mov r14, rdx\n  mov r15, rcx\n\n  \n  ; zero out already seen\n  lea rdi, [rel as]\n  mov rsi, 0\nl_zloop:\n  mov qword [rdi + rsi * 8], 0\n  inc rsi\n  cmp rsi, 50\n  jbe l_zloop\n\n  ; write pos in out\n  mov rbx, 0\n  \n  \n  mov rdi, r12\n  mov rsi, 0\nl_loop:\n  mov rax, [rdi + rsi * 8]\n\n  call f_get_as\n  \n  cmp rax, r14\n  jae l_nnum\n  mov rax, [rdi + rsi * 8]\n  call f_inc_as\n\n  \n  ; add to output\n  mov rax, [rdi + rsi * 8]\n  call f_add_out\nl_nnum:\n  inc rsi\n  cmp rsi, r13\n  jb l_loop\n  \n  mov rax, rbx\n  ret\n  \n; rax in - number to get already seen state\n; rax out - already seen state\nf_get_as:\n  push rdi\n  push rsi\n  lea rdi, [rel as]\n  mov rsi, rax\n  mov rax, [rdi + rsi * 8]\n  pop rsi\n  pop rdi\n  ret\n\n; increment already seen state for number from rax\nf_inc_as:\n  push rdi\n  push rsi\n  lea rdi, [rel as]\n  mov rsi, rax\n  mov rax, [rdi + rsi * 8]\n  inc rax\n  mov qword [rdi + rsi * 8], rax\n  pop rsi\n  pop rdi\n  ret\n\n; write rax in output at position rbx\nf_add_out:\n  push rdi\n  push rsi\n  mov rdi, r15\n  mov rsi, rbx\n  mov [rdi + rsi * 8], rax\n  inc rbx\n  pop rsi\n  pop rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212402,"user_id":null,"body":"section .bss\noccurrences: resb 64 ; 8 * 8 \n\nsection .text\nglobal delete_nth\n; long delete_nth(const long *array, long length, long max_e, long *out)\ndelete_nth:\n  xor rax,rax\n  test rsi,rsi   ; if length=0, just return 0\n  jnz .go\n  ret\n.go:\n  mov r8,rsi  ; length\n  mov r9,rdi  ; input\n  mov r10,rdx ; max n of elements\n  mov r11,rcx ; output pointer\n  \n  ; zero array\n  mov rdi,occurrences\n  mov rcx,8\n  xor rax,rax\n  rep stosq\n  \n  mov rsi,r9    ; input\n  mov rdi,r11   ; output\n  mov rcx,r8\n  xor rdx,rdx\n.elem:\n  lodsq         ; get element\n  inc byte [occurrences + rax] \n  cmp byte [occurrences + rax], r10b\n  ja .next\n  stosq\n  inc rdx\n.next:\n  loop .elem\n  mov rax,rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212403,"user_id":null,"body":"section .data\nsilly times 51 dq 0\nsection .text\nglobal delete_nth\ndelete_nth:\n  mov rax, 50\nouchloop: ; this is to reinitialise silly (stupified me for a while why code worked in my IDE but not here)\n  mov qword [silly+8*rax], 0\n  sub rax, 1\n  jnz ouchloop ; rax := 0 as a consequence, used to return length\n  xor r8, r8 ; loop counter\n  jmp start\nsexyloop:\n  mov r9, [rdi+8*r8] ; loops through array\n  inc r8\n  mov r10, qword [silly+8*r9] ; r10 stores the number\n  cmp r10, rdx\n  je start\n  inc r10\n  mov qword [silly+8*r9], r10\n  mov qword [rcx+8*rax], r9\n  inc rax\nstart:\n  cmp r8, rsi\n  jne sexyloop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212404,"user_id":null,"body":"extern malloc\nsection .bss\n@histmap resq 51\nsection .text\nglobal delete_nth\ndelete_nth:     mov r8, 50\n                lea r9,[@histmap]\n@rig_table:     mov [r9 + r8 * 8],rdx\n                dec r8\n                jns @rig_table\n                xor rax,rax\n                xor r10,r10\n@main_loop:     dec rsi\n                js  @done_copy\n                mov rdx,[rdi + r10 * 8]\n                inc r10\n                cmp qword [r9 + rdx * 8],0\n                je  @main_loop\n                dec qword [r9 + rdx * 8]\n                mov [rcx + rax * 8],rdx\n                inc rax\n                jmp @main_loop\n@done_copy:     ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212405,"user_id":null,"body":"section .text\nglobal delete_nth\n; long delete_nth(const long *array, long length, long max_e, long *out)\ndelete_nth:\n  test rsi, rsi\n  jnz .non_zero\n  xor eax, eax\n  ret\n  .non_zero:\n  mov r8, rdx\n  mov r9, rcx\n  xor ecx, ecx\n  xor edx, edx\n  .initialize:\n    mov byte [counts+rcx], 0\n    inc rcx\n    cmp rcx, 50\n    jl .initialize\n  xor ecx, ecx\n  .loop:\n    mov r10, [rdi+rcx*8]\n    lea r11, [counts+r10-1]\n    inc byte [r11]\n    movsx rax, byte [r11]\n    cmp rax, r8\n    jg .cont\n    mov [r9+rdx*8], r10\n    inc rdx\n    .cont:\n    inc rcx\n    cmp rcx, rsi\n    jl .loop\n  mov rax, rdx\n  ret\n\nsection .bss\n  counts: resb 50","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212406,"user_id":null,"body":"global delete_nth\ndelete_nth:\n  xor  rax,rax\n  test rsi,rsi\n  je .exit\n    xchg rcx,rsi\n    xchg rdi,rsi\n    xor  r8,r8\n    push rcx\n    push rdi\n    lea  rdi,[rsp-200]\n    mov  rcx,25\n    rep  stosq\n    pop  rdi\n    pop  rcx\n    .b:lodsq\n       inc dword[rsp-216+rax*4-4]\n       cmp [rsp-216+rax*4-4],edx\n       ja .f\n         stosq\n         inc r8\n       .f:\n    loop .b  \n    mov rax,r8\n  .exit:\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212407,"user_id":null,"body":"DEFAULT REL\nsection .data\ncounter:\ttimes 51 dq 0\n\nsection .text\nglobal delete_nth\nextern memset\n; long delete_nth(const long *array, long length, long max_e, long *out)\n\n; RDI *out \n; RSI *array\n; RDX length\n; RCX max_e\n; r9 out_len\ndelete_nth:\n\tPUSH RBX\n  PUSH RDI\n  PUSH RSI\n  PUSH RDX\n  PUSH RCX\n  \n  MOV RDI, counter\n  XOR RSI, RSI\n  MOV RDX, 51*8\n  CALL memset\n  \n  POP RCX\n  POP RDX\n  POP RSI\n  POP RDI\n  \n\tMOV RBX, RDI\n\tMOV RDI, RCX\n\tMOV RCX, RDX\n\tMOV RDX, RSI\n\tMOV RSI, RBX\n\tXOR R8, R8\n\tMOV R9, R8\n\n.nextelm:\n\tCMP RDX, R9\n\tJLE .return\n\tLODSQ\n\tINC R9\n\tMOV RBX, [counter + RAX*8]\n\tCMP RBX, RCX\n\tJE .nextelm\n\n\tINC R8\t\n\tINC QWORD [counter + RAX*8]\n\tSTOSQ\n\tJMP .nextelm\n\n.return:\n\tMOV RAX, R8\n\tPOP RBX\n\tRET","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"554e4a2f232cdd87d9000038":[{"id":212408,"user_id":null,"body":"SECTION .text\nglobal dna_strand\nextern strdup\ndna_strand:\n  call strdup\n  xor  rcx,rcx\n  .b:movzx rdx,byte[rax+rcx]\n     mov   dl,[.replace+rdx-'A']\n     mov   [rax+rcx],dl\n     inc   rcx\n     cmp   byte[rax+rcx],0\n  jne .b   \n  ret\n .replace      db 'T',0,'G',0,0,0,'C'\n times 'T'-'H' db 0\n               db 'A'","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212409,"user_id":null,"body":"extern strdup\nsection .text\nglobal dna_strand\ndna_strand:\n  call strdup\n  mov  rdi, rax\n  xor  rcx, rcx\nstart_loop:\n  mov  cl, [rdi]\n  test cl, cl\n  jz   end_loop\n  mov  cl, [xlate+rcx-'A']\n  mov  [rdi], cl\n  inc  rdi\n  jmp  start_loop\nend_loop:\n  ret\nsection .data\nxlate: db 'T.G...C............A'","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212410,"user_id":null,"body":"extern malloc\n\nsection .text\nglobal dna_strand\n\ndna_strand:\n  mov rsi, rdi\n  push rsi\n  mov rdi, 1024\n  call malloc\n  pop rsi\n  mov rdi, rax\n  mov rcx, rax\nloop:\n  lodsb\n  test al, 2 ; is G or C\n  jz notgc\n  xor al, 4 ; G <-> C\n  stosb\n  jmp loop\nnotgc:\n  test al, al\n  jz done\n  xor al, 21 ; A <-> T\n  stosb\n  jmp loop\ndone:\n  stosb\n  mov rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212411,"user_id":168,"body":"SECTION .text\nextern strlen, malloc\nglobal dna_strand\n\n; Returns a new heap-allocated string representing the complementary DNA.\n; Note that this function will only receive valid inputs, though feel free to do edge-checking.\n; char *dna_strand(const char *dna)\ndna_strand:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  lea rdi, [rax + 1]\n  call malloc\n  mov rdi, rax\n  mov esi, 21\n  jmp .loop_cond\n.loop:\n  mov ecx, 4\n  test edx, 2\n  cmovz ecx, esi\n  xor edx, ecx\n  mov byte [rdi], dl\n  inc rdi\n  inc rbx\n.loop_cond:\n  movzx edx, byte [rbx]\n  test edx, edx\n  jnz .loop\n  mov byte [rdi], dl\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212412,"user_id":null,"body":"extern malloc\nSECTION .text\nglobal dna_strand\n\n; Returns a new heap-allocated string representing the complementary DNA.\n; Note that this function will only receive valid inputs, though feel free to do edge-checking.\n; char *dna_strand(const char *dna)\ndna_strand:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  xor ebx, ebx\n.findlen:\n  cmp byte [r14 + rbx], 0\n  lea rbx, [rbx + 1]\n  jne .findlen\n  mov rdi, rbx\n  call malloc\n  lea rsi, [rbx - 1]\n  xor edx, edx\n.loop:\n  cmp rsi, rdx\n  je .done\n  mov cl, [r14 + rdx]\n  mov edi, 149\n  test cl, 2\n  je .gc\n  mov edi, 138\n.gc:\n  sub dil, cl\n  mov [rax + rdx], dil\n  inc rdx\n  jmp .loop\n.done:\n  mov byte [rax + rbx - 1], 0\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212413,"user_id":null,"body":"SECTION .text\nglobal dna_strand\nextern strlen\nextern malloc\n\n; Returns a new heap-allocated string representing the complementary DNA.\n; Note that this function will only receive valid inputs, though feel free to do edge-checking.\n; char *dna_strand(const char *dna)\ndna_strand:\n  push rdi           ; save dna and align to 16 byte boundary\n  call strlen        ; length of dna now in RAX\n  lea rdi, [rax + 1] ; malloc arg 1 now length of dna + 1 for zero terminator\n  call malloc        ; new dna now in RAX\n  mov rdi, [rsp]     ; restore dna\n  mov [rsp], rax     ; save new dna\n  mov cl, 'A'        ; cached A\n  mov dl, 'T'        ; cached T\n  mov r9b, 'C'       ; cached C\n  mov r10b, 'G'      ; cached G\n.loop:\n  mov sil, [rdi]     ; load dna char\n  mov r11b, sil      ; save original char\n  cmp r11b, cl       ; cmp A\n  cmovz esi, edx     ; make T if A\n  cmp r11b, dl       ; cmp T\n  cmove esi, ecx     ; make A if T\n  cmp r11b, r9b      ; cmp C\n  cmove esi, r10d    ; make G if C\n  cmp r11b, r10b     ; cmp G\n  cmove esi, r9d     ; make C if G\n  mov [rax], sil     ; commit write\n  test sil, sil      ; check if zero terminator\n  jz .exit           ; exit if zero terminator\n  inc rdi            ; increment read ptr\n  inc rax            ; increment write ptr\n  jmp .loop          ; next char\n.exit:\n  pop rax            ; restore new dna\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212414,"user_id":null,"body":"extern malloc\nextern realloc\n\nSECTION .text\nglobal dna_strand\n\n; Returns a new heap-allocated string representing the complementary DNA.\n; Note that this function will only receive valid inputs, though feel free to do edge-checking.\n; char *dna_strand(const char *dna)\ndna_strand:\n    \n    push rsi\n    push rdi\n    \n    xor rax, rax\n    test rdi,rdi  ; null parameter\n    jz end\n    cmp [rdi],al  ; not null parameter, but does not contain any data\n    jz end\n;=====================================\n    mov [input], rdi\n    mov rdi, 100\n    call malloc\n    mov [outmem], rax\n    mov rdi, [outmem]    ; rdi = malloc(100)\n    xor rax, rax         ; rax = 0\n    mov rsi, [input]     ; rsi = dns      \nloop:\n    lodsb\n    test al, al\n    jz endloop\n    mov al, [subst + rax-'A'] ; rax becomes index of the subst array\n    stosb\n    jmp loop\nendloop:  \n    stosb     ; put al=0 at the end of edi, to finalize the string\n    mov  rdi, [outmem]\n    call realloc\nend:\n    pop rdi\n    pop rsi\n    ret    \n  \nsection .data\nsubst: db 'T.G...C............A',0\n\nsection .bss\ninput: resb 8\noutmem: resb 8\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212415,"user_id":null,"body":"extern malloc\nextern realloc\n\nSECTION .text\nglobal dna_strand\n\n; Returns a new heap-allocated string representing the complementary DNA.\n; Note that this function will only receive valid inputs, though feel free to do edge-checking.\n; char *dna_strand(const char *dna)\ndna_strand:\n    \n    push rsi\n    push rdi\n    \n    xor rax, rax\n    test rdi,rdi  ; null parameter\n    jz end\n    cmp [rdi],al  ; not null parameter, but does not contain any data\n    jz end\n;=====================================\n    mov [input], rdi\n    mov rdi, 100\n    call malloc\n    mov [outmem], rax\n    mov rdi, [outmem]    ; rdi = malloc(100)\n    xor rax, rax         ; rax = 0\n    mov rsi, [input]     ; rsi = dns      \nloop:\n    lodsb\n    test al, al\n    jz endloop\n    lea rax, [rax-'A'] ; rax becomes index of the subst array\n    mov al, [subst + rax]\n    stosb\n    jmp loop\nendloop:  \n    stosb     ; put al=0 at the end of edi, to finalize the string\n    mov  rdi, [outmem]\n    call realloc\nend:\n    pop rdi\n    pop rsi\n    ret    \n  \nsection .data\nsubst: db 'T', 0, 'G', 0, 0, 0, 'C', 0, 0,0,0,0,0,0,0,0,0,0,0,'A',0\n\nsection .bss\ninput: resb 8\noutmem: resb 8\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212416,"user_id":null,"body":"SECTION .text\nglobal dna_strand\nextern malloc, strlen\n\n; Returns a new heap-allocated string representing the complementary DNA.\n; Note that this function will only receive valid inputs, though feel free to do edge-checking.\n; char *dna_strand(const char *dna)\ndna_strand:\n  push rdi\n  call strlen\n  lea rdi, [rax+1]\n  call malloc\n  pop rdi\n  test rax, rax\n  jz .quit\n  lea rsi, [rax-1]\n  \n.loop:\n  mov dl, [rdi]\n  inc rdi\n  inc rsi\n  cmp dl, 'A'\n  je .a_to_t\n  cmp dl, 'T'\n  je .t_to_a\n  cmp dl, 'C'\n  je .c_to_g\n  cmp dl, 'G'\n  je .g_to_c\n  mov byte [rsi], 0\n.quit:\n  ret\n  \n.a_to_t:\n  mov byte [rsi], 'T'\n  jmp .loop\n.t_to_a:\n  mov byte [rsi], 'A'\n  jmp .loop\n.c_to_g:\n  mov byte [rsi], 'G'\n  jmp .loop\n.g_to_c:\n  mov byte [rsi], 'C'\n  jmp .loop\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212417,"user_id":null,"body":"SECTION .data\ncomp db 'T0G000C000000000000A', 0\n\nSECTION .text\nglobal dna_strand\nextern strlen, sprintf, calloc\n\ndna_strand:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  inc rax\n  mov rdi, rax\n  mov rsi, 1\n  call calloc\n  xor rdx, rdx\n  mov rsi, rax\nloop:\n  mov dl, byte [rbx]\n  test dl, dl\n  jz return\n  mov cl, byte [comp + rdx - 'A']\n  mov byte [rsi], cl\n  inc rbx\n  inc rsi\n  jmp loop\n  \nreturn:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"555086d53eac039a2a000083":[{"id":212418,"user_id":76,"body":"section .text\nglobal lovefunc\n\nsection .text\nlovefunc:\n    lea eax, [edi + esi]\n    and eax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212419,"user_id":null,"body":"section .text\nglobal lovefunc\nlovefunc:\n  mov rax,rsi\n  xor rax,rdi\n  and rax,1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212420,"user_id":null,"body":"section .text\nglobal lovefunc\n\nsection .text\nlovefunc:              ; int lovefunc(int flower1, int flower2)\n                       ; input:  edi = flower1, esi = flower2\n                       ; output: al (1 for true, 0 for false)\n    xor edi, esi\n    and edi, 1\n    mov eax, edi\n\n    ret \n; end of lovefunc","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212421,"user_id":null,"body":"section .text\nglobal lovefunc\nsection .text\nlovefunc:\n  xor eax, eax\n  and edi, 1\n  and esi, 1\n  cmp edi, esi\n  setne al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212422,"user_id":null,"body":"section .text\nglobal lovefunc\n\nlovefunc:                                   \n    mov al, 1\n    and rdi, 1\n    and rsi, 1\n    cmp rdi, rsi\n    je _no\n    ret\n    \n_no:\n  dec al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212423,"user_id":null,"body":"section .text\nglobal lovefunc\n\nsection .text\nlovefunc:              ; int lovefunc(int flower1, int flower2)\n                       ; input:  edi = flower1, esi = flower2\n                       ; output: al (1 for true, 0 for false)\n    mov rbx, 2\n    xor rdx, rdx\n    mov eax, edi\n    div rbx\n    mov edi, edx\n    \n    xor rdx, rdx\n    mov eax, esi\n    div rbx\n    mov esi, edx\n    \n    cmp edi, esi\n    je false\n    \n    mov rax, 1\n    ret\n    \n    false:\n      xor rax, rax\n      ret\n; end of lovefunc","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212424,"user_id":null,"body":"section .text\n  global lovefunc\n\nlovefunc:\n  xor edi,esi\n  and edi,1\n  mov eax,edi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212425,"user_id":null,"body":"section .text\n  global lovefunc\n\nlovefunc:\n  add edi,esi\n  mov ebx,1\n  bzhi eax,edi,ebx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212426,"user_id":null,"body":"section .text\nglobal lovefunc\n\nsection .text\nlovefunc:              ; int lovefunc(int flower1, int flower2)\n                       ; input:  edi = flower1, esi = flower2\n                       ; output: al (1 for true, 0 for false)\n    mov al, dil\n    add al, sil\n    and al, 1\n    ret\n; end of lovefunc\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212427,"user_id":881,"body":"section .text\nglobal lovefunc\n\nlovefunc:\n    lea rax, [rdi + rsi]\n    and rax, 1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5552101f47fc5178b1000050":[{"id":212428,"user_id":null,"body":"global dig_pow\n\nsection .text\n\ndig_pow:\n  mov rax, [rbp-0x58]\n  mov eax, [rax+0x8]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212429,"user_id":null,"body":"extern asprintf, pow, free\nglobal dig_pow\n\nsection .text\n\ndig_pow:\n  push rbp\n  push r15\n  push r14\n  push r13\n  push r12\n  push rbx\n  sub rsp, 24\n  lea rbx, [rsp + 12]\n  lea r15, [rsp + 16]\n  mov edx, edi\n  mov ebp, esi\n  mov esi, .fmt\n  xor eax, eax\n  xor r12d, r12d\n  mov rdi, r15\n  mov rcx, rbx\n  mov [rsp + 8], edx\n  call asprintf\n  mov ebx, [rbx]\n  mov r14, [r15]\n  test rbx, rbx\n  je .skip\n  xor r13d, r13d\n  mov r15, r14\n.loop:\n  movsx eax, byte [r15]\n  add eax, -48\n  xorps xmm0, xmm0\n  cvtsi2sd xmm0, eax\n  mov eax, ebp\n  xorps xmm1, xmm1\n  cvtsi2sd xmm1, rax\n  call pow\n  cvttsd2si rax, xmm0\n  subsd xmm0, [.max]\n  inc ebp\n  inc r15\n  mov rdx, rax\n  cvttsd2si rcx, xmm0\n  sar rdx, 63\n  and rcx, rdx\n  or rcx, rax\n  add r13, rcx\n  dec rbx\n  jne .loop\n  jmp .done\n.skip:\n  xor r13d, r13d\n.done:\n  mov rdi, r14\n  call free\n  mov ecx, [rsp + 8]\n  mov rax, r13\n  xor edx, edx\n  div rcx\n  cmp rdx, 1\n  sbb r12d, r12d\n  not r12d\n  or eax, r12d\n  add rsp, 24\n  pop rbx\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  pop rbp\n  ret\n  \n.fmt: db \"%u%n\",0\n.max: dq 0x43e0000000000000\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212430,"user_id":null,"body":"global dig_pow\n\nsection .text\n\n; <----- int dig_pow(unsigned n, unsigned p) ----->\ndig_pow:\n    push rbp\n    mov  rbp, rsp\n    mov  rax, rdi\n    mov  rbx, 10\n    xor  rdx, rdx\n\n  .next:\n    push rdx\n    xor  rdx, rdx\n    div  rbx\n    test rax, rax\n    jnz  .next\n    \n    xor  rbx, rbx\n    mov  r8, rdx\n  .next2:\n    mov  rcx, rsi\n    ; %edi pow %ecx\n    mov  rax, 1\n  .next3:\n    mul  r8\n    dec  rcx\n    jnz  .next3\n    ; end pow\n    add  rbx, rax\n    inc  rsi\n    pop  r8\n    cmp  ebp, esp\n    jnz  .next2\n    \n    mov  rax, rbx\n    xor  rdx, rdx\n    div  rdi\n    mov  rbx, -1\n    test rdx, rdx\n    cmovnz rax, rbx\n    pop  rbp\n    ret\n; ---------> endof dig_pow <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212431,"user_id":null,"body":"global dig_pow\n\nsection .text\n\n; <----- int dig_pow(unsigned n, unsigned p) ----->\ndig_pow:\n  sub rsp, 16\n  mov rcx, rsp\n  mov eax, edi\n\n.div_loop:\n  xor edx, edx\n  div DWORD [const10]\n\n  mov [rcx], dl\n\n  test eax, eax\n  jz .end_div_loop\n\n  inc rcx\n  jmp .div_loop\n\n.end_div_loop:\n  xor r9d, r9d\n  mov r10, rcx\n\n.pow_loop_init:\n  mov eax, 1\n  xor r11, r11\n  mov r11b, [r10]\n  mov rcx, rsi\n\n.pow_loop:\n  mul r11d\n  loop .pow_loop\n\n  add r9d, eax\n  inc rsi\n  dec r10\n  cmp r10, rsp\n  jae .pow_loop_init\n\n\n  mov eax, r9d\n  xor edx, edx\n  div edi\n\n  test edx, edx\n  jz .return\n\n  mov eax, -1\n\n.return:\n  add rsp, 16\n  ret\n; ---------> endof dig_pow <---------\n\nsection .data\nconst10 dd 10\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212432,"user_id":null,"body":"global dig_pow\n\nsection .text\n\n; IN (edi, esi) OUT (eax) MOD (eax, edx, esi)\n; eax = edi ^ esi\nmy_pow:\n  push rbp\n  mov ebp, esp\n  \n  mov eax, 1\n  sub esi, eax\n  jb .pow_end\n  mov eax, edi\n  jz .pow_end\n.pow_loop:\n  mul edi\n  dec esi\n  jnz .pow_loop\n  \n.pow_end:\n  mov ebp, esp\n  pop rbp\n  ret\n\n; <----- int dig_pow(unsigned n, unsigned p) ----->\n; IN (edi, esi) OUT (eax) MOD (eax, edx, edi, esi)\n;   n : edi\n;   p : esi\ndig_pow:\n  push rbp\n  mov ebp, esp\n  \n; for each digit d\n.for_init_d:\n; n_copy : r9d\n; base_value : r10d\n; d : r11d\n  mov r9d, edi\n  mov r10d, 10\n.for_begin_d:\n  cmp r9d, 0\n  jz .for_end_d\n  mov edx, 0 ; avoid error\n  mov eax, r9d\n  div r10d\n  ; d = r9d % 10\n  mov r11d, edx\n  mov r9d, eax\n.for_body_d:\n;   p++\n  inc esi\n.for_loop_d:\n  jmp .for_begin_d\n.for_end_d:\n\n; sum : r8d\n; init sum\n  mov r8d, 0\n\n; while (p > 0)\n.while_init_count:\n; n_copy : r9d\n; base_value : r10d\n; d : r11d\n  mov r9d, edi\n  mov r10d, 10\n.while_begin_count:\n  cmp r9d, 0\n  jz .while_end_count\n;   p--\n  dec esi\n; redundant if start value was > 0\n  cmp esi, 0\n  jz .while_end_count\n  mov edx, 0 ; avoid error\n  mov eax, r9d\n  div r10d\n  ; d = r9d % 10\n  mov r11d, edx\n  mov r9d, eax\n.while_body_count:\n;   sum += pow(d, p)\n  push rdi\n  push rsi\n  mov edi, r11d\n  call my_pow\n  add r8d, eax\n  pop rsi\n  pop rdi\n.while_loop_count:\n  jmp .while_begin_count\n.while_end_count:\n\n; if ((sum % n) == 0)\n  mov edx, 0 ; avoid error\n  mov eax, r8d\n  div edi\n  cmp edx, 0\n  jnz .else\n;  eax : k = sum \/ n\n  jmp .return_k\n.else:\n;   k = -1\n  mov eax, (-1)\n  \n.return_k:\n; return k\n; EAX <- the result\n\n  mov ebp, esp\n  pop rbp\n  ret\n; ---------> endof dig_pow <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212433,"user_id":null,"body":"global dig_pow\n\nsection .text\n\n; <----- int dig_pow(unsigned n, unsigned p) ----->\ndig_pow:\n    ; @parameters:\n        ; rsi == p0 > 0 : first exponant.\n        ; rdi == n > 0 : digit\n    ; @return:\n        ; rax == k\n\n    push rdi    ; save edi = n\n\n    ; decomposing ...\n    mov rax, rdi\n    mov rbx, 10     ; to div by 10 below\n\n    xor r9,r9   ; Sure r9 is 0 at first\n\nnext_digit:\n    xor rdx,rdx\n    div rbx         ; rax:rdx \/\/ rbx => Q = rax : R = rdx\n    ; Store result in r9\n    xor r9, rdx\n    shl r9, 8       ; shift left 8 bits for next digit to store.\n    or rax, rax      ; rax == 0 means nothing more to split.\n    jnz next_digit\n\n    shr r9, 8   ; ''A bridge to far'' at the most right of @compo_digits.\n\n    ; pow compute : a^b = a*a*a*a*... b times.\n    xor r8, r8      ; Sure r8 is 0 at first.\nsum_power:\n    mov rbx, r9\n\n    mov rax, 1\n    mov rcx, rsi\n    and rbx,0x00000000000000ff  ; Keep only last 8 bits.\npow:\n    mul rbx\n    loop pow\n\n    add r8, rax\n    inc rsi\n    shr r9, 8   ; Want next digit in r9 LSB\n    jnz sum_power   ; Go on if r9 != 0\n\n    pop rbx     ; restore edi = n in ebx\n    xor rdx, rdx\n    mov rax, r8\n\n    div rbx     ; sum_power_result \/\/ n\n\n    or rdx,rdx   ; No reminder ? So the formula is verified.\n    jne KO\n\n    ret\n\nKO:\n    mov eax, -1\n    ret\n; ---------> endof dig_pow <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212434,"user_id":null,"body":"section .data\n    sum_power_result dd 0\n    dummy db 0xff\n    compo_digits db 0,0,0,0,0,0,0,0,0,0\n\n\nglobal dig_pow\n\nsection .text\n\n; <----- int dig_pow(unsigned n, unsigned p) ----->\ndig_pow:\n    ; esi == p0 > 0 : first exponant.\n    ; edi == n > 0 : digit\n\n    push rdi    ; save rdi = n (64-bits mode)\n\n    ; decomposing ...\n    mov eax, edi\n    mov ebx, 10     ; to div by 10 below\n\n    mov edi, compo_digits     ; @ where to save one by one [edi] digits\n\nnext_digit:\n    xor edx,edx\n    div ebx\n    mov byte [edi], dl\n    inc edi\n    cmp eax, 0\n    jnz next_digit\n\n    dec edi  ; 1st digit is at the most right of @compo_digits\n\n    ; pow compute : a^b = a*a*a*a*... b times.\n\n    mov dword [sum_power_result], eax\nsum_power:\n    xor ebx, ebx\n    mov bl, byte [edi]\n\n    mov eax, 1\n    mov ecx, esi\npow:\n    mul ebx\n    loop pow\n\n    add dword [sum_power_result], eax\n    inc esi\n    dec edi\n    cmp byte [edi], 0xff\n    jnz sum_power\n\n    pop rbx     ; restore rdi = n in rbx (64-bits mode)\n    xor edx, edx\n    mov eax, dword [sum_power_result]\n\n    div ebx     ; sum_power_result \/\/ n\n\n    cmp edx,0\n    jne KO\n\n    ret\n\nKO:\n    mov eax, -1\n    \n    ret\n; ---------> endof dig_pow <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212435,"user_id":null,"body":"global dig_pow\n\nsection .text\n@Ten dd 10\ndig_pow:        cmp edi,10            ; If single digit it'll be n ^p -1\n                jae @m_dig\n                mov eax,1\n                dec esi\n@l:             dec esi\n                js @l2\n                mul edi\n                jmp @l\n@l2:            ret\n\n@m_dig:         mov r10,rdi           ; r10 = the original n\n                mov eax,edi\n                mov ecx,1\n                mov r12,1\n@digs:          xor edx,edx\n                div dword [@Ten]\n                imul r12d,[@Ten]      ; What we start dividing on \n                cmp eax,10\n                jge @digs\n                xor r9,r9             ; The accumulated sum of digits pow'd\n                \n@e_digits:      mov rax,rdi\n                xor rdx,rdx\n                div r12\n                mov r8,rax\n                mov ecx,esi\n                mov rax,1\n@pow:           mul r8\n                dec ecx\n                jnz @pow\n                inc esi\n                add r9,rax\n                imul r8,r12\n                sub rdi,r8\n                mov rax,r12\n                xor rdx,rdx\n                div dword [@Ten]\n                mov r12,rax\n                mov rax,rdi\n                cmp r12,10\n                jge @e_digits\n@sub_10:        mov ecx,esi\n                mov r8,1\n@pow2:          imul r8,rax\n                dec ecx\n                jnz @pow2\n                add r9,r8\n                mov rax,r9\n                cmp rax,r10\n                div r10\n                mov ecx,-1\n                test rdx,rdx\n                cmovnz eax,ecx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212436,"user_id":null,"body":"global dig_pow\n\nsection .text\n@Ten dd 10\ndig_pow:        cmp edi,10  ; If single digit it'll be n ^p -1\n                jae @m_dig\n                mov eax,1\n                dec esi\n@l:             dec esi\n                js @l2\n                mul edi\n                jmp @l\n@l2:            ret\n\n@m_dig:         mov r10,rdi          ; r10 = the original n\n                mov eax,edi\n                mov ecx,1\n                mov r12,1\n@digs:          xor edx,edx\n                div dword [@Ten]\n                imul r12d,[@Ten]      ; What we start dividing on \n                cmp eax,10\n                jge @digs\n                xor r9,r9             ; The accumulated sum of digits pow'd\n                \n@e_digits:      mov rax,rdi\n                xor rdx,rdx\n                div r12\n                mov r8,rax\n                mov ecx,esi\n                mov rax,1\n@pow:           mul r8\n                dec ecx\n                jnz @pow\n                inc esi\n                add r9,rax\n                imul r8,r12\n                sub rdi,r8\n                mov rax,r12\n                xor rdx,rdx\n                div dword [@Ten]\n                mov r12,rax\n                mov rax,rdi\n                cmp r12,10\n                jge @e_digits\n@sub_10:        mov ecx,esi\n                mov r8,1\n@pow2:          imul r8,rax\n                dec ecx\n                jnz @pow2\n                add r9,r8\n                mov rax,r9\n                cmp rax,r10\n                ;jae @g\n                ;mov eax,-1\n                ;ret\n@g:             div r10\n                mov ecx,-1\n                test rdx,rdx\n                cmovnz eax,ecx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212437,"user_id":null,"body":"global dig_pow\n\nsection .data\n  ten: dd  10\n\nsection .text\n\n; <----- int dig_pow(unsigned n, unsigned p) ----->\ndig_pow:\n    xor r10d, r10d\n    xor rcx, rcx\n    mov eax, edi\n  .split_10:\n    test eax, eax\n    jz .make_sum\n    xor edx, edx\n    div dword [ten]\n    push dx\n    inc rcx\n    jmp .split_10\n    \n  .make_sum:\n    xor r8d, r8d\n    pop r8w\n    mov eax, 1\n    mov r9d, esi\n  .pow:  \n    mul r8d\n    sub r9d, 1\n    jnz .pow\n    \n    add r10d, eax\n    inc esi\n    loop .make_sum\n    \n    mov eax, r10d\n    div edi\n    \n    test edx, edx\n    jnz .no_whole_k\n    ret\n    \n    .no_whole_k:\n    mov eax, -1        ; EAX <- the result\n    ret\n; ---------> endof dig_pow <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"555624b601231dc7a400017a":[{"id":212438,"user_id":null,"body":"global josephus_survivor\njosephus_survivor:\n  mov ecx, 1\n  xor edx, edx\n  inc edi\n.loop:\n  cmp edi, ecx\n  jbe .done\n  lea eax, [rdx+rsi]\n  xor edx, edx\n  div ecx\n  inc ecx\n  jmp .loop\n.done:\n  lea eax, [rdx+1]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212439,"user_id":50,"body":"global josephus_survivor\njosephus_survivor:\n  xor rax, rax ; a=0\n  mov rbx,2   ; i=2\n_loop:\n  cmp rbx,rdi\n  jg _exit ; if i>n exit\n  add rax,rsi ; a+k\n  xor rdx,rdx   ; rem=0\n  div rbx ; a=(a+k)\/i, rdx=(a+k)%i\n  mov rax,rdx ; a=(a+k)%i\n  inc rbx ; i++\n  jmp _loop\n_exit:\n  inc rax ; a++\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212440,"user_id":null,"body":"global josephus_survivor\njosephus_survivor:  ; RDI = n, RSI = k\n  call josephus_survivor_0idx\n  inc rax\n  ret\njosephus_survivor_0idx:\n  push rdi\n  dec rdi\n  jz .zero\n  call josephus_survivor_0idx\n  pop rdi\n  add rax, rsi\n  xor rdx, rdx\n  div rdi\n  mov rax, rdx\n  ret\n.zero:\n  xor rax, rax\n  pop rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212441,"user_id":null,"body":"global josephus_survivor\njosephus_survivor:\n        cmp     edi, 1\n        jne     not_one\n        mov     eax, 1\n        ret\n\nnot_one:\n        push    r14\n        push    rbx\n        push    rax\n        mov     r14d, esi\n        mov     ebx, edi\n        lea     edi, [rbx - 1]\n        call    josephus_survivor\n        add     eax, r14d\n        add     eax, -1\n        cdq\n        idiv    ebx\n        lea     eax, [rdx + 1]\n        add     rsp, 8\n        pop     rbx\n        pop     r14\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212442,"user_id":77,"body":"global josephus_survivor\njosephus:\n  cmp rdi, 1\n  je .zero\n  push rdi\n  dec rdi\n  call josephus\n  add rax, rsi\n  pop rdi\n  xor rdx, rdx\n  idiv rdi\n  mov rax, rdx\n  ret\n.zero:\n  xor rax, rax\n  ret\njosephus_survivor:\n  call josephus\n  inc rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212443,"user_id":null,"body":"global josephus_survivor\njosephus_survivor:\n  xor r8,r8\n  mov rax,1\n  .b:inc r8\n     lea rax,[rax+rsi-1]\n     xor rdx,rdx\n     div r8\n     lea rax,[rdx+1]\n     dec rdi\n  jne .b   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212444,"user_id":527,"body":"global josephus_survivor\nsection .text\njosephus_survivor:\n                mov     eax, 1\n                mov     ecx, 1\n.loop:          add     eax, esi\n                xor     edx, edx\n                div     ecx\n                mov     eax, edx\n                add     ecx, 1\n                cmp     ecx, edi\n                jbe     .loop\n                inc     eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212445,"user_id":168,"body":"global josephus_survivor\njosephus_survivor:\n  xor eax, eax\n  mov ecx, 2\n  jmp .loop_cond\n.loop:\n  add eax, esi\n  cdq\n  idiv ecx\n  mov eax, edx\n  inc ecx\n.loop_cond:\n  cmp ecx, edi\n  jle .loop\n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212446,"user_id":168,"body":"global josephus_survivor\njosephus_survivor:\n  cmp edi, 1\n  jle .one\n  dec edi\n  call josephus_survivor\n  lea eax, [rax + rsi - 1]\n  xor edx, edx\n  inc edi\n  idiv edi\n  lea eax, [rdx + 1]\n  ret\n.one:\n  mov eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212447,"user_id":645,"body":"global josephus_survivor\njosephus_survivor:\n  push r12\n  mov r12d, edi\n  push rbx\n  sub rsp, 8\n  cmp edi, 1\n  jz .eq1\n  lea edi, [rdi - 1H]\n  mov ebx, esi\n  call josephus_survivor\n  lea eax, [rbx + rax - 1H]\n  cdq\n  idiv r12d\n  lea r12d, [rdx + 1H]\n.eq1:\n  add rsp, 8\n  mov eax, r12d\n  pop rbx\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5556282156230d0e5e000089":[{"id":212448,"user_id":1315,"body":"SECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\nextern strdup\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 1\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  call strdup\n  mov  rdi, rax\n  dec  rdi\nnext_char:\n  inc  rdi\n  mov  bl, [rdi]\n  test bl, bl\n  jz   end_loop\n  cmp  bl, 'T'\n  jne  next_char\n  mov  [rdi], byte 'U'\n  jmp  next_char\nend_loop:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212449,"user_id":null,"body":"SECTION .bss\n\nrna:\n  resb 350\n\nSECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 0\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  xor rax, rax\n  mov rcx, 0\n  mov rbx, rna\nloop:\n  mov BYTE al, [edi]\n  mov BYTE [rbx], al\n  test al, al\n  jz end\n  cmp al, 84\n  jne loop_end\n  mov BYTE [rbx], 85\nloop_end:\n  inc edi\n  inc rbx\n  jmp loop\nend:\n  mov rax, rna\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212450,"user_id":null,"body":"SECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 0\n  ret\n\ndna_to_rna:\n  mov rsi,rdi\n  mov rdi,RNA\n  .b:movsb\n     cmp byte[rdi-1],'T'\n     sbb byte[rdi-1],-1\n     cmp byte[rdi-1],0\n  jne .b   \n  mov rax,RNA\n  ret\n  \n  SECTION .data\n  RNA resb 350","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212451,"user_id":null,"body":"SECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov   rax, 0\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  mov   rax, out\n  xor   rcx,rcx\n.l:\n  mov   dl, [rdi+rcx]\n  cmp   dl,'T'\n  jne   .l2\n  mov   dl,'U'\n.l2:\n  mov   [rax+rcx], dl\n  inc   rcx\n  test  dl,dl\n  jnz   .l\n  ret\n  \nSECTION .bss\nout:\n  resb  350","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212452,"user_id":null,"body":"extern malloc\nSECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 1\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  xor eax, eax\n.findlen:\n  cmp byte [r14 + rax], 0\n  lea rax, [rax + 1]\n  jne .findlen\n  mov edi, eax\n  call malloc\n  xor ecx, ecx\n  jmp .copy\n.loop:\n  mov byte [rax + rcx], bl\n  inc rcx\n.copy:\n  movzx edx, byte [r14 + rcx]\n  mov bl, 85\n  cmp edx, 84\n  je .loop\n  test edx, edx\n  je .done\n  mov ebx, edx\n  jmp .loop\n.done:\n  mov byte [rax + rcx], 0\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212453,"user_id":null,"body":"SECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 0\n  ret\n\nclear_buffer:\n  xor rax, rax\nl:\n  mov byte [buffer+rax], 0\n  inc rax\n  cmp rax, 350\n  jnz l\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  call clear_buffer\n  \n  xor rax, rax\n  xor rdx, rdx\n  \nloop:\n  mov dl, [rdi+rax]\n  \n  ; check if \\0\n  cmp dl, 0\n  je end\n  \n  ; check if replace\n  cmp dl, 'T'\n  jz repl\n  \n  ; else\n  mov [buffer+rax], dl\n  inc rax\n  jmp loop\n  \nrepl:\n  mov byte [buffer+rax], 'U'\n  inc rax\n  jmp loop\n  \nend:\n  mov rax, buffer\n  ret\n  \nSECTION .data\nbuffer: times 350 db 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212454,"user_id":null,"body":"section .bss\n  rna: resb 100\nSECTION .text\nextern strcpy\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 0\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  xor rax, rax\n  push rbp\n  mov rbp,rsp\n  sub rsp,0x10\n  mov rsi,rdi\n  mov rdi,rna\n  call strcpy\n  mov rdi,rax\n  jmp check_null\ncheck_null:\n  cmp byte[rdi],0\n  jne transle\n  leave\n  ret\ntransle:\n  cmp byte[rdi],'T'\n  jne pass\n  mov byte[rdi],'U'\n  jmp pass\npass:\n  add rdi,1\n  jmp check_null","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212455,"user_id":173,"body":"SECTION .bss\nbuf:\n  resb 350\n\nSECTION .text\n\n\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 0\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  lea rsi, [rel buf]\nLOOP:\n  cmp byte [rdi], 0\n  je DONE\n  cmp byte [rdi], 0x54\n  je REPLACE\n  mov al, byte [rdi]\n  mov byte [rsi], al\n  jmp NEXT\nREPLACE:\n  mov byte [rsi], 0x55\nNEXT:\n  inc rdi\n  inc rsi\n  jmp LOOP\nDONE:\n  mov byte [rsi], 0\n  lea rax, [rel buf]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212456,"user_id":null,"body":"extern malloc\n\nSECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n\n; Returns a boolean indicating whether the return value of dna_to_rna is\n; allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value\n; of dna_to_rna if this function returns false.\n \ndna_to_rna_uses_dynamic_allocation:\n\tmov rax, 1\n\tret\n \n; Returns a string representation of a DNA sequence converted to\n; an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\n \ndna_to_rna:\n\txor rax, rax\t\t\t\t      ;setting the pointer to <result> to NULL\t\n\txor rdx, rdx\t\n\txor rsi, rsi\t\t\n\tmov rcx, -1\t\t\t\t        ;initial <len>\n \n.strlen:\n\tinc rcx\t\t\t\t            ;incrementing <len>\n\tcmp byte [rdi+rcx], 0\t  \t;whether <input+len> is empty char\n\tjne .strlen\t\t\t\t        ;otherwise jumping to .strlen\n\ttest rcx, rcx\t\t\t      \t;whether <len> is zero\n\tje .exit\t\t\t\t          ;jumping to .exit\n\t\n\tmov sil, 'U'\t\t\t      \t;copying to dl <RNAchar>\t\n\tpush rcx\t\t\t\t          ;saving <len> in the stack\n\tpush rsi\t\t\t\t          ;saving <RNAchar> in the stack\n\tpush rdi\t\t\t          \t;saving <input> in the stack\n\tmov rdi, rcx\t\t          ;copying <len> to rdi\n\tinc rdi\t\t\t\t            ;adding an extra space for the null char\n\tcall malloc\t\t\t        \t;allocating memory\n\tpop rdi\t\t\t\t            ;restoring <len> from the stack\n\tpop rsi\t\t\t\t            ;restoring <RNAchar> from the stack\n\tpop rcx\t\t\t\t            ;restoring <input> from the stack\n\ttest rax, rax\t\t         \t;whether the memory is allocated\n\tje .exit\t\t\t\t          ;otherwise jumping to .exit\n\tmov byte [rax+rcx], 0\t  \t;copying the null char to the end of the <result>\n\t\n.loop:\n\ttest rcx, rcx\t\t\t       \t;whether there are chars left\n\tje .exit\t\t\t          \t;otherwise jumping to exit\n\tdec rcx\t\t\t            \t;decrementing <len>\n\tcmp byte [rdi+rcx], 'T'\t\t;whether <input+len> is &apos;T&apos;\n\tjne .not_equal\t\t      \t;otherwise jumping to .not_equal section\n\tmov dl, sil\t\t\t        \t;copying <RNAchar> to <c>\n\tjmp .cpy\t\t\t\t          ;jumping to .cpy section\n\t\n.not_equal:\t\n\tmov\tdl, [rdi+rcx]\t\t      ;copying <input+len> char to <c> \n.cpy:\n\tmov [rax+rcx], dl\t\t     \t;copying <c> to <result+len> \n\tjmp\t.loop\t\t\t          \t;jumping to the next iteration\n \n.exit:\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212457,"user_id":null,"body":"SECTION .bss\nrna: resb 350\n\nSECTION .text\nglobal dna_to_rna\nglobal dna_to_rna_uses_dynamic_allocation\n; Returns a boolean indicating whether the return value of dna_to_rna is allocated on the heap or allocated statically.\n; Please allocate a static buffer of 350 characters for the return value of dna_to_rna if this function returns false.\ndna_to_rna_uses_dynamic_allocation:\n  mov rax, 0\n  ret\n\n; Returns a string representation of a DNA sequence converted to an RNA sequence\n; arg0         = (const char*) DNA sequence.\n; return value = (char*)       RNA sequence.\ndna_to_rna:\n  mov rsi, rna\n  .loop:\n  cmp DWORD [rdi], 0x00\n  je .end_loop\n  mov rdx, 0xFF\n  and rdx, [rdi]\n  cmp rdx, 0x54\n  je .change\n  jne .copy\n  .increment:\n  inc rdi\n  inc rsi\n  jmp .loop\n  .end_loop:\n  mov DWORD [rsi], 0\n  mov rax, rna\n  ret\n  .change:\n  mov DWORD [rsi], 0x55\n  jmp .increment\n  .copy:\n  mov rdx, [rdi]\n  mov [rsi], rdx\n  jmp .increment","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"555bfd6f9f9f52680f0000c5":[{"id":212458,"user_id":null,"body":"global reverse_num\n\nsection .text\n\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n    mov rax, rdi        ; copying <n> to RAX\n    mov rsi, 10         ; will be used to shift a digit\n    xor ecx, ecx        ; resetting RCX as <r>\n.loop:\n    test rax, rax       ; whether <n> is zero\n    je .exit            ; jumping to exit\n    cqo                 ; resetting RDX\n    idiv rsi            ; getting rid of the rightmost digit in <n>\n    imul rcx, 10        ; shifting <r> one digit left\n    add rcx, rdx        ; setting the rightmost digit in <r>\n    jmp .loop           ; jumping to the next iteration\n.exit:\n    mov rax, rcx        ; setting the result\n    ret\n; ---------> endof reverse_num <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212459,"user_id":null,"body":"global reverse_num\nsection .text\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n        mov  rax, rdi\n        mov  rbx, 10\n        xor  rcx, rcx ;RESULT\nmain:   cqo\n        idiv rbx\n        add  rcx, rdx\n        test rax, rax\n        jz   end\n        imul rcx, rbx\n        jmp main\nend:    mov rax, rcx\n        ret\n; ---------> endof reverse_num <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212460,"user_id":null,"body":"global reverse_num\nsection .text\nreverse_num:\n  xor rax,rax\n  mov rsi,10\n.loop:\n  test rdi,rdi\n  jz .exit\n  imul rcx,rax,10\n  mov rax,rdi\n  cqo\n  idiv rsi\n  mov rdi,rax\n  lea rax,[rcx+rdx]\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212461,"user_id":null,"body":"global reverse_num\n\nsection .text\n\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n  mov rax, rdi\n  neg rax\n  cmovs rax, rdi\n  xor edx, edx\n  mov rcx, 10\n.loop:\n  test rax, rax\n  je .done\n  imul rsi, rdx, 10\n  cqo\n  idiv rcx\n  add rdx, rsi\n  jmp .loop\n.done:\n  mov rax, rdx\n  neg rax\n  test rdi, rdi\n  cmovns rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212462,"user_id":46,"body":"section .text\nglobal reverse_num\nreverse_num:\n  cmp rdi, 0\n  js _neg_num\n  jmp _after_neg_num\n  _neg_num:\n    neg rdi\n    call reverse_num\n    neg rax\n    ret\n  _after_neg_num:\n  xor rax, rax\n  mov rbx, 10\n  _loop:\n    mul rbx\n    push rax\n    mov rax, rdi\n    xor rdx, rdx\n    div rbx\n    mov rdi, rax\n    pop rax\n    add rax, rdx\n    cmp rdi, 0\n    jne _loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212463,"user_id":null,"body":"global reverse_num\n\nsection .text\n\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n  mov ecx, 10\n  xor esi, esi\n  mov rax, rdi\n  \n  mov r8, 1\n  cmp rax, 0\n  jge .loop\n  sub r8, 2\n  neg rax\n  \n.loop:\n  xor edx, edx\n  div rcx\n  lea rsi, [rsi*5]\n  lea rsi, [rsi*2+rdx]\n  test rax, rax\n  jnz .loop\n  \n  mov rax, rsi\n  imul rax, r8\n  ret\n; ---------> endof reverse_num <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212464,"user_id":460,"body":"global reverse_num\nsection .text\nreverse_num:\npush rbp\nmov rbp, rsp\n\n; get sign multiplicator\n  xor rcx, rcx\n  bt rdi, 63\n  setc cl\n  cmp rcx, 1\n  je .negative\n; positive\n  mov rcx, 1\n  jmp .end_sign_retrival\n.negative:\n  neg rcx\n  neg rdi ; negate initial number if negative\n  jmp .end_sign_retrival\n.end_sign_retrival:\n  mov r11, rcx ; set sign multiplicator to r11\n\n  xor r8, r8\n  mov rax, rdi\n  mov rcx, 10\n.collect_digits:\n  xor rdx, rdx\n  idiv rcx\n  cmp r8, 0\n  jne .push_digit ; if it's not first pushed digit\n  cmp rdx, 0\n  jne .push_digit ; if it's not zero\n  jmp .skip_push\n.push_digit:\n  push rdx\n  inc r8\n.skip_push:\n  cmp rax, 0 ; if there are some digits left\n  jne .collect_digits\n\n  cmp r8, 0 ; if digits count isn't zero\n  jne .reverse\n  xor rax, rax\nleave  \nret\n\n.reverse:\n  xor r9, r9\n  mov r10, 1\n.reverse_loop:\n  pop rax ; get last digit\n  imul r10 ; multiply by tens\n  add r9, rax ; add to sum\n  \n  ; multiply tens by 10\n  mov rax, 10\n  imul r10\n  mov r10, rax\n  \n  dec r8\n  cmp r8, 0 ; if there are some digits left\n  jne .reverse_loop\n  \n  mov rax, r9 ; move reversed digits in rax\n  imul r11 ; multiply by sign multiplicator\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212465,"user_id":null,"body":"global reverse_num\n\nsection .text\n\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n    mov r8,10         ; divisor\/multiplier\n    xor cx,cx         ; sign flag\n    xor rsi,rsi       ; accumulator\n    mov rax,rdi\n    test rax,rax\n    jns .digit\n    neg rax           ; flip sign if negative\n    inc cx\n.digit:\n    xchg rax,rsi      ; multiply accumulator by 10\n    mul r8\n    xchg rax,rsi\n    xor rdx,rdx       ; extract digit from input\n    div r8\n    add rsi,rdx       ; add to accumulator\n    test rax,rax      ; done yet?\n    jnz .digit        ; if not, get next digit\n    mov rax,rsi       ; get accumulator\n    dec cx            ; sign flag\n    jnz .out          ; if positive, return it unchanged\n    neg rax           ; otherwise, negate it\n.out:\n    ret\n; ---------> endof reverse_num <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212466,"user_id":50,"body":"global reverse_num\n\nsection .text\n\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n    xor r8,r8 ;flag negative \n    cmp rdi,0\n    jl _inv\n    jmp _start\n_inv:\n  neg rdi\n  mov r8,1\n_start:\n    xor rax, rax\n    xor rbx,rbx\n    mov rcx,10\n    mov rax,rdi\n_loop:\n  cmp rax,0\n  je _exit\n  imul rbx,rcx\n  xor rdx,rdx\n  div rcx\n  add rbx,rdx\n  jmp _loop\n_exit:\n  mov rax,rbx\n  cmp r8,1\n  je _invres\n  ret\n_invres:\n  mov rax,rbx\n  neg rax\n  ret\n; ---------> endof reverse_num <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212467,"user_id":null,"body":"global reverse_num\n\nsection .text\n\n; <--- long long reverse_num(long long n) --->\nreverse_num:\n  mov r9, rdi                  ; store original (sign)\n  \n  neg rdi\n  cmovs rdi, r9                ; rdi = abs(n)\n\n  mov rsi, 0x199999999999999a   ; multiplicative inverse of 10\n  xor r8, r8                    ; r8 is our new number\n  \nL_loop:\n  mov rax, rdi\n  mul rsi\n  mov rdi, rdx                  ; rdi = n \/ 10\n  \n  mov edx, 10\n  mul rdx                       ; rdx = n % 10\n  \n  lea r8, [r8 + 4*r8]           \n  lea r8, [rdx + 2*r8]          ; r8 = 10 * r8 + (n % 10)\n  \n  test rdi, rdi\n  jnz L_loop\n  \n  mov rax, r8\n  neg r8\n  \n  test r9, r9\n  cmovs rax, r8\n  \n  ret\n; ---------> endof reverse_num <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55685cd7ad70877c23000102":[{"id":212468,"user_id":168,"body":"SECTION .text\nglobal make_negative\n\nmake_negative:\n  mov eax, edi\n  neg edi\n  cmovs eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212469,"user_id":527,"body":"global make_negative\nsection .text\nmake_negative: \n                mov     eax, edi\n                neg     edi\n                cmovs   eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212470,"user_id":null,"body":"SECTION .text\nglobal make_negative\n\nmake_negative: \n  mov eax, edi\n  cmp eax, 0\n  jl flag1\n  neg eax\nflag1:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212471,"user_id":1277,"body":"SECTION .rodata\nINT32_MIN: dd 0x80000000\n\nSECTION .text\nglobal make_negative\n\n; branchless hack\nmake_negative: \n  vxorps xmm0, xmm0, xmm0\n  vxorps xmm1, xmm1, xmm1\n  vcvtsi2ss xmm0, xmm0, edi\n  movss xmm1, [INT32_MIN]\n  vorps xmm0, xmm0, xmm1\n  vcvtss2si eax, xmm0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212472,"user_id":null,"body":"SECTION .text\nglobal make_negative\n\nmake_negative:\n  xor eax, eax\n  mov eax, edi\n  cmp eax, 0\n  jle end\n  neg eax\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212473,"user_id":null,"body":"SECTION .text\nglobal make_negative\n\nmake_negative: \n  cmp edi, 0\n  jng after\n  neg edi\nafter:\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212474,"user_id":null,"body":"section .text\nglobal make_negative\n\nmake_negative:\n  neg edi\n  mov eax, edi\n  cmp edi, 0\n  jg positive\n  ret\n  \npositive:\n  imul eax, edi, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212475,"user_id":null,"body":"SECTION .text\nglobal make_negative\n\nmake_negative:\n  mov eax, edi\n  test eax, eax\n  js skip\n  neg eax\nskip:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212476,"user_id":null,"body":"SECTION .text\nglobal make_negative\n\nmake_negative: \n  cmp edi, 0\n  jle end\n  neg edi\nend:\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212477,"user_id":null,"body":"SECTION .text\nglobal make_negative\n\nmake_negative:\n  mov eax, edi\n  cmp eax, 0\n  jle return\n  neg eax\nreturn:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"557cd6882bfa3c8a9f0000c1":[{"id":212478,"user_id":null,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n    movzx eax, byte [rdi]       ; extending <*inp> to <age>\n    sub eax, '0'                ; subtracting the ASCII code of '0' to get the age\n    ret\n; ---------> endof get_age <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212479,"user_id":null,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n    mov al, [rdi]\n    and rax, 0x0f\n\n    ret\n; ---------> endof get_age <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212480,"user_id":null,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n    xor  rax, rax\n    mov  al, [rdi]\n    sub  al,'0'      ; assume the first char is the number\n    ret\n; ---------> endof get_age <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212481,"user_id":null,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n    xor eax, eax       ; EAX <- the result\n    mov al, byte[rdi]\n    sub al, 0x30\n    ret\n; ---------> endof get_age <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212482,"user_id":null,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n    xor rax, rax       ; EAX <- the result\n    mov al, [rdi]\n    sub al, 48\n    ret\n; ---------> endof get_age <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212483,"user_id":null,"body":"global get_age\n\nsection .text\n\nget_age:\n    xor eax, eax       ; EAX <- the result\n    mov al, [rdi]\n    sub al, '0'\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212484,"user_id":null,"body":"global get_age\n\nsection .text\nget_age:\n    movzx rax,byte[rdi]\n    sub   rax,'0'\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212485,"user_id":1196,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n  movzx eax, byte [rdi]\n  sub al, '0'\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212486,"user_id":881,"body":"global get_age\n\nsection .text\n\n; <--- unsigned int get_age(const char *inp) --->\nget_age:\n    xor eax, eax\n    mov al, byte[rdi]\n    sub eax, '0'\n    ret\n; ---------> endof get_age <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212487,"user_id":null,"body":"global get_age\n\nsection .text\n\nget_age:\n    movzx   eax, byte [rdi]\n    sub     eax, 48\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5583d268479559400d000064":[{"id":212488,"user_id":527,"body":"global b_to_s\nextern malloc, strlen\n\nsection .text\n\n; char *b_to_s(const char *b)\nb_to_s:\n                push    rdi\n                call    strlen\n                shr     rax, 3\n                push    rax\n                lea     rdi, [rax + 1]\n                push    rbp\n                call    malloc\n                pop     rbp\n                pop     rcx\n                pop     rdi\n                lea     rdi, [rdi + rcx * 8]\n                lea     rsi, [rax + rcx]\n                neg     rcx\n                jz      .done\n                vmovq        xmm0, [byte_swap_mask]\n                vmovq        xmm1, [one_chars]\n.loop:          vpcmpeqb     xmm2, xmm1, [rdi + rcx * 8]\n                vpshufb      xmm2, xmm0\n                vpmovmskb    edx, xmm2\n                mov     byte [rsi + rcx], dl\n                inc     rcx\n                jnz     .loop\n.done:          mov     byte [rsi], 0\n                ret\n\nsection .rodata\nbyte_swap_mask  db 7, 6, 5, 4, 3, 2, 1, 0\none_chars       db '11111111'\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212489,"user_id":null,"body":"global b_to_s\nextern strdup\nb_to_s:\n  call strdup\n  xor  rcx,rcx\n  jmp @f\n  @b:movbe rdx,[rax+rcx*8]\n     pext  rdx,rdx,[mask]\n     mov   [rax+rcx],rdx\n     inc   rcx\n  @f:cmp   byte[rax+rcx*8],0\n  jne @b   \n  mov byte[rax+rcx],0\nret\nmask dq 0x101010101010101","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212490,"user_id":168,"body":"global b_to_s\nextern strdup\n\nsection .bss\nbuf resb 1024\n\nsection .text\nc_mul dq 0102040810204080h\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n  mov rax, buf\n  movq mm1, [c_mul]\n  mov rcx, 3030303030303030h\n  jmp .loop_cond\n.loop:\n  mov rdx, qword [rdi]\n  sub rdx, rcx\n  movq mm0, rdx\n  pmaddubsw mm0, mm1\n  phaddw mm0, mm0\n  phaddw mm0, mm0\n  movd edx, mm0\n  mov byte [rax], dl\n  inc rax\n  add rdi, 8\n.loop_cond:\n  movzx edx, byte [rdi]\n  test edx, edx\n  jnz .loop\n  mov byte [rax], 0\n  mov rdi, buf\n  call strdup\n  ret\n; -----> endof b_to_s <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212491,"user_id":null,"body":"global b_to_s\nextern malloc\n\nsection .text\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n  push r15\n  push r14\n  push rbx\n  mov r15, rdi\n  mov r14, -1\n.lengthloop:\n  cmp byte [r15 + 8*r14 + 8], 0\n  lea r14, [r14 + 1]\n  jne .lengthloop\n  lea rdi, [r14 + 1]\n  call malloc\n  test r14, r14\n  je .done\n  xor ecx, ecx\n.loop:\n  mov sil, [r15 + 8*rcx]\n  mov r8b, [r15 + 8*rcx + 1]\n  mov dil, [r15 + 8*rcx + 2]\n  mov r9b, [r15 + 8*rcx + 3]\n  mov bl, [r15 + 8*rcx + 4]\n  mov dl, [r15 + 8*rcx + 6]\n  add sil, sil\n  and r8b, 1\n  add dil, dil\n  and r9b, 1\n  shl bl, 2\n  and dl, 1\n  and sil, 2\n  and dil, 2\n  and bl, 4\n  or r8b, sil\n  mov sil, [r15 + 8*rcx + 5]\n  shl r8b, 2\n  or dil, r8b\n  or r9b, dil\n  add sil, sil\n  mov dil, [r15 + 8*rcx + 7]\n  shl r9b, 3\n  and sil, 2\n  or bl, r9b\n  or sil, bl\n  and dil, 1\n  or dl, sil\n  add dl, dl\n  or dil, dl\n  mov [rax + rcx], dil\n  inc rcx\n  cmp r14, rcx\n  jne .loop\n.done:\n  mov byte [rax + r14], 0\n  pop rbx\n  pop r14\n  pop r15\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212492,"user_id":null,"body":"global b_to_s\nextern malloc, strlen\n\nsection .text\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n  push rdi\n  call strlen\n  shr eax, 3\n  lea edi, [rax+1]\n  call malloc\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  \n.loop:\n  mov cl, [rsi]\n  inc rsi\n  test cl, cl\n  jz .done\n  shr cl, 1\n  rcl dl, 1\n  %rep 7\n  mov cl, [rsi]\n  inc rsi\n  shr cl, 1\n  rcl dl, 1\n  %endrep\n  \n  mov [rdi], dl\n  inc rdi\n  jmp .loop\n  \n.done:\n  mov byte [rdi], 0\n.quit:\n  ret\n; -----> endof b_to_s <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212493,"user_id":null,"body":"global b_to_s\nextern malloc, strlen\n\nsection .text\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n  push rdi\n\n  call strlen\n\n  mov rcx, 8\n  xor rdx, rdx\n  div rcx\n\n  mov rdi, rax\n  inc rdi         \n  call malloc     ; malloc(strlen(bin) \/ 8 + 1)\n\n  pop rdi         ; restore input *\n  push rax        ; save return *\n  mov rsi, rax\n\n  mov al, [rdi]\n\n  test al, al     ; test null input\n  jz .return\n\n  mov rcx, 7      ; init shifter\n  xor rdx, rdx\n\n.loop:\n  sub al, '0'     ; convert ascii bit to num\n  shl al, cl      ; shift bit to position\n  or dl, al       ; or with temp byte register\n\n  dec cl\n  jns .next_bit   ; skip storing byte until cl underflow\n\n.store_byte:\n  mov [rsi], dl\n  inc rsi\n  mov cl, 7\n  xor dl, dl\n\n.next_bit:\n  inc rdi\n  mov al, [rdi]\n\n  test al, al\n  jnz .loop\n\n.return:\n  mov BYTE [rsi], 0\n  pop rax\n  ret\n; -----> endof b_to_s <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212494,"user_id":null,"body":"global b_to_s\nextern malloc\n\nsection .text\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n    mov r15, rdi   \n    xor rdx, rdx\n    xor rax, rax\n    xor rdi, rdi\n    mov rdi, 64\n    call malloc\n    mov rdi, rax    \n    xor rcx, rcx\n    loop:\n    cmp byte [r15], 0\n    je end\n    shl dl, 1\n    cmp byte [r15], '1'\n    jne skip\n    or dl, 1\n    skip:\n    inc rcx\n    cmp rcx, 8\n    jne skip2\n    mov byte [rdi], dl\n    inc rdi\n    xor rdx, rdx\n    xor rcx, rcx\n    skip2:\n    inc r15\n    jmp loop  \n    end:\n    mov byte [rdi], 0\n    ret\n\n; -----> endof b_to_s <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212495,"user_id":null,"body":"global b_to_s\nextern malloc,strlen\n\nsection .text\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n    push    rdi\n    call    strlen\n    push    rax\n    inc     rax\n    mov     rdi, rax\n    call    malloc\n    pop     rcx\n    pop     rdi\n    push    rax\n    xor     rdx,rdx\n\n    .loop:\n    cmp     rdx, rcx\n    je      .end\n    \n    \n    .onebyte:\n    xor     r8,r8\n    mov     r9,   rdi\n        \n    inc     r9\n    mov     r10, [r9]\n    shl     r10,  6\n    or      r8,   r10\n    \n    inc     r9\n    mov     r10,  [r9]\n    and     r10,  1\n    shl     r10,  5\n    or      r8,   r10\n    \n    inc     r9\n    mov     r10,  [r9]\n    and     r10,  1\n    shl     r10,  4\n    or      r8,   r10\n    \n    inc     r9\n    mov     r10,  [r9]\n    and     r10,  1\n    shl     r10,  3\n    or      r8,   r10\n\n    inc     r9\n    mov     r10,  [r9]\n    and     r10,  1\n    shl     r10,  2\n    or      r8,   r10\n    \n    inc     r9\n    mov     r10,  [r9]\n    and     r10,  1\n    shl     r10,  1\n    or      r8,   r10\n\n    inc     r9\n    mov     r10,  [r9]\n    and     r10,  1\n    or      r8,   r10\n    \n    mov     [rax], r8\n    .endonebyte:\n\n    inc     rax\n    add     rdx, 8          \n    add     rdi, 8\n    jmp     .loop\n    .end:\n    mov     [rax], byte 0\n    pop     rax\n    ret\n; -----> endof b_to_s <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212496,"user_id":null,"body":"global b_to_s\nextern malloc\nextern strlen\n\nsection .text\n\n%macro testbit 1\n    cmp byte [rsi], '1'\n    jnz %%nobit\n    or byte [rdi], %1\n%%nobit:\n    inc rsi\n%endmacro\n\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n    ; strlen(rdi) \/ 8\n    push rdi\n    call strlen\n    shr rax, 3\n\n    ; malloc(rax + 1)\n    mov rdi, rax\n    inc rdi\n    call malloc\n\n    ; Set up iteration\n    mov rdi, rax\n    pop rsi\n\n    ; For each 8 'bits' in rsi[], set the equivalent bit of *rdi\n.nextch:\n    mov byte [rdi], 0\n    cmp byte [rsi], 0\n    jz .end\n    testbit 0x80\n    testbit 0x40\n    testbit 0x20\n    testbit 0x10\n    testbit 0x08\n    testbit 0x04\n    testbit 0x02\n    testbit 0x01\n    inc rdi\n    jmp .nextch\n\n.end:\n    ret\n; -----> endof b_to_s <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212497,"user_id":null,"body":"global b_to_s\nextern strlen, malloc\n; <-- [byte RAX] b_to_s(ro [byte RDI] bin) -->\nb_to_s:\n    push rdi\n    call strlen             ; call for input string length\n    shr rax, 3              ; divide by 8 as each 8 bytes of input is 1 byte of output\n    push rax\n    lea rdi, [rax+1]        ; allocate 1 extra byte for null termination\n    call malloc\n    pop rcx                 ; rcx holds the return string length\n    pop rdi                 ; rdi holds a pointer to the string passed to the function\n    mov byte [rax+rcx], 0   ; null terminate\n    test rcx, rcx           ; test for an empty input before we enter the loop\n    jz .end\n.str_loop:\n    mov rsi, [rdi+8*rcx-8]  ; move 8 bytes into rsi\n    shl rsi, 7              ; '1' bytes now have a 1 in their MSB, '0' bytes have 0\n    bswap rsi\n    movq mm0, rsi           ; load into an MMX register \n    pmovmskb edx, mm0       ; condense the MSB of each byte in mm0 into the byte dl\n    mov [rax+rcx-1], dl     ; this is the output byte we need\n    loop .str_loop\n.end:\n    ret\n; -----> endof b_to_s <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55908aad6620c066bc00002a":[{"id":212498,"user_id":1277,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor ecx, ecx\n.loop_cond:\n  mov al, [rdi]\n  test al, al\n  jz .ret\n.loop:\n  inc rdi\n  or al, 32        ; I couldn't get tolower to work for whatever reason, so here's my hack\n  cmp al, 'x'\n  jne .loop_checkO\n  inc ecx\n  jmp .loop_cond\n.loop_checkO:\n  cmp al, 'o'\n  jne .loop_cond\n  dec ecx\n  jmp .loop_cond\n.ret:\n  test ecx, ecx\n  setz cl\n  movzx rax, cl\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212499,"user_id":null,"body":"SECTION .text\nglobal xo\n\n\nxo:  \n  xor rcx, rcx ;clear rcx register\n  xor rax, rax\n  \nget_new_value:\n  mov r8b, BYTE [rdi]\n  test r8, r8\n  jz finish\n  \n  and r8, 11011111b ; to lowercase\n  \ntest_x:\n  cmp r8, 88\n  jne test_o\n  \n  inc rax\n  jmp next\n  \ntest_o:\n  cmp r8, 79\n  jne next\n  \n  dec rax\n  \nnext:\n  inc rdi\n  jmp get_new_value\n  \nfinish:\n  sub rax, 1\n  sbb rax, rax\n  and rax, 1\n  \n  ret\n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212500,"user_id":null,"body":"SECTION .text\nglobal xo\nxo:\n  mov rcx,-1\n  mov rax,1\n  loop1:\n  inc rcx\n  mov bl,[rdi+rcx]\n  cmp bl,'x'\n  jne skipx\n  inc rax\n  skipx:\n  cmp bl,'X'\n  jne skipx2\n  inc rax\n  skipx2:\n  cmp bl,'o'\n  jne skipo\n  dec rax\n  skipo:\n  cmp bl,'O'\n  jne skipo2\n  dec rax\n  skipo2:\n  cmp bl,0\n  jne loop1\n  cmp rax,1\n  jne false1\n  jmp end\n  false1:\n  xor rax,rax\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212501,"user_id":null,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor eax, eax\n.loop:\n  mov dl, [rdi]\n  test dl, dl\n  je .done\n  and edx, -33\n  cmp dl, 88\n  jne .notx\n  inc rax\n  jmp .next\n.notx:\n  cmp dl, 79\n  jne .next\n  dec rax\n.next:\n  inc rdi\n  jmp .loop\n.done:\n  test rax, rax\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212502,"user_id":null,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor ecx, ecx\n  xor edx, edx\n  \n.loop:\n  mov al, [rdi]\n  inc rdi\n  cmp al, 'X'\n  je .x\n  cmp al, 'x'\n  je .x\n  cmp al, 'O'\n  je .o\n  cmp al, 'o'\n  je .o\n  test al, al\n  jnz .loop\n  \n  cmp ecx, edx\n  sete al\n  ret\n  \n.x:\n  inc ecx\n  jmp .loop\n\n.o:\n  inc edx\n  jmp .loop\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212503,"user_id":null,"body":"SECTION .text\nglobal xo\n\n; bool xo(const char *str)\n; str: rdi\nxo:\n    push rbp\n    mov rbp, rsp\n    \n    xor r8, r8  ; num_o: r8\n    xor r9, r9  ; num_x: r9\n    xor rcx, rcx\n.l0:\n    mov al, [rdi + rcx]\n    cmp al, 0\n    je .exit_loop\n    \n    cmp al, 'a'\n    jge .next\n    add al, 32\n.next:    \n    cmp al, 'o'\n    jne .l1\n    inc r8\n    jmp .l2\n.l1:\n    cmp al, 'x'\n    jne .l2\n    inc r9\n.l2:\n    inc rcx\n    jmp .l0\n.exit_loop:\n    cmp r8, r9\n    jne .false\n    mov rax, 1\n    jmp .end\n.false:\n    xor rax, rax\n.end:\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212504,"user_id":173,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor rcx, rcx\n  xor rdx, rdx\n@next:\n  cmp byte [rdi], 0\n  je @end\n  cmp byte [rdi], 'x'\n  je @incx\n  cmp byte [rdi], 'X'\n  je @incx\n  cmp byte [rdi], 'o'\n  je @inco\n  cmp byte [rdi], 'O'\n  je @inco\n  inc rdi\n  jmp @next\n@end:\n  cmp rcx, rdx\n  je @true\n  mov rax, 0\n  ret\n@true:\n  mov rax, 1\n  ret\n@incx:\n  inc rcx\n  inc rdi\n  jmp @next\n@inco:\n  inc rdx\n  inc rdi\n  jmp @next","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212505,"user_id":null,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor rax, rax\n  xor rdx, rdx\nloop:\n  mov cl, byte [rdi]\n  test cl, cl\n  jz return\n  or cl, 32\n  cmp cl, 'x'\n  setz dh\n  add al, dh\n  cmp cl, 'o'\n  setz dh\n  add dl, dh\n  inc rdi\n  jmp loop\nreturn:\n  cmp dl, al\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212506,"user_id":null,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor rax, rax\n  xor rdx, rdx\n  xor rsi, rsi\nloop:\n  mov cl, byte [rdi]\n  cmp cl, sil\n  jz return\n  or cl, 32\n  cmp cl, 'x'\n  setz dh\n  add al, dh\n  cmp cl, 'o'\n  setz dh\n  add dl, dh\n  inc rdi\n  jmp loop\nreturn:\n  cmp dl, al\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212507,"user_id":null,"body":"SECTION .text\nglobal xo\n\nxo:\n  xor edx,edx\nfind:\n  mov al,byte[rdi]\n  test al,al\n  jz end\n  or al, 32\n  cmp al, 'o'\n  sete cl\n  sub edx,ecx\n  cmp al,'x'\n  sete cl\n  add edx,ecx\n  inc rdi\n  jmp find\nend:\n  test edx,edx\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5592e3bd57b64d00f3000047":[{"id":212508,"user_id":168,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n  cvtsi2sd xmm0, rdi\n  sqrtsd xmm0, xmm0\n  addsd xmm0, xmm0\n  sqrtsd xmm0, xmm0\n  cvttsd2si ecx, xmm0\n  lea eax, [ecx + 1]\n  imul rax, rax\n  imul rax, rcx\n  imul rax, rcx\n  shr rax, 2\n  cmp rax, rdi\n  mov rax, -1\n  cmove rax, rcx\n  ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212509,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n; RAX n^3 RBX n RDI m\n        xor rax, rax ; RAX <- the result\n        push rbx\n        xor rbx, rbx\n.lp:    cmp rdi, rax\n        jz .true\n        jb .false\n        sub rdi, rax\n        inc rbx\n        mov rax, rbx\n        mul ebx\n        mul ebx\n        shl rdx, 32\n        or rax, rdx\n        jmp .lp\n.false: mov rax, -1\n        pop rbx\n        ret\n.true:  mov rax, rbx\n        pop rbx\n        ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212510,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n  xor rax, rax      ; RAX <- the result\n  xor rbx, rbx\n  \n  l: \n    inc rax\n    \n    mov rcx, rax\n    imul rcx, rax\n    imul rcx, rax\n    add rbx, rcx\n    \n    cmp rbx, rdi\n    jl l\n  \n  cmp rbx, rdi\n  je end\n  mov rax, 0xffffffffffffffff\n  end:\n    ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212511,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n    xor rcx, rcx\n    xor rbx, rbx\n    .loop:\n        inc rcx\n        \n        ; rax <- rcx ** 3\n        mov rax, rcx\n        mul rcx\n        mul rcx\n\n        add rbx, rax\n\n        ; repeat while rbx < rdi\n        cmp rbx, rdi\n        jl .loop\n\n        jne .invalid\n        ; do only if rbx == rdi\n        mov rax, rcx\n        ret\n\n        ; do only if rbx != rdi\n    .invalid:\n        mov rax, -1\n        ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212512,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n  cvtsi2sd xmm0, rdi\n  movsd xmm1, [.one]\n  mov rdx, -1\n  sqrtsd xmm0, xmm0\n  mulsd xmm0, [.eight]\n  addsd xmm0, xmm1\n  sqrtsd xmm0, xmm0\n  subsd xmm0, xmm1\n  mulsd xmm0, [.half]\n  cvttsd2si rax, xmm0\n  roundsd xmm1, xmm0, 11\n  subsd xmm0, xmm1\n  xorps xmm1, xmm1\n  comisd xmm0, xmm1\n  cmovne rax, rdx\n  ret\n  \nsection .data\n.eight: dq 8.0\n.one: dq 1.0\n.half: dq 0.5\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212513,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n    push rbp\n    mov rbp, rsp\n    push rbx\n    push rdx\n    push rdi\n    ; rdi param\n    mov rbx, 0 ; result\nloop:\n    cmp rdi, 0\n    je correct\n    jl wrong\n    add rbx, 1\n    mov rax, rbx\n    mul rbx\n    mul rbx ; ^3\n    sub rdi, rax\n    jmp loop\nwrong:\n    mov rax, -1\n    jmp end_loop\ncorrect:\n    mov rax, rbx\nend_loop:  \n    pop rdi\n    pop rdx\n    pop rbx\n    pop rbp\n    ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212514,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n  mov ebx, 0x8000\n  xor rcx, rcx\nC:or rcx, rbx\n  mov eax, ecx\n  mov esi, ecx\n  inc eax\n  mul esi\n  shr eax, 1\n  mov esi, eax\n  mul esi\n  shl rdx, 32\n  add rax, rdx\n  cmp rax, rdi\n  jne A\n  mov rax, rcx\n  ret\nA:jl B\n  xor rcx, rbx\nB:shr ebx, 1\n  test ebx, ebx\n  jnz C\n  mov rax, -1\n  ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212515,"user_id":null,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n    xor rax, rax      ; RAX <- the result\n    xor edx, edx\n    .loop:\n        inc rax\n        mov rcx, rax\n        imul rcx, rax\n        imul rcx, rax\n        add rdx, rcx\n        cmp rdx, rdi\n        je .success\n        jg .failure\n        jmp .loop\n    .success:\n        ret\n    .failure:\n        mov rax, -1\n        ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212516,"user_id":50,"body":"global find_nb\n\nsection .text\n\n; <----- long find_nb(long long m) ----->\nfind_nb:\n    xor rax, rax\n    xor r8,r8 ; S\n    mov  r9,1 ; n\n_loop:\n    cmp r8,rdi\n    jge _exit\n    mov rax,r9\n    mul r9\n    mul r9\n    inc r9\n    add r8,rax\n    jmp _loop\n_exit:\n    cmp r8,rdi\n    jne _retMinusOne\n    mov rax, r9\n    dec rax\n    ret\n_retMinusOne:\n    mov rax,-1\n    ret\n; ---------> end of findnb <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212517,"user_id":null,"body":"global find_nb\n\nsection .text\n\nfind_nb:\n    xor r8, r8\n    xor r9, r9\nsum:\n    inc r9\n    mov rax, r9\n    imul rax, r9\n    imul rax, r9\n    add r8, rax\n    mov rax, -1\n    cmp r8, rdi\n    jl sum\n    jg end\n    mov rax, r9\nend:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559536379512a64472000053":[{"id":212518,"user_id":null,"body":"global play_pass\nextern malloc, strlen\n\nsection .text\n\n; <--- char *play_pass(const char *phr, int shf) --->\nplay_pass:\n  push r12\n  mov r12d, esi\n  push rbp\n  mov rbp, rdi\n  push rbx\n  call strlen\n  lea rdi, [rax+1]\n  mov rbx, rax\n  call malloc\n  xor ecx, ecx\n  mov r8d, 26\n  mov r9b, 105\n  lea rdi, [rax+rbx]\n  mov rsi, rax\n  mov byte [rdi], 0\n.loop:\n  cmp rcx, rbx\n  je .done\n  mov dl, [rbp+0+rcx]\n  mov eax, edx\n  and eax, -33\n  sub eax, 65\n  cmp al, 25\n  jbe .alpha\n  lea eax, [rdx-48]\n  cmp al, 9\n  ja .next\n  mov eax, r9d\n  sub eax, edx\n  mov edx, eax\n  jmp .next\n.alpha:\n  and edx, 223\n  lea eax, [r12-65+rdx]\n  cdq\n  idiv r8d\n  mov rax, rcx\n  and eax, 1\n  cmp rax, 1\n  sbb eax, eax\n  and eax, -32\n  lea edx, [rax+97+rdx]\n.next:\n  mov rax, rcx\n  inc rcx\n  neg rax\n  mov [rdi-1+rax], dl\n  jmp .loop\n.done:\n  pop rbx\n  mov rax, rsi\n  pop rbp\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212519,"user_id":46,"body":"extern malloc\n\nsection .data\n    sLength: dq 0\n\n    isSmall: db 0\n    isCaps: db 0\n\nsection .text\n_strlen:\n    push rcx\n    \n    xor rax, rax\n    _count_loop:\n        mov cl, byte [ rdi + rax ]\n\n        inc rax\n        cmp cl, 0x0\n        jne _count_loop\n\n    dec rax\n    pop rcx\n    ret\n\nglobal play_pass\nplay_pass:\n    call _strlen\n    inc rax\n    push rsi\n    push rdi\n    mov rdi, rax\n    push rax\n    call malloc\n    mov r11, rax\n    pop rax\n    pop rdi\n    pop rsi\n    xor r15, r15\n    _strcpy_loop:\n        mov bl, byte [ rdi + r15 ]\n        mov byte [ r11 + r15 ], bl\n\n        inc r15\n        cmp r15, rax\n        js _strcpy_loop\n    \n    dec rax\n    mov qword [ sLength ], rax\n    xor rdx, rdx\n    mov rbx, 2\n    div rbx\n    xor r15, r15\n    _change_str_loop:\n        mov byte [ isSmall ], 0\n        mov byte [ isCaps ], 0\n        cmp r15, rax\n        js _charac_equals_si\n            mov rbx, qword [ sLength ]\n            sub rbx, r15\n            dec rbx\n            jmp _after_charac_equals_si\n        _charac_equals_si:\n            mov rbx, r15\n        _after_charac_equals_si:\n\n        mov cl, 97\n        cmp cl, byte [ r11 + rbx ]\n        jle _small_first_cond_true\n        jmp _after_small_cond\n        _small_first_cond_true:\n            mov cl, byte [ r11 + rbx ]\n            cmp cl, 122\n            jle _small_second_cond_true\n            jmp _after_small_cond\n            _small_second_cond_true:\n                mov byte [ isSmall ], 1\n        _after_small_cond:\n\n        mov cl, 65\n        mov dl, byte [ r11 + rbx ]\n        cmp cl, dl\n        jle _caps_first_cond_true\n        jmp _after_caps_cond\n        _caps_first_cond_true:\n            mov cl, byte [ r11 + rbx ]\n            cmp cl, 90\n            jle _caps_second_cond_true\n            jmp _after_caps_cond\n            _caps_second_cond_true:\n                mov byte [ isCaps ], 1\n        _after_caps_cond:\n\n        mov cl, byte [ isSmall ]\n        or cl, byte [ isCaps ]\n\n        cmp cl, 1\n        je _is_letter\n        jmp _after_is_letter\n        _is_letter:\n            push rax\n            mov rax, rsi\n            mov rcx, 26\n            xor rdx, rdx\n            div rcx\n            mov rsi, rdx\n            pop rax\n\n            mov cl, byte [ r11 + rbx ]\n            add cl, sil\n\n            cmp cl, 122\n            jg _char_greater_than_z\n            jmp _char_smaller_than_equal_z\n            _char_greater_than_z:\n                mov dl, byte [ isSmall ]\n                cmp dl, 1\n                jne _set_charac_cl\n                mov byte [ r11 + rbx ], cl\n                sub byte [ r11 + rbx ], 26\n                jmp _after_is_letter\n            _char_smaller_than_equal_z:\n                cmp cl, 90\n                jg _char_greater_than_Z\n                jmp _set_charac_cl\n                _char_greater_than_Z:\n                    mov dl, byte [ isCaps ]\n                    cmp dl, 1\n                    jne _set_charac_cl\n                    mov byte [ r11 + rbx ], cl\n                    sub byte [ r11 + rbx ], 26\n                    jmp _after_is_letter\n\n            _set_charac_cl:\n                mov byte [ r11 + rbx ], cl\n\n        _after_is_letter:\n\n        mov dl, 48\n        mov cl, byte [ r11 + rbx ]\n        cmp dl, cl\n        jle _0_less_than_equals_char\n        jmp _after_numeric_transformation\n        _0_less_than_equals_char:\n            cmp cl, 57\n            jle _char_less_than_equals_9\n            jmp _after_numeric_transformation\n            _char_less_than_equals_9:\n                mov dl, byte [ r11 + rbx ]\n                mov byte [ r11 + rbx ], 105\n                sub byte [ r11 + rbx ], dl\n\n        _after_numeric_transformation:\n\n        push rax\n        mov rax, r15\n        mov rcx, 2\n        xor rdx, rdx\n        div rcx\n        pop rax\n\n        cmp rdx, 1\n        je _convert_to_lower\n        mov cl, 97\n        cmp cl, byte [ r11 + rbx ]\n        jle _small_first_cond_true_2\n        jmp _after_case_conversion\n        _small_first_cond_true_2:\n            mov cl, byte [ r11 + rbx ]\n            cmp cl, 122\n            jle _small_second_cond_true_2\n            jmp _after_case_conversion\n            _small_second_cond_true_2:\n                sub byte [ r11 + rbx ], 32\n        jmp _after_case_conversion\n\n        _convert_to_lower:\n            mov cl, 65\n            cmp cl, byte [ r11 + rbx ]\n            jle _caps_first_cond_true_2\n            jmp _after_case_conversion\n            _caps_first_cond_true_2:\n                mov cl, byte [ r11 + rbx ]\n                cmp cl, 90\n                jle _caps_second_cond_true_2\n                jmp _after_case_conversion\n            _caps_second_cond_true_2:\n                add byte [ r11 + rbx ], 32\n        _after_case_conversion:\n\n        cmp r15, rax\n        js _swap\n        jmp _after_swap\n        _swap:\n            mov cl, byte [ r11 + r15 ]\n            mov r13, qword [ sLength ]\n            sub r13, r15\n            dec r13\n            mov dl, byte [ r11 + r13 ]\n            mov byte [ r11 + r15 ], dl\n            mov byte [ r11 + r13 ], cl\n\n        _after_swap:\n\n        inc r15\n        cmp r15, qword [ sLength ]\n        js _change_str_loop\n\n    mov rax, r11\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212520,"user_id":null,"body":"global play_pass\nextern malloc\n\nsection .text\n\n; <--- char *play_pass(const char *phr, int shf) --->\nplay_pass:\n    xor eax, eax\n    xor ecx, ecx\n    mov r8, 26\n    .first_pass:\n        mov al, [rdi+rcx]\n        test rax, rax\n        jz .break\n        cmp al, 'A'\n        jl .nonletter\n        cmp al, 'Z'\n        jg .nonletter\n        lea rax, [rax+rsi-'A']\n        xor edx, edx\n        div r8\n        test rcx, 1\n        jz .upper\n        add rdx, 'a'\n        jmp .cont\n        .upper:\n            add rdx, 'A'\n        .cont:\n            push rdx\n            inc rcx\n            jmp .first_pass\n        .nonletter:\n            cmp al, '0'\n            jl .nondigit\n            cmp al, '9'\n            jg .nondigit\n            mov rdx, '9'\n            sub rdx, rax\n            add rdx, '0'\n            push rdx\n            inc rcx\n            jmp .first_pass\n            .nondigit:\n                push rax\n                inc rcx\n                jmp .first_pass\n    .break:\n    push rdi\n    push rsi\n    push rcx\n    lea rdi, [rcx+2]\n    call malloc\n    pop r8\n    pop rsi\n    pop rdi\n    xor ecx, ecx\n    .second_pass:\n        pop rdx\n        mov [rax+rcx], dl\n        inc rcx\n        cmp rcx, r8\n        jl .second_pass\n    mov [rax+rcx], byte 0\n    ret\n; -----> end of passwdphr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212521,"user_id":null,"body":"global play_pass\nextern malloc\n\nsection .text\n\nstrlen:\n  push rbx\n  push rcx\n  \n  mov rax, 0\n  \n  cmp rdi, 0\n  je strlen_exit\n  \n  mov rbx, rdi\n  \nstrlen_loop:\n  mov rcx, 0\n  mov cl, [rbx]\n  cmp cl, 0\n  je strlen_exit\n  inc eax\n  inc rbx\n  jmp strlen_loop\n  \nstrlen_exit:\n  pop rcx\n  pop rbx\n  ret\n\n\ncircular_shift:\n  mov rax, rdi\n  \n  cmp al, 65\n  jl circular_shift_digits\n  \n  cmp al, 90\n  jg circular_shift_exit\n  \ncircular_shift_check_shift_amount:\n  cmp rsi, 26\n  jl circular_shift_shift_checked\n  sub rsi, 26\n  jmp circular_shift_check_shift_amount\n\ncircular_shift_shift_checked:\n  cmp rsi, 0\n  je circular_shift_exit\n  \n  add rax, rsi\n  \n  \n  cmp al, 65\n  jge check_upper_bound\n  \n  sub rax, 65\n  add rax, 90\n\n  jmp circular_shift_exit\n\ncheck_upper_bound:\n  cmp al, 90\n  jle circular_shift_exit\n  \n  sub rax, 90\n  add rax, 64\n  jmp circular_shift_exit\n  \ncircular_shift_digits:\n  cmp al, 48\n  jl circular_shift_exit\n  cmp al, 57\n  jg circular_shift_exit\n  sub rax, 48\n  neg rax\n  add rax, 57\n\ncircular_shift_exit:\n\n  ret\n\n\nstring_reverse:\n  push rbx\n  push rcx\n  mov rax, rdi\n  mov rbx, 0\n  \nstring_reverse_loop:\n  mov rcx, 0 ; temporary character cleared\n  mov cl, [rax]; reading from input\n  push rcx\n  inc rax\n  inc rbx\n  cmp rbx, rsi\n  jl string_reverse_loop\n  \n  mov rax, rdi\n  mov rbx, 0\nstring_reverse_loop2:\n  pop rcx\n  mov [rax], cl\n  inc rax\n  inc rbx\n  cmp rbx, rsi\n  jl string_reverse_loop2\n  \n  pop rcx\n  pop rbx\n  ret\n\n\n\n; <--- char *play_pass(const char *phr, int shf) --->\nplay_pass:\n    push rbp\n    mov rbp, rsp\n    sub rsp, 64\n    \n    mov [rbp - 8], rdi ; input pointer\n    mov [rbp - 32], rsi; shift amount\n    call strlen\n    mov [rbp - 16], rax ; string length\n    mov rdi, rax\n    inc rdi ; add one more for the termination character\n    call malloc\n    cmp rax, 0 ; check the pointer returnd by malloc\n    je play_pass_exit\n    \n    mov [rbp - 24], rax ; output ptr\n    mov rbx, [rbp - 8]; rbx = input pointer\n    mov rcx, [rbp - 24]; rcx = output pointer\n    mov rdx, 0 ; rdx = interation counter\n    \nplay_pass_loop:\n    mov rdi, [rbx] ; read from input buffer\n    mov rsi, [rbp - 32]\n    call circular_shift\n    ; now al holds the circular handled character\n    mov r8, rdx ; check if the iteration is odd or even\n    and r8, 1\n    cmp r8, 1\n    je odd_position\n    jmp write_characters\n    \nodd_position:\n    cmp al, 65\n    jl write_characters\n    cmp al, 90\n    jg write_characters\n    add al, 32\nwrite_characters:\n    mov [rcx], al\n    inc rcx\n    inc rbx\n    inc rdx\n    cmp rdx, [rbp - 16]\n    jl play_pass_loop\n\n    mov byte [rcx], 0 ; terminating the output string\n    \n    mov rdi, [rbp - 24] ; arg0: output pinter\n    mov rsi, [rbp - 16] ; arg1: length\n    call string_reverse\n    \n    mov rax, [rbp - 24] ; returning the output pointer\n    \nplay_pass_exit:\n    mov rsp, rbp\n    pop rbp\n    ret\n; -----> end of passwdphr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212522,"user_id":168,"body":"global play_pass\nextern strlen, malloc\n\nsection .text\n\n; <--- char *play_pass(const char *phr, int shf) --->\nplay_pass:\n  push rbx\n  push rdi\n  push rsi\n  call strlen\n  mov rbx, rax  ; length\n  lea rdi, [rax + 1]\n  call malloc\n  mov byte [rax + rbx], 0\n  mov r8, rax\n  pop rsi\n  pop rdi\n  mov r9d, 26\n  xor ecx, ecx\n  jmp .loop_cond\n.loop:\n  movzx edx, byte [rdi + rcx]\n  lea eax, [rdx - 'A']\n  cmp al, 25\n  jbe .letter\n  lea eax, [rdx - '0']\n  cmp al, 9\n  ja .continue\n.digit:\n  neg dl\n  add dl, '0' * 2 + 9\n  jmp .continue\n.letter:\n  lea eax, [rax + rsi]\n  xor edx, edx\n  div r9d\n  add dl, 'A'\n  test cl, 1\n  setnz al\n  shl al, 5\n  add dl, al\n.continue:\n  mov byte [r8 + rbx], dl\n  inc rcx\n.loop_cond:\n  sub rbx, 1\n  jae .loop\n.end:\n  mov rax, r8\n  pop rbx\n  ret\n; -----> end of passwdphr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212523,"user_id":null,"body":"global play_pass\nextern malloc\n\nsection .text\n\n; <--- char *play_pass(const char *phr, int shf) --->\nplay_pass:\n    xor rax, rax            ; setting the result pointer to <passwd> to NULL\n    mov rcx, -1             ; the initial value for <len>\n.strlen:\n    inc rcx                 ; incrementing <len>\n    cmp byte [rdi+rcx], 0   ; whether <phr+len> is an empty character\n    jne .strlen             ; otherwise jumping to .strlen\n    test rcx, rcx           ; whether <len> is zero\n    je .exit                ; jumping to exit\n\n    mov eax, esi            ; copying <shf> to EAX\n    mov esi, 26             ; the number of Latin characters\n    xor edx, edx            ; resetting RDX before the division operation\n    div esi                 ; getting the uncircular shift\n    push rcx                ; saving <len> in the stack\n    push rdx                ; saving <shf> in the stack\n    push rdi                ; saving <phr> in the stack\n    mov rdi, rcx            ; copying <len> to RDI to pass to malloc\n    inc rdi                 ; adding an extra space for the null character\n    call malloc             ; allocating memory\n    pop rdi                 ; restoring <phr> from the stack\n    pop rsi                 ; restoring <shf> from the stack\n    pop rcx                 ; restoring <len> from the stack\n    test rax, rax           ; whether the memory is allocated\n    je .exit                ; otherwise, jumping to exit\n    mov byte [rax+rcx], 0   ; copying the null character to the end of <passwd>\n    xor r8b, r8b            ; resetting R8B as <chg> to mark whether a char needs to be lowered\n.loop:\n    test rcx, rcx           ; whether there are characters left\n    je .exit                ; otherwise, jumping to exit\n    dec rcx                 ; decrementing <len>\n    mov dl, [rdi]           ; copying <*phr> to DL as <c> for fast access\n    cmp dl, '0'             ; whether <c> is less\/below than '0'\n    jl .alpha               ; jumping to the .alpha section\n    cmp dl, '9'             ; whether <c> is greater\/above '9'\n    jg .alpha               ; jumping to the .alpha section\n    mov r9b, '9'            ; copying '9' to form complement to nine\n    sub r9b, dl             ; getting the complement\n    add r9b, '0'            ; forming its ASCII code\n    mov dl, r9b             ; saving back in <c>\n    jmp .cpy                ; jumping to the .cpy section\n.alpha:\n    cmp dl, 'A'             ; whether <c> is less\/below than 'A'\n    jl .cpy                 ; jumping to the .cpy section\n    cmp dl, 'Z'             ; whether <c> is greater\/above than 'Z'\n    jg .cpy                 ; jumping to the .cpy section\n    test sil, sil           ; whether the character needs to be shifted\n    je .lwr                 ; otherwise, jumping to the .lwr section\n    add dl, sil             ; applying a character shift\n    cmp dl, 'Z'             ; whether the transformed character is above the range\n    jle .lwr                ; otherwise, jumping to the .lwr section\n    add dl, 'A'             ; adding the initial ASCII uppercase letter code to <c>\n    sub dl, 'Z'             ; subtracting the difference from the last ASCII uppercase letter code\n    dec dl                  ; decrementing to get the appropriate ASCII code\n.lwr:\n    test r8b, r8b           ; whether the character needs to be lowered\n    je .cpy                 ; otherwise, jumping to the .cpy section\n    add dl, ' '             ; lowering <c>\n.cpy:\n    mov [rax+rcx], dl       ; copying <c> to <passwd-len-1>\n    test r8b, r8b           ; testing <chg> to apply logical negation\n    sete r8b                ; negating <chg> logically\n    inc rdi                 ; pointing <phr> to the next character\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    ret\n; -----> end of passwdphr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559a28007caad2ac4e000083":[{"id":212524,"user_id":527,"body":"global perimeter\n\nsection .text\n\n; unsigned long long perimeter(int n)\nperimeter:\n                mov     eax, 4\n                mov     edx, 8\n.loop:          mov     rcx, rdx\n                add     rdx, rax\n                mov     rax, rcx\n                dec     edi\n                jns     .loop\n                sub     rax, 4\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212525,"user_id":null,"body":"global perimeter\n\nsection .text\n\n; <--   unsigned long long perimeter(int n) -->\n; n := edi\nperimeter:\n    mov   rdx, 1\n    mov   rax, 2\n.loop:\n    dec   edi\n    jz    .end\n    lea   rcx, [rax+rdx+1]\n    mov   rdx, rax\n    mov   rax, rcx\n    jmp   .loop\n.end:\n    shl   rax, 2\n    ret\n;<--    end of perimeter -->","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212526,"user_id":null,"body":"global perimeter\n\nsection .text\n\n      ; <--   unsigned long long perimeter(int n) -->\n      ; n := edi\nperimeter:\n  xor rax, rax     ; rax, the result\n    \n  mov rax, 0\n  mov rbx, 1\n  mov rcx, 1\n  inc edi\n  l:\n    add rax, rbx\n    mov rdx, rbx\n    mov rbx, rcx\n    add rcx, rdx\n    dec edi\n    cmp edi, 0\n    jne l\n  mov rdx, 4\n  mul rdx\n  ret\n;<--    end of perimeter -->","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212527,"user_id":null,"body":"global perimeter\nextern pow\nsection .text\n\n      ; <--   unsigned long long perimeter(int n) -->\n      ; n := edi\nperimeter:\n  push r15\n  lea r15d, [rdi+1]\n  test r15d, r15d\n  push r14\n  push r13\n  push r12\n  push rbp\n  push rbx\n  jle .done\n  mov edi, 1\n  xor r13d, r13d\n  mov ecx, 1\n  xor eax, eax\n  mov qword [rsp-32], 1\n  mov esi, 1\n  mov r9d, 1\n  mov qword [rsp-24], 1\n.loop:\n  mov rbp, rax\n  lea r11, [rax+r9]\n  lea rdx, [rsi+rcx]\n  sub r9, rcx\n  sub rbp, rsi\n  test r15b, 1\n  lea r10, [rax+rcx]\n  je .even\n  mov r12, [rsp-24]\n  mov rbx, rdi\n  mov r14, r13\n  imul rbx, r11\n  mov r8, r12\n  imul r14, rdx\n  add r12, r13\n  sub r8, rdi\n  imul r12, rbp\n  imul r8, rax\n  mov [rsp-16], rbx\n  mov rbx, [rsp-32]\n  sub rbx, r13\n  mov [rsp-8], r12\n  mov r12, [rsp-16]\n  mov [rsp-24], r8\n  imul rbx, rcx\n  lea r8, [r13+rdi]\n  mov r13, QWORD [rsp-32]\n  imul r8, r10\n  add r13, rdi\n  mov rdi, QWORD [rsp-24]\n  imul r13, r9\n  add r13, r8\n  add r13, rbx\n  add rbx, r14\n  sub r13, r12\n  add r12, rdi\n  mov [rsp-32], rbx\n  sub rdi, r14\n  mov rbx, [rsp-8]\n  mov [rsp-24], r12\n  add rdi, r8\n  sub rdi, rbx\n.even:\n  mov r8, rax\n  mov r12, rcx\n  mov rbx, rax\n  sub rsi, rax\n  imul r12, r11\n  imul rbx, rdx\n  imul r8, r9\n  imul r10, r10\n  imul rdx, r9\n  imul rsi, rcx\n  lea r9, [r8+r12]\n  imul r11, rbp\n  add r8, r10\n  add rdx, r10\n  sub r8, rbx\n  add rdx, rsi\n  mov rcx, r8\n  add rsi, rbx\n  mov rax, rdx\n  sub rcx, r11\n  sub rax, r12\n  sar r15d, 1\n  jne .loop\n  pop rbx\n  lea rax, [rdi*4-4]\n  pop rbp\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  ret\n.done:\n  pop rbx\n  xor eax, eax\n  pop rbp\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212528,"user_id":null,"body":"global perimeter\nsection .text\nperimeter:\n  mov ecx,1\n  xor rax,rax\n  xor rdx,rdx\n  @b:add  rax,rcx\n     xadd rcx,rdx\n     dec  rdi\n  jns @b\n  shl rax,2\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212529,"user_id":168,"body":"global perimeter\n\nsection .text\n\nperimeter:\n  mov eax, 1\n  mov edx, 1\n  inc edi\n.loop:\n  xadd rax, rdx\n  dec edi\n  jnz .loop\n  lea rax, [4 * rax - 4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212530,"user_id":527,"body":"global perimeter\n\nsection .text\n\n; unsigned long long perimeter(int n)\nperimeter:\n                mov     eax, 4\n                mov     edx, 8\n.loop:          xadd    rdx, rax\n                dec     edi\n                jns     .loop\n                sub     rax, 4\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212531,"user_id":50,"body":"global perimeter\n\nsection .text\n\n      ; <--   unsigned long long perimeter(int n) -->\n      ; n := edi\nperimeter:\n  mov rax, 1\n  mov rdx, 1\n  mov ecx, edi\n  inc ecx\n_loop:\n  add rdx, rax\n  xchg rax, rdx\n  loop _loop\n_exit:\n  dec rax\n  shl rax, 2\n  ret\n;<--    end of perimeter -->","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559cc2d2b802a5c94700000c":[{"id":212532,"user_id":null,"body":"section .text\nglobal consecutive\n\n; int consecutive(const int arr[], size_t sz)\n; Calculates the count of missing numbers in the array.\n; No numbers are missing if all numbers min..max are in the array.\n; CONDITION: No number is double in the array.\nconsecutive:\n  xor eax, eax\n  cmp rsi, 1\n  jle .exit               ; less than 2 items in array: 0 missing\n  cld                     ; read array upwards\n  lea r8, [rdi+4*rsi]     ; r8 := end of array address, first behind last item\n  xchg rsi, rdi           ; rsi := array, rdi := size\n  lodsd\n  mov ecx, eax            ; ecx := min of array items (up to current item)\n  mov edx, eax            ; edx := max of array items\n.loop:\n  lodsd\n  cmp ecx, eax\n  cmovg ecx, eax          ; found new min\n  cmp edx, eax\n  cmovl edx, eax          ; found new max\n  cmp rsi, r8\n  jl .loop                ; repeat while rsi before end of array\n  mov eax, edx\n  sub eax, ecx\n  inc eax                 ; eax := (max-min)+1, items needed\n  sub eax, edi            ; eax := missing items\n.exit:  \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212533,"user_id":null,"body":"section .text\nglobal consecutive\nconsecutive:   ; int consecutive(const int arr[], size_t sz)\n  xor eax, eax\n  test rsi, rsi\n  je .done\n  mov ecx, [rdi]\n  mov edx, 1\n  mov eax, ecx\n.loop:\n  cmp rdx, rsi\n  je .end\n  mov r8d, dword [rdi+rdx*4]\n  cmp r8d, eax\n  jg .newh\n  cmp ecx, r8d\n  cmovg ecx, r8d\n  mov r8d, eax\n.newh:\n  inc rdx\n  mov eax, r8d\n  jmp .loop\n.end:\n  sub eax, ecx\n  sub edx, 2\n  sub eax, edx\n  dec eax\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212534,"user_id":null,"body":"section .text\nglobal consecutive\nconsecutive:   ; int consecutive(const int arr[], size_t sz)\n  test esi, esi\n  jz .bailout\n  \n  mov ecx, esi\n  mov r8d, [rdi]\n  mov r9d, [rdi]\n  \n.loop:\n  add rdi, 4\n  dec ecx\n  jz .done\n  mov eax, [rdi]\n  cmp r8d, eax\n  cmovg r8d, eax\n  cmp r9d, eax\n  cmovl r9d, eax\n  jmp .loop\n  \n.done:\n  mov eax, r9d\n  sub eax, r8d\n  sub eax, esi\n  inc eax\n  ret\n  \n.bailout:\n  xor eax, eax\n  ret\n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212535,"user_id":null,"body":"global consecutive\nconsecutive:   ; int consecutive(const int arr[], size_t sz)\n    xor eax, eax\n    mov ecx, esi\n    dec ecx\n    jle .end\n    mov edx, [rdi]\n    mov eax, edx\n.mloop:\n    cmp edx, [rdi+4*rcx]\n    cmovg edx, [rdi+4*rcx]\n    cmp eax, [rdi+4*rcx]\n    cmovl eax, [rdi+4*rcx]\n    loop .mloop\n    lea ecx, [edx+esi-1]\n    sub eax, ecx\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212536,"user_id":null,"body":"section .text\nglobal consecutive\n; <--- int {eax} consecutive(const {rdi} int arr[], {rsi} size_t sz) --->\nconsecutive:\n      xor eax, eax\n      cmp rsi, 2\n      jl end\n      mov edx, [rdi+4*(rsi-1)]\n      mov r8d, edx\n      mov r9d, edx\n      lea rcx, [rsi-1]\nlp:   mov edx, [rdi+4*(rcx-1)]\n      cmp r8d, edx\n      cmovg r8d, edx\n      cmp r9d, edx\n      cmovl r9d, edx\n      loop lp\n      lea eax, [r9d+1]\n      sub eax, r8d\n      sub eax, esi\nend:  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212537,"user_id":null,"body":"section .text\nglobal consecutive\n; <--- int {eax} consecutive(const {rdi} int arr[], {rsi} size_t sz) --->\nconsecutive:\n      xor eax, eax\n      cmp rsi, 2\n      jl end\n      dec rsi\n      mov edx, [rdi+4*rsi]\n      mov [min], edx\n      mov [max], edx\n      mov rcx, rsi\nlp:   mov edx, [rdi+4*(rcx-1)]\n      cmp [min], edx\n      jl j1\n      mov [min], edx\nj1:   cmp [max], edx\n      jg j2\n      mov [max], edx\nj2:   loop lp\n      mov eax, [max]\n      sub eax, [min]\n      sub eax, esi\nend:  ret\n\nsection .bss\nmin   resd 1\nmax   resd 1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212538,"user_id":null,"body":"section .text\nglobal consecutive\nconsecutive:   ; int consecutive(const int arr[], size_t sz)\n  mov rcx, rsi\n  xor eax, eax\n  cmp esi, 1\n  jb .done\n  \n  mov eax, [rdi]\n  mov edx, eax\n.find_min_and_max:\n  dec rcx\n  js .calculate\n  mov r8d, [rdi]\n  cmp eax, r8d\n  cmovl eax, r8d\n  cmp edx, r8d\n  cmovg edx, r8d\n  add rdi, 4\n  jmp .find_min_and_max\n.calculate:\n  sub eax, edx\n  sub eax, esi\n  inc eax\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212539,"user_id":null,"body":"section .text\nglobal consecutive\nconsecutive:\n    cmp rsi,2\n    jge @go\n    xor rax,rax\n    ret    \n\n@go:xor r8,r8             ; Current max \n    mov r9d,2147483647    ; Current min\n    lea rcx,[rsi -1]\n    \n@main: \n    mov eax,[rdi + rcx * 4]\n    cmp eax,r8d\n    cmovg r8d,eax\n    cmp eax,r9d\n    cmovl r9d,eax\n    dec ecx\n    jns @main\n    \n    sub r8,r9 ; Entries needed is (max - min) +1\n    inc r8\n    sub r8,rsi\n    mov rax,r8\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212540,"user_id":168,"body":"section .text\nglobal consecutive\n\n; int consecutive(const int arr[], size_t sz)\nconsecutive:\n  xor eax, eax\n  sub rsi, 1\n  jbe .end\n  mov r8, rsi\n  mov eax, dword [rdi + 4 * rsi]\n  mov ecx, dword [rdi + 4 * rsi]\n  jmp .loop_cond\n.loop:\n  mov edx, dword [rdi + 4 * rsi]\n  cmp edx, eax\n  cmovg eax, edx\n  cmp edx, ecx\n  cmovl ecx, edx\n.loop_cond:\n  sub rsi, 1\n  jae .loop\n  add ecx, r8d\n  sub eax, ecx\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212541,"user_id":1315,"body":"section .text\nglobal consecutive\nconsecutive:   ; int consecutive(const int arr[], size_t sz)\n  test  rsi, rsi\n  jz    return_zero\n  mov   ebx, 0x7FFFFFFF\n  mov   eax, 0x80000000\n  xor   rcx, rcx\nloop_begin:\n  mov   edx, [rdi + 4 * rcx]\n  cmp   edx, ebx\n  cmovl ebx, edx\n  cmp   edx, eax\n  cmovg eax, edx\n  inc   rcx\n  cmp   rcx, rsi\n  jl    loop_begin\n  sub   eax, ebx\n  sub   eax, esi\n  inc   eax\n  ret\nreturn_zero:\n  xor   eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55a2d7ebe362935a210000b2":[{"id":212542,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov      eax, [rdi]\n  \n  .loop\n  dec      esi\n  cmp      eax, [rdi+rsi*4]\n  cmovg    eax, [rdi+rsi*4]\n  cmp      esi, 0\n  jne      .loop\n  \n  ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212543,"user_id":null,"body":"global find_smallest_int\n\nsection .text\n\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n    mov eax, [rdi]            ; copying <*array> to EAX as <min>\n.loop:\n    dec esi                   ; decrementing <size> to exclude self-comparing\n    test esi, esi             ; whether <size> is greater than zero\n    jle .exit                 ; otherwise, jumping to exit\n    cmp eax, [rdi+rsi*4]      ; whether <min> is greater than <*(array+size)>\n    cmovg eax, [rdi+rsi*4]    ; setting <mim> to <*(array+size)>\n    jmp .loop                 ; jumping to the next iteration\n.exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212544,"user_id":17,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov eax, 0x7FFFFFFF\n.loop:\n  cmp esi, 0\n  jle .end\n  cmp dword [rdi], eax\n  cmovl eax, dword [rdi]\n  dec esi\n  add rdi, 4\n  jmp .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212545,"user_id":50,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  xor rax,0x7fffffff ; int max\n  mov eax,[rdi] ; load first value in the array\n  xor rcx,rcx ; clean rcx upper bits??? seems useless...\n  mov ecx,esi\n_parse:\n  cmp eax,[rdi+4*(rcx-1)]\n  jg _update\n  loop _parse\n  jmp _exit\n_update:\n  mov eax,[rdi+4*(rcx-1)]\n  loop _parse\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212546,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov ecx, esi\n  mov edx, 1<<31-1\n\n  .loop:\n    mov eax, [rdi]\n    add rdi, 4\n    cmp eax, edx\n    cmovl edx, eax\n    loop .loop\n  \n  mov eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212547,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov eax, DWORD [rdi]\n  mov rcx, rsi\n.loop:\n  cmp rcx, 0\n  jz  .quit\n  cmp eax, DWORD [rdi]\n  jl  .L1\n  mov eax, DWORD [rdi]\n.L1:\n  dec rcx\n  add rdi, 4\n  jmp .loop\n\n.quit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212548,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov eax,[rdi+rsi*4-4]\n  loop1:\n  cmp eax,[rdi+rsi*4-4]\n  jl skip\n  mov eax,[rdi+rsi*4-4]\n  skip:\n  dec rsi\n  jnz loop1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212549,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov DWORD eax, [rdi]\n.loop:\n  dec esi\n  jz .exit\n  add rdi, 4\n  cmp DWORD eax, [rdi]\n  cmovg eax, [rdi]\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212550,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov eax, [rdi]\n  mov ecx, 0\nloop_start:\n  cmp eax, [rdi]\n  cmovg eax, [rdi]\n  inc ecx\n  add rdi, 4\n  cmp ecx, esi\n  jne loop_start\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212551,"user_id":null,"body":"section .text\n\nglobal find_smallest_int\n; int find_smallest_int(int *array, int size)\nfind_smallest_int:\n  mov eax, 0x7fffffff\n  loop:\n  mov ebx, [rdi]\n  dec rsi\n  add rdi, 4\n  cmp eax, ebx\n  cmovg eax, ebx\n  cmp rsi, 0\n  jne loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55a5c82cd8e9baa49000004c":[{"id":212552,"user_id":null,"body":"section .text\nglobal divcnt\n\ndivcnt:\n  mov r8, rdx\n  xor rdx, rdx\n  mov rax, rdi\n  div r8\n  mov rdi, rax\n  cmp rdx, 0\n  jng divcnt.lb_end\n  inc rdi\n.lb_end:\n\n  xor rdx, rdx\n  mov rax, rsi\n  div r8\n  mov rsi, rax\n\n  cmp rsi, rdi\n  jb divcnt.zero\n  mov rax, rsi\n  sub rax, rdi\n  inc rax\n  jmp divcnt.end\n.zero:\n  mov rax, 0\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212553,"user_id":null,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n    xor rax, rax            ; RAX <- the result\n    \n    mov rax, rdi\n    mov rcx, rdx\n    xor rdx, rdx\n    div rcx\n    cmp rdx, 0\n    je .first\n    inc rax\n    mul rcx\n    mov rbx, rax\n    jmp .comp\n\n.first:\n    mov rbx, rdi  ; first\n.comp:\n    cmp rsi, rbx\n    jb .raz\n    sub rsi, rbx\n    mov rax, rsi\n    xor rdx, rdx\n    div rcx\n    inc rax\n\n    jmp .end\n.raz:\n    mov rax, 0\n.end:\n    ret\n; -----> endof divcnt <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212554,"user_id":null,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n  mov rcx, rdx\n  mov rax, rsi\n  xor edx, edx\n  div rcx\n  xor edx, edx\n  mov rsi, rax\n  mov rax, rdi\n  div rcx\n  sub rsi, rax\n  cmp rdx, 1\n  adc rsi, 0\n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212555,"user_id":76,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n    ; add y \/ k\n    mov rax, rsi\n    mov r8, rdx\n    xor rdx, rdx\n    div r8\n    mov r9, rax\n    ; subtract x \/ k\n    mov rax, rdi\n    xor rdx, rdx\n    div r8\n    sub r9, rax\n    mov rax, rdi\n    xor rdx, rdx\n    div r8\n    mov rax, r9\n    ; add 1 if x % k == 0\n    test rdx, rdx\n    jnz .ret\n    inc rax\n.ret:\n    ret\n; -----> endof divcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212556,"user_id":null,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n  mov rcx, rdx\n  mov rax, rsi\n  xor edx, edx\n  div rcx\n  test rdi, rdi\n  jz .fromzero\n  mov rsi, rax\n  \n  lea rax, [rdi-1]\n  xor edx, edx\n  div rcx\n  neg rax\n  add rax, rsi\n  ret\n  \n.fromzero:\n  inc rax\n  ret\n; -----> endof divcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212557,"user_id":50,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n  mov rax,rsi\n  mov rbx,rdx  ; save k\n  xor rdx,rdx\n  div rbx ; y\/k\n  mov rcx,rax ; save in rcx\n  mov rax,rdi\n  xor rdx,rdx\n  div rbx ; x\/k, remainder in rdx\n  sub rax,rcx\n  neg rax\n  test rdx,rdx\n  jz _inc\n  ret\n_inc:\n  inc rax\n  ret\n; -----> endof divcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212558,"user_id":null,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n    mov r8, rdx     ; R8 = divisor\n    xor rcx, rcx    ; RCX will hold [1..x)\n    not rcx\n    test rdi, rdi\n    jz .x_zero      ; But if X=0 then this set is empty\n    dec rdi\n    mov rax, rdi\n    xor rdx, rdx\n    div r8          ; amount of divisible numbers in [1..x-1] i.e. [1..x)\n    mov rcx, rax    ; in RCX\n.x_zero:\n    mov rax, rsi\n    xor rdx, rdx\n    div r8          ; amount of divisible numbers in [1..y]\n    sub rax, rcx    ; remove the bottom set\n    ret\n; -----> endof divcnt <-----\n\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212559,"user_id":77,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n    mov rcx, rdx\n    lea rax, [rsi+1]\n    sub rax, rdi\n    xor rdx, rdx\n    div rcx\n    mov rbx, rax\n    mov rax, rdi\n    xor rdx, rdx\n    div rcx\n    test rdx, rdx\n    cmovz rdx, rcx\n    mov rdi, rdx\n    lea rax, [rsi+1]\n    xor rdx, rdx\n    div rcx\n    test rdx, rdx\n    cmovz rdx, rcx\n    cmp rdx, rdi\n    adc rbx, 0\n    mov rax, rbx\n    ret\n; -----> endof divcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212560,"user_id":null,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n    mov rax, rsi            ; RAX <- the result\n    mov rcx, rdx\n    xor rdx, rdx\n    idiv rcx\n    cmp rdi, 0\n    jne @cont\n    inc rax\n    ret\n@cont:\n    mov r11, rax\n    dec rdi\n    mov rax, rdi\n    xor rdx, rdx\n    idiv rcx\n    sub r11, rax\n    mov rax, r11\n    ret\n; -----> endof divcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212561,"user_id":null,"body":"global divcnt\n\n; <-- RAX divcnt(RDI x, RSI y, RDX k) -->\ndivcnt:\n    push rbx\n    mov rbx, rdx\n    mov rax, rsi\n    xor rdx, rdx\n    div rbx\n    mov rsi, rax\n    mov rax, rdi\n    xor rdx, rdx\n    div rbx\n    sub rsi, rax\n    xor rax, rax\n    test rdx, rdx\n    sete al\n    add rax, rsi\n    pop rbx\n    ret\n; -----> endof divcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55a70521798b14d4750000a4":[{"id":212562,"user_id":1277,"body":"SECTION .rodata\nformatStr:\n            db \"Hello, %s how are you doing today?\", 0\n\nSECTION .text\nglobal greet\nextern asprintf\n\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\ngreet:\n            sub  rsp, 8         ; Allocate space to hold a char* (and align the stack for upcoming function call)\n            mov  rdx, rdi       ; arg2 = The name to greet.\n            mov  rsi, formatStr ; arg1 = The format string.\n            mov  rdi, rsp       ; arg0 = The address of the allocated char*\n            call asprintf       ; call asprintf\n            pop  rax            ; pop the char* off the stack\n            ret                 ; return the char*","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212563,"user_id":null,"body":"global greet\nextern asprintf\n\n; <-- [byte RAX] greet(ro [byte RDI] name) -->\ngreet:\n    mov rdx, rdi            ; pointing RDX to <name>\n    mov rsi, .fmt           ; pointing RSI to <.fmt>\n    lea rdi, [rsp-0h8]      ; setting RDI to the address where to store the greet\n    push rdi                ; saving <greet> onto the stack\n    call asprintf           ; allocating and formatting <greet>\n    pop rax                 ; restoring <greet> from the stack\n    ret\n\n; local read-only storage\n.fmt:\n    db    `Hello, %s how are you doing today?\\0`\n; -----> endof greet <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212564,"user_id":null,"body":"SECTION .data\nmsg: db \"Hello, %s how are you doing today?\", 0\nbuf: dq 0\n\nSECTION .text\nglobal greet\nextern asprintf\n\ngreet:\n  xor rax, rax\n  mov rdx, rdi\n  mov rdi, buf\n  mov rsi, msg\n  call asprintf\n  mov rax, [buf]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212565,"user_id":null,"body":"SECTION .text\nglobal greet\nextern asprintf\n\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\ngreet:\n  push rax\n  mov rdx, rdi\n  lea rsi, [.str]\n  mov rdi, rsp\n  xor eax, eax\n  call asprintf\n  mov rax, [rsp]\n  pop rcx\n  ret\n.str: db \"Hello, %s how are you doing today?\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212566,"user_id":null,"body":"section .data\nfmt: db 'Hello, %s how are you doing today?', 0\n\nsection .text\nglobal greet\nextern asprintf\n\ngreet:\n  push rax      ; grow stack to hold return (and align to 16 byte boundary)\n  mov  rdx, rdi ; 3rd arg: name\n  mov  rdi, rsp ; 1st arg: top of stack\n  mov  rsi, fmt ; 2nd arg: format string\n  xor  eax, eax ; clear al\n  call asprintf\n  pop  rax      ; pop return into RAX\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212567,"user_id":null,"body":"SECTION .text\nglobal greet\nextern asprintf\n\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\ngreet:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 0x10\n  mov rdx, rdi\n  mov rsi, fmt\n  lea rdi, [rbp - 0x8]\n  call asprintf\n  mov rax, [rbp - 0x8]\n  leave\n  ret\n  \nSECTION .data\nfmt db \"Hello, %s how are you doing today?\", 0x0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212568,"user_id":null,"body":"SECTION .rodata\n  format: db \"Hello, %s how are you doing today?\",0\nSECTION .bss\n  say: resb 100\nSECTION .text\nglobal greet\nextern asprintf\n\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\ngreet:\n  xor rax, rax\n  push rbp\n  mov rbp,rsp\n  sub rsp,0x8\n  push say\n  mov rdx,rdi ;arg[2]=name\n  mov rsi,format\n  mov rdi,say\n  call asprintf wrt ..plt\n  mov rax,[say]\n  leave\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212569,"user_id":null,"body":"SECTION .data\nfmt: db 'Hello, % how are you doing today?',0\n\nSECTION .text\nglobal greet\nextern strlen\nextern malloc\nextern sprintf\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\ngreet:\n  ; arg0 = rdi\n  push  rdi\n  mov   rdi, 4096\n  call  malloc\n  pop   rdi\n  push  rax\n  mov   rcx, fmt\n  .loop:\n  cmp   [rcx], byte 0\n  je    .end\n  cmp   [rcx], byte '%'\n  je    .innerloop\n  mov   rdx, [rcx]\n  mov   [rax], rdx\n  inc   rax\n  inc   rcx\n  jmp   .loop\n  .innerloop:\n  cmp   [rdi], byte 0\n  je    .endinnerloop\n  mov   rdx,  [rdi]\n  mov   [rax], rdx\n  inc   rax\n  inc   rdi\n  jmp   .innerloop\n  .endinnerloop:\n  inc   rcx\n  jmp   .loop\n  .end:\n  mov   [rax], byte 0\n  pop   rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212570,"user_id":null,"body":"SECTION .data\nfomt:\n  db \"Hello, %s how are you doing today?\", 0\n\nSECTION .text\nglobal greet\nextern asprintf\n\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\ngreet:\n  mov  rdx, rdi\n  mov  rsi, fomt\n;  sub  rsp, 8\n;  mov  rdi, rsp\n  lea  rdi, [rsp - 0h8]\n  push rdi\n  call asprintf\n  pop  rax\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212571,"user_id":104,"body":"; 2021 nomennescio\nSECTION .text\nglobal greet\nextern asprintf\n\nfmt: db \"Hello, %s how are you doing today?\",0\n\n; Returns a string formatted so that it greets a person by the name given.\n; Note: Return a pointer to a string allocated on the heap. Do not return a pointer to a string allocated on the stack!\n; arg0         = (const char*) The name to greet.\n; return value = (char*)       The formatted return string.\n\ngreet:\n  push rax\n  mov rdx, rdi\n  lea rdi, [rsp]\n  lea rsi, [fmt]\n  call asprintf\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55acfc59c3c23d230f00006d":[{"id":212572,"user_id":168,"body":"SECTION .text\nglobal get_ascii\n\nget_ascii:\n  movzx eax, dil\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212573,"user_id":null,"body":"section .text\n\nglobal get_ascii\n\nget_ascii:\n  movzx  rax, dil\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212574,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  xor rax, rax\n  mov rax, rdi\n  and rax, 0x000000ff\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212575,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  mov rax, rdi\n  and rax, 0x0000000ff\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212576,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  and     edi,0xff\n  mov     eax,edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212577,"user_id":null,"body":"SECTION .text\n  global get_ascii\nget_ascii:\n  mov rax,8\n  bzhi rax,rdi,rax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212578,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  movzx eax, dil\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212579,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  xor eax, eax\n  mov al, dil\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212580,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  and rdi, 255\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212581,"user_id":null,"body":"SECTION .text\nglobal get_ascii\n\n; int get_ascii(char);\n; sizeof(int) = 4\n; sizeof(char) = 1\nget_ascii:\n  xor eax, eax\n  mov eax, edi\n  and eax, 255\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55b051fac50a3292a9000025":[{"id":212582,"user_id":null,"body":"section .text\nglobal filter_string\nfilter_string:   ; long long filter_string(const char *value)\n    mov rax, rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212583,"user_id":527,"body":"section .text\nglobal filter_string\n; long long filter_string(const char *value)\nfilter_string:\n                xor     eax, eax\n                jmp     .entry\n.loop:          lea     rcx, [rax * 5]\n                lea     rcx, [rcx * 2 + rdx]\n                cmp     edx, 9\n                cmovbe  rax, rcx\n.entry:         movzx   edx, byte [rdi]\n                inc     rdi\n                sub     edx, '0'\n                jae     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212584,"user_id":null,"body":"global filter_string\nfilter_string:\n  xor rdx,rdx\n  xor rax,rax\n  mov rsi,rdi\n  jmp .f\n  .b:lea rdx,[rdx+rdx*4]\n     lea rdx,[rdx*2+rax-'0']\n     .f:lodsb\n        bt  [nums],eax \n     jnc .f\n     test eax,eax\n  jne .b    \n  mov rax,rdx\nret\nnums dq 3FF000000000001h,0,0,0    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212585,"user_id":null,"body":"section .text\nglobal filter_string\nfilter_string:   ; long long filter_string(const char *value)\n  xor eax, eax\n.loop:\n  movsx rcx, byte [rdi]\n  test rcx, rcx\n  je .done\n  imul rsi, rax, 10\n  lea edx, [rcx - 48]\n  cmp dl, 10\n  lea rcx, [rsi + rcx - 48]\n  cmovb rax, rcx\n  inc rdi\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212586,"user_id":168,"body":"section .text\nglobal filter_string\nfilter_string:   ; long long filter_string(const char *value)\n  xor eax, eax\n.loop:\n  movzx edx, byte [rdi]\n  inc rdi\n  sub dl, '0'\n  cmp dl, 9\n  ja .next\n  imul rax, 10\n  add rax, rdx\n.next:\n  cmp dl, 256 - '0'\n  jne .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212587,"user_id":null,"body":"section .text\nglobal filter_string\nfilter_string:   ; long long filter_string(const char *value)\n    xor   rax,  rax\n    cmp   [rdi],  byte 0\n    je    .end\n    xor   rdx,  rdx\n    .loop:    \n    mov   dl,  [rdi]\n    sub   dl,  byte 48    \n    cmp   dl,  byte 9\n    ja    .nodigit\n    .digit:\n    imul  rax, 10\n    add   rax, rdx\n    .nodigit:\n    inc   rdi\n    cmp   [rdi],  byte 0\n    jne   .loop\n    .end:\n    ret   ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212588,"user_id":50,"body":"section .text\nglobal filter_string\nfilter_string:   ; long long filter_string(const char *value)\n    xor rax, rax\n    mov r10,10\n    xor r8,r8\n    xor r9,r9\n_loop:\n  mov r8b,byte[rdi+r9]\n  test r8,r8\n  jz _exit\n  inc r9\n  cmp r8b,48\n  jl _loop\n  cmp r8b,57\n  jg _loop\n  sub r8,48\n  imul r10\n  add rax,r8\n  jmp _loop\n_exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212589,"user_id":1315,"body":"section .text\nextern atoll\nglobal filter_string\nfilter_string:\n    sub  rsp, 20\n    xor  rcx, rcx\nnext_char:\n    mov  al, [rdi]\n    inc  rdi\n    test al, al\n    jz   end_loop\n    cmp  al, '0'\n    jl   next_char\n    cmp  al, '9'\n    jg   next_char\n    mov  [rsp + rcx], al\n    inc  rcx\n    jmp  next_char\nend_loop:\n    mov  [rsp + rcx], byte 0\n    mov  rdi, rsp\n    call atoll\n    add  rsp, 20\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55b1fd84a24ad00b32000075":[{"id":212590,"user_id":331,"body":"section .text\nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n  xor rax, rax\n  \n  ; Check what day\n  cmp BYTE [edi+0], 'M'\n  je Monday\n  cmp BYTE [edi+0], 'W'\n  je Wednesday\n  cmp BYTE [edi+0], 'F'\n  je Friday\n  T_DAY:\n  cmp BYTE [edi+0], 'T'\n  jne S_DAY\n  cmp BYTE [edi+1], 'u'\n  je Tuesday\n  jmp Thursday\n  S_DAY:\n  cmp BYTE [edi+1], 'a'\n  je Saturday\n  jmp Sunday\n  \n  \n  Monday:\n  cmp esi, 12\n  jne Return\n  jmp is_afraid\n  \n  Tuesday:\n  cmp esi, 95\n  jle Return\n  jmp is_afraid\n  \n  Wednesday:\n  cmp esi, 34\n  jne Return\n  jmp is_afraid\n  \n  Thursday:\n  cmp esi, 0\n  jne Return\n  jmp is_afraid\n  \n  Friday:\n  test esi, 1\n  jnz Return\n  jmp is_afraid\n  \n  Saturday:\n  cmp esi, 56\n  jne Return\n  jmp is_afraid\n  \n  Sunday:\n  cmp esi, 666\n  jne neg\n  jmp is_afraid\n  neg:\n  cmp esi, -666\n  jne Return\n\n  is_afraid:\n  mov eax, 1\n  \n  Return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212591,"user_id":null,"body":"section .text\nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n  mov cl, [rdi + 1]\n  cmp cl, 117\n  jne .notu\n  cmp byte [rdi], 84\n  mov edx, esi\n  mov al, 1\n  sete dil\n  cmp esi, 96\n  setge r8b\n  neg edx\n  cmovs edx, esi\n  test r8b, dil\n  jne .done\n  cmp edx, 666\n  je .done\n.notscaryfri:\n  cmp cl, 97\n  sete cl\n  cmp esi, 56\n  sete al\n  and al, cl\n  jmp .done\n.notu:\n  cmp esi, 12\n  mov al, 1\n  jne .not12\n  cmp cl, 111\n  je .done\n.not12:\n  cmp esi, 34\n  jne .not34\n  cmp cl, 101\n  je .done\n.not34:\n  test esi, esi\n  jne .notzero\n  cmp cl, 104\n  je .done\n.notzero:\n  test sil, 1\n  jne .notscaryfri\n  cmp cl, 114\n  jne .notscaryfri\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212592,"user_id":null,"body":"section .text\nextern puts\nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n  xor   al, al\n  mov   bl, 1\n  cmp   byte [rdi], 'M'\n  je    .monday\n  cmp   byte [rdi], 'T'\n  je    .t\n  cmp   byte [rdi], 'W'\n  je    .wednesday\n  cmp   byte [rdi], 'T'\n  je    .t\n  cmp   byte [rdi], 'F'\n  je    .friday\n  cmp   byte [rdi], 'S'\n  je    .s\n  ret\n  .t:\n  cmp   byte [rdi+1], 'u'\n  je    .tuesday\n  jmp   .thursday\n  .s:\n  cmp   byte [rdi+1], 'u'\n  je    .sunday\n  jmp   .saturday\n  .monday:\n  cmp   esi, 12\n  cmove eax, ebx\n  ret\n  .tuesday:\n  cmp   esi, 95\n  cmovg eax, ebx\n  ret\n  .wednesday:\n  cmp   esi, 34\n  cmove eax, ebx\n  ret\n  .thursday:\n  cmp   esi, 0\n  cmove eax, ebx\n  ret\n  .friday:\n  shr    esi, 1\n  cmovnc eax, ebx\n  ret\n  .saturday:\n  cmp   esi, 56\n  cmove eax, ebx\n  ret\n  .sunday:\n  cmp   esi, -666\n  cmove eax, ebx\n  cmp   esi, 666\n  cmove eax, ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212593,"user_id":null,"body":"section .rodata\nmon: db \"Monday\", 0\ntue: db \"Tuesday\", 0\nwed: db \"Wednesday\", 0\nthu: db \"Thursday\", 0\nfri: db \"Friday\", 0\nsat: db \"Saturday\", 0\nsun: db \"Sunday\", 0\n\nsection .text\nglobal am_i_afraid\nextern strcmp\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n  push rbx\n  push rbp\n  mov ebx, edi\n  mov ebp, esi\n  \n  mov rsi, mon\n  call strcmp\n  test eax, eax\n  jz .monday\n  \n  mov rdi, rbx\n  mov rsi, tue\n  call strcmp\n  test eax, eax\n  jz .tuesday\n  \n  mov rdi, rbx\n  mov rsi, wed\n  call strcmp\n  test eax, eax\n  jz .wednesday\n  \n  mov rdi, rbx\n  mov rsi, thu\n  call strcmp\n  test eax, eax\n  jz .thursday\n  \n  mov rdi, rbx\n  mov rsi, fri\n  call strcmp\n  test eax, eax\n  jz .friday\n  \n  mov rdi, rbx\n  mov rsi, sat\n  call strcmp\n  test eax, eax\n  jz .saturday\n  \n  mov rdi, rbx\n  mov rsi, sun\n  call strcmp\n  test eax, eax\n  jz .sunday\n  \n  jmp .no_match\n  \n  .monday:\n  cmp ebp, 12\n  sete al\n  jmp .done\n  \n  .tuesday:\n  cmp ebp, 95\n  setg al\n  jmp .done\n  \n  .wednesday:\n  cmp ebp, 34\n  sete al\n  jmp .done\n  \n  .thursday:\n  test ebp, ebp\n  sete al\n  jmp .done\n  \n  .friday:\n  test ebp, 1\n  setz al\n  jmp .done\n  \n  .saturday:\n  cmp ebp, 56\n  sete al\n  jmp .done\n  \n  .sunday:\n  cmp ebp, 666\n  sete dl\n  cmp ebp, -666\n  sete al\n  or al, dl\n  jmp .done\n  \n  .no_match:\n  xor eax, eax\n  .done:\n  pop rbp\n  pop rbx\n  ret\n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212594,"user_id":null,"body":"section .text\nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid([edi] const char *day, [esi] int num)\n  ; monday\n  cmp byte [rdi], 'M'\n  je monday\n  \n  ; thursday\n  cmp byte [rdi + 1], 'h'\n  je thursday\n  \n  ;tuesday\n  cmp byte [rdi], 'T'\n  je tuesday\n  \n  ;wednesday\n  cmp byte [rdi], 'W'\n  je wednesday\n  \n  ;friday\n  cmp byte [rdi], 'F'\n  je friday\n  \n  ;sat\n  cmp byte [rdi + 1], 'a'\n  je saturday\n  \n  jmp sunday\nmonday:\n  cmp esi, 12\n  je true\n  jmp false\nthursday:\n  cmp esi, 0\n  je true\n  jmp false\ntuesday:\n  cmp esi, 95\n  jg true\n  jmp false\nwednesday:\n  cmp esi, 34\n  je true\n  jmp false\nfriday:\n  mov eax, esi\n  xor edx, edx\n  mov ebx, 2\n  div ebx\n  cmp edx, 0\n  je true\n  jmp false\nsaturday:\n  cmp esi, 56\n  je true\n  jmp false\nsunday:\n  cmp esi, 666\n  je true\n  cmp esi, -666\n  je true\nfalse:\n  xor eax, eax\n  ret\ntrue:\n  mov eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212595,"user_id":null,"body":"section .text\nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n    xor rax, rax        ; 0 the rax\n    mov dx, [rdi]       ; first char into dl, second into dh\n    cmp byte dl, 'M'    ; Monday\n    je mon\n    cmp byte dl, 'W'    ; Wednesday\n    je wed\n    cmp byte dl, 'F'    ; Friday\n    je fri    \n    cmp byte dl, 'T'    ; Tuesday or Thursday\n    jne sat_or_sun\n    cmp byte dh, 'u'    ; Tuesday\n    je tue\n    jmp thu\nsat_or_sun:        \n    cmp byte dh, 'a'    ; Saturday\n    je sat\n;sun        \n    mov ecx, esi        ; get absolute value of esi\n    neg esi\n    cmovl esi, ecx\n    cmp esi, 666        ; is esi 666\n    je true\n    ret\nmon:\n    cmp esi, 12         ; is esi 12\n    je true\n    ret\ntue:\n    cmp esi, 95         ; is esi > 95\n    jg true\n    ret\nwed:\n    cmp esi, 34         ; is esi 34\n    je true\n    ret    \nthu:\n    cmp esi, 0          ; is esi 0\n    je true             \n    ret\nfri:\n    sar esi, 1          ; is esi even\n    jnc true\n    ret    \nsat:  \n    cmp esi, 56         ; is esi 56\n    je true\n    ret    \ntrue:\n    mov rax, 1\n    ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212596,"user_id":168,"body":"section .text\ndays dq r0, saturday, friday, monday, thursday, r0, r0, r0, r0, sunday, r0, r0, r0, wednesday, tuesday, r0\n  \nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n  xor eax, eax\n  movzx edx, byte [rdi + 1]\n  add edx, edx\n  xor dl, byte [rdi]\n  and edx, 15\n  jmp [days + rdx * 8]  \ntuesday:\n  cmp esi, 95\n  setg al\n  ret\nfriday:\n  test esi, 1\n  sete al\n  ret\nsunday:\n  mov edx, esi\n  neg edx\n  cmovns esi, edx\n  sub esi, 666 - 56\nsaturday:\n  sub esi, 56 - 34\nwednesday:\n  sub esi, 34 - 12\nmonday:\n  sub esi, 12\nthursday:\n  test esi, esi\n  sete al\nr0:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212597,"user_id":1315,"body":"section .text\nglobal am_i_afraid\nam_i_afraid:    ; bool am_i_afraid(const char *day, int num)\n  mov eax, esi\n  mov ebx, edi\n\n  mov esi, monday_str\n  mov rcx, 3\n  rep cmpsb\n  je .monday\n\n  mov esi, tuesday_str\n  mov edi, ebx\n  mov rcx, 3\n  rep cmpsb\n  je .tuesday\n\n  mov esi, wednesday_str\n  mov edi, ebx\n  mov rcx, 3\n  rep cmpsb\n  je .wednesday\n\n  mov esi, thursday_str\n  mov edi, ebx\n  mov rcx, 3\n  rep cmpsb\n  je .thursday\n\n  mov esi, friday_str\n  mov edi, ebx\n  mov rcx, 3\n  rep cmpsb\n  je .friday\n\n  mov esi, saturday_str\n  mov edi, ebx\n  mov rcx, 3\n  rep cmpsb\n  je .saturday\n\n  mov esi, sunday_str\n  mov edi, ebx\n  mov rcx, 3\n  rep cmpsb\n  je .sunday\n\n  xor eax, eax\n  ret\n\n.monday:\n  cmp eax, 12\n  sete al\n  ret\n\n.tuesday:\n  cmp eax, 95\n  setg al\n  ret\n\n.wednesday:\n  cmp eax, 34\n  sete al\n  ret\n\n.thursday:\n  test eax, eax\n  setz al\n  ret\n\n.friday:\n  and eax, 1\n  setz al\n  ret\n\n.saturday:\n  cmp eax, 56\n  sete al\n  ret\n\n.sunday:\n  mov ebx, eax\n  neg eax\n  cmovl eax, ebx\n  cmp eax, 666\n  sete al\n  ret\n\nsection .data\nmonday_str    db 'Mon',0\ntuesday_str   db 'Tue',0\nwednesday_str db 'Wed',0\nthursday_str  db 'Thu',0\nfriday_str    db 'Fri',0\nsaturday_str  db 'Sat',0\nsunday_str    db 'Sun',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55b2549a781b5336c0000103":[{"id":212598,"user_id":null,"body":"extern log\nsection .text\nglobal compare_powers\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  push rbp\n  mov rbp, rdi\n  push rbx\n  mov rbx, rsi\n  sub rsp, 24\n  cvtsi2sd xmm0, [rdi]\n  call log\n  cvtsi2sd xmm1, [rbp+4]\n  mulsd xmm1, xmm0\n  cvtsi2sd xmm0, [rbx]\n  movsd [rsp+8], xmm1\n  call log\n  movsd xmm1, [rsp+8]\n  xor eax, eax\n  movapd xmm2, xmm0\n  cvtsi2sd xmm0, [rbx+4]\n  mulsd xmm0, xmm2\n  comisd xmm0, xmm1\n  seta al\n  xor edx, edx\n  comisd xmm1, xmm0\n  seta dl\n  add rsp, 24\n  sub eax, edx\n  pop rbx\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212599,"user_id":null,"body":"section .text\nglobal compare_powers\nextern log\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  push rbx\n  push rdi\n  push rsi\n  \n  cvtsi2sd xmm0, [rdi]\n  call log\n  mov rdi, [rsp+8]\n  cvtsi2sd xmm1, [rdi+4]\n  mulsd xmm0, xmm1\n  movsd [rsp+8], xmm0\n  \n  mov rsi, [rsp]\n  cvtsi2sd xmm0, [rsi]\n  call log\n  mov rsi, [rsp]\n  cvtsi2sd xmm1, [rsi+4]\n  mulsd xmm0, xmm1\n  \n  mov eax, 1\n  xor ecx, ecx\n  mov edx, -1\n\n  ucomisd xmm0, [rsp+8]\n  cmovz eax, ecx\n  cmovc eax, edx\n  \n  pop rsi\n  pop rdi\n  pop rbx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212600,"user_id":null,"body":"section .text\nglobal compare_powers\n\nextern log2\n\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  cvtsi2sd xmm0, [rdi]  ; base0 => double\n  \n  push rbx\n  mov ebx, [rdi + 4]\n  \n  push rbp\n  mov ebp, [rsi]\n  \n  push r14\n  mov r14d, [rsi + 4]\n\n  call log2\n  \n  cvtsi2sd xmm1, ebx    ; exponent0 => double\n  mulsd xmm0, xmm1      ; base0 * exponent0\n  movq rbx, xmm0        ; preserve in rbx\n  \n  cvtsi2sd xmm0, rbp    ; base1 => double\n  call log2\n  cvtsi2sd xmm1, r14d   ; exponent1 => double\n  mulsd xmm0, xmm1      ; base1 * exponent1\n  movq rdx, xmm0        ; extract as integer data\n\n  xor eax, eax\n  mov ecx, 1\n  mov edi, -1\n  \n  cmp rbx, rdx\n  cmova eax, edi\n  cmovb eax, ecx\n  \n  pop r14\n  pop rbp\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212601,"user_id":null,"body":"section .text\nextern logf\nglobal compare_powers\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  xor    rax, rax\n  finit\n  fild    dword [rsi + 4]\n  fild    dword [rsi]\n  fyl2x\n  fild    dword [rdi + 4]\n  fild    dword [rdi]\n  fyl2x\n  fcomip\n  ja     _above\n  jb     _below\n  jmp    _finish\n_above:\n  mov    eax, 0xffffffff\n  jmp    _finish\n_below:\n  mov    eax, 0x01\n_finish:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212602,"user_id":743,"body":"global compare_powers\n\nsection .text\n; eax                           rdi            rsi\n; int compare_powers(const int* n1, const int* n2);\ncompare_powers:\n  fild dword [rdi + 4]\n  fild dword [rdi + 0]\n  fyl2x\n  fild dword [rsi + 4]\n  fild dword [rsi + 0]\n  fyl2x\n  xor eax, eax\n  fcomip st1\n  mov edx, -1\n  seta al\n  cmovb eax, edx\n  fstp st0\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212603,"user_id":null,"body":"section .text\nglobal compare_powers\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  finit\n  fild dword [rsi+4]\n  fild dword [rsi]\n  fyl2x\n  fild dword [rdi+4]\n  fild dword [rdi]\n  fyl2x\n  fsubrp\n  ftst\n  fstsw  ax\n  \n  sahf\n  jz .is_zero\n  jc .is_negative\n.is_positive:\n  mov eax, -1\n  ret\n.is_zero:\n  xor rax, rax\n  ret\n.is_negative:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212604,"user_id":527,"body":"extern log\nsection .text\nglobal compare_powers\n; int compare_powers(const int n1[2], const int n2[2])\ncompare_powers:\n                push        qword [rsi]\n                push        qword [rdi]\n                push        rbp\n                cvtsi2sd    xmm0, dword [rdi]\n                call        log\n                cvtsi2sd    xmm1, dword [rsp + 12]\n                mulsd       xmm1, xmm0\n                movsd       [rsp], xmm1\n                cvtsi2sd    xmm0, dword [rsp + 16]\n                call        log\n                cvtsi2sd    xmm1, dword [rsp + 20]\n                mulsd       xmm1, xmm0\n                xor         eax, eax\n                xor         edx, edx\n                ucomisd     xmm1, [rsp]\n                seta        al\n                setb        dl\n                sub         eax, edx\n                add         rsp, 24\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212605,"user_id":168,"body":"section .text\nglobal compare_powers\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  xor eax, eax\n  xor ecx, ecx\n  fild dword [rsi + 4]\n  fild dword [rsi]\n  fyl2x\n  fild dword [rdi + 4]\n  fild dword [rdi]\n  fyl2x\n  fcomip\n  fstp st0\n  setb al\n  seta cl\n  sub eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212606,"user_id":168,"body":"section .text\nglobal compare_powers\n; input: rdi = n1, rsi = n2\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\ncompare_powers:\n  xor eax, eax\n  xor ecx, ecx\n  fild dword [rsi + 4]\n  fild dword [rsi]\n  fyl2x\n  fild dword [rdi + 4]\n  fild dword [rdi]\n  fyl2x\n  fcomip\n  fstp st0\n  setb al\n  seta cl\n  sub eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55b7bb74a0256d4467000070":[{"id":212607,"user_id":168,"body":"global proper_fractions\nsection .text\n; input: rdi = n\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nproper_fractions:\n  push rbx\n  xor esi, esi\n  cmp rdi, 1\n  jbe .end\n  mov rsi, rdi\n  test al, 1\n  jnz .start_loop\n  shr rsi, 1\n  bsf rcx, rdi\n  shr rdi, cl\n.start_loop:\n  mov ecx, 1\n  mov ebx, ecx\n.loop:\n  lea rbx, [rcx * 4 + rbx + 4]  ; rbx == ecx * ecx\n  cmp rbx, rdi\n  ja .loop_end\n  add rcx, 2\n  xor edx, edx\n  mov rax, rdi\n  div rcx\n  test rdx, rdx\n  jnz .loop\n  mov rdi, rax\n  mov rax, rsi\n  div rcx   ; rdx == 0 before and after this operation\n  sub rsi, rax\n  mov rax, rdi\n.div_loop:\n  mov rdi, rax\n  div rcx\n  test rdx, rdx\n  jz .div_loop\n  jmp .loop\n.loop_end:\n  cmp rdi, 1\n  jbe .end\n  xor edx, edx\n  mov rax, rsi\n  div rdi\n  sub rsi, rax\n.end:\n  mov rax, rsi\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212608,"user_id":null,"body":"global proper_fractions\nsection .text\n; input: rdi = n\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\n; used caller saved registers: r8-r11\n\ndivision:\n  beggg:\n  mov rax, rdi\n  mov rdx, 0\n  div rsi\n  cmp rdx, 0\n  jne endd\n  mov rdi, rax\n  jmp beggg\n  endd:ret\n\nproper_fractions:\n  xor rax, rax\n  cmp rdi, 1\n  je trueend\n  mov r11, rdi\n  mov r8, rdi\n  and r8, 1\n  cmp r8, 0\n  jne contd\n  shr r11, 1\n  divtoend:\n  shr rdi, 1\n  mov r8, rdi\n  and r8, 1\n  jne contd\n  jmp divtoend\n  contd:\n  mov rsi, 3\n  frot:\n  mov rax, rdi\n  mov rdx, 0\n  div rsi\n  cmp rdx, 0\n  jne npf\n  mov rax, r11\n  mov rdx, 0\n  div rsi\n  dec rsi\n  mul rsi\n  mov r11, rax\n  inc rsi\n  call division\n  npf:\n  mov rax, rdi\n  mov rdx, 0\n  div rsi\n  cmp rax, rsi\n  jl end\n  add rsi, 2\n  jmp frot\n  end:\n  cmp rdi, 1\n  mov rax, r11\n  jle trueend\n  mov rdx, 0\n  div rdi\n  dec rdi\n  mul rdi\n  trueend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212609,"user_id":null,"body":"global proper_fractions\nsection .text\n; input: rdi = n\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nproper_fractions:\n  cmp rdi, 1\n  jbe .bailout\n  \n  mov rcx, rdi\n  test rdi, 1\n  jne .skip\n  shr rcx, 1\n.loop:\n  shr rdi, 1\n  test rdi, 1\n  je .loop\n\n.skip:\n  mov rsi, 3\n  \n.loop2:\n  mov rax, rdi\n  xor edx, edx\n  div rsi\n  test rdx, rdx\n  jz .reduce\n.next:\n  add rsi, 2\n  mov r8, rsi\n  imul r8, r8\n  cmp rdi, r8\n  jae .loop2\n  \n  cmp rdi, 1\n  jbe .skip2\n  mov rax, rcx\n  xor edx, edx\n  div rdi\n  sub rcx, rax\n\n.skip2:\n  mov rax, rcx\n  ret\n  \n.reduce:\n  mov rdi, rax\n  div rsi\n  test rdx, rdx\n  jz .reduce\n  \n  mov rax, rcx\n  xor edx, edx\n  div rsi\n  sub rcx, rax\n  jmp .next\n  \n.bailout:\n  xor eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212610,"user_id":50,"body":"global proper_fractions\nsection .text\n; input: rdi = n\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nproper_fractions:\n  xor rax, rax\n  cmp rdi,1\n  je _retz\n  mov r9,rdi\n  mov r8,rdi ; a=n\n  mov r11,1 ; p=1\n_loop:\n  inc r11 ; p++ \n  mov rax,r11 ; rdx=p \n  mul rax ; rdx=p*p \n  cmp rax,r9\n  ja _out ;  if p*p>n\n  mov rax,r9 ; rax=n\n  xor rdx,rdx\n  div r11 ; rax=n\/\/p\n  cmp rdx,0 ; n%p==0\n  je _yahou\n  jmp _loop\n_yahou:\n ; mov r9,rax ; n\/\/=p\n  mov rax,r8 ; rax=a\n  div r11 ; rax=a\/\/p\n  sub r8, rax ; a-=a\/\/p\n_while:\n  mov rax,r9 ; rax=n\n  xor rdx,rdx\n  div r11 ; rax=n\/\/p\n  cmp rdx,0\n  jne _loop\n  mov r9,rax\n  jmp _while\n_retz:\n  ret\n_out:\n  mov rax,r8 ; rax=a\n  cmp r9,1\n  jbe _yep ; if n<=1\n  xor rdx,rdx\n  div r9\n  sub r8,rax       \n  mov rax,r8\n  ret\n_yep:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212611,"user_id":null,"body":"global proper_fractions\nsection .text\n; input: rdi = n\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nproper_fractions:\n  push qword 0      ; + 48 = p^k-1\n  push qword 0      ; + 40 = last n \/ p^k\n  push qword 0      ; + 32 = n % p^k\n  push qword 0      ; + 24 = n \/ p^k\n  push qword 0      ; + 16 = p^k\n  push qword 0      ; + 8  = p\n  push rdi          ; + 0  = n \n  \n  ; find first prime factor of n\n  call fpf\n  mov [rsp + 8], rax\n  \n  ; p^k = 1 for k = 0\n  mov qword [rsp + 16], qword 1\n  \n  ; n \/ p^k = n for k = 0\n  mov rax, [rsp]\n  mov [rsp + 24], rax\n  \n  ; repeatedly divide n by p k times, until n' and p are coprime or n' is 1\n.div_p:  \n\n  ; if n \/ p^k is one\n  mov rax, [rsp + 24]\n  cmp rax, qword 1\n  jne .is_not_one\n  \n  ; return n - n \/ p\n  \n    ; calc n \/ p\n    mov rax, [rsp]\n    xor rdx, rdx\n    div qword [rsp + 8]\n    mov rcx, rax\n\n    ; calc n - n \/ p\n    mov rax, [rsp]\n    sub rax, rcx\n\n    ; return\n    jmp .end\n  \n  ; else\n.is_not_one:\n  \n  ; n' = n' \/ p\n  xor rdx, rdx\n  mov [rsp + 40], rax\n  div qword [rsp + 8]\n  mov [rsp + 24], rax\n  mov [rsp + 32], rdx\n  \n  ; p^k = p * p^k-1\n  mov rax, [rsp + 16]\n  mov [rsp + 48], rax\n  xor rdx, rdx\n  mul qword [rsp + 8]         \n  mov [rsp + 16], rax\n  \n  ; if p divides n, loop\n  cmp qword [rsp + 32], qword 0        \n  je  .div_p        \n  \n  ; proper_fractions(n')\n  mov rdi, [rsp + 40]\n  call proper_fractions\n  mov [rsp + 40], rax\n  \n  ; proper_fractions(p^k)\n  mov rdi, [rsp + 48]\n  call proper_fractions\n  xor rdx, rdx\n  \n  ; proper_fractions(n') * proper_fractions(p^k)\n  mul qword [rsp + 40]  \n\n; return\n.end:  \n  add rsp, 56\n  ret\n  \n  \nsqrt: ; rough square root\n  mov rax, rdi\n  xor rcx, rcx\n.div:\n  shr rax, 1\n  inc rcx\n  cmp rax, 1\n  jg .div\n  shr rcx, 1\n  inc rcx\n  mov rax, 1\n  shl rax, cl\n  ret\n  \nfpf: ; first prime factor\n  cmp rdi, 1\n  je .is_one\n  push rdi      ; n\n  call sqrt\n  push rax      ; sqrt n\n  push 0        ; wheel cur\n  push 0        ; wheel pos\n  push 0        ; wheel n\n  mov rdi, rsp\n  push rdi      ; ptr for wheel\n.loop:\n  call wheel\n  cmp rax, [rsp + 32]\n  jge .is_prime\n  mov rcx, rax\n  xor rdx, rdx\n  mov rax, [rsp + 40]\n  div rcx\n  cmp rdx, 0\n  jne .loop\n  mov rax, rcx\n  add rsp, 48\n  ret\n.is_prime:\n  mov rax, [rsp + 40]\n  add rsp, 48\n  ret\n.is_one:\n  mov rax, 1\n  ret\n\n\nwheel:\n  ; rdi - ptr to [cur, pos in wheel, pos overall]\n  mov rdx, [rdi + 16]\n  cmp rdx, 4\n  jl .first\n  mov r8, [rdi]\n  mov r9, [rdi + 8]\n  add r8, [the_wheel + 8 * r9]\n  inc r9\n  mov rax, r9\n  xor rdx, rdx\n  mov r10, 8\n  div r10\n  mov [rdi + 8], rdx\n  inc qword [rdi + 16]\n  mov [rdi], r8\n  mov rax, r8\n  ret\n.first:\n  mov rax, [the_first + 8 * rdx]\n  inc qword [rdi + 16]\n  mov [rdi], rax\n  ret\n  \nthe_first:\n  dq 2, 3, 5, 7\nthe_wheel:\n  dq 4,2,4,2,4,6,2,6\n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212612,"user_id":null,"body":"global proper_fractions\nproper_fractions:\n  xor rax,rax\n  cmp rdi,1\n  je .exit\n    mov rcx,2\n    mov r8,rdi\n    .b:mov  rax,rdi\n       xor  rdx,rdx\n       div  rcx\n       test rdx,rdx\n       jne .f\n         .c:mov  rdi,rax\n            div  rcx\n            test rdx,rdx\n         je .c  \n         mov rax,r8\n         xor rdx,rdx\n         div rcx\n         sub r8,rax\n       .f:\n       inc  rcx\n       mov  rax,rcx\n       imul rax,rax\n       cmp  rax,rdi\n    jbe .b   \n    cmp rdi,1\n    je .d\n      mov rax,r8\n      xor rdx,rdx\n      div rdi\n      sub r8,rax\n    .d:\n    mov rax,r8\n  .exit:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212613,"user_id":null,"body":"global proper_fractions\n\nsection .text\n\n; input: rdi = n\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nproper_fractions:\n\n; \/\/ Euler function\n; unsigned long phi(unsigned long n) {\n;   unsigned long result = n;\n;   if ((n & 1) == 0) {\n;     do { n >>= 1; } while ((n & 1) == 0);\n;     result >>= 1;\n;   }\n;   for (unsigned long i = 3; i*i <= n; i += 2) {\n;     if (n % i == 0) {\n;       do { n \/= i; } while (n % i == 0);\n;       result -= result \/ i;\n;     }\n;   }\n;   if (n > 1) { result -= result \/ n; }\n;   return result;\n; }\n\n  xor eax,eax\n  cmp rdi,2\n  jb .exit\n\n  mov rsi,rdi  ; rsi = result\n\n.while1:\n  bsf rcx,rdi\n  jecxz .skip1\n  shr rdi,cl\n  shr rsi,1\n.skip1:\n  \n  mov ecx,3    ; rcx = i\n  jmp .start\n.for:\n  xor edx,edx\n  mov rax,rdi\n  div rcx\n  test rdx,rdx\n  jnz .skip2\n\n.while2:\n  mov rdi,rax\n  xor edx,edx\n  div rcx\n  test rdx,rdx\n  jz .while2\n\n  xor edx,edx\n  mov rax,rsi\n  div rcx\n  sub rsi,rax\n\n.skip2:\n  add ecx,2\n\n.start:\n  mov eax,ecx\n  imul rax,rax\n  cmp rax,rdi\n  jbe .for\n\n  mov rax,rsi\n  cmp rdi,1\n  jna .exit\n  xor edx,edx\n  div rdi\n  sub rsi,rax\n  mov rax,rsi\n\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55ba95a17970ff3e80000064":[{"id":212614,"user_id":null,"body":"section .text\nglobal is_ore\n; int is_ore(long n)\nis_ore:\n  cmp rdi, 1\n  mov eax, 1\n  je .done\n  cvtsi2sd xmm0, rdi\n  lea rsi, [rdi+1]\n  mov ecx, 2\n  sqrtsd xmm0, xmm0\n  cvttsd2si r9, xmm0\n  mov rax, r9\n  imul rax, r9\n  cmp rax, rdi\n  jne .notps\n  sub rsi, r9\n  mov ecx, 1\n.notps:\n  mov r8d, 2\n.loop:\n  cmp r8, r9\n  jg .end\n  mov rax, rdi\n  cqo\n  idiv r8\n  test rdx, rdx\n  jne .next\n  add rax, r8\n  add rcx, 2\n  add rsi, rax\n.next:\n  inc r8\n  jmp .loop\n.end:\n  mov rax, rcx\n  imul rax, rdi\n  cqo\n  idiv rsi\n  xor eax, eax\n  test rdx, rdx\n  sete al\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212615,"user_id":null,"body":"section .data\ntable dq 1, 6, 28, 140, 270, 496, 672, 1638, 2970, 6200, 8128, 8190, 18600, 18620, 27846, 30240, 32760, 55860, 105664, 117800, 167400, 173600, 237510, 242060, 332640, 360360, 539400, 695520, 726180, 753480, 950976, 1089270, 1421280, 1539720\nend equ $\nsection .text\nglobal is_ore\n; int is_ore(long n)\nis_ore:\n  mov rdx, table\n  mov rcx, end\n.loop:\n  mov rax, [rdx]\n  cmp rax, rdi\n  je  .yes\n  add rdx, 8\n  cmp rcx, rdx\n  jne .loop\n  mov rax, 0\n  ret\n.yes:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212616,"user_id":104,"body":"; 2022 nomennescio\n\nsection .text\nglobal is_ore\n\nore: \ndq 1,6,28,140,270,496,672,1638,2970,6200,8128,8190,\ndq 18600,18620,27846,30240,32760,55860,105664,117800,\ndq 167400,173600,237510,242060,332640,360360,539400,\ndq 695520,726180,753480,950976,1089270,1421280,1539720\nn_ore: equ $-ore-1\n\n; int is_ore (long n)\n; rdi : n (64 bit Linux : sizeof (long)==8)\n; callee saved registers: rbx, rsp, rbp, r12-r15\n; rax : is_ore\n\nis_ore:\n  mov rax, 0\n  lea rbx, [rel ore]\n  mov rsi, n_ore\n.next:\n  cmp rdi,[rbx+rsi]\n  je .found\n  ja .notfound\n  sub rsi,1\n  jae .next\n  ret\n.found:\n  inc rax\n.notfound:  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212617,"user_id":null,"body":"; esi current denominator\n; edi number tested\n; ecx sum of numerators\n; r8 number of divisors\n\nsection .text\nglobal is_ore\nis_ore:\n      xor r8, r8\n      xor rcx,rcx\n      mov esi,edi\n@main:\n      mov eax,edi\n      xor rdx,rdx\n      idiv esi\n      test rdx,rdx\n      jnz @no_div\n      inc r8\n      add ecx,esi\n@no_div:\n      dec esi\n      jnz @main\n      \n      mov rax,rdi\n      mul r8    ; Multiply number of divisors with denominator \n      div rcx  ; divide on numerators\n      xor rax,rax\n      test rdx,rdx ; test for a remainder\n      setz al\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212618,"user_id":null,"body":"; esi current denominator\n; edi number tested\n; ecx sum of numerators\n; r8 number of divisors\n\nsection .text\nglobal is_ore\nis_ore:\n      xor r8, r8\n      xor rcx,rcx\n      mov esi,1\n@main:\n      mov eax,edi\n      xor rdx,rdx\n      idiv esi\n      test rdx,rdx\n      jnz @no_div\n      inc r8\n      add ecx,esi\n@no_div:\n      inc esi\n      cmp esi,edi\n      jle @main\n      mov rax,rdi\n      mul r8    ; Multiply number of divisors with denominator \n      div rcx  ; divide on numerators\n      xor rax,rax\n      test rdx,rdx ; test for a remainder\n      setz al\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212619,"user_id":null,"body":"section .text\nglobal is_ore\n; int is_ore(long n)\nis_ore:\n  mov ecx, edi   ; ecx holds trial divisor\n  mov ebx, 1     ; number of factors of n - throw in n for free\n  mov r8d, edi   ; sum of factors - throw in n for free\n  shr ecx, 1     ; start testing factors from the halfway point down to save time\n.loop1:\n  mov eax, edi\n  xor edx, edx\n  div ecx        ; does n divide by ecx with no remainder?\n  test edx, edx\n  jnz .skip1\n  inc ebx        ; yes, so inc counter of no of factors\n  add r8d, ecx   ; and accumulate sum of factors\n.skip1:\n  dec ecx\n  jnz .loop1\n                 ; now see if (n * no of factors) is divisible by (sum of factors)\n  mov eax, edi\n  mul ebx\n  xor edx, edx\n  div r8d\n  test edx, edx  \n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212620,"user_id":null,"body":"section .text\nglobal is_ore\n\n\n; rdi -> long, number to find divisors for\n; rsi -> last divisor\n; rax -> return: next divisor, or number to find divisors for if at end\nget_next_divisor:\n    xor rax, rax\n\n    mov rcx, rsi\n    cmp rsi, rdi\n    jge .return\n\n    inc rcx\n    .loop:\n        mov rax, rdi\n        xor rdx, rdx\n        div rcx\n        test rdx, rdx\n        jz .return\n        inc rcx\n        jmp .loop\n    .return:\n        mov rax, rcx\n        ret\n\n; rax -> common_multiple\n; r9  -> return total\nget_reciprocal_total:\n    xor rcx, rcx\n    xor r9, r9\n    .loop:\n        cmp rcx, rdx\n        je .end\n        mov r8, [rsp+rcx*8+8]\n        push rdx     ; save rdx for after divison\n        xor rdx, rdx ; clear rdx for divison\n        push rax     ; save rax for after divison\n        div r8       ; divide by r8\n        mov r8, rax\n        pop rax      ; move back rax and rdx\n        pop rdx\n        add r9, r8   ; add to total \n        inc rcx\n        jmp .loop\n    .end:\n        ret\n\n; int is_ore(long n)\nis_ore:\n    xor rax, rax ; return in rax\n    mov rcx, 0 ; loop counter\n    mov rdx, 0 ; number of divisors\n    .loop:\n        cmp rcx, rdi\n        je .end\n        mov rsi, rcx\n        push rdx     ; save rdx\n        call get_next_divisor\n        pop rdx\n        push rax     ; push found divisor\n        inc rdx      ; increment number of divisors\n\n        cmp rax, rdi ; if last divisor was base number, exit loop\n        je .end\n        mov rcx, rax ; skip to next found divisor\n        jmp .loop\n    .end:\n    mov rax, rdi\n    call get_reciprocal_total\n\n    mov rcx, rdx   ; these steps are equivalent to:\n    imul rax, rdx  ; ( # elements * common multiple ) \/ recip total\n    xor rdx, rdx\n    idiv r9\n\n    ; pop saved numbers off stack\n    .pop_loop:\n        test rcx, rcx\n        jz .end_pop_loop\n        dec rcx\n        pop r9\n        jmp .pop_loop\n    .end_pop_loop:\n    mov rax, 1\n    test rdx, rdx\n    jz .return\n    mov rax, 0\n\n    .return: ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212621,"user_id":743,"body":"global is_ore\n\nsection .text\n\n; eax             rdi\n; int is_ore(long n);\nis_ore:\n  xor r8d, r8d\n  xor r9d, r9d\n  xor esi, esi\n.loop:\n  add esi, 1\n  mov rax, rdi\n  xor edx, edx\n  div rsi\n  cmp rax, rsi\n  jbe .endl\n.loop_:\n  test rdx, rdx\n  jnz .loop\n  lea r8, [r8 + rdi * 2]\n  add r9, rsi\n  add r9, rax\n  add esi, 1\n  mov rax, rdi\n  xor edx, edx\n  div rsi\n  cmp rax, rsi\n  ja .loop_\n.endl:\n  jne .end\n  test rdx, rdx\n  jne .end\n  add r8, rdi\n  add r9, rsi\n.end:\n  mov rax, r8\n  xor edx, edx\n  div r9\n  xor eax, eax\n  test rdx, rdx\n  setz al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212622,"user_id":743,"body":"global is_ore\n\nsection .text\n\n; eax             rdi\n; int is_ore(long n);\nis_ore:\n  xor r8d, r8d\n  xor r9d, r9d\n  xor esi, esi\n.loop:\n  add esi, 1\n  mov r10d, esi\n  imul r10, r10\n  cmp r10, rdi\n  jae .endl\n.loop_:\n  mov rax, rdi\n  xor edx, edx\n  div rsi\n  test rdx, rdx\n  jnz .loop\n  lea r8, [r8 + rdi * 2]\n  add r9, rsi\n  add r9, rax\n  add esi, 1\n  mov r10d, esi\n  imul r10, r10\n  cmp r10, rdi\n  jb .loop_\n.endl:\n  jne .end\n  add r8, rdi\n  add r9, rsi\n.end:\n  mov rax, r8\n  xor edx, edx\n  div r9\n  xor eax, eax\n  test rdx, rdx\n  setz al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212623,"user_id":null,"body":"section .text\nextern printf\nglobal is_ore\n; int is_ore(long n)\nis_ore:\n  xor rcx, rcx\n  xor r9, r9\n  xor r10, r10\n  \n.loop:\n  inc rcx\n  mov rax, rdi\n  cqo\n  div rcx\n  cmp rcx, rax  ; if rcx > rdi\/rcx, then rcx > the square root\n  jg .found_all ; and we can stop looking\n  \n  test rdx, rdx\n  jnz .loop     ; not a factor; keep looking\n  \n  add r9, rax\n  inc r10\n  \n  cmp rax, rcx\n  je .found_all\n\n  add r9, rcx\n  inc r10\n  jmp .loop\n  \n.found_all:\n  mov rax, rdi\n  mul r10\n  div r9\n  xor rax, rax\n  test rdx, rdx\n  setz al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55beec7dd347078289000021":[{"id":212624,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax            ; RAX <- the result\n    mov ebx, 0\n.loop:\n    cmp rdi, 0\n    je .end\n    mov rdi, [rdi+node.next]\n    inc rax\n    jmp .loop\n.end:\n    ret\n; ---------> endof length <---------\n\n; rdi, esi\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax            ; RAX <- the result\n.loop:\n    cmp rdi, 0\n    je .end\n    mov ebx, [rdi+node.data]\n    cmp ebx, esi\n    jne .next\n    inc rax\n.next\n    mov rdi, [rdi+node.next]\n    jmp .loop\n.end:\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212625,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\nlength:\n  xor eax, eax\n.loop:\n  test rdi, rdi\n  je .done\n  mov rdi, [rdi + 8]\n  inc rax\n  jmp .loop\n.done:\n  ret\n\ncount:\n  xor eax, eax\n.loop:\n  test rdi, rdi\n  je .done\n  xor ecx, ecx\n  cmp [rdi], esi\n  mov rdi, [rdi + 8]\n  sete cl\n  add rax, rcx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212626,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax            ; RAX <- the result    \n.search_end:\n    cmp rdi, 0\n    je .end\n    inc rax\n    mov rdi, [rdi + node.next]\n    jmp .search_end\n.end:\n    ret\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax            ; RAX <- the result\n.search_end:\n    cmp rdi, 0\n    je .end\n    cmp dword [rdi + node.data], esi\n    jne .continue\n    inc rax\n.continue:\n    mov rdi, [rdi + node.next]\n    jmp .search_end\n.end:\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212627,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax            ; RAX <- the result\n    jmp .start_loop         ; 0 element list possible\n.loop:\n    inc rax                 ; count node\n    mov rdi, [rdi+node.next]\n.start_loop:\n    test rdi, rdi\n    jnz  .loop              ; not null, pointer to an node\n    ret\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax            ; RAX <- the result\n    jmp .start_loop         ; list could be empty\n.loop:\n    cmp esi, [rdi+node.data]\n    jne .not_equal\n    inc rax                 ; count this node\n.not_equal:\n    mov rdi, [rdi+node.next]\n.start_loop:\n    test rdi, rdi\n    jnz  .loop              ; not null, pointer to an node\n    ret\n; ---------> endof count <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212628,"user_id":881,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax            ; RAX <- the result\n.for_each_node:\n    test rdi, rdi\n    jz .end_each_node\n    inc rax\n    mov rdi, [rdi + node.next]\n    jmp .for_each_node\n.end_each_node:\n    ret\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax            ; RAX <- the result\n.for_each_node:\n    test rdi, rdi\n    jz .end_each_node\n    cmp esi, [rdi + node.data]\n    jne .no_match\n.match:\n    inc rax\n.no_match:\n    mov rdi, [rdi + node.next]\n    jmp .for_each_node\n.end_each_node:\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212629,"user_id":881,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax\n.for_each:\n    test rdi, rdi\n    jz .end\n    mov rdi, [rdi + node.next]\n    inc rax\n    jmp .for_each\n.end:\n    ret\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax\n.for_each:\n    test rdi, rdi\n    jz .end\n    cmp esi, dword[rdi + node.data]\n    mov rdi, [rdi + node.next]\n    jne .for_each\n    inc rax\n    jmp .for_each\n.end:\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212630,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor eax, eax            ; RAX <- the result\n    test rdi, rdi\n    jz .done\n.loop:\n    inc rax\n    mov rdi, [rdi+node.next]\n    test rdi, rdi\n    jnz .loop\n.done:\n    ret\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor eax, eax            ; RAX <- the result\n    xor ecx, ecx\n    test rdi, rdi\n    jz .done\n.loop:\n    cmp esi, [rdi+node.data]\n    sete cl\n    add rax, rcx\n    mov rdi, [rdi+node.next]\n    test rdi, rdi\n    jnz .loop\n.done:\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212631,"user_id":104,"body":"; 2022 nomennescio\n\nglobal length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\n; input: rdi = list\n; callee saved registers: rbx, rsp, rbp, r12-r15\n; output: rax = length of list\n\nlength:\n    xor rax, rax \n.recurse:\n    test rdi,rdi\n    je .end\n    mov rdi,[rdi+8]\n    inc rax\n    jmp .recurse\n.end:\n    ret\n\n; <--- size_t count(struct node *list, int data) --->\n; input: rdi = list, rsi = data\n; callee saved registers: rbx, rsp, rbp, r12-r15\n; output: rax = number of nodes equal to 'data'\n\ncount:\n    xor rax, rax            ; RAX <- the result\n.recurse:\n    test rdi,rdi\n    je .end\n    cmp esi,[rdi]\n    jne .skip\n    inc rax\n.skip:    \n    mov rdi,[rdi+8]\n    jmp .recurse\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212632,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax            ; RAX <- the result\n    xor rdx, rdx\nlength_loop:\n    cmp rdi, rdx\n    jz return\n    inc rax\n    mov rdi, qword [rdi + node.next]\n    jmp length_loop\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax            ; RAX <- the result\n    xor rdx, rdx\ncount_loop:\n    cmp rdi, rdx\n    jz return\n    cmp [rdi], rsi\n    mov rdi, qword [rdi + node.next]\n    jnz count_loop\n    inc rax\n    jmp count_loop\nreturn:                     ;shared return\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212633,"user_id":null,"body":"global length, count\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- size_t length(struct node *list) --->\nlength:\n    xor rax, rax            ; RAX <- the result\n    xor rdx, rdx\nlength_loop:\n    cmp rdi, rdx\n    jz return\n    inc rax\n    mov rdi, qword [rdi + node.next]\n    jmp length_loop\n; ---------> endof length <---------\n\n; <--- size_t count(struct node *list, int data) --->\ncount:\n    xor rax, rax            ; RAX <- the result\n    xor rdx, rdx\ncount_loop:\n    cmp rdi, rdx\n    jz return\n    mov rcx, [rdi]\n    mov rdi, qword [rdi + node.next]\n    cmp rcx, rsi\n    jnz count_loop\n    inc rax\n    jmp count_loop\nreturn:                     ;shared return\n    ret\n; ---------> endof count <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55cbc3586671f6aa070000fb":[{"id":212634,"user_id":null,"body":"section .text\n\nglobal check_for_factor\n; bool check_for_factor([positive] int base, [positive] int factor);\n; arguments: base - EDI, factor - ESI\n; store 1 in AL if result is true, or 0 otherwise\n\ncheck_for_factor:\n  xor edx, edx\n  mov eax, edi\n  idiv esi\n  cmp edx, 0\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212635,"user_id":168,"body":"section .text\n\nglobal check_for_factor\n; bool check_for_factor([positive] int base, [positive] int factor);\n; arguments: base - EDI, factor - ESI\n; store 1 in AL if result is true, or 0 otherwise\n\ncheck_for_factor:\n  mov eax, edi\n  xor edx, edx\n  div esi\n  test edx, edx\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212636,"user_id":527,"body":"section .text\n\nglobal check_for_factor\n; bool check_for_factor([non-negative] int base, [positive] int factor)\ncheck_for_factor:\n                xor     edx, edx\n                mov     eax, edi\n                idiv    esi\n                test    edx, edx\n                setz    al\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212637,"user_id":null,"body":"section .text\nglobal check_for_factor\ncheck_for_factor:\n  cdq\n  idiv esi\n  cmp edx, 0\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212638,"user_id":null,"body":"section .text\n\nglobal check_for_factor\n; bool check_for_factor([positive] int base, [positive] int factor);\n; arguments: base - EDI, factor - ESI\n; store 1 in AL if result is true, or 0 otherwise\n\ncheck_for_factor:\n  xor edx,edx\n  mov eax,edi\n  div esi\n  mov eax,1\n  cmp edx,0\n  je end\n  xor eax,eax\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212639,"user_id":null,"body":"section .text\nglobal check_for_factor\n\ncheck_for_factor:\n  mov al, 1\n  xor rdx, rdx\n  mov rax, rdi\n  div rsi\n  cmp rdx, 0\n  jg is_not\n  mov rax, 1\n  ret\n  \nis_not:\n  xor al, al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212640,"user_id":46,"body":"section .text\nglobal check_for_factor\ncheck_for_factor:\n  mov eax, edi ; prepare for division\n  xor edx, edx ; edx = 0, to prevent SIGFPE\n  div esi ; division, remainder in edx\n  cmp edx, 0 ; modifies the zero flag if edx is 0\n  sete al ; if zero flag is 1, set al to 1, else set al to 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212641,"user_id":46,"body":"section .text\nglobal check_for_factor\ncheck_for_factor:\n  mov eax, edi\n  mov edx, 0\n  div esi\n  cmp edx, 0\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212642,"user_id":46,"body":"section .text\nglobal check_for_factor\ncheck_for_factor:\n  mov eax, edi\n  mov edx, 0\n  div esi\n  cmp edx, 0\n  jne _return_false\n  mov al, 1\n  ret\n  _return_false:\n  mov al, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212643,"user_id":null,"body":"section .text\n\nglobal check_for_factor\n; bool check_for_factor([positive] int base, [positive] int factor);\n; arguments: base - EDI, factor - ESI\n; store 1 in AL if result is true, or 0 otherwise\n\ncheck_for_factor:\n  mov   edx, 0\n  mov   eax, edi\n  div   esi\n  test  edx, edx\n  je    factor\n  mov   al, 0\n  jmp   exit\nfactor:\n  mov   al, 1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55cbd4ba903825f7970000f5":[{"id":212644,"user_id":null,"body":"global get_grade\nget_grade:\n  lea rax,[rsi+rdi]\n  add rax,rdx\n  xor rdx,rdx\n  mov rcx,30\n  div rcx\n  movzx rax,byte[.grade+rax]\nret\n.grade db 'FFFFFFDCBAA'","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212645,"user_id":173,"body":"section .text\nglobal get_grade\n\n; char get_grade(int a, int b, int c);\nget_grade:\n    mov rax, 0\n    add eax, esi\n    add eax, edi\n    add eax, edx\n    mov rdx, 0\n    mov rcx, 3\n    div rcx\n    cmp rax, 90\n    jae l_a\n    cmp rax, 80\n    jae l_b\n    cmp rax, 70\n    jae l_c\n    cmp rax, 60\n    jae l_d\n    jmp l_f\nl_a:\n    mov al, 'A'\n    ret\nl_b:\n    mov al, 'B'\n    ret\nl_c:\n    mov al, 'C'\n    ret\nl_d:\n    mov al, 'D'\n    ret\nl_f:\n    mov al, 'F'\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212646,"user_id":null,"body":"section .text\nglobal get_grade\nout1 db 'FFFFFFDCBAA'\n\n; char get_grade(int a, int b, int c);\nget_grade:\n  add rsi,rdx\n  add rdi,rsi\n  mov rbx,30\n  mov rax,rdi\n  xor rdx,rdx\n  div rbx\n  mov rax,[out1+rax]\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212647,"user_id":null,"body":"section .text\nglobal get_grade\n\n; char get_grade(int a, int b, int c);\nget_grade:\n    mov rax, rdi\n    add rax, rsi\n    add rax, rdx\n    mov rcx, 3\n    mov rdx, 0\n    div rcx\n    cmp rax, 90\n    jge A_GRADE\n    cmp rax, 80\n    jge B_GRADE\n    cmp rax, 70\n    jge C_GRADE\n    cmp rax, 60\n    jge D_GRADE\n    cmp rax, 60\n    jl F_GRADE\n    \nA_GRADE:\n    mov rax, 'A'\n    jmp EXIT\nB_GRADE:\n    mov rax, 'B'\n    jmp EXIT\nC_GRADE:\n    mov rax, 'C'\n    jmp EXIT\nD_GRADE:\n    mov rax, 'D'\n    jmp EXIT\nF_GRADE:\n    mov rax, 'F'\n    jmp EXIT\n    \n\nEXIT:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212648,"user_id":null,"body":"section .text\nglobal get_grade\n\n; char get_grade(int a, int b, int c);\nget_grade:\n    xor rax, rax\n    add eax, edi\n    add eax, esi\n    add eax, edx\n    mov edx, 0\n    mov ecx, 3\n    div ecx\n    cmp eax, 90\n    jae a\n    cmp eax, 80\n    jae b\n    cmp eax, 70\n    jae c\n    cmp eax, 60\n    jae d\n    jmp f\na:\n    mov eax, 'A'\n    jmp return\nb:\n    mov eax, 'B'\n    jmp return\nc: \n    mov eax, \"C\"\n    jmp return\nd: \n    mov eax, \"D\"\n    jmp return\nf:\n    mov eax, \"F\"\nreturn:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212649,"user_id":null,"body":"section .text\nglobal get_grade\n\n; char get_grade(int a, int b, int c);\nget_grade:\n  lea eax, [rdi + rsi]\n  add eax, edx\n  mov rcx, 30\n  cdq\n  idiv ecx\n  cdqe\n  lea rcx, [.grades]\n  mov al, [rax + rcx]\n  ret\n.grades: db \"FFFFFFDCBAA\"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212650,"user_id":null,"body":"section .data\n_arr db 'FFFFFFDCBAA'\n\nsection .text\nglobal get_grade\n\n;int a, int b, int c\n;rdi, rsi, rdx\nget_grade:\n    lea  rax, [rsi+rdi]\n    add  rax, rdx\n    xor  rdx, rdx\n    mov  rcx, 30\n    div  rcx\n    movzx rax, byte[_arr+rax]\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212651,"user_id":null,"body":"section .text\nglobal get_grade\n; char get_grade(int a, int b, int c);\nget_grade:\n    xor  rax, rax\n    mov  rax, rdi\n    add  rax, rsi\n    add  rax, rdx\n    xor  rdx, rdx\n    mov  rcx, 3\n    div  rcx\n    \n    cmp  rax, 90\n    jge  _A\n    cmp  rax, 80\n    jge  _B\n    cmp  rax, 70\n    jge  _C\n    cmp  rax, 60\n    jge  _D\n    jl   _F\n    \n_A:\n    mov  al, 'A'\n    ret\n_B:\n    mov  al, 'B'\n    ret\n_C:\n    mov  al, 'C'\n    ret\n_D:\n    mov  al,  'D'\n    ret\n_F:\n    mov  al, 'F'\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212652,"user_id":1400,"body":"\n\nsection .data\narr db \"FFFFFFDCBAA\"\n\nsection .text\nglobal get_grade\n\n; char get_grade(int a, int b, int c);\n;rdi, rsi, rdx\nget_grade:\n  mov rax, 0\n  mov rcx, 0\n  \n  add eax, edi\n  add eax, esi\n  add eax, edx\n  \n  mov edx, 0\n  mov ecx, 30\n  div ecx\n  \n  ;sub eax, 5\n  mov al, [arr+eax]\n  \n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212653,"user_id":1400,"body":"section .data\narr db 'F','D','C','B','A','A'\n\nsection .text\nglobal get_grade\n\n; char get_grade(int a, int b, int c);\n;rdi, rsi, rdx\nget_grade:\n  mov rax, 0\n  mov rcx, 0\n  \n  add eax, edi\n  add eax, esi\n  add eax, edx\n  \n  mov edx, 0\n  mov ecx, 3\n  div ecx\n  \n  mov edx, 0\n  mov ecx, 10\n  div ecx\n\n  cmp eax, 5\n  jl other\n  \n  sub eax, 5\n  mov al, [arr+eax]\n  jmp end\n  \nother:\n  mov al, 'F'\n\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55d24f55d7dd296eb9000030":[{"id":212654,"user_id":null,"body":"section .text\nglobal summation\nsummation:  \n  lea eax, [edi+1] ; edi = arg0\n  imul eax, edi\n  shr eax, 1\n  ret           ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212655,"user_id":527,"body":"section .text\nglobal summation\nsummation:\n                lea     eax, [edi + 1]\n                imul    eax, edi\n                shr     eax, 1\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212656,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  lea eax, [edi+1]\n  mul edi\n  shr eax, 1\n  ret           ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212657,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  xor eax, eax\n.loop:\n  test edi, edi\n  jz .exit\n  add eax, edi\n  dec edi\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212658,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  lea eax, [edi]\n  mul edi\n  add eax, edi\n  shr eax, 1\n  ret       ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212659,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  mov eax, edi  ; edi = arg0\n  mov ecx, eax  ; use ecx for current number\n  ; eax is the accumulator\nloop:\n  ; n-1\n  dec ecx\n  ; n + n-1\n  add eax, ecx\n  ; n + n-1 + n-2 + n-3 ...\n  cmp ecx, 0\n  jne loop\n  \ndone:\n  ret           ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212660,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  xor eax, eax\n  xor ecx, ecx\nloop:\n  inc ecx\n  add eax, ecx\n  cmp ecx, edi\n  jne loop\n  ret           ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212661,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  mov eax,0\n  loop1:\n  add eax,edi\n  dec edi\n  jnz loop1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212662,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  lea ecx, [rdi + 1]\n  imul ecx, edi\n  mov eax, ecx\n  shr eax, 31\n  add eax, ecx\n  sar eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212663,"user_id":null,"body":"section .text\nglobal summation\nsummation:\n  mov eax, edi  ; edi = arg0\n  mov ebx, 1\n  mov ecx,1\nlp:\n  sub eax,1\n  jz end\n  add ecx,1\n  add ebx,ecx\n  jnz lp  \nend:\n  mov eax, ebx\n  ret           ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55e6f5e58f7817808e00002e":[{"id":212664,"user_id":168,"body":"global seven\nsection .data\nresult: dd 0, 0\nsection .text\n; input: rdi = m\n; output: rax\nseven:\n  mov rax, rdi\n  mov r8, 10\n  xor rcx, rcx\n.loop:\n  cmp rax, 100\n  jl .end\n  xor rdx, rdx\n  div r8\n  shl rdx, 1\n  sub rax, rdx\n  inc rcx\n  jmp .loop\n.end:\n  mov dword [result], eax\n  mov dword [result + 4], ecx\n  mov rax, result\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212665,"user_id":null,"body":"global seven\nsection .data\nresult: dd 0, 0\nsection .text\n; input: rdi = m\n; output: rax\nseven:\n  mov rax, rdi\n  xor ecx, ecx\n  mov esi, 10\n.loop:\n  cmp rax, 99\n  jle .done\n  cqo\n  inc ecx\n  idiv rsi\n  add rdx, rdx\n  sub rax, rdx\n  jmp .loop\n.done:\n  mov [result], eax\n  mov eax, result\n  mov [result+4], ecx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212666,"user_id":null,"body":"global seven\nSECTION .text\n\nseven:\n  xor rcx, rcx\n  mov r8, 10\n.next:\n  cmp rax, 100\n  jl .end\n  inc rcx\n  xor rdx, rdx\n  div r8\n  shl rdx, 1\n  sub rax, rdx\n  jmp .next\n.end:\n  mov [result], rax\n  mov [result+4], rcx\n  lea rax, [result]\n  ret\n  \nSECTION .data\nresult: dd 0, 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212667,"user_id":null,"body":"global seven\nSECTION .text\n\nseven:\n  xor rcx, rcx\n  mov r8, 10\n.next:\n  cmp rdi, 100\n  jl .end\n  inc rcx\n  mov rax, rdi\n  xor rdx, rdx\n  div r8\n  shl rdx, 1\n  sub rax, rdx\n  mov rdi, rax\n  jmp .next\n.end:\n  mov [result], rdi\n  mov [result+4], rcx\n  mov rax, result\n  ret\n  \nSECTION .data\nresult: dd 0, 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212668,"user_id":null,"body":"global seven\nsection .data\nresult: dd 0, 0\nsection .text\nseven:            mov rax, rdi\n                  mov r8, 10\n                  xor rcx, rcx\n@main_loop:       cmp rax, 100\n                  jl  @cooked\n                  xor rdx, rdx\n                  div r8\n                  add rdx, rdx\n                  sub rax, rdx\n                  inc rcx\n                  jmp @main_loop\n@cooked:          mov [result], eax\n                  mov [result + 4], ecx\n                  lea rax,[result]\n                  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212669,"user_id":null,"body":"global seven\nsection .data\nresult: dd 0, 0\nsection .text\nseven:            mov r8,10    \n                  xor rcx,rcx\n@main_loop:       cmp rax,100\n                  jl  @cooked\n                  xor rdx,rdx\n                  div r8\n                  add rdx,rdx\n                  sub rax,rdx\n                  inc rcx\n                  jmp @main_loop\n@cooked:          mov [result],eax\n                  mov [result + 4],ecx\n                  lea rax,[result]\n                  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212670,"user_id":77,"body":"global seven\nsection .data\nresult: dd 0, 0\nsection .text\n; input: rdi = m\n; output: rax\nseven:\n  xor rcx, rcx\n  mov rsi, 10\n  mov rax, rdi\n  cmp rax, 100\n  jl .end\n.loop:\n  xor rdx, rdx\n  div rsi\n  shl rdx, 1\n  sub rax, rdx\n  inc rcx\n  cmp rax, 100\n  jge .loop\n.end:\n  mov [result], eax\n  mov rax, result\n  mov [rax+4], ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212671,"user_id":null,"body":"global seven\nsection .data\nresult: dd 0, 0\n\nsection .text\n \nseven:\n  xor rcx, rcx\n  mov rax, rdi\n  mov rbx, 10\n  cmp rdi, 0\n  jnz main\n  mov dword[result], 0\n  mov dword[result+4], 0\n  mov rax, result\n  ret\nmain:\n  xor rdx, rdx\n  idiv rbx\n  shl rdx, 1\n  sub rax, rdx\n  inc rcx\n  cmp rax, 100\n  jge main\n  mov dword[result], eax\n  mov dword[result+4], ecx\n  mov rax, result\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212672,"user_id":null,"body":"global seven\nsection .data\n  result: dd 0, 0\n  ten: dq 10\n\nsection .text\n; input: rdi = m\n; output: rax\nseven:\n  mov qword [result], 0\n  \n  .check_end:\n  cmp rdi, 100\n  jl .end_loop\n    mov rax, rdi\n    xor rdx, rdx\n    div qword [ten]\n    shl rdx, 1\n    sub rax, rdx\n    mov rdi, rax\n    inc dword [result + 4]\n    jmp .check_end\n    \n  .end_loop:\n  mov [result], edi\n  mov rax, result\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212673,"user_id":220,"body":"global seven\nsection .data\nresult: dd 0, 0\nsection .text\n; input: rdi = m\n; output: rax\nseven:\n\n  mov rcx, result\n  mov rbx, 10\n  mov rax, rdi\n  xor rsi, rsi\n  \nloop:\n  cmp rax, 100\n  jl done\n  xor rdx, rdx\n  idiv rbx\n  \n  neg rdx\n  lea rax, [rax + 2*rdx]\n  \n  inc rsi\n  jmp loop\n  \ndone:\n  mov [ecx], eax\n  mov [ecx+4], esi\n  mov eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55eca815d0d20962e1000106":[{"id":212674,"user_id":null,"body":"section .text\nglobal generate_range\nextern malloc\n\n;  1) dynamically allocate memory for the return array\n;  2) assign the size of this array to the pointer *sz\n\n; int *generate_range(int min, int max, int step, size_t *sz)\n; min -> edi, max -> esi, step -> edx, *sz -> rcx, *result -> rax\ngenerate_range:\n  push rbp\n  push r14\n  push rbx\n  mov r14d, edx\n  mov eax, esi\n  mov ebp, edi\n  sub eax, edi\n  cdq\n  idiv r14d\n  mov ebx, eax\n  cdqe\n  inc ebx\n  lea rdx, [rax + 1]\n  mov [rcx], rdx\n  lea rdi, [4*rax + 4]\n  call malloc\n  xor ecx, ecx\n.loop:\n  cmp rbx, rcx\n  je .done\n  mov [rax + 4*rcx], ebp\n  inc rcx\n  add ebp, r14d\n  jmp .loop\n.done:\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212675,"user_id":null,"body":"section .text\nglobal generate_range\nextern malloc\n\n;  1) dynamically allocate memory for the return array\n;  2) assign the size of this array to the pointer *sz\n\n; int *generate_range(int min, int max, int step, size_t *sz)\n; min -> edi, max -> esi, step -> edx, *sz -> rcx, *result -> rax\ngenerate_range:\n  push rbx\n  push rbp\n  push r12\n  mov ebx, edi\n  mov ebp, esi\n  mov r12d, edx\n  mov eax, ebp\n  sub eax, ebx\n  cdq\n  idiv r12d\n  inc eax\n  mov [rcx], eax\n  lea edi, [eax*4]\n  call malloc\n  xor edx, edx\n  mov ecx, ebx\n  .loop:\n  cmp ecx, ebp\n  jg .done\n  mov dword [rax+rdx*4], ecx\n  add ecx, r12d\n  inc edx\n  jmp .loop\n  .done:\n  pop r12\n  pop rbp\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212676,"user_id":null,"body":"extern malloc\n\nsection .text\nglobal generate_range\n\n  \n\n;  1) dynamically allocate memory for the return array\n;  2) assign the size of this array to the pointer *sz\n\n; int *generate_range(int min, int max, int step, size_t *sz)\n; min -> edi, max -> esi, step -> edx, *sz -> rcx, *result -> rax\ngenerate_range:\n  \n.allocate:\n  push rdx\n  push rcx\n  push rdi\n  push rsi\n  mov rdi, 350\n  shl rdi, 5\n  call malloc\n  pop rsi\n  pop rdi\n  pop rcx\n  pop rdx\n \n  xor r10, r10\n  \n.while:\n  mov dword [rax + r10 * 4], edi\n  inc r10\n  add edi, edx\n  cmp edi, esi\n  jbe .while\n\n  lea r8, [rcx]\n  mov [r8], r10\n  \n.exit:\n  ret ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212677,"user_id":null,"body":"global generate_range\nextern malloc\ngenerate_range:\n  lea  rax,[rsi+rdx]\n  sub  rax,rdi\n  mov  r8,rdx\n  cqo\n  div  r8\n  push rdi\n  push r8\n  mov  [rcx],eax\n  lea  rdi,[rax*4]\n  push rdi\n  call malloc\n  pop  rcx  \n  pop  r8\n  pop  rdi\n  lea  rsi,[rax+rcx]\n  neg  rcx\n  .b:mov [rsi+rcx],edi\n     add rdi,r8\n     add rcx,4\n  jne .b\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212678,"user_id":null,"body":"global generate_range\nextern malloc\n\nsection .text\n\n; int *generate_range(int min, int max, int step, size_t* n)\ngenerate_range:\n    push rbp\n    mov rbp, rsp\n    sub rsp, 0x8\n    mov rax, rsi\n    sub rax, rdi\n    mov r8, rdx\n    xor rdx, rdx\n    idiv r8\n    mov rdx, r8 ;restore step\n    inc rax\n    mov qword [rcx], rax\n    imul rax, 0x4\n    push rdx\n    push rdi\n    push rcx\n    mov rdi, rax\n    call malloc wrt ..plt\n    pop rcx\n    pop rdi\n    pop rdx\n    mov [rbp-0x8], rax\n    mov r8, 0\n    .label:\n    \tcmp r8, [rcx]\n\tjge .done\n\n\tmov rax, rdi\n\tmov r9, r8\n\timul r9, rdx\n\tadd rax, r9\n\n\tmov r9, [rbp-0x8]\n\tmov [r9+0x4*r8], eax\n\n\tinc r8\n\tjmp .label\n\n.done:\n    mov rax, [rbp-0x8]\n    leave\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212679,"user_id":168,"body":"section .text\nglobal generate_range\nextern malloc\n\n;  1) dynamically allocate memory for the return array\n;  2) assign the size of this array to the pointer *sz\n\n; int *generate_range(int min, int max, int step, size_t *sz)\n; min -> edi, max -> esi, step -> edx, *sz -> rcx, *result -> rax\ngenerate_range:\n  mov eax, esi\n  sub eax, edi\n  mov esi, edx\n  xor edx, edx\n  div esi\n  inc eax\n  mov qword [rcx], rax\n  push rax\n  push rdi\n  push rsi\n  lea rdi, [4 * rax]\n  call malloc\n  pop rsi   ; step\n  pop rdi   ; min\n  pop rcx   ; len\n  mov rdx, rax\n.loop:\n  mov dword [rdx], edi\n  add rdx, 4\n  add edi, esi\n  dec rcx\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212680,"user_id":881,"body":"section .text\nglobal generate_range\nextern malloc\n\n;  1) dynamically allocate memory for the return array\n;  2) assign the size of this array to the pointer *sz\n\n; int *generate_range(int min, int max, int step, size_t *sz)\n; min -> edi, max -> esi, step -> edx, *sz -> rcx, *result -> rax\ngenerate_range:\n    mov r9d, edx        ; move step to r9d\n    xor rdx, rdx        ; clear rdx for division\n    mov eax, esi        ; len = (max\n    sub eax, edi        ;            - min)\n    div r9              ;                  \/ step\n    inc eax             ;                         + 1\n    mov dword[rcx], eax      ; *sz = len\n    push rax\n    push r9\n    push rdi            ; save registers for malloc call\n    lea rdi, [rax*4]    \n    call malloc         ; rax = array = malloc(len * sizeof(int))\n    pop rdi             ; rdi = min\n    pop rsi             ; rsi = step\n    pop rcx             ; rcx = len\n    xor r9, r9          ; r9 = i\n.loop:                  ; for i = 0:len-1\n    mov dword[rax + 4*r9], edi ; array[i] = min\n    add edi, esi          ; min += step\n    inc r9d                \n    cmp r9d, ecx\n    jne .loop           ; end\n.done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55ecd718f46fba02e5000029":[{"id":212681,"user_id":null,"body":"section .text\nglobal between\nbetween:\n  mov [rdx],edi\n  inc edi\n  add rdx,4\n  cmp edi,esi\n  jle between\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212682,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                         Written by Ali Muhammed\n;                           uniapi@outlook.com\n;                             June 22, 2022\n; ----------------------------------------------------------------------\nglobal between\n\n; Note: also tested on real AVX512F!\n\n; <-- between(EDI a, ESI b, [dword RDX] integers) -->\nbetween:\n    push rbx                        ; saving RBX onto stack\n    push rdx                        ; saving <integers> onto stack\n    inc esi                         ; incrementing <b> and\n    sub esi, edi                    ;       subtracting <a> to get the <n>umber of elements\n    push rsi                        ; saving <n> onto stack\n    push rdi                        ; saving <a> onto stack\n    mov eax, 7                      ; setting EAX=7, ECX=0\n    xor ecx, ecx                    ;       to get\"Extended Features\"\n    cpuid                           ;               executing CPUID\n    pop rax                         ; restoring <a> from stack\n    pop rcx                         ; restoring <n> from stack\n    pop rdi                         ; restoring <integers> from stack\n    xor esi, esi                    ; resetting RSI as <i>\n    mov edx, ecx                    ; copying <n> to RDX as <v>\n    test ebx, 1 << 16               ; whether CPU supports AVX512F\n    pop rbx                         ; restoring RBX from stack\n    jne .avx512f                    ; then jumping to .avx512f\n    and edx, 0xFFFFFFF8             ; getting max <vi>ndex for .v8loop\n    je .v8stop                      ; jumping to .v8stop if <vi> is zero\n    vmovd xmm0, eax                 ; moving <a> to XMM0\n    vpbroadcastd ymm0, xmm0         ; broadcasting <a> to 8 lanes of YMM0: | a | a | a | a | a | a | a | a |\n    mov rax, .ininums               ; pointing RAX to <.ininums>\n    vpaddd ymm0, ymm0, [rax]        ; adding eight lanes in YMM0 and <.ininums> as <vs>\n    mov eax, 8                      ; copying 8 to EAX\n    vmovd xmm1, eax                 ; moving 8 to XMM1\n    vpbroadcastd ymm1, xmm1         ; broadcasting to 8 lanes of YMM1: | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | as <v8>\n.v8loop:\n    vmovdqu [rdi+rsi*4], ymm0       ; storing <vs> in <integers+i[0..7]>\n    vpaddd ymm0, ymm0, ymm1         ; adding <v8> to <vs>\n    add esi, 8                      ; incrementing <i> by eight elements\n    cmp esi, edx                    ; whether <i> is below <v>\n    jb .v8loop                      ; then jumping to the next .v8loop iteration\n    mov eax, [rdi+rsi*4-4]          ; setting EDX to <integers[i-1]>, i.e. the last already stored element\n    inc eax                         ; getting the next element <s>\n.v8stop:\n    mov edx, ecx                    ; setting <v> to <n>\n    sub edx, esi                    ; subtracting <i> from <v>\n    and edx, 0xFFFFFFFE             ; whether there are v2 loops\n    je .exit                        ; otherwise, jumping to exit\n    cmp eax, 0                      ; whether <a> is greater than or equal to zero\n    jl .exit                        ; otherwise, jumping to exit\n    add edx, esi                    ; adding <i> to <v>\n    mov r8d, eax                    ; copying <s> to R8D\n    shl rax, 32                     ; shifting EAX 32 bits left\n    or rax, r8                      ; getting broadcast <s> as 2 lanes in RAX: | s | s |\n    mov r8, 0x100000000             ; setting R8 to | 1 | 0 |\n    add rax, r8                     ; setting <vs> to | s+1 | s |\n    mov r8, 0x200000002             ; setting R8 as <v2>: | 2 | 2 |\n.v2loop:\n    mov [rdi+rsi*4], rax            ; storing <vs> in <integers+i[0..1]>\n    add rax, r8                     ; adding <v2> to <vs>\n    add rsi, 2                      ; incrementing <i> by two elements\n    cmp rsi, rdx                    ; whether <i> is below <v>\n    jb .v2loop                      ; then jumping to the next .v2loop iteration\n    jmp .exit                       ; jumping to exit\n.loop:\n    mov [rdi+rsi*4], eax            ; storing the last element in <integers[i]>\n    inc esi                         ; incrementing <i> by one element\n    inc eax                         ; getting the next <s> element\n.exit:\n    cmp esi, ecx                    ; whether <i> is below <n>\n    jb .loop                        ; then jumping to the next iteration\n    ret\n.avx512f:\n    vmovd xmm0, eax                 ; moving <a> to XMM0\n    vpbroadcastd zmm0, xmm0         ; broadcasting <a> to 16 lanes of ZMM0\n    mov rax, .ininums               ; pointing RAX to <.ininums>\n    vpaddd zmm0, zmm0, [rax]        ; adding 16 lanes in ZMM0 and <.ininums> as <vs>\n    and edx, 0xFFFFFFF0             ; getting max <vi>ndex for .v16loop\n    je .v16stop                     ; jumping to .v16stop if there are no .v16loop iterations\n    mov eax, 16                     ; copying 16 to EAX\n    vmovd xmm1, eax                 ; moving 16 to XMM1\n    vpbroadcastd zmm1, xmm1         ; broadcasting to 16 lanes of ZMM1\n.v16loop:\n    vmovdqu32 [rdi+rsi*4], zmm0     ; storing <vs> in <integers+i[0..15]>\n    vpaddd zmm0, zmm0, zmm1         ; adding <v16> to <vs>\n    add esi, 16                     ; incrementing <i> by 16 elements\n    cmp esi, edx                    ; whether <i> is below <v>\n    jb .v16loop                     ; then jumping to the next .v16loop iteration\n.v16stop:\n    sub ecx, esi                    ; subtracting <i> from <n>\n    mov edx, 0xFFFFFFFF             ; preparing mask\n    shl edx, cl                     ;       for the\n    not edx                         ;           elements left\n    kmovd k1, edx                   ; moving <msk> to K1 mask register\n    vmovdqu32 [rdi+rsi*4] {k1}, zmm0; storing <vs> in <integers+i[msk]> using <msk>\n    ret\n.ininums:\n    dd  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\n; -----> endof between <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212683,"user_id":null,"body":"section .text\nglobal between\n\nbetween:\n.loop:\n  mov [rdx], edi\n  add rdx, 4\n  inc edi\n  cmp edi, esi\n  jle .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212684,"user_id":null,"body":"section .text\nglobal between\nbetween:\n  mov rcx,0\n  loop1:\n  mov [rdx+rcx*4],edi\n  inc edi\n  inc rcx\n  cmp edi,esi\n  jle loop1\n  mov rax,rdx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212685,"user_id":null,"body":"section .text\nglobal between\n\n; void between(int a, int b, int *integers)\n; a -> edi, b -> esi, *integers -> rdx\n; assign function results to provided array\nbetween:\n    xor rax,rax\n    mov rax,rdx\nbefore_loop:\n    cmp edi,esi\n    jle loop\n    ret\nloop:\n    mov dword[rdx],edi\n    add edi,1\n    add rdx,4\n    jmp before_loop\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212686,"user_id":null,"body":"section .text\nglobal between\n\n; void between(int a, int b, int *integers)\n; a -> edi, b -> esi, *integers -> rdx\n; assign function results to provided array\nbetween:\n  sub esi, edi\n  inc esi\n  movsxd rax, esi\n  mov ecx, edi\n  xor esi, esi\n.loop:\n  cmp rsi, rax\n  jg .done\n  lea edi, [rcx + rsi]\n  mov dword [rdx + 4*rsi], edi\n  inc rsi\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212687,"user_id":168,"body":"section .text\nglobal between\n\n; void between(int a, int b, int *integers)\n; a -> edi, b -> esi, *integers -> rdx\n; assign function results to provided array\nbetween:\n.loop:\n  mov [rdx], edi\n  inc edi\n  add rdx, 4\n  cmp edi, esi\n  jle .loop\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212688,"user_id":527,"body":"section .text\nglobal between\n\n; void between(int a, int b, int *integers)\nbetween:\n                mov     [rdx], edi\n                inc     edi\n                add     rdx, 4\n                cmp     edi, esi\n                jle     between\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212689,"user_id":50,"body":"section .text\nglobal between\n\n; void between(int a, int b, int *integers)\n; a -> edi, b -> esi, *integers -> rdx\n; assign function results to provided array\nbetween:\n    xor rax, rax\n_loop:\n    cmp edi,esi\n    jg _exit\n    mov [rdx + 4 * rax], edi\n    inc edi\n    inc rax\n    jmp _loop\n_exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212690,"user_id":881,"body":"section .text\nglobal between\n\n; void between(int a, int b, int *integers)\n; a -> edi, b -> esi, *integers -> rdx\n; assign function results to provided array\nbetween:\n    cmp edi, esi\n    jg .end\n    mov [rdx], edi\n    add rdx, 4\n    inc edi\n    jmp between\n.end:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55f2b110f61eb01779000053":[{"id":212691,"user_id":null,"body":"global get_sum\nsection .text\n\n; int get_sum(int a, int b)\nget_sum:\n    xor eax, eax\n    cmp edi, esi\n    jge .loop\n    xchg edi, esi\n.loop:\n    add eax, edi\n    dec edi\n    cmp edi, esi\n    jge .loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212692,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n    ;xor eax, eax        ; EAX <- the result\n    lea     eax, [edi + esi]\n    ; abs(rdi - rsi)\n    sub     edi, esi\n    mov     ecx, edi\n    neg     ecx\n    cmovns  edi, ecx\n    \n    inc     edi\n    mul     edi\n    sar     eax, 1\n    ret\n; -----> endof get_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212693,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n  mov eax, edi\n  sub eax, esi\n  jns .skip \n  neg rax\n  \n.skip:\n  inc rax\n  add rdi, rsi\n  imul rdi\n  sar eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212694,"user_id":168,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n  lea eax, [rdi + rsi]\n  sub edi, esi\n  mov ecx, edi\n  neg edi\n  cmovns ecx, edi\n  inc ecx\n  imul ecx\n  sar eax, 1\n  ret\n; -----> endof get_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212695,"user_id":527,"body":"global get_sum\n\nsection .text\n\n; int get_sum(int a, int b)\nget_sum:\n                lea     eax, [rdi + rsi]\n                mov     edx, esi\n                sub     edx, edi\n                sub     edi, esi\n                cmovs   edi, edx\n                inc     edi\n                imul    eax, edi\n                sar     eax, 1\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212696,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n  xor eax, eax\n  cmp edi, esi\n  jl .loop\n  xchg edi, esi\n.loop:\n  add eax, edi\n  inc edi\n  cmp edi, esi\n  jle .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212697,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n  lea eax, [edi + esi]\n  mov ecx, esi\n  sub ecx, edi\n  neg ecx\n  sub esi, edi\n  cmovl esi, ecx\n  inc esi\n  imul eax, esi\n  sar eax, 1\n  ret\n; -----> endof get_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212698,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\n; a = edi\n; b = esi\nget_sum:\n    xor eax, eax        ; EAX <- the result    \n    mov ebx, esi\n    mov eax, edi\n\n    cmp ebx, eax\n    jg .body\n    je .end\n    xchg eax, ebx\n.body\n    sub ebx, eax\n    inc ebx\n    mov ecx, esi\n    mov eax, edi\n    add eax, ecx\n    xor edx, edx\n    imul ebx\n    cdq\n    mov ecx, 2\n    idiv ecx\n.end\n    ret\n\n; -----> endof get_sum <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212699,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n  cmp esi, edi\n  mov eax, esi\n  lea ecx, [rsi + rdi]\n  cmovl eax, edi\n  cmovl edi, esi\n  not eax\n  add eax, edi\n  imul eax, ecx\n  mov rcx, -2\n  cdq\n  idiv ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212700,"user_id":null,"body":"global get_sum\n\nsection .text\n\n; <--- int get_sum(int a, int b) --->\nget_sum:\n  cmp edi, esi\n  jle .start\n  xchg edi, esi\n  .start:\n  mov eax, edi\n  jmp .cond\n  .loop:\n  inc edi\n  add eax, edi\n  .cond:\n  cmp edi, esi\n  jne .loop\n  ret\n; -----> endof get_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55f73be6e12baaa5900000d4":[{"id":212701,"user_id":null,"body":"section    .text\nglobal     goals\n\ngoals:\n  xor      eax, eax\n  add      eax, edi\n  add      eax, esi\n  add      eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212702,"user_id":1315,"body":"global goals\ngoals:\n  lea eax, [edi + esi]\n  add eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212703,"user_id":null,"body":"global goals\ngoals:\n  lea rax,[rdi+rsi]\n  add rax,rdx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212704,"user_id":null,"body":"global goals\ngoals:\n  lea eax, [edi + edx]\n  add eax, esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212705,"user_id":null,"body":"global goals\ngoals:\n  xor eax, eax\n  lea eax, [edi+esi]\n  lea eax, [eax+edx]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212706,"user_id":null,"body":"section    .text\nglobal     goals\n\ngoals:\n  xor      rax, rax\n;  add      rax, rdi\n;  add      rax, rsi\n  lea      rax, [rdi + rsi]\n  add      rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212707,"user_id":null,"body":"global goals\ngoals:\n  add rdi, rsi\n  add rdi, rdx\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212708,"user_id":null,"body":"global goals\ngoals:\n  xor rax, rax\n  add rax, rdi\n  add rax, rsi\n  add rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212709,"user_id":null,"body":"global goals\ngoals:\n  xor eax, eax\n  add edi, esi\n  add edi, edx\n  mov eax, edi\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212710,"user_id":null,"body":"global goals\ngoals:\n  add rdi, rsi\n  add rdi, rdx\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55f9bca8ecaa9eac7100004a":[{"id":212711,"user_id":null,"body":"global past\npast:\n  mov eax, edi\n  imul eax, 60\n  add eax, esi\n  imul eax, 60\n  add eax, edx\n  imul eax, 1000\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212712,"user_id":null,"body":"global past\npast:\n  mov rax, rdx\n  mov rbx, 1000\n  mul rbx\n  mov rcx, rax\n\n  mov rax, rsi\n  mov rbx, 60000\n  mul rbx\n  add rcx, rax\n  \n  mov rax, rdi\n  mov rbx, 3600000\n  mul rbx\n  add rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212713,"user_id":null,"body":"global past\n\nsection .text\n\npast:\n    mov     eax, edi\n    imul    eax, 3600000\n    mov     ecx, esi\n    imul    ecx, 60000\n    add     eax, ecx\n    mov     ecx, edx\n    imul    ecx, 1000\n    add     eax, ecx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212714,"user_id":null,"body":"global past\npast:\n  imul rdi, 3600\n  imul rsi, 60\n  lea  rax, [rdi + rsi]\n  add  rax, rdx\n  imul rax, 1000\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212715,"user_id":null,"body":"global past\npast:\n  imul eax,edi,3600\n  imul ebx,esi,60\n  add eax,ebx\n  add eax,edx\n  imul eax,eax,1000\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212716,"user_id":null,"body":"global past\npast:\n  xor rax, rax\n  mov r8, 3600000 \n  imul rdi, r8\n  add rax, rdi\n  mov r8, 60000\n  imul rsi, r8\n  add rax, rsi\n  mov r8, 1000\n  imul rdx, r8\n  add rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212717,"user_id":null,"body":"global past\npast:\n  mov eax, 1000\n  imul eax, edx\n  mov edx, 60000\n  imul esi, edx\n  mov edx, 3600000\n  imul edi, edx\n  add eax, esi\n  add eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212718,"user_id":null,"body":"global past\npast:\n  imul eax, edi, 60\n  add eax, esi\n  imul eax, eax, 60\n  add eax, edx\n  imul eax, eax, 1000\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212719,"user_id":null,"body":"section .data\nh equ 3600000\nm equ 60000\ns equ 1000\nsection .bss\n\nsection .text\nglobal past\npast:\nxor eax, eax\nimul edi, h\nimul esi, m\nimul edx, s\n  add eax, edi\n  add eax, esi\n  add eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212720,"user_id":null,"body":"global past\npast:\n  mov rax, rdi\n  imul rax, 3600\n  mov rcx, rsi\n  imul rcx, 60\n  add rax, rcx\n  add rax, rdx\n  imul rax, 1000\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55fd2d567d94ac3bc9000064":[{"id":212721,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n    mov rax, rdi      ; copying <n> into RAX\n    mul rdi           ; multiplying by itself\n    mul rdi\n    ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212722,"user_id":null,"body":"section .text\nglobal row_odd_sum_numbers\n\nrow_odd_sum_numbers:\n    mov rax, rdi\n    mul rdi\n    mul rdi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212723,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n  mov ecx, edi\n  mov rax, rcx\n  imul rax, rcx\n  imul rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212724,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n  mov eax, edi\n  mov edi, edi\n  imul rax, rdi\n  imul rax, rdi\n  ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212725,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n    mov   rax, rdi        ; save your result in RAX!\n    imul  rax, rdi\n    imul  rax, rdi\n    ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212726,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n    mov qword [sum],0 ;initialise sum\n    mov [first],rdi   ;save n\n    mov rax,rdi       \n    dec rax           \n    mul qword [first] \n    inc rax           ;n*(n-1)+1 first element\nloop: \n    add qword [sum],rax ; it is possibele to calculate sn = (a1 + n-1)*n\n    add rax,2 ;but i do a loop and increase an = an' + 2 \n    cmp rdi,0\n    dec rdi\n    jne loop\n    \n    mov rax, [sum]        ; save your result in RAX!\n  \n    ret\n; ---------> end of roddsum <---------\nsection .data\nsum DQ 0\nfirst DQ 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212727,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n    mov eax, edi        ; save your result in RAX!\n    mul edi\n    xor rdx, rdx\n    mul edi\n    shl rdx, 32\n    add rax, rdx\n    ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212728,"user_id":50,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n    mov rax,rdi\n    imul rax\n    imul rdi\n    ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212729,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\n; <----- unsigned long long row_odd_sum_numbers(unsigned n) ----->\nrow_odd_sum_numbers:\n    mov rax, rdi\n    mul rdi\n    mul rdi       ; Spoiler: This sum is equal to n^3. So, that's what I do.\n    \n    ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212730,"user_id":null,"body":"global row_odd_sum_numbers\n\nsection .text\n\nrow_odd_sum_numbers:\n  ; sum{k}(n*n-n+2*k-1) = n**3\n    mov   rax, rdi\n    imul  rdi, rdi\n    imul  rax, rdi\n    ret\n; ---------> end of roddsum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5601409514fc93442500010b":[{"id":212731,"user_id":null,"body":"section .text\nglobal better_than_average\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n    xor eax, eax ; return value in eax\n    mov r11, rdx ; saving rdx to r11\n    xor r9, r9   ; clear r9\n    mov ecx, esi ; moving class_size into the counter resgister\n    mov r10, 4   ; using r10 as a temp\n\ncalc_avg_loop:\n    mov eax, esi ; Calculate the next index\n    sub eax, ecx ; calc cont.\n    mul r10      ; 4-byte offset for int list (rdi)\n    mov r8d, [rdi+rax] ; get int from list\n    add r9d, r8d ; add to accumulator\n    loop calc_avg_loop\n\n    mov eax, r9d  ; setup for divide\n    div esi       ; \n    cmp r11d, eax ; compare average to our score\n    mov eax, 1    ; \n    jg _ret       ; \n    mov eax, 0    ; \n_ret:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212732,"user_id":null,"body":"section .text\nglobal better_than_average\nbetter_than_average:\n    mov   eax,edx\n    imul  edx,esi\n    add   edx,eax\n    .b:add eax,[rdi+rsi*4-4]\n       dec rsi\n    jne .b\n    cmp   edx,eax\n    seta  al\n    movzx eax,al\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212733,"user_id":null,"body":"section .text\nglobal better_than_average\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n        push    rdx\n        xor     ecx, ecx\n        xor     eax, eax\n.loop:\n        cmp     esi, ecx\n        jle     .exit\n        add     eax, DWORD [rdi+rcx*4]\n        inc     rcx\n        jmp     .loop\n.exit:\n        cdq\n        idiv    esi\n        pop     rdx\n        cmp     eax, edx\n        setl    al\n        movzx   eax, al\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212734,"user_id":null,"body":"section .text\nglobal better_than_average\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n  mov eax, esi\n  sar eax, 31\n  andn r8d, eax, esi\n  xor eax, eax\n  xor ecx, ecx\n.loop:\n  cmp r8, rax\n  je .done\n  add ecx, [rdi + 4*rax]\n  inc rax\n  jmp .loop\n.done:\n  imul edx, esi\n  xor eax, eax\n  cmp edx, ecx\n  setg al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212735,"user_id":null,"body":"section .text\nglobal better_than_average\n\nbetter_than_average:\n   xor rax,rax\n   xor rcx,rcx\n   xor r8,r8\n   xor r9,r9\n   \n   push rbp\n   mov  rbp,rsp\n   \n   mov r8,rsi\n   mov r9,rdx\n   \n   mov rdx,0\n   .loop:\n   add rdx,[rdi+4*rcx]\n   inc rcx\n   cmp rcx,r8\n   jnz .loop\n   \n   xor rax,rax\n   mov ax,dx\n   xor rdx,rdx\n   div r8\n\n\n   cmp rax,r9\n   jl  .1\n   jge .0\n   \n   .1:\n   mov rax,1\n   jmp .exit\n   \n   .0:\n   mov rax,0\n   jmp .exit\n  \n   .exit:  \n   leave\n   ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212736,"user_id":null,"body":"section .text\nglobal better_than_average\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n    mov eax, 0\n    lea rcx, [rdi + rsi * 4]\n    cmp rdi, rcx\n    je  B\nA:  add eax, [rdi]\n    add rdi, 4\n    cmp rdi, rcx\n    jne A\nB:  mov ecx, edx\n    mov edx, 0\n    div esi\n    cmp eax, ecx\n    setb al\n    movzx eax, al\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212737,"user_id":null,"body":"section .text\nglobal better_than_average\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n    mov eax,edx\n    lea rcx,[rdi+rsi*4]\n    inc esi\n.loop:\n    add eax,[rdi]\n    lea rdi,[rdi+4]\n    cmp rdi,rcx\n    jb .loop\n    \n    mov ecx,edx\n    xor edx,edx\n    div esi\n    cmp eax,ecx\n    setb al\n    \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212738,"user_id":null,"body":"section .text\nglobal better_than_average\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n    mov eax, edx\n    mul esi\n.L1:\n    sub eax, [rdi]\n    add rdi, 4\n    dec esi\n    jnz .L1\n\n    test eax, eax\n    jle .L2\n    mov eax, 1\n    ret\n.L2:\n    xor eax, eax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212739,"user_id":null,"body":"section .text\nglobal better_than_average\nextern puts\n\n; int better_than_average(int class_points[] (rdi), int class_size (esi), int your_points (edx));\nbetter_than_average:\n    xor eax, eax\n    xor rbx, rbx\n.calculate_sum:\n    cmp ebx, esi\n    je .calculate_avg\n    add eax, [rdi + 4 * rbx]\n    inc ebx\n    jmp .calculate_sum\n.calculate_avg:\n    mov ecx, edx\n    xor edx, edx\n    idiv esi\n.determine_if_better:\n    mov ebx, eax\n    xor eax, eax\n    cmp ecx, ebx\n    setg al\n    ret\n    \n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212740,"user_id":460,"body":"section .text\nglobal better_than_average\nbetter_than_average:\n  mov r8, rdx\n  mov rcx, rsi\n  inc rcx ; +1 for us\n  mov rax, rdx ; start with our score\n  .sum:\n    dec rsi\n    add eax, [rdi+rsi*4]\n    cmp rsi, 0\n  jne .sum\n  xor rdx, rdx\n  div rcx\n  cmp rax, r8\n  setc al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"563a631f7cbbc236cf0000c2":[{"id":212741,"user_id":null,"body":"global move\nmove:\n    lea rax,[rdi+rsi*2]\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212742,"user_id":null,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:\n    mov eax, esi            ; AX <- the result\n    mov ebx, 2\n    mul ebx \n    add eax, edi\n    ret\n; -----> endof move <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212743,"user_id":50,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:\n    xor eax,eax            ; AX <- the result\n    imul esi,2\n    add edi,esi\n    mov eax,edi\n    ret\n; -----> endof move <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212744,"user_id":null,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:\n    mov eax, edi\n    add eax, esi\n    add eax, esi\n    ret\n; -----> endof move <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212745,"user_id":null,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:\n    lea eax, [edi + 2*esi]\n    ret\n; -----> endof move <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212746,"user_id":527,"body":"global move\n\n; unsigned short move(unsigned short pos, unsigned short roll)\nmove:\n                lea     eax, [rdi + rsi * 2]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212747,"user_id":168,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:\n  lea eax, [rdi + 2 * rsi]\n  ret\n; -----> endof move <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212748,"user_id":null,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:    dq -1.03662877420357888E17","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212749,"user_id":null,"body":"global move\n\n; <-- AX move(DI pos, SI roll) -->\nmove:\n  imul ax,si,2\n  add ax,di\nret\n; -----> endof move <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212750,"user_id":null,"body":"global move\n\nmove:\n    shl si, 1\n    add si, di\n    mov ax, si\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"563e320cee5dddcf77000158":[{"id":212751,"user_id":null,"body":"section .text\nglobal get_average\nget_average:\n    mov rcx,rsi\n    xor rax,rax\n_loop: add eax,[rdi + rcx * 4 - 4]    \n    loop _loop\n    xor edx,edx\n    idiv esi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212752,"user_id":592,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n   \n   mov eax, 0\n   mov ebx, 0\n   \n   WhileLp:\n     cmp ebx, esi      ; esi == count\n     jnl  EndWhileLp\n       add eax, [rdi]  ; rdi == ptr to marks\n       inc ebx\n       add rdi, 4\n       jmp WhileLp\n     \n   EndWhileLp:\n     xor edx, edx\n     div esi\n     \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212753,"user_id":50,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n    xor rax, rax\n    xor rbx,rbx ; count\n_loop:\n  cmp rbx,rsi\n  je _exit\n  xor rcx,rcx\n  mov ecx,[rdi+4*rbx]\n  add rax,rcx\n  inc rbx\n  jmp _loop\n_exit:\n  xor rdx,rdx\n  div rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212754,"user_id":null,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n    lea rdx, [rdi+rsi*4]\n    xor eax, eax\n.loop:\n    add eax, [rdi]\n    add rdi, 4\n    cmp rdx, rdi\n    jne .loop\n    xor edx, edx\n    div rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212755,"user_id":null,"body":"section .text\nglobal get_average\nget_average:\n  mov rcx, rsi\n  xor rax, rax\n.loop:\n  add eax, [rdi+4*rsi-4]\n  dec rsi\n  jnz .loop\n  cqo\n  div rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212756,"user_id":null,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n    xor rax, rax\n    mov rcx, 0\n.loop:\n    mov rbx, [rdi+4*rcx] \n    add rax, rbx\n    inc rcx\n    cmp rcx, rsi\n    jl .loop\n    xor rdx, rdx\n    idiv esi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212757,"user_id":null,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n  xor rax,rax\n  mov rcx,rsi\n  loop1:\n  add eax,[rdi+rcx*4-4]\n  loop loop1\n  xor rdx,rdx\n  idiv esi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212758,"user_id":null,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n  xor eax, eax\n  xor ecx, ecx\n.loop:\n  cmp rsi, rax\n  je .done\n  add ecx, [rdi + 4*rax]\n  inc rax\n  jmp .loop\n.done:\n  movsxd rax, ecx\n  xor edx, edx\n  div rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212759,"user_id":null,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n    xor rax, rax\n    xor rcx, rcx\n    .loop:\n    cmp rcx, rsi\n    je .done\n    add eax, dword [rdi+rcx*4]\n    inc rcx\n    jmp .loop\n    .done:\n    cdq\n    div rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212760,"user_id":null,"body":"section .text\nglobal get_average\n\n; int get_average(const int *marks, size_t count);\nget_average:\n    xor rax, rax\n    xor rcx, rcx\n    xor rdx, rdx\n    .sum:\n    cmp rax, rsi\n    je .done\n    add ecx, [rdi+rax*4]\n    inc rax\n    jmp .sum\n    .done:\n    mov eax, ecx\n    idiv rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"563f0c54a22b9345bf000053":[{"id":212761,"user_id":527,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n                xor     eax, eax\n                bts     rax, rdi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212762,"user_id":1339,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  mov rcx, rdi\n  mov rax, 1\n  shl rax, cl\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212763,"user_id":null,"body":"section .text\nglobal fcn\n\nfcn:\n  mov rax, 1\n  mov r9, rdi\n  cmp r9, 0\n  jg _loop\n  ret\n  \n_loop:\n  shl rax, 1\n  dec r9\n  cmp r9, 0\n  jg _loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212764,"user_id":null,"body":"section .text\nglobal fcn\n\nfcn:\n  mov rax, 1\n  mov r9, rdi\n  cmp r9, 0\n  jg _loop\n  ret\n  \n_loop:\n  imul rax, 2\n  dec r9\n  cmp r9, 0\n  jg _loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212765,"user_id":null,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  mov rax, 1\n  l:\n    shl rax, 1\n    dec edi\n    test edi, edi\n    jnz l\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212766,"user_id":null,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  xor rcx, rcx\n  mov ecx, byte edi\n  mov rax, 1\n  shl rax, cl\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212767,"user_id":null,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  mov ecx, edi\n  mov eax, 1\n  sal rax, cl\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212768,"user_id":50,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  xor rax,rax\n  add rax,1\n_loop:\n  cmp rdi,0\n  je _exit\n  shl rax,1\n  dec rdi\n  jmp _loop\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212769,"user_id":76,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  mov rax, 1\n  mov rcx, rdi\n.shift:\n  shl rax, 1\n  loop .shift\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212770,"user_id":null,"body":"section .text\nglobal fcn\n; unsigned long fcn(long n)\nfcn:\n  mov rax, 1\n  mov cl, dil\n  shl rax, cl\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56541980fa08ab47a0000040":[{"id":212771,"user_id":null,"body":"global printer_error\nextern sprintf\nextern malloc\nprinter_error:\n  push rdi\n  mov  rdi,256\n  call malloc\n  xchg rax,[rsp]\n  xor  rcx,rcx\n  xor  rdx,rdx\n  @b:movzx rdi,byte[rax+rcx]\n     bt    qword[colors],rdi\n     adc   rdx,0\n     inc   rcx\n     cmp   byte[rax+rcx],0\n  jne @b  \n  mov  rsi,fmt\n  mov  rdi,[rsp]\n  xor  rax,rax\n  call sprintf\n  pop  rax\nret\ncolors dq 0xFFFFFFFFFFFFFFFF,0xFFFFC001FFFFFFFF,0xFFFFFFFFFFFFFFFF,0xFFFFFFFFFFFFFFFF\nfmt:   db '%u\/%u',0\n ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212772,"user_id":null,"body":"extern asprintf\nSECTION .text\nglobal printer_error\n\nprinter_error:\n  sub rsp, 24\n  xor ecx, ecx\n  xor edx, edx\n.loop:\n  mov al, [rdi+rcx]\n  test al, al\n  je .done\n  cmp al, 109\n  jle .good\n  inc edx\n.good:\n  inc rcx\n  jmp .loop\n.done:\n  lea rdi, [rsp+8]\n  mov esi, .fmt\n  call asprintf\n  mov rax, [rsp+8]\n  add rsp, 24\n  ret\n.fmt: db \"%u\/%u\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212773,"user_id":null,"body":"SECTION .text\nglobal printer_error\nextern malloc\nextern sprintf\n\n; Accepts a string and returns a string representing the number of errors in the string according to the description.\n; NOTE: Please return a pointer to a string allocated on the heap.\n; arg0         = (const char*) The control string.\n; return value = (char*)       The string representing the number of errors in the string.\nprinter_error:\n  push rdi\n  mov edi, 64\n  call malloc\n  pop rdi\n  test rax, rax\n  jz .quit\n  \n  push rax\n  xor ecx, ecx\n  xor edx, edx\n  \n.loop:\n  mov al, [rdi]\n  inc rdi\n  test al, al\n  jz .done\n  inc ecx\n  sub al, 'a'\n  cmp al, 12\n  jbe .loop\n  inc edx\n  jmp .loop\n\n.done:\n  mov rdi, [rsp]\n  lea rsi, [format]\n  xor eax, eax\n  call sprintf\n  pop rax\n\n.quit:\n  ret\n\nsection .rodata\nformat: db \"%d\/%d\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212774,"user_id":null,"body":"SECTION .data\nSECTION .text\nextern strdup\nglobal printer_error\n\n; Accepts a string and returns a string representing the number of errors in the string according to the description.\n; NOTE: Please return a pointer to a string allocated on the heap.\n; arg0         = (const char*) The control string.\n; return value = (char*)       The string representing the number of errors in the string.\nprinter_error:\n  mov   rdi,rsi\n  call  strdup\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212775,"user_id":null,"body":"SECTION .text\nglobal printer_error\nextern strdup\n\n; Accepts a string and returns a string representing the number of errors in the string according to the description.\n; NOTE: Please return a pointer to a string allocated on the heap.\n; arg0         = (const char*) The control string.\n; return value = (char*)       The string representing the number of errors in the string.\nprinter_error:\n  mov rdi, rsi\n  jmp strdup","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212776,"user_id":null,"body":"SECTION .text\nglobal printer_error\nextern malloc\nextern printf\n\n; Accepts a string and returns a string representing the number of errors in the string according to the description.\n; NOTE: Please return a pointer to a string allocated on the heap.\n; arg0         = (const char*) The control string.\n; return value = (char*)       The string representing the number of errors in the string.\nprinter_error:\n  xor rax, rax\n  mov [er], rax\n  mov [tot], rax\n  \n_loop:\n  cmp  byte [rdi], 0            ; see if finished processing input\n  jz _end\n  cmp byte [rdi], 110           ; see if character is 'error'\n  jl less\n  mov edx, [er]                 ; add to error count\n  inc edx\n  mov [er], edx\nless:\n  mov edx, [tot]                ; add to total count\n  inc edx\n  mov [tot], edx\n  inc rdi\n  jmp _loop\n  \n  \n_end:\n\n  mov rdi, 32                   ; malloc a return string\n  call malloc\n  mov rcx, rax                  ; put return string pointer in rcx\n  \n  push rax                      ; push rax so we can get back to return string for return\n  \n  mov eax, [er]                 ; convert er to string and append to return string\n  call convertNumAndAppend\n  \n  mov byte [rcx], 47            ; add \/ to return string\n  inc rcx\n  \n  mov eax, [tot]                ; convert total to string and append to return string\n  call convertNumAndAppend\n \n  pop rax                       ; pop rax which contains return string\n  ret                  \n  \nconvertNumAndAppend:   ; convert int in rdx to string and append \n                      ;  to [rcx]\n\n    push rax         ; pushed used registers to stack\n    push rbx\n    push rdx\n    push rdi\n   \n    mov edi, 0      ; count of how many bytes to print in the end\n   \ndivloop: \n                    ; div eax by ebx, initially set edx to zero so it will not be part of the division\n                    ; result will be in eax and remainder in rdx\n    inc edi         ; total bytes being processed\n    mov edx, 0 \n    mov ebx, 10\n    idiv ebx\n    add edx, 48     ; add 48 to convert number to digit\n    push rdx        ; push digit so we can append in proper order later\n    cmp eax, 0      ; check if finished dividing\n    jne divloop\n    \nappendloop:\n\n    dec edi\n    pop rdx          ; pop digit\n    mov [rcx], edx   ; append digit to string pointed to by rcx\n    inc rcx          ; increment the string pointer rcx\n    cmp edi, 0       ; check if we have pop all digits\n    jnz appendloop\n\n    pop rdi          ; pop used registers from stack\n    pop rdx\n    pop rbx\n    pop rax\n\n    ret\n  \nsection .data\n   message_value: db \"Value=%lu\", 10, 0\n  \nsection .bss\n   er: resb 4\n   tot: resb 4\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212777,"user_id":null,"body":"SECTION .text\nglobal printer_error\nextern malloc\nextern sprintf\n\nfmt_str:  db  \"%d\/%d\", 0\n\n; Accepts a string and returns a string representing the number of errors in the string according to the description.\n; NOTE: Please return a pointer to a string allocated on the heap.\n; arg0         = (const char*) The control string.\n; return value = (char*)       The string representing the number of errors in the string.\nprinter_error:\n  xor edx, edx\n  xor ecx, ecx\n.next_char:\n  movzx eax, byte [rdi+rcx]\n  or al, al\n  jz .get_status\n  sub eax, 97\n  add ecx, 1\n  cmp eax, 12\n  seta al\n  movzx eax, al\n  add rdx, rax\n  jmp .next_char\n.get_status:\n  push rdx\n  push rcx\n  mov rdi, 64\n  call malloc\n  mov rdi, rax\n  mov rsi, fmt_str\n  xor eax, eax\n  pop rcx\n  pop rdx\n  push rdi\n  call sprintf\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212778,"user_id":null,"body":"section .bss\n@ptr  resq 1\nSECTION .text\nextern asprintf\nglobal printer_error\n@fmt  db \"%d\/%d\", 0\nprinter_error:      xor rdx,rdx\n                    xor rcx,rcx\n@main_loop:         mov al,[rdi]\n                    inc rdi\n                    test al,al\n                    jz @done\n                    cmp al,'m'\n                    jle @good\n                    inc rdx\n                    jmp @main_loop\n@good:              inc rcx\n                    jmp @main_loop\n@done:              add rcx,rdx\n                    lea rsi,[@fmt]\n                    lea rdi,[@ptr]\n                    call asprintf\n                    mov rax,[@ptr]\n                    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212779,"user_id":null,"body":"[BITS 64]\nSECTION .text\nglobal printer_error\n\n;;\n; C-Signature:\n;    int asprintf(char **strp, const char *fmt, ...)\n;   [rax]         [rdi]        [rsi]\nextern asprintf\n\n;;\n; C-signature:\n;     char *printer_errors(const char *s)\n;     [rax]                [rdi]\n;\n; Check the given colour sequence (s) and return the number of errors\n; encountered and the number of code characters provided.\n;\n; This function assumes that:\n;     (1) the given string pointer is valid.\n;     (2) the given string is null-terminated.\n;     (3) the colour codes are given in lower case letters (other\n;         symbols are interpreted as errors).\n;     (4) the allocated memory for the result is freed by the caller\n;         with a call to free().\n;\n; @param s [rdi]  the colour code sequence\n; @return a string encoding the number of errors in the sequence and the\n;         total number of symbols in sequence (s), excluding the\n;         terminating zero.\n;\n%define ADDR_RESULT_STRING rbp - 0x08\nprinter_error:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 0x10\n  \n  xor ecx, ecx\n  xor eax, eax\n.next_symbol:\n  cmp byte [rdi + rcx], 0\n  jz .end_of_sequence\n  cmp byte [rdi + rcx], 'a'\n  jl .error_detected\n  cmp byte [rdi + rcx], 'm'\n  jg .error_detected\n  jmp .advance_to_next_symbol\n.error_detected:\n  inc rax\n.advance_to_next_symbol:\n  inc rcx\n  jmp .next_symbol\n.end_of_sequence:\n  lea rdi, [ADDR_RESULT_STRING]\n  lea rsi, [rel .result_format]\n  mov rdx, rax\n  call asprintf WRT ..plt\n  mov rax, [ADDR_RESULT_STRING]\n  \n  mov rsp, rbp\n  pop rbp\n  ret\n\n.result_format:\n  db \"%d\/%d\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212780,"user_id":null,"body":"SECTION .data\n  format_str: db \"%d\/%d\", 0\n  \nSECTION .text\n  global printer_error\n  extern sprintf, malloc\n\n; Accepts a string and returns a string representing the number of errors in the string according to the description.\n; NOTE: Please return a pointer to a string allocated on the heap.\n; arg0         = (const char*) The control string.\n; return value = (char*)       The string representing the number of errors in the string.\nprinter_error:\n  push  rdi\n  mov   edi, 128\n  call  malloc\n  mov   rdi, rax\n  cld\n  pop   rsi\n  xor   ecx, ecx\n  xor   edx, edx\n  .next:\n    lodsb\n    cmp   al, 0\n    jz    .print\n    cmp   al, 'n'\n    jl    .good\n      inc    edx\n    .good:\n    inc   ecx\n  jmp   .next\n  .print:\n  push  rdi\n  mov   rsi, format_str\n  xor   rax, rax\n  call  sprintf\n  pop   rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"566be96bb3174e155300001b":[{"id":212781,"user_id":null,"body":"global max_ball\nsection .text\nmax_ball:\n  mov rax, 2500\n  mul rdi\n  mov rcx, 8829\n  add rax, 4414\n  div rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212782,"user_id":null,"body":"global max_ball\nsection .text\n;h=-4.905t\u00b2+vt\n;1000km\/3600h=5\/18 m\/s\n;h=-4.905t\u00b2+vt*50\/18 (every tenth second)\n;h=-4.905t\u00b2+50*vt\/18\n;h=-490.5t\u00b2+5000*vt\/18 (accuracy adjustment)\nmax_ball:\n  mov rcx,0\n  mov r8,18\n  mov r9,0\n  mov r10,10\n  loop1:\n  inc rcx\n  imul rax,rcx,-4905\n  imul rcx\n  add rax,500\n  mov rdx,0\n  idiv r10\n  mov rbx,rax\n  \n  imul rax,rdi,5000\n  imul rcx\n  add rax,9\n  mov rdx,0\n  idiv r8\n  \n  add rax,rbx\n  \n  cmp rax,r9\n  cmovg r9,rax\n  jg loop1\n  \n  dec rcx\n  mov rax,rcx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212783,"user_id":null,"body":"global max_ball\nsection .text\n;h=-4.905t\u00b2+vt\n;1000km\/3600h=5\/18 m\/s\n;h=-4.905t\u00b2+vt*50\/18 (every tenth second)\n;h=-4.905t\u00b2+50*vt\/18\n;h=-490.5t\u00b2+5000*vt\/18 (accuracy adjustment)\nmax_ball:\n  mov rcx,0\n  mov r8,18\n  mov r9,0\n  mov r10,10\n  mov r11,rdi\n  loop1:\n  inc rcx\n  imul rax,rcx,-4905\n  imul rcx\n  add rax,500\n  mov rdx,0\n  shl rax,1\n  idiv r10\n  mov rbx,rax\n  \n  imul rax,r11,5000\n  imul rcx\n  add rax,9\n  mov rdx,0\n  shl rax,1\n  idiv r8\n  \n  add rax,rbx\n  \n  cmp rax,r9\n  cmovg r9,rax\n  jg loop1\n  \n  dec rcx\n  mov rax,rcx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212784,"user_id":null,"body":"extern lround\nglobal max_ball\nsection .text\nmax_ball:\n  cvtsi2sd xmm0, edi\n  push rax\n  mulsd xmm0, [.const]\n  call lround\n  pop rdx\n  ret\n.const: dq 0x3fd21f41ca5bcc9f","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212785,"user_id":null,"body":"global max_ball\nsection .text\n;my previous attempt was wrong, because i assumed i need to round down\n;usually the rounding is set to round down, so i thought i hit the nail on the head\n;apparantly this is the method for rounding with just integers\n;a\/b = (a+b\/2)\/b for same signs (+\/+) or (-\/-)\n;a\/b = (a-b\/2)\/b, for opposite signs (+\/-) or (-\/+)\n;source:https:\/\/stackoverflow.com\/a\/18067292\nmax_ball:\n  mov rax,2500\n  mul edi\n  add eax,4415\n  mov rbx,8829\n  div ebx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212786,"user_id":null,"body":";math\n;h=-0.5gt\u00b2+vt\n;h=-4.905t\u00b2+vt\n\n;if you look at the example equation, you can see, that\n;the result we are looking for is 10 times the x-value of the angular point, rounded down\n\n;for v = 15km\/h = 15 * 1000\/3600 m\/s = 25\/6 = 4.166666667 h=-4.905t\u00b2+4.166666667t\n;https:\/\/i.ibb.co\/T0TfhpF\/Screenshot-2022-06-25-at-17-39-22-ax-bx-c.png\n\n;So all we need to do is make an equation using something for the angular point\n;according to the internet, the angular point is calculated by setting the derivative to 0\n;h'=-9.81t+v\n;0=-9.81t+v\n;then we just solve it for t, because that is what we are using as our x here\n;-v=-9.81t\n;t=-v\/-9.81\n;t=v\/9.81\n;the only thing missing is that we are now mistaking the v for the v provided\n;our v is actually just the 'b' of a parabola equation, which assumes regular units like meters per second\n;so i will re-write that formula with a b for clarity\n;t=b\/9.81\n;and that b is calculated same as above => b = v * 1000\/3600 = v * 5\/18\n;t = (v * 5\/18) \/ 9.81\n;t = v * 250\/8829\n;a quick test reveals, that for v = 15 we get 0.424, we just have to multiply with 10 and round down\n;result = 10 * v * 250\/8829\n;result = v * 2500\/8829\n;result = v * 0.2831577755\n;unfortunately i struggled to make floating numbers work in nasm here on codewars, so i used integer numbers, which worked out\n;the numbers, that i first tryed are based on the 5\/18. i just multiplied with 10 there to get 50 as factor1\n;and for factor2 i just multiplier 18 with 9.81 = 176.58\n;also for some reason the test crashes, if i put input1 and output1 in section .text as dd 0\n;(if you look at a finished executable, an extra section to me looks like unnecessary overhead)\n\nglobal max_ball\nextern printf\nsection .text\n;factor1 dq 50\n;factor2 dq 176.58\nfactor1 dd 2500\nfactor2 dd 8829\nformat1 db '%d',0\n;input1 dd 0\n;output1 dd 0\n\nmax_ball:\n  fild dword[factor1]\n  fild dword[factor2]\n  fdivp\n  mov [input1],edi\n  fild dword[input1]\n  fmulp\n  fistp dword[output1]\n  mov rax,[output1]\n  \n  ;debug:\n  ;mov rsi,[output1]\n  ;mov rdi,format1\n  ;sub rsp,8\n  ;call printf\n  ;add rsp,8\nret\n\nsection .bss\ninput1 resd 1\noutput1 resd 1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212787,"user_id":173,"body":"section .data\ng:\n  dq 9.81\n\nsection .bss\nv_ms \n  resq 1\nmh \n  resq 1\n\n\nglobal max_ball\nsection .text\nmax_ball:\n  ; init mh to 0.0\n  mov rax, 0\n  cvtsi2sd xmm0, rax\n  lea rax, [rel mh]\n  movq [rax], xmm0\n\n  ; mt\n  mov rcx, 0\n\n  ; v in m\/s\n  mov r12d, 1000\n  cvtsi2sd xmm1, r12d\n  cvtsi2sd xmm0, rdi\n  mulsd xmm0, xmm1  \n  mov r12d, 3600\n  cvtsi2sd xmm1, r12d\n  divsd xmm0, xmm1\n  lea rax, [rel v_ms]\n  movq [rax], xmm0\n    \n  ; loop forever increasing r12 (time register)\n  mov r12, 0\nl_loop:\n  mov rax, 10\n  cvtsi2sd xmm2, rax\n  cvtsi2sd xmm1, r12\n  divsd xmm1, xmm2  ; xmm1 is t\/10\n  \n  mov rax, 1\n  cvtsi2sd xmm3, rax\n  mov rax, 2\n  cvtsi2sd xmm4, rax\n  divsd xmm3, xmm4 ; xmm3 = 0.5\n  lea rax, [rel g]\n  movq xmm4, [rax]\n  mulsd xmm3, xmm4 ; xmm3 = 0.5 * g\n  \n  mulsd xmm3, xmm1\n  mulsd xmm3, xmm1 ; xmm3 = 0.5 * g * t\/10 * t\/10\n  \n  lea rax, [rel v_ms]\n  movq xmm2, [rax] ; xmm2 = v\n  mulsd xmm2, xmm1 ; xmm2 = v*t\/10\n  \n  subsd xmm2, xmm3 ; h = v*(t\/10) - 0.5*g*(t\/10)*(t\/10)\n  \n  \n  lea rax, [rel mh]\n  movq xmm5, [rax]\n  movq xmm0, xmm2\n  cmpltsd xmm0, xmm5\n  movq rax, xmm0  \n  cmp rax, 0\n  jne l_done\n  lea rax, [rel mh]\n  movq [rax], xmm2\n  mov rcx, r12\n  \n  inc r12\n  jmp l_loop\n    \nl_done:\n  mov rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212788,"user_id":50,"body":"global max_ball\nsection .text\nmax_ball:\n  xor rax, rax\n  mov rax,rdi\n  imul rax,56630\n  add rax,100000\n  xor rdx, rdx\n  xor rbx,rbx\n  mov rbx,200000\n  div rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212789,"user_id":525,"body":"global max_ball\nsection .text\nmax_ball:\n    imul    eax, edi, 1000\n    add     eax, 1766\n    cdqe\n    imul    rax, rax, 38912501\n    mov     rcx, rax\n    shr     rcx, 63\n    sar     rax, 37\n    add     eax, ecx\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212790,"user_id":null,"body":"global max_ball\nsection .text\nmax_ball: \n        cvtsi2sd    xmm0, edi\n        mulsd       xmm0, [L1000]\n        divsd       xmm0, [L3600]\n        divsd       xmm0, [L9_81]\n        mulsd       xmm0, [L10]\n        movapd      xmm1, [L_0]\n        andpd       xmm1, xmm0\n        movsd       xmm2, [L0_5]\n        orpd        xmm2, xmm1\n        addsd       xmm2, xmm0\n        xorps       xmm0, xmm0\n        roundsd     xmm0, xmm2, 11\n        cvttsd2si   eax, xmm0\n        ret\n\n        align(8)\n\nL1000:\n        dq   0x408f400000000000              ; double 1000\nL3600:\n        dq   0x40ac200000000000              ; double 3600\nL9_81:\n        dq   0x40239eb860000000              ; double 9.8100004196166992\nL10:\n        dq   0x4024000000000000              ; double 10\nL0_5:\n        dq   0x3fdfffffffffffff              ; double 0.49999999999999994\n        \n        align(16)\n\nL_0:\n        dq   0x8000000000000000              ; double -0\n        dq   0x8000000000000000              ; double -0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"566fc12495810954b1000030":[{"id":212791,"user_id":null,"body":"global nbdig\n\nsection .text\nnbdig:    \n  xor r8d, r8d\n  mov r9, 10\n  xor r10d, r10d\n.loop:\n  cmp r10d, edi\n  ja .done\n  mov r11d, r10d\n  imul r11d, r10d\n.nextdigit:\n  mov eax, r11d\n  xor edx, edx\n  xor ecx, ecx\n  div r9d\n  cmp edx, esi\n  sete cl\n  add r8d, ecx\n  cmp r11d, 9\n  mov r11d, eax\n  ja .nextdigit\n  inc r10d\n  jmp .loop\n.done:\n  mov eax, r8d\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212792,"user_id":null,"body":"global nbdig\nsection .text\nnbdig:    \n        xor r10,r10\n        xor ebx,ebx     ; counter for digits\n        mov r8d,10\n        mov r9d,edi      ; will be 'k'\n        \n@main:  mov  eax,r9d    ; Get the next number\n        mul  eax        ; and square it\n        \n@l2:    xor  edx,edx\n        div  r8d         ; divide on 10\n        cmp  dx,si       ; and check if digit is what we're looking for\n        sete r10b\n        add  ebx,r10d    ; add true\/false to ebx\n        test eax,eax     ; check if remaining digits\n        jne  @l2\n        \n        dec  r9d          ; as long as 'k >= 0'\n        jns  @main\n        mov  eax,ebx\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212793,"user_id":50,"body":"global nbdig\n\nsection .text\n\n; ---> unsigned nbdig(unsigned n, unsigned d) <---\n; n - an integer where n >= 0\n; d - a digit where 0 <= d <= 9\nnbdig:    \n    xor rax,rax\n    xor r9,r9  ; c\n    mov r8,1   ; k\n    mov r10,10\n_loop:\n  cmp r8,rdi\n  jg _exit\n  mov rax,r8\n  imul rax ; rax = k * k\n_parse:\n  test rax,rax\n  jz _inc_and_loop\n  xor rdx,rdx\n  idiv r10\n  cmp rdx,rsi\n  je _inc_res\n  jmp _parse\n_inc_res:\n  inc r9\n  jmp _parse\n_inc_and_loop:\n  inc r8\n  jmp _loop\n_exit:\n  mov rax,r9\n  test rsi,rsi\n  jz _incz\n  ret\n_incz:\n  inc rax\n  ret\n; -----> end of nbdig <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212794,"user_id":null,"body":"global nbdig\nsection .text\nnbdig:\n    mov r10, 10\n    xor rcx, rcx\nsexyloop:\n    mov rax, rdi\n    mul rdi\nsexierloop:\n    xor rdx, rdx\n    div r10\n    cmp rdx, rsi\n    jne pass\n    inc rcx\npass:\n    test rax, rax\n    jnz sexierloop\n    dec rdi\n    test rdi, rdi\n    jns sexyloop \n    mov rax, rcx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212795,"user_id":null,"body":"global nbdig\n\nsection .text\n\n; ---> unsigned nbdig(unsigned n, unsigned d) <---\n; edi = n - an integer where n >= 0\n; esi = d - a digit where 0 <= d <= 9\nnbdig:    \n    mov r8, -1     ;; rangeCounter\n    mov r12, rdi   ;; rangeUpperLimit\n    mov r11, rsi   ;; digitToCompare\n    mov r9, 0     ;; totalCounter\n    \n    mov rdx, 0\n    .loopRange:\n      inc r8\n      cmp r8, r12\n      jg .return\n      mov rax, r8\n      mul rax\n      .countDigits:\n        mov rdx, 0    ;; clear rdx for div\n        mov r10, 0    ;; flagForCounter\n        mov rdi, 10\n        div rdi       ;; rdx = rax % 10, rax = rax \/\/ 10\n        mov rsi, 1\n        cmp rdx, r11\n        cmove r10, rsi\n        add r9, r10\n        cmp rax, 0\n        je .loopRange\n        jmp .countDigits\n        \n    \n    .return:\n      mov rax, r9\n      ret\n; -----> end of nbdig <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212796,"user_id":null,"body":"global  nbdig\n\nsection .text\n\nnbdig:\n        mov     r10, 10\n\n        xor     rcx, rcx\n        test    rsi, rsi\n        jne     .loop\n        inc     rcx\n\n.loop:\n        test    rdi, rdi\n        je      .end\n\n        mov     rax, rdi\n        mul     rdi\n\n.loopdigits:\n        test    rax, rax\n        je      .enddigits\n\n        xor     rdx, rdx\n        div     r10\n\n        cmp     rdx, rsi\n        jne     .loopdigits\n        inc     rcx\n        jmp     .loopdigits\n\n.enddigits:\n        dec     rdi\n        jmp     .loop\n\n.end:\n        mov     rax, rcx\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212797,"user_id":77,"body":"global nbdig\n\nsection .text\n\n; ---> unsigned nbdig(unsigned n, unsigned d) <---\n; n - an integer where n >= 0\n; d - a digit where 0 <= d <= 9\nnbdig:\n    mov rcx, rdi\n    mov r10, 10\n    xor r8, r8\n.mainloop:\n    mov rax, rcx\n    mul rcx\n.digitloop:\n    xor rdx, rdx\n    div r10\n    cmp rdx, rsi\n    jne .diff\n    inc r8\n.diff:\n    test rax, rax\n    jnz .digitloop\n    loop .mainloop\n    test rsi, rsi\n    setz al\n    add rax, r8\n    ret\n; -----> end of nbdig <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212798,"user_id":null,"body":"global nbdig\n\nsection .text\n\n; ---> unsigned nbdig(unsigned n, unsigned d) <---\n; n - an integer where n >= 0\n; d - a digit where 0 <= d <= 9\nnbdig:\n  xor r9, r9\n  xor r10, r10\n  mov rcx, 10\n  .multiply:\n    cmp r9, rdi\n    jg .done\n    mov r8, r9\n    imul r8, r8\n    mov rax, r8\n    inc r9\n    .div_loop:\n      xor rdx, rdx\n      div rcx\n      cmp rdx, rsi\n      jne .div_test_if_done\n      inc r10\n      .div_test_if_done:\n        test rax, rax\n        jz .multiply\n      jmp .div_loop\n  .done:\n    mov rax, r10\n    ret\n; -----> end of nbdig <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212799,"user_id":null,"body":"global nbdig\n\nsection .text\n\n; ---> unsigned nbdig(unsigned n, unsigned d) <---\n; n - an integer where n >= 0\n; d - a digit where 0 <= d <= 9\n; EAX <- the result\nnbdig:\n    xor  ebx,  ebx\n    xor  ecx,  ecx\n    mov  r8d,  10\n    jmp  .m0\n.loop:\n    inc  ecx\n.m0:\n    mov  eax,  ecx\n    mul  eax\n    .sloop:\n        xor  edx,  edx\n        div  r8d\n        cmp  edx,  esi\n        jne  .m1\n        inc  ebx\n        .m1\n        cmp  eax,  0\n        jne  .sloop\n    cmp  ecx,  edi\n    jl   .loop\n    mov  eax,  ebx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212800,"user_id":null,"body":"global nbdig\n\n\nsection .text\n\n; ---> unsigned nbdig(unsigned n, unsigned d) <---\n; n - an integer where n >= 0\n; d - a digit where 0 <= d <= 9\nnbdig:    \n    xor eax, eax      ; EAX <- the result\n    xor ebx, ebx\n    xor r9d, r9d\n    mov r9d, edi\n    L17: mov eax, r9d\n    mov ecx, r9d\n    mul ecx\n    push rax\n    dec r9d\n    jnz L17\n    mov ecx, 10\n    L24: pop rax\n    L25: xor edx, edx\n    div ecx\n    cmp edx, esi\n    jne L30\n    add ebx, 1 \n    L30: cmp eax, 0\n    jne L25\n    dec edi\n    jnz L24\n    cmp esi, 0\n    jne L37\n    add ebx, 1\n    L37: mov eax, ebx\n    ret\n; -----> end of nbdig <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5672682212c8ecf83e000050":[{"id":212801,"user_id":null,"body":"global dbl_linear\nsection .text\nextern malloc,free\n; input: edi = n\n; output: eax\ndbl_linear:\n  push r14\n  push rbx\n  push rax\n  mov ebx, edi\n  lea eax, [rbx + rbx]\n  movsxd rdi, eax\n  shl rdi, 2\n  call malloc\n  movsxd r8, ebx\n  xor esi, esi\n  test r8d, r8d\n  lea r9, [rax + 4*r8]\n  cmovg esi, r8d\n  mov r14, 1\n  mov r10, rax\n  mov rcx, rax\n.loop:\n  sub esi, 1\n  jb .done\n  lea edx, [r14 + r14 + 1]\n  xor edi, edi\n  xor ebx, ebx\n  mov [rcx], edx\n  lea edx, [r14 + 2*r14 + 1]\n  mov [rcx + 4*r8], edx\n  add rcx, 4\n  mov r14d, dword [r10]\n  mov edx, [r9]\n  cmp r14d, edx\n  setle dil\n  setge bl\n  cmovg r14d, edx\n  lea r10, [r10 + 4*rdi]\n  lea r9, [r9 + 4*rbx]\n  jmp .loop\n.done:\n  mov rdi, rax\n  call free\n  mov eax, r14d\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212802,"user_id":null,"body":"global dbl_linear\n\nsection .text\n; input: edi = n\n; output: eax\ndbl_linear:\n  cmp edi, [count]\n  jl .finish\n  \n  mov eax, [val2]\n  cmp eax, [val3]\n  cmovg eax, [val3]\n  \n  mov ecx, [count] \n  inc dword [count]\n  mov [seqence + ecx * 4], eax\n  \n  cmp eax, [val2]\n  jne .not2\n  inc dword [ptr2]\n  mov ecx, [ptr2]\n  mov ecx, [seqence + ecx * 4]\n  shl ecx, 1\n  add ecx, 1\n  mov [val2], ecx\n  .not2:\n  \n  cmp eax, [val3]\n  jne .not3\n  inc dword [ptr3]\n  mov ecx, [ptr3]\n  imul ecx, [seqence + ecx * 4], 3\n  add ecx, 1\n  mov [val3], ecx\n  .not3:\n  \n  jmp dbl_linear\n  \n  .finish:\n  mov eax, [seqence + edi * 4]\n  ret\n  \nsection .data\n  count: dd 1\n  seqence: \n      dd 1\n      times 999999 dd 0\n  ptr2: dd 0\n  ptr3: dd 0\n  val2: dd 3\n  val3: dd 4","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212803,"user_id":null,"body":"global dbl_linear\n\n%define LINEAGE     0h100000\n\n%macro  setx    3\n    cmp %1d, LINEAGE        ; whether <i> is below <LINEAGE>\n    jb %%x                  ; jumping to the macro-local .x label\n    xor %1, %1              ; resetting <i>\n%%x:\n    mov edx, [rsp+%1*4]     ; copying <*(line+i)> to EDX as <x>\n    lea %2, [edx*%3+1]      ; multiplying <x> by <n> and adding one\n%endmacro\n\n; <-- EAX dbl_linear(EDI n) -->\ndbl_linear:\n    test edi, edi           ; whether <n> is zero\n    jne .start              ; otherwise, jumping to .start\n    xor eax, eax            ; setting the result...\n    inc eax                 ; ... to one\n    ret\n.start:\n    push r13                ; saving R13 in the stack\n    push r12                ; saving R12 in the stack\n    sub rsp, LINEAGE << 2   ; allocating space for <line>\n    mov esi, LINEAGE        ; loading ESI with <LINEAGE> as <linage>\n    xor r10d, r10d          ; resetting R10D as <yi>\n    xor r11d, r11d          ; resetting R11D as <zi>\n    xor ecx, ecx            ; resetting ECX as <i>\n    mov dword [rsp], 1      ; saving one in <*line>\n.loop:\n    inc ecx                 ; incrementing <i>\n    cmp ecx, edi            ; whether <i> is above <n>\n    ja .exit                ; jumping to exit\n    setx r10, r8d, 2        ; setting R8D as <y>\n    setx r11, r9d, 3        ; setting R9D as <z>\n    lea r12d, [r10d+1]      ; copying <yi+1> to R12D\n    lea r13d, [r11d+1]      ; copying <zi+1> to R13D\n    cmp r8d, r9d            ; whether <y> is below <z>\n    cmovbe r10d, r12d       ; incrementing <yi> if below or equal to\n    cmovae r11d, r13d       ; incrementing <zi> if above or equal to\n    cmova r8d, r9d          ; otherwise, copying <z> to <y>\n    mov eax, ecx            ; copying <i> to EAX as <inx>\n    cmp ecx, LINEAGE        ; whether <i> is below <LINEAGE>\n    jb .x                   ; jumping to the .x label\n    xor edx, edx            ; resetting EDX before division\n    div esi                 ; dividing <i> by <lineage>\n    mov eax, edx            ; copying the reminder to <inx>\n.x:\n    mov [rsp+rax*4], r8d    ; copying <y> to <*(line+inx)>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    mov eax, r8d            ; setting the result to <y>\n    add rsp, LINEAGE << 2   ; destroying the local storage\n    pop r12                 ; restoring the original R12\n    pop r13                 ; restoring the original R13\n    ret\n; -----> endof dbl_linear <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212804,"user_id":743,"body":"global dbl_linear\n\nsection .bss\n\nVec resw 10000000\n\nsection .text\n\ndbl_linear:\n  mov dword [Vec], 1\n  mov rcx, Vec\n  mov rdx, Vec\n  xor rsi, rsi\n  mov r8d, 3\n  mov r9d, 4\n  add edi, 1\n.loop:\n  add esi, 1\n  cmp esi, edi\n  je .end\n  cmp r8d, r9d\n  ja .gre\n  jb .les\n  add ecx, 4\n  mov r8d, dword [rcx]\n  lea r8d, [r8 + r8 + 1]\n.gre:\n  mov dword [Vec + rsi * 4], r9d\n  add edx, 4\n  mov r9d, dword [rdx]\n  lea r9d, [r9 + r9 * 2 + 1]\n  jmp .loop\n.les:\n  mov dword [Vec + rsi * 4], r8d\n  add ecx, 4\n  mov r8d, dword [rcx]\n  lea r8d, [r8 + r8 + 1]\n  jmp .loop\n.end:\n  mov eax, dword [Vec - 4 + rdi * 4]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212805,"user_id":null,"body":"global dbl_linear\nglobal heap_add\nglobal heap_pop\n\nextern malloc\nextern free\n\nsection .text\n; input: edi = n\n; output: eax\ndbl_linear:\n  push rbp\n  mov rbp, rsp\n\n  mov eax, 1\n  test edi, edi\n  jz .return\n  push rdi\n  \n  lea rdi, [rdi*4+16]\n  call malloc\n  mov rdi, rax\n  test rax, rax\n  jz .return\n  xor esi, esi\n  \n  mov rdx, 1\n  call heap_add\n  \n  pop rcx\n  \n.next:\n  call heap_pop\n  push rax\n  lea edx, [eax*2+1]\n  call heap_add\n  \n  mov eax, [rsp]\n  lea edx, [eax*3+1]\n  call heap_add\n\n  pop rax\n  cmp eax, [rdi]\n  jne .deduped\n  \n.dedupe:\n  call heap_pop\n  cmp eax, [rdi]\n  je .dedupe\n  \n.deduped:\n  loop .next\n  \n  mov eax, [rdi]\n  push rax\n  call free\n  pop rax\n  \n.return:\n  mov rsp, rbp\n  pop rbp\n  ret\n\nheap_add:\n  push rbp\n  mov rbp, rsp\n  inc esi\n  mov eax, esi\n  mov r8d, esi\n  \n.bubble_up:\n  shr r8d, 1\n  jz .insert\n  mov r9d, [r8*4+rdi-4]\n  cmp r9d, edx\n  jle .insert\n  \n  mov [rax*4+rdi-4], r9d\n  mov eax, r8d\n  jmp .bubble_up\n\n.insert:\n  mov [rax*4+rdi-4], edx\n  leave\n  ret\n  \nheap_pop:\n  push rbp\n  mov rbp, rsp\n\n  mov eax, [rdi]\n  dec esi\n  jz .done\n  \n  push rax\n  \n  mov edx, [rsi*4+rdi]\n  xor eax, eax\n  mov r8d, 2\n\n.bubble_down:\n  cmp r8d, esi\n  ja .insert\n  je .go_left\n  mov r9d, [r8*4+rdi]\n  cmp r9d, [r8*4+rdi-4]\n  jb .go_right\n  \n.go_left:\n  mov r9d, [r8*4+rdi-4]\n  dec r8d\n  \n.go_right:\n  cmp r9d, edx\n  jge .insert\n  mov [rax*4+rdi], r9d\n  mov eax, r8d\n  inc r8d\n  shl r8d, 1\n  jmp .bubble_down\n  \n.insert:\n  mov [rax*4+rdi], edx\n  pop rax\n  \n.done:\n  leave\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212806,"user_id":527,"body":"global dbl_linear\nextern malloc, free\nsection .text\n; input: edi = n\n; output: eax\ndbl_linear:\n%define xs_end rax\n%define x2 esi\n%define x3 edi\n%define p2 r9\n%define p3 r10\n%define x edx\n%define x64 rdx\n%define i ecx\n%define i64 rcx\n                push    rdi\n                lea     edi, [(edi + 1) * 4]\n                call    malloc\n                pop     i64\n                push    xs_end\n                mov     p2, xs_end\n                mov     p3, xs_end\n                mov     x2, 1\n                mov     x3, 1\n.loop:          mov     x, x3\n                cmp     x2, x3\n                cmovb   x, x2\n                mov     [xs_end], x\n                add     xs_end, 4\n                cmp     x, x2\n                jne     .done_next_x2\n                imul    x2, [p2], 2\n                add     p2, 4\n                inc     x2\n.done_next_x2:  cmp     x, x3\n                jne     .done_next_x3\n                imul    x3, [p3], 3\n                add     p3, 4\n                inc     x3\n.done_next_x3:  dec     i\n                jns     .loop\n                mov     x, [xs_end - 4]\n                pop     rdi\n                push    x64\n                call    free\n                pop     rax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212807,"user_id":168,"body":"global dbl_linear\nextern malloc\nextern free\nsection .text\n; input: edi = n\n; output: eax\ndbl_linear:\n  mov edi, edi\n  push rdi\n  lea rdi, [rdi * 4 + 4]\n  call malloc\n  pop rcx\n  mov dword [rax], 1\n  push rax\n  \n  mov rdi, rax\n  mov rsi, rax\n  \n.loop:\n  cmp rcx, 1\n  jl .end\n  dec rcx\n  add rax, 4\n  mov r8d, dword [rdi]\n  mov edx, dword [rsi]\n  lea r8, [r8 * 2 + 1]\n  lea rdx, [rdx * 2 + rdx + 1]\n\n  cmp r8, rdx\n  jle .le_2_3\n  mov dword [rax], edx\n  add rsi, 4\n  jmp .loop\n.le_2_3:\n  mov dword [rax], r8d\n  ; lea does not modify flags\n  lea rdi, [rdi + 4]\n  jne .loop\n  add rsi, 4\n  jmp .loop\n\n.end:\n  pop rdi\n  mov eax, dword [rax]\n  push rax\n  call free\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56747fd5cb988479af000028":[{"id":212808,"user_id":null,"body":"section .text\nglobal get_middle\nget_middle:\n  xor   rax,rax\n  mov   rcx,-1\n  repne scasb\n  dec   rcx\n  sar   rcx,1\n  mov   ax,[rdi+rcx]\n  mov   [rsi],ax\n  adc   rsi,1\n  mov   byte[rsi],0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212809,"user_id":null,"body":"section .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n  xor rcx, rcx\n  dec rcx ; rcx = 0xFFFFFFFFFFFFFFFF\n  xor rax, rax ; rax = \\0\n  mov [rsi], rax ; buf = {0, 0, 0,}\n  push rdi\n  cld\n  repne scasb\n  pop rdi ; rdi = s\n  neg rcx\n  sub rcx, 2 ; rcx = strlen(s)\n  mov rax, rcx\n  xor rdx, rdx ; rdx:rax = strlen(s)\n  mov rbx, 2\n  div rbx ; rax = strlen(s) \/ 2\n  mov bl, [rdi + rax] ; rbx = center or right symbol\n  test rcx, 1\n  jnz return ; if (rcx & 1 == 0) even\n  mov [rsi + 1], bl\n  mov bl, [rdi + rax - 1] ; rbx = left symbol\nreturn:\n  mov [rsi], bl\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212810,"user_id":527,"body":"extern strlen\n\nsection .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\nget_middle:\n                push    rdi\n                push    rsi\n                push    rbp\n                call    strlen\n                pop     rbp\n                pop     rsi\n                pop     rdi\n                dec     rax\n                shr     rax, 1\n                sbb     ecx, ecx\n                mov     dl, [rdi + rax]\n                mov     [rsi], dl\n                and     cl, [rdi + rax + 1]\n                mov     [rsi + 1], cl\n                mov     [rsi + 2], byte 0                \n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212811,"user_id":null,"body":"section .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n  mov rcx,-1\n  xor rax,rax\n  loop1:\n  inc rcx\n  mov al,[rdi+rcx]\n  cmp al,0\n  jne loop1\n  bt rcx,0\n  jnc even\n  shr rcx,1\n  mov al,[rdi+rcx]\n  mov [rsi],ax\n  jmp end\n  even:\n  shr rcx,1\n  dec rcx\n  mov ax,[rdi+rcx]\n  mov [rsi],ax\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212812,"user_id":null,"body":"\nsection .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n    xor rdx, rdx\n    mov rax, -1\n    mov r8, 2\n.first_loop:\n    inc rax\n    cmp byte [rdi + rax], 0\n    jne .first_loop\n\n.second_loop:\n    div r8\n    cmp rdx, 0\n    jne .two\n.one:\n    mov cl, byte [rdi + rax -1]\n    mov byte [rsi], cl\n    mov cl, [rdi + rax]\n    mov byte [rsi + 1], cl\n    mov byte [rsi + 2], 0\n    ret \n.two:\n    mov cl, byte [rdi + rax]\n    mov byte [rsi], cl\n    mov byte [rsi + 1], 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212813,"user_id":null,"body":"section .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n  mov rax, -1\n.getlen:\n  cmp byte [rdi + rax + 1], 0\n  lea rax, [rax + 1]\n  jne .getlen\n  lea rcx, [rax - 1]\n  shr rcx, 1\n  test al, 1\n  mov dl, [rdi + rcx]\n  mov [rsi], dl\n  jne .odd\n  mov al, [rcx + rdi + 1]\n  mov byte [rsi + 1], al\n  add rsi, 2\n  jmp .done\n.odd:\n  inc rsi\n.done:\n  mov byte [rsi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212814,"user_id":173,"body":"section .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n  mov rax, 0\nNC:\n  cmp byte [rdi + rax], 0\n  je L1\n  inc rax\n  jmp NC\nL1:\n  mov rdx, 0\n  mov rcx, 2\n  div rcx\n\n  add rdi, rax\n  dec rdi\n  add rdi, rdx\n  mov byte cl, [rdi]\n  mov byte [rsi], cl\n  cmp rdx, 0\n  jne L2\n  inc rsi\n  inc rdi\n  mov byte cl, [rdi]\n  mov byte [rsi], cl\nL2:\n  inc rsi\n  mov byte [rsi], 0\n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212815,"user_id":null,"body":"section .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n\n    ;get length of the given string -> rbx\n    xchg  rdi,rsi\n    push  rsi\n    mov   rbx,-1\n.loop1:\n    inc   rbx\n    lodsb\n    cmp   al,0\n    jne   .loop1\n    pop   rsi\n\n    ;number of chars to get -> rcx\n    mov   rcx,1\n    test  bl,1\n    jnz   .odd\n    inc   ecx\n    dec   rsi\n.odd:\n    shr   rbx,1\n    add   rsi,rbx\n\n    ;copy chars to given buffer\n    push  rdi\n.copy:\n    lodsb\n    stosb\n    loop  .copy\n    mov   byte[rdi],0\n    pop   rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212816,"user_id":null,"body":"section .text\nglobal get_middle\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n  lea rax, [rdi-1]\nstrlen:\n  inc rax\n  cmp byte[rax],0\n  jne strlen\n  sub rax,rdi\n  dec rax\n  \n  xor ecx,ecx\n  shr rax,1\n  setnc ch\n  dec cx\n  add rdi,rax\n  and cx,[rdi]\n  mov [rsi],ecx\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212817,"user_id":null,"body":"section .text\nglobal get_middle\nextern strlen\n; void get_middle(const char *s, char *buf)\n; Write the result to `buf`. Don't forget to add a null byte.\nget_middle:\n  push  rdi\n  push  rsi\n  call  strlen\n  pop   rsi\n  pop   rdi\n  mov   rcx, rax\n  and   rcx, 1\n  test  rcx, rcx  ; == 0 if even\n  je    .even\n  .odd:\n  shr   rax, 1\n  mov   r10, [rdi+rax]\n  mov   [rsi], r10\n  inc   rsi\n  mov   [rsi], byte 0\n  ret\n  .even:\n  shr   rax, 1\n  dec   rax\n  mov   r10, [rdi+rax]\n  mov   [rsi], r10\n  inc   rax\n  inc   rsi\n  mov   r10, [rdi+rax]\n  mov   [rsi], r10\n  inc   rsi\n  mov   [rsi], byte 0\n  ret   ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5679aa472b8f57fb8c000047":[{"id":212818,"user_id":null,"body":"global find_even_index\n\nsection .text\n\n; <--- int find_even_index(const int *values, int len) --->\nfind_even_index:\n    xor r8d, r8d            ; resetting R8D as <rsum>\n    test esi, esi           ; whether <len> is zero\n    cmove eax, r8d          ; resetting <inx>\n    je .exit                ; jumping to exit\n    mov eax, -1             ; setting <inx> to \"not found\"\n    mov ecx, esi            ; setting ECX to <len> as <i>\n    xor r9d, r9d            ; resetting R9D as <lsum>\n.lpsum:\n    dec ecx                 ; decrementing <i>\n    jl .loop                ; jumping to the .loop label if less than zero\n    add r8d, [rdi+rcx*4]    ; adding <*(arr+i)> to <rsum>\n    jmp .lpsum              ; jumping to the next .lpsum iteration\n.loop:\n    inc ecx                 ; incrementing <i>\n    cmp ecx, esi            ; whether <i> and <len> are equal\n    je .exit                ; jumping to exit\n    mov edx, [rdi+rcx*4]    ; coppying <*(arr+i)> to EDX as <curr>\n    sub r8d, edx            ; subtracting <curr> from <rsum>\n    cmp r8d, r9d            ; whether <rsum> and <lsum> are equal\n    cmove eax, ecx          ; setting <inx> to <i>\n    je .exit                ; jumping to exit\n    add r9d, edx            ; adding <curr> to <lsum>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    ret\n; ---------> endof find_even_index <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212819,"user_id":null,"body":"global find_even_index\nsection .text\nfind_even_index:\n  xor rcx,rcx\n  mov rdx,rsi\n  .b:add ecx,dword[rdi+rsi*4-4]\n     dec rsi\n  jne .b\n  xor r8,r8\n  xor rax,rax\n  .c:sub ecx,dword[rdi+rax*4]\n     cmp ecx,r8d\n     je .q\n     add r8d,dword[rdi+rax*4]\n     inc rax\n     dec rdx\n  jne .c   \n  mov rax, -1\n  .q:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212820,"user_id":null,"body":"global find_even_index\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\n  xor edx, edx\n  movsx rsi, esi\n  mov rax, 1\n.rsum:\n  cmp rax, rsi\n  jnb .rsumdone\n  movsx rcx, dword [rdi+rax*4]\n  inc rax\n  add rdx, rcx\n  jmp .rsum\n.rsumdone:\n  xor eax, eax\n  test rdx, rdx\n  je .done\n  xor ecx, ecx\n  mov rax, 1\n.loop:\n  cmp rax, rsi\n  jnb .fail\n  movsx r8, dword [rdi-4+rax*4]\n  add rcx, r8\n  movsx r8, dword [rdi+rax*4]\n  sub rdx, r8\n  cmp rcx, rdx\n  je .done\n  inc rax\n  jmp .loop\n.fail:\n  mov rax, -1\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212821,"user_id":null,"body":"global find_even_index\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\n  test rsi, rsi\n  jz .failure\n  xor eax, eax\n  lea r8d, [eax + 1]\n  cmp rsi, r8\n  je .success\n  xor ecx, ecx\n.init_loop:\n  add ecx, [rdi + r8 * 4]\n  inc r8\n  cmp r8, rsi\n  jne .init_loop\n  xor edx, edx\n.split_loop:\n  cmp ecx, edx\n  je .success\n  add edx, [rdi + rax * 4]\n  inc rax\n  cmp rax, rsi\n  je .failure\n  sub ecx, [rdi + rax * 4]\n  jmp .split_loop\n.failure:\n  mov rax, -1\n.success:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212822,"user_id":null,"body":"global find_even_index\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\n  test rsi, rsi\n  jz .failure\n  xor eax, eax\n  mov r8d, 1\n  cmp rsi, r8\n  je .success\n.init:\n  xor ecx, ecx\n.init_loop:\n  add ecx, [rdi + r8 * 4]\n  inc r8\n  cmp r8, rsi\n  jne .init_loop\n  xor edx, edx\n.split_loop:\n  cmp ecx, edx\n  je .success\n  add edx, [rdi + rax * 4]\n  inc rax\n  cmp rax, rsi\n  je .failure\n  sub ecx, [rdi + rax * 4]\n  jmp .split_loop\n.failure:\n  mov rax, -1\n.success:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212823,"user_id":null,"body":"global find_even_index\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\n  test rsi, rsi\n  jz .failure\n  xor eax, eax\n  cmp rsi, 1\n  je .success\n.init:\n  mov r8d, 1\n  xor ecx, ecx\n.init_loop:\n  add ecx, [rdi + r8 * 4]\n  inc r8\n  cmp r8, rsi\n  jne .init_loop\n  xor edx, edx\n.split_loop:\n  cmp ecx, edx\n  je .success\n  add edx, [rdi + rax * 4]\n  inc rax\n  cmp rax, rsi\n  je .failure\n  sub ecx, [rdi + rax * 4]\n  jmp .split_loop\n.failure:\n  mov rax, -1\n.success:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212824,"user_id":null,"body":"global find_even_index\nextern mprint\nextern mprint_b\n\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\n  ;int ret = -1;\n  mov rax,-1\n  ;int sum_front = 0;\n  mov qword [sum_front],0\n  ;int sum_rear  = 0;\n  mov qword [sum_rear],0\n  ;for(int i=0;i<length;i++){sum_rear+=arr[i]}\n  push rsi\nsum_loop:\n  mov ebx , [rdi+4*rsi-4]\n  add dword [sum_rear],ebx\n  dec esi\n  jnz sum_loop\n  pop rsi\n  \n; int current_amount = 0\n  mov r12,0\n  ;if(sum_front==sum_rear) return 0;\n  mov r14d,dword [sum_front]\n  mov r15d, dword [sum_rear]\n  cmp r14d,r15d\n  jnz skip\n  mov rax,0\n  ret\nskip:\n;for(int i=0;i<length;i++){\n  mov r13,0\nmov_loop:\n  ;sum_front+=current_amount;\n  add dword [sum_front],r12d\n  ;current_amount = arr[i]\n  mov r12d , [rdi+4*r13]\n  ;sum_rear -=current_amount;\n  sub dword [sum_rear],r12d\n  \n  ;if(sum_front==sum_rear) \n  mov r14d,dword [sum_front]\n  mov r15d, dword [sum_rear]\n  cmp r14d,r15d\n  jnz skip1\n  ;return i;  \n  mov rax,r13\n  ret\nskip1:  \n  inc r13\n  cmp r13d,esi\n;}    \n  jnz mov_loop\n   \n;return i  \n  ret\n  \n  \nsection .data\nsum_front:    dd 0\nsum_rear:     dd 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212825,"user_id":50,"body":"global find_even_index\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\n  xor rax,rax ; rax accumulator to zero\n  push rsi ; save length\n  xor r8,r8 ; i\n  xor r9,r9 ; b\n_sum:\n  test esi,esi ; if esi==0 we parsed all the array\n  jz _next\n  dec esi ; esi-=1\n  add eax,dword[rdi+4*rsi] ; rax += arr[esi]\n  jmp _sum\n_next:\n  pop rsi ; restaure length\n_loop:\n  cmp r8,rsi ; if i==l return -1\n  je _retMinusOne\n  sub eax,dword[rdi+4*r8] ; rax-=arr[i]\n  cmp rax,r9 ; compare rax with r9\n  je _exit ; if they are equal it's over and we should return i\/r8\n  add r9d,dword[rdi+4*r8] ; b+=arr[i]\n  inc r8 ; i++\n  jmp _loop\n_retMinusOne:\n  mov r8,-1\n_exit:\n  mov rax,r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212826,"user_id":null,"body":"global find_even_index\nsection .text\nfind_even_index:\n  mov rax, -1\n  xor r8, r8 ; sum\n  xor rcx, rcx ; index\n  xor edx, edx ; for holding temp values\n  jmp startsum\nsumloop:\n  mov edx, [rdi+4*rcx]\n  add r8d, edx\n  inc rcx\nstartsum:\n  cmp ecx, esi\n  jne sumloop\n  xor r9, r9 ; sum to the left\n  xor rcx, rcx ; index\n  jmp start\nsexyloop:\n  mov edx, [rdi+4*rcx]\n  sub r8d, edx ; sum to the right\n  cmp rcx, 0\n  je next\n  mov edx, [rdi+4*rcx-4]\n  add r9d, edx\nnext:\n  cmp r8, r9\n  jne cont\n  mov rax, rcx\n  ret\ncont:\n  inc rcx\nstart:\n  cmp ecx, esi\n  jne sexyloop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212827,"user_id":null,"body":"global find_even_index\nsection .text\n; input: rdi = values, esi = length\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfind_even_index:\npush rbx\nmov eax, 0\nmov ecx, -1\nsub rdi, 4\nouter:\n  push rdi \n  push rcx\n  \n  add rdi, 8\n  add ecx, 2\n  mov ebx, 0\n\ninner:\n  cmp ecx, esi\n  jns inner_end\n\n  add ebx, dword[rdi]\n  \n  inc ecx\n  add rdi, 4\n  jmp inner\n\ninner_end:\n  pop rcx\n  pop rdi\n\n  cmp eax, ebx\n  je end\n  \n  inc ecx\n  add rdi, 4\n  \n  cmp ecx, esi\n  jns outer_end\n  \n  add eax, dword[rdi]\n  jmp outer\n\nouter_end:\n  mov ecx, -2\n\nend:\n  mov eax, ecx\n  inc eax\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"568d0dd208ee69389d000016":[{"id":212828,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n    mov eax, 0h28       ; moving to EAX forty\n    mul edi             ; multiplying by <d> to get the usual cost\n    cmp edi, 0h02       ; whether the rent is less than two days\n    jle .exit           ; jumping to exit\n    sub eax, 0h14       ; subtracting twenty from the cost\n    cmp edi, 0h06       ; whether the rent is less than six days\n    jle .exit           ; jumping to exit\n    sub eax, 0h1E       ; subtracting thirty from the cost\n.exit:\n    ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212829,"user_id":527,"body":"global rental_car_cost\n\nsection .text\n\n; unsigned rental_car_cost(unsigned d)\nrental_car_cost:\n                lea     eax, [edi * 5]\n                lea     eax, [rax * 8]\n                lea     ecx, [rax - 20]\n                lea     edx, [rax - 50]\n                cmp     edi, 3\n                cmovae  eax, ecx\n                cmp     edi, 7\n                cmovae  eax, edx\n.done:          ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212830,"user_id":168,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n  imul eax, edi, 40\n  lea edx, [eax - 20]  \n  cmp edi, 3\n  cmovae eax, edx\n  lea edx, [eax - 30]\n  cmp edi, 7\n  cmovae eax, edx\n  ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212831,"user_id":null,"body":"section .text\nglobal rental_car_cost\nrental_car_cost:\n  mov eax, 40\n  mul edi\n  cmp edi, 3\n  jb .exit\n  cmp edi, 7\n  jb .3days\n  sub eax, 50\n  ret\n.3days:\n  sub eax, 20\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212832,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n    xor eax, eax        ; EAX <- the result\n    mov eax, 40\n    cmp edi, 7\n    jge .seven\n    cmp edi, 3\n    jge .three\n    jmp .else\n\n.seven:\n    mul edi\n    sub eax, 50\n    jmp .quit\n\n.three:\n    mul edi\n    sub eax, 20\n    jmp .quit\n\n.else:\n    mul edi\n    jmp .quit\n\n.quit:\n    ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212833,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n    xor eax, eax \n    mov eax, 40\n    mul edi\n    cmp edi, 3\n    jae three\n    ret\nthree:\n    cmp edi, 7\n    jae seven\n    sub eax, 20\n    ret\nseven:\n    sub eax, 50\n    ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212834,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n    cmp rdi, 0\n    jle none\n    cmp rdi, 2       ; EAX <- the result\n    jle one\n    cmp rdi, 7\n    jge greater\n    mov rax, 40\n    imul rax, rdi\n    sub rax, 20\n    ret\n    \none:\n    mov rax, 40\n    imul rax, rdi\n    ret\n    \ngreater:\n    mov rax, 40\n    imul rax, rdi\n    sub rax, 50\n    ret\n    \nnone:\n    mov rax, rdi\n    ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212835,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n    xor eax, eax        ; EAX <- the result\n    mov eax, edi\n    imul eax, 40\n    cmp edi, 7\n    jge bigCut\n    cmp edi, 3\n    jge smallCut\n    ret\n    bigCut:\n    sub eax, 50\n    ret\n    smallCut:\n    sub eax, 20\n    ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212836,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n    xor eax, eax        ; EAX <- the result\n    mov ebx, edi\n    cmp edi, 3\n    jl direct\n    cmp edi, 7\n    jl shorte\n    sub eax, 30\n    shorte:\n    sub eax, 20\n    direct:\n    imul ebx, 40\n    add eax, ebx\n    ret\n; -----> end of rental_car_cost <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212837,"user_id":null,"body":"global rental_car_cost\n\nsection .text\n\n; <--- unsigned rental_car_cost(unsigned d) --->\nrental_car_cost:\n  xor eax, eax\n  cmp edi, 3\n  mov ecx, -20\n  cmovb ecx, eax\n  cmp edi, 7\n  mov eax, -50\n  cmovb eax, ecx\n  lea ecx, [rdi + 4*rdi]\n  lea eax, [rax + 8*rcx]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"568dcc3c7f12767a62000038":[{"id":212838,"user_id":168,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\nsetalarm:\n  andn eax, esi, edi\n  ret\n; ---------> endof setalarm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212839,"user_id":null,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\n; rdi = empl\n; rsi = vac\n; rdi AND !rsi\nsetalarm:\n    mov rdx, 1    ; !rsi is implemented with xor\n    xor rsi, rdx  ; 1 xor 0 = 1; 1 xor 1 = 0\n    and rdi, rsi\n    mov al, dil \n    ret\n; ---------> endof setalarm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212840,"user_id":527,"body":"global setalarm\n\nsection .text\n\n; bool setalarm(bool empl, bool vac)\nsetalarm:\n                andn    eax, esi, edi\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212841,"user_id":null,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\nsetalarm:   dq  -2.7815371558485528576E19\n; ---------> endof setalarm <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212842,"user_id":null,"body":"global setalarm\n\nsetalarm:\n    sub rdi, rsi\n    setg al\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212843,"user_id":527,"body":"global setalarm\nsetalarm db 'UNNAMED]VX#\u01d03\u01d0\u00c0'","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212844,"user_id":null,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\nsetalarm:\n    not rsi\n    and rdi, rsi\n    mov rax, rdi\n    ret\n; ---------> endof setalarm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212845,"user_id":null,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\nsetalarm:\n    test  dil,dil        ; interpret values != 0 mean true\n    setnz dil            ; dil = 1 or 0 if dil if true or false\n    test  sil,sil        ; interpret values != 0 mean true\n    setz  al             ; al = 0 or 1 if sil is true or false\n    and   al, dil        ; bitwise and = logical and after normalization\n    movzx rax, al        ; expand to rax to ensure compatibility\n    ret\n; ---------> endof setalarm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212846,"user_id":null,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\nsetalarm:\n    lea eax, [esi+1]\n    and eax, edi\n    ret\n; ---------> endof setalarm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212847,"user_id":null,"body":"global setalarm\n\nsection .text\n\n; <--- bool setalarm(bool empl, bool vac) --->\nsetalarm:\n    ;xor al, al      ; AL <- the result\n  xor esi,edi\n  and edi,esi\n  mov eax,edi\nret\n; ---------> endof setalarm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"569d488d61b812a0f7000015":[{"id":212848,"user_id":null,"body":"global data_reverse\nextern malloc\n\nsection .text\n\n; <--- unsigned char *data_reverse(unsigned char *rdata, const unsigned char *data, size_t nblk) --->\ndata_reverse:\n    lea rdi,[rdi+rdx*8-8]  ; Point to the last byte of array\n    \n    .loop1:\n    movsq    ; Mov 8 bytes of one array to other array\n    sub rdi,16 \n    dec rdx\n    jnz .loop1\n    \n    mov rax, rdi  ;send final array\n    ret\n; ---------> endof data_reverse <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212849,"user_id":null,"body":"global data_reverse\nsection .text\n\ndata_reverse:\n  mov r8, [rsi+(rdx-1)*8]\n  mov [rdi], r8\n  add rdi, 8\n  dec rdx\n  jnz data_reverse\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212850,"user_id":null,"body":"global data_reverse\nsection .text\n\ndata_reverse:\n    dec rdx\n    xor rcx,rcx\n@l1:mov rax,[rsi + rdx * 8]\n    mov [rdi + rcx * 8],rax\n    inc rcx\n    dec rdx\n    jns @l1\n    mov rax, rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212851,"user_id":null,"body":"global data_reverse\nextern malloc\n\nsection .text\n\ndata_reverse:\n        mov     rax, rdi\n        mov     rcx, rdi\n.loop:\n        test    rdx, rdx\n        jz      .exit\n        dec     rdx\n        mov     rdi, [rsi+rdx*8]\n        add     rcx, 8\n        mov     [rcx-8], rdi\n        jmp     .loop\n.exit:\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212852,"user_id":null,"body":"global data_reverse\nextern malloc\n\nsection .text\n\n; <--- unsigned char *data_reverse(unsigned char *rdata, const unsigned char *data, size_t nblk) --->\ndata_reverse:\n  mov rax, rdi\n.loop:\n  sub rdx, 1\n  jb .done\n  mov rcx, [rsi]\n  mov [rax + 8*rdx], rcx\n  add rsi, 8\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212853,"user_id":null,"body":"global data_reverse\nextern malloc\n\nsection .text\n; <--- unsigned char *data_reverse(unsigned char *rdata, const unsigned char *data, size_t nblk) --->\ndata_reverse:\n    mov rax, rdi        ; RAX <- the result\n    test rdx, rdx\n    jz .bailout\n    lea rdi, [rdi+rdx*8]\n    \n.loop:\n    sub rdi, 8\n    mov rcx, [rsi]\n    add rsi, 8\n    mov [rdi], rcx\n    cmp rax, rdi\n    jne .loop\n\n.bailout:\n    ret\n; ---------> endof data_reverse <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212854,"user_id":460,"body":"extern malloc\nsection .text\nglobal data_reverse\ndata_reverse:\n  mov rcx, [rsi+(rdx-1)*8]\n  mov [rdi], rcx\n  add rdi, 8\n  dec rdx\n  jnz data_reverse\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212855,"user_id":460,"body":"extern malloc\nsection .text\nglobal data_reverse\ndata_reverse:\n  ; save beginnings of arrays\n  mov r8, rsi\n  mov r9, rdi\n  sal rdx, 3 ; multiply nblk by 8\n  ; rdi - source byte iterator (start from last byte) \n  mov rdi, r8\n  add rdi, rdx\n  sub rdi, 8\n  ; rsi - target byte iterator (start from first byte)\n  mov rsi, r9\n  \n.byte_loop:\n  xor rcx, rcx ; rcx - bit iterator (start from first bit)\n.bit_loop:\n  mov al, byte [rdi]\n  mov byte [rsi], al\n  inc rdi\n  inc rsi\n  inc rcx\n  cmp rcx, 8\njl .bit_loop\n\n  ; bit_loop moved rdi to end of current byte, so we need to \n  ; subtract 2 * 8 to get to beginning of previous byte\n  sub rdi, 16 ; go to previous byte \n  ; nothing for rsi because it's already on beginning of requred byte\n  cmp rdi, r8\njge .byte_loop\n\n  mov rax, r9\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212856,"user_id":173,"body":"global data_reverse\n\n\nsection .text\n\n; <--- unsigned char *data_reverse(unsigned char *rdata, const unsigned char *data, size_t nblk) --->\ndata_reverse:\n    mov r12, rdi\n    mov r13, rsi\n    mov r15, rdx\n\n\n    mov rdx, 0\n    mov rax, r15\n    mov rcx, 8\n    mul rcx\n    ; r14 is length (8 * nblk)\n    mov r14, rax\n    \n    mov rdx, r15\n    \n    mov rdi, r12\n    mov rsi, r13\n    add rsi, r14\nl_loop:\n    sub rsi, 8\n    \n    mov rcx, 0\nl_l:\n    mov al, byte [rsi]\n    mov byte [rdi], al\n    inc rdi\n    inc rsi\n    inc rcx\n    cmp rcx, 8\n    jb l_l\n\n    dec rdx\n    cmp rdx, 0\n    je l_done\n    sub rsi, 8\n    jmp l_loop\nl_done:\n    mov rax, r12\n    ret\n; ---------> endof data_reverse <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212857,"user_id":null,"body":"global data_reverse\n\nsection .text\n\n; <--- unsigned char *data_reverse(unsigned char *rdata, const unsigned char *data, size_t nblk) --->\ndata_reverse:\n  mov rcx, rdx\n.next_byte:\n  mov r8, [rsi+(rcx-1)*8]\n  mov [rdi], r8\n  add rdi, 8\n  loopnz .next_byte\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56b22765e1007b79f2000079":[{"id":212858,"user_id":881,"body":"section .text\nglobal is_narcissistic\n\n; bool is_narcissistic(long long unsigned x)\n; x -> rdi, result -> al\nis_narcissistic:\n    mov rax, rdi\n    xor rcx, rcx\n    mov r10, 10\n.count_digits:\n    xor rdx, rdx\n    inc rcx\n    div r10\n    cmp rax, 0\n    jnz .count_digits\n    mov rax, rdi\n    xor r8, r8\n    test rax, rax\n    jz .true\n.sum_powers:\n    xor rdx, rdx\n    div r10\n    mov r9, rax\n    mov rax, 1\n    mov rsi, rdx\n    mov r11, rcx\n.sum_loop:\n    mul rsi\n    dec r11\n    jnz .sum_loop\n    add r8, rax\n    mov rax, r9\n    cmp r9, 0\n    jne .sum_powers  \n    cmp rdi, r8 \n    je .true\n    xor rax, rax\n    ret\n.true:\n    inc rax\n    ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212859,"user_id":168,"body":"section .bss\nbuf resb 20\n\nsection .text\nglobal is_narcissistic\nextern pow, sprintf, strlen\n\nformat db '%lld', 0\n\n; bool is_narcissistic(long long unsigned x)\n; x -> rdi, result -> al\nis_narcissistic:\n  push rbx\n  push rbp\n  push r15\n  mov rbx, rdi\n  mov rdx, rdi\n  mov rdi, buf\n  mov rsi, format\n  call sprintf\n  mov rdi, buf\n  call strlen\n  mov r15, rax\n  mov rbp, buf\n  jmp .loop_cond\n.loop:\n  sub edx, '0'\n  cvtsi2sd xmm0, edx\n  cvtsi2sd xmm1, r15d\n  call pow\n  cvttsd2si rax, xmm0\n  sub rbx, rax\n  inc rbp\n.loop_cond:\n  movzx edx, byte [rbp]\n  test edx, edx\n  jnz .loop\n  test rbx, rbx\n  setz al\n  pop r15\n  pop rbp\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212860,"user_id":50,"body":"section .text\nglobal is_narcissistic\n\n; bool is_narcissistic(long long unsigned x)\n; x -> rdi, result -> al\nis_narcissistic:\n  cmp rdi, 10\n  jb _retTrue\n  mov r11,4679307774\n  cmp rdi,r11\n  je _retTrue\n  cmp rdi, 0x99\n  je _retTrue\n  cmp rdi, 0x172\n  je _retTrue\n  cmp rdi, 0x173\n  je _retTrue\n  cmp rdi, 0x197\n  je _retTrue\n  cmp rdi, 0x662\n  je _retTrue\n  cmp rdi, 0x2010\n  je _retTrue\n  cmp rdi, 0x2502\n  je _retTrue\n  cmp rdi, 0xd5dc\n  je _retTrue\n  cmp rdi, 0x16a37\n  je _retTrue\n  cmp rdi, 0x16b9c\n  je _retTrue\n  cmp rdi, 0x85fe2\n  je _retTrue\n  cmp rdi, 0x1a939d\n  je _retTrue\n  cmp rdi, 0x404082\n  je _retTrue\n  cmp rdi, 0x958c71\n  je _retTrue\n  cmp rdi, 0x9776ab\n  je _retTrue\n  cmp rdi, 0x1788ea2\n  je _retTrue\n  cmp rdi, 0x547d445\n  je _retTrue\n  cmp rdi, 0x8bb9568\n  je _retTrue\n  cmp rdi, 0x1c274667\n  je _retTrue\n  cmp rdi, 0x1fdbbe74\n  je _retTrue\n  cmp rdi, 0x116e891fe\n  je _retTrue\n  cmp rdi, 0x116e891fe\n  je _retTrue\n  cmp rdi, 912985153\n  je _retTrue\n  xor al,al\n  jmp _exit\n_retTrue:\n  mov al, 1\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56b7f2f3f18876033f000307":[{"id":212861,"user_id":null,"body":"global in_asc_order\n\nsection .text\n\n; <----- unsigned in_asc_order(const unsigned *v, unsigned len) ----->\nin_asc_order:\n    mov eax, 1              ; setting EAX to true\n    mov ecx, 4              ; the size of unsigned\n.loop:\n    dec esi                 ; decrementing <len>    \n    je .exit                ; jumping to exit if no elements left to operate\n    mov edx, [rdi]          ; copying the current element\n    add rdi, rcx            ; moving the pointer to <v+i>\n    cmp edx, [rdi]          ; if the sequence is still ascending\n    jle .loop               ; then jumping to iterate once again\n    xor eax, eax            ; otherwise, resetting EAX and exiting\n.exit:\n    ret\n; ---------> end of asc_order <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212862,"user_id":null,"body":"global in_asc_order\nsection .text\nin_asc_order:\n.loop:\n  dec rsi\n  test rsi,rsi\n  jz .pass\n  mov edx,[rdi]\n  add rdi,4\n  cmp [rdi],edx\n  jae .loop\n  xor eax,eax\n  ret\n.pass:\n  mov eax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212863,"user_id":null,"body":"global in_asc_order\n\nsection .text\n\n; <----- unsigned in_asc_order(const unsigned *v, unsigned len) ----->\nin_asc_order:\n  cmp esi, 1\n  mov eax, 1\n  jbe .nopair\n  mov edx, [rdi]\n  mov eax, 1\n.loop:\n  mov ecx, [rdi+rax*4]\n  cmp ecx, edx\n  jb .zero\n  inc rax\n  mov edx, ecx\n  cmp eax, esi\n  jb .loop\n  mov eax, 1\n  ret\n.zero:\n  xor eax, eax\n.nopair:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212864,"user_id":null,"body":"global in_asc_order\n\n\n\n\nsection .text\n\n; <----- unsigned in_asc_order(const unsigned *v, unsigned len) ----->\nin_asc_order:\n\n    xchg rsi, rdi\n    \n    cmp  rdi,0\n    jz   ret1\n    lea  rcx, [rdi-1]\n    jz   ret1\n    \n    lodsd\n    \nloop:\n    lodsd\n    cmp [rsi-8], eax\n    jg ret0\n    loopne loop\n    \nret1:    \n    xor eax, eax\n    inc eax\n    ret\nret0:\n    xor rax, rax\n    ret\n; ---------> end of in_asc_order <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212865,"user_id":null,"body":"global in_asc_order\n\n\n%define V 8\n%define LEN 16\n\n\nsection .text\n\n; <----- unsigned in_asc_order(const unsigned *v, unsigned len) ----->\nin_asc_order:\n\n    xor rax, rax\n    \n    cmp  rsi,0\n    jz   ret1\n    lea  rcx, [rsi-1]\n    jz   ret1\n    \n    xchg rsi, rdi\n    \n    lodsd\n    mov ebx, eax\n    \nloop:\n    lodsd\n    cmp ebx, eax\n    jg ret0\n    mov ebx, eax\n    loopne loop\n    \nret1:    \n    xor eax, eax\n    inc eax\n    ret\nret0:\n    xor rax, rax\n    ret\n; ---------> end of in_asc_order <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212866,"user_id":null,"body":"global in_asc_order\n\nsection .text\n\n; <----- unsigned in_asc_order(const unsigned *v, unsigned len) ----->\nin_asc_order:\n  mov eax, [rdi]\n.loop:\n  dec esi\n  jz .yes\n  add rdi, 4\n  mov ecx, [rdi]\n  cmp eax, ecx\n  jg .no\n  mov eax, ecx\n  jmp .loop\n\n.yes:\n  mov eax, 1\n  ret\n.no:\n  xor eax, eax\n  ret\n; ---------> end of in_asc_order <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212867,"user_id":null,"body":"global in_asc_order\nsection .text\nin_asc_order:\n        cmp   esi,1\n        jle   @true     ; Function is true if only one entry in the array\n        dec   esi       ; One less comparison than entries in the array\n@loop:  mov   eax,[rdi + rsi * 4]\n        cmp   eax,[rdi + rsi * 4 - 4]\n        jb    @false    ; if pair is in wrong order, bail\n        dec   esi       ; check if we have more comparisons to do\n        jnz   @loop\n@true:  mov   eax,1      ; all good\n        ret\n@false: xor eax, eax\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212868,"user_id":173,"body":"global in_asc_order\n\nin_asc_order:\n    mov eax, 1\n    mov rcx, rsi\n    cmp rcx, 1\n    je l_done\n    xor rsi, rsi\n    mov dword eax, [rdi]\nl_loop:\n    inc rsi\n    cmp rsi, rcx\n    jae l_done\n    mov dword ebx, [rdi + rsi*4]\n    cmp eax, ebx\n    ja l_false\n    xchg eax, ebx\n    jmp l_loop\nl_done:\n    mov eax, 1\n    ret\nl_false:\n    xor eax, eax\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212869,"user_id":null,"body":"global in_asc_order\n\nsection .text\n\n; <----- unsigned in_asc_order(const unsigned *v, unsigned len) ----->\n; rdi (v), rsi (len)\nin_asc_order:\n    sub rdi, 4\n    lea rsi, [rdi + rsi*4]\n\nloop:\n    add rdi, 4\n    cmp rdi, rsi\n    je done\n\n    mov eax, [rdi]\n    cmp eax, [rdi+4]\n    jna loop\n\nfail:\n    xor eax, eax\n    ret\n\ndone:\n    mov eax, 1\n    ret\n; ---------> end of in_asc_order <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212870,"user_id":460,"body":"global in_asc_order\nsection .text\nin_asc_order:\n  xor eax, eax\n  cmp rsi, 1\n  jne .check_array\n  jmp .in_order\n\n.check_array:\n  dec rsi\n.loop:\n  mov eax, dword [rdi+rsi*4]\n  dec rsi\n  cmp eax, dword [rdi+rsi*4]\n  jl .not_in_order\n  cmp rsi, 0\n  jne .loop\n\n.in_order:\n  mov rax, 1\n  ret\n.not_in_order:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56bc28ad5bdaeb48760009b0":[{"id":212871,"user_id":null,"body":"global rmflchr\n\nsection .text\nrmflchr:\n    mov rax,rdi\n    inc rsi\n    .b:movsb\n       cmp byte[rsi],0\n    jne .b\n    mov byte[rdi-1],0\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212872,"user_id":null,"body":"; Note:\n;    You should not allocate memory\n;    Also return the destination as the result\n\nglobal rmflchr\n\nsection .text\n\n; <--- char *rmflchr(char *dest, const char *src) --->\nrmflchr:\n  xor rax, rax        ; RAX <- dest\n  mov r10, 1\n\ncopy_loop:\n  mov dl, byte [rsi + r10]\n  cmp dl, 0\n  je remove_last\n  mov byte [rdi + r10 - 1], dl\n  inc r10\n  jmp copy_loop\n\nremove_last:\n  mov byte [rdi + r10 - 2], 0\n  mov rax, rdi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212873,"user_id":null,"body":"global rmflchr\n\nsection .text\n\n; <--- char *rmflchr(char *dest, const char *src) --->\nrmflchr:\n    mov rax, rdi        ; saving <dest> in RAX to return as the result\n    mov rcx, 1          ; the <i>ndex to start copying from\n.loop:\n    mov dl, [rsi+rcx]   ; copying the <src+i> character\n    test dl, dl         ; whether <c> is an empty character\n    je .exit            ; jumping to exit\n    mov [rdi], dl       ; copying <c> to <dest+i-1>\n    inc rcx             ; incrementing <i>\n    inc rdi             ; moving the pointer to <dest> to the next position\n    jmp .loop           ; jumping to the next iteration\n.exit:\n    dec rdi             ; moving the pointer to <dest> one position back\n    mov [rdi], dl       ; copying the empty character\n    ret\n; -----> end of rmflchr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212874,"user_id":645,"body":"global rmflchr\n\nextern stpcpy\nextern _GLOBAL_OFFSET_TABLE_\n\nrmflchr:\n  push r12\n  add rsi, 1\n  mov r12, rdi\n  call stpcpy\n  mov byte [rax - 1H], 0\n  mov rax, r12\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212875,"user_id":null,"body":"extern strcpy\nextern strlen\nglobal rmflchr\nsection .text\nrmflchr:\n  inc rsi\n  call strcpy\n  call strlen\n  mov [rdi+rax-1], byte 0\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212876,"user_id":null,"body":"; Note:\n;    You should not allocate memory\n;    Also return the destination as the result\n\nglobal rmflchr\n\nsection .text\n\n; <--- char *rmflchr(char *dest, const char *src) --->\nrmflchr:\n    xor rax, rax        ; RAX <- dest\n    mov rcx, 0\n.loop:\n    inc rsi\n    mov al, [rsi]\n    test al, al\n    je .end\n    mov [rdi+rcx], al\n    inc rcx\n    jmp .loop\n.end:\n    mov [rdi+rcx-1], al\n    mov rax, rdi\n    ret\n; -----> end of rmflchr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212877,"user_id":null,"body":"global rmflchr\n\nsection .text\n\n; char *rmflchr(char *dest, const char *src)\nrmflchr:\n  mov rax, rdi\n.loop:\n  inc rsi\n  cmp BYTE [rsi + 1], 0\n  jz .exit\n  mov dl, [rsi]\n  mov [rdi], dl\n  inc rdi\n  jmp .loop\n.exit:\n  mov BYTE [rdi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212878,"user_id":null,"body":"; Note:\n;    You should not allocate memory\n;    Also return the destination as the result\n\nglobal rmflchr\nextern printf\nsection .text\n    \nrmflchr:\n    push rbp\n    mov rbp, rsp ; prologue\n    push rdi\n    inc rsi\n    \n    .copy_step:\n        movsb\n        cmp byte [rsi], 0\n        jne .copy_step\n    \n    dec rdi\n    mov byte [rdi], 0\n\n    pop rax\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212879,"user_id":null,"body":"; Note:\n;    You should not allocate memory\n;    Also return the destination as the result\n\nglobal rmflchr\nsection .text\n\nLen: ; <- rsi, calculate lenth of string in rsi without '\\0'\n    push rbp\n    mov rbp, rsp\n    push rdi\n    push rcx ; prologue\n    \n    mov rdi,rsi\n    xor rax, rax\n    mov rcx, -1 ; make counter\n    repne scasb ; seacrh for '\\0'\n    not rcx\n    mov rax, rcx ; getting the number of characters\n    \n    pop rcx ; epilogue\n    pop rdi\n    mov rsp, rbp\n    pop rbp\n    ret\n    \nrmflchr:\n    push rbp\n    mov rbp, rsp ; prologue\n    push rdi ; save pointer to result\n    \n    inc rsi ; skip one symbol in src\n    call Len ; get lenth\n    dec rax ; we don't need last symbol\n    mov rcx, rax ; make counter\n    xor rax, rax\n    rep movsb ; copy until '\\0'\n    dec rdi\n    mov byte [rdi], 0 ; set '\\0'\n    \n    pop rax ; recovery of pointer\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212880,"user_id":null,"body":"; Note:\n;    You should not allocate memory\n;    Also return the destination as the result\n\nglobal rmflchr\n\nsection .text\n\n; <--- char *rmflchr(char *dest, const char *src) --->\nrmflchr:\n  mov rcx,0\n  loop1:\n  inc rcx\n  mov al,[rsi+rcx]\n  cmp byte[rsi+rcx+1],0\n  je end\n  mov [rdi+rcx-1],al\n  jmp loop1\n  end:\n  mov byte[rdi+rcx-1],0\n  mov rax,rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56bdd0aec5dc03d7780010a5":[{"id":212881,"user_id":564,"body":"global next_higher\nnext_higher:\n  mov rax, rdi\n  popcnt rsi, rdi\n.find_next:\n  inc rax\n  popcnt rdi, rax\n  cmp rdi, rsi\n  jne .find_next\n.found:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212882,"user_id":null,"body":"global next_higher\nnext_higher:\n  popcnt ecx,edi\n  mov    eax,edi\n  @b:inc    eax\n     popcnt edx,eax\n     cmp    edx,ecx\n  jnz @b\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212883,"user_id":168,"body":"global next_higher\nnext_higher:\n  bsf ecx, edi\n  mov eax, 1\n  shl eax, cl\n  lea eax, [rax + rdi]\n  xor edi, eax\n  shr edi, cl\n  shr edi, 2\n  add eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212884,"user_id":null,"body":"global next_higher\nnext_higher:\n  tzcnt esi, edi    ; Count trailing zeros\n  \n  blsi edx, edi\n  add edx, edi      ; Extract lowest set bit and add it back to\n                    ; carry it into desired position.\n                    \n  tzcnt ecx, edx    ; Count 1 bits to generate:\n  sub ecx, esi      ; Position of lowest set bit in the new value\n  dec ecx           ; minus the number of zero bits that was already there.\n  \n  ; Generate \"ecx\" count of 1 bits.\n  xor eax, eax\n  bts eax, ecx\n  dec eax\n  \n  ; Add generated one-bits to the rest of the value.\n  or eax, edx\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212885,"user_id":527,"body":"global next_higher\nsection .text\nnext_higher:\n                lea     eax, [rdi - 1]\n                or      eax, edi\n                lea     ecx, [rax + 1]\n                andn    eax, eax, ecx\n                dec     eax\n                tzcnt   edx, edi\n                inc     dl\n                shrx    eax, eax, edx\n                or      eax, ecx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212886,"user_id":null,"body":"global next_higher\nnext_higher:\n  popcnt rax,rdi\n  loop1:\n  inc rdi\n  popcnt rbx,rdi\n  cmp rax,rbx\n  jne loop1\n  mov rax,rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212887,"user_id":null,"body":"global next_higher\nnext_higher:\n  bsf edx, edi\n  xor ecx, ecx\n.loop:\n  mov eax, edi\n  and eax, 3\n  cmp eax, 1\n  je .done\n  sar edi, 1\n  inc ecx\n  jmp .loop\n.done:\n  xor edi, 3\n  sal edi, cl\n  sub ecx, edx\n  sal eax, cl\n  dec eax\n  or eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212888,"user_id":null,"body":"global next_higher\nnext_higher:\n  bsf ecx,edi\n  mov eax,edi\n  shr eax,cl\n  mov edx,ecx\n  not eax\n  bsf ecx,eax\n  add ecx,edx\n  dec ecx\n  mov eax,3\n  shl eax,cl\n  xor eax,edi\n  mov esi,-1\n  shr esi,cl\n  shl esi,cl\n  and eax,esi\n  not esi\n  and esi,edi\n  mov ecx,edx\n  shr esi,cl\n  or eax,esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212889,"user_id":527,"body":"global next_higher\nsection .text\nnext_higher:\n                blsi    eax, edi\n                add     eax, edi\n                tzcnt   ecx, edi\n                add     ecx, 2\n                mov     edx, edi\n                xor     edx, eax\n                shrx    edx, edx, ecx\n                or      eax, edx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212890,"user_id":null,"body":"global next_higher\nnext_higher:\n    mov     eax, edi\n    popcnt  ecx, eax\nL1:\n    inc     eax\n    popcnt  edx, eax\n    cmp     ecx, edx\n    jne     L1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56c5847f27be2c3db20009c3":[{"id":212891,"user_id":null,"body":"global subtract_sum\nsubtract_sum:\n  mov rax, s\n  ret ; fruit name like \"apple\"\n\ns:\n  db \"apple\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212892,"user_id":50,"body":"section .data\n  m db \"apple\",0\n  \nsection .text\nglobal subtract_sum\nsubtract_sum:\n  xor rax,rax\n  mov rax,m\n  ret ; fruit name like \"apple\"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212893,"user_id":null,"body":"global subtract_sum\nsection .data\n  fruit_map:  \n        db  0, 1, 0, 2, 3, 2, 3, 4, 5, 4, 6, 4\n        db  6, 7, 8, 7, 8, 5, 8, 9, 1, 9, 1, 0\n        db  2, 0, 5, 3, 2, 3, 4, 3, 4, 6, 7, 5\n        db  7, 8, 7, 8, 9, 1, 9, 1, 5, 1, 0, 2\n        db  0, 2, 3, 4, 3, 5, 6, 4, 6, 7, 6, 7\n        db  8, 9, 5, 9, 1, 9, 1, 0, 1, 0, 2, 5\n        db  2, 3, 4, 3, 4, 6, 4, 6, 5, 8, 7, 8\n        db  9, 8, 9, 1, 9, 5, 0, 2, 0, 2, 3, 2\n        db  3, 4, 5, 4\n\n  _f1:  db \"kiwi\", 0\n  _f2:  db \"pear\", 0\n  _f3:  db \"banana\", 0\n  _f4:  db \"melon\", 0\n  _f5:  db \"pineapple\", 0\n  _f6:  db \"apple\", 0\n  _f7:  db \"cucumber\", 0\n  _f8:  db \"orange\", 0\n  _f9:  db \"grape\", 0\n  _f10: db \"cherry\", 0    \n\n  fruit_labels:\n        dq _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10\n        \nsection .text\n  subtract_sum:\n    mov ecx, 10\n    loop0:\n      xor r8d, r8d\n      mov eax, edi\n      loop1:\n        xor rdx, rdx\n        div ecx\n        add r8d, edx\n        cmp eax, 0\n      jnz  loop1\n      sub edi, r8d\n      cmp edi, 100\n    jnb loop0\n\n    dec edi\n    movzx edi, byte [fruit_map + edi]\n    mov rax, [fruit_labels + edi*8]\n  \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212894,"user_id":527,"body":"global subtract_sum\nsubtract_sum:\n  mov rax, .apple\n  ret\n.apple db 'apple', 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212895,"user_id":null,"body":"global subtract_sum\nsubtract_sum:\n  lea rax, [.apple]\n  ret\n.apple: db \"apple\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212896,"user_id":null,"body":"global subtract_sum\nsubtract_sum:\n  mov rax, WhatTheFruit\n  ret\n\nWhatTheFruit:\n  db \"apple\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212897,"user_id":null,"body":"global subtract_sum\nsubtract_sum:\n  mov eax, message\n  ret\n  \nsection   .data\n  message: db \"apple\"\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212898,"user_id":53,"body":"SECTION .data\n secret db \"apple\", 0\n\nSECTION .text\nglobal subtract_sum\nextern strcmp\nsubtract_sum:\n  xor rax, rax\n  mov rax, secret\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212899,"user_id":null,"body":"global subtract_sum\nsubtract_sum:\n  mov rax, apple\n  ret\n\nsection .data\n  apple: db \"apple\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212900,"user_id":null,"body":"global subtract_sum\nsection .data\napple db \"apple\",0\nsubtract_sum:\n  mov rax,apple\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56cd44e1aa4ac7879200010b":[{"id":212901,"user_id":null,"body":"section     .text\nglobal      is_uppercase\n\nis_uppercase:\n    xor     rax, rax\n    xor     rsi, rsi\n    \n    dec     rsi\n\n_check_loop:\n    inc     rsi\n    \n    cmp     byte [rdi + rsi], 0\n    je      _end\n\n    cmp     byte [rdi + rsi], 97\n    jge     _potential_false\n    \n    jmp     _check_loop\n\n_end:\n    mov     rax, 1\n    ret\n\n_potential_false:\n    cmp     byte [rdi + rsi], 122\n    jle     _false\n    jmp     _check_loop\n\n_false:\n    mov     rax, 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212902,"user_id":null,"body":"global is_uppercase\n\nsection .text\n\nis_uppercase:\n    mov     rax, 1\n\n.loop:\n    mov     cl, [rdi]\n    test    cl, cl\n    jz      .exit\n\n    sub     cl, 'a'\n    sub     cl, 25\n    jc      .return_false\n    \n    inc     rdi\n    jmp     .loop\n\n.return_false:\n    xor     rax, rax\n\n.exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212903,"user_id":null,"body":"SECTION .text\nglobal is_uppercase\n\n; rdi <- string\nis_uppercase:\n  xor rax, rax\n  xor rbx, rbx\n  mov eax, 1\n  mov rcx, 0\n\n.loop:\n  mov bl, byte [rdi+rcx]\n  cmp bl, 0\n  je .end\n\n  cmp bl, 65\n  jl .incloop\n  cmp bl, 90\n  jg .testalpha\n  jmp .incloop\n\n.testalpha:\n  cmp bl, 97\n  jl .incloop\n  cmp bl, 122\n  jle .notupper\n  jmp .incloop\n\n.notupper:\n  mov eax, 0\n  jl .end\n\n.incloop:\n  inc rcx\n  jmp .loop\n\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212904,"user_id":null,"body":"SECTION .text\n  global is_uppercase\n\nis_uppercase:\n  mov rax,1\n  mov rcx,-1\n  \n  loop1:\n  inc rcx\n  cmp byte[rdi+rcx],0\n  je end\n  \n  cmp byte[rdi+rcx],'a'\n  jl loop1\n  \n  cmp byte[rdi+rcx],'z'\n  jg loop1\n  \n  mov rax,0\n  jmp loop1\n  \n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212905,"user_id":null,"body":"SECTION .text\nglobal is_uppercase\n\nis_uppercase:\n    xor rax, rax\n.my_loop:\n    cmp byte [rdi], 0\n    je .true\n    cmp byte [rdi], 96\n    jg .check\n    inc rdi\n    jmp .my_loop\n.true:\n    inc rax\n    ret    \n.false:\n    ret\n\n.check:\n    cmp byte [rdi], 123\n    jl .false\n    inc rdi \n    jmp .my_loop","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212906,"user_id":null,"body":"SECTION .text\nglobal is_uppercase\n\nis_uppercase:\n  mov rax, 1\n.loop:\n  mov cl, [rdi]\n  test cl, cl\n  je .done\n  add cl, -97\n  inc rdi\n  cmp cl, 25\n  ja .loop\n  xor eax, eax\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212907,"user_id":null,"body":"SECTION .text\nglobal is_uppercase\n\nis_uppercase:\n  xor rax, rax\n  xor rsi, rsi\n  \ncheck_loop:\n  cmp byte [rdi+rsi], 32\n  je ok\n  \n  cmp byte [rdi+rsi], 97\n  jb ok\n  cmp byte [rdi+rsi], 122\n  ja ok\n  jmp end\n  \nok:\n  inc rsi\n  cmp byte [rdi+rsi], 0\n  jnz check_loop\n\ntrueEnd:\n  mov rax, 1\n  ret\n\nend:\n  mov rax, 0\n  ret\n  \n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212908,"user_id":881,"body":"SECTION .text\nglobal is_uppercase\n\n\nis_uppercase:\n    mov rax, 1\n.for_each_char:\n    mov dl, [rdi]\n    inc rdi\n    test dl, dl\n    jz .true\n    cmp dl, 'a'\n    jb .for_each_char\n    cmp dl, 'z'\n    ja .for_each_char\n.false:\n    xor rax, rax\n.true:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212909,"user_id":null,"body":"SECTION .text\nglobal is_uppercase\n\nis_uppercase:\n  xor rax, rax\n  mov rbx,0\n  mov rcx,1\nlp:\n  mov rax, [rdi+rbx]\n  cmp al,0\n  je ende\n  inc rbx\n  cmp al, 0x20\n  je lp\n  cmp al, 0x61\n  jl lp\n  cmp al, 0x7a\n  jg lp\n  mov rcx,0\nende:\n  mov rax,rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212910,"user_id":null,"body":"SECTION .text\nglobal is_uppercase\n\nis_uppercase:\n  mov   rax, 1\n  xor   rcx,rcx\n  .loop:\n  cmp   [rdi], byte 'a'\n  jge    .end\n  .sec:\n  inc   rdi\n  cmp   [rdi], byte 0\n  jne   .loop\n  ret\n  .end:\n  cmp   [rdi], byte 'z'\n  jg    .sec\n  xor   rax,rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56d8f14cba01a83cdb0002a2":[{"id":212911,"user_id":50,"body":"; EDI will contain step number\n; RSI will be a pointer to an array of 3*32 bit\n\nglobal get_positions\nsegment .text\nget_positions:\n  xor rax,rax\n  mov rax,rdi\n  mov ebx,3\n  xor rdx,rdx\n  div ebx\n  mov [rsi],edx\n  xor rdx,rdx\n  div ebx\n  mov [rsi+4],edx\n  xor rdx,rdx\n  div ebx\n  mov [rsi+8],edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212912,"user_id":527,"body":"global get_positions\nsegment .text\nget_positions:\n                imul    rax, rdi, 1272582903\n                shr     rax, 35\n                imul    eax, -54\n                lea     edi, [rdi * 2 + rax]\n                mov     rax, 0x24924924924924\n                mov     rcx, 0x2a540a9502a540\n                mov     rdx, 0x2aaaa555540000\n                shrx    rax, rax, rdi\n                shrx    rcx, rcx, rdi\n                shrx    rdx, rdx, rdi\n                and     eax, 3\n                and     ecx, 3\n                and     edx, 3\n                mov     [rsi], eax\n                mov     [rsi + 4], ecx\n                mov     [rsi + 8], edx\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212913,"user_id":168,"body":"global get_positions\nsegment .text\nget_positions:\n  xor edx, edx\n  mov eax, edi\n  mov ecx, 3\n  div ecx\n  mov dword [rsi], edx\n  xor edx, edx\n  div ecx\n  mov dword [rsi + 4], edx\n  xor edx, edx\n  div ecx\n  mov dword [rsi + 8], edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212914,"user_id":77,"body":"; EDI will contain step number\n; ESI will be a pointer to an array of 3*32 bit\n\nglobal get_positions\nsegment .text\nget_positions:\n    mov eax, edi\n    lea rdi, [rsi+12]\n    mov ecx, 3\n.loop:\n    xor edx, edx\n    div ecx\n    mov [rsi], edx\n    add rsi, 4\n    cmp rsi, rdi\n    jb .loop\n    lea rax, [rsi-12]\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212915,"user_id":null,"body":"; EDI will contain step number\n; RSI will be a pointer to an array of 3*32 bit\n\nglobal get_positions\nsegment .text\nget_positions:\n  mov ecx, 3\n  mov eax, edi\n  xor edx, edx\n  div ecx\n  mov r8d, eax\n  mov eax, edi\n  cdq\n  idiv ecx\n  mov eax, r8d\n  mov [rsi], edx\n  xor edx, edx\n  div ecx\n  mov [rsi+4], edx\n  xor edx, edx\n  div ecx\n  mov [rsi+8], edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212916,"user_id":null,"body":"; EDI will contain step number\n; RSI will be a pointer to an array of 3*32 bit\n\nglobal get_positions\nsegment .text\nget_positions:\n  mov eax, edi\n  mov ecx, 3\n  xor edx, edx\n  div ecx\n  mov [rsi], edx\n  xor edx, edx\n  div ecx\n  mov [rsi+4], edx\n  xor edx, edx\n  div ecx\n  mov [rsi+8], edx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212917,"user_id":53,"body":"; EDI will contain step number\n; RSI will be a pointer to an array of 3*32 bit\n\nglobal get_positions\nsegment .text\nget_positions:\n\n      mov eax,edi\n      xor edx,edx\n      mov r8,9                    \n      mov ecx,3\n      div ecx\n      mov dword [rsi],edx\n      jnz a\n\na:\n      mov eax,edi\n      xor edx,edx\n      div ecx\n      xor edx,edx\n      div ecx\n      mov dword [rsi + 4],edx\n      jnz b\n      \nb:\n      mov eax,edi\n      xor edx,edx\n      div r8\n      xor edx,edx\n      div ecx\n      mov dword [rsi + 8],edx\n      ret\n      ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212918,"user_id":null,"body":"; EDI will contain step number\n; ESI will be a pointer to an array of 3*32 bit\n\nglobal get_positions\nsegment .text\nget_positions:\n                      ; <--- your code goes here\n                      mov ecx, 3\n                      mov rax, rdi\n                      xor rdi, rdi\n                    sexyboy:\n                      xor edx, edx\n                      div ecx\n                      mov [rsi+4*rdi], edx\n                      inc rdi\n                      cmp rdi, 3\n                      jne sexyboy\n                      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212919,"user_id":null,"body":"global get_positions\nget_positions:\n  mov    rax,rdi\n  mov    rcx,27\n  cqo\n  div    rcx\n  shl    rdx,2\n  movups xmm0,[.troic+rdx*2+rdx]\n  movups [rsi],xmm0\nret\nalign 16\n.troic dd 0,0,0,\\\n          1,0,0,\\\n          2,0,0,\\\n          0,1,0,\\\n          1,1,0,\\\n          2,1,0,\\\n          0,2,0,\\\n          1,2,0,\\\n          2,2,0,\\\n          0,0,1,\\\n          1,0,1,\\\n          2,0,1,\\\n          0,1,1,\\\n          1,1,1,\\\n          2,1,1,\\\n          0,2,1,\\\n          1,2,1,\\\n          2,2,1,\\\n          0,0,2,\\\n          1,0,2,\\\n          2,0,2,\\\n          0,1,2,\\\n          1,1,2,\\\n          2,1,2,\\\n          0,2,2,\\\n          1,2,2,\\\n          2,2,2\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212920,"user_id":527,"body":"global get_positions\nsegment .text\nget_positions:\n                imul    rax, rdi, 1431655766\n                imul    rcx, rdi, 1908874354\n                shr     rax, 32\n                lea     edx, [rax * 3]\n                sub     edi, edx\n                mov     [rsi], edi\n                imul    rdx, rax, 1431655766\n                shr     rdx, 32\n                lea     edx, [rdx * 3]\n                sub     eax, edx\n                mov     [rsi + 4], eax\n                shr     rcx, 34\n                imul    rdx, rcx, 1431655766\n                shr     rdx, 32\n                lea     edx, [rdx * 3]\n                sub     ecx, edx\n                mov     [rsi + 8], ecx\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56d904db9963e9cf5000037d":[{"id":212921,"user_id":527,"body":"global testit\nsection .text\ntestit:\n        mov     rax, rdi\n        or      rax, rsi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212922,"user_id":null,"body":"global testit\nsection .text\ntestit:\n        or rdi, rsi\n        mov rax, rdi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212923,"user_id":null,"body":"global testit\nsection .text\ntestit:\n        mov rax, rsi\n        or rax, rdi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212924,"user_id":null,"body":"global testit\n\ntestit:  dq -1.8488560187033059328E19","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212925,"user_id":1343,"body":"global testit\nsection .text\ntestit:\n        ; Quick reminder: `a` in rdi, `b` in rsi, `result` in rax\n        ; a + b ?\n        ; a * b ?\n        ; a ? b\n        OR RSI, RDI\n        MOV RAX, RSI\n        \n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212926,"user_id":609,"body":"global testit\nsection .text\ntestit:\n        ; Quick reminder: `a` in rdi, `b` in rsi, `result` in rax\n        ; a + b ?\n        ; a * b ?\n        ; a ? b\n        or rdi, rsi\n        mov rax, rdi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212927,"user_id":527,"body":"global testit\nsection .text\ntestit:\n        mov     rax, rdi\n        or      rax, rsi\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56d931ecc443d475d5000003":[{"id":212928,"user_id":null,"body":"global testit\ntestit:\n  popcnt rax,rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212929,"user_id":168,"body":"global testit\n\ntestit:\n  popcnt eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212930,"user_id":104,"body":"; 2021 nomennescio\nglobal testit\n\ntestit:\n  popcnt rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212931,"user_id":null,"body":"global testit\n\ntestit:\n  popcnt rax, rdi ; count of bits with value 1 in the parameter number\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212932,"user_id":527,"body":"global testit\nsection .text\ntestit:\n                popcnt  eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212933,"user_id":645,"body":"global testit\n\nextern _GLOBAL_OFFSET_TABLE_ \nextern __popcountdi2\n\ntestit:\n  sub rsp, 8\n  mov edi, edi\n  call __popcountdi2\n  add rsp, 8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56dec885c54a926dcd001095":[{"id":212934,"user_id":null,"body":"global opposite\n\nsection .text\n\n; <----- int opposite(int num) ----->\nopposite:\n  mov eax, edi      ; copying <num> to EAX\n  neg eax           ; negating the result\n  ret\n; ---------> end of opposite <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212935,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  imul rax, rdi,-1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212936,"user_id":1277,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  mov eax, edi\n  neg eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212937,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  xor eax, eax\n  sub eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212938,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  mov eax, -1\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212939,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  mov eax, edi\n  not eax\n  add eax,0x1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212940,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  mov eax, edi\n  xor eax, 0x8FFFFFFFFF\n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212941,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  imul eax, edi, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212942,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  xor rax, rax\n  mov rax, -1\n  imul rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212943,"user_id":null,"body":"SECTION .text\nglobal opposite\n\nopposite:\n  mov eax, edi\n  mov ecx, -1\n  imul ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56e56756404bb1c950000992":[{"id":212944,"user_id":null,"body":"global sum_differences_between_products_and_LCMs\nsum_differences_between_products_and_LCMs:\n  xor r8,r8\n  .loop:mov   ecx,[rdi+rsi*8-4]\n        mov   edx,[rdi+rsi*8-8]\n        mov   eax,ecx\n        imul  rax,rdx\n        add   r8,rax\n        jmp  .s\n        .gcd:ja .f\n               xchg edx,ecx\n             .f:\n             sub edx,ecx\n          .s:cmp edx,ecx\n         jne .gcd  \n         jrcxz .zero\n           cqo\n           div  rcx\n         .zero:  \n         sub  r8,rax  \n         dec  rsi         \n  jne .loop     \n  mov rax,r8\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212945,"user_id":null,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n; input: rdi = pairs, rsi = count\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsum_differences_between_products_and_LCMs:\n  xor r8d, r8d\n  test rsi, rsi\n  je .done\n  xor r11d, r11d\n.loop:\n  movsxd r9, dword [rdi + 8*r11]\n  test r9, r9\n  je .zero\n  movsxd r10, dword [rdi + 8*r11 + 4]\n  test r10, r10\n  je .zero\n  mov rdx, r9\n  mov rcx, r10\n.eucloop:\n  mov rax, rcx\n  mov rcx, rdx\n  xor edx, edx\n  div rcx\n  test rdx, rdx\n  jne .eucloop\n  mov rax, r9\n  xor edx, edx\n  div rcx\n  sub r9, rax\n  imul r9, r10\n  add r8, r9\n.zero:\n  inc r11\n  cmp r11, rsi\n  jne .loop\n.done:\n  mov rax, r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212946,"user_id":null,"body":"section .text\nglobal sum_differences_between_products_and_LCMs\nsum_differences_between_products_and_LCMs:\n            xor  r11,r11   \n            xor  r9,r9 ; Seems r8 and r8 come zeroed, but nonetheless the high 32 bit needs to be 0\n            xor  r8,r8 ; due to the mul and div ops\n@main_loop: dec  rsi\n            js   @done\n            mov  r8d,[rdi + rsi * 8]\n            mov  r9d,[rdi + rsi * 8 + 4]\n            mov  r10d,r8d\n            imul r10,r9\n@lcm_loop:  test r9d,r9d\n            jz   @lcm_done\n            mov  rax,r8\n            xor  edx,edx\n            div  r9d\n            mov  r8d,r9d\n            mov  r9d,edx\n            jmp  @lcm_loop\n@lcm_done:  xor  rax,rax\n            test r8d,r8d\n            jz   @no_cm\n            mov  rax,r10\n            div  r8\n@no_cm:     sub  r10,rax    ; product of the pair in r10 - LCM in rax - subtract LCM from the product\n            add  r11,r10    ; Add the difference to r11\n            jmp  @main_loop\n@done:      mov  rax,r11\n            ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212947,"user_id":null,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n\n\n; input: eax, edx\n; output: esi\ngcd:\n  test edx, edx\n  je .gcdret\n  mov r8d, edx\n  cdq\n  div r8d\n  mov eax, r8d\n  jmp gcd\n.gcdret:\n  mov esi, eax\n  ret\n  \n; input: rdi = pairs, rsi = count\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\n\nsum_differences_between_products_and_LCMs:\n\n  mov rcx, rsi\n  xor rax, rax\n  xor r11, r11\n.loop:\n\n  mov r8d, [rdi]\n  mov r9d, [rdi+4]\n \n  \n  mov eax, r8d\n  mul r9\n  mov r10, rax\n  \n  mov eax, r8d\n  mov edx, r9d\n  push r8\n  call gcd\n  pop r8\n  \n  test r10d, r10d\n  je .skip\n  mov rax, r10\n  cqo\n  div rsi\n  sub r10, rax\n  \n.skip:\n  add r11, r10\n  add rdi, 8\n  \n  loop .loop\n  \n  mov rax, r11\n  ret\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212948,"user_id":17,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n; input: rdi = pairs, rsi = count\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsum_differences_between_products_and_LCMs:\n  xor rax, rax\n.loop:\n  cmp rsi, 0\n  jle .end\n  cmp dword [rdi], 0\n  je .update_loop\n  cmp dword [rdi + 4], 0\n  je .update_loop\n  xor r8, r8\n  xor r9, r9\n  mov r8d, dword [rdi]\n  mov r9d, dword [rdi + 4]\n  mov rdx, r8\n  imul rdx, r9\n  add rax, rdx\n  push rax\n  push rdi\n  push rsi\n  mov rdi, r8\n  mov rsi, r9\n  call lcm\n  pop rsi\n  pop rdi\n  pop rdx\n  sub rdx, rax\n  mov rax, rdx\n.update_loop:\n  dec rsi\n  add rdi, 8\n  jmp .loop\n.end:\n  ret\n\ngcd:\n  cmp rsi, 0\n  je .trivial_case\n  mov rdx, rdi\n  mov rdi, rsi\n  mov rsi, rdx\n  xor rdx, rdx\n  mov rax, rsi\n  idiv rdi\n  mov rsi, rdx\n  call gcd\n  ret\n.trivial_case:\n  mov rax, rdi\n  ret\n\nlcm:\n  mov rax, rdi\n  imul rax, rsi\n  push rax\n  call gcd\n  xor rdx, rdx\n  mov rcx, rax\n  pop rax\n  idiv rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212949,"user_id":1315,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n; input: rdi = pairs, rsi = count\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsum_differences_between_products_and_LCMs:\n  mov  r8,  rdi            ; r8  = pairs\n  mov  r9,  rsi            ; r9  = count\n  xor  r10, r10            ; r10 = sum = 0\n  xor  rcx, rcx            ; rcx = i   = 0\nnext_pair:\n  test r9,  r9             ; while ( count != 0 )\n  jz   end_loop\n  mov  edi, [r8+4*(rcx)]   ; a = pairs[i]\n  test edi, edi            ; if a != 0\n  jz   continue_loop\n  mov  esi, [r8+4*(rcx+1)] ; b = pairs[i+1]\n  test esi, esi            ; if b != 0\n  jz   continue_loop\n  call lcm                 ; rax = lcm(a,b)\n  imul rdi, rsi            ; rdi = a * b\n  sub  rdi, rax            ; rdi = (a * b) - lcm(a,b)\n  add  r10, rdi            ; r10 = sum + (a * b) - lcm(a,b)\ncontinue_loop:\n  add  rcx, 2              ; i += 2\n  dec  r9                  ; count--\n  jmp  next_pair\nend_loop:  \n  mov  rax, r10            ; return sum\n  ret\n\n; Least Common Multiple\n; lcm(a,b) = (a * b) \/ gcd(a,b)\n; input: rdi = a, rsi = b\n; output: rax\n; uses: rax, rdx\nlcm:\n  call gcd\n  mov  rbx, rax            ; rbx = gcd(a,b)\n  mov  rax, rdi            ; rax = a\n  imul rax, rsi            ; rax = a * b\n  xor  rdx, rdx\n  div  rbx                 ; rax = (a * b) \/ gcd(a,b)\n  ret\n\n; Greatest Common Divisor\n; function gcd(a, b)\n;     while b \u2260 0\n;        t := b; \n;        b := a mod b; \n;        a := t; \n;     return a;\n; input: rdi = a, rsi = b\n; output: rax\n; uses: rax, rbx, rdx\ngcd:\n  mov  rax, rdi            ; rax = a\n  mov  rbx, rsi            ; rax = b\ngcd_loop:\n  test rbx, rbx            ; while b \u2260 0\n  jz   gcd_end\n  xor  rdx, rdx\n  div  rbx                 ; divide a by b\n  mov  rax, rbx            ; a := (t)\n  mov  rbx, rdx            ; b := a mod b\n  jmp  gcd_loop\ngcd_end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212950,"user_id":527,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n; input: rdi = pairs, rsi = count\n; output: rax\nsum_differences_between_products_and_LCMs:\n                xor     r9, r9\n                test    rsi, rsi\n                jz      .done\n.loop:          mov     ecx, [rdi]\n                mov     edx, [rdi + 4]\n                mov     r8, rcx\n                imul    r8, rdx\n                mov     eax, ecx\n                or      eax, edx\n                jz      .skip_00\n.gcd_loop:      mov     eax, ecx\n                mov     ecx, edx\n                xor     edx, edx\n                div     ecx\n                test    edx, edx\n                jnz     .gcd_loop\n.gcd_done:      mov     rax, r8\n                xor     edx, edx\n                div     rcx\n                sub     r9, rax\n.skip_00:       add     r9, r8\n                add     rdi, 8\n                dec     rsi\n                jnz     .loop\n.done:          mov     rax, r9\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212951,"user_id":null,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n; input: rdi = pairs, rsi = count\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsum_differences_between_products_and_LCMs:\n  xor r10, r10\nloop:  \n  mov rbx, [rdi]\n  mov eax, ebx\n  shr rbx, 32\n  cmp rax, 0\n  je continue\n  cmp rbx, 0\n  je continue\n  mov r8, rax\n  mov r9, rbx\nbegin_nod:  \n  cmp rax, 0\n  je end_nod\n  cmp rbx, 0\n  je end_nod\n  xor rdx, rdx\n  cmp rax, rbx\n  jl b\n  div rbx\n  mov rax, rdx\n  jmp begin_nod\nb:mov rcx, rax\n  mov rax, rbx\n  div rcx\n  mov rbx, rdx\n  mov rax, rcx\n  jmp begin_nod\nend_nod:\n  or rax, rbx\n  mov rcx, rax\n  mov rax, r8\n  mul r9\n  mov r8, rax\n  div rcx\n  sub r8, rax\n  add r10, r8\ncontinue:  \n  add rdi, 8\n  dec rsi\n  cmp rsi, 0\n  jg loop\n  mov rax, r10\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212952,"user_id":168,"body":"global sum_differences_between_products_and_LCMs\nsection .text\n; input: rdi = pairs, rsi = count\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsum_differences_between_products_and_LCMs:\n  push rbx\n  xor r8d, r8d\n.loop:\n  test rsi, rsi\n  jz .end\n  dec rsi\n  mov ecx, [rdi + rsi * 8]\n  mov ebx, [rdi + rsi * 8 + 4]\n  mov eax, ecx\n  mul rbx\n  xchg rax, rcx  ; rcx = a * b\n  ; compute gcd(a, b) -> eax\n  ; a = eax\n  ; b = ebx\n.gcd:\n  test ebx, ebx\n  jz .gcd_end\n  xor edx, edx\n  div ebx\n  mov eax, ebx\n  mov ebx, edx\n  jmp .gcd\n.gcd_end:\n  test eax, eax\n  jz .loop\n  xchg rax, rcx\n  add r8, rax\n  xor edx, edx\n  div rcx\n  sub r8, rax\n  jmp .loop\n.end:\n  mov rax, r8\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56efc695740d30f963000557":[{"id":212953,"user_id":null,"body":"SECTION .text\nglobal to_alternating_case\nextern malloc\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  xor rax, rax\n  xor rcx, rcx\n  mov rax, rdi\n  mov rsi, rdi\n  .len_check_loop:\n    cmp byte [rsi+rcx], 0\n    je .alloc_new_str\n    inc rcx\n    jmp .len_check_loop\n\n  .alloc_new_str:\n    inc rcx\n    mov rdi, rcx\n    push rsi\n    call malloc\n    pop rsi\n    push rax\n    mov rdi, rax\n  \n  .next_char:\n    lodsb\n    test al, al\n    jz .end\n    cmp al, 64\n    jg .check_if_upper\n    jmp .append\n    \n  .check_if_upper:\n    cmp al, 90\n    jg .check_if_lower\n    add al, 32\n    jmp .append\n    \n  .check_if_lower:\n    cmp al, 97\n    jl .append\n    cmp al, 122\n    jg .append\n    sub al, 32\n    jmp .append\n    \n  .append:\n    stosb\n    jmp .next_char\n  \n  .end:\n    stosb\n    pop rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212954,"user_id":168,"body":"SECTION .text\nextern strlen, malloc\nglobal to_alternating_case\ntable db 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n      db 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31\n      db ' !\"#$%&', 44, '()*+,-.\/0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~', 127\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; The returned string is not free'd, and as such can be allocated on either the stack or the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  lea rdi, [rax + 1]\n  call malloc\n  mov rdx, rax\n  mov rsi, rbx\n  lea rbx, [rel table]\n  mov rdi, rax\n.loop:\n  lodsb\n  xlatb\n  stosb\n  test al, al\n  jnz .loop\n  mov rax, rdx\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212955,"user_id":null,"body":"SECTION .text\nglobal to_alternating_case\nextern malloc, strlen\n\nto_alternating_case:\n  push rdi\n  call strlen\n  mov rdi, rax\n  inc rdi\n  call malloc\n  mov rdi, rax\n  pop rsi\n  xor rcx, rcx\n.loop:\n  mov dl, [rsi+rcx]\n  test dl, dl\n  jz .exit\n  mov [rdi+rcx], dl\n  cmp dl, 'A'\n  jb .skip\n  cmp dl, 'Z'\n  jbe .change\n  cmp dl, 'z'\n  ja .skip\n  cmp dl, 'a'\n  jb .skip\n.change:\n  xor byte [rdi+rcx], 32\n.skip:\n  inc rcx\n  jmp .loop\n.exit:\n  mov byte [rdi+rcx], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212956,"user_id":null,"body":"extern malloc\nSECTION .text\nglobal to_alternating_case\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  xor ebx, ebx\n.findend:\n  cmp byte [r14 + rbx], 0\n  lea rbx, [rbx + 1]\n  jne .findend\n  mov rdi, rbx\n  call malloc\n  xor ecx, ecx\n  lea rdi, [.trans]\n.loop:\n  cmp rbx, rcx\n  je .done\n  movsx rsi, byte [r14 + rcx]\n  mov dl, [rsi + rdi]\n  mov byte [rax + rcx], dl\n  inc rcx\n  jmp .loop\n.done:\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret\n.trans: db 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 924, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 215, 248, 249, 250, 251, 252, 253, 254, 83, 83, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 247, 216, 217, 218, 219, 220, 221, 222, 223","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212957,"user_id":null,"body":"SECTION .text\nglobal to_alternating_case\nextern strdup\nextern puts\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  push rdi\n  call strdup\n  mov rbx, rax\n  start:\n  cmp [rbx], byte 0\n  jz end\n  cmp [rbx], byte 90\n  jle upper\n  cmp [rbx], byte 122\n  jle lower\n  inc rbx\n  jmp start\n  lower:\n  cmp [rbx], byte 96\n  jle next\n  sub [rbx],  byte 32\n  inc rbx\n  jmp start\n  upper:\n  cmp [rbx], byte 64\n  jle next\n  add [rbx], byte 32\n  next:\n  inc rbx\n  jmp start\n  end:\n  pop rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212958,"user_id":null,"body":"extern malloc\n\nSECTION .text\nglobal to_alternating_case\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  push rdi\n  mov rdi, 350\n  shl rdi, 3\n  call malloc\n  pop rdi\n  \n  mov cl, 0100000b\n  \n  xor r8, r8\n  \n.for:\n  mov dl, [rdi + r8]\n\n  cmp dl, 'A'\n  jb .continue\n  cmp dl, 'z'\n  ja .continue\n  cmp dl, 'Z'\n  jbe .change\n  cmp dl, 'a'\n  jb .continue\n  \n.change:\n  xor dl, cl\n  \n.continue:\n  mov [rax + r8], dl\n  inc r8\n  cmp dl, 0\n  jnz .for \n \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212959,"user_id":null,"body":"extern malloc\nextern strlen\nextern strcpy\n\nSECTION .text\nglobal to_alternating_case\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  xor rax, rax\n  \n  test rdi, rdi     ; \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0442\u043e \u0432\u044b\u0445\u043e\u0434\u0438\u043c\n  jz exit\n  \n  push rdi          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435\n  call strlen       ; \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443\n  push rax          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435\n  mov rcx, rax      ; \u0433\u043e\u0442\u043e\u0432\u0438\u043c \u0440\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0440\u043e\u043a\u0438 \u0434\u043b\u044f \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043f\u0430\u043c\u044f\u0442\u0438 \u0434\u043b\u044f \u0431\u0443\u0434\u0443\u044e\u0449\u0435\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n  inc rcx           ; \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u043d\u0430 \u043e\u0434\u0438\u043d \u0434\u043b\u044f '\\0'\n  mov rdi, rcx\n  call malloc       ; \u0432\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c\n  \n  test rax, rax     ; \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0430 \u043b\u0438 \u043f\u0430\u043c\u044f\u0442\u044c\n  jz exit\n  \n  mov rdi, rax      ; \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u0443\u044e \u043f\u0430\u043c\u044f\u0442\u044c\n  pop rcx           ; \u0434\u043e\u0441\u0442\u0430\u0435\u043c \u0434\u043b\u0438\u043d\u0443, \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u0442\u043e\u043c \u0434\u043e\u0441\u0442\u0430\u0442\u044c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438-\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\n  pop rsi           ; \u0430 \u0432\u043e\u0442 \u0438 \u043e\u043d\u0430\n  push rcx          ; \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u043f\u0440\u044f\u0447\u0435\u043c \u0434\u043b\u0438\u043d\u0443\n  call strcpy       ; \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443-\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n  mov rbx, rax      ; \u0431\u0435\u0440\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u043d\u0430 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n  pop rcx           ; \u0431\u0435\u0440\u0435\u043c \u0434\u043b\u0438\u043d\u0443, \u043e\u043d\u0430 \u043d\u0443\u0436\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0434\u043b\u044f \u0441\u0447\u0435\u0442\u0447\u0438\u043a\u0430\ncycle:\n  xor rdx, rdx              \n  mov dl, byte [rbx + rcx - 1]  ; \u0431\u0435\u0440\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b (\u0441 \u043a\u043e\u043d\u0446\u0430)\nis_upper: \n  cmp dl, 'A'                   ; \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430 uppercase\n  jl is_lower\n  cmp dl, 'Z'\n  jg is_lower                   \n  ; \u0435\u0441\u043b\u0438 uppercase, \u0442\u043e \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u043a lowercase \n  sub dl, 'A'                   ; \u043e\u0442\u043d\u0438\u043c\u0430\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0435, \u0438 \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u0443\u0437\u043d\u0430\u0435\u043c \u043a\u0430\u043a\u0438\u043c \u043f\u043e \u0441\u0447\u0435\u0442\u0443 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043d\u0430\u0448 \u0441\u0438\u043c\u0432\u043e\u043b\n  add dl, 'a'                   ; \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u0432 lowercase-\u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0435, \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u043f\u043e\u043b\u0443\u0447\u0438\u043c \u043d\u043e\u043c\u0435\u0440 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u043d\u0435\u043c\n  mov byte [rbx + rcx - 1], dl  ; \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u043c \u043d\u0430 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n  jmp next_char                 ; \u0441\u043b\u0435\u0434. \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u044f\nis_lower:                       ; \u0442\u0443\u0442 \u0432\u0441\u0435 \u0430\u043d\u0430\u043b\u0430\u0433\u0438\u0447\u043d\u043e \u0441 uppercase\n  cmp dl, 'a'\n  jl next_char\n  cmp dl, 'z'\n  jg next_char\n  sub dl, 'a'\n  add dl, 'A'\n  mov byte [rbx + rcx - 1], dl\nnext_char:                      \n  loop cycle                    ; \u043e\u0442\u043d\u0438\u043c\u0430\u0435\u043c \u043e\u0442 rcx \u0435\u0434\u0438\u043d\u0438\u0446\u0443, \u0438 \u0437\u0430\u0445\u043e\u0434\u0438\u043c \u043d\u0430 \u0441\u043b\u0435\u0434. \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u044e\n  mov rax, rbx                  ; \u043a\u043b\u0430\u0434\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0430\u0434\u0440\u0435\u0441 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212960,"user_id":null,"body":"extern malloc\nextern strlen\nextern strcpy\n\nSECTION .text\nglobal to_alternating_case\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n  xor rax, rax\n  push rdi          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435\n  call strlen       ; \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443\n  push rax          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435\n  mov rcx, rax      ; \u0433\u043e\u0442\u043e\u0432\u0438\u043c \u0440\u0430\u0437\u043c\u0435\u0440 \u0441\u0442\u0440\u043e\u043a\u0438 \u0434\u043b\u044f \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043f\u0430\u043c\u044f\u0442\u0438 \u0434\u043b\u044f \u0431\u0443\u0434\u0443\u044e\u0449\u0435\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n  inc rcx           ; \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u043d\u0430 \u043e\u0434\u0438\u043d \u0434\u043b\u044f '\\0'\n  mov rdi, rcx\n  call malloc       ; \u0432\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c\n  mov rdi, rax      ; \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u0443\u044e \u043f\u0430\u043c\u044f\u0442\u044c\n  pop rcx           ; \u0434\u043e\u0441\u0442\u0430\u0435\u043c \u0434\u043b\u0438\u043d\u0443, \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u0442\u043e\u043c \u0434\u043e\u0441\u0442\u0430\u0442\u044c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438-\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\n  pop rsi           ; \u0430 \u0432\u043e\u0442 \u0438 \u043e\u043d\u0430\n  push rcx          ; \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u043f\u0440\u044f\u0447\u0435\u043c \u0434\u043b\u0438\u043d\u0443\n  call strcpy       ; \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443-\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n  mov rbx, rax      ; \u0431\u0435\u0440\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u043d\u0430 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n  pop rcx           ; \u0431\u0435\u0440\u0435\u043c \u0434\u043b\u0438\u043d\u0443, \u043e\u043d\u0430 \u043d\u0443\u0436\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0434\u043b\u044f \u0441\u0447\u0435\u0442\u0447\u0438\u043a\u0430\ncycle:\n  xor rdx, rdx              \n  mov dl, byte [rbx + rcx - 1]  ; \u0431\u0435\u0440\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b (\u0441 \u043a\u043e\u043d\u0446\u0430)\nis_upper: \n  cmp dl, 'A'                   ; \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430 uppercase\n  jl is_lower\n  cmp dl, 'Z'\n  jg is_lower                   \n  ; \u0435\u0441\u043b\u0438 uppercase, \u0442\u043e \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u043a lowercase \n  sub dl, 'A'                   ; \u043e\u0442\u043d\u0438\u043c\u0430\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0435, \u0438 \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u0443\u0437\u043d\u0430\u0435\u043c \u043a\u0430\u043a\u0438\u043c \u043f\u043e \u0441\u0447\u0435\u0442\u0443 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043d\u0430\u0448 \u0441\u0438\u043c\u0432\u043e\u043b\n  add dl, 'a'                   ; \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u0432 lowercase-\u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0435, \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u043f\u043e\u043b\u0443\u0447\u0438\u043c \u043d\u043e\u043c\u0435\u0440 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u043d\u0435\u043c\n  mov byte [rbx + rcx - 1], dl  ; \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u043c \u043d\u0430 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n  jmp next_char                 ; \u0441\u043b\u0435\u0434. \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u044f\nis_lower:                       ; \u0442\u0443\u0442 \u0432\u0441\u0435 \u0430\u043d\u0430\u043b\u0430\u0433\u0438\u0447\u043d\u043e \u0441 uppercase\n  cmp dl, 'a'\n  jl next_char\n  cmp dl, 'z'\n  jg next_char\n  sub dl, 'a'\n  add dl, 'A'\n  mov byte [rbx + rcx - 1], dl\nnext_char:                      \n  loop cycle                    ; \u043e\u0442\u043d\u0438\u043c\u0430\u0435\u043c \u043e\u0442 rcx \u0435\u0434\u0438\u043d\u0438\u0446\u0443, \u0438 \u0437\u0430\u0445\u043e\u0434\u0438\u043c \u043d\u0430 \u0441\u043b\u0435\u0434. \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u044e\n  mov rax, rbx                  ; \u043a\u043b\u0430\u0434\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0430\u0434\u0440\u0435\u0441 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212961,"user_id":null,"body":"extern malloc\nextern strlen\nextern strcpy\n\nSECTION .text\nglobal to_alternating_case\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n\n  xor rax, rax\n  push rdi          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435\n  call strlen       ; \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443\n  push rax          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435\n  mov rcx, rax      \n  inc rcx\n  mov rdi, rcx\n  call malloc\n  mov rdi, rax      ; \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u043f\u0430\u043c\u044f\u0442\u044c\n  \n  pop rcx           ; \u0434\u043b\u0438\u043d\u0430\n  pop rsi           ; \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0441\u0442.\n\n  push rcx          ;\u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0434\u043b\u0438\u043d\u0443\n\n  call strcpy\n  \n  mov rbx, rax      ; \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430, \u0442\u0435\u043f\u0435\u0440\u044c rdx \u043d\u0435 \u043d\u0443\u0436\u0435\u043d\n  pop rcx\ncycle:\n\n  xor rdx, rdx              \n  mov dl, byte [rbx + rcx - 1]  ; \u0431\u0435\u0440\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b (\u0441 \u043a\u043e\u043d\u0446\u0430)\nis_upper: \n  cmp dl, 'A'               ; \u0435\u0441\u043b\u0438 upper\n  jl is_lower\n  cmp dl, 'Z'\n  jg is_lower\n  \n  sub dl, 'A'\n  add dl, 'a'\n  mov byte [rbx + rcx - 1], dl\n  \n  jmp next_char\nis_lower:\n  cmp dl, 'a'\n  jl next_char\n  cmp dl, 'z'\n  jg next_char\n  \n  sub dl, 'a'\n  add dl, 'A'\n  mov byte [rbx + rcx - 1], dl\nnext_char:\n  loop cycle\n\n  mov rax, rbx\n\n  ;pop rsp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212962,"user_id":null,"body":"extern malloc\nextern strlen\nextern strcpy\n\nSECTION .text\nglobal to_alternating_case\n\n; Returns a new string in which every uppercase character in the original string is lowercase, and vice versa.\n; Please return a pointer to a string allocated on the heap.\n; arg0         = (const char *) The original string.\n; return value = (char *)       The new string.\nto_alternating_case:\n\n  xor rax, rax\n  push rdi          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0441\u0442\u0440\u043e\u043a\u0438\n  \n  call strlen\n  pop rdi\n  push rdi\n  push rax          ; \u043f\u0440\u044f\u0447\u0435\u043c \u0435\u0435 \u0434\u043b\u0438\u043d\u0443\n  \n;  push rcx\n;  push rax\n\n\n  mov rcx, rax\n  inc rcx\n  mov rdi, rcx\n  call malloc\n  mov rdi, rax      ; \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u043f\u0430\u043c\u044f\u0442\u044c\n  \n  pop rcx           ; \u0434\u043b\u0438\u043d\u0430\n  pop rsi           ; \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0441\u0442.\n  \n ; pop rsi           ; \u0434\u043b\u0438\u043d\u0430\n ; pop rdx           ; \u0430\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0441\u0442.\n\n  push rcx          ;\u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0434\u043b\u0438\u043d\u0443\n\n  call strcpy\n  \n  mov rbx, rax      ; \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430, \u0442\u0435\u043f\u0435\u0440\u044c rdx \u043d\u0435 \u043d\u0443\u0436\u0435\u043d\n  pop rcx\ncycle:\n\n  xor rdx, rdx              \n  mov dl, byte [rbx + rcx - 1]  ; \u0431\u0435\u0440\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b (\u0441 \u043a\u043e\u043d\u0446\u0430)\nis_upper: \n  cmp dl, 'A'               ; \u0435\u0441\u043b\u0438 upper\n  jl is_lower\n  cmp dl, 'Z'\n  jg is_lower\n  \n  sub dl, 'A'\n  add dl, 'a'\n  mov byte [rbx + rcx - 1], dl\n  \n  jmp next_char\nis_lower:\n  cmp dl, 'a'\n  jl next_char\n  cmp dl, 'z'\n  jg next_char\n  \n  sub dl, 'a'\n  add dl, 'A'\n  mov byte [rbx + rcx - 1], dl\nnext_char:\n  loop cycle\n\n  mov rax, rbx\n\n  ;pop rsp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56f695399400f5d9ef000af5":[{"id":212963,"user_id":null,"body":"global correct_tail\n\n; <-- EAX correct_tail(ro [byte RDI] anl, ro [byte RSI] tail) -->\ncorrect_tail:\n    xor eax, eax        ; resetting EAX as <corr>\n    mov dl, [rsi]       ; loading DL with <*tail> as <t>\n    dec rdi             ; pointing <anl> before the first character\n.loop:\n    inc rdi             ; pointing <anl> to the next character\n    cmp byte [rdi], 0   ; whether <*anl> is the null character\n    jne .loop           ; otherwise, jumping to the next iteration\n    cmp dl, [rdi-1]     ; whether <t> and the last character in <*anl> are equal\n    sete al             ; setting AL as true\n    ret\n; -----> endof correct_tail <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212964,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\n\n; int correct_tail(const char* pcAnimal, const char* pcTail);\ncorrect_tail:\n  ; RDI = char* (pointer to INPUT string)\n  ; RSI = char* (pointer to OUTPUT string)\n  \n  ; \"Fox0\"\n  ; for ( rdi=pcAnimal ; *rdi!=0 ; rdi++ ) {}  \n  @IsStringEnd:\n    ;byte=8 word=16 dword=32 qword=64    \n    cmp byte [rdi], 0 ; if (*((char*)rdi) == 0) {} \n    ; reg64 + reg64*N + offset; (N=1,2,4,8) (syntax for addressing) \n    lea rdi, [rdi+1] ; add rdi, 1 ; rdi += 1 ; advance RDI pointer to next char    \n  jne @IsStringEnd\n  ; rdi is ONE character after the \\0 (end of string)\n  ; so we need to subtract 2\n  ;sub rdi, 2\n  xor rax,rax\n  mov al, [rdi-2]\n  cmp [rsi], al   ; al = (al==*rsi) ? 1 : 0;\n  sete al\n  ret\n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212965,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\n; input:\n;    rdi - pointer to ASCII zero string\n;    rsi - pointer to last char to check\n; output:\n;    rax - true if and only if last char in string is the given char.\ncorrect_tail:\n  xor rax,rax        ; rax = 0 == false and also al == '\\0'\n  xor rcx,rcx\n  dec rcx            ; rcx = -1\n  cld\n  repne scasb        ; scan for end of string ''\\0'\n  dec rcx            ; rcx = len of string\n  jz .nok            ; string is empty\n  mov sil,[rsi]      ; sil = the correct tail char\n  cmp sil,[rdi-2]    ; compare last char\n  jne .nok\n  inc rax            ; rax = 1 == true\n.nok:  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212966,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\ncorrect_tail:\n  xor   rax, rax\n  mov   rcx,-1\n  repne scasb\n  sub   rdi,2\n  cmpsb\n  sete  al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212967,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\ncorrect_tail:\n  inc rdi\n  mov al,[rdi]\n  cmp al,0\n  jne correct_tail\n  mov bl,[rdi-1]\n  mov rax,1\n  cmp bl,[rsi]\n  je end\n  xor rax,rax\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212968,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\ncorrect_tail:\n  cmp byte [rdi], 0\n  lea rdi, [rdi + 1]\n  jne correct_tail\n  mov cl, [rdi - 2]\n  xor eax, eax\n  cmp cl, [rsi]\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212969,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\n; rdi is body\n; rsi is tail\ncorrect_tail:\n\nlop:\n  cmp byte [rdi], 0\n  lea rdi, [rdi + 1]\n;  inc rdi  ;\uff7c\uff6c\uff70 \u0e05(`\ua20a\u00b4\u0e05)\n  jne lop\n  \n  xor rax, rax\n  mov dl, [rdi - 2]\n  cmp [rsi], dl\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212970,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\ncorrect_tail:\n  mov r8, rdi\n  \n.strlen:\n  xor rax, rax\n  mov rcx, 0x03ff\n  cld\n  repne scasb\n  sub rcx, 0x03ff\n  neg rcx\n  sub rcx, 2\n  \n.tail:\n  mov al, byte [r8 + rcx]\n  cmp al, byte [rsi]\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212971,"user_id":null,"body":"SECTION .text\nglobal correct_tail\n\n\n; int correct_tail(const char* pcAnimal, const char* pcTail);\ncorrect_tail:\n  ; RDI = char* (pointer to INPUT string)\n  ; RSI = char* (pointer to OUTPUT string)\n  \n  ; load tail character into eax (rax)\n  movzx eax, byte [rsi]\n  \n  ; for ( rdi=pcAnimal ; *rdi!=0 ; rdi++ ) {}  \n  @IsStringEnd:\n    ;byte=8 word=16 dword=32 qword=64    \n    cmp byte [rdi], 0 ; if (*((char*)rdi) == 0) {} \n    ; reg64 + reg64*N + offset; (N=1,2,4,8) (syntax for addressing) \n    lea rdi, [rdi+1] ; add rdi, 1 ; rdi += 1 ; advance RDI pointer to next char    \n  jne @IsStringEnd\n  \n  ; rdi is ONE character after the \\0 (end of string)\n  ; so we need to access it  2  charaters before    \n  cmp [rdi-2], al   ; al = (al==rdi[-2]) ? 1 : 0;\n  sete al\n  ret\n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212972,"user_id":50,"body":"extern strlen\nSECTION .text\nglobal correct_tail\n\ncorrect_tail:\n  cmp rdi,0\n  je _retFalse\n  mov r10b,[rdi]\n_loop:\n  cmp byte[rdi],0\n  je _exit\n  mov r10b,[rdi]\n  inc rdi\n  jmp _loop\n_exit:\n  mov r9b,[rsi]\n  cmp r10b,r9b\n  je _retTrue\n  mov rax,0\n  ret\n_retTrue:\n  mov rax,1\n  ret\n_retFalse:\n  mov rax,0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56f69d9f9400f508fb000ba7":[{"id":212973,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    push rdi\n    lea rdi, [0+rdi*8]\n    call malloc\n    pop rdi\n  loop:\n    cmp rdi, 0\n    jz end_l\n    \n    mov [rax-8+rdi*8], rdi\n    \n    dec rdi\n    jmp loop\n  end_l:\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212974,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    xor rax, rax        ; RAX <- the result\n    push rdi\n    lea rdi, [0 + rdi * 8]\n    call malloc\n    pop rdi\n    push rax\n    mov rcx, 1\nl:\n    cmp rcx, rdi\n    jg return\n    mov [rax], rcx\n    add rax, 8\n    add rcx, 1\n    jmp l\nreturn:\n    pop rax\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212975,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    mov rbx, rdi\n    imul rdi, 8\n    call malloc\n    mov rcx, 1\n    mov rdx, rax\n    loep:\n    cmp rcx, rbx\n    jg end\n    mov QWORD [rdx], rcx\n    inc rcx\n    add rdx, 8\n    jmp loep\n    end:ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212976,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nextern malloc\nmonkcnt:\n  push rbx\n  mov rbx, rdi\n  lea rdi, [8*rdi]\n  call malloc\n  neg rbx\n  push 1\n  pop rcx\n.loop:\n  lea rdx, [rbx + rcx]\n  cmp rdx, 1\n  je .done\n  mov [rax + 8*rcx - 8], rcx\n  inc rcx\n  jmp .loop\n.done:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212977,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    push rdi        ; save number of items\n    sal rdi, 3      ; rdi = size of array, 8 bytes per item\n    call malloc\n    pop rcx         ; rcx = number of items\n    or rax,rax\n    jz return       ; malloc failed, returned null\n    mov rsi, rax    ; rsi = save pointer to array\n    mov rdi, rax    \n    sub rdi, 8      ; rdi = base address with 1 start index\n    xor rax, rax    ; rax = value to store\nstore:\n    inc rax\n    mov qword [rdi+rax*8], rax\n    loop store\n    mov rax, rsi    ; return pointer to array\nreturn:\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212978,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    mov rcx, rdi    ; rcx = number of items\n    push rcx        ; save number of items\n    sal rdi, 3      ; rdi = size of array, 8 bytes per item\n    call malloc\n    pop rcx         ; rcx = number of items\n    or rax,rax\n    jz return       ; malloc failed, returned null\n    mov rsi, rax    ; rsi = save pointer to array\n    mov rdi, rax    \n    sub rdi, 8      ; rdi = base address with 1 start index\n    xor rax, rax    ; rax = value to store\nstore:\n    inc rax\n    mov qword [rdi+rax*8], rax\n    loop store\n    mov rax, rsi    ; return pointer to array\nreturn:\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212979,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    push rbx\n    mov rbx, rdi\n    shl rdi, 3\n    call malloc\n    xor rcx, rcx\n    .loop:\n    cmp rcx, rbx\n    je .done\n    lea rdx, [rcx+1]\n    mov qword [rax+rcx*8], rdx\n    inc rcx\n    jmp .loop\n    .done:\n    pop rbx\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212980,"user_id":null,"body":"global monkcnt\nextern calloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    push  rdi\n    push  rsi\n    mov   rsi, 8\n    call  calloc\n    pop   rsi\n    pop   rdi\n    xor   rcx,rcx\n    .loop:\n    cmp   rcx,rdi\n    je    .end\n    lea   rdx, [rcx+1]\n    mov   qword [rax+(rcx*8)], rdx\n    inc   rcx\n    jmp   .loop\n    .end:\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212981,"user_id":null,"body":"global monkcnt\nextern malloc\n\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n  push rdi\n  shl rdi, 8\n  call malloc\n  pop rcx\n  mov edx, 1\n  \n  mov r8, 1\n.for:\n  mov qword [rax + r8 * 8 - 8], r8\n  inc r8\n  loop .for\n  \n.exit\n  ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212982,"user_id":null,"body":"global monkcnt\nextern malloc\n\nsection .text\n\n; <--- size_t *monkcnt(size_t n) --->\nmonkcnt:\n    push rdi\n    lea rdi, [rdi*8]\n    call malloc\n    pop rcx\n    .loop:\n        mov [rax+rcx*8-8], rcx\n        dec rcx\n        jnz .loop\n    ret\n; ---------> endof monkcnt <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56fa3c5ce4d45d2a52001b3c":[{"id":212983,"user_id":null,"body":"SECTION .text\nglobal xorf\n\n;  Returns a boolean indicating whether one of the arguments is true.\n;  arg0         = (bool) A boolean.\n;  arg1         = (bool) A boolean.\n;  return value = (bool) true if one argument is true, else false.\n\n;arg0 = rdi, arg1 = rsi\nxorf:\n  mov rax, rdi\n  xor rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212984,"user_id":null,"body":"section     .text\nglobal      xorf\n\nxorf:\n  xor       rax, rax\n  xor       rdi, rsi\n  mov       rax, rdi\n  ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212985,"user_id":null,"body":"SECTION .text\nglobal xorf\n\nxorf:\n  mov rax, 0\n  cmp rdi, rsi\n  je end\n  mov rax, 1\n\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212986,"user_id":null,"body":"SECTION .text\nglobal xorf\n\nxorf:\n  mov rax, rdi\n  xor rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212987,"user_id":null,"body":"SECTION .text\nglobal xorf\n\n;  Returns a boolean indicating whether one of the arguments is true.\n;  arg0         = (bool) A boolean.\n;  arg1         = (bool) A boolean.\n;  return value = (bool) true if one argument is true, else false.\nxorf:\n  mov rax, rsi\n  xor rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212988,"user_id":null,"body":"SECTION .text\nglobal xorf\n\n;  Returns a boolean indicating whether one of the arguments is true.\n;  arg0         = (bool) A boolean.\n;  arg1         = (bool) A boolean.\n;  return value = (bool) true if one argument is true, else false.\nxorf:\n  mov rax, 0\n  xor rdi, rsi\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212989,"user_id":null,"body":"SECTION .text\nglobal xorf\n\n;  Returns a boolean indicating whether one of the arguments is true.\n;  arg0         = (bool) A boolean.\n;  arg1         = (bool) A boolean.\n;  return value = (bool) true if one argument is true, else false.\nxorf:\n  mov eax, edi\n  mov ecx, esi\n  xor eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212990,"user_id":null,"body":"SECTION .text\nglobal xorf\nxorf:\n  xor rdi,rsi\n  mov rax,rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212991,"user_id":null,"body":"SECTION .text\nglobal xorf\n\n;  Returns a boolean indicating whether one of the arguments is true.\n;  arg0         = (bool) A boolean.\n;  arg1         = (bool) A boolean.\n;  return value = (bool) true if one argument is true, else false.\nxorf:\n  mov rax, 1\n  cmp rdi, rsi\n  jnz end\n  mov rax, 0\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212992,"user_id":null,"body":"SECTION .text\nglobal xorf\n\n;  Returns a boolean indicating whether one of the arguments is true.\n;  arg0         = (bool) A boolean.\n;  arg1         = (bool) A boolean.\n;  return value = (bool) true if one argument is true, else false.\nxorf:\n  push rbp\n  mov rbp, rsp\n  \n  xor rax, rax\n  xor r10, r10\n  \n  add sil, dil\n  add al, sil\n  cmp al, 2\n  cmove rax, r10\n  \n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56fe17fcc25bf3e19a000292":[{"id":212993,"user_id":null,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n  xor rax, rax\n  inc rdi\n  mov rax, rsi\n  mul rdi\n  ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n  xor rax, rax\n  mov rcx, 2\n  mov rax, rdi\n  mul rcx\n  inc rax\n  mul rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212994,"user_id":null,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n  xor rax, rax\n  inc rdi\n  mov rax, rsi\n  mul rdi\n  ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n  xor rax, rax\n  mov rcx, 2\n  mov rax, rdi\n  mul rcx\n  inc rax\n  mul rsi\n  ret\n\n;long long v1(int n, int p)\n;{\n;    return (2*n+1)*p;\n;}\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212995,"user_id":null,"body":"section .text\nglobal u1\nu1:\n  lea rax, [rdi + 1]\n  imul rax, rsi\n  ret\n\nglobal v1\nv1:\n  lea rax, [rdi + rdi + 1]\n  imul rax, rsi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212996,"user_id":null,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n    mov rax, rdi\n    inc rax\n    mul rsi\n    ret\nglobal v1\n; long v1(long n, long p)\nv1:\n    mov rax, rdi\n    add rax, rax\n    inc rax\n    mul rsi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212997,"user_id":50,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n  xor rax, rax\n  mov rax,rdi\n  inc rax\n  mul rsi\n  ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n  xor rax, rax\n  mov rax,rdi\n  shl rax,1\n  inc rax\n  mul rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212998,"user_id":77,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n  lea eax, [edi+1]\n  imul esi\n  ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n  lea eax, [2*edi+1]\n  imul esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":212999,"user_id":null,"body":"section .text\nglobal u1\nglobal v1\n\nu1:\n  ; in:   rdi=n, rsi=p\n  ; out:  rdx:rax\n  mov rax, rdi\n  mul rsi\n  add rax, rsi\n  \n  ; rdx is already ours, and already gets the high qword of rax*anything.\n  ; so 128-bit math is almost free. we just have to carry properly.\n  adc rdx, 0\n  ret\n\nv1:\n  ; in: rdi=n, rsi=p\n  ; out: rdx:rax\n  ; note: v1(0x8000000000000000, 0xffffffffffffffff) = 0xffffffffffffffff_ffffffffffffffff\n  ; past that, you need bignums\n  mov rax, rdi\n  mul rsi\n  shl rax, 1\n  rcl rdx, 1\n  add rax, rsi\n  adc rdx, 0\n  ret\n  \n\n\n\n; these are the old brutish ones\n\n; long u1(long n, long p)\n_u1:\n  enter 16, 0\n  lea rax, [rdi+1]\n  mul rsi\n  leave\n  ret\n  \n  lea rcx, [rdi*2]\n  mov r11, 1\n  shl r11, cl\n  lea r10, [rcx+1]\n  \n  xor rcx, rcx\n  xor r8, r8\n  \n.loop:\n  call combinations\n  imul r11\n  add r8, rax\n  dec r10\n  sar r11, 2\n  neg r11\n  inc rcx\n  cmp rcx, rdi\n  jbe .loop\n  \n  mov rax, r8\n  mul rsi\n  leave\n  ret\n\n; long v1(long n, long p)\n_v1:\n  enter 16, 0\n  \n  lea rcx, [rdi*2]\n  mov r11, 1\n  shl r11, cl\n  mov r10, rcx\n  \n  xor rcx, rcx\n  xor r8, r8\n  \n.loop:\n  call combinations\n  imul r11\n  add r8, rax\n  dec r10\n  sar r11, 2\n  neg r11\n  inc rcx\n  cmp rcx, rdi\n  jbe .loop\n  \n  mov rax, r8\n  mul rsi\n  leave\n  ret\n\n; C(n, k) = n! \/ k!(n-k)!\n;         = n * (n-1) * ... * (n-k+1) \/ k!\n;         = n \/ 1 * (n-1) \/ 2 * ... * (n-k+1) \/ k\ncombinations:\n; long combinations(long n, long k)\n; input: n=r10, k=rcx\n  push rcx\n\n  cmp r10, rcx\n  mov eax, 0\n  jb .done          ; there's no way to take k of (n<k) items\n  mov eax, 1\n  je .done          ; and only one way to take k of k\n  test rcx, rcx\n  jz .done          ; or 0 of k\n  \n  mov ecx, 1\n  mov r9, r10\n  \n.loop:\n  mul r9\n  div rcx\n  inc ecx\n  dec r9\n  cmp ecx, [rsp]\n  jbe .loop\n  \n.done:  \n  pop rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213000,"user_id":527,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n                lea     rax, [rdi + 1]\n                imul    rax, rsi\n                ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n                lea     rax, [2 * rdi + 1]\n                imul    rax, rsi\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213001,"user_id":168,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n  mov rax, rdi\n  inc rax\n  imul rax, rsi\n  ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n  lea rax, [2 * rdi + 1]\n  imul rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213002,"user_id":null,"body":"section .text\nglobal u1\n; long u1(long n, long p)\nu1:\n  mov rax, rsi\n  inc rdi\n  mul rdi\n  ret\n\nglobal v1\n; long v1(long n, long p)\nv1:\n  mov rax, rsi\n  shl rdi, 1\n  inc rdi\n  mul rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"570409d3d80ec699af001bf9":[{"id":213003,"user_id":null,"body":"global fusc\nfusc:\n  mov rcx, 1\n  xor eax, eax\n.loop:\n  test edi, edi\n  jle .done\n  lea edx, [rcx + rax]\n  test dil, 1\n  cmovne eax, edx\n  cmove ecx, edx\n  shr edi, 1\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213004,"user_id":null,"body":"section .text\nglobal fusc\nfusc:\n  cmp edi, 1\n  jle .bailout\n  test edi, 1\n  jz .even\n  \n  shr edi, 1\n  push rdi\n  call fusc\n  pop rdi\n  push rax\n  inc edi\n  call fusc\n  pop rcx\n  add eax, ecx\n  ret\n\n.bailout:\n  mov eax, edi\n  ret\n\n.even:\n  shr edi, 1\n  jmp fusc\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213005,"user_id":null,"body":"global fusc\nfusc:\n  cmp rdi, 1\n  jle .end\n  mov rax, rdi\n  xor rdx, rdx\n  mov rcx, 2\n  div rcx\n  mov rdi, rax\n  push rax\n  push rdx\n  call fusc\n  pop rdx\n  pop rdi\n  inc rdi\n  cmp rdx, 1\n  je .odd\n  ret\n.odd:\n  push rax\n  call fusc\n  pop rdi\n  add rdi, rax\n.end:\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213006,"user_id":null,"body":"global fusc\nfusc:\n  shr rdi,1\n  jz .base\n  jnc fusc        ; fusc(2*n) = fusc(n)\n  push rdi\n  inc rdi\n  call fusc       ; rax = fusc(n+1)\n  pop rdi\n  push rax\n  call fusc       ; rax = fusc(n)\n  pop rcx\n  add rax,rcx     ; rax = fusc(n) + fusc(n+1)\n  ret\n.base:\n  setc al         ; fusc({0,1}) = {0,1}\n  movzx rax,al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213007,"user_id":null,"body":"global fusc\nfusc:\n  push rdi\n  cmp edi, 0\n  jne next\n  mov eax, 0\n  pop rdi\n  ret\nnext:\n  cmp edi, 1\n  jne nexties\n  mov eax, 1\n  pop rdi\n  ret\nnexties:\n  shr edi, 1\n  jc double\n  call fusc\n  pop rdi\n  ret\ndouble:\n  call fusc\n  mov edx, eax\n  inc edi\n  push rdx\n  call fusc\n  pop rdx\n  add eax, edx\n  pop rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213008,"user_id":77,"body":"global fusc\nfusc:\n  cmp edi, 2\n  jl .end\n  shr edi, 1\n  jnc fusc\n  push rdi\n  inc edi\n  call fusc\n  pop rdi\n  push rax\n  call fusc\n  pop rdi\n  add eax, edi\n  ret\n.end:\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213009,"user_id":null,"body":"global fusc\nfusc:\n  xor  rax,rax\n  push rdi\n  call _fusc\nret\n\n_fusc:\n  mov rdx,[rsp+8]\n  cmp rdx,1\n  jbe @a\n    shr  rdx,1\n    jnc @b\n      inc  rdx\n      push rdx\n      call _fusc\n      mov  rdx,[rsp-8]\n      dec  rdx\n    @b:\n    push rdx\n    call _fusc\n    ret 8\n  @a:  \n  add rax,rdx\nret 8","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213010,"user_id":527,"body":"global fusc\nsection .text\nfusc:\n                cmp     edi, 1\n                jle     .le1\n                shr     edi, 1\n                jnc     fusc\n                push    rdi\n                call    fusc\n                pop     rdi\n                push    rax\n                inc     edi\n                call    fusc\n                pop     rdx\n                add     eax, edx\n                ret\n.le1:           mov     eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213011,"user_id":168,"body":"global fusc\nfusc:\n  shr edi, 1\n  jz .done\n  jnc fusc\n  push rbx\n  mov ebx, edi\n  call fusc\n  lea edi, [rbx + 1]\n  mov ebx, eax\n  call fusc\n  add eax, ebx\n  pop rbx\n  ret  \n.done:\n  mov eax, 0\n  setc al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213012,"user_id":645,"body":"global fusc\nfusc:\n  push r12\n  push rbp\n  push rbx\n  mov ebx, edi\n  cmp edi, 1\n  jle .f4\n  xor r12d, r12d\n\n.f1:\n  mov ebp, ebx\n  sar ebp, 1\n  mov edi, ebp\n  call fusc\n  and ebx, 01H\n  jnz .f3\n  add eax, r12d\n\n.f2:\n  pop rbx\n  pop rbp\n  pop r12\n  ret\n\n.f3: \n  lea ebx, [rbp + 1H]\n  add r12d, eax\n  jmp .f1\n\n.f4:\n  mov eax, edi\n  jmp .f2","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5715eaedb436cf5606000381":[{"id":213013,"user_id":null,"body":"global positive_sum\n  \nSECTION .text\n\npositive_sum:  \n  mov rcx, rsi            ; moving count to RCX\n  xor rax, rax            ; ressetting RAX to be the return sum\n  \nlooppsum_ctrl:\n  cmp rcx, 0              ; if no numbers are left\n  je exitpsum\n  cmp dword [rdi], 0      ; if not positive\n  jle looppsum_inc        ; jumping to increment section    \n  add rax, [rdi]          ; otherwise adding to the sum\nlooppsum_inc:\n  add rdi, 4              ; next integer pointer\n  dec rcx                 ; decrementing the counter\n  jmp looppsum_ctrl       ; jumping to next iteration\n  \nexitpsum:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213014,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n    xor  eax,eax          ; sum up in eax\n    test rsi, rsi\n    jz   .end             ; count == 0: return\n.next:\n    mov   ecx, [rdi]      ; load int from values\n    add   rdi, 4          ; ponter to next item in values\n    test  ecx, ecx\n    js    .count          ; skip add if int is negative\n    add   eax, ecx        ; sum up the values\n.count:\n    dec   rsi\n    jnz   .next           ; next item\n.end    \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213015,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n    xor   eax, eax\nloop1:\n    cmp   rsi, 0\n    je    done\n    dec   rsi\n    mov   ecx, [rdi+rsi*4]\n    cmp   ecx, 0\n    jl    loop1\n    add   rax, rcx\n    jmp   loop1\ndone:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213016,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n\n  ; result to zero\n  xor rax, rax\n  ; get the second argument, the number of elements to sum\n  mov rcx, rsi\n\n  ; check if there even is something to sum in the first place\n  cmp rcx, 0\n  ; if not, just stop and return rax, which is zero\n  jz done\n  \nloop:\n  ; next index, start from last array element\n  dec rcx \n  ; get the next value from the array by indexing it\n  mov ebx, dword[rdi+rcx*4]\n  ; check if the current number is negative using the sign bit\n  test ebx, ebx\n  ; if it is, don't add it to the sum \n  js continue\n  ; if it is positive, add it to the sum\n  add eax, ebx\ncontinue:\n  ; check if we processed the first array element at position 0\n  cmp ecx, 0\n  ; if yes, we're done, if not continue processing\n  jnz loop\n\ndone:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213017,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n  xor eax, eax\n  test rsi, rsi\n  jz .exit\n.loop:\n  mov ebx, DWORD [rdi]\n  cmp ebx, 0\n  jl .neg\n  add eax, ebx\n.neg:\n  add rdi, 4\n  dec rsi\n  jnz .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213018,"user_id":null,"body":"SECTION .text\nglobal positive_sum\npositive_sum:\n  mov rax,0\n  cmp rsi,0\n  je end\n  loop1:\n  mov edx,[rdi+rsi*4-4]\n  cmp edx,0\n  jle skipad\n  add eax,edx\n  skipad:\n  dec rsi\n  jnz loop1\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213019,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n  xor eax, eax\n  xor ecx, ecx\n  lop:\n  cmp ecx, esi\n  je end\n  mov ebx, [rdi+4*rcx]\n  inc ecx\n  cmp ebx, 0\n  jle noadd\n  add eax, ebx\n  noadd:\n  jmp lop\n  end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213020,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n  lea rcx, [rdi + 4*rsi]\n  xor eax, eax\n.loop:\n  cmp rdi, rcx\n  jae .done\n  mov edx, dword [rdi]\n  mov esi, edx\n  sar esi, 31\n  andn edx, esi, edx\n  add eax, edx\n  add rdi, 4\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213021,"user_id":null,"body":"SECTION .text\nglobal positive_sum\n\n; rdi array rsi length\npositive_sum:\n  xor rax, rax\n  \n  mov rcx, 0\n  mov rdx, rsi\n  mov rbx, 0\n.loop:\n  mov rax, [rdi, 4*rcx]\n  \n  mov r8, 0\n  cmp eax, 0\n  cmovle rax, r8\n  add rbx, rax\n\n  add rcx, 1\n  cmp rcx, rdx\n  jl .loop\n\n  mov rax, rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213022,"user_id":881,"body":"SECTION .text\nglobal positive_sum\n\npositive_sum:\n    xor eax, eax\n.while:\n    dec rsi\n    jge .do\n    ret\n.do:\n    cmp dword[rdi + rsi * 4], 0\n    jle .while\n    add eax, [rdi + rsi * 4]\n    jmp .while","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"571d42206414b103dc0006a1":[{"id":213023,"user_id":null,"body":"SECTION .text\nglobal fill_arr\nextern malloc\n\n; int32_t *fill_arr(size_t);\nfill_arr:\n  ;call malloc procedure\n  push rdi\n  shl rdi,2\n  call malloc\n  pop rdi\n  \n  ;fill array with the positions\n  .loop:\n  dec rdi\n  mov [rax+rdi*4],edi\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213024,"user_id":null,"body":"global fill_arr\nextern malloc\nfill_arr:\n  push rdi\n  shl  rdi,2\n  call malloc\n  pop  rcx\n  @b:dec rcx\n     mov [rax+rcx*4],ecx\n  jne @b\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213025,"user_id":null,"body":"SECTION .text\nglobal fill_arr\n\nextern malloc\nfill_arr:\n  push rbx\n  mov rbx, rdi\n  lea rdi, [4*rdi]\n  call malloc\n  xor ecx, ecx\n.loop:\n  cmp rbx, rcx\n  je .done\n  mov dword [rax + 4*rcx], ecx\n  inc rcx\n  jmp .loop\n.done:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213026,"user_id":null,"body":"SECTION .text\nglobal fill_arr\nextern malloc\n\n; int32_t *fill_arr(size_t);\nfill_arr:\n  push rdi            ; save items count\n  shl rdi, 2          ; 4 bytes per int32\n  call malloc\n  pop rdi             ; restore items count\n  test rax, rax\n  jz .exit            ; malloc failed\n  xor rsi, rsi        ; rsi = index in the array\n  jmp .check\n.loop:\n  mov [rax+rsi*4],esi ; fill item by item\n  inc rsi\n.check:\n  cmp rsi, rdi    \n  jb .loop            ; not end of array\n.exit:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213027,"user_id":null,"body":"SECTION .text\nglobal fill_arr\nextern malloc\n\n; int32_t *fill_arr(size_t);\nfill_arr:\n  push rdi            ; save items count\n  shl rdi, 3          ; 4 bytes per int32\n  call malloc\n  pop rdi             ; restore items count\n  test rax, rax\n  jz .exit            ; malloc failed\n  xor rsi, rsi        ; rsi = index in the array\n  jmp .check\n.loop:\n  mov [rax+rsi*4],esi ; fill item by item\n  inc rsi\n.check:\n  cmp rsi, rdi    \n  jb .loop            ; not end of array\n.exit:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213028,"user_id":null,"body":"SECTION .text\nglobal fill_arr\nextern malloc\n; int32_t *fill_arr(size_t);\nfill_arr:\n  push  rdi\n  xor   rax, rax\n  shl   rdi, 3\n  call  malloc\n  pop   rdi\n  push  rax\n  xor   rcx,rcx\n  .loop:\n  mov   [rax], rcx\n  add   rax, 4\n  inc   rcx\n  cmp   rcx, rdi\n  jne   .loop\n  pop   rax\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213029,"user_id":null,"body":"SECTION .text\nextern malloc\nglobal fill_arr\n\n; int32_t *fill_arr(size_t);\nfill_arr:\n  push rbx\n  mov rbx, rdi\n  shl rdi, 2\n  call malloc\n  xor rcx, rcx\n  .loop:\n  cmp rcx, rbx\n  je .done\n  mov dword [rax+rcx*4], ecx\n  inc rcx\n  jmp .loop\n  .done:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213030,"user_id":104,"body":"; 2021 nomennescio\nSECTION .text\nglobal fill_arr\nextern malloc\n\n; int32_t *fill_arr (size_t);\nfill_arr:\n  push rbx\n  mov rbx, rdi\n  shl rdi, 2\n  je exit\n  call malloc\nloop:\n  dec rbx\n  mov [rax+rbx*4], ebx\n  cmp rbx,0\n  jg loop\nexit:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213031,"user_id":null,"body":"extern malloc\n  \nSECTION .text\nglobal fill_arr\n\n; int32_t *fill_arr(size_t);\nfill_arr:\n  cmp rdi, 0\n  jne .allocate\n  mov rdi, 1\n  \n.allocate:\n  push rdi\n  shl rdi, 5\n  call malloc\n  pop rdi\n  \n.for:\n  dec rdi\n  mov dword [rax + rdi * 4], edi\n  cmp rdi, 0\n  jnz .for\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213032,"user_id":null,"body":"extern malloc\nSECTION .text\nglobal fill_arr\n\n; int32_t *fill_arr(size_t);\nfill_arr:\n  push rdi\n  shl rdi, 2\n  call malloc\n  pop rdi\n  xor rcx, rcx\n_loop:\n  mov dword [rax + rcx*4], ecx\n  inc rcx\n  cmp rcx, rdi\n  jne _loop\n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5727bb0fe81185ae62000ae3":[{"id":213033,"user_id":null,"body":"[BITS 64]\n\nsection .text\n\n;;\n; C-signature:\n;     void *calloc(size_t num_members, size_t size_of_member)\n;     [rax]        [rdi]               [rsi]\nextern calloc\n\n;;\n; C-signature:\n;     void *realloc(void *ptr, size_t size)\n;     [rax]         [rdi]      [rsi]\nextern realloc\n\n;;\n; C-signature:\n;     size_t strlen(const char *string)\n;     [rax]         [rdi]\nextern strlen\n\nglobal strclr\n;;\n; C-signature:\n;     char *strclr(const char *s)\n;     [rax]        [rdi]\n;\n; For any '#' encountered in the given string (s) remove the '#'\n; and the preceding character from the result string if present,\n; otherwise just copy the source (s).\n;\n; This function assumes that:\n;     (1) the given string to (s) is valid.\n;     (2) the string (s) is null-terminated.\n;     (3) the memory allocated for the result is freed by the\n;         caller with a call to free().\n;     (4) there is enough memory to allocate (and relocate) the\n;         result buffer\n;\n; @param s [rdi] null-terminated input string\n; @return a null-terminated string where every '#' and its\n;         preceding character from the input string is removed\n;\n%define SIZE_PROVIDED_STRING rbp - 0x18\n%define ADDR_PROVIDED_STRING rbp - 0x10\n%define ADDR_RESULT_STRING   rbp - 0x08\nstrclr:\n  push rbp\n  mov rbp, rsp\n  sub rsp, 0x20\n  ; Calculate the size of the given string (c).\n  mov [ADDR_PROVIDED_STRING], rdi\n  call strlen WRT ..plt\n  mov [SIZE_PROVIDED_STRING], rax\n\n  ; We allocate memory one byte longer than the size of the\n  ; given array. (Worst case: We have to copy all characters and\n  ; also have to put a null-byte at the end.)\n  inc rax\n  mov rdi, rax\n  xor esi, esi\n  inc esi\n  call calloc WRT ..plt\n  mov [ADDR_RESULT_STRING], rax\n  \n  ; We use rsi to hold the source address and rdi to hold the\n  ; destination address, while ecx will be an index into the\n  ; arrays.\n  mov rsi, [ADDR_PROVIDED_STRING]\n  mov rdi, [ADDR_RESULT_STRING]\n  xor rcx, rcx\n\n.next_character:\n  cmp byte [rsi + rcx], 0\n  ; If the current character is zero, we leave this loop.\n  jz .finish_result_string\n  \n  cmp byte [rsi + rcx], '#'\n  ; If the current character is not a '#', we jump to the\n  ; code that copies the character into the destination.\n  jnz .copy_character\n  \n  ; At this point we have a '#'.\n  lea rax, [rdi + rcx]\n  ; Because we need to adjust the index into our arrays we also\n  ; have to account for this in our result array and decrement here\n  ; to not move forward again on the \"adjust_array_index\" step.\n  dec rdi\n  cmp rax, [ADDR_RESULT_STRING]\n  ; If our current result address (address + index) is at the\n  ; front of our result array, we jump to increasing the index\n  ; to the next character\n  jle .adjust_array_index\n  ; We are inside our result array and can move at least one\n  ; character back.\n  dec rdi\n  jmp .adjust_array_index\n\n.copy_character:\n  mov al, byte [rsi + rcx]\n  mov byte [rdi + rcx], al\n\n.adjust_array_index:\n  inc rcx\n  jmp .next_character\n\n.finish_result_string:\n  ; As a final modification, we null-terminate our result string.\n  ; Our result buffer will then be split by this zero character if\n  ; we moved backwards over characters we already copied.\n  mov byte [rdi + rcx], 0\n  ; Our index shall become our length. To include the null-byte\n  ; we increase it by one.\n  inc rcx\n  ; But, because we decreased the array pointer to move back, we\n  ; have to account for this by subtracting the amount of shifting\n  ; from the length\n  mov rax, [ADDR_RESULT_STRING]\n  sub rax, rdi\n  sub rcx, rax\n  \n  ; Now, we reallocate our array to get rid of potentially\n  ; dangling characters after the null-byte.\n  mov rsi, rcx\n  mov rdi, [ADDR_RESULT_STRING]\n  call realloc WRT ..plt\n  \n  mov rsp, rbp\n  pop rbp\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213034,"user_id":null,"body":"global strclr\nextern strdup\n\n; char *strclr(const char *s)\n; Returns a new allocated string.\n;\n; Interprets a string with \"backspaces\".\n; \"#\" is like a backspace. \n; E.g. the  input \"a###bc#d\" is interpreted as \"bd\".\nstrclr:\n    call strdup       ; copy string, the argument is const string\n    mov cl,'#'        ; special backspace char as constant\n    mov edx, eax      ; hold base address of the string\n    mov edi, eax      ; address of the next char to write\n    mov esi, eax      ; address of the next char to read\n    cld               ; parse string upwards\n.next:    \n    lodsb             ; load next char from string\n    cmp al,cl         ; a backspace ?\n    jne .nobackspace\n    cmp edi, edx\n    je .next          ; output is empty, nothing to delete\n    dec edi           ; delete last char in output\n    jmp .next\n.nobackspace:\n    stosb             ; write into the output\n    test al,al        ; end of string ?\n    jnz .next\n    mov eax, edx      ; return the string\n    ret\n; -----> endof strclr <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213035,"user_id":null,"body":"extern malloc, strlen\nglobal strclr\n\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  lea rdi, [rax+1]\n  call malloc\n  xor edx, edx\n.loop:\n  mov cl, [rbx]\n  test cl, cl\n  je .done\n  cmp cl, 35\n  jne .nothash\n  cmp rdx, 1\n  adc rdx, -1\n  jmp .next\n.nothash:\n  mov [rax+rdx], cl\n  inc rdx\n.next:\n  inc rbx\n  jmp .loop\n.done:\n  mov byte [rax+rdx], 0\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213036,"user_id":null,"body":"global strclr\nextern malloc, strlen\n\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n  push rdi\n  call strlen\n  lea rdi, [rax+1]\n  call malloc\n  pop rdi\n  test rax, rax\n  jz .quit\n  xor ecx, ecx\n  \n.loop:\n  mov dl, [rdi]\n  inc rdi\n  test dl, dl\n  jz .done\n  cmp dl, '#'\n  je .backspace\n  mov [rax+rcx], dl\n  inc rcx\n  jmp .loop\n  \n.backspace:\n  test rcx, rcx\n  jz .loop\n  dec rcx\n  jmp .loop\n  \n.done:\n  mov byte [rax+rcx], 0\n.quit:\n  ret\n; -----> endof strclr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213037,"user_id":null,"body":"global strclr\nextern strlen\nextern malloc\n\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n    push rdi          ; allocate the same amount of memory as the input string\n    call strlen       ; (that is guaranteed to be enough)\n    inc rax\n    mov rdi,rax\n    call malloc\n    pop rsi\n    test rax,rax      ; return NULL if allocation fails\n    jz .out \n    mov rdi,rax\n    mov r8,rax\n.loop:\n    cmp rdi,r8\n    cmovb rdi,r8\n    lodsb\n    stosb\n    test al,al\n    jz .done\n    cmp al,'#'\n    jnz .loop\n    sub rdi,2\n    jmp .loop\n.done:\n    mov rax,r8\n.out:    \n    ret\n; -----> endof strclr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213038,"user_id":null,"body":"global strclr\nextern malloc\n\nsection .text\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n    push rdi\n    xor rcx, rcx\nmain_loop:\n    mov dl, [rdi]\n    inc rdi\n    cmp dl, 0\n    je end_of_string\n    cmp dl, \"#\"\n    je backspace\n    inc rcx\n    jmp main_loop\nbackspace:\n    test rcx, rcx\n    jz main_loop\n    dec rcx\n    jmp main_loop\nend_of_string:\n    inc rcx\n    mov rdi, rcx\n    call malloc\n    pop rdi\n                    ; dangerous code because writes out of bounds of allocated\n                    ; memory with malloc\n                    ; in general code should be fised, but works anyway\n                    ; so no motivation to do that\n    mov rcx, rax\nmain_loop2:\n    mov dl, [rdi]\n    inc rdi\n    cmp dl, 0\n    je end_of_string2\n    cmp dl, \"#\"\n    je backspace2\n    mov [rcx], dl\n    inc rcx\n    jmp main_loop2\nbackspace2:\n    cmp rcx, rax\n    je main_loop2\n    dec rcx\n    jmp main_loop2\nend_of_string2:\n    mov [rcx], byte 0\n    ret\n; -----> endof strclr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213039,"user_id":null,"body":"global strclr\nextern strdup\n\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n  push rax      ; Align the stack\n  call strdup\n  \n  cmp byte [rax], 0\n  je L_exit\n  \n  mov rdi, rax    ; RDI = write ptr\n  mov rsi, rax    ; RSI = read ptr\n  \nL_loop:\n  movzx edx, byte [rsi]\n  inc rsi\n  \n  xor ecx, ecx    ; ECX = backward step\n  xor r8, r8      ; R8 = forward step\n  cmp edx, '#'\n  sete cl\n  setne r8b\n  \n  sub rdi, rcx    ; Step back\n  cmp rdi, rax    ; Verify we're not past the beginning\n  cmovb rdi, rax\n  \n  mov byte [rdi], dl\n  add rdi, r8\n  \n  test edx, edx\n  jnz L_loop\n  \n  mov byte [rdi], 0\n  \nL_exit:\n  pop rcx\n  ret\n; -----> endof strclr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213040,"user_id":525,"body":"global strclr\nextern malloc\nextern strlen\n\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n    push rdi\n    mov rdi, 1025\n    call malloc\n    mov rdx, rax\n    pop rcx\n    push rax\n    mov rax, rcx\n    xor ecx, ecx\nloop_check:\n    mov cl, BYTE [rax]\n    mov BYTE [rdx], cl\n    test cl, cl\n    jz loop_end\nloop_body:\n    cmp cl, '#'\n    setz cl\n    and rcx, 0xFF\n    shl rcx, 1\n    sub rdx, rcx\n    inc rax\n    inc rdx\n    pop rcx\n    cmp rdx, rcx\n    cmovl rdx, rcx\n    push rcx\n    jmp loop_check\nloop_end:\n    pop rax\n    ret\n; -----> endof strclr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213041,"user_id":null,"body":"global strclr\n\nextern strdup\n\n; <-- [byte RAX] strclr(ro [byte RDI] s) -->\nstrclr:\n        push    rbx\n        mov     rbx, rdi\n        call    strdup\n        mov     rsi, rax\n        lea     rdi, [rbx+1]\n        mov     eax, 0\n        jmp     loop_entry\n\nhash:\n        test    eax, eax\n        setg    dl\n        movzx   edx, dl\n        sub     eax, edx\n        mov     ecx, eax\n\nloop:\n        add     rdi, 1\n        mov     eax, ecx\n\nloop_entry:\n        movzx   edx, BYTE [rdi-1]\n        cmp     dl, '#'\n        je      hash\n        lea     ecx, [rax+1]\n        cdqe\n        mov     BYTE [rsi+rax], dl\n        cmp     BYTE [rdi-1], 0\n        jne     loop\n\n        mov     rax, rsi\n        pop     rbx\n        ret\n; -----> endof strclr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213042,"user_id":null,"body":"segment .text\nglobal strclr\nextern malloc\nstrclr:\n      push rdi\n      mov rcx,rdi\n      mov al,0\n      repne scasb\n      sub rdi,rcx\n      inc rdi\n      call malloc\n      mov rdi,rax\n      pop rsi\n      xor rcx,rcx\n@l1:  lodsb\n      test al,al\n      jz @done\n      cmp al,'#'\n      jne @nobs\n      test rcx,rcx\n      jz  @l1\n      dec rcx\n      jmp @l1\n@nobs:mov [rdi + rcx], al\n      inc rcx\n      jmp @l1\n@done:mov byte [rdi + rcx], 0\n      mov rax,rdi     \n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"572b6b2772a38bc1e700007a":[{"id":213043,"user_id":527,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s)\nuni_total:\n                xor     eax, eax\n.loop:          movzx   edx, byte [rdi]\n                inc     rdi\n                add     eax, edx\n                test    edx, edx\n                jnz     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213044,"user_id":881,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n    xor rax, rax\n    xor rdx, rdx\n.loop:\n    mov dl, byte[rdi]\n    inc rdi\n    add rax, rdx\n    test dl, dl\n    jnz .loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213045,"user_id":null,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n    xor rax, rax\n    xor rbx,rbx\n  .loop:\n    mov bl, byte [rdi]\n    cmp bl, 0\n    je .end\n    add eax, ebx  \n    inc rdi\n    jmp .loop\n .end:   \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213046,"user_id":null,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s)\nuni_total:\n  xor rax, rax\n  xor rdx, rdx\n.loop:\n  mov BYTE dl, [rdi]\n  test dl, dl\n  jz .exit\n  add rax, rdx\n  inc rdi\n  jnz .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213047,"user_id":null,"body":"section .text\nglobal uni_total\nuni_total:\n  mov rcx,0\n  mov rax,0\n  mov rbx,0\n  loop1:\n  mov bl,[rdi+rcx]\n  add rax,rbx\n  inc rcx\n  cmp bl,0\n  jg loop1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213048,"user_id":null,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n  xor eax, eax\n.loop:\n  movsx ecx, byte [rdi]\n  test ecx, ecx\n  je .done\n  inc rdi\n  add eax, ecx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213049,"user_id":null,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n    xor rcx, rcx      ; rcx = sum up here\n    xor rax, rax\n    mov rsi, rdi      ; rsi running pointer in s\n    test rsi, rsi\n    jz .exit          ; error exit: null pointer\n    cld               ; run upwards though the string\n.loop:   \n    lodsb\n    add rcx, rax      ; sum up all ASCII values\n    test al, al\n    jnz .loop         ; end of string\n.exit:\n    mov rax, rcx      ; return the sum\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213050,"user_id":104,"body":"; 2022 nomennescio\nsection .text\nglobal uni_total\n\n; int uni_total (const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n    xor rax, rax\n    xor rcx, rcx\nloop:\n    mov cl, [rdi]\n    inc rdi\n    add rax, rcx\n    test cl, cl\n    jne loop\nend:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213051,"user_id":null,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n    xor rax, rax\n    xor rcx,rcx\n    mov rbx,0\nlp:\n    mov cl,[rdi+rbx]\n    cmp rcx,0\n    je ende\n    add rax,rcx\n    inc rbx\n    jmp lp\n\nende:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213052,"user_id":173,"body":"section .text\nglobal uni_total\n\n; int uni_total(const char *s);\n; *s --> rdi, result --> rax\nuni_total:\n    xor rax, rax\nl_loop:\n    movzx rcx, byte [rdi] \n    add rax, rcx\n    cmp byte [rdi], 0\n    jz l_done\n    inc rdi\n    jmp l_loop\nl_done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57356c55867b9b7a60000bd7":[{"id":213053,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  ; xorps xmm0, xmm0    ; XMM0 <- the result\n  \n  cmp dil, '+'\n  je .add\n  cmp dil, '-'\n  je .subtract\n  cmp dil, '*'\n  je .multiply\n  cmp dil, '\/'\n  je .divide\n  jmp .end\n  \n  .add:\n    addsd xmm0, xmm1\n    jmp .end\n  .subtract:\n    subsd xmm0, xmm1\n    jmp .end\n  .multiply:\n    mulsd xmm0, xmm1\n    jmp .end\n  .divide:\n    divsd xmm0, xmm1\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213054,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\nbasic_op:\n  jmp [.case+rdi*8-'*'*8]\n    .mul:mulsd xmm0,xmm1\n         ret\n   .plus:addsd xmm0,xmm1 \n         ret\n  .minus:subsd xmm0,xmm1\n         ret \n    .div:divsd xmm0,xmm1\n         ret\n    \n  .case dq .mul,.plus,0,.minus,0,.div","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213055,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  cmp   dil, '+'\n  je    .add\n  cmp   dil, '-'\n  je    .sub\n  cmp   dil, '*'\n  je    .mul\n  divpd xmm0, xmm1\n  ret\n.add:\n  addpd xmm0, xmm1\n  ret\n.sub:\n  subpd xmm0, xmm1\n  ret\n.mul:\n  mulpd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213056,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\nbasic_op:\n  cmp dil, '+'\n  je add\n  cmp dil, '-'\n  je sub\n  cmp dil, '*'\n  je mull\ndiv:\n  divsd xmm0, xmm1\n  ret\nmull:\n  mulsd xmm0, xmm1\n  ret\nsub:\n  subsd xmm0, xmm1\n  ret\nadd:\n  addsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213057,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  xor rax, rax\n  mov al, dil\n  cmp al, '+'\n  je addition\n  cmp al, '-'\n  je substraction\n  cmp al, '*'\n  je multiplication\n  cmp al, '\/'\n  je division\n  mov rax, __float64__(0.0)\n  movq xmm0, rax\nreturn:\n  ret\n\naddition:\n  movq [f1], xmm0\n  movq [f2], xmm1\n  finit\n  fld QWORD [f1]\n  fld QWORD [f2]\n  fadd\n  fstp QWORD [f1]\n  movq xmm0, [f1]\n  jmp return\n\nsubstraction:\n  movq [f1], xmm0\n  movq [f2], xmm1\n  finit\n  fld QWORD [f1]\n  fld QWORD [f2]\n  fsub\n  fstp QWORD [f1]\n  movq xmm0, [f1]\n  jmp return\n\nmultiplication:\n  movq [f1], xmm0\n  movq [f2], xmm1\n  finit\n  fld QWORD [f1]\n  fld QWORD [f2]\n  fmul\n  fstp QWORD [f1]\n  movq xmm0, [f1]\n  jmp return\n\ndivision:\n  movq [f1], xmm0\n  movq [f2], xmm1\n  finit\n  fld QWORD [f1]\n  fld QWORD [f2]\n  fdiv\n  fstp QWORD [f1]\n  movq xmm0, [f1]\n  jmp return\n\nSECTION .bss\nf1: resq 1\nf2: resq 1\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213058,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  add edi, -42\n  lea rax, [.switchbase]\n  movsxd rcx, dword [rax + 8*rdi]\n  add rcx, rax\n  jmp rcx\n.mul:\n  vmulsd xmm0, xmm0, xmm1\n  ret\n.div:\n  vdivsd xmm0, xmm0, xmm1\n  ret\n.add:\n  vaddsd xmm0, xmm0, xmm1\n  ret\n.sub:\n  vsubsd xmm0, xmm0, xmm1\n  ret\n.switchbase:\n  dq .mul-.switchbase\n  dq .add-.switchbase\n  dq .sub-.switchbase\n  dq .sub-.switchbase\n  dq .sub-.switchbase\n  dq .div-.switchbase\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213059,"user_id":173,"body":"extern mprotect\nglobal basic_op\n\n\nSECTION .bss\n  alignb\t4\nmc:\n  resb\t0x2000\n\nSECTION .data\nop: \n  db 0x59, 0x58, 0x00, 0x5c, 0x00, 0x5e\n\nSECTION .text\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n\n  ; use mprotect to set up writable and executable BSS space\n  xor r12, r12\n  mov\tdword r12, (mc + 0x1000)\n\tand\tdword r12, 0xfffff000\n\n  push rdi\n  push rsi\n  push rdx\n  mov rdi, r12\n  mov rsi, 0x1000\n  mov rdx, 7\n  call mprotect\n  pop rdx\n  pop rsi\n  pop rdi\n\n  ; compute opcode for operation on ascii offset\n  lea rsi, [rel op]\n  add rsi, rdi\n  sub rsi, 0x2a\n  mov byte cl, [rsi]\n  \n  ; write modifiable code based on opcode and execute it\n  mov rax, r12\n  mov byte [rax], 0xf2\n  mov byte [rax + 1], 0x0f\n  mov byte [rax + 2], cl\n  mov byte [rax + 3], 0xc1\n  mov byte [rax + 4], 0xc3\n  jmp r12\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213060,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  cmp dil, '+'\n  je .add\n  cmp dil, '-'\n  je .sub\n  cmp dil, '*'\n  je .mul\n  cmp dil, '\/'\n  je .div\n  .add:\n  addsd xmm0, xmm1\n  ret\n  .sub\n  subsd xmm0, xmm1\n  ret\n  .mul:\n  mulsd xmm0, xmm1\n  ret\n  .div:\n  divsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213061,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  cmp dil, '+'\n  jne three\n  addpd xmm0, xmm1\n  ret\n  three:\n  cmp dil, '-'\n  jne two\n  subpd xmm0, xmm1\n  ret\n  two:\n  cmp dil, '*'\n  jne divis\n  mulpd xmm0, xmm1\n  ret\n  divis:\n  divpd xmm0, xmm1\n  ;xorps xmm0, xmm0    ; XMM0 <- the result\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213062,"user_id":null,"body":"SECTION .text\nglobal basic_op\n\n; double basic_op(char op, double a, double b)\n; params:\n;   DIL  <- op\n;   XMM0 <- a\n;   XMM1 <- b\nbasic_op:\n  cmp dil, '+'\n  je .add\n  cmp dil, '-'\n  je .sub\n  cmp dil, '*'\n  je .mult\n  cmp dil, '\/'\n  je .div\n  \n  xorps xmm0, xmm0  \n  ret\n  \n.add:\n  addsd xmm0, xmm1   \n  ret\n  \n.sub:\n  subsd xmm0, xmm1\n  ret\n  \n.mult:\n  mulsd xmm0, xmm1\n  ret\n  \n.div:\n  divsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"574b3b1599d8f897470018f6":[{"id":213063,"user_id":null,"body":"section .text\nglobal get_real_floor\nget_real_floor:\n  mov eax, edi\n  cmp eax,1\n  jge g_1\n  ret\ng_1:\n  cmp eax,13\n  jl l_13\n  sub eax,2\n  ret\nl_13:\n  sub eax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213064,"user_id":null,"body":"section .text\nglobal get_real_floor\n\nget_real_floor:\n  mov eax, edi\n  cmp eax, 1\n  js .exit\n  dec al \n  cmp eax, 13\n  jb .exit\n  dec al\n \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213065,"user_id":28,"body":"global get_real_floor\nget_real_floor:\n  ; Test if we're in the basement\n  mov ebx, edi\n  cmp ebx, 0\n  jg positiveFloor\n  \n  ; If we're in the basement, do nothing!\n  mov eax, edi\n  ret\n\n  positiveFloor:\n  ; Test if we're floor 13 or above\n  mov ebx, edi\n  cmp ebx, 13\n  jb twelfthOrBelow\n  \n  ; If we're here, then that means we're floor 13 or above\n  ; subtract 1 more than usual\n  sub edi, 1\n  \n  twelfthOrBelow:\n  ; Subtract 1 from the floor regardless of where we're at\n  sub edi, 1\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213066,"user_id":null,"body":"global get_real_floor\nget_real_floor:\n\n  cmp edi, 14     ; see if we need to subtract ground and 13th floors\n  jl less         ; if not continue to next check\n  sub edi, 2      ; sub 2 for ground and 13\n  jmp exit        ; jmp to exit\n\nless:\n  cmp edi, 1      ; see if we need to subtract ground floor\n  jl exit         ; if not continue to exit\n  sub edi, 1      ; sub 1 for ground\n\nexit:\n  mov eax, edi    ; put result in eax register\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213067,"user_id":527,"body":"global get_real_floor\nsection .text\nget_real_floor:\n                mov     eax, edi\n                cmp     edi, 13\n                adc     eax, -2\n                test    edi, edi\n                cmovle  eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213068,"user_id":null,"body":"global get_real_floor\nget_real_floor:\n  mov eax, edi\n  dec edi \n  test edi, edi\n  cmovge eax, edi\n  cmovl edi, eax\n  dec edi\n  cmp edi, 12\n  cmovge eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213069,"user_id":null,"body":"global get_real_floor\n\nget_real_floor:\n    mov eax,edi\n    cmp eax,0\n    jle greater\n    cmp eax,13\n    jg greater2\n    dec eax\n    ret\ngreater:\n    ret\n  \ngreater2:\n   sub eax,2\n   ret\n   \n\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213070,"user_id":null,"body":"global get_real_floor\nget_real_floor:\n  mov eax, edi\n  cmp eax, 13\n  jnl fu2\n  cmp eax, 1\n  jnl fu1\n  ret\n\n  \nfu1:\ndec eax\nret\n\nfu2:\nsub eax, 2\nret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213071,"user_id":null,"body":"section     .text\nglobal      get_real_floor\n\nget_real_floor:\n    xor     eax, eax\n    \n    cmp     edi, 0\n    jle     _zero_or_below\n\n    xor     edx, edx\n    xor     ecx, ecx\n\n_loop:\n    cmp     edx, 0\n    jnz     _test_for_thirteen\n_mid_loop:\n    inc     edx\n    cmp     edx, edi\n    jnz     _loop\n    \n    mov     eax, ecx\n    ret\n\n_test_for_thirteen:\n    cmp     edx, 13\n    jnz      _increment\n    jmp     _mid_loop\n\n_increment:\n    inc     ecx\n    jmp     _mid_loop\n\n_zero_or_below:\n    mov     eax, edi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213072,"user_id":null,"body":"global get_real_floor\nget_real_floor:\n  xor ecx, ecx\n  cmp edi, 14\n  setge cl\n  not ecx\n  xor eax, eax\n  test edi, edi\n  cmovg eax, ecx\n  add eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57591ef494aba64d14000526":[{"id":213073,"user_id":null,"body":"section .text\nglobal john\nglobal ann\nglobal sum_john\nglobal sum_ann\nextern realloc\n\ngenerate:\n  push rbp\n  push rbx\n  mov rbx, rdi\n  push rdx\n  mov rbp, [s]\n  mov rdi, [j]\n  cmp rbp, rbx\n  jnb .rightsize\n  mov rax, rbx\n  mov ecx, 1024\n  cqo\n  idiv rcx\n  lea rsi, [rax+1]\n  mov rax, rsi\n  sal rsi, 13\n  sal rax, 10\n  mov [s], rax\n  call realloc\n  mov rdi, [a]\n  mov [j], rax\n  mov rax, [s]\n  lea rsi, [rax*8]\n  call realloc\n  test rbp, rbp\n  mov [a], rax\n  jne .rightsize\n  mov rdx, [j]\n  and qword [rdx], 0\n  mov qword [rax], 1\n.rightsize:\n  mov rdx, [a]\n  mov rcx, [j]\n.loop:\n  mov rax, [l]\n  mov rsi, [rcx-8+rax*8]\n  mov rdi, rax\n  sub rdi, [rdx+rsi*8]\n  mov [rcx+rax*8], rdi\n  mov rax, [l]\n  mov rsi, [rdx-8+rax*8]\n  mov rdi, rax\n  sub rdi, [rcx+rsi*8]\n  mov [rdx+rax*8], rdi\n  mov rax, [l]\n  inc rax\n  cmp rbx, rax\n  mov [l], rax\n  jnb .loop\n  pop rax\n  pop rbx\n  pop rbp\n  ret\n  \njohn:\n  push rbp\n  mov rbp, rsi\n  push rbx\n  mov rbx, rdi\n  push rdx\n  cmp rdi, [l]\n  jb .enough\n  call generate\n.enough:\n  mov rsi, [j]\n  lea rcx, [rbx*8]\n  mov rdi, rbp\n  rep movsb\n  pop rax\n  pop rbx\n  pop rbp\n  ret\n  \nann:\n  push rbp\n  mov rbp, rsi\n  push rbx\n  mov rbx, rdi\n  push rdx\n  cmp rdi, [l]\n  jb .enough\n  call generate\n.enough:\n  mov rsi, [a]\n  lea rcx, [rbx*8]\n  mov rdi, rbp\n  rep movsb\n  pop rax\n  pop rbx\n  pop rbp\n  ret\n  \nsum_john:\n  cmp rdi, [l]\n  push rbx\n  mov rbx, rdi\n  jb .enough\n  call generate\n.enough:\n  mov rcx, [j]\n  xor eax, eax\n  xor edx, edx\n.loop:\n  cmp rbx, rax\n  je .done\n  add rdx, [rcx+rax*8]\n  inc rax\n  jmp .loop\n.done:\n  mov rax, rdx\n  pop rbx\n  ret\n  \nsum_ann:\n  cmp rdi, [l]\n  push rbx\n  mov rbx, rdi\n  jb .enough\n  call generate\n.enough:\n  mov rcx, [a]\n  xor eax, eax\n  xor edx, edx\n.loop:\n  cmp rbx, rax\n  je .done\n  add rdx, [rcx+rax*8]\n  inc rax\n  jmp .loop\n.done:\n  mov rax, rdx\n  pop rbx\n  ret\n  \nsection .data\na: dq 0\nj: dq 0\nl: dq 1\ns: dq 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213074,"user_id":null,"body":"section .text\nglobal john\n; void john(long n, long *output)\n; For `john` and `ann`, write the array to `output`. No need to return array length.\njohn:\n  push rdi\n  push rsi\n  call run_once\n  pop rdi\n  pop rcx\n  lea rsi, [john_data]\n  rep movsq\n  ret\n\nglobal ann\n; void ann(long n, long *output)\nann:\n  push rdi\n  push rsi\n  call run_once\n  pop rdi\n  pop rcx\n  lea rsi, [ann_data]\n  rep movsq\n  ret\n\nglobal sum_john\n; long sum_john(long n)\n; Input for `sum_john` and `sum_ann` is less than 1000000.\nsum_john:\n  push rdi\n  call run_once\n  pop rdi\n  xor eax, eax\n  \n  test rdi, rdi\n  jz .done\n  lea rsi, [john_data]\n.loop:\n  add rax, [rsi+rdi*8-8]\n  dec rdi\n  jnz .loop\n.done:\n  ret\n\nglobal sum_ann\n; long sum_ann(long n)\nsum_ann:\n  push rdi\n  call run_once\n  pop rdi\n  xor eax, eax\n  \n  test rdi, rdi\n  jz .done\n  lea rsi, [ann_data]\n.loop:\n  add rax, [rsi+rdi*8-8]\n  dec rdi\n  jnz .loop\n.done:\n  ret\n  \nrun_once:\n  cmp byte [calc_done], 0\n  jne .done\n  \n  xor ecx, ecx\n  lea rsi, [john_data]\n  lea rdi, [ann_data]\n  inc qword [rdi]\n  \n.loop:\n  inc ecx\n  \n  mov edx, ecx\n  mov rax, [rdi+rcx*8-8]\n  sub rdx, [rsi+rax*8]\n  mov [rdi+rcx*8], rdx\n  \n  mov edx, ecx\n  mov rax, [rsi+rcx*8-8]\n  sub rdx, [rdi+rax*8]\n  mov [rsi+rcx*8], rdx\n  \n  cmp ecx, 1000000\n  jne .loop\n  inc byte [calc_done]\n.done:\n  ret\n\nsection .bss\ncalc_done: resq 1\njohn_data: resq 1000001\nann_data: resq 1000001\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213075,"user_id":168,"body":"section .bss\nann_table resq 1000001\njohn_table resq 1000001\n\nsection .data\nmax_n dd -1\n\nsection .text\nglobal john\nglobal ann\nglobal sum_john\nglobal sum_ann\n\nann_john:\n  mov ecx, dword [max_n]\n  cmp edi, ecx\n  jle .end\n  cmp ecx, 0\n  jge .fill_tables\n  xor eax, eax\n  mov qword [rel john_table], rax\n  inc eax\n  mov qword [rel ann_table], rax\n  xor ecx, ecx\n.fill_tables:\n  mov dword [max_n], edi\n  ; rdx = a[i - 1]\n  ; rax = j[i - 1]\n  mov rdx, qword [rel ann_table + rcx * 8]\n  mov rax, qword [rel john_table + rcx * 8]\n  jmp .loop_cond\n.loop:\n  inc ecx\n  ; j[i] = i - a[j[i - 1]]\n  mov rax, qword [rel ann_table + rax * 8]\n  neg rax\n  add rax, rcx\n  mov qword [rel john_table + rcx * 8], rax\n  ; a[i] = i - j[a[i - 1]]\n  mov rdx, qword [rel john_table + rdx * 8]\n  neg rdx\n  add rdx, rcx\n  mov qword [rel ann_table + rcx * 8], rdx\n.loop_cond:\n  cmp ecx, edi\n  jl .loop\n.end:\n  ret\n\n; void john(long n, long *output)\njohn:\n  call ann_john\n  mov ecx, edi\n  inc ecx\n  mov rdi, rsi\n  lea rsi, [rel john_table]\n  rep movsq\n  ret\n\n; void ann(long n, long *output)\nann:\n  call ann_john\n  mov ecx, edi\n  inc ecx\n  mov rdi, rsi\n  lea rsi, [rel ann_table]\n  rep movsq\n  ret\n\n; long sum_john(long n)\nsum_john:\n  call ann_john\n  xor eax, eax\n  mov ecx, edi\n  lea rdi, [rel john_table]\n  jmp .loop_dec\n.loop:\n  add rax, qword [rdi + rcx * 8]\n.loop_dec:\n  dec ecx\n  jnl .loop\n  ret\n\n; long sum_ann(long n)\nsum_ann:\n  call ann_john\n  xor eax, eax\n  mov ecx, edi\n  lea rdi, [rel ann_table]\n  jmp .loop_dec\n.loop:\n  add rax, qword [rdi + rcx * 8]\n.loop_dec:\n  dec ecx\n  jnl .loop\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213076,"user_id":1339,"body":"section .text\nextern memcpy\n\nglobal john\n; void john(long n, long *output)\njohn:\n  cmp qword [init], 0\n  jnz .pass\n  \n  push rdi\n  push rsi\n  push 0\n  call do_init\n  pop rax\n  pop rsi\n  pop rdi\n  \n.pass:\n  mov rdx, rdi\n  shl rdx, 3\n  mov rdi, rsi\n  mov rsi, john_buf\n  jmp memcpy\n\nglobal ann\n; void ann(long n, long *output)\nann:\n  cmp qword [init], 0\n  jnz .pass\n  \n  push rdi\n  push rsi\n  push 0\n  call do_init\n  pop rax\n  pop rsi\n  pop rdi\n  \n.pass:\n  mov rdx, rdi\n  shl rdx, 3\n  mov rdi, rsi\n  mov rsi, ann_buf\n  jmp memcpy\n\nglobal sum_john\n; long sum_john(long n)\nsum_john:\n  cmp qword [init], 0\n  jnz .pass\n  \n  push rdi\n  call do_init\n  pop rdi\n  \n.pass:\n  mov rax, [john_sum_buf + rdi * 8 - 8]\n  ret\n\nglobal sum_ann\n; long sum_ann(long n)\nsum_ann:\n  cmp qword [init], 0\n  jnz .pass\n  \n  push rdi\n  call do_init\n  pop rdi\n  \n.pass:\n  mov rax, [ann_sum_buf + rdi * 8 - 8]\n  ret\n\ndo_init:\n  mov qword [john_buf], 0\n  mov qword [ann_buf], 1\n  mov qword [john_sum_buf], 0\n  mov qword [ann_sum_buf], 1\n  mov rcx, 1\n  \n.loop:\n  cmp rcx, 1000000\n  jl .continue\n  mov qword [init], 1\n  ret\n  \n.continue:\n  mov rax, [john_buf + rcx * 8 - 8]\n  mov rax, [ann_buf + rax * 8]\n  mov [john_buf + rcx * 8], rcx\n  sub [john_buf + rcx * 8], rax\n  \n  mov rax, [ann_buf + rcx * 8 - 8]\n  mov rax, [john_buf + rax * 8]\n  mov [ann_buf + rcx * 8], rcx\n  sub [ann_buf + rcx * 8], rax\n  \n  mov rax, [john_sum_buf + rcx * 8 - 8]\n  add rax, [john_buf + rcx * 8]\n  mov [john_sum_buf + rcx * 8], rax\n  \n  mov rax, [ann_sum_buf + rcx * 8 - 8]\n  add rax, [ann_buf + rcx * 8]\n  mov [ann_sum_buf + rcx * 8], rax\n  \n  inc rcx\n  jmp .loop\n\nsection .data\ninit: dq 0\n\nsection .bss\njohn_buf:     resq 1000000\nann_buf:      resq 1000000\njohn_sum_buf: resq 1000000\nann_sum_buf:  resq 1000000","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5763bb0af716cad8fb000580":[{"id":213077,"user_id":null,"body":"section .text\nglobal countSquares\n\n; int countSquares(int cuts)\n; cuts -> edi\n; result -> eax\ncountSquares:\n    xor eax, eax\n    xor edx, edx\n    cmp edi, 0\n    je .zero\n    mov eax, edi\n    imul eax\n    imul eax, 6 \n    add eax, 2\n    jmp .end\n  .zero:\n    mov eax, 1\n  .end:  \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213078,"user_id":null,"body":"section .text\nglobal countSquares\n\n; int countSquares(int cuts)\n; cuts -> edi\n; result -> eax\ncountSquares:\n  mov eax, edi\n  imul eax, eax\n  test edi, edi\n  lea eax, [rax + 2*rax]\n  lea ecx, [rax + rax + 2]\n  mov eax, 1\n  cmovne eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213079,"user_id":null,"body":"global countSquares\ncountSquares:\n  mov rax,rdi\n  mul rax\n  lea rax,[rax*3]\n  lea rax,[rax*2+2]\n  cmp rax,3\n  sbb rax,0\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213080,"user_id":50,"body":"section .text\nglobal countSquares\n\n; int countSquares(int cuts)\n; cuts -> edi\n; result -> eax\ncountSquares:\n    xor eax, eax\n    cmp edi,0\n    jne _h\n    mov eax,1\n    ret\n_h:\n    mov eax,edi\n    mul eax\n    imul eax,6\n    add eax,2\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213081,"user_id":527,"body":"section .text\nglobal countSquares\n\n; int countSquares(int cuts)\ncountSquares:\n                imul    edi, edi\n                add     edi, edi\n                jz      .ret1\n                lea     eax, [rdi * 3 + 2]\n                ret\n.ret1:          mov     eax, 1\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213082,"user_id":168,"body":"section .text\nglobal countSquares\n\n; int countSquares(int cuts)\n; cuts -> edi\n; result -> eax\ncountSquares:\n  mov ecx, -1\n  mov eax, edi\n  imul eax, eax\n  imul eax, -6\n  neg eax\n  cmovz eax, ecx\n  add eax, 2\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213083,"user_id":881,"body":"section .text\nglobal countSquares\n\n; int countSquares(int cuts)\n; cuts -> edi\n; result -> eax\ncountSquares:\n    cmp edi, 0\n    jz .iszero\n    mov eax, 6\n    mul edi\n    mul edi\n    add eax, 2\n    ret\n.iszero:\n    mov eax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"576bb71bbbcf0951d5000044":[{"id":213084,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n    mov dword [rdx], 0\n    mov dword [rcx], 0\n    \n    ; The loop starts at the end of the array, and works towards the beginning\n  _loop:\n    cmp rsi, 0 ; Bound check. Are we at the beggining of the array?\n    jle _end   ; Bound check\n    mov eax, dword [rdi+rsi*4-4] ; Get next value in array. Work back to front\n    cmp eax, 0 ; Check for pos, neg, or zero\n    jg _pos    \n    je _loop_tail ; If zero, then do nothing\n  _neg:        ; If neg, add to the accumulator\n    add [rcx], eax\n    jmp _loop_tail\n  _pos:        ; If pos, add to the tally count\n    inc dword [rdx]\n  _loop_tail:  \n    dec rsi\n    jmp _loop\n    \n  _end:\n    ret\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213085,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n    xor r8d, r8d\n    xor r9d, r9d\n    xor eax, eax\n    test rdi, rdi\n    jz .end\n    test rsi, rsi\n    jz .end\n    dec rsi\n    .loop:\n        mov eax, [rdi+rsi*4]\n        test eax, eax\n        jg .pos\n        jl .neg\n        dec rsi\n        jns .loop\n        jmp .end\n        .pos:\n            inc r8\n            dec rsi\n            jns .loop\n            jmp .end\n        .neg:\n            add r9d, eax\n            dec rsi\n            jns .loop\n            jmp .end\n    .end:\n    mov [rdx], r8d\n    mov [rcx], r9d\n    ret\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213086,"user_id":null,"body":"global count_positives_sum_negatives\nsection .text\n; void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum)\ncount_positives_sum_negatives:\n  mov dword [rdx], 0\n  mov dword [rcx], 0\n.loop:\n  test rsi, rsi\n  jz .exit\n  dec rsi\n  mov dword eax, [rdi + 4 * rsi]\n  cmp eax, 0\n  jz .loop\n  jl .neg\n  add dword [rdx], 1\n  jmp .loop\n.neg:\n  add dword [rcx], eax\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213087,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n    mov r9, rcx\n    mov dword [rdx], 0      ; resetting <*poscnt>\n    mov dword [r9], 0      ; resetting <*negsum>\n    cmp rsi, 0\n    je finished\n    xor rax, rax\n    xor r11, r11\n    mov rcx, rsi\ncount_loop:\n    mov r10d, dword [rdi + 4*rcx - 4]\n    cmp r10d, 0\n    jg not_negative\n    add eax, r10d\n    jmp cont_loop\nnot_negative:\n    inc r11d\ncont_loop:\n    loop count_loop\n    mov dword [rdx], r11d\n    mov dword [r9], eax\nfinished:\n    ret\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213088,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n    mov dword [rdx], 0      ; resetting <*poscnt>\n    mov dword [rcx], 0      ; resetting <*negsum>\n    cmp rsi, 0\n    je .end\n    xor rbx, rbx\n.loop:\n    mov eax, dword [rdi + 4*rbx]\n    cmp eax, 0\n    jle .sum\n\n    mov eax, dword [rdx]\n    inc eax\n    mov dword [rdx], eax\n    jmp .incloop\n.sum:\n    add eax, dword [rcx]\n    mov dword [rcx], eax\n.incloop:\n    inc rbx\n    cmp rbx, rsi\n    jl .loop\n.end:\n    ret\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213089,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n  mov r8, rdx\n  xor eax, eax\n  lea rdx, [rdi+rsi*4]\n  mov [r8], eax\n  mov [rcx], eax\n  jmp .checkend\n.loop:\n  mov eax, [rdi]\n  test eax, eax\n  jle .neg\n  inc dword [r8]\n  jmp .next\n.neg:\n  jge .next\n  add dword [rcx], eax\n.next:\n  add rdi, 4\n.checkend:\n  cmp rdi, rdx\n  jb .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213090,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n    mov dword [rdx], 0      ; resetting <*poscnt>\n    mov dword [rcx], 0      ; resetting <*negsum>\n    xor rbx, rbx\nloop:\n    cmp rbx, rsi\n    je end\n    mov eax, dword [rdi+rbx*4]\n    test eax, eax\n    js negative\n    inc rbx\n    test eax, eax\n    jz loop\n    inc dword [rdx]\n    jmp loop\nnegative:\n    add dword [rcx], eax\n    inc rbx\n    jmp loop\nend:\n    ret\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213091,"user_id":null,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n    push rbp\n    mov rbp,rsp\n    sub rsp,32\n    mov dword [rdx], 0      ; resetting <*poscnt>\n    mov dword [rcx], 0      ; resetting <*negsum>\n    mov r8,0                ;i=0\n    jmp check_loop\ncheck_loop:\n    cmp r8,rsi\n    jl pos_neg ;if i<sz\n    leave\n    ret\npos_neg:\n    cmp dword [rdi],0\n    jg poscnt ;if *vet>0\n    jl negsum ;else if *vet<0\n    jmp pass\nposcnt:\n    add dword [rdx],1;*poscnt+=1\n    jmp pass\nnegsum:\n    mov qword [rsp],rax\n    mov eax,dword [rdi];fix to 4 bytes\n    add dword [rcx],eax;*negsum+=*vet\n    mov rax,qword [rsp]\n    jmp pass\npass:\n    add rdi,0x4\n    add r8,1\n    jmp check_loop\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213092,"user_id":460,"body":"global count_positives_sum_negatives\nsection .text\ncount_positives_sum_negatives:\n  xor rax, rax\n  mov dword [rdx], 0\n  mov dword [rcx], 0\n  @loop:\n  mov eax, dword [rdi]\n  cmp eax, 0\n  jl @negative\n  cmp eax, 0\n  jg @positive\n  jmp @continue \n  @positive:\n    inc dword [rdx]\n    jmp @continue\n  @negative:\n    add dword [rcx], eax\n  @continue:\n  add rdi, 4\n  dec rsi\n  jnz @loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213093,"user_id":1400,"body":"global count_positives_sum_negatives\n\nsection .text\n\n; <--- void count_positives_sum_negatives(int *vec, size_t sz, unsigned *poscnt, int *negsum) --->\n; params:\n;   RDI <- vec\n;   RSI <- sz\n;   EDX <- poscnt\n;   ECX <- negsum\ncount_positives_sum_negatives:\n  push rbp\n  mov rbp, rsp\n  \n  mov dword [rdx], 0      ; resetting <*poscnt>\n  mov dword [rcx], 0      ; resetting <*negsum>\n  \n  ;rax for loop counter\n  ;rbx for intermediate values\n  \n  mov rax, 0\nloop:\n  cmp rax, rsi\n  je end\n\n  ;value\n  mov dword ebx, [rdi+4*rax]\n  cmp ebx, 0\n  jl isneg\n  jg ispos\n  je both\n  \nisneg:\n  ;update negsum\n  add dword [rcx], ebx\n  jmp both\nispos:\n  ;update poscnt\n  inc dword [rdx]\n  jmp both\n\nboth:\n  inc rax\n  jmp loop\nend:\n  \n  pop rbp\n  ret\n; ---------> end of cnt_pos_sum_neg <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5772da22b89313a4d50012f7":[{"id":213094,"user_id":null,"body":"extern strcmp\n\nSECTION .data\nGUEST db \"Hello guest\", 0\nBOSS db \"Hello boss\", 0\n\nSECTION .text\nglobal greet\n\ngreet:\n  xor rax, rax\n  \n  call strcmp\n  test rax, rax\n  je hello_boss\n  mov rax, GUEST\n  ret\n  \nhello_boss:\n  mov rax, BOSS\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213095,"user_id":null,"body":"SECTION .text\n\n\nglobal greet\n\ngreet:\n  mov rbx, [rdi]\n  cmp rbx, [rsi]\n  je boss\n  mov rax, gsg\n  ret\n  boss:\n    mov rax, bsg\n  ret\n    \nsection .data\nbsg: db \"Hello boss\",0\ngsg: db \"Hello guest\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213096,"user_id":null,"body":"SECTION .text\nglobal greet\n\ngreet:\n  movdqu     xmm0,[rdi]\n  pcmpistri  xmm0,[rsi],011000b\n  mov        rax,[answer]\n  cmovc      rax,[answer+8]\n  ret\n  \nanswer dq text1,text2\ntext1  db 'Hello boss',0\ntext2  db 'Hello guest',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213097,"user_id":null,"body":"SECTION .data\n  msgG db 'Hello guest', 0\n  msgB db 'Hello boss', 0\n  \nSECTION .text\nglobal greet\n\ngreet:\n  mov r10, msgB\n  mov rax, msgG\n  cmpsq\n  cmove rax, r10\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213098,"user_id":864,"body":"section .data\n      boss db \"Hello boss\", 0x0\n      guest db \"Hello guest\", 0x0\n      \nsegment .text\n      global greet\n      \ngreet:\n      mov al, [rdi]  ; Current letter of name (starts at first)\n      mov ah, [rsi]  ; Current letter of owner (starts at first)\n      cmp al, ah     ; Are both letters currently loaded into al and ah equal?\n      jne isGuest    ; If not, then the names cannot be equal, so it must be a guest\n      inc rdi        ; Increase byte pointed to in name (use next letter in name)\n      inc rsi        ; Increase byte pointed to in owner (use next letter in owner)\n      cmp al, 0x0    ; If the content in al is zero, then the string terminator is reached\n      je isBoss      ; If the terminator is reached, then the names must be the same, because otherwise we wouldn't get this far\n      jmp greet      ; If both al and ah contain the same letter, jump to the beginning and do the same with the next letters\n      \nisGuest:\n      mov rax, guest ; Load the guest message into rax (the message would probably also fit into eax but using rax ensures it)\n      jmp end        ; Jump to the end label\n      \nisBoss:\n      mov rax, boss  ; Load the boss message into rax (the message would probably also fit into eax but using rax ensures it)\n                     ; No jump required, because it will fall into the end label nonetheless\n      \nend:\n      ret            ; Terminate the program, the return value is always expected to be in a (ax, eax, rax)","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213099,"user_id":null,"body":"global greet\n    \nsection .text    \n\ngreet:\n  xor rcx, rcx\n  \nmain_loop:\n  ; Save for later\n  mov r8, rdi ; String 1\n  mov r9, rsi ; String 2\n  ; Need to start by getting string lengths\n  ; scasb counts down apparently\n  or ecx, 0FFFFFFFFh\n  ; Simple clear.  Originally had mov ah, 0\n  xor eax, eax\n  cld\n  repne scasb\n  ; Save the counter\n  not ecx\n  mov r10, rcx\n  ; Compare the next string\n  mov rdi, rsi\n  or ecx, 0FFFFFFFFh\n  cld\n  repne scasb\n  not ecx\n  cmp r10, rcx\n  jle str_cmp\n  xchg r10, rcx\nstr_cmp:\n  mov rdi, r8\n  mov rsi, r9\n  cld\n  repe cmpsb\n  jnz is_guest\n  mov rax, owner\n  ret\nis_guest:\n  mov rax, guest\n  ret\n\nowner:\n  db 'Hello boss',0\nguest:\n  db 'Hello guest',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213100,"user_id":null,"body":"SECTION .data\nhb db \"Hello boss\", 0x0\nhg db \"Hello guest\", 0x0\n\nSECTION .text\nglobal greet\n\ngreet:\nloop_start:\n  mov al, [rdi] ; byte of string1\n  mov ah, [rsi] ; byte of string2\n  inc rdi ; increment pointer\n  inc rsi ; ^\n  cmp al, ah ; compare two bytes\n  jne ne ; if not equal, jump to ne\n  cmp al, 0 ; test if null (termination)\n  je e ; if terminated, jump to e\n  jmp loop_start ; otherwise, continue checking\n  \nne:\n  mov rax, hg ; say hello guest if not equal\n  jmp end\ne:\n  mov rax, hb ; say hellow boss if equal\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213101,"user_id":null,"body":"global greet\n\n; <-- ro [byte RAX] greet(ro [byte RDI] name, ro [byte RSI] owner) -->\ngreet:\n    mov rax, .guest     ; setting the result to <.guest>\n    dec rdi             ; pointing <name> to the previous character\n    dec rsi             ; pointing <owner> to the previous character\n.loop:\n    inc rdi             ; pointing <name> to the next character\n    inc rsi             ; pointing <owner> to the next character\n    mov dl, [rdi]       ; loading DL with <*name> as <c>\n    cmp dl, [rsi]       ; whether <c> is equal to <*owner>\n    jne .exit           ; otherwise, jumping to exit\n    test dl, dl         ; whether <c> is the null character\n    jne .loop           ; otherwise, jumping to the next iteration\n    mov rax, .boss      ; setting the result to <.boss>\n.exit:\n    ret\n; local read-only strings\n.boss:\n    db    `Hello boss\\0`\n.guest:\n    db    `Hello guest\\0`\n; -----> endof greet <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213102,"user_id":null,"body":"extern strcmp\n\nSECTION .text\nglobal greet\n\ngreet:\n  call strcmp\n  mov rcx, guest\n  mov rdx, boss\n  cmp eax, 0\n  cmove rcx, rdx\n  mov rax, rcx\n  ret\n\nSECTION .data\nboss: db \"Hello boss\", 0\nguest: db \"Hello guest\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213103,"user_id":null,"body":"extern strcmp\n\nSECTION .text\n  global greet\n\ngreet:\n  xor rax, rax\n  call strcmp\n  cmp rax, 0\n  mov rcx, boss\n  mov rdx, guest\n  cmove rax, rcx\n  cmovne rax, rdx\n  ret\n  \nSECTION .data\nboss: \n  db \"Hello boss\", 0\nguest:\n  db \"Hello guest\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"577a98a6ae28071780000989":[{"id":213104,"user_id":null,"body":"global min, max\nmin:\n  mov eax,7FFFFFFFh\n  .b:cmp   eax,[rdi+rsi*4-4]\n     cmovg eax,[rdi+rsi*4-4]\n     dec rsi\n  jne .b   \nret\n\nmax:\n  mov eax,80000000h\n  .b:cmp   eax,[rdi+rsi*4-4]\n     cmovl eax,[rdi+rsi*4-4]\n     dec   rsi\n  jne .b   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213105,"user_id":null,"body":"section .text\nglobal min, max\n\n%macro setup 0\n    cmp esi, 0\n    je .end\n    \n    mov ebx, 0\n    mov ecx, 0\n    mov ebx, dword [rdi]\n%endmacro\n\n%macro body  0\n.loop:\n\n    mov eax, dword [rdi+4*rcx]\n    cmp eax, ebx\n%endmacro\n\n%macro endbody 0\n    mov ebx, eax\n\n.incloop:\n    inc ecx\n    cmp ecx, esi\n    jl .loop\n%endmacro\n\n%macro endf 0\n.end:\n    mov eax, ebx\n    ret\n%endmacro\n\n; int min(int* array [rdi], int arrayLength [esi]); --> [eax]\nmin:\n    setup\n    body\n    jge .incloop\n    endbody\n    endf\n\n; int max(int* array [rdi], int arrayLength [esi]); --> [eax]\nmax:\n    setup\n    body\n    jle .incloop\n    endbody\n    endf","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213106,"user_id":null,"body":"section .text\nglobal min, max\n\nmin:\n  mov eax, [rdi]\n.loop:\n  dec esi\n  test esi, esi\n  jz .exit\n  add rdi, 4\n  mov edx, [rdi]\n  cmp edx, eax\n  cmovl eax, [rdi]\n  jmp .loop\n.exit:\n  ret\n\nmax:\n  mov eax, [rdi]\n.loop:\n  dec esi\n  test esi, esi\n  jz .exit\n  add rdi, 4\n  mov edx, [rdi]\n  cmp edx, eax\n  cmovg eax, [rdi]\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213107,"user_id":null,"body":"section .text\nglobal min, max\n\n; int min(int* array [rdi], int arrayLength [esi]); --> [eax]\nmin:\nxor rax, rax      \nmov rax, [rdi]\nadd rdi, 4\ndec esi\ncmp esi, 0      \nje rdyMin      \nloopMin:\nmov rbx, [rdi] \nadd rdi, 4     \ndec esi        \ncmp eax, ebx     \ncmovg eax, ebx   \ncmp esi, 0      \nje rdyMin         \njmp loopMin\nrdyMin:\nret\n\n; int max(int* array [rdi], int arrayLength [esi]); --> [eax]\nmax:\nxor rax, rax      \nmov rax, [rdi]\nadd rdi, 4\ndec esi\ncmp esi, 0      \nje rdyMax      \nloopMax:\nmov rbx, [rdi] \nadd rdi, 4     \ndec esi        \ncmp eax, ebx     \ncmovl eax, ebx   \ncmp esi, 0      \nje rdyMax         \njmp loopMax\nrdyMax:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213108,"user_id":null,"body":"section .text\nglobal min, max\n\n; int min(int* array [rdi], int arrayLength [esi]); --> [eax]\nglobal min\n\nsection .text\n\nmin:\n    mov eax,[rdi]\nbefore_loop_min:\n    cmp esi,1\n    jg loop_min; if arrayLength>1\n    ret\nloop_min:\n    sub esi,1\n    add rdi,4\n    cmp eax,[rdi]\n    jle before_loop_min\n    mov eax,[rdi]\n    jmp before_loop_min\n    \n; int max(int* array [rdi], int arrayLength [esi]); --> [eax]\nmax:\n    mov eax,[rdi]\nbefore_loop_max:\n    cmp esi,1\n    jg loop_max; if arrayLength>1\n    ret\nloop_max:\n    sub esi,1\n    add rdi,4\n    cmp eax,[rdi]\n    jge before_loop_max\n    mov eax,[rdi]\n    jmp before_loop_max","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213109,"user_id":null,"body":"section .text\n  global min, max\n\nmin:\n  mov rax,[rdi]\n  \n  loop1:\n  dec rsi\n  \n  mov ebx,[rdi+rsi*4]\n  cmp ebx,eax\n  cmovl eax,ebx\n  \n  cmp rsi,0\n  jg loop1\nret\n\nmax:\n  mov rax,[rdi]\n  \n  loop2:\n  dec rsi\n  \n  mov ebx,[rdi+rsi*4]\n  cmp ebx,eax\n  cmovg eax,ebx\n  \n  cmp rsi,0\n  jg loop2\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213110,"user_id":null,"body":"section .text\nglobal min, max\n\n\nmin:\n    mov eax, 0x7FFFFFFF\n.first_loop:\n    dec rsi\n    cmp [rdi + rsi * 4], eax\n    jg .not_change\n    mov eax, [rdi + rsi * 4]\n.not_change:\n    cmp rsi, 0\n    jne .first_loop\n    ret\n\nmax:\n    mov eax, 0xFFFFFFFF\n.first_loop:\n    dec rsi\n    cmp [rdi + rsi * 4], eax\n    jng .not_change\n    mov eax, [rdi + rsi * 4]\n.not_change:\n    cmp rsi, 0\n    jne .first_loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213111,"user_id":null,"body":"section .text\nglobal min, max\n\n; int min(int* array [rdi], int arrayLength [esi]); --> [eax]\nmin:\n  mov eax, 0x7FFFFFFF\n.loop:\n  mov ecx, [rdi + rsi * 4 - 4]\n  cmp ecx, eax\n  cmovl eax, ecx\n  dec esi\n  jnz .loop\n  ret\n\n; int max(int* array [rdi], int arrayLength [esi]); --> [eax]\nmax:\n  mov eax, 0xFFFFFFF8\n.loop:\n  mov ecx, [rdi + rsi * 4 - 4]\n  cmp ecx, eax\n  cmovg eax, ecx\n  dec esi\n  jnz .loop\n  ret\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213112,"user_id":null,"body":"section .text\nglobal min, max\n\n; int min(int* array [rdi], int arrayLength [esi]); --> [eax]\nmin:\n  mov eax, esi\n  lea rcx, [rdi + 4*rax]\n  mov eax, [rdi]\n.loop:\n  add rdi, 4\n  cmp rdi, rcx\n  jae .done\n  mov edx, [rdi]\n  cmp edx, eax\n  cmovl eax, edx\n  jmp .loop\n.done:\n  ret\n  \nmax:\n  mov eax, esi\n  lea rcx, [rdi + 4*rax]\n  mov eax, [rdi]\n.loop:\n  add rdi, 4\n  cmp rdi, rcx\n  jae .done\n  mov edx, [rdi]\n  cmp edx, eax\n  cmovg eax, edx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213113,"user_id":null,"body":"section .text\nglobal min, max\n\n; int min(int* array [rdi], int arrayLength [esi]); --> [eax]\nmin:\n    mov   eax, 7FFFFFFFh\n.b: cmp   eax, [rdi + rsi * 4 - 4]\n    cmovg eax, [rdi + rsi * 4 - 4] ;Move if greater (ZF=0 and SF=OF).\n    dec   rsi\n    jne  .b ;(ZF = 0)\tJump if Not Equal\n    ret\n\n; int max(int* array [rdi], int arrayLength [esi]); --> [eax]\nmax:\n    mov   eax, 80000000h\n.b: cmp   eax, [rdi + rsi * 4 - 4]\n    cmovl eax, [rdi + rsi * 4 - 4]\n    dec   rsi\n    jne  .b\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"577bd026df78c19bca0002c0":[{"id":213114,"user_id":null,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:  \n  mov    ecx, 0\n  \nloop_string:\n  cmp    byte [rdi], '0'\n  je     o_exchange\n  cmp    byte [rdi], '5'\n  je     s_exchange\n  cmp    byte [rdi], '1'\n  je     i_exchange\n  cmp    byte [rdi], `\\0`\n  jne    increment\n  jmp    reset\n  \nincrement:\n  add    ecx, 1\n  inc    rdi\n  jmp    loop_string\n\nreset:\n  dec    rdi\n  sub    ecx, 1\n  cmp    ecx, 0\n  je     exit\n  jmp    reset\n  \nexit:\n  mov    rax, rdi\n  ret\n\no_exchange:\n  mov    byte [rdi], 'O'\n  jmp    increment\n  \ns_exchange:\n  mov    byte [rdi], 'S'\n  jmp    increment\n  \ni_exchange:\n  mov    byte [rdi], 'I'\n  jmp    increment","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213115,"user_id":1196,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  mov rax, rdi\n  xor rcx, rcx\n  xor edx, edx\n.loop:\n  mov dl, byte [rdi+rcx]\n  test dl, dl\n  jz .exit\n  cmp dl, '0'\n  jl .next\n  cmp dl, '5'\n  jg .next\n  sub dl, '0'\n  mov dl, byte [table+edx]\n  mov byte [rdi+rcx], dl\n.next:\n  inc rcx\n  jmp .loop\n.exit:\n  ret\n\nSECTION .data\ntable: db \"OI234S\"\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213116,"user_id":1027,"body":"SECTION .code\nglobal correct\ncorrect:\n  mov rax,rdi\n  xor rcx,rcx\n.loop:\n  mov bl,'0'\n  cmp byte[rdi+rcx],'0'\n  jnz .1\n  mov byte[rdi+rcx],'O'\n.1:\n  cmp byte[rdi+rcx],'5'\n  jnz .2\n  mov byte[rdi+rcx],'S'\n.2:\n  cmp byte[rdi+rcx],'1'\n  jnz .3\n  mov byte[rdi+rcx],'I'\n.3:\n  inc rcx\n  cmp byte[rdi+rcx],0\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213117,"user_id":null,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  mov rcx,-1\n  loop1:\n  inc rcx\n  cmp byte[rdi+rcx],0\n  je end\n  cmp byte[rdi+rcx],'5'\n  jne skip5\n  add byte[rdi+rcx],30\n  jmp loop1\n  skip5:\n  cmp byte[rdi+rcx],'0'\n  jne skipz\n  add byte[rdi+rcx],31\n  jmp loop1\n  skipz:\n  cmp byte[rdi+rcx],'1'\n  jne loop1\n  add byte[rdi+rcx],24\n  jmp loop1\n  end:\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213118,"user_id":null,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  mov rax, rdi\n  mov r9b, 'S'\n  mov r10b, 'I'\n  mov r11b, 'O'\n  jmp .cond\n  .loop:\n  mov cl, sil\n  sub cl, 48\n  cmp cl, 5\n  ja .continue\n  cmove esi, r9d\n  cmp cl, 1\n  cmove esi, r10d\n  cmovb esi, r11d\n  mov [rdi], sil\n  .continue:\n  inc rdi\n  .cond:\n  mov sil, [rdi]\n  test sil, sil\n  jnz .loop\n  .exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213119,"user_id":null,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  mov rax, rdi\n  mov r9b, 'S'\n  mov r10b, 'I'\n  mov r11b, 'O'\n  jmp .cond\n  .loop:\n  mov cl, sil\n  sub cl, 48\n  cmp cl, 5\n  ja .continue\n  cmove esi, r9d\n  cmp cl, 1\n  cmove esi, r10d\n  test cl, cl\n  cmovz esi, r11d\n  .continue:\n  mov [rdi], sil\n  inc rdi\n  .cond:\n  mov sil, [rdi]\n  test sil, sil\n  jnz .loop\n  .exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213120,"user_id":null,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  mov rax, rdi\n  lea r8, [.smap]\n  mov rdx, rdi\n.loop:\n  movzx esi, byte [rdx]\n  test rsi, rsi\n  je .done\n  lea edi, [rsi - 48]\n  cmp dil, 5\n  ja .over5\n  add esi, -48\n  mov cl, [rsi + r8]\n  mov byte [rdx], cl\n.over5:\n  inc rdx\n  jmp .loop\n.done:\n  ret\n.smap: db \"OI234S\"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213121,"user_id":null,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  push rdi\n  mov rax, rdi\n  .loop:\n  cmp [rdi], byte 0\n  je .end\n  cmp [rdi], byte '0'\n  je .O\n  cmp [rdi], byte '5'\n  je .S\n  cmp [rdi], byte '1'\n  je .I\n  .next:\n  inc rdi\n  jmp .loop\n  .end:\n  pop rdi\n  ret\n  \n  .O:\n  mov [rdi], byte 'O'\n  jmp .next\n  .S:\n  mov [rdi], byte 'S'\n  jmp .next\n  .I:\n  mov [rdi], byte 'I'\n  jmp .next\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213122,"user_id":50,"body":"; Please modify the string in-place and return it.\nSECTION .text\nglobal correct\n\ncorrect:\n  push rdi ; save pointer to output in stack\n  xor rbx,rbx\n  dec rdi\n_loop:\n  inc rdi\n  mov bl,[rdi]\n  test bl,bl\n  jz _exit\n  cmp bl,'0'\n  je _replace0\n  cmp bl,'5'\n  je _replace5\n  cmp bl,'1'\n  je _replace1\n  jmp _loop\n_replace1:\n  mov byte[rdi],'I'\n  jmp _loop\n_replace5:\n  mov byte[rdi],'S'\n  jmp _loop\n_replace0:\n  mov byte[rdi],'O'\n  jmp _loop\n_exit:\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213123,"user_id":76,"body":"SECTION .text\nglobal correct\n\ncorrect:\n  mov rax, rdi\n  mov rbx, rdi\n.loop:\n  cmp byte [rdi], 0\n  je .ret\n  mov al, byte [rdi]\n  cmp al, '5'\n  jne .o\n  mov byte [rdi], 'S'\n.o:\n  cmp al, '0'\n  jne .i\n  mov byte [rdi], 'O'\n.i:\n  cmp al, '1'\n  jne .continue\n  mov byte [rdi], 'I'\n.continue:\n  inc rdi\n  jmp .loop\n.ret:\n  mov rax, rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"578553c3a1b8d5c40300037c":[{"id":213124,"user_id":527,"body":"section .text\nglobal binary_array_to_number\nbinary_array_to_number:\n                xor     eax, eax\n.loop:          shl     eax, 1\n                or      eax, [rdi]\n                add     rdi, 4\n                dec     rsi\n                jnz     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213125,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\n\n; Returns an integer represented by the passed-in array of integers 0 or 1\n; arg0         = (int32_t*) The array\n; arg1         = (size_t)   The length of the array (guaranteed range of 1 inclusive to 32 inclusive)\n; return value = (int32_t)  The integer represented by the array\nbinary_array_to_number:\n  xor rax, rax\n  mov rcx, rsi\n.next_bit:\n  bt dword [rdi], 0\n  rcl eax, 1\n  add rdi, 4\n  loop .next_bit\n  \n  \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213126,"user_id":null,"body":"global binary_array_to_number\n\nsection .text\n\n; <----- unsigned binary_array_to_number(const unsigned *bits, size_t count) ----->\nbinary_array_to_number:\n    xor rax, rax        ; resetting RAX as <num>\n    test rsi, rsi       ; if there are no bits to handle\n    je .exit            ; jumping to exit\n.loop:\n    shl rax, 0h1        ; shifting <num> by one bit\n    or rax, [rdi]       ; adding a rightmost bit to <num>\n    add rdi, 4          ; pointing <bits> to the next bit\n    dec rsi             ; decrementing <count>\n    jne .loop           ; jumping to the next iteration if still there are bits to handle\n.exit:\n    ret\n; ---------> end of bintonum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213127,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\n\n; Returns an integer represented by the passed-in array of integers 0 or 1\n; arg0         = (int32_t*) The array\n; arg1         = (size_t)   The length of the array (guaranteed range of 1 inclusive to 32 inclusive)\n; return value = (int32_t)  The integer represented by the array\nbinary_array_to_number:\n  xor eax, eax\n  .loop:\n    bt dword [rdi], 0\n    adc eax, eax\n    sub esi, 1\n    lea rdi,[rdi+4]\n    jnz .loop  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213128,"user_id":null,"body":"SECTION .text\n  global binary_array_to_number\n\nbinary_array_to_number:\n  mov eax,0\n  mov ebx,-1\n  \n  loop1:\n  dec esi\n  inc ebx\n  \n  cmp dword[rdi+rsi*4],0\n  je skip1\n  \n  bts eax,ebx\n  \n  skip1:\n  cmp esi,0\n  jg loop1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213129,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\n\nbinary_array_to_number:\n  lea ecx, [rsi - 1]\n  mov r8, 1\n  shl r8, cl\n  xor ecx, ecx\n  xor eax, eax\n.loop:\n  sub rsi, 1\n  jb .down\n  cmp dword [rdi], 0\n  mov rdx, r8\n  cmove rdx, rcx\n  sar r8, 1\n  add rdi, 4\n  or rax, rdx\n  jmp .loop\n.down:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213130,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\n\n; Returns an integer represented by the passed-in array of integers 0 or 1\n; arg0         = (int32_t*) The array\n; arg1         = (size_t)   The length of the array (guaranteed range of 1 inclusive to 32 inclusive)\n; return value = (int32_t)  The integer represented by the array\nbinary_array_to_number:\n  xor eax, eax\n  lea rcx, [rdi + rsi * 4]\n.loop:\n  cmp rcx, rdi\n  je .exit\n  shl eax, 1\n  or eax, [rdi]\n  add rdi, 4\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213131,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\n\n; Returns an integer represented by the passed-in array of integers 0 or 1\n; arg0         = (int32_t*) The array\n; arg1         = (size_t)   The length of the array (guaranteed range of 1 inclusive to 32 inclusive)\n; return value = (int32_t)  The integer represented by the array\nbinary_array_to_number:\n  xor eax, eax\n  lea rcx, [rdi + rsi * 4]\n.loop:\n  cmp rcx, rdi\n  je .exit\n  shl eax, 1\n  mov edx, [rdi]\n  or eax, edx\n  add rdi, 4\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213132,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\nextern puts,printf\n\n;formatstr db \"Input is a-%d, b-%d\",0\nformat db '%d',0\n\nbinary_array_to_number:\n\nmov rax,rsi ;rsi contains length of array\ndec rax ;index starts at zero so subtract 1\nmov rbx,4 ;multiply with 4, because that's how the values are stored(rdi+4,+8,etc.)\nmul rbx\nmov rcx,rax ;mov the value to rcx, because rcx is typically used for counting\n\nmov rax,0\nmov rbx,0\nset_bits:\ncmp byte[rdi+rcx],0\nje skip_set\nbts rax,rbx\nskip_set:\ninc rbx\nsub rcx,4\ncmp rcx,0\njge set_bits\n\n;mov rsi,[rdi] ;rdi contains the array values at intervals of 4 (rdi+4,+8,etc.)\n;mov rsi,rax\n;mov rdi,format\n;sub rsp,8\n;call printf\n;add rsp,8\n\n;mov eax,0\n  ret\n  \n  ; Returns an integer represented by the passed-in array of integers 0 or 1\n; arg0         = (int32_t*) The array\n; arg1         = (size_t)   The length of the array (guaranteed range of 1 inclusive to 32 inclusive)\n; return value = (int32_t)  The integer represented by the array","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213133,"user_id":null,"body":"SECTION .text\nglobal binary_array_to_number\n\n; Returns an integer represented by the passed-in array of integers 0 or 1\n; arg0         = (int32_t*) The array\n; arg1         = (size_t)   The length of the array (guaranteed range of 1 inclusive to 32 inclusive)\n; return value = (int32_t)  The integer represented by the array\nbinary_array_to_number:\n  xor eax, eax\n  xor rcx, rcx\n.loop:\n  cmp rcx, rsi\n  je .return\n  mov edx, [rdi + 4 * rcx]\n  shl eax, 1\n  or eax, edx\n  inc rcx\n  jmp .loop\n.return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a049e253ba33ac5e000212":[{"id":213134,"user_id":null,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n  xor rdx, rdx    ; RDX <- the high 64bits of result\n  mov rax, 1    ; RAX <- the low 64bits of result\n  mov rbx, 1\nloop:\n  inc rbx\n  cmp rbx, rdi\n  jg end\n  mov r10, rdx\n  mul rbx\n  imul r10, rbx\n  add rdx, r10\n  jmp loop\nend:\n  ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213135,"user_id":null,"body":"global factorial\n\nsection .text\n\nfactorial:\n  mov ecx, 2\n  mov eax, 1\n  xor edx, edx\n.loop:\n  cmp edi, ecx\n  jb .done\n  mov esi, ecx\n  mov r8, rdx\n  inc ecx\n  imul r8, rsi\n  mul rsi\n  add rdx, r8\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213136,"user_id":null,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n  xor edx, edx\n  mov eax, 1\n  test edi, edi\n  jz .done\n  \n.loop:\n  mov rcx, rdx\n  mul rdi\n  imul rcx, rdi\n  add rdx, rcx\n  dec edi\n  test edi, edi\n  jnz .loop\n  \n.done:\n  ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213137,"user_id":50,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n  xor rdx, rdx    ; RDX <- the high 64bits of result\n   ; xor rax, rax    ; RAX <- the low 64bits of result\n  mov rax,1\n_loop:\n  cmp edi,2\n  jl _exit\n  imul rdx,rdi\n  mov r9,rdx\n  mul rdi\n  add rdx,r9\n  dec rdi\n  jmp _loop\n_exit:\n  ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213138,"user_id":null,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n    xor edx, edx    ; RDX <- the high 64bits of result\n    lea eax, [edx+1]; RAX <- the low 64bits of result \n    test edi,edi\n    je end\nloop:\n    mov rcx, rdx\n    imul rcx,rdi\n    mul rdi\n    add rdx, rcx\n    dec edi\n    jne loop\nend:\n    ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213139,"user_id":null,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n    xor rdx, rdx    ; RDX <- the high 64bits of result, init to 0\n    mov rax, 1    ; RAX <- the low 64bits of result, init to 1\n    test rdi, rdi ; return 1 if input is 0\n    jz end\n    loop:\n    ; mul high bits\n    mov r8, rax\n    mov rax, rdx\n    mul rdi\n    mov r9, rax\n    mov rax, r8\n    \n    ; mul low bits\n    mul rdi\n    \n    ; add high bits\n    add rdx, r9\n    \n    dec rdi\n    jnz loop\n    end:\n    ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213140,"user_id":3088,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n    xor rdx, rdx    ; RDX <- the high 64bits of result\n    mov rax, 1      ; RAX <- the low 64bits of result\n    mov rcx, rdi\n    \n.loop:\n    cmp rcx, 0\n    je  .end\n    mov rdi, rdx    ; Use RDI for high 64 bits of current multiplication\n    imul rdi, rcx\n    mul rcx\n    add rdx, rdi\n    dec rcx\n    jmp .loop\n    \n.end:\n    ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213141,"user_id":null,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n  xor edx, edx    ; RDX <- the high 64bits of result\n  mov eax, 1      ; RAX <- the low 64bits of result\n  \n  cmp edi, 2\n  jb L_exit\n  \n  ; Perform the first few multiplications with 64x64 -> 64bit product.\n  mov ecx, 20\n  cmp edi, ecx\n  cmovb ecx, edi\n\nL_single_loop:\n  imul rax, rcx\n  \n  dec ecx\n  jnz L_single_loop\n  \n  cmp edi, 20\n  jbe L_exit\n  \n  ; Rest has to be done with 128-bit multiplication.\n  xor esi, esi\n\nL_double_loop:\n  mul rdi\n  imul rsi, rdi\n  add rsi, rdx\n  \n  dec edi\n  cmp edi, 20\n  jne L_double_loop\n  \n  mov rdx, rsi\n\nL_exit:\n  ret\n; ---------> endof factorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213142,"user_id":null,"body":"global factorial\n\nsection .text\n\n; <--- unsigned __int128 factorial(unsigned num) --->\nfactorial:\n    xor rdx, rdx    ; RDX <- the high 64bits of result\n    xor rax, rax    ; RAX <- the low 64bits of result\n   \n    mov rax, 1  \n    mov qword [lo], rax\n    mov qword [hi], rdx\n\nloop:\n    cmp rdi, 0\n    jg cont\n    mov rax, qword [lo]\n    mov rdx, qword [hi]\n    ret\ncont:\n    mov rax, qword [lo]    ; load lo 64 bits in rax\n    xor rdx, rdx           ; clear rdx\n    mul rdi                ;  multi lo 64 bits\n    mov qword [lo], rax    ;  store lo 64 bits\n    mov qword [hitemp], rdx  ; store carry\n    mov rax, qword[hi]     ; load hi 64 bits\n    xor rdx, rdx\n    mul rdi               ; multi hi 64 bits\n    add rax, qword [hitemp] ; add carry\n    mov qword [hi], rax    ; store hi 64 bits\n    dec rdi               ; dec counter\n    jmp loop              ; goto beginning of loop\n; ---------> endof factorial <---------\nsection .bss\nlo: resb 8\nhi: resb 8\nhitemp: resb 8","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213143,"user_id":1088,"body":"\nglobal factorial\nsection .text\n\n; unsigned __int128 factorial(unsigned num);\nfactorial:\n\tcmp\tedi, 1\n\tjbe\t.f_out\n\tmov\teax, edi\n\txor\tecx, ecx\n\tadd\tedi, -1\n\tcmp\tedi, 2\n\tjb\t.f_outc\n.f_loop:\n\tmov\tedx, edi\n\timul\trcx, rdx\n\tmul\trdx\n\tadd\trcx, rdx\n\tadd\tedi, -1\n\tcmp\tedi, 2\n\tjae\t.f_loop\n.f_outc:\n\tmov\trdx, rcx\n\tret\n.f_out:\n\tmov\teax, 1\n\tcdq\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a0e5c372292dd76d000d7e":[{"id":213144,"user_id":null,"body":"SECTION .text\nglobal string_repeat\nextern malloc\nextern strlen\n\nstring_repeat:\n  push rsi ;src\n  push rdi ;n\n  push rdi ;n\n  mov rdi, rsi\n  call strlen\n  pop rcx ;n\n  mul rcx\n  add rax, 1\n  mov rdi, rax\n  call malloc\n  mov rdi, rax ;dest\n  pop rcx ;n\n  pop rsi ;src\n  \n  .loop:\n    test rcx, rcx\n    jz .end\n    push rsi\n  .copy:\n    mov dl, [rsi]\n    test dl, dl\n    jz .endcopy\n    mov [rdi], dl\n    inc rdi\n    inc rsi\n    jmp .copy\n  .endcopy:\n    pop rsi\n    dec rcx\n    jnz .loop\n  \n  .end:\n    mov BYTE [rdi], 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213145,"user_id":null,"body":"extern malloc\nextern printf\nSECTION .text\nglobal string_repeat\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nLen:\n    ;rdi - const char*\n    push rbp\n    mov rbp, rsp\n    mov rcx, -1\n    xor rax,rax\n    repne scasb\n    not rcx\n    dec rcx\n    mov rax, rcx\n    mov rsp, rbp\n    pop rbp\n    ret\n    \ncopy:\n    ; rdi - dst\n    ; rsi - src\n    push rbp\n    mov rbp, rsp\n    repne movsb\n    mov rsp, rbp\n    pop rbp\n    ret\n    \nstring_repeat:\n    push rbp\n    mov rbp, rsp\n    push rdi\n    push rsi\n    \n    mov rdi, rsi\n    call Len\n    push rax\n    mov rdi, rax\n    imul rdi, qword [rbp-8]\n    inc rdi\n    call malloc\n    mov rdi, rax\n    mov r8, qword[rbp-8]\n    \n.while:\n    cmp r8, 0\n    jle .end\n    mov rcx, qword [rbp-24]\n    mov rsi, qword [rbp-16]\n    call copy\n    dec r8\n    jmp .while\n    \n.end:\n    mov byte [rdi], 0\n    mov rdi, rax\n    \n    pop rsi\n    pop rsi\n    pop rdi\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213146,"user_id":null,"body":"SECTION .text\nglobal string_repeat\n\nextern malloc\nstring_repeat:\n  push r12\n  push r13\n  push r14\n  mov r12, rdi\n  mov r13, rsi\n  test r12, r12\n  je .empty\n  cmp byte [r13], 0\n  je .empty\n  xor r14d, r14d\n  mov rax, r13\n.seekend:\n  inc rax\n  inc r14\n  cmp byte [rax], 0\n  jne .seekend\n  mov rdi, r12\n  imul rdi, r14\n  inc rdi\n  call malloc\n  mov rdx, rax\n  jmp .lastchar\n.nextrep:\n  dec r12\n  test r14, r14\n  je .lastchar\n  mov rdi, rdx\n  mov rsi, r13\n  mov rcx, r14\n  rep movsb\n  add rdx, r14\n.lastchar:\n  test r12, r12\n  jne .nextrep\n  mov byte [rdx], 0\n  jmp .done\n.empty:\n  xor edi, edi\n  inc rdi\n  call malloc\n  mov byte [rax], 0\n.done:\n  pop r14\n  pop r13\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213147,"user_id":null,"body":"SECTION .text\nglobal  string_repeat\nextern  malloc\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nstring_repeat:\n\n    ;get length of the given string -> rcx\n    push  rsi\n    mov   rcx,-1\n.loop1:\n    inc   rcx\n    lodsb\n    cmp   al,0\n    jne   .loop1\n\n    ;allocate mem for the new string -> rax\n    push  rdi\n    cmp   rdi,0\n    jge   .num_ok\n    xor   rdi,rdi\n.num_ok:\n    mov   rax,rdi\n    mul   ecx\n    inc   eax\n    mov   rdi,rax\n    call  malloc\n    pop   rdi\n    pop   rsi\n    push  rax\n\n    ;repeat the original string\n    mov   rcx,rdi\n    mov   rdi,rax\n.loop2:\n    cmp   rcx,0\n    je    .end\n    call  write\n    dec   rcx\n    jmp   .loop2\n.end:\n    mov   byte[rdi],0\n    pop   rax\n    ret\n    \nwrite:\n    push  rsi\n.loop:\n    lodsb\n    cmp   al,0\n    je    .end\n    stosb\n    jmp   .loop\n.end:\n    pop   rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213148,"user_id":null,"body":"extern strlen\nextern malloc\n\nSECTION .text\nglobal string_repeat\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nstring_repeat:\n  push rdi\n  push rsi\n  push rdi\n  mov rdi, rsi\n  call strlen\n  pop rdi\n  push rax\n  imul rax, rdi\n  inc rax\n  mov rdi, rax\n  call malloc\n  pop r11\n  pop rsi\n  pop rdi\n  cmp rdi, 0\n  jle .empty\n  cmp r11, 0\n  jle .empty\n  xor r10, r10\n.loop:\n    xor rcx, rcx\n.copystring: \n      mov r8, r10\n      imul r8, r11\n      add r8, rcx\n      movzx rdx, byte [rsi+rcx]   \n      mov [rax+r8], dl\n      inc rcx\n      cmp rcx, r11\n      jne .copystring\n    inc r10\n    cmp r10, rdi ; times to copy\n    jne .loop\n  mov r8, rdi\n  imul r8, r11\n  mov [rax+r8], byte 0\n  ret\n.empty:\n  mov [rax], byte 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213149,"user_id":null,"body":"extern malloc\n\nSECTION .text\nglobal string_repeat\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\n\nstr_size:\n    xor rax, rax\nlp_3:\n    mov bl, [rsi + rax]\n    cmp bl, 0\n    je end_str_size\n    inc rax\n    jmp lp_3\nend_str_size:\n    ret\n\nstring_repeat:\n    push rbp\n    mov rbp, rsp\n\n    push rdi\n    push rsi\n\n    call str_size\n    mul rdi\n\n    mov rdi, rax\n    call malloc\n    pop rsi\n    pop rdi\n\n    mov rcx, rdi\n    xor rdx, rdx\n    cmp rcx, 0\n    je end\n\nlp_1:\n    mov r8, rsi\nlp_2:\n    mov bl, [r8]\n    inc r8\n    cmp bl, 0\n    je next_sent\n\nnext_sym:\n    mov [rax + rdx], bl\n    inc rdx\n    jmp lp_2\n\nnext_sent:\n    dec rcx\n    cmp rcx, 0\n    jne lp_1\n\nend:\n    mov byte [rax + rdx], 0\n\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213150,"user_id":null,"body":"SECTION .text\nextern malloc\nextern strlen\n\nglobal string_repeat\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      repeating\n;  arg1         = (const char*) src\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nstring_repeat:\n    push      r12\n    push      r13\n    mov       r12, rsi            ; src\n    mov       r13, rdi            ; repeating\n\n    mov       rdi, rsi\n    call      strlen\n    \n    push      r14\n    mov       r14, rax            ; srclen = strlen(src)\n    \n    imul      rax, r13\n    inc       rax\n    \n    mov       rdi, rax\n    call      malloc\n    \n    mov       rdi, rax\n    \n.for_0:    \n    test      r13, r13\n    jz        .end_for\n    \n    mov       rsi, r12\n    mov       rcx, r14\n    rep       movsb\n    \n    dec       r13\n    jmp       .for_0\n\n.end_for:\n    \n    mov       [ rdi ], byte 0\n    pop       r14\n    pop       r13\n    pop       r12\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213151,"user_id":null,"body":"SECTION .text\nextern malloc\n\nglobal string_repeat\n\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nstring_repeat:\n        push    r12           \n        push    rbp\n        push    rbx\n        \n        mov     r12, rdi      ; r12 - repeating\n        mov     rbx, rsi      ; rbx - src string\n        \n        xor     al, al\n.search_0:                      ; strlen(src)\n        cmp     al, [ rsi ]\n        jz      .strlen\n        inc     rsi\n        jmp     .search_0\n.strlen:        \n        mov     rax, rsi\n        sub     rax, rbx       \n        \n        mov     rbp, rax        ; rbp - srclen\n        imul    rax, r12\n        inc     rax\n        mov     rdi, rax\n        call    malloc\n        \n; rbx - src ; rbp - srclen  ; rax - result string ; r12 - repeating\n        mov     rdi, rax          ; dest\n        mov     r8, rax           ; r8 = dest\n.while: \n        test    r12, r12          ; while(repeat !=0)\n        jz      .end_while\n        \n        mov     rsi, rbx          ; src\n        mov     rcx, rbp          ; count = srclen\n        \n.memcpy: ; memcpy()\n        mov     al, [ rsi ]\n        mov     [ rdi ], al       ; *dest = *src\n        inc     rsi               ; src++\n        inc     rdi               ; dst++\n        dec     rcx               ; count --\n        test    rcx, rcx\n        jnz     .memcpy\n        dec     r12\n        jmp     .while\n        \n.end_while:\n        xor     al, al\n        mov     [ rdi ], al\n        mov     rax, r8\n        pop     rbx\n        pop     rbp\n        pop     r12\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213152,"user_id":null,"body":"extern malloc\n\nSECTION .text\nglobal string_repeat\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nstring_repeat:\n  cmp rdi, 0\n  jnz .strlen\n  mov r10, 1\n  mov rcx, 1\n  jmp .allocate\n  \n.strlen:\n  push rdi\n  mov rdi, rsi\n  xor rax, rax\n  mov rcx, 0x03ffff\n  cld\n  repne scasb\n  sub rcx, 0x03ffff\n  neg rcx\n  dec rcx\n  pop rdi\n  \n  mov r10, rdi\n  \n.allocate:\n  push rdi\n  push rsi\n  push rcx\n  mov rdi, r10\n  imul rdi, rcx\n  shl rdi, 8\n  call malloc\n  pop rcx\n  pop rsi\n  pop rdi\n  \n  xor r8, r8\n  cmp rdi, 0\n  jz .exit\n  \n.repeat:\n  push rcx\n  xor r9, r9 \n  \n.copy:\n  mov dl, byte [rsi + r9]\n  mov byte [rax + r8], dl\n  inc r8\n  inc r9\n  dec rcx\n  jnz .copy  \n  pop rcx\n  dec rdi\n  jnz .repeat\n  \n.exit:\n  mov byte [rax + r8], 0\n  ret\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213153,"user_id":null,"body":"default rel\n\nSECTION .text align=16\nglobal string_repeat\nextern malloc\n\n\n;  Returns a string repeated arg1 times.\n;  Note: Please return a pointer to the new string which was allocated by C's malloc.\n;  arg0         = (size_t)      The number of times to repeat.\n;  arg1         = (const char*) The original string.\n;  return value = (char*)       New string which holds the value of arg0 repeated arg1 times.\nstring_repeat:\n  lea r8, [rsi]   ; originalString\n  mov r9, rdi   ; timesToRepeat\n  \n  mov rcx, -1\n  .strSize:\n  inc rcx\n  cmp byte [r8 + rcx], 0\n  jne .strSize\n  \n  mov r10, rcx   ; originalStringLength\n  \n  \n  mov rax, r9\n  mul rcx\n  inc rax       ; sizeToMalloc\n  \n  \n  push r8\n  push r9\n  push r10\n  push rax\n  mov rdi, rax\n  call malloc\n  \n  lea rdi, [rax]; resultStr\n \n  pop rax\n  pop r10\n  pop r9\n  pop r8\n  \n  \n  mov rdx, 0\n  lea rsi, [r8]\n  \n  \n  .loop:\n    cmp r9, 0 \n    je .end\n    dec r9\n\n    mov rcx, 0\n    .inner:\n      cmp  rcx, r10 \n      je .loop\n      mov al, [rsi + rcx]\n      mov byte [rdi + rdx], al\n      inc rcx\n      inc rdx\n      jmp .inner\n\n    \n  .end:\n    mov rax, 0\n    mov byte [rdi + rdx], al\n    lea rsi, [rdi]\n    lea rax, [rdi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a153e872292d7c030009d4":[{"id":213154,"user_id":null,"body":"global simple_transposition\nextern malloc\n\nsection .text\n\n; <--- char *simple_transposition(const char *s) --->\nsimple_transposition:   \n     \n    mov rbx,rdi\n.loop_len:    ;Str len\n    mov  al,[rbx]\n    cmp al,0\n    jz   .end_len  \n    inc  rbx            \n    jmp .loop_len\n.end_len:    ;rcx is the len i need\n    sub rbx,rdi\n    mov rcx,rbx\n\n    push rdi\n    push rcx\n    \n    lea rdi,[rcx+1]\n    call malloc    ;malloc memory\n    mov rdi,rax\n    \n    pop rcx\n    pop rsi\n    \n    \n    xor rbx,rbx\n    push rdi    \n.loop:\n    mov al,[rsi+rbx]\n    stosb\n    add rbx,2\n    cmp rbx,rcx\n    jb .loop\n    \n    mov rbx,1\n    \n.loop2:\n    mov al,[rsi+rbx]\n    stosb\n    add rbx,2\n    cmp rbx,rcx\n    jb .loop2\n    \n    mov al,0\n    stosb\n    \n    pop rax\n    ret\n; ---------> endof simple_transposition <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213155,"user_id":null,"body":"global simple_transposition\nextern malloc, strlen\n\nsection .text\n\n; <--- char *simple_transposition(const char *s) --->\nsimple_transposition:\n    sub rsp, 0h18           ; reserving space for local variables\n    xor eax, eax            ; resetting RAX in case <s> is null\n    test rdi, rdi           ; whether <s> is null\n    je .exit                ; jumping to exit\n    mov [rsp], rdi          ; saving <s> in the local storage\n    call strlen             ; getting the <s> length as <n>\n    mov [rsp+8], rax        ; saving <n> in the local storage\n    lea rdi, [rax+1]        ; the bytes to allocate for <trans>\n    call malloc             ; allocating memory\n    test rax, rax           ; whether the memory allocated\n    je .exit                ; otherwise, jumping to exit\n    mov rdi, [rsp]          ; restoring the pointer to <s>\n    mov rsi, [rsp+8]        ; restoring <n>\n    mov byte [rax+rsi], 0   ; terminating <*(trans+n)>\n    inc rsi                 ; incrementing <n>\n    shr rsi, 1              ; dividing <n> by two\n    xor r8d, r8d            ; resetting R8 as <i>\n    xor ecx, ecx            ; resetting CX as <shf>\n.loop:\n    mov dl, [rdi]           ; copying <*s> to DL as <c>\n    inc rdi                 ; pointing <s> to the next character\n    test dl, dl             ; whether <c> is the null character\n    je .exit                ; jumping to exit\n    mov r9, r8              ; copying <i> to R9 as <inx>\n    test cl, cl             ; whether <shf> is not set\n    sete cl                 ; setting <shf>\n    je .cpy                 ; jumping to the .cpy label\n    add r9, rsi             ; adding <n> to <inx>\n    inc r8                  ; incrementing <n>\n.cpy:\n    mov [rax+r9], dl        ; copying <c> to <*(trans+inx)>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    add rsp, 0h18           ; restoring the stack boundary\n    ret\n; ---------> endof simple_transposition <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213156,"user_id":null,"body":"global simple_transposition\nextern malloc, strlen\n\nsection .text\n\n; <--- char *simple_transposition(const char *s) --->\nsimple_transposition:\n  sub rsp, 24\n  mov [rsp], rdi\n  call strlen\n  mov [rsp+8], eax\n  lea edi, [rax+1]\n  call malloc\n  test rax, rax\n  jz .bailout\n  \n  mov ecx, [rsp+8]\n  mov rsi, [rsp]\n  mov rdi, rax\n  test ecx, ecx\n  jle .next\n.loop1:\n  mov dl, [rsi]\n  mov [rdi], dl\n  inc rdi\n  add rsi, 2\n  sub ecx, 2\n  jg .loop1\n  \n.next:\n  mov ecx, [rsp+8]\n  mov rsi, [rsp]\n  inc rsi\n  dec ecx\n  jle .done\n.loop2:\n  mov dl, [rsi]\n  mov [rdi], dl\n  inc rdi\n  add rsi, 2\n  sub ecx, 2\n  jg .loop2\n  \n.done:\n  mov byte [rdi], 0\n.bailout:\n  add rsp, 24\n  ret\n; ---------> endof simple_transposition <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213157,"user_id":null,"body":"global simple_transposition\nextern malloc, strlen\n\nsection .text\n\n; <--- char *simple_transposition(const char *s) --->\nsimple_transposition:    \n  push r12\n  mov r12, rdi\n  push rbp\n  push rbx\n  call strlen\n  lea rbx, [rax+1]\n  mov rbp, rax\n  mov rdi, rbx\n  call malloc\n  xor edx, edx\n.row1:\n  lea rcx, [rdx+rdx]\n  cmp rcx, rbp\n  jnb .end1\n  mov cl, [r12+rdx*2]\n  mov [rax+rdx], cl\n  inc rdx\n  jmp .row1\n.end1:\n  shr rbx, 1\n  mov ecx, 1\n  lea rdx, [rax+rbx]\n  mov rsi, rdx\n.row2:\n  cmp rcx, rbp\n  jnb .end2\n  mov dil, [r12+rcx]\n  inc rdx\n  add rcx, 2\n  mov [rdx-1], dil\n  jmp .row2\n.end2:\n  shr rbp, 1\n  mov byte [rsi+rbp], 0\n  pop rbx\n  pop rbp\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213158,"user_id":173,"body":"global simple_transposition\nextern malloc\n\nsection .text\n\nsimple_transposition:\n    mov r12, rdi\n    mov r13, 0\n\n    ; compute length of input\n    mov rcx, 0\nl_loop:\n    mov byte al, [rdi]\n    cmp al, 0\n    je l_done\n    inc r13\n    inc rdi\n    jmp l_loop\n\nl_done:\n    ; out buffer\n    inc r13\n    mov rdi, r13\n    call malloc\n    mov r14, rax\n    \n    ; offset into second row in r15\n    mov rax, r13\n    shr rax, 1\n    mov r15, rax\n    \n    mov rdi, r12\n    mov rsi, 0\nl_nc:\n    mov byte al, [rdi + rsi]\n    cmp al, 0\n    je l_end\n    \n    mov rcx, rsi\n    and rcx, 1\n    cmp rcx, 1\n    je l_odd\n    mov rcx, rsi\n    shr rcx, 1\n    jmp l_w\nl_odd:\n    mov rcx, rsi\n    shr rcx, 1\n    add rcx, r15\nl_w:\n    push rdi\n    push rsi\n    mov rdi, r14\n    mov rsi, rcx\n    mov byte [rdi + rsi], al\n    pop rsi\n    pop rdi\n        \n    inc rsi\n    jmp l_nc\nl_end:\n    mov rdi, r14\n    mov rsi, r13\n    dec rsi\n    mov byte [rdi + rsi], 0\n    \n    mov rax, r14\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213159,"user_id":null,"body":"global simple_transposition\nextern malloc,strlen\n\nsection .text\n; <--- char *simple_transposition(const char *s) --->\nsimple_transposition:\n    xor     rax, rax            ; RAX <- the result\n    cmp     [rdi], byte 0\n    je      .end\n    push    rdi\n    call    strlen\n    mov     rdi, rax\n    add     rdi, 10   ;wtf\n    push    rax\n    call    malloc\n    pop     rcx       ; strlen(s)\n    pop     rdi       ; *s\n    push    rax       \n    xor     rdx,rdx\n    xor     rbx, rbx\n    .loop1:\n    mov   bl, [rdi+rdx] \n    mov   [rax], rbx\n    inc    rax\n    add    rdx, 2\n    cmp    rdx, rcx\n    jl     .loop1\n    mov    rdx, 1\n    .loop2:\n    mov   bl, [rdi+rdx] \n    mov   [rax], rbx\n    inc   rax\n    add   rdx, 2\n    cmp   rdx, rcx\n    jl    .loop2\n    .preend:\n    mov     [rax], byte 0\n    pop     rax\n    .end:\n    ret\n; ---------> endof simple_transposition <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213160,"user_id":null,"body":"global simple_transposition\nextern malloc\nsimple_transposition:    \n    push rdi\n    xor rcx, rcx\n.lenloop:               ; loop to find length of input string \n    mov dl, [rdi+rcx]   ; probably more efficient than a strlen call\n    inc rcx\n    test dl, dl\n    jnz .lenloop\n    lea rdi, [rcx+1]\n    push rcx\n    call malloc\n    pop rcx\n    pop rdi\n    shr rcx, 1\n    mov [rax+2*rcx], byte 0\n    lea rsi, [rax+rcx]\n.writeloop:\n    mov dx, [rdi+2*rcx-2]\n    mov [rax+rcx-1], dl\n    shr dx, 8\n    mov [rsi+rcx-1], dl\n    loop .writeloop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213161,"user_id":null,"body":"global simple_transposition\nextern malloc\nsimple_transposition:    \n    push rdi\n    xor rcx, rcx\n.lenloop:               ; loop to find length of input string \n    mov dl, [rdi+rcx]   ; probably more efficient than a strlen call\n    inc rcx\n    test dl, dl\n    jnz .lenloop\n    lea rdi, [rcx+1]\n    push rcx\n    call malloc\n    pop rcx             ; length with terminating 0\n    pop r8              ; pointer to input string\n    mov r9, rax         ; pointer to return string\n    shr rcx, 1\n    mov [r9+2*rcx], byte 0\n    lea r10, [r9+rcx]\n.writeloop:\n    mov dx, [r8+2*rcx-2]\n    mov [r9+rcx-1], dl\n    shr dx, 8\n    mov [r10+rcx-1], dl\n    loop .writeloop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213162,"user_id":null,"body":"global simple_transposition\nextern malloc\n; <--- char *simple_transposition(const char *s) --->\nsimple_transposition:    \n    mov r8, rdi       ; r8 pointer to input string\n    xor rdi, rdi\n.lenloop:             ; loop to find length of input string\n    mov dl, [r8+rdi]\n    inc rdi\n    test dl, dl\n    jnz .lenloop\n    push rdi          ; rdi now string length (including terminating 0)\n    push r8\n    call malloc\n    pop r8\n    pop rcx           ; rcx now string length (including terminating 0)\n    mov r9, rax       ; r9 pointer to return string\n    shr rcx, 1        ; half length in rcx (rcx is just number of loops)\n    setc dh           ; dh set if odd (in that case will have to manually add terminating 0)\n    lea r10, [r9+rcx] ; r10 pointer to return string address + half length\n.writeloop:\n    mov dl, [r8]\n    inc r8\n    mov [r9], dl\n    inc r9\n    mov dl, [r8]\n    inc r8\n    mov [r10], dl\n    inc r10\n    loop .writeloop\n    test dh, dh\n    jz .end\n    mov [r10], byte 0\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213163,"user_id":null,"body":"global simple_transposition\nextern malloc, strlen\n\nsection .text\nsimple_transposition:    \n    push rdi\n    call strlen\n    push rax\n    lea  rdi,[rax +1]\n    call malloc\n    mov  rdi,rax             ; Output buffer\n    pop  rax                 \n    mov  byte [rdi + rax],0  ; Zero terminate the new string\n    shr  rax,1               ; rax is string offset for 2nd half\n    jnc  @even               ; Adjust middle of string for add stringlength\n    inc  rax\n@even:    \n    pop  rsi\n    push rdi\n@loop:\n    movzx edx, byte [rsi]\n    inc  rsi\n    test edx,edx\n    jz @done\n    mov byte [rdi],dl\n    movzx edx, byte [rsi]\n    inc  rsi\n    test edx,edx\n    jz @done\n    mov byte [rdi + rax],dl\n    inc  rdi\n    jmp @loop\n@done:\n    pop  rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a1d5ef7cb1f3db590002af":[{"id":213164,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n    mov   rax, 1\n    mov   rcx, 1\n\nloop0:\n    cmp   rdi, 1\n    jle   done\n\n    mov   rdx, rax\n    mov   rax, rcx\n    add   rcx, rdx\n    dec   rdi\n    jmp   loop0\n\ndone:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213165,"user_id":168,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n  xor eax, eax\n  mov edx, 1\n.loop:\n  xadd eax, edx\n  dec edi\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213166,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n  xor eax, eax\n    \n  mov eax, 0\n  mov ebx, 1\n  \n  loop:\n    mov ecx, eax\n    mov eax, ebx\n    add ebx, ecx\n    dec edi\n    test edi, edi\n    jnz loop\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213167,"user_id":null,"body":"section .text\nglobal fib\n\nfib:\n    xor ebx, ebx\n    xor eax, eax\n    mov ecx, 1\n\n.first_loop:\n    mov ebx, ecx\n    add ecx, eax\n    mov eax, ebx\n    dec edi\n    cmp edi, 0\n    jne .first_loop\n    ret   ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213168,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n  test edi, edi\n  je .base\n  mov eax, 1\n  cmp edi, 3\n  jl .done\n  add edi, -2\n  mov edx, 1\n  mov ecx, 1\n.loop:\n  mov eax, edx\n  mov edx, ecx\n  add eax, ecx\n  add edi, -1\n  mov ecx, eax\n  jne .loop\n.done:\n  ret\n.base:\n  xor eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213169,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n    mov eax, 1\n    add edi, -1\n    jz  fin\n    \n    mov edx, 0 ; initial another \nnext:\n    lea ecx, [eax + edx]\n    mov edx, eax\n    mov eax, ecx\n    add edi, -1\n    jnz next\nfin:\n\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213170,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\nfib:\n  xor ebx, ebx\n  mov eax, 1\n.iter:\n  dec edi\n  jz .exit\n  xchg ebx, eax\n  add eax, ebx\n  jmp .iter\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213171,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n    xor   eax, eax\n    cmp   edi, 1\n    jle   .n\n    mov   edx, 1\n    xor   r8d, r8d\n    mov   ecx, 2\n    .l:\n      lea  eax, [edx+r8d]\n      mov  r8d, edx\n      mov  edx, eax\n      inc  ecx  \n      cmp  ecx, edi\n    jle   .l\n    ret\n    .n:\n    mov   eax, edi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213172,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n        mov r8, rdi\n        mov rax, 1\n        mov rbx, 1\n        mov rcx, 1\n        mov rdx, 1\n        cmp r8, 2\n        jle end\n        sub r8, 2\n        fibloop:\n          add rax, rdx\n          mov rbx, rcx\n          mov rcx, rax\n          mov rdx, rbx\n          dec r8\n          cmp r8, 0\n          je end\n          jmp fibloop\n      end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213173,"user_id":null,"body":"section .text\nglobal fib\n\n; int fib(int n)\n; n -> edi, result -> eax\nfib:\n        sub     edi, 1\n        test    edi, edi\n        jle     _return_1\n        xor     edx, edx\n        mov     eax, 1\n        mov     ecx, 1\n_loop:\n        mov     ebx, eax\n        add     edx, 1\n        add     eax, ecx\n        mov     ecx, ebx\n        cmp     edx, edi\n        jne     _loop\n        mov     eax, ebx\n        ret\n_return_1:\n        mov     eax, 1\n        ret\n ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a1fd2ce298a731b20006a4":[{"id":213174,"user_id":null,"body":"global is_palindrome\nis_palindrome:\n  xor   eax,eax\n  mov   rcx,-1\n  mov   rsi,rdi\n  repne scasb\n  jmp   .s\n  .b:dec  rdi\n     lodsb\n     xor  al,[rdi-1]\n     and  al,~32\n  .s:sete al\n     jne  .f\n     cmp  byte[rsi],0\n  jne .b\n  .f:\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213175,"user_id":null,"body":"section .text\n\nglobal is_palindrome\nis_palindrome:\n  mov dl, [rdi]\n  test dl, dl\n  jz .true\n  mov rsi, rdi ;rdi=p1, rsi=p2\n.sz:\n  mov dl, [rsi + 1]\n  test dl, dl\n  jz .cont\n  inc rsi\n  jmp .sz\n\n.cont:\n  cmp rdi, rsi\n  jae .true ; return true, p1 & p2 have met\n  mov dl, [rdi] ; dl=char1\n  mov cl, [rsi] ; cl=char2\n  or dl, 32 ; tolower(dl)\n  or cl, 32 ; tolower(cl)\n  inc rdi\n  dec rsi\n  cmp dl, cl\n  je .cont\n  xor rax, rax ;return false\n  ret\n  \n.true:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213176,"user_id":null,"body":"; 2019 NASM translation by nomennescio\nsection .text\nglobal is_palindrome\n; bool is_palindrome (const char *s)\nis_palindrome:\n  lea rax, [rdi - 2]\n.seekend:\n  cmp byte [rax + 2], 0\n  lea rax, [rax + 1]\n  jne .seekend\n  jmp .cmppts\n.loop:\n  mov sil, byte [rcx]\n  xor sil, byte [rdx]\n  lea rdi, [rcx + 1]\n  lea rax, [rdx - 1]\n  test sil, -33\n  jne .end\n.cmppts:\n  mov rcx, rdi\n  mov rdx, rax\n  cmp rax, rdi\n  ja .loop\n.end:\n  cmp rdx, rcx\n  setbe al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213177,"user_id":null,"body":"; 2019 NASM translation by nomennescio\nsection .text\nglobal is_palindrome\n; bool is_palindrome (const char *s)\nis_palindrome:\n\n    mov rax, 1\n    mov rdx, rdi\n    \n    cmp byte[rdx], 0\n    je end\n      \n\n    reachedge:\n    \n      inc rdx\n      cmp byte[rdx], 0\n      jne reachedge\n      \n      \n      dec rdx\n      mov rcx, rdx ; rcx is @ end\n      \n      xor rbx, rbx\n      mov rbx, rdi  ; rbx is @ beginning\n      \n      mov rax, 1        ; 1st iteration of 1st-char-to-last-char comparison loop\n      cmp rbx, rcx\n      je end\n      \n      mov dl, byte[rbx]\n      cmp dl, byte[rcx]\n      jne are_twins\n\n\n     comploop: ; compare & lop off tails of string until either we find unequal values or meet\n     \n      mov rax, 1\n      \n      inc rbx\n      dec rcx\n      cmp rbx, rcx\n      jg end\n      \n      mov dl, byte[rbx]\n      cmp dl, byte[rcx]\n      jne are_twins\n      \n      cmp rbx, rcx\n      jl comploop\n      \n      jmp end\n      \n    are_twins:\n    \n      cmp dl, byte[rcx] ; which letter has a higher ascii value\n      jg firsthigher\n      mov al, byte[rcx]\n      sub al, dl\n      cmp al, 32 ; if they're the same letter, just diff caps, we're good, go back to comploop\n      je comploop\n      firsthigher:\n      sub dl, byte[rcx]\n      cmp dl, 32 ; if they're the same letter, just diff caps, we're good, go back to comploop\n      je comploop\n      \n    isnot:\n    \n      mov rax, 0\n      \n      \n    end:\n    \n    \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213178,"user_id":881,"body":"section .text\nglobal is_palindrome\n\n; bool is_palindrome (const char *s)\nis_palindrome:\n    xor rax, rax\n    cmp byte[rdi], 0\n    je .true\n    mov rsi, rdi\n.findlastindex:\n    cmp byte[rsi + 1], 0\n    je .palindrometest\n    inc rsi\n    jmp .findlastindex\n.palindrometest:\n    mov dl, byte[rdi]\n    mov dh, byte[rsi]\n    or dx, 0x2020\n    cmp dl, dh\n    jne .false\n    inc rdi\n    dec rsi\n    cmp rdi, rsi\n    jl .palindrometest\n.true:\n    inc rax\n.false:\n    ret \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213179,"user_id":null,"body":"; 2019 NASM translation by nomennescio\nglobal is_palindrome\n; bool is_palindrome (const char *s)\nis_palindrome:\n    mov rsi, rdi\n    xor al, al\n    mov rcx, -1\n    repnz scasb\n    sub rdi, 2\n    inc al\n.L1:\n    movzx rcx, byte [rdi]\n    lea r8, [rcx-32]\n    cmp cl, 'a'\n    cmovge rcx, r8\n    movzx rdx, byte [rsi]\n    lea r8, [rdx-32]\n    cmp dl, 'a'\n    cmovge rdx, r8\n    dec rdi\n    inc rsi\n    cmp cl, dl\n    sete al\n    jne .L2\n    cmp rsi, rdi\n    jle .L1\n.L2:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213180,"user_id":null,"body":"; 2019 NASM translation by nomennescio\nsection .text\nglobal is_palindrome\n\n; bool is_palindrome (const char *s)\nis_palindrome:\n  xor r8, r8\n  \n.find_last:\n  mov cl, byte [rdi + r8]\n  inc r8\n  cmp cl, 0\n  jnz .find_last\n  \n  mov rax, 1\n  cmp r8, 0\n  jz .exit\n   \n  sub r8, 2\n  js .exit\n  \n  xor r9, r9\n  xor rax, rax\n  \n.compare:\n  mov cl, byte [rdi + r8] \n  mov dl, byte [rdi + r9]\n  or cl, 32\n  or dl, 32\n  cmp cl, dl\n  sete al\n  jne .exit\n  inc r9\n  dec r8\n  jns .compare\n  \n.exit:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213181,"user_id":527,"body":"section .text\nglobal is_palindrome\n; bool is_palindrome(const char *s)\nis_palindrome:\n                cmp     byte [rdi], 0\n                jz      .ret_1\n                mov     rsi, rdi\n.loop_len:      inc     rsi\n                cmp     byte [rsi], 0\n                jnz     .loop_len\n.loop_cmp:      dec     rsi\n                cmp     rdi, rsi\n                jae     .ret_1\n                movzx   edx, byte [rdi]\n                inc     rdi\n                xor     dl, [rsi]\n                test    dl, ~('A' ^ 'a')\n                je      .loop_cmp\n                xor     eax, eax\n                ret\n.ret_1:         mov     eax, 1\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213182,"user_id":168,"body":"; 2019 NASM translation by nomennescio\nsection .text\nglobal is_palindrome\nextern strlen\n\n; bool is_palindrome (const char *s)\nis_palindrome:\n  push rdi\n  call strlen\n  pop rdi\n  lea rsi, [rdi + rax - 1]\n  jmp .loop_cond\n.loop:\n  movzx edx, byte [rdi]\n  xor dl, byte [rsi]\n  and dl, 31\n  jnz .false\n  inc rdi\n  dec rsi\n.loop_cond:\n  cmp rdi, rsi\n  jb .loop\n  mov eax, 1\n  ret\n.false:\n  xor eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213183,"user_id":104,"body":"; 2019 nomennescio\nsection .text\nextern strlen\nglobal is_palindrome\n; bool is_palindrome (const char *s)\nis_palindrome:\n  push rdi\n  call strlen\n  pop rdi\n  mov rsi, rdi\n  add rdi, rax\n  mov rax, 1\nloop:\n  cmp rsi, rdi\n  jae ok\n  mov cl, [rsi]\n  sub cl, 'A'\n  cmp cl, 'Z'-'A'\n  ja not_upper1\n  add cl, 'a'-'A'\nnot_upper1:\n  mov dl, [rdi-1]\n  sub dl, 'A'\n  cmp dl, 'Z'-'A'\n  ja not_upper2\n  add dl, 'a'-'A'\nnot_upper2:\n  inc rsi\n  dec rdi\n  cmp cl, dl\n  je loop\n  xor rax, rax\nok:  \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a2013acf1fa5bfc4000921":[{"id":213184,"user_id":null,"body":"global find_average\n\nsection .text\n\n; <--- double find_average(const double *nums, int n) --->\nfind_average:\n    xorpd xmm0, xmm0        ; resetting XMM0 as <sum>\n    test esi, esi           ; whether <n> is zero\n    jne $+1                 ; otherwise, skiping the return instruction\n    ret\n    cvtsi2sd xmm1, esi      ; casting <n> to double\n.loop:\n    addsd xmm0, [rdi]       ; adding <sum> with <*nums>\n    add rdi, 0h8            ; pointing <nums> to the next double\n    dec esi                 ; decrementing <n>\n    jg .loop                ; jumping to the next iteration in case <n> is positive\n    divsd xmm0, xmm1        ; dividing <sum> by <n>\n    ret\n; ---------> endof find_average <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213185,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  xorps xmm0, xmm0\n  xor rax, rax\n  sum:\n    cmp rax, rsi\n    je finished_sum\n    addsd xmm0, [rdi+rax*8]\n    inc rax\n    jmp sum\n\n  finished_sum:\n    cvtsi2sd xmm1, rsi\n    divsd xmm0, xmm1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213186,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  test esi, esi\n  je .empty\n  movsxd rax, esi\n  lea rax, [rdi + 8*rax]\n  vxorpd xmm0, xmm0, xmm0\n.loop:\n  cmp rdi, rax\n  jae .done\n  vaddsd xmm0, xmm0, qword [rdi]\n  add rdi, 8\n  jmp .loop\n.done:\n  vcvtsi2sd xmm1, xmm1, esi\n  vdivsd xmm0, xmm0, xmm1\n  ret\n.empty:\n  vxorps xmm0, xmm0, xmm0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213187,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  xorpd xmm0, xmm0\n  cvtsi2sd xmm1, rsi\n  lopp:\n  mov rax, 1\n  cmp rsi, 0\n  je end\n  addsd xmm0, [rdi]\n  add rdi, 8\n  dec rsi\n  jmp lopp\n  end:\n  cmp rax, 0\n  je rete\n  divsd xmm0, xmm1\n  rete:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213188,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  pxor      xmm0, xmm0\n  test      esi, esi\n  jz        exit\n  cvtsi2sd  xmm1, esi\n  loop:\n    addsd     xmm0, QWORD [rdi]\n    add       rdi, 8\n    dec       esi\n    jnz       loop\n  divsd     xmm0, xmm1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213189,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  pxor      xmm0, xmm0\n  test      esi, esi\n  jz        exit\n  mov       eax, esi\n  loop:\n    addsd     xmm0, QWORD [rdi]\n    add       rdi, 8\n    dec       eax\n    jnz       loop\n  pxor      xmm1, xmm1\n  cvtsi2sd  xmm1, esi\n  divsd     xmm0, xmm1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213190,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n    pxor xmm0, xmm0\n    xor rax, rax\n\n.calculate_sum:\n    cmp eax, esi\n    je .calculate_avg\n    movsd xmm1, qword [rdi + 8 * rax]\n    addsd xmm0, xmm1\n    inc eax\n    jmp .calculate_sum\n\n.calculate_avg:\n    cvtsi2sd xmm1, esi\n    divsd xmm0, xmm1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213191,"user_id":173,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  mov esi, esi\n  cmp rsi, 0\n  jbe @zero\n  \n  mov r12, 0\n  pxor xmm0, xmm0\n@loop:\n  movsd xmm1, [rdi + r12 * 8]\n  addsd xmm0, xmm1\n  inc r12\n  cmp r12, rsi\n  jb @loop\n@done:\n  cvtsi2sd xmm1, rsi\n  divsd xmm0, xmm1\n  ret\n@zero:\n  pcmpeqd xmm0, xmm0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213192,"user_id":null,"body":"SECTION .text\nglobal find_average\n\nfind_average:\n  xorpd xmm0, xmm0\n  mov rcx, rsi\n  \narray_loop:\n  addsd xmm0, [rdi]\n  add rdi, 8\n  loop array_loop\n  cvtsi2sd xmm1, rsi\n  divsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213193,"user_id":null,"body":"extern   printf\n\nsection  .data\n  format: db       \"%g\", 10, 0\n\nSECTION .text\nglobal find_average\n\n\n\nfind_average:\n  xorpd xmm0, xmm0\n  mov rcx, rsi\n  \n  \narray_loop:\n  addsd xmm0, [rdi]\n  add rdi, 8\n  loop array_loop\n  cvtsi2sd xmm1, rsi\n  divsd xmm0, xmm1\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a23e3753ba332b8e0008da":[{"id":213194,"user_id":168,"body":"global help_zoom\n\nsection .text\n\nyes db \"Yes\", 0\nno db \"No\", 0\n\n; <--- char *help_zoom(const int key[], size_t count) --->\nhelp_zoom:\n  cvtsi2sd xmm0, rsi\n  sqrtsd xmm0, xmm0\n  cvttsd2si rax, xmm0\n  imul rax, rax\n  cmp rax, rsi\n  jne .no\n  xor ecx, ecx\n.loop:\n  cmp rsi, rcx\n  jbe .yes\n  mov edx, dword [rdi + rcx * 4]\n  inc rcx\n  dec rsi\n  cmp edx, dword [rdi + rsi * 4]\n  je .loop\n.no:\n  mov rax, no\n  ret\n.yes:\n  mov rax, yes\n  ret\n; ---------> endof help_zoom <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213195,"user_id":null,"body":"global help_zoom\n\nsection .text\n\n; <--- char *help_zoom(const int key[], size_t count) --->\nhelp_zoom:\n    mov rax, no             ; setting RAX as the result to <no>\n    cvtsi2sd xmm1, rsi      ; copying <count> to XMM1 as <cnt>\n    sqrtsd xmm0, xmm1       ; getting the square root of <cnt>\n    cvttsd2si rcx, xmm0     ; getting rid of the fractional part of <cnt>\n    imul rcx, rcx           ; squaring <cnt>\n    cmp rcx, rsi            ; whether <count> is square\n    jne .exit               ; otherwise, jumping to exit\n    mov rcx, -1             ; setting RCX to minus one as <n>\n    mov rax, yes            ; setting the result to <yes>\n.loop:\n    inc rcx                 ; incrementing <n>\n    dec rsi                 ; decrementing <count>\n    cmp rcx, rsi            ; whether <n> is less than <count>\n    jge .exit               ; otherwise, jumping to exit\n    mov edx, [rdi+rcx*4]    ; copying <*(key+n)> to EDX as <num>\n    cmp edx, [rdi+rsi*4]    ; whether <num> is equal to <*(key+n)>\n    je .loop                ; jumping to the next iteration\n    mov rax, no             ; setting the resutl to <no>\n.exit:\n    ret\n; ---------> endof help_zoom <---------\n\nsection .rodata\n\nyes:    db  \"Yes\",0h0\nno:     db  \"No\",0h0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213196,"user_id":null,"body":"global help_zoom\n\nsection .text\n\n; <--- char *help_zoom(const int key[], size_t count) --->\nhelp_zoom:\n  mov eax, esi\n  mov edx, .no\n  cvtsi2ss xmm0, rax\n  sqrtss xmm0, xmm0\n  cvttss2si eax, xmm0\n  imul eax, eax\n  cdqe\n  cmp rax, rsi\n  jne .done\n  lea rax, [rdi-4+rax*4]\n.loop:\n  cmp rdi, rax\n  jnb .end\n  mov ecx, [rdi]\n  cmp [rax], ecx\n  jne .mismatch\n  add rdi, 4\n  sub rax, 4\n  jmp .loop\n.end:\n  mov edx, .yes\n  jmp .done\n.mismatch:\n  mov edx, .no\n.done:\n  mov rax, rdx\n  ret\n.no: db \"No\",0\n.yes: db \"Yes\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213197,"user_id":null,"body":"global help_zoom\n\nsection .text\n\n; <--- char *help_zoom(const int key[], size_t count) --->\nhelp_zoom:\n  lea rax, [no]\n\n  cvtsi2sd xmm0, rsi\n  sqrtsd xmm0, xmm0\n  cvttsd2si rdx, xmm0\n  imul rdx, rdx\n  cmp rsi, rdx\n  jne .quit\n  \n  lea rdx, [rdi+rsi*4-4]\n.loop:\n  mov ecx, [rdi]\n  cmp ecx, [rdx]\n  jne .quit\n  add rdi, 4\n  sub rdx, 4\n  cmp rdi, rdx\n  jb .loop\n  \n  lea rax, [yes]\n.quit:\n  ret\n; ---------> endof help_zoom <---------\n\nsection .rodata\nyes: db \"Yes\", 0\nno: db \"No\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213198,"user_id":104,"body":"; 2021 nomennescio\nglobal help_zoom\n\nsection .rodata\n\nyes: db \"Yes\",0\nno:  db \"No\",0\n\nsection .text\n\n; char *help_zoom (const int key[], size_t count)\nhelp_zoom:\n    mov eax, no\n    cvtsi2sd xmm0, rsi\n    sqrtsd xmm1, xmm0\n    cvtsd2si rdx, xmm1\n    imul rdx, rdx\n    cmp rdx, rsi\n    jne exit\n    \n    shl rsi, 2\n    add rsi, rdi\nloop:\n    sub rsi, 4\n    mov edx, [rdi]\n    cmp edx, [rsi]\n    jne exit\n    add rdi, 4\n    cmp rdi, rsi\n    jb loop\n    mov eax, yes\nexit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213199,"user_id":null,"body":"global help_zoom\nhelp_zoom:\n  cvtsi2ss  xmm0,rsi\n  sqrtss    xmm0,xmm0\n  roundss   xmm0,xmm0,3\n  mulss     xmm0,xmm0\n  cvttss2si rdx,xmm0\n  cmp       rdx,rsi\n  mov       rax,.answer+4\n  jne .f\n  lea rsi,[rdi+rsi*4-4]\n  .b:cmpsd\n     jne .f\n     sub rsi,8\n     cmp rsi,rdi\n  ja .b\n    sub rax,4\n  .f:   \nret\n.answer db 'Yes',0,'No',0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213200,"user_id":null,"body":"global help_zoom \nsection .text\nhelp_zoom:                    ; int has size 4 byte\n    xor rcx, rcx              ; iterate throug squares, should work for reasonable matrix size... not optimal\nis_sq:\n    inc rcx\n    mov rax, rcx\n    mul rax\n    cmp rax, rsi\n    jb is_sq\n    jne bad\n    xor rcx, rcx\nmain_loop:\n    mov edx, dword[rdi+4*rsi-4]    ; edx last element\n    mov eax, dword[rdi+4*rcx]      ; eax first\n    cmp eax, edx\n    jnz bad\n    inc rcx\n    dec rsi\n    cmp rcx, rsi\n    jbe main_loop\n    mov rax, yes\n    ret\nbad:\n    mov rax, no              ; RAX <- the result\n    ret\n    \nsection .data\nno:   db 'No',0,0\nyes:  db 'Yes',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a429e253ba3381850000fb":[{"id":213201,"user_id":null,"body":"global bmi\nbmi:\n  cvtsi2sd xmm1, rdi\n  mulsd xmm0, xmm0\n  divsd xmm1, xmm0\n\n  comisd xmm1, [_185] \n  jbe UNDERWEIGHT\n  \n  comisd xmm1, [_25]\n  jbe NORMAL\n  \n  comisd xmm1, [_30]\n  jbe OVERWEIGHT\n\n  jmp OBESE\n\nUNDERWEIGHT:\n  mov rax, underweight\n  ret\nNORMAL:\n  mov rax, normal\n  ret\nOVERWEIGHT:\n  mov rax, overweight\n  ret\nOBESE:\n  mov rax, obese\n  ret\n  \nsection .text\nunderweight   db  'Underweight', 0\nnormal        db  'Normal', 0\noverweight    db  'Overweight', 0\nobese         db  'Obese', 0\n_185          dq  18.5\n_25           dq  25.0\n_30           dq  30.0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213202,"user_id":527,"body":"global bmi\nbmi:\n                vmulsd        xmm0, xmm0\n                vbroadcastsd  ymm0, xmm0\n                vmulpd        ymm0, [ks]\n                vcvtsi2sd     xmm1, edi\n                vbroadcastsd  ymm1, xmm1\n                vcmpltpd      ymm0, ymm1\n                vmovmskps     eax, ymm0\n                bsf     eax, eax\n                lea     rax, [strs + rax * 8]\n                ret\n\nks              dq 30.0, 25.0, 18.5, 0.0\nstrs            db `Obese\\0..........Overweight\\0.....Normal\\0.........Underweight\\0`\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213203,"user_id":null,"body":"global bmi\nbmi:\n  cvtsd2ss xmm1,xmm0\n  cvtsi2ss xmm0,edi\n  mulss    xmm1,xmm1\n  divss    xmm0,xmm1\n  pshufd   xmm0,xmm0,0\n  cmpleps  xmm0,[.weight]\n  phaddd   xmm0,xmm0\n  phaddd   xmm0,xmm0\n  movd     eax,xmm0\n  mov      rax,[.answer+eax*8+32]\nret\nalign 16\n.weight dd 18.5,25.0,30.0,9999.0\n.answer dq .under,.norm,.over,.obese\n.under  db 'Underweight',0\n.norm   db 'Normal',0\n.over   db 'Overweight',0\n.obese  db 'Obese',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213204,"user_id":null,"body":"; Weight is placed in EDI\n; Height is placed in xmm0 - the number format is double\nglobal bmi\nbmi:\n  add edi, edi\n  vcvtsi2sd xmm1, xmm1, edi\n  vdivsd xmm1, xmm1, xmm0\n  vdivsd xmm0, xmm1, xmm0\n  vcvttsd2si eax, xmm0\n  cmp eax, 38\n  jge .LBB0_2\n  lea rax, [.s1]\n  ret\n.LBB0_2:\n  cmp eax, 51\n  jae .LBB0_4\n  lea rax, [.s2]\n  ret\n.LBB0_4:\n  cmp eax, 61\n  lea rcx, [.s3]\n  lea rax, [.s4]\n  cmovb rax, rcx\n  ret\n.s1: db \"Underweight\",0\n.s2: db \"Normal\",0\n.s3: db \"Overweight\",0\n.s4: db \"Obese\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213205,"user_id":null,"body":"SECTION .text\nglobal bmi\n\nbmi:\n  xor rcx, rcx\n  cvtsi2sd xmm1, edi\n  mulsd xmm0, xmm0 \n  divsd xmm1, xmm0\n  comisd xmm1, [bmi_values]\n  ja .end\n  inc rcx\n  comisd xmm1, [bmi_values+rcx*8]\n  ja .end\n  inc rcx\n  comisd xmm1, [bmi_values+rcx*8]\n  ja .end\n  inc rcx\n.end:\n  imul rcx, 2\n  lea rax, [bmi_strings+rcx*8]\n  ret\n\nSECTION .data\nbmi_values: dq 30.0, 25.0, 18.5\nbmi_strings: db \"Obese\",0,0,0,0,0,0,0,0,0,0,0,\"Overweight\",0,0,0,0,0,0,\"Normal\",0,0,0,0,0,0,0,0,0,0,\"Underweight\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213206,"user_id":50,"body":"; Weight is placed in EDI\n; Height is placed in xmm0 - the number format is double\nsection .data\n  a db  \"Underweight\",0\n  b db  \"Normal\",0\n  c db  \"Overweight\",0\n  d db  \"Obese\",0\n  e dq  18.5\n  f dq  25.0\n  g dq  30.0\n  \nsection .text\nglobal bmi\nbmi:\n  cvtsi2sd xmm1,edi\n  divsd xmm1,xmm0\n  divsd xmm1,xmm0\n  comisd xmm1,[g]\n  ja _ob\n  comisd xmm1,[f]\n  ja _ov\n  comisd xmm1,[e]\n  ja _n\n  lea rax,[a]\n  ret\n_n:\n  lea rax,[b]\n  ret\n_ov:\n  lea rax,[c]\n  ret\n_ob:\n  lea rax,[d]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213207,"user_id":1088,"body":"\n[section .rodata]\nalign 8\n_case1:\n\tdq 18.5\n_case2:\n\tdq 25.0\n_case3:\n\tdq 30.0\n_str1:\n\tdb \"Underweight\",0\n_str2:\n\tdb \"Normal\",0\n_str3:\n\tdb \"Overweight\",0\n_str4:\n\tdb \"Obese\",0\n\n[section .text]\nglobal bmi\n\n; const char *__bmi(int, double);\n; \/\/ Weight is placed in EDI\n; \/\/ Height is placed in xmm0 - the number format is double\n__bmi:\n\tcvtsi2sd\txmm1, edi\n\tmulsd\t\txmm0, xmm0\n\tdivsd\t\txmm1, xmm0\n\n\tlea\t\trax, [rel _str1]\n\tmovsd\t\txmm0, [rel _case1]\n\tucomisd\t\txmm1, xmm0\n\tjbe\t\t.l_out\n\n\tlea\t\trax, [rel _str2]\n\tmovsd\t\txmm0, [rel _case2]\n\tucomisd\t\txmm1, xmm0\n\tjbe\t\t.l_out\n\n\tlea\t\trax, [rel _str3]\n\tmovsd\t\txmm0, [rel _case3]\n\tucomisd\t\txmm1, xmm0\n\tjbe\t\t.l_out\n\n\tlea\t\trax, [rel _str4]\n.l_out:\n\tret\nbmi:\n\tjmp\t__bmi\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213208,"user_id":null,"body":"section .data\nfifty dq 1.8\nthirty dq 30.0\ntwentyFive dq 25.0\neighteenHalf dq 18.5\n\nobese: db \"Obese\",0\noverweight: db \"Overweight\",0\nnormal: db \"Normal\",0\nunderweight: db \"Underweight\",0\n\n\nsection .text\n\n; Weight is placed in EDI\n; Height is placed in xmm0 - the number format is double\nglobal bmi\nbmi:\n        \n        \n        \n        cvtsi2sd xmm1, rdi  ;; conversion signed integer to scalar double        https:\/\/cs.fit.edu\/~mmahoney\/cse3101\/nasmdocb.html\n        \n        \n        mulsd xmm0, xmm0    ;; multiply scalar double        \n        divsd xmm1, xmm0    ;; divide scalar double\n        \n        \n        comisd xmm1, [thirty]    ;; compare and set flags scalar double, only sets (ZF, PF, CF)\n        ja .obese\n        \n        \n        comisd xmm1, [twentyFive]\n        ja .overweight\n        \n        comisd xmm1, [eighteenHalf]\n        ja .normal\n        \n        jmp .underweight\n        \n        .obese:\n          lea rax, [obese]\n          ret\n        .overweight:\n          lea rax, [overweight]\n          ret\n        .normal:\n          lea rax, [normal]\n          ret\n        .underweight:\n          lea rax, [underweight]\n          ret\n        \n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213209,"user_id":null,"body":"section .data\nfifty dq 1.8\nthirty dq 30.0\ntwentyFive dq 25.0\neighteenHalf dq 18.5\n\nobese: db \"Obese\",0\noverweight: db \"Overweight\",0\nnormal: db \"Normal\",0\nunderweight: db \"Underweight\",0\n\n\nsection .text\n\n; Weight is placed in EDI\n; Height is placed in xmm0 - the number format is double\nglobal bmi\nbmi:\n        \n        \n        \n        cvtsi2sd xmm1, rdi  ;; conversion signed integer to scalar double        https:\/\/cs.fit.edu\/~mmahoney\/cse3101\/nasmdocb.html\n        \n        \n              \n        mulsd xmm0, xmm0    ;; multiply scalar double        \n        divsd xmm1, xmm0    ;; divide scalar double\n        \n        mov rdi, 30\n        cvtsi2sd xmm2, rdi\n        comisd xmm1, xmm2    ;; compare and set flags scalar double, only sets (ZF, PF, CF)\n        ja .obese\n        \n        \n        mov rdi, 25\n        cvtsi2sd xmm2, rdi\n        comisd xmm1, xmm2\n        ja .overweight\n        \n        \n        \n        mov rdi, 18\n        cvtsi2sd xmm2, rdi\n        comisd xmm1, xmm2\n        ja .normal\n        \n        \n        jmp .underweight\n        \n        .obese:\n          lea rax, [obese]\n          ret\n        .overweight:\n          lea rax, [overweight]\n          ret\n        .normal:\n          lea rax, [normal]\n          ret\n        .underweight:\n          lea rax, [underweight]\n          ret\n        \n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213210,"user_id":null,"body":"; Weight is placed in EDI\n; Height is placed in xmm0 - the number format is double\nglobal bmi\n\n@double dq 200.0\n\nbmi:\n  cvtsi2sd xmm1,edi ; int to double\n  mulsd xmm0, xmm0  ;\n  divsd xmm1, xmm0  ;\n  movsd xmm0,[@double]\n  mulsd xmm1, xmm0  ;\n  cvtsd2si eax, xmm1\n  \n  cmp eax, 3700\n  jle under\n  \n  cmp eax, 5000\n  jle norm\n  \n  cmp eax, 6000\n  jle over\n  \n  mov rax,str_obese\n  ret\n\nunder:\n  mov rax,str_under\n  ret\n\nnorm:\n  mov rax,str_normal\n  ret\n  \nover:\n  mov rax,str_overweight\n  ret\n  \n  \n\nsection   .data\n\nstr_under:  db        \"Underweight\",0\nstr_normal:  db        \"Normal\",0\nstr_overweight:  db        \"Overweight\",0\nstr_obese:  db        \"Obese\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a4d500e298a7952100035d":[{"id":213211,"user_id":null,"body":"global hex_to_dec\nextern strtol\nsection .text\nhex_to_dec:\n    xor rsi,rsi\n    mov rdx,16\njmp strtol\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213212,"user_id":null,"body":"global hex_to_dec\n\nsection .text\n\n; <--- unsigned hex_to_dec(const char *hex) --->\nhex_to_dec:\n\txor    r8d, r8d ; result = 0\n\nloop:\n\tmov    al, [rdi]\n\ttest   al, al\n\tje     done\n\nnumber:\n\tcmp    al, '0'\n\tjl     next\n\tcmp    al, '9'\n\tjg     upper\n\tmovzx  ecx, al\n\tsub    ecx, '0'\n\tjmp    digit\n\nupper:\n\tcmp    al, 'A'\n\tjl     next\n\tcmp    al, 'F'\n\tjg     lower\n\tmovzx  ecx, al\n\tsub    ecx, 'A'-10\n\tjmp    digit\n\nlower:\n\tcmp    al, 'a'\n\tjl     next\n\tcmp    al, 'f'\n\tjg     lower\n\tmovzx  ecx, al\n\tsub    ecx, 'a'-10\n\ndigit:\n\tsal    r8d, 4\n\tadd    r8d, ecx\n\nnext:\n\tadd    rdi, 1\n\tjmp    loop\n\ndone:\n\tmov    eax, r8d\n\n\tret\n\n; ---------> endof hex2dec <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213213,"user_id":527,"body":"global hex_to_dec\nextern strtol\n\nsection .text\n\n; unsigned hex_to_dec(const char *hex)\nhex_to_dec:\n                xor     esi, esi\n                mov     edx, 16\n                jmp     strtol\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213214,"user_id":null,"body":"global hex_to_dec\n\nsection .text\n\n; <--- unsigned hex_to_dec(const char *hex) --->\nhex_to_dec:\n  xor eax, eax\n  jmp .cond\n.loop:\n  inc rdi\n  shl rax, 4\n  or cl, 0x20\n  sub cl, '0'\n  mov edx, ecx\n  sub cl, ('a' - '0') - 10\n  cmovc ecx, edx\n  or rax, rcx\n.cond:\n  movzx ecx, byte [rdi]\n  test cl, cl\n  jnz .loop\n  ret\n; ---------> endof hex2dec <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213215,"user_id":1196,"body":"global hex_to_dec\n\nsection .text\n\n; <--- unsigned hex_to_dec(const char *hex) --->\nhex_to_dec:\n  xor eax, eax\n  xor rcx, rcx\n  xor rdx, rdx\n.loop:\n  mov dl, byte [rdi+rcx]\n  shl eax, 4\n  or al, byte [table+rdx-'0']\n  inc rcx\n  cmp byte [rdi+rcx], 0\n  jne .loop\n  ret\n\nsection .data\ntable:\n  db 0,1,2,3,4,5,6,7,8,9\n  dw 0,0,0\n  db 0,10,11,12,13,14,15\n  dq 0,0,0\n  dw 0\n  db 10,11,12,13,14,15","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213216,"user_id":null,"body":"section .text\nglobal hex_to_dec\nextern strtol\n\nhex_to_dec:\n    mov eax, edi\n    mov edx, 0x10\n    xor esi, esi\n    call strtol\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213217,"user_id":null,"body":"global hex_to_dec\n\nsection .text\n\n; <--- unsigned hex_to_dec(const char *hex) --->\nhex_to_dec:\n  mov r8, rdi\n  xor eax, eax\n  jmp .checkdone\n.loop:\n  cmp ecx, 57\n  lea edx, [-7+rcx]\n  cmovg ecx, edx\n  inc r8\n  movsx rcx, cl\n  cmp ecx, 63\n  lea esi, [-32+rcx]\n  movsx rdi, sil\n  cmovg ecx, edi\n  shl eax, 4\n  add ecx, -48\n  or eax, ecx\n.checkdone:\n  movsx ecx, byte [r8]\n  test ecx, ecx\n  jne .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213218,"user_id":null,"body":"global hex_to_dec\n\nsection .text\n\n; <--- unsigned hex_to_dec(const char *hex) --->\nhex_to_dec:\n  push rbp\n  mov rbp, rsp\n  \n  xor eax, eax\n  xor r8, r8\n  dec r8\n  \n.nextchar:\n  inc r8\n  mov cl, byte [rdi + r8]\n  cmp cl, 0\n  jz  .exit\n  sub cl, 48\n  cmp cl, 9\n  jg  .letter\n \n.continue:\n  shl eax, 4\n  add al, cl\n  jmp .nextchar\n  \n.exit:\n  pop rbp\n  ret\n  \n.letter:\n  sub cl, 7\n  cmp cl, 16\n  jl  .continue\n  sub cl, 32\n  jmp .continue\n; ---------> endof hex2dec <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213219,"user_id":3088,"body":"global hex_to_dec\n\nsection .text\n\n; <--- unsigned hex_to_dec(const char *hex) --->\nhex_to_dec:\n    xor eax, eax        ; EAX <- the result\n    xor edx, edx        ; DL will hold the current digit\n    \n    .loop:\n    mov dl, byte[rdi]\n    cmp dl, 0\n    jz .done\n    \n    sub dl, '0'\n    cmp dl, 9       ; Was it 0-9, then we should be at 0-9 now\n    jle .loop_end\n    sub dl, 7\n    cmp dl, 15      ; Was it A-F? Then we should be on 0-15 now\n    jle .loop_end\n    sub dl, 32      ; It was a-f\n    \n    .loop_end:\n    shl eax, 4\n    add eax, edx\n    inc rdi\n    jmp .loop\n    \n    .done:\n    ret\n; ---------> endof hex2dec <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213220,"user_id":1088,"body":"; SPDX-License-Identifier: GPL-2.0\n;\n; Copyright (C) 2021  Ammar Faizi <ammarfaizi2@gmail.com>\n;\n\nsection .rodata\nhex_tbl:\n\ttimes 49 db 0x0\n\tdb 1,2,3,4,5,6,7,8,9\n\ttimes 39 db 0x0\n\tdb 10,11,12,13,14,15\n\nsection .text\nglobal hex_to_dec\n\nmy_strlen:\n\txor\teax, eax\n\tcmp\tbyte [rdi], 0\n\tje\t._out\n._my_loop:\n\tinc\trax\n\tinc\trdi\n\tcmp\tbyte [rdi], 0\n\tjne\t._my_loop\n._out:\n\tret\n\n\nhex_to_dec:\n\tpush\trbp\n\tmov\trbp, rdi\n\tcall\tmy_strlen\n\tmov\trdi, rax\n\n\t; rdx will be the end condition for rdi\n\tlea\trdx, [rbp - 1]\n\n\t; Now we got the tail of string.\n\tlea\trdi, [rdi + rbp - 1]\n\n\t; Start the value to be returned from zero.\n\txor\teax, eax\n\n\t; If we get rdx = rdi here, this means we got an empty string.\n\tcmp\trdx, rdi\n\tje\t._out\n\n\t; rsi will be the cycle counter\n\txor\tesi, esi\n\n\tlea\tr8, [rel hex_tbl]\n\n\t; We don't need rbp anymore, we can reuse it for byte load.\n\tmovzx\tebp, byte [rdi]\n\tor\tebp, ' '\n\tmovzx\teax, byte [r8 + rbp]\n\n\t; If rdx = rdi, we are done!\n\tdec\trdi\n\tcmp\trdx, rdi\n\tje\t._out\n\n._loop:\n\t; Whee...\n\timul\tecx, esi, 4\n\tmov\tr9d, 16\n\tshl\tr9d, cl\n\tmovzx\tebp, byte [rdi]\n\tor\tebp, ' '\n\tmovzx\tebp, byte [r8 + rbp]\n\timul\tebp, r9d\n\tadd\trax, rbp\n\n\t; If rdx = rdi, we are done!\n\tdec\trdi\n\tinc\trsi\n\tcmp\trdx, rdi\n\tjne\t._loop\n._out:\n\tpop\trbp\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a5c31ce298a7e6b7000334":[{"id":213221,"user_id":1196,"body":"global bin_to_dec\n\nsection .text\n\n; <--- unsigned bin_to_dec(const char *bin) --->\nbin_to_dec:\n  xor eax, eax\n  xor rcx, rcx\n.loop:\n  mov dl, byte [rdi+rcx]\n  test dl, dl\n  jz .end\n  shl eax, 1\n  and dl, 1\n  or al, dl\n  inc rcx\n  jmp .loop\n.end:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213222,"user_id":null,"body":"global bin_to_dec\n\nsection .text\n\n; <--- unsigned bin_to_dec(const char *bin) --->\nbin_to_dec:\n    xor eax, eax            ; resetting EAX as <dec>\n    xor ecx, ecx            ; resetting ECX as <dig>\n    movsx edx, byte [rdi]   ; extending <*bin> to EDX as <c>\n.loop:\n    cmp edx, '1'            ; whether <c> is equal to '1'\n    sete cl                 ; setting <dig> to one, otherwise, to zero\n    sal eax, 1              ; shifting <dec> one position left\n    add eax, ecx            ; adding <dig> to <dec>\n    inc rdi                 ; pointing <bin> to the next character\n    movsx edx, byte [rdi]   ; extending <*bin> to EDX as <c>\n    test edx, edx           ; whether <c> is the null character\n    jne .loop               ; otherwise, jumping to the next iteration\n    ret\n; ---------> endof bin2dec <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213223,"user_id":527,"body":"global bin_to_dec\nextern strtoul\n\nsection .text\n\n; unsigned bin_to_dec(const char *bin)\nbin_to_dec:\n                xor     esi, esi\n                mov     edx, 2\n                jmp     strtoul","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213224,"user_id":null,"body":"section .text\nglobal bin_to_dec\n\nbin_to_dec:\n  xor eax, eax\n.loop:\n  mov dl, [rdi]\n  test dl, dl\n  jz .exit\n  shl eax, 1\n  sub dl, '0'\n  or al, dl\n  inc rdi\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213225,"user_id":null,"body":"global bin_to_dec\nsection .text\n\nbin_to_dec:\n  mov rax,0\n  dec rdi\n  \n  loop1:\n  inc rdi\n  rol rax,1\n  \n  cmp byte[rdi],'0'\n  jl end\n  je loop1\n  \n  bts rax,0\n  jmp loop1\n  \n  end:\n  ror rax,1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213226,"user_id":null,"body":"global bin_to_dec\n\nsection .text\n\n; <--- unsigned bin_to_dec(const char *bin) --->\nbin_to_dec:\n  xor eax, eax\n.loop:\n  movzx ecx, byte [rdi]\n  test ecx, ecx\n  je .done\n  inc rdi\n  and ecx, 1\n  lea eax, [rcx + 2*rax]\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213227,"user_id":null,"body":"global bin_to_dec\nsection .text\nbin_to_dec:\nmov rax,0\ndec rdi\nloop1:\ninc rdi\ncmp byte[rdi],48\njl end\nshl rax,1\ncmp byte[rdi],48\nje loop1\nbts rax,0\njmp loop1\nend:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213228,"user_id":null,"body":"global bin_to_dec\n\nsection .text\n\n; <--- unsigned bin_to_dec(const char *bin) --->\nbin_to_dec:\n  xor  eax, eax\n.loop:\n  mov  cl, [rdi]\n  test cl, cl\n  jz .exit\n  shl  eax, 1\n  cmp  cl, '0'\n  je  .continue\n  or   eax, 1\n.continue:\n  inc  rdi\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213229,"user_id":null,"body":"global bin_to_dec\n\nsection .text\n\n; <--- unsigned bin_to_dec(const char *bin) --->\nbin_to_dec:\n    xor rcx, rcx    ; ecx = accumulated value\n    mov bx, '10'    ; cache constants bl='1', bh = '0'\n    mov rsi, rdi    ; rsi = running pointer in string\n    test rsi, rsi\n    jz .exit        ; error: null string pointer\n.loop:\n    lodsb\n    cmp al, bl      ; cmp to '1'\n    jne .not1\n    shl ecx, 1      ; digit is '1'\n    inc ecx\n    jmp .loop\n.not1:\n    cmp al, bh      ; cmp to '0'\n    jne .exit\n    shl ecx, 1      ; digit is '0' \n    jmp .loop\n.exit:              ; not '0' stop parsing\n    mov rax, rcx    ; return value\n    ret\n; ---------> endof bin2dec <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213230,"user_id":null,"body":"global bin_to_dec\n\nsection .text\n\n; <--- unsigned bin_to_dec(const char *bin) --->\nbin_to_dec:\n    xor eax, eax\n    xor ebx, ebx\ncollect:\n    cmp byte [rdi],0\n    je fi\n    shl eax,1\n    mov bl,byte [rdi]\n    sub bl,'0'\n    add eax,ebx\n    inc rdi\n    jmp collect\nfi:\n    ret\n; ---------> endof bin2dec <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a83e447cb1f32de80000d5":[{"id":213231,"user_id":168,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n  xor eax, eax\n  test rdi, rdi\n  jz .end\n  mov rdi, [rdi + 8]\n  call len_r\n  inc rax\n.end:\n  ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213232,"user_id":null,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n  xor eax, eax\n\n.loop:\n  test rdi, rdi\n  jz .done\n  inc rax\n  mov rdi, [rdi+node.next]\n  jmp .loop\n  \n.done:\n  ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213233,"user_id":null,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n    xor rax,rax\ninner:\n    test rdi,rdi\n    je done\n    inc rax\n    mov rdi,[rdi+node.next]\n    call inner\ndone:\n    ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213234,"user_id":null,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n  xor rax, rax            ; RAX <- the result\n_loop:\n  test rdi, rdi\n  jz _exit\n  inc rax\n  mov rdi, [rdi + node.next]\n  jmp _loop\n_exit:\n  ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213235,"user_id":50,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n    xor rax, rax        ; EAX <- the result\n    xor rbx,rbx\n_loop:\n  cmp rdi,0\n  je _exit\n  inc rax\n  mov rdi,[rdi+node.next]\n  jmp _loop\n_exit:\n    ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213236,"user_id":null,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n    xor rax, rax            ; RAX <- the result\n    cmp rdi, 0\n    jz @end\n    mov rdi, [rdi+8]\n    call len_r\n    inc rax\n@end:\n    ret\n    \n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213237,"user_id":77,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n    test rdi, rdi\n    jz .zero\n    mov rdi, [rdi+8]\n    call len_r\n    inc rax\n    ret\n.zero:\n    xor rax, rax            ; RAX <- the result\n    ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213238,"user_id":null,"body":"global len_r\n\nstruc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\n\n; <----- size_t len_r(const struct node *list) ----->\nlen_r:\n    xor rax, rax            ; RAX <- the result\n    test rdi,rdi\n    jz .end\n    mov rdi,[rdi+8]\n    call len_r\n    inc rax\n    .end:\n    ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213239,"user_id":1315,"body":"global len_r\nsection .text\nlen_r:\n    test rdi, rdi\n    jnz  recurse\n    xor  rax, rax\n    ret\nrecurse:\n    mov  rdi, [rdi + 8]\n    call len_r\n    inc  rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213240,"user_id":null,"body":"struc node\n.data:  resd 2\n.next:  resq 1\nendstruc\n\nsection .text\nglobal len_r\n\n; <----- [rax] size_t len_r([rdi] const struct node *list) ----->\nlen_r:\n    ; base condition\n    xor     rax, rax\n    test    rdi, rdi\n    jz      _finish\n    \n    mov    rdi, [rdi + 8]\n    call   len_r\n    inc    rax\n    \n_finish:\n    ret\n; ---------> endof len_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a84137cf1fa5f9f80000d6":[{"id":213241,"user_id":null,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n  xor eax, eax\n.tail:\n  test rdi, rdi\n  je .return\n  add eax, [rdi]\n  mov rdi, [rdi + 8]\n  jmp .tail\n.return:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213242,"user_id":null,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n  xor eax, eax\n  \n.loop:\n  add eax, [rdi+node.data]\n  mov rdi, [rdi+node.next]\n  test rdi, rdi\n  jnz .loop\n  \n  ret\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213243,"user_id":null,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n    xor rax, rax\n_start:\n    test rdi, rdi\n    jz _exit\n    add rax, [rdi]\n    mov rdi, [rdi+8]\n    jmp _start\n_exit:\n    ret\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213244,"user_id":null,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n  lea r8, [rdi]\n  xor rax, rax\n  cmp rdi, 0\n  jz .exit\n \n  add eax, dword [r8 + node.data]\n  mov r8, [r8 + node.next]\n  cmp r8, 0\n  jz .exit\n  \n  push rdi\n  push rsi\n  push rax\n  \n  mov rdi, r8\n  call sum_r\n  \n  pop r8\n  pop rsi\n  pop rdi\n  \n  add eax, r8d\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213245,"user_id":50,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n    xor eax, eax        ; EAX <- the result\n    xor rbx,rbx\n_loop:\n  cmp rdi,0\n  je _exit\n  add eax,[rdi]\n  mov rdi,[rdi+node.next]\n  jmp _loop\n_exit:\n    ret\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213246,"user_id":77,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n    test rdi, rdi\n    jz .zero\n    push rdi\n    mov rdi, [rdi+8]\n    call sum_r\n    pop rdi\n    add eax, [rdi]\n    ret\n.zero:\n    xor eax, eax        ; EAX <- the result\n    ret\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213247,"user_id":null,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n    xor eax, eax        ; EAX <- the result\n    test rdi, rdi\n    jnz .sum\n    ret\n    .sum:\n      push rbx\n      mov rbx, rdi\n      mov rdi, [rdi+8]\n      call sum_r\n      mov rcx, rax\n      movsx rax, dword [rbx]\n      add rax, rcx\n      pop rbx\n      ret\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213248,"user_id":null,"body":"global sum_r\nsum_r:\n  xor rax,rax\n  jmp .start\n   .loop:add rax,[rdi]\n         mov rdi,[rdi+8]\n  .start:test rdi,rdi\n  jne .loop   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213249,"user_id":881,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n    xor eax, eax                ; sum = 0\n    jmp .cond                   ; skip to loop check\n.next:\n    add eax, [rdi]              ; copy current node's data\n    mov rdi, [rdi + node.next]  ; point at next node\n.cond:\n    cmp rdi, 0                  ; if not a null pointer\n    jnz .next                   ; do next node\n    ret                         ; else return\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213250,"user_id":null,"body":"global sum_r\n\nstruc node\n    .data:  resd 1\n    alignb  8\n    .next:  resq 1\nendstruc\n\nsection .text\n\n; <--- int sum_r(const node *list) --->\nsum_r:\n    xor eax, eax        ; EAX <- the result\n.rec:\n    cmp rdi, 0\n    jz  .exit\n    add eax, [rdi]\n    mov rdi, [rdi + 8]\n    call .rec\n.exit:\n    ret\n; ---------> endof sum_r <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57cc981a58da9e302a000214":[{"id":213251,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\nsmall_enough:\n.loop:\n  mov rax, rsi\n  sub rsi, 1\n  jb .done\n  cmp [rdi], edx\n  lea rdi, [rdi + 4]\n  jle .loop\n.done:\n  test rax, rax\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213252,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\nsmall_enough:\n  mov eax, 1\n  xor ecx, ecx\n.loop:\n  test rsi, rsi\n  jz .return\n  cmp [rdi], edx\n  cmovg eax, ecx\n  jg .return\n  add rdi, 4\n  dec rsi\n  jmp .loop\n.return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213253,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\nsmall_enough:\n  xor eax, eax\n  \n.loop:\n  cmp edx, [rdi+rsi*4-4]\n  jl .false\n  dec rsi\n  jnz .loop\n\n  inc eax\n.false:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213254,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\nsmall_enough:\n  xor   rax,rax\n  .loop:\n  cmp  [rdi], edx\n  jg    .end\n  add   rdi, 4\n  dec   rsi\n  jnz   .loop\n  mov   rax, 1\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213255,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\nsmall_enough:\n  xor rbx, rbx\nloop:\n  cmp DWORD [rdi+(rbx*4)],edx\n  jg end\n  inc rbx\n  cmp rbx, rsi\n  jb loop\n  mov rax, 1\n  ret\n  \nend:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213256,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\n; bool small_enough(int* rdi, size_t si, int edx)\nsmall_enough:\n  mov rcx, rsi\n  mov rsi, rdi\n\n  .loop:\n    lodsd\n    cmp eax, edx\n    setle al\n    jg .end\n    loop .loop\n    \n  .end:\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213257,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\n; bool small_enough(int* rdi, size_t si, int edx)\nsmall_enough:\n  mov rcx, rsi\n  mov rsi, rdi\n\n  .loop:\n    lodsd\n    cmp eax, edx\n    setg al\n    jg .end\n    loop .loop\n    \n  .end:\n  xor al, 1\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213258,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\n; bool small_enough(int* rdi, size_t si, int edx)\nsmall_enough:\n  xor rcx, rcx\n  mov rcx, rsi\n  mov rsi, rdi\n\n  .loop:\n    lodsd\n    cmp eax, edx\n    setg al\n    jg .end\n    loop .loop\n    \n  .end:\n  xor al, 1\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213259,"user_id":null,"body":"SECTION .text\nglobal small_enough\n\n\n;bool small_enough(int *arr, size_t length, int limit);\n;                 (rdi  arr,    rsi length, rdx limit)\n\nsmall_enough:\n  mov rax, 1\n  \n  mov rcx, rsi\n  .loop:\n      dec rcx\n      cmp rcx, 0\n      jl .return\n      \n      mov r8d, [rdi + 4 * rcx] \n      cmp r8d, edx\n      jg .false\n      jmp .loop\n      \n  .false:\n      xor rax, rax\n  .return:\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213260,"user_id":null,"body":"section .rodata\n\n    TRUE    equ     1   \n    FALSE   equ     0   \n\nsection .text\n\nglobal small_enough\nsmall_enough:\n\n    push rbx \n    xor rbx, rbx \n    xor rax, rax \n.check:\n    cmp rbx, rsi \n    je .break\n    cmp dword [rdi+(rbx*4)], edx \n    ja .false\n    inc rbx \n    jmp .check\n.break:\n    mov eax, TRUE\n.end:\n    pop rbx \n    ret \n.false:\n    mov eax, FALSE\n    jmp .end\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57cebe1dc6fdc20c57000ac9":[{"id":213261,"user_id":null,"body":"global find_short\n\nsection .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n    ; save registers\n    push rbx             ; word counter\n    push rcx             ; min word length\n        \n    ; Initialize registers\n    mov  al,0      \n    mov  rcx,0xFFFF      ; RCX <-- 0xFFFF\n    mov  rbx,0           ; RBX <-- 0\n    \n    ; Loop until find string termination\nloop1:\n    mov  al,[rdi]\n    cmp  al,0            ; check string terminator '\\0'\n    je   check_length\n    \n    inc  rdi             ; rdi++\n    \n    cmp  al,' '\n    je   check_length\n    \n    inc  rbx             ; rbx++\n    \n    jmp loop1\n\ncheck_length:\n    cmp  rbx,rcx\n    jl   rbx_smaller\n    \n    jmp  reset_word_counter\n    \nrbx_smaller:\n    mov  rcx,rbx\n    \n    jmp  reset_word_counter\n\nreset_word_counter:\n    mov   rbx,0\n    \n    cmp   al,0\n    je    finish\n    \n    jmp   loop1\n\nfinish:\n    mov rax,rcx         ; RAX <- the result\n    \n    ; restore registers\n    pop rcx\n    pop rbx\n        \n    ; return data\n    ret\n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213262,"user_id":null,"body":"global find_short\n\nsection .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n    mov rax, -1         ; setting RAX to the largest value as <len>\n    xor ecx, ecx        ; resetting ECX as <inw>\n    xor rsi, rsi        ; resetting RSI as <n>\n    dec rdi             ; rewinding <s> one character                          \n.loop:\n    inc rdi             ; pointing <s> to the next character\n    mov dl, [rdi]       ; copying <*s> to DL as <c>\n    test dl, dl         ; whether <c> is the null character\n    je .exit            ; jumping to exit\n    cmp dl, ' '         ; whether <c> is a space\n    jne .set            ; otherwise, jumping to the .set label\n    test ecx, ecx       ; whether <inw> is set\n    je .loop            ; jumping to the next iteration\n    xor ecx, ecx        ; resetting <inw>\n    cmp rax, rsi        ; whether <len> is greater than <n>\n    jbe .loop           ; otherwise, jumping to the next iteration\n    mov rax, rsi        ; setting <len> to <n>\n    cmp rax, 1          ; whether <len> is one\n    jne .loop           ; otherwise, jumping to the next iteration\n    mov eax, 1          ; setting <len> to one\n    ret\n.set:\n    inc rsi             ; incrementing <n>\n    test ecx, ecx       ; whether <inw> is not set\n    jne .loop           ; jumping to the next iteration\n    inc ecx             ; setting <inw> to true\n    mov esi, 1          ; setting <n> to one\n    jmp .loop           ; jumping to the next iteration\n.exit:\n    cmp rax, rsi        ; whether <len> is greater than <n>\n    cmova rax, rsi      ; setting <len> to <n>\n    ret\n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213263,"user_id":null,"body":"global find_short\n\nSECTION .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n  mov rax, -1\n  mov r8, .loop\n  xor ecx, ecx\n.loop:\n  mov sil, [rdi]\n  inc rdi\n  test sil, sil\n  jz .term_nul\n  cmp sil, ' '\n  je .term\n  inc rcx\n  jmp .loop\n.term_nul:\n  pop r8\n.term:\n  cmp rax, rcx\n  cmova rax, rcx\n  xor ecx, ecx\n  jmp r8\n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213264,"user_id":null,"body":"global find_short\n\nsection .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n  mov rax, 9223372036854775807\n  xor ecx, ecx\n.loop:\n  mov dl, [rdi]\n  cmp dl, 32\n  je .eow\n  test dl, dl\n  je .done\n  inc rcx\n  jmp .next\n.eow:\n  cmp rcx, rax\n  cmovl rax, rcx\n  xor ecx, ecx\n.next:\n  inc rdi\n  jmp .loop\n.done:\n  cmp rcx, rax\n  cmovl rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213265,"user_id":null,"body":"global find_short\n\nSECTION .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n  mov rax, -1\n  mov r8, .loop\n  xor ecx, ecx\n.loop:\n  mov sil, [rdi]\n  inc rdi\n  cmp sil, 0\n  je .term_nul\n  cmp sil, ' '\n  je .term\n  inc rcx\n  jmp .loop\n.term_nul:\n  pop r8\n.term:\n  cmp rax, rcx\n  cmova rax, rcx\n  xor ecx, ecx\n  jmp r8\n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213266,"user_id":null,"body":"global find_short\n\nSECTION .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n  mov rax, -1\n  mov r8, .loop\n  xor ecx, ecx\n.loop:\n  mov sil, [rdi]\n  inc rdi\n  cmp sil, 0\n  je .term_nul\n  cmp sil, ' '\n  je .term\n  inc rcx\n  jmp .loop\n.term_nul:\n  pop r8\n.term:\n  cmp rax, rcx\n  jbe .continue\n  mov rax, rcx\n.continue:\n  xor ecx, ecx\n  jmp r8\n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213267,"user_id":null,"body":"global find_short\nextern printf\n\nsection .text\nformat db '%d',0\n\n; <--- int find_short(const char *s) --->\nfind_short:\n\nmov rbx,0\nmov rax,999\n\nstartcount:\n\ncmp byte[rdi],0\nje endcount\n\ncmp byte[rdi],32\nje endword\n\ninc rbx\ninc rdi\n\njmp startcount\n\nendword:\n\ncmp rbx,rax\ncmovl rax,rbx\n\nmov rbx,0\n\ninc rdi\njmp startcount\n\nendcount:\n\ncmp rbx,rax\ncmovl rax,rbx\n\n;mov rsi,[rdi+1]\n;mov qword[result],rax\n;mov rsi,rax\n;mov rdi,format\n;add rsp,8\n;call printf\n;sub rsp,8\n;mov rax,qword[result]\n   ;mov rax, -1         ; RAX <- the result\n    ret\n; -----> endof find_short <-----\n\n;section .data\n;result dq 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213268,"user_id":null,"body":"global find_short\n\nsection .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n  mov rax, -1\n  \n.loop0:\n  xor edx, edx\n.loop1:\n  mov cl, [rdi]\n  inc rdi\n  cmp cl, ' '\n  je .space\n  cmp cl, 0\n  je .end\n  inc rdx\n  jmp .loop1\n  \n.space:\n  test rdx, rdx\n  jz .loop0\n  cmp rax, rdx\n  cmova rax, rdx\n  jmp .loop0\n  \n.end:\n  test rdx, rdx\n  jz .end2\n  cmp rax, rdx\n  cmova rax, rdx  \n.end2:\n  ret\n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213269,"user_id":null,"body":"global find_short\n\nsection .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n    xor eax, eax\n    dec eax\n    lea rcx,[rdi-1]\nwordlen:\n    inc rcx\n    test byte[rcx], 0xdf\n    jnz wordlen\n    sub rcx,rdi\n    cmp ecx,eax\n    cmovb eax,ecx\n    add rdi, rcx\n    lea rcx,[rdi]\n    inc rdi\n    cmp byte[rcx],0\n    jne wordlen\n    ret\n    \n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213270,"user_id":null,"body":"global find_short\n\nsection .text\n\n; <--- int find_short(const char *s) --->\nfind_short:\n    xor eax, eax\n    dec eax\nwordlen:\n    lea rcx,[rdi-1]\nloop:\n    inc rcx\n    test byte[rcx], 0xdf\n    jnz loop\n    sub rcx,rdi\n    cmp ecx,eax\n    cmovb eax,ecx\n    add rdi, rcx\n    cmp byte[rdi],0\n    lea rdi, [rdi+1]\n    jne wordlen\n    ret\n    \n; -----> endof find_short <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57cf50a7eca2603de0000090":[{"id":213271,"user_id":168,"body":"section .text\nglobal moveTen\n\n; void moveTen(char *str)\nloop:\n  lea eax, [rdx + 10]\n  sub edx, 16\n  cmp edx, 'a'\n  cmovb edx, eax\n  mov byte [rdi], dl\n  inc rdi\nmoveTen:\n  movzx edx, byte [rdi]\n  test edx, edx\n  jnz loop\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213272,"user_id":null,"body":"section .text\nglobal moveTen\n\n; void moveTen(char *str)\nmoveTen:\n.loop:\n  movzx eax, byte [rdi]\n  test eax, eax\n  je .done\n  test al, 64\n  je .nonalpha\n  and eax, 63\n  mov al, [rax + .map]\n  mov [rdi], al\n.nonalpha:\n  inc rdi\n  jmp .loop\n.done:\n  ret\n.map: db `@KLMNOPQRSTUVWXYZABCDEFGHIJ[\\\\]^_\\`klmnopqrstuvwxyzabcdefghij{|}~\\177`","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213273,"user_id":null,"body":"section .text\nglobal moveTen\n\n; void moveTen(char *str)\nmoveTen:\n    xor rax, rax\n    mov al, byte [rdi]\n    test al, al\n    jz return\n    or al, 32\n    sub al, 'a'\n    add al, 10\n    xor rdx, rdx\n    mov rcx, 26\n    div rcx\n    mov al, dl\n    add al, 'a'\n    mov byte [rdi], al\n    inc rdi\n    jmp moveTen\n    \nreturn:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213274,"user_id":null,"body":"section .text\nglobal moveTen\n\n; void moveTen(char *str)\nmoveTen:\n  .loop:\n  cmp byte [rdi], 0\n  je .done\n  movzx ax, byte [rdi]\n  sub ax, 'a' - 10;\n  mov cl, 26\n  div cl\n  add ah, 'a'\n  mov byte [rdi], ah\n  inc rdi\n  jmp .loop\n  .done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213275,"user_id":null,"body":"section .data\nlookup db 'klmnopqrstuvwxyzabcdefghij',0\nsection .text\nglobal moveTen\n; void moveTen(char *str)\nmoveTen:\n    .loop:\n    cmp     [rdi], byte 0\n    je      .end\n    xor     rcx, rcx\n    xor     rbx, rbx\n    mov     rcx, lookup\n    mov     bl, byte [rdi]\n    sub     bl, 97\n    add     rcx, rbx\n    mov     bl, byte[rcx]\n    mov     [rdi], bl\n    inc     rdi\n    jmp     .loop\n    .end:\n    ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213276,"user_id":null,"body":"A equ 97\nZ equ A + 26\n\nsection .text\nglobal moveTen\n\n; void moveTen(char *str)\nmoveTen:\n    ; modify the string in-place\n    xor rax, rax\n    mov rdx, rdi\n_loop:\n    mov al, [rdi]\n    test al, al\n    jz _end\n    add al, 10\n    cmp al, Z\n    jae _wrap\n_continue:\n    mov [rdi], al\n    inc rdi\n    jmp _loop\n_end:\n    mov rax, rdx\n    ret\n    \n_wrap:\n  sub al, 26\n  jmp _continue\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213277,"user_id":null,"body":"global moveTen\nmoveTen:\n  .b:movzx rax,byte[rdi]\n     mov   al,[move+rax-'a']\n     stosb\n     cmp   byte[rdi],0\n  jne .b   \nret\nmove db 'klmnopqrstuvwxyzabcdefghij'","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213278,"user_id":null,"body":"global moveTen\nmoveTen:\n    mov rcx, -1\n.my_loop:\n    inc rcx\n    cmp byte [rdi+rcx], 0\n    je .end\n    add byte [rdi+rcx], 10\n    cmp byte [rdi+rcx], 'z'\n    jbe .my_loop\n    add byte [rdi+rcx], 'a'-'z'-1\n    jmp .my_loop\n.end:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213279,"user_id":null,"body":"section .text\nglobal moveTen\n\n; void moveTen(char *str)\nmoveTen:\n    xor ecx, ecx\n    mov rdx, 26\n    .loop:\n        xor eax, eax\n        mov al, [rdi+rcx]\n        test rax, rax\n        jz .break\n        sub rax, 87\n        div dl\n        add ah, 97\n        mov [rdi+rcx], ah\n        inc rcx\n        jmp .loop\n    .break:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213280,"user_id":50,"body":"section .text\nglobal moveTen\n\n; void moveTen(char *str)\nmoveTen:\n  xor rax, rax\n  mov rbx,26\n_loop:\n    cmp byte[rdi],0\n    je _exit\n    mov al,[rdi]\n    sub al,87\n    xor rdx,rdx\n    div rbx\n    mov rax,rdx\n    add rax,97\n    mov [rdi],al\n    inc rdi\n    jmp _loop\n_exit:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57d2ba8095497e484e00002e":[{"id":213281,"user_id":null,"body":"extern strlen,malloc\nglobal borrow\n\n; <-- [byte RAX] borrow(ro [byte RDI] src) -->\nborrow:\n  push rbx\n  mov rbx, rdi\n  call strlen\n  lea edi, [rax+1]\n  call malloc\n  xor edx, edx\n  mov r8d, 1\n  mov r9, 576460743847706622\n.loop:\n  mov cl, [rbx]\n  lea rdi, [rax+rdx]\n  test cl, cl\n  je .done\n  test cl, 64\n  je .notalpha\n  mov esi, r8d\n  sal esi, cl\n  movsx rsi, esi\n  test rsi, r9\n  je .notalpha\n  or ecx, 32\n  inc rdx\n  mov [rdi], cl\n.notalpha:\n  inc rbx\n  jmp .loop\n.done:\n  mov byte [rdi], 0\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213282,"user_id":null,"body":"global borrow\nextern strlen,malloc\n; <-- [byte RAX] borrow(ro [byte RDI] src) -->\nborrow:\n    push  rdi\n    call  strlen\n    inc   eax\n    mov   edi, eax\n    call  malloc\n    pop   rdi\n    push  rax\n    mov   r9b, 'a'-'A'\n    .loop:\n    xor   r8b, r8b\n    mov   bl, byte [rdi]\n    cmp   bl, ' '\n    je    .next\n    cmp   bl, 65\n    jl    .next\n    cmp   bl, 91\n    cmovl r8, r9\n    add   bl, r8b\n    mov   byte [rax], bl\n    inc   rdi\n    inc   rax\n    cmp   byte [rdi], 0\n    jne   .loop\n    .end\n    mov   byte [rax], 0\n    pop   rax\n    ret\n    .next:\n    cmp   byte [rdi], 0\n    je    .end\n    inc   rdi\n    jmp   .loop\n; -----> endof borrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213283,"user_id":null,"body":"extern malloc\n\nsection .text\nglobal borrow\n\n; <-- [byte RAX] borrow(ro [byte RDI] src) -->\nborrow:\n  push rdi\n  push rsi\n  \n.strlen:\n  xor rax, rax\n  mov rcx, 0x03ffff\n  repne scasb\n  sub rcx, 0x03ffff\n  neg rcx\n  \n.allocate:\n  push rcx\n  mov rdi, rcx\n  shl rdi, 5\n  call malloc\n  \n  pop rcx\n  pop rsi\n  pop rdi\n  lea r8, [rdi]\n  xor r9, r9\n  xor r10, r10\n  \n.convert:\n  mov bl, byte [r8 + r9]\n  cmp bl, 'A'\n  jl .cont\n  cmp bl, ' '\n  je .cont\n  \n  or bl, 0x20\n  mov byte [rax + r10], bl\n  inc r10\n  \n.cont:\n  inc r9\n  cmp byte [r8 + r9], 0\n  jnz .convert\n  \n  mov byte [rax + r10], 0\n  \n.exit:\n  ret\n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213284,"user_id":1088,"body":"\n[section .text]\n\nextern malloc\nglobal borrow\n\n\n; size_t my_strlen(const char *str);\nmy_strlen:\n\txor\teax, eax\n\tcmp\tbyte [rdi], 0\n\tje\t.l_out\n.l_loop:\n\tadd\trax, 1\n\tadd\trdi, 1\n\tcmp\tbyte [rdi], 0\n\tjne\t.l_loop\n.l_out:\n\tret\n\n\n; char *borrow(const char *src);\nborrow:\n\tpush\trbp\n\tmov\trbp, rdi\n\tcall\tmy_strlen\n\tlea\trdi, [rax + 1]\n\tcall\tmalloc\n\tmov\trsi, rax\n\n\tmov\tdl, byte [rbp]\n\ttest\tdl, dl\n\tjz\t.l_out\n\n.chk_lower:\n\tcmp\tdl, 'a'\n\tjb\t.chk_upper\n\tcmp\tdl, 'z'\n\tjbe\t.do_assign\n.chk_upper:\n\tcmp\tdl, 'A'\n\tjb\t.skip_assign\n\tcmp\tdl, 'Z'\n\tja\t.skip_assign\n.l_tolower:\n\tor\tdl, 0x20\n.do_assign:\n\tmov\tbyte [rsi], dl\n\tadd\trsi, 1\n.skip_assign:\n\tadd\trbp, 1\n\tmov\tdl, byte [rbp]\n\ttest\tdl, dl\n\tjnz\t.chk_lower\n.l_out:\n\tmov\tbyte [rsi], 0\n\tpop\trbp\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213285,"user_id":null,"body":"global borrow\nextern malloc, strlen\n\n; <-- [byte RAX] borrow(ro [byte RDI] src) -->\nborrow:\n  call strlen\n  mov rbx, rdi\n  lea rdi, [rax+1]\n  call malloc\n  push rax\n.lp:\n  mov dl, byte [rbx]\n  cmp dl, 0\n  je .end\n  cmp dl, 'A'\n  jl .nlp\n  cmp dl, 'Z'\n  jg .chlower\n  add dl, 32\n  mov byte [rax], dl\n  inc rax\n  jmp .nlp\n.chlower:\n  cmp dl, 'a'\n  jl .nlp\n  cmp dl, 'z'\n  jg .nlp\n  mov byte [rax], dl\n  inc rax\n.nlp:\n  inc rbx\n  jmp .lp\n.end:\n  mov byte [rax], 0\n  pop rax\n  ret\n; -----> endof borrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213286,"user_id":null,"body":"extern malloc\nextern strlen\n\nglobal borrow\n\n; src:      rdi\n; returns:  rax\nborrow:\n    mov     rbx,    rdi\n    call    strlen\n; src       rbx\n\n    inc     rax\n    mov     rdi,    rax\n    call    malloc\n; res:      rax\n\n    mov     rdi,    rax\n; ptr:      rdi\n\n    .while:\n    mov     cl,     byte [rbx]\n; cl:       current\n    cmp     cl,     0\n    je      .break\n\n    cmp     cl,     'A'\n    jl      .else\n    cmp     cl,     'Z'\n    jg      .else\n\n            sub     cl,     'A'\n            add     cl,     'a'\n            mov     byte [rdi],     cl\n            inc     rdi\n            jmp     .eif \n\n    .else:\n    cmp     cl,     'a'\n    jl      .eif\n    cmp     cl,     'z'\n    jg      .eif\n\n            mov     byte [rdi],     cl\n            inc     rdi\n    \n    .eif:\n    inc     rbx\n    jmp     .while\n\n    .break:\n    mov     byte [rdi],     0\n    ret\n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213287,"user_id":null,"body":"global borrow\nextern strdup\nborrow:\n  push rdi\n  call strdup\n  pop  rsi\n  mov  rdi,rax\n  @b:movsb\n     movzx rcx,byte[rsi-1]\n     or    byte[rdi-1],32\n     bt    [chars],rcx\n     adc   rdi,-1\n     jrcxz @f\n  jmp @b\n  @f:\n  mov [rdi],cl\nret\nchars dq 0,0x7FFFFFE07FFFFFE,0,0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213288,"user_id":null,"body":"global borrow\nextern strdup, realloc\n\n; <-- [byte RAX] borrow(ro [byte RDI] src) -->\nborrow:\n    sub rsp, 0h8            ; aligning the stack boundary before call\n    call strdup             ; duplicating <src>\n    add rsp, 0h8            ; restoring the stack boundary\n    mov rdi, rax            ; pointing RDI to <src> as <res>\n    mov rsi, rax            ; pointing RSI to <src> as <r>\n    dec rax                 ; pointing <src> one character prior to the starting one\n    jmp .exit               ; jumping to exit\n.loop:\n    or edx, 0h20            ; making <c> to be in lower case\n    cmp edx, 'z'            ; whether <c> is above 'z'\n    ja .exit                ; jumping to exit\n    cmp edx, 'a'            ; whether <c> is below 'z'\n    jb .exit                ; jumping to exit\n    mov [rsi], dl           ; copying <c> to <*r>\n    inc rsi                 ; pointing <r> to the next character\n.exit:\n    inc rax                 ; pointing <src> to the next character\n    movzx edx, byte [rax]   ; copying zero-extended <*src> to EDX as <c>\n    test edx, edx           ; whether <c> is the null character\n    jnz .loop               ; otherwise, jumping to the next iteration\n    mov byte [rsi], 0       ; copying the null character to <*r>\n    inc rsi                 ; incrementing the address of <r>\n    sub rsi, rdi            ; computing the number of actual bytes to reallocate\n    jmp realloc             ; reallocating memory and returning from here through there\n; -----> endof borrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57e1e61ba396b3727c000251":[{"id":213289,"user_id":881,"body":"section .text\n\nglobal clean_string\n\n; char *clean_string (char *string)\nclean_string:\n    mov rax, rdi\n    xor rdx, rdx\n.dec_loop:\n    dec rdx\n.loop:\n    mov cl, [rdi]\n    inc rdi\n    cmp cl, '0'\n    jb .copy_char\n    cmp cl, '9'\n    jbe .dec_loop\n.copy_char:\n    mov [rdi + rdx], cl\n    test cl, cl\n    jnz .loop\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213290,"user_id":null,"body":"section .text\nextern strdup\nglobal clean_string\nclean_string:\n  mov  rsi,rdi\n  .b:movsb\n     movzx edx,byte[rsi-1]\n     bt    [nums],edx\n     sbb   rdi,0\n     test  edx,edx\n  jne .b\nret\nnums dq 3FF000000000000h,0,0,0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213291,"user_id":null,"body":"section .text\nglobal clean_string\n\nclean_string:\n  mov rax, rdi\n  mov rsi, rdi\n.loop:\n  mov dl, [rsi]\n  test dl, dl\n  jz .exit\n.digit:\n  cmp dl, '0'\n  jb .continue\n  cmp dl, '9'\n  ja .continue\n  inc rsi\n  mov dl, [rsi]\n  jmp .digit\n.continue:\n  mov [rdi], dl\n  inc rsi\n  inc rdi\n  jmp .loop\n.exit:\n  mov byte [rdi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213292,"user_id":null,"body":"section .text\n\nglobal clean_string\n; char *clean_string (char *string)\nclean_string:\n  mov rax, rdi\n  mov rcx, rdi\n  mov rdx, rdi\n.loop:\n  movsx esi, byte [rcx]\n  test esi, esi\n  je .done\n  lea edi, [rsi - 48]\n  cmp edi, 10\n  jb .digit\n  mov byte [rdx], sil\n  inc rdx\n.digit:\n  inc rcx\n  jmp .loop\n.done:\n  mov byte [rdx], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213293,"user_id":527,"body":"section .text\n\nglobal clean_string\n\n; char *clean_string(char *string)\nclean_string:\n                mov     rax, rdi\n                mov     rsi, rdi\n.loop:          movzx   edx, byte [rdi]\n                inc     rdi\n                mov     [rsi], dl\n                sub     dl, '0'\n                cmp     dl, 10\n                sbb     rsi, -1\n                cmp     dl, -'0'\n                jne     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213294,"user_id":168,"body":"\n\nsection .text\n\nglobal clean_string\n\n; char *clean_string (char *string)\nclean_string:\n  mov rsi, rdi\n  mov rcx, rdi\n  xor edx, edx\n.loop:\n  movzx eax, byte [rsi]\n  mov byte [rdi], al\n  add al, 255 - 9 - '0'\n  cmp al, 255 - 9\n  adc rdi, rdx\n  inc rsi\n  cmp al, 255 - 9 - '0'\n  jne .loop\n  mov rax, rcx\n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213295,"user_id":168,"body":"section .text\n\nglobal clean_string\n\n; char *clean_string (char *string)\nclean_string:\n  mov rsi, rdi\n  mov rcx, rdi\n.loop:\n  movzx eax, byte [rsi]\n  mov edx, eax\n  sub dl, '0'\n  cmp dl, 9\n  seta dl\n  mov byte [rdi], al\n  add rdi, rdx\n  inc rsi\n  test eax, eax\n  jnz .loop\n  mov rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213296,"user_id":50,"body":"section .text\n\nglobal clean_string\n\n; char *clean_string (char *string)\nclean_string:\n    ;  mutate the string in-place and return it\n    mov rax, rdi    ; RAX = output, RDI = input\n    xor rbx,rbx     ; index 1\n    xor rcx,rcx     ; index 2\n_loop:\n    mov dl,[rdi + rbx]\n    test dl,dl\n    jz _exit\n    cmp dl,'0'\n    jge _testDigit\n_ok:\n    mov [rdi + rcx],dl\n    inc rbx\n    inc rcx\n    jmp _loop\n_testDigit:\n    cmp dl,'9'\n    jg _ok\n    inc rbx\n    jmp _loop\n_exit:\n    mov [rdi + rcx],dl\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57eadb7ecd143f4c9c0000a3":[{"id":213297,"user_id":527,"body":"section .text\n\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\nabbrev_name:\n                mov     eax, `\\0.\\0\\0`\n                or      al, byte [rdi]\n.loop:          inc     rdi\n                cmp     [rdi], byte ' '\n                jne     .loop\n                movzx   edx, byte [rdi + 1]\n                shl     edx, 16\n                or      eax, edx\n                and     eax, ~(('A' ^ 'a') | ('A' ^ 'a') << 16)\n                mov     [rsi], eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213298,"user_id":null,"body":"global abbrev_name\n\n; <-- ro [byte RAX] abbrev_name(ro [byte RDI] name, [byte RSI] output[4] -->\nabbrev_name:\n    mov dl, [rdi]           ; loading DL with copying <*name> as <ch>\n    and dl, 0hDF            ; converting <ch> to the upper case\n    mov [rsi], dl           ; copying <ch> to <*output>\n    mov byte [rsi+1], '.'   ; copying '.' to <*(name+1)>\n.loop:\n    inc rdi                 ; pointing <name> to the next character\n    cmp byte [rdi], ' '     ; whether <*name> is a space character\n    jne .loop               ; otherwise, jumping to the next iteration\n    mov dl, [rdi+1]         ; loading <ch> with <*name>\n    and dl, 0hDF            ; converting <ch> to the upper case\n    mov [rsi+2], dl         ; copying <ch> to <*(name+2)>\n    mov byte [rsi+3], `\\0`  ; terminating <output>\n    ret\n; -----> endof abbrev_name <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213299,"user_id":168,"body":"section .text\ntable db '................................ !.#$%&.()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~'\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n  mov rdx, rbx\n  lea rbx, [rel table]\n  xchg rdi, rsi\n  lodsb\n  xlatb\n  stosb\n  mov al, '.'\n  stosb\n  xchg rdi, rsi\n  mov al, ' '\n  xor ecx, ecx\n  dec ecx\n  repne scasb\n  xchg rdi, rsi\n  lodsb\n  xlatb\n  stosb\n  xor eax, eax\n  stosb\n  mov rbx, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213300,"user_id":null,"body":"section .text\n\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n  mov al, [rdi]\n  and al, 0xdf\n  mov [rsi], al\n  mov BYTE [rsi + 1], '.'\n.name1:\n  inc rdi\n  cmp BYTE [rdi], ' '\n  jne .name1\n.spaces:\n  inc rdi\n  cmp BYTE [rdi], ' '\n  je .spaces\n  mov al, [rdi]\n  and al, 0xdf\n  mov BYTE [rsi + 2], al\n  mov BYTE [rsi + 3], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213301,"user_id":null,"body":"section .text\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n  mov al,[rdi]\n  mov ah,'.'\n  cmp al,'a'\n  jl nochange\n  sub al,32\n  nochange:\n  ror eax,16\n  mov rcx,0\n  loop1:\n  inc rcx\n  cmp byte[rdi+rcx],' '\n  jne loop1\n  mov al,[rdi+rcx+1]\n  cmp al,'a'\n  jl end\n  sub al,32\n  end:\n  mov ah,0\n  rol eax,16\n  mov [rsi],eax\n  mov rax,rsi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213302,"user_id":null,"body":"section .text\n\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n  mov al, [rdi]\n  and al, -33\n  mov byte [rsi], al\n  mov byte [rsi + 1], 46\n  inc rdi\n.findspace:\n  cmp byte [rdi], 32\n  lea rdi, [rdi + 1]\n  jne .findspace\n  mov al, [rdi]\n  and al, -33\n  mov byte [rsi + 2], al\n  mov byte [rsi + 3], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213303,"user_id":173,"body":"section .text\n\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n  mov al, byte [rdi]\n  cmp al, 'Z'\n  jbe l_1\n  sub al, 0x20\nl_1:\n  mov byte [rsi], al\n  inc rsi\n  mov byte [rsi], '.'\n  inc rsi\n\n  mov rcx, -1\n  mov rax, ' '\n  cld\n  repne scasb\n  \n  mov al, byte [rdi]\n  cmp al, 'Z'\n  jbe l_2\n  sub al, 0x20\nl_2:\n  mov byte [rsi], al\n  \n  inc rsi\n  mov byte [rsi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213304,"user_id":50,"body":"section .text\n\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n  push rsi ; save pointer to output\n  mov rax,rsi ; rax points to the beginning of output\n  xor rbx,rbx ; will hold chars\n  xor r8,r8 ; flag to check if space found\n  mov bl,byte[rdi]\n  cmp bl,'Z' ; check is first letter is uppercase\n  jg _toupper\n  mov [rax],bl\n_loop: ; advance through the input until finding a space character\n  inc rdi\n  mov bl,byte[rdi]\n  cmp bl,32 ; is current char space ?\n  je _loop2\n  jmp _loop\n_toupper:\n  sub bl,32\n  mov [rax],bl\n  jmp _loop\n_loop2:\n  inc rax\n  mov bl,'.'\n  mov [rax],bl ; add dot to output\n  inc rax ; advance in output\n  inc rdi ; advance in input\n  mov bl,byte[rdi]\n  cmp bl,'Z' ; check if is upper\n  jg _toupper2\n  mov [rax],bl ; add char to output and jump to exit\n  jmp _exit\n_toupper2:\n  sub bl,32 ; upcase the char\n  mov [rax],bl ; add char to output\n_exit:\n  inc rax ; advance in output\n  mov bl,0\n  mov [rax],bl ; terminate string\n  pop rax ; restaure pointer to output to rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213305,"user_id":null,"body":"section .text\n\nglobal abbrev_name\n; void abbrev_name(const char *name, char *output)\n; Take the input `name` and write the output to `output`.\n; Don't forget to add a null byte at the end!\nabbrev_name:\n.getspace_position:\n  push rsi\n  push rdi\n  mov al, 0x20\n  mov rcx, 0x03ff\n  cld\n  repne scasb\n  sub rcx, 0x03ff\n  neg rcx\n  pop rdi\n  pop rsi\n  \n.abbreviate:\n  lea r8, [rsi]\n  lea r9, [rdi]\n  \n  mov al, byte [r9]\n  mov byte [r8], al\n  mov byte [r8 + 1], '.'\n  mov al, byte [r9 + rcx]\n  mov byte [r8 + 2], al\n  mov byte [r8 + 3], 0\n \n.caps:\n  cmp byte [r8], 0x61\n  jl .next\n  sub byte [r8], 0x20\n  \n.next:\n  cmp byte [r8 + 2], 0x61\n  jl .exit\n  sub byte [r8 + 2], 0x20\n  \n.exit: \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213306,"user_id":1088,"body":"\n[section .text]\n\nglobal abbrev_name\n\n; void abbrev_name(const char *name, char *output)\nabbrev_name:\n\tmov\tal, byte [rdi]\n\ttest\tal, al\n\tjz\t.l_out\n\n\tand\tal, 0x5f\n\tmov\tbyte [rsi], al\n\tmov\tbyte [rsi + 1], '.'\n\tadd\trdi, 1\n\tadd\trsi, 2\n.l_loop:\n\tmov\tal, byte [rdi]\n\tcmp\tal, ' '\n\tje\t.got_space\n\ttest\tal, al\n\tjz\t.l_out\n\tadd\trdi, 1\n\tjmp\t.l_loop\n.got_space:\n\tmov\tal, byte [rdi + 1]\n\tand\tal, 0x5f\n\tmov\tbyte [rsi], al\n\tadd\trsi, 1\n.l_out:\n\tmov\tbyte [rsi], 0\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57eae20f5500ad98e50002c5":[{"id":213307,"user_id":null,"body":"section .text\nglobal no_space\nextern malloc\nextern strlen\n\n; char *no_space(const char *str_in)\nno_space:\n  push rdi\n  call strlen\n  lea rdi, [rax + 1]\n  call malloc\n  pop rsi\n  mov rdi, rax\n  \n.loop:\n  mov dl, [rsi]\n  cmp dl, ' '\n  je .skipchar\n  test dl, dl\n  je .exit\n  mov BYTE [rdi], dl\n  inc rdi\n.skipchar:\n  inc rsi\n  jmp .loop\n  \n.exit:\n  mov BYTE [rdi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213308,"user_id":null,"body":"section .text\nglobal no_space\nextern malloc\n\nLen:\n    push rbp\n    mov rbp, rsp\n    xor rax,rax\n    mov rcx, 0\n.repeat:\n    cmp byte [rdi], ' '\n    je .inc\n    cmp byte[rdi], 0\n    je .end\n    inc rcx\n    \n.inc:\n    inc rdi\n    jmp .repeat\n\n.end:\n    inc rcx\n    mov rax, rcx\n    mov rsp, rbp\n    pop rbp\n    ret\n\n; char *no_space(const char *str_in)\n; str_in -> RDI, result -> RAX\nno_space:\n    push rbp\n    mov rbp, rsp\n    push rdi\n    \n    call Len\n    mov rdi, rax\n    call malloc\n    mov rdi, rax\n    mov rsi, [rbp-8]\n    mov dl, ' '\n    \n.repeat:\n    cmp byte [rsi], dl\n    je .doinc\n    cmp byte [rsi], 0\n    je .end\n    movsb\n    jmp .repeat\n    \n.doinc:\n    inc rsi\n    jmp .repeat\n    \n.end:\n    dec rsi\n    mov byte[rdi], 0\n    \n    pop rdi\n    mov rsp, rbp\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213309,"user_id":null,"body":"section .text\nglobal no_space\nextern strdup\nno_space:\n  call strdup\n  mov  rsi,rax\n  mov  rdi,rax\n  .b:movsb\n     cmp  byte[rsi-1],' '\n     sete dl\n     sub  rdi,rdx\n     cmp  byte[rsi-1],0\n  jne .b   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213310,"user_id":null,"body":"section .text\nglobal no_space\nextern malloc\n\n; char *no_space(const char *str_in)\n; str_in -> RDI, result -> RAX\nno_space:\n  push rbx\n  mov rbx, rdi\n  mov edi, 1\n  mov rax, rbx\n.fwd:\n  movzx ecx, byte [rax]\n  cmp ecx, 32\n  je .dctspace\n  test ecx, ecx\n  je .eos\n  inc rdi\n.dctspace:\n  inc rax\n  jmp .fwd\n.eos:\n  call malloc\n  mov rcx, rax\n.cploop:\n  movzx edx, byte [rbx]\n  cmp edx, 32\n  je .dcpspace\n  test edx, edx\n  je .nullterm\n  mov byte [rcx], dl\n  inc rcx\n.dcpspace:\n  inc rbx\n  jmp .cploop\n.nullterm:\n  mov byte[rcx], 0\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213311,"user_id":168,"body":"section .text\nglobal no_space\nextern strdup\n\n; char *no_space(const char *str_in)\n; str_in -> RDI, result -> RAX\nno_space:\n  push rdi\n  call strdup\n  pop rsi\n  mov rdi, rax\n  xor ecx, ecx\n.loop:\n  movzx edx, byte [rsi]\n  inc rsi\n  cmp dl, ' '\n  setne cl\n  mov byte [rdi], dl\n  add rdi, rcx\n  test edx, edx\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213312,"user_id":881,"body":"section .text\nglobal no_space\nextern malloc, realloc\nextern strlen\n\n; char *no_space(const char *str_in)\n; str_in -> RDI, result -> RAX\nno_space:\n    push rdi\n    call strlen\n    mov rdi, rax\n    call malloc\n    mov rdi, rax\n    xor rsi, rsi\n    pop rdx\n    xor rcx, rcx\n; dest -> RDI, dest_index -> RSI, src -> RDX, src index -> RCX\n.for_each_char:\n    mov al, [rdx + rcx]\n    inc rcx\n    cmp al, ' '\n    je .for_each_char\n    mov [rdi + rsi], al\n    inc rsi\n    cmp al, 0\n    jne .for_each_char\n    jmp realloc\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57eae65a4321032ce000002d":[{"id":213313,"user_id":null,"body":"global fakebin\n\nsection .text\n\nfakebin:    \n    push rsi\n    mov r15,rdi\n    mov rdi,rsi\nl1: cmp byte [r15], 0\n    je _done\n    cmp byte [r15],'5'\n    setae al\n    add al,'0'\n    stosb\n    inc r15\n    jmp l1\n_done:\n    mov byte [rdi],0\n    pop rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213314,"user_id":null,"body":"section     .text\nglobal      fakebin\n\nfakebin:\n    xor     rax, rax\n    xor     rdx, rdx\n    xor     rcx, rcx\n\n    dec     rdx\n    \n_loop:\n    inc     rdx\n    mov     cl, [rdi + rdx]\n\n    cmp     cl, 0\n    jz      _exit\n\n    cmp     cl, 0x35\n    jge     _one\n\n    cmp     cl, 0x35\n    jl      _zero\n\n    jmp     _loop\n\n_one:\n    mov     [rsi + rdx], BYTE '1'\n    jmp     _loop\n\n_zero:\n    mov     [rsi + rdx], BYTE '0'\n    jmp     _loop\n    \n\n_exit:\n    mov     [rsi + rdx], BYTE 0\n    mov     rax, rsi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213315,"user_id":null,"body":"global fakebin\n\nsection .text\n\nfakebin:    \n    push rsi\nl1: cmp byte [rdi],0\n    je _done\n    cmp byte [rdi],'5'\n    setae dl\n    add dl,'0'\n    mov byte [rsi],dl\n    inc rsi\n    inc rdi\n    jmp l1\n_done:\n    mov byte [rsi],0\n    pop rax\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213316,"user_id":null,"body":"global fakebin\n\nsection .text\n\n; <----- char *fakebin(const char *digits, char *buffer) ----->\nfakebin:    \n    ; rax should return the pointer to <buffer>\n    xchg rsi, rdi\n    push rdi\n    \n.loop:\n    lodsb\n    test al, al\n    jz .end\n    cmp al, '5'\n    jl .zero\n    jmp .one\n    \n.zero:\n    mov al, '0'\n    stosb\n    jmp .loop\n    \n.one:\n    mov al, '1'\n    stosb\n    jmp .loop\n    \n.end:\n    stosb\n    pop rax\n    ret\n; ---------> end of fakebin <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213317,"user_id":1315,"body":"global fakebin\nsection .text\nfakebin:\n    mov  rax, rsi\n    xor  rcx, rcx\nloop_begin:\n    mov  bl, [rdi+rcx]\n    test bl, bl\n    jz   loop_end\n    cmp  bl, '4'\n    setg bl\n    add  bl, '0'\n    mov  [rsi+rcx], bl\n    inc  rcx\n    jmp  loop_begin\nloop_end:\n    mov  [rsi+rcx], byte 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213318,"user_id":null,"body":"global fakebin\n\nsection .text\n\n; <----- char *fakebin(const char *digits, char *buffer) ----->\nfakebin:\n\tmov rax, rsi\n\tmov rcx, rdi\n_lp:\n\tcmp byte [rcx], 0\n\tje _end\n\tcmp byte [rcx], '5'\n\tjge _one\n\tmov byte [rax], '0'\n\tjmp _endl\n_one:\n\tmov byte [rax], '1'\n_endl:\n\tinc rax\n\tinc rcx\n\tjmp _lp\n_end: \n  mov byte [rax], 0\n\tmov rax, rsi\n\tret\n; ---------> end of fakebin <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213319,"user_id":77,"body":"global fakebin\n\nsection .text\n\n; <----- char *fakebin(const char *digits, char *buffer) ----->\nfakebin:\n    xchg   rsi, rdi\n    mov    rdx, rdi\n.loop:\n    lodsb\n    test   al, al\n    jz     .end\n    cmp    al, '5'\n    mov    al, '0'\n    jl     .zero\n    inc    al\n.zero:\n    stosb\n    jmp    .loop\n.end:\n    stosb\n    mov    rax, rdx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213320,"user_id":null,"body":"global fakebin\n\nsection .text\n\n; <----- char *fakebin(const char *digits, char *buffer) ----->\nfakebin:\n    xor eax, eax\n    xor ecx, ecx\n    xor edx, edx\n    .loop:\n        mov dl, [rdi+rcx]\n        test rdx, rdx\n        jz .end\n        cmp rdx, '5'\n        jl .0\n        mov [rsi+rcx], byte '1'\n        inc rcx\n        jmp .loop\n        .0:\n        mov [rsi+rcx], byte '0'\n        inc rcx\n        jmp .loop\n    .end:\n        mov [rsi+rcx], byte 0\n        mov rax, rsi\n        ret\n; ---------> end of fakebin <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213321,"user_id":null,"body":"global fakebin\n\nsection .text\n\n; char *fakebin(const char *digits, char *buffer)\nfakebin:\n  xchg rdi, rsi\n  mov rax, rdi ;set rax to buffer\n  xor rcx, rcx ;offset\n.loop:\n  cmp BYTE [rsi + rcx], 0\n  je .exit\n  cmp BYTE [rsi + rcx], '5'\n  setge dl\n  mov BYTE [rdi + rcx], '0'\n  add BYTE [rdi + rcx], dl\n  inc rcx\n  jmp .loop\n.exit:\n  mov BYTE [rdi + rcx], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213322,"user_id":null,"body":"global fakebin\n;extern puts\nsection .text\n\nfakebin:\n  ;mov r9,rdi\n  ;call puts\n  ;mov rdi,r9\n  mov rax,0\n  mov rdx,1\n  mov rcx,0\n  loop1:\n  cmp byte[rdi+rcx],0\n  je end\n  cmp byte[rdi+rcx],'5'\n  cmovl rbx,rax\n  cmovge rbx,rdx\n  add rbx,'0'\n  ;mov [out1+rcx],rbx\n  mov [rsi+rcx],rbx\n  inc rcx\n  jmp loop1\n  end:\n  ;mov byte[out1+rcx],0\n  mov byte[rsi+rcx],0\n  mov rax,rsi\n  ;mov rdi,out1\n  ;call puts\n  ;mov rax,out1\nret\n\n;section .bss\n  ;out1 resb 999","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57eb8fcdf670e99d9b000272":[{"id":213323,"user_id":null,"body":"extern strndup\nSECTION .text\nglobal high\n\nhigh:\n  xor ecx, ecx\n  xor eax, eax\n  mov r9, rdi\n.loop:\n  movsx rdx, byte [rdi]\n  cmp rdx, 32\n  je .word\n  test dl, dl\n  je .done\n  add rax, rdx\n  add rax, -96\n  jmp .next\n.word:\n  cmp rax, rcx\n  cmova r8, r9\n  cmova rcx, rax\n  cmova rsi, rdi\n  lea r9, [rdi + 1]\n  xor eax, eax\n.next:\n  inc rdi\n  jmp .loop\n.done:\n  cmp rax, rcx\n  cmova r8, r9\n  cmova rsi, rdi\n  sub rsi, r8\n  mov rdi, r8\n  jmp strndup","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213324,"user_id":460,"body":"extern malloc\nsection .text\nglobal high\nhigh:\npush rbp\nmov rbp, rsp\n  mov r8, rdi ; r8 - pointer to max scored word\n  xor r9, r9 ; r9 - size of max scored word\n  xor rdx, rdx ; rdx - max score\n  xor rcx, rcx ; rcx - current word score\n  xor rsi, rsi ; rsi - current word size\n\n  dec rdi\n  .word_loop:\n    inc rdi\n    xor rax, rax\n    mov al, [rdi] ; al - current letter\n    cmp al, ' ' ; al == ' ' ?\n    jg .is_not_space\n      cmp rcx, rdx ; current score > max score ?\n      jle .not_max_score\n        mov rdx, rcx ; set rdx to new max score\n        mov r8, rdi ; set r8 to address after the word\n        mov r9, rsi ; set r9 to size of new word\n      .not_max_score:\n      xor rcx, rcx ; reset current word score\n      xor rsi, rsi ; reset current word size\n      jmp .continue_loop\n    .is_not_space:\n    inc rsi\n    sub al, 'a'-1 ; ASCII code -> letter score\n    add rcx, rax\n    .continue_loop:\n    cmp byte [rdi], 0 ; *rdi == \\0\n  jne .word_loop\n  sub r8, r9 ; set pointer to word beginning\n  \n  ; allocate array for result string\n  mov rdi, r9\n  inc rdi ; for '\\0'\n  push r8\n  push r9\n  call malloc\n  pop r9\n  pop r8\n  \n  ; copy word from r8 to new array\n  mov byte [rax+r9], 0 ; set '\\0'\n  xor rcx, rcx\n  .copy_word:\n    dec r9\n    mov cl, [r8+r9]\n    mov [rax+r9], cl\n    cmp r9, 0\n  jg .copy_word\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213325,"user_id":460,"body":"extern malloc\nsection .text\nglobal high\nhigh:\npush rbp\nmov rbp, rsp\n  mov r8, rdi ; r8 - points to max scored word\n  xor r9, r9 ; r9 - size of max scored word\n  xor rdx, rdx ; rdx - max score\n  xor rcx, rcx ; rcx - current score\n  xor rsi, rsi ; rsi - current word size\n  dec rdi\n  .loop:\n    inc rdi\n    xor rax, rax\n    mov al, [rdi] ; al - current letter\n    ; al == ' ' ?\n    cmp al, 96\n    jg .is_not_space\n      cmp rcx, rdx ; current score > max score ?\n      jle .not_max_score\n        mov rdx, rcx ; set rdx to new max score\n        mov r8, rdi\n        sub r8, rsi ; set r8 to beginning of word\n        mov r9, rsi ; set r9 to size of new word\n      .not_max_score:\n      xor rcx, rcx ; reset current word score\n      xor rsi, rsi ; reset current word score\n      jmp .continue_loop\n    .is_not_space:\n    inc rsi\n    sub al, 96 ; ASCII code -> letter score\n    add rcx, rax\n    .continue_loop:\n    cmp byte [rdi], 0 ; *rdi == \\0\n  jne .loop\n  \n  mov rdi, r9\n  inc rdi ; for '\\0'\n  push r8\n  push r9\n  call malloc\n  pop r9\n  pop r8\n  mov rdx, rax\n  xor rcx, rcx\n.copy_word:\n  mov cl, [r8]\n  mov [rdx], cl\n  inc r8\n  inc rdx\n  dec r9\n  jnz .copy_word\n  mov byte [rdx], 0 ; set '\\0'\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213326,"user_id":460,"body":"extern malloc\nextern printf\nsection .data\n  fmt db \"%s\"\nsection .text\nglobal high\nhigh:\npush rbp\nmov rbp, rsp\n  mov r8, rdi ; r8 - points to max scored word\n  xor r9, r9 ; r9 - size of max scored word\n  xor rdx, rdx ; rdx - max score\n  xor rcx, rcx ; rcx - current score\n  xor rsi, rsi ; rsi - current word size\n  dec rdi\n  .find_max_score:\n    inc rdi\n    xor rax, rax\n    mov al, [rdi] ; al - current letter\n    ; al == ' ' ?\n    cmp al, 96\n    jg .is_not_space\n      cmp rcx, rdx ; current score > max score ?\n      jle .not_max_score\n        mov rdx, rcx ; set rdx to new max score\n        mov r8, rdi\n        sub r8, rsi ; set r8 to beginning of word\n        mov r9, rsi ; set r9 to size of new word\n      .not_max_score:\n      xor rcx, rcx ; reset current word score\n      xor rsi, rsi ; reset current word score\n      jmp .continue_loop\n    .is_not_space:\n    inc rsi\n    sub al, 96 ; ASCII code -> letter score\n    add rcx, rax\n    .continue_loop:\n    cmp byte [rdi], 0 ; *rdi == \\0\n  jne .find_max_score\n  \n  ; allocate array for result string\n  mov rdi, r9\n  inc rdi ; for '\\0'\n  push r8\n  push r9\n  call malloc\n  pop r9\n  pop r8\n  \n  ; copy word from r8 to new array\n  mov byte [rax+r9], 0 ; set '\\0'\n  xor rcx, rcx\n  .copy_word:\n    dec r9\n    mov cl, [r8+r9]\n    mov [rax+r9], cl\n    cmp r9, 0\n  jg .copy_word\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213327,"user_id":460,"body":"extern malloc\nextern printf\nsection .data\n  fmt db \"%s\"\nsection .text\nglobal high\nhigh:\npush rbp\nmov rbp, rsp\n  mov r8, rdi ; r8 - points to max scored word\n  xor r9, r9 ; r9 - size of max scored word\n  xor rdx, rdx ; rdx - max score\n  xor rcx, rcx ; rcx - current score\n  xor rsi, rsi ; rsi - current word size\n  dec rdi\n  .loop:\n    inc rdi\n    xor rax, rax\n    mov al, [rdi] ; al - current letter\n    ; al == ' ' ?\n    cmp al, 96\n    jg .is_not_space\n      cmp rcx, rdx ; current score > max score ?\n      jle .not_max_score\n        mov rdx, rcx ; set rdx to new max score\n        mov r8, rdi\n        sub r8, rsi ; set r8 to beginning of word\n        mov r9, rsi ; set r9 to size of new word\n      .not_max_score:\n      xor rcx, rcx ; reset current word score\n      xor rsi, rsi ; reset current word score\n      jmp .continue_loop\n    .is_not_space:\n    inc rsi\n    sub al, 96 ; ASCII code -> letter score\n    add rcx, rax\n    .continue_loop:\n    cmp byte [rdi], 0 ; *rdi == \\0\n  jne .loop\n  \n  mov rdi, r9\n  inc rdi ; for '\\0'\n  push r8\n  push r9\n  call malloc\n  pop r9\n  pop r8\n  mov rdx, rax\n  xor rcx, rcx\n.copy_word:\n  mov cl, [r8]\n  mov [rdx], cl\n  inc r8\n  inc rdx\n  dec r9\n  jnz .copy_word\n  mov byte [rdx], 0 ; set '\\0'\nleave\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213328,"user_id":173,"body":"section .data\nfmt: db \"s: %s\", 10, 0\nextern strdup, printf\nSECTION .text\nglobal high\n\nhigh:\n  ; highest score\n  mov r12, 0\n  ; index of word with highest score\n  mov r13, 0\n  ; address of current word\n  mov r14, rdi\n  ; current score\n  mov rax, 0\nl_next:\n  cmp byte [rdi], 0\n  je l_done\n  \n  cmp byte [rdi], ' '\n  je l_end_of_word\n  \n  \n  xor cx, cx\n  mov byte cl, [rdi]\n  sub cx, 0x60\n  add ax, cx\n  inc rdi\n  jmp l_next\n  \n\nl_done:\n  ; check last word\n  cmp rax, r12\n  cmova r12, rax\n  cmova r13, r14\n\n  mov rdi, r13\n  call strdup\n  mov r13, rax\n  \n  ; add string terminator\nl_addterm:\n  cmp byte [r13], 0\n  je l_termdone\n\n  cmp byte [r13], 0x20\n  je l_repl\nl_cont:\n  inc r13\n  jmp l_addterm\nl_termdone:\n\n  push rax\n  lea rdi, [rel fmt]\n  mov rsi, rax\n  call printf\n  pop rax\n  \n  ret\n  \nl_repl:\n  mov byte [r13], 0\n  jmp l_termdone\n  \nl_end_of_word:\n  cmp rax, r12\n  cmova r12, rax\n  cmova r13, r14\n  \n  mov rax, 0\n  inc rdi\n  mov r14, rdi\n  \n  ; eat up empty spaces\nl_checkspaces:\n  cmp byte [rdi], 0x20\n  je l_space\n  jmp l_next\n  \nl_space:\n  inc rdi\n  mov r14, rdi\n  jmp l_checkspaces","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213329,"user_id":null,"body":"SECTION .text\nglobal high\nextern malloc\n\nhigh:\n  xor rax,rax\n  mov rsi,rdi\n  xor r9,r9        ; highest score\n  mov r10,rsi      ; start of highest scoring word\n.score_word:\n  xor r8,r8        ; current score\n  mov r11,rsi      ; start of current word\n.letter:\n  lodsb\n  sub al,96\n  jbe .word_done\n  add r8,rax\n  jmp .letter\n.word_done:\n  cmp r8,r9        ; is this word better?\n  cmova r9,r8      ; then its score is now the highest score\n  cmova r10,r11    ; and its address is the address of the best word\n  add al,96        ; and was it the end of the string?\n  jnz .score_word  ; if not, get next word \n  mov rsi,r10      ; otherwise, find out how long this word is\n  xor rcx,rcx\n.size:\n  inc rcx          ; this will give one too many, but we need it for the zero terminator anyway\n  lodsb\n  cmp al,'a'\n  jae .size\n  push r10         ; keep address\n  push rcx         ; and length\n  mov rdi,rcx\n  call malloc      ; allocate memory\n  pop rcx\n  pop rsi          ; address of best word into source index\n  test rax,rax     ; return NULL if allocation failed\n  jz .out\n  mov rdi,rax      ; set destination index to allocated memory      \n  mov rdx,rax      ; also keep it around to return it\n  rep movsb        ; copy the word\n  mov [rdi-1],byte 0  ; write terminator\n  mov rax,rdx\n.out:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213330,"user_id":null,"body":"SECTION .text\nextern strdup, free\nglobal high\n; rcx - score of current word\n; rdx - score of highest ranking word\n; r8 - addr of highest ranking word\n; r9 - addr of current word\n\nhigh:\n    call strdup\n    push rax\n    mov rdi,rax\n    xor rax, rax\n    xor rcx, rcx\n    xor rdx, rdx\n    mov r8,rdi\n    \n@main:\n    mov al,[rdi]\n    inc rdi\n    test al,al\n    jz @return\n    cmp al, ' '\n    je @next_word\n    test rcx,rcx ; Check if it's a new word\n    jnz @not_space\n    lea r9,[rdi -1]\n@not_space:\n    sub al, 96\n    add rcx,rax\n    jmp @main\n    \n@next_word:\n    cmp rcx,rdx\n    cmovg rdx,rcx\n    cmovg r8,r9\n    mov byte [rdi -1],0 ; Replace space with zero to terminate current word\n    xor rcx,rcx\n    jmp @main\n    \n@return:\n    cmp rcx,rdx\n    cmovg r8,r9\n    mov rdi,r8\n    call strdup ; Duplicate highest ranking word\n    pop rdi \n    push rax\n    call free  ; Free copy of original string\n    pop rax\n    ret    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213331,"user_id":null,"body":"SECTION .text\nextern strdup, free\nglobal high\n; rcx - score of current word\n; rdx - score of highest ranking word\n; r8- addr of highest ranking word\n; r9 - addr of current word\n\nhigh:\n    call strdup\n    push rax\n    mov rdi,rax\n    xor rax, rax\n    xor rcx, rcx\n    xor rdx, rdx\n    mov r8,rdi\n@l1:  \n    mov al,[rdi]\n    inc rdi\n    test al,al\n    jz @r\n    cmp al, ' '\n    je @l3\n    test rcx,rcx\n    jnz @l2\n    lea r9,[rdi -1]\n@l2:sub al, 96\n    add rcx,rax\n    jmp @l1\n    \n@l3 cmp rcx,rdx\n    cmovg rdx,rcx\n    cmovg r8,r9\n    mov byte [rdi -1],0\n    xor rcx,rcx\n    jmp @l1\n    \n@r: cmp rcx,rdx\n    cmovg r8,r9\n    mov rdi,r8\n@r2:call strdup ; Duplicate max word\n    pop rdi \n    push rax\n    call free  ; Free copy of original string\n    pop rax\n    ret    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213332,"user_id":null,"body":"SECTION .text\nglobal high\nextern malloc\nextern strcpy\nextern strlen\nextern free\n\nhigh:\n    push rbx\n    push r15\n    sub rsp, 0x20\n\n.mystrcpy:\n    mov r15, rdi\n    call strlen\n    inc rax\n    mov rdi, rax\n    call malloc\n    mov [rsp + 0x8], rax\n    mov rdi, rax\n    mov rsi, r15\n    call strcpy\n    mov rdi, rax\n\n.setup:\n    xor rax, rax\n    xor rbx, rbx\n    xor rcx, rcx\n    xor rdx, rdx\n    xor rsi, rsi\n\n    mov [rsp + 0x10], rax\n    mov rbx, rdi\n    mov rdx, rbx\n\n.loop2:\n    cmp [rbx], BYTE 0x0\n    je .loop1\n    cmp [rbx], BYTE 0x20\n    je .loop1\n    mov sil, BYTE [rbx]\n    sub sil, 0x60\n    add rcx, rsi\n    inc rbx\n    jmp .loop2\n\n.loop1:\n    cmp rcx, [rsp + 0x10]\n    jg .greater\n    jmp .next\n\n.greater:\n    mov [rsp + 0x10], rcx\n    mov [rsp + 0x18], rdx\n\n.next:\n    cmp [rbx], BYTE 0x0\n    je .mystrcpy2\n    mov [rbx], BYTE 0x0\n    inc rbx\n    mov rdx, rbx\n    xor rcx, rcx\n    jmp .loop2\n\n.mystrcpy2:\n    mov rdi, [rsp + 0x18]\n    call strlen\n    mov rdi, rax\n    inc rdi\n    call malloc\n\n    mov [rsp], rax\n    mov rdi, rax\n    mov rsi, [rsp + 0x18]\n    call strcpy\n    mov rdi, [rsp + 0x8]\n    call free\n\n.leave:\n    mov rax, [rsp]\n    add rsp, 0x20\n    pop r15\n    pop rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57ebaa8f7b45ef590c00000c":[{"id":213333,"user_id":null,"body":"extern atoi\nextern malloc\nglobal nums2alpha\n\n; <-- [byte RAX] nums2alpha(ro [qword [byte RDI]] codes, RSI n) -->\nnums2alpha:\n  push r15\n  push r14\n  push r12\n  push rbx\n  push rax\n  mov r14, rdi\n  lea rdi, [rsi + 1]\n  mov r15, rsi\n  call malloc\n  mov r12, rax\n  xor ebx, ebx\n.loop:\n  cmp r15, rbx\n  je .done\n  mov rdi, [r14 + 8*rbx]\n  call atoi\n  cdqe\n  mov al, [rax + .str]\n  mov [r12 + rbx], al\n  inc rbx\n  jmp .loop\n.done:\n  mov byte [r12 + r15], 0\n  mov rax, r12\n  add rsp, 8\n  pop rbx\n  pop r12\n  pop r14\n  pop r15\n  ret\n.str: db \"@zyxwvutsrqponmlkjihgfedcba!? \"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213334,"user_id":null,"body":"section .text\nglobal nums2alpha\nextern malloc\n\n; <-- [byte RAX] nums2alpha(ro [qword [byte RDI]] codes, RSI n) -->\nnums2alpha:\n  push rdi\n  push rsi\n\n  ; malloc(n+1)\n  mov rdi, rsi\n  inc rdi\n  call malloc\n  mov r8, rax\n  mov r9, rax\n\n  pop rax\n  pop rdi\n\n  ; get addr to stop at\n  ; *array + n*8\n  mov rcx, 8\n  mul rcx\n  mov rsi, rax\n  add rsi, rdi\n\n  ; rdi = input char *[] and iterator\n  ; rsi = stop addr\n  ; r8  = return char *\n  ; r9  = return char * iterator\n\n.loop:\n  xor rax, rax\n  xor rcx, rcx\n\n  mov rdx, [rdi] ; deref char *\n\n  mov al, [rdx] ; get first digit\n  test al, al\n  jz .continue\n\n  sub al, '0' ; convert ascii digit to num value\n\n  mov cl, [rdx+1]\n  test cl, cl ; check for second digit\n  jz .no_mul\n\n  ; if its a two digit number, mul first by 10 then add second\n  sub cl, '0'\n  mov dl, 10\n  mul dl\n  add al, cl\n\n.no_mul:\n  cmp al, 26\n  jbe .letter\n\n  cmp al, 27\n  je .exclamation\n\n  cmp al, 28\n  je .question\n\n  cmp al, 29\n  je .space\n\n.letter:\n  ; letter = abs(x-26) + 'a'\n  \n  sub al, 26\n\n  ; abs(al)\n  mov dl, al\n  neg al\n  jnl .letter_cont\n  mov al, dl\n\n.letter_cont:\n  add al, 'a'\n  mov BYTE [r9], al\n  jmp .continue\n\n.exclamation:\n  mov BYTE [r9], '!'\n  jmp .continue\n\n.question:\n  mov BYTE [r9], '?'\n  jmp .continue\n\n.space:\n  mov BYTE [r9], ' '\n\n.continue:\n  inc r9\n  add rdi, 8\n  cmp rdi, rsi\n  jne .loop\n\n  ; null terminate\n  mov BYTE [r9], 0\n\n  mov rax, r8\n  ret\n; -----> endof nums2alpha <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213335,"user_id":null,"body":"global nums2alpha\nextern malloc\nnums2alpha:\n    push rdi\n    push rsi\n    lea  rdi,[rsi+1]\n    call malloc\n    pop  rsi\n    pop  rdi\n    mov  byte[rax+rsi],0\n    @b:mov   rdx,[rdi+rsi*8-8]\n       movzx rdx,word[rdx]\n       mov   dl,[tab+rdx-'1']\n       mov   [rax+rsi-1],dl\n       dec   rsi\n    jne @b   \n    ret\ntab db 'zyxwvutsr'\n    resb '10'-'9'-1\n    db 'qg'\n    resb '11'-'10'-2\n    db 'pf'\n    resb '12'-'11'-2\n    db 'oe'\n    resb '13'-'12'-2\n    db 'nd'\n    resb '14'-'13'-2\n    db 'mc'\n    resb '15'-'14'-2\n    db 'lb'\n    resb '16'-'15'-2\n    db 'ka'\n    resb '17'-'16'-2\n    db 'j!'\n    resb '18'-'17'-2\n    db 'i?'\n    resb '19'-'18'-2\n    db 'h '","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213336,"user_id":null,"body":"global nums2alpha\nextern atoi\nextern calloc\n\n; <-- [byte RAX] nums2alpha(ro [qword [byte RDI]] codes, RSI n) -->\nnums2alpha:\n    ; Allocate memory. \n    mov r12, rdi\n    mov r13, rsi\n    \n    mov rdi, rsi\n    mov rsi, 1\n    inc rdi\n    call calloc\n    \n    ; Save the buffer and the beginning of the buffer in <R14> and <R15>\n    mov r14, rax\n    mov r15, rax\n    \n    ; Restore <RSI> and <RDI>.\n    mov rsi, r13\n    mov rdi, r12\n    \n    ; Loop and convert.\n    mov rcx, rsi\n    xor al, al\n    \nconvert:\n    ; Convert string to number\n    mov r12, rdi\n    mov r13, rcx\n    \n    mov rdi, [rdi]\n    call atoi\n    \n    mov rdi, r12\n    mov rcx, r13\n    \n    ; Check special cases.\nexclamation:\n    cmp al, 0x1b\n    jnz question\n    mov al, 0x21\n    jmp cases_end\n    \nquestion:\n    cmp al, 0x1c\n    jnz space\n    mov al, 0x3f\n    jmp cases_end\n    \nspace:\n    cmp al, 0x1d\n    jnz normal_case\n    mov al, 0x20\n    jmp cases_end\n    \nnormal_case:\n    neg rax\n    add rax, 0x1a\n    add rax, 0x61\n    \ncases_end:\n    mov [r14], al\n    inc r14\n    \n    ; Go to next element.\n    mov rdi, r12\n    add rdi, 8\n    loop convert\n    \n    mov rax, r15\n    ret\n; -----> endof nums2alpha <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213337,"user_id":null,"body":"global nums2alpha\nextern calloc, atoi\n\n; <-- [byte RAX] nums2alpha(ro [qword [byte RDI]] codes, RSI n) -->\nnums2alpha:\n    push r14                ; saving R14 onto stack\n    push r13                ; saving R13 onto stack\n    push r12                ; saving R12 onto stack\n    push rbx                ; saving RBX onto stack\n    push rbp                ; saving RBP onto stack\n    mov rbp, rdi            ; pointing RBP to <codes>\n    mov rbx, rsi            ; copying <n> to RBX\n    mov rdi, 1              ; setting RDI to one byte\n    inc rsi                 ; adding extra space to the null character\n    call calloc             ; allocating memory for <r>\n    mov r12, rax            ; pointing R12 to <r>\n    mov r13, rax            ; pointing R13 to <r> as <s>\n    mov r14, .dict          ; pointing R14 to <.dict>\n.loop:\n    mov rdi, [rbp]          ; pointing RDI to <*codes>\n    call atoi               ; converting <*codes> to <inx>\n    mov dl, [r14+rax]       ; copying <*(.dict+inx)> to DL as <ch>\n    mov [r13], dl           ; copying <ch> to <*s>\n    inc r13                 ; promoting <s> to the next character position\n    add rbp, 0h8            ; pointing <codes> to the next code\n    dec rbx                 ; decrementing <n>\n    ja .loop                ; jumping to the next iteration if <n> is above zero\n    mov rax, r12            ; setting the result to <r>\n    pop rbp                 ; restoring the original RBP from stack\n    pop rbx                 ; restoring the original RBX from stack\n    pop r12                 ; restoring the original R12 from stack\n    pop r13                 ; restoring the original R13 from stack\n    pop r14                 ; restoring the original R14 from stack\n    ret\n.dict:\n    db  `\\0zyxwvutsrqponmlkjihgfedcba!? `\n; -----> endof nums2alpha <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57f24e6a18e9fad8eb000296":[{"id":213338,"user_id":null,"body":"SECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  mov rax, rdi\n  dec rax\n  xor edx, edx\n  mov rcx, 6\n  div rcx\n  add rdx, rdx\n  lea rax, [.phrase + rdx * 8]\n  ret\n\nsection .data\n  .phrase:\n    db \"I love you\", 0\n    align 16, db 0\n    db \"a little\", 0\n    align 16, db 0\n    db \"a lot\", 0\n    align 16, db 0\n    db \"passionately\", 0\n    align 16, db 0\n    db \"madly\", 0\n    align 16, db 0\n    db \"not at all\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213339,"user_id":null,"body":"SECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  xor   rdx, rdx\n  mov   rax, rdi\n  dec   rax\n  mov   rcx, 6\n  div   rcx                ; rdx = (rdi-1) % 6\n  mov   rax,[table+rdx*8]\n  ret\n  \nSECTION .data\n\ntext0:  db 'I love you',0\ntext1:  db 'a little',0\ntext2:  db 'a lot',0\ntext3:  db 'passionately',0\ntext4:  db 'madly',0\ntext5:  db 'not at all',0\n\ntable:  dq text0\n        dq text1\n        dq text2\n        dq text3\n        dq text4\n        dq text5\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213340,"user_id":null,"body":"SECTION .text\nglobal how_much_i_love_you\nstr0: db 'not at all', 0\nstr1: db \"I love you\", 0\nstr2: db \"a little\", 0\nstr3: db \"a lot\", 0\nstr4: db \"passionately\", 0\nstr5: db \"madly\", 0\n        \nhow_much_i_love_you:\n  xor rax, rax\n  mov rax, rdi\n  mov rcx, 6\n  xor rdx, rdx\n  div rcx\n  cmp dl, 1\n  jz msg1\n  cmp dl, 2\n  jz msg2\n  cmp dl, 3\n  jz msg3\n  cmp dl, 4\n  jz msg4\n  cmp dl, 5\n  jz msg5\n  mov rax, str0\n  jmp exit\n  msg1:\n  mov rax, str1\n  jmp exit\n  msg2:\n  mov rax, str2\n  jmp exit\n  msg3:\n  mov rax, str3\n  jmp exit\n  msg4:\n  mov rax, str4\n  jmp exit\n  msg5:\n  mov rax, str5\n  exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213341,"user_id":null,"body":"SECTION .text\nglobal how_much_i_love_you\n\nout1 db 'I love you',0\nout2 db 'a little',0\nout3 db 'a lot',0\nout4 db 'passionately',0\nout5 db 'madly',0\nout6 db 'not at all',0\n\nhow_much_i_love_you:\n  loop1:\n  cmp rdi,6\n  jle choiche\n  sub rdi,6\n  jmp loop1\n  \n  choiche:\n  mov rax,out1\n  cmp rdi,2\n  jl end\n  mov rax,out2\n  je end\n  \n  mov rax,out3\n  cmp rdi,4\n  jl end\n  mov rax,out4\n  je end\n  \n  mov rax,out5\n  cmp rdi,5\n  je end\n  mov rax,out6\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213342,"user_id":null,"body":"SECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  mov eax, 715827883\n  dec edi\n  imul edi\n  mov ecx, edi\n  sar ecx, 31\n  sub edx, ecx\n  lea esi, [rdx+rdx*2]\n  add esi, esi\n  sub edi, esi\n  movsxd rdi, edi\n  mov rax, [.answers+rdi*8]\n  ret\n.s1: db \"I love you\", 0\n.s2: db \"a little\", 0\n.s3: db \"a lot\", 0\n.s4: db \"passionately\", 0\n.s5: db \"madly\", 0\n.s6: db \"not at all\", 0\n.answers: dq .s1,.s2,.s3,.s4,.s5,.s6\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213343,"user_id":null,"body":"section .data\ns0 db 'not at all', 0\ns1 db 'I love you', 0\ns2 db 'a little', 0\ns3 db 'a lot', 0\ns4 db 'passionately', 0\ns5 db 'madly', 0\ntable dq s0, s1, s2, s3, s4, s5\n\nsection .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  mov rax, rdi               ; low dividend is nb_petals\n  xor rdx, rdx               ; high dividend is 0 \n  mov rdi, 6                 ; divisor is 6 (our message count)\n  div rdi                    ; divide!\n  mov rax, [table + rdx * 8] ; offset to appropriate message is in RDX now\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213344,"user_id":null,"body":"extern printf\n\nSECTION .data\n  fmt db '%s', 10, 0\n  fmt2 db '%d', 10, 0\n  \n  first db 'I love you', 0\n  second db 'a little', 0\n  third db 'a lot', 0\n  fourth db 'passionately', 0\n  fifth db 'madly', 0\n  sixth db 'not at all', 0\n  levels dq sixth, first, second, third, fourth, fifth\n  \nSECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  xor rdx, rdx\n  mov r8, 6\n  mov rax, rdi\n  idiv r8\n  mov rax, qword [levels + rdx * 8]\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213345,"user_id":50,"body":"section .data\n  a  db \"I love you\",0\n  b  db \"a little\",0\n  c  db \"a lot\",0\n  d  db \"passionately\",0\n  e  db \"madly\",0\n  f  db \"not at all\",0\n  \nSECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  xor rax, rax\n  mov rax,rdi\n  dec rax\n  mov rcx,6\n  xor rdx,rdx\n  div rcx\n  cmp rdx,0\n  je _a\n  cmp rdx,1\n  je _b\n  cmp rdx,2\n  je _c\n  cmp rdx,3\n  je _d\n  cmp rdx,4\n  je _e\n  mov rax,f\n  ret\n_a:\n  mov rax,a\n  ret\n_b:\n  mov rax,b\n  ret\n_c:\n  mov rax,c\n  ret\n _d:\n  mov rax,d\n  ret\n _e:\n  mov rax,e\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213346,"user_id":null,"body":"section .data\nsix      dw 6\nlove     db \"I love you\",0\nlittle   db \"a little\", 0\nlot      db \"a lot\",0\npass     db \"passionately\", 0\nmad      db \"madly\", 0\nnotat    db \"not at all\", 0\npetals   dq love, little, lot, pass, mad, notat\n\nSECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  xor rdx, rdx\n  lea rax, [rdi -1]\n  div word [six]\n  mov rax, [petals + rdx * 8]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213347,"user_id":null,"body":"SECTION .text\nglobal how_much_i_love_you\n\nhow_much_i_love_you:\n  dec rdi\n  cmp rdi,6\n  jl c\nwhile:\n  sub rdi, 6\n  cmp rdi, 5\n  jg while\nc:\n  lea r8, [starr]\n  mov rax, [r8+ rdi*8]\n  \n  ret\n  \nSECTION .data\n\nstr0: db \"I love you\",0\nstr1: db \"a little\",0\nstr2: db \"a lot\",0\nstr3: db \"passionately\",0\nstr4: db \"madly\",0\nstr5: db \"not at all\",0\n\nstarr: dq str0, str1, str2, str3, str4, str5","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57f36495c0bb25ecf50000e7":[{"id":213348,"user_id":null,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  mov eax, edi\n  mov ecx, 3\n  mov r8d, 15\n  cdq\n  idiv ecx\n  mov ecx, 5\n  mov esi, eax\n  mov eax, edi\n  cdq\n  idiv ecx\n  mov ecx, eax\n  mov eax, edi\n  cdq\n  idiv r8d\n  lea edx, [rsi+1]\n  imul edx, esi\n  lea edx, [rdx+rdx*2]\n  mov edi, eax\n  lea eax, [rcx+1]\n  imul eax, ecx\n  mov ecx, 2\n  lea eax, [rax+rax*4]\n  add edx, eax\n  lea eax, [rdi+1]\n  imul eax, edi\n  imul eax, eax, -15\n  add eax, edx\n  cdq\n  idiv ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213349,"user_id":null,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  mov eax, edi\n  xor edx, edx\n  mov ecx, 3\n  div ecx\n  lea edx, [eax+1]\n  mul edx\n  mul ecx\n  mov esi, eax\n  \n  mov eax, edi\n  xor edx, edx\n  mov ecx, 5\n  div ecx\n  lea edx, [eax+1]\n  mul edx\n  mul ecx\n  add esi, eax\n  \n  mov eax, edi\n  xor edx, edx\n  mov ecx, 15\n  div ecx\n  lea edx, [eax+1]\n  mul edx\n  mul ecx\n  neg eax\n  \n  add eax, esi\n  shr eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213350,"user_id":263,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  xor eax, eax\n  xor r8, r8\n  mov r9, 3\n  mov r10, 5\n  loop:\n    mov edx, 0\n    mov eax, edi\n    div r9\n    or edx, edx\n    jz divisible\n    mov edx, 0\n    mov eax, edi\n    div r10\n    or edx, edx\n    jz divisible\n    jmp break\n  divisible:\n    add r8d, edi\n  \n  break:\n  dec rdi\n  jnz loop\n  mov eax, r8d\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213351,"user_id":null,"body":"section .data\n  multiples dq 3, 5, 15\n  \nsection .text\nglobal find_sum\n\nfind_sum:\n  xor rax, rax\n  xor r8, r8\n  xor r9, r9\n  \n.for:\n  push rdi\n  xor rdx, rdx\n  mov rax, rdi\n  mov rsi, qword [multiples + r8 * 8]\n  idiv rsi\n  lea rdi, [rax + 1]\n  call _sum\n  pop rdi\n  cmp rsi, 15\n  je .sub\n  add r9, rax\n  jmp .cont\n  \n.sub:\n  sub r9, rax\n  \n.cont:\n  inc r8\n  cmp r8, 3\n  jl .for\n  \n  mov rax, r9\n  ret\n  \n; rdi => N, rsi => multiple\n; sum = multiple * (N)(N-1)\/2\n_sum:\n  push rbp\n  mov rbp, rsp\n \n  lea rax, [rdi - 1]\n  imul rdi \n  shr rax, 1\n  imul rsi\n  \n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213352,"user_id":null,"body":"section .text\nglobal find_sum\n\n; sum of multiples of 3 and 5 up to edi=n\nfind_sum:\n  mov esi,3\n  call sum_mul\n  mov r8d,eax\n  mov esi,5\n  call sum_mul\n  add r8d,eax\n  mov esi,15\n  call sum_mul\n  sub r8d,eax\n  mov eax,r8d\n  ret\n\n; sum of multiples of esi=d up to edi=n\nsum_mul:\n  mov eax,edi\n  xor edx,edx\n  div esi\n  mov ecx,eax\n  inc ecx\n  mul ecx\n  shr eax,1\n  mul esi\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213353,"user_id":50,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  xor rax, rax\n  xor rbx,rbx\n  mov r8,1 ; index\n  mov r9,3\n  mov r10,5\n_loop:\n  cmp r8,rdi\n  jg _exit ; index > n\n  mov eax, r8d\n  xor rdx,rdx\n  div r9\n  cmp rdx,0\n  je _sum\n  mov eax,r8d\n  xor rdx,rdx\n  div r10\n  cmp rdx,0\n  je _sum\n  inc r8\n  jmp _loop\n_sum:\n  add ebx,r8d\n  inc r8\n  jmp _loop\n_exit:\n mov rax,rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213354,"user_id":null,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  xor eax, eax\n  mov r9d,3 ; current multiple\n  mov r10d,3 ; base multiple\n  mov r13d,3 ; Used later to test dups\n  xor r11,r11 ; total\n  xor r12, r12\n  mov r12d, edi\n  .loop:\n    cmp r9d, r12d\n    jg .Next\n      add r11d, r9d\n      add r9d,r10d\n      jmp .loop\n  .Next:\n    mov r9d, 5\n    mov r10d, 5\n    .loop2:\n      cmp r9d, r12d\n      jg .end\n      ;Test for duplicate with 3\n        mov eax, r9d\n        xor rdx,rdx ;Zero our the return for the remainder\n        idiv r13d ; edx:rdx \/ r13d\n        cmp edx, 0 ;it is divisable by 3, ignore\n        je .Skip\n          add r11d, r9d\n        ;good result add to total and move to next\n        .Skip:\n        add r9d,r10d\n        jmp .loop2\n  .end:\n\n  mov eax, r11d\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213355,"user_id":null,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  mov rax, rdi\n  mov ecx, edi\n  mov edx, edi\n  imul rax, rax, 0x2aaaaaab\n  imul rcx, rcx, 0x1999999a\n  imul rdx, rdx, 0x8888889\n  shr rax, 31\n  shr rcx, 31\n  shr rdx, 31\n  lea edi, [rax+1]\n  imul edi, eax\n  lea eax, [edi*2+edi]\n  lea edi, [rcx+1]\n  imul edi, ecx\n  lea edi, [edi*4+edi]\n  add eax, edi\n  lea edi, [rdx+1]\n  imul edi, edx\n  mov ecx, edi\n  add edi, edi\n  neg ecx\n  lea edi, [8*edi+ecx]\n  sub eax, edi\n  shr eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213356,"user_id":null,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  xor eax, eax\n  mov ecx, 3\nfor3:\n  cmp ecx, edi\n  ja end_for3\n  add eax, ecx\n  add ecx, 3\n  jmp for3\nend_for3:\n  mov ecx, 5\nfor5:\n  cmp ecx, edi\n  ja end_for5\n  add eax, ecx\n  add ecx, 5\n  jmp for5\nend_for5:\n  mov ecx, 15\nfor15:\n  cmp ecx, edi\n  ja end\n  sub eax, ecx\n  add ecx, 15\n  jmp for15\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213357,"user_id":77,"body":"section .text\nglobal find_sum\n\nfind_sum:\n  imul rsi, rdi, 858993460\n  shr rsi, 32\n  lea rax, [rsi+1]\n  imul rsi\n  mov rcx, rax\n  shr rcx, 1\n  shl rax, 1\n  add rcx, rax\n  imul rsi, rdi, 1431655766\n  shr rsi, 32\n  lea rax, [rsi+1]\n  imul rsi\n  add rcx, rax\n  shr rax, 1\n  add rcx, rax\n  imul rsi, rdi, 286331154\n  shr rsi, 32\n  lea rax, [rsi+1]\n  imul rsi\n  mov rsi, rax\n  shr rax, 1\n  shl rsi, 3\n  add rax, rcx\n  sub rax, rsi\n  ret\n.zero:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57f609022f4d534f05000024":[{"id":213358,"user_id":null,"body":"SECTION .text\nglobal stray\n\nstray:\n  mov eax, [rdi]\n  mov ecx, [rdi + 4]\n  mov edx, [rdi + 8]\n  cmp eax, ecx\n  jne .early\n  cmp eax, edx\n  jne .early\n  add rdi, 8\n.loop:\n  add rdi, 4\n  mov eax, [rdi]\n  cmp eax, ecx\n  je .loop\n  ret\n.early:\n  xor eax, ecx\n  xor eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213359,"user_id":null,"body":"global stray\nstray: \n  xor eax,eax\n  @b:xor eax,[rdi+rsi*4-4]\n     dec rsi\n  jne @b\n ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213360,"user_id":527,"body":"section .text\nglobal stray\n\nstray: \n                xor     eax, eax\n.loop:          xor     eax, [rdi]\n                add     rdi, 4\n                dec     rsi\n                jnz     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213361,"user_id":null,"body":"section .text\nglobal stray\n\nstray:\n        xor eax, eax\n.loop:\n        test rsi, rsi\n        jz .exit\n        dec rsi\n        xor eax, [rdi + 4*rsi]\n        jmp .loop\n.exit:\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213362,"user_id":null,"body":"; The program should return the different number in rax.\n; The pointer to the array will be passed in rdi, \n; the number of items in rsi.\nsection .text\nglobal stray\n\nstray: \n  \n  xor rax,rax\n  xor rcx, rcx\n  inc rcx \n  mov edx, [rdi]\n  dec rsi\nchecker:\n  cmp edx, [rdi+4*rcx]\n  je incr\n  cmp rsi, 1\n  jbe zero\n  cmp edx, [rdi+4*rcx+4]\n  je end\n  mov rax, rdx\n  ret\nincr:\n  inc rcx\n  dec rsi\n  jmp checker\n\nzero:\n  cmp edx, [rdi+4*rcx-4]\n  je end\n  mov rax, rdx\n  ret\nend:\n  mov rax, [rdi+4*rcx]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213363,"user_id":null,"body":"SECTION .text\nglobal stray\n\nstray:\n  mov eax, [rdi]\n  mov ecx, [rdi + 4]\n  mov edx, [rdi + 8]\n  cmp eax, ecx\n  jne .early\n  cmp eax, edx\n  jne .early\n  add rdi, 12\n  .loop:\n  mov eax, [rdi]\n  add rdi, 4\n  cmp eax, ecx\n  je .loop\n  ret\n  .early:\n  xor eax, ecx\n  xor eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213364,"user_id":null,"body":"section .text\nglobal stray\n\nstray: \n  mov edx, [rdi]\n  mov ecx, [rdi+4]\n  mov eax, [rdi+8]\n  cmp edx, ecx\n  je .zeroonesame\n  cmp ecx, eax\n  mov eax, ecx\n  cmove eax, edx\n  ret\n.zeroonesame:\n  cmp edx, eax\n  jne .zerotwodiff\n  mov ecx, 3\n.loop:\n  inc rcx\n  mov eax, [rdi-4+rcx*4]\n  cmp edx, eax\n  je .loop\n.zerotwodiff:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213365,"user_id":null,"body":"; The program should return the different number in rax.\n; The pointer to the array will be passed in rdi, \n; the number of items in rsi.\nsection .text\nglobal stray\n\nstray: \n        mov     edx, DWORD  [rdi]\n        test    esi, esi\n        jle     L1\n        movsx   rax, esi\n        xor     r8d, r8d\n        lea     rcx, [rdi+rax*4]\n        jmp     L4\nL5:\n        add     rdi, 4\n        mov     r9d, eax\n        cmp     rcx, rdi\n        je      L8\nL4:\n        mov     eax, DWORD  [rdi]\n        cmp     edx, eax\n        jne     L5\n        add     rdi, 4\n        add     r8d, 1\n        cmp     rcx, rdi\n        jne     L4\nL8:\n        sub     esi, 1\n        cmp     esi, r8d\n        cmove   edx, r9d\nL1:\n        mov     eax, edx\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213366,"user_id":null,"body":"; The program should return the different number in rax.\n; The pointer to the array will be passed in rdi, \n; the number of items in rsi.\nsection .text\nglobal stray\n\nstray: \n        xor eax, eax\n.loop:\n        dec esi\n        xor eax, [rdi+rsi*4]\n        test esi, esi\n        jnz .loop\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213367,"user_id":null,"body":"; The program should return the different number in rax.\n; The pointer to the array will be passed in rdi, \n; the number of items in rsi.\nsection .text\nglobal stray\n\nstray: \n        xor rax, rax;\n        xor rcx, rcx;\nm1:\n        mov rbx, [rdi+rcx*4]\n        xor rax, rbx;\n        inc rcx;\n        cmp rcx, rsi;\n        jne m1;\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57f75cc397d62fc93d000059":[{"id":213368,"user_id":null,"body":"section .text\nglobal calc\n\n; int calc(const char *source);\ncalc:\n  xor ecx, ecx\n  mov r8b, 10\n.loop:\n  mov dl, [rdi]\n  test dl, dl\n  je .done\n  movsx eax, dl\n  xor esi, esi\n  idiv r8b\n  movsx eax, ah\n  cmp al, 7\n  sete sil\n  add dl, -70\n  add ecx, esi\n  cmp dl, 10\n  adc ecx, 0\n  inc rdi\n  jmp .loop\n.done:\n  imul eax, ecx, 6\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213369,"user_id":null,"body":"section .text\nglobal calc\n\n; \n; int calc(const char *source);\ncalc:\n    xor r8, r8 ; sum\n    jmp char\nnextchar:\n    add rdi, 1\nchar:\n    movzx eax, byte [rdi] \n    \n    cmp eax, 0\n    je return\n    \n    cmp eax, 77\n    je add12\n    \n    mov edx, 0\n    mov r9, 10\n    div r9\n    \n    cmp edx, 7\n    je add6\n    cmp eax, 7\n    je add6\n    \n    jmp nextchar\nadd12:\n    add r8, 6\nadd6:\n    add r8, 6\n    jmp nextchar\nreturn:\n    mov rax, r8\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213370,"user_id":null,"body":"section .text\nglobal calc\n\n; int calc(const char *source);\ncalc:\n        mov rsi, rdi\n        xor rax, rax    \n        xor edi, edi\n        mov dh, 100\n        mov dl, 10\n        mov r11d, 7\n.loadchar:\n        lodsb\n        test  al, al\n        jz  .eofstr\n.above100:\n        cmp al, dh\n        jb .below100\n        sub al, dh\n        jmp .above100\n.below100:\n        xor ecx, ecx\n.above10:\n        cmp al, dl\n        jb .below10\n        inc ecx\n        sub al, dl\n        jmp .above10\n.below10:\n        mov r9d, 6\n        mov r8d, eax\n        xor eax, eax\n        cmp r8d, r11d\n        cmovz eax, r9d\n        add edi, eax\n        xor eax, eax\n        cmp ecx, r11d\n        cmovz eax, r9d\n        add edi, eax\n        jmp .loadchar\n\n.eofstr:\n        mov eax, edi\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213371,"user_id":50,"body":"section .text\nglobal calc\n\n; int calc(const char *source);\ncalc:\n    xor rax, rax\n    xor r8,r8\n    mov rbx,10\n_loop:\n  cmp byte[rdi],0\n  je _exit\n  mov al,[rdi]\n_lloop:\n  cmp al,0\n  je _adv\n  xor rdx,rdx\n  div rbx\n  cmp rdx,7\n  je _inc\n  jmp _lloop\n _inc:\n inc r8\n jmp _lloop\n_adv:\n  inc rdi\n  jmp _loop\n_exit:\n  mov rax,r8\n  mov r8,6\n  imul rax,r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213372,"user_id":null,"body":"\nsection .text\nglobal calc\n\ndecimal dw 10\n\ncalc:    xor r8,r8\n         xor ecx,ecx\n@l1:     cmp byte [rdi + r8],0\n         je @eos\n         movzx eax,byte [rdi + r8]\n         xor edx,edx\n         div word [decimal]\n         cmp ax,7\n         jne @l2\n         add ecx,6\n@l2:     cmp dx,7\n         jne @l3\n         add ecx,6\n@l3:     inc r8\n         jmp @l1\n@eos:    mov eax,ecx\n         ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213373,"user_id":null,"body":"section .text\nglobal calc\n\n; int calc(const char *source);\ncalc:\n    xor    rsi,rsi           ; sum in rsi the difference\n    mov    cl,10             ; number base\n    mov    ch,7              ; the digit to earch\n    mov    rdx,6             ; add 6 to the difference for each 7\n    jmp    .start\n.loop:\n    div    cl                ; split the number into lower digit and rest\n    cmp    ah,ch             \n    jne    .no7\n    add    rsi,rdx           ; add 6 for the digit 7\n.no7:\n    movzx  ax,al\n    test   al,al\n    jnz    .loop             ; loop for all digits\n.start:\n    movzx  ax,[rdi]\n    inc    di\n    test   al,al             ; 0 terminates the string\n    jnz    .loop             ; loop for all chars\n    mov    rax,rsi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213374,"user_id":1088,"body":"\nsection .text\nglobal calc\n\n; int calc(const char *rdi);\ncalc:\n\txor\tecx, ecx\n\txor\tr9d, r9d\n\tmov\tsil, 10\n.tr_loop:\n\tmovzx\tax, byte [rdi]\n\ttest\tax, ax\n\tjz\t.end\n\txor\tdx, dx\n\tdiv\tsil\n\n\tmovzx\tdx, al\n\tdec\tdx\n\tcmp\tdx, 6\n\tcmovne\tdx, r9w\n\tadd\tcl, dl\n\n\tmovzx\tdx, ah\n\tdec\tdx\n\tcmp\tdx, 6\n\tcmovne\tdx, r9w\n\tadd\tcl, dl\n\tinc\trdi\n\tjmp\t.tr_loop\n.end:\n\tmov\teax, ecx\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213375,"user_id":1088,"body":"\nsection .text\nglobal calc\n\n; int calc(const char *rdi);\ncalc:\n\txor\tecx, ecx\n\txor\tr8d, r8d\n\txor\tr9d, r9d\n\tmov\tsil, 10\n.loop_strlen:\n\tcmp\tbyte [rdi + rcx], 0\n\tje\t.end_loop_strlen\n\tinc\trcx\n\tjmp\t.loop_strlen\n.end_loop_strlen:\n\ttest\trcx, rcx\n\tjz\t.end\n\tmovzx\tax, byte [rdi + rcx - 1]\n\txor\tdx, dx\n\tdiv\tsil\n\n\tmovzx\tdx, al\n\tdec\tdx\n\tcmp\tdx, 6\n\tcmovne\tdx, r9w\n\tadd\tr8b, dl\n\n\tmovzx\tdx, ah\n\tdec\tdx\n\tcmp\tdx, 6\n\tcmovne\tdx, r9w\n\tadd\tr8b, dl\n.end_al_is_7:\n\tdec\trcx\n\tjmp\t.end_loop_strlen\n.end:\n\tmov\teax, r8d\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213376,"user_id":527,"body":"section .text\nglobal calc\n\n; int calc(const char *source);\ncalc:\n                xor     eax, eax\n                movzx   edx, byte [rdi]\n                test    dl, dl\n                jz      .done\n.loop:          inc     rdi\n                ; this part is based on clang output, looks interesting\n                imul    ecx, edx, -51\n                add     cl, 101\n                ror     cl, 1\n                sub     dl, 70\n                cmp     dl, 10\n                setb    dl\n                cmp     cl, 25\n                adc     eax, edx\n                movzx   edx, byte [rdi]\n                test    dl, dl\n                jnz     .loop\n                lea     eax, [eax * 3]\n                add     eax, eax\n.done:          ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213377,"user_id":527,"body":"section .text\nglobal calc\n\n; int calc(const char *source);\ncalc:\n                xor     eax, eax\n                movzx   edx, byte [rdi]\n                test    edx, edx\n                jz      .done\n.loop:          inc     rdi\n                imul    esi, edx, 205\n                shr     esi, 11\n                lea     ecx, [rsi - 7]\n                lea     esi, [rsi * 5]\n                lea     esi, [rsi * 2 + 7]\n                cmp     edx, esi\n                setz    dl\n                sub     ecx, 1\n                adc     eax, edx\n                movzx   edx, byte [rdi]\n                test    edx, edx\n                jnz     .loop\n                lea     eax, [eax * 3]\n                add     eax, eax\n.done:          ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57f781872e3d8ca2a000007e":[{"id":213378,"user_id":null,"body":"SECTION .text\nglobal maps\nextern malloc\nmaps:\n  push rdi\n  push rsi\n  lea  rdi,[rsi*4]\n  call malloc\n  pop rsi\n  pop rdi\n  .b:mov edx,[rdi+rsi*4-4]\n     add edx,edx\n     mov [rax+rsi*4-4],edx\n     dec rsi\n  jne .b\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213379,"user_id":null,"body":"global maps\nextern malloc\n\nsection .text\n\n; <--- int *maps(const int *arr, size_t size) --->\nmaps:\n    push rdi                ; saving <arr> in the stack\n    push rsi                ; saving <size> in the stack\n    sub rsp, 8              ; aligning the stack before call\n    lea rdi, [rsi*4]        ; target bytes to allocate for new array\n    call malloc             ; allocating memory\n    add rsp, 8              ; restoring the stack boundary\n    pop rcx                 ; restoring <size> from the stack\n    pop rdi                 ; restoring <arr> from the stack\n    test rax, rax           ; whether the memory is allocated\n    je .exit                ; otherwise, jumping to exit\n.loop:\n    dec rcx                 ; decrementing <size>\n    jl .exit                ; jumping to exit in case less then zero\n    mov edx, [rdi+rcx*4]    ; copying <*(arr+size)> to EDX as <num>\n    sal edx, 1              ; doubling <num>\n    mov [rax+rcx*4], edx    ; saving <num> in <*(newarr+size)>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    ret\n; ---------> endof maps <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213380,"user_id":null,"body":"SECTION .text\nglobal maps\nextern malloc\n\nmaps:\n  push rdi\n  push rsi\n  mov rdi, rsi\n  shl rdi, 2\n  call malloc\n  pop rsi\n  pop rdi\n.loop:\n  test rsi, rsi\n  jz .exit\n  dec rsi\n  mov edx, [rdi + 4 * rsi]\n  add edx, edx\n  mov [rax + 4 * rsi], edx\n  jmp .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213381,"user_id":null,"body":"SECTION .text\nglobal maps\nextern malloc\n\nmaps:\n  push r14\n  push rbx\n  push rax\n  mov rbx, rsi\n  mov r14, rdi\n  lea rdi, [4*rsi]\n  call malloc\n  test rbx, rbx\n  je .done\n  xor ecx, ecx\n.loop:\n  mov edx, [r14 + 4*rcx]\n  add edx, edx\n  mov [rax + 4*rcx], edx\n  inc rcx\n  cmp rbx, rcx\n  jne .loop\n.done:\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213382,"user_id":null,"body":"SECTION .text\nglobal maps\nextern malloc\n\nmaps:\n  push    rdi\n  push    rsi\n  shl     rsi, 2\n  xchg    rsi, rdi\n  call    malloc\n  pop     rsi\n  pop     rdi\n  push    rax\n  .loop:\n  mov     ecx,  [rdi]\n  add     rdi, 4\n  shl     ecx, 1\n  mov     [rax], ecx\n  add     rax, 4\n  dec     rsi\n  jnz     .loop\n  .end:\n  pop     rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213383,"user_id":173,"body":"extern malloc\n\nSECTION .text\nglobal maps\n\nmaps:\n  mov r12, rdi\n  mov r13, rsi\n  \n  mov rdi, r13\n  add rdi, rdi\n  add rdi, rdi\n  add rdi, rdi\n  call malloc\n  mov r14, rax\n\n  mov rdi, r12\n  mov rsi, 0\nLOOP:\n  cmp rsi, r13\n  je DONE\n  mov word ax, [rdi + rsi]\n  shl ax, 1\n  mov word [r14 + rsi], ax\n  inc rsi\n  jmp LOOP\nDONE:\n  mov rax, r14\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213384,"user_id":null,"body":"extern malloc\n\nSECTION .text\nglobal maps\n\nmaps:\n  push rdi\n  push rsi\n  lea rdi, [rsi * 8]\n  call malloc\n  pop rsi\n  pop rdi\n\n  xor r8, r8\n  \n.for:\n  mov dword edx, [rdi + r8 * 4]\n  shl edx, 1\n  mov dword [rax + r8 * 4], edx\n  inc r8\n  cmp r8, rsi\n  jne .for\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213385,"user_id":null,"body":"SECTION .text\nglobal maps\nextern malloc\n\nmaps:\n  push rdi\n  push rsi\n  lea rdi, [rsi*4]\n  call malloc\n  pop rsi\n  pop rdi\n  dec rsi\n  xor edx, edx\n  .loop:\n    mov edx, [rdi+rsi*4]\n    add rdx, rdx\n    mov [rax+rsi*4], edx\n    dec rsi\n    jns .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213386,"user_id":525,"body":"SECTION .text\nglobal maps\nextern malloc\n\nmaps:\n  push    rbp\n  push    rbx\n  sub     rsp, 8\n  mov     rbx, rdi\n  mov     rbp, rsi\n  lea     rdi, [rsi*4]\n  call    malloc\n  mov     rcx, rax\n  lea     rax, [rbp-1]\n  test    rbp, rbp\n  jle     .loop_end\n.loop_body:\n  mov     esi, DWORD [rbx+rax*4]\n  lea     edx, [rsi+rsi]\n  mov     DWORD [rcx+rax*4], edx\n  sub     rax, 1\n  cmp     rax, -1\n  jne     .loop_body\n.loop_end:\n  mov     rax, rcx\n  add     rsp, 8\n  pop     rbx\n  pop     rbp\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213387,"user_id":null,"body":"SECTION .text\nextern malloc\nglobal maps\n\nmaps:\n    push rdi\n    push rsi\n    lea edi,[esi *4]\n    call malloc \n    pop rcx\n    pop rsi\n    cmp rcx,0 ; Check for empty array\n    je @e\n    push rax\n    mov rdi,rax\n@l: lodsd\n    shl  eax,1\n    stosd\n    loop @l\n    pop rax\n@e: ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58064355c3c77984e900033c":[{"id":213388,"user_id":null,"body":"global filter_refs_out\nfilter_refs_out:\n  mov  rax,']'\n  mov  rsi,rdi\n  push rdi\n  .b:cmp byte[rsi],'['\n     jne .f\n       xchg  rsi,rdi\n       repne scasb\n       xchg  rsi,rdi\n       jmp .b\n     .f:\n     movsb\n     cmp byte[rsi-1],0\n  jne .b   \n  pop  rax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213389,"user_id":null,"body":"extern strlen, malloc\nglobal filter_refs_out\n\nsection .text\n\n; <--- char *filter_refs_out(char *s) --->\nfilter_refs_out:\n  mov rax, rdi\n  mov rcx, rdi\n  mov rsi, rdi\n  mov dl, 1\n  mov r9b, 1\n.loop:\n  mov dil, [rsi]\n  test dil, dil\n  je .done\n  cmp dil, 91\n  setne r8b\n  and dl, r8b\n  je .inbrackets\n  mov [rcx], dil\n  inc rcx\n.inbrackets:\n  cmp byte [rsi], 93\n  cmove edx, r9d\n  inc rsi\n  jmp .loop\n.done:\n  mov byte [rcx], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213390,"user_id":null,"body":"global filter_refs_out\n\nsection .text\n\n; <--- char *filter_refs_out(char *s) --->\nfilter_refs_out:\n    push rdi\n    mov rsi, rdi\n    xor rcx, rcx\n.loop:    \n    lodsb\n    test al, al\n    jz .out\n    cmp al, '['\n    je .up\n    cmp al, ']'\n    je .down\n    test rcx, rcx\n    jnz .loop\n    stosb\n    jmp .loop\n.up:\n    inc rcx\n    jmp .loop\n.down:\n    dec rcx\n    jmp .loop\n.out:\n    stosb\n    pop rax\n    ret\n; -----> endof filter_refs_out <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213391,"user_id":null,"body":"global filter_refs_out\n\nsection .text\n\n; <--- char *filter_refs_out(char *s) --->\nfilter_refs_out:\n    xor ecx, ecx\n    xor r8d, r8d\n    xor edx, edx\n    .loop:\n        mov dl, [rdi+r8]\n        cmp rdx, 0\n        je .end\n        cmp rdx, '['\n        je .reference\n        mov dl, [rdi+r8]\n        mov [rdi+rcx], dl\n        inc rcx\n        inc r8\n        jmp .loop\n        .reference:\n            .reference_loop:\n                inc r8\n                cmp byte [rdi+r8], ']'\n                jne .reference_loop\n            inc r8\n            jmp .loop\n    .end:\n        mov [rdi+rcx], byte 0\n        mov rax, rdi\n        ret\n; -----> endof filter_refs_out <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213392,"user_id":null,"body":"global filter_refs_out\n\n%define STATE_COPY  0\n%define STATE_SKIP  1\n\nsection .text\n\n; <--- char *filter_refs_out(char *s) --->\nfilter_refs_out:\n  mov rax, rdi\n  mov rsi, rdi\n  mov rcx, STATE_COPY\n  \n.top:\n  ; branch to state handler\n  cmp rcx, STATE_COPY\n  je .state_copy\n  cmp rcx, STATE_SKIP\n  je .state_skip\n  \n  \n.state_copy:\n  ; branch to character handler\n  movzx rdx, BYTE [rsi]\n  cmp rdx, 0\n  je .end\n  cmp rdx, '['\n  je .case_copy_openbracket\n  jmp .case_copy_default\n\n.case_copy_openbracket:\n  ; transition to skip state\n  mov rcx, STATE_SKIP\n  jmp .top\n  \n.case_copy_default:\n  ; copy character to destination\n  movzx rdx, BYTE [rsi]\n  mov [rdi], dl\n  inc rsi\n  inc rdi\n  jmp .top\n  \n.state_skip:\n  ; branch to character handler\n  movzx rdx, BYTE [rsi]\n  cmp rdx, 0\n  je .end\n  cmp rdx, ']'\n  je .case_skip_closebracket\n  jmp .case_skip_default\n  \n.case_skip_closebracket:\n  ; transition to copy state (and skip 1 input char)\n  mov rcx, STATE_COPY\n  ; fallthrough\n  \n.case_skip_default:\n  ; skip input\n  inc rsi\n  jmp .top\n\n.end:\n  ; add null char and return\n  mov BYTE [rdi], 0\n  ret\n\n\n; -----> endof filter_refs_out <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213393,"user_id":null,"body":"global filter_refs_out\n\nsection .text\n\n; <--- char *filter_refs_out(char *s) --->\nfilter_refs_out:\n    xor rcx, rcx\n.loop1:\n    cmp byte[rdi+rcx], 0\n    je .loop1_end\n    cmp byte[rdi+rcx], '['\n    jne .tag_end\n.tag:\n    mov rbx, rcx\n    mov rdx, rcx\n.loop2:\n    cmp byte[rdi+rbx], ']'\n    je .loop2_end\n    inc rbx\n    jmp .loop2\n.loop2_end:\n    inc rbx\n.loop3:\n    mov al, [rdi+rbx]\n    cmp al, 0\n    je .loop3_end\n    mov [rdi+rdx], al\n    inc rdx\n    inc rbx\n    jmp .loop3\n.loop3_end:\n    mov byte[rdi+rdx], 0\n    dec rcx\n.tag_end:\n    inc rcx\n    jmp .loop1\n.loop1_end:\n    mov rax, rdi\n    ret\n; -----> endof filter_refs_out <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213394,"user_id":null,"body":"global filter_refs_out\n\nsection .text\n\n; <--- char *filter_refs_out(char *s) --->\nfilter_refs_out:\n    mov rax, rdi            ; copying <s> to RAX\n    test rax, rax           ; whether <s> is NULL\n    je .exit                ; jumping to exit\n    xor edi, edi            ; resetting RDI as <reflen>\n    xor esi, esi            ; resetting RSI as <inx>\n    mov rcx, -1             ; setting RCX to minus one as <i>\n    xor r8d, r8d            ; will be used in conditional move as a resetter\n.loop:\n    inc rcx                 ; incrementing <i>\n    mov dl, [rax+rcx]       ; copying <*(s+i)> to DL as <c>\n    test dl, dl             ; whether <c> is the null character\n    je .term                ; jumping to the .term label\n    test rdi, rdi           ; whether <reflen> is not zero\n    je .setref              ; otherwise, jumping to the .setref label\n    cmp dl, ']'             ; whether <c> is ']'\n    cmove rdi, r8           ; resetting <reflen>\n    je .loop                ; jumping to the next iteration\n    cmp dl, '0'             ; whether <c> is bellow '0'\n    jb .setinx              ; jumping to the .setinx label\n    cmp dl, '9'             ; whether <c> above '9'\n    ja .setinx              ; jumping to the .setinx label\n    inc rdi                 ; incrementing <reflen>\n    jmp .loop               ; jumping to the next iteration\n.setinx:\n    lea rsi, [rsi+rdi+1]    ; increasing <inx> by <reflen>\n    xor edi, edi            ; resetting <reflen>\n    jmp .loop               ; jumping to the next iteration\n.setref:\n    cmp dl, '['             ; whether <c> is '['\n    jne .setsym             ; otherwise, jumping to the .setsym label\n    mov rdi, 1              ; setting <reflen> to one\n    jmp .loop               ; jumping to the next iteration\n.setsym:\n    mov [rax+rsi], dl       ; copying <c> to <*(s+inx)>\n    inc rsi                 ; incrementing <inx>\n    jmp .loop               ; jumping to the next iteration\n.term:\n    mov byte [rax+rsi], 0   ; terminating <*(s+inx)>\n.exit:\n    ret\n; -----> endof filter_refs_out <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"580755730b5a77650500010c":[{"id":213395,"user_id":null,"body":"extern strlen,malloc\nglobal sort_my_string\n; Function signature:\n; char *sort_my_string(const char *s)\nsection .text\nsort_my_string:\n  push r15\n  push r14\n  push rbx\n  mov r15, rdi\n  call strlen\n  lea rdi, [rax + 2]\n  mov r14, rax\n  call malloc\n  lea rcx, [r14 + 1]\n  xor edx, edx\n  shr rcx, 1\n.evenloop:\n  cmp rcx, rdx\n  je .evendone\n  mov bl, [r15 + 2*rdx]\n  mov [rax + rdx], bl\n  inc rdx\n  jmp .evenloop\n.evendone:\n  mov ecx, ecx\n  mov byte [rax + rcx], 32\n  inc rcx\n  push 1\n  pop rdx\n.oddloop:\n  cmp r14, rdx\n  jbe .odddone\n  mov bl, [r15 + rdx]\n  add rdx, 2\n  mov [rax + rcx], bl\n  inc rcx\n  jmp .oddloop\n.odddone:\n  mov ecx, ecx\n  mov byte [rax + rcx], 0\n  pop rbx\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213396,"user_id":null,"body":"global sort_my_string\n; Function signature:\n; char *sort_my_string(const char *s)\n\nsection .bss\nout_str resb 1024     \n\nsection .text\nsort_my_string:\n  mov rsi,out_str\n  xchg rsi,rdi\n  mov rdx,rsi\n  jmp .even_load\n.even:\n  stosb\n.even_load:\n  lodsw\n  test ah,ah\n  jz .even_last\n  test al,al\n  jnz .even\n  jmp .space\n.even_last:\n  test al,al\n  jz .space\n  stosb\n.space:\n  mov rsi,rdx\n  mov ah,' '\n.odd:\n  xchg ah,al\n  stosb\n  lodsw\n  test al,al\n  jnz .odd\n  stosb\n  mov rax,out_str\n  ret ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213397,"user_id":null,"body":"extern malloc\n\nsection .text\nglobal sort_my_string\n\n; Function signature:\n; char *sort_my_string(const char *s)\nsort_my_string:\n  push rbp\n  mov rbp, rsp\n  \n  push rdi\n  \n.strlen:\n  mov rcx, 0x03ffff\n  xor rax, rax\n  cld\n  repne scasb\n  sub rcx, 0x03ffff\n  neg rcx\n  dec rcx\n  \n.allocate:\n  push rcx\n  mov rdi, rcx\n  shl rdi, 3\n  call malloc\n  pop rcx\n  pop rdi\n  \n  xor r8, r8\n  xor r9, r9\n  cmp rcx, 0\n  jz .exit\n  \n.even:\n  mov bl, [rdi + r8]\n  mov [rax + r9], bl\n  add r8, 2\n  inc r9\n  cmp r8, rcx\n  jl .even\n  \n  mov byte [rax + r9], 0x20\n  inc r9\n  mov r8, 1\n  \n.odd:\n  mov bl, [rdi + r8] \n  mov [rax + r9], bl\n  add r8, 2\n  inc r9\n  cmp r8, rcx\n  jl .odd\n  \n.exit:\n  mov byte [rax + r9], 0\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213398,"user_id":null,"body":"global sort_my_string\nsort_my_string:\n  mov  rsi,output\n  xchg rsi,rdi\n  push rsi\n  .even:lodsw\n        stosb\n        mul  ah\n        test ax,ax\n  jne .even\n  pop  rsi\n  cmp  byte[rdi-1],1\n  sbb  rdi,0\n  mov  byte[rdi],' '\n  inc  rdi\n  .odd:lodsb\n       movsb\n       mul  byte[rsi-1]\n       test ax,ax\n  jne .odd\n  mov  byte[rdi-1],0\n  mov  rax,output  \nret\nsection .data\noutput resb 1024","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213399,"user_id":null,"body":"global sort_my_string\n; Function signature:\n; char *sort_my_string(const char *s)\nsection .text\nsort_my_string:\n  xor rax, rax ; result <- NULL\n  xor rcx, rcx\n  xor rdx, rdx\n  mov rcx, rdi\n  lea rax, [result]\n  l1:\n  mov bl, byte[rcx]  \n  inc rcx\n  \n  testBl:\n  test bl, bl\n  jz p2\n  add rdx, 1\n  and rdx, 1\n  jz l1\n  mov byte[rax], bl\n  inc rax\n  jmp l1\n  p2:\n  xor rdx, rdx\n  mov rcx, rdi\n  mov bl, ' '\n  mov byte[rax], bl\n  inc rax\n  l2:\n  mov bl, byte[rcx]  \n  inc rcx\n  add rdx, 1\n  and rdx, 1\n  jnz testBl2\n  mov byte[rax], bl\n  inc rax\n  testBl2:\n  test bl, bl\n  jnz l2\n  mov byte[rax], 0\n  lea rax, [result]\n  ret ; TODO\n\nsection .bss\n  result resb 100","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213400,"user_id":null,"body":"global sort_my_string\nsection .bss\nbuf resb 256\nsection .text\nsort_my_string:\n  mov rdx, rdi\n  xor cl, cl\n  mov rsi, buf\nevens_loop:\n  inc cl\n  mov al, [rdi]\n  inc rdi\n  test al, al\n  jz break_evens\n  test cl, 1\n  jz evens_loop\n  mov [rsi], al\n  inc rsi\n  jmp evens_loop\nbreak_evens:\n  mov byte [rsi], ' '\n  inc rsi\n  xor cl, cl\nodds_loop:\n  inc cl\n  mov al, [rdx]\n  inc rdx\n  test al, al\n  jz break_odds\n  test cl, 1\n  jnz odds_loop\n  mov [rsi], al\n  inc rsi\n  jmp odds_loop\nbreak_odds:\n  mov byte [rsi], 0\n  mov rax, buf\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213401,"user_id":null,"body":"section .data\nres db '', 0\nglobal sort_my_string\n; Function signature:\n; char *sort_my_string(const char *s)\nsection .text\nsort_my_string:\n  mov rbx, rdi\n  mov rdx, 0\n  mov rcx, 0\n  cloop:\n  cmp [rdi + rdx], byte 0\n  je end\n  inc rcx\n  inc rdx\n  jmp cloop\n  end:\n  push rcx\n  mov rdx, 0\n  mov rax, 0\n  mov r8d, 0\n  cloop2:\n    cmp rcx, 0\n    jle end2\n    cmp r8d, 0\n    jne skp\n    mov r8d, 1\n    movzx rbx, byte [rdi + rdx]\n    mov [res + rax], bl\n    inc rax\n    jmp skp2\n    skp:\n    mov r8d, 0\n    skp2:\n    add rdx, 1\n    dec rcx\n    jmp cloop2\n  end2:\n  mov [res + rax], byte ' '\n  inc rax\n  mov rdx, 0\n  mov r8d, 0\n  pop rcx\n  cloop3:\n    cmp rcx, 0\n    jle end3\n    cmp r8d, 1\n    jne skp3\n    mov r8d, 0\n    movzx rbx, byte [rdi + rdx]\n    mov [res + rax], bl\n    inc rax\n    jmp skp4\n    skp3:\n    mov r8d, 1\n    skp4:\n    add rdx, 1\n    dec rcx\n    jmp cloop3\n  end3:\n  mov [res + rax], byte 0\n  mov rax, res\n  ret ; TODO","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213402,"user_id":null,"body":"    section .bss\nlength:     resd    1\npivot:      resd    1\n\n    section .text\n    global sort_my_string\n    extern strlen\n    extern malloc\n\nsort_my_string:\n    push rbp\n    mov rbp, rsp               ; prologue\n\n    push rdi                   ; save original input pointer\n    call strlen                ; get length of the input string\n    mov [length], eax          ; save its length into variable\n    mov [pivot], eax           ; make so called 'pivot' which denotes\n    shr dword [pivot], 1       ;  where is spacing between even and odd parts\n    \n    test [length], byte 1      ; check if string length is even\n    jz .not_even               ; if it's even then\n    inc dword [pivot]          ;  increase pivot by one\n    \n.not_even:\n    mov rdi, rax               ; use output from strlen for allocating char array\n    inc rdi                    ; the output have one more character then input\n    call malloc                ; allocate memory\n    pop rdi                    ; resore pointer to input string\n\n    xor rcx, rcx               ; set counter register to 0\n.loop:\n    mov r9, rcx                ; r9 will be used as output array index\n    shr r9, 1                  ; divide by 2\n    test rcx, 1                ; check if current loop variable is even\n    jz .add_char               ; if not then skip to copying characters\n    add r9, [pivot]            ; even chars are at i + pivot + 1 position\n    inc r9\n.add_char:\n    mov dl, byte [rdi + rcx]   ; move character from original string and save it\n    mov [rax + r9], dl         ;  into position according to value of r9\n    inc rcx                    ; increment loop variable\n    cmp ecx, [length]          ; check it against length of the string\n    jl .loop                   ; if counter is less than length then jump back\n\n    inc rcx                    ; increase counter to reach index after last character\n    mov [rax + rcx], byte 0    ; terminate string with zero\n    mov rcx, [pivot]           ; copy pivot value into registry\n    mov [rax + rcx], byte ' '  ; insert space character into pivot position\n\n    leave                      ; epilogue shortcut\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213403,"user_id":null,"body":"global sort_my_string\nextern strlen\nextern malloc\n\nsection .text\n; char *sort_my_string(char *s)\nsort_my_string:\n    push rbx\n    push rdi\n    call strlen\n    mov rdi, rax\n    mov rbx, rax\n    add rdi, 2\n    call malloc\n    pop rdi\n    push rax\n    mov rcx, 0\n\n.even:\n    cmp rcx, rbx\n    jge .even_done\n    mov dl, [rdi,rcx]\n    mov [rax], dl\n    add rcx, 2\n    inc rax\n    jmp short .even\n\n.even_done:\n    mov byte [rax], 0x20\n    inc rax\n    mov rcx, 1\n\n.odd:\n    cmp rcx, rbx\n    jge .odd_done\n    mov dl, [rdi,rcx]\n    mov [rax], dl\n    add rcx, 2\n    inc rax\n    jmp short .odd\n\n.odd_done:\n    mov byte [rax], 0\n    pop rax\n    pop rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213404,"user_id":168,"body":"extern strlen\nglobal sort_my_string\nsection .bss\nresult resb 1024\nsection .text\n; Function signature:\n; char *sort_my_string(const char *s)\nsort_my_string:\n  push rdi\n  call strlen\n  mov rcx, rax\n  shr rax, 1\n  adc rax, 1\n  mov byte [result + rax - 1], ' '\n  mov byte [result + rcx + 1], 0\n  pop rsi\n  jmp .loop_cond\n.loop:\n  xor rdx, rdx\n  mov rdi, rcx\n  shr rdi, 1\n  cmovc rdx, rax\n  add rdi, rdx\n  mov dl, byte [rsi + rcx]\n  mov byte [result + rdi], dl\n.loop_cond:\n  dec rcx\n  jge .loop\n  lea rax, [result]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"580878d5d27b84b64c000b51":[{"id":213405,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\n\n\n; We can see that the rate of change of the values is y = x + 0.5 .\n; Taking the integral of that, we get y = ( x^2 + x ) \/ 2 for the\n; triangular values.\n; We need the sum at specific points along an interval - a simple integral\n; will not work (I don't know much about calculus though so...).\n; Instead, we can look at some summation rules.\n; For n natural numbers, it's n(n + 1) \/ 2\n; For squares for n natural numbers, it's n(n+1)(2n+1)\/6\n; Our function is composed of a linear and quadratic function,\n; so we can sub those out for the sums (it's a bit to write out,\n; and I think you get what's going on).\n; x^2 gets replaced with the quadratic summation, and x with the linear one.\n; \/6 remains unchanged.\n; We are then left with, after simplifying, ( x^3 + 3*x^2 + 2*x ) \/ 6 (q.e.d.)\n\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n   \n   ; Don't solve when < 0\n   cmp edi, 0\n   jge .run\n   mov rax, 0\n   ret\n   .run:\n   \n   ; ecx -> acculm\n   ; eax -> scratch\n   xor rcx, rcx\n   xor rax, rax\n   \n   ; ( x^3 + 3*x^2 + 2*x ) \/ 6\n   mov eax, edi\n   ; 2*x\n   add ecx, eax\n   add ecx, eax\n   ; 3*x^2\n   mul edi\n   add ecx, eax\n   add ecx, eax\n   add ecx, eax\n   ; x^3\n   mul edi\n   add ecx, eax\n   ; \/6\n   xor edx, edx\n   mov eax, ecx\n   mov ecx, 6\n   div ecx\n   \n   ret\n   \n   \n   \n   ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213406,"user_id":168,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  xor eax, eax\n  cmp edi, 0\n  jle .end\n  lea eax, [edi + 1]\n  imul eax, edi\n  add edi, 2\n  imul eax, edi\n  mov edi, 6\n  xor edx, edx\n  div edi\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213407,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  xor eax, eax\n  \n  cmp edi, 0\n  jle end\n  \n  xor ebx, ebx\n  xor ecx, ecx\n  l:\n    inc ebx\n    add ecx, ebx\n    add eax, ecx\n    cmp ebx, edi\n    jl l\n  end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213408,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n  xor eax, eax\n  test edi, edi\n  jle .done\n  lea eax, [rdi+1]\n  lea edx, [rdi+2]\n  movsx rdi, edi\n  mov ecx, 6\n  movsx rdx, edx\n  cdqe\n  imul rax, rdx\n  xor edx, edx\n  imul rax, rdi\n  div rcx\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213409,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  push rcx\n  push rdx\n  push rdi\n  \n  xor rax, rax\n  cmp edi, 0\n  jl end\n\n  mov ecx, edi\n  xor rdi, rdi\n  xor rdx, rdx\n  \nloop:\n\n  inc rdi  \n  add rdx, rdi\n  add rax, rdx\n\n  loopne loop\n  \nend:\n \n  pop rdi\n  pop rdx\n  pop rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213410,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  cmp edi, 0\n  jle .bailout\n  mov eax, edi\n  inc edi\n  mul edi\n  inc edi\n  mul edi\n  mov ecx, 6\n  xor edx, edx\n  div ecx\n  ret\n  \n.bailout:\n  xor eax, eax\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213411,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  xor rax,rax\n  xor rdx,rdx\n  cmp edi,0\n  jle done\n  mov ebx,edi\n  add ebx,1;n+1\n  mov ecx,edi\n  add ecx,2;n+2\n  imul edi,ebx\n  imul edi,ecx\n  mov eax,edi;n(n+1)(n+2)\n  mov ebx,6\n  div ebx\ndone:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213412,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  xor   eax,  eax\n  cmp   edi,  0\n  jle   .end\n  mov   ecx,  1\n  .loop:\n  lea   r8d,   [ecx+1]\n  imul  r8d,   ecx\n  shr   r8d,   1\n  add   eax,  r8d\n  inc   ecx\n  cmp   ecx,  edi\n  jle   .loop\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213413,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  xor eax, eax\n  cmp edi, 0\n  jle .end\n  ; start value\n  xor ebx, ebx\n  mov ecx, 1\n.sum:\n  add ebx, ecx\n  add eax, ebx\n  inc ecx\n  cmp ecx, edi \n  jbe .sum\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213414,"user_id":null,"body":"section .text\nglobal sumTriangularNumbers\nsumTriangularNumbers: ; int sumTriangularNumbers(int n)\n                      ; input:  edi = n\n                      ; output: eax\n  xor rax,rax\n  test edi, edi\n  js return\n  mov rax, 1\n  mov rdx, 1\n  mov rcx, 1\nloop:\n  cmp rdi, rcx\n  jle return\n  inc rcx\n  add rdx, rcx\n  add rax, rdx\n  jmp loop\n\nreturn:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5808dcb8f0ed42ae34000031":[{"id":213415,"user_id":null,"body":"SECTION .rodata\nzero: db \"Zero\", 0\none: db \"One\", 0\ntwo: db \"Two\", 0\nthree: db \"Three\", 0\nfour: db \"Four\", 0\nfive: db \"Five\", 0\nsix: db \"Six\", 0\nseven: db \"Seven\", 0\neight: db \"Eight\", 0\nnine: db \"Nine\", 0\nten: db \"Ten\", 0\n\nnumber_arr: dq zero, one, two, three, four, five, six, seven, eight, nine, ten\n\nSECTION .text\nglobal switch_it_up\n\nswitch_it_up:\n  mov rax, [number_arr + rdi * 8]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213416,"user_id":null,"body":"global switch_it_up\n\nsection .text\n\n; <--- const char *switch_it_up(unsigned n) --->\nswitch_it_up:\n    mov rax, .nums              ; copying the pointer to nums as <nums> \n    mov rax, [rax + rdi * 8]    ; setting the restul to <*(nums+n)>\n    ret\n\n; local read-only data\n.none:   db  \"Zero\",0h0\n.one:    db  \"One\",0h0\n.two:    db  \"Two\",0h0\n.three:  db  \"Three\",0h0\n.four:   db  \"Four\",0h0\n.five:   db  \"Five\",0h0\n.six:    db  \"Six\",0h0\n.seven:  db  \"Seven\",0h0\n.eight:  db  \"Eight\",0h0\n.nine:   db  \"Nine\",0h0\n.nums:\n        dq .none\n        dq .one\n        dq .two\n        dq .three\n        dq .four\n        dq .five\n        dq .six\n        dq .seven\n        dq .eight\n        dq .nine\n; ---------> endof switch_it_up <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213417,"user_id":168,"body":"SECTION .text\nglobal switch_it_up\nnumbers db \"Zero\", 0, 0\n        db \"One\", 0, 0, 0\n        db \"Two\", 0, 0, 0\n        db \"Three\", 0\n        db \"Four\", 0, 0\n        db \"Five\", 0, 0\n        db \"Six\", 0, 0, 0\n        db \"Seven\", 0\n        db \"Eight\", 0\n        db \"Nine\", 0, 0\n        db \"Ten\", 0\nswitch_it_up:\n  shl edi, 1\n  lea rax, [numbers + edi * 3]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213418,"user_id":null,"body":"SECTION .text\nglobal switch_it_up\nzero db \"Zero\", 0\none db \"One\", 0\ntwo db \"Two\", 0\nthree db \"Three\", 0\nfour db \"Four\", 0\nfive db \"Five\", 0\nsix db \"Six\", 0\nseven db \"Seven\", 0\neight db \"Eight\", 0\nnine db \"Nine\", 0\n\n; Pointers to strings (each pointer is 8 bytes long)\ntable dq zero, one, two, three, four, five, six, seven, eight, nine\n\nswitch_it_up:\n  push rbp\n  mov rbp, rsp\n  mov rcx, 9\ncheck:\n  cmp rdi, rcx\n  je integer_found\n  loop check\ninteger_found:\n  mov rax, [table + 8*rcx]\n  mov rsp, rbp\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213419,"user_id":null,"body":"SECTION .text\nzero db \"Zero\", 0\none db \"One\",0\ntwo db \"Two\",0\nthree db \"Three\",0\nfour db \"Four\", 0\nfive db \"Five\", 0\nsix db \"Six\", 0\nseven db \"Seven\", 0\neight db \"Eight\", 0\nnine db \"Nine\", 0\n\ndigits dq zero, one, two, three, four, five, six, seven, eight, nine\n\nglobal switch_it_up\n\nswitch_it_up:\n  mov rax,[digits + rdi * 8]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213420,"user_id":null,"body":"section .data\n        numbers db \"Zero\",0,0\n                db \"One\",0,0,0\n                db \"Two\",0,0,0\n                db \"Three\",0\n                db \"Four\",0,0\n                db \"Five\",0,0\n                db \"Six\",0,0,0\n                db \"Seven\",0\n                db \"Eight\",0\n                db \"Nine\",0,0\nsection .text\nglobal switch_it_up\n\nswitch_it_up:\n  shl edi, 1\n  lea rax, [numbers + edi * 2 + edi]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213421,"user_id":null,"body":"section .rodata\nstr0 db \"Zero\", 0\nstr1 db \"One\", 0\nstr2 db \"Two\", 0\nstr3 db \"Three\", 0\nstr4 db \"Four\", 0\nstr5 db \"Five\", 0\nstr6 db \"Six\", 0\nstr7 db \"Seven\", 0\nstr8 db \"Eight\", 0\nstr9 db \"Nine\", 0\ntable dq str0, str1, str2, str3, str4, str5, str6, str7, str8, str9\n\nSECTION .text\nglobal switch_it_up\n\nswitch_it_up:\n  mov rax, [table + 8 * rdi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213422,"user_id":null,"body":"SECTION .text\nglobal switch_it_up\n\nswitch_it_up:\n  shl edi, 3\n  movsxd rcx, edi\n  lea rax, [.numbers]\n  add rax, rcx\n  ret\n.numbers:\n  db \"Zero\",0,0,0,0\n  db \"One\",0,0,0,0,0\n  db \"Two\",0,0,0,0,0\n  db \"Three\",0,0,0\n  db \"Four\",0,0,0,0\n  db \"Five\",0,0,0,0\n  db \"Six\",0,0,0,0,0\n  db \"Seven\",0,0,0\n  db \"Eight\",0,0,0\n  db \"Nine\",0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213423,"user_id":null,"body":"SECTION .text\nnum: db \"Zero\",0,\"One\",0,\"Two\",0,\"Three\",0,\"Four\",0,\"Five\",0,\"Six\",0,\"Seven\",0,\"Eight\",0,\"Nine\",0\nglobal switch_it_up\n\nswitch_it_up:\n  mov rax, num\n  cmp rdi, 0\n  je ed\n  add rax, 5\n  cmp rdi, 1\n  je ed\n  add rax, 4\n  cmp rdi, 2\n  je ed\n  add rax, 4\n  cmp rdi, 3\n  je ed\n  add rax, 6\n  cmp rdi, 4\n  je ed\n  add rax, 5\n  cmp rdi, 5\n  je ed\n  add rax, 5\n  cmp rdi, 6\n  je ed\n  add rax, 4\n  cmp rdi, 7\n  je ed\n  add rax, 6\n  cmp rdi, 8\n  je ed\n  add rax, 6\n  cmp rdi, 9\n  je ed\n  add rax, 5\n  ed:ret\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213424,"user_id":null,"body":"SECTION .text\nglobal switch_it_up\n\nswitch_it_up:\n  mov rax,[table + 8 * rdi]\n  ret\n  \nsection .data\ntable dq zero,one,two,three,four,five,six,seven,eight,nine\n\nzero db \"Zero\",0\none db \"One\",0\ntwo db \"Two\",0\nthree db \"Three\",0\nfour db \"Four\",0\nfive db \"Five\",0\nsix db \"Six\",0 \nseven db  \"Seven\",0\neight db \"Eight\",0 \nnine db \"Nine\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5809b62808ad92e31b000031":[{"id":213425,"user_id":null,"body":"extern sscanf,asprintf\nglobal calc\n\n; <-- [byte RAX] calc(ro [byte RDI] s) -->\ncalc:\n  push rbx\n  mov esi, .firstnumberfmt\n  xor eax, eax\n  mov rbx, rdi\n  sub rsp, 32\n  lea rcx, [rsp+16]\n  lea rdx, [rsp+12]\n  call sscanf\n.loop:\n  movsx rax, dword [rsp+16]\n  lea r8, [rsp+16]\n  lea rcx, [rsp+20]\n  mov esi, .opandnumberfmt\n  lea rdx, [rsp+11]\n  add rbx, rax\n  xor eax, eax\n  mov rdi, rbx\n  call sscanf\n  inc eax\n  je .nomore\n  cmp byte [rsp+11], 109\n  jne .plus\n  neg dword [rsp+20]\n.plus:\n  mov eax, [rsp+20]\n  add [rsp+12], eax\n  jmp .loop\n.nomore:\n  mov edx, [rsp+12]\n  lea rdi, [rsp+24]\n  mov esi, .resultfmt\n  xor eax, eax\n  call asprintf\n  mov rax, [rsp+24]\n  add rsp, 32\n  pop rbx\n  ret\n.firstnumberfmt: db \"%d%n\",0\n.opandnumberfmt: db\"%c%*[^0-9]%d%n\",0\n.resultfmt: db \"%d\",0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213426,"user_id":null,"body":"global calc\nextern asprintf\ncalc:\n  xor  rax,rax\n  xor  rcx,rcx\n  jmp  .c\n  .b:cmp   byte[rdi],'p'\n     sbb   rcx,rcx\n     adc   rdi,4\n  .c:xor   r9,r9\n     .a:movzx r8,byte[rdi]\n        lea   r9,[r9*4+r9]\n        lea   r9,[r9*2+r8-'0']\n        inc   rdi\n        movzx r8,byte[rdi]\n        sub   r8,'0'\n        cmp   r8,'9'-'0'\n     jbe .a   \n     xor   r9,rcx\n     sub   r9,rcx\n     add   rax,r9\n     cmp   byte[rdi],0\n  jne .b   \n  sub  rsp,8\n  mov  rdi,rsp\n  mov  rsi,fmt\n  mov  rdx,rax\n  call asprintf\n  pop  rax\nret\nfmt db '%i',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213427,"user_id":null,"body":"global calc\n\nsection .text\nextern malloc\n; <-- [byte RAX] calc(ro [byte RDI] s) -->\ncalc:\n    xor rcx, rcx        ; cl used for next byte from array, whole register needed for adding to rdx\n    mov r9b, 'p'        ; used for flag for current operator ('p' or 'm') - want to add first number so set to 'p'    \n    xor r10, r10        ; used as a break flag - if set non-zero, finish current iteration and end loop\n    xor rdx, rdx        ; used to build up current operand\n    xor rax, rax        ; running total\n    .loop:        \n        mov cl, [rdi]   ; get next byte\n        test cl, cl     ; check for null terminator\n        jz .end_of_string_found            \n        cmp cl, 'p'     ; check for start of 'plus'\n        je .plus_operator\n        cmp cl, 'm'     ; check for start of 'minus'\n        je .minus_operator\n        ; not a 'p' or an 'm' - must be a numeric character since we skip the rest of the letters in 'plus' and 'minus'\n        inc rdi         ; move rdi to nexct byte\n        imul rdx, 10    ; multiply current operand by 10 - shift its place\n        sub rcx, 48     ; convert from ascii to number\n        add rdx, rcx    ; add value of current byte\n    jmp .loop\n        .plus_operator:     \n          add rdi, 4    ; point rdi to next byte after 'plus'\n          cmp r9b, 'p'  ; check for *previous* operator, and perform that\n          je .add\n          jmp .sub                   \n        .minus_operator:\n          add rdi, 5    ; point rdi to next byte after 'minus'\n          cmp r9b, 'p'  ; check for *previous* operator, and perform that\n          je .add\n          jmp .sub \n        .end_of_string_found:\n            mov r10, 1  ; set flag to break after performing last operation\n            cmp r9b, 'p'; check for previous operator, and perform it\n            je .add\n            jmp .sub \n        .add:\n          add rax, rdx  ; add current operand to running total\n          xor rdx, rdx  ; clear current operand\n          mov r9b, cl   ; save new operator\n          test r10, r10 ; see if break flag set\n          jnz .break       \n    jmp .loop\n        .sub:\n          sub rax, rdx  ; subtract current operand from running total\n          xor rdx, rdx  ; clear current operand\n          mov r9b, cl   ; save new operator\n          test r10, r10 ; see if break flag set\n          jnz .break       \n    jmp .loop\n    .break:\n    xor r9, r9          ; number is negative flag\n    test rax, rax       ; check if neg\n    jns .have_handled_sign\n      mov r9, 1         ; flag as negative\n      neg rax           ; and make positive\n    .have_handled_sign:\n    push word 0         ; string terminator onto stack first\n    mov rcx, 1          ; rcx used as stack counter\n    mov r8, 10          ; for division\n    .digits_loop:       ; get digits by division, put on stack then pop off to reverse\n        xor rdx, rdx    ; clear for div remainder\n        div r8          ; rax \/ 10 into rax.  rax % 10 into rdx\n        add rdx, 48     ; convert to ascii\n        push dx         ; push low word of rdx (don't seem to be able to push a byte??)\n        inc rcx         ; items on stack counter\n        test rax, rax\n    jnz .digits_loop\n    test r9, r9         ; check if number is negative is flagged, stick a '-' char onto stack \n    jnz .do_minus_sign\n    .create_string:\n    mov rdi, rcx        ; length of result for malloc\n    inc rdi             ; with extra byte for terminator\n    push rcx            ; save rcx register from malloc\n    sub rsp, 20h        ; shadow space\n    call malloc \n    add rsp, 20h        ; remove shadow space\n    pop rcx             ; restore rcx\n    mov rdx, rax        ; pointer to next char to write\n    .string_loop:       \n        pop r8w          ; pop each char (16 bits per on stack) and write to string (8 bits per)\n        mov [rdx], r8b\n        inc rdx\n    loop .string_loop   ; rcx was set with number of items added to stack\n    mov byte [rdx], 0   ; terminate string\n    ret  \n    .do_minus_sign:\n      push word '-'\n      inc rcx\n    jmp .create_string\n    jmp .string_loop","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213428,"user_id":null,"body":"global calc\nextern malloc, atol\nextern sprintf, sscanf\n\n%macro lfmt 2\n    lea rdi, [%1]           ; pointing RDI to <s>\n    mov rsi, .fmt           ; pointing RSI to <.fmt>\n    mov rdx, %2             ; copying <l> to RDX\n    call sprintf            ; printing <l> to <s>\n%endmacro\n\n%macro lscan 3\n    add %2, %1              ; offsetting <s>\n    mov rdi, %2             ; pointing RDI to <s>\n    mov rsi, .fmt           ; poinring RSI to <.fmt>\n    mov rdx, %3             ; pointing RDX to <l>\n    call sscanf             ; scanning a long to <l> from <s>\n%endmacro\n\n; <-- [byte RAX] calc(ro [byte RDI] s) -->\ncalc:\n    push r12                ; saving R12 onto stack\n    push rbx                ; saving RBX onto stack\n    sub rsp, 0h28           ; reserving storage for <x> and <fmt>\n    mov rbx, rdi            ; pointing RBX to <s>\n    call atol               ; parsing a number from <s>\n    mov r12, rax            ; copying the result from atol to R12 as <y>\n    lfmt rsp+0h8, rax       ; formatting <y> to <fmt>\n    add rbx, rax            ; pointing <s> after the number\n    jmp .lpout              ; jumping to loop exit\n.loop:\n    cmp dl, 'p'             ; whether <c> is 'p'\n    jne .m                  ; otherwise, jumping to the .m label\n    lscan 4, rbx, rsp       ; scanning a long to <x> from <s>\n    add r12, [rsp]          ; adding <x> to <y>\n    jmp .f                  ; jumping to the .f label\n.m:\n    lscan 5, rbx, rsp       ; scanning a long to <x> from <s>\n    sub r12, [rsp]          ; subtracting <x> from <y>\n.f:\n    lfmt rsp+0h8, [rsp]     ; formatting <x> to <fmt>\n    add rbx, rax            ; pointing <s> after the number\n.lpout:\n    mov dl, [rbx]           ; copying <*s> to DL as <c>\n    test dl, dl             ; whether <c> is the null character\n    jnz .loop               ; jumping to the next iteration in case not empty\n    mov rdi, 0h8            ; the number of byte to allocate for <r>\n    call malloc             ; allocating memory for <r>\n    test rax, rax           ; whether <r> has been allocated\n    je .exit                ; otherwise, jumping to exit\n    mov rbx, rax            ; copying <r> to RBX\n    lfmt rax, r12           ; formatting <y> to <r>\n    mov rax, rbx            ; pointing RAX to <r>\n.exit:\n    add rsp, 0h28           ; restoring the stack boundary\n    pop rbx                 ; restoring the original RBX from stack\n    pop r12                 ; restoring the original R12 from stack\n    ret\n; local read-only storage\n.fmt:\n    db  `%li\\0`\n; -----> endof calc <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"580a094553bd9ec5d800007d":[{"id":213429,"user_id":null,"body":"section .data\nhot: db \"It's hotter than the sun!!\", 0\nnotHot: db \"Help yourself to a honeycomb Yorkie for the glovebox.\", 0\n\n; x = edi\\rdi\n; put result string into eax\\rax\n\nSECTION .text\nglobal apple\napple:\n  cmp rdi, 32\n  jge .isHot\n  \n  lea rax, [notHot]\n  ret\n  \n  .isHot:\n    lea rax, [hot]\n    ret\n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213430,"user_id":null,"body":"section .rodata\nstr0 db \"Help yourself to a honeycomb Yorkie for the glovebox.\", 0\nstr1 db \"It's hotter than the sun!!\", 0\n\nsection .text\nglobal apple\napple:\n  mov rax, str0\n  mov rdx, str1\n  imul rdi, rdi\n  cmp rdi, 1000\n  cmovg rax,rdx\n            ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213431,"user_id":null,"body":"; x = edi\\rdi\n; put result string into eax\\rax\nSECTION .text\nglobal apple\napple:\n  imul edi, edi\n  cmp edi, 1001\n  lea rcx, [.sun]\n  lea rax, [.yorkie]\n  cmovae rax, rcx\n  ret\n.sun: db \"It's hotter than the sun!!\",0\n.yorkie: db \"Help yourself to a honeycomb Yorkie for the glovebox.\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213432,"user_id":null,"body":"SECTION .text\nglobal apple\n\napple:\n  ; x = edi\n  ; put result string into rax\n  mov rax, str_cold\n  mov rcx, str_hot\n  cmp edi, 31         ;it is 31\u00b2 = 961 , 32\u00b2 = 1024\n  cmovg rax, rcx\n  cmp edi, -31\n  cmovl rax, rcx\n  ret\n\nsection .data\n  str_cold db \"Help yourself to a honeycomb Yorkie for the glovebox.\",0\n  str_hot db \"It's hotter than the sun!!\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213433,"user_id":null,"body":"global apple\n\nsection .rodata\nhot:    db \"It's hotter than the sun!!\", 0\ncold:   db \"Help yourself to a honeycomb Yorkie for the glovebox.\", 0\n\n\nsection .text\n\napple:\n    cmp rdi, 32\n    jg  ret_hot\n    mov rax, cold\n    ret\n\nret_hot:\n    mov rax, hot\n    jmp ret_apple\n\nret_apple:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213434,"user_id":null,"body":"; x = edi\\rdi\n; put result string into eax\\rax\nSECTION .data\nt: db \"It's hotter than the sun!!\",0\nf: db \"Help yourself to a honeycomb Yorkie for the glovebox.\",0\nSECTION .text\nglobal apple\napple:\n  mov     rcx, t\n  mov     rax, f\n  cmp     rdi, 32\n  cmovge  rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213435,"user_id":null,"body":"; x = edi\\rdi\n; put result string into eax\\rax\nSECTION .data\n  hot db \"It's hotter than the sun!!\", 0\n  help db \"Help yourself to a honeycomb Yorkie for the glovebox.\", 0\n  \nSECTION .text\nglobal apple\n\napple:\n  mov rax, hot\n  mov r10, help\n  mov r8, rdi\n  imul r8, rdi\n  cmp r8, 1000\n  cmovb rax, r10\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213436,"user_id":null,"body":"global apple\napple:\n  cmp   rdi,31\n  mov   rdx,.yes\n  mov   rax,.no\n  cmova rax,rdx\nret\n.no  db \"Help yourself to a honeycomb Yorkie for the glovebox.\",0\n.yes db \"It's hotter than the sun!!\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213437,"user_id":3088,"body":"; x = edi\\rdi\n; put result string into eax\\rax\nSECTION .text\nglobal apple\n\napple:\n  cmp rdi, 32\n  jge .its_hot\n  mov rax, .cold\n  ret\n  \n  .its_hot:\n  mov rax, .hot\n  ret\n  \n.hot  db \"It's hotter than the sun!!\", 0\n.cold db \"Help yourself to a honeycomb Yorkie for the glovebox.\", 0\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213438,"user_id":77,"body":"; x = edi\\rdi\n; put result string into eax\\rax\nSECTION .text\nsun: \n    db \"It's hotter than the sun!!\",0,0,0,0,0,0\n    db \"Help yourself to a honeycomb Yorkie for the glovebox.\",0\nglobal apple\napple:\n    mov rcx, 32\n    mov rax, sun\n    cmp rdi, rcx\n    jge .end\n    add rax, rcx\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58261acb22be6e2ed800003a":[{"id":213439,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n    ; volume is length * width * height\n    mulsd xmm0, xmm1\n    mulsd xmm0, xmm2\n    ret\n; ---------> end of cubvol <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213440,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n    ; volume is length * width * height\n    mulpd xmm0, xmm1\n    mulpd xmm0, xmm2\n    ret\n; ---------> end of cubvol <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213441,"user_id":null,"body":"section .text\nglobal get_volume_of_cuboid\n\nget_volume_of_cuboid:\n    mulsd xmm0, xmm1\n    mulsd xmm0, xmm2\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213442,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n    mulsd xmm0, xmm1\n    mulsd xmm0, xmm2\n;     xorps xmm0, xmm0        ; XMM0 <- the result\n    ret\n; ---------> end of cubvol <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213443,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n  vmulsd xmm0, xmm0, xmm1\n  vmulsd xmm0, xmm0, xmm2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213444,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n    mulsd xmm0, xmm1\n    mulsd xmm0, xmm2\n    movq rax, xmm0\n    ret\n; ---------> end of cubvol <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213445,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n        mulsd   xmm0, xmm1\n        mulsd   xmm0, xmm2\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213446,"user_id":460,"body":"global get_volume_of_cuboid\nsection .text\nget_volume_of_cuboid:\n    mulsd xmm0, xmm1\n    mulsd xmm0, xmm2\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213447,"user_id":null,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n     mulsd xmm0, xmm1        ; multiplying <length> by <width>\n    mulsd xmm0, xmm2        ; multiplying <area> by <height>\n; ---------> end of cubvol <---------\n  \n    ret\n; ---------> end of cubvol <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213448,"user_id":50,"body":"global get_volume_of_cuboid\n\nsection .text\n\n; <--- double get_volume_of_cuboid(double length, double width, double height) --->\nget_volume_of_cuboid:\n    mulsd xmm1,xmm2\n    mulsd xmm0,xmm1\n    ret\n; ---------> end of cubvol <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"582c297e56373f0426000098":[{"id":213449,"user_id":17,"body":"global stringify\nextern strcat, sprintf\nsection .text\nstringify:\n  mov byte [result], 0\n.begin_while:\n  cmp rdi, 0\n  je .end_while\n  push rdi\n  xor rdx, rdx\n  mov edx, dword [rdi]\n  mov rdi, tmp\n  mov rsi, fmt\n  call sprintf\n  mov rdi, result\n  mov rsi, tmp\n  call strcat\n  pop rdi\n  mov rdi, qword [rdi + 8]\n  jmp .begin_while\n.end_while:\n  mov rdi, result\n  mov rsi, null_strrep\n  call strcat\n  mov rax, result\n  ret\n\nsection .data\nnull_strrep db \"NULL\", 0\nfmt db \"%d -> \", 0\n\nsection .bss\nresult resb 2049\ntmp resb 16","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213450,"user_id":null,"body":"extern malloc,sprintf\nglobal stringify\nsection .text\nstringify:\n  push r15\n  push r14\n  push rbx\n  mov r15, rdi\n  mov rax, 5\n  mov rcx, rdi\n.findtail:\n  test rcx, rcx\n  je .lengthfound\n  mov rcx, [rcx + 8]\n  add eax, 16\n  jmp .findtail\n.lengthfound:\n  mov edi, eax\n  call malloc\n  mov r14, rax\n  mov rbx, rax\n.printnode:\n  test r15, r15\n  je .finishstring\n  mov edx, [r15]\n  mov esi, .str\n  mov rdi, rbx\n  xor eax, eax\n  call sprintf\n  mov r15, [r15 + 8]\n  cdqe\n  add rbx, rax\n  jmp .printnode\n.finishstring:\n  mov byte [rbx + 4], 0\n  mov dword [rbx], 1280070990\n  mov rax, r14\n  pop rbx\n  pop r14\n  pop r15\n  ret\n.str: db \"%d -> \",0,\"NULL\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213451,"user_id":173,"body":"extern sprintf, malloc\nglobal stringify\nsection .data\nfmt: db \"%d -> \", 0\nnstr: db \"NULL\", 0\n\nsection .text\nstringify:\n  push rdi\n  mov rdi, 32768\n  call malloc\n  pop rdi\n\n  ; r14 is position to write at, r15 is buffer start\n  mov r14, rax\n  mov r15, r14\n\n  cmp rdi, 0\n  jz l_done\n\nl_loop:\n  mov r12d, dword [rdi]\n  add rdi, 8\n  \n  push rdi\n  mov rdi, r14\n  lea rsi, [rel fmt]\n  mov edx, r12d\n  call sprintf\n  pop rdi\n  add r14, rax\n  \n  mov r13, qword [rdi]\n  cmp r13, 0\n  jz l_done\n  \n  mov rdi, r13\n  jmp l_loop\n  \n  \nl_done:\n  mov byte [r14], 'N'\n  inc r14\n  mov byte [r14], 'U'\n  inc r14\n  mov byte [r14], 'L'\n  inc r14\n  mov byte [r14], 'L'\n  inc r14\n  mov byte [r14], 0\n\n  mov rax, r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213452,"user_id":null,"body":"global stringify\nextern sprintf\n\nsection .text\n\nstringify:\n    mov rbx, buffer\n    mov r12, rdi\n\n.next_node:\n    ; r12 points to a node\n    cmp r12, 0x0\n    je .exit\n\n    ; add number\n    mov rdi, rbx ; 1st argument: pointer to buffer\n    mov rsi, format_num ; 2nd argument: pointer to format string\n    mov edx, dword [r12] ; 3rd argument: number\n    xor rax, rax\n    call sprintf\n    add rbx, rax\n\n    ; point to a next node\n    mov r12, qword [r12 + 8]\n    jmp .next_node\n\n.exit:\n    mov rdi, rbx\n    mov rsi, format_str\n\n    xor rax, rax\n    call sprintf\n\n    mov rax, buffer\n    ret\n\n\nsection .bss\nbuffer resb 1024\n\nsection .data\nformat_num db '%d -> ', 0x0\nformat_str db 'NULL', 0x0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213453,"user_id":null,"body":"global stringify\nextern sprintf\n\nsection .text\n\nstringify:\n    mov rbx, buffer\n    mov r12, rdi\n\n.next_node:\n    ; r12 points to a node\n    cmp r12, 0x0\n    je .exit\n\n    ; add number\n    mov rdi, rbx ; 1st argument: pointer to buffer\n    mov rsi, format_num ; 2nd argument: pointer to format string\n    mov edx, dword [r12] ; 3rd argument: number\n    xor rax, rax\n    call sprintf\n    add rbx, rax\n\n    ; add delimiter\n    mov rdi, rbx\n    mov rsi, format_str\n    mov rdx, delimiter\n    xor rax, rax\n    call sprintf\n    add rbx, rax\n\n    ; point to a next node\n    mov r12, qword [r12 + 8]\n    jmp .next_node\n\n.exit:\n    mov rdi, rbx\n    mov rsi, format_str\n    mov rdx, terminator\n\n    xor rax, rax\n    call sprintf\n\n    mov rax, buffer\n    ret\n\n\nsection .bss\nbuffer resb 1024\n\nsection .data\nformat_num db '%d', 0x0\nformat_str db '%s', 0x0\ndelimiter db ' -> ', 0x0\nterminator db 'NULL', 0x0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213454,"user_id":null,"body":"global stringify\nsection .text\nextern sprintf\nstringify:\n  push rbx\n  push r12\n  mov  r12,txt\n  test rdi,rdi\n  je @f\n    mov  rbx,rdi\n    @b:mov  rdi,r12\n       mov  rsi,fmt\n       mov  rdx,[rbx]\n       xor  rax,rax\n       call sprintf\n       add  r12,rax\n       mov  rbx,[rbx+8]\n       test rbx,rbx\n    jne @b   \n  @f:\n  mov  qword[r12],'NULL'\n  mov  rax, txt\n  pop  r12\n  pop  rbx\n  ret\n section .data\n fmt db '%u -> ',0\n txt times 1024 db 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213455,"user_id":168,"body":"global stringify\nextern snprintf\n%define SIZE 4096\nsection .bss\nbuf resb SIZE\nsection .text\nformat db \"%d -> \", 0\nnull db \"NULL\", 0\nstringify:\n  push rbx\n  push r12\n  push r13\n  lea r12, [rel buf]\n  xor r13, r13\n  mov rbx, rdi\n  jmp .cond\n.loop:\n  mov esi, SIZE\n  sub esi, r13d\n  jle .end\n  lea rdi, [r12 + r13]\n  lea rdx, [rel format]\n  mov ecx, dword [rbx]\n  call snprintf\n  add r13, rax\n  mov rbx, [rbx + 8]\n.cond:\n  test rbx, rbx\n  jnz .loop\n  mov esi, SIZE\n  sub esi, r13d\n  jle .end\n  lea rdi, [r12 + r13]\n  lea rdx, [rel null]\n  call snprintf\n.end:\n  mov rax, r12\n  pop r13\n  pop r12\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"582cb0224e56e068d800003c":[{"id":213456,"user_id":1277,"body":"SECTION .text\nglobal litres\n\n; int litres(double);\nlitres:\n  cvttsd2si eax, xmm0\n  shr eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213457,"user_id":null,"body":"global litres\n\nsection .text\n\n; <--- int litres(double) --->\nlitres:\n    mov rdx, __float64__(0.5)    ; moving a half to RDX\n    movq xmm1, rdx               ; copying RDX to XMM1\n    mulsd xmm0, xmm1             ; multiplying hours by litre per hour\n    cvttsd2si eax, xmm0          ; getting rid of the fraction part\n    ret\n; -----> endof litres <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213458,"user_id":525,"body":"SECTION .text\nglobal litres\n\n; int litres(double);\nlitres:\n  cvttsd2si eax, xmm0    ; cast to int\n  shr eax, 1            ; divide by 2\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213459,"user_id":50,"body":"SECTION .text\nglobal litres\n\n; int litres(double);\nlitres:\n  xor rax, rax\n  cvttsd2si rax,xmm0\n  shr rax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213460,"user_id":null,"body":"section .data\ntwo: dq 2.0\n\n\nSECTION .text\nglobal litres\n\nextern printf \n; int litres(double time);\nlitres:\n  \n  \n  divsd xmm0, [two]\n  CVTTSD2SI rax, xmm0    ;; Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Dword Integer \n                         ;; https:\/\/en.wikipedia.org\/wiki\/X86_instruction_listings#SSE2_instructions\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213461,"user_id":null,"body":"SECTION .text\nglobal litres\n\n; int litres(double);\nlitres:\n  cvttsd2si rax, xmm0    ; truncate hours to int\n  sar rax,1              ; 1 liter per 2 hours\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213462,"user_id":1088,"body":"[section .text]\n\nglobal litres\n\n; int litres(double);\nlitres:\n  mulsd     xmm0, [rel .lt]\n  cvttsd2si eax, xmm0\n  ret\n.lt:\n  dq 0.5\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213463,"user_id":null,"body":"SECTION .text\nglobal litres\n\n; int litres(double);\nlitres:\n    mulsd xmm0, [half]\n    cvttsd2si eax, xmm0\n    ret\n\nsection .data\nhalf: dq 0.5\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213464,"user_id":null,"body":"SECTION .text\nglobal litres\n\n; int litres(double);\nlitres:\n  mulsd   xmm0, [scale_factor]\n  cvttsd2si       eax, xmm0\n  ret\n  \nscale_factor: dq 0.5\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213465,"user_id":null,"body":"SECTION .text\nglobal litres\n\nlitres:\n  mulsd     xmm0,[.half]\n  cvttsd2si rax,xmm0\n  ret\n .half dq 0.5","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"583710ccaa6717322c000105":[{"id":213466,"user_id":null,"body":"SECTION .text\nglobal simple_multiplication\n\n; Multiplies and returns the argument by 8 if the argument is even, else 9 if the argument is odd.\n; arg0         = (int64_t) The argument to multiply.\n; return value = (int64_t) The result.\nsimple_multiplication:\n    mov rax, 1\n    and rax, rdi\n    add rax, 8\n    mul rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213467,"user_id":null,"body":"section     .text\nglobal      simple_multiplication\n\nsimple_multiplication:\n    xor     rax, rax\n    xor     rcx, rcx\n    xor     rdx, rdx\n\n    mov     rax, rdi\n    mov     rcx, 2\n\n    div     rcx\n    \n    cmp     rdx, 1\n    jz      _nine\n    jmp     _eight\n\n_nine:\n    mov     rcx, 9\n    jmp     _finish\n\n_eight:\n    mov     rcx, 8\n    jmp     _finish\n\n_finish:\n    mov     rax, rdi\n    mul     rcx\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213468,"user_id":168,"body":"SECTION .text\nglobal simple_multiplication\n\n; Multiplies and returns the argument by 8 if the argument is even, else 9 if the argument is odd.\n; arg0         = (int64_t) The argument to multiply.\n; return value = (int64_t) The result.\nsimple_multiplication:\n  xor edx, edx\n  test dil, 1\n  cmovnz rdx, rdi\n  lea rax, [rdi * 8 + rdx]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213469,"user_id":527,"body":"section .text\nglobal simple_multiplication\nsimple_multiplication:\n                xor     edx, edx\n                test    edi, 1\n                cmovnz  rdx, rdi\n                lea     rax, [rdi * 8 + rdx]\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213470,"user_id":null,"body":"SECTION .text\n  global simple_multiplication\n\nsimple_multiplication:\n  mov rax,8\n  bt rdi,0\n  adc rax,0\n  imul rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213471,"user_id":null,"body":"global simple_multiplication\nsimple_multiplication:\n  mov rax, rdi\n  and rax, 1\n  add rax, 8\n  mul rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213472,"user_id":null,"body":"SECTION .text\nglobal simple_multiplication\n\nsimple_multiplication:\n  lea  rax,[rdi*8]\n  shrd rdx,rdi,1\n  sar  rdx,63\n  and  rdx,rdi\n  add  rax,rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213473,"user_id":null,"body":"section .text\nglobal simple_multiplication\n\nsimple_multiplication:\n  mov rsi, rdi\n  shl rdi, 3\n  mov rax, rdi\n  mov rdx, rsi\n  and rdx, 1\n  jnz _add\n  ret\n  \n_add:\n  add rax, rsi\n  ret\n\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213474,"user_id":null,"body":"SECTION .text\nglobal simple_multiplication\n\n; Multiplies and returns the argument by 8 if the argument is even, else 9 if the argument is odd.\n; arg0         = (int64_t) The argument to multiply.\n; return value = (int64_t) The result.\nsimple_multiplication:\n  mov eax, edi\n  xor edx, edx\n  mov ebx, 2\n  div ebx\n  mov ecx, 8\n  add ecx, edx\n  mov eax, edi\n  mul ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213475,"user_id":null,"body":"SECTION .text\nglobal simple_multiplication\n\n; Multiplies and returns the argument by 8 if the argument is even, else 9 if the argument is odd.\n; arg0         = (int64_t) The argument to multiply.\n; return value = (int64_t) The result.\nsimple_multiplication:\n  xor rax, rax\n  xor rdx, rdx\n  \n  mov rax, rdi\n  mov rbx, 2\n  div rbx\n  mov rax, rdi\n  cmp rdx, 0\n  jne .odd\n  mov rbx, 8\n  mul rbx\n\n  jmp .end\n.odd:\n  mov rbx, 9\n  mul rbx\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5839edaa6754d6fec10000a2":[{"id":213476,"user_id":527,"body":"global find_missing_letter\n\nsection .text\n\n; char find_missing_letter(const char *s, int n)\nfind_missing_letter:\n                movzx   eax, byte [rdi]\n.loop:          inc     al\n                inc     rdi\n                cmp     [rdi], al\n                je      .loop\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213477,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n    xor al, al; AL <- the result\n    mov bl, [rdi]\n    inc rdi\n    mov al, [rdi]\n    sub al, bl\n    cmp al, 0x1\n    jnz bl_last\n    jmp find_missing_letter\nbl_last:\n    inc bl\n    movzx rax, bl\n    ret\n    ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213478,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n  ;xor al, al      ; AL <- the result\n  dec rsi\n  mov al,[rdi+rsi]\n  dec al\n  cmp al,[rdi+rsi-1]\n  je find_missing_letter\nret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213479,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n  mov dl, [rdi]\n  lea rsi, [rdi+1]\n.loop:\n  lodsb\n  sub dl, al\n  inc dl\n  mov dl, al\n  jz .loop\n  \n  dec al\n  ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213480,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n  mov rdx, 1\n.loop:\n  movsx ecx, byte [rdi+rdx-1]\n  movsx esi, byte [rdi+rdx]\n  mov eax, ecx\n  inc ecx\n  cmp esi, ecx\n  jne .done\n  inc rdx\n  jmp .loop\n.done:\n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213481,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n    WHILE:\n    mov al, [rdi]\n    mov dl, [rdi+1]\n    inc rdi\n    inc al\n    cmp al, dl\n    jz  WHILE\n    ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213482,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n    mov al,[rdi]\n    \n    _loop:\n    inc rdi\n    inc al\n    \n    mov bl, [rdi]\n    cmp al, bl\n    jne _return\n    dec rsi\n    test rsi, rsi\n    jnz _loop\n    \n    inc al\n    \n    \n    _return:\n    ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213483,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n    mov al,[rdi]\n    \n    _loop:\n    inc rdi\n    inc al\n    \n    mov bl, [rdi]\n    cmp al, bl\n    jne _return\n    dec rsi\n    test rsi, rsi\n    jnz _loop\n    \n    mov al, bl\n    inc al\n    \n    \n    _return:\n    ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213484,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n\n    lea rcx, [rsi]\n    mov al, byte[rdi]\n    \nloop:\n    \n    cmp al, byte[rdi]\n    jnz end\n    inc al\n    inc rdi\n    \n    loopne loop\n    \n    xor al, al          \n    \nend:    \n    ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213485,"user_id":null,"body":"global find_missing_letter\n\nsection .text\n\n; <--- char find_missing_letter(const char *s, int n) --->\nfind_missing_letter:\n\n    lea rcx, [rsi-1]\n    mov al, byte[rdi+rcx]\n    \nloop:\n    \n    cmp al, byte[rdi+rcx]\n    jnz end\n    dec al    \n    \n    loopne loop\n    \n    cmp al, byte[rdi+rcx]\n    jnz end\n\n    xor al, al          \n    \nend:    \n    ret\n; ---------> endof find_missing_letter <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58558673b6b0e5a16b000028":[{"id":213486,"user_id":null,"body":"global fightResolve\nfightResolve:\n  pext  rcx,rdi,[pextmask]\n  pext  rdx,rsi,[pextmask]\n  movzx ecx,byte[defender+rcx]\n  mov   eax,esi\n  xor   esi,edi\n  bt    esi,5\n  mov   esi,0\n  adc   esi,-1\n  cmp   cl,byte[attacker+rdx]\n  cmove eax,edi\n  or    eax,esi\nret\npextmask dq 10011b\n;             a   k p     s\ndefender db 0,0,0,1,2,0,0,3\nattacker db 0,1,0,2,3,0,0,0\n         ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213487,"user_id":null,"body":"global fightResolve\nsection .text\n\nfightResolve:\n  mov ecx, esi\n  mov al, -1\n  xor cl, dil\n  test cl, 32\n  je .done\n  mov eax, edi\n  mov dl, 3\n  or al, 32\n  cbw\n  idiv dl\n  mov ecx, eax\n  mov eax, esi\n  or al, 32\n  shl cl, 2\n  cbw\n  and cl, 12\n  idiv dl\n  and al, 3\n  or cl, al\n  movzx eax, cl\n  mov ecx, 60795\n  bt ecx, eax\n  movzx ecx, dil\n  movzx eax, sil\n  cmovae eax, ecx\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213488,"user_id":null,"body":"global fightResolve\nsection .text\n\nfightResolve:\n  mov al,dil    ; See if the pieces are from the same player\n  xor al,sil\n  shr al,6\n  sbb al,al     ; If so, stop \n  not al\n  jz .stop\n  \n  xor rcx,rcx    ; Clear counter\n  mov r8b,dil    ; R8B = defender\n  mov r9b,sil    ; R9B = attacker\n  \n  mov rdi,.defenders\n  mov cl,4\n  mov al,32      ; Find defender\n  or al,r8b\n  repne scasb\n  mov dl,cl      ; DL = defender index\n  \n  mov rdi,.attackers\n  mov cl,4\n  mov al,32\n  or al,r9b      ; Find attacker\n  repne scasb\n  \n  cmp dl,cl      ; Are they the same?\n  cmove ax,r8w   ; Then the defender wins\n  cmovne ax,r9w  ; Otherwise the attacker wins\n.stop:\n  ret\n.attackers: db 'apsk' ; These are arranged such that if the index is the same,\n.defenders: db 'ksap' ; the defender wins. ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213489,"user_id":168,"body":"global fightResolve\nsection .text\n\nfightResolve:\n  mov ecx, -1\n  mov eax, esi\n  xor eax, edi\n  and eax, 32\n  cmovz esi, ecx\n  mov eax, esi\n  or esi, 32\n  mov edx, edi\n  or edx, 32\n  lea ecx, [edx + 'a' - 'k']\n  cmp ecx, esi\n  cmove eax, edi\n  lea ecx, [edx + 'p' - 's']\n  cmp ecx, esi\n  cmove eax, edi\n  lea ecx, [edx + 's' - 'a']\n  cmp ecx, esi\n  cmove eax, edi\n  lea ecx, [edx + 'k' - 'p']\n  cmp ecx, esi\n  cmove eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213490,"user_id":864,"body":"global fightResolve\nsection .text\n\nfightResolve:\n  jmp samePlayer\nactualCheck:\n  cmp edi, 75\n  je defenseKnight\n  cmp edi, 107\n  je defenseKnight\n  \n  cmp edi, 83\n  je defenseSwordsman\n  cmp edi, 115\n  je defenseSwordsman\n  \n  cmp edi, 65\n  je defenseArcher\n  cmp edi, 97\n  je defenseArcher\n  \n  jmp defensePikeman\n\nsamePlayer:\n  cmp edi, 97\n  jl UP\n\nLO:\n  cmp esi, 96\n  jg illegalMove\n  jmp actualCheck\n\nUP:\n  cmp esi, 97\n  jl illegalMove\n  jmp actualCheck\n  \ndefenseKnight:\n  cmp esi, 65\n  je defenseWins\n  cmp esi, 97\n  je defenseWins\n  jmp offenseWins\n  \ndefenseSwordsman:\n  cmp esi, 80\n  je defenseWins\n  cmp esi, 112\n  je defenseWins\n  jmp offenseWins\n  \ndefenseArcher:\n  cmp esi, 83\n  je defenseWins\n  cmp esi, 115\n  je defenseWins\n  jmp offenseWins\n  \ndefensePikeman:\n  cmp esi, 75\n  je defenseWins\n  cmp esi, 107\n  je defenseWins\n  jmp offenseWins\n  \ndefenseWins:\n  mov eax, edi\n  ret\n  \noffenseWins:\n  mov eax, esi\n  ret\n\nillegalMove:\n  mov eax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"585c50e75d0930e6a7000336":[{"id":213491,"user_id":null,"body":"global are_coprime\n\nsection .text\n      \nare_coprime:     ; bool are_coprime(unsigned int a, unsigned int b)\n  mov edx, esi\n.loop:\n  mov eax, edi\n  mov edi, edx\n  xor edx, edx\n  div edi\n  test edx, edx\n  jne .loop\n  cmp edi, 1\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213492,"user_id":881,"body":"section .text\nglobal are_coprime\n      \n; bool are_coprime(unsigned int a, unsigned int b)\nare_coprime:\n    call gcd\n    xor rdx, rdx\n    cmp rax, 1\n    cmovne rax, rdx\n    ret\n\n; unsigned int gcd(unsigned int a, unsigned int b)\ngcd:\n    mov eax, edi\n    jmp .while\n.do:\n    xor edx, edx\n    div esi\n    mov eax, esi\n    mov esi, edx    \n.while:\n    test esi, esi\n    jnz .do\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213493,"user_id":168,"body":"global are_coprime\n\nsection .text\n      \nare_coprime:     ; bool are_coprime(unsigned int a, unsigned int b)\n                 ; a := edi\n                 ; b := esi\n  mov eax, edi\n.loop:\n  xor edx, edx\n  div esi\n  mov eax, esi\n  mov esi, edx\n  test esi, esi\n  jnz .loop\n  cmp eax, 1\n  sete al\n  ret\n;<--    end of are_coprime -->","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213494,"user_id":527,"body":"global are_coprime\n\nsection .text\n      \n; bool are_coprime(unsigned a, unsigned b)\nare_coprime:\n                mov     eax, edi\n                or      eax, esi\n                and     eax, 1\n                jz      .done\n                tzcnt   eax, edi\n                tzcnt   edx, esi\n                shrx    edi, edi, eax\n                shrx    esi, esi, edx\n.loop:          mov     eax, edi\n                sub     eax, esi\n                tzcnt   ecx, eax\n                mov     edx, esi\n                sub     edx, edi\n                cmovb   edx, eax\n                cmovb   edi, esi\n                shrx    esi, edx, ecx\n                jnz     .loop\n                cmp     edi, 1\n                sete    al\n.done:          ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213495,"user_id":50,"body":"global are_coprime\n\nsection .text\n      \nare_coprime:\n  mov eax, edi\n  mov ecx, esi\n_loop:\n  test ecx, ecx\n  jz _exit\n  xor edx, edx\n  div ecx\n  mov eax, edx\n  xchg eax, ecx\n  jmp _loop\n_exit:\n  cmp eax, 1\n  je _ret\n  xor al, al\n_ret:\n  ret\n;<--    end of are_coprime -->","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"585cf93f6ad5e0d9bf000010":[{"id":213496,"user_id":null,"body":"global throwbowls\n\nsection .text\n\nthrowbowls:\n  movups xmm0, [.fullframe+16]\n  movups xmm1, [.fullframe]\n  mov rax, rdi\n  movups [rdi + 16], xmm0\n  movups [rdi], xmm1\n.loop:\n  sub rdx, 1\n  jb .done\n  movsxd rcx, dword [rsi]\n  add rsi, 4\n  movsx rcx, byte [rcx + .pin]\n  mov byte [rax + rcx], 32\n  jmp .loop\n.done:\n  ret\n.fullframe: db `I I I I\n I I I \n  I I  \n   I   `,0\n.pin: db 0,27,18,20,9,11,13,0,2,4,6","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213497,"user_id":null,"body":"global throwbowls\n\nsection .text\n\n; <-- [byte RAX] throwbowls([byte RDI] field, ro [dword RSI] pins, RDX len) -->\nthrowbowls:\n    xor rcx, rcx\n.set_field:\n    mov al, byte [new_field + rcx]\n    mov byte [rdi + rcx], al\n    inc rcx\n    test al, al\n    jnz .set_field\n    xor rcx, rcx\n.knock_pins:\n    cmp rcx, rdx\n    je .return\n    mov eax, dword [rsi + 4 * rcx]\n    movzx rax, byte [pin_pos + eax]\n    mov byte [rdi + rax], ' '\n    inc rcx\n    jmp .knock_pins\n.return:\n    mov rax, rdi\n    ret\n; -----> endof throwbowls <-----\n\nsection .data\n;           0   1   2   3  4   5   6  7  8  9 10\npin_pos db -1, 27, 18, 20, 9, 11, 13, 0, 2, 4, 6\nnew_field db \"I I I I\", 0x0a, \" I I I \", 0x0a, \"  I I  \", 0x0a, \"   I   \", 0x00\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213498,"user_id":null,"body":"global throwbowls\n\nsection .text\n\n; <-- [byte RAX] throwbowls([byte RDI] field, ro [dword RSI] pins, RDX len) -->\nthrowbowls:\n  mov r8, rsi\n  mov rax, rdi\n  lea rsi, [initial_field]\n  mov rcx, field_length\n  rep movsb\n  mov rsi, r8\n  \n  test rdx, rdx\n  jz .done\n  lea rdi, [pin_position]\n.loop:\n  mov ecx, [rsi+rdx*4-4]\n  mov ecx, [rdi+rcx*4]\n  mov byte [rax+rcx], ' '\n  dec rdx\n  jne .loop\n  \n.done:\n  ret\n; -----> endof throwbowls <-----\n\nsection .rodata\npin_position: dd 0, 27, 18, 20, 9, 11, 13, 0, 2, 4, 6 \ninitial_field: db \"I I I I\", 10, \" I I I \", 10, \"  I I  \", 10, \"   I   \"\nfield_length: equ $-initial_field\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213499,"user_id":null,"body":"global throwbowls\nextern strcpy\n    pins db 'I I I I', 10, ' I I I ', 10, '  I I  ', 10, '   I   ', 0\n    ltable db 27, 18, 20, 9, 11, 13, 0, 2, 4, 6\nthrowbowls:\n    push rbx\n    push rsi\n    push rdx\n    push rdi\n    mov rsi, pins\n    call strcpy\n    pop rdi\n    pop rcx\n    pop rsi\n    test rcx, rcx\n    jz .L2\n    lea rbx, [ltable-1]\n.L1:\n    mov eax, [rsi+4*rcx-4]\n    xlatb\n    mov byte [rdi+rax], ' '\n    loop .L1\n    mov rax, rdi\n.L2:\n    pop rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213500,"user_id":null,"body":"global throwbowls\nextern strcpy\n    pins db 'I I I I', 10, ' I I I ', 10, '  I I  ', 10, '   I   ', 0\n    ltable db 27, 18, 20, 9, 11, 13, 0, 2, 4, 6\nthrowbowls:\n    push rbx\n    push rsi\n    push rdx\n    push rdi\n    mov rsi, pins\n    call strcpy\n    pop rdi\n    pop rcx\n    pop rsi\n    mov rbx, ltable\n    test rcx, rcx\n    jz .L2\n.L1:\n    mov eax, [rsi+4*rcx-4]\n    dec eax\n    xlatb\n    mov byte [rdi+rax], ' '\n    loop .L1\n    mov rax, rdi\n.L2:\n    pop rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213501,"user_id":null,"body":"global throwbowls\n\nsection .text\n\n; <-- [byte RAX] throwbowls([byte RDI] field, ro [dword RSI] pins, RDX len) -->\nthrowbowls:\n    mov r8, rdi                   ; keep arguments out of harm's way\n    mov r9, rsi\n    mov rsi, .inistr              ; initialize bowling pins \n    movsq                         ; each line is 8 bytes\n    movsq\n    movsq\n    movsq\n    test rdx, rdx                 ; if there are no pins to knock over, exit immediately\n    jz .out\n    mov rsi, r9                   ; otherwise start knocking pins over\n.pin:\n    lodsd                         ; get pin\n    movzx rax, byte [rax + .ix]   ; get pin index\n    mov [r8 + rax], byte ' '      ; knock pin over\n    dec rdx                       ; more pins?\n    jnz .pin \n.out:\n    mov rax, r8\n    ret\n.ix:                              ; indices of pins\n    db 1  ; no-op in case of 0\n    db       1Bh\n    db     12h, 14h \n    db   9h, 0Bh, 0Dh \n    db  0h, 2h, 4h, 6h\n.inistr:\n    db 'I I I I',10\n    db ' I I I ',10\n    db '  I I  ',10\n    db '   I   ',0\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213502,"user_id":null,"body":"global throwbowls\nthrowbowls:\n  mov  rax,rdi\n  mov  r8,rsi\n  mov  rsi,result\n  movsq\n  movsq\n  movsq\n  movsq\n  jmp .f\n  .b:mov   ecx,[r8+rdx*4]\n     movzx rcx,byte[translate+rcx-1]\n     mov   byte[rax+rcx],' '\n  .f:dec   rdx\n  jns .b\nret\nresult    db 'I I I I',10,' I I I ',10,'  I I  ',10,'   I   ',0\ntranslate db 27,18,20,9,11,13,0,2,4,6","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213503,"user_id":null,"body":"global throwbowls\n\nsection .text\n\n; <-- [byte RAX] throwbowls([byte RDI] field, ro [dword RSI] pins, RDX len) -->\nthrowbowls:\n    vmovdqa ymm0, [rel .field]      ; copying <.field> to YMM0\n    vmovdqu [rdi], ymm0             ; copying YMM0 to <field>\n    mov rax, rdi                    ; pointing RAX to <field>\n    mov rdi, .pins                  ; pointing RDI to <.pins>\n    sub rdx, 1                      ; decrementing <len>\n    jmp .exit                       ; jumping to exit\n.loop:\n    mov ecx, [rsi+rdx*4]            ; copying <pins[len]> to RCX as <pin>\n    mov ecx, [rdi+rcx*4]            ; getting the pin <inx>\n    mov byte [rax+rcx], ' '         ; clearing the pin in <field[inx]>\n    sub rdx, 1                      ; decrementing <len>\n.exit:\n    jae .loop                       ; jumping to the next iteration if <len> is equal or above zero\n    ret\n; readonly local storage\nalign 32\n.field: db  `I I I I\n I I I \n  I I  \n   I   \\0`\n.pins:  dd  -1, 27, 18, 20, 9, 11, 13,  0, 2, 4, 6\n; -----> endof throwbowls <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5861d28f124b35723e00005e":[{"id":213504,"user_id":null,"body":"global zero_fuel\nzero_fuel:\n  ; XMM0 distance_to_pump\n  ; XMM1 mpg [miles\/gallon]\n  ; XMM2 fuel_left [gallon]\n  xor eax,eax           ; EAX = 0\n  mulsd xmm1, xmm2      ; XMM1 = XMM1 * XMM2 \n                        ; XMM1 stores distance left to go [miles]\n  comisd xmm1, xmm0     ; CF=1 if XMM1 < XMM0 (we can not get to the pump)\n  setnb al              ; EAX=1, if CF = 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213505,"user_id":null,"body":"section .text\nglobal zero_fuel\n\nzero_fuel:\n  push rbp\n  mov rbp, rsp\n  movsd [rbp - 0x08], xmm0\n  movsd [rbp - 0x10], xmm1\n  movsd [rbp - 0x18], xmm2\n  movsd xmm0, [rbp - 0x10]\n  mulsd xmm0, [rbp - 0x18]\n  comisd xmm0, [rbp - 0x08]\n  setae al\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213506,"user_id":null,"body":"global zero_fuel\n            ; xmm0 <- distance,\n            ; xmm1 <- mpg,\n            ; xmm2 <- fuel left,\n            ; result to eax : 1 for true, 0 for false\nzero_fuel:\n  vmulsd xmm1, xmm1, xmm2\n  vucomisd xmm1, xmm0\n  setae al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213507,"user_id":null,"body":"global zero_fuel\n            ; xmm0 <- distance,\n            ; xmm1 <- mpg,\n            ; xmm2 <- fuel left,\n            ; result to eax : 1 for true, 0 for false\nzero_fuel:\n  divsd xmm0, xmm1\n  cmpsd xmm0, xmm2, 2\n  movd eax, xmm0\n  and eax, 0x1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213508,"user_id":null,"body":"global zero_fuel\nzero_fuel:\n  mulsd xmm1,xmm2\n  comisd xmm0,xmm1\n  setbe al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213509,"user_id":173,"body":"section .data\none:\n  dw 1\n\nsection .text\nglobal zero_fuel\n            ; xmm0 <- distance,\n            ; xmm1 <- mpg,\n            ; xmm2 <- fuel left,\n            ; result to eax : 1 for true, 0 for false\n            \nzero_fuel:\n  xor eax, eax\n  mulsd xmm1, xmm2\n  comisd xmm0, xmm1\n  cmovbe eax, [rel one]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213510,"user_id":104,"body":"; 2021 nomennescio\nglobal zero_fuel\n; eax zero_fuel (xmm0 distance, xmm1 mpg, xmm2 fuel_left)\nzero_fuel:\n  mulsd xmm1, xmm2\n  comisd xmm0, xmm1\n  setbe al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213511,"user_id":168,"body":"global zero_fuel\nzero_fuel:\n  vmulsd xmm1, xmm1, xmm2\n  vcomisd xmm0, xmm1\n  setbe al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213512,"user_id":10,"body":"global zero_fuel\nzero_fuel:\n  mulsd xmm1, xmm2\n  comisd xmm1, xmm0\n  jb DEAD\n  mov rax, 1\n  ret\nDEAD:\n  xor rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213513,"user_id":50,"body":"global zero_fuel\nzero_fuel:\n  mulsd xmm1, xmm2\n  comisd xmm1, xmm0\n  jb _retfalse\n  mov rax,1\n  ret\n_retfalse:\n  xor rax,rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58649884a1659ed6cb000072":[{"id":213514,"user_id":null,"body":"section .text\n\nglobal update_light\n\nNewColor:\ndb \"red\",0,0,0,0,0\ndb \"green\",0,0,0\ndb \"yellow\",0\n\n; char *update_light(const char *current)\n; Hint: You can use data section to store string constants. \n;  ^ then you should had made the proto \"const\" and i dont need .data to store consts lol\nupdate_light:\n  movzx eax, byte [rdi]\n  and al, 3\n  lea rax, [NewColor-8+rax*8]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213515,"user_id":null,"body":"section .data\n  green db 'green', 0\n  yellow db 'yellow', 0\n  red db 'red', 0\n\nsection .text\n\nglobal update_light\n; char *update_light(const char *current)\n; Hint: You can use data section to store string constants.\nupdate_light:\n  mov rax, 0\n  mov al, [rdi]\n  cmp al, 0x67\n  je .green\n  cmp al, 0x79\n  je .yellow\n  jmp .red\n\n.green:\n  mov rax, yellow\n  ret\n.yellow:\n  mov rax, red\n  ret\n.red:\n  mov rax, green\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213516,"user_id":null,"body":"section .data\ngreen   db  'green',0\nyellow  db  'yellow',0\nred     db  'red',0\n\nsection .text\n\nglobal update_light\n; char *update_light(const char *current)\n; Hint: You can use data section to store string constants.\nupdate_light:\n  xor rax, rax\n  cmp byte[rdi], 'g'\n  je  .yellow\n  cmp byte[rdi], 'y'\n  je  .red\n  cmp byte[rdi], 'r'\n  je  .green\n\n.yellow:\n  mov rax, yellow\n  jmp .quit\n\n.red:\n  mov rax, red\n  jmp .quit\n\n.green:\n  mov rax, green\n  jmp .quit\n\n.quit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213517,"user_id":null,"body":"section .data\n\n  green: db \"green\",0\n  yellow: db \"yellow\",0\n  red: db \"red\",0\n\nsection .text\n\nglobal update_light\nupdate_light:\n  mov al, byte [rdi]\n  cmp al, 0x67\n  jz retyellow\n  cmp al, 0x79\n  jz retred\n  jmp retgreen\n\nretgreen:\n  mov rax, green\n  ret\n\nretyellow:\n  mov rax, yellow\n  ret\nretred:\n  mov rax, red\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213518,"user_id":null,"body":"section .data\ngreen:  db 'green',0\nyellow: db 'yellow',0\nred:    db 'red',0\n\nsection .text\nglobal update_light\n; char *update_light(const char *current)\n; Hint: You can use data section to store string constants.\nupdate_light:\n  cmp     [rdi], byte 'g'\n  mov     rax,yellow\n  je      .end\n  cmp     [rdi], byte 'y'\n  mov     rax,red\n  je      .end\n  cmp     [rdi], byte 'r'\n  mov     rax, green\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213519,"user_id":null,"body":"section .rodata\ngreen: db 'green', 0;\nyellow: db 'yellow', 0;\nred: db 'red', 0\n\nsection .text\n\nglobal update_light\nextern strcmp\n; char *update_light(const char *current)\n; Hint: You can use data section to store string constants.\nupdate_light:\n  mov rcx, green\n  mov rdx, yellow\n  mov rsi, red\n  cmp byte [rdi], 'g'\n  cmove rax, rdx\n  cmp byte [rdi], 'y'\n  cmove rax, rsi\n  cmp byte [rdi], 'r'\n  cmove rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213520,"user_id":null,"body":"section .data\nstrings:\n  db \"yellow\", 0, 0, 0, 0, 0, \"green\", 0, 0, \"red\"\n\nsection .text\n\nglobal update_light\n\nupdate_light:\n  movzx eax, byte [rdi]\n  lea rax, [eax + strings - 103]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213521,"user_id":null,"body":"section .text\n  global update_light\n\nis_green:\n  mov rax, rsi\n  ret\n\nupdate_light:\n  jmp is_green\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213522,"user_id":null,"body":"section .data\ngreen:    db \"green\", 0\nyellow:   db \"yellow\", 0\nred:      db \"red\", 0\nempty:     db 0\n\nsection .text\nglobal update_light\nupdate_light:\n  mov rdx, rdi\n  lea rsi, [green] ;str2\n  mov rcx, 6 ;len\n  cld\n  repe cmpsb\n  je .yellow\n  lea rdi, [rdx]\n  lea rsi, [yellow]\n  mov rcx, 7\n  repe cmpsb\n  jz .red\n  lea rdi, [rdx]\n  lea rsi, [red]\n  mov rcx, 4\n  repe cmpsb\n  jnz .none\n.green:\n  lea rax, [green]\n  ret\n.red:\n  lea rax, [red]\n  ret\n.yellow:\n  lea rax, [yellow]\n  ret\n.none:\n  lea rax, [empty]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213523,"user_id":null,"body":"section .data\ngreen   db    'green', 0\nyellow  db    'yellow', 0\nred     db    'red', 0\n\nsection .text\n\nglobal update_light\n; char *update_light(const char *current)\n; Hint: You can use data section to store string constants.\nupdate_light:\n  xor rax, rax\n  cmp byte[rdi], 0x67 ;g\n  je  .yellow\n  cmp byte[rdi], 0x79 ;y\n  je  .red\n  cmp byte[rdi], 'r'\n  je  .green\n  \n.yellow:\n  mov rax, yellow\n  ret\n.red:\n  mov rax, red\n  ret\n.green:\n  mov rax, green\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5865cff66b5699883f0001aa":[{"id":213524,"user_id":null,"body":"extern asprintf\n\nsection .text\nglobal to_time\nto_time:\n  mov esi, 60\n  mov eax, edi\n  xor edx, edx\n  sub rsp, 24\n  div esi\n  xor edx, edx\n  lea rdi, [rsp+8]\n  div esi\n  mov esi, .str\n  mov ecx, edx\n  mov edx, eax\n  xor eax, eax\n  call asprintf\n  mov rax, [rsp+8]\n  add rsp, 24\n  ret\n.str: db \"%u hour(s) and %u minute(s)\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213525,"user_id":null,"body":"; The program should return a pointer to a zero-terminated string in rax\n; The string will be freed\nsection .text\nglobal to_time\nextern malloc\nextern sprintf\nto_time:\n  push rdi\n  mov edi, 256\n  call malloc\n  pop rsi\n  test rax, rax\n  jz .fail\n  \n  push rax\n  mov rdi, rax\n  mov eax, esi\n  mov ecx, 60\n  xor edx, edx\n  div ecx\n  xor edx, edx\n  div ecx\n  mov ecx, edx\n  mov edx, eax\n  xor eax, eax\n  lea rsi, [format]\n  call sprintf\n  pop rax\n  \n.fail:\n  ret\n\n\nsection .rodata\nformat: db \"%d hour(s) and %d minute(s)\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213526,"user_id":null,"body":"; The program should return a pointer to a zero-terminated string in rax\n; The string will be freed\nsection .data\nformat: db \"%d hour(s) and %d minute(s)\",0\nsection .text\nglobal to_time\nextern malloc\nextern sprintf\nto_time:\n            push rbp\n            mov rbp,rsp\n            sub rsp,0x10 ;prepare before calling\n            mov r13,rdi;save seconds\n            mov rdi,500\n            call malloc\n            push rax ; save return pointer to stack\n            mov rax,r13\n            mov rbx,3600\n            xor rdx,rdx\n            div rbx\n            mov rbx,rax;save hour\n            mov rax,rdx;\n            xor rdx,rdx;\n            mov rcx,60\n            div rcx;\n            mov rcx,rax;save minute;arg[3]=minute\n            mov rdi,qword[rsp];arg[0]=char * (from heap)\n            mov rsi,format;arg[1]=format\n            mov rdx,rbx;arg[2]=hour\n            xor rax,rax;avoid bug\n            call sprintf\n            mov rax,qword[rsp]\n            leave\n            ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213527,"user_id":null,"body":"; The program should return a pointer to a zero-terminated string in rax\n; The string will be freed\nsection .data\nfmt: db '%d hour(s) and %d minute(s)',0\n\nsection .text\nglobal to_time\nextern malloc, sprintf\nto_time:\n  push  rdi\n    .hours:\n  xor   rdx, rdx\n  mov   rbx, 3600\n  mov   rax, rdi\n  div   rbx\n  push  rax\n    .minutes:\n  xor   rdx, rdx\n  mov   rbx, 60\n  mov   rax, rdi\n  div   rbx\n  xor   rdx, rdx\n  mov   rbx, 60\n  div   rbx\n  push  rdx\n    .format:\n  mov   rdi, 4096\n  call  malloc\n  mov   rdi, rax\n  mov   rsi, fmt\n  pop   rcx     ; 2nd %d poping push rdx l22\n  pop   rdx     ; 1st %d poping push rax l16\n  push  rax\n  mov   rax, 0  ;rax = count of non int vaargs\n  call  sprintf\n    .end:\n  pop   rax\n  pop   rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213528,"user_id":null,"body":"section .text\nextern asprintf\nglobal to_time\nto_time:\n  mov  rax,rdi\n  mov  r8,3600\n  cqo\n  div  r8\n  mov  r8d,2290649225\n  mulx ecx,r8d,r8d\n  shr  rcx,5\n  mov  rdi,outstr\n  mov  rsi,format\n  mov  rdx,rax\n  xor  rax,rax\n  call asprintf\n  mov  rax,[outstr]\nret\nsection .data\nformat db '%i hour(s) and %i minute(s)',0\noutstr dq 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213529,"user_id":168,"body":"section .text\nglobal to_time\nextern asprintf\n\nformat: db \"%d hour(s) and %d minute(s)\", 0\n\nto_time:\n  xor edx, edx\n  mov eax, edi\n  mov edi, 3600\n  div edi\n  mov ecx, eax\n  mov eax, edx\n  xor edx, edx\n  mov edi, 60\n  div edi\n  push rax\n  mov rdi, rsp\n  mov rsi, format\n  mov edx, ecx\n  mov ecx, eax\n  call asprintf\n  pop rax\n  ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213530,"user_id":527,"body":"extern malloc, sprintf\nsection .text\nglobal to_time\nto_time:\n                push    rbx\n                inc     edi\n                imul    rdi, 1145324612\n                shr     rdi, 36\n                mov     eax, 2290649225\n                imul    rax, rdi\n                shr     rax, 37\n                push    rax\n                imul    eax, 60\n                sub     edi, eax\n                push    rdi\n                mov     rdi, buf_size\n                call    malloc\n                pop     rcx\n                pop     rdx\n                mov     rdi, rax\n                mov     rsi, fmt\n                mov     rbx, rax\n                call    sprintf\n                mov     rax, rbx\n                pop     rbx\n                ret\n\nsection .rodata\nfmt             db '%u hour(s) and %u minute(s)', 0\nfmt_size equ $ - fmt\nbuf_size equ fmt_size - 4 + 10\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213531,"user_id":null,"body":"; The program should return a pointer to a zero-terminated string in rax\n; The string will be freed\nsection .data\nstring_ptr  dq  0\n\nsection .text\ntime_string db \"%i hour(s) and %i minute(s)\", 0\n@3600 dd 3600\n@60   dd 60  \nextern asprintf\nstatic global to_time\n\nto_time:    sub  rsp, 8\n            mov  eax, edi\n            xor  rdx, rdx\n            div  dword [@3600]\n            mov  [rsp],rax\n            mul  dword [@3600]\n            sub  edi,eax\n            mov  eax,edi\n            xor  rdx,rdx\n            div  dword [@60]\n            mov  ecx,eax\n            mov  rdx,[rsp]\n            lea  rsi,[time_string]\n            lea  rdi,[string_ptr]\n            call asprintf\n            mov  rax,[string_ptr]\n            add  rsp,8\n            ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"586dd26a69b6fd46dd0000c0":[{"id":213532,"user_id":null,"body":"section .text\nglobal interpret\n; void interpret(const char *code, char *output)\n; Write the output string to `output`. Don't forget to add a null byte at the end.\ninterpret:\n  ; Exchange them for later use with lods and stos\n  xchg rsi, rdi\n  \n  ; <AL> handles the operator\n  ; <DL> handles the memory cell\n  xor al, al\n  xor dl, dl\n  \ninterpret_loop:\n  lodsb\n  test al, al\n  jz interpret_loop_done\n  \noperator_plus:\n  cmp al, 0x2b\n  jnz operator_dot\n  inc dl\n  jmp interpret_loop\n  \noperator_dot:\n  cmp al, 0x2e\n  jnz interpret_loop\n  xchg al, dl\n  stosb\n  xchg al, dl\n  jmp interpret_loop\n  \ninterpret_loop_done:\n  ; String terminator.\n  stosb\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213533,"user_id":null,"body":"section .text\nglobal interpret\n; void interpret(const char *code, char *output)\n; Write the output string to `output`. Don't forget to add a null byte at the end.\ninterpret:\n  ; input char:  dl\n  ; memory cell: r8b\n  ; random tmp: al\n  xor r8b, r8b\n.loop:\n  ; read from the code\n  mov dl, byte [rdi]\n  test dl, dl\n  jz .end\n  cmp dl, '+'\n  je .increment\n  cmp dl, '.'\n  je .output\n.continue:\n  add rdi, 1\n  jmp .loop\n\n.increment:\n  add r8b, 1\n  jmp .continue\n\n.output:\n  mov byte [rsi], r8b\n  add rsi, 1\n  jmp .continue\n\n.end:\n  mov byte [rsi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213534,"user_id":null,"body":"section .text\nglobal interpret\ninterpret:\n  xor rax,rax\n  xor rdx,rdx\n  xor rcx,rcx\n  .b:cmp  byte[rdi+rcx],'+'\n     sete dl\n     add  al,dl\n     cmp  byte[rdi+rcx],'.'\n     sete dl\n     mov  [rsi],al\n     add  rsi,rdx\n     inc  rcx\n     cmp  byte[rdi+rcx],0\n  jne .b   \n  mov  [rsi],ah   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213535,"user_id":1027,"body":"section .code\nglobal interpret\ninterpret:\n  mov r8,rsi\n  xor rax,rax\n.loop:\n  cmp byte[rdi],'+'\n  jnz .ni\n  inc al\n.ni:\n  cmp byte[rdi],'.'\n  jnz .np\n  mov byte[rsi],al\n  inc rsi\n.np:\n  inc rdi\n  cmp byte[rdi],0\n  jnz .loop\n  mov byte[rsi],0\n  mov rax,r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213536,"user_id":null,"body":"section .text\nglobal interpret\ninterpret:\n  xor cl, cl\n.loop:\n  mov al, [rdi]\n  inc rdi\n  test al, al\n  jz .exit\n  cmp al, '+'\n  je .inc\n  cmp al, '.'\n  je .write\n  jmp .loop\n.inc:\n  inc cl\n  jmp .loop\n.write:\n  mov byte [rsi], cl\n  inc rsi\n  jmp .loop\n.exit:\n  mov byte [rsi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213537,"user_id":null,"body":"section .text\nglobal interpret\ninterpret:\n  xor eax, eax\n.loop:\n  mov dl, byte [rdi]\n  cmp dl, 43\n  jne .notplus\n  inc eax\n  jmp .notdot\n.notplus:\n  cmp dl, 46\n  jne .notdot\n  mov [rsi], al\n  inc rsi\n.notdot:\n  inc rdi\n  cmp byte [rdi-1], 0\n  jne .loop\n  mov byte [rsi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213538,"user_id":null,"body":"section .text\nglobal interpret\n\ninterpret:\n  xor rax, rax\n  xor rcx, rcx\n.loop:\n  mov bl, [rdi]\n  cmp bl, 0\n  je .end\n  cmp bl, 43\n  je .do_incr\n  cmp bl, 46\n  je .do_output\n  jmp .recurse\n.do_incr:\n  inc rcx\n  jmp .recurse\n.do_output:\n  mov [rsi], cl\n  inc rsi\n.recurse:\n  inc rdi\n  jmp .loop\n.end:\n  mov [rsi], BYTE 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213539,"user_id":null,"body":"section .text\nglobal interpret\n; void interpret(const char *code, char *output)\n; Write the output string to `output`. Don't forget to add a null byte at the end.\ninterpret:\n  xor ecx, ecx\n  \n.loop:\n  mov al, [rdi]\n  inc rdi\n  test al, al\n  jz .done\n  cmp al, '+'\n  je .plus\n  cmp al, '.'\n  jne .loop\n  \n  mov [rsi], cl\n  inc rsi\n  jmp .loop\n.plus:\n  inc cl\n  jmp .loop\n.done:\n  mov byte [rsi], 0\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213540,"user_id":881,"body":"section .text\nglobal interpret\n; void interpret(const char *code, char *output)\n; Write the output string to `output`. Don't forget to add a null byte at the end.\ninterpret:\n    xor rax, rax\n    xor rdx, rdx\n    dec rdx\n.for_each_char:\n    inc rdx\n    mov cl, [rdi + rdx]\n    cmp cl, 0\n    je .done\n    cmp cl, '+'\n    jne .test_dot\n    inc al\n    jmp .for_each_char\n.test_dot:\n    cmp cl, '.'\n    jne .for_each_char\n    mov byte[rsi], al\n    inc rsi\n    jmp .for_each_char\n.done:\n    mov byte[rsi], 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213541,"user_id":null,"body":"section .text\nglobal interpret\n; void interpret(const char *code, char *output)\n; Write the output string to `output`. Don't forget to add a null byte at the end.\ninterpret:\n  xor al, al\n\n.loop:\n  mov dl, [rdi]\n  test dl, dl\n  jz .ret\n \n  cmp dl, '+'\n  je .increment\n \n  cmp dl, '.'\n  je .write\n\n  jmp .continue\n \n.increment:\n  inc al\n  jmp .continue\n\n.write:\n  mov [rsi], al\n  inc rsi\n\n.continue:\n  inc rdi\n  jmp .loop\n \n.ret:\n  mov BYTE [rsi], 0\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"586f6741c66d18c22800010a":[{"id":213542,"user_id":null,"body":"global sequence_sum\n\nsection .text\n\n; <--- unsigned sequence_sum(unsigned start, unsigned end, unsigned step) --->\nsequence_sum:\n    ; we can do better: we can do O(1).\n    ;\n    ; Some reducing later...\n    ;\n    ; Finally:\n    ; (b + (floor((e-b)\/s)*s + b) \/ 2   * (floor((e-b)\/s) + 1)\n    \n    ; b     - edi\n    ; e     - esi\n    ; s     - ebx\n    ; e-b\/s - ecx\n    \n    xor   eax, eax\n    cmp   edi, esi\n    jg    .end        ; Check if start > begin\n    \n    mov   ebx, edx\n    \n    xor   edx, edx   ; For division and multiplication. Clear upper contents.\n    \n    mov   eax, esi\n    sub   eax, edi\n    div   ebx         ; (e - b) \/ s\n    \n    mov   ecx, eax\n    \n;     mov   eax, esi    Redundant. Also, WHY THE HELL DOES IT RETURN WRONG RESULTS IF UNCOMMENTED!? WTF?!\n;     sub   eax, edi \n;     div   ebx\n    mul   ebx\n    add   eax, edi    ; floor((e - b) \/ s) * s + b\n    \n    add   eax, edi    ; (b + (floor((e-b)\/s)*s + b)\n    \n    inc   ecx\n    mul   ecx         ; (b + (floor((e-b)\/s)*s + b)   * (floor((e-b)\/s) + 1)\n    \n    shr   eax, 1      ; (b + (floor((e-b)\/s)*s + b) \/ 2   * (floor((e-b)\/s) + 1)\n    \n.end:    \n    ret\n; ---------> endof sequence_sum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213543,"user_id":null,"body":"global sequence_sum\n\nsection .text\nsequence_sum:\n    xor rax,rax\n    jmp .s\n    .b:add rax,rdi\n       add rdi,rdx\n    .s:cmp rdi,rsi\n    jna .b   \n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213544,"user_id":null,"body":"global sequence_sum\n\nsection .text\n\n; <--- eax sequence_sum(edi start, esi end, edx step) --->\nsequence_sum:\n  xor eax, eax\n\nagain:\n  cmp edi, esi\n  jg end\n    \n  add eax, edi\n  add edi, edx\n    \n  jmp again\n    \nend:\n    \n  ret\n; ---------> endof sequence_sum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213545,"user_id":null,"body":"global sequence_sum\nsection .text\n\nsequence_sum:\n\txor eax, eax\n\tloop:\n\tcmp edi, esi\n\tjg end\n\tadd eax, edi\n\tadd edi, edx\n\tjmp loop\n\tend:\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213546,"user_id":null,"body":"global sequence_sum\n\nsection .text\n\n; <--- unsigned sequence_sum(unsigned start, unsigned end, unsigned step) --->\nsequence_sum:\n    xor eax, eax        ; EAX <- the result\n    cmp edi, esi\n    jg return\n    push rdi\n    add edi, edx\n    call sequence_sum\n    pop rdi\n    add eax, edi\nreturn:\n    ret\n; ---------> endof sequence_sum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213547,"user_id":null,"body":"global sequence_sum\nsection .text\nsequence_sum:\n  mov rax,0\n  sub rdi,rdx\n  loop1:\n  add rdi,rdx\n  \n  cmp rdi,rsi\n  jg end\n  \n  add rax,rdi\n  jmp loop1\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213548,"user_id":null,"body":"global sequence_sum\n\nsection .text\n\n; <--- unsigned sequence_sum(unsigned start, unsigned end, unsigned step) --->\nsequence_sum:\n  xor eax, eax\n  sub esi, edi\n  jb .done\n  mov ecx, edx\n  mov eax, esi\n  xor edx, edx\n  div ecx\n  lea edx, [rax + 1]\n  imul eax, ecx\n  lea eax, [rax + 2*rdi]\n  imul eax, edx\n  shr eax, 1\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213549,"user_id":null,"body":"global sequence_sum\n\nsection .text\n\n; <--- unsigned sequence_sum(unsigned start, unsigned end, unsigned step) --->\nsequence_sum:\n  xor eax, eax\n  \n.loop:\n  cmp edi, esi\n  ja .end\n  add eax, edi\n  add edi, edx\n  jmp .loop\n  \n.end:\n  ret\n; ---------> endof sequence_sum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213550,"user_id":1400,"body":"global sequence_sum\n\nsection .text\n\n; <--- unsigned sequence_sum(unsigned start, unsigned end, unsigned step) --->\n;edi start\n;esi end\n;edx step\nsequence_sum:\n    xor eax, eax        ; EAX <- the result\n    mov ecx, edi ;index\nmyloop:\n    cmp ecx, esi ;index > end?\n    jg end\n    \n    add eax, ecx\n\n    add ecx, edx ;index+=step\n    jmp myloop\nend:\n    ret\n; ---------> endof sequence_sum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213551,"user_id":null,"body":"global sequence_sum\n\nsection .text\n\n; <--- unsigned sequence_sum(unsigned start, unsigned end, unsigned step) --->\nsequence_sum:\n    xor eax, eax        ; EAX <- the result\nloop:\n    cmp edi, esi\n    jg return\n    add eax, edi\n    add edi, edx\n    jmp loop\nreturn:\n    ret\n; ---------> endof sequence_sum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58712dfa5c538b6fc7000569":[{"id":213552,"user_id":568,"body":"SECTION .text\nglobal count_red_beads\n\n; Counts the number of red beads, given a number of blue beads.\n; arg0         = (int32_t) Number of blue beads\n; return value = (int32_t) Number of red beads\ncount_red_beads:\n  lea rax, [(rdi - 1) * 2]\n  xor edx, edx\n  cmp edi, 0\n  cmovle rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213553,"user_id":527,"body":"section .text\nglobal count_red_beads\ncount_red_beads:\n                dec     edi\n                js      .zero\n                lea     eax, [edi * 2]\n                ret\n.zero:          xor     eax, eax\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213554,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\n\n; Counts the number of red beads, given a number of blue beads.\n; arg0         = (uint32_t) Number of blue beads\n; return value = (uint32_t) Number of red beads\ncount_red_beads:\n  test edi,edi\n  jle .zero\n  lea eax,[edi*2-2]\n  ret\n.zero:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213555,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\n\n; Counts the number of red beads, given a number of blue beads.\n; arg0         = (uint32_t) Number of blue beads\n; return value = (uint32_t) Number of red beads\ncount_red_beads:\n  xor eax, eax\n  cmp edi, 0\n  jne count\n  ret\n\ncount:\n  mov eax, edi\n  shl eax, 1\n  sub eax, 2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213556,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\n\ncount_red_beads:\n  cmp edi, 2\n  jg sum\n  mov eax, 0\n  jmp exit\nsum:\n  mov eax, edi\n  sub eax, 1\n  shl eax, 1\nexit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213557,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\n\n; Counts the number of red beads, given a number of blue beads.\n; arg0         = (uint32_t) Number of blue beads\n; return value = (uint32_t) Number of red beads\ncount_red_beads:\n  xor eax, eax\n  cmp edi, 2\n  jb .end\n  dec edi\n  mov eax, edi\n  mov ecx, 2\n  mul ecx\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213558,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\ncount_red_beads:\n  dec rdi\n  adc rdi,0\n  js end\n  imul rax,rdi,2\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213559,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\n\n; Counts the number of red beads, given a number of blue beads.\n; arg0         = (uint32_t) Number of blue beads\n; return value = (uint32_t) Number of red beads\ncount_red_beads:\n  test edi, edi\n  lea eax, [rdi + rdi - 2]\n  cmove eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213560,"user_id":46,"body":"section .text\nglobal count_red_beads\ncount_red_beads:\n  cmp rdi, 2\n  js _ret_0\n    mov rax, rdi\n    add rax, rdi\n    sub rax, 2\n    ret\n  _ret_0:\n    mov rax, 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213561,"user_id":null,"body":"SECTION .text\nglobal count_red_beads\n\n; Counts the number of red beads, given a number of blue beads.\n; arg0         = (uint32_t) Number of blue beads\n; return value = (uint32_t) Number of red beads\ncount_red_beads:\n  lea eax, [rdi*2-2]\n  xor ecx, ecx\n  cmp eax, ecx\n  cmovl eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"588417e576933b0ec9000045":[{"id":213562,"user_id":null,"body":"global seats_in_theater\n\nsection .text\nseats_in_theater:\n    sub  rdi,rdx\n    sub  rsi,rcx\n    imul rdi,rsi\n    lea  rax,[rdi+rsi]\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213563,"user_id":null,"body":"global seats_in_theater\n\nsection .text\n\nseats_in_theater:\n  mov rax, rdi\n  add rax, 1\n  sub rax, rdx\n  sub rsi, rcx\n  mul rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213564,"user_id":null,"body":"global seats_in_theater\n\nsection .text\n;edi\n;esi\n;edx\n;ecx\n; <--- size_t seats_in_theater(size_t ncols, size_t nrows, size_t col, size_t row) --->\nseats_in_theater:\n    xor rax, rax    ; RAX <- the result\n    sub edi, edx\n    inc edi\n    sub esi, ecx\n    mov eax, edi\n   imul eax, esi\n    ret\n; ---------> endof seats_in_theater <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213565,"user_id":null,"body":"global seats_in_theater\n\nsection .text\n\n; <--- size_t seats_in_theater(size_t ncols, size_t nrows, size_t col, size_t row) --->\nseats_in_theater:\n  sub rdi, rdx\n  lea rax, [rdi + 1]\n  sub rsi, rcx\n  imul rax, rsi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213566,"user_id":null,"body":"global seats_in_theater\n\nsection .text\n\n; <--- size_t seats_in_theater(size_t ncols, size_t nrows, size_t col, size_t row) --->\nseats_in_theater:\n    lea rax, [rdi+1]\n    sub rax, rdx\n    sub rsi, rcx\n    imul rax, rsi\n    ret\n; ---------> endof seats_in_theater <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213567,"user_id":50,"body":"global seats_in_theater\n\nsection .text\n\n; <--- size_t seats_in_theater(size_t ncols, size_t nrows, size_t col, size_t row) --->\nseats_in_theater:\n    mov rax,rdi\n    inc rax\n    sub rax,rdx\n    mov rbx,rsi\n    sub rbx,rcx\n    imul rbx\n    ret\n; ---------> endof seats_in_theater <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213568,"user_id":null,"body":"global seats_in_theater\n\nsection .text\n\nseats_in_theater:\n    inc rdi\n    sub rdi, rdx\n    sub rsi, rcx\n    mov rax, rdi\n    xor rdx, rdx\n    imul rsi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213569,"user_id":76,"body":"global seats_in_theater\n\nsection .text\n\n; <--- size_t seats_in_theater(size_t ncols, size_t nrows, size_t col, size_t row) --->\nseats_in_theater:\n    lea rax, [rdi + 1]\n    sub rax, rdx        ; rax = ncols - col + 1\n    mov rbx, rsi\n    sub rbx, rcx        ; rbx = nrows - row\n    mul rbx             ; rax = rax * rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213570,"user_id":null,"body":"global seats_in_theater\n\nsection .text\n\n; <--- size_t seats_in_theater(size_t ncols, size_t nrows, size_t col, size_t row) --->\nseats_in_theater:\n    mov rax, rdi\n    inc rax\n    sub rax, rdx\n    sub rsi, rcx\n    mul rsi\n    ret\n; ---------> endof seats_in_theater <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213571,"user_id":1027,"body":"global seats_in_theater\nsection .code\nseats_in_theater:\n  sub rdi,rdx\n  inc rdi\n  sub rsi,rcx\n  mov rax,rdi\n  cqo\n  mul rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5886e082a836a691340000c3":[{"id":213572,"user_id":527,"body":"global rectangle_rotation\nsection .text\nrectangle_rotation:\n                mov     eax, 3037000500\n                mul     edi\n                mov     ecx, edx\n                mov     eax, 3037000500\n                mul     esi\n                lea     edi, [rcx + rdx]\n                imul    ecx, edx\n                or      edi, 1\n                lea     eax, [rcx * 2 + rdi]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213573,"user_id":527,"body":"global rectangle_rotation\nsection .text\nrectangle_rotation:\n                mov     edi, edi\n                imul    rdi, 1518500250\n                shr     rdi, 31\n                mov     esi, esi\n                imul    rsi, 1518500250\n                shr     rsi, 31\n                lea     eax, [rdi + rsi]\n                imul    edi, esi\n                or      eax, 1\n                lea     eax, [rax + rdi * 2]\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213574,"user_id":168,"body":"global rectangle_rotation\n\nsection .data\ninv_sqrt2 dq 0x3FE6A09E667F3BCC\n\nsection .text\n\nrectangle_rotation:\n  cvtsi2sd xmm0, edi  \n  cvtsi2sd xmm1, esi\n  movsd xmm2, qword [inv_sqrt2]\n  mulsd xmm0, xmm2\n  mulsd xmm1, xmm2\n  cvttsd2si eax, xmm0\n  cvttsd2si edx, xmm1\n  mov ecx, eax\n  xor ecx, edx\n  and ecx, 1\n  lea rsi, [rax + rdx + 1]\n  imul rax, rdx\n  lea rax, [2 * rax + rsi]\n  sub rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213575,"user_id":645,"body":"global rectangle_rotation\nrectangle_rotation:\n  pxor xmm0, xmm0\n  movsd xmm1, qword [rel .LC0]\n  cvtsi2sd xmm0, edi\n  divsd xmm0, xmm1\n  cvttsd2si edx, xmm0\n  pxor xmm0, xmm0\n  cvtsi2sd xmm0, esi\n  lea eax, [rdx + 1H]\n  divsd xmm0, xmm1\n  cvttsd2si ecx, xmm0\n  lea esi, [rcx + 1H]\n  imul eax, esi\n  mov esi, edx\n  imul esi, ecx\n  add eax, esi\n  mov esi, edx\n  shr esi, 31\n  add edx, esi\n  and edx, 01H\n  sub edx, esi\n  mov esi, ecx\n  shr esi, 31\n  add ecx, esi\n  and ecx, 01H\n  sub ecx, esi\n  xor edx, ecx\n  sub eax, edx\n  cdqe\n  ret\n\nsection .rodata.cst8\n.LC0:\n  dq 3FF6A09E667F3BCDH","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213576,"user_id":null,"body":"global rectangle_rotation\nrectangle_rotation:\n  cvtsi2sd xmm0, edi\n  cvtsi2sd xmm1, esi\n  movsd xmm2, [.r2]\n  mulsd xmm0, xmm2\n  mulsd xmm1, xmm2\n  movsd xmm2, [.neghalf]\n  cvttsd2si rax, xmm0\n  cvttsd2si rcx, xmm1\n  addsd xmm0, xmm2\n  addsd xmm1, xmm2\n  cvttsd2si rdx, xmm0\n  cvttsd2si rsi, xmm1\n  add rax, rax\n  add rax, 1\n  add rcx, rcx\n  add rcx, 1\n  imul rcx, rax\n  add rdx, rdx\n  add rdx, 2\n  lea rax, [rsi + rsi + 2]\n  imul rax, rdx\n  add rax, rcx\n  ret\n  \nsection .data\n.r2: dq 0x3fd6a09e667f3bcc\n.neghalf: dq 0xbfe0000000000000\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213577,"user_id":50,"body":"global rectangle_rotation\n\nrectangle_rotation:\n  xor rax,rax\n  xor r8,r8 ; c\n  xor r9,r9 ; d\n  mov eax,edi ; a\n  imul eax,eax ; a**2\n  shr eax,1 ; a**2\/\/2\n  mov ebx,eax ; save a\n  xor eax,eax ; x=0\n_loop1:\n  cmp eax,ebx ; if x >= a\n  jge _ouf\n  inc r8d\n  mov eax,r8d\n  imul eax\n  jmp _loop1\n_ouf:\n  dec r8d ; c-=1\n  mov eax,esi ; b\n  imul eax,eax ; b**2\n  shr eax,1 ; b**2\/\/2\n  mov ebx,eax ; save ebx = b\n  xor eax,eax ; y = 0\n_loop2:\n  cmp eax,ebx ; if y >= b\n  jge _exit\n  inc r9d ; d +=1\n  mov eax,r9d\n  imul eax ; y = d*d\n  jmp _loop2\n_exit:\n  dec r9d ; d-=1\n  mov eax,r8d ; o=c\n  imul r9d ; o=c**2\n  shl eax,1\n  add eax,r8d\n  add eax,r9d\n  inc eax\n  mov ebx,eax\n  test ebx,1\n  jz _even\n  ret\n_even:\n  dec eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213578,"user_id":null,"body":"global rectangle_rotation\nrectangle_rotation:\n  mov rcx, rdi  ; rcx = h\n  mov rdx, rsi  ; rdx = w\n  call mulrt12\n  inc rax\n  mov rcx, rax  ; rcx = h*rt(1\/2) + 1\n  mov rdi, rdx\n  call mulrt12\n  mov rdx,rax   ; rdx = w*rt(1\/2)\n  \n  mov r8, rax\n  add r8, rcx   ; r8 = hrt + wrt\n  mov r9, rcx\n  sub r9, rdx\n  dec r9        ; r9 - hrt - wrt - 1\n  \n  mov rdi, r8 \n  call gut\n  mov r10, rax\n  mov rdi, r9\n  call gut\n  mov r11, rax\n  mov rax, r10\n  sub rax, r11\n  shl rax, 1\n  sub rax, r8\n  add rax, r9\n  ret\n  \ngut:\n  xor rdx, rdx\n  inc rdi\n  mov rax, rdi\n  mul rdi\n  shr rax, 2\n  ret\n  \nmulrt12:\n  push rdi\n  fld1\n  fld1\n  fadd\n  fld1\n  fdivr\n  fsqrt\n  fild qword [rsp]\n  fmulp\n  fisttp qword [rsp]\n  pop rax\n  ret\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58880c6e79a0a3e459000004":[{"id":213579,"user_id":null,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n    xor eax, eax\n  loop:\n    cmp [rdi], dword 0\n    je return\n    \n    add eax, [rdi]\n    add rdi, qword 4\n    \n    jmp loop\n  return:\n    ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213580,"user_id":null,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n    mov rdx, rdi\n    xor eax, eax\n    mov rcx, rsi\n    repne scasd\n.loop:\n    cmp rdi, rdx\n    je .end\n    sub rdi, 4\n    add eax, dword [rdi]\n    jmp .loop\n.end:\n    ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213581,"user_id":null,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n  xor eax, eax\n.loop:\n  mov ecx, [rdi]\n  test ecx, ecx\n  je .done\n  add rdi, 4\n  add eax, ecx\n  jmp .loop\n.done:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213582,"user_id":null,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n  xor eax, eax\n.loop:\n  mov edx, [rdi]\n  add rdi, 4\n  add eax, edx\n  test edx, edx\n  jnz .loop\n  \n  ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213583,"user_id":null,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n  xor eax, eax\n  xor ecx, ecx\n  .loop:\n  mov edx, [rdi+rcx*4]\n  test edx, edx\n  jz .done\n  add eax, edx\n  inc rcx\n  jmp .loop\n  .done:\n  ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213584,"user_id":1088,"body":"\n[section .text]\nglobal house_numbers_sum\n\n; unsigned house_numbers_sum(const unsigned *houses, size_t len);\nhouse_numbers_sum:\n\txor\teax, eax\n\ttest\trsi, rsi\n\tjz\t.l_out\n\txor\tedx, edx\n.l_loop:\n\tmov\tecx, dword [rdi + rdx * 4]\n\ttest\tecx, ecx\n\tjz\t.l_out\n\tadd\teax, ecx\n\tadd\trdx, 1\n\tcmp\trdx, rsi\n\tjb\t.l_loop\n.l_out:\n\tret\t\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213585,"user_id":50,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n    xor eax, eax        ; EAX <- the result\n    xor r8,r8\n_loop:\n  cmp r8,rsi\n  je _exit\n  mov ebx,[rdi+4*r8]\n  cmp ebx,0\n  je _exit\n  add eax,ebx\n  inc r8\n  jmp _loop\n_exit:\n    ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213586,"user_id":null,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n    xor eax, eax        ; EAX <- the result\n    \nloop:\n    mov ecx, [rdi]\n    test ecx, ecx\n    jz done\n    add eax, ecx\n    add rdi, 4\n    jmp loop\n\ndone:\n    ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213587,"user_id":76,"body":"global house_numbers_sum\n\n; <-- EAX house_numbers_sum(ro [dword RDI] houses, RSI len) -->\nhouse_numbers_sum:\n    xor rax, rax \n    mov rcx, rsi\n.add:\n    mov ebx, [rdi]\n    test ebx, ebx\n    jz .exit\n    add rax, [rdi]\n    add rdi, 4\n    loop .add\n.exit:\n    ret\n; -----> endof house_numbers_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213588,"user_id":null,"body":"global house_numbers_sum\nhouse_numbers_sum:\n  xor eax,eax\n  mov rcx,rsi\n  .b:add eax,[rdi]\n     add rdi,4\n     cmp dword[rdi-4],0\n  loopne .b   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5893e0c41a88085c330000a0":[{"id":213589,"user_id":168,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n  lea eax, [rdi - 1]\n  mul edi\n  shl eax, 1\n  inc eax\n  ret\n; ---------> endof shape_area <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213590,"user_id":null,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n  lea eax, [rdi + rdi - 2]\n  imul eax, edi\n  or eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213591,"user_id":null,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n  lea eax, [rdi-1]\n  mul edi\n  lea eax, [rax*2+1]\n  ret\n; ---------> endof shape_area <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213592,"user_id":50,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n    mov eax,edi\n    imul edi\n    sub eax,edi\n    shl eax,1\n    inc eax\n    ret\n; ---------> endof shape_area <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213593,"user_id":null,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n    lea eax, [2*edi-2]\n    mul edi\n    inc eax\n    ret\n; ---------> endof shape_area <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213594,"user_id":null,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n    mov eax, edi\n    dec eax\n    mul  edi\n    sal eax, 1\n    inc eax\n    ret\n; ---------> endof shape_area <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213595,"user_id":77,"body":"global shape_area\n\nsection .text\n\nshape_area:\n    lea rax, [rdi-1]\n    mul rdi\n    lea rax, [2*rax+1]\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213596,"user_id":null,"body":"global shape_area\n\nshape_area:\n    xor rax, rax \n    xor rcx, rcx\n    mov rax, rdi\n    dec rdi\n    mul rdi\n    add rax, rax\n    inc rax\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213597,"user_id":null,"body":"global shape_area\nshape_area:\n  lea  rax,[rdi-1]\n  mul  rax\n  imul rdi,rdi\n  add  rax,rdi\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213598,"user_id":null,"body":"global shape_area\n\nsection .text\n\n; <--- unsigned shape_area(unsigned n) --->\nshape_area:\n    xor eax, eax    ; EAX <- the result\n    mov ecx, edi\n    imul ecx, 2\n    dec edi\n    imul edi, ecx\n    mov eax, edi\n    inc eax\n    ret\n; ---------> endof shape_area <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58941fec8afa3618c9000184":[{"id":213599,"user_id":527,"body":"section .text\nglobal growingPlant\n; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\ngrowingPlant:\n                lea     eax, [rdx - 1]\n                sub     eax, esi\n                sub     edi, esi\n                cdq\n                idiv    edi\n                cdq\n                andn    eax, edx, eax\n                inc     eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213600,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n  mov eax, 1\n  cmp edi, edx\n  jge .done\n  cvtsi2ss xmm0, esi\n  cvtsi2ss xmm1, edx\n  sub esi, edi\n  cvtsi2ss xmm2, esi\n  subss xmm0, xmm1\n  divss xmm0, xmm2\n  roundss xmm0, xmm0, 10\n  cvttss2si eax, xmm0\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213601,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n  mov eax, edx\n  xor edx, edx\n  sub eax, esi\n  sub edi, esi\n  div edi\n  cmp eax, 0\n  jg .checkRemainder\n  mov eax, 1\n  jmp .return\n.checkRemainder:\n  test edx, edx\n  jz .return\n  inc eax\n.return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213602,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n\n  xor eax, eax\n  sub edx, edi\n  jle .bailout\n  \n  sub edi, esi\n  lea eax, [rdx+rdi-1]\n  xor edx, edx\n  div edi\n\n.bailout:\n  inc eax\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213603,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:\n  xor rax, rax\n  xor rcx, rcx\n \n.loop:\n  inc rax\n  add rcx, rdi\n  cmp rcx, rdx\n  jae .return\n \n  sub rcx, rsi\n  jmp .loop\n \n.return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213604,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n  xor rax, rax\n  xor rcx, rcx\n \n.loop:\n  inc rax\n  add rcx, rdi\n  cmp rcx, rdx\n  jae .return\n \n  sub rcx, rsi\n  jmp .loop\n \n.return:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213605,"user_id":50,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n  mov rax,1 ;\n_loop:\n  cmp rdx,rdi\n  jle _exit\n  inc rax\n  add rdx, rsi\n  sub rdx,rdi\n  jmp _loop\n_exit:\n  ret ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213606,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n  xor rax, rax\n  xor rcx, rcx\n  inc rax\n  add rcx, rdi\n  sub rdi, rsi\n  \nwhile:\n  cmp rcx, rdx\n  jae end\n  add rcx, rdi\n  inc rax\n  jmp while\n\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213607,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n  sub rdi, rsi ; rdi = upSpeed - downSpeed\n  neg rsi\n  lea rax, [rdx+rsi] ; load desiredHeight - downSpeed into rax\n  test rax, rax\n  jns cont\n  mov rax, 1\n  ret\ncont:\n  xor rdx, rdx\n  div rdi\n  neg rdx ; set CF if remainder > 0\n  adc rax, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213608,"user_id":null,"body":"section .text\nglobal growingPlant\ngrowingPlant:   ; int growingPlant(int upSpeed, int downSpeed, int desiredHeight)\n                ; rdi = upSpeed\n                ; rsi = downSpeed\n                ; rdx = desiredHeight\n  xor rax, rax ; time\n  xor rcx, rcx ; heigth\n@mainloop:\n  inc rax\n  add rcx, rdi\n  cmp rcx, rdx\n  jge @end\n  sub rcx, rsi\n  jmp @mainloop\n@end:  \n  ret           ; return 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5899dc03bc95b1bf1b0000ad":[{"id":213609,"user_id":null,"body":"SECTION .text\nglobal invert\n\n; void invert(int *, size_t);\n; rdi - array\n; rsi - size\ninvert:\n  mov ecx, 0\n  .loop:\n    mov eax, dword [rdi+rcx*4] ; grab current number\n    imul rax, -1               ; invert by multiplying by -1\n    mov [rdi+rcx*4], eax       ; copy back into position\n    cmp ecx, esi               ; exit if at end of loop\n    jz .end\n    inc ecx\n    jmp .loop\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213610,"user_id":null,"body":"SECTION .text\nglobal invert\n\ninvert:\nL1:\n    dec   rsi\n    cmp   rsi, 0\n    jl    done\n    mov   eax, [rdi+rsi*4]\n    neg   eax\n    mov   [rdi+rsi*4], eax\n    jmp   L1\ndone:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213611,"user_id":10,"body":"SECTION .text\nglobal invert\n\ninvert:\n  xor rcx, rcx  \n  jmp _check\n  \n_loop:\n  mov edx, [rdi+rcx*4]\n  imul edx, -1\n  mov [rdi+rcx*4], edx\n  inc rcx\n  \n_check:\n  cmp rcx, rsi\n  jl _loop\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213612,"user_id":null,"body":"global invert\n  \ninvert:\n  test rsi, rsi\n  jz end\n  mov rcx, rsi\narray_loop:\n  neg dword [rdi+4*rcx-4]\n  loop array_loop\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213613,"user_id":null,"body":"SECTION .text\nglobal invert\n\ninvert:\n  dec rsi\n  .loop:\n    xor dword [rdi+rsi*4], -1         ; flip all bits\n    inc dword [rdi+rsi*4]             ; add one\n    dec rsi\n    jns .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213614,"user_id":null,"body":"SECTION .text\nglobal invert\n\n;rdi, rsi\ninvert:\n  mov rdx, 0\n  cmp rsi, 0\n  je .end\n.loop\n  mov ebx, [rdi+4*rdx]\n  mov eax, 0\n  sub eax, ebx\n  mov [rdi+4*rdx], eax\n  inc rdx\n  cmp rdx, rsi\n  jb .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213615,"user_id":null,"body":"SECTION .text\nglobal invert\n\ninvert:\n.loop:\n  test rsi, rsi\n  jz .end\n  neg DWORD [rdi]\n  add rdi, 4 ;next int\n  dec rsi\n  jmp .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213616,"user_id":null,"body":"\n\nSECTION .text\nglobal invert\n\ninvert:\n  mov rax, rdi\n  xor rcx, rcx\n  .loop:\n    neg dword [rax + rcx * 4] \n    inc rcx\n    cmp rcx, rsi\n    jl .loop\n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213617,"user_id":null,"body":"SECTION .text\nglobal invert\n\ninvert:\n  mov rax, rdi\n  xor rcx, rcx\n  .loop:\n    not dword [rax + rcx * 4] \n    inc dword [rax + rcx * 4]\n    inc rcx\n    cmp rcx, rsi\n    jl .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213618,"user_id":null,"body":"SECTION .text\nglobal invert\n\ninvert:\n  test rsi, rsi\n  jz .exit\n.loop:\n  neg dword [rdi + rsi * 4 - 4]\n  dec rsi\n  jnz .loop\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58ad09d6154165a1c80000d1":[{"id":213619,"user_id":null,"body":"global zero_and_one\nzero_and_one:\n  xor eax,eax\n  jmp .f\n  .b:xor   dl,[rdi+1]\n     lea   eax,[eax+edx-1]\n     lea   rdi,[rdi+rdx+1]\n  .f:movzx rdx,byte[rdi]\n     test  dl,[rdi+1]\n  jne .b\n  cmp byte[rdi],1\n  adc eax,-1\n  neg eax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213620,"user_id":null,"body":"section .text\nglobal zero_and_one\n\n; unsigned int zero_and_one(const char *string)\nzero_and_one:\n  xor esi, esi\n  xor r8d, r8d\n  xor eax, eax\n.loop:\n  mov cl, [rdi+rax]\n  test cl, cl\n  je .done\n  movsx edx, cl\n  sub edx, esi\n  mov esi, edx\n  neg esi\n  cmovns edx, esi\n  dec edx\n  jne .notpair\n  add r8, 2\n  xor ecx, ecx\n.notpair:\n  inc rax\n  movsx esi, cl\n  jmp .loop\n.done:\n  sub eax, r8d\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213621,"user_id":527,"body":"section .text\nglobal zero_and_one\n\n; unsigned zero_and_one(const char *string)\nzero_and_one:\n                xor     esi, esi\n                movzx   edx, byte [rdi]\n                test    edx, edx\n                jz      .done\n                mov     rax, rdi\n                mov     ecx, edx\n.loop:          inc     rax\n                xor     ecx, edx\n                lea     esi, [rsi + rcx]\n                mov     ecx, edx\n                movzx   edx, byte [rax]\n                cmovnz  ecx, edx\n                test    edx, edx\n                jnz     .loop\n                add     esi, esi\n.done:          sub     eax, edi\n                sub     eax, esi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213622,"user_id":168,"body":"section .text\nglobal zero_and_one\n\n; unsigned int zero_and_one(const char *string)\nzero_and_one:\n  xor eax, eax\n  xor ecx, ecx\n  jmp .loop_cond\n.loop:\n  inc rdi\n  xor dl, byte [rdi]\n  cmp dl, 1\n  sete cl\n  setne dl\n  add rdi, rcx\n  add eax, edx\n.loop_cond:\n  movzx edx, byte [rdi]\n  test edx, edx\n  jnz .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213623,"user_id":50,"body":"section .text\nglobal zero_and_one\n\n; unsigned int zero_and_one(const char *string)\nzero_and_one:\n    xor eax, eax  ; string --> RDI, result --> EAX\n    xor rbx,rbx   ; index1\n    mov rcx,1     ; index2\n_loop:\n    mov dl, [rdi + rbx]\n    test dl,dl\n    jz _exit\n    mov r8b, [rdi + rcx]\n    test r8b,r8b\n    jz _inc\n    cmp dl, r8b\n    je _inc\n    add rbx,2\n    add rcx,2\n    jmp _loop\n_inc:\n    inc rax\n    inc rbx\n    inc rcx\n    jmp _loop\n_exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213624,"user_id":881,"body":"section .text\nglobal zero_and_one\n\n; unsigned int zero_and_one(const char *string)\nzero_and_one:\n    xor eax, eax  ; string --> RDI, result --> EAX\n    xor rcx, rcx  ; current char --> CL, next char --> CH\n.for_each_char:\n    mov cl, [rdi]\n.if_char_not_null:\n    inc rdi\n    test cl, cl\n    jnz .test_is_pair\n    ret\n.test_is_pair:\n    mov ch, [rdi]\n    test ch, ch\n    jz .not_a_pair\n    cmp ch, cl\n    je .not_a_pair\n.is_a_pair:\n    inc rdi\n    jmp .for_each_char\n.not_a_pair:\n    inc eax\n    mov cl, ch\n    jmp .if_char_not_null\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58cb43f4256836ed95000f97":[{"id":213625,"user_id":null,"body":"global find_diff\nfind_diff:\n  mov  eax,[rdi]\n  mul  dword[rdi+4]\n  mul  dword[rdi+8]\n  mov  edx,[rsi]\n  imul edx,[rsi+4]\n  imul edx,[rsi+8]\n  sub  eax,edx\n  sbb  edx,edx\n  xor  eax,edx\n  sub  eax,edx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213626,"user_id":null,"body":"global find_diff\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff:  db 0h8B,0h07,0h0F,0hAF,0h47,0h04,0h0F,0hAF,0h47,0h08,0h8B,0h0E,0h0F,0hAF,0h4E,0h04,0h0F,0hAF,0h4E,0h08,0h29,0hC8,0h7D,0h02,0hF7,0hD8,0hC3","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213627,"user_id":null,"body":"global find_diff\n\nfind_diff:\n  mov eax, [rdi]\n  imul eax, [rdi+4]\n  imul eax, [rdi+8]\n  mov edx, [rsi]\n  imul edx, [rsi+4]\n  imul edx, [rsi+8]\n  sub eax, edx\n  cmp eax, 0\n  jg .exit\n  neg eax\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213628,"user_id":null,"body":"global find_diff\n\n; Reminder: If you can, try writing it in one line of code. (chuckle)\n;    troll:D\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff: \n   mov eax, 1\n   mov ebx, 1\n   mov rcx, 3\nfill:\n  imul eax, [rdi]\n  imul ebx, [rsi]\n   add rdi, 4\n   add rsi, 4\nloopne fill\n   cmp eax, ebx\n    jg firstbigger\n  xchg eax, ebx\nfirstbigger:\n   sub eax, ebx\n   ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213629,"user_id":null,"body":"global find_diff\n\n; Reminder: If you can, try writing it in one line of code. (chuckle)\n;    troll:D\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff:\n  mov ecx, [rdi + 4]\n  imul ecx, [rdi]\n  imul ecx, [rdi + 8]\n  mov eax, [rsi + 4]\n  imul eax, [rsi]\n  imul eax, [rsi + 8]\n  sub ecx, eax\n  mov eax, ecx\n  neg eax\n  cmovs eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213630,"user_id":null,"body":"global find_diff\n\n; Reminder: If you can, try writing it in one line of code. (chuckle)\n;    troll:D\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff:\n  mov ecx, [rsi]\n  imul ecx, [rsi+4]\n  imul ecx, [rsi+8]\n  mov eax, [rdi]\n  imul eax, [rdi+4]\n  imul eax, [rdi+8]\n  cmp eax, ecx\n  jng tb\n  sub eax, ecx\n  ret\n  tb:\n  sub ecx, eax\n  mov eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213631,"user_id":null,"body":"global find_diff\n\n; Reminder: If you can, try writing it in one line of code. (chuckle)\n;    troll:D\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff:\n  mov rax, [rdi]\n  mov rcx, 0\n  add rcx, 4\n  mov r8, [rdi, rcx]\n  mul r8\n  add rcx, 4\n  mov r8, [rdi, rcx]\n  mul r8\n  mov r9, rax\n\n  mov rax, [rsi]\n  mov rcx, 0\n  add rcx, 4\n  mov r8, [rsi, rcx]\n  mul r8\n  add rcx, 4\n  mov r8, [rsi, rcx]\n  mul r8\n\n  sub r9, rax\n  mov rax, r9\n\n  cmp eax, 0\n  jg .end\n  neg eax\n\n.end: \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213632,"user_id":null,"body":"global find_diff\n\n; Reminder: If you can, try writing it in one line of code. (chuckle)\n;    troll:D\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff:\n  mov rax, [rdi]\n  mov rcx, 0\n  add rcx, 4\n  mov r8, [rdi, rcx]\n  mul r8\n  add rcx, 4\n  mov r8, [rdi, rcx]\n  mul r8\n  mov r9, rax\n\n  mov rax, [rsi]\n  mov rcx, 0\n  add rcx, 4\n  mov r8, [rsi, rcx]\n  mul r8\n  add rcx, 4\n  mov r8, [rsi, rcx]\n  mul r8\n\n  sub r9, rax\n  mov rax, r9\n\n  mov ebx, eax\n  neg eax\n  cmovl eax, ebx\n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213633,"user_id":460,"body":"global find_diff\n\nfind_diff: \n  xor rax, rax\n  mov eax, dword [rdi+0*4]\n  imul dword [rdi+1*4]\n  imul dword [rdi+2*4]\n  mov edx, dword [rsi+0*4]\n  imul edx, dword [rsi+1*4]\n  imul edx, dword [rsi+2*4]\n  sub eax, edx\n  cmp eax, 0\n  jge .positive\n  neg eax\n.positive:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213634,"user_id":460,"body":"global find_diff\n\n; Reminder: If you can, try writing it in one line of code. (chuckle)\n;    troll:D\n\n; <-- EAX find_diff(ro [dword RDI] a[3], ro [dword RSI] b[3]) -->\nfind_diff: \nxor rax, rax\nor eax, 1\nimul eax, dword [rdi+0*4]\nimul eax, dword [rdi+1*4]\nimul eax, dword [rdi+2*4]\nxor rdx, rdx\nmov edx, eax\nxor rax, rax\nor eax, 1\nimul eax, dword [rsi+0*4]\nimul eax, dword [rsi+1*4]\nimul eax, dword [rsi+2*4]\nsub eax, edx\nxor edx, edx\ncmp eax, 0\njg .positive\nneg eax\n.positive:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58cd7f6914e656400100005a":[{"id":213635,"user_id":168,"body":";  ====----    PRELOADED INFO     ----====\n; Instantiates a new struct instance with given value (as u64)\nextern uinf_new ; (u64) -> uinf_t*\n; Frees the memory used by the given structure\nextern uinf_free ; (uinf_t*) -> void\n; Instantiates a new struct instance with given value (as infinite number)\nextern uinf_copy ; (uinf_t*) -> uinf_t*\n\n; Adds the second value to the first one inplace\nextern uinf_add ; (uinf_t*, uinf_t*) -> void\n; Subtracts the second value from the first one inplace\nextern uinf_sub ; (uinf_t*, uinf_t*) -> void\n; Multiplies the first value by the second one inplace\nextern uinf_mul ; (uinf_t*, uinf_t*) -> void\n\n; Multiplies the first value by the given byte inplace\nextern uinf_mulu ; (uinf_t*, u8) -> void\n; Shifts the first value left by the given amount of bytes inplace\nextern uinf_shlu ; (uinf_t*, u8) -> void\n\n; compares numbers. Returns negative if a < b; positive if a > b; 0 otherwise\nextern uinf_cmp ; (uinf_t* a, uinf_t* b) -> i32\n\n\n;  ====----    USER SPACE    ----====\nSECTION .text\nglobal find_initial_numbers\n\n\n; find_initial_numbers(u32 divisor, u32 iterations) -> (uinf_t*, uinf_t*)\nfind_initial_numbers:\n  ; inputs are passed through registers edi \/ esi\n  ; outputs shall be put into registers rax \/ rdx\n  push rbx      ; iterations\n  push r13      ; a\n  push r14      ; b\n  mov ebx, esi\n  call uinf_new\n  mov r13, rax\n  xor edi, edi\n  call uinf_new\n  mov r14, rax\n  test ebx, ebx\n  jz .end\n  inc ebx\n.loop:\n  mov rdi, r14\n  mov rsi, r13\n  call uinf_add\n  xchg r14, r13\n  dec ebx\n  jnz .loop\n.end:\n  mov rax, r13\n  mov rdx, r14\n  pop r14\n  pop r13\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213636,"user_id":null,"body":";  ====----    PRELOADED INFO     ----====\n; Instantiates a new struct instance with given value (as u64)\nextern uinf_new ; (u64) -> uinf_t*\n; Frees the memory used by the given structure\nextern uinf_free ; (uinf_t*) -> void\n; Instantiates a new struct instance with given value (as infinite number)\nextern uinf_copy ; (uinf_t*) -> uinf_t*\n\n; Adds the second value to the first one inplace\nextern uinf_add ; (uinf_t*, uinf_t*) -> void\n; Subtracts the second value from the first one inplace\nextern uinf_sub ; (uinf_t*, uinf_t*) -> void\n; Multiplies the first value by the second one inplace\nextern uinf_mul ; (uinf_t*, uinf_t*) -> void\n\n; Multiplies the first value by the given byte inplace\nextern uinf_mulu ; (uinf_t*, u8) -> void\n; Shifts the first value left by the given amount of bytes inplace\nextern uinf_shlu ; (uinf_t*, u8) -> void\n\n; compares numbers. Returns negative if a < b; positive if a > b; 0 otherwise\nextern uinf_cmp ; (uinf_t* a, uinf_t* b) -> i32\n\n;  ====----    USER SPACE    ----====\nSECTION .text\nglobal find_initial_numbers\n\n\n; find_initial_numbers(u32 divisor, u32 iterations) -> (uinf_t*, uinf_t*)\nfind_initial_numbers:\n  push rbp\n  push r14\n  push rbx\n  mov ebx, edi\n  test esi, esi\n  je .zeroiter\n  mov ebx, ebx\n  mov ebp, esi\n  mov rdi, rbx\n  call uinf_new\n  mov rdi, rbx\n  mov r14, rax\n  call uinf_new\n.loop:\n  mov rbx, rax\n  sub ebp, 1\n  jb .done\n  mov rdi, r14\n  mov rsi, rbx\n  call uinf_add\n  mov rax, r14\n  mov r14, rbx\n  jmp .loop\n.zeroiter:\n  xor edi, edi\n  call uinf_new\n  mov edi, ebx\n  mov r14, rax\n  call uinf_new\n  mov rbx, rax\n.done:\n  mov rax, r14\n  mov rdx, rbx\n  pop rbx\n  pop r14\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213637,"user_id":525,"body":";  ====----    PRELOADED INFO     ----====\n; Instantiates a new struct instance with given value (as u64)\nextern uinf_new ; (u64) -> uinf_t*\n; Frees the memory used by the given structure\nextern uinf_free ; (uinf_t*) -> void\n; Instantiates a new struct instance with given value (as infinite number)\nextern uinf_copy ; (uinf_t*) -> uinf_t*\n\n; Adds the second value to the first one inplace\nextern uinf_add ; (uinf_t*, uinf_t*) -> void\n; Subtracts the second value from the first one inplace\nextern uinf_sub ; (uinf_t*, uinf_t*) -> void\n; Multiplies the first value by the second one inplace\nextern uinf_mul ; (uinf_t*, uinf_t*) -> void\n\n; Multiplies the first value by the given byte inplace\nextern uinf_mulu ; (uinf_t*, u8) -> void\n; Shifts the first value left by the given amount of bytes inplace\nextern uinf_shlu ; (uinf_t*, u8) -> void\n\n; compares numbers. Returns negative if a < b; positive if a > b; 0 otherwise\nextern uinf_cmp ; (uinf_t* a, uinf_t* b) -> i32\n\n\n;  ====----    USER SPACE    ----====\nSECTION .text\nglobal find_initial_numbers\n\n\n; find_initial_numbers(u32 divisor, u32 iterations) -> (uinf_t*, uinf_t*)\nfind_initial_numbers:\n        push    r12\n        push    r14\n        push    rbp\n        movsx   rax, esi\n        push    rax\n        movsx   rdx, edi\n        mov     rdi, rdx\n        push    rdx\n        call    uinf_new ;(u64)\n        mov     r12, rax\n        pop     rdx\n        mov     rax, [rsp]\n        test    rax, rax\n        jz      .no_iters_return\n        mov     rdi, rdx\n        call    uinf_new ;(u64)\n        mov     rdx, rax\n.perform_iteration:\n        mov     r14, rdx\n        mov     rdi, r12\n        call    uinf_copy ;(uinf_t*)\n        push    rax\n        mov     rsi, r14\n        mov     rdi, r12\n        call    uinf_add ;(uinf_t*, uinf_t*)\n        mov     rdi, r14\n        call    uinf_free\n        pop     rdx\n        dec     QWORD [rsp]\n        jnz     .perform_iteration\n.quit:\n        pop     rax\n        mov     rax, r12\n        pop     rbp\n        pop     r14\n        pop     r12\n        ret\n.no_iters_return:\n        mov     edi, 0\n        call    uinf_new ;(u64)\n        mov     rdx, rax\n        jmp     .quit\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213638,"user_id":168,"body":"SECTION .text\nglobal find_initial_numbers\n\n\n; find_initial_numbers(u32 divisor, u32 iterations) -> (uinf_t*, uinf_t*)\nfind_initial_numbers:\n  ; inputs are passed through registers edi \/ esi\n  ; outputs shall be put into registers rax \/ rbx\n  push r12      ; iterations\n  push r13      ; a\n  push r14      ; b\n  mov r12d, esi\n  call uinf_new\n  mov r13, rax\n  xor edi, edi\n  call uinf_new\n  mov r14, rax\n  test r12, r12\n  jz .end\n  inc r12\n.loop:\n  mov rdi, r14\n  mov rsi, r13\n  call uinf_add\n  xchg r14, r13\n  dec r12\n.loop_cond:\n  test r12, r12\n  jnz .loop\n.end:\n  mov rax, r13\n  mov rbx, r14\n  pop r14\n  pop r13\n  pop r12\n  ret\n\n;  ====----    PRELOADED INFO     ----====\n; Instantiates a new struct instance with given value (as u64)\nglobal uinf_new:function ; (u64) -> uinf_t*\n; Frees the memory used by the given structure\nglobal uinf_free:function ; (uinf_t*) -> void\n; Instantiates a new struct instance with given value (as infinite number)\nglobal uinf_copy:function ; (uinf_t*) -> uinf_t*\n\n; Adds the second value to the first one inplace\nglobal uinf_add:function ; (uinf_t*, uinf_t*) -> void\n; Subtracts the second value from the first one inplace\nglobal uinf_sub:function ; (uinf_t*, uinf_t*) -> void\n; Multiplies the first value by the second one inplace\nglobal uinf_mul:function ; (uinf_t*, uinf_t*) -> void\n\n; Multiplies the first value by the given byte inplace\nglobal uinf_mulu:function ; (uinf_t*, u8) -> void\n; Shifts the first value left by the given amount of bytes inplace\nglobal uinf_shlu:function ; (uinf_t*, u8) -> void\n\n; compares numbers. Returns negative if a < b; positive if a > b; 0 otherwise\nglobal uinf_cmp:function ; (uinf_t* a, uinf_t* b) -> i32\n\n  \n\n; TOUCH IT NOT!!!\n;  ====----    PRELOADED STUFF    ----====\nextern malloc, calloc, realloc, free\nextern memcpy, memset, memmove\n\nuinf_new: ;(u64):\n        push    rbp\n        push    rbx\n        sub     rsp, 8\n        mov     rbx, rdi\n        mov     edi, 16\n        call    malloc\n        mov     rbp, rax\n        mov     DWORD [rax+4], 0\n        mov     DWORD [rax], 8\n        mov     esi, 1\n        mov     edi, 8\n        call    calloc\n        mov     [rbp+8], rax\n        test    rbx, rbx\n        je      .L1\n        mov     rcx, rax\n        mov     eax, DWORD 0\n.L3:\n        mov     edx, eax\n        mov     BYTE [rcx+rdx], bl\n        add     eax, 1\n        mov     rdx, rbx\n        shr     rbx, 8\n        cmp     rdx, 255\n        ja      .L3\n        mov     DWORD [rbp+4], eax\n.L1:\n        mov     rax, rbp\n        add     rsp, 8\n        pop     rbx\n        pop     rbp\n        ret\n\nuinf_free: ;(uinf*):\n        push    rbx\n        mov     rbx, rdi\n        mov     rdi, [rdi+8]\n        call    free\n        mov     rdi, rbx\n        call    free\n        pop     rbx\n        ret\n\nuinf_copy: ;(uinf*):\n        push    rbp\n        push    rbx\n        sub     rsp, 8\n        mov     rbp, rdi\n        mov     edi, 16\n        call    malloc\n        mov     rbx, rax\n        mov     rax, [rbp+0]\n        mov     rdx, [rbp+8]\n        mov     [rbx], rax\n        mov     [rbx+8], rdx\n        mov     edi, eax\n        call    malloc\n        mov     rdi, rax\n        mov     [rbx+8], rax\n        mov     edx, DWORD [rbp+0]\n        mov     rsi, [rbp+8]\n        call    memcpy\n        mov     rax, rbx\n        add     rsp, 8\n        pop     rbx\n        pop     rbp\n        ret\n\nuinf_clear: ;(uinf*):\n        push    rbx\n        mov     rbx, rdi\n        mov     edx, DWORD [rdi+4]\n        mov     rdi, [rdi+8]\n        mov     esi, 0\n        call    memset\n        mov     DWORD [rbx+4], 0\n        pop     rbx\n        ret\n\nuinf_extend_capacity: ;(uinf*, u32):\n        cmp     DWORD [rdi], esi\n        jb      .L18\n        ret\n.L18:\n        push    rbp\n        push    rbx\n        sub     rsp, 8\n        mov     rbx, rdi\n        mov     ebp, esi\n        mov     esi, esi\n        mov     rdi, [rdi+8]\n        call    realloc\n        mov     [rbx+8], rax\n        mov     edi, DWORD [rbx]\n        mov     edx, ebp\n        sub     edx, edi\n        mov     edi, edi\n        add     rdi, rax\n        mov     esi, 0\n        call    memset\n        mov     DWORD [rbx], ebp\n        add     rsp, 8\n        pop     rbx\n        pop     rbp\n        ret\n\nuinf_add: ;(uinf*, uinf*):\n        push    rbp\n        push    rbx\n        sub     rsp, 8\n        mov     rbx, rdi\n        mov     rbp, rsi\n        mov     edx, DWORD [rdi+4]\n        mov     eax, DWORD [rsi+4]\n        lea     ecx, [rdx+1]\n        lea     esi, [rax+1]\n        cmp     edx, eax\n        cmova   esi, ecx\n        call    uinf_extend_capacity ;(uinf*, u32)\n        mov     ecx, DWORD [rbx]\n        test    ecx, ecx\n        je      .L22\n        mov     eax, 0\n        mov     edx, 0\n        mov     r8d, 0\n        jmp     .L24\n.L23:\n        mov     ecx, eax\n        add     rcx, [rbx+8]\n        movzx   esi, BYTE [rcx]\n        add     rsi, rdi\n        add     rdx, rsi\n        mov     BYTE [rcx], dl\n        shr     rdx, 8\n        add     eax, 1\n        mov     ecx, DWORD [rbx]\n        cmp     ecx, eax\n        jbe     .L22\n.L24:\n        mov     rdi, r8\n        cmp     DWORD [rbp+4], eax\n        jbe     .L23\n        mov     ecx, eax\n        mov     rsi, [rbp+8]\n        movzx   edi, BYTE [rsi+rcx]\n        jmp     .L23\n.L22:\n        mov     DWORD [rbx+4], ecx\n        mov     rcx, [rbx+8]\n.L26:\n        mov     eax, DWORD [rbx+4]\n        sub     eax, 1\n        mov     edx, eax\n        cmp     BYTE [rcx+rdx], 0\n        jne     .L19\n        mov     DWORD [rbx+4], eax\n        test    eax, eax\n        jne     .L26\n.L19:\n        add     rsp, 8\n        pop     rbx\n        pop     rbp\n        ret\n\nuinf_sub: ;(uinf*, uinf*):\n        mov     r8, rdi\n        mov     r9, rsi\n        mov     edx, DWORD [rdi]\n        test    edx, edx\n        je      .L32\n        mov     ecx, 0\n        mov     eax, 0\n        mov     r10d, 0\n        jmp     .L34\n.L33:\n        sub     eax, edx\n        mov     esi, ecx\n        add     rsi, [r8+8]\n        movzx   edx, BYTE [rsi]\n        add     eax, edx\n        mov     edi, eax\n        sar     edi, 31\n        shr     edi, 24\n        lea     edx, [rax+rdi]\n        movzx   edx, dl\n        sub     edx, edi\n        mov     BYTE [rsi], dl\n        sar     eax, 31\n        add     ecx, 1\n        mov     edx, DWORD [r8]\n        cmp     edx, ecx\n        jbe     .L32\n.L34:\n        mov     edx, r10d\n        cmp     DWORD [r9+4], ecx\n        jbe     .L33\n        mov     edx, ecx\n        mov     rsi, [r9+8]\n        movzx   edx, BYTE [rsi+rdx]\n        jmp     .L33\n.L32:\n        mov     DWORD [r8+4], edx\n        mov     rcx, [r8+8]\n.L36:\n        mov     eax, DWORD [r8+4]\n        sub     eax, 1\n        mov     edx, eax\n        cmp     BYTE [rcx+rdx], 0\n        jne     .L31\n        mov     DWORD [r8+4], eax\n        test    eax, eax\n        jne     .L36\n.L31:\n        ret\n\nuinf_shlu: ;(uinf*, u32):\n        push    r12\n        push    rbp\n        push    rbx\n        mov     rbx, rdi\n        mov     ebp, esi\n        add     esi, DWORD [rdi+4]\n        call    uinf_extend_capacity ;(uinf*, u32)\n        mov     rsi, [rbx+8]\n        mov     r12d, ebp\n        mov     edx, DWORD [rbx+4]\n        lea     rdi, [rsi+r12]\n        call    memmove\n        mov     rdi, [rbx+8]\n        mov     rdx, r12\n        mov     esi, 0\n        call    memset\n        add     DWORD [rbx+4], ebp\n        pop     rbx\n        pop     rbp\n        pop     r12\n        ret\n\nuinf_mulu: ;(uinf*, u8):\n        push    rbp\n        push    rbx\n        sub     rsp, 8\n        mov     rbx, rdi\n        mov     ebp, esi\n        mov     eax, DWORD [rdi+4]\n        lea     esi, [rax+1]\n        call    uinf_extend_capacity ;(uinf*, u32)\n        mov     edx, DWORD [rbx]\n        test    edx, edx\n        je      .L43\n        mov     ecx, 0\n        mov     eax, 0\n        movzx   edi, bpl\n.L44:\n        mov     edx, ecx\n        add     rdx, [rbx+8]\n        movzx   esi, BYTE [rdx]\n        imul    rsi, rdi\n        add     rax, rsi\n        mov     BYTE [rdx], al\n        shr     rax, 8\n        add     ecx, 1\n        mov     edx, DWORD [rbx]\n        cmp     edx, ecx\n        ja      .L44\n.L43:\n        mov     DWORD [rbx+4], edx\n        mov     rcx, [rbx+8]\n.L46:\n        mov     eax, DWORD [rbx+4]\n        sub     eax, 1\n        mov     edx, eax\n        cmp     BYTE [rcx+rdx], 0\n        jne     .L42\n        mov     DWORD [rbx+4], eax\n        test    eax, eax\n        jne     .L46\n.L42:\n        add     rsp, 8\n        pop     rbx\n        pop     rbp\n        ret\n\nuinf_mul: ;(uinf*, uinf*):\n        push    r14\n        push    r13\n        push    r12\n        push    rbp\n        push    rbx\n        mov     r13, rdi\n        cmp     DWORD [rsi+4], 0\n        je      .L51\n        mov     r12, rsi\n        cmp     DWORD [rdi+4], 0\n        jne     .L52\n.L51:\n        mov     rdi, r13\n        call    uinf_clear ;(uinf*)\n.L50:\n        pop     rbx\n        pop     rbp\n        pop     r12\n        pop     r13\n        pop     r14\n        ret\n.L52:\n        call    uinf_copy ;(uinf*)\n        mov     r14, rax\n        mov     rax, [r12+8]\n        movzx   esi, BYTE [rax]\n        mov     rdi, r13\n        call    uinf_mulu ;(uinf*, u8)\n        cmp     DWORD [r12+4], 1\n        jbe     .L54\n        mov     ebp, 1\n.L55:\n        mov     rdi, r14\n        call    uinf_copy ;(uinf*)\n        mov     rbx, rax\n        mov     esi, ebp\n        mov     rdi, rax\n        call    uinf_shlu ;(uinf*, u32)\n        mov     eax, ebp\n        mov     rdx, [r12+8]\n        movzx   esi, BYTE [rdx+rax]\n        mov     rdi, rbx\n        call    uinf_mulu ;(uinf*, u8)\n        mov     rsi, rbx\n        mov     rdi, r13\n        call    uinf_add ;(uinf*, uinf*)\n        mov     rdi, rbx\n        call    free\n        add     ebp, 1\n        cmp     DWORD [r12+4], ebp\n        ja      .L55\n.L54:\n        mov     rdi, r14\n        call    free\n        jmp     .L50\n\nuinf_cmp: ;(uinf*, uinf*):\n        mov     r8, rsi\n        mov     edx, DWORD [rsi+4]\n        mov     eax, DWORD [rdi+4]\n        cmp     edx, eax\n        je      .L60\n        sub     eax, edx\n        ret\n.L60:\n        sub     edx, 1\n        cmp     edx, -1\n        je      .L61\n        mov     eax, edx\n        mov     rcx, [rdi+8]\n        movzx   ecx, BYTE [rcx+rax]\n        mov     rsi, [r8+8]\n        movzx   esi, BYTE [rsi+rax]\n        cmp     cl, sil\n        je      .L60\n        movzx   eax, cl\n        movzx   esi, sil\n        sub     eax, esi\n        ret\n.L61:\n        mov     eax, 0\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58ce8725c835848ad6000007":[{"id":213639,"user_id":168,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  edi     esi     edx\npotatoes:\n  sub edi, 100\n  lea ecx, [edx - 100]\n  mov eax, esi\n  imul edi\n  idiv ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213640,"user_id":564,"body":"section .text\nglobal potatoes\n; int potatoes(int pctIn, int weight, int pctOut)\n;                    rdi,        rsi,        rdx\npotatoes:\n  ; rax := weight\n  mov rax, rsi\n\n  ; rdi := 100 - pctIn\n  sub rdi, 100\n\n  ; rdx := 100 - pctOut\n  sub rdx, 100\n  \n  ; result of imul would flow into rdx, so move rdx out of that range\n  lea rcx, [rdx]\n  \n  ; weight *= (100 - pctIn)\n  imul rdi\n  \n  ; weight \/= (100 - pctOut)\n  idiv rcx\n  \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213641,"user_id":null,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n  lea eax, [rdi-100]\n  lea ecx, [rdx-100]\n  imul eax, esi\n  cdq\n  idiv ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213642,"user_id":null,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n  mov eax, esi\n  sub edi, 100\n  neg edi\n  lea ecx, [rdx-100]\n  neg ecx\n  mul edi\n  div ecx\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213643,"user_id":50,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n  mov r9,rdi\n  mov r10,rsi\n  mov r11,rdx\n  xor rax,rax\n  mov rax,100\n  sub rax,r9\n  mul r10\n  neg r11\n  add r11,100\n  xor rdx,rdx\n  div r11\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213644,"user_id":null,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n  xor rax, rax\n  xor rcx, rcx\n  mov rax, 100\n  mov rcx, 100\n  sub rax, rdi\n  imul rax, rsi\n  xor rdi, rdi\n  mov rdi, rax\n  xor rax, rax\n  mov rax, rdi\n  sub rcx, rdx\n  xor rdx, rdx\n  div rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213645,"user_id":null,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n    mov rcx, 100\n    sub rcx, rdx\n    mov rax, 100\n    sub rax, rdi\n    mul rsi\n    div rcx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213646,"user_id":null,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n  mov rax, 100\n  sub rax, rdi\n  mov rcx, 100\n  sub rcx, rdx\n  imul rsi\n  xor rdx, rdx\n  idiv rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213647,"user_id":null,"body":"section .text\nglobal potatoes\n; int potatoes(int p0, int w0, int p1)\n;                  rdi     rsi     rdx\npotatoes:\n\n  sub rdi, 100;\n  neg rdi;\n  sub rdx, 100;\n  neg rdx;\n  mov rbx, rdx;\n  \n  mov rax, rsi;\n  mul rdi;\n  div rbx\n  \n  \n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213648,"user_id":564,"body":"section .text\nglobal potatoes\n; int potatoes(int pctIn, int weight, int pctOut)\n;                    rdi         rsi         rdx\npotatoes:\n  push rbp\n\n  mov rbp, rsp\n  mov [rbp-4], edi\n  mov [rbp-8], esi\n  mov [rbp-12], edx\n\n  mov eax, 100\n  sub eax, [rbp-4]\n\n  imul eax, [rbp-8]\n\n  mov edx, 100\n  mov ecx, edx\n  sub ecx, [rbp-12]\n\n  cdq\n  idiv ecx\n\n  pop rbp\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58f5ae82164573de7c00038c":[{"id":213649,"user_id":527,"body":"global rand, solution\n\nsection .text\n\nrand:\nsolution:\n                xor     eax, eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213650,"user_id":168,"body":"global solution, rand\nsection .text\nsolution dd 6.1172108\nrand dd 6.1172108","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213651,"user_id":null,"body":"extern rand, srand\nglobal solution\n\nsection .text\n\n; <--- unsigned solution() --->\nsolution:\n  push rbx\n  xor edi, edi\n  call srand\n  call rand\n  xor edi, edi\n  mov ebx, eax\n  call srand\n  mov eax, ebx\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213652,"user_id":null,"body":"global solution\nextern srand\nsection .text\n\n; <--- unsigned solution() --->\nsolution:\n    xor edi,edi\n    call srand\n    mov eax,1804289383\n    ret\n; -----> endof solution <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213653,"user_id":null,"body":"global solution\nglobal rand\n\nsection .text\n\nrand:\n  xor eax, eax\n  ret\n\n; <--- unsigned solution() --->\nsolution:\n  xor eax, eax    ; EAX <- the result\n  ret\n; -----> endof solution <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213654,"user_id":null,"body":"global solution\nsection .text\n\nsolution:\n  pop rax\n  add rax, 30\n  push rax\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213655,"user_id":null,"body":"global solution,rand\n\nsection .text\n\nrand:\n    mov   rax, 1337\n    ret\n; <--- unsigned solution() --->\nsolution:\n    call  rand\n    ret\n; -----> endof solution <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213656,"user_id":1088,"body":"global solution, rand\n\n[section .text]\n\n; unsigned solution();\nsolution:\n\txor\teax, eax\n\tret\n\nrand:\n\txor\teax, eax\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213657,"user_id":null,"body":"global solution\nglobal rand\n\nsection .text\n\nrand:\n; <--- unsigned solution() --->\nsolution:\n    mov eax, 42    ; EAX <- the result\n    ret\n; -----> endof solution <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213658,"user_id":50,"body":"global solution, rand\n\nsection .text\n\n; <--- unsigned solution() --->\nrand:\n  mov rax, 0\n  ret\nsolution:\n    xor eax, eax    ; EAX <- the result\n    ret\n; -----> endof solution <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"590e03aef55cab099a0002e8":[{"id":213659,"user_id":168,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n  xor eax, eax\n  test rdx, rdx\n  jz .end\n  mov r9, rdi\n  lea r8, [rsi + 4 * rdx]\n.loop:\n  inc eax\n  xor ecx, ecx\n  cmp eax, 10\n  cmovge eax, ecx\n  mov edx, dword [rsi]\n  add edx, eax\n  mov ecx, edx\n  sub ecx, 10\n  cmovge edx, ecx\n  mov dword [rdi], edx\n  add rsi, 4\n  add rdi, 4\n  cmp rsi, r8\n  jb .loop\n  mov rax, r9\n.end:\n  ret\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213660,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    xor eax, eax  ; RAX <- the result\n    cmp rdx, 0\n    je return\n    mov r8, rdi\n    mov r9, rsi\n    mov r10, 1\nloop:\n    cmp r10, rdx\n    jg end\n    mov r11d, [r9]\n    add r11d, r10d\nmod:\n    cmp r11d, 10\n    jl b\n    sub r11d, 10\n    jmp mod\nb:\n    mov [r8], r11d\n    inc r10\n    add r9, 4\n    add r8, 4\n    jmp loop\nend:\n    mov rax, rdi\nreturn:\n    ret\n\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213661,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n  test rdx, rdx\n  mov r8, rdx\n  je .null\n  xor ecx, ecx\n  mov r9d, 10\n.loop:\n  mov eax, [rsi+rcx*4]\n  inc rcx\n  xor edx, edx\n  add rax, rcx\n  div r9\n  cmp rcx, r8\n  mov [rdi-4+rcx*4], edx\n  jne .loop\n  jmp .done\n.null:\n  xor edi, edi\n.done:\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213662,"user_id":881,"body":"section .text\nglobal incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    xor rcx, rcx\n    mov r8, rdx\n    mov r10, 10\n    test r8, r8\n    cmove rdi, rcx\n.for_each_number:\n    cmp rcx, r8\n    jge .end_each_number\n    inc rcx\n    mov eax, [rsi + 4 * rcx - 4]\n    add eax, ecx\n    xor rdx, rdx\n    div r10d\n    mov [rdi + 4 * rcx - 4], edx\n    jmp .for_each_number\n.end_each_number:\n    mov rax, rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213663,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    xor eax, eax            ; RAX <- the result\n    \n    mov rcx, 0\n\n.loop:\n    mov rax, [rsi, 4*rcx]\n    add rax, rcx\n    add rax, 1\n\n    push rdx\n    xor rdx, rdx\n    mov rbx, 10\n    div ebx\n    mov rax, rdx\n    pop rdx\n    \n    mov [rdi, 4*rcx], rax\n\n    add rcx, 1\n    cmp rcx, rdx\n    jl .loop\n.end:\n    mov rax, rdi\n\n    cmp rdx, 0\n    cmove rax, rdx\n\n    ret\n\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213664,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    xor rax, rax\n    mov rcx, rdx        ; rcx = item counter\n    test rcx, rcx       ; empty input?\n    jz exit             ; exit with null return\n    push rdi            ; store *dest for return\n    xor edx, edx        ; edx = offset to add\nnext:\n    lodsd               ; eax = next item\n    inc edx             ; edx = next offset to add\n    cmp edx, 10\n    jb  no_add_limit\n    xor edx, edx        ; limit offset to 9\nno_add_limit:    \n    add eax, edx\n    cmp eax, 10\n    jb  no_overflow_10\n    sub eax, 10         ; add overflow, eg. 12 -> 2\nno_overflow_10:\n    stosd\n    loop next\n    pop rax             ; rax = *dest\nexit:\n    ret\n; -----> endof incrementer <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213665,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n  test rdx, rdx\n  jz .bailout\n  push rdi\n  mov r9, rdx\n  \n  mov ecx, 1\n  mov r8d, 10\n\n.loop:\n  mov eax, [rsi]\n  add rsi, 4\n  add eax, ecx\n  inc ecx\n  xor edx, edx\n  div r8d\n  mov [rdi], edx\n  add rdi, 4\n  dec r9\n  jnz .loop\n  \n  pop rax\n  ret\n\n.bailout:\n  xor eax, eax\n  ret\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213666,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    test    rdx, rdx\n    je      .null\n    mov     rax, rdi            ; RAX <- the result\n    mov     ecx, 1\n    .loop:\n    mov     ebx, dword [rsi]\n    mov     dword [rdi], ebx\n    add     [rdi], ecx\n    cmp     dword [rdi], 10\n    jge     .drop\n    .continue:\n    add     rdi, 4\n    add     rsi, 4\n    inc     ecx\n    dec     rdx\n    jnz     .loop\n    ret\n    .null:\n    xor     rax,rax\n    ret\n    .drop:\n    push    rdx\n    push    rax\n    mov     eax, dword [rdi]\n    xor     edx, edx\n    mov     r8d, 10\n    div     r8d\n    mov     dword [rdi], edx\n    pop     rax\n    pop     rdx\n    jmp     .continue\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213667,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    xor rcx, rcx\n    mov r9, rdx\n    mov r10, 10\nloop:\n    cmp rcx, r9\n    jz return\n    mov r8d, dword [rsi+rcx*4]\n    lea eax, [r8d+ecx+1]\n    xor rdx, rdx\n    div r10\n    mov dword [rdi+rcx*4], edx\n    inc ecx\n    jmp loop\n    \nreturn:\n    xor rax, rax\n    test r9, r9\n    cmovnz rax, rdi           ; RAX <- the result\n    ret\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213668,"user_id":null,"body":"global incrementer\n\n; <-- [dword RAX] incrementer([dword RDI] dest, ro [dword RSI] src, RDX n) -->\nincrementer:\n    xor rcx, rcx\n    xor rax, rax\n    xor r10, r10\n    mov r9, 10\nloop:\n    cmp rcx, rdx\n    jz return\n    mov r8d, dword [rsi+rcx*4]\n    lea r8d, [r8d+ecx+1]\n    cmp r8d, 10\n    jge overflow\ncontinue:\n    mov dword [rdi+rcx*4], r8d\n    inc ecx\n    jmp loop\noverflow:\n    sub r8d, r9d\n    cmp r8d, 10\n    jg overflow\n    cmove r8d, r10d\n    jmp continue\nreturn:\n    cmp rdx, 0\n    cmovg rax, rdi           ; RAX <- the result\n    ret\n\n; -----> endof incrementer <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"592e830e043b99888600002d":[{"id":213669,"user_id":null,"body":"global encode\nextern malloc, strlen\n\nsection .text\n\n; <--- unsigned char *encode(const char *s, unsigned k) --->\nencode:\n  push rbp\n  push rdi\n  push rsi\n  call strlen\n  mov rdi, rax\n  call malloc\n  pop rsi\n  pop rdi\n  xor ecx, ecx\n  xor r8d, r8d\n  mov r9, rax\n  mov eax, esi\n  mov r10d, 10\n  xor r11d, r11d\n  .key_loop:\n  xor edx, edx\n  div r10d\n  dec r11\n  mov [rsp + r11], dl\n  test eax, eax\n  jnz .key_loop\n  mov rdx, r11\n  jmp .encode_continue\n  .encode_loop:\n  mov al, [rsp + rdx]\n  inc rdx\n  cmovz rdx, r11\n  lea ecx, [ecx - 'a' + 1 + eax]\n  mov [r9 + r8], cl\n  inc r8\n  .encode_continue:\n  mov cl, [rdi + r8]\n  test ecx, ecx\n  jnz .encode_loop\n  mov rax, r9\n  pop rbp\n  ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213670,"user_id":null,"body":"global encode\nextern malloc\n\nsection .text\n\n; <--- unsigned char *encode(const char *s, unsigned k) --->\nencode:\n  push rbp\n  push r14\n  push rbx\n  sub rsp, 16\n  mov ebp, esi\n  mov r14, rdi\n  mov rbx, -1\n.strlenloop:\n  cmp byte [r14 + rbx + 1], 0\n  lea rbx, [rbx + 1]\n  jne .strlenloop\n  mov rdi, rbx\n  call malloc\n  mov rdi, rax\n  xor esi, esi\n  mov rcx, 10\n.digitloop:\n  test ebp, ebp\n  je .lastdigit\n  mov eax, ebp\n  xor edx, edx\n  div ecx\n  mov [rsp + rsi + 6], dl\n  inc rsi\n  mov ebp, eax\n  jmp .digitloop\n.lastdigit:\n  xor eax, eax\n  mov rdx, rsi\n.loop:\n  cmp rbx, rax\n  je .done\n  dec rdx\n  mov cl, [r14 + rax]\n  add cl, [rsp + rdx + 6]\n  add cl, -96\n  test rdx, rdx\n  mov [rdi + rax], cl\n  cmove rdx, rsi\n  inc rax\n  jmp .loop\n.done:\n  mov rax, rdi\n  add rsp, 16\n  pop rbx\n  pop r14\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213671,"user_id":null,"body":"global encode\nextern malloc, strlen\n\nsection .text\n\n; <--- unsigned char *encode(const char *s, unsigned k) --->\nencode:\n  %push mycontext\n  %stacksize flat64       ; address local with ebp\n  %assign %$localsize 0\n  %local arg_s:qword      ; storage of *s\n  %local result:qword     ; address of the result array buffer\n  %local kcode:yword      ; the digits of k - 'a' + 1\n  %local lastcode:qword   ; address of the top digit in kcode\n  \n    enter %$localsize, 0\n    mov [arg_s], rdi      ; store *s\n    \n    ; convert number k into k_digits\n    mov ecx, 10           ; decimal digits\n    mov eax, esi          ; eax = k\n    lea rdi, [kcode]      ; rdi = running pointer in array k_digits\nnext_digit:\n    xor edx, edx\n    div ecx               ; eax = eax \/ ecx, edx = eax % edx\n    sub dl, 'a'-1         ; dl = offset to encode\n    mov [rdi], dl         ; store value of digit\n    inc rdi\n    test eax, eax\n    jnz next_digit        ; next digit of k\n    dec rdi\n    mov [lastcode], rdi   ; address of the topmost digit of k\n\n  \t; allocate result array\n    mov rdi, [arg_s]\n    call strlen           ; rax = strlen(*s)\n    mov rdi, rax\n    call malloc           ; allocate result array\n    mov [result], rax\n    test rax, rax\n    jz exit               ; error exit: no memory\n    \n    ; encode the string\n    mov rdi, rax          ; rdi = running pointer in result\n    mov rsi, [arg_s]      ; rsi = running pointer in s\n    mov rbx, [lastcode]   ; rbx = running pointer in kcode\n    lea rcx, [kcode]      ; rcx = addr of the lowest kcode\nnext_char:\n    lodsb                 ; al = next input char\n    test al,al\n    jz exit               ; end of string -> exit\n    ;sub al, 'a'-1        ; this sub is already in the kcode\n    add al, [rbx]\n    dec rbx               ; next code of k\n    cmp rbx, rcx          ; end of kcode array?\n    jae no_wrap\n    mov rbx, [lastcode]   ; use code k again\nno_wrap:    \n    stosb                 ; store the encoded char\n    jmp next_char\n\nexit:\n    mov rax, [result]\n    leave\n    ret\n\n  %pop\n; ---------> endof encode <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213672,"user_id":168,"body":"global encode\nextern malloc, strlen\n\nsection .bss\n\ndigits resb 10\n\nsection .text\n\n; <--- unsigned char *encode(const char *s, unsigned k) --->\nencode:\n  push rbx\n  push rbp\n  push rdx\n\n  mov eax, esi\n  xor esi, esi\n  mov ecx, 10\n.loop_digits:\n  xor edx, edx\n  div ecx\n  mov byte [digits + rsi], dl\n  inc esi\n  test eax, eax\n  jnz .loop_digits\n\n  mov rbx, rdi  ; s\n  mov ebp, esi  ; |digits|\n  call strlen\n  mov rdi, rax\n  call malloc\n  mov rdi, rax\n  mov esi, ebp\n  jmp .loop_cond\n  \n.loop:\n  dec esi\n  movzx ecx, byte [digits + rsi]\n  cmovz esi, ebp\n  lea edx, [rdx + rcx - 'a' + 1]\n  mov byte [rdi], dl\n  inc rdi\n  inc rbx\n.loop_cond:\n  movzx edx, byte [rbx]\n  test edx, edx\n  jnz .loop\n\n  pop rdx\n  pop rbp\n  pop rbx\n  ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213673,"user_id":null,"body":"global encode\nextern malloc, strlen\nextern pow, log10\n\nsection .text\n\n; <--- unsigned char *encode(const char *s, unsigned k) --->\nencode:\n    push rbp                ; saving <RBP> in the stack\n    push rbx                ; saving <RBX> in the stack\n    push rdi                ; saving <s> in the stack\n    test rdi, rdi           ; whether <s> is NULL\n    je .exit                ; jumping to exit\n    mov ebx, esi            ; copying <k> to EBX\n    call strlen             ; getting the length of <s>\n    lea edi, [eax+1]        ; the target bytes for <enc>\n    call malloc             ; allocating memory\n    mov rbp, rax            ; copying the memory address to RBP as <enc>\n    test rbp, rbp           ; whether the memory is allocated\n    je .exit                ; jumping to exit\n    test ebx, ebx           ; whether <k> is zero\n    je .ini                 ; jumping to the .ini label\n    cvtsi2sd xmm0, ebx      ; converting <k> to double\n    call log10              ; getting the number of digits <ndig>\n    cvttsd2si esi, xmm0     ; getting rid of the floating part in <ndig>\n    cvtsi2sd xmm1, esi      ; converting <ndig> back to double\n    mov rdi, __float64__(10.); setting RDI to ten being in the floating representation\n    movq xmm0, rdi          ; moving the floating ten to XMM0\n    call pow                ; getting the cypher divisor <ncyph>\n    cvttsd2si r11d, xmm0    ; converting <ncyph> to the integer repre\n    mov r10d, 10            ; the divisor to get rid of the rightmost digit\n    mov r9d, r11d           ; setting R11D to <ncyph> as <cyph>\n    mov r8d, ebx            ; setting R9D to <k> as <key>\n.ini:\n    mov rdi, [rsp]          ; copying <s> from the stack to RDI\n    xor ecx, ecx            ; resetting RCX as <n>\n.loop:\n    mov sil, [rdi+rcx]      ; setting <*(s+n)> to SIL as <c>\n    test sil, sil           ; whether <c> is the null character\n    je .exit                ; jumping to exit\n    sub sil, 96             ; converting <c> from the ASCII code to the digital one\n    test ebx, ebx           ; whether <k> is empty\n    je .set                 ; jumping to the .set label immediately\n    test r9d, r9d           ; whether <cyph> is zero\n    cmove r9d, r11d         ; setting <cyph> to <ncyph>\n    cmove r8d, ebx          ; setting <key> to <k>\n    mov eax, r8d            ; setting EAX to <key>\n    xor edx, edx            ; resetting EDX before the division\n    div r9d                 ; dividing <key> by <cyph>\n    mov r8d, edx            ; updating <key> with the leftmost digit removed\n    add esi, eax            ; encrypting <c>\n    mov eax, r9d            ; copying <cyph> to EAX\n    xor edx, edx            ; resetting EDX before the division\n    div r10d                ; shifting <cyph> right by one digit\n    mov r9d, eax            ; updating <cyph>\n.set:\n    mov [rbp+rcx], sil      ; copying <c> to <*(enc+n)>\n    inc rcx                 ; incrementing <n>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    mov rax, rbp            ; copying <enc> to RAX\n    add rsp, 8              ; restoring the stack boundary\n    pop rbx                 ; restoring the initial RBX\n    pop rbp                 ; restoring the initial RBP\n    ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"592edfda5be407b9640000b2":[{"id":213674,"user_id":null,"body":"global decode\nextern malloc\n\nsection .text\n\n; <--- char *decode(const unsigned char *code, size_t n, unsigned key) --->\ndecode:\n  push rbp\n  push r15\n  push r14\n  push rbx\n  sub rsp, 24\n  mov r14, rdi\n  lea rdi, [rsi + 1]\n  mov ebp, edx\n  mov r15, rsi\n  call malloc\n  mov rcx, rax\n  xor esi, esi\n  push 10\n  pop rdi\n.digitloop:\n  test ebp, ebp\n  je .lastdigit\n  mov eax, ebp\n  xor edx, edx\n  div edi\n  mov byte [rsp + rsi + 14], dl\n  inc rsi\n  mov ebp, eax\n  jmp .digitloop\n.lastdigit:\n  xor eax, eax\n  mov rdx, rsi\n.loop:\n  cmp r15, rax\n  je .done\n  dec rdx\n  mov bl, byte [r14 + rax]\n  sub bl, byte [rsp + rdx + 14]\n  add bl, 96\n  test rdx, rdx\n  mov [rcx + rax], bl\n  cmove rdx, rsi\n  inc rax\n  jmp .loop\n.done:\n  mov byte [rcx + r15], 0\n  mov rax, rcx\n  add rsp, 24\n  pop rbx\n  pop r14\n  pop r15\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213675,"user_id":null,"body":"global decode\nextern malloc\ndecode:\n  mov       [rsp-8],rdx\n  fild      qword[rsp-8]\n  fbstp     [rsp-10]\n  movdqu    xmm2,[rsp-10]\n  punpcklbw xmm2,xmm2\n  movdqa    xmm1,xmm2\n  movdqa    xmm0,[blend]\n  psrad     xmm1,4\n  pblendvb  xmm2,xmm1,xmm0\n  pand      xmm2,[mask]\n  pshufb    xmm2,[shufle]\n  pxor      xmm1,xmm1\n  pcmpeqb   xmm1,xmm2\n  pmovmskb  ecx,xmm1\n  not       rcx\n  bsf       rcx,rcx\n  movdqu    [rsp-16],xmm2\n  movdqu    xmm2,[rsp-16+rcx]\n\n  push rcx\n  push rdi\n  push rsi\n  lea  rdi,[rsi+15]\n  call malloc\n  pop  rsi\n  pop  rdi\n  pop  rcx\n \n  neg   rcx\n  add   rcx,16\n  psubb xmm2,[ascii]\n  mov   r9,rsi\n  xor   r8,r8\n  .b:movdqu xmm0,[rdi+r8]\n     psubb  xmm0,xmm2\n     movdqu [rax+r8],xmm0\n     add    r8,rcx\n     sub    rsi,rcx\n  jg .b   \n  mov byte[rax+r9],0\nret\nalign 16\nmask   dq 0x0F0F0F0F0F0F0F0F,0x0F0F0F0F0F0F0F0F\nblend  dq 0xFF00FF00FF00FF00,0xFF00FF00FF00FF00\nshufle dq 0x08090A0B0C0D0E0F,0x0001020304050607\nascii  times 16 db 'a'-1\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213676,"user_id":null,"body":"global decode\nextern malloc\n\nsection .text\n\n; <--- char *decode(const unsigned char *code, size_t n, unsigned key) --->\n; rdi = *code\n; esi = n\n; edx = key\ndecode:\n\n    ; Allocate memory for string\n    push rdi\n    push rsi\n    push rdx\n    lea edi,[rsi+1]  ; string len + '\\0' (n+1)\n    call malloc\n    mov rdi,rax  ; rdi = result string address (current position)\n    mov r10,rax  ; r10 = start of string\n    pop rax  ; rax = key\n    pop r9   ; r9 = n\n    pop rsi  ; rsi = code address\n\n    cld\n    test r9d,r9d\n    jz .finish  ; empty string?\n\n    ; Decode key (eax) to key array (in red zone of stack)\n    xor ecx,ecx  ; ecx = number of digits (negative)\n    mov r11d,10\n.dig:\n    xor edx,edx\n    div r11d\n    dec rcx\n    mov [rsp+rcx],dl\n    test eax,eax\n    jnz .dig\n    mov r8,rcx  ; negative size of key array\n\n    ; Decode\n.loop:\n    lodsb\n    sub al,[rsp+rcx]  ; subtract key\n    add al,'a'-1  ; convert to char\n    stosb\n    inc rcx\n    cmovz rcx,r8\n    dec r9d\n    jnz .loop\n\n.finish:\n    xor al,al\n    stosb  ; end of string\n    mov rax,r10\n    ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213677,"user_id":null,"body":"global decode\nextern malloc\n\nsection .text\n\n; <--- char *decode(const unsigned char *code, size_t n, unsigned key) --->\n; rdi = *code\n; esi = n\n; edx = key\ndecode:\n\n    ; Allocate memory for string\n    push rdi\n    push rsi\n    push rdx\n    lea edi,[rsi+1]  ; string len + '\\0' (n+1)\n    call malloc\n    mov rdi,rax  ; rdi = result string address (current position)\n    mov r10,rax  ; r10 = start of string\n    pop rax  ; rax = key\n    pop r9   ; r9 = n\n    pop rsi  ; rsi = code address\n\n    cld\n    test r9d,r9d\n    jz .finish  ; empty string?\n\n    ; Decode key (eax) to key array (in red zone of stack)\n    xor ecx,ecx  ; ecx = number of digits (negative)\n    mov r11d,10\n.dig:\n    xor edx,edx\n    div r11d\n    dec rcx\n    mov [rsp+rcx],dl\n    test eax,eax\n    jnz .dig\n    mov r8,rcx  ; negative size of key array\n\n    ; Decode\n.loop:\n    lodsb\n    sub al,[rsp+rcx]  ; subtract key\n    add al,'a'-1  ; convert to char\n    stosb\n    inc rcx\n    jnz .ok\n    mov rcx,r8\n.ok:\n    dec r9d\n    jnz .loop\n\n.finish:\n    xor al,al\n    stosb  ; end of string\n    mov rax,r10\n    ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213678,"user_id":168,"body":"global decode\nextern malloc\n\nsection .text\n\n; <--- char *decode(const unsigned char *code, size_t n, unsigned key) --->\ndecode:\n  push rbx\n  push rbp\n  sub rsp, 16\n  push rsi\n\n  mov eax, edx\n  mov ebx, 8\n  mov ecx, 10\n.loop_digits:\n  xor edx, edx\n  div ecx\n  mov byte [rsp + rbx], dl\n  inc ebx\n  test eax, eax\n  jnz .loop_digits\n\n  mov rbp, rdi  ; code\n  sub ebx, 8    ; |digits|\n  lea rdi, [rsi + 1]\n  call malloc\n  \n  pop rsi       ; n\n  add rsi, rbp\n  mov rdi, rax\n  mov ecx, ebx\n  jmp .loop_cond\n  \n.loop:\n  movzx edx, byte [rbp]\n  sub dl, byte [rsp + rcx - 1]\n  dec ecx\n  cmovz ecx, ebx\n  add dl, 'a' - 1\n  mov byte [rdi], dl\n  inc rdi\n  inc rbp\n.loop_cond:\n  cmp rbp, rsi\n  jb .loop\n\n  mov byte [rdi], 0\n  add rsp, 16\n  pop rbp\n  pop rbx\n  ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213679,"user_id":null,"body":"global decode\nextern malloc\nextern pow, log10\n\nsection .text\n\n; <--- char *decode(const unsigned char *code, size_t n, unsigned key) --->\ndecode:\n    push rbp                ; saving RBP in the stack\n    push rbx                ; saving RBX in the stack\n    sub rsp, 0h10           ; target bytes to keep digits of unsigned integer\n    mov rbp, rsp            ; pointing RBP to the local storage for <cyphtab>\n    mov qword [rbp], 0      ; resetting initial values of <cyphtab> in case <key> is zero\n    xor eax, eax            ; resetting RAX as <str>\n    test rdi, rdi           ; whether <code> is NULL\n    je .exit                ; jumpting to exit\n    test rsi, rsi           ; whether <n> is zero\n    je .exit                ; jumping to exit\n    push rdi                ; saving <code> in the stack\n    push rsi                ; saving <n> in the stack\n    push rdx                ; saving <key> in the stack\n    lea rdi, [rsi + 1]      ; target bytes to allocate for <str>\n    call malloc             ; allocating memory\n    test rax, rax           ; whether the memory is allocated\n    je .error               ; otherwise, jumping to the .error label\n    pop rbx                 ; restoring <key> from the stack\n    push rax                ; saving <str> in the stack\n    mov r11d, ebx           ; copying <key> to R11D\n    test ebx, ebx           ; whether <key> is zero\n    je .ini                 ; jumping to the .ini label\n\n    cvtsi2sd xmm0, r11d     ; converting <key> to double\n    call log10              ; getting the power for parsing digits from left to right as <ncyph>\n    cvttsd2si r9d, xmm0     ; removing the floating part in <ncyph>\n    cvtsi2sd xmm1, r9d      ; copying <ncyph> to XMM1\n    push r9                 ; saving <ncyph> in the stack\n    sub rsp, 8              ; aligning the stack before calling\n    mov rax, __float64__(10.); setting RAX to ten being in the floating representation\n    movq xmm0, rax          ; moving the floating ten to XMM0\n    call pow                ; getting <cyph> for parsing digits from left to right\n    cvttsd2si r8d, xmm0     ; removing the floating part in <cyph>\n    add rsp, 8              ; restoring the stack boundary\n    pop r9                  ; restoring <ncyph> from the stack\n    mov r10d, 10            ; will be used to get rid of digits in <cyph>\n    mov r11d, ebx           ; copying <key> to R11D\n    xor ecx, ecx            ; resetting RCX as <i>\n.cyphtab:\n    test r8d, r8d           ; whether <cyph> is zero\n    je .ini                 ; jumping to the .ini label\n    mov eax, r11d           ; copying <key> to EAX\n    xor edx, edx            ; resetting EDX before the division\n    div r8d                 ; dividing <key> by <cyph>\n    mov r11d, edx           ; updating <key> with the leftmost digit removed\n    mov [rbp+rcx], al       ; saving in <*(cyphtab+i)>\n    mov eax, r8d            ; copying <cyph> to EAX\n    xor edx, edx            ; resetting EDX before the division\n    div r10d                ; getting rid of a digit\n    mov r8d, eax            ; updating <cyph> with the rightmost digit removed\n    inc ecx                 ; incrementing <i>\n    jmp .cyphtab            ; jumping to the next .cyphtab iteration\n.ini:\n    pop rax                 ; restoring <str> from the stack\n    pop rsi                 ; restoring <n> from the stack\n    pop rdi                 ; restoring <code> from the stack\n    xor ecx, ecx            ; resetting RCX as <i>\n    xor r10d, r10d          ; will be used in conditional move as a resetter\n    mov byte [rax+rsi], 0   ; terminating <*(str+n)>\n.loop:\n    cmp ecx, esi            ; whether <i> is less than <n>\n    je .exit                ; jumping to exit\n    mov dl, [rdi+rcx]       ; copying to DL <*(code+i)> as <c>\n    test ebx, ebx           ; whether <key> is zero\n    je .set                 ; jumping immediately to the .set label\n    cmp r8d, r9d            ; whether <cyph> is greater than <ncyph>\n    cmovg r8d, r10d         ; resetting <cyph>\n    sub dl, [rbp+r8]        ; subtracting <cyphtab[cyph]> from <c>\n    inc r8d                 ; incrementing <cyph>\n.set:\n    add dl, 96              ; decoding <c>\n    mov [rax+rcx], dl       ; copying <c> to <*(str+i)>\n    inc ecx                 ; incrementing <n>\n    jmp .loop               ; jumping to the next iteration\n.error:\n    add rsp, 0h18           ; restoring the stack boundary\n.exit:\n    add rsp, 0h10           ; destroying <cyphtab> and restoring the stack boundary\n    pop rbx                 ; restoring the initial RBX\n    pop rbp                 ; restoring the initial RBP\n    ret\n; ---------> endof encode <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5930d8a4b8c2d9e11500002a":[{"id":213680,"user_id":null,"body":"extern free, malloc\nglobal find_the_key\n\n; <-- EAX find_the_key(ro [byte RDI] msg, ro [byte RSI] code, RDX n) -->\nfind_the_key:\n  push r12\n  mov r12, rsi\n  push rbp\n  mov rbp, rdi\n  mov rdi, rdx\n  push rbx\n  mov rbx, rdx\n  call malloc\n  mov rdi, rax\n  xor eax, eax\n.keyloop:\n  mov cl, [rbp+0+rax]\n  test cl, cl\n  je .keydone\n  mov sil, [r12+rax]\n  lea edx, [rsi+96]\n  sub edx, ecx\n  mov [rdi+rax], dl\n  inc rax\n  jmp .keyloop\n.keydone:\n  mov edx, 1\n.minlenloop:\n  cmp rdx, rbx\n  jnb .lenfound\n  mov r8, rdi\n  mov rsi, rdx\n  mov rcx, rdx\n  sub r8, rdx\n.substrloop:\n  lea rax, [rsi+rdx]\n  mov r9, rbx\n  cmp rax, rbx\n  cmovbe r9, rax\n  cmp rcx, r9\n  jnb .endsub\n  mov al, [r8+rcx]\n  cmp [rdi+rcx], al\n  je .nextcode\n  inc rdx\n  jmp .minlenloop\n.nextcode:\n  lea rax, [rcx+1]\n  jmp .nextrepeat\n.endsub:\n  cmp rax, rbx\n  jnb .lenfound\n  mov rsi, rax\n.nextrepeat:\n  mov rcx, rax\n  jmp .substrloop\n.lenfound:\n  xor eax, eax\n  xor ebx, ebx\n.numberloop:\n  imul ebx, ebx, 10\n  movsx ecx, byte [rdi+rax]\n  inc rax\n  add ebx, ecx\n  cmp rdx, rax\n  jne .numberloop\n  call free\n  mov eax, ebx\n  pop rbx\n  pop rbp\n  pop r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213681,"user_id":168,"body":"global find_the_key\n\n; <-- EAX find_the_key(ro [byte RDI] msg, ro [byte RSI] code, RDX n) -->\nfind_the_key:\n  mov eax, 20\n  cmp edx, eax\n  cmova edx, eax\n  sub rsp, rdx\n \n  xor ecx, ecx\n.decode:\n  movzx eax, byte [rsi + rcx]\n  sub al, byte [rdi + rcx]\n  add al, 96\n  mov byte [rsp + rcx], al\n  inc ecx\n  cmp ecx, edx\n  jb .decode\n\n  xor r8d, r8d\n  xor ecx, ecx\n.loop:\n  inc ecx\n  cmp ecx, edx\n  jae .found\n  mov edi, ecx\n  xor esi, esi\n.periodic:\n  mov al, byte [rsp + rdi]\n  cmp al, byte [rsp + rsi]\n  jne .loop\n  inc edi\n  inc esi\n  cmp esi, ecx\n  cmovae esi, r8d\n  cmp edi, edx\n  jb .periodic\n\n.found:\n  xor eax, eax\n  xor esi, esi\n.key:\n  movzx edi, byte [rsp + rsi]\n  lea rax, [5 * rax]\n  lea rax, [2 * rax + rdi]\n  inc esi\n  cmp esi, ecx\n  jb .key\n\n  add rsp, rdx\n  ret\n; -----> endof find_the_key <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213682,"user_id":null,"body":"global find_the_key\n\n; <-- EAX find_the_key(ro [byte RDI] msg, ro [byte RSI] code, RDX n) -->\nfind_the_key:\n    push rbp                ; saving RBP in the stack\n    push rbx                ; saving RBX in the stack\n    xor ebp, ebp            ; resetting RBP  as <k>\n    inc ebp                 ; incrementing <k>\n    xor ebx, ebx            ; resetting EBX as <n>\n.lpt:\n    cmp ebx, 10             ; whether <n> is less than ten\n    jge .start              ; otherwise, jumping to .start\n    mov dl, [rdi+rbx]       ; loading DL with <*(msg+n)> as <m>\n    test dl, dl             ; whether <m> is the null character\n    je .start               ; jumping to .start\n    mov al, [rsi+rbx]       ; loading AL with <*(code+n)> as <c>\n    sub al, dl              ; subtracing <m> from <c>\n    add al, 96              ; converting <c> to digit\n    mov [rsp-0h10+rbx], al  ; saving <c> in <*(keytab+n)>\n    inc ebx                 ; incrementing <n>\n    jmp .lpt                ; jumping to the nex .lpt iteration\n.start:\n    xor edi, edi            ; resetting EDI as <i>\n    xor esi, esi            ; resetting ESI as <j>\n    xor eax, eax            ; resetting EAX as <key>; also will be used in conditional move\n    xor ecx, ecx            ; resetting ECX as a duplicate <n> for jumpless\n.lpk:\n    inc edi                 ; incrementing <i>\n    cmp edi, ebx            ; whether <i> is less than <n>\n    jge .exit               ; otherwise, jumping to exit    \n    cmp esi, ebp            ; whether <j> is less than <k>\n    cmovge esi, eax         ; otherwise, resetting <j>\n    mov dl, [rsp-0h10+rsi]  ; loading DL with <*(keytab+j)> as <kj>\n    inc esi                 ; incrementing <j>\n    cmp dl, [rsp-0h10+rdi]  ; whether <kj> is not equal to <*(keytab+i)>\n    je .lpk                 ; otherwise, jumping to the next .lpk iteration\n    mov edi, ebp            ; setting <i> to <k>\n    inc ebp                 ; incrementing <k>\n    xor esi, esi            ; resetting <j>\n    jmp .lpk                ; jumping to the next .lpk iteration\n.loop:\n    movzx ebx, byte [rsp-0h10+rcx]  ; extracting the digit\n    imul eax, 10                    ; shifting <key> one digit left\n    add eax, ebx                    ; adding the digit to <key>\n    inc ecx                         ; incrementing <n>\n.exit:\n    cmp ecx, ebp                    ; whether <n> is less than <k>\n    jl .loop                        ; jumping to the next .loop iteration\n    pop rbx                         ; restoring the original RBX from the stack\n    pop rbp                         ; restoring the original RBP from the stack\n    ret\n; -----> endof find_the_key <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213683,"user_id":null,"body":"global find_the_key\n\n; <-- EAX find_the_key(ro [byte RDI] msg, ro [byte RSI] code, RDX n) -->\nfind_the_key:\n    push rbp                ; saving RBP in the stack\n    push rbx                ; saving RBX in the stack\n    xor ebp, ebp            ; resetting RBP  as <k>\n    inc ebp                 ; incrementing <k>\n    xor ebx, ebx            ; resetting EBX as <n>\n.lpt:\n    cmp ebx, 10             ; whether <n> is less than ten\n    jge .start              ; otherwise, jumping to .start\n    mov dl, [rdi+rbx]       ; loading DL with <*(msg+n)> as <m>\n    test dl, dl             ; whether <m> is the null character\n    je .start               ; jumping to .start\n    mov al, [rsi+rbx]       ; loading AL with <*(code+n)> as <c>\n    sub al, dl              ; subtracing <m> from <c>\n    add al, 96              ; converting <c> to digit\n    mov [rsp-0h10+rbx], al  ; saving <c> in <*(keytab+n)>\n    inc ebx                 ; incrementing <n>\n    jmp .lpt                ; jumping to the nex .lpt iteration\n.start:\n    xor edi, edi            ; resetting EDI as <i>\n    xor esi, esi            ; resetting ESI as <j>\n    xor eax, eax            ; resetting EAX as <key>; also will be used in conditional move\n    xor ecx, ecx            ; resetting ECX as a duplicate <n> for jumpless\n.lpk:\n    inc edi                 ; incrementing <i>\n    cmp edi, ebx            ; whether <i> is less than <n>\n    jge .exit               ; otherwise, jumping to exit    \n    cmp esi, ebp            ; whether <j> is less than <k>\n    cmovge esi, eax         ; otherwise, resetting <j>\n    mov dl, [rsp-0h10+rsi]  ; loading DL with <*(keytab+j)> as <kj>\n    inc esi                 ; incrementing <j>\n    cmp dl, [rsp-0h10+rdi]  ; whether <kj> is not equal to <*(keytab+i)>\n    je .lpk                 ; otherwise, jumping to the next .lpk iteration\n    mov edi, ebp            ; setting <i> to <k>\n    inc ebp                 ; incrementing <k>\n    xor esi, esi            ; resetting <j>\n    jmp .lpk                ; jumping to the next .lpk iteration\n.loop:\n    movzx ebx, byte [rsp-0h10+rcx]  ; extracting the digit\n    imul eax, 10                    ; shifting <key> one digit left\n    add eax, ebx                    ; adding the digit to <key>\n    inc ecx                         ; incrementing <n>\n.exit:\n    cmp ecx, ebp                    ; whether <n> is less than <k>\n    jl .loop                        ; jumping to the next .loop iteration\n    pop rbx                         ; restoring the original RBX from the stack\n    pop rbp                         ; restoring the original RBP from the stack\n    ret\n; -----> endof find_the_key <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5933a1f8552bc2750a0000ed":[{"id":213684,"user_id":525,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\n  lea rax, [(edi - 1) * 2]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213685,"user_id":null,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\n  lea eax, [edi*2-2]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213686,"user_id":null,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\n  lea rax, [rdi*2-2]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213687,"user_id":168,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\n  lea eax, [2 * (edi - 1)]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213688,"user_id":527,"body":"global nth_even\nsection .text\nnth_even:\n                lea     eax, [2 * (edi - 1)]\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213689,"user_id":null,"body":"SECTION     .text\nglobal      nth_even\n\nnth_even:\n    xor       eax, eax\n    mov       edx, 1\n\n    cmp       edi, 1\n    jz        _exit\n\n    mov       eax, 2\n    imul      eax, edi\n    sub       eax, 2\n    \n_exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213690,"user_id":null,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\n  xor eax, eax\n  mov eax, edi\n  shl eax, 1\n  sub eax, 2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213691,"user_id":null,"body":"section .text\nglobal nth_even\n\nnth_even:\n  lea rax, [rdi + rdi - 2]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213692,"user_id":null,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\n  xor rax, rax\n  mov eax, edi\n  sub eax, 1\n  mov edi, 2\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213693,"user_id":null,"body":"SECTION .text\nglobal nth_even\n\nnth_even:\ndec edi\nshl edi, 1\nmov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59342039eb450e39970000a6":[{"id":213694,"user_id":null,"body":"global oddcnt\n\n; <-- EAX oddcnt(EDI n) -->\noddcnt:\n    ; RDI contains input, RAX will be return value\n    xor rax, rax      ; Zeroes RAX\n    xor rcx, rcx      ; Zeroes RCX\n    xor rdx, rdx      ; Zeroes RDX\n    mov rax, rdi      ; Moves RDI into RAX, dividend is RAX\n    mov rcx, 2        ; Moves 2 into RCX, divisor is RCX\n    div rcx           ; Divides RAX by RCX, quotient in RAX, remainder in RDX\n    ret\n; -----> endof oddcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213695,"user_id":null,"body":"section       .text\n\nglobal        oddcnt\n\noddcnt:\n    xor     rdx, rdx\n    mov     rax, rdi\n    mov     rbx, 2\n    div     rbx\n    \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213696,"user_id":null,"body":"global oddcnt\n\n; <-- EAX oddcnt(EDI n) -->\noddcnt:  dd  -4.65637420654296875E2","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213697,"user_id":null,"body":"global oddcnt\n\noddcnt:\n    mov eax,edi\n    shr eax,1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213698,"user_id":null,"body":"global oddcnt\n\n; <-- EAX oddcnt(EDI n) -->\noddcnt:\n    shr edi, 1\n    mov eax, edi\n    ret\n; -----> endof oddcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213699,"user_id":null,"body":"global oddcnt\n\n; <-- EAX oddcnt(EDI n) -->\noddcnt:\n    mov rax, rdi\n    xor rax, 1\n    shr rax, 1\n    ret\n; -----> endof oddcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213700,"user_id":null,"body":"section .text\nglobal oddcnt\noddcnt:\n  xor edx,edx\n  mov ecx,2\n  div ecx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213701,"user_id":null,"body":"global oddcnt\n\n; <-- EAX oddcnt(EDI n) -->\noddcnt:\n    mov  rax,rdi\n    sar  rax,1\n    ret\n; -----> endof oddcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213702,"user_id":null,"body":"global oddcnt\n\n; <-- EAX oddcnt(EDI n) -->\noddcnt:\n    ;xor eax, eax\n    xor rdx, rdx\n    mov rax, rdi\n    mov r8, 2\n    \n    div r8\n    \n    \n    ret\n; -----> endof oddcnt <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213703,"user_id":864,"body":"global oddcnt\n\noddcnt:\n    mov rax, rdi\n    mov rax, rax\n    and rax, 0x1\n    cmp rax, 0x0\n    je even\n    mov rax, rdi\n    sub rax, 0x1\n    shr rax, 0x1\n    ret\n    \neven:\n    mov rax, rdi\n    shr rax, 0x1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59377c53e66267c8f6000027":[{"id":213704,"user_id":168,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n  xor ecx, ecx\n  mov rdx, table\n  jmp .loop_cond\n.loop:\n  sub al, 'b'\n  cmp al, 25\n  jae .continue\n  add ecx, dword [rdx + rax * 4]\n.continue:\n  inc rdi\n.loop_cond:\n  movzx eax, byte [rdi]\n  test eax, eax\n  jnz .loop\n.end:\n  mov rax, draw\n  mov rsi, left\n  mov rdi, right\n  test ecx, ecx\n  cmovl rax, rdi\n  cmovg rax, rsi\n  ret\n; ---------> end of alphawar <---------\n\nsection .data\n\n;        b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\ntable dd 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0,-4, 0, 0, 3,-3, 0, 1, 0, 0, 0, 4, 0, 0,-1\ndraw  db \"Let's fight again!\", 0\nleft  db \"Left side wins!\", 0\nright db \"Right side wins!\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213705,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n  xor eax, eax\n.loop:\n  movsx rcx, byte [rdi]\n  test rcx, rcx\n  je .done\n  movsx ecx, byte [rcx + .power-98]\n  inc rdi\n  add eax, ecx\n  jmp .loop\n.done:\n  test eax, eax\n  mov eax, .right\n  mov ecx, .left\n  cmovs rcx, rax\n  mov eax, .again\n  cmovne rax, rcx\n  ret\n  \nsection .data\n.power: db 2,0,-2,0,0,0,0,0,0,0,0,-4,0,0,3,-3,0,1,0,0,0,4,0,0,-1\n.again: db \"Let's fight again!\",0\n.right: db \"Right side wins!\",0\n.left: db \"Left side wins!\",0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213706,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    mov rsi, rdi            ; RAX <- the result\n    mov rbx, punches\n    xor rcx, rcx\nloop:  ;===========================\n    lodsb\n    movzx rdx, al\n    sub   rdx, 98\n    \n    movsx r13, byte[rbx + rdx]\n    \n    add rcx, r13\n         \n    test al, al\n    jnz loop\n    ;==============================\n    \n    cmp rcx, 0\n    jl lleft\n    jg lright\n\n    mov rax, again\n    jmp end\n\nlleft:\n    mov rax, left\n    jmp end\n    \nlright:\n    mov rax, right\n    \nend:\n    ret\n; ---------> end of alphawar <---------\n\nsection .data\n\nleft:     db \"Left side wins!\"   , 0h0\nright:    db \"Right side wins!\"  , 0h0\nagain:    db \"Let's fight again!\", 0h0\npunches:  db  -2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, -3, 3, 0, -1, 0, 0, 0, -4, 0, 0, 1, 0h0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213707,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n  xor edx, edx\n  lea rsi, [data]\n  \n.loop:\n  movzx ecx, byte [rdi]\n  inc rdi\n  test ecx, ecx\n  jz .done\n  movsx ecx, byte [rsi+rcx]\n  add edx, ecx\n  jmp .loop\n  \n.done:\n  lea rax, [draw]\n  lea rcx, [left]\n  lea rsi, [right]\n  cmp edx, 0\n  cmovg rax, rcx\n  cmovl rax, rsi\n  ret\n; ---------> end of alphawar <---------\n\nsection .rodata\n\ndata:\n  times 98 db 0\n  db 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, -4, 0, 0, 3, -3, 0, 1, 0, 0, 0, 4, 0, 0, -1\n\nleft: db \"Left side wins!\", 0\nright: db \"Right side wins!\", 0\ndraw: db \"Let's fight again!\", 0\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213708,"user_id":null,"body":"global alphabet_war\n\nsection .data\nstrl : db 'Left side wins!',0\nstrr : db 'Right side wins!',0\nstrd : db \"Let's fight again!\",0\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    mov     rax, strd            ; RAX <- the result\n    xor     rcx, rcx             ; l \n    xor     rdx, rdx             ; r\n    cmp     [rdi], byte 0\n    je      .end\n    .loop:\n    cmp     [rdi], byte 'w'\n    je      .w\n    cmp     [rdi], byte 'p'\n    je      .p\n    cmp     [rdi], byte 'b'\n    je      .b\n    cmp     [rdi], byte 's'\n    je      .s\n    cmp     [rdi], byte 'm'\n    je      .m\n    cmp     [rdi], byte 'q'\n    je      .q\n    cmp     [rdi], byte 'd'\n    je      .d\n    cmp     [rdi], byte 'z'\n    je      .z\n    jmp     .next\n    .w:\n    add     rcx, 4\n    jmp     .next\n    .p:\n    add     rcx, 3\n    jmp     .next\n    .b:\n    add     rcx, 2\n    jmp     .next\n    .s:\n    add     rcx, 1\n    jmp     .next\n\n    .m:\n    add     rdx, 4\n    jmp     .next\n    .q:\n    add     rdx, 3\n    jmp     .next\n    .d:\n    add     rdx, 2\n    jmp     .next\n    .z:\n    add     rdx, 1\n    \n    .next:\n    inc     rdi\n    cmp     [rdi], byte 0\n    jne     .loop\n    .end:\n    cmp     rcx, rdx\n    jl      .r\n    jg      .l\n    ret\n    .l:\n    mov     rax, strl\n    ret\n    .r:\n    mov     rax, strr\n    ret\n; ---------> end of alphawar <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213709,"user_id":null,"body":"global alphabet_war\n\nsection .text\nalphabet_war:\n  mov rsi, rdi\n  call left_score\n  mov edx, eax\n  mov rsi, rdi\n  call right_score\n  cmp edx, eax\n  jl right\n  jg left\n  mov rax, str_draw\n  jmp end\nright:\n  mov rax, str_right\n  jmp end\nleft:\n  mov rax, str_left\nend:\n  ret\n\nleft_score:\n  xor eax, eax\ntopl:\n  mov cl, byte [rsi]\n  cmp cl, 0\n  je exitl\n  cmp cl, \"w\"\n  jne p\n  add eax, 4\np:\n  cmp cl, \"p\"\n  jne b\n  add eax, 3\nb:\n  cmp cl, \"b\"\n  jne s\n  add eax, 2\ns:\n  cmp cl, \"s\"\n  jne ll\n  add eax, 1\nll:\n  inc rsi\n  jmp topl\nexitl:\n  ret\n\nright_score:\n  xor eax, eax\ntopr:\n  mov cl, byte [rsi]\n  cmp cl, 0\n  je exitr\n  cmp cl, \"m\"\n  jne q\n  add eax, 4\nq:\n  cmp cl, \"q\"\n  jne d\n  add eax, 3\nd:\n  cmp cl, \"d\"\n  jne z\n  add eax, 2\nz:\n  cmp cl, \"z\"\n  jne rr\n  add eax, 1\nrr:\n  inc rsi\n  jmp topr\nexitr:\n  ret\n\nsection .data\nstr_draw: db \"Let's fight again!\", 0\nstr_left: db \"Left side wins!\", 0\nstr_right: db \"Right side wins!\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213710,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    mov rcx, -1\n    xor edx, edx\n    xor eax, eax\n    .loop:\n      inc rcx\n      mov al, [rdi+rcx]\n      test rax, rax\n      jz .end\n      cmp rax, 'w'\n      je .w\n      cmp rax, 'p'\n      je .p\n      cmp rax, 'b'\n      je .b\n      cmp rax, 's'\n      je .s\n      cmp rax, 'm'\n      je .m\n      cmp rax, 'q'\n      je .q\n      cmp rax, 'd'\n      je .d\n      cmp rax, 'z'\n      je .z\n      jmp .loop\n    .w:\n      sub rdx, 4\n      jmp .loop\n    .p:\n      sub rdx, 3\n      jmp .loop\n    .b:\n      sub rdx, 2\n      jmp .loop\n    .s:\n      dec rdx\n      jmp .loop\n    .m:\n      add rdx, 4\n      jmp .loop\n    .q:\n      add rdx, 3\n      jmp .loop\n    .d:\n      add rdx, 2\n      jmp .loop\n    .z:\n      inc rdx\n      jmp .loop\n    .end:\n      cmp rdx, 0\n      jg .end_right\n      jl .end_left\n      mov rax, same\n      ret\n    .end_right:\n      mov rax, right\n      ret\n    .end_left:\n      mov rax, left\n      ret\n; ---------> end of alphawar <---------\n\nsection .data\n  right: db \"Right side wins!\", 0\n  left: db \"Left side wins!\", 0\n  same:  db \"Let's fight again!\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213711,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    xor     rcx,rcx             ; sum powers in rcx\n    mov     rsi,table           ; base address of power table\n    jmp     .start\n.loop:\n    movsx   rax,byte [rsi+rax]  ; translate chr to power\n    add     rcx,rax\n.start:    \n    movzx   rax,byte [rdi]      ; load next char\n    inc     rdi\n    test    al,al               ; 0 terminates the string\n    jnz     .loop\n    cmp     rcx,0\n    cmovz   rax,[adr_msg_equal] ; rax = result string\n    cmovg   rax,[adr_msg_left]\n    cmovl   rax,[adr_msg_right]\n    ret\n; ---------> end of alphawar <---------\n\nsection .data\n\n; Messages\nmsg_equal:  db \"Let's fight again!\",0\nmsg_left:   db \"Left side wins!\",0\nmsg_right:  db \"Right side wins!\",0\n\n; Addresses of the messages\nadr_msg_equal dq msg_equal\nadr_msg_left  dq msg_left\nadr_msg_right dq msg_right\n\n; Translation table ASCII to war power\n; left side letters: positive values\n; rught side letters: negative values\ntable:\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0,-4, 0, 0\n    db 3,-3, 0, 1, 0, 0, 0, 4, 0, 0,-1, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213712,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    mov rax, str            ; RAX <- the result\n    xor r15, r15 \n    xor r14, r14 \nnext_iter:\n    \n    mov al, [rdi]\n    cmp al, 'w'\n    jz _addL_4\n    cmp al, 'p'\n    jz _addL_3\n    cmp al, 'b'\n    jz _addL_2\n    cmp al, 's'\n    jz _addL_1\n    \n    cmp al, 'm'\n    jz _addR_4\n    cmp al, 'q'\n    jz _addR_3\n    cmp al, 'd'\n    jz _addR_2\n    cmp al, 'z'\n    jz _addR_1\n    jmp normal\n    \n  _addL_4:\n    add r15, 4\n    jmp normal\n  _addL_3:\n    add r15, 3\n    jmp normal\n  _addL_2:\n    add r15, 2\n    jmp normal\n  _addL_1:\n    add r15, 1\n    jmp normal\n  \n  _addR_4:\n    add r14, 4\n    jmp normal\n  _addR_3:\n    add r14, 3\n    jmp normal\n  _addR_2:\n    add r14, 2\n    jmp normal\n  _addR_1:\n    add r14, 1\n  \n    \nnormal:\n    add rdi, 1\n    \n    cmp al, 0\n    jz _end\n    jmp next_iter\n_end:    \n    cmp r15, r14\n    jl _ret_right\n    jg _ret_left\n    mov rax, str\n    ret\n_ret_right:\n    mov rax, strR\n    ret\n_ret_left:\n    mov rax, strL\n    ret\n; ---------> end of alphawar <---------\n\nsection .data\n\nstr:  db \"Let's fight again!\",0h0\nstrR: db \"Right side wins!\",0h0\nstrL: db \"Left side wins!\", 0h0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213713,"user_id":null,"body":"global alphabet_war\nalphabet_war:\n  xor rdx,rdx\n  .b:movzx rax,byte[rdi]\n     add   dl,[power+rax]\n     inc   rdi\n     cmp   byte[rdi],0\n  jne .b   \n  test  dl,dl\n  setg  dl\n  setl  al\n  sub   rdx,rax\n  mov   rax,[txt+rdx*8+8]\nret\npower resq 12\n        dq  0x0000000200FE0000,0x0000040000000000,0xFC000000FF0003FD,0x0000000000010000\n      resq 16         \ntxt   dq a,b,c\na     db \"Left side wins!\",0\nb     db \"Let's fight again!\",0\nc     db \"Right side wins!\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5938f5b606c3033f4700015a":[{"id":213714,"user_id":null,"body":"global alphabet_war\n\nsection .text\n\nalphabet_war:\n  mov al, [rdi]\n  mov edx, .again\n  test al, al\n  je .done\n  xor ecx, ecx\n  cmp byte [rdi+1], 42\n  je .checkend\n  sub eax, 98\n  cmp al, 24\n  ja .checkend\n  movzx eax, al\n  movsx ecx, byte [rax+.parr]\n  jmp .checkend\n.loop:\n  xor edx, edx\n  cmp byte [rdi], 42\n  jne .nobombleft\n.next:\n  add ecx, edx\n  inc rdi\n.checkend:\n  mov al, [rdi+1]\n  test al, al\n  jne .loop\n  jmp .message\n.nobombleft:\n  cmp byte [rdi+2], 42\n  je .next\n  sub eax, 98\n  cmp al, 24\n  ja .next\n  movzx eax, al\n  movsx edx, byte [rax+.parr]\n  jmp .next\n.message:\n  test ecx, ecx\n  mov edx, .again\n  je .done\n  mov edx, .right\n  mov eax, .left\n  cmovs rdx, rax\n.done:\n  mov rax, rdx\n  ret\n\nsection .data\n\n.again: db \"Let's fight again!\",0\n.right: db \"Right side wins!\",0\n.left: db \"Left side wins!\",0\n.parr: db -2,0,2,0,0,0,0,0,0,0,0,4,0,0,-3,3,0,-1,0,0,0,-4,0,0,1\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213715,"user_id":null,"body":"global alphabet_war\n\nsection .data\n\nres:  db \"Let's fight again!\",0h0\nleft_win_str: db  \"Left side wins!\", 0\nright_win_str:  db  \"Right side wins!\", 0\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    xor r9, r9; left side\n    xor r10, r10; right side\n    xor rcx, rcx\n    loop:\n    cmp byte [rdi+rcx], 0x00\n    je loop_end\n    cmp rcx, 0x00\n    je skip_prev_check\n    cmp byte [rdi+rcx-1], '*'\n    je char_is_dead\n    skip_prev_check:\n    cmp byte [rdi+rcx+1], '*'\n    je char_is_dead\n    \n    cmp byte [rdi+rcx], 'w'\n    jne skip_w\n    add r9, 4\n    skip_w:\n    cmp byte [rdi+rcx], 'p'\n    jne skip_p\n    add r9, 3\n    skip_p:\n    cmp byte [rdi+rcx], 'b'\n    jne skip_b\n    add r9, 2\n    skip_b:\n    cmp byte [rdi+rcx], 's'\n    jne skip_s\n    add r9, 1\n    skip_s:\n    cmp byte [rdi+rcx], 'm'\n    jne skip_m\n    add r10, 4\n    skip_m:\n    cmp byte [rdi+rcx], 'q'\n    jne skip_q\n    add r10, 3\n    skip_q:\n    cmp byte [rdi+rcx], 'd'\n    jne skip_d\n    add r10, 2\n    skip_d:\n    cmp byte [rdi+rcx], 'z'\n    jne skip_z\n    add r10, 1\n    skip_z:\n    char_is_dead:\n    inc rcx\n    jmp loop\n    loop_end:\n    \n    cmp r9, r10\n    jg left_win\n    jl right_win\n    mov rax, res\n    ret\n    \n    left_win:\n    mov rax, left_win_str\n    ret\n    right_win:\n    mov rax, right_win_str\n    ret\n; ---------> end of alphawar <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213716,"user_id":null,"body":"global alphabet_war\n\nsection .data\n\ntie:  db \"Let's fight again!\",0\nlsw:  db \"Left side wins!\",0\nrsw:  db \"Right side wins!\",0\n\npower:\n      ;  a   b   c  d  e   f  g  h  i   j  k  l  m \n      db 0, -2,  0, 2, 0,  0, 0, 0, 0,  0, 0, 0, 4 \n      db 0,  0, -3, 3, 0, -1, 0, 0, 0, -4, 0, 0, 1\n      ;  n   o   p  q  r   s  t  u  v   w  x  y  z\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    mov rsi, rdi\n    xor dx, dx        ; total score\n.loop:\n    xor rax, rax\n    lodsb\n    test al, al\n    jz .done \n    cmp byte [rsi-2], '*' ; is there a bomb to the left?\n    je .loop              ; then this letter does not count\n    cmp byte [rsi], '*'   ; is there a bomb to the right?\n    je .loop              ; then this letter does not count\n    sub al, 'a'           ; valid letter?\n    jb .loop              ; if not then skip it\n    mov al, [power + rax] ; otherwise it counts\n    cbw \n    add dx, ax\n    jmp .loop\n.done:\n    test dx, dx           ; how is the score?\n    mov rax, tie\n    jz .out               ; 0 = tie\n    mov rax, lsw\n    js .out               ; < 0 = left side win\n    mov rax, rsw          ; > 0 = right side win \n.out:\n    ret\n; ---------> end of alphawar <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213717,"user_id":null,"body":"global alphabet_war\n\nsection .data\n\nstalematestr:  db \"Let's fight again!\",0h0\nleftwinstr:  db \"Left side wins!\",0h0\nrightwinstr:  db \"Right side wins!\",0h0\n\nsection .text\n\n%macro letter 2\n  cmp sil, %1\n  jne %%next\n  add rax, %2\n  jmp .inc\n%%next:\n%endmacro\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n  xor rax, rax ; 0 out rax, used to keep score\n  mov r8, rdi  ; store start position in r8\n  jmp .strcond\n.strloop:\n  cmp sil, '*' ; if letter is bomb\n  je .inc\n\n  cmp r8, rdi ; if str pointer is at start dont check to left\n  je .atstart\n  cmp byte [rdi - 1], '*' ; if bomb to left skip score\n  je .inc\n.atstart:\n  cmp byte [rdi + 1], '*' ; if bomb to right skip score\n  je .inc\n  letter 'w', -4\n  letter 'p', -3\n  letter 'b', -2\n  letter 's', -1\n  letter 'm', 4\n  letter 'q', 3\n  letter 'd', 2\n  letter 'z', 1\n\n.inc:\n  inc rdi\n.strcond:\n  mov sil, [rdi]\n  test sil, sil\n  jnz .strloop   ; loop until null terminator\n\n  cmp rax,0\n  je .stalemate\n  jl .leftwins\n  mov rax, rightwinstr\n  ret\n.stalemate:\n  mov rax, stalematestr\n  ret\n.leftwins:\n  mov rax, leftwinstr\n  ret\n; ---------> end of alphawar <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213718,"user_id":null,"body":"global alphabet_war\n\nsection .data\n\ndraw:  db \"Let's fight again!\", 0x0\nleft_win: db \"Left side wins!\", 0x0\nright_win: db \"Right side wins!\", 0x0\n\nsection .text\n\nalphabet_war:\n    push rdi\n\n    xor r10, r10\n    xor r11, r11\n    xor r15, r15\n\n.iterate:\n    cmp byte [rdi], 0x0\n    je .exit\n\n    call chk_alive\n    cmp rax, 0\n    je .go_ahead\n\n.add_scores:\n    call calc_left_score\n    call calc_right_score\n\n.go_ahead:\n    inc rdi\n    jmp .iterate\n\n.exit:\n    pop rdi\n\n    cmp r10, r11\n    je .ret_draw\n    jl .ret_right\n    jmp .ret_left\n\n.ret_draw:\n    mov rax, draw\n    ret\n\n.ret_right:\n    mov rax, right_win\n    ret\n\n.ret_left:\n    mov rax, left_win\n    ret\n\n\nchk_alive:\n    cmp byte [rdi], '*'\n    je .set_skip_flag\n\n    cmp r15, 1\n    je .del_skip_flag\n\n    call is_next_bomb\n    cmp rax, 1\n    je .ret_false\n\n    jmp .ret_true\n\n.del_skip_flag:\n    xor r15, r15\n    jmp .ret_false\n\n.set_skip_flag:\n    mov r15, 1\n    jmp .ret_false\n\n.ret_true:\n    mov rax, 1\n    ret\n\n.ret_false:\n    xor rax, rax\n    ret\n\n\nis_next_bomb:\n    xor rax, rax\n\n    cmp byte [rdi + 1], '*'\n    jne .exit\n\n    inc rax\n.exit:\n    ret\n\n\n\ncalc_left_score:\n    ; w - 4\n    ; p - 3 \n    ; b - 2\n    ; s - 1\n\n    mov al, byte[rdi]\n\n.chk_w:\n    cmp al, 'w'\n    jne .chk_p\n    add r10, 4\n    ret\n\n.chk_p:\n    cmp al, 'p'\n    jne .chk_b\n    add r10, 3\n    ret\n\n.chk_b:\n    cmp al, 'b'\n    jne .chk_s\n    add r10, 2\n    ret\n\n.chk_s:\n    cmp al, 's'\n    jne .exit\n    add r10, 1\n\n.exit:\n    ret\n\n\n\ncalc_right_score:\n    ; m - 4\n    ; q - 3 \n    ; d - 2\n    ; z - 1\n    mov al, byte[rdi]\n\n.chk_m:\n    cmp al, 'm'\n    jne .chk_q\n    add r11, 4\n    ret\n\n.chk_q:\n    cmp al, 'q'\n    jne .chk_d\n    add r11, 3\n    ret\n\n.chk_d:\n    cmp al, 'd'\n    jne .chk_z\n    add r11, 2\n    ret\n\n.chk_z:\n    cmp al, 'z'\n    jne .exit\n    add r11, 1\n\n.exit:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213719,"user_id":null,"body":"global alphabet_war\n\nsection .data\n\ndraw:  db \"Let's fight again!\", 0\nleft: db \"Left side wins!\", 0\nright: db \"Right side wins!\", 0\nscores: dq 0, -1, -2, -3, -4, 1, 2, 3, 4\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    push rbx            ; ran out of volatile registers \n    xor rbx, rbx        ; is used to cache current char for loop exit checking\n    xor rcx, rcx        ; current bomb flag\n    xor rdx, rdx        ; previous bomb flag \n    xor r8, r8          ; current char\n    xor r9, r9          ; previous char\n    mov r10, '0'        ; for use by cmov.. - a non-scoring character that can be used to overwrite a bombedout one, and also as a non-zero flag\n    xor r11, r11        ; running total - negative is points for left, positive for right\n    .string_loop:\n        mov r9, r8      ; current to previous\n        mov rdx, rcx    ; current bomb flag to previous bomb flag\n        xor rcx, rcx    ; clear current bomb flag\n        mov r8b, [rdi]  ; get new current\n        inc rdi         ; move string pointer\n        cmp r8b, '*'    ; check current char for bomb\n        cmove r9, r10   ; if bomb, overwrite previous char with non-scoring char\n        cmove rcx, r10  ; if bomb, set current bomb flag non-zero\n        mov rbx, r8     ; save unmodified character so it can be checked for a null at end of loop check\n        test rdx, rdx   ; check previous bomb flag,\n        cmovnz r8, r10  ; and overwrite current char if found (already set flag if it is a bomb)        \n        ; score previous char.  Wanted to avoid jumps, no idea if this repeated test and cmov\n        ; is more efficent, especially since it requires memory access as cmov won't take a literal\n        xor rax, rax\n        cmp r9, 'w'\n        cmove rax, [scores + 32]   \n        cmp r9, 'p'\n        cmove rax, [scores + 24]    \n        cmp r9, 'b'\n        cmove rax, [scores + 16]    \n        cmp r9, 's'\n        cmove rax, [scores + 8]     \n        cmp r9, 'm'\n        cmove rax, [scores + 64]      \n        cmp r9, 'q'\n        cmove rax, [scores + 56]    \n        cmp r9, 'd'\n        cmove rax, [scores + 48]    \n        cmp r9, 'z'\n        cmove rax, [scores + 40]      \n        add r11, rax                              \n        test bl, bl     ; test current char (unmodified saved in least significent byte of rbx)\n    jnz .string_loop    ; and exit loop if terminator found    \n    test r11, r11\n    js .left\n    je .draw    \n    mov rax, right\n    pop rbx\n    ret\n    .left:\n    mov rax, left\n    pop rbx\n    ret\n    .draw:\n    mov rax, draw\n    pop rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213720,"user_id":743,"body":"global alphabet_war\n\nsection .rodata\n\nTab times 'a' dd 0\n    dd 0, 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, -4\n    dd 0, 0, 3, -3, 0, 1, 0, 0, 0, 4, 0, 0, -1\n\nsection .data\n\nLWin  db \"Left side wins!\", 0\nRWin  db \"Right side wins!\", 0\nAgain db \"Let's fight again!\", 0\n\nsection .text\n\n; rax                            rdi\n; char* alphabet_war(const char* fight)\nalphabet_war:\n  xor ecx, ecx\n  xor eax, eax\n  mov al, [rdi]\n  test eax ,eax\n  jz .endl\n  cmp eax, '*'\n  je .loop\n  cmp byte [rdi + 1], '*'\n  je .loop\n  add ecx, [Tab + rax * 4]\n.loop:\n  add rdi, 1\n  mov al, [rdi]\n  test eax, eax\n  jz .endl\n.loop_:\n  cmp eax, '*'\n  je .loop\n  cmp byte [rdi - 1], '*'\n  je .loop\n  cmp byte [rdi + 1], '*'\n  je .loop\n  add ecx, [Tab + rax * 4]\n  add rdi, 1\n  mov al, [rdi]\n  test eax, eax\n  jnz .loop_\n.endl:\n  mov rax, LWin\n  test ecx, ecx\n  mov rdx, Again\n  mov rcx, RWin\n  cmovz rax, rdx\n  cmovs rax, rcx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213721,"user_id":168,"body":"global alphabet_war\n\nsection .data\n\n;        b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\ntable dd 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0,-4, 0, 0, 3,-3, 0, 1, 0, 0, 0, 4, 0, 0,-1\ndraw  db \"Let's fight again!\", 0\nleft  db \"Left side wins!\", 0\nright db \"Right side wins!\", 0\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n  xor eax, eax\n  xor ecx, ecx\n  movzx esi, byte [rdi]\n  jmp .continue\n.loop:\n  movzx esi, byte [rdi]\n  cmp al, '*'\n  je .continue\n  cmp dl, '*'\n  je .continue\n  cmp sil, '*'\n  je .continue\n  sub al, 'b'\n  cmp al, 25\n  jae .continue\n  add ecx, dword [table + rax * 4]\n.continue:\n  inc rdi\n  mov edx, eax\n  mov eax, esi\n  test eax, eax\n  jnz .loop\n.end:\n  mov rax, draw\n  mov rsi, left\n  mov rdi, right\n  test ecx, ecx\n  cmovl rax, rdi\n  cmovg rax, rsi\n  ret\n; ---------> end of alphawar <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213722,"user_id":null,"body":"global alphabet_war\n\nsection .data\n\nalpha:  db  'w','p','b','s','z','d','q','m',0h0\npower:  dd  -4, -3, -2, -1,  1,  2,  3,  4\nagain:  db \"Let's fight again!\",0h0\nright:  db \"Right side wins!\",0h0\nleft:   db \"Left side wins!\",0h0\n\nsection .text\n\n; <----- char *alphabet_war(const char *fight) ----->\nalphabet_war:\n    xor ecx, ecx            ; resetting ECX as <score>\n    xor eax, eax            ; resetting EAX as <pwr>\n    mov r8, again           ; copying <again> to R8 to use in conditional mov\n    mov r9, right           ; copying <right> to R9 to use in conditional mov\n    mov r10, left           ; copying <left> to R10 to use in conditional mov\n.loop:\n    add ecx, eax            ; adding <pwr> to <score>\n    mov dl, [rdi]           ; copying <*fight> to DL as <c>\n    test dl, dl             ; whether <c> is an empty character\n    je .exit                ; jumping to exit\n    inc rdi                 ; moving <fight> to the next character\n    xor eax, eax            ; resetting <pwr>\n    xor r11, r11            ; resetting R11 as the alpha-power <i> index\n    cmp byte [rdi], '*'     ; whether <*(fight+1)> is '*'\n    je .loop                ; jumping to the next iteration\n    cmp dl, '*'             ; whether <c> is '*'\n    jne .alphaloop          ; otherwise, jumping to the .alphaloop section\n    cmp byte [rdi], 0       ; whether <*(fight+1)> is not an empty character\n    je .loop                ; otherwise, jumping to the next iteration\n    inc rdi                 ; moving <fight> to the next character\n    jmp .loop               ; jumping to the next iteration\n.alphaloop:\n    mov sil, [alpha+r11]    ; copying <*alpha> to SIL as <a>\n    test sil, sil           ; whether <a> is an empty character\n    je .loop                ; jumping to the next iteration\n    cmp dl, sil             ; whether <c> is equal to <alph>\n    cmove eax, [power+r11*4]; copying to <pwr> <*power>\n    je .loop                ; jumping to the next .loop iteration\n    inc r11                 ; incremening <i>\n    jmp .alphaloop          ; jumping to the next .alphaloop iteration\n.exit:\n    test ecx, ecx           ; whether <score> is zero\n    cmove rax, r8           ; copying <again> to RAX\n    cmovg rax, r9           ; otherwise, if greater, copying <right> to RAX\n    cmovl rax, r10          ; otherwise, if less, copying <left> to RAX\n    ret\n; ---------> end of alphawar <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"593e2077edf0d3e2d500002d":[{"id":213723,"user_id":null,"body":"global alphabet_war\nextern malloc, strlen\n\nsection .bss\ncounter: resd 512\nresb 1\ncheck: resb 511\n\nsection .text\n\n; <--- char *alphabet_war(const char *reinforces[], const char *airstrikes[], size_t nreinforce, size_t nairstrike) --->\n;  params:\n;    rdi <- reinforces\n;    rsi <- airstrikes\n;    rdx <- nreinforce\n;    rcx <- nairstrike\nalphabet_war:\n  push rdi\n  push rdx\n  sub rsp, 8\n\n  mov r9, rcx\n  lea r10, [counter]\n  mov rdi, r10\n  mov rcx, 256\n  xor eax, eax\n  rep stosq\n  lea r8, [check]\n  \n.loop1:\n  lea rdi, [r8-1]\n  mov rcx, 64\n  xor eax, eax\n  rep stosq\n  \n  mov rdi, [rsi]\n  xor ecx, ecx\n.loop2:\n  mov al, [rdi]\n  cmp al, '*'\n  jne .skip1\n  mov byte [r8+rcx-1], 1\n  mov byte [r8+rcx], 1\n  mov byte [r8+rcx+1], 1\n.skip1:\n  inc rdi\n  inc rcx\n  test al, al\n  jnz .loop2\n  \n.loop21:\n  dec rcx\n  cmp byte [r8+rcx], 0\n  jz .skip2\n  inc dword [r10+rcx*4]\n.skip2:\n  test rcx, rcx\n  jnz .loop21\n  \n  add rsi, 8\n  dec r9\n  jnz .loop1\n    \n  mov rdi, [rsp+16]\n  mov rdi, [rdi]\n  call strlen\n  mov [rsp], rax\n  lea rdi, [rax+1]\n  call malloc\n  test rax, rax\n  jz .quit\n\n  lea rsi, [counter]\n  mov rdx, [rsp+8]\n  mov r8, [rsp+16]\n  mov r9, [rsp]\n  mov byte [rax+r9], 0\n  \n.loop3:\n  dec r9\n  mov ecx, [rsi+r9*4]\n  cmp ecx, edx\n  jge .empty\n  mov rdi, [r8+rcx*8]\n  mov dil, [rdi+r9]\n  mov [rax+r9], dil\n  jmp .next\n.empty:\n  mov byte [rax+r9], '_'\n.next:\n  inc rdi\n  test r9, r9\n  jnz .loop3\n  \n.quit:\n  add rsp, 24\n  ret\n; ---------> end of alphabet_war <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213724,"user_id":null,"body":"global alphabet_war\nextern calloc, free, malloc, memset, strlen\n\nsection .data\n\ncws:  db  \"codewars\",0h0\n\nsection .text\n\nalphabet_war:\n  push rbp\n  push r15\n  push r14\n  push r13\n  push r12\n  push rbx\n  sub rsp, 40\n  mov [rsp + 16], rdi\n  mov rdi, [rdi]\n  mov rbp, rcx\n  mov [rsp + 24], rdx\n  mov r14, rsi\n  call strlen\n  mov r15, rax\n  lea rbx, [rax + 2]\n  mov rsi, 8\n  mov rdi, rbx\n  call calloc\n  mov r13, rax\n  mov rsi, 1\n  mov rdi, rbx\n  mov [rsp + 32], rbx\n  call calloc\n  mov [rsp + 8], r15\n  mov rbx, rax\n  inc r15\n  xor r12d, r12d\n.strikeloop:\n  cmp r12, rbp\n  je .endstrikes\n  mov rax, [r14 + 8*r12]\n  xor ecx, ecx\n.acchitloop:\n  mov dl, [rax + rcx]\n  cmp dl, 42\n  je .ast\n  test dl, dl\n  jne .nextbomb\n  jmp .addcasualties\n.ast:\n  mov word [rbx + rcx], 257\n  mov byte [rbx + rcx + 2], 1\n.nextbomb:\n  inc rcx\n  jmp .acchitloop\n.addcasualties:\n  mov rax, 1\n.casualtyloop:\n  cmp rax, r15\n  ja .adddone\n  movzx ecx, byte [rbx + rax]\n  add [r13 + 8*rax], rcx\n  inc rax\n  jmp .casualtyloop\n.adddone:\n  mov rdx, [rsp + 32]\n  mov rdi, rbx\n  xor esi, esi\n  call memset\n  inc r12\n  jmp .strikeloop\n.endstrikes:\n  mov rdi, r15\n  call malloc\n  mov rsi, [rsp + 24]\n  mov r8, [rsp + 16]\n  mov rdi, [rsp + 8]\n  mov rbp, rax\n  xor eax, eax\n.lastreinfloop:\n  cmp rdi, rax\n  je .done\n  mov rdx, [r13 + 8*rax + 8]\n  mov cl, 95\n  cmp rdx, rsi\n  jae .emptyground\n  mov rcx, [r8 + 8*rdx]\n  mov cl, byte [rcx + rax]\n.emptyground:\n  mov byte [rbp + rax], cl\n  inc rax\n  jmp .lastreinfloop\n.done:\n  mov byte [rbp + rdi], 0\n  mov rdi, r13\n  call free\n  mov rdi, rbx\n  call free\n  mov rax, rbp\n  add rsp, 40\n  pop rbx\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213725,"user_id":743,"body":"global alphabet_war\nextern malloc\n\nsection .data\n\nsection .text\n\n; rax                            rdi                       rsi                  rdx                rcx\n; char* alphabet_war(const char* reinforces[], const char* airstrikes[], size_t nreinforce, size_t nairstrike);\n; \nalphabet_war:\n  push rbx  ; len\n  push r12  ; rf_beg\n  push r13  ; as_beg\n  push r14  ; rf_end\n  push r15  ; as_end\n  mov r12, rdi\n  lea r14, [rdi + rdx * 8]\n  mov r13, rsi\n  lea r15, [rsi + rcx * 8]\n  mov rdi, [r12]\n  xor eax, eax\n  mov rcx, -1\n  repne scasb\n  mov rbx, -2\n  sub rbx, rcx\n  lea rdi, [rbx * 8 + 8]\n  call malloc\n  mov rdi, rax\n  mov r11, rax\n  mov rax, r12\n  mov rcx, rbx\n  rep stosq\n.loop1:\n  mov rsi, [r13]\n  xor ecx, ecx\n  mov r8d, 1\n  xor r9d, r9d\n.loop2:\n  movzx eax, byte [rsi + rcx]\n  test eax, eax\n  jz .endl2\n.loop2_:\n  cmp eax, '*'\n  jne .incl2\n  test r8d, r8d\n  jnz .nol\n  add qword [r11 + rcx * 8 - 8], 8\n.nol:\n  test r9d, r9d\n  jnz .nom\n  add qword [r11 + rcx * 8], 8\n  mov r9d, 1\n.nom:\n  add qword [r11 + rcx * 8 + 8], 8\n  xor r10d, r10d\n.incl2:\n  mov r8d, r9d\n  setz r9b\n  add rcx, 1\n  movzx eax, byte [rsi + rcx]\n  test eax, eax\n  jnz .loop2_\n.endl2:\n  add r13, 8\n  cmp r13, r15\n  jb .loop1\n  mov rdi, r11\n  xor rcx, rcx\n.loop3:\n  mov rsi, [r11 + rcx * 8]\n  mov eax, '_'\n  cmp rsi, r14\n  jnb .sto\n  mov rsi, [rsi]\n  movzx eax, byte [rsi + rcx]\n.sto:\n  stosb\n  add rcx, 1\n  cmp rcx, rbx\n  jb .loop3\n  mov byte [rdi], 0\n  mov rax, r11\n  pop r15\n  pop r14\n  pop r13\n  pop r12\n  pop rbx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213726,"user_id":168,"body":"global alphabet_war\nextern malloc, calloc, strlen, free\n\nsection .data\n\nsection .text\n\n; <--- char *alphabet_war(const char *reinforces[], const char *airstrikes[], size_t nreinforce, size_t nairstrike) --->\n;  params:\n;    rdi <- reinforces\n;    rsi <- airstrikes\n;    rdx <- nreinforce\n;    rcx <- nairstrike\nalphabet_war:\n  push rbx ; reinforces\n  push rbp ; airstrikes\n  push r15 ; nreinforce\n  push r14 ; nairstrike\n  push r13 ; strlen(reinforces[0])\n  mov rbx, rdi\n  mov rbp, rsi\n  mov r15, rdx\n  mov r14, rcx\n  mov rdi, qword [rbx]\n  call strlen\n  mov r13, rax\n  mov rdi, rax\n  mov esi, 4\n  call calloc\n  sub rax, 4  ; adjust rax by -1 element\n  xor ecx, ecx\n  jmp .loop1_cond\n.loop1:\n  mov rsi, qword [rbp + 8 * rcx]\n  inc rcx\n  movzx edi, byte [rsi]  ; edi = next\n  xor r9, r9             ; edx = prev, r9 = current\n  xor r8, r8             ; inner counter\n  jmp .inner_loop_cond\n.inner_loop:\n  movzx edi, byte [rsi + r8]\n  cmp dl, '*'\n  je .inc\n  cmp r9b, '*'\n  je .inc\n  cmp dil, '*'\n  jne .inner_loop_cond\n.inc:\n  inc dword [rax + 4 * r8]\n.inner_loop_cond:\n  inc r8\n  mov edx, r9d\n  mov r9d, edi\n  test r9d, r9d\n  jnz .inner_loop\n.inner_loop_end:\n  cmp r8, r13\n  ja .loop1_cond\n  cmp dl, '*'\n  sete dl\n  add dword [rax + 4 * r8], edx\n.loop1_cond:\n  cmp rcx, r14\n  jb .loop1\n  lea rbp, [rax + 4]  ; positions\n  lea rdi, [r13 + 1]\n  call malloc\n  xor ecx, ecx\n  jmp .loop2_cond\n.loop2:\n  mov edx, '_'\n  mov edi, dword [rbp + rcx * 4]\n  cmp rdi, r15\n  jae .continue2\n  mov rdi, qword [rbx + rdi * 8]\n  movzx edx, byte [rdi + rcx]\n.continue2:\n  mov byte [rax + rcx], dl\n  inc rcx\n.loop2_cond:\n  cmp rcx, r13\n  jb .loop2\n  mov byte [rax + rcx], 0\n  mov rbx, rax\n  mov rdi, rbp\n  call free\n  mov rax, rbx\n  pop r13\n  pop r14\n  pop r15\n  pop rbp\n  pop rbx\n  ret\n; ---------> end of alphabet_war <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213727,"user_id":null,"body":"global alphabet_war\nextern malloc, strlen\n\nsection .text\n\n; <--- char *alphabet_war(const char *reinforces[], const char *airstrikes[], size_t nreinforce, size_t nairstrike) --->\nalphabet_war:\n    push r15                    ; saving R15 in the stack\n    push r14                    ; saving R14 in the stack\n    push r13                    ; saving R13 in the stack\n    push r12                    ; saving R12 in the stack\n    push rbx                    ; saving RBX in the stack\n    mov r12, rdi                ; copying <reinforces> to R12\n    mov r13, rsi                ; copying <airstrikes> to R13\n    mov r14, rdx                ; copying <nreinforce> to R14\n    mov r15, rcx                ; copying <nairstrike> to R15\n    mov rdi, [rdi]              ; copying <*reinforces> to RDI\n    call strlen                 ; counting the character length\n    mov rbx, rax                ; saving as <len> in RBX\n    inc rax                     ; adding an extra byte for the null character\n    mov rdi, rax                ; copying <len+1> to RDI as a parameter for malloc\n    call malloc                 ; allocating memory\n    test rax, rax               ; whether the memory is allocated\n    je .exit                    ; otherwise, jumping to exit\n    mov byte [rax+rbx], 0       ; copying the null character to <*(field+len)>\n    imul rdx, r15, 8            ; the storage for <airlen> to keep lengths of <airstrikes>\n    sub rsp, rdx                ; allocating the storage in the stack\n    xor rcx, rcx                ; resetting RCX as <i>\n    xor rsi, rsi                ; resetting RSI as <pos>\n    dec rsi                     ; decrementing <pos> to start with zero in the .airloop section\n.airloop:\n    inc rsi                     ; incrementing <pos>\n    cmp rcx, r15                ; whether <i> is less than <nairstrike>\n    jge .fieldini               ; otherwise, jumping to the .fieldini section\n    mov r8, [r13+rcx*8]         ; copying <*(airstrikes+i)> to R8\n    cmp byte [r8+rsi], 0        ; whether <*(*(airstrikes+i)+pos> is the null character\n    jne .airloop                ; otherwise, jumping to the next airloop iteration\n    mov [rsp+rcx*8], rsi        ; saving <pos> in <*(airlen+i)>\n    mov rsi, -1                 ; setting <pos> to minus to start the loop with zero\n    inc rcx                     ; incrementing <i>\n    jmp .airloop                ; jumping to the next airloop iteration\n.fieldini:\n    xor rsi, rsi                ; resetting RSI as <pos>\n    xor rcx, rcx                ; resetting RCX as <i>\n    xor r9, r9                  ; resetting R9 as <inx>\n.fieldloop:\n    cmp rsi, rbx                ; whether <pos> is less than <len>\n    jge .preexit                ; otherwise, jumping to the .preexit section\n    cmp rcx, r15                ; whether <i> is greater or equal to <nairstrike>\n    jl .fieldset                ; otherwise, jumping to the .fieldset section\n    mov cl, '_'                 ; copying the strike character to CL as <c>\n    cmp r9, r14                 ; whether <inx> is less than <nreinforce>\n    jge .fieldappl              ; otherwise, jumping to the .fieldappl section\n    mov rdi, [r12+r9*8]         ; copying <*(reinforces+inx)> to RDI\n    mov cl, [rdi+rsi]           ; copying <*(*(reinforces+inx)+pos)> to <c>\n.fieldappl:\n    mov [rax+rsi], cl           ; copying <c> to <*(field+pos)>\n    xor rcx, rcx                ; resetting <i>\n    xor r9, r9                  ; resetting <inx>\n    inc rsi                     ; incrementing <pos>\n    jmp .fieldloop              ; jumping to the next .fieldloop iteration\n.fieldset:\n    mov r10, [rsp+rcx*8]        ; setting R10 as <n> to <*(airlen+i)>\n    mov r11, [r13+rcx*8]        ; setting R11 as <airstrike> to <*(airstrikes+i)>\n    mov r8, rsi                 ; copying <pos> to R8\n.next:\n    inc r8                      ; incrementing <pos+1>\n    cmp r8, r10                 ; whether <pos+1> is less than <n>\n    jge .curr                   ; otherwise, jumping to the .curr section\n    cmp byte [r11+r8], '*'      ; whether <*(airstrike+pos+1)> is an asterisk\n    je .airinx                  ; jumping to the .airinx section\n.curr:\n    dec r8                      ; decrementing <pos>\n    cmp r8, r10                 ; whether <pos> is less than <n>\n    jge .prev                   ; otherwise, jumping to the .prev section\n    cmp byte [r11+r8], '*'      ; whether <*(airstrike+pos)> is an asterisk\n    je .airinx                  ; jumping to the .airinx section\n.prev:\n    test rsi, rsi               ; whether <pos> is not zero\n    je .inc                     ; otherwise, jumping to the .inc section\n    dec r8                      ; decrementing <pos-1>\n    cmp r8, r10                 ; whether <pos-1> is less than <n>\n    jge .inc                    ; otherwise, jumping to the .inc section\n    cmp byte [r11+r8], '*'      ; whether <*(airstrike+pos-1)> is an asterisk\n    jne .inc                    ; otherwise, jumping to the .inc section\n.airinx:\n    inc r9                      ; incrementing <inx>\n.inc:\n    inc rcx                     ; incrementing <i>\n    jmp .fieldloop              ; jumping to the next .fieldloop iteration\n.preexit:\n    add rsp, rdx                ; destroying the local <airlen> storage\n.exit:\n    pop rbx                     ; restoring the initial RBX from the stack\n    pop r12                     ; restoring the initial R12 from the stack\n    pop r13                     ; restoring the initial R13 from the stack\n    pop r14                     ; restoring the initial R14 from the stack\n    pop r15                     ; restoring the initial R15 from the stack\n    ret\n; ---------> end of alphabet_war <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213728,"user_id":null,"body":"global alphabet_war\nextern malloc, strlen\n\nsection .text\n\n; <--- char *alphabet_war(const char *reinforces[], const char *airstrikes[], size_t nreinforce, size_t nairstrike) --->\nalphabet_war:\n    push r15                    ; saving R15 in the stack\n    push r14                    ; saving R14 in the stack\n    push r13                    ; saving R13 in the stack\n    push r12                    ; saving R12 in the stack\n    push rbx                    ; saving RBX in the stack\n    mov r12, rdi                ; copying <reinforces> to R12\n    mov r13, rsi                ; copying <airstrikes> to R13\n    mov r14, rdx                ; copying <nreinforce> to R14\n    mov r15, rcx                ; copying <nairstrike> to R15\n    mov rdi, [rdi]              ; copying <*reinforces> to RDI\n    call strlen                 ; counting the character length\n    mov rbx, rax                ; saving as <len> in RBX\n    inc rax                     ; adding an extra byte for the null character\n    mov rdi, rax                ; copying <len+1> to RDI as a parameter for malloc\n    call malloc                 ; allocating memory\n    test rax, rax               ; whether the memory is allocated\n    je .exit                    ; otherwise, jumping to exit\n    mov byte [rax+rbx], 0       ; copying the null character to <*(field+len)>\n    imul rdx, r15, 8            ; the storage for <airlen> to keep lengths of <airstrikes>\n    sub rsp, rdx                ; allocating the storage in the stack\n    xor rcx, rcx                ; resetting RCX as <i>\n    xor rsi, rsi                ; resetting RSI as <pos>\n    dec rsi                     ; decrementing <pos> to start with zero in the .airloop section\n.airloop:\n    inc rsi                     ; incrementing <pos>\n    cmp rcx, r15                ; whether <i> is less than <nairstrike>\n    jge .fieldini               ; otherwise, jumping to the .fieldini section\n    mov r8, [r13+rcx*8]         ; copying <*(airstrikes+i)> to R8\n    cmp byte [r8+rsi], 0        ; whether <*(*(airstrikes+i)+pos> is the null character\n    jne .airloop                ; otherwise, jumping to the next airloop iteration\n    mov [rsp+rcx*8], rsi        ; saving <pos> in <*(airlen+i)>\n    mov rsi, -1                 ; setting <pos> to minus to start the loop with zero\n    inc rcx                     ; incrementing <i>\n    jmp .airloop                ; jumping to the next airloop iteration\n.fieldini:\n    xor rsi, rsi                ; resetting RSI as <pos>\n    xor rcx, rcx                ; resetting RCX as <i>\n    xor r9, r9                  ; resetting R9 as <inx>\n.fieldloop:\n    cmp rsi, rbx                ; whether <pos> is less than <len>\n    jge .preexit                ; otherwise, jumping to the .preexit section\n    cmp rcx, r15                ; whether <i> is greater or equal to <nairstrike>\n    jl .fieldset                ; otherwise, jumping to the .fieldset section\n    mov cl, '_'                 ; copying the strike character to CL as <c>\n    cmp r9, r14                 ; whether <inx> is less than <nreinforce>\n    jge .fieldappl              ; otherwise, jumping to the .fieldappl section\n    mov rdi, [r12+r9*8]         ; copying <*(reinforces+inx)> to RDI\n    mov cl, [rdi+rsi]           ; copying <*(*(reinforces+inx)+pos)> to <c>\n.fieldappl:\n    mov [rax+rsi], cl           ; copying <c> to <*(field+pos)>\n    xor rcx, rcx                ; resetting <i>\n    xor r9, r9                  ; resetting <inx>\n    inc rsi                     ; incrementing <pos>\n    jmp .fieldloop              ; jumping to the next .fieldloop iteration\n.fieldset:\n    mov r10, [rsp+rcx*8]        ; setting R10 as <n> to <*(airlen+i)>\n    mov r11, [r13+rcx*8]        ; setting R11 as <airstrike> to <*(airstrikes+i)>\n    mov r8, rsi                 ; copying <pos> to R8\n.next:\n    inc r8                      ; incrementing <pos+1>\n    cmp r8, r10                 ; whether <pos+1> is less than <n>\n    jge .curr                   ; otherwise, jumping to the .curr section\n    cmp byte [r11+r8], '*'      ; whether <*(airstrike+pos+1)> is an asterisk\n    je .airinx                  ; jumping to the .airinx section\n.curr:\n    dec r8                      ; decrementing <pos>\n    cmp r8, r10                 ; whether <pos> is less than <n>\n    jge .prev                   ; otherwise, jumping to the .prev section\n    cmp byte [r11+r8], '*'      ; whether <*(airstrike+pos)> is an asterisk\n    je .airinx                  ; jumping to the .airinx section\n.prev:\n    test rsi, rsi               ; whether <pos> is not zero\n    je .inc                     ; otherwise, jumping to the .inc section\n    dec r8                      ; decrementing <pos-1>\n    cmp r8, r10                 ; whether <pos-1> is less than <n>\n    jge .inc                    ; otherwise, jumping to the .inc section\n    cmp byte [r11+r8], '*'      ; whether <*(airstrike+pos-1)> is an asterisk\n    jne .inc                    ; otherwise, jumping to the .inc section\n.airinx:\n    inc r9                      ; incrementing <inx>\n.inc:\n    inc rcx                     ; incrementing <i>\n    jmp .fieldloop              ; jumping to the next .fieldloop iteration\n.preexit:\n    add rsp, rdx                ; destroying the local <airlen> storage\n.exit:\n    pop rbx                     ; restoring the initial RBX from the stack\n    pop r12                     ; restoring the initial R12 from the stack\n    pop r13                     ; restoring the initial R13 from the stack\n    pop r14                     ; restoring the initial R14 from the stack\n    pop r15                     ; restoring the initial R15 from the stack\n    ret\n; ---------> end of alphabet_war <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5949481f86420f59480000e7":[{"id":213729,"user_id":881,"body":"section .rodata\nstring: db \"even\",0,\"odd\",0\nsection .text\nglobal odd_or_even\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\n  xor rcx, rcx\n.loop:\n  dec rsi\n  jl .done\n  xor ecx, dword[rdi + rsi * 4]\n  jmp .loop\n.done:\n  and ecx, 1\n  lea rax, [string + ecx * 5]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213730,"user_id":null,"body":"section .text\nglobal odd_or_even\n; const char *odd_or_even(const int *array, size_t length);\nodd  db \"odd\", 0, 0, 0, 0, 0\neven db \"even\", 0, 0, 0, 0\nodd_or_even:\n  mov rcx, rsi\n  xor r10, r10\n  cmp rsi, 0\n  je  gusu\nkurikae: \n  mov r11d, [rdi]\n  add r10d, r11d\n  add rdi, 4\n  loop kurikae\n  and r10d, 1\n  je  gusu\n  mov rax, odd\n  ret\ngusu: \n  mov rax, even\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213731,"user_id":null,"body":"section .text\nglobal odd_or_even\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\n  mov rcx, rsi\n  xor rax, rax\n  test rsi, rsi\n  je .done\n.loop:\n  add eax, [rdi]\n  add rdi, 4\n  loop .loop\n\n.done:\n  and eax, 1\n  lea eax, [even+eax*5]\n  ret\n  \nsection .data\neven db 'even', 0\nodd  db 'odd' , 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213732,"user_id":null,"body":"section .data\nodd db 'odd', 0\neven db 'even', 0\nsection .text\nglobal odd_or_even\nodd_or_even:\n  xor eax, eax\n  xor edx, edx\n.loop:\n  cmp rax, rsi\n  je .exit\n  add edx,[rdi+rax*4]\n  inc rax\n  jmp .loop\n.exit:\n  and dl, 1\n  mov rax, even\n  mov rdx, odd\n  cmovne rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213733,"user_id":null,"body":"section .text\nglobal odd_or_even\nout_even db 'even',0\nout_odd db 'odd',0\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\n  cmp rsi,0\n  je even\n  xor rax,rax\n  mov rcx,rsi\n  loop1:\n  add eax,[rdi+rcx*4-4]\n  loop loop1\n  bt eax,0\n  jnc even\n  mov rax,out_odd\nret\n  even:\n  mov rax,out_even\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213734,"user_id":null,"body":"section .data\n\nodd_string db \"odd\", 0\neven_string db \"even\", 0\n\nsection .text\n\n; const char *odd_or_even(const int *array, size_t length);\nglobal odd_or_even\nodd_or_even:\n\n  push rbp\n  mov rbp, rsp             ; save stack and establish new stack base\n  \n  mov eax, even_string\n  test rsi, rsi\n  je odd_or_even_end       ; if (length == 0) return \"even\"\n  \n  xor eax, eax             ; acc = 0\n  lea rdx, [rdi + rsi * 4] ; rdx = &array[length]\nloop:\n  add eax, [rdi]           ; acc += *array\n  add rdi, 4               ; array++\n  cmp rdi, rdx             ; loop while(array != &array[length])\n  jne loop\n  \n  test al, 1               \n  mov edx, odd_string\n  mov eax, even_string\n  cmovne rax, rdx          ; return acc % 2 ? \"even\" : \"odd\"\n\nodd_or_even_end:\n  pop rbp                  ; restore stack base\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213735,"user_id":null,"body":"section .text\nglobal odd_or_even\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\n  xor eax, eax\n.loop:\n  sub rsi, 1\n  jb .done\n  xor eax, [rdi]\n  add rdi, 4\n  jmp .loop\n.done:\n  and eax, 1\n  lea eax, [rax + 4*rax]\n  lea rax, [rax + .str]\n  ret\n.str: db `even\\0odd\\0`","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213736,"user_id":null,"body":"section .data\neven  db \"even\",0\nodd   db \"odd\",0\nsection .text\nglobal odd_or_even\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\n  mov  rax, even\n  test rdi, rdi\n  je   .finish\n  test rsi, rsi\n  je   .finish\n  \n  xor  ebx, ebx\n.loop:\n  add  ebx, [rdi]\n  add  rdi, 4\n  dec  rsi\n  jnz  .loop\n  \n  and  ebx, 1\n  mov  rdx, odd\n  cmovnz rax, rdx\n.finish:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213737,"user_id":null,"body":"section .data\nodd: db \"odd\" , 0\neven: db \"even\" , 0\nsection .text\nglobal odd_or_even\n\n\n\n\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\nxor eax, eax\nXor rbx, rbx\n\nCmp rsi, rbx\nJe exeven\nJmp suite\nsuite:\n\n\n\nAdd eax, [rdi+4*rbx]\nInc rbx\nCmp rbx, rsi\nJe testf\nJmp suite\ntestf:\nXor ecx, ecx\nXor edx, edx\nMov ecx, 2\nDiv ecx\nCmp edx, 0\nJe exeven\nJmp exodd\nexeven:\nXor rax, rax\nMov rax , even\nRet \nexodd:\nXor rax, rax\nMov rax, odd\nRet \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213738,"user_id":null,"body":"section .text\nglobal odd_or_even\n; const char *odd_or_even(const int *array, size_t length);\nodd_or_even:\n  xor eax, eax\n  test rsi, rsi\n  jz .finish\n.loop:\n  add eax, [rdi+rsi*4-4]\n  dec rsi\n  jnz .loop\n  \n.finish:\n  test eax, 1\n  lea eax, [even]\n  jz .skip\n  lea eax, [odd]\n.skip:\n  ret\n  \nsection .rodata\nodd: db \"odd\", 0\neven: db \"even\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"594adadee075005308000122":[{"id":213739,"user_id":null,"body":"extern calloc\nglobal eval\n\nsection .text\n\n; <--- unsigned long long *eval(unsigned long long num) --->\neval:\n  push rbx\n  mov esi, 8\n  mov rbx, rdi\n  mov edi, 2\n  sub rsp, 16\n  call calloc\n  mov qword [rsp], 1\n  mov r8d, 10\n  mov qword [rsp+8], 1\n  mov rcx, rax\n.loop:\n  test rbx, rbx\n  je .done\n  mov rax, rbx\n  xor edx, edx\n  mov rsi, rbx\n  div r8\n  and esi, 1\n  mov rdi, [rsp+rsi*8]\n  imul rdx, rdi\n  mov rbx, rax\n  add [rcx+rsi*8], rdx\n  imul rdi, rdi, 10\n  mov [rsp+rsi*8], rdi\n  jmp .loop\n.done:\n  add rsp, 16\n  mov rax, rcx\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213740,"user_id":null,"body":"global eval\nextern malloc\n\nsection .text\n\n; <--- unsigned long long *eval(unsigned long long num) --->\neval:\n  push rdi\n  mov rdi, 16\n  call malloc\n  pop rdi\n  test rax, rax\n  jz .quit\n  mov rsi, rax\n  mov rax, rdi\n  \n  push -1\n  mov rcx, 10\n.loop:\n  xor edx, edx\n  div rcx\n  push rdx\n  test rax, rax\n  jne .loop\n  \n  xor ecx, ecx\n  xor edx, edx\n  \n.loop2:\n  pop rax\n  cmp eax, -1\n  je .done\n  test eax, 1\n  jz .even\n  \n  lea rcx, [rcx*5]\n  lea rcx, [rax+rcx*2]\n  jmp .loop2\n\n.even:\n  lea rdx, [rdx*5]\n  lea rdx, [rax+rdx*2]\n  jmp .loop2\n  \n.done:\n  mov rax, rsi\n  mov [rsi], rdx\n  mov [rsi+8], rcx\n.quit:\n  ret\n; ---------> end of eval <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213741,"user_id":null,"body":"extern malloc\n\nglobal eval\n  \nsection .text\n\n; <--- unsigned long long *eval(unsigned long long num) --->\neval:\n.allocate:\n  push rdi\n  mov rdi, 0x10000000\n  call malloc\n  pop rdi\n  \n  mov r8, 1\n  mov r9, 1\n  lea r10, [rax]\n  mov rax, rdi\n  mov rbx, 10\n  \n.loop:\n  xor rdx, rdx\n  idiv rbx\n  bt rdx, 0\n  jc .odd\n  imul rdx, r8\n  add qword [r10], rdx\n  imul r8, rbx\n  jmp .cont\n   \n.odd:\n  imul rdx, r9\n  add qword [r10 + 8], rdx\n  imul r9, rbx\n  \n.cont:\n  cmp rax, 0\n  jnz .loop\n  \n  mov rax, r10\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213742,"user_id":168,"body":"global eval\nextern malloc\n\nsection .text\n\n; <--- unsigned long long *eval(unsigned long long num) --->\neval:\n  push rbx\n  push r14\n  push rax\n  mov rax, rdi\n  mov r8d, 10\n  mov ecx, 1      ; even 10^p\n  mov edi, 1      ; odd 10^p\n  xor ebx, ebx    ; even\n  xor r14, r14    ; odd\n.loop:\n  xor edx, edx\n  div r8\n  test edx, 1\n  jz .even\n  imul rdx, rdi\n  add r14, rdx\n  add rdi, rdi\n  lea rdi, [5 * rdi]\n  jmp .loop_cond\n.even:\n  imul rdx, rcx\n  add rbx, rdx\n  add rcx, rcx\n  lea rcx, [5 * rcx]\n.loop_cond:\n  test rax, rax\n  jnz .loop\n  mov rdi, 16\n  call malloc\n  mov qword [rax], rbx\n  mov qword [rax + 8], r14\n  add rsp, 8\n  pop r14\n  pop rbx\n  ret\n; ---------> end of eval <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213743,"user_id":null,"body":"global eval\nextern calloc\n\nsection .text\n\n; <--- unsigned long long *eval(unsigned long long num) --->\neval:\n    sub rsp, 16                 ; local storage for <neof> even and odd multipliers\n    push rdi                    ; saving <num> in the stack\n    mov edi, 2                  ; the number of elements to allocate for <neno>\n    mov esi, 8                  ; the size of each element\n    call calloc                 ; allocating memory and resseting it\n    pop rdi                     ; restoring <num> from the stack\n    mov rsi, rax                ; copying the result from calloc to RSI\n    test rsi, rsi               ; whether the memory is allocated\n    je .exit                    ; otherwise, jumping to exit\n    mov r8, 0h8                 ; will be used frequently to choose odd from <neof>\n    mov r10, 0hA                ; will be used frequently to shift multipliers and to get rid of a digit\n    mov qword [rsp], 0h1        ; setting <neof+0> to one\n    mov qword [rsp+r8], 0h1     ; setting <neof+1> to one\n.loop:\n    test rdi, rdi               ; whether <num> is not zero\n    je .exit                    ; otherwise, jumping to exit\n    xor rdx, rdx                ; resetting RDX before the division\n    mov rax, rdi                ; copying <num> to RAX to check for oddness\n    and rax, 1                  ; computing whether <num> is odd\n    cmove rcx, rdx              ; otherwise, setting RCX as <i> to zero, i.e. even\n    cmovne rcx, r8              ; setting <i> to eight to choose odd\n    mov rax, rdi                ; copying <num> to RAX to get rid of a digit and get the reminder\n    div r10                     ; dividing <num> by ten\n    mov rdi, rax                ; updating <num>\n    mov rax, [rsp+rcx]          ; copying <neof+i> to RAX\n    mul rdx                     ; multiplying by the reminder\n    add [rsi+rcx], rax          ; adding the result to <neno+i>\n    mov rax, [rsp+rcx]          ; copying <neof+i> to RAX\n    mul r10                     ; shifting left by one digit\n    mov [rsp+rcx], rax          ; updating <neof+i>\n    jmp .loop                   ; jumping to the next iteration\n.exit:\n    add rsp, 16                 ; destroying the local storage and restoring the stack boundary\n    mov rax, rsi                ; copying <neno> to RAX to return\n    ret\n; ---------> end of eval <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59530d2401d6039f8600001f":[{"id":213744,"user_id":null,"body":"extern log\nglobal how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  push rax\n  cvtsi2sd xmm0, edi\n  call log\n  mulsd xmm0, [.rln3]\n  roundsd xmm0, xmm0, 10\n  cvttsd2si eax, xmm0\n  pop rcx\n  ret\n.rln3: dq 0x3fed20ae03bcc152\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213745,"user_id":null,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  push rbx\n  mov eax, 1\n  mov ebx, 3\n  xor ecx, ecx\n  \n.search:\n  cmp eax, edi\n  jae .end\n  mul ebx\n  inc ecx\n  jmp .search\n  \n.end:\n  mov eax, ecx\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213746,"user_id":null,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  mov eax, edi\n  mov ecx, 3\n  xor esi, esi\n  \n.loop:\n  cmp eax, 1\n  je .done\n  xor edx, edx\n  div ecx\n  test edx, edx\n  lea edx, [eax+1]\n  cmovnz eax, edx\n  inc esi\n  jmp .loop\n  \n.done:\n  mov eax, esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213747,"user_id":null,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  xor eax, eax\n\nloop:\n  cmp edi, 0x1\n  jz return\n  push rax\n  xor edx, edx\n  mov ebx, 0x3\n  mov eax, edi\n  idiv ebx\n  mov edi, eax\n  pop rax\n  cmp edx, 0\n  jnz add_one_to_n\n  inc eax\n  jmp loop\n  ret\n\nadd_one_to_n:\n  inc edi\n  inc eax\n  jmp loop\n\nreturn:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213748,"user_id":null,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  xor eax, eax\n\nhow_many_measurements_2:\n  cmp edi, 0x1\n  jz return\n  push rax\n  push rbx\n  xor edx, edx\n  mov ebx, 0x3\n  mov eax, edi\n  idiv ebx\n  mov edi, eax\n  pop rbx\n  pop rax\n  cmp edx, 0\n  jnz add_one\n  add eax, 0x1\n  jmp how_many_measurements_2\n  ret\n\nadd_one:\n  add edi, 0x1\n  add eax, 0x1\n  jmp how_many_measurements_2\n\nreturn:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213749,"user_id":null,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  xor eax,eax\n  mov edx,1\nl:\n  cmp edx,edi\n  jae end\n  lea edx, [edx+edx*2]\n  inc eax\n  jmp l\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213750,"user_id":50,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n  xor rax, rax\n  xor r8,r8\n  mov r9,3\n_loop:\n  cmp rdi,2\n  jl _exit\n  inc r8\n  xor rdx,rdx\n  mov rax,rdi\n  idiv r9\n  cmp rdx,0\n  je _up\n  inc rax\n_up:\n  mov rdi,rax\n  jmp _loop\n_exit:\n  mov rax,r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213751,"user_id":null,"body":"global how_many_measurements\nhow_many_measurements:\n  push  rdi\n  fldcw [cw]\n  fld1\n  fild  qword[rsp]\n  fyl2x\n  fld1\n  fld   dword[base]\n  fyl2x\n  fdiv\n  fistp qword[rsp]\n  pop   rax\nret\ncw   dw 2879\nbase dd 3.0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213752,"user_id":743,"body":"global how_many_measurements\n\nsection .text\n; eax                           edi\n; int how_many_measurements(int n);\nhow_many_measurements:\n  xor eax, eax\n  cmp edi, 1\n  je .end\n  mov ecx, 0xaaaaaaad ; guess what this is\n.loop_:\n  add edi, 2\n  imul rdi, rcx\n  add eax, 1\n  shr rdi, 33\n  cmp edi, 1\n  jne .loop_\n.end:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213753,"user_id":null,"body":"global how_many_measurements\nsection .text\n; input: edi = n\n; output: eax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nhow_many_measurements:\n\n  mov rcx, 3\n  \n  mov rbx, 0\n  cmp rdi, 1\n  je  end\n  \n  mov rbx, 1\n  mov rax, rcx\n  \nloop:\n  cmp rax, rdi\n  jnl  end\n  \n  mul rcx\n  inc rbx\n  \n  jmp loop\n  \n\nend:\n  mov rax, rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5959ec605595565f5c00002b":[{"id":213754,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n    xor   rax,rax\n.next:\n    sar   rdi,1\n    rcl   rax,1\n    test  rdi,rdi\n    jnz   .next\n    ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213755,"user_id":527,"body":"global revbits\n\n; unsigned revbits(unsigned n)\nrevbits:\n                xor     eax, eax\n.loop:          adc     eax, eax\n                shr     edi, 1\n                jnz     .loop\n                adc     eax, eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213756,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n  xor eax, eax\n.loop:\n  test edi, edi\n  je .done\n  mov ecx, edi\n  shr edi, 1\n  and ecx, 1\n  lea eax, [rcx + 2*rax]\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213757,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n  xor eax, eax\n.loop:\n  shr edi, 1\n  rcl eax, 1\n  test edi, edi\n  jnz .loop\n  ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213758,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n    xor eax, eax        ; resetting EAX as <r>\n    loop:\n    xor rdx, rdx\n    xor r8, r8\n    \n    \n    cmp edi, 0\n    je end\n    bsf rdx, rdi  ;; bit scan lowest significant bit\n    \n    bsr rcx, rdi  ;; bit scan most significant bit\n    mov r8, 1\n    sub rcx, rdx\n    mov r9, 1\n    \n    \n    shl r8, cl\n    mov rcx, rdx\n    shl r9, cl\n    xor rdi, r9\n    or rax, r8\n    xor rdx, rdx\n    \n    jmp loop\n  \n    end:\n    ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213759,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n  xor rdx, rdx\n  xor rax, rax\n  mov rcx, 32\n  \n.for:\n  shl eax, 1\n  rcr edi, 1\n  adcx eax, edx\n  cmp rdi, 0\n  jz .exit\n  loop .for\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213760,"user_id":50,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n    xor eax, eax        ; resetting EAX as <r>\n    xor r9,r9 ; temporary result\n    \n_loop:\n  cmp edi,1\n  jbe _exit\n  shl eax,1\n  mov r9d,edi\n  and r9d,1\n  shr edi,1\n  cmp r9d,1\n  je _addOne\n  jmp _loop\n_addOne:\n  inc eax\n  jmp _loop\n_exit:\n  shl eax,1\n  add eax,edi\n  ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213761,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n    xor eax, eax\nlp: shr edi, 1\n    setc dl\n    shl eax, 1\n    or al, dl\n    test edi, edi\n    jnz lp\n    ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213762,"user_id":null,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nsection .text\nrevbits:\n    test eax,eax\n    jnz .ok\n    xor eax,eax\n    ret\n    .ok:\n    mov rcx, 32\n    .loop:\n    clc\n    rcr edi,1\n    rcl eax,1\n    loop .loop\n    .z:\n    clc\n    rcr eax,1\n    jnc .z\n    rcl eax,1\n    ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213763,"user_id":76,"body":"global revbits\n\n; <-- EAX revbits(EDI n) -->\nrevbits:\n  xor eax, eax\n.loop:\n  test edi, edi\n  jz .exit\n  shl eax, 1\n  mov ebx, edi\n  and ebx, 1\n  or eax, ebx\n  shr edi, 1\n  jmp .loop\n.exit:\n    ret\n; -----> endof revbits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"596d34df24a04ee1e3000a25":[{"id":213764,"user_id":527,"body":"global count_ones\nglobal count_ones_from_zero_to\n\nsection .text\ncount_ones:\n                push    rsi\n                dec     edi\n                call    count_ones_from_zero_to\n                pop     rdi\n                push    rax\n                call    count_ones_from_zero_to\n                pop     rdx\n                sub     rax, rdx\n                ret\n\ncount_ones_from_zero_to:\n                xor     eax, eax\n                mov     esi, 31\n.loop:          xor     edx, edx\n                bts     edx, esi\n                test    edi, edx\n                jz      .skip_add\n                dec     edx\n                and     edx, edi\n                lea     rax, [rax + rdx + 1]\n                mov     edx, esi\n                lea     ecx, [rsi - 1]\n                shl     rdx, cl\n                add     rax, rdx\n.skip_add:      dec     esi\n                jns     .loop\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213765,"user_id":null,"body":"global count_ones\nsection .text\n; input: edi = left, esi = right\n; output: rax\ncount_ones:\n    push  rdi\n    mov   edi,esi     ;count ones in right\n    call  count\n    mov   rax,rcx\n    pop   rdi\n    dec   edi         ;left is included, so count ones in left-1\n    push  rax\n    call  count\n    pop   rax\n    sub   rax,rcx     ;total = ones in right minus ones in left\n    ret\n\ncount:\n    inc   edi\n    bsr   esi,edi\n    inc   esi\n    xor   rcx,rcx\n    mov   rbx,2\n.loop:\n    xor   edx,edx\n    mov   eax,edi\n    div   ebx\n    shr   ebx,1\n    cmp   ebx,edx\n    jge   .neg\n    add   rcx,rdx\n    sub   rcx,rbx\n.neg:\n    cmp   eax,0\n    je    .next\n    xor   edx,edx\n    mul   ebx\n    add   rcx,rax\n.next:\n    shl   ebx,2\n    dec   esi\n    jne   .loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213766,"user_id":null,"body":"global count_ones\nsection .text\n; input: edi = left, esi = right\n; output: rax\ncount_ones:\n  MOV EDX, ESI\n  SUB EDX, EDI\n  TEST EDX, 0xFFFE0000\n  JZ COUNT_SMALL\n  SHR EDX, 16\n  CMP SI, DI\n  JB B\n  DEC EDX\nB:SHL RDX, 19\n  PUSH RSI\n  PUSH RDI\n  SHR RSI, 16\n  SHR RDI, 16\n  INC RDI\n  DEC RSI\n  CALL COUNT_SMALL\n  PUSH RDX\n  MOV RDX, 0x0000000000010000\n  MUL RDX\n  POP RDX\n  ADD RDX, RAX\n  POP RDI\n  MOV ESI, EDI\n  AND ESI, 0xFFFF0000\n  OR ESI, 0x0000FFFF\n  CALL COUNT_SMALL\n  ADD RDX, RAX\n  POP RSI\n  MOV EDI, ESI\n  AND EDI, 0xFFFF0000\n  CALL COUNT_SMALL\n  ADD RAX, RDX\n  RET\nCOUNT_SMALL:\n  XOR RAX, RAX\nA:POPCNT ECX, EDI\n  ADD RAX, RCX\n  INC EDI\n  CMP EDI, ESI\n  JLE A\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213767,"user_id":50,"body":"global count_ones\nsection .text\n; input: edi = left, esi = right\n; output: rax\ncount_ones:\n  dec rdi\n  call f ; f(edi=x-1)\n  mov r11,rax ; save in r11\n  xor rax,rax\n  mov rdi,rsi\n  call f  ;f(es=y)\n  sub rax,r11\n  ret\n  \nf:\n  xor rax,rax ; o\n_loop:\n  cmp rdi,0\n  je _exit\n  xor rbx,rbx ; res\n  mov rcx,rdi ; m\n_countBits:\n  cmp rcx,1 ; if m<=1\n  jle _out\n  inc rbx ; r++\n  shr rcx,1 ; m>>=1\n  jmp _countBits\n_out:\n  mov r8,rbx ; r-1\n  dec r8\n  xor r9,r9\n  bts r9,r8 ; 2**(r-1)\n  imul r9,rbx ; *r\n  inc r9 ; +1\n  add rax,r9 ; o+=2**(r-1)*res+1\n  xor r10,r10\n  bts r10,rbx ;2**r\n  sub rdi,r10 ; n-=2**r\n  add rax,rdi ;o+=n\n  jmp _loop\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213768,"user_id":null,"body":"section .data\nalign 64 \n\nbitcnt:     times 256   db  0\ntotal:      dq 0\n               \nglobal count_ones\nsection .text\nalign 64\n\n; input: edi = left, esi = right\n; output: rax\ncount_ones:\n\n; Make lookup table\n  \n  push rcx\n  push rbx\n  push rdx\n  \n  mov rcx, 256\n  xor rax, rax\n  mov [total], rax\n  mov rbx, bitcnt\n  push rbx\n  \n@store:  \n  push rax\n  rcr al, 1\n  adc ah, 0\n  \n  rcr al, 1\n  adc ah, 0\n\n  rcr al, 1\n  adc ah, 0\n\n  rcr al, 1\n  adc ah, 0\n\n  rcr al, 1\n  adc ah, 0\n\n  rcr al, 1\n  adc ah, 0\n\n  rcr al, 1\n  adc ah, 0\n\n  rcr al, 1\n  adc ah, 0\n  \n  mov [rbx], ah\n  pop rax\n  inc rax\n  inc rbx\n  loop @store\n    \n; Main procedure\n\n  pop rbx           ;XLATB table\n  \n  mov rcx, rdi    ;left value\n  mov rdx, rdi    ;left value\n  xor rdi, rdi\n  inc rsi\n\n  xor rax,rax\n\n;--- initial count\n\n@upbytes:\n\n  mov rcx, rdx\n  push rcx\n  \n  xor rdi, rdi\n  \n  sar rcx, 8      ;byte 2\n  mov al, cl        \n  xlatb                 ;count bits\n  add rdi, rax      ;accumulating\n  \n  sar rcx, 8      ;byte 3  \n  mov al, cl        \n  xlatb               \n  add rdi, rax      ;accumulating\n  \n  sar rcx, 8      ;byte 4\n  mov al, cl        \n  xlatb             \n  add rdi, rax      ;accumulating\n\n  pop rcx    ;restore\n  \n  or cl, cl\n  jz @skip\n  \n@nxt0:\n\n  mov rdx, [total]\n \n@nxt:  \n\n;--- byte 1\n\n  mov al, cl            ;get LSB byte\n  \n  xlatb                 ;count bits\n  add rax, rdi          ;add local\n  add rdx, rax\n\n  inc rcx\n  cmp rcx, rsi\n  jge @fin               ;all counted\n  \n  or cl, cl\n  jnz @nxt        ;count first byte\n  \n  mov [total], rdx\n  mov rdx, rcx\n  jmp @upbytes\n  \n@skip:\n\n  mov rdx, rcx    ;save left value\n  \n  add rcx, 0x100\n  cmp rcx, rsi\n  mov rcx, rdx\n  jnc @nxt0\n  \n  add rdx, 0x100\n  mov rcx, rdi\n  sal rdi, 8\n  add rdi, 0x400\n  add qword [total], rdi\n\n  jmp @upbytes\n\n@fin:\n  mov rax, rdx\n  pop rdx\n  pop rbx\n  pop rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213769,"user_id":null,"body":"global count_ones\nsection .text\n; input: edi = left, esi = right\n; output: rax\ncount_ones:\n    popcnt r8,rdi\n    call count_ones_lt\n    mov  rdi,rsi\n    sub  r8,rax\n    call count_ones_lt\n    add  rax,r8\n    ret\n    \ncount_ones_lt: \n    cmp  rdi,2\n    jg   .main\n    mov  rax,rdi\n    ret\n  .main:\n    bsr  rcx,rdi\n    btr  rdi,rcx\n    mov  rax,1\n    shl  rax,cl\n    shr  rax,1\n    mul  rcx\n    inc  rax\n    add  rax,rdi\n    push rax\n    call count_ones_lt\n    pop  rdx\n    add  rax,rdx\n    ret\n            ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213770,"user_id":null,"body":"global count_ones\nsection .text\n\n; sum[0-63]{ b[[(2^i\/2)*i + 1] + rem ] }\n; rem is remainder, all bits behind current bit\n; input: rdi = number\ncount_0_to_number:\n  enter  0x16, 0                               ; 32 bits for local variables\n  xor    rcx, rcx                              ; counter => [0 - 63]\n  mov    qword [rbp - 8],  0x0000000000000001  ; bit & power mask\n  mov    qword [rbp - 16], 0x00                ; total sum\n  \n_l1:\n  ; bit extract\n  mov    rsi, rdi\n  and    rsi, qword [rbp - 8]\n  shr    rsi, cl\n  ; rsi <= bit\n\n  ; major\n  mov    rax, [rbp - 8]\n  shr    rax, 0x01\n  mul    rcx\n  inc    rax\n  ; rax  <= major\n\n  ; rem\n  mov    rdx, [rbp - 8]\n  dec    rdx\n  and    rdx, rdi\n  \n  ; sum all\n  add    rax, rdx\n  mul    rsi\n  add    [rbp - 16], rax \n\n  inc    cl\n  shl    qword [rbp - 8], 0x01\n  cmp    cl, 0x40\n  jne    _l1\n  \n  ; rax result\n  mov    rax, qword [rbp - 16]\n  leave\n  ret\n  \n; input: rdi = left, rsi = right\n; output: rax\ncount_ones:\n  enter  16, 0\n  mov    [rbp - 8], rsi\n  mov    qword [rbp - 16], 0x00\n  dec    rdi\n  call   count_0_to_number\n  add    qword [rbp - 16], rax\n  mov    rdi, [rbp - 8]\n  call   count_0_to_number\n  sub    rax, [rbp - 16]\n  leave\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213771,"user_id":null,"body":"global count_ones\nsection .text\ncount_ones:\n  xor    rax,rax\n  lea    rdx,[rdi-1]\n  call   .count\n  neg    rax\n  mov    rdx,rsi  \n  .count:\n    mov    r8,1\n    xor    r9,r9\n    mov    rcx,-1\n    .b:inc  rcx\n       shr  rdx,1\n       jnc .f\n         popcnt r10,rdx\n         shl    r10,cl\n         add    rax,r8\n         add    rax,r10\n       .f:\n       lea  r8,[r8*2+r9]\n       lea  r9,[r9*2+1]\n    jne .b   \nret\n      ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213772,"user_id":null,"body":"global count_ones\nsection .text\n; input: edi = left, esi = right\n; output: rax\n\n; given the arguments 'left' and 'right' count_ones\n; will call calculate_bits for each argument passed\n; and after that it will substract the results in order\n; to calculate the actual set bits between the two numbers\ncount_ones:\n  ; move 'left' in r9. This register will be passed\n  ; to calculate_bits subroutine.\n  mov r9, rdi\n  ; decrement rdi in order to calculate the correct \n  ; number of bits\n  dec r9\n  call calculate_bits\n  \n  ; store result for 'left' in r12\n  mov r12, rax\n  \n  ; calculate the number of bits for 'right'\n  mov r9, rsi\n  call calculate_bits\n  \n  ; calculate number of bits in range 'left' - 'right'\n  sub rax, r12\n  ret\n\n; the subroutine will calculate the number of set bits\n; between 1 and a given number, n. The number is passed\n; in the r9 register.\ncalculate_bits:\n  ; for a better understanding of what is happening here\n  ; write down the binary representation of the numbers between\n  ; 1 and n and follow each column from right to left.\n  ; you will see that each column follows a certain pattern regarding\n  ; the occurence of 0's and 1's\n  \n  inc r9; compensate the number 0\n  mov rcx, 2; powerof2 - this variable will keep track\n  ; of the column we are computing the set bits for\n  \n  ; we will initialise the result with n\/2 because this is\n  ; how many set bits are set on the first column from right\n  ; to left\n  ; the result will be stored in rdi\n  mov rdi, r9\n  shr rdi, 1\n  \n  ; next step is to calculate the pairs of 1's and 0's\n  ; from each column until the powerof2 variable is less\n  ; or equal with our given number aka all bits in the binary\n  ; representation were computed\n  \n.loop:\n  ; calculate number of pairs of 1's and 0's\n  ; by dividing the number by powerof2\n  mov rax, r9\n  xor rdx, rdx; empty rdx register before division\n  div rcx; n \/ powerof2\n  \n  mov r11, rax; save the number of pairs for later\n  \n  shr rax, 1; divide the number of pairs by 2 in order\n  ; to get the number of set bits groups\n  \n  mul rcx; multiply the number in rax with powerof2 in order\n  ; to get the actual number of set bits\n  \n  add rdi, rax; add the number to result\n  \n  ; next we will decide whether our number landed in the\n  ; middle of a group of ones. If so we need to check\n  ; how many set bits are until our number\n  and r11, 1\n  cmp r11, 0\n  ; if the number is even we simply go back to the beginning\n  ; of the loop\n  je .loop.back\n  \n  ; else we add to result the numbre n%powerof2;\n  ; meaning that we add the set bits until our number\n  ; also n%(2^i) = n & (2^i - 1)\n  mov rax, rcx\n  dec rax\n  and rax, r9\n  \n  ; add to result\n  add rdi, rax\n  \n.loop.back:\n  shl rcx, 1; multiply powerof2 with 2\n  \n  ; compare powerof2 with n\n  cmp rcx, r9\n  jle .loop\n  \n  ; end of function -- move result to rax and return\n  mov rax, rdi\n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213773,"user_id":null,"body":"global count_ones\n\nsection .text\n\ncount_ones:\n    push    rbx\n    push    r12\n    push    r13\n    push    r14\n    push    rcx\n    \n    xor     rbx, rbx\n    lea     r12, [rdi - 1]\n    mov     r13, rsi\n    mov     r14, 1\n\n.loop:\n    cmp     r13, r14\n    jl      .exit\n    shl     r14, 1\n    \n    mov     rdi, r12\n    mov     rsi, r14\n    call    count_ones_for_power_of_two\n    sub     rbx, rax\n    \n    mov     rdi, r13\n    mov     rsi, r14\n    call    count_ones_for_power_of_two\n    add     rbx, rax\n\n    jmp     .loop\n\n.exit:\n    mov     rax, rbx\n\n    pop     rcx\n    pop     r14\n    pop     r13\n    pop     r12\n    pop     rbx\n\n    ret\n\ncount_ones_for_power_of_two:\n    lea     rax, [rdi + 1]\n    xor     rdx, rdx\n    div     rsi\n\n    shr     rsi, 1\n    xor     rcx, rcx\n    sub     rdx, rsi\n    cmovg   rcx, rdx\n\n    mul     rsi\n    add     rax, rcx\n\n.exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"596d93bd9b6a5df4de000049":[{"id":213774,"user_id":null,"body":"global hash\n\nsection .text\n\n; <----- int hash(const char *str) ----->\nhash:\n  movsx r8d, byte [rdi]\n  xor esi, esi\n  xor edx, edx\n.loop:\n  mov al, byte [rdi]\n  lea ecx, [rsi+1]\n  test al, al\n  je .loopend\n  movsx r9d, al\n  inc rdi\n  add edx, r9d\n  cmp al, 32\n  cmove esi, ecx\n  jmp .loop\n.loopend:\n  movsx eax, byte [rdi-1]\n  sal ecx, 5\n  sub eax, r8d\n  or eax, edx\n  not edx\n  sal edx, 2\n  and eax, edx\n  xor eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213775,"user_id":77,"body":"global hash\n\nsection .text\n\n; <----- int hash(const char *str) ----->\nhash:\n    mov rsi, rdi\n    xor eax, eax\n    mov ebx, 32\n    xor ecx, ecx\n    movzx edx, byte [rsi]\n.loop:\n    mov edi, eax\n    lodsb\n    add ecx, eax\n    cmp al, 32\n    jne .nospace\n    add ebx, eax\n.nospace:\n    test al, al\n    jnz .loop\n    sub edi, edx\n    or edi, ecx\n    not ecx\n    shl ecx, 2\n    and ecx, edi\n    xor ecx, ebx\n    mov eax, ecx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213776,"user_id":null,"body":"global hash\nhash:\n  xor r8,r8\n  xor r9,r9\n  mov r10,1\n  cmp byte[rdi],0\n  je .f\n    .b:movzx rcx,byte[rdi]\n       movzx rdx,byte[rdi+1]\n       add   r8,rcx\n       sub   r9,rcx\n       add   r9,rdx\n       cmp   byte[rdi],' '+1\n       adc   r10,0\n       inc   rdi\n       cmp   byte[rdi],0\n    jne .b   \n    add r9,rcx\n  .f:\n  or   r9,r8\n  lea  r8,[r8*4+3]\n  andn rax,r8,r9\n  shl  r10,5\n  xor  rax,r10\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213777,"user_id":168,"body":"global hash\n\nsection .text\n\n; <----- int hash(const char *str) ----->\nhash:\n  mov edx, 1\n  xor ecx, ecx\n  mov rsi, rdi\n  jmp .loop_cond\n.loop:\n  add ecx, eax\n  cmp eax, ' '\n  sete al\n  add edx, eax\n  inc rsi\n.loop_cond:\n  movzx eax, byte [rsi]\n  test eax, eax\n  jnz .loop\n  cmp rsi, rdi\n  je .end\n  movzx eax, byte [rsi - 1]\n  movzx edi, byte [rdi]\n  sub eax, edi\n.end:\n  or eax, ecx\n  not ecx\n  shl ecx, 2\n  and eax, ecx\n  shl edx, 5\n  xor eax, edx\n  ret\n; ---------> end of hash <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213778,"user_id":null,"body":"global hash\n\nsection .text\n\n; <----- int hash(const char *str) ----->\nhash:\n    mov eax, 32             ; the code of space and its factor\n    xor r8d, r8d            ; resetting R8D to use as <a>\n    xor r9d, r9d            ; resetting R9D to use as <b>\n    xor esi, esi            ; resetting ESI to use as <spc> and setting to one\n    xor ecx, ecx            ; resetting the highest ECX bits\n    xor edx, edx            ; resetting the highest EDX bits\n    test rdi, rdi           ; whether <str> is NULL\n    je .exit                ; jumping to exit\n    mov cl, [rdi]           ; copying <*str> to CL, will be used as <*str-1>\n    test cl, cl             ; whether <*str> is empty\n    je .exit                ; jumping to exit\n    mov r8b, cl             ; copying <*str> to <a> as the initial sum\n    cmp cl, al              ; whether <*str> is a space\n    sete sil                ; then setting <spc> to one\n.loop:\n    inc rdi                 ; moving the pointer to the next character\n    mov dl, [rdi]           ; copying a character to DL\n    test dl, dl             ; whether <*str> is an empty character\n    je .exit                ; jumping to the exit section\n    add r8d, edx            ; adding the code of <*str> to <a>\n    sub r9d, ecx            ; subtracting from <b> the code of <*str-1>\n    add r9d, edx            ; adding to <b> the code of <*str>\n    mov cl, dl              ; copying <*str> to CL to use as <*str-1> in the next iteration\n    cmp cl, al              ; whether <*str> is a space character\n    jne .loop               ; otherwise, jumping to the next iteration\n    inc esi                 ; incrementing <spc>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    or r9d, r8d             ; oring <b> with <a> and saving the result in <b>\n    not r8d                 ; negating <a>\n    shl r8d, 2              ; shifting negated <a> left by two bits\n    and r9d, r8d            ; anding modified <b> with <a and saving the result in <b>\n    inc esi                 ; incrementing <spc>\n    imul esi                ; multiplying <spc> by the space factor\n    xor eax, r9d            ; xoring the multiplied <spc> with modified <b> and saving in EAX\n    ret\n; ---------> end of has <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5971b219d5db74843a000052":[{"id":213779,"user_id":527,"body":"global added_char\nsection .text\nadded_char:\n                xor     eax, eax\n.loop1:         movzx   edx, byte [rdi]\n                xor     eax, edx\n                inc     rdi\n                test    edx, edx\n                jnz     .loop1\n.loop2:         movzx   edx, byte [rsi]\n                xor     eax, edx\n                inc     rsi\n                test    edx, edx\n                jnz     .loop2\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213780,"user_id":null,"body":"global added_char\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n  xor eax, eax\n.s2loop:\n  movsx ecx, byte [rsi]\n  inc rsi\n  add eax, ecx\n  test cl, cl\n  jne .s2loop\n.s1loop:\n  movsx ecx, byte [rdi]\n  inc rdi\n  sub eax, ecx\n  test cl, cl\n  jne .s1loop\n  mov ecx, 3\n  xor edx, edx\n  div ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213781,"user_id":null,"body":"global added_char\nextern puts\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n    sub rsp, 400h       ; allocate 100h dword table on stack\n    ; init character counter table\n    xor rax, rax\n    mov ecx, 100h\/2     ; init the 100h dwords with 100h\/2 qwords\n.init_loop:\n    mov [rsp+rcx*8-8], rax\n    loop .init_loop\n    ; count characters in string s1\n    xchg rsi, rdi       ; rsi = s1, rdi = s2\n    cld                 ; go upwards in the strings\n.s1_count_loop:\n    lodsb\n    inc dword [rsp+rax*4]\n    test al, al\n    jnz .s1_count_loop  ; repeat until end of string\n    ; subtract count of characters in string s2\n    ; a negative count indicates an added char in s2\n    mov rsi, rdi        ; rsi = s2\n.s2_count_loop:\n    lodsb\n    dec dword [rsp+rax*4]\n    js .found           ; counter negative: found an added char\n    test al, al\n    jnz .s2_count_loop  ; repeat until end of string\n    ; the rip is here: error, not found an added char\n.found:\n    add rsp, 400h\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213782,"user_id":null,"body":"global added_char\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n  xor eax, eax\n  lea rdx, [data]\n  \n  %assign i 0\n  %rep 32\n  mov [rdx+i], rax\n  %assign i i+8\n  %endrep\n  \n.loop1:\n  movzx eax, byte [rsi]\n  inc rsi\n  inc byte [rdx+rax]\n  test eax, eax\n  jnz .loop1\n  \n.loop2:\n  movzx eax, byte [rdi]\n  inc rdi\n  dec byte [rdx+rax]\n  test eax, eax\n  jnz .loop2\n  \n  dec eax\n.loop3:\n  inc eax\n  cmp byte [rdx+rax], 0\n  jz .loop3  \n  ret\n\nsection .bss\ndata: resb 256\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213783,"user_id":null,"body":"global added_char\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n  xor eax, eax\n.loop:\n  xor al,[rsi]\n  inc rsi\n  mov cl,[rdi]\n  inc rdi\n  xor al,cl\n  test cl,cl\n  jne .loop\n  mov ecx,[rsi]\n  xor al,cl\n  xor al,ch\n  sar ecx,8\n  xor al,ch\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213784,"user_id":null,"body":"global added_char\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n  xor eax, eax\n.loop:\n  mov cl,[rsi]\n  inc rsi\n  xor al,cl\n  mov cl,[rdi]\n  inc rdi\n  xor al,cl\n  test cl,cl\n  jne .loop\n  mov ecx,[rsi]\n  xor al,cl\n  xor al,ch\n  sar ecx,8\n  xor al,ch\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213785,"user_id":null,"body":"global added_char\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n    xor   cl,cl\n    call  xor_chars\n    mov   rsi,rdi\n    call  xor_chars\n    mov   al,cl\n    ret\n\nxor_chars:\n    lodsb\n    cmp   al,0\n    je    .end\n    xor   cl,al\n    jmp   xor_chars\n.end:\n    ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213786,"user_id":null,"body":"global added_char\nsection .text\n; input: rdi = s1, rsi = s2\n; output: al\n; callee saved registers: rbx, rsp, rbp, r12-r15\nadded_char:\n  xor cl,cl\n  call dostring\n  mov rsi,rdi\n  call dostring\n  mov al,cl\n  ret\n\ndochar:\n  xor cl,al\ndostring:\n  lodsb\n  test al,al\n  jnz dochar\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213787,"user_id":null,"body":"global added_char\nsection .text\nadded_char:\n  xor r10, r10\nsexyloop:\n  mov al, [rdi+r10]\n  inc r10\n  call count\n  mov r9, rdx\n  call count\n  cmp r9, rdx\n  je sexyloop\n  ret\ncount:\n  xor r8, r8\n  xor rdx, rdx\ncountloop:\n  mov cl, [rdi+r8]\n  cmp cl, al\n  jne pass\n  inc rdx\npass:\n  inc r8\n  cmp cl, 0\n  jne countloop\n  xchg rsi, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213788,"user_id":null,"body":"global added_char\nsection .text\nextern strlen, strdup\nadded_char:\n    push rdi\n    mov rdi,rsi\n    call strdup\n    push rax\n    mov rdi,rax\n    call strlen\n    pop rdi        ; New writeable copy of long string with extra chars\n    pop rsi        ; Original string\n    mov rdx,rax    ; Length of string with extra chars\n    mov rcx,rax    ; Length of original string\n    sub rcx,3\n\n@main:\n    dec rcx\n    js @l2\n    movzx eax, byte [rsi + rcx]\n    mov r9,rdx\n    \n@l1:\n    dec r9\n    movzx r10d, byte [rdi + r9]\n    cmp r10d,eax\n    jne @l1\n    mov byte [rdi + r9],0    ; If we find the char from the original string, replace it with a 0\n    jmp @main\n@l2:\n    xor r9,r9\n@l3:\n    movzx eax,byte [rdi + r9]  ; FInd the first char in the long string that isn't 0. There shoould be 3 entries, and all be the same\n    inc r9\n    test eax,eax\n    jz @l3\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"597d75744f4190857a00008d":[{"id":213789,"user_id":null,"body":"extern calloc\nsection .text\nglobal paint_letterboxes\n; int *paint_letterboxes(int start, int end)\n; input:  rdi = start, rsi = end\n; output: rax\npaint_letterboxes:\n  push rbp\n  mov ebp, esi\n  mov esi, 4\n  push rbx\n  mov ebx, edi\n  mov edi, 10\n  push rcx\n  call calloc\n  mov esi, 10\n  mov rcx, rax\n.letterloop:\n  cmp ebx, ebp\n  jg .done\n  mov eax, ebx\n.nextdigit:\n  test eax, eax\n  jle .nomoredigits\n  cdq\n  idiv esi\n  movsx rdx, edx\n  inc dword [rcx+rdx*4]\n  jmp .nextdigit\n.nomoredigits:\n  inc ebx\n  jmp .letterloop\n.done:\n  pop rdx\n  mov rax, rcx\n  pop rbx\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213790,"user_id":460,"body":"extern calloc\nsection .text\nglobal paint_letterboxes\n; int *paint_letterboxes(int start, int end)\n; input:  rdi = start, rsi = end\n; output: rax\npaint_letterboxes:\n  push rdi\n  push rsi\n  mov rdi, 10\n  mov rsi, 4\n  call calloc\n  mov r8, rax\n  pop rsi\n  pop rdi\n  \n  mov rcx, 10\n.number_loop:\n  mov rax, rdi\n.digit_loop:\n  xor rdx, rdx\n  div rcx\n  inc dword [r8+rdx*4]\n  cmp rax, 0\njne .digit_loop\n  inc rdi\n  cmp rdi, rsi\njle .number_loop\n  mov rax, r8\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213791,"user_id":null,"body":"extern calloc\nglobal paint_letterboxes\n; int *paint_letterboxes(int start, int end)\n; input:  rdi = start, rsi = end\n; output: rax\npaint_letterboxes:\n    push rdi\n    push rsi\n    mov rdi, 10\n    mov rsi, 4\n    call calloc\n    mov r9, rax\n    pop rsi\n    pop rdi\n    mov r8, 10\n.outer_loop:\n    mov rax, rdi\n.inner_loop:\n    xor rdx, rdx\n    div r8\n    inc dword [r9+4*rdx]\n    test rax, rax\n    jnz .inner_loop\n    inc rdi\n    cmp rdi, rsi\n    jle .outer_loop\n    mov rax, r9\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213792,"user_id":null,"body":"extern malloc\nglobal paint_letterboxes\n; int *paint_letterboxes(int start, int end)\n; input:  rdi = start, rsi = end\n; output: rax\npaint_letterboxes:\n    push rdi\n    push rsi\n    mov rdi, 40\n    call malloc\n    mov r9, rax\n    pop rsi\n    pop rdi\n    xor rcx, rcx\n.init_loop:\n    mov [r9+4*rcx], dword 0\n    inc rcx\n    cmp rcx, 10\n    jne .init_loop\n    mov r8, 10\n.outer_loop:\n    mov rax, rdi\n.inner_loop:\n    xor rdx, rdx\n    div r8\n    inc dword [r9+4*rdx]\n    test rax, rax\n    jnz .inner_loop\n    inc rdi\n    cmp rdi, rsi\n    jle .outer_loop\n    mov rax, r9\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213793,"user_id":null,"body":"extern calloc\nsection .text\nglobal paint_letterboxes\npaint_letterboxes:\n  xor rax, rax\n  push rbp\n  mov rbp, rsp\n  push rdi\n  push rsi\n    mov rdi, 10\n    mov rsi, 4\n    call calloc\n  pop rsi\n  pop rdi\n  mov rcx, rax\n  xor rax, rax\n\n  .nums:\n    mov r9, 10\n    mov rax, rdi\n    .inner:\n      xor rdx, rdx\n      div r9d\n      add dword [rcx + rdx * 4], 1\n      cmp rax, 0\n      jne paint_letterboxes.inner\n\n    inc rdi\n    cmp rdi, rsi\n    jle paint_letterboxes.nums\n\n\n  mov rax, rcx\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213794,"user_id":17,"body":"section .text\nglobal paint_letterboxes\nextern calloc\npaint_letterboxes:\n  mov r15d, 10\n  push rdi\n  push rsi\n  mov rdi, 10\n  mov rsi, 4\n  call calloc\n  pop r9\n  pop r8\n  push rax\n.outer_loop:\n  mov r10d, r8d\n.inner_loop:\n  xor rdx, rdx\n  mov eax, r10d\n  div r15d\n  imul edx, 4\n  pop r11\n  mov r12, r11\n  add r12, rdx\n  inc dword [r12]\n  push r11\n  mov r10d, eax\n  cmp r10d, 0\n  jg .inner_loop\n  inc r8d\n  cmp r8d, r9d\n  jle .outer_loop\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213795,"user_id":null,"body":"section .text\nglobal paint_letterboxes\nextern abort, calloc\n\n; int *paint_letterboxes(int start, int end)\n; input:  rdi = start, rsi = end\n; output: rax\npaint_letterboxes:\n  push rdi\n  push rsi\n\n  ; allocate an array of 10 ints\n  mov rdi, 10\n  mov rsi, 4\n  call calloc\n  cmp rax, 0\n  je abort\n  mov r8, rax\n\n  mov r9, 10 ; used in idiv\n  pop rsi\n  pop rdi\n  ; loop from start (rdi) to end (rsi)\n.outer_loop:\n  mov rax, rdi\n.inner_loop:\n  ; divide by 10 until quotient is 0\n  mov rdx, 0\n  idiv r9\n  ; counts[remainder] += 1\n  mov ecx, dword [r8+4*rdx]\n  inc ecx\n  mov dword [r8+4*rdx], ecx\n  ; end loop if quotient is 0\n  cmp rax, 0\n  jne .inner_loop\n\n  ; break from loop if i == end\n  cmp rsi, rdi\n  je .break_outer_loop\n  inc rdi\n  jmp .outer_loop\n\n.break_outer_loop:\n  mov rax, r8\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213796,"user_id":null,"body":"section .text\nglobal paint_letterboxes\nextern abort, calloc\n\n; int *paint_letterboxes(int start, int end)\n; input:  rdi = start, rsi = end\n; output: rax\npaint_letterboxes:\n  push r8\n  push r9\n  push rdi\n  push rsi\n\n  ; allocate an array of 10 ints\n  mov rdi, 10\n  mov rsi, 4\n  call calloc\n  cmp rax, 0\n  je abort\n  mov r8, rax\n\n  mov r9, 10 ; used in idiv\n  pop rsi\n  pop rdi\n  ; loop from start (rdi) to end (rsi)\n.outer_loop:\n  mov rax, rdi\n.inner_loop:\n  ; divide by 10 until quotient is 0\n  mov rdx, 0\n  idiv r9\n  ; counts[remainder] += 1\n  mov ecx, dword [r8+4*rdx]\n  inc ecx\n  mov dword [r8+4*rdx], ecx\n  ; end loop if quotient is 0\n  cmp rax, 0\n  jne .inner_loop\n\n  ; break from loop if i == end\n  cmp rsi, rdi\n  je .break_outer_loop\n  inc rdi\n  jmp .outer_loop\n\n.break_outer_loop:\n  mov rax, r8\n  pop r9\n  pop r8\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213797,"user_id":168,"body":"section .text\nextern calloc\nglobal paint_letterboxes\n; int *paint_letterboxes(int start, int end)\n; input:  edi = start, esi = end\n; output: rax\npaint_letterboxes:\n  push rbx\n  push rsi\n  push rdi\n  mov edi, 10\n  mov esi, 4\n  call calloc\n  mov rbx, rax\n  pop rdi\n  pop rsi\n  mov ecx, 10\n.loop:\n  mov eax, edi\n  jmp .digits_cond\n.digits:\n  xor edx, edx\n  div ecx\n  inc dword [rbx + rdx * 4]\n.digits_cond:\n  test eax, eax\n  jnz .digits\n  inc edi\n  cmp edi, esi\n  jle .loop\n  mov rax, rbx\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213798,"user_id":527,"body":"extern calloc\n\nsection .text\n\nglobal paint_letterboxes\n; int *paint_letterboxes(int start, int end)\npaint_letterboxes:\n                push    rdi\n                push    rsi\n                push    rbp\n                mov     edi, 10\n                mov     esi, 4\n                call    calloc\n                pop     rbp\n                pop     rsi\n                pop     rdi\n.loop:          mov     r8d, edi\n.loop_digits:   imul    rdx, r8, 1717986919\n                shr     rdx, 34\n                imul    ecx, edx, -10\n                add     ecx, r8d\n                mov     r8d, edx\n                inc     dword [rax + 4 * rcx]\n                test    edx, edx\n                jnz     .loop_digits\n                inc     edi\n                cmp     edi, esi\n                jbe     .loop\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"599da159a30addffd00000af":[{"id":213799,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0, xmm3\n  subss xmm1, xmm4\n  addss xmm2, xmm5\n  mulss xmm1, xmm1\n  mulss xmm0, xmm0\n  addss xmm0, xmm1\n  sqrtss xmm0, xmm0\n  comiss xmm2, xmm0\n  setnb al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213800,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0, xmm3\n  subss xmm1, xmm4\n  addss xmm2, xmm5\n  mulss xmm0, xmm0\n  mulss xmm1, xmm1\n  mulss xmm2, xmm2\n  addss xmm0, xmm1\n  ucomiss xmm0, xmm2\n  setc al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213801,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0, xmm3\n  subss xmm1, xmm4\n  addss xmm2, xmm5\n  mulss xmm0, xmm0\n  mulss xmm1, xmm1\n  addss xmm0, xmm1\n  mulss xmm2, xmm2\n  ucomiss xmm0, xmm2\n  setb al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213802,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0, xmm3\n  subss xmm1, xmm4\n  addss xmm2, xmm5\n  mulss xmm0, xmm0\n  mulss xmm1, xmm1\n  addss xmm0, xmm1\n  mulss xmm2, xmm2\n  mov rax, 0\n  mov rdx, 1\n  ucomiss xmm0, xmm2\n  cmovb rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213803,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0, xmm3\n  subss xmm1, xmm4\n  mulss xmm0, xmm0\n  mulss xmm1, xmm1\n  addss xmm0, xmm1\n  sqrtss xmm0, xmm0\n  addss xmm2, xmm5\n  comiss xmm2, xmm0\n  seta al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213804,"user_id":50,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0,xmm3\n  mulss xmm0,xmm0\n  subss xmm1,xmm4\n  mulss xmm1,xmm1\n  addss xmm0,xmm1\n  addss xmm2,xmm5\n  mulss xmm2,xmm2\n  movss xmm1,xmm2\n  vucomiss xmm0,xmm1\n  jb _retTrue\n  mov al,0\n  ret\n_retTrue:\n  mov al,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213805,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss xmm0, xmm3\n  mulss xmm0, xmm0\n  subss xmm1, xmm4\n  mulss xmm1, xmm1\n  addss xmm0, xmm1 ; xmm0 = (x2-x1)^2 + (y2-y1)^2\n  addss xmm2, xmm5\n  mulss xmm2, xmm2 ; xmm2 = (r1+r2)^2\n  MOVQ     RBX, XMM0 ; google help me for I know not what I have done\n  MOVQ     RAX, XMM2\n  cmp rbx, rax\n  setle al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213806,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  subss   xmm1, xmm4\n  mulss   xmm1, xmm1\n  subss   xmm0, xmm3\n  mulss   xmm0, xmm0\n  addss   xmm0, xmm1\n  addss   xmm5, xmm2\n  mulss   xmm5, xmm5\n  comiss  xmm0, xmm5\n  setb   al\n  \n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213807,"user_id":null,"body":"global is_collision\nis_collision:\n  shufps xmm0,xmm1,0\n  shufps xmm3,xmm4,0\n  subps  xmm0,xmm3\n  dpps   xmm0,xmm0,10100001b\n  addss  xmm2,xmm5\n  mulss  xmm2,xmm2\n  comiss xmm0,xmm2\n  sbb    rax,rax\n  and    al,1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213808,"user_id":null,"body":"global is_collision\nsection .text\n; input: xmm0 = x1, xmm1 = y1, xmm2 = r1, xmm3 = x2, xmm4 = y2, xmm5 = r2\n; output: al\nis_collision:\n  xor    rax, rax\n  subss  xmm0, xmm3\n  subss  xmm1, xmm4\n  addss  xmm2, xmm5\n  \n  mulss  xmm0, xmm0\n  mulss  xmm1, xmm1\n  mulss  xmm2, xmm2\n  addss  xmm0, xmm1\n  \n  cmpless  xmm0, xmm2\n  cvttss2si eax, xmm0\n  test   eax, eax\n  setnz  al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59a8570b570190d313000037":[{"id":213809,"user_id":null,"body":"global sumcubes\n\nsumcubes:\n    mov rax, rdi\n    inc rdi\n    imul rax, rdi\n    imul rax, rax\n    shr rax, 2\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213810,"user_id":null,"body":"global sumcubes\nsumcubes:\n    mov rbx, 1\n    mov rcx, 0\n    looping:\n      mov rax, rbx\n      mul rbx\n      mul rbx\n      add rcx, rax\n      cmp rbx, rdi\n      je fin\n      inc rbx\n      jmp looping\n    fin:\n      mov rax, rcx\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213811,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n  lea rax, [rdi + 2]\n  imul rax, rdi\n  imul rdi, rdi\n  add rax, 1\n  imul rax, rdi\n  shr rax, 2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213812,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n  movzx esi, di\n  lea eax, [rsi+1]\n  mul esi\n  shr eax, 1\n  mul rax\n  ret\n; -----> endof sumcubes <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213813,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n    xor rax, rax        ; RAX <- the result\n    xor rcx,rcx \nm1:\n    mov rax, rdi;\n    mul rax;\n    mul rdi;\n    add rcx, rax;\n    dec rdi;\n    jnz m1;\n    \n    mov rax,rcx;\n    ret\n; -----> endof sumcubes <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213814,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n    xor rax, rax        ; RAX <- the result\n    xor rcx, rcx\nloop:\n    test rdi, rdi\n    jz return\n    mov rax,rdi\n    mul rdi\n    mul rdi\n    add rcx, rax\n    dec rdi\n    jmp loop\n    \n    \n return:\n    mov rax, rcx\n    ret\n; -----> endof sumcubes <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213815,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n    xor rax, rax        ; RAX <- the result\n    xor rcx, rcx\nloop:\n    test rdi, rdi\n    jz return\n    mov rax,rdi\n    mov r10, rax\n    mul r10\n    mul r10\n    add rcx, rax\n    dec rdi\n    jmp loop\n    \n    \n return:\n    mov rax, rcx\n    ret\n; -----> endof sumcubes <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213816,"user_id":53,"body":"global sumcubes\n\nsumcubes:\n    movzx rdi, di   \n    lea rax, [rdi+1]  \n    mul rdi      \n    shr rax, 1   \n    mul rax \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213817,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n    xor   rsi, rsi\n    mov   rcx, rdi\nL1:\n    mov   rax, rcx\n    mul   rcx\n    mul   rcx\n    add   rsi, rax\n    loop  L1\n\n    mov   rax, rsi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213818,"user_id":null,"body":"global sumcubes\n\n; <-- RAX sumcubes(DI n) -->\nsumcubes:\n  mov rax, rdi\n  add rax, 1\n  imul rdi\n  shr rax, 1\n  imul rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59b401e24f98a813f9000026":[{"id":213819,"user_id":null,"body":"section .text\nglobal integer_depth\ninteger_depth:\n  mov r8, 1\n  xor esi, esi\n  mov rcx, 10\n  mov r9d, edi\n.loop:\n  cmp esi, 1023\n  mov eax, r9d\n  je .done\n.digitloop:\n  test eax, eax\n  je .lastdigit\n  cdq\n  idiv ecx\n  bts esi, edx\n  jmp .digitloop\n.lastdigit:\n  add r9d, edi\n  inc r8d\n  jmp .loop\n.done:\n  dec r8d\n  mov eax, r8d\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213820,"user_id":881,"body":"section .text\nglobal integer_depth\n\n; unsigned integer_depth(unsigned n);\ninteger_depth:\n    xor rsi, rsi\n    xor r9, r9\n    mov r10, 10\n    .for_each_depth:\n        inc rsi\n        mov rax, rdi\n        mul rsi\n        .for_each_digit:\n            xor rdx, rdx\n            div r10\n            mov cl, dl\n            mov rdx, 1\n            shl rdx, cl\n            or r9, rdx\n            test rax, rax\n            jnz .for_each_digit\n        cmp r9, 0x3ff\n        jne .for_each_depth\n    mov rax, rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213821,"user_id":50,"body":"section .text\nglobal integer_depth\ninteger_depth:\n                ; unsigned integer_depth (unsigned n)\n                ; rdi := sn\n  xor r8, r8    ; lookup\n  xor r9, r9    ; depth\n  mov r10, 10\n_loop1:\n  cmp r8, 0x3ff\n  je _exit\n  inc r9\n  mov rax, rdi\n  imul r9\n_loop2:\n  test rax, rax\n  jz _loop1\n  xor rdx, rdx\n  idiv r10\n  xor r11, r11\n  bts r11, rdx\n  or r8, r11\n  jmp _loop2\n_exit:\n  mov rax, r9\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59c0b9d4cb7fb4dd41000962":[{"id":213822,"user_id":168,"body":"section .text\nglobal bulb_maze\n\n; bool bulb_maze(const char *maze);\nbulb_maze:\n  xor eax, eax\n  mov ecx, 'o'\n.loop:  \n  movzx edx, byte [rdi]\n  inc rdi\n  cmp edx, ecx\n  jz .end\n  xor ecx, 23\n  test edx, edx\n  jnz .loop\n  mov eax, 1\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213823,"user_id":881,"body":"section .text\nglobal bulb_maze\n\n; bool bulb_maze(const char *maze);\nbulb_maze:\n    xor rax, rax\n    mov sil, 'x'\n.for_each_char:\n    xor sil, 'x' ^ 'o'\n    mov cl, byte[rdi]\n    inc rdi\n    cmp cl, sil\n    je .end\n    test cl, cl\n    jnz .for_each_char\n    inc rax\n.end:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213824,"user_id":null,"body":"section .text\nglobal bulb_maze\nbulb_maze:\n  xor eax,eax\n  xor esi,esi\n  .b:mov  cl,[rdi+rsi]\n     mov  dl,cl\n     shr  cl,4\n     jnc .f\n       xor  ecx,esi   \n       test ecx,1\n       je .exit\n     .f:\n     inc  rsi\n     test dl,dl\n  jne .b  \n  mov eax,1\n  .exit:  \nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213825,"user_id":null,"body":"section .text\nglobal bulb_maze\n\n; bool bulb_maze(const char *maze);\nbulb_maze:\n  mov rax, 111\n.loop:\n  movsx ecx, byte [rdi]\n  test ecx, ecx\n  je .done\n  movzx edx, al\n  cmp edx, ecx\n  je .done\n  mov eax, 231\n  inc rdi\n  sub eax, edx\n  jmp .loop\n.done:\n  test cl, cl\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213826,"user_id":null,"body":"section .text\nglobal bulb_maze\n\n; bool bulb_maze(const char *maze);\nbulb_maze:\n    mov rsi,rdi   ; rsi = pointer running in the string\n\n    ; case minute 0, 2, 4, ...\n.minute0:         \n    lodsb\n    test al, al   ; end of maze -> ok\n    jz  .true\n    cmp al, 'x'   ; no light in 0,2,.. -> ok\n    je  .minute1\n    cmp al, ' '\n    jne .false    ; other -> caught\n\n; case minute 1, 3, 5, ...\n.minute1:         \n    lodsb\n    test al, al   ; end of maze -> ok\n    jz  .true\n    cmp al, 'o'   ; no light in 1,3,.. -> ok\n    je  .minute0\n    cmp al, ' '   ; never light -> ok\n    je .minute0\n\n.false:\n    xor rax, rax\n    ret\n.true:\n    mov rax, 1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213827,"user_id":null,"body":"section .text\nglobal bulb_maze\nbulb_maze:\n    mov rcx, 0\nloop:\n    movzx rax, byte [rdi]\n    cmp rax, 0\n    je exit\n    inc rdi\n    inc rcx    \n    cmp rax, 32\n    je loop\n    add rax, rcx\n    and rax, 1\n    jne loop\n    ret\nexit:    \n    inc rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213828,"user_id":null,"body":"section .text\nglobal bulb_maze\nbulb_maze:\n    mov rcx, 0\nloop:\n    movzx rax, byte [rdi]\n    cmp rax, 0\n    je exit\n    inc rdi\n    inc rcx    \n    cmp rax, 32\n    je loop\n    add rax, rcx\n    and rax, 1\n    jne loop\n    ret\nexit:    \n    mov rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213829,"user_id":null,"body":"section .text\nglobal bulb_maze\nbulb_maze:\n    mov rcx, 0\nloop:\n    mov al, byte [rdi]\n    cmp al, 0\n    je exit\n    inc rdi\n    inc rcx    \n    cmp al, 32\n    je loop\n    add rax, rcx\n    and rax, 1\n    jne loop\n    ret\nexit:    \n    mov rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213830,"user_id":null,"body":"section .text\nglobal bulb_maze\nbulb_maze:\n    mov rcx, 0\nloop:\n    mov al, byte [rdi]\n    cmp al, 0\n    je exit\n    inc rdi\n    inc rcx    \n    cmp al, ' '\n    je loop\n    cmp al, 'x'\n    mov rax, rcx\n    je test\n    inc rax\ntest:\n    and rax, 1\n    jne loop\n    ret\nexit:    \n    mov rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213831,"user_id":null,"body":"section .text\nglobal bulb_maze\nbulb_maze:\n    mov rcx, 0\nloop:\n    mov al, byte [rdi]\n    cmp al, 0\n    je exit\n    inc rdi\n    inc rcx    \n    cmp al, ' '\n    je loop\n    mov rsi, rcx\n    cmp al, 'x'\n    je test\n    inc rsi\ntest:\n    test rsi, 1\n    je trap\n    jmp loop\ntrap:\n    mov rax, 0\n    ret\nexit:    \n    mov rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59c633e7dcc4053512000073":[{"id":213832,"user_id":168,"body":"global solve\n\nsection .text\n\nsolve:\n  xor eax, eax\n  xor esi, esi\n  xor r8d, r8d\n  mov ecx, 0b1000001000001000100010  ; vowels (shifted by 1)\n  jmp .loop_cond\n.loop:\n  inc rdi\n  sub dl, 'a' - 1\n  add esi, edx\n  bt ecx, edx\n  cmovc esi, r8d\n  cmp esi, eax\n  cmova eax, esi\n.loop_cond:\n  movzx edx, byte [rdi]\n  test edx, edx\n  jnz .loop\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213833,"user_id":null,"body":"global solve\n\nsection .text\n\n; <--- unsigned solve(const char *s) --->\nsolve:\n  xor eax, eax\n  mov r8d, 1173\n  xor ecx, ecx\n.loop:\n  movsx esi, byte [rdi]\n  test esi, esi\n  je .done\n  or esi, 32\n  lea edx, [rsi - 97]\n  ror dl, 1\n  cmp dl, 10\n  ja .cons\n  movzx edx, dl\n  bt r8, rdx\n  jae .cons\n  cmp ecx, eax\n  cmova eax, ecx\n  xor ecx, ecx\n.next:\n  inc rdi\n  jmp .loop\n.cons:\n  lea ecx, [rcx + rsi - 96]\n  jmp .next\n.done:\n  cmp ecx, eax\n  cmova eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213834,"user_id":173,"body":"global solve\n\nsection .text\n\n; <--- unsigned solve(const char *s) --->\nsolve:\n    ; maximum\n    mov r12, 0\n    ; current value\n    mov r13, 0\n    xor rcx, rcx\nl_l:\n    mov byte cl, [rdi]\n    cmp cl, 0\n    je l_done\n\n    call f_is_vowel\n    cmp al, 1\n    je l_vowel\n    add r13, rcx\n    sub r13, 96\n    jmp l_loop\nl_vowel:\n    cmp r13, r12\n    cmova r12, r13\n    mov r13, 0\nl_loop:\n    inc rdi\n    jmp l_l\nl_done:\n    cmp r13, r12\n    cmova r12, r13\n\n    mov rax, r12\n    ret\nf_is_vowel:\n    mov al, 0\n    cmp cl, 'a'\n    je l_iv\n    cmp cl, 'e'\n    je l_iv\n    cmp cl, 'i'\n    je l_iv\n    cmp cl, 'o'\n    je l_iv\n    cmp cl, 'u'\n    je l_iv\n    ret\nl_iv:\n    mov al, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213835,"user_id":null,"body":"global solve\n\nsection .text\n\n; <--- unsigned solve(const char *s) --->\nsolve:\n    xor   rax, rax        ; EAX <- the result\n    xor   rcx, rcx        ; Current\n    xor   rdx, rdx\n    .loop:\n    cmp   [rdi], byte 'a'\n    je    .v\n    cmp   [rdi], byte 'e'\n    je    .v\n    cmp   [rdi], byte 'i'\n    je    .v\n    cmp   [rdi], byte 'o'\n    je    .v\n    cmp   [rdi], byte 'u'\n    je    .v\n    mov   dl, [rdi]\n    add   rcx, rdx\n    sub   rcx, 96\n    .next:\n    inc   rdi\n    cmp   [rdi], byte 0\n    jne   .loop\n    .end:\n    cmp   rcx,rax\n    cmovg rax,rcx\n    ret\n    \n    .v:\n    cmp   rcx,rax\n    cmovg rax,rcx\n    xor   rcx,rcx\n    jmp   .next\n; ---------> endof solve <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213836,"user_id":null,"body":"global solve\n\nsolve:\n    xor eax, eax            ; max\n    xor ecx, ecx            ; accumulator for sum\n.str_loop:\n    movzx edx, byte [rdi]\n    inc rdi\n    cmp dl, 0               ; check if we have reached the end of the string\n    je .end\n    xor r8, r8              ; r8b = dl is one of a, e, i, o, u\n    cmp dl, 'a'\n    sete r9b\n    or r8b, r9b\n    cmp dl, 'e'\n    sete r9b\n    or r8b, r9b\n    cmp dl, 'i'\n    sete r9b\n    or r8b, r9b\n    cmp dl, 'o'\n    sete r9b\n    or r8b, r9b\n    cmp dl, 'u'\n    sete r9b\n    or r8b, r9b\n    jz .not_vowel\n    cmp ecx, eax\n    cmovg eax, ecx          ; update max\n    xor ecx, ecx            ; reset ecx\n    jmp .str_loop\n.not_vowel:\n    lea ecx, [ecx+edx-96]   ; ecx += value of this consonant\n    jmp .str_loop\n.end:\n    cmp ecx, eax\n    cmovg eax, ecx          ; one final (possible) update of max\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213837,"user_id":null,"body":"global solve\n\nsection .text\n\n; <--- unsigned {eax} solve(const {rdi} char *s) --->\nsolve:\n    xor eax, eax ; max\n    xor edx, edx ; to store char in lowest byte\n    xor ecx, ecx ; temp to store running sum\nlp:\n    mov dl, [rdi]\n    inc rdi\n    cmp dl, \"a\"\n    je break\n    cmp dl, \"e\"\n    je break\n    cmp dl, \"i\"\n    je break\n    cmp dl, \"o\"\n    je break\n    cmp dl, \"u\"\n    je break\n    cmp dl, 0\n    je break\n      add ecx, edx\n      add ecx, -96 ; -\"a\" + 1\n    jmp lp\nbreak:\n    cmp ecx, eax\n    cmovg eax, ecx\n    xor ecx, ecx\n    cmp dl, 0\n    jne lp\n    ret\n; ---------> endof solve <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213838,"user_id":null,"body":"global solve\n\nsection .data\n\nvowels: db \"aeiou\", 0\n\nsection .text\n\n; <--- unsigned solve(const char *s) --->\nsolve:\n  xor rsi, rsi\n  xor rax, rax\n  xor rcx, rcx\n  xor r8, r8\n  dec rsi\n\n.loop:\n  inc rsi\n  mov cl, [rdi + rsi]\n  cmp cl, 0\n  je .end\n  \n  xor rdx, rdx\n  dec rdx\n.loop.check:\n  inc rdx\n  cmp rdx, 5\n  jge .not_vowel\n  cmp cl, byte [vowels + rdx]\n  jne .loop.check\n  \n; is_vowel\n  cmp rax, r8\n  cmovl rax, r8\n  xor r8, r8\n  jmp .loop\n  \n.not_vowel:\n  sub cl, 'a' - 1\n  add r8, rcx\n  jmp .loop\n  \n.end:\n  cmp rax, r8\n  cmovl rax, r8\n  ret\n; ---------> endof solve <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213839,"user_id":525,"body":"global solve\n\nsection .text\n\n; <--- unsigned solve(const char *s) --->\nsolve:\n    movzx   eax, BYTE [rdi]\n    test    al, al\n    je      .fast_end\n    mov     edx, 0\n    mov     ecx, 0\n    mov     r8d, 1065233\n    jmp     .loop_body\n.reset_counter:\n    mov     edx, 0\n.loop_head:\n    cmp     ecx, edx\n    cmovb   ecx, edx\n    add     rdi, 1\n    movzx   eax, BYTE [rdi]\n    test    al, al\n    je      .loop_end\n.loop_body:\n    lea     esi, [rax-97]\n    bt      r8d, esi\n    jc      .reset_counter\n    cmp     sil, 25\n    ja      .reset_counter\n    movsx   eax, al\n    lea     edx, [rdx-96+rax]\n    jmp     .loop_head\n.fast_end:\n    mov     ecx, 0\n.loop_end:\n    mov     eax, ecx\n    ret\n; ---------> endof solve <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213840,"user_id":null,"body":"global solve\nglobal is_vowels\n\nsection .data\n  vowels: db 'aeiou', 0\n\nsection .text\n\nis_vowels:\n    xor al, al\n    xor ecx, ecx\n    mov dl, byte [rdi]\nfor_v:\n    cmp cl, 5\n    je end_v\n    cmp dl, byte [vowels + ecx]\n    je true\n    inc cl\n    jmp for_v\ntrue:\n    inc al\nend_v:\n    ret\n\n; <--- unsigned solve(const char *s) --->\nsolve:\n    xor eax, eax ; EAX <- the result\n    xor r9d, r9d\nbefor:\n    xor r8d, r8d\nfor:\n    cmp byte [rdi], 0\n    je end\n    push rax\n    call is_vowels\n    cmp al, 1\n    je l1\n    pop rax\n    mov r9b, byte [rdi]\n    sub r9b, 0x60\n    add r8d, r9d\n    inc rdi\n    jmp for   \nl1:\n    pop rax\n    inc rdi\n    cmp r8d, eax\n    jbe befor\n    mov eax, r8d\n    jmp befor\nend:\n    cmp r8d, eax\n    jbe end_end\n    mov eax, r8d\nend_end:\n    ret\n; ---------> endof solve <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213841,"user_id":null,"body":"global solve\nsection .text\nsolve:\n    xor rax,rax\n    xor r8,r8\n    xor r9,r9\n@l1:mov rdx, 0x6165696f75\n    mov al,[rdi]\n    inc rdi\n    test al,al\n    jz  @e\n@l2:cmp al,dl\n    je @l3\n    ror rdx,8\n    test dl,dl\n    jnz @l2\n    sub al,0x60\n    add r8,rax\n    jmp @l1\n@l3:cmp r8,r9\n    cmovg r9,r8\n    xor r8,r8\n    jmp @l1\n@e: cmp r8,r9\n    cmovg r9,r8\n    mov rax,r9\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59c9e82ea25c8c05860001aa":[{"id":213842,"user_id":527,"body":"global jump_to\nsection .text\njump_to:\n                lzcnt   ecx, edi\n                lzcnt   eax, esi\n                sub     ecx, eax\n                shrx    eax, esi, ecx\n                cmp     eax, edi\n                sbb     ecx, 0\n                bzhi    edx, esi, ecx\n                popcnt  edx, edx\n                shrx    eax, esi, ecx\n                sub     eax, edi\n                add     edx, ecx\n                add     eax, edx\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213843,"user_id":null,"body":"global jump_to\nsection .text\njump_to:\n  xor eax, eax\n.loop\n  cmp esi, edi\n  jbe .done\n  mov ecx, esi\n  mov edx, esi\n  shr ecx, 1\n  dec edx\n  cmp ecx, edi\n  cmovb ecx, edx\n  test sil, 1\n  cmovne ecx, edx\n  inc eax\n  mov esi, ecx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213844,"user_id":50,"body":"global jump_to\nsection .text\njump_to:\n                ; coding and coding...\n  xor eax, eax\n_loop:\n  cmp edi,esi\n  jge _exit\n  inc eax\n  test esi,1\n  jnz _dec\n  mov edx,edi\n  shl edx,1\n  cmp edx,esi\n  jg _dec\n  shr esi,1\n  jmp _loop\n_dec:\n  dec esi\n  jmp _loop\n_exit:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59ca8246d751df55cc00014c":[{"id":213845,"user_id":1277,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  shl esi, 1\n  cmp edi, esi\n  setge al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213846,"user_id":null,"body":"SECTION .text\nglobal hero\n\nhero:\n  mov eax, edi\n  xor edx, edx\n  div esi\n  cmp eax, 2\n  setae al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213847,"user_id":null,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  mov al, 1\n  shl esi, 1\n  sub edi, esi\n  cmp edi, 0\n  jl _no\n  ret\n_no:\n  mov al, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213848,"user_id":null,"body":"SECTION .text\nglobal hero\nhero:\n  mov eax, esi\n  mov ecx, 2\n  mul ecx\n  cmp edi, eax\n  jl loose\n  mov eax, 1\n  ret\nloose:\n  mov eax, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213849,"user_id":null,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  add esi, esi\n  cmp edi, esi\n  setae al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213850,"user_id":null,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  xor eax, eax\n  mov ebx, edi\n  shr ebx, 1\n  cmp ebx, esi\n  jl dead\n  mov eax, 1\n  dead:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213851,"user_id":null,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n\tadd\tesi, esi\n\tcmp\tesi, edi\n\tsetbe\tal\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213852,"user_id":null,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  xor eax,eax\n  mov ebx,1\n  shr edi, 1\n  cmp esi, edi\n  cmovle eax,ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213853,"user_id":173,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  xor eax, eax\n  shr rdi, 1\n  cmp rdi, rsi\n  setae al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213854,"user_id":null,"body":"SECTION .text\nglobal hero\n\n; Returns true if the hero will survive an encounter given a specific number of bullets and dragons.\n; arg0         = (uint32_t) The number of bullets.\n; arg1         = (uint32_t) The number of dragons.\n; return value = (bool)     True if the hero survives, false otherwise.\nhero:\n  xor     eax, eax\n  mov     ecx, 1\n  shr     rdi, 1\n  cmp     rdi,rsi\n  cmovge  eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59cfc000aeb2844d16000075":[{"id":213855,"user_id":null,"body":"global capitalize\nglobal contiguous\nextern malloc\nextern strlen\n\n; for ease you can allocate memory only once instead of several times\n; set <contiguous> to one for one contiguous allocation\n; set <contiguous> to zero for more than one allocation\nsection .rodata\ncontiguous: db  0\n\nsection .text\n\n; <--- char **capitalize(const char *s) --->\ncapitalize:\n  push r15\n  push r14\n  push r13\n  push r12\n  push rbx\n  mov r15, rdi\n  mov edi, 16\n  call malloc\n  mov rdi, r15\n  mov r14, rax\n  call strlen\n  lea r13, [rax + 1]\n  mov r12, rax\n  mov rdi, r13\n  call malloc\n  mov rdi, r13\n  mov rbx, rax\n  mov [r14], rax\n  call malloc\n  test r12, r12\n  mov [r14 + 8], rax\n  je .done\n  xor ecx, ecx\n.evenloop:\n  movzx edx, byte [r15 + rcx]\n  mov [rax + rcx], dl\n  and dl, -33\n  mov [rbx + rcx], dl\n  add rcx, 2\n  cmp r12, rcx\n  ja .evenloop\n  cmp r12, 2\n  jb .done\n  mov ecx, 1\n.oddloop:\n  movzx edx, byte [r15 + rcx]\n  mov [rbx + rcx], dl\n  and dl, -33\n  mov [rax + rcx], dl\n  add rcx, 2\n  cmp r12, rcx\n  ja .oddloop\n.done:\n  mov byte [rax + r12], 0\n  mov byte [rbx + r12], 0\n  mov rax, r14\n  pop rbx\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213856,"user_id":null,"body":"global capitalize\nglobal contiguous\nextern malloc\nextern strlen\n\n; for ease you can allocate memory only once instead of several times\n; set <contiguous> to one for one contiguous allocation\n; set <contiguous> to zero for more than one allocation\nsection .rodata\ncontiguous: db  1\n\nsection .text\n\n; <--- char **capitalize(const char *s) --->\ncapitalize:\n  push rdi\n  call strlen\n  push rax\n  push rbp\n  lea edi, [rax*2+32]\n  call malloc\n  pop rbp\n  pop rsi\n  pop rdi\n  test rax, rax\n  jz .done\n  \n  lea r8, [rax+16]\n  mov [rax], r8\n  lea r9, [rax+rsi+18]\n  mov [rax+8], r9\n  \n.loop:\n  mov cl, [rdi]\n  inc rdi\n  test cl, cl\n  jz .done1\n  mov [r9], cl\n  inc r9\n  sub cl, 'a'-'A'\n  mov [r8], cl\n  inc r8\n  \n  mov cl, [rdi]\n  inc rdi\n  test cl, cl\n  jz .done1\n  mov [r8], cl\n  inc r8\n  sub cl, 'a'-'A'\n  mov [r9], cl\n  inc r9\n  jmp .loop\n\n.done1:\n  mov [r8], cl\n  mov [r9], cl\n.done:\n  ret\n; ---------> endof cap <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213857,"user_id":null,"body":"global capitalize\nglobal contiguous\nextern malloc\n\n; for ease you can allocate memory only once instead of several times\n; set <contiguous> to one for one contiguous allocation\n; set <contiguous> to zero for more than one allocation\nsection .rodata\ncontiguous: db  1\n\nsection .text\n\n; <--- char **capitalize(const char *s) --->\ncapitalize:\n\n    ;get length of passed string (including null char)\n    mov   rsi,rdi\n    mov   rcx,0\n.rep:\n    inc   rcx\n    lodsb\n    cmp   al,0\n    jne   .rep\n\n    ;allocate a buffer for an array of strings\n    push  rdi\n    push  rcx\n    mov   rdi,rcx\n    shl   rdi,1\n    add   rdi,8+8\n    call  malloc\n    pop   rcx\n    pop   rdi\n    push  rax\n\n    ;set pointers\n    mov   rsi,rdi\n    mov   rdi,rax\n    add   rax,8+8\n    mov   [rdi],rax\n    add   rax,rcx\n    mov   [rdi+8],rax\n    add   rdi,8+8\n\n    ;capitalize strings\n    xor   ebx,ebx\n.loop:\n    lodsb\n    cmp   al,0\n    je    .end\n    cmp   al,'A'\n    jl    .noalpha\n    cmp   al,'Z'\n    jle   .alpha\n    cmp   al,'a'\n    jl    .noalpha\n    cmp   al,'z'\n    jg    .noalpha\n.alpha:\n    test   ebx,1\n    jnz   .odd\n    mov   byte[rdi+rcx],al\n    sub   al,32\n    mov   byte[rdi],al\n    jmp   .next\n.odd:\n    mov   byte[rdi],al\n    sub   al,32\n    mov   byte[rdi+rcx],al\n    jmp   .next\n.noalpha:\n    mov   byte[rdi],al\n    mov   byte[rdi+rcx],al\n.next:\n    inc   ebx\n    inc   rdi\n    jmp   .loop\n.end:\n    mov   byte[rdi],0\n    mov   byte[rdi+rcx],0\n    pop   rax\n    ret\n    \n; ---------> endof cap <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213858,"user_id":null,"body":"global capitalize\nglobal contiguous\nextern malloc\n\n; for ease you can allocate memory only once instead of several times\n; set <contiguous> to one for one contiguous allocation\n; set <contiguous> to zero for more than one allocation\nsection .rodata\ncontiguous: db  0\n\nsection .text\n\n; <--- char **capitalize(const char *s) --->\ncapitalize:\n    \n    ; String length\n    xor rax, rax\n    .lloop:\n    cmp byte[rdi+rax], 0\n    je .endLloop\n    inc rax\n    jmp .lloop\n    .endLloop:\n    \n    ; Allocate buffers\n    push rdi ; In ptr\n    push rax\n    inc rax\n    push rax\n    mov rdi, rax\n    call malloc\n    pop rdi\n    push rax ; Out 2\n    call malloc\n    push rax; Out 1\n    mov rdi, 16\n    call malloc\n    \n    pop r8 ; Out 1\n    pop r9 ; Out 2\n    pop r10 ; Length\n    pop r11 ; In\n    \n    push rax ; Output holder\n    \n    mov rdi, r8\n    mov rsi, r11\n    mov rdx, 0xFF\n    call cpy\n    mov rdi, r9\n    mov rsi, r11\n    mov rdx, 0\n    call cpy\n    \n    pop rax ; Output holder\n    mov qword[rax], r8\n    mov qword[rax+8], r9\n    \n    ret\ncpy:\n    ; rdi=out, rsi=in, dl=flag\n    ; rcx -> index\n    ; rax -> temp\n    xor rcx, rcx\n    xor rax, rax\n    .loop:\n    mov al, byte[rsi+rcx]\n    cmp dl, 0\n    je .test\n    xor al, 0x20\n    .test:\n    not dl\n    mov byte[rdi+rcx], al\n    cmp byte[rsi+rcx], 0\n    je .leave\n    inc rcx\n    jmp .loop\n    .leave:\n    mov byte[rdi+rcx], 0\n    ret\n; ---------> endof cap <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213859,"user_id":null,"body":"global capitalize\nglobal contiguous\n\nextern calloc\nextern strlen\n\n; for ease you can allocate memory only once instead of several times\n; set <contiguous> to one for one contiguous allocation\n; set <contiguous> to zero for more than one allocation\nsection .rodata\ncontiguous: db  1\n\nsection .text\n\n; <--- char **capitalize(const char *s) --->\ncapitalize:\n    push rdi\n    call strlen\n    push rax\n    lea rdi, [rax*2 + 18]\n    mov rsi, 1\n    call calloc\n    lea rdi, [rax + 16]\n    mov [rax], rdi\n    pop rcx ; strlen\n    add rdi, rcx\n    inc rdi ; \\0\n    mov [rax+8], rdi\n    pop rdi ; in str\n    \n    xor rdx, rdx ; counter\n    \n    .loop_check:\n    cmp rdx, rcx\n    jz .loop_end\n    \n    mov r8b, [rdi + rdx]\n    lea r9, [rax + rdx + 16]\n    mov [r9], r8b\n    mov [r9 + rcx + 1], r8b\n    \n    test rdx, 1\n    jz .even\n    sub byte [r9 + rcx + 1], 32\n    inc rdx\n    jmp .loop_check\n    \n    .even:\n    sub byte [r9], 32\n    inc rdx\n    jmp .loop_check\n    \n    .loop_end:\n    ret\n; ---------> endof cap <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213860,"user_id":null,"body":"global capitalize\nglobal contiguous\nextern strdup\nextern malloc\ncontiguous: db  1\ncapitalize:\n  call strdup\n  push rax\n  mov  rdi,rax\n  call strdup\n  push rax\n  mov  rdi,16\n  call malloc\n  pop  rdi\n  pop  rsi\n  mov  [rax],rdi\n  mov  [rax+8],rsi\n  push rax\n  .b:xor   byte[rdi],32\n     add   rdi,2\n     lodsw\n     xor   byte[rsi-1],32\n     mul   ah\n     test  ax,ax\n  jne .b  \n  cmp  byte[rdi-2],33\n  sbb  rdi,0\n  mov  byte[rdi-1],0\n  cmp  byte[rsi-1],33\n  sbb  rsi,0\n  mov  byte[rsi],0\n  pop  rax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213861,"user_id":168,"body":"global capitalize\nglobal contiguous\nextern malloc, strdup\n\n; for ease you can allocate memory only once instead of several times\n; set <contiguous> to one for one contiguous allocation\n; set <contiguous> to zero for more than one allocation\nsection .rodata\ncontiguous: db  0\n\nsection .text\n\n; <--- char **capitalize(const char *s) --->\ncapitalize:\n  push rbx\n  push rbp\n  push rdx\n  mov rbx, rdi\n  mov edi, 16\n  call malloc\n  mov rbp, rax\n  mov rdi, rbx\n  call strdup\n  mov qword [rbp], rax\n  mov rdi, rbx\n  mov rbx, rax\n  call strdup\n  mov qword [rbp + 8], rax\n.loop:\n  and byte [rbx], ~32\n  jz .end\n  or byte [rax], 32\n  xchg rbx, rax\n  inc rax\n  inc rbx\n  jmp .loop\n.end:\n  mov rax, rbp\n  pop rdx\n  pop rbp\n  pop rbx\n  ret\n; ---------> endof cap <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59e1b9ce7997cbecb9000014":[{"id":213862,"user_id":null,"body":"section .text\nglobal cog_rpm\ncog_rpm:         ; double cog_rpm(const int cogs[], unsigned count)\n                 ; input:  rdi = cogs, rsi = count\n                 ; output: xmm0\n                 \n      cvtsi2sd xmm0, [rdi]\n      movsx rax, dword [rsi*4+rdi-4]\n      test rsi, 1\n      jnz .after_negate\n      neg rax\n  .after_negate:\n      cvtsi2sd xmm1, rax\n      divsd xmm0, xmm1\n      ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213863,"user_id":null,"body":"global cog_rpm\n\nsection .text\n\n; <--- double cog_rpm(const int cogs[], unsigned count) --->\ncog_rpm:\n    mov eax, [rdi+rsi*4-4]    ; copying the cogs of the last gear\n    and esi, 1                ; whether the last gear rotates clockwise\n    jne .exit                 ; jumping to the .exit section\n    neg eax                   ; changing the direction to counterwise\n.exit:\n    cvtsi2sd xmm0, [rdi]      ; converting the cogs value of the first gear to double\n    cvtsi2sd xmm1, eax        ; converting the cogs value of the second gear to double\n    divsd xmm0, xmm1          ; getting RPM\n    ret\n; ---------> endof cog_rpm <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213864,"user_id":null,"body":"section .text\nglobal cog_rpm\ncog_rpm:         ; double cog_rpm(const int cogs[], unsigned count)\n  mov eax, esi\n  add esi, -1\n  and eax, 1\n  cvtsi2sd xmm1, dword [rdi + 4*rsi]\n  lea eax, [rax + rax - 1]\n  imul eax, dword [rdi]\n  cvtsi2sd xmm0, eax\n  divsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213865,"user_id":null,"body":"section .text\nglobal cog_rpm\ncog_rpm:         ; double cog_rpm(const int cogs[], unsigned count)\n  mov eax,[rdi+rsi*4-4]               ; input:  rdi = cogs, rsi = count\n  and rsi,1             ;    utput: xmm0\n  jnz .end\n  neg eax\n  .end:\n  cvtsi2sd xmm0,[rdi]\n  cvtsi2sd xmm1,eax\n  divsd xmm0,xmm1\n  ret            ; Your code here!\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213866,"user_id":null,"body":"global cog_rpm\ncog_rpm:\n  dec rsi\n  lea rdi,[rdi+rsi*4]\n  neg rsi\n  movsd xmm0,[one]\n  .b:cvtsi2sd xmm1,[rdi+rsi*4]\n     cvtsi2sd xmm2,[rdi+rsi*4+4]\n     divsd    xmm1,xmm2\n     mulsd    xmm0,xmm1\n     xorpd    xmm0,[minus]\n     inc      rsi\n  jne .b\nret  \nalign 16\nminus dq 0x8000000000000000\none   dq 1.0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213867,"user_id":null,"body":"section .text\nglobal cog_rpm\ncog_rpm:\n  push rbp\n  mov rbp, rsp\n  \n  ; Align stack for sse operations.\n  and rsp, -16\n  \n  mov eax, [rdi]\n  push rax\n  cvtsi2sd xmm0, [rsp]\n  add rsp, 8\n  \n  ; If count is even then multiply with -1 at the end\n  ; of the subroutine. This shows that the final cog\n  ; is anti-clockwise. If count is odd the do nothing\n  ; (multiply with -1).\n  mov rax, rsi\n  shr al, 1\n  setc al\n  shl al, 1\n  dec al\n  movsx rax, al\n  \n  dec rsi\n  \n  cvtsi2sd xmm1, [rdi + 4 * rsi]\n  divpd xmm0, xmm1\n  \nanti_clockwise:\n  push rax\n  cvtsi2sd xmm1, [rsp]\n  add rsp, 8\n  \n  mulpd xmm0, xmm1\n  \ncog_rpm_return:\n  mov rsp, rbp\n  pop rbp\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213868,"user_id":null,"body":"section .data\nsign_bit dq 8000000000000000h\n\nsection .text\nglobal cog_rpm\ncog_rpm:         ; double cog_rpm(const int cogs[], unsigned count)\n                 ; input:  rdi = cogs, rsi = count\n                 ; output: xmm0\n  cvtsi2sd xmm0, [rdi]\n  cvtsi2sd xmm1, [rdi + (rsi - 1) * 4]\n  divsd xmm0, xmm1\n  and rsi, 1\n  jnz clockwise\n  por xmm0, [sign_bit]\nclockwise:\n  ret         ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213869,"user_id":null,"body":"                 section .data\n                 \nnegone           dd      -1\n\n                 section .text\nglobal cog_rpm\ncog_rpm:         ; double cog_rpm(const int cogs[], unsigned count)\n                 ; input:  rdi = cogs, rsi = count\n                 ; output: xmm0\n                 \n                 cvtsi2sd     xmm0,   dword [rdi]\n                 lea          rdi,    [rdi + 4 * rsi - 4]\n                 cvtsi2sd     xmm1,   dword [rdi]\n                 \n                 divsd        xmm0,   xmm1\n    \n                 and          rsi,    1\n                 jnz          end\n                 \n                 cvtsi2sd     xmm1,   dword [negone]\n                 mulsd        xmm0,   xmm1\n                 \nend:\n    \n                ret            \n\n  \n  ; Your code here!\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213870,"user_id":null,"body":"section data\nnegone           dd      -1\n\nsection .text\nglobal cog_rpm\ncog_rpm:         ; double cog_rpm(const int cogs[], unsigned count)\n                 ; input:  rdi = cogs, rsi = count\n                 ; output: xmm0\n                 \n                 movd         xmm0,   dword [rdi]\n                 cvtdq2pd     xmm0,   xmm0\n                 lea          rdi,    [rdi + 4 * rsi - 4]\n                \n                 movd         xmm1,   dword [rdi]\n                 cvtdq2pd     xmm1,   xmm1\n                 \n                 divsd        xmm0,   xmm1\n    \n                 and          rsi,    1\n                 jnz          end\n                 \n                 movd         xmm1,   dword [negone]\n                 cvtdq2pd     xmm1,   xmm1\n                 \n                 mulsd        xmm0,   xmm1\n                 \nend:\n                \n  ret            ; Your code here!","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213871,"user_id":17,"body":"section .text\nglobal cog_rpm\ncog_rpm:\n  mov edx, esi\n  and edx, 1\n  imul edx, 2\n  dec edx\n  imul edx, dword [rdi]\n  and rsi, 0b1111111111111111111111111111111\n  dec rsi\n  imul rsi, 4\n  add rdi, rsi\n  cvtsi2sd xmm1, dword [rdi]\n  cvtsi2sd xmm0, edx\n  divsd xmm0, xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59e72bdcfc3c4974190000d9":[{"id":213872,"user_id":null,"body":"extern malloc\nsection .text\nglobal cog_rpm\ncog_rpm:        ; double *cog_rpm(const int cogs[], unsigned count, int n)\n  push rbp\n  push r14\n  push rbx\n  mov r14, rdi\n  mov edi, 16\n  mov ebp, edx\n  mov ebx, esi\n  call malloc\n  mov ecx, ebp\n  movdqa xmm0, [.ozzz]\n  movsxd rdx, ebp\n  shr ecx, 31\n  cvtsi2sd xmm2, dword [r14 + 4*rdx]\n  add ecx, ebp\n  and ecx, -2\n  sub ebp, ecx\n  mov ecx, ebx\n  dec ebx\n  movd xmm1, ebp\n  and ecx, 1\n  pinsrd xmm0, ecx, 1\n  pshufd xmm1, xmm1, 80\n  pcmpeqd xmm1, xmm0\n  por xmm1, [.oozz]\n  movddup xmm2, xmm2\n  cvtdq2pd xmm0, xmm1\n  movd xmm1, dword [r14]\n  pinsrd xmm1, dword [r14 + 4*rbx], 1\n  mulpd xmm2, xmm0\n  cvtdq2pd xmm0, xmm1\n  divpd xmm2, xmm0\n  movupd [rax], xmm2\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n.ozzz:\n  dd 1,0,0,0\n.oozz:\n  dd 1,1,0,0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213873,"user_id":568,"body":"section .text\nextern malloc\nglobal cog_rpm\n\ncog_rpm:                                ; double* (int *cogs(rdi), size_t count(rsi), int n(rdx))\n        push rdi\n        push rsi\n        push rdx\n        mov rdi, 16\n        call malloc\n        pop rdx\n        pop rsi\n        pop rdi\n\n        movsx rdx, edx\n\n        pxor xmm0, xmm0\n        cvtsi2sd xmm0, [rdi + rdx * 4]      ; n0(xmm0) = (double) cogs[n]\n\n        pxor xmm1, xmm1\n        movsd xmm1, xmm0                ; n1(xmm1) = n0\n\n        pxor xmm2, xmm2\n        cvtsi2sd xmm2, [rdi]            ; n0 \/= (double) cogs[0]\n        divsd xmm0, xmm2\n\n        pxor xmm2, xmm2\n        cvtsi2sd xmm2, [rdi + (rsi - 1) * 4]  ; n1 \/= (double) cogs[count - 1]\n        divsd xmm1, xmm2\n\n        xor ecx, ecx                    ; odd0(rcx) = n & 1\n        mov r8, rdx\n        shr r8, 1\n        setc cl\n\n        mulsd xmm0, [8 * rcx + .neg]    ; n0 *= neg[odd0]\n\n        sub rsi, rdx                    ; odd1(rcx) = (count - n) & 1\n        shr rsi, 1\n        setnc cl\n\n        mulsd xmm1, [8 * rcx + .neg]    ; n1 *= neg[odd1]\n\n        movsd [rax], xmm0               ; arr[0] = n0\n        movsd [rax + 8], xmm1           ; arr[1] = n1\n\n        ret                             ; return\n\nsection .rodata\n\n.neg:                                   ; const neg[2] = { 1.0, -1.0 }\n        dq +1.0\n        dq -1.0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213874,"user_id":17,"body":"section .text\nglobal cog_rpm\nextern malloc\ncog_rpm:\n  push rdi\n  push rsi\n  push rdx\n  mov rdi, 16\n  call malloc\n  pop rdx\n  pop rsi\n  pop rdi\n  mov ecx, edx\n  inc ecx\n  and ecx, 1\n  imul ecx, 2\n  dec ecx\n  imul ecx, dword [rdi + rdx * 4]\n  cvtsi2sd xmm0, ecx\n  cvtsi2sd xmm1, dword [rdi]\n  divsd xmm0, xmm1\n  movsd qword [rax], xmm0\n  mov ecx, esi\n  sub ecx, edx\n  and ecx, 1\n  imul ecx, 2\n  dec ecx\n  imul ecx, dword [rdi + rdx * 4]\n  cvtsi2sd xmm0, ecx\n  cvtsi2sd xmm1, dword [rdi + rsi * 4 - 4]\n  divsd xmm0, xmm1\n  movsd qword [rax + 8], xmm0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213875,"user_id":168,"body":"section .text\nextern malloc\nglobal cog_rpm\ncog_rpm:        ; double *cog_rpm(const int cogs[], unsigned count, int n)\n                ; input:  rdi = cogs, esi = count, edx = n\n                ; output: rax\n  push rdi\n  push rsi\n  push rdx\n  mov rdi, 16\n  call malloc\n  pop rdx\n  pop rsi\n  pop rdi\n  mov esi, esi\n  mov edx, edx\n  mov ecx, dword [rdi + rsi * 4 - 4]\n  sub esi, edx\n  test esi, 1\n  jnz .continue1\n  neg ecx\n.continue1:\n  shl rcx, 32\n  mov esi, dword [rdi]\n  test edx, 1\n  jz .continue2\n  neg esi\n.continue2:\n  or rcx, rsi\n  movq xmm0, rcx\n  cvtdq2pd xmm0, xmm0\n  cvtsi2sd xmm1, dword [rdi + rdx * 4]\n  movddup xmm1, xmm1\n  divpd xmm1, xmm0\n  movupd [rax], xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213876,"user_id":168,"body":"section .text\nextern malloc\nglobal cog_rpm\ncog_rpm:        ; double *cog_rpm(const int cogs[], unsigned count, int n)\n                ; input:  rdi = cogs, esi = count, edx = n\n                ; output: rax\n  push rdi\n  push rsi\n  push rdx\n  mov rdi, 16\n  call malloc\n  pop rdx\n  pop rsi\n  pop rdi\n  mov esi, esi\n  mov edx, edx\n  mov ecx, dword [rdi + rsi * 4 - 4]\n  sub esi, edx\n  test esi, 1\n  jnz .continue1\n  neg ecx\n.continue1:\n  shl rcx, 32\n  mov esi, dword [rdi]\n  test edx, 1\n  jz .continue2\n  neg esi\n.continue2:\n  or rcx, rsi\n  movd mm0, rcx\n  cvtpi2pd xmm0, mm0\n  cvtsi2sd xmm1, dword [rdi + rdx * 4]\n  movddup xmm1, xmm1\n  divpd xmm1, xmm0\n  movupd [rax], xmm1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213877,"user_id":1315,"body":"section .text\nextern malloc\nglobal cog_rpm\ncog_rpm:        ; double *cog_rpm(const int cogs[], unsigned count, int n)\n                ; input:  rdi = cogs, rsi = count, rdx = n\n                ; output: rax\n  push     rdi               ; save parameters\n  push     rsi\n  push     rdx\n  mov      rdi, 2*8          ; rax := a = (double *)malloc(2 * sizeof(double))\n  call     malloc\n  pop      r10               ; r10 := n\n  pop      r11               ; r11 := count\n  pop      r12               ; r12 := cogs\n  mov      rbx, -1           ; xmm0 = -1.0\n  push     rbx\n  cvtsi2sd xmm0, [rsp]\n  pop      rbx\n  cvtsi2sd xmm1, [r12]       ; xmm1 = cogs[0]\n  cvtsi2sd xmm2, [r12+4*r10] ; xmm2 = cogs[n]\n  dec      r11\n  cvtsi2sd xmm3, [r12+4*r11] ; xmm3 = cogs[count-1]  \n  mov      rbx, r10          ; if n is odd\n  and      rbx, 1\n  jz       no_sign1\n  mulsd    xmm1, xmm0       ; then xmm1 *= -1\nno_sign1:\n  sub      r11, r10         ; if count - n is odd\n  and      r11, 1\n  jz       no_sign2\n  mulsd    xmm3, xmm0       ; then xmm3 *= -1\nno_sign2:\n  vdivsd   xmm0, xmm2, xmm1 ; a[0] = cogs[n] \/ cogs[0]\n  movsd    [rax], xmm0\n  vdivsd   xmm0, xmm2, xmm3 ; a[1] = cogs[n] \/ cogs[count-1]\n  movsd    [rax+8], xmm0\n  ret                       ; return a","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59fa8e2646d8433ee200003f":[{"id":213878,"user_id":527,"body":"extern qsort\n\nsection .text\n\nglobal sort_by_bit\n; input: rdi = arr, rsi = length\nsort_by_bit:\n                mov     rdx, 4\n                mov     rcx, comparator\n                jmp     qsort\n\ncomparator:\n                mov     edi, [rdi]\n                mov     esi, [rsi]\n                popcnt  eax, edi\n                popcnt  edx, esi\n                cmp     edi, esi\n                setg    dil\n                setl    sil\n                sub     dil, sil\n                movsx   edi, dil\n                sub     eax, edx\n                cmovz   eax, edi\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213879,"user_id":null,"body":"global sort_by_bit\n\nsection .text\n\n; <--- int *sort_by_bit(int *arr, size_t len) --->\nsort_by_bit:\n    lea r8, [rsi*4]             ; loading R8 with <len*sizeof(int)> as <nbyte>\n    sub rsp, r8                 ; allocating memory in the stack for <bits>\n    mov r11, rsp                ; pointing R11 to the beginning of <bits>\n    push r8                     ; saving <nbyte> in the stack\n    push rbx                    ; saving RBX in the stack\n    mov rcx, rsi                ; loading RCX with <len> as <n>\n    dec rcx                     ; decrementing <n>\n.loop:\n    lea r8, [rcx*4]             ; loading R8 with <n*4> as <ndx>\n    mov ebx, [rdi+r8]           ; loading EBX with <*(arr+ndx)> as <num>\n    popcnt edx, ebx             ; loading EDX with the bits count of <num> as <bitcnt>\n    mov r10, rsi                ; loading R10 with <len> as <i>\n.srch:\n    dec r10                     ; decrementing <i>\n    cmp r10, rcx                ; whether <i> is equal to <n>\n    je .ins                     ; jumping to the .ins label\n    lea r9, [r10*4]             ; loading R9 with <i*4> as <inx>\n    cmp edx, [r11+r9]           ; whether <bitcnt> is less than <*(bits+inx)>\n    jl .srch                    ; jumping to the next .srch iteration\n    jg .exch                    ; otherwise, if greater, jumping to the .exch label\n    cmp ebx, [rdi+r9]           ; whether <num> is greater then <*(arr+inx)>\n    jle .srch                   ; otherwise, jumping to the next .srch iteration\n.exch:\n    xchg edx, [r11+r9]          ; exchanging <bitcnt> with <*(bits+inx)>\n    xchg ebx, [rdi+r9]          ; exchanging <num> with <*(arr+inx)>\n    mov [rdi+r8], ebx           ; saving the exchanged <num> in <*(arr+ndx)>\n    jmp .srch                   ; jumping to the next .srch iteration\n.ins:\n    mov [r11+r8], edx           ; inserting <bitcnt> into <*(bits+ndx)>\n    dec rcx                     ; decrementing <n>\n    jge .loop                   ; jumping to the next .label it`eration if not negative\n.exit:\n    pop rbx                     ; restoring RBX from the stack\n    pop r8                      ; restoring <nbyte> from the stack\n    add rsp, r8                 ; destroyting <bits> and restoring the stack boundary\n    mov rax, rdi                ; pointing RAX to <arr> to return\n    ret\n; ---------> endof sort_by_bit <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213880,"user_id":null,"body":"extern qsort\nsection .text\nglobal sort_by_bit\n; input: rdi = arr, rsi = length\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsort_by_bit:\n  mov edx, 4\n  mov ecx, cmp\n  jmp qsort\n\ncmp:\n  mov eax, [rdi]\n  mov ecx, [rsi]\n  xor edi, edi\n  popcnt edx, eax\n  popcnt esi, ecx\n  cmp eax, ecx\n  setg dil\n  xor eax, eax\n  cmp edx, esi\n  seta al\n  cmovne edi, eax\n  lea eax, [rdi + rdi - 1]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213881,"user_id":null,"body":"section .text\nglobal sort_by_bit\nextern qsort\n\ncompare:\n  xor eax, eax\n  mov edi, [rdi]\n  mov esi, [rsi]\n  popcnt ecx, edi\n  popcnt edx, esi\n  cmp ecx, edx\n  jg .g\n  jl .l\n  cmp edi, esi\n  jl .l\n  je .e\n.g:\n  inc eax\n  ret\n.l:\n  dec eax\n.e:\n  ret\n  \n; input: rdi = arr, rsi = length\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsort_by_bit:\n  push rsp\n  mov rdx, 4\n  lea rcx, [compare]\n  call qsort\n  pop rsp  \n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213882,"user_id":null,"body":"global sort_by_bit\nsort_by_bit:\n    lea rcx, [rsi-1]\n.L1:\n    push rcx\n    lea rcx, [rsi-1]\n.L2:\n    popcnt eax, [rdi+4*rcx]\n    popcnt edx, [rdi+4*rcx-4]\n    cmp edx, eax\n    mov eax, [rdi+4*rcx]\n    mov edx, [rdi+4*rcx-4]\n    jl .L3\n    je .L4\n    mov [rdi+4*rcx], edx\n    mov [rdi+4*rcx-4], eax\n    jmp .L3\n.L4:\n    cmp edx, eax\n    jle .L3\n    mov [rdi+4*rcx], edx\n    mov [rdi+4*rcx-4], eax\n.L3:\n    loop .L2\n    pop rcx\n    loop .L1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213883,"user_id":null,"body":"section .text\nglobal sort_by_bit\n; input: rdi = arr, rsi = length\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsort_by_bit:\n    lea rcx, [rsi-1]\n.L1:\n    push rcx\n    lea rcx, [rsi-1]\n.L2:\n    popcnt eax, dword [rdi+4*rcx]\n    popcnt edx, dword [rdi+4*rcx-4]\n    \n    ;  [  edx   ]  [  eax   ]  if eax < edx, swap\n    cmp edx, eax\n    mov eax, dword [rdi+4*rcx]\n    mov edx, dword [rdi+4*rcx-4]\n    jl .L3\n    je .L4\n    mov dword [rdi+4*rcx], edx\n    mov dword [rdi+4*rcx-4], eax\n    jmp .L3\n.L4:\n    cmp edx, eax\n    jle .L3\n    mov dword [rdi+4*rcx], edx\n    mov dword [rdi+4*rcx-4], eax\n.L3:\n    loop .L2\n    pop rcx\n    loop .L1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213884,"user_id":null,"body":"section .text\nglobal sort_by_bit\n; input: rdi = arr, rsi = length\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsort_by_bit:\n  xor rax, rax\n  dec rsi\n  jnz sexyloop\n  ret\nsexyloop:\n  cmp rax, rsi\n  je sort_by_bit\n  mov ecx, [rdi+4*rax]\n  mov edx, [rdi+4*rax+4]\n  xor r9, r9\n  mov r8d, ecx\nlpc:\n  shr r8d, 1\n  jnc lc\n  inc r9\nlc:\n  test r8d, r8d\n  jnz lpc\n  xor r10, r10\n  mov r8d, edx\nlpd:\n  shr r8d, 1\n  jnc ld\n  inc r10\nld:\n  test r8d, r8d\n  jnz lpd\n  cmp r9, r10\n  jl sorted\n  je equal\n  xchg ecx, edx\n  jmp sorted\nequal:\n  cmp ecx, edx\n  jle sorted\n  xchg ecx, edx\nsorted:\n  mov [rdi+4*rax], ecx\n  mov [rdi+4*rax+4], edx\n  inc rax\n  jmp sexyloop","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213885,"user_id":null,"body":"section .text\nglobal sort_by_bit\n; input: rdi = arr, rsi = length\n; callee saved registers: rbx, rsp, rbp, r12-r15\nsort_by_bit:\n  \n.outer_loop:\n  dec rsi\n  jz .done\n  xor rdx, rdx\n.inner_loop:\n  mov r8d, [rdi + rdx * 4]\n  mov r9d, [rdi + rdx * 4 + 4]\n  popcnt r10d, r8d\n  popcnt r11d, r9d\n  cmp r10d, r11d\n  ja .swap\n  jb .next\n  cmp r8d, r9d\n  jle .next\n.swap:\n  mov [rdi + rdx * 4], r9d\n  mov [rdi + rdx * 4 + 4], r8d\n.next:\n  inc rdx\n  cmp rdx, rsi\n  jae .outer_loop\n  jmp .inner_loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213886,"user_id":null,"body":"section .text\n\nglobal sort_by_bit\n\nextern qsort\n\n;---\n\ncompare_bits:\n        mov     ecx, dword [rdi]\n        mov     edx, dword [rsi]\n        popcnt  eax, ecx\n        popcnt  esi, edx\n        sub     eax, esi\n        jne     popcnts_differ\n        \n        xor     esi, esi\n        cmp     ecx, edx\n        setl    sil\n        neg     esi\n        cmp     ecx, edx\n        mov     eax, 1\n        cmovle  eax, esi\n\npopcnts_differ:\n        ret\n\n;---\n\nsort_by_bit:\n        push    rax\n        mov     edx, 4\n        mov     ecx, compare_bits\n        xor     eax, eax\n        call    qsort\n        pop     rax\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213887,"user_id":null,"body":"; 6kyu kata - using bubblesort for not-so-large array\n; rdi - address of array\n; rsi - num items \nsection .text\nglobal sort_by_bit\nsort_by_bit:\n    xor r8,r8\n@outer_loop:  \n    xor r9,r9            ; Flag for modified\n    lea rcx,[rsi -2]     ; Index in array\n@inner_loop:\n    popcnt eax,dword [rdi + rcx * 4]\n    popcnt edx,dword [rdi + rcx * 4 + 4]\n    cmp ax,dx\n    jl @no_swap\n    mov r10d,[rdi + rcx * 4]\n    mov r11d,[rdi + rcx * 4 + 4]\n    jg @swap\n    cmp r10d, r11d\n    jle @no_swap\n@swap:\n    mov [rdi + rcx * 4],r11d\n    mov [rdi + rcx * 4 +4],r10d\n    setg r9b\n@no_swap:    \n    dec rcx\n    jns @inner_loop\n    test r9,r9\n    jnz @outer_loop ; As long as one tableentry was moved - loop again\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59fca81a5712f9fa4700159a":[{"id":213888,"user_id":null,"body":"global to_binary\n\nsection .text\n\nto_binary:\n    xor rax, rax\n    mov rcx,16\n    .b:imul rax,rax,10\n       shl  di,1\n       adc  rax,0\n    loop .b   \n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213889,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n\n    ; di - input argument\n  ; si - copy of input arg, gets its bits shifted every iteration\n  ; ecx - counter\n  ; r8 - accumulated result\n  ; rbx - number to add to result if current bit is set (gets multiplied by 10 every iteration)\n\n  xor r8, r8\n  xor esi, esi\n  mov ebx, 1\n  mov si, di\n  mov ecx, 16\n\n  result_add:\n\n    mov edx, 1\n    and dx, si\n    shr si, 1\n\n    test edx, edx\n    jz increment_rbx\n\n    add r8, rbx\n\n    increment_rbx:\n\n      mov eax, 10\n      mul rbx\n      mov rbx, rax\n\n  loop result_add\n\n  mov rax, r8\n  ret\n\n; -----> end of tobin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213890,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n    xor rax, rax        ; RAX <- the result\n    mov rcx, 1\n    \n  myloop:\n    shr di, 1\n    jnc notone\n    \n    add rax, rcx\n  notone:\n    imul rcx, 10\n    \n    cmp di, 0\n    jne myloop\n    \n    ret\n; -----> end of tobin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213891,"user_id":527,"body":"global to_binary\n\nsection .text\n\n; unsigned long long to_binary(unsigned short num)\nto_binary:\n                xor     eax, eax\n                mov     ecx, 15\n.loop:          lea     rax, [rax * 5]\n                bt      edi, ecx\n                adc     rax, rax\n                dec     ecx\n                jge     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213892,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n    xor rax, rax        ; RAX <- the result\n    xor rbx, rbx\n    mov rcx, 1\n    loop:\n    rcr rdi, 1\n    adc rbx, 0\n   imul rbx, rcx\n    add rax, rbx\n   imul rcx, 10\n    xor rbx, rbx\n    cmp rdi, 0\n    jnz loop\n    ret\n; -----> end of tobin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213893,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n\tlzcnt\teax, edi\n\tmov\tecx, -2147483648\n\tshrx\tecx, ecx, eax\n\txor\teax, eax\n\ttest\tcx, cx\n\tje\t.done\n.loop:\n\tadd\trax, rax\n\tlea\trdx, [rax + 4*rax]\n\txor\teax, eax\n\ttest\tecx, edi\n\tsetne\tal\n\tor\trax, rdx\n\tshr\tecx, 1\n\tand\tecx, 32767\n\tjne\t.loop\n.done:\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213894,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n    xor   rax, rax        ; RAX <- the result\n    mov   rcx, 1\n    .loop:\n      xor   rbx, rbx\n      mov   bx, di\n      and   bx, 1\n      imul  rbx, rcx\n      add   rax, rbx\n      imul  rcx, 10\n      shr   di, 1\n      cmp   di, 0\n    jne   .loop\n    ret\n; -----> end of tobin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213895,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n  mov rax, rdi\n  xor rcx, rcx\n  mov r8, 2\n  mov r9, 1\n  \n.loop:\n  cmp rax, 0\n  jz  .exit\n  xor rdx, rdx\n  idiv r8\n  imul rdx, r9\n  add rcx, rdx\n  imul r9, 10\n  jmp .loop\n  \n .exit:\n  mov rax, rcx\n  ret\n; -----> end of tobin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213896,"user_id":50,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n    mov r10,1 ; p\n    mov rax,rdi ;num\n    xor rbx,rbx ;tmp\n    xor rcx,rcx ; o\n    mov r8,10\n_loop:\n  cmp rax,0\n  je _exit\n  mov rbx,rax\n  shr rax,1\n  and rbx,1\n  imul rbx,r10\n  imul r10,r8\n  add rcx,rbx\n  jmp _loop\n_exit:\n  mov rax,rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213897,"user_id":null,"body":"global to_binary\n\nsection .text\n\n; <--- unsigned long long to_binary(unsigned short num) --->\nto_binary:\n    mov   rax, 1\n    xor   rdx, rdx      ; rdx:rax \"10-value\" of current bit\n    mov   r8, 10\n    xor   r9, r9        ; sum up the result in r9\n.loop:    \n    shr   rdi, 1        ; check current bit\n    jnc   .digit0\n    add   r9, rax       ; bit is set => add current 10-value\n.digit0:\n    mul   r8            ; 10 value of next bit\n    test  rdi, rdi\n    jnz   .loop         ; repeat until all bits handled\n    mov   rax, r9\n    ret\n; -----> end of tobin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a00e05cc374cb34d100000d":[{"id":213898,"user_id":null,"body":"extern malloc\n\nglobal reverse_seq\nsection .text\nreverse_seq:\n  mov [rsi], rdi\n  push rdi\n  shl rdi, 2\n  call malloc\n  pop rdi\n  push rax\nloop:\n  mov [rax], edi\n  add rax, 4\n  dec rdi\n  jnz loop\n  pop rax ; result = NULL\n  ret ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213899,"user_id":null,"body":"global reverse_seq\nsection .text\nextern malloc\n\n; int *reverse_seq(int n, size_t *size)\nreverse_seq:\n  push rdi\n  push rsi\n  shl rdi, 2 ;rdi *= 4\n  call malloc ;rax = malloc(sizeof(int) * edi)\n  pop rsi\n  pop rdi\n  xor rcx, rcx ;offset\n  \n.loop:\n  mov DWORD [rax + 4 * rcx], edi\n  inc rcx\n  dec edi\n  test edi, edi\n  jnz .loop\n  \n  mov QWORD [rsi], rcx ;set *size\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213900,"user_id":null,"body":"global reverse_seq\nextern malloc\nsection .text\nreverse_seq:\n\tpush\tr15\n\tpush\tr14\n\tpush\trbx\n\tmov\tr14, rsi\n\ttest\tedi, edi\n\tje\t.done\n\tmov\tebx, edi\n\tmov\tr15d, edi\n\tlea\trdi, [4*r15]\n\tcall\tmalloc\n\ttest\trax, rax\n\tje\t.done\n\tmov\t[r14], r15\n\tmov\trcx, rax\n.loop:\n\tmov\t[rcx], ebx\n\tadd\trcx, 4\n\tdec\tebx\n\tjne\t.loop\n\tpop\trbx\n\tpop\tr14\n\tpop\tr15\n\tret\n.done:\n\tmov\tdword [r14], 0\n\txor\teax, eax\n\tpop\trbx\n\tpop\tr14\n\tpop\tr15\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213901,"user_id":null,"body":"extern malloc\n\nglobal reverse_seq\nsection .text\nreverse_seq:\n  mov  [rsi], rdi\n  push rdi\n  shl rdi, 2\n  call malloc\n  pop rcx\n  mov rsi, rax\n.loop:\n  mov [rsi], ecx\n  add rsi, 4\n  loop .loop\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213902,"user_id":null,"body":"extern malloc\n\nglobal reverse_seq\nsection .text\nreverse_seq:\n  mov  [rsi], rdi\n  push rdi\n  imul rdi, 5\n  call malloc\n  pop rcx\n  mov rsi, rax\n.loop:\n  mov [rsi], rcx\n  add rsi, 4\n  loop .loop\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213903,"user_id":881,"body":"section .text\nglobal reverse_seq\nextern malloc\n\nreverse_seq:\n    mov [rsi], rdi\n    test rdi, rdi\n    jz .end\n    push rdi\n    lea rdi, [rdi * 4]\n    call malloc\n    pop rdi\n    xor rsi, rsi\n.for_each_n:\n    mov [rax + rsi * 4], edi\n    inc rsi\n    dec rdi\n    jnz .for_each_n\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213904,"user_id":null,"body":"global reverse_seq\nextern malloc\n\nsection .text\nreverse_seq:\n    mov qword [rsi], rdi ; return number of items in the array\n    push rdi             ; save number of items\n    sal rdi, 2           ; rdi = size of array in bytes, 4 bytes per item\n    call malloc\n    pop rcx              ; rcx = number of items\n    or rcx, rcx\n    jz return            ; no items, return\n    or rax, rax\n    jz return            ; malloc failed, returned null\n    xor rdi, rdi         ; rdi = index in the array\nstore:\n    mov dword [rax+rdi*4], ecx\n    inc rdi\n    loop store\nreturn:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213905,"user_id":173,"body":"extern malloc\nglobal reverse_seq\nsection .text\nreverse_seq:\n  mov r15, rsi\n  mov qword [rsi], rdi\n\n  mov esi, 11\n  mov edx, 0\n  mov eax, edi\n  mov ecx, 4\n  mul ecx\n  mov r12d, eax\n  \n  push rdi\n  mov rdi, r12\n  call malloc\n  pop rdi\n  mov r13, rax\n  mov r14, rax\n  \nl_loop:\n  mov dword [r13], edi\n  add r13, 4\n  dec rdi\n  cmp rdi, 0\n  ja l_loop\n\n  mov rax, r14\n  ret ; return result","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213906,"user_id":null,"body":"extern malloc\nglobal reverse_seq\n\nsection .text\nreverse_seq:\n  ;rdi = int n\n  ;rsi = size_t *expected\n  ;rax = int *ret[n]\n  xor r15,r15\n  xor rax,rax\n  \n  mov r15, rdi        ; r15 = rdi = n\n  mov [rsi], rdi      ; *rsi = rdi\n  imul rdi,5          ; wtf *4 crash\n  call malloc         ; malloc(rdi)\n  xor rcx,rcx         ; rcx = i = 0\n  mov rbx, rax        ; *rbx = &rax\n  mov [rbx], r15      ; rbx[0] = r15 = n\n  loop1:              ; while(r15 > 0)\n  add rbx, 4          ; rbx += sizeof(int)\n  dec r15             ; r15--\n  mov [rbx], r15      ; *rbx = r15\n  cmp r15, 0\n  jne loop1\n  end:           \n  ret                 ; return rax","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213907,"user_id":null,"body":"extern malloc\n\nsection .bss\n  nums resq 1\n  \nglobal reverse_seq\nsection .text\n\nreverse_seq:\n  push rdi\n  mov [rsi], rdi\n  shl rdi, 3\n  call malloc\n  mov [nums], rax\n  pop rcx\n   \n  xor r8, r8\n  \n.for:\n  mov dword [rax + r8 * 4] , ecx\n  inc r8\n  loop .for\n\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a023c426975981341000014":[{"id":213908,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  lea rax, [rdi + rsi - 180]\n  neg rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213909,"user_id":null,"body":"SECTION .text\nglobal other_angle\nother_angle:\n  mov rax, 180\n  sub rax, rdi\n  sub rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213910,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  mov eax,180\n  add edi,esi\n  cmp edi,0\n  jg okay\n  neg edi\n  okay:\n  sub eax,edi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213911,"user_id":null,"body":"section .text\nglobal other_angle\n\nother_angle:\n  mov ax, 180\n  sub ax, si\n  sub ax, di\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213912,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  xor eax, eax\n  mov ebx, edi\n  add ebx, esi\n  mov eax, 180\n  sub eax, ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213913,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1 , rdi\n; arg1         = (int32_t) Angle2 , rsi\n; return value = (int32_t) Angle3?\nother_angle:\n  xor eax, eax\n  add rax, 180\n  sub rax, rdi\n  sub rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213914,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  mov eax, 180    ; sum of all angles = 180\u00b0\n  sub eax, edi\n  sub eax, esi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213915,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  xor eax, eax\n  mov eax, edi\n  add eax, esi\n  mov ebx, 180\n  sub ebx,eax\n  mov eax,ebx\n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213916,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  xor eax, eax\n  mov eax, 180\n  sub eax, edi\n  sub eax, esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213917,"user_id":null,"body":"SECTION .text\nglobal other_angle\n; Returns the third angle (in degrees) of a triangle\n; arg0         = (int32_t) Angle1\n; arg1         = (int32_t) Angle2\n; return value = (int32_t) Angle3?\nother_angle:\n  xor rax, rax\n  mov rax, rdi\n  add rax, rsi\n  sub rax, 180\n  xor rax, -1\n  add rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a03b3f6a1c9040084001765":[{"id":213918,"user_id":527,"body":"section .text\nglobal angle\nangle:\n                sub     edi, 2\n                imul    eax, edi, 180\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213919,"user_id":null,"body":"section .text\nglobal angle\nangle:  \n  mov eax, edi ; edi = arg0\n  \n  mov r8d, eax\n  sub r8d, 2\n  \n  mov eax, r8d\n  mov r8d, 180\n  \n  mul r8d\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213920,"user_id":null,"body":"section .text\nglobal angle\nangle:  \n  mov rax, rdi\n  sub rax, 2\n  mov rdx, 180\n  imul rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213921,"user_id":null,"body":"section .text\nglobal angle\nangle:\n  lea eax, [rdi-2]\n  imul eax, 180\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213922,"user_id":null,"body":"section .text\nglobal angle\nangle:  \n  mov eax, edi ; edi = arg0\n  sub eax,2\n  mov edi,180\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213923,"user_id":null,"body":"section .text\nglobal angle\nangle:\n  lea eax, [edi-2]\n  imul eax, eax, 180\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213924,"user_id":null,"body":"section .text\nglobal angle\nangle:  \n  mov eax, edi ; edi = arg0\n  dec rax\n  dec rax\n  xor edx, edx\n  mov ebx, 180\n  mul ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213925,"user_id":null,"body":"section .text\nglobal angle\nangle:\n    lea   eax, [edi-2]\n    mov   ecx, 180\n    mul   ecx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213926,"user_id":null,"body":"section .text\nglobal angle\nangle:\n  lea edi, [edi*4]\n  lea edi, [edi*9]\n  lea eax, [5*edi - 360]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213927,"user_id":null,"body":"global angle\nangle:   imul    edi, ((1<<(1<<1))+1)*((1<<((1<<1)+1))+1)<<(1<<1)\n         lea     eax, [edi-(((1<<(1<<1))+1)*((1<<((1<<1)+1))+1)<<((1<<1)+1))]\n         ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a057ec846d843c81a0000ad":[{"id":213928,"user_id":null,"body":"section .text\nglobal cycle\n; int cycle(int n)\ncycle:\n  mov eax, edi\n  mov ecx, 5\n  cdq\n  idiv ecx\n  or ecx, -1\n  test edx, edx\n  je .done\n  test dil, 1\n  je .done\n  mov edx, 1\n  xor ecx, ecx\n  movsx rdi, edi\n.exploop:\n  imul rax, rdx, 10\n  inc ecx\n  cqo\n  idiv rdi\n  cmp rdx, 1\n  jne .exploop\n.done:\n  mov eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213929,"user_id":null,"body":"section .text\nglobal cycle\n; int cycle(int n)\ncycle:\n  test edi, 1\n  jz .bailout\n  mov eax, edi\n  xor edx, edx\n  mov ecx, 5\n  div ecx\n  test edx, edx\n  jz .bailout\n  \n  mov edx, 1\n  xor esi, esi\n  mov rcx, rax\n  \n.loop:\n  inc esi\n  lea edx, [rdx*5]\n  lea eax, [rdx*2]\n  xor edx, edx\n  div edi\n  cmp edx, 1\n  jne .loop\n    \n  mov eax, esi\n  ret\n\n.bailout:\n  mov eax, -1\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213930,"user_id":50,"body":"section .text\nglobal cycle\n; int cycle(int n)\ncycle:\n  mov rax,rdi ; n\/a to rax\n  mov rbx,10 ; b\n _gcd:\n  test rbx,rbx ; b == 0\n  jz _exitGcd\n  xor rdx,rdx\n  div rbx ; a\/=b, rdx= a%b\n  mov rax,rbx ; rax = b\n  mov rbx,rdx ; rbx = a%b\n  jmp _gcd ; gcd b a%b\n_exitGcd: ; rax= gcd n 10\n  cmp rax,1\n  jne _retMinusOne\n  mov rax,10\n  xor rdx,rdx\n  div rdi ; rdx=10\/n, rdx=10%n \n  mov rcx,1 ; counter i\n  mov rbx,10\n_loop:\n  cmp rdx,1\n  je _retI\n  inc rcx\n  mov rax,rdx ; rax=tmp\n  mul rbx ; rax=tmp*10\n  xor rdx,rdx\n  div rdi ; rax=(tmp*10)\/n, remainder in rdx\n  jmp _loop\n_retMinusOne:\n  mov rax,-1\n  ret\n_retI:\n  mov rax,rcx ; rax=i\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213931,"user_id":77,"body":"section .text\nglobal cycle\n; int cycle(int n)\ncycle:\n  test rdi, 1\n  jz .no\n  mov rax, rdi\n  xor rdx, rdx\n  mov rsi, 5\n  div rsi\n  test rdx, rdx\n  jz .no\n  shl rsi, 1\n  mov rax, 1\n  mov rcx, 1\n.loop:\n  mul rsi\n  div rdi\n  cmp rdx, 1\n  je .end\n  mov rax, rdx\n  inc rcx\n  jmp .loop\n.end:\n  mov rax, rcx\n  ret\n.no:\n  mov rax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213932,"user_id":null,"body":"section .text\n\nglobal cycle\n; int cycle(int n -> edi)\ncycle:\n  test edi, 1\n  jz .skip\n\n  mov esi, 5\n  xor edx, edx\n  mov eax, edi\n  div esi\n  test edx, edx\n  jz .skip\n\n  mov esi, -1\n  mov r8d, 1\n\n  .loop:\n  imul r8d, 10  \n  mov eax, r8d\n  xor edx, edx\n  div edi\n  mov r8d, edx\n\n  add esi, 1\n  cmovz ecx, edx\n  jz .loop\n\n  cmp ecx, 1000\n  jz .skip\n  \n  cmp ecx, edx\n  jnz .loop\n\n  mov eax, esi\n  ret\n\n  .skip:\n  mov eax, -1\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213933,"user_id":null,"body":"extern printf\n\nglobal cycle\n\nlimit   equ 1000000\n\nsection .data\n    n5      db  5\n\nsection .text\n\n    cycle:\n        test        rdi, rdi\n        jz          .nfound         ; \u043d\u043e\u043b\u044c \u0432 \u0437\u043d\u0430\u043c\u0435\u043d\u0430\u0442\u0435\u043b\u0435\n\n        test        rdi, 1\n        jz          .nfound         ; \u0434\u0435\u043b\u0438\u043c\u043e\u0441\u0442\u044c \u043d\u0430 2\n\n        mov         rcx, 8\n        mov         rbx, rdi\n        xor         ah, ah\n    .loop2:\n        rol         rbx, 8\n        mov         al, bl\n\n    .next2:\n        div         byte [n5]\n        loop        .loop2\n\n        test        ah, ah\n        jz          .nfound         ; \u0434\u0435\u043b\u0438\u043c\u043e\u0441\u0442\u044c \u043d\u0430 5\n\n        xor         rcx, rcx\n        mov         rax, 10\n        mov         rbx, rax\n\n    .loop:\n        inc         rcx\n        xor         rdx, rdx\n        div         rdi\n\n        cmp         rdx, 1\n        jne          .next\n\n        mov         rax, rcx\n        ret\n\n    .next:\n        mov         rax, rdx\n        mul         rbx\n\n        cmp         rcx, limit\n        jl          .loop\n\n    .nfound:\n        mov         rax, -1\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213934,"user_id":743,"body":"global cycle\n\nsection .text\n\n; eax           edi\n; int cycle(int n);\ncycle:\n  mov eax, -1\n  test edi, 1\n  jz .end\n  imul esi, edi, 0xcccccccd\n  add esi, 0x19999999\n  cmp esi, 0x33333332\n  jbe .end\n  xor ecx, ecx\n  mov edx, 1\n.loop:\n  add edx, edx\n  lea eax, [rdx + rdx * 4]\n  xor edx, edx\n  div edi\n  add ecx, 1\n  cmp edx, 1\n  jne .loop\n  mov eax, ecx\n.end:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213935,"user_id":743,"body":"global cycle\n\nsection .bss\n\nVis resb 100000000\n\nsection .text\n\n; eax           edi\n; int cycle(int n);\ncycle:\n  mov eax, -1\n  test edi, 1\n  jz .end\n  imul esi, edi, 0xcccccccd\n  add esi, 0x19999999\n  cmp esi, 0x33333332\n  jbe .end\n  mov esi, edi\n  mov ecx, edi\n  mov rdi, Vis\n  mov eax, 1\n  rep stosb\n  mov edx, 1\n.loop:\n  add edx, edx\n  lea eax, [rdx + rdx * 4]\n  xor edx, edx\n  div esi\n  xor eax, eax\n  xchg al, [Vis + rdx]\n  test eax, eax\n  jz .endl\n  add ecx, 1\n  jmp .loop\n.endl:\n  mov eax, ecx\n.end\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213936,"user_id":null,"body":"section .text\nglobal cycle\n; int cycle(int n)\ncycle:\n  mov ecx, -1   ; ecx is our return value, since we need eax for math\n  cmp edi, 2\n  jbe .done\n  mov esi, 10\n  mov eax, edi\n  xor edx, edx\n  div esi\n  test edx, 1\n  jz .done\n  cmp edx, 5\n  jz .done\n  \n  mov edx, 1\n  inc ecx\n  \n.next_digit:\n  mov eax, edx\n  mul esi\n  div edi\n  inc ecx\n  cmp edx, 1\n  jne .next_digit\n\n.done:\n  mov rax, rcx\n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213937,"user_id":168,"body":"section .text\nglobal cycle\n; int cycle(int n)\ncycle:\n  test edi, 1\n  jz .no_cycle\n  mov eax, edi\n  xor edx, edx\n  mov ecx, 5\n  div ecx\n  test edx, edx\n  jz .no_cycle\n  xor ecx, ecx\n  mov eax, 1\n.loop:\n  imul eax, 10\n  xor edx, edx\n  div edi\n  mov eax, edx\n  inc ecx\n  cmp eax, 1\n  jne .loop\n  mov eax, ecx\n  ret\n.no_cycle:\n  xor eax, eax\n  not eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a0d38c9697598b67a000041":[{"id":213938,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n  mov eax, 1\n.loop:\n  mov dl, [rdi]\n  test dl, dl\n  je .done\n  inc rdi\n  cmp dl, 49\n  jne .loop\n  add rax, rax\n  jmp .loop\n.done:\n  dec rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213939,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n  xor eax, eax\n  \n.loop:\n  mov dl, [rdi]\n  inc rdi\n  cmp dl, '1'\n  jne .skip\n  lea rax, [rax*2+1]\n.skip:\n  test dl, dl\n  jnz .loop\n  \n.done:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213940,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor rax, rax ; return value in RAX;sum=0\n    mov rdx,1;base=1\ncheck_null:\n    cmp byte [rdi],0\n    jne not_null\n    ret\nnot_null:\n    cmp byte [rdi],'1'\n    jne pass\n    add rax,rdx;sum+=base\n    imul rdx,2;base*=2\npass:\n    add rdi,1\n    jmp check_null","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213941,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor rax, rax ; return value in RAX\n    xor rdx,rdx;sum=0\n    add rax,1;base=1\ncheck_null:\n    cmp byte [rdi],0\n    jne not_null\n    mov rax,rdx;return sum\n    ret\nnot_null:\n    cmp byte [rdi],'1'\n    jne pass\n    add rdx,rax;sum+=base\n    imul rax,2;base*=2\npass:\n    add rdi,1\n    jmp check_null","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213942,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor   rax, rax ; return value in RAX\n    mov   dl, 1\n    .loop:\n    xor   cl, cl\n    cmp   byte [rdi], '1'\n    cmove ecx, edx\n    add   al, cl\n    sal   rax, cl\n    inc   rdi\n    cmp   [rdi], byte 0\n    jne   .loop\n    shr   rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213943,"user_id":104,"body":"; 2021 nomennescio\nsection .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits (const char* number (RDI));\neliminate_unset_bits:\n  xor rcx, rcx\nloop:\n  mov sil, [rdi]\n  test sil, sil\n  je exit\n  cmp sil, 49\n  sbb cl, -1\n  inc rdi\n  jmp loop\nexit:\n  mov rax, 1\n  shl rax, cl\n  dec rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213944,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor rdx,rdx\n    mov rsi,rdi\n.char:    \n    lodsb\n    test al,al\n    jz .done\n    rcr al,1\n    jnc .char\n    rcl rdx,1\n    jmp .char\n.done:\n    mov rax,rdx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213945,"user_id":50,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor rax, rax ; return value in RAX\n_loop:\n  cmp byte[rdi],0\n  je _exit\n  cmp byte[rdi],49\n  je _inc\n  inc rdi\n  jmp _loop\n_inc:\n  shl rax,1\n  inc rax\n  inc rdi\n  jmp _loop\n_exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213946,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor rax, rax\n    mov rcx, 1\nstrloop:\n    mov dl, [rdi]\n    cmp dl, 0\n    je exitloop       ; test for end of string \n    inc rdi           ; prepare to read next byte in next iteration\n    cmp dl, \"0\"\n    je strloop        ; \"0\" is ignored\n    or rax, rcx       ; OR result with rcx\n    shl rcx, 1        ; which is initialised with 1, but gets shifted to\n    jmp strloop       ;     the left with every further \"1\"\nexitloop:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213947,"user_id":null,"body":"section .text\nglobal eliminate_unset_bits\n\n; unsigned long eliminate_unset_bits(const char* number (RDI));\neliminate_unset_bits:\n    xor rax, rax      ; collect the 1 bits in rax\n    mov ch,'1'        ; the symbol of a 1 bit\n    jmp .next\n.one:\n    stc               ; push a 1 bit into rax\n    rcl rax,1\n.next:\n    mov cl, [rdi]     ; read char from strinh\n    inc rdi           ; move pointer to next char\n    cmp cl,ch\n    je  .one          ; current char is '1', and not end\n    test cl,cl\n    jnz  .next        ; current char is not end\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a1a9e5032b8b98477000004":[{"id":213948,"user_id":null,"body":"segment .text\nglobal even_last\neven_last:\n  xor eax, eax\n  test rsi, rsi\n  je .done\n  xor edx, edx\n.loop:\n  add eax, [rdi+rdx*4]\n  add rdx, 2\n  cmp rdx, rsi\n  jb .loop\n  imul eax, [rdi-4+rsi*4]\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213949,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\neven_last:    ; <--- Code here\n  xor eax, eax\n  test rsi, rsi\n  jz .quit\n  mov ecx, [rdi+rsi*4-4]\n\n.loop:\n  add eax, [rdi]\n  add rdi, 8\n  sub rsi, 2\n  jg .loop\n\n  mul ecx\n.quit:\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213950,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\neven_last:    ; <--- Code here\n    xor rbx,rbx;i=0\n    xor rax,rax;sum=0\n    mov rdx,rsi\n    imul rdx,4\n    add rdx,rdi\n    sub rdx,4;last integer\ncheck_size:\n    cmp rbx,rsi\n    jl in_loop\n    imul eax,dword[rdx]\n    ret\nin_loop:\n    add eax,dword[rdi]\n    add rbx,2\n    add rdi,8\n    jmp check_size","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213951,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\neven_last:    ; <--- Code here\n  xor   rax, rax\n  xor   rcx, rcx\n  mov   rbx, rsi\n  dec   rbx\n  mov   rbx, [rdi+rbx*4]\n  .loop:\n  add   rax, [rdi]\n  add   rdi, 8\n  add   rcx, 2\n  cmp   rcx, rsi\n  jl   .loop\n  mov   rcx, rbx\n  mul   rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213952,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\neven_last:    ; <--- Code here\n  xor rcx, rcx\n  xor eax, eax\n  dec rsi\n  .loop:\n  cmp rcx, rsi\n  jg .done\n  add eax, [rdi+rcx*4]\n  add rcx, 2\n  jmp .loop\n  .done:\n  imul eax, [rdi+rsi*4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213953,"user_id":null,"body":"global even_last\neven_last:\n  xor eax,eax\n  mov edx,[rdi+rsi*4-4]\n  inc rsi\n  or  rsi,1\n  jmp .f\n  .b:mulx ecx,r8d,[rdi+rsi*4-4]\n     add  eax,r8d\n  .f:sub  rsi,2\n  jnle .b  \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213954,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\neven_last:    ; <--- Code here            \n              xor eax,eax\n              test rsi,rsi\n              jz .stop\n              xor r8d,r8d\n              mov r9d,[rdi+4*rsi-4]\n              xchg rsi,rdi\n.loop:        lodsd\n              add r8d,eax\n              add rsi,4\n              sub rdi,2\n              ja .loop\n.mul:         mov eax,r8d\n              imul eax,r9d\n.stop:        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213955,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\n\neven_last:    ; <--- Code here\n  xor rax, rax\n  cmp rsi, 0              \n  jz .exit\n  \n  xor r8, r8\n  mov r9, 2\n  \n.loop:\n  add eax, dword [rdi + r8 * 4]\n  add r8, r9\n  cmp r8, rsi\n  jl .loop\n  imul eax, dword [rdi + rsi * 4 - 4] \n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213956,"user_id":null,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nglobal even_last\neven_last:\n    xor rax, rax      ; return value\n    xor rcx, rcx      ; loop counter\n.arrLoop:\n    cmp rcx, rsi\n    jz .breakArrLoop  ; test for end of array\n    mov rdx, rcx\n    shr rdx, 1\n    mov edx, [rdi+4*rcx]\n    jc .odd           ; test for index being odd\n    add rax, rdx      ; add to rax\n.odd:\n    inc rcx\n    jmp .arrLoop\n.breakArrLoop:\n    mul edx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213957,"user_id":50,"body":"; RDI will hold a pointer to an array of 32 bit ints\n; RSI will hold the size number of entries in the array\n; Return the product in EAX\n\nsegment .text\nglobal even_last\neven_last:    ; <--- Code here\n    mov r8d,[rdi+4*(rsi-1)] ; last value\n    xor eax,eax\n    xor ebx,ebx ; tmp result\n    xor rcx,rcx ; indexer\n_loop:\n  cmp rcx,rsi\n  jge _exit\n  mov eax,[rdi+4*rcx]\n  add rcx,2\n  mul r8d\n  add ebx,eax\n  jmp _loop\n_exit:\n  mov eax,ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a24254fe1ce0ec2eb000078":[{"id":213958,"user_id":null,"body":"section .text\nglobal solve\n; long solve(const char *str, long idx)\nsolve:\n  mov rax, -1\n  cmp byte[rdi+rsi], '('\n  jz l1\n  ret\nl1:\n  mov rax, 1\nmain:\n  inc rsi\n  cmp  byte[rdi+rsi], '('\n  jnz l2\n  inc rax\nl2:\n  cmp  byte[rdi+rsi], ')'\n  jnz l3\n  dec rax\nl3:\n  test rax, rax\n  jnz main\n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213959,"user_id":null,"body":"global solve\n\nsection .text\n\n; <--- long solve(const char *str, long idx) --->\nsolve:\n    mov rax, -1                 ; setting RAX to minus one as <ind>\n    cmp byte [rdi+rsi], '('     ; whether <idx> is not an opening brace\n    jne .exit                   ; jumping to exit\n    mov rcx, 1                  ; setting RCX to one as the braces count to match <cnt>\n.loop:\n    inc rsi                     ; incrementing <idx>\n    mov dl, [rdi+rsi]           ; copying <*(str+idx)> to DL as <c>\n    test dl, dl                 ; whether <c> is the null character\n    je .exit                    ; jumping to exit\n    cmp dl, '('                 ; whether <c> is one more opening brace\n    jne .alt                    ; otherwise, jumping to the .alt section\n    inc rcx                     ; incrementing <cnt>\n    jmp .loop                   ; jumping to the next iteration\n.alt:\n    cmp dl, ')'                 ; whether <c> is the closing brace\n    jne .loop                   ; otherwise, jumping to the next iteration\n    dec rcx                     ; decrementing the braces count to match <cnt>\n    jg .loop                    ; jumping to the next iteration in case unmatched left\n    mov rax, rsi                ; otherwise, saving <idx> to <ind>\n.exit:\n    ret\n; ---------> endof strind <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213960,"user_id":743,"body":"section .text\nglobal solve\n; rax                    rdi       rsi\n; long solve(const char* str, long idx);\nsolve:\n  xor rax, rax\n  cmp byte [rdi + rsi], '('\n  je .op\n  not rax\n  ret\n.op:\n  add rax, 1\n.loop:\n  add rsi, 1\n  cmp byte [rdi + rsi], '('\n  je .op\n  cmp byte [rdi + rsi], ')'\n  jne .loop\n  sub rax, 1\n  jnz .loop\n  mov rax, rsi\n  ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213961,"user_id":null,"body":"section .text\nglobal solve\n; long solve(const char *str, long idx)\nsolve:\n  cmp byte [rdi + rsi], 40\n  jne .end\n  mov rax, rsi\n  mov ecx, 1\n.loop:\n  movzx edx, byte [rdi + rax + 1]\n  test dl, dl\n  je .end\n  add rax, 1\n  cmp dl, 41\n  je .close\n  cmp dl, 40\n  jne .loop\n  add ecx, 1\n  jmp .loop\n.close:\n  add ecx, -1\n  jne .loop\n  jmp .done\n.end:\n  mov rax, -1\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213962,"user_id":46,"body":"section .text\n_strlen:\n  push rcx\n\n  xor rax, rax\n  _count_loop:\n    mov cl, byte [ rdi + rax ]\n\n    inc rax\n    cmp cl, 0x0\n    jne _count_loop\n\n  dec rax\n  pop rcx\n  ret\n\nglobal solve\nsolve:\n  mov cl, byte [ rdi + rsi ]\n  cmp cl, 40\n  jne _ret_neg1\n  \n  call _strlen\n  mov rbx, rax\n  xor rax, rax\n  _loop:\n    mov cl, byte [ rdi + rsi ]\n    cmp cl, 40\n    je _inc_count\n    jmp _after_inc_count\n    _inc_count:\n      inc rax\n    _after_inc_count:\n    cmp cl, 41\n    je _dec_count\n    jmp _after_dec_count\n    _dec_count:\n      dec rax\n    _after_dec_count:\n    \n    cmp rax, 0\n    jne _after_return\n      mov rax, rsi\n      ret\n    _after_return:\n    inc rsi\n    cmp rsi, rbx\n    js _loop\n    \n  \n  _ret_neg1:\n    mov rax, -1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213963,"user_id":null,"body":"section .text\nglobal solve\n; long solve(const char *str, long idx)\nsolve:\n  movzx eax,byte[rdi+rsi]\n  cmp al, '('\n  jne .invalid\n  mov ecx,1\n.loop:\n  inc rsi\n  movzx eax,byte[rsi+rdi]\n  test eax,eax\n  je .invalid\n  cmp al, '('\n  sete dl\n  add ecx,edx\n  cmp al, ')'\n  sete dl\n  sub ecx,edx\n  jnz .loop\n  mov rax,rsi\n  ret\n.invalid:\n  mov rax,-1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213964,"user_id":null,"body":"section .text\nglobal solve\n; long solve(const char *str (RDI), long idx (RSI))\nsolve:\n  mov al, [rdi+rsi]\n  cmp al, '('\n  jne .nope\n  mov rax, rsi\n  xor rdx, rdx\n  inc rdx\n.loop:\n  inc rax\n  mov cl, [rdi+rax]\n  cmp cl, '('\n  je .up\n  cmp cl, ')'\n  je .down\n  jmp .loop\n.up:\n  inc rdx\n  jmp .loop\n.down:\n  dec rdx\n  jnz .loop\n  ret\n.nope:\n  xor rax, rax\n  not rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213965,"user_id":null,"body":"section .text\nglobal solve\n\n; long solve(const char *str, long idx)\nsolve:\n  xor ecx, ecx\n  \n  cmp byte [rdi + rsi], '('\n  jne L_no_open_paren\n  \nL_loop:\n  movzx r8d, byte [rdi + rsi]\n  inc rsi\n  \n  xor edx, edx  ;  EDX = inc counter\n  cmp r8d, '('\n  sete dl\n  \n  xor eax, eax  ; EAX = dec counter\n  cmp r8d, ')'\n  sete al\n  \n  add ecx, edx\n  sub ecx, eax\n  jnz L_loop\n  \n  lea rax, [rsi - 1]\n  ret\n\nL_no_open_paren:\n  mov rax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213966,"user_id":null,"body":"section .text\nglobal solve\n\nsolve:\n  cmp byte[rdi + rsi], '('\n  jne solve.no_paren\n\n  mov rcx, rsi\n  mov r8, 1\n.search:\n  inc rcx\n  mov al, byte [rdi + rcx]\n  cmp al, ')'\n  je solve.found_c_paren\n  cmp al, '('\n  je solve.found_o_paren\n\n  cmp al, 0\n  jne solve.search\n  jmp solve.no_paren\n\n.found_c_paren:\n  dec r8\n  mov rax, rcx\n  cmp r8, 0\n  je solve.end\n  jmp solve.search\n\n.found_o_paren:\n  inc r8\n  jmp solve.search\n\n.no_paren:\n  mov rax, -1\n.end:\n\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213967,"user_id":null,"body":"section .text\nglobal solve\n\n; We need a function to increment or decrement a counter, and advance the input.\ndoIt:\n  cmp byte [rdi], 40\n  jne .check_close\n  inc rsi\n  inc rdi\n  ret\n.check_close:\n  cmp byte [rdi], 41\n  jne .end\n  dec rsi\n  inc rdi\n  ret\n.end:\n  inc rdi\n  ret\n\n; long solve(const char *str, long idx)\nsolve:\n  ; Get to the index in question.\n  push rdi\n  add rdi, rsi \n  cmp byte [rdi], 40\n  jne .fail\n  ; Cool so we have an opening paren.\n  ; Every opening paren should increment a count and every closing paren should decrement a count.\n  ; When we reach zero we have our index.\n  ; Let's reserve rsi for this count.\n  mov rsi, 1\n  inc rdi\n.main_loop:\n  cmp rsi, 0\n  je .sucess\n  call doIt\n  jmp .main_loop\n  \n  \n .sucess:\n   mov rax,rdi\n   pop rdi\n   sub rax,rdi\n   dec rax\n   ret\n\n.fail:\n  pop rdi\n  mov rax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a25ac6ac5e284cfbe000111":[{"id":213968,"user_id":null,"body":"extern strlen,strdup,free\nglobal triangle\n\nsection .text\n\n; <-- EAX triangle(ro [byte RDI] clrs) -->\ntriangle:\n  push rbx\n  sub rsp, 16\n  mov [rsp+8], rdi\n  call strlen\n  cmp rax, 1\n  mov rdi, [rsp+8]\n  jne .dupstr\n  mov bl, byte [rdi]\n  jmp .done\n.dupstr:\n  mov rbx, rax\n  call strdup\n  mov rdi, rax\n  lea rcx, [rbx-1]\n.reduce:\n  mov rsi, rdi\n  lea r8, [rdi+rcx]\n.eachpair:\n  movsx eax, byte [rsi]\n  movsx edx, byte [rsi+1]\n  sub edx, eax\n  mov eax, edx\n  sar eax, 31\n  xor edx, eax\n  sub edx, eax\n  cmp edx, 11\n  je .B\n  cmp edx, 16\n  je .G\n  cmp edx, 5\n  jne .next\n  mov byte [rsi], 82\n  jmp .next\n.B:\n  mov byte [rsi], 66\n  jmp .next\n.G:\n  mov byte [rsi], 71\n.next:\n  inc rsi\n  cmp r8, rsi\n  jne .eachpair\n  dec rcx\n  jne .reduce\n  mov bl, byte [rdi]\n  call free\n.done:\n  add rsp, 16\n  mov eax, ebx\n  pop rbx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213969,"user_id":null,"body":"global triangle\nextern strdup, free\n\nsection .text\n\n; <-- EAX triangle(ro [byte RDI] clrs) -->\ntriangle:\n  cmp byte [rdi+1], 0\n  je .bailout\n  \n  push rbp\n  call strdup\n  pop rbp\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  mov rsi, rax\n  \n.loop:\n  mov ax, [rdi]\n  inc rdi\n  test ah, ah\n  jz .linedone\n  cmp ax, \"RG\"\n  je .b\n  cmp ax, \"RB\"\n  je .g\n  cmp ax, \"GR\"\n  je .b\n  cmp ax, \"GB\"\n  je .r\n  cmp ax, \"BR\"\n  je .g\n  cmp ax, \"BG\"\n  jne .loop\n  \n.r:\n  mov byte [rdi-1], 'R'\n  jmp .loop\n.g:\n  mov byte [rdi-1], 'G'\n  jmp .loop\n.b:\n  mov byte [rdi-1], 'B'\n  jmp .loop\n  \n.linedone:\n  mov [rdi-1], ah\n  mov rdi, rsi\n  cmp [rdi+1], ah\n  jne .loop\n  \n  mov al, [rdi]\n  push rax\n  call free\n  pop rax\n\n.quit:\n  ret\n  \n.bailout:\n  mov al, [rdi]\n  ret\n; -----> endof triangle <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213970,"user_id":null,"body":"global triangle\n\nsection .text\n\n; <-- EAX triangle(ro [byte RDI] clrs) -->\ntriangle:\n    mov rsi, rdi\n    mov rdi, tri_temp               \n.copy_initial:\n    lodsb\n    stosb\n    test al,al\n    jnz .copy_initial\n.step:\n    xor rax, rax\n    mov rsi, tri_temp\n    mov ax, [rsi]\n    test ah, ah         ; If second byte is 0, the first byte is the final color\n    jz .done\n    mov rdi, rsi\n    lodsb\n.color:    \n    mov ah, al          ; AH = previous color\n    lodsb               ; AL = current color\n    test al, al         ; End of string?\n    jz .ends\n    mov dx, ax\n    xor ah, al \n    jz .write           ; If AL == AH, keep the color (in AL)\n    cmp ah, 'B' ^ 'G'   ; B and G, write R\n    mov al, 'R'\n    je .write\n    cmp ah, 'G' ^ 'R'   ; G and R, write B\n    mov al, 'B'\n    je .write\n    mov al, 'G'         ; Otherwise (if B and R) write G\n.write:\n    stosb\n    mov ax, dx\n    jmp .color\n.ends:\n    stosb               ; Terminate the string\n    jmp .step\n.done:\n    ret                 ; Final color is already in AL \n    \nsection .bss\ntri_temp:  resb  1024\n\n\n; -----> endof triangle <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213971,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                         Written by uniapi\n;                           July 30, 2021\n; ----------------------------------------------------------------------\n\nglobal triangle\n\nsection .text\n\n; <-- RAX strlen(ro [byte RDI] s) -->\nvstrlen:\n    vpxor xmm0, xmm0\n    mov rcx, -32\n.loop:\n    add rcx, 32\n    vpcmpeqb ymm1, ymm0, [rdi+rcx]\n    vpmovmskb eax, ymm1\n    test eax, eax\n    je .loop\n    bsf eax, eax\n    add rax, rcx\n    ret\n; -----> endof strlen <-----\n\n; <-- [byte RAX] memcpy([byte RDI] s1, ro [byte RSI] s2, RDX n) -->\nvmemcpy:\n    xor ecx, ecx\n    mov rax, rdx\n    shr rax, 5\n    shl rax, 5\n    je .exit\n.loopv:\n    vmovdqu ymm0, [rsi+rcx]\n    vmovdqu [rdi+rcx], ymm0\n    add rcx, 32\n    cmp rcx, rax\n    jb .loopv\n    jmp .exit\n.loop:\n    mov al, [rsi+rcx]\n    mov [rdi+rcx], al\n    inc rcx\n.exit:\n    cmp rcx, rdx\n    jne .loop\n    mov rax, rdi\n    ret\n; -----> endof memcpy <-----\n\n; <-- spalign(CONST bits) -->\n%macro spalign 1\n    sub rsp, 2 << %1 - 1\n    shr rsp, %1\n    shl rsp, %1\n    or rsp, 2 << %1 - 1\n%endmacro\n\n; <-- EAX triangle(ro [byte RDI] clrs) -->\ntriangle:\n    push rbp                        ; saving RBP onto stack\n    mov rbp, rsp                    ; pointing RBP to initial stack position\n    sub rsp, 0h10                   ; allocating space for <locals>\n    mov [rsp], rdi                  ; saving <clrs> in <locals>\n    call vstrlen                    ; counting <n>umber of characters in <clrs>\n    mov [rbp-8], rax                ; saving <n> in local storage\n    sub rsp, rax                    ; allocating space for <s>\n    spalign 3                       ; aligning the stack boundary before call\n    mov rdi, rsp                    ; pointing RDI to <s>\n    mov rsi, [rbp-0h10]             ; pointing RSI to <clrs>\n    mov rdx, rax                    ; setting RDX to <n>\n    call vmemcpy                    ; copying <clrs> to <s>\n    mov rsi, [rbp-8]                ; setting RSI to <n>\n    mov r8, .cvts                   ; pointing R8 to <.cvts>\n    jmp .exit                       ; jumping to exit\n.loop:\n    movzx edx, byte [rsp+rcx]       ; copying and zero-extending <s[i]> to EDX\n    movzx eax, byte [rsp+rcx+1]     ; copying and zero-extending <s[i+1] to EAX\n    lea rax, [rax+rdx-0h84]         ; getting <inx> of color\n    mov dl, [r8+rax]                ; loading <.cvts[inx]> to DL as <clr>\n    mov [rsp+rcx], dl               ; copying <clr> to <s[i]>\n    inc rcx                         ; incrementing <i>\n.stop:\n    cmp rcx, rsi                    ; whether <i> is equal to <n>\n    jne .loop                       ; otherwise, jumping to the next iteration\n.exit:\n    xor ecx, ecx                    ; resetting RCX as <i>\n    dec rsi                         ; decrementing <n>\n    jne .stop                       ; jumping to .stop if <n> is not zero\n    movzx eax, byte [rsp]           ; copying and extending <*s> to EAX as the result\n    mov rsp, rbp                    ; restoring the stack boundary\n    pop rbp                         ; restoring the original RBP from stack\n    ret\n; local readonly storage\n.cvts:\n    db  'B',0,0,0,0,'R',0,0,0,0,'G',0,0,0,0,0,'G',0,0,0,0,'B',0,0,0,0,0,0,0,0,0,0,'R'\n; -----> endof triangle <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a2be17aee1aaefe2a000151":[{"id":213972,"user_id":564,"body":"section .text\nglobal arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n  xor rax, rax\n  xor r10, r10\n.loop_a:\n  dec rdx\n  jl .loop_b\n  movsx r10, dword[rdi + rdx * 4]\n  add rax, r10\n  jmp .loop_a\n.loop_b:\n  dec rcx\n  jl .end\n  movsx r10, dword[rsi + rcx * 4]\n  add rax, r10\n  jmp .loop_b\n.end:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213973,"user_id":null,"body":"global arrplusarr\n\narrplusarr:\n  xor rax,rax\n  .b:movsx r8,dword[rsi+rcx*4-4]\n     add   rax,r8\n  loop .b\n  .c:movsx r8,dword[rdi+rdx*4-4]\n     add   rax,r8\n     dec   rdx\n  jne .c\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213974,"user_id":null,"body":"global arrplusarr\narrplusarr:\n  xor rax, rax\n.loop1:\n  test rdx, rdx\n  jz .loop2\n  movsxd r8, [rdi + 4*rdx-4]\n  add rax, r8\n  dec rdx\n  jmp .loop1\n.loop2:\n  test rcx, rcx\n  jz .exit\n  movsxd r8, [rsi + 4*rcx-4]\n  add rax, r8\n  dec rcx\n  jmp .loop2\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213975,"user_id":null,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n    xor rax, rax            ; RAX <- the result\n\n.l1:\n    dec rdx\n    movsxd rbx, dword [rdi+4*rdx]\n    add rax, rbx\n    cmp rdx, 0\n    ja .l1\n\n.l2:\n    dec rcx\n    movsxd rbx, dword [rsi+4*rcx]\n    add rax, rbx\n    cmp rcx, 0\n    ja .l2\n    ret\n; -----> endof arrplusarr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213976,"user_id":null,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n\txor\teax, eax\n\ttest\trdx, rdx\n\tje\t.aempty\n\txor\tr8d, r8d\n.sumaloop:                                ; =>This Inner Loop Header: Depth=1\n\tmovsxd\tr9, [rdi + 4*r8]\n\tadd\trax, r9\n\tinc\tr8\n\tcmp\trdx, r8\n\tjne\t.sumaloop\n.aempty:\n\ttest\trcx, rcx\n\tjne\t.bnotempty\n\tjmp\t.done\n.bnotempty:\n\txor\tedx, edx\n.sumbloop:                                ; =>This Inner Loop Header: Depth=1\n\tmovsxd\trdi, [rsi + 4*rdx]\n\tadd\trax, rdi\n\tinc\trdx\n\tcmp\trcx, rdx\n\tjne\t.sumbloop\n.done:\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213977,"user_id":null,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n    xor r8, r8              ; r8 = sum of elements so far\n    xor r9b, r9b            ; 0 = adding b, 1 = adding a\n    ; add all items of array rsi, rcx\n.adding:\n    test ecx, ecx\n    jz .end_adding        ; empty array\n    test rsi, rsi\n    jz .end_adding        ; null pointer\n    lodsd                 ; load next int from array\n    movsx rax, eax        ; expand int to long\n    add r8, rax           ; sum in a long\n    loop .adding\n.end_adding:    \n    test r9b, r9b\n    jnz .done             ; the last array was a\n    inc r9b               ; 1 = adding a\n    mov rsi, rdi          ; pointer to a\n    mov rcx, rdx          ; count of a\n    jmp .adding\n.done:    \n    mov rax, r8           ; return sum of all items\n    ret\n; -----> endof arrplusarr <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213978,"user_id":null,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n  xor rax, rax\n  xor rbx, rbx\n \n.second:\n  movsx rbx, dword [rsi + rcx * 4 - 4]\n  add rax, rbx \n  loop .second\n  \n  mov rcx, rdx\n \n.first:\n  movsx rbx, dword [rdi + rcx * 4 - 4]\n  add rax, rbx\n  loop .first\n  \n  ret\n; -----> endof arrplusarr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213979,"user_id":76,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n    xor rax, rax\n.first:\n    test rdx, rdx\n    jz .next\n    dec rdx\n    movsx rbx, dword [rdi + rdx * 4]\n    add rax, rbx\n    jmp .first\n.next:\n    test rcx, rcx\n    jz .exit\n    dec rcx\n    movsx rbx, dword [rsi + rcx * 4]\n    add rax, rbx\n    jmp .next\n.exit:\n    ret\n; -----> endof arrplusarr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213980,"user_id":50,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n    xor rax,rax            ; RAX <- the result\n    mov r8,rdx\n    mov r9,rcx\n    xor r10,r10\n_loop1:\n  cmp r8,0\n  je _loop2\n  dec r8\n  movsx r10,dword[rdi+4*r8]\n  add rax,r10\n  jmp _loop1\n_loop2:\n  cmp r9,0\n  je _exit\n  dec r9\n  movsx r10,dword[rsi+4*r9]\n  add rax,r10\n  jmp _loop2\n_exit:\n    ret\n; -----> endof arrplusarr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213981,"user_id":null,"body":"global arrplusarr\n\n; <-- RAX arrplusarr([dword RDI] a, [dword RSI] b, RDX na, RCX nb) -->\narrplusarr:\n    xor eax, eax            ; RAX <- the result\nL1:\n    movsx r8, dword [rsi + rcx * 4 - 4]\n    add rax, r8\n    loop L1\n    mov rcx, rdx\nL2:\n    movsx r8, dword [rdi + rcx * 4 - 4]\n    add rax, r8\n    loop L2\n    ret\n; -----> endof arrplusarr <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a3fe3dde1ce0e8ed6000097":[{"id":213982,"user_id":527,"body":"section .text\nglobal century_from_year\ncentury_from_year:\n                add     edi, 99\n                imul    rax, rdi, 1374389535\n                shr     rax, 37\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213983,"user_id":null,"body":"section .text\nglobal century_from_year\ncentury_from_year:   ; int century_from_year(int year)\n                   ; input:  edi = year\n                   ; output: eax\n  mov eax, edi\n  dec eax\n  mov edx, 0\n  mov ebx, 100\n  div ebx\n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213984,"user_id":null,"body":"section      .bss\n    divisor:    equ     100\n\nsection     .text\nglobal      century_from_year\n\ncentury_from_year:\n    xor       rax, rax\n    xor       rdx, rdx\n    mov       rcx, divisor\n    mov       rax, rdi\n    \n    idiv      rcx\n    \n    cmp       rdx, 0\n    jne       _Add_One\n    ret\n\n_Add_One:\n    add       rax, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213985,"user_id":null,"body":"section .text\nglobal century_from_year\ncentury_from_year:\n  xor rax, rax\n  lea eax, [rdi+99]\n  mov ecx, 100\n  cdq\n  idiv    ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213986,"user_id":null,"body":"section .text\nglobal century_from_year\n\ncentury_from_year:\n  lea eax, [edi + 99] ;(year + 99)\n  cdq\n  mov ecx, 100\n  idiv ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213987,"user_id":null,"body":"section .text\nglobal century_from_year\n\ncentury_from_year:\n  mov eax, edi\n  mov esi, 100\n  cdq\n  idiv esi ;sets eax, edx\n  xor ecx, ecx\n  cmp edx, 0\n  setnz cl\n  add eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213988,"user_id":null,"body":"section .text\nglobal century_from_year\n\ncentury_from_year:\n  mov eax, edi\n  dec eax\n  mov ecx, 100\n  cdq\n  idiv ecx\n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213989,"user_id":null,"body":"section .text\nglobal century_from_year\ncentury_from_year:   ; int century_from_year(int year)\n                   ; input:  edi = year\n                   ; output: eax\n  xor rdx,rdx\n  mov rax, rdi\n  add rax,99\n  mov rbx,100\n  div rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213990,"user_id":null,"body":"section .text\nglobal century_from_year\ncentury_from_year:   ; int century_from_year(int year)\n                   ; input:  edi = year\n                   ; output: eax\n  mov eax, edi\n  add eax, 99\n  mov ecx, 100\n  xor edx, edx\n  div ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213991,"user_id":null,"body":"section .text\nglobal century_from_year\n\ncentury_from_year:\n  lea eax, [edi - 1]\n  xor edx, edx\n  mov esi, 100\n  idiv esi\n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a4138acf28b82aa43000117":[{"id":213992,"user_id":null,"body":"global adjacentElementsProduct\nadjacentElementsProduct:\n  mov eax,80000000h\n  dec rsi\n  .b:mov   ecx,dword[rdi+rsi*4-4]\n     imul  ecx,[rdi+rsi*4]\n     cmp   eax,ecx\n     cmovl eax,ecx\n     dec   rsi\n  jne .b   \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213993,"user_id":168,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  dec rsi\n  mov edx, dword [rdi + 4 * rsi]\n  mov eax, 0x80000000\n.loop:\n  mov ecx, dword [rdi + 4 * rsi - 4]\n  imul edx, ecx\n  cmp edx, eax\n  cmovg eax, edx\n  mov edx, ecx\n  sub rsi, 1\n  ja .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213994,"user_id":881,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  call multiplynums  ; multiply the first two numbers in the list\n  dec esi            ; decrement size as we have counted 1 pair\n  mov r9d, eax       ; highest so far is only one we've found\n  jmp .while\n.do:                 ; do {\n  add rdi, 4         ;   increment array pointer\n  call multiplynums  ;   multiply next two numbers\n  cmp eax, r9d       \n  jle .while         ;   if (eax > edx)\n  mov r9d, eax       ;     edx = eax;\n.while:\n  sub esi, 1         ;   decrement size of remaining list\n  jnz .do            ; } while (list.length > 0)\n  mov eax, r9d       ; return highest number found\n  ret\n\n; int multiplynums(int inputArray[]) {\n;   return inputArray[0] * inputArray[1];\n; }\nmultiplynums:\n  mov eax, [rdi] \n  imul dword[rdi+4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213995,"user_id":null,"body":"section .text\nglobal adjacentElementsProduct\nadjacentElementsProduct:\n    push   rbp\n    mov    rbp,rsp\n    mov    qword [rbp-0x18],rdi\n    mov    qword [rbp-0x20],rsi\n    mov    rax,[rbp-0x18]\n    mov    edx,[rax]\n    mov    rax,[rbp-0x18]\n    add    rax,0x4\n    mov    eax,[rax]\n    imul   eax,edx\n    mov    dword [rbp-0x4],eax\n    mov    qword [rbp-0x10],0x1\n    jmp    a \nb:\n    mov    rax, [rbp-0x10]\n    lea    rdx,[rax*4+0x0]\n    mov    rax, [rbp-0x18]\n    add    rax,rdx\n    mov    edx,[rax]\n    mov    rax, [rbp-0x10]\n    add    rax,0x1\n    lea    rcx,[rax*4+0x0]\n    mov    rax, [rbp-0x18]\n    add    rax,rcx\n    mov    eax,[rax]\n    imul   eax,edx\n    cmp    dword [rbp-0x4],eax\n    jge    c \n    mov    rax, [rbp-0x10]\n    lea    rdx,[rax*4+0x0]\n    mov    rax, [rbp-0x18]\n    add    rax,rdx\n    mov    edx, [rax]\n    mov    rax, [rbp-0x10]\n    add    rax,0x1\n    lea    rcx,[rax*4+0x0]\n    mov    rax, [rbp-0x18]\n    add    rax,rcx\n    mov    eax, [rax]\n    imul   eax,edx\n    mov    dword [rbp-0x4],eax\nc:\n    add    qword [rbp-0x10],0x1\na:\n    mov    rax,[rbp-0x20]\n    sub    rax,0x1\n    cmp    qword [rbp-0x10],rax\n    jb     b \n    mov    eax, [rbp-0x4]\n    pop    rbp\n    ret  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213996,"user_id":null,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  mov eax, [rdi]\n  mov edx, 2\n  imul eax, [rdi+4]\n.loop:\n  cmp rdx, rsi\n  jnb .done\n  mov ecx, [rdi+rdx*4]\n  imul ecx, [rdi-4+rdx*4]\n  cmp eax, ecx\n  cmovl eax, ecx\n  inc rdx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213997,"user_id":null,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  xor rax, rax ; <- return value\n  dec rsi\n  mov rcx,0\n  mov rdx,0\n  \n  mov eax,[rdi]\n  mov ebx,[rdi+4]\n  push rdx\n  imul ebx\n  pop rdx\n  mov edx,eax \nlp:\n  cmp rcx,rsi\n  je ende\n  xor rax,rax\n  xor rbx,rbx\n  mov eax,[rdi+4*rcx]\n  inc rcx\n  mov ebx,[rdi+4*rcx]\n  push rdx\n  imul ebx\n  pop rdx\n  cmp eax,edx\n  jle lp\n  mov edx,eax\n  jmp lp\nende:\n  mov rax,rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213998,"user_id":null,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  mov eax, [rdi]\n  mov ecx, [rdi+4]\n  imul eax, ecx\n  \n  add rdi, 4\n  dec rsi\n.loop:\n  add rdi, 4\n  dec rsi\n  jz .done\n  mov edx, [rdi]\n  imul ecx, edx\n  cmp eax, ecx\n  cmovl eax, ecx\n  mov ecx, edx\n  jmp .loop\n  \n.done:  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":213999,"user_id":null,"body":"CONST_MIN_INT equ 0x80000000\n\nsection .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  xor rcx, rcx\n  mov r8d, CONST_MIN_INT\n  dec rsi ; set n to index of last element, not size\n\n.loop:\n  mov eax, [rdi+rcx*4]\n  inc rcx\n  mov edx, [rdi+rcx*4]\n  imul edx\n\n  cmp eax, r8d\n  jl .continue\n\n  mov r8d, eax\n\n.continue:\n  cmp rcx, rsi\n  jne .loop\n\n  xor rax, rax\n  mov eax, r8d\n  ret  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214000,"user_id":null,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  dec rsi\n  mov eax, dword [rdi]\n  imul eax, dword [rdi+4]\n  xor rcx, rcx\n  inc rcx\n  .loop:\n  cmp rcx, rsi\n  je .done\n  mov edx, dword [rdi+rcx*4]\n  imul edx, dword [rdi+rcx*4+4]\n  cmp edx, eax\n  cmovg eax, edx\n  inc rcx\n  jmp .loop\n  .done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214001,"user_id":null,"body":"section .text\nglobal adjacentElementsProduct\n\n; int adjacentElementsProduct(int inputArray[], size_t input_size);\nadjacentElementsProduct:\n  xor rax, rax\n  mov r8, rdi\n  mov r9, 1\n  mov r10d, -2147483648\n  mov rcx, rsi\n  sub rcx, 1\n.loop:\n  lea r11, [r8 + r9*4]\n  mov rdx, [r11]\n  sub r11, 4\n  mov rax, [r11]\n  imul edx\n  cmp r10d, eax\n  jge .next\n  mov r10, rax  \n.next:  \n  inc r9\n  loopnz .loop\n  mov rax, r10\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a4d303f880385399b000001":[{"id":214002,"user_id":null,"body":"section .text\nglobal strong_num\n; const char *strong_num(int number)\nstrong_num:\n  mov eax, .strong\n  cmp edi, 2\n  jbe .done\n  cmp edi, 145\n  je .done\n  cmp edi, 40585\n  je .done\n  mov eax, .notstrong\n.done:\n  ret\n\n.strong: db \"STRONG!!!!\",0\n.notstrong: db \"Not Strong !!\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214003,"user_id":null,"body":"section .text\nglobal strong_num\n; const char *strong_num(int number)\nstrong_num:\n  xor esi, esi\n  mov eax, edi\n  mov ecx, 10\n  lea r8, [data]\n  \n.loop:\n  xor edx, edx\n  div ecx\n  add esi, [r8+rdx*4]\n  test eax, eax\n  jnz .loop\n  \n  lea rax, [yes]\n  lea rdx, [no]\n  cmp esi, edi\n  cmovne rax, rdx\n  ret\n\nsection .rodata\ndata: dd 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880\nyes: db \"STRONG!!!!\", 0\nno: db \"Not Strong !!\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214004,"user_id":50,"body":"section .data\ny: db 'STRONG!!!!',0\nn: db 'Not Strong !!',0\n\nsection .text\nglobal strong_num\n; const char *strong_num(int number)\nstrong_num:\n  cmp edi, 1\n  je _retTrue\n  cmp edi, 2\n  je _retTrue\n  cmp edi, 145\n  je _retTrue\n  cmp edi, 40585\n  je _retTrue\n  mov rax, n\n  ret\n_retTrue:\n  mov rax, y\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214005,"user_id":460,"body":"section .data\n  fact dq 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880\n  str_strong db \"STRONG!!!!\", 0\n  str_not_strong db \"Not Strong !!\", 0\nsection .text\nglobal strong_num\nstrong_num:\n  xor r8, r8 ; zero out r8 (sum of factorials)\n  mov rcx, 10 ; set 10 to rcx (for getting digits by modulo)\n  mov rax, rdi ; set number into rax\n.digits:\n  xor rdx, rdx ; zero out rdx\n  div rcx ; divide rax by rcx (10)\n  mov rdx, [fact+rdx*8] ; get factorial for current digit (modulo)\n  add r8, rdx ; add factorial into r8 (sum of factorials)\n  cmp rax, 0 ; if number is not 0 yet\n  jne .digits\n  \n  cmp r8, rdi ; if sum of factorials is equal to rdi (initial number)\n  je .strong\n  mov rax, str_not_strong\n  ret\n.strong:\n  mov rax, str_strong\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214006,"user_id":null,"body":"section .text\nglobal strong_num\n;  Inspired from Blind4Basics python amazing solution ...\nstrong_num:\n  cmp rdi, 1\n  je @end\n  cmp rdi, 2\n  je @end\n  cmp rdi, 145\n  je @end\n  cmp rdi, 40585\n  je @end\n  mov rax, s2\n  ret\n@end:\n  mov rax, s1\n  ret\ns1 : db \"STRONG!!!!\", 0\ns2 : db \"Not Strong !!\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214007,"user_id":168,"body":"section .text\nglobal strong_num\n\nstrong db \"STRONG!!!!\", 0\nnot_strong db \"Not Strong !!\", 0\n\n; const char *strong_num(int number)\nstrong_num:\n  cmp edi, 1\n  je .strong\n  cmp edi, 2\n  je .strong\n  cmp edi, 145\n  je .strong\n  cmp edi, 40585\n  je .strong\n  mov rax, not_strong\n  ret\n.strong:\n  mov rax, strong\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214008,"user_id":1339,"body":"section .text\nglobal strong_num\n; const char *strong_num(int number)\nstrong_num:\n  cmp rdi, 1\n  je .strong\n  cmp rdi, 2\n  je .strong\n  cmp rdi, 145\n  je .strong\n  cmp rdi, 40585\n  je .strong\n  mov rax, _not_strong\n  ret\n.strong:\n  mov rax, _strong\n  ret\n  \nsection .data\n_strong: db 'STRONG!!!!', 0\n_not_strong: db 'Not Strong !!', 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a4e3782880385ba68000018":[{"id":214009,"user_id":null,"body":"extern sprintf,strlen\nsection .text\nglobal balancedNum\nbalancedNum:\n  sub rsp, 40\n  mov rdx, rdi\n  mov esi, .fmt\n  mov rdi, rsp\n  xor eax, eax\n  call sprintf\n  mov rdi, rsp\n  call strlen\n  lea rdx, [rsp-1+rax]\n  xor ecx, ecx\n  xor esi, esi\n  mov rax, rsp\n.loop:\n  dec rdx\n  cmp rax, rdx\n  jnb .compare\n  movsx edi, byte [rax]\n  inc rax\n  add esi, edi\n  movsx edi, byte [rdx+1]\n  add ecx, edi\n  jmp .loop\n.compare:\n  cmp esi, ecx\n  mov eax, .str\n  mov edx, .str+4\n  cmove rax, rdx\n  add rsp, 40\n  ret\n  \n.str: db `Not Balanced\\0`\n.fmt: db `%llu\\0`\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214010,"user_id":460,"body":"section .data\n  res_str db \"Not Balanced\"\n  res_str_offset equ 4\nsection .text\nglobal balancedNum\nbalancedNum:\npush rbp\nmov rbp, rsp\n  xor r8, r8 ; zero out r8 (numbers count)\n  mov rax, rdi ; take n into accum\n  mov rcx, 10 ; set counter to 10\n.collect_digits:\n  xor rdx, rdx ; zero out rdx\n  div rcx ; divide rax by rcx\n  push rdx ; push division modulo onto stack\n  inc r8 ; increment r8 (numbers count)\n  cmp rax, 0 ; if we not collected all digits\n  jne .collect_digits\n\n  cmp r8, 2 ; if number have more than 2 digits\n  jg .complex_case\n  \n  ; if number have 2 or less digits\n.clear_stack: ; clear stacked numbers\n  pop rdx\n  dec r8\n  cmp r8, 0\n  jne .clear_stack\n  \n  mov rax, res_str ; set rax to \"Not Balanced\"\n  add rax, res_str_offset ; move rax by 4 chars to get \"Balanced\" in rax\nleave\nret\n\n.complex_case:\n  mov r9, r8 ; copy r8 to t9\n  xor rcx, rcx ; zero out rcx\n  bt r8, 0 ; get first bit from digits count\n  setc cl ; set 0 (even count) or 1 (odd count) to rcx\n  \n  mov r8, 2 ; set 2 in r8\n  sub r8, rcx ; subtract 1 if digits count is odd (0 if even)\n  \n  sub rcx, 1 ; subtract 1 from rcx (-1 if even, 0 if odd)\n  sar r9, 1 ; divide r9 by 2\n  add r9, rcx ; add rcx to r8 (if number is even - subtract 1)\n  ; Example:\n  ; n == 5 -> r8 == 1, r9 == 2\n  ; n == 6 -> r8 == 2, r9 == 2\n  ; r8 - count of digits in the middle (we will skip them)\n  ; r9 - count of digits on the left\/right side of number\n  \n  xor rax, rax ; zero out rax\n  mov rcx, r9 ; set r9 (count of digits on the right) to rcx\n.first_part:\n  pop rdx ; get last digit from stack\n  add rax, rdx ; add this digit to rax\n  dec rcx ; decrement digits count\n  cmp rcx, 0 ; if there are still some digits to add\n  jne .first_part\n\n  mov rcx, r8 ; set r8 (count of digits in the middle) to rcx\n.skip_middle:\n  pop rdx ; pop middle digit\n  dec rcx ; decrement digits count\n  cmp rcx, 0 ; if there are still some digits to skip\n  jne .skip_middle\n\n  mov rcx, r9 ; set r9 (count of digits on the left) to rcx\n.second_part:\n  pop rdx ; get last digit from stack\n  sub rax, rdx ; subtract this digit from current sum (of right part digits)\n  dec rcx ; decrement digits count\n  cmp rcx, 0 ; if there are still some digits to add\n  jne .second_part\n\n  mov rdx, rax ; move rax (difference between sums of right and left part) to rdx\n  mov rax, res_str ; set rax to \"Not Balanced\"\n  cmp rdx, 0 ; if difference between sums of right and left parts is not 0\n  jne .not_balanced\n  add rax, res_str_offset ; move rax by 4 chars to get \"Balanced\" in rax\n.not_balanced:\nleave\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214011,"user_id":460,"body":"section .data\n  res_str db \"Not Balanced\"\n  res_str_offset equ 4\nsection .text\nglobal balancedNum\nbalancedNum:\npush rbp\nmov rbp, rsp\n  mov rax, rdi\n  mov rcx, 10\n  xor r8, r8\n.collect_digits:\n  xor rdx, rdx\n  div rcx\n  push rdx\n  inc r8\n  cmp rax, 0\n  jne .collect_digits\n\n  cmp r8, 2\n  jg .complex_case\n  \n.clear_stack:\n  pop rdx\n  dec r8\n  cmp r8, 0\n  jne .clear_stack\n  \n  mov rax, res_str\n  add rax, res_str_offset\nmov rsp, rbp\npop rbp\nret\n\n.complex_case:\n  xor rcx, rcx\n  bt r8, 0\n  setc cl\n  \n  mov r9, r8\n\n  mov r8, 2\n  sub r8, rcx\n  \n  sub rcx, 1\n  sar r9, 1\n  add r9, rcx\n  \n  xor rax, rax\n  mov rcx, r9\n.first_part:\n  pop rdx\n  add rax, rdx\n  dec rcx\n  cmp rcx, 0\n  jne .first_part\n\n  mov rcx, r8\n.skip_middle:\n  pop rdx\n  dec rcx\n  cmp rcx, 0\n  jne .skip_middle\n\n  mov rcx, r9\n.second_part:\n  pop rdx\n  sub rax, rdx\n  dec rcx\n  cmp rcx, 0\n  jne .second_part\n\n  mov rdx, rax\n  mov rax, res_str\n  cmp rdx, 0\n  jne .not_balanced\n  add rax, res_str_offset\n.not_balanced:\nmov rsp, rbp\npop rbp\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214012,"user_id":null,"body":"global balancedNum\nbalancedNum:\n  mov rax,rdi\n  mov r8,10\n  mov rcx,1\n  xor r9,r9\n  xor r10,r10\n  xor r11,r11\n  .c:xchg r10,r9\n    .b:xor rdx,rdx\n       div  r8\n       add  r9,rdx\n       imul rcx,r8\n       not  r11\n       cmp  rcx,rax\n    jnae .b\n    jrcxz .f\n    xor rcx,rcx\n    sub r9,rdx\n    xor rdx,rdx\n    div r8\n    mov r12,rdx\n    mul r8\n    jmp .c\n  .f:\n  and  r11,r12\n  add  r9,r11\n  cmp  r10,r9\n  sete al\n  lea  rax,[.answer+rax*4]\nret\n.answer db \"Not Balanced\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214013,"user_id":null,"body":"section .text\nglobal balancedNum\nbalancedNum:    ; const char* balancedNum(unsigned long long n)\n                ; input:  rdi = n\n                ; output: rax\n  push rbp\n  mov rbp, rsp\n  mov rax, rdi\n  xor rcx, rcx\n  mov rsi, 10\n\n.loop:\n  xor rdx, rdx\n  div rsi\n  mov qword [digits + ecx * 8], rdx\n  inc rcx\n  cmp rax, 0\n  jne balancedNum.loop\n\n  cmp rcx, 2\n  jle balancedNum.le_two_digits\n  test rcx, 1\n  jz balancedNum.even_digits\n  jmp balancedNum.odd_digits\n\n.le_two_digits:\n  jmp balancedNum.balanced\n\n.even_digits:\n  xor rax, rax\n  xor rsi, rsi\n  mov rdx, rcx\n  mov r8, rcx\n  sub r8, 1\n  shr rdx, 1\n  .even_sum_upper:\n    add rax, qword [digits + r8 * 8]\n    dec r8\n    cmp r8, rdx\n    jne balancedNum.even_sum_upper\n\n  sub rdx, 2\n  mov r8, rdx\n  .even_sum_lower:\n    add rsi, qword [digits + r8 * 8]\n    dec r8\n    cmp r8, 0\n    jge balancedNum.even_sum_lower\n\n  cmp rax, rsi\n  je balancedNum.balanced\n  jmp balancedNum.not_balanced\n\n.odd_digits:\n  xor rax, rax\n  xor rsi, rsi\n  mov rdx, rcx\n  mov r8, rcx\n  sub r8, 1\n  shr rdx, 1\n  .odd_sum_upper:\n    add rax, qword [digits + r8 * 8]\n    dec r8\n    cmp r8, rdx\n    jne balancedNum.odd_sum_upper\n\n  sub rdx, 1\n  mov r8, rdx\n  .odd_sum_lower:\n    add rsi, qword [digits + r8 * 8]\n    dec r8\n    cmp r8, 0\n    jge balancedNum.odd_sum_lower\n\n  cmp rax, rsi\n  je balancedNum.balanced\n  jmp balancedNum.not_balanced\n\n.balanced:\n  mov rax, balanced\n  jmp balancedNum.end\n\n.not_balanced:\n  mov rax, not_balanced\n  jmp balancedNum.end\n\n.end:\n  pop rbp\n  ret\n\nsection .rodata\nbalanced: db \"Balanced\", 0\nnot_balanced: db \"Not Balanced\", 0\n\nsection .bss\ndigits: resq 20\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214014,"user_id":null,"body":"section .text\nglobal balancedNum\n\nbalancedNum:    ; const char* balancedNum(unsigned long long n)\n    mov rax, rdi        ; n into rax\n    xor rcx, rcx        ; clear rcx - used to count number of digits of n in base 10\n    mov r8, 10          ; load 10 into r8 - to divide with\ndigit_loop:\n    inc rcx             ; count digit\n    mov rdx, 0          ; clear rdx (will get remainder from div, must be 0 or error)\n    div r8              ; divide rax by 10, result (rest of n) into rax, remainder (the digit) into rdx\n    push rdx            ; push digit onto the stack\n    cmp rax, 0\n    jne digit_loop      ; loop until rax is 0 (all digits of nu have been counted and pushed onto the stack)\n    cmp rcx, 2          ; only continue if more than 2 digits\n    ja more_than_two_digits\n    mov rax, balanced   ; 2 digits or less is balanced\n    mov rdx, 8          ; been adding 8 byte values to the stack\n    imul rdx, rcx       ; rcx holds how many\n    add rsp, rdx        ; clean up the stack\n    ret\nmore_than_two_digits:\n    mov rdi, rcx        ; move number of digits into rdi, rdi will be halved to find the mid point.  rcx will be used to control the loop.\n    xor r8, r8          ; clear r8 - will be the balence sum of left side vs right side\n    mov r9, -1          ; r9 will hold the index of the second mid-digit (index is before the first), if even number of digits, or -1 if odd.  \n    shr rdi, 1          ; integer divide rdi (number of digits by 2), this sets it to 1 below the first (higher) midpoint, and sets carry flag if it was odd\n    cmovnc r9, rdi      ; if carry flag was not set (even number of digits), the second (lower) midpoint is where rdi is now.\n    inc rdi             ; move rdi to its correct postion\ndigit_sum_loop:\n    pop rax             ; digit into rax\n    cmp rcx, r9\n    je continue_loop    ; if this is the second mid point, continue to next iteration    \n    cmp rcx, rdi    \n    je continue_loop    ; if this is the first mid point, continue to next iteration\n    jl second_half      ; if it is after the second mid point, jump to subtraction of rax from r8\n    add r8, rax         ; its in the first half, so add rax to r8\n    jmp continue_loop   \nsecond_half:\n    sub r8, rax\ncontinue_loop:\n    loop digit_sum_loop ; dec rcx and loop if it is not 0    \n    mov rax, not_balanced   ; default return is pointer to not balanced\n    mov rcx, balanced       ; store pointer to balanced in register for use in cmove\n    cmp r8, 0               \n    cmove rax, rcx      ; if it was balanced, move that pointer into rax\n    ret  \n    \nsection .data\nbalanced: db \"Balanced\", 0\nnot_balanced: db \"Not Balanced\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214015,"user_id":168,"body":"section .text\nglobal balancedNum\nnot_balanced db \"Not Balanced\", 0, 0, 0, 0\nbalanced db \"Balanced\", 0\nbalancedNum:    ; const char* balancedNum(unsigned long long n)\n                ; input:  rdi = n\n                ; output: rax\n  sub rsp, 20\n  xor ecx, ecx\n  mov rax, rdi\n  mov esi, 10\n.digits:\n  xor edx, edx\n  div rsi\n  mov [rsp + rcx], dl\n  inc ecx\n.digits_cond:\n  test eax, eax\n  jnz .digits\n  xor eax, eax\n  lea edx, [ecx - 1]\n  shr edx, 1\n  jmp .loop_cond\n.loop:\n  add al, [rsp + rdx]\n  sub al, [rsp + rcx]\n.loop_cond:\n  dec ecx\n  dec edx\n  jge .loop\n  test al, al\n  setz al\n  shl al, 4\n  lea rax, [rel not_balanced + rax]\n  add rsp, 20\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214016,"user_id":1315,"body":"section .text\nglobal balancedNum\nbalancedNum:    ; const char* balancedNum(unsigned long long n)\n                ; input:  rdi = n\n                ; output: rax\n  test rdi, rdi      ; if ( n == 0 )\n  jz   balanced      ; return \"Balanced\"\n  sub  rsp, 20       ; rsp := int8_t arr[20] \/\/ reserve stack frame\n  mov  rax, rdi      ; rax := n\n  mov  rbx, 10       ; rbx := const 10\n  xor  rcx, rcx      ; rcx := i = 0\nparse_loop:\n  test rax, rax      ; while ( n != n )\n  jz   end_parse_loop\n  xor  rdx, rdx      ; n' = n \/ 10\n  div  rbx      \n  mov  [rsp+rcx], dl ; arr[i] = n % 10\n  inc  rcx           ; i++\n  jmp  parse_loop\nend_parse_loop:\n  mov  rdi, rsp      ; rdi := arr1 = arr\n  mov  rsi, rsp      ; rsi := arr2 = arr + i - 1\n  add  rsi, rcx\n  dec  rsi\n  mov  rax, rcx      ; if ( i & 0x01 == 0 )\n  and  rax, 1\n  jnz  odd\neven:\n  shr  rcx, 1        ; i = i \/ 2 - 1\n  dec  rcx\n  jmp  not_odd\nodd:                 ; else\n  shr  rcx, 1        ; i = i \/ 2\nnot_odd:\n  xor  rax, rax      ; rax := a = 0\n  xor  rbx, rbx      ; rbx := b = 0\n  xor  rdx, rdx      ; rdx := sum = 0\nsum_loop:\n  cmp  rcx, 0        ; while ( i != 0 )\n  jz   end_sum_loop\n  dec  rcx           ; i--\n  mov  al, [rdi]     ; a = *arr1\n  inc  rdi           ; arr1++\n  mov  bl, [rsi]     ; b = *arr2\n  dec  rsi           ; arr2--\n  add  rdx, rax      ; sum += a\n  sub  rdx, rbx      ; sum -= a\n  jmp  sum_loop\nend_sum_loop:\n  add  rsp, 20       ; restore stack pointer\n  test rdx, rdx      ; if ( sum == 0 )\n  jnz  unbalanced\nbalanced:\n  mov  rax, balanced_str\n  ret                ; return \"Balanced\"\nunbalanced:          ; else\n  mov  rax, unbalanced_str\n  ret                ; return \"Not Balanced\"\nsection .data\nbalanced_str:   db 'Balanced',0\nunbalanced_str: db 'Not Balanced',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a512f6a80eba857280000fc":[{"id":214017,"user_id":null,"body":"section .text\nglobal nth_smallest\nnth_smallest:\n  mov r8, rdi\n  xor ecx, ecx\n  mov edi, -2147483648\n  mov eax, 2147483647\n.minmaxloop:\n  cmp esi, ecx\n  jle .seekmid\n  mov r9d, [r8+rcx*4]\n  cmp eax, r9d\n  cmovg eax, r9d\n  cmp edi, r9d\n  cmovl edi, r9d\n  inc rcx\n  jmp .minmaxloop\n.testmid:\n  cmp [r8+r9*4], ecx\n  jg .overmid\n  inc r10d\n.overmid:\n  inc r9\n.midloop:\n  cmp esi, r9d\n  jg .testmid\n  cmp r10d, edx\n  jge .L10\n  lea eax, [rcx+1]\n.seekmid:\n  cmp eax, edi\n  jge .done\n  mov ecx, edi\n  sub ecx, eax\n  sar ecx, 1\n  add ecx, eax\n  xor r9d, r9d\n  xor r10d, r10d\n  jmp .midloop\n.L10:\n  mov edi, ecx\n  jmp .seekmid\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214018,"user_id":null,"body":"section .text\nglobal nth_smallest\nextern qsort\n\ncompare_int:\n  ; rdi :: pointer of A\n  ; rsi :: pointer of B\n  mov edi, [rdi]\n  xor eax, eax\n  cmp edi, [rsi]\n  jg .greater\n  je .equal\n  dec eax\n.equal:\n  ret\n.greater:\n  inc eax\n  ret\n  \n\nnth_smallest:\n  ; rdi :: pointer to array\n  ; esi :: length of array\n  ; edx :: nth\n  push rdi\n  push rdx\n  push rbp\n  mov edx, 4\n  lea rcx, [compare_int]\n  call qsort\n  \n  pop rbp\n  pop rdx\n  pop rdi\n  mov eax, [rdi+rdx*4-4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214019,"user_id":null,"body":"section .text\nglobal nth_smallest\nnth_smallest:\n  xor   rcx,rcx\n  mov   r8d, esi\n  dec   r8d\n  .loop:\n  xor   r9, r9\n  mov   r10d, esi\n  sub   r10d, ecx\n  dec   r10d\n    .innerloop:\n    xor   r13, r13\n    mov   r13d, r9d\n    inc   r13d\n    mov   r11d, dword [rdi+r9*4]\n    mov   r12d, dword [rdi+r13*4]\n    cmp   r11d, r12d\n    jl    .continue\n    xchg  r11d, r12d\n    .continue:\n    mov   dword [rdi+r9*4], r11d\n    mov   dword [rdi+r13*4], r12d\n    inc   r9d\n    cmp   r9d, r10d\n    jl    .innerloop\n  inc   ecx\n  cmp   ecx, r8d\n  jl    .loop\n    \n  dec   rdx\n  mov   eax,  dword [rdi+rdx*4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214020,"user_id":null,"body":"; int nth_smallest(const int *arr -> rdi, int count -> esi, int n -> edx)\nglobal nth_smallest\nextern qsort\n\nsection .text\n\ncompare_fn:\n  mov edx, [rsi]\n  mov eax, -1\n  cmp [rdi], edx\n  jl .smaller\n  setne al ; equal\n  movzx eax, al\n  .smaller:\n  ret\n\nnth_smallest:\n  push rdi\n  movsx rdx, edx\n  push rdx\n\n  mov edx, 4\n  lea rcx, [rel compare_fn]\n  call qsort wrt ..plt\n\n  pop rdx\n  pop rdi\n\n  mov eax, [rdi + rdx * 4 - 4]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214021,"user_id":null,"body":"section .text\nglobal nth_smallest\nextern memcpy, malloc,qsort\n\nnth_smallest:\n  push rbx\n  push r14\n  push r15\n  mov rbx, rdi    ; arr\n  mov r14d, esi   ; count\n  mov r15d, edx   ; n\n  lea rdi, [r14 * 4]\n  call malloc\n  mov rdi, rax\n  mov rsi, rbx\n  lea rdx, [r14 * 4]\n  call memcpy\n  mov rbx, rax\n  mov rdi, rax\n  mov rsi, r14\n  mov edx, 4\n  mov rcx, .compare\n  call qsort\n  mov eax, dword [rbx + r15 * 4 - 4]\n  pop r15\n  pop r14\n  pop rbx\n  ret\n  \n.compare:\n  mov eax, dword [rdi]\n  sub eax, dword [rsi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214022,"user_id":168,"body":"section .text\nglobal nth_smallest\nextern memcpy, malloc, free, qsort\n\nnth_smallest:\n  push rbx\n  push r14\n  push r15\n  mov rbx, rdi    ; arr\n  mov r14d, esi   ; count\n  mov r15d, edx   ; n\n  lea rdi, [r14 * 4]\n  call malloc\n  mov rdi, rax\n  mov rsi, rbx\n  lea rdx, [r14 * 4]\n  call memcpy\n  mov rbx, rax\n  mov rdi, rax\n  mov rsi, r14\n  mov edx, 4\n  mov rcx, .compare\n  call qsort\n  mov r14d, dword [rbx + r15 * 4 - 4]\n  mov rdi, rbx\n  call free\n  mov eax, r14d\n  pop r15\n  pop r14\n  pop rbx\n  ret\n  \n.compare:\n  mov eax, dword [rdi]\n  sub eax, dword [rsi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214023,"user_id":1027,"body":"section .text\nglobal sort\nsort:\n  push rbx\n  xor rdx,rdx\n.L1:\n  mov rcx,rdx\n.L2:\n  mov eax,[rdi+rdx*4]\n  mov ebx,[rdi+rcx*4]\n  cmp eax,ebx\n  jle .L3\n  \n  mov [rdi+rdx*4],ebx\n  mov [rdi+rcx*4],eax\n  \n.L3:\n  inc rcx\n  cmp rcx,rsi\n  jb .L2\n  \n  inc rdx\n  cmp rdx,rsi\n  jb .L1\n  \n  pop rbx\n  ret\nglobal nth_smallest\nnth_smallest:\n  push rdx\n  call sort\n  pop rdx\n  mov eax,[rdi+rdx*4-4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a54e796b3bfa8932c0000ed":[{"id":214024,"user_id":null,"body":"global jmpnum\n\nsection .text\n\n; <--- const char *jmpnum(unsigned num) --->\njmpnum:\n    mov eax, edi            ; copying <num> to EAX\n    mov edi, 10             ; the divisor to get rid of the rightmost digit\n    xor edx, edx            ; resetting EDX before the division as <lft>\n    div edi                 ; getting rid of the rightmost digit\n.loop:\n    test eax, eax           ; whether non-zero digits left\n    je .exit                ; otherwise, jumping to exit\n    mov ecx, edx            ; copying <lft> to ECX as <rgt>\n    xor edx, edx            ; resetting <lft> before the division\n    div edi                 ; getting rid of the rightmost digit\n    sub ecx, edx            ; subtracting <lft> from <rgt>\n    cmp ecx, 1              ; whether <rgt> is equal to one\n    je .loop                ; jumping to the next iteration\n    cmp ecx, -1             ; whether <rgt> is equal to minus one\n    je .loop                ; jumping to the next iteration\n    mov rax, .nojmp         ; setting the result to <.nojmp>\n    ret\n.exit:\n    mov rax, .jump          ; setting the result to <.jump>\n    ret\n.jump:  db  \"Jumping!!\",0h0\n.nojmp: db  \"Not!!\",0h0\n; ---------> endof jmpnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214025,"user_id":null,"body":"global jmpnum\n\nsection .text\n\n; <--- const char *jmpnum(unsigned num) --->\njmpnum:\n  mov eax, edi\n  xor edx, edx\n  mov edi, 10\n  div edi\n.loop:\n  mov esi, edx\n  test eax, eax\n  je .jumping\n  xor edx, edx\n  div edi\n  mov ecx, edx\n  sub ecx, esi\n  mov esi, ecx\n  sar esi, 31\n  xor ecx, esi\n  sub ecx, esi\n  dec ecx\n  je .loop\n  mov eax, .str\n  ret\n.jumping:\n  mov eax, .str+6\n  ret\n.str: db \"Not!!\",0,\"Jumping!!\",0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214026,"user_id":null,"body":"section .data\n  jump: db \"Jumping!!\", 0\n  noJump: db \"Not!!\", 0\n\n\nglobal jmpnum\n\nsection .text\n\n; <--- const char *jmpnum(unsigned num) --->\njmpnum:\n  mov r15, rsp\n  xor rax, rax\n  xor rdx, rdx\n  xor r8, r8\n  mov r10, 10\n  mov rax, rdi\n  mov r11, -1\n  \n  cmp rax, 10\n  jl stop_j\n\nresiduals:\n  cmp rax, 0\n  jbe next\n  div r10\n  push rdx\n  xor rdx, rdx\n  add r8, 1\n  jmp residuals\n    \nnext:\n  mov rcx, r8\n  sub rcx, 1\n\nnext_loop:\n  pop rax\n  sub rax, [rsp]\n  \n  \n  \n  mov rbx, 0\n  cmp rax, 0\n  cmovl rbx, r11\n  xor rax, rbx\n  sub rax, rbx\n\n  cmp rax, 1\n  jne stop_no\n  loop next_loop\n  \nstop_j:\n  mov rsp, r15\n  lea rax, [jump]\n  ret\n  \nstop_no:\n  mov rsp, r15\n  lea rax, [noJump]\n  ret\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214027,"user_id":null,"body":"global jmpnum\njmpnum:\n  mov   [rsp-10],rdi\n  finit\n  fild  qword[rsp-10]\n  fbstp [rsp-10]\n  bsr   rcx,[rsp-10]\n  shr   rcx,2\n  je .f  \n    neg       rcx\n    movdqu    xmm2,[mask+16+rcx]\n    movq      xmm0,[rsp-10]\n    punpcklbw xmm0,xmm0\n    vpand     xmm1,xmm0,[mask3]\n    pand      xmm0,[mask2]\n    pmullw    xmm1,[mult]\n    por       xmm0,xmm1\n    vpsrldq   xmm1,xmm0,1\n    psubsb    xmm0,xmm1  \n    pabsb     xmm0,xmm0\n    pcmpeqb   xmm0,[ones]\n    pand      xmm0,xmm2\n    pcmpeqb   xmm0,xmm2\n    pmovmskb  ecx,xmm0\n    inc       cx\n    mov       rax,no\n  .f:\n  cmove   rax,[yes]\nret\nalign 16\nmask  dq -1,-1,0,0\nmask2 dq 0x000F000F000F000F,0x000F000F000F000F\nmask3 dq 0x00F000F000F000F0,0x00F000F000F000F0\nones  dq 0x0101010101010101,0x0101010101010101\nmult  dw 16,16,16,16,16,16,16,16\nyes  dq $+8 \n     db 'Jumping!!',0\nno   db 'Not!!',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214028,"user_id":null,"body":"global jmpnum\n\nsection .data\njumping db \"Jumping!!\", 0\nnot_jumping db \"Not!!\", 0\n\nsection .text\n\n; <--- const char * [RAX] jmpnum(unsigned num [RDI] ) --->\njmpnum:\n    mov r8, 10 ; 10 constant\n    xor rdx, rdx ; clear dividend\n    mov rax, rdi ; dividend\n    div r8 ; divide by 10\n    mov r9, rdx ; first number (rdx contains remainder)\nwhile_start:\n    cmp rax, 0 ; on iterator, test if number is 0, return true if is\n    je is_jumping\n    \n    xor rdx, rdx ; clear dividend\n    div r8 ; divide by 10\n    \n    mov r10, rdx ; second number\n    sub r10, r9 ; subtract\n    mov r9, rdx ; store second number as first\n    \n    cmp r10, 1 ; test if number is +-1\n    je while_start\n    neg r10\n    cmp r10, 1\n    je while_start\n     ; otherwise, return false\nis_not_jumping:\n    mov rax, not_jumping\n    jmp end\nis_jumping:\n    mov rax, jumping\nend:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214029,"user_id":168,"body":"global jmpnum\n\nsection .text\n\ntrue db \"Jumping!!\", 0\nfalse db \"Not!!\", 0\n\n; <--- const char *jmpnum(unsigned num) --->\njmpnum:\n  mov esi, 10\n  mov eax, edi\n  xor edx, edx\n  div esi\n  mov ecx, edx\n  jmp .loop_cond\n.loop:\n  xor edx, edx\n  div esi\n  mov edi, edx\n  sub edx, ecx\n  mov ecx, edx\n  neg edx\n  cmovns ecx, edx\n  cmp ecx, 1\n  jne .false\n  mov ecx, edi\n.loop_cond:\n  test eax, eax\n  jnz .loop\n  mov rax, true\n  ret\n.false:\n  mov rax, false\n  ret\n; ---------> endof jmpnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a55f04be6be383a50000187":[{"id":214030,"user_id":527,"body":"; division optimized by clang\n\nsection .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n                mov     eax, 3435973837\n.loop:          mov     edx, edi\n                imul    rdx, rax\n                shr     rdx, 35\n                lea     esi, [rdx + rdx]\n                lea     esi, [rsi + rsi * 4]\n                sub     esi, edi\n                cmp     esi, -5\n                jl      .not\n                cmp     edi, 9\n                mov     edi, edx\n                ja      .loop\n                mov     rax, s_special\n                ret\n.not:           mov     rax, s_not\n                ret\n\nsection .rodata\ns_special       db 'Special!!', 0\ns_not           db 'NOT!!', 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214031,"user_id":null,"body":"section .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov eax, edi\n  mov ecx, 10\n.loop:\n  test eax, eax\n  je .done\n  cdq\n  idiv ecx\n  cmp edx, 5\n  jle .loop\n  mov eax, .not\n  ret\n.done:\n  mov eax, .special\n  ret\n.not: db \"NOT!!\",0\n.special: db \"Special!!\",0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214032,"user_id":null,"body":"section .rodata\nyes: db \"Special!!\", 0\nno: db \"NOT!!\", 0\n\nsection .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov ecx, 10\n  mov eax, edi\n  \n.loop:\n  xor edx, edx\n  div ecx\n  cmp edx, 5\n  jg .no\n  test eax, eax\n  jnz .loop\n  \n  lea rax, [yes]\n  ret\n.no:\n  lea rax, [no]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214033,"user_id":null,"body":"section .data\nn: db 'NOT!!',0\ns: db 'Special!!',0\n\nsection .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov   rax, rdi\n  mov   rcx, 10\n  xor   rdx,rdx\n  .loop:\n  div   rcx\n  cmp   rdx, 6\n  jge   .fail\n  xor   rdx,rdx\n  cmp   rax, 0\n  jne   .loop\n  mov   rax,s\n  ret\n  \n  .fail:\n  mov   rax,n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214034,"user_id":null,"body":"section .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n    mov   eax, edi\n    mov   ecx, 10\nL1:\n    xor   edx, edx\n    div   ecx\n    cmp   edx, 5\n    jg    not_special\n    cmp   eax, 0\n    je    is_special\n    jmp   L1\n\nis_special:\n    lea   rax, [special]\n    ret\nnot_special:\n    lea   rax, [not_sp]\n    ret\n\nsection .rodata\nspecial:  db  \"Special!!\", 0\nnot_sp:   db  \"NOT!!\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214035,"user_id":50,"body":"section .data\n  a: db 'Special!!',0\n  b: db 'NOT!!',0\n\nsection .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov eax, edi\n  mov r10b,10\n_loop:\n  test eax,eax\n  jz _yeeees\n  xor edx,edx\n  idiv r10\n  cmp edx,5\n  jg _noooot\n  jmp _loop\n_noooot:\n  mov rax, b\n  jmp _exit\n_yeeees:\n  mov rax,a\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214036,"user_id":null,"body":"section .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov rax,rdi\n  mov rsi,10\n.digit:\n  xor rdx,rdx\n  div rsi\n  cmp dl,5\n  ja .no\n  test rax,rax\n  jz .yes\n  jmp .digit\n.no:\n  mov rax,.s_no\n  ret\n.yes:\n  mov rax,.s_yes\n  ret\n.s_yes: db 'Special!!',0\n.s_no:  db 'NOT!!',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214037,"user_id":null,"body":"section .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov eax, edi\n  mov ecx, 10\n    cmp eax, 0\n    jne $+11\n      mov rax, strs\n      ret\n    mov edx, 0\n    div ecx\n    cmp edx, 5\n  jle special_number+7\n  mov rax, strn\n  ret\n\nsection .data\nstrs db \"Special!!\", 0\nstrn db \"NOT!!\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214038,"user_id":null,"body":"section .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov eax, edi\n  cmp eax, 0\n  jne $+11\n    mov rax, strs\n    ret\n  mov edx, 0\n  mov ecx, 10\n  div ecx\n  cmp edx, 5\n  jle special_number+2\n  mov rax, strn\n  ret\n\nsection .data\nstrs db \"Special!!\", 0\nstrn db \"NOT!!\", 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214039,"user_id":1196,"body":"section .text\nglobal special_number\n; const char *special_number(int number);\nspecial_number:\n  mov eax, edi\n  mov ecx, 10\n.loop:\n  test eax, eax\n  jz .exit\n  xor edx, edx\n  idiv ecx\n  cmp edx, 5\n  jg .exit\n  mov edx, eax\n  jmp .loop\n.exit:\n  mov    rsi, notspec\n  mov    rax, special\n  test   edx, edx\n  cmovnz rax, rsi\n  ret\n\nsection .data\nspecial: db \"Special!!\", 0\nnotspec: db \"NOT!!\",     0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a58d46cfd56cb4e8600009d":[{"id":214040,"user_id":168,"body":"global halving_sum\nsection .text\n\nhalving_sum:\n  lea eax, [rdi + rdi]\n  popcnt edx, edi\n  sub eax, edx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214041,"user_id":527,"body":"global halving_sum\nsection .text\n\nhalving_sum:\n                lea     eax, [edi * 2]\n                popcnt  edi, edi\n                sub     eax, edi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214042,"user_id":null,"body":"global halving_sum\nsection .text\n\n; <-- EAX halving_sum(EDI n) -->\nhalving_sum:                            ;\n    xor eax, eax            ; resetting EAX as <r>\n.loop:\n    add eax, edi            ; adding <r> and <n>\n    shr edi, 1              ; getting rid of the rightmost bit\n    jne .loop               ; jumping to the next iteration if <n> is not zero\n    ret\n; -----> endof halving_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214043,"user_id":null,"body":"global halving_sum\nsection .text\nhalving_sum:\n  mov rax,rdi\n  loop1:\n  shr rdi,1\n  add rax,rdi\n  cmp rdi,1\n  jg loop1\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214044,"user_id":null,"body":"global halving_sum\nsection .text\n\nhalving_sum:\n  mov eax, edi\n.loop:\n  test edi, edi\n  je .done\n  shr edi, 1\n  add eax, edi\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214045,"user_id":460,"body":"global halving_sum\nsection .text\nhalving_sum:\n  xor rax, rax\n  @loop:\n  add rax, rdi\n  sar rdi, 1\n  cmp rdi, 0\n  jne @loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214046,"user_id":null,"body":"global halving_sum\nsection .text\n\nhalving_sum:\n  xor eax,eax\nloop:\n  add eax, edi\n  shr edi,1\n  jne loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214047,"user_id":null,"body":"global halving_sum\nsection .text\n\nhalving_sum:\nxor eax, eax\nloop:\nadd eax, edi\nshr edi, 1\ncmp edi, 0\njg loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214048,"user_id":null,"body":"global halving_sum\nsection .text\n\nhalving_sum:\n  mov rax, rdi\n  .loop:\n  test rdi, rdi\n  jz .done\n  shr rdi, 1\n  add rax, rdi\n  jmp .loop\n  .done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214049,"user_id":881,"body":"global halving_sum\nsection .text\n\nhalving_sum:\n    xor eax, eax\n.loop:\n    add eax, edi\n    sar edi, 1\n    jnz .loop\n.done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a58d889880385c2f40000aa":[{"id":214050,"user_id":null,"body":"global auto_morphic\n\nsection .text\n\nauto_morphic:\n    mov rax, rdi   \n    mul rdi        ; rax will contain the sqare \n\nmy_loop:\n    mov rdx, 0     ; rdx will contain the last digital (remainder)\n    mov rcx, 10    ; we will divide by 10\n    div rcx        \n    mov r8, rdx    ; we save the last digital of square in r8\n    mov r10, rax   ; save square\/10 in r10\n    mov rax, rdi   ; do all the same with the number itself\n    mov rdx, 0\n    div rcx\n    cmp rdx, r8    ; compare two remainders\n    jne not_auto   \n    mov rdi, rax   ; change number to number\/10\n    mov rax, r10   ; restore square\/10\n    cmp rdi, 0     ; if number\/10 isn't 0, make again\n    jne my_loop\n\nauto:\n    mov rax, msg1\n    jmp end\n\nnot_auto:\n    mov rax, msg2\n    \nend:\n    ret\n\nsection .data\n\nmsg1: db \"Automorphic\", 0\nmsg2: db \"Not!!\", 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214051,"user_id":null,"body":"global auto_morphic\n\nsection .text\n\n; <--- const char *auto_morphic(unsigned num) --->\nauto_morphic:\n  mov ecx, 1\n  mov rdx, rdi\n  test rdi, rdi\n  je .checkauto\n  mov rax, 0xcccccccccccccccd\n.countdigits:\n  mulx rdx, rsi, rax\n  lea rcx, [rcx+rcx*4]\n  add rcx, rcx\n  shr rdx, 3\n  jne .countdigits\n.checkauto:\n  mov rax, rdi\n  xor edx, edx\n  imul rax, rdi\n  div rcx\n  xor ecx, ecx\n  cmp rdx, rdi\n  sete cl\n  lea rsi, [rcx+rcx*2]\n  lea rax, [.str+rsi+rsi]\n  ret\n.str: db `Not!!\\0Automorphic\\0`","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214052,"user_id":null,"body":"global auto_morphic\n\nsection .bss\n    num resb 16\n    \nsection .data\n    automorphic db \"Automorphic\", 0\n    not_automorphic db \"Not!!\", 0\n\nsection .text\n\n; <--- const char *auto_morphic(unsigned num) --->\nauto_morphic:\n    xor rax, rax            ; RAX <- the result\n    mov rax, rdi\n    mov rbx, 10\n    mov rcx, 1\n.size_num:\n    xor rdx, rdx\n    div rbx\n    cmp rax, 0\n    je .check_auto_morphic\n    inc rcx\n    jmp .size_num\n.check_auto_morphic:\n    xor rdx, rdx \n    mov rax, rdi\n    mul rdi\n    mov qword [num], rax\n    mov qword [num+64], rdx\n    jmp .first_loop\n.loop:\n    mov rax, [num] \n    mov rdx, [num+64]\n.first_loop:\n    div rbx\n    mov r8, rdx\n    xor rdx, rdx\n    mov rax, rdi\n    div rbx\n    cmp r8, rdx\n    je .continue\n    jmp .end_not_auto_morphic\n.continue:\n    mov rdi, rax\n    xor rdx, rdx\n    mov rax, [num]\n    div rbx\n    mov qword [num], rax\n    xor rdx, rdx\n    mov rax, [num+64]\n    div rbx\n    mov qword [num+64], rax\n    loop .loop\n    mov rax, automorphic\n    jmp .end\n.end_not_auto_morphic:\n    mov rax, not_automorphic\n.end:\n    ret\n; ---------> endof automorph <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214053,"user_id":50,"body":"global auto_morphic\n\nsection .data\n  a db \"Automorphic\",0\n  b db \"Not!!\",0\n\nsection .text\n\n; <--- const char *auto_morphic(unsigned num) --->\nauto_morphic:\n    xor rax, rax            ; RAX <- the result\n    mov r8,rdi\n    mov r9,rdi\n    mov rbx,10\n    imul r9,rdi\n_loop:\n  cmp r8,0\n  je _retTrue\n  mov rax,r8\n  xor rdx,rdx\n  div rbx\n  mov r10,rdx\n  mov r8,rax\n  mov rax,r9\n  xor rdx,rdx\n  div rbx\n  cmp r10,rdx\n  jne _retFalse\n  mov r9,rax\n  jmp _loop\n_retFalse:\n  mov rax,b\n  ret\n_retTrue:\n  mov rax,a\n  ret\n; ---------> endof automorph <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214054,"user_id":null,"body":"global auto_morphic\n\nsection .text\n\n; <--- const char *auto_morphic(unsigned num) --->\nauto_morphic:\n    mov rax, 1          ; Find first N such that 10^N > RDI\n    mov rcx, 10\n.powten:\n    cmp rax, rdi        ; Found it yet?\n    ja .found\n    mul rcx\n    test rdx, rdx       ; More than 64 bits -> overflow -> say 'no'\n    jnz .nope\n    jmp .powten\n.found:\n    mov rcx, rax        ; RCX = requisite power of 10\n    mov rax, rdi        ; Calculate square of input\n    mul rax\n    div rcx             ; Get last digits\n    cmp rdi, rdx        ; Equal to the former number?\n    jne .nope           ; If not, then the number is not automorphic\n    mov rax, s_automorphic\n    je .done            \n.nope:    \n    mov rax, s_not\n.done:\n    ret\n    \nsection .data\ns_automorphic:\n    db 'Automorphic', 0\ns_not:\n    db 'Not!!', 0\n    \n; ---------> endof automorph <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214055,"user_id":76,"body":"global auto_morphic\n\nsection .text\nauto db \"Automorphic\", 0\nnot_auto db \"Not!!\", 0\n; <--- const char *auto_morphic(unsigned num) --->\nauto_morphic:\n    mov rax, not_auto\n    cmp rdi, 1\n    je .auto\n    cmp rdi, 5\n    je .auto\n    cmp rdi, 6\n    je .auto\n    cmp rdi, 25\n    je .auto\n    cmp rdi, 76\n    je .auto\n    cmp rdi, 376\n    je .auto\n    cmp rdi, 625\n    je .auto\n    cmp rdi, 9376\n    je .auto\n    cmp rdi, 90625\n    je .auto\n    cmp rdi, 890625\n    je .auto\n    cmp rdi, 2890625\n    je .auto\n    cmp rdi, 7109376\n    je .auto\n    cmp rdi, 12890625\n    je .auto\n    cmp rdi, 87109376\n    je .auto\n    cmp rdi, 212890625\n    je .auto\n    cmp rdi, 787109376\n    je .auto\n    cmp rdi, 1787109376\n    je .auto\n    jmp .exit\n.auto:\n    mov rax, auto\n.exit:\n    ret\n; ---------> endof automorph <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214056,"user_id":null,"body":"global auto_morphic\nauto_morphic:\n  mov   rax,rdi\n  mul   rax\n  mov   rcx,11\n  @b:cmp rdi,[powers+rcx*8-8]\n     ja @f\n  loop @b \n  @f:\n  div   qword[powers+rcx*8]\n  cmp   rdi,rdx\n  mov   rax,no\n  cmove rax,[yes]\nret\nno     db 'Not!!',0\nyes    dq $+8\n       db 'Automorphic',0\npowers dq 0,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214057,"user_id":331,"body":"section .data\n  aut: db 'Automorphic',0\n  noa: db 'Not!!',0\n\nsection .text\nglobal auto_morphic\nglobal next_modulo\n\n; <--- const char *auto_morphic(unsigned num) --->\n; is ONLY Automorphic if last number ends with 5 or 6 except for one\n; is automorphic if (num**2 - num) mod (number to next 10s) = 0\n; 625 -> 1000\n; 25 -> 100\n; 5 -> 10\nauto_morphic:\n    mov rax, rdi            ; RAX <- the result\n    mul rax\n    sub rax, rdi\n    mov rbx, rax            ; make copy of automorph number (squared - number)\n    call next_modulo     \n    mov rdx, rax            ; copy 10s\n    mov rax, rbx            ; copy back number\n    mov rbx, rdx            ; copy back 10s\n    xor rdx, rdx            ; holds the rest\n    div rbx\n    cmp rdx, 0              ; if rest is 0 the number is automorph\n    je .is_morph\n    jmp .not_morph\n    \n  .is_morph:\n    mov rax, aut\n    jmp .exit\n    \n  .not_morph:\n    mov rax, noa\n    \n  .exit:\n    ret\n; ---------> endof automorph <---------\n\n; helper routine which returns the next highest base 10 number \nnext_modulo:\n    xor rax, rax\n    mov rax, 10\n    mov rsi, 10\n  .loop:\n    cmp rdi, rax\n    jle .exit_mod\n    mul rsi\n    jmp .loop\n  .exit_mod:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214058,"user_id":null,"body":"global auto_morphic\n\nsection .data\n    true    db  \"Automorphic\", 0\n    false   db  \"Not!!\", 0\n\nsection .text\n\n    auto_morphic:\n\n        mov         rax, rdi\n        mov         rcx, 1\n        mov         rbx, 10\n\n    .loop_1:\n        xchg        rax, rcx\n        mul         rbx\n        xchg        rax, rcx\n        xor         rdx, rdx\n        div         rbx\n        test        rax, rax\n        jnz         .loop_1\n\n        mov         rax, rdi\n        mul         rdi\n        div         rcx\n        mov         rax, true\n        cmp         rdx, rdi\n        je          .done\n\n        mov         rax, false\n\n    .done:\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214059,"user_id":168,"body":"global auto_morphic\n\nsection .text\n\ntrue db \"Automorphic\", 0\nfalse db \"Not!!\", 0\n\n; <--- const char *auto_morphic(unsigned num) --->\nauto_morphic:\n  mov eax, edi\n  mov ecx, 1\n.loop:\n  imul rcx, 10\n  cmp rcx, rax\n  jbe .loop\n  mul rax\n  div rcx\n  cmp edx, edi\n  lea rax, [rel false]\n  lea rdx, [rel true]\n  cmove rax, rdx\n  ret\n; ---------> endof automorph <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a662a02e626c54e87000123":[{"id":214060,"user_id":null,"body":"global extra_perfect\nextern malloc\n\nsection .text\n\n; <--- unsigned *extra_perfect(unsigned num, int *cnt) --->\nextra_perfect:\n  push rbx\n  mov ebx, edi\n  inc ebx\n  shr ebx, 1\n  mov [rsi], ebx\n  lea rdi, [4*rbx]\n  call malloc\n  add rbx, rbx\n  xor ecx, ecx\n.loop:\n  cmp rbx, rcx\n  je .done\n  lea rdx, [rcx + 1]\n  mov [rax + 2*rcx], edx\n  add rcx, 2\n  jmp .loop\n.done:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214061,"user_id":null,"body":"global extra_perfect\nextern malloc\n\nsection .text\n\n; <--- unsigned *extra_perfect(unsigned num, int *cnt) --->\nextra_perfect:\n  push rbx\n  push rbp\n  mov ebx, edi\n  mov rbp, rsi  \n  shl rdi, 2\n  call malloc\n  mov ecx, 1\n  xor edx, edx\n  .loop:\n  cmp ecx, ebx\n  ja .done\n  mov dword [rax+rdx*4], ecx\n  add ecx, 2\n  inc edx\n  jmp .loop\n  .done:\n  shr ecx, 1\n  mov dword [rbp], ecx\n  pop rbp\n  pop rbx\n  ret\n; ---------> endof extra_perfect <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214062,"user_id":null,"body":"global extra_perfect\nextern malloc\n\nsection .text\n\n; <--- unsigned *extra_perfect(unsigned num, int *cnt) --->\n\n; The first bit of a number is of course always set.\n; If the last bit is set then the number is odd.\n; So we need to get N\/2 integers of memory (N*2 bytes), and fill them with\n; the odd numbers 1 .. N.\nextra_perfect:\n    inc rdi               ; N is inclusive\n    mov rax,rdi           ; N \/ 2 odd numbers\n    shr rax,1\n    mov [rsi],eax\n    push rdi              ; Upper limit\n    add rdi,rdi           ; 4-byte integers\n    call malloc\n    test rax,rax          ; Return NULL on error\n    mov rdi,rax           ; Start writing numbers there\n    mov rsi,rax           ; Keep start address around\n    pop rdx               ; Get our limit back and store it in RDX\n    jz .out               ; Stop if the address was zero \n    xor rax,rax\n.loop:\n    inc rax               ; Write odd number\n    stosd\n    inc rax               ; Skip even number\n    cmp rax,rdx           ; Are we there yet?\n    jb .loop              ; If not, keep going\n    mov rax,rsi           ; Return the start of the array\n.out:\n    ret\n; ---------> endof extra_perfect <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214063,"user_id":null,"body":"global extra_perfect\nextern malloc\nextra_perfect:\n  push rdi\n  inc  rdi\n  shr  rdi,1\n  sbb  qword[rsp],0\n  mov  [rsi],edi\n  push rdi\n  shl  rdi,2\n  call malloc\n  pop  rcx\n  pop  rdi\n  .b:mov [rax+rcx*4-4],edi\n     sub rdi,2\n  loop .b\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214064,"user_id":168,"body":"global extra_perfect\nextern malloc\n\nsection .text\n\n; <--- unsigned *extra_perfect(unsigned num, int *cnt) --->\nextra_perfect:\n  push rbx\n  inc edi\n  shr edi, 1\n  mov ebx, edi\n  mov dword [rsi], edi\n  shl edi, 2\n  call malloc\n  lea edx, [rbx * 2 - 1]\n.loop:\n  dec ebx\n  mov dword [rax + 4 * rbx], edx\n  sub edx, 2\n  jg .loop\n  pop rbx\n  ret\n; ---------> endof extra_perfect <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214065,"user_id":null,"body":"global extra_perfect\nextern malloc\n\nsection .text\n\n; <--- unsigned *extra_perfect(unsigned num, int *cnt) --->\nextra_perfect:\n    test edi, edi           ; whether <num> is zero\n    je .error               ; jumping to the .error label\n    mov ecx, edi            ; copying <num> to ECX as <n>\n    inc edi                 ; incrementing <num>\n    test ecx, 1             ; whether <n> is extra perfect\n    cmovne ecx, edi         ; setting <n> to <num>\n    shr ecx, 1              ; dividing <n> by two\n    mov [rsi], ecx          ; saving <n> in <*cnt>\n    push rsi                ; saving <cnt> in the stack\n    lea rdi, [rcx*4]        ; target bytes for <extranums>\n    call malloc             ; allocating memory\n    pop rsi                 ; restoring <cnt> from the stack\n    test rax, rax           ; whether <extranums> is not NULL\n    je .error               ; otherwise, jumping to the .error label\n    mov esi, [rsi]          ; copying <*cnt> to ESI as <cnt>\n    xor ecx, ecx            ; resetting ECX as <i>\n    mov edx, 1              ; setting EDX to one as <num>\n.loop:\n    cmp rcx, rsi            ; whether <i> is less than <cnt>\n    je .exit                ; otherwise, jumping to exit\n    mov [rax+rcx*4], edx    ; copying <num> to <*(extranums+i)>\n    add edx, 2              ; setting <num> to the next extra perfect\n    inc rcx                 ; incrementing <i>\n    jmp .loop               ; jumping to the next iteration\n.error:\n    mov dword [rsi], -1     ; setting the actual count to minus one\n    xor eax, eax            ; resetting <extranums>\n.exit:\n    ret\n; ---------> endof extra_perfect <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a805d8cafa10f8b930005ba":[{"id":214066,"user_id":null,"body":"global nearestsq\n\nnearestsq:\ncvtsi2sd  xmm0, edi\nsqrtsd    xmm0, xmm0\ncvtsd2si eax, xmm0\nmul eax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214067,"user_id":null,"body":"global nearestsq\n\n; <-- EAX nearestsq(EDI num) -->\nnearestsq:\n    xor eax, eax            ; EAX <- the result\n    xor ecx, ecx\nloop:\n    inc ecx\n    mov eax, ecx\n    mul eax\n    cmp eax, edi\n    je exact\n    jl loop\n    dec ecx\n   imul ecx, ecx\n   push rax\n    sub eax, edi\n    sub edi, ecx\n    cmp eax, edi\n    jl high\nlow:\n    pop rax\n    mov eax, ecx\n    ret\nhigh: \n    pop rax\nexact:\n    ret\n; -----> endof nearestsq <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214068,"user_id":null,"body":"global nearestsq\n\nhalf: DQ 0x3fe0000000000000\n\nnearestsq:\n  vxorpd xmm0, xmm0, xmm0\n  mov edi, edi\n  vcvtsi2sd xmm0, xmm0, rdi\n  vsqrtsd xmm0, xmm0, xmm0\n  vaddsd xmm1, xmm0, [half]\n  vcvttsd2si rax, xmm1\n  imul eax, eax\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214069,"user_id":null,"body":"global nearestsq\n\nsection .text\n\n; <-- EAX nearestsq(EDI num) -->\nnearestsq:\n  push rdi\n  \n  fild dword [rsp]\n  fsqrt\n  fstp dword [rsp]\n  cvtss2si rax, [rsp]\n  imul rax\n  \n  pop rdi\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214070,"user_id":50,"body":"global nearestsq\n\n; <-- EAX nearestsq(EDI num) -->\nnearestsq:\n    xor eax, eax            ; EAX <- the result\n    cvtsi2ss xmm0, edi\n    sqrtss xmm0, xmm0\n    cvtss2si eax,xmm0\n    mul eax\n    ret\n; -----> endof nearestsq <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214071,"user_id":null,"body":"global nearestsq\nnearestsq:\n    cvtsi2sd xmm0,rdi\n    sqrtsd   xmm0,xmm0\n    roundsd  xmm0,xmm0,0\n    mulsd    xmm0,xmm0\n    cvtsd2si rax,xmm0\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214072,"user_id":1027,"body":"global nearestsq\nextern sqrt,round,pow\n; edi => n\nnearestsq:\n  cvtsi2sd xmm0,edi\n  call sqrt\n  call round\n  cvttsd2si eax,xmm0\n  \n  xor edx,edx\n  mov ecx,eax\n  mul ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214073,"user_id":null,"body":"global nearestsq\n\n; <-- EAX nearestsq(EDI num) -->\nnearestsq:\n    mov edi, edi            ; resetting the high 32 bits\n    cvtsi2sd xmm0, edi      ; converting <num> to double   \n    sqrtsd xmm0, xmm0       ; getting the square root\n    cvtsd2si eax, xmm0      ; converting to integer from double without truncation, i.e. rounded\n    mul eax                 ; squaring <num>\n    ret\n; -----> endof nearestsq <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214074,"user_id":527,"body":"global nearestsq\n\n; unsigned nearestsq(unsigned num)\nnearestsq:\n                mov         edi, edi\n                cvtsi2sd    xmm0, rdi\n                sqrtsd      xmm0, xmm0\n                cvtsd2si    eax, xmm0\n                imul        eax, eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214075,"user_id":527,"body":"global nearestsq\n\n; unsigned nearestsq(unsigned num)\nnearestsq:\n                cvtsi2sd    xmm0, edi\n                sqrtsd      xmm0, xmm0\n                cvtsd2si    eax, xmm0\n                imul        eax, eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a87449ab1710171300000fd":[{"id":214076,"user_id":null,"body":"global tidy_number\n\nsection .text\n\n; <--- bool tidy_number(int num) --->\ntidy_number:\n  mov r8, 10\n  mov eax, edi\n  cdq\n  idiv r8d\n  mov ecx, edx\n.loop\n  mov eax, edi\n  cdq\n  idiv r8d\n  mov esi, eax\n  cdq\n  idiv r8d\n  mov eax, edi\n  add eax, 9\n  cmp eax, 19\n  jb .done\n  mov edi, esi\n  cmp edx, ecx\n  mov ecx, edx\n  jle .loop\n.done:\n  cmp eax, 19\n  setb al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214077,"user_id":50,"body":"global tidy_number\n\nsection .text\n\n; <--- bool tidy_number(int num) --->\ntidy_number:\n    xor rax,rax          ; AL <- the result    \n    xor rcx,rcx\n    mov eax,edi\n    mov rbx,10\n    xor rdx,rdx\n    div rbx\n    mov rcx,rdx\n_loop:\n  cmp eax,0\n  je _retTrue\n  xor rdx,rdx\n  div rbx\n  cmp rdx,rcx\n  jg _retFalse\n  mov rcx,rdx\n  jmp _loop\n_retFalse:\n  mov rax,0\n  ret\n_retTrue:\n  mov rax,1\n  ret\n; ---------> endof tidynum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214078,"user_id":null,"body":"global tidy_number\n\nsection .text\n\n; <--- bool {al} tidy_number(int {edi} num) --->\ntidy_number:\n    xor edx, edx\n    mov ecx, 10\n    mov eax, edi\n    div ecx\nloop1:\n    mov esi, edx\n    xor edx, edx\n    div ecx\n    cmp edx, 0\n    jg cont\n    cmp esi, 0\n    jg cont\n    mov al, 1\n    ret\ncont:\n    cmp esi, edx\n    jge loop1\n    mov al, 0\n    ret\n; ---------> endof tidynum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214079,"user_id":null,"body":"global tidy_number\n\nsection .text\n\n; <--- bool tidy_number(int num) --->\ntidy_number:    \n  mov eax, edi\n  mov ecx, 10\n  mov edx, 10\n\n.loop:\n  cmp eax, 0\n  jle .tiny\n  mov esi, edx\n  xor edx, edx\n  div ecx\n  cmp edx, esi\n  jle .loop\n  xor al, al\n  ret\n  \n.tiny:\n  mov al, 1\n  ret\n; ---------> endof tidynum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214080,"user_id":null,"body":"global tidy_number\n\nsection .text\n\n; <--- bool tidy_number(int num) --->\ntidy_number:\n    push rbp\n    mov rbp, rsp\n    mov rax, rdi\n    \n    push rdx\n    xor rdx, rdx\n    push rbx\n    mov rbx, 10\n    push rcx\n    \n    div rbx\n    mov rcx, rdx\n    \n    cmp rax, 0\n    jz .ret1\n    \n.divide:\n    cmp rax, 0\n    jz .ret1\n    \n    mov rdx, 0\n    div rbx\n    cmp rdx, rcx\n    jg .ret0\n    mov rcx, rdx\n    jmp .divide\n.ret1:\n    mov rax, 1\n    jmp .ret\n.ret0:\n    xor rax,rax\n.ret:\n    pop rcx\n    pop rbx\n    pop rdx\n    mov rsp, rbp\n    pop rbp\n    ret\n; ---------> endof tidynum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214081,"user_id":null,"body":"global tidy_number\n\nsection .text\n\n; <--- bool tidy_number(int num) --->\ntidy_number:\n    mov esi, 10          ; digitize decimal number\n    xor edx, edx\n    mov eax, edi\n    div esi\n    test eax, eax        ; quotient\n    jz .true             ; number < 10\n.digitize:\n    mov ecx, edx         ; remainder \n    xor edx, edx\n    div esi\n    cmp ecx, edx         ; current (edx) to previous (ecx) compare\n    jl .false\n    test eax, eax        ; no more digits\n    jz .true\n    jmp .digitize        ; from low to high digits\n.false:\n    xor rax, rax\n    jmp .quit\n.true:\n    xor rax, rax\n    inc al\n.quit:                   ; AL <- the result\n    ret\n; ---------> endof tidynum <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214082,"user_id":null,"body":"global tidy_number\n\nsection .text\n\ntidy_number:\n    mov rax,rdi\n    mov rcx,10\n    .b:cqo\n       div  rcx\n       cmp  r8,rdx\n       jc .e\n       mov  r8,rdx\n       test rax,rax\n    jne .b   \n    .e:   \n    setnc al\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214083,"user_id":527,"body":"global tidy_number\n\nsection .text\n\n; bool tidy_number(int num)\ntidy_number:\n                mov     edi, edi\n                mov     ecx, 10\n.loop:          mov     rax, 3435973837\n                imul    rax, rdi\n                shr     rax, 35\n                imul    edx, eax, 10\n                sub     edi, edx\n                cmp     edi, ecx\n                ja      .ret0\n                mov     ecx, edi\n                mov     edi, eax\n                test    eax, eax\n                jnz     .loop\n                mov     eax, 1\n                ret\n.ret0:          xor     eax, eax\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214084,"user_id":null,"body":"global tidy_number\n\nsection .text\n\ntidy_number:\n    mov rax, rdi\n    mov rbx, 10 ; contains last examined digit\n    mov rcx, 10 ; div needs a register\n.loop:\n    xor rdx, rdx ; clear rdx set by last div\n    cmp rax, 0\n    jle .true\n    div rcx\n    cmp rbx, rdx\n    jl .false\n    mov rbx, rdx\n    jmp .loop\n    \n.true:\n    mov rax, 1\n    ret\n    \n.false:\n    mov rax, 0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214085,"user_id":168,"body":"global tidy_number\n\nsection .text\n\n; <--- bool tidy_number(int num) --->\ntidy_number:\n  mov eax, edi\n  mov ecx, 10\n  mov esi, ecx\n.loop:\n  xor edx, edx\n  div ecx\n  cmp edx, esi\n  ja .false\n  mov esi, edx\n  test eax, eax\n  jnz .loop\n  mov al, 1\n  ret\n.false:\n  xor eax, eax\n  ret\n; ---------> endof tidynum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a8bcd980025e99381000099":[{"id":214086,"user_id":null,"body":"global squareUp\nextern calloc\n\nsection .text\n; int32_t * squareUp(int32_t n);\n; Ensure that the returned pointer is free'able.\nsquareUp:\n  push rbp\n  mov ebp, edi\n  imul ebp, edi\n  push rbx\n  mov ebx, edi\n  mov esi, 4\n  push rcx\n  movsx rdi, ebp\n  call calloc\n  movsx rdi, ebx\n  lea r8, [rdi-1]\n  mov rsi, r8\n  mov edx, 1\n.oloop:\n  cmp edx, ebx\n  jg .odone\n  mov rcx, rsi\n.iloop:\n  cmp ebp, ecx\n  jle .idone\n  mov [rax+rcx*4], edx\n  add rcx, rdi\n  jmp .iloop\n.idone:\n  inc edx\n  add rsi, r8\n  jmp .oloop\n.odone:\n  pop rdx\n  pop rbx\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214087,"user_id":null,"body":"global squareUp\nextern malloc\nsection .data\nsection .text\nsquareUp:\n      push rdi\n      imul rdi,rdi     ; Square number of entries in the table\n      shl  rdi,2       ; 4 bytes per int\n      call malloc\n      pop  rdi\n      mov  rsi,rdi\n      imul rsi,rsi\n      dec  rsi         ; Offset set to last entry in the array\n      mov  r8,rdi      ; Move from top - start out with all values\n      mov  r9,-1       ; initial zero padding\n@l1:  xor  ecx,ecx\n@l2:  inc  ecx\n      mov  [rax + rsi * 4],ecx\n      dec  rsi\n      cmp  ecx,r8d\n      jl   @l2\n      dec  r8          ; Decrease number of values to write next loop\n      inc  r9          ; Increase number of zeros to pad\n      mov  r10,r9\n@l3:  test rsi,rsi\n      js   @cooked     ; Done when offset became negative\n      test r10,r10     ; Zero padding done? \n      jz   @l1\n      mov  dword [rax + rsi * 4],0\n      dec  rsi\n      dec  r10\n      jmp  @l3\n@cooked:      \n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214088,"user_id":null,"body":"global squareUp\nextern calloc\nsection .text\nsquareUp:\n  push rdi\n  imul rdi,rdi\n  push rdi\n  mov  rsi,4\n  call calloc\n  pop  rdi\n  pop  rdx\n  lea  rax,[rax+rdi*4]\n  neg  rdx\n  mov  rsi,rdx\n  .a:mov rcx,rsi\n    .b:sub [rax+rcx*4] ,ecx\n       inc rcx\n    jne .b\n    lea  rax,[rax+rdx*4]\n    inc rsi\n  jne .a  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214089,"user_id":null,"body":"global squareUp\n\nextern calloc\n\nsection .text\n\nsquareUp:\n    push    rdi\n    imul    edi, edi\n    mov     rsi, 4\n    call    calloc\n    pop     rcx\n\n    mov     rdi, rax\n    xor     esi, esi\n\n.outer_loop:\n    test    ecx, ecx\n    jz      .exit\n    \n    dec     ecx\n    lea     rdi, [rdi + 4 * rcx]\n\n    inc     esi\n    mov     edx, esi\n\n.inner_loop:\n    test    edx, edx\n    jz      .outer_loop\n\n    mov     dword [rdi], edx\n    add     rdi, 4\n    \n    dec     edx\n    jmp     .inner_loop\n    \n.exit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214090,"user_id":null,"body":"section .text\n\nglobal squareUp\nextern calloc\n\n; int32_t * squareUp(int32_t n)\nsquareUp:\n    push rdi\n    imul rdi, rdi               ; allocate n^2 double words\n    mov rsi, 4\n    call calloc\n    pop rdi                     ; restore n\n    mov rsi, rdi                ; loop n times using this\n    mov rdx, rax                ; moving memory pointer\n\n.loop:\n    test rsi, rsi\n    jz .end\n    dec rsi\n\n    lea rdx, [rdx+4*rsi]        ; skip zeroes\n    mov rcx, rdi\n    sub rcx, rsi\n\n.countdown:\n    mov [rdx], ecx\n    add rdx, 4\n    loop .countdown\n\n    jmp .loop\n\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214091,"user_id":168,"body":"global squareUp\nextern calloc\nsection .text\n; int32_t * squareUp(int32_t n);\n; Ensure that the returned pointer is free'able.\nsquareUp:\n  push rbx\n  mov ebx, edi\n  lea esi, [edi * 4]\n  call calloc\n  mov edx, ebx\n  mov esi, ebx\n  imul esi, ebx\n.loop1:\n  mov ecx, edx\n  mov edi, esi\n  sub edi, ecx\n.loop2:\n  mov dword [rax + 4 * rdi], ecx\n  inc edi\n  dec ecx\n  jnz .loop2\n  sub esi, ebx\n  dec edx\n  jg .loop1\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214092,"user_id":null,"body":"global squareUp\nextern calloc\n\nsquareUp:\n  enter 0, 0\n  push rbx\n  push rdi\n  \n  mov eax, edi\n  mul rdi\n  push rax\n  mov rdi, rax\n  mov esi, 4\n  call calloc\n  mov rbx, rax\n  test rbx, rbx\n  jz .done\n  \n  pop r9\n  pop r8\n  \n  mov rcx, r8\n  \n  ; rcx=i; rax=j\n.next_i:\n  lea rax, [r8-1]\n  mul rcx\n  \n.next_j:\n  mov [rax*4+rbx], ecx\n  add rax, r8\n  cmp rax, r9\n  jb .next_j\n  loop .next_i\n  \n.done:\n  mov rax, rbx\n  mov rbx, [rbp-8]\n  leave\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a905c2157c562994900009d":[{"id":214093,"user_id":null,"body":"extern malloc\nglobal product_array\nsection .text\nproduct_array:\n  push rbp\n  mov rbp, rdi\n  lea rdi, [rsi*4]\n  push rbx\n  mov rbx, rsi\n  push rcx\n  call malloc\n  movsx rdi, dword [rbp]\n  mov rsi, rax\n  xor eax, eax\n.prodloop:\n  inc rax\n  cmp rax, rbx\n  jnb .buildarray\n  movsx rdx, dword [rbp+rax*4]\n  imul rdi, rdx\n  jmp .prodloop\n.buildarray:\n  xor ecx, ecx\n.divloop:\n  cmp rbx, rcx\n  je .done\n  movsx r8, dword [rbp+rcx*4]\n  mov rax, rdi\n  cqo\n  idiv r8\n  mov [rsi+rcx*4], eax\n  inc rcx\n  jmp .divloop\n.done:\n  pop rdx\n  pop rbx\n  mov rax, rsi\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214094,"user_id":null,"body":"global product_array\nsection .text\nextern malloc\nproduct_array:\n  push rsi\n  push rdi\n  lea  rdi,[rsi*4]\n  call malloc\n  mov  rsi,rax\n  pop  rdi\n\n  mov  rcx,[rsp]\n  mov rax,1\n  .a:mov r8d,[rdi+rcx*4-4]\n     mul r8\n  loop .a\n  \n  pop  rcx\n  mov  r8,1\n  .b:xor rdx,rdx\n     mov r9d,dword[rdi+rcx*4-4]\n     div r9\n     mul r8\n     mov r8,r9\n     mov [rsi+rcx*4-4],eax\n  loop .b\n  mov rax,rsi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214095,"user_id":1315,"body":"global product_array\nextern malloc\nsection .text\nproduct_array:           ; int *product_array(const int *numbers, size_t count)\n  push rdi               ; save numbers\n  push rsi               ; save count\n  imul rdi, rsi, 4       ; rdi = count * sizeof(int)\n  call malloc\n  pop  rbx               ; rbx := count\n  pop  rsi               ; rsi := numbers\n  mov  rdi, rax          ; rdi := products = malloc(count * sizeof(int))\n  mov  rax, 1            ; rax := fullProduct = 1\n  xor  rcx, rcx          ; rcx := i = 0\n  xor  rdx, rdx\nscan_numbers:\n  cmp  rcx, rbx          ; while ( i < count )\n  jge  end_scan          ; {\n  imul dword [rsi+4*rcx] ;     fullProduct *= numbers[i]\n  inc  rcx               ;     i++\n  jmp  scan_numbers      ; }\nend_scan:\n  mov  r10, rax          ; save full product\n  mov  r11, rdx\n  xor  rcx, rcx          ; i = 0\ngenerate_products:\n  cmp  rcx, rbx          ; while ( i < count )\n  jge  end_generation    ; {\n  mov  rax, r10\n  mov  rdx, r11\n  idiv dword [rsi+4*rcx]\n  mov  [rdi+4*rcx], eax  ;     products[i] = fullProduct \/ numbers[i]\n  inc  rcx               ;     i++\n  jmp  generate_products ; }\nend_generation:\n  mov  rax, rdi          ; return products\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214096,"user_id":527,"body":"global product_array\nextern malloc\nsection .text\nproduct_array:\n                shl     rsi, 2\n                push    rbx\n                push    rdi\n                push    rsi\n                mov     rdi, rsi\n                call    malloc\n                pop     rsi\n                pop     rdi\n                mov     r8, rax\n                add     rdi, rsi\n                neg     rsi\n                mov     rbx, rax\n                sub     rbx, rsi\n                mov     rcx, rsi\n                mov     r10, 1\n.loop_prod:     movsx   rax, dword [rdi + rcx]\n                imul    r10, rax\n                add     rcx, 4\n                jnz     .loop_prod\n                mov     r11, r10\n                shr     r11, 32\n                mov     rcx, rsi\n.loop_out:      mov     rax, r10\n                mov     rdx, r11\n                idiv    dword [rdi + rcx]\n                mov     [rbx + rcx], eax\n                add     rcx, 4\n                jnz     .loop_out\n                pop     rbx\n                mov     rax, r8\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214097,"user_id":null,"body":"global product_array\nextern malloc\nsection .text\nproduct_array:\n  push rdi\n  push rsi\n  xor rax, rax\n  inc rax\n  mov rcx, rsi\n  xor rbx, rbx\n.prod_loop:\n  mov ebx, dword [rdi]\n  mul rbx\n  add rdi, 4\n  loop .prod_loop\n  push rax\n  shl rsi, 2\n  mov rdi, rsi\n  call malloc\n  pop rbx\n  pop rcx\n  pop rsi\n  push rax\n  mov rdi, rax\n  xor rdx, rdx\n  xor r8, r8\n.fill_loop:\n  mov rax, rbx\n  mov r8d, dword [rsi]\n  div r8\n  add rsi, 4\n  mov dword [rdi], eax\n  add rdi, 4\n  loop .fill_loop\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214098,"user_id":null,"body":"global product_array\nextern malloc\nsection .text\nproduct_array:\n  push rdi\n  push rsi\n  xor rax, rax\n  inc rax\n  mov rcx, rsi\n  xor rbx, rbx\n.prod_loop:\n  mov ebx, dword [rdi]\n  mul rbx\n  add rdi, 4\n  loop .prod_loop\n  push rax\n  lea rdi, [rsi * 4]\n  call malloc\n  pop rbx\n  pop rcx\n  pop rsi\n  push rax\n  mov rdi, rax\n  xor rdx, rdx\n  xor r8, r8\n.fill_loop:\n  mov rax, rbx\n  mov r8d, dword [rsi]\n  div r8\n  mov dword [rdi], eax\n  add rsi, 4\n  add rdi, 4\n  loop .fill_loop\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214099,"user_id":168,"body":"global product_array\nextern malloc\nsection .text\nproduct_array:\n  push rdi\n  push rsi\n  mov rax, 1\n  mov rcx, rsi\n  xor rbx, rbx\n.prod_loop:\n  mov ebx, dword [rdi]\n  mul rbx\n  add rdi, 4\n  loop .prod_loop\n  push rax\n  lea rdi, [rsi * 4]\n  call malloc\n  ; rbx = prod\n  pop rbx\n  ; rcx = length\n  pop rcx\n  ; rsi = array ptr\n  pop rsi\n  push rax\n  mov rdi, rax\n  xor rdx, rdx\n  xor r8, r8\n.fill_loop:\n  mov rax, rbx\n  mov r8d, dword [rsi]\n  div r8\n  mov dword [rdi], eax\n  add rsi, 4\n  add rdi, 4\n  loop .fill_loop\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214100,"user_id":17,"body":"global product_array\nextern malloc\nsection .text\nproduct_array:\n  push rdi\n  push rsi\n  mov rdi, rsi\n  imul rdi, 4\n  call malloc\n  pop rsi\n  pop rdi\n  push rax\n  mov r12, 0\ncompute_product:\n  mov dword [rax], 1\n  push rdi\n  mov r13, 0\ninner_loop:\n  cmp r13, r12\n  je no_multiply\n  mov r14d, dword [rax]\n  imul r14d, dword [rdi]\n  mov dword [rax], r14d\nno_multiply:\n  add rdi, 4\n  inc r13\n  cmp r13, rsi\n  jl inner_loop\n  pop rdi\n  add rax, 4\n  inc r12\n  cmp r12, rsi\n  jl compute_product\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a97387e5ee396e70a00016d":[{"id":214101,"user_id":null,"body":"section .data\nv: db '1',0,0,'i',0,0,'-1',0,'-i',0\nsection .text\nglobal pofi\npofi:\n  and edi, 3\n  lea eax, [v+edi*3]\n  mov ebx, [eax]\n  mov [rsi], ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214102,"user_id":168,"body":"section .text\nresult db '1', 0, 0, 0, 'i', 0, 0, 0, '-1', 0, 0, '-i', 0\nextern strcpy\nglobal pofi\n; void pofi(long n, char *output)\npofi:\n  xchg rdi, rsi\n  and esi, 3\n  lea rsi, [rel result + esi * 4]\n  jmp strcpy","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214103,"user_id":null,"body":"section .text\nglobal pofi\n; void pofi(long n, char *output)\n; Write output to `output`. Don't forget to add a null byte at the end.\npofi:\n  xor rcx, rcx\n  xor rdx, rdx\n  mov rax, rdi\n  mov rbx, 4\n  idiv rbx\n  cmp rdx, 2\n  jl .nominus\n  mov byte [rsi], '-'\n  inc rcx\n.nominus:\n  and rdx, 1\n  jz .one\n  mov byte [rsi+rcx], 'i'\n  jmp .end\n.one:\n  mov byte [rsi+rcx], '1'\n.end:\n  mov byte [rsi+rcx+1], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214104,"user_id":null,"body":"section .text\nglobal pofi\n; void pofi(long n, char *output)\n; Write output to `output`. Don't forget to add a null byte at the end.\npofi:\n  test dil, 2\n  je .pos\n  mov byte [rsi], 45\n  inc rsi\n.pos:\n  test dil, 1\n  mov eax, 49\n  mov ecx, 105\n  cmove ecx, eax\n  mov [rsi], cl\n  mov byte [rsi + 1], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214105,"user_id":null,"body":"section .text\nglobal pofi\n; void pofi(long n, char *output)\n; Write output to `output`. Don't forget to add a null byte at the end.\npofi:\n  lea rdx, [data]\n  and edi, 3\n  mov eax, [rdx+rdi*4]\n  mov [rsi], eax\n  ret\n  \nsection .rodata\ndata:\ndd \"1\"\ndd \"i\"\ndd \"-1\"\ndd \"-i\"\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214106,"user_id":null,"body":"section .text\nglobal pofi\n; void pofi(long n, char *output)\n; Write output to `output`. Don't forget to add a null byte at the end.\npofi:\n  mov byte [rsi], '-'\n  mov eax, '1'\n  mov r9d, 'i'\n  test dil, 1\n  cmovnz rax, r9\n  lea r10, [rsi+1]\n  test dil, 2\n  cmovnz rsi, r10\n  mov [rsi], ax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214107,"user_id":null,"body":"section .text\nglobal pofi\npofi:\n  xor rdx, rdx\n  mov al, \"i\"\n  shr edi, 1\n  jc me_be_smart\n  mov al, \"1\"\nme_be_smart:\n  shr edi, 1\n  setc dl\n  mov [rsi], byte \"-\"\n  mov [rsi+rdx], byte al\n  mov [rsi+rdx+1], byte 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214108,"user_id":null,"body":"section .text\nglobal pofi\npofi:\n  mov al, \"i\"\n  shr edi, 1\n  jc j1\n  mov al, \"1\"\nj1:\n  shr edi, 1\n  jc j2\n  mov [rsi], byte al\n  mov [rsi+1], byte 0\n  jmp j3\nj2:\n  mov [rsi], byte \"-\"\n  mov [rsi+1], byte al\n  mov [rsi+2], byte 0\nj3:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214109,"user_id":null,"body":"section .text\nglobal pofi\n; void pofi(long n, char *output)\n; Write output to `output`. Don't forget to add a null byte at the end.\npofi:\n  mov rax, rdi\n  xor edx, edx\n  mov rcx, 4\n  div rcx\n  cmp rdx, 0\n  je .zero\n  cmp rdx, 1\n  je .one\n  cmp rdx, 2\n  je .two\n  mov [rsi], dword 26925\n  ret\n  .zero:\n    mov [rsi], word 49        ;  values are written into memory using little endian\n    ret                       ;  therefore this becomes dec 49(ascii 1) dec 0 in memory\n  .one:\n    mov [rsi], word 105\n    ret\n  .two:\n    mov [rsi], dword 12589\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214110,"user_id":null,"body":"section .text\nglobal pofi\n; void pofi(long n, char *output)\n; Write output to `output`. Don't forget to add a null byte at the end.\n\npofi:\n  xor rdx, rdx\n  mov rax, rdi \n  mov rbx, 4\n  idiv rbx       ;n%4 in rdx\n  xor rax, rax\n  cmp rdx, 0\n  jnz l1\n  mov rax, '1'\n  mov [rsi], rax\n  ret\nl1:\n  cmp rdx, 1\n  jnz l2\n  mov rax, 'i'\n  mov [rsi], rax\n  ret\nl2:\n  cmp rdx, 2\n  jnz l3\n  mov rax, '-1'\n  mov [rsi], rax\n  ret\nl3:\n  mov rax, '-i'\n  mov [rsi], rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a99a03e4a6b34bb3c000124":[{"id":214111,"user_id":527,"body":"global num_primorial\n\nsection .text\n; unsigned __int128 num_primorial(unsigned n)\nnum_primorial:\n                shl     edi, 4\n                mov     rax, [results + rdi]\n                mov     rdx, [results + rdi + 8]\n                ret\n\nsection .rodata\nresults         dq 1, 0, 2, 0, 6, 0, 30, 0, 210, 0, 2310, 0, 30030, 0, 510510, 0, 9699690, 0, 223092870, 0, 6469693230, 0, 200560490130, 0, 7420738134810, 0, 304250263527210, 0, 13082761331670030, 0, 614889782588491410, 0, 14142414403480493114, 1, 4298966488419271006, 104, 3982538761641808742, 6358, 8575679998067463090, 426000, 130725430374676062, 30246033, 9542956417351352526, 2207960409, 16023794022374784914, 174428872351, 1809330550019431510, 14477596405205, 13456466362052991462, 1288506080063253, 14005151959471558694, 124985089766135611, 12567798304701505278, 12623494066379696787","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214112,"user_id":null,"body":"global num_primorial\n\nsection .text\n\n; <--- unsigned __int128 num_primorial(unsigned n) --->\nnum_primorial:\n  mov ecx, edi\n  shl rcx, 4\n  mov rax, [rcx + .p]\n  mov rdx, [rcx + .p+8]\n  ret\n\nsection .data\n.p: dq 0x1, 0x0, 0x2, 0x0, 0x6, 0x0, 0x1e, 0x0, 0xd2, 0x0, 0x906, 0x0,\n    dq 0x754e, 0x0, 0x7ca2e, 0x0, 0x94016a, 0x0, 0xd4c2086, 0x0,\n    dq 0x1819faf2e, 0x0, 0x2eb2563692, 0x0, 0x6bfc675e31a, 0x0,\n    dq 0x114b6c8e15f2a, 0x0, 0x2e7ab3bddafc0e, 0x0, 0x88886ffdb344692, 0x0,\n    dq 0xc443f2f861d29c3a, 0x1, 0x3ba8ff3e8b8a015e, 0x68,\n    dq 0x3744d1e73fe25366, 0x18d6, 0x7702ef85b83bd3b2, 0x68010,\n    dq 0x1d06e161897b65e, 0x1cd8491, 0x846f644d034300ce, 0x839acd59,\n    dq 0xde5ff3c401ad3f92, 0x289cc55e9f, 0x191c088c8b2b9c56, 0xd2ad3fdadd5,\n    dq 0xbabef8dc622959e6, 0x493e3b3316f15, 0xc25c4b8131ab1026, 0x1bc0946e5bb173b,\n    dq 0xae69c9f8987d5efe, 0xaf2fa8f8a2d02a93\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214113,"user_id":null,"body":"global num_primorial\n\nsection .text\n\n; <--- unsigned __int128 num_primorial(unsigned n) --->\nnum_primorial:\n  xor ecx, ecx\n  lea rsi, [primes]\n  mov rax, [rsi+rdi*8]\n  \n.loop:\n  test edi, edi\n  jz .end\n  dec edi\n  xor edx, edx\n  mul qword [rsi+rdi*8]\n  imul rcx, [rsi+rdi*8]\n  add rcx, rdx\n  jmp .loop\n  \n.end:\n  mov rdx, rcx\n  ret\n; ---------> endof num_primorial <---------\n\nsection .rodata\nprimes:\ndq 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97\ndq 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214114,"user_id":null,"body":"global num_primorial\n\nsection .rodata\n; Every 128-bit primorial can be calculated with just these primes\nprimes: db 1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101\nsection .text\n\n; <--- unsigned __int128 num_primorial(unsigned n) --->\nnum_primorial:\n    mov rax, 1          ; RAX <- the low 64bits of the result\n    xor rdx, rdx        ; RDX <- the high 64bits of the result\n    mov rcx, rdi\n    test rcx, rcx\n    jz .out\n.step:\n    movzx rdi, byte [primes + rcx]\n    mov rsi, rax       ; save low half\n    mov rax, rdx       ; multiply high half\n    mul rdi\n    mov r8, rax        ; (low) result of high half\n    mov rax, rsi\n    mul rdi            ; multiply low half\n    add rdx, r8        ; add result of high half\n    loop .step\n.out:    \n    ret\n; ---------> endof num_primorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214115,"user_id":null,"body":"global num_primorial\nnum_primorial:\n  shl rdi,4\n  mov rax,[tab+rdi]\n  mov rdx,[tab+rdi+8]\nret\ntab dq 1,0,2,0,6,0,30,0,210,0,2310,0,30030,0,510510,0,9699690,0,223092870,0,6469693230,0,200560490130,0,7420738134810,0,304250263527210,0,13082761331670030,0,614889782588491410,0,\\\n       0xC443F2F861D29C3A,0x1,\\\n       0x3BA8FF3E8B8A015E,0x68,\\\n       0x3744D1E73FE25366,0x18D6,\\\n       0x7702EF85B83BD3B2,0x68010,\\\n       0x01D06E161897B65E,0x1CD8491,\\\n       0x846F644D034300CE,0x839ACD59,\\\n       0xDE5FF3C401AD3F92,0x289CC55E9F,\\\n       0x191C088C8B2B9C56,0xD2AD3FDADD5,\\\n       0xBABEF8DC622959E6,0x493E3B3316F15,\\\n       0xC25C4B8131AB1026,0x1BC0946E5BB173B,\\\n       0xAE69C9F8987D5EFE,0xAF2FA8F8A2D02A93\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214116,"user_id":609,"body":"global num_primorial\nextern malloc\nextern free\n\nsection .text\n\n; <--- unsigned __int128 num_primorial(unsigned n) --->\nnum_primorial:\n    mov r9, 1\n    xor r10, r10 ; result : r10:r9\n    mov r8, 1 ; main loop counter i\n    \n    .loop:\n      inc r8\n      test rdi, rdi\n      je .end\n      \n      mov r11, 1 ; inner loop counter j\n      .loop_isprime:\n        inc r11\n        mov rax, r11\n        mul r11\n        cmp rax, r8\n        jg .end_isprime\n        \n        mov rax, r8\n        div r11\n        test rdx, rdx\n        je .loop\n        jmp .loop_isprime\n      .end_isprime:  \n      \n      mov rax, r10\n      mul r8\n      mov r10, rax\n      \n      mov rax, r9\n      mul r8\n      mov r9, rax\n      add r10, rdx\n      \n      dec rdi\n      \n      jmp .loop\n    .end:\n    \n    mov rdx, r10\n    mov rax, r9\n    \n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214117,"user_id":743,"body":"global num_primorial\n\nsection .rodata\n\nTab dq 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43\n    dq 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103\n\nsection .text\n\n; rdx:rax                                  rdi\n; unsigned __int128 num_primorial(unsigned n);\nnum_primorial:\n  mov rsi, Tab\n  lea rdi, [Tab + rdi * 8]\n  xor rcx, rcx\n  mov rax, 1\n  cmp rsi, rdi\n  je .end\n.loop_:\n  imul rcx, [rsi]\n  xor rdx, rdx\n  mul qword [rsi]\n  add rsi, 8\n  add rcx, rdx\n  cmp rsi, rdi\n  jne .loop_\n.end:\n  mov rdx, rcx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214118,"user_id":null,"body":"global num_primorial\nextern malloc, free\n\nsection .text\n\n; <--- unsigned __int128 num_primorial(unsigned n) --->\nnum_primorial:\n    xor rdx, rdx        ; resetting the high 64bits of <primorial>\n    movsx rax, edi      ; extending <n> to RAX as the low 64bits of <primorial>\n    cmp edi, 1          ; whether <n> is greater than one\n    ja .tab             ; jumping to the .tab section\n    inc rax             ; incrementing <primorial>\n    ret\n.tab:\n    push rax            ; saving <n> in the stack\n    imul rdi, rax, 8    ; getting the target bytes for the prime table\n    call malloc         ; allocating memory\n    mov rdi, rax        ; saving the allocated memory in RDI as <primetab>\n    pop rcx             ; restoring <n> from the stack\n    dec rcx             ; decrementing <n>\n    push rbx            ; saving RBX in the stack\n    push rbp            ; saving RBP in the stack\n    xor rbp, rbp        ; resetting RBP to use as the high 64bits of <primorial>\n    mov rbx, 2          ; setting RBX to two as the low 64bits of <primorial>\n    mov qword [rdi], 2  ; saving the two prime in <*primetab>\n    mov rsi, 1          ; setting RSI to one as <num>\n    mov r8, 1           ; setting R8 to one as <i>\n.loop:\n    add rsi, 2          ; adding two to <num> to skip even numbers\n    xor r9, r9          ; resetting R9 as <j>\n.lptab:\n    mov rax, rsi        ; copying <num> to RAX\n    xor rdx, rdx        ; resetting RDX before the division\n    div qword [rdi+r9*8]; dividing <num> by <*(primetab+j)>\n    test rdx, rdx       ; whether the reminder is left\n    je .loop            ; otherwise, jumping to the next .loop iteration\n    inc r9              ; incrementing <j>\n    cmp r9, r8          ; whether <j> is less than <i>\n    jl .lptab           ; jumping to the next .lptab iteration\n    mov [rdi+r8*8], rsi ; saving <num> in <*(primetab+i)>\n    inc r8              ; incrementing <i>\n    mov rax, rsi        ; copying <num> to RAX\n    imul rbp, rax       ; multiplying the high 64bits of <primorial> by <num>\n    mul rbx             ; multiplying the low 64bits of <primorial> by <num>\n    mov rbx, rax        ; updating the low 64bits of <primorial>\n    add rbp, rdx        ; updating the high 64bits of <primorial>\n    dec rcx             ; decrementing <n>\n    jne .loop           ; jumping to the next .loop iteration if <n> is not zero\n    sub rsp, 8          ; aligning the stack before calling\n    call free           ; deallocating <primetab>\n    add rsp, 8          ; restoring the stack boundary\n    mov rdx, rbp        ; saving the high 64bits of <primorial> in RDX\n    mov rax, rbx        ; saving the low 64bits of <primorial> in RAX\n    pop rbp             ; restoring the initial RBP\n    pop rbx             ; restoring the initial RBX\n    ret\n; ---------> endof num_primorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214119,"user_id":null,"body":"global num_primorial\nextern malloc, free\n\nsection .text\n\n; <--- unsigned __int128 num_primorial(unsigned n) --->\nnum_primorial:\n    xor rdx, rdx        ; resetting the high 64bits of <primorial>\n    movsx rax, edi      ; extending <n> to RAX as the low 64bits of <primorial>\n    cmp edi, 1          ; whether <n> is greater than one\n    ja .tab             ; jumping to the .tab section\n    inc rax             ; incrementing <primorial>\n    ret\n.tab:\n    push rax            ; saving <n> in the stack\n    imul rdi, rax, 8    ; getting the target bytes for the prime table\n    call malloc         ; allocating memory\n    mov rdi, rax        ; saving the allocated memory in RDI as <primetab>\n    pop rcx             ; restoring <n> from the stack\n    dec rcx             ; decrementing <n>\n    push rbx            ; saving RBX in the stack\n    push rbp            ; saving RBP in the stack\n    xor rbp, rbp        ; resetting RBP to use as the high 64bits of <primorial>\n    mov rbx, 2          ; setting RBX to two as the low 64bits of <primorial>\n    mov qword [rdi], 2  ; saving the two prime in <*primetab>\n    mov rsi, 1          ; setting RSI to one as <num>\n    mov r8, 1           ; setting R8 to one as <i>\n.loop:\n    add rsi, 2          ; adding two to <num> to skip even numbers\n    xor r9, r9          ; resetting R9 as <j>\n.lptab:\n    mov rax, rsi        ; copying <num> to RAX\n    xor rdx, rdx        ; resetting RDX before the division\n    div qword [rdi+r9*8]; dividing <num> by <*(primetab+j)>\n    test rdx, rdx       ; whether the reminder is left\n    je .loop            ; otherwise, jumping to the next .loop iteration\n    inc r9              ; incrementing <j>\n    cmp r9, r8          ; whether <j> is less than <i>\n    jl .lptab           ; jumping to the next .lptab iteration\n    mov [rdi+r8*8], rsi ; saving <num> in <*(primetab+i)>\n    inc r8              ; incrementing <i>\n    mov rax, rsi        ; copying <num> to RAX\n    imul rbp, rax       ; multiplying the high 64bits of <primorial> by <num>\n    mul rbx             ; multiplying the low 64bits of <primorial> by <num>\n    mov rbx, rax        ; updating the low 64bits of <primorial>\n    add rbp, rdx        ; updating the high 64bits of <primorial>\n    dec rcx             ; decrementing <n>\n    jne .loop           ; jumping to the next .loop iteration if <n> is not zero\n    sub rsp, 8          ; aligning the stack before calling\n    call free           ; deallocating <primetab>\n    add rsp, 8          ; restoring the stack boundary\n    mov rdx, rbp        ; saving the high 64bits of <primorial> in RDX\n    mov rax, rbx        ; saving the low 64bits of <primorial> in RAX\n    pop rbp             ; restoring the initial RBP\n    pop rbx             ; restoring the initial RBX\n    ret\n; ---------> endof num_primorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214120,"user_id":168,"body":"global num_primorial\n\nsection .text\n\n; The last number overflows\ndata dq 1, 2, 6, 30, 210, 2310, 30030, 510510, 9699690, 223092870, 6469693230, 200560490130, 7420738134810, 304250263527210, 13082761331670030, 614889782588491410, 32589158477190044730\n\n; <--- unsigned long long num_primorial(unsigned n) --->\nnum_primorial:\n  mov rax, [data + edi * 8]\n  ret\n; ---------> endof num_primorial <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a9c35e9ba1bb5c54a0001ac":[{"id":214121,"user_id":null,"body":"section .text\nglobal sum\nsum:\n  cmp rsi, 0\n  jz zero\n  \n  mov eax, edi\n  xor edi, esi\n  and esi, eax\n  shl esi, 1\n  \n  jmp sum\n zero:\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214122,"user_id":1196,"body":"section .text\nglobal sum\n; int sum(int edi, int esi)\nsum:\n  mov edx, edi\n  and edx, esi\n  xor edi, esi\n  mov esi, edx\n  shl esi, 1\n  jnz sum\n  mov eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214123,"user_id":null,"body":"section .text\nglobal sum\nsum:\n  mov rax, rdi\n  ADD rax, rsi ; bruh\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214124,"user_id":527,"body":"global sum\nsum db 67h, 8dh, 04h, 37h, 0c3h","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214125,"user_id":168,"body":"section .text\none dq 1.0\nglobal sum\nsum:            ; int sum(int x, int y)\n                ; input:  edi = x, esi = y\n                ; output: rax\n  cvtsi2sd xmm0, edi      ; xmm0 = ?, x\n  cvtsi2sd xmm1, esi      ; xmm1 = ?, y\n  movhpd xmm0, [one]      ; xmm0 = 1, x\n  movhpd xmm1, [one]      ; xmm1 = 1, y\n  shufpd xmm1, xmm1, 1    ; xmm1 = y, 1\n  dppd xmm0, xmm1, 0x31   ; xmm0 = 0, dot((1, x), (y, 1))\n  cvttsd2si rax, xmm0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214126,"user_id":null,"body":"section .text\nglobal sum\nsum:\n  pinsrd   xmm0,edi,0\n  pinsrd   xmm0,esi,1\n  movdq2q  mm0,xmm0\n  cvtpi2pd xmm0,mm0\n  dppd     xmm0,[.ones],110001b\n  cvtsd2si rax,xmm0\n  ret\nsection .data\n.ones dq 1.0,1.0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214127,"user_id":null,"body":"section .text\nglobal sum\nsum:            ; int sum(int x, int y)\n  mov eax, edi\n.loop:\n  mov ecx, eax\n  mov eax, esi\n  and esi, ecx\n  xor eax, ecx\n  shl esi, 1\n  jne .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214128,"user_id":null,"body":"section .text\nglobal sum\n\nsum:                    ; int sum(int x, int y)\n                        ; input:  rdi = x, rsi = y\n                        ; output: rax\n        cmp rsi, 0\n        je return       ; if (x == 0) goto return\n\nwhile_y:\n        mov rax, rdi    ; temp = x\n        xor rax, rsi    ; temp = temp ^ y\n        and rsi, rdi    ; y = x & y\n        mov rdi, rax    ; x = temp\n        shl rsi, 1      ; y <<= 1\n        jnz while_y     ; if (y != 0) goto while_y\n\nreturn:\n        mov rax, rdi    ; return x\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214129,"user_id":null,"body":"%macro calc_bit 0\n  mov ecx, edx\n  shl ecx, 16\n  shr edi, 1\n  setc cl\n  shr esi, 1\n  setc ch \n\n  xor edx, edx\n  shr eax, 1\n  cmp ecx, 0x010101\n  je %%flag3\n  cmp ecx, 0x000101\n  je %%flag2\n  cmp ecx, 0x010001\n  je %%flag2\n  cmp ecx, 0x010100\n  je %%flag2\n  cmp ecx, 0\n  je %%end\n\n  bts eax, 31\n  jmp %%end\n%%flag3:\n  bts eax, 31\n%%flag2:\n  mov dl, 1\n%%end:\n%endmacro\n\nsection .text\nglobal sum\nsum:            ; int sum(int x, int y)\n                ; input:  rdi = x, rsi = y\n                ; output: rax\n  xor eax, eax\n  xor ecx, ecx\n  xor edx, edx\n  \n  %rep 32\n  calc_bit\n  %endrep\n  \n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214130,"user_id":null,"body":"section .text\nglobal sum\n\nsum:\n  pop rax\n  LEAVE\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5aa736a455f906981800360d":[{"id":214131,"user_id":null,"body":"global feast\nfeast:\n  xor   rax,rax\n  mov   dl,[rdi]\n  xor   dl,[rsi]\n  mov   rcx,-1\n  repne scasb\n  xchg  rsi,rdi\n  repne scasb\n  mov   al,[rdi-2]\n  xor   al,[rsi-2]\n  or    al,dl\n  sete  al\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214132,"user_id":168,"body":"section .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n  xor eax, eax\n  movzx edx, byte [rdi]\n  cmp dl, byte [rsi]\n  jne .end\n  mov ecx, -1\n  repnz scasb\n  movzx edx, byte [rdi - 2]\n  mov rdi, rsi\n  repnz scasb\n  cmp dl, byte [rdi - 2]\n.end:\n  sete al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214133,"user_id":null,"body":"section .text\nglobal feast\n\n; Load first and last char of a ASCII zero string.\n; argument: rsi = start of the string.\n; return: al = first char, ah = last char (before \\0)\n; Function uses ONLY rsi, rax, rbx.\nfirstlast:\n    mov bl, [rsi]     ; store first char\n    mov al, bl\n.loop:\n    mov ah, al        ; char before current char\n    lodsb\n    test al, al       ; al == 0, end of string?\n    jnz .loop             \n    mov al, bl        ; al = first, ah = last char\n    ret\n   \n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    cld               ; process strings upwards\n    call firstlast\n    mov ecx, eax      ; cx = first, last char of dish\n    mov rsi, rdi\n    call firstlast    ; ax = first, last char of beast\n    cmp cx, ax\n    sete al           ; return true if last&first char equal\n    movzx eax, al\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214134,"user_id":null,"body":"section .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    xor rax, rax\n  lodsb             ;load first letter of string a\n    mov rbx, rax    \n   xchg rsi, rdi    \n  lodsb             ;load first letter of string b\n    cmp rax, rbx    \n    jne fail        \n    xor rax, rax    \n    xor rbx, rbx    \n    mov rcx, 2      ;counter for 2 loops\nemptying:           \n  lodsb             ;load next char\n    cmp ax, 0       ;if it is not end of the string\n cmovne rbx, rax    ;save it\n    jne emptying    \n    dec rcx         \n    cmp rcx, 0      \n     je done        ;both strings are processed\n    mov rdx, rbx    ;save last char of string b\n   xchg rsi, rdi    ;same for other string\n    jmp emptying    \ndone:               \n    cmp rbx, rdx    \n    jne fail        \n    mov rax, 1      \n    ret             \nfail:               \n    xor rax, rax    \n    ret             ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214135,"user_id":null,"body":"section .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    mov\tal, [rdi]\n    cmp\tal, [rsi]\n    jne\t.false\n    inc\trdi\n.findbeastend:\n    cmp\t[rdi], byte 0\n    lea\trdi, [rdi + 1]\n    jne\t.findbeastend\n    inc\trsi\n.finddishend:\n    cmp\t[rsi], byte 0\n    lea\trsi, [rsi + 1]\n    jne\t.finddishend\n    mov\tal, [rsi - 2]\n    cmp\tal, [rdi - 2]\n    sete\tal\n    ret\n.false:\n    xor\teax, eax\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214136,"user_id":46,"body":"section .text\n_get_len:\n  push rbx\n  push rcx\n  \n  mov rax, 0\n  _count_len:\n    inc rax\n    mov cl, byte [ rdi + rax ]\n    cmp cl, 0x0\n    jne _count_len\n  \n  dec rax\n  \n  pop rcx\n  pop rbx\n  ret\n  \n_set_false:\n  mov al, 0\n  ret\n\nglobal feast\nfeast:\n    mov cl, byte [ rdi ]\n    cmp cl, byte [ rsi ]\n    jne _set_false\n    mov al, 1\n    \n    call _get_len\n    mov cl, byte [ rdi + rax ]\n    push rdi\n    mov rdi, rsi\n    call _get_len\n    pop rdi\n    mov dl, byte [ rsi + rax ]\n    cmp cl, dl\n    jne _set_false\n    mov al, 1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214137,"user_id":104,"body":"; 2021 nomennescio\nsection .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    xor al, al\n    mov rcx, -1\n    mov dl, [rdi]\n    xor dl, [rsi]\n    jne false\n    repne scasb\n    mov dl, [rdi-2]\n    mov rdi, rsi\n    repne scasb\n    xor dl, [rdi-2]\n    setz al\nfalse:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214138,"user_id":3088,"body":"section .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    mov al, byte[rdi]\n    xor al, byte[rsi]\n    jnz not_equal\n\nfind_last_beast:\n    inc rdi\n    cmp byte[rdi], 0\n    jnz find_last_beast\n    dec rdi\n    \nfind_last_dish:\n    inc rsi\n    cmp byte[rsi], 0\n    jnz find_last_dish\n    dec rsi\n\n    mov al, byte[rdi]\n    xor al, byte[rsi]   \n    jnz not_equal\n    \n    mov eax, 1\n    ret\n    \nnot_equal:\n    xor eax, eax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214139,"user_id":null,"body":"section .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    mov al, byte [rdi]\n    mov bl, byte [rsi]\n    cmp al, bl\n    jne .returnFalse\n    mov rcx, 1\n    \n    .forRdi:\n        cmp byte [rdi + rcx], 0\n        je .endForRdi\n        inc  rcx\n        jmp .forRdi\n    \n    .endForRdi:\n        dec rcx\n        mov r8, rcx\n        mov rcx, 1\n    \n    .forRsi:\n        cmp byte [rsi + rcx], 0\n        je .endForRsi\n        inc  rcx\n        jmp .forRsi\n    \n    .endForRsi:\n        dec rcx\n        mov r9, rcx\n    \n    mov bl, byte[rdi + r8]\n    cmp bl, byte[rsi + r9]\n    je .returnTrue\n    \n    .returnFalse:\n        mov rax, 0\n        ret\n    .returnTrue:\n        mov rax, 1\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214140,"user_id":50,"body":"section .text\nglobal feast\n\n; bool feast(const char* beast [rdi], const char* dish [rsi]);\n; return: al\nfeast:\n    xor rax, rax\n    mov r11b,[rdi]\n    mov r12b,[rsi]\n    cmp r11b,r12b\n    jne _exit\n_inca:\n  cmp byte[rdi+1],0\n  je _incb\n  inc rdi\n  jmp _inca\n_incb:\n  cmp byte[rsi+1],0\n  je _finish\n  inc rsi\n  jmp _incb\n_finish:\n    mov al,[rdi]\n    cmp al,[rsi]\n    jne _exit\n    mov al,1\n    ret\n_exit:\n    mov al,0\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ab6538b379d20ad880000ab":[{"id":214141,"user_id":null,"body":"global area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter(int length, int width) ----->\narea_or_perimeter:\n    cmp   rdi, rsi\n    je    square\n    lea   rax, [rdi+rsi*2]\n    add   rax, rdi\n    jmp   done\nsquare:\n    mov   rax, rdi\n    mul   rax\ndone:\n    ret\n; ---------> end of area_or_perim <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214142,"user_id":104,"body":"; 2021 nomennescio\nglobal area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter (int length, int width) ----->\narea_or_perimeter:\n    mov eax, edi\n    cmp edi, esi\n    je square\n    \nrectangle:\n    add eax, esi\n    shl eax, 1\n    ret\n    \nsquare:\n    imul eax, esi\n    ret\n; ---------> end of area_or_perim <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214143,"user_id":168,"body":"global area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter(int length, int width) ----->\narea_or_perimeter:\n  lea eax, [edi + esi]\n  mov edx, 2\n  cmp edi, esi\n  cmove eax, edi\n  cmove edx, esi\n  imul eax, edx\n  ret\n; ---------> end of area_or_perim <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214144,"user_id":null,"body":"global area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter(int length, int width) ----->\narea_or_perimeter:\n    mov   eax, edi\n    add   eax,esi\n    shl   eax,1\n    ret\n; ---------> end of area_or_perim <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214145,"user_id":525,"body":"global area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter(int length, int width) ----->\narea_or_perimeter:\n    mov eax, edi    ; EAX <- the result\n    mul esi\n    lea edx, [edi + esi]\n    shl edx, 1\n    test edi, esi\n    cmovns eax, edx\n    ret\n; ---------> end of area_or_perim <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214146,"user_id":null,"body":"global area_or_perimeter\n\nsection .text\n\n; int area_or_perimeter(int length, int width)\narea_or_perimeter:\n  shl edi,1\n  shl esi,1\n  mov eax,edi\n  add eax,esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214147,"user_id":null,"body":"global area_or_perimeter\n\nsection .text\n\narea_or_perimeter:\n    xor eax, eax\n    shl edi, 1\n    add eax, edi\n    shr edi, 1\n    shl esi, 1\n    add eax, esi\n    shr esi, 1\n    cmp esi, edi\n    je square\n    ret\n    \nsquare:\n  mov eax, esi\n  mul edi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214148,"user_id":null,"body":"global area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter(int length, int width) ----->\narea_or_perimeter:\n    mov eax, esi    ; EAX <- the result\n    cmp esi, edi\n    je square\n    add eax, edi\n    shl eax, 1\n    ret\n    square:\n    mul eax\n    ret\n; ---------> end of area_or_perim <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214149,"user_id":null,"body":"global area_or_perimeter\n\nsection .text\n\n; <----- int area_or_perimeter(int length, int width) ----->\narea_or_perimeter:\n    xor rax, rax; EAX <- the result\n    mov rax, rdi\n    cmp rax, rsi\n    jne perimeter\n    imul rax, rsi\n    ret\nperimeter:\n    imul rax, 2\n    imul rsi, 2\n    add rax, rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214150,"user_id":null,"body":"global area_or_perimeter\nsection .text\narea_or_perimeter:\n  cmp rdi,rsi\n  jne hardmode\n  mov rax,rdi\n  mul rsi\n  jmp end\n  hardmode:\n  add rdi,rsi\n  shl rdi,1\n  mov rax,rdi\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5aba780a6a176b029800041c":[{"id":214151,"user_id":168,"body":"global max_multiple\nsection .text\nmax_multiple:\n  mov rdx, 0\n  mov rax, rsi\n  div rdi\n  mul rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214152,"user_id":527,"body":"global max_multiple\nsection .text\nmax_multiple:\n                mov     eax, esi\n                xor     edx, edx\n                div     edi\n                sub     esi, edx\n                mov     eax, esi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214153,"user_id":527,"body":"global max_multiple\nsection .text\nmax_multiple:\n                mov     eax, esi\n                xor     edx, edx\n                div     edi\n                mul     edi\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214154,"user_id":null,"body":"global max_multiple\nsection .text\nmax_multiple:\n      mov eax, 1\n      mov ebx, 1\n      \n    while:\n      mov edx, 0\n      mov eax, ebx\n      div edi\n      cmp edx, 0\n      je eql\n      jmp incloop\n    eql:\n      mov ecx, ebx\n    incloop:\n      cmp ebx, esi\n      je fin\n      inc ebx\n      jmp while\n    fin:\n      mov eax, ecx\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214155,"user_id":null,"body":"global max_multiple\nsection .text\nmax_multiple:\n  mov eax, esi\n  cdq\n  idiv edi\n  imul eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214156,"user_id":null,"body":"global max_multiple\nsection .text\nmax_multiple:\n  mov rax, rsi\n  xor rdx, rdx        ; rdx:rax = bound\n  div rdi             ; rdx = bound % divisor, rax = bound \/ divisor\n  sub rsi, rdx        ; rsi = bound - bound % divisor\n  mov rax, rsi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214157,"user_id":null,"body":"global max_multiple\nsection .text\nmax_multiple:\n  xor edx, edx\n  mov eax, esi\n  div edi\n  mul edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214158,"user_id":null,"body":"global max_multiple\nsection .text\nmax_multiple:\n    mov   rax, rsi\n    xor   edx, edx\n    div   rdi\n    mov   rax, rsi\n    sub   rax, rdx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214159,"user_id":50,"body":"global max_multiple\nsection .text\nmax_multiple:\n  xor rax,rax\n_loop:\n  mov rax,rsi\n  cmp rsi,0\n  je _exit\n  xor rdx,rdx\n  div rdi\n  cmp rdx,0\n  je _exit\n  dec rsi\n  jmp _loop\n_exit:\n  mov rax,rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214160,"user_id":null,"body":"global max_multiple\nsection .text\nmax_multiple:\n    xor   rdx, rdx    ; Clear upper part for division \/ multiplication.\n    \n    mov   rax, rsi    ; I don't have to explain shit.\n    div   rdi\n    mul   rdi\n    \n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5abd66a5ccfd1130b30000a9":[{"id":214161,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\n    dec rdx               ; decrementing <n>\n    mov eax, [rsi+rdx*4]  ; copying <*(weights+n)> to EAX\n    mov rcx, rdx          ; copying <i> to RCX\n    and rcx, 1            ; getting the team <inx>\n    add [rdi+rcx*4], eax  ; movinng <*(weights+n> to *(teams+inx)\n.exit:\n    cmp rdx, 0            ; whether <n> is greater then zero\n    ja row_weights        ; jumping to the next iteration\n    mov rax, rdi          ; copying <teams> to RAX\n    ret\n; -----> endof row_weights <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214162,"user_id":null,"body":"global row_weights\nrow_weights:\n    pxor mm0,mm0\n    .b:paddd mm0,[rsi] \n       add   rsi,8\n       sub   rdx,2\n    jnle .b\n    jnl .f\n      movd  mm1,[rsi-4]\n      psllq mm1,32\n      psubd mm0,mm1\n    .f\n    movq [rdi],mm0\n    mov  rax,rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214163,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\npush rdi\n.loop:\ndec rdx\nmov rax, rdx\nmov ecx, [rsi+rdx*4]\nand eax, 1\nadd [rdi+rax*4], ecx\ntest rdx, rdx\njnz .loop\n.exit:\npop rax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214164,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\n  mov r8, rdx\n  xor ecx, ecx\n  xor edx, edx\n  test r8, r8\n  jbe .done\n.loop:\n  mov r9d, [rsi+rcx*4]\n  inc rcx\n  add [rdi+rdx*4], r9d\n  neg rdx\n  inc rdx\n  cmp rcx, r8\n  jb .loop\n.done:\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214165,"user_id":460,"body":"global row_weights\nsection .data\n  size dd 4\nsection .text\nrow_weights:\n  mov r8, rdx\n  dec r8\n  mov rax, r8\n  mul dword [size]\n  add rsi, rax\n\n.loop:\n  mov eax, dword [rsi]\n  xor rcx, rcx\n  bt r8, 0\n  setc cl\n  add dword [rdi+4*rcx], eax\n  dec r8\n  sub rsi, 4\n  cmp r8, 0\n  jge .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214166,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\n    xor rcx, rcx\nloop:\n    cmp rcx, rdx\n    jz return\n    mov eax, dword [rsi + rcx * 4]\n    mov r9, 1\n    and r9, rcx\n    add dword [rdi + r9 * 4], eax\n    inc rcx\n    jmp loop\n    \nreturn:\n    mov rax, rdi\n    ret\n; -----> endof row_weights <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214167,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\n    dec rdx\n    mov ecx, [rsi + rdx*4]\n    \n    mov rax, rdx\n    and rax, 1    \n    add dword [rdi + rax*4], ecx\n    \n    test rdx, rdx\n    jnz row_weights\n    \n    mov rax, rdi\n    ret\n; -----> endof row_weights <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214168,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\n  xor r8d, r8d\n  xor r9d, r9d\n  xor rcx, rcx\n  mov rax, rdi\n  \n  .loop:\n    cmp rcx, rdx\n    je done\n    test cl, 1\n    je .add_odd_index\n    add r8d, dword [rsi+rcx*4]\n    jmp .inc_index\n    .add_odd_index:\n      add r9d, dword [rsi+rcx*4]\n    .inc_index:\n      inc rcx\n    jmp .loop\n    \n  done:\n    mov dword [rax], r9d\n    mov dword [rax+4], r8d\n    ret\n; -----> endof row_weights <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214169,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX count) -->\nrow_weights:\n  mov dword [rdi + 0], 0 ; teams[0] = 0\n  mov dword [rdi + 4], 0 ; teams[1] = 0\n  \n  ; for (int rcx = 0; rcx + 1 < rdx, rcx += 2) {\n  mov rcx, 0\n.loop:\n  mov rax, rcx\n  inc rax\n  cmp rax, rdx\n  jge .loop_end\n  \n  ; teams[0] += weights[i]\n  mov eax, dword [rsi + rcx * 4]\n  add dword [rdi + 0], eax\n  \n  ; teams[1] += weights[i + 1]\n  mov eax, dword [rsi + rcx * 4 + 4]\n  add dword [rdi + 4], eax\n  \n  add rcx, 2\n  jmp .loop\n.loop_end:\n  ; }\n\n  ; if ((rdx & 1) == 1)\n  test rdx, 1\n  jz .if_end\n.if:\n  ; teams[0] += weights[rcx]\n  mov eax, dword [rsi + rcx * 4]\n  add dword [rdi + 0], eax\n.if_end:\n\n  ; return teams\n  mov rax, rdi\n  ret\n; -----> endof row_weights <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214170,"user_id":null,"body":"global row_weights\n\n; <-- [RAX] row_weights([RDI] teams, ro [RSI] weights, RDX n) -->\nrow_weights:\n\tmov rcx, 0\n\tpush rbx\nasd:\tmov eax, DWORD [rsi + rcx*4]\n\tmov rbx, rcx\n\tand rbx, 1\n\tjz even\n\tadd DWORD [rdi + 4], eax\n\tjmp ready\neven:\tadd DWORD [rdi], eax\nready:\tinc rcx\n\tcmp rcx, rdx\n\tjne asd\n\n\tpop rbx\n\tmov rax, rdi\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5aceae374d9fd1266f0000f0":[{"id":214171,"user_id":null,"body":"section .text\nglobal time_math\nextern strdup\ntime_math: \n  call  .time2num\n  mov   rax,r8\n  mov   rdi,rdx\n  call  .time2num\n  cmp   byte[rsi],'-'\n  jne .neg\n    neg r8\n  .neg:\n  add   rax,r8\n  jnl .carry_negative\n    add eax,24*3600\n  .carry_negative: \n  cmp     eax,24*3600\n  jb .carry_positive\n    sub eax,24*3600\n  .carry_positive:\n  mov   ecx,6 \n  sub   rsp,16\n  mov   rdi,rsp\n  .b:cdq\n     div   dword[divis+rcx*4-4]\n     add   al,'0'\n     stosb\n     mov   byte[rdi],':'\n     bt    rcx,0\n     adc   rdi,0\n     mov   eax,edx\n  loop .b\n  mov   byte[rdi-1],0\n  mov   rdi,rsp\n  call  strdup\n  add   rsp,16\nret\n\n.time2num:\n  movdqu  xmm0,[rdi]\n  pshufb  xmm0,[shuffle]\n  psubusw xmm0,[subt]\n  pmaddwd xmm0,[mult]\n  phaddd  xmm0,xmm0\n  phaddd  xmm0,xmm0\n  movd    r8d,xmm0\n  movzx   r9,byte[rdi]\n  sub     r9d,'0'\n  imul    r9d,r9d,36000\n  add     r8,r9\nret  \n\nalign 16\nshuffle db 1,8,3,8,4,8,6,8,7,8,8,8,8,8,8,8\nsubt    dw '0','0','0','0','0',0,0,0\nmult    dw 3600,600,60,10,1,0,0,0\ndivis   dd 1,10,60,600,3600,36000\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214172,"user_id":null,"body":"extern sscanf,asprintf\nsection .text\nglobal time_math\n; char *time_math(const char *time1, const char *op, const char *time2);\n; input:  rdi = time1, rsi = op, rdx = time2\n; output: rax\ntime_math:\n  push r12\n  xor eax, eax\n  mov r12, rdx\n  push rbp\n  mov rbp, rsi\n  mov esi, .LC0\n  push rbx\n  sub rsp, 32\n  lea r8, [rsp+20]\n  lea rcx, [rsp+16]\n  lea rdx, [rsp+12]\n  call sscanf\n  imul ebx, [rsp+12], 60\n  xor eax, eax\n  add ebx, [rsp+16]\n  lea rcx, [rsp+16]\n  lea r8, [rsp+20]\n  mov esi, .LC0\n  mov rdi, r12\n  imul ebx, ebx, 60\n  lea rdx, [rsp+12]\n  add ebx, [rsp+20]\n  call sscanf\n  imul eax, [rsp+12], 60\n  add eax, [rsp+16]\n  mov ecx, ebx\n  imul eax, eax, 60\n  add eax, [rsp+20]\n  sub ecx, eax\n  cmp byte [rbp], 43\n  jne .sub\n  lea ecx, [rbx+rax]\n.sub:\n  test ecx, ecx\n  jns .pos\n  add ecx, 86400\n  jmp .lt24h\n.pos:\n  cmp ecx, 86399\n  jle .lt24h\n  sub ecx, 86400\n.lt24h:\n  mov eax, ecx\n  mov edi, 60\n  mov esi, 3600\n  cdq\n  idiv edi\n  mov r9d, eax\n  mov eax, ecx\n  mov [rsp+20], edx\n  mov r8d, edx\n  cdq\n  idiv esi\n  mov [rsp+12], eax\n  mov esi, eax\n  mov eax, r9d\n  cdq\n  idiv edi\n  lea rdi, [rsp+24]\n  xor eax, eax\n  mov [rsp+16], edx\n  mov ecx, edx\n  mov edx, esi\n  mov esi, .LC0\n  call asprintf\n  mov rax, [rsp+24]\n  add rsp, 32\n  pop rbx\n  pop rbp\n  pop r12\n  ret\n.LC0: db \"%02d:%02d:%02d\",0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214173,"user_id":null,"body":"section .text\nglobal time_math\nextern strdup\n\n%macro add_digit 1\n  add dl, [rsi]\n  dec rsi\n  sub dl, '0'\n  add [rdi], dl\n  xor edx, edx\n  cmp byte [rdi], %1+'0'\n  jl %%skip\n  \n  sub byte [rdi], %1\n  inc dl\n%%skip:\n  dec rdi\n%endmacro\n\n%macro sub_digit 1\n  add dl, [rsi]\n  dec rsi\n  sub dl, '0'\n  sub [rdi], dl\n  xor edx, edx\n  cmp byte [rdi], '0'\n  jge %%skip\n  \n  add byte [rdi], %1\n  inc dl\n%%skip:\n  dec rdi\n%endmacro\n\n; char *time_math(const char *time1, const char *op, const char *time2);\n; input:  rdi = time1, rsi = op, rdx = time2\n; output: rax\ntime_math:\n  push rdi\n  push rsi\n  push rdx\n  call strdup\n  pop rsi\n  pop rcx\n  pop rdi\n  test rax, rax\n  jz .done\n  \n  lea rdi, [rax+7]\n  add rsi, 7\n  xor edx, edx\n  cmp byte [rcx], '-'\n  je .subtract\n    \n  add_digit 10\n  add_digit 6\n  dec rdi\n  dec rsi\n  add_digit 10\n  add_digit 6\n  dec rdi\n  dec rsi\n  add_digit 10\n  add dl, [rsi]\n  sub dl, '0'\n  add [rdi], dl\n  jmp .check\n  \n.subtract:\n  add word [rdi-7], 0x0402\n  cmp byte [rdi-6], '9'\n  jle .skip1\n  sub byte [rdi-6], 10\n  inc byte [rdi-7]\n\n.skip1:\n  sub_digit 10\n  sub_digit 6\n  dec rdi\n  dec rsi\n  sub_digit 10\n  sub_digit 6\n  dec rdi\n  dec rsi\n  sub_digit 10\n  add dl, [rsi]\n  sub dl, '0'\n  sub [rdi], dl\n\n.check:\n  movzx ecx, byte [rdi]\n  movzx edx, byte [rdi+1]\n  lea ecx, [rcx*5-'0'*5]\n  lea ecx, [rcx*2+rdx-'0']\n  cmp ecx, 24\n  jl .done\n  sub ecx, 24\n  lea rdx, [data]\n  mov cx, [rdx+rcx*2]\n  mov [rdi], cx\n  \n.done:\n  ret\n  \nsection .rodata\ndata:\n  db \"000102030405060708091011121314151617181920212223\"\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214174,"user_id":1315,"body":"extern malloc\nextern sscanf\nextern sprintf\nsection .text\nglobal time_math\n; char *time_math(const char *time1, const char *op, const char *time2);\n; input:  rdi = time1, rsi = op, rdx = time2\n; output: rax\ntime_math:\n;char *time_math(const char *time1, const char *op, const char *time2)\n;{\n;    int h1, h2, m1, m2, s1, s2, t3;\n;    sscanf(time1, \"%d:%d:%d\", &h1, &m1, &s1);\n;    sscanf(time2, \"%d:%d:%d\", &h2, &m2, &s2);\n;    t3 = (3600 * h1 + 60 * m1 + s1) +\n;         ('+' == op[0] ? 1 : -1) *\n;         (3600 * h2 + 60 * m2 + s2);\n;    if ( t3 < 0 ) t3 += 86400;\n;    char *time3 = (char *)malloc(9);\n;    sprintf(time3, \"%02d:%02d:%02d\", t3 \/ 3600 % 24, t3 % 3600 \/ 60 % 60, t3 % 60);\n;    return time3;\n;}\n  push rsi ; save last 2 parameters\n  push rdx\n  \n  ; extract time1\n  call parse_time\n  mov  r12, rax\n  \n  ; extract time2\n  pop  rdi\n  call parse_time\n  \n  ; construct t3\n  pop  rdx\n  xor  rbx, rbx\n  mov  bl,  [rdx]\n  cmp  bl,  '+'\n  je   positive\n  sub  r12, rax\n  mov  rax, r12\n  jmp  negative\npositive:\n  add  rax, r12\nnegative:\n  \n  ; adjust for negative value\n  cmp  rax, 0\n  jge  no_adjustment\n  add  rax, 86400\nno_adjustment:\n  mov  rbx, 86400\n  xor  rdx, rdx\n  div  rbx\n  mov  rax, rdx\n  \n  ; calculate hours\/minutes\/seconds\n  mov  r12, rax\n  mov  rbx, 60\n  mov  rcx, 3600\n  mov  rdi, 24\n  xor  rdx, rdx\n  div  rcx\n  xor  rdx, rdx\n  div  rdi\n  push rdx\n  mov  rax, r12\n  xor  rdx, rdx\n  div  rcx\n  mov  rax, rdx\n  xor  rdx, rdx\n  div  rbx\n  xor  rdx, rdx\n  div  rbx\n  push rdx\n  mov  rax, r12\n  xor  rdx, rdx\n  div  rbx\n  push rdx\n  \n  ; allocate memory\n  mov  rdi, 100\n  call malloc\n  mov  r12, rax\n  \n  ; write time3\n  mov  rdi, rax\n  mov  rsi, format\n  pop  r8\n  pop  rcx\n  pop  rdx\n  xor  rax, rax\n  call sprintf\n  \n  mov  rax, r12 ; return time3\n  ret\n  \n; int parse_time(const char *time_str)\n; input:  rdi = time_str\n; output: rax\nparse_time:\n  mov  rsi, format\n  sub  rsp, 4\n  mov  rdx, rsp\n  sub  rsp, 4\n  mov  rcx, rsp\n  sub  rsp, 4\n  mov  r8,  rsp\n  xor  rax, rax\n  call sscanf\n  imul eax, [rsp+8], 3600\n  imul ebx, [rsp+4], 60\n  add  eax, [rsp]\n  add  rax, rbx\n  add  rsp, 12\n  ret\n\nsection .data\nformat: db '%02d:%02d:%02d',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ad0d8356165e63c140014d4":[{"id":214175,"user_id":null,"body":"global final_grade\n\nsection .text\n\nfinal_grade:\n    xor       eax, eax\n\n    cmp       edi, 90\n    jg        One_Hundred\n\n    cmp       esi, 10\n    jg        One_Hundred\n\n    cmp       edi, 75\n    jg        Ninety\n\n_Failed_Ninety_Label:\n\n    cmp       edi, 50\n    jg        Seventy_Five\n\n_Failed_Seventy_Five_Label:\n    \n    mov       eax, 0\n    ret\n\nOne_Hundred:\n    mov       eax, 100\n    ret\n\nNinety:\n    cmp       esi, 5\n    jge       Ninety_Complete\n    jmp       _Failed_Ninety_Label\n\nNinety_Complete:\n    mov       eax, 90\n    ret\n\nSeventy_Five:\n    cmp       esi, 2\n    jge       Seventy_Five_Complete\n    jmp       _Failed_Seventy_Five_Label\n\nSeventy_Five_Complete:\n    mov       eax, 75\n    ret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214176,"user_id":527,"body":"global final_grade\n\nsection .text\n\n; unsigned final_grade(unsigned exam, unsigned nproj)\n; nproj < 127\nfinal_grade:\n                mov     eax, 01010101h\n                imul    edi, eax\n                imul    esi, eax\n                sub     edi, 07f5b4c33h\n                sub     esi, 07f0b0502h\n                and     edi, 080808080h\n                and     esi, 080808080h\n                bsf     edi, edi\n                bsf     esi, esi\n                shr     edi, 3\n                shr     esi, 3\n                movzx   eax, byte [grades + rdi*4 + rsi]\n                ret\n\nsection .rodata\ngrades          db 0,0,0,100, 0,75,75,100, 0,75,90,100, 100,100,100,100\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214177,"user_id":null,"body":"global final_grade\n\nfinal_grade:\n        mov     eax, 100\n        cmp     edi, 90\n        jg      .exit\n        cmp     esi, 10\n        jg      .exit ; return 100\n        \n        cmp     edi, 75\n        jle     .under75\n        mov     eax, 90\n        cmp     esi, 4\n        jle     .under75\n        ret ; return 90\n.under75:\n        xor     ecx, ecx\n        cmp     esi, 2\n        mov     eax, 75\n        cmovl   eax, ecx\n        cmp     edi, 50\n        cmovle   eax, ecx\n.exit:\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214178,"user_id":null,"body":"global final_grade\n\nsection .text\n\n; <--- unsigned final_grade(unsigned exam, unsigned nproj) --->\nfinal_grade:\n    xor rax, rax\n    mov al, 100       ; result 100\n    cmp rdi, 90\n    jg .exit          ; ... if grade > 90\n    cmp rsi, 10\n    jg .exit          ; ... or projects > 10\n    mov al, 90        ; result 90\n    cmp rdi, 75\n    jle .no75         ; ... if grade > 75\n    cmp rsi, 5\n    jge .exit         ; ... and projects >= 5\n.no75:\n    mov al, 75        ; result 75\n    cmp rdi, 50\n    jle .no50         ; ... if grade > 50\n    cmp rsi, 2\n    jge .exit         ; ... and  projects >= 2\n.no50:\n     xor al, al       ; else result is 0\n.exit:    \n    ret\n; ---------> endof final_grade <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214179,"user_id":null,"body":"global final_grade\n\nsection .text\n\n; <--- unsigned final_grade(unsigned exam, unsigned nproj) --->\nfinal_grade:\n    xor eax, eax        ; EAX <- the result\n    cmp edi, 90\n    jg Agrade\n    cmp esi, 10\n    jg Agrade\n    cmp edi, 75\n    jle CgradeCheck\n    cmp esi, 5\n    jge Bgrade    \nCgradeCheck:\n    cmp edi, 50\n    jle Fgrade\n    cmp esi, 2\n    jge Cgrade\nFgrade:\n    ret\nCgrade:\n    mov eax, 75\n    ret\nBgrade:\n    mov eax, 90\n    ret\nAgrade:\n    mov eax, 100\n    ret\n    \n    \n    \n; ---------> endof final_grade <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214180,"user_id":null,"body":"global final_grade\n\nsection .text\n\n; <--- unsigned final_grade(unsigned exam, unsigned nproj) --->\nfinal_grade:\n\tmov\teax, 100\n\tcmp\tedi, 90\n\tja\t.done\n\tcmp\tesi, 10\n\tja\t.done\n\tcmp\tedi, 76\n\tjb\t.not90\n\tmov\teax, 90\n\tcmp\tesi, 4\n\tjbe\t.not90\n.done:\n\tret\n.not90:\n\txor\tecx, ecx\n\tcmp\tesi, 1\n\tmov\teax, 75\n\tcmovbe\teax, ecx\n\tcmp\tedi, 50\n\tcmovbe\teax, ecx\n\tret\n; ---------> endof final_grade <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214181,"user_id":null,"body":"global final_grade\n\nsection .text\n\n; <--- unsigned final_grade(unsigned exam, unsigned nproj) --->\nfinal_grade:\n    xor eax, eax        ; EAX <- the result\n    cmp edi, 90\n    ja return_100\n    cmp esi, 10\n    ja return_100\n    xor ecx, ecx\n    xor edx, edx\n    mov ebx, 1\n    cmp edi, 75\n    cmovg ecx, ebx\n    cmp esi, 5\n    cmovge edx, ebx\n    and ecx, edx\n    jnz return_90\n    cmp edi, 50\n    cmovg ecx, ebx\n    cmp esi, 2\n    cmovge edx, ebx\n    and ecx, edx\n    jnz return_75\n    ret\n    \nreturn_100:\n    mov eax, 100\n    ret\n    \nreturn_90:\n    mov eax, 90\n    ret\n\nreturn_75:\n    mov eax, 75\n    ret\n; ---------> endof final_grade <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214182,"user_id":null,"body":"global final_grade\n\nsection .text\n\n; <--- unsigned final_grade(unsigned exam, unsigned nproj) --->\nfinal_grade:\n    xor eax, eax        ; EAX <- the result\n    cmp edi, 90\n    ja return_100\n    cmp esi, 10\n    ja return_100\n    cmp edi, 75\n    ja check_75\ncontinue:\n    cmp edi, 50\n    ja check_50\n    ret\n    \ncheck_75:\n    cmp esi, 5\n    jae return_90\n    jmp continue\n    \ncheck_50:\n    cmp esi, 2\n    jae return_75\n    ret\n    \nreturn_100:\n    mov eax, 100\n    ret\n    \nreturn_90:\n    mov eax, 90\n    ret\n\nreturn_75:\n    mov eax, 75\n    ret\n; ---------> endof final_grade <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214183,"user_id":null,"body":"global final_grade\n\nsection .text\n\n; <--- unsigned final_grade(unsigned exam, unsigned nproj) --->\nfinal_grade:\n    cmp edi, 90\n    jg .100\n    cmp esi, 10\n    jg .100\n    cmp esi, 2\n    jl .0\n    cmp edi, 50\n    jle .0\n    cmp esi, 5\n    jl .75\n    cmp edi, 75\n    jle .75\n    mov eax, 90\n    ret\n.0:\n    xor eax, eax\n    ret\n.75:\n    mov eax, 75\n    ret\n.100:\n    mov eax, 100\n    ret\n  \n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214184,"user_id":null,"body":"global final_grade\nfinal_grade:\n  mov ecx,3\n  .b:cmp   esi,[.proj+rcx*4]\n     setae al\n     cmp   [.exam+rcx*4],edi\n     adc   al,0\n     cmp   al,[.cmp+rcx*4]\n     jae .f\n  loop .b\n  .f:mov eax,[.res+rcx*4]     \nret\n.exam dd 0,50,75,90\n.proj dd 0,2,5,11\n.res  dd 0,75,90,100\n.cmp  dd 0,2,2,1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ad4ac83c4623d039800013d":[{"id":214185,"user_id":null,"body":"global has_digits\n\nsection .text\n\n; <--- bool has_digits(const char *s) --->\nhas_digits:\n    xor eax, eax        ; resetting the result\n    test rdi, rdi       ; whether <s> is NULL\n    je .exit            ; jumping to exit\n.loop:\n    mov sil, [rdi]      ; copying <*s> to SIL as <c>\n    test sil, sil       ; whether <c> is the null character\n    je .exit            ; jumping to exit\n    inc rdi             ; pointing <s> to the next character\n    cmp sil, '0'        ; whether <c> is bellow '0'\n    jb .loop            ; jumping to the next iteration\n    cmp sil, '9'        ; whether <c> is above '9'\n    ja .loop            ; jumping to the next iteration\n    setbe al            ; setting the result to true\n.exit:\n    ret\n; -----> endof has_digits <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214186,"user_id":null,"body":"global has_digits\nsection .text\nhas_digits:\n  mov eax, 0\n  mov ecx, -1\n  test edi, edi\n  jz .end\n.loop:\n  inc ecx\n  mov edx, edi\n  mov al, [edx + ecx]\n  test al, al\n  jz .end\n  cmp al, 0x39\n  jg .loop\n  cmp al, 0x30\n  jge .true\n  jmp .loop\n  \n  \n.true:\n  mov eax, 1\n  ret\n.end:\n  xor eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214187,"user_id":null,"body":"section         .text\nglobal          has_digits\n\nhas_digits:\n    xor     rax, rax\n    xor     rdx, rdx\n    xor     rsi, rsi\n\n    cmp     rdi, 0\n    jz      _False\n\n    dec     rdx\n    \n_string_loop:\n    inc     rdx\n    mov     sil, [rdi + rdx]\n\n    cmp     sil, 0\n    jz      _False\n    \n    cmp     sil, 0x30\n    jge     _Potential_Digit\n    \n    jmp     _string_loop\n\n_False:\n    mov     rax, 0\n    ret\n\n_Potential_Digit:\n    cmp     sil, 0x39\n    jg      _string_loop\n    mov     rax, 1\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214188,"user_id":null,"body":"global has_digits\nsection .text\nhas_digits:\n    mov eax, 0\n    cmp rdi, 0\n    je bye\nhello:  \n    cmp byte [rdi], 0\n    je bye\n    cmp byte [rdi], '0'\n    jl next\n    cmp byte [rdi], '9'\n    jg next\n    mov eax, 1\nbye:\n    ret\nnext:\n    inc rdi\n    jmp hello","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214189,"user_id":1343,"body":"global has_digits\nsection .text\nhas_digits:\n  cmp edi, 0\n  jne inspectChar\ndone:\n  mov eax, 0\n  ret\ninspectChar:\n  cmp byte [edi], 0\n  je done\n  cmp byte [edi], 48\n  jl next\n  cmp byte [edi], 58\n  jge next\n  mov eax, 1\n  ret\nnext:\n  inc edi\n  jmp inspectChar","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214190,"user_id":168,"body":"global has_digits\nsection .text\nhas_digits:\n  xor eax, eax\n  test edi, edi\n  je end\nloop:\n  mov al, [edi]\n  test al, al\n  je end\n  inc edi\n  cmp al, '0'\n  jl loop\n  cmp al, '9'\n  jg loop\n  mov al, 1\nend:\n  RET","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214191,"user_id":null,"body":"global has_digits\nsection .text\nhas_digits:\n  xor eax, eax\n  test rdi, rdi\n  jz .end\n.loop:\n  mov BYTE al, [rdi]\n  test al, al\n  jz .end\n  sub al, 48\n  cmp al, 9\n  jbe .found\n  inc rdi\n  jmp .loop\n.found:\n  mov al, 1\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214192,"user_id":null,"body":"global has_digits\nsection .text\nhas_digits:\n  test rdi, rdi\n  je .empty\n.loop:\n  mov al, [rdi]\n  test al, al\n  je .done\n  lea ecx, [rax - 48]\n  inc rdi\n  cmp cl, 9\n  ja .loop\n.done:\n  test al, al\n  setne al\n  ret\n.empty:\n  xor eax, eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214193,"user_id":null,"body":"global has_digits\nsection .text\nhas_digits:\n  test rdi, rdi\n  jz .done\n  .loop:\n  mov al, byte [rdi]\n  test al, al\n  jz .done\n  sub eax, 48\n  inc rdi\n  cmp al, 9\n  ja .loop\n  mov al, 1\n  .done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214194,"user_id":null,"body":"global has_digits\nsection .text\nhas_digits:\n  xor eax, eax\n  test rdi, rdi\n  jz .no\n  \n.loop:\n  mov dl, [rdi]\n  inc rdi\n  test dl, dl\n  jz .no\n  sub dl, '0'\n  cmp dl, 9\n  ja .loop  \n\n  inc eax\n.no:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ae62fcf252e66d44d00008e":[{"id":214195,"user_id":527,"body":"global expression_matter\nsection .text\nexpression_matter:\n                mov     eax, edi\n                imul    eax, esi\n                imul    eax, edx\n                lea     ecx, [rdi + rsi]\n                imul    ecx, edx\n                cmp     ecx, eax\n                cmova   eax, ecx\n                add     edx, esi\n                lea     ecx, [rdi + rdx]\n                imul    edx, edi\n                cmp     ecx, edx\n                cmova   edx, ecx\n                cmp     edx, eax\n                cmova   eax, edx\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214196,"user_id":null,"body":"global expression_matter\n; inorder: rdi, rsi, rdx, rcx\nexpression_matter:\n  mov ecx, edx\n  xor eax, eax ; your code here\n  mov eax, edi\n  add eax, esi\n  add eax, ecx\n  mov ebx, eax\n  mov eax, edi\n  mul esi\n  mul ecx\n  cmp ebx, eax\n  cmovl ebx, eax\n  mov eax, edi\n  mul esi\n  add eax, ecx\n  cmp ebx, eax\n  cmovl ebx, eax\n  mov eax, esi\n  add eax ,ecx\n  mul edi\n  cmp ebx, eax\n  cmovl ebx, eax\n  mov eax, edi\n  add eax, esi\n  mul ecx\n  cmp ebx, eax\n  cmovl ebx, eax\n  mov eax, esi\n  mul ecx\n  add eax, edi\n  cmp ebx, eax\n  cmovl ebx, eax\n  mov eax, ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214197,"user_id":null,"body":"global expression_matter\n;1 - edi\n;2 - esi\n;3 - edx\nexpression_matter:\n  xor eax, eax ; your code here\n  mov rcx, rsp\n  add eax, edi\n  add eax, esi\n  add eax, edx ; a+b+c\n  push rax\n  \n  mov eax, edi\n  add eax, esi\n  imul eax, edx ; (a+b)*c\n  push rax\n  \n  mov eax, edx\n  imul eax, esi\n  add eax, edi ; a+b*c\n  push rax\n  \n  mov eax, edi\n  imul eax, esi\n  add eax, edx ; a*b+c\n  push rax\n  \n  mov eax, edx\n  add eax, esi\n  imul eax, edi ; a*(b+c)\n  push rax\n  \n  mov eax, edi\n  imul eax, esi\n  imul eax, edx ; a*b*c\n  \n  loop:\n  pop rbx\n  cmp rax, rbx\n  jge next\n  mov rax, rbx\n  next:\n  cmp rcx, rsp\n  jne loop\n  \n  mov rsp, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214198,"user_id":881,"body":"section .text\nglobal expression_matter\n\n; int expression_matter(int, int, int)\nexpression_matter:\n    mov ecx, edx\n    xor edx, edx\n    mov eax, edi\n    mul esi\n    mul ecx\n    mov r8d, eax\n    lea eax, [edi + esi]\n    add eax, ecx\n    cmp eax, r8d\n    cmovg r8d, eax\n    lea eax, [edi + esi]\n    mul ecx\n    cmp eax, r8d\n    cmovg r8d, eax\n    lea eax, [esi + ecx]\n    mul edi\n    cmp eax, r8d\n    cmovl eax, r8d\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214199,"user_id":null,"body":"global expression_matter\nexpression_matter:\n\tlea\tecx, [rsi + rdi]\n\tlea\tr8d, [rcx + rdx]\n\tlea\teax, [rdx + rsi]\n\timul\teax, edi\n\timul\tecx, edx\n\timul\tesi, edi\n\timul\tesi, edx\n\tcmp\tr8d, eax\n\tcmovae\teax, r8d\n\tcmp\teax, ecx\n\tcmovl\teax, ecx\n\tcmp\teax, esi\n\tcmovl\teax, esi\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214200,"user_id":50,"body":"global expression_matter\nexpression_matter:\n  xor r8,r8 ; r8 will hold temporary max\n  xor rbx,rbx\n  xor rax, rax ; tmp = \n  add eax,edi ; a +\n  add eax,esi ; b \n  mov ebx,eax ; ebx=a+b \n  imul eax,edx ; eax= (a+b)*c\n  add ebx, edx ; ebx=a+b+c\n  cmp ebx,eax\n  jg _set1 ; if ebx is greater, r8=ebx\n  mov r8d,eax ; else r8=eax\n_step1:\n  mov eax,esi  ; eax=b\n  add eax,edx  ; +c\n  imul eax,edi ; *a\n  cmp eax,r8d\n  jg _set2 ; if eax is greater, r8=eax\n_step2:\n  mov eax,edi  ; eax=a\n  imul eax,esi ; *b\n  imul eax,edx ; *c\n  cmp eax,r8d\n  jg _set3 ; if eax is greater, ret\n  mov eax,r8d\n  ret\n_set1:\n  mov r8d,ebx\n  jmp _step1\n_set2:\n  mov r8d,eax\n  jmp _step2\n_set3:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214201,"user_id":null,"body":"global expression_matter\n\n\n; everyone returns RAX\nraw_sum:\n        add rax, rbx    ; perform sum\n        add rax, rcx\n        ret\n\nraw_product:\n        push rdx\n        mul rbx\n        mul rcx\n        pop rdx\n        ret\n\nf1:\n        push rdx\n        mul rbx\n        add rax, rcx\n        pop rdx\n        ret\n\nf2:\n        push rdx\n        add rax, rbx\n        mul rcx\n        pop rdx\n        ret\n\ncompare_and_set:\n        cmp rax, rdx\n        jle continue\nproduct_is_greater:\n        mov rdx, rax\ncontinue:\n        ret\n\nexpression_matter:\n        xor rax, rax\n        mov rax, rdx\n        mov rbx, rsi\n        mov rcx, rdi ; move the args to more reasonable regs\n\n        push rax\n        call raw_sum\n        mov rdx, rax ; move to the compare reg\n        pop rax\n\n        push rax\n        call raw_product\n        call compare_and_set\n        pop rax\n\n        ; (a*b)+c\n        push rax\n        call f1\n        call compare_and_set\n        pop rax\n\n        ; (c*b)+a\n        push rax\n        push rcx\n        xchg rax, rcx\n        call f1\n        call compare_and_set\n        pop rcx\n        pop rax\n        xchg rax, rcx\n\n        ; (a+b)*c\n        push rax\n        call f2\n        call compare_and_set\n        pop rax\n\n        ; (c+b)*a\n        push rax\n        push rcx\n        xchg rax, rcx\n        call f2\n        call compare_and_set\n        pop rcx\n        pop rax\n        xchg rax, rcx\n\n        mov rax, rdx ; set the ret_val\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214202,"user_id":null,"body":"global expression_matter\nexpression_matter:\n  \n  mov ebx, edi\n  add ebx, esi\n  add ebx, edx\n  \n  mov ecx, edx\n  mov eax, edi\n  mul esi\n  add eax, ecx\n  cmp ebx, eax\n  jge s1\n  mov ebx, eax\ns1:\n\n  mov eax, esi\n  add eax, ecx\n  mul edi\n  cmp ebx, eax\n  jge s2\n  mov ebx, eax\ns2:\n  \n  mov eax, esi\n  mul ecx\n  add eax, edi\n  cmp ebx, eax\n  jge s3\n  mov ebx, eax\ns3:\n\n  mov eax, edi\n  add eax, esi\n  mul ecx\n  cmp ebx, eax\n  jge s4\n  mov ebx, eax\ns4:\n\n  mov eax, edi\n  mul esi\n  mul ecx\n  cmp ebx, eax\n  jge s5\n  mov ebx, eax\ns5:\n  \n  mov eax, ebx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214203,"user_id":null,"body":"SECTION .text\nglobal expression_matter\n\nmultiplication:\n  mov rax, r8\n  imul rax, r9\n  imul rax, r10\n  ret\n  \naddition:\n  mov rax, r8\n  add rax, r9\n  add rax, r10\n  ret\n\nmul_add:\n  mov rax, r8\n  imul rax, r9\n  add rax, r10\n  ret\n  \nadd_mul:\n  mov rax, r9\n  imul rax, r10\n  add rax, r8\n  ret\n  \nmul_add_parent:\n  mov rax, r9\n  add rax, r10\n  imul rax, r8\n  ret\n  \nadd_mul_parent:\n  mov rax, r8\n  add rax, r9\n  imul rax, r10\n  ret\n\nexpression_matter:\n  ; edi - num1, esi - num2, edx - num3\n  ; r8 - num1, r9 - num2, r10 - num3\n  mov r8, rdi\n  mov r9, rsi\n  mov r10, rdx\n  \n  ; r8 * r9 * r10\n  call multiplication\n  mov rbx, rax\n  \n  ; r8 + r9 + r10\n  call addition\n  cmp rax, rbx\n  cmovg rbx, rax\n  \n  ; r8 * r9 + r10\n  call mul_add\n  cmp rax, rbx\n  cmovg rbx, rax\n  \n  ; r8 + r9 * r10\n  call add_mul\n  cmp rax, rbx\n  cmovg rbx, rax\n  \n  ; r8 * (r9 + r10)\n  call mul_add_parent\n  cmp rax, rbx\n  cmovg rbx, rax\n  \n  ; (r8 + r9) * r10\n  call add_mul_parent\n  cmp rax, rbx\n  cmovg rbx, rax\n  \n  mov rax,  rbx; your code here\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214204,"user_id":168,"body":"global expression_matter\nexpression_matter:\n  lea ecx, [rdi + rsi]\n  lea eax, [rcx + rdx]\n  imul ecx, edx\n  cmp ecx, eax\n  cmovg eax, ecx\n  lea ecx, [rsi + rdx]\n  imul esi, edx\n  imul ecx, edi\n  cmp ecx, eax\n  cmovg eax, ecx\n  imul esi, edi\n  cmp esi, eax\n  cmovg eax, esi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ae71f8c2c5061059e000044":[{"id":214205,"user_id":1339,"body":"global findX\nsection .text\nfindX:\n  mov rax, rdi\n  mul rdi\n  lea rdi, [rdi*3-2]\n  mul rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214206,"user_id":17,"body":"global findX\nsection .text\nfindX:\n  mov rax, rdi\n  imul rax, rdi\n  imul rdi, 3\n  sub rdi, 2\n  imul rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214207,"user_id":527,"body":"global findX\nsection .text\nfindX:\n                mov     eax, edi\n                imul    rax, rax\n                lea     edi, [edi * 3 - 2]\n                imul    rax, rdi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214208,"user_id":null,"body":"global findX\nsection .text\n; input: edi = n\n; output: rax\nfindX:\n  mov rax, 3\n  mul rdi\n  sub rax, 2\n  mul rdi\n  mul rdi\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214209,"user_id":null,"body":"global findX\nsection .text\n; input: edi = n\n; output: rax\nfindX:\n  mov rax, rdi\n  mul rax\n  mov rbx, rax  ; n*n\n  mov rdx, 3\n  mov rax, rdi\n  mul rdx\n  sub rax, 2\n  mul rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214210,"user_id":null,"body":"global findX\nsection .text\n; input: edi = n\n; output: rax\nfindX:\n  movsxd rcx, edi\n  lea rax, [rcx + 2*rcx - 2]\n  imul rcx, rcx\n  imul rax, rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214211,"user_id":76,"body":"global findX\nsection .text\n; input: edi = n\n; output: rax\nfindX:\n  lea rbx, [rdi * 3 - 2]\n  mov rax, rdi\n  mul rdi\n  mul rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214212,"user_id":null,"body":"global findX\nsection .text\nfindX:\n  movsx rdx, edi\n  lea rax, [rdx + 2 * rdx - 2]\n  imul rax, rdx\n  imul rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214213,"user_id":null,"body":"global findX\nsection .text\n; input: edi = n\n; output: rax\n\n; The calculation is mathematically the same as: x = (6n^3 - 4n^2) \/ 2\n\nfindX:\n  mov rax, rdi\n  mul rdi\n  mov rcx, rax      ; ecx = n^2\n  mul rdi\n  mov rdx, 6\n  mul rdx           ; eax = 6n^3\n  mov rsi, rax      ; esi = 6n^3\n  mov rax, 4\n  mul rcx           ; eax = 4n^2\n  sub rsi, rax      ; 6n^3 - 4n^2\n  shr rsi, 1        ; (6n^3 - 4n^2) \/ 2 \n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214214,"user_id":77,"body":"global findX\nsection .text\n; input: edi = n\n; output: rax\nfindX:\n  xor rax, rax\n  mov eax, edi\n  mov rdi, rax\n  mov rcx, 3\n  mul rcx\n  sub rax, 2\n  mul rdi\n  mul rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5aec1ed7de4c7f3517000079":[{"id":214215,"user_id":null,"body":"section .text\nextern malloc, qsort\nglobal first_n_smallest\n\ncompare1:\n  mov eax, [rdi]\n  sub eax, [rsi]\n  jnz compare_done\ncompare2:\n  mov eax, [rsi+4]\n  sub eax, [rdi+4]\ncompare_done:\n  ret\n  \n\n; input: rdi = array, rsi = size, rdx = n\n; do not modify the input array\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfirst_n_smallest:\n  push rdi\n  push rsi\n  push rdx\n  \n  xor eax, eax\n  test edx, edx\n  jz .quit\n  lea edi, [rsi*8]\n  call malloc\n  test rax, rax\n  jz .quit\n    \n  mov rdi, rax\n  mov rsi, [rsp+16]\n  mov ecx, [rsp+8]\n.loop:\n  mov edx, [rsi]\n  mov [rdi], edx\n  mov [rdi+4], ecx\n  add rsi, 4\n  add rdi, 8\n  loop .loop\n  \n  mov [rsp+16], rax\n  mov rdi, rax\n  mov rsi, [rsp+8]\n  mov rdx, 8\n  lea rcx, [compare1]\n  call qsort\n  \n  mov rdi, [rsp+16]\n  mov rsi, [rsp]\n  mov rdx, 8\n  lea rcx, [compare2]\n  call qsort\n  \n  mov rdi, [rsp+16]\n  mov rsi, rdi\n  mov ecx, [rsp]\n.loop2:\n  lodsq\n  stosd\n  loop .loop2\n  \n  mov rax, [rsp+16]  \n.quit:\n  add rsp, 24\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214216,"user_id":null,"body":"section .text\nextern malloc,memcpy,realloc\nglobal first_n_smallest\n; input: rdi = array, rsi = size, rdx = n\n; do not modify the input array\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfirst_n_smallest:\n  push r15\n  push r14\n  push r13\n  push r12\n  push rbx\n  lea r13, [4*rsi]\n  mov r12, rdi\n  mov r15, rdx\n  mov r14, rsi\n  mov rdi, r13\n  call malloc\n  mov rdi, rax\n  mov rsi, r12\n  mov rdx, r13\n  mov rbx, rax\n  call memcpy\n  lea rax, [r15 - 1]\n  movsxd r9, r15d\n  lea r8d, [r15 - 2]\n.loop:\n  cmp r9, r14\n  jae .done\n  mov edi, [rbx + 4*r15 - 4]\n  mov esi, eax\n  mov edx, r8d\n.maxloop:\n  test edx, edx\n  js .maxdone\n  mov ecx, edx\n  mov ecx, [rbx + 4*rcx]\n  cmp ecx, edi\n  cmovg edi, ecx\n  cmovg esi, edx\n  dec edx\n  jmp .maxloop\n.maxdone:\n  cmp edi, [rbx + 4*r9]\n  jle .noshift\n  movsxd rdx, esi\n.shiftloop:\n  cmp rax, rdx\n  jbe .shiftdone\n  mov ecx, [rbx + 4*rdx + 4]\n  mov [rbx + 4*rdx], ecx\n  inc rdx\n  jmp .shiftloop\n.shiftdone:\n  mov ecx, [rbx + 4*r9]\n  mov [rbx + 4*r15 - 4], ecx\n.noshift:\n  inc r9\n  jmp .loop\n.done:\n  shl r15, 2\n  mov rdi, rbx\n  mov rsi, r15\n  pop rbx\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  jmp realloc","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214217,"user_id":168,"body":"section .text\nextern malloc\nextern qsort\nglobal first_n_smallest\n; input: rdi = array, rsi = size, rdx = n\n; do not modify the input array\n; output: rax\n; callee saved registers: rbx, rsp, rbp, r12-r15\nfirst_n_smallest:\n  push rbx ; = array\n  push r12 ; = size\n  push r13 ; = n\n  push r14 ; = result\n  push r15\n  mov rbx, rdi\n  mov r12, rsi\n  mov r13, rdx\n  lea rdi, [rsi * 8]\n  call malloc \n  mov r14, rax\n  test r13, r13\n  jz .end\n  \n  mov rdi, rax\n  mov rsi, rbx\n  mov rcx, r12\n  inc rcx\n  xor eax, eax\n  jmp .enumerate_cond\n.enumerate:\n  movsd\n  stosd\n  inc eax\n.enumerate_cond:\n  dec rcx\n  jnz .enumerate\n  \n  mov rdi, r14\n  mov rsi, r12\n  mov edx, 8\n  mov rcx, compare_values\n  call qsort\n  \n  mov rdi, r14\n  mov rsi, r13\n  mov edx, 8\n  mov rcx, compare_indices\n  call qsort\n  \n  lea rdi, [r14 + 4]\n  lea rsi, [r14 + 8]\n  mov rcx, r13\n  jmp .shift_cond\n.shift:\n  movsd\n  add rsi, 4\n.shift_cond:\n  dec rcx\n  jnz .shift\n  \n.end:\n  mov rax, r14\n  pop r15\n  pop r14\n  pop r13\n  pop r12\n  pop rbx\n  ret\n  \ncompare_values:\n  mov eax, dword [rdi]\n  sub eax, dword [rsi]\n  ret\n  \ncompare_indices:\n  mov eax, dword [rdi + 4]\n  sub eax, dword [rsi + 4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5aff237c578a14752d0035ae":[{"id":214218,"user_id":168,"body":"SECTION .text\nglobal predict_age\n\n;  Accepts the ages of 8 great-grandparents and predicts the age of death of the grandchild according to the formula in the description.\n;  arg0         = (uint64_t) An age.\n;  arg1         = (uint64_t) An age.\n;  arg2         = (uint64_t) An age.\n;  arg3         = (uint64_t) An age.\n;  arg4         = (uint64_t) An age.\n;  arg5         = (uint64_t) An age.\n;  arg6         = (uint64_t) An age.\n;  arg7         = (uint64_t) An age.\n;  return value = (uint64_t) The predicted age of death.\npredict_age:\n  imul rdi, rdi\n  imul rsi, rsi\n  imul rdx, rdx\n  imul rcx, rcx\n  imul r8, r8\n  imul r9, r9\n  mov rax, [rsp + 8]\n  imul rax, rax\n  add rax, rdi\n  add rax, rsi\n  add rax, rdx\n  add rax, rcx\n  add rax, r8\n  add rax, r9\n  mov rdx, [rsp + 16]\n  imul rdx, rdx\n  add rax, rdx\n  shr rax, 2\n  cvtsi2sd xmm0, rax\n  sqrtsd xmm0, xmm0\n  cvttsd2si rax, xmm0\n  ret\n  \n  \n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214219,"user_id":527,"body":"section .text\nglobal predict_age\npredict_age:\n                imul    rdi, rdi\n                imul    rsi, rsi\n                imul    rdx, rdx\n                imul    rcx, rcx\n                imul    r8, r8\n                imul    r9, r9\n                mov     r10, [rsp + 8]\n                imul    r10, r10\n                mov     rax, [rsp + 16]\n                imul    rax, rax\n                add     rsi, rdi\n                add     rcx, rdx\n                add     r9, r8\n                add     rax, r10\n                add     rcx, rsi\n                add     rax, r9\n                add     rax, rcx\n                cvtsi2ss    xmm0, rax\n                sqrtss      xmm0, xmm0\n                cvttss2si   rax, xmm0\n                shr     rax, 1\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214220,"user_id":527,"body":"; just for fun\nsection .text\nglobal predict_age\npredict_age:\n                mov     [rsp + 12], edi\n                mov     [rsp + 20], esi\n                xchg    [rsp], rdx\n                mov     [rsp + 4], ecx\n                mov     [rsp - 4], r8d\n                mov     [rsp - 8], r9d\n                vcvtdq2ps     ymm0, [rsp - 8]\n                vdpps         ymm0, ymm0, 255\n                vextractf128  xmm1, ymm0, 1\n                vaddss        xmm0, xmm1\n                vsqrtss       xmm0, xmm0\n                vcvttss2si    eax, xmm0\n                shr     eax, 1\n                jmp     rdx","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214221,"user_id":null,"body":"SECTION .text\nglobal predict_age\nextern sqrt\nextern floor\n;  arg0         = (uint64_t) An age. (rdi)\n;  arg1         = (uint64_t) An age. (rsi)\n;  arg2         = (uint64_t) An age. (rdx)\n;  arg3         = (uint64_t) An age. (rcx)\n;  arg4         = (uint64_t) An age. (r8)\n;  arg5         = (uint64_t) An age. (r9)\n;  arg6         = (uint64_t) An age. (rsp + 8)\n;  arg7         = (uint64_t) An age. (rsp + 16)\n;  return value = (uint64_t) The predicted age of death. (rax)\npredict_age:\n  imul rdi, rdi\n  imul rsi, rsi\n  imul rdx, rdx\n  imul rcx, rcx\n  imul r8, r8\n  imul r9, r9\n  lea rax, [rdi + rsi]\n  add rax, rdx\n  mov rdx, [rsp + 0x08]\n  imul rdx, rdx\n  add rax, rdx\n  add rax, rcx\n  mov rcx, [rsp + 0x10]\n  imul rcx, rcx\n  add rax, rcx\n  add rax, r8\n  add rax, r9\n  cvtsi2sd xmm0, rax\n  call sqrt\n  mov r8, 2\n  cvtsi2sd xmm1, r8\n  divsd xmm0, xmm1\n  call floor\n  cvtsd2si rax, xmm0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214222,"user_id":null,"body":"SECTION .text\nglobal predict_age\npredict_age:\n      pop r11\n      push rdi\n      push rsi\n      push rdx\n      push rcx\n      push r8\n      push r9\n      xor r10,r10\n      mov rcx,8\n      \n@l1:  mov rax,[rsp + rcx * 8 -8]\n      mul rax\n      add r10,rax\n      loop @l1\n      \n      cvtsi2ss xmm1,r10       ; OK - this section turned out uglier than expected\n      mov rax,2\n      cvtsi2ss xmm2,rax\n      sqrtss xmm0,xmm1\n      divss xmm0,xmm2\n      cvttss2si rax,xmm0\n      \n      add rsp,48\n      push r11\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214223,"user_id":null,"body":"SECTION .text\nglobal predict_age\n\n;  Accepts the ages of 8 great-grandparents and predicts the age of death of the grandchild according to the formula in the description.\n;  arg0         = (uint64_t) An age.\n;  arg1         = (uint64_t) An age.\n;  arg2         = (uint64_t) An age.\n;  arg3         = (uint64_t) An age.\n;  arg4         = (uint64_t) An age.\n;  arg5         = (uint64_t) An age.\n;  arg6         = (uint64_t) An age.\n;  arg7         = (uint64_t) An age.\n;  return value = (uint64_t) The predicted age of death.\npredict_age:\n  vcvtsi2ss xmm7, xmm7, esi\n  vcvtsi2ss xmm6, xmm6, edi\n  vcvtsi2ss xmm5, xmm5, edx\n  vcvtsi2ss xmm4, xmm4, ecx\n  vmulss xmm7, xmm7, xmm7\n  vcvtsi2ss xmm3, xmm3, r8d\n  vcvtsi2ss xmm2, xmm2, r9d\n  vfmadd132ss xmm6, xmm7, xmm6\n  vcvtsi2ss xmm1, xmm1, dword [rsp+8]\n  vcvtsi2ss xmm0, xmm0, dword [rsp+16]\n  vfmadd132ss xmm5, xmm6, xmm5\n  vfmadd132ss xmm4, xmm5, xmm4\n  vfmadd132ss xmm3, xmm4, xmm3\n  vfmadd132ss xmm2, xmm3, xmm2\n  vfmadd132ss xmm1, xmm2, xmm1\n  vfmadd132ss xmm0, xmm1, xmm0\n  vsqrtss xmm0, xmm0, xmm0\n  vmulss xmm0, xmm0, dword [.half]\n  vcvttss2si eax, xmm0\n  ret\n.half: dq 1056964608","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214224,"user_id":null,"body":"SECTION .text\nglobal predict_age\n\n;  Accepts the ages of 8 great-grandparents and predicts the age of death of the grandchild according to the formula in the description.\n;  arg0         = (uint64_t) An age.\n;  arg1         = (uint64_t) An age.\n;  arg2         = (uint64_t) An age.\n;  arg3         = (uint64_t) An age.\n;  arg4         = (uint64_t) An age.\n;  arg5         = (uint64_t) An age.\n;  arg6         = (uint64_t) An age.\n;  arg7         = (uint64_t) An age.\n;  return value = (uint64_t) The predicted age of death.\npredict_age:\n  ; rdi, rsi, rdx, rcx, r8, r9, [rsp+8], [rsp+16]\n  imul rdi, rdi\n  imul rsi, rsi\n  add rdi, rsi\n  mov rsi, [rsp+8]\n  imul rdx, rdx\n  imul rcx, rcx\n  add rdx, rcx\n  mov rcx, [rsp+16]\n  imul r8, r8\n  imul r9, r9\n  add r8, r9\n  add rdi, rdx\n  add rdi, r8\n  imul rsi, rsi\n  imul rcx, rcx\n  add rsi, rcx\n  add rdi, rsi\n  \n  cvtsi2sd xmm0, rdi\n  sqrtsd xmm0, xmm0\n  cvttsd2si rax, xmm0\n  shr rax, 1\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214225,"user_id":null,"body":"SECTION .text\nglobal predict_age\n\n;  Accepts the ages of 8 great-grandparents and predicts the age of death of the grandchild according to the formula in the description.\n;  arg0         = (uint64_t) An age. => rdi\n;  arg1         = (uint64_t) An age. => rsi\n;  arg2         = (uint64_t) An age. => rdx\n;  arg3         = (uint64_t) An age. => rcx\n;  arg4         = (uint64_t) An age. => r8\n;  arg5         = (uint64_t) An age. => r9\n;  arg6         = (uint64_t) An age. => rbp + 16\n;  arg7         = (uint64_t) An age. => rbp + 24\n;  return value = (uint64_t) The predicted age of death.\npredict_age:\n  push rbp\n  mov rbp, rsp\n  \n  xor rax, rax\n  imul rdi, rdi\n  imul rsi, rsi\n  imul rdx, rdx\n  imul rcx, rcx\n  imul r8, r8\n  imul r9, r9\n  mov r10d, dword [rbp + 16]\n  imul r10, r10\n  mov r11d, dword [rbp + 24]\n  imul r11, r11\n  \n  lea rax, [rdi + rsi]\n  lea rcx, [rcx + rdx]\n  lea r8, [r8 + r9]\n  lea r10, [r10 + r11]\n  add rax, rcx\n  add rax, r8\n  add rax, r10\n  \n  push rax\n  fild dword [rsp]\n  fsqrt\n  fstp dword [rsp]\n  cvttss2si eax, dword [rsp]\n  pop rdx \n  shr rax, 1\n  \n.exit:\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214226,"user_id":null,"body":"SECTION .text\nglobal predict_age\n\n;  Accepts the ages of 8 great-grandparents and predicts the age of death of the grandchild according to the formula in the description.\n;  arg0         = (uint64_t) An age. => rdi\n;  arg1         = (uint64_t) An age. => rsi\n;  arg2         = (uint64_t) An age. => rdx\n;  arg3         = (uint64_t) An age. => rcx\n;  arg4         = (uint64_t) An age. => r8\n;  arg5         = (uint64_t) An age. => r9\n;  arg6         = (uint64_t) An age. => rbp + 16\n;  arg7         = (uint64_t) An age. => rbp + 24\n;  return value = (uint64_t) The predicted age of death.\npredict_age:\n  push rbp\n  mov rbp, rsp\n  \n  xor rax, rax\n  imul rdi, rdi\n  imul rsi, rsi\n  imul rdx, rdx\n  imul rcx, rcx\n  imul r8, r8\n  imul r9, r9\n  mov r10d, dword [rbp + 16]\n  imul r10, r10\n  mov r11d, dword [rbp + 24]\n  imul r11, r11\n  \n  lea rax, [rdi + rsi]\n  lea rcx, [rcx + rdx]\n  lea r8, [r8 + r9]\n  lea r10, [r10 + r11]\n  add rax, rcx\n  add rax, r8\n  add rax, r10\n  \n  push rax\n  fild dword [rsp]\n  fsqrt\n  fstp dword [rsp]\n  cvttss2si eax, dword [rsp]\n  pop rdx \n \n  mov r12, 2\n  xor rdx, rdx\n  idiv r12\n  \n.exit:\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214227,"user_id":50,"body":"SECTION .text\nglobal predict_age\n\npredict_age:\n  imul rdi,rdi\n  mov rax,rdi\n  imul rsi,rsi\n  add rax,rsi\n  imul rdx,rdx\n  add rax,rdx\n  imul rcx,rcx\n  add rax,rcx\n  imul r9,r9\n  add rax,r9\n  imul r8,r8\n  add rax,r8\n  mov r11,[rsp+8]\n  imul r11,r11\n  add rax,r11\n  mov r11,[rsp+16]\n  imul r11,r11\n  add rax,r11\n  mov rbx,1\n_sqrt:\n  mov rcx,rbx\n  imul rcx,rbx\n  cmp rcx,rax\n  jg _exit\n  inc rbx\n  jmp _sqrt\n_exit:\n  dec rbx\n  mov rax,rbx\n  shr rax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b097da6c3323ac067000036":[{"id":214228,"user_id":null,"body":"extern asprintf\nsection .text\nglobal solve_rock_off\n; char *solve_rock_off(const int alice[], const int bob[], int count);\n; input: rdi = alice, rsi = bob, rdx = count\n; output: rax\nsolve_rock_off:\n  push rbx\n  sub rsp, 16\n  mov r8d, edx\n  xor r11d, r11d\n  test edx, edx\n  cmovle r8d, r11d\n  xor edx, edx\n  xor ecx, ecx\n.loop:\n  cmp r8, r11\n  je .LBB0_2\n  mov r9d, [rdi + 4*r11]\n  mov r10d, [rsi + 4*r11]\n  xor eax, eax\n  xor ebx, ebx\n  cmp r9d, r10d\n  setg al\n  setl bl\n  add edx, eax\n  add ecx, ebx\n  inc r11\n  jmp .loop\n.LBB0_2:\n  cmp ecx, edx\n  mov eax, .bobwins\n  mov edi, .draw\n  cmova rdi, rax\n  mov esi, .alicewins\n  cmovae rsi, rdi\n  lea rbx, [rsp + 8]\n  mov rdi, rbx\n  xor eax, eax\n  call asprintf\n  mov rax, [rbx]\n  add rsp, 16\n  pop rbx\n  ret\n.alicewins: db '%u, %u: Alice made \"Kurt\" proud!',0\n.bobwins: db '%u, %u: Bob made \"Jeff\" proud!',0\n.draw: db '%u, %u: that looks like a \"draw\"! Rock on!',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214229,"user_id":null,"body":"section .text\nextern malloc, sprintf\nglobal solve_rock_off\n; char *solve_rock_off(const int alice[], const int bob[], int count);\n; input: rdi = alice, rsi = bob, rdx = count\n; output: rax\nsolve_rock_off:\n  xor r8d, r8d\n  xor r9d, r9d\n  \n.loop:\n  mov eax, [rdi]\n  cmp eax, [rsi]\n  jg .a\n  je .next\n  inc r9d\n  jmp .next\n.a:\n  inc r8d\n.next:\n  add rdi, 4\n  add rsi, 4\n  dec rdx\n  jne .loop\n  \n  push r8\n  push r9\n  push rbp\n  mov edi, 128\n  call malloc\n  pop rbp\n  pop rcx\n  pop rdx\n  test rax, rax\n  jz .quit\n\n  push rax\n  mov rdi, rax\n  lea rsi, [format]\n  lea r8, [resultD]\n  lea r9, [resultA]\n  lea rax, [resultB]\n  cmp edx, ecx\n  cmovg r8, r9\n  cmovl r8, rax\n  xor eax, eax\n  call sprintf\n  pop rax\n  \n.quit:\n  ret\n\n\nsection .rodata\nformat: db \"%d, %d: %s\", 0\nresultA: db 'Alice made \"Kurt\" proud!', 0\nresultB: db 'Bob made \"Jeff\" proud!', 0\nresultD: db 'that looks like a \"draw\"! Rock on!', 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214230,"user_id":null,"body":"section .data\nfmtbob   db '%d, %d: Bob made \"Jeff\" proud!',0\nfmtalice db '%d, %d: Alice made \"Kurt\" proud!',0\nfmtdraw  db '%d, %d: that looks like a \"draw\"! Rock on!',0\nsection .text\nglobal solve_rock_off\nextern malloc,sprintf\n; char *solve_rock_off(const int alice[], const int bob[], int count);\n; input: rdi = alice, rsi = bob, rdx = count\n; output: rax\nsolve_rock_off:\n  xor   rcx,rcx   ; score bob\n  xor   rbx,rbx   ; score alice\n  xor   r10,r10   ; counter i\n  .loop1:\n  cmp   r10,rdx\n  je    .end1\n  mov   eax, [rsi]\n  cmp   [rdi], eax ;rdi == alice | r9 == bob \n  jl    .bobinc\n  jg    .aliceinc\n  .continue:\n  add   rdi, byte 4\n  add   rsi, byte 4\n  inc   r10\n  jmp   .loop1\n  .end1:\n  push  rbx\n  push  rcx\n  mov   rdi, 64\n  call  malloc\n  pop   rcx\n  pop   rbx\n  push  rax\n  cmp   rbx, rcx  ;rbx == alice | rcx == bob\n  je    .draw\n  jl    .bob\n  .alice:\n  mov   rsi, fmtalice\n  jmp   .end2\n  .bob:\n  mov   rsi, fmtbob\n  jmp   .end2\n  .draw:\n  mov   rsi, fmtdraw\n  .end2:\n  mov   rdi, rax\n  mov   rdx, rbx\n  mov   r10,  rcx\n  call  sprintf\n  pop   rax\n  ret\n  \n  .bobinc:\n  inc   rcx\n  jmp   .continue\n  .aliceinc:\n  inc   rbx\n  jmp   .continue","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214231,"user_id":104,"body":"; 2021 nomennescio\nsection .text\nglobal solve_rock_off\nextern asprintf\n\n; char *solve_rock_off(const int alice[], const int bob[], int count);\n; input: rdi = alice, rsi = bob, rdx = count\n; output: rax\n\nkurt: db `Alice made \"Kurt\" proud!`, 0\njeff: db `Bob made \"Jeff\" proud!`, 0\ndraw: db `that looks like a \"draw\"! Rock on!`, 0\nfmt:  db `%d, %d: %s`,0\n\nsolve_rock_off:\n    sub rsp, 8\n    xor rcx, rcx\n    xor r8, r8\n  \nloop:\n    mov eax, [rdi+4*rdx-4]\n    cmp eax, [rsi+4*rdx-4]\n    je .2\n    jb .1\n    inc r8\n    jmp .2\n.1  inc rcx\n.2  dec rdx\n    jne loop\n  \n    mov rdi, rsp\n    mov rsi, fmt\n    mov rdx, r8\n    cmp rcx, r8\n    mov r8, draw\n    mov r9, kurt\n    mov r10, jeff\n    cmovl r8, r9\n    cmovg r8, r10\n    call asprintf\n    pop rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214232,"user_id":null,"body":"global solve_rock_off\nextern malloc\nextern sprintf\nsolve_rock_off:\n  xor r8,r8\n  xor r9,r9\n  @b:cmpsd\n     seta al\n     adc  r8,0   ;maybe adcx better?\n     add  r9b,al\n     dec  rdx\n  jne @b   \n  push  r8\n  push  r9\n  mov   rdi,64\n  call  malloc\n  pop   rcx\n  pop   rdx\n  cmp   rdx,rcx\n  mov   r8,c\n  cmova r8,[a]\n  cmovb r8,[b]\n  mov   rsi,fmt\n  mov   rdi,rax\n  push  rax\n  xor   rax,rax\n  call  sprintf\n  pop   rax\nret\nfmt db '%u, %u: %s',0\na dq _a\nb dq _b\n_a db 'Alice made \"Kurt\" proud!',0\n_b db 'Bob made \"Jeff\" proud!',0\nc db 'that looks like a \"draw\"! Rock on!',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214233,"user_id":null,"body":"section .text\n\nglobal solve_rock_off\nextern asprintf\n\n; char *solve_rock_off(const int alice[], const int bob[], int count)\nsolve_rock_off:\n    ; r8 for Alice's score, r9 for Bob's\n    xor r8, r8\n    xor r9, r9\n\n.score_count:\n    mov ecx, [rdi]\n    cmp [rsi], ecx\n    adc r8, 0\n    cmp ecx, [rsi]\n    adc r9, 0\n    add rdi, 4\n    add rsi, 4\n    dec rdx\n    jg .score_count\n\n    ; Prepare asprintf\n    sub rsp, 8\n    mov rdi, rsp\n    lea rsi, [rel format]\n    mov rdx, r8\n    mov rcx, r9\n\n    ; Decide winner text\n    lea r8, [rel draw]\n    cmp rdx, rcx\n    je .call_asprintf\n    jl .bob\n    lea r8, [rel alice]\n    jmp .call_asprintf\n.bob:\n    lea r8, [rel bob]\n\n.call_asprintf:\n    call asprintf\n    mov rax, [rsp]\n    add rsp, 8\n    ret\n\nsection .rodata\nalice db 'Alice made \"Kurt\" proud!', 0\nbob db 'Bob made \"Jeff\" proud!', 0\ndraw db 'that looks like a \"draw\"! Rock on!', 0\nformat db \"%d, %d: %s\"","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214234,"user_id":168,"body":"section .text\nglobal solve_rock_off\nextern asprintf\nalice db '%d, %d: Alice made \"Kurt\" proud!', 0\nbob db '%d, %d: Bob made \"Jeff\" proud!', 0\ndraw db '%d, %d: that looks like a \"draw\"! Rock on!', 0\n; char *solve_rock_off(const int alice[], const int bob[], int count);\n; input: rdi = alice, rsi = bob, edx = count\n; output: rax\nsolve_rock_off:\n  xor ecx, ecx\n  xor edx, edx\n  mov eax, [rdi]\n  cmp eax, [rsi]\n  setg dl\n  setl cl\n  mov eax, [rdi + 4]\n  cmp eax, [rsi + 4]\n  setg al\n  setl r8b\n  add dl, al\n  add cl, r8b\n  mov eax, [rdi + 8]\n  cmp eax, [rsi + 8]\n  setg al\n  setl r8b\n  add dl, al\n  add cl, r8b\n  lea rsi, [rel draw]\n  lea rax, [rel alice]\n  cmp edx, ecx\n  cmovg rsi, rax\n  lea rax, [rel bob]\n  cmovl rsi, rax\n  push rax\n  xor eax, eax\n  mov rdi, rsp\n  call asprintf\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214235,"user_id":1315,"body":"extern malloc\nextern sprintf\nsection .text\nglobal solve_rock_off\n; char *solve_rock_off(const int alice[], const int bob[], int count);\n; input: rdi = alice, rsi = bob, rdx = count\n; output: rax\nsolve_rock_off:\n  xor  r11, r11         ; r11 := alice_score\n  xor  r12, r12         ; r12 := bob_score\n  xor  rcx, rcx         ; rcx := i = 0\nloop_start:\n  mov  eax, [rdi+4*rcx] ; eax = alice[i]\n  mov  ebx, [rsi+4*rcx] ; ebx = bob[i]\n  cmp  eax, ebx\n  jg   alice_point      ; if ( alice[i] > bob[i] )\n  jl   bob_point        ; else if ( alice[i] < bob[i] )\n  jmp  continue_loop\nalice_point:\n  inc  r11              ; alice_score++\n  jmp  continue_loop\nbob_point:\n  inc  r12              ; bob_score+++\ncontinue_loop:\n  inc  rcx              ; i++\n  cmp  rcx, rdx         ; while ( i < count )\n  jl   loop_start\n  push r12              ; save scores\n  push r11\n  mov  rdi, 100         ; allocate memory for return string\n  call malloc\n  pop  rdx              ; recover scores\n  pop  rcx\n  cmp  rdx, rcx\n  jg   alice_wins       ; if ( alice_score > bob_score )\n  jl   bob_wins         ; if ( alice_score < bob_score )\n  mov  r8, tie\n  jmp  finish\nalice_wins:\n  mov  r8, alice_victory\n  jmp  finish\nbob_wins:\n  mov  r8, bob_victory\nfinish:\n  push rax              ; save return string address\n  mov  rdi, rax\n  mov  rsi, format\n  xor  rax, rax\n  call sprintf          ; write return string\n  pop  rax              ; recover return string address\n  ret\nsection .data\nformat:        db '%d, %d: %s',0\nalice_victory: db 'Alice made \"Kurt\" proud!',0\nbob_victory:   db 'Bob made \"Jeff\" proud!',0\ntie:           db 'that looks like a \"draw\"! Rock on!',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b180e9fedaa564a7000009a":[{"id":214236,"user_id":17,"body":"SECTION .text\nglobal solve\nextern malloc, strlen, strcpy\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n  push rdi\n  call strlen\n  pop rdi\n  inc rax\n  push rdi\n  mov rdi, rax\n  call malloc\n  pop rdi\n  mov rsi, rdi\n  mov rdi, rax\n  push rax\n  call strcpy\n  pop rax\n  xor rdi, rdi\n  push rax\n.loop1:\n  cmp byte [rax], 0\n  je .loop1_end\n  cmp byte [rax], 'A'\n  jl .loop1_update\n  cmp byte [rax], 'Z'\n  jg .check_lowercase\n  inc rdi\n  jmp .loop1_update\n.check_lowercase:\n  cmp byte [rax], 'a'\n  jl .loop1_update\n  cmp byte [rax], 'z'\n  jg .loop1_update\n  dec rdi\n.loop1_update:\n  inc rax\n  jmp .loop1\n.loop1_end:\n  pop rax\n  push rax\n  cmp rdi, 0\n  jle .tolower_loop\n.toupper_loop:\n  cmp byte [rax], 0\n  je .end\n  cmp byte [rax], 'a'\n  jl .toupper_loop_update\n  cmp byte [rax], 'z'\n  jg .toupper_loop_update\n  sub byte [rax], 32\n.toupper_loop_update:\n  inc rax\n  jmp .toupper_loop\n.tolower_loop:\n  cmp byte [rax], 0\n  je .end\n  cmp byte [rax], 'A'\n  jl .tolower_loop_update\n  cmp byte [rax], 'Z'\n  jg .tolower_loop_update\n  add byte [rax], 32\n.tolower_loop_update:\n  inc rax\n  jmp .tolower_loop\n.end:\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214237,"user_id":null,"body":"SECTION .text\nglobal solve\n\nextern malloc\nextern exit\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:  \n      \n  xor ecx, ecx\n  xor edx, edx    \n  .cnt:                ;strlen      \n    xor eax, eax\n    add al, [rdi+rcx]\n    jz solve.endcnt\n    inc ecx            ;char read\n    bt eax, 5          ;is lowercase?\n    sbb eax, eax       ;-1 upper , +1 lower\n    or eax, 1\n    add edx, eax       ;edx = -upper,lower+ (balance)    \n    jmp .cnt\n  .endcnt:\n    \n  push rdi             ;save registers and align stack\n  push rdx             ;balance\n  push rcx             ;length\n  lea rdi,[ecx+1]      ;malloc(len+1)\n  call malloc\n  pop rcx              ;restore saved registers\n  pop rdx\n  pop rdi\n      \n  test ecx, ecx        ; was length 0?\n  mov rsi, rax         ; copy buffer ptr to rsi\n  jz solve.done        ; then skip the rest\n  \n  cmp edx, 0          ;dh=and dl=or  \n  mov edx, 0xFF20     ;for lower\n  jle .is_lower\n  mov edx, 0xDF00     ;for upper\n  .is_lower:\n      \n  .next:\n    mov bl, [rdi]     ;get char\n    and bl, dh        ;to upper?\n    inc rdi\n    or bl, dl         ;to lower?\n    dec ecx           ;one char read\n    mov [rsi], bl     ;save transformed char\n    lea rsi, [rsi+1]  ;point to next\n  jnz .next\n  \n  .done:\n  mov [rsi], byte 0   ;must be zero terminated\n  ret                 ;and return (eax)  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214238,"user_id":null,"body":"SECTION .text\nglobal solve\nextern strdup\nsolve:\n  call strdup\n  push rax\n  xor  rcx,rcx\n  @a:btr dword[rax],5\n     sbb rdx,rdx\n     lea rcx,[rcx+rdx*2+1]\n     inc rax \n     cmp byte[rax],0\n  jne @a\n  add rcx,rcx\n  ja @c\n    mov rax,[rsp]\n    @b:or  byte[rax],32\n       inc rax\n       cmp byte[rax],0\n    jne @b   \n  @c:\n  pop  rax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214239,"user_id":null,"body":"SECTION .text\nglobal solve\nextern malloc\n\nsolve:\n  push rbp\n  push r14\n  push rbx\n  mov rbx, rdi\n  xor r14d, r14d\n  mov rax, 1\n  xor ebp, ebp\n.countsize:\n  lea ecx, [rax - 1]\n  movzx ecx, byte [rbx + rcx]\n  test ecx, ecx\n  je .eos\n  shr ecx, 5\n  and ecx, 1\n  add ebp, ecx\n  xor ecx, 1\n  add r14d, ecx\n  inc eax\n  jmp .countsize\n.eos:\n  mov edi, eax\n  call malloc\n  mov rcx, rax\n  cmp r14d, ebp\n  jbe .upper\n.lower:\n  mov dl, [rbx]\n  test dl, dl\n  je .done\n  and dl, -33\n  mov [rcx], dl\n  inc rcx\n  inc rbx\n  jmp .lower\n.upper:\n  mov dl, [rbx]\n  test dl, dl\n  je .done\n  or dl, 32\n  mov [rcx], dl\n  inc rcx\n  inc rbx\n  jmp .upper\n.done:\n  mov byte [rcx], 0\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214240,"user_id":null,"body":"SECTION .text\nglobal solve\nextern malloc\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n    push  rdi\n    xor   rbx,rbx   ; up counter\n    xor   rdx,rdx   ; low counter\n    .loop1:\n    cmp   [rdi], byte 0\n    je    .end1\n    cmp   [rdi], byte 97\n    jge    .low\n    .up:\n    inc   rbx\n    inc   rdi\n    jmp   .loop1\n    .low:\n    inc   rdx\n    inc   rdi\n    jmp   .loop1\n    .end1:\n    push  rbx\n    push  rdx\n    add   rdx,rbx\n    mov   rdi,512\n    inc   rdi\n    call  malloc\n    pop   rdx\n    pop   rbx\n    pop   rdi\n    push  rax\n    cmp   rdx,rbx\n    jge   .looplow\n    \n    .loopup:\n    cmp   [rdi], byte 0\n    je    .end2\n    mov   r10, [rdi]\n    cmp   [rdi], byte 97\n    jl   .continue2\n    sub   r10,32\n    .continue2:\n    mov   [rax], r10\n    inc   rdi\n    inc   rax\n    jmp   .loopup\n\n    .looplow:\n    cmp   [rdi], byte 0\n    je    .end2\n    mov   r10, [rdi]\n    cmp   [rdi], byte 97\n    jge   .continue\n    add   r10, 32\n    .continue:\n    mov   [rax], r10\n    inc   rdi\n    inc   rax\n    jmp   .looplow\n    \n    .end2:\n    mov   [rax], byte 0\n    pop   rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214241,"user_id":null,"body":"SECTION .text\nglobal solve\nextern strdup\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n  push rbp\n  mov rbp, rsp\n  call strdup\n\n  xor rdx, rdx\n  xor r8, r8\n\n  mov rcx, -1\n_count_lcase:\n  inc rcx\n  cmp byte [rax + rcx], 'a'\n  jb _check_lcase_null\n  cmp byte [rax + rcx], 'z'\n  ja _check_lcase_null\n  inc rdx\n  jmp _count_lcase\n_check_lcase_null:\n  cmp byte [rax + rcx], 0\n  jne _count_lcase\n\n  mov rcx, -1\n_count_ucase:\n  inc rcx\n  cmp byte [rax + rcx], 'A'\n  jb _check_ucase_null\n  cmp byte [rax + rcx], 'Z'\n  ja _check_ucase_null\n  inc r8\n  jmp _count_ucase\n_check_ucase_null:\n  cmp byte [rax + rcx], 0\n  jne _count_ucase\n\n  ;cmp r8, 0\n  ;je _sl_end\n  cmp rdx, r8\n  jge _sl_to_lower\n  jmp _sl_to_upper\n\n\n_sl_to_lower:\n  mov rcx, -1\n_sl_to_l_loop:\n  inc rcx\n  cmp byte [rax + rcx], 0\n  je _sl_end\n  cmp byte [rax + rcx], 'A'\n  jb _sl_to_l_loop\n  cmp byte [rax + rcx], 'Z'\n  ja _sl_to_l_loop\n  add byte [rax + rcx], 0x20\n  jmp _sl_to_l_loop\n\n_sl_to_upper:\n  mov rcx, -1\n_sl_to_u_loop:\n  inc rcx\n  cmp byte [rax + rcx], 0\n  je _sl_end\n  cmp byte [rax + rcx], 'a'\n  jb _sl_to_u_loop\n  cmp byte [rax + rcx], 'z'\n  ja _sl_to_u_loop\n  sub byte [rax + rcx], 0x20\n  ja _sl_to_u_loop\n\n_sl_end:\n\n  pop rbp\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214242,"user_id":null,"body":"SECTION .text\nglobal solve\nextern malloc\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n  xor rbx, rbx\n  xor rcx, rcx\n  xor rdx, rdx\n  mov rax, rdi\n_lp:\n  cmp byte [rax], 0\n  je _endl\n  cmp byte [rax], 65\n  jl _check_lower\n  cmp byte [rax], 90\n  jg _check_lower\n  inc rbx\n  jmp _cont\n_check_lower:\n  cmp byte [rax], 97\n  jl _cont\n  cmp byte [rax], 122\n  jg _cont\n  inc rcx\n_cont:\n  inc rax\n  inc rdx\n  jmp _lp\n_endl:\n  push rdi\n  mov rdi, rdx\n  push rcx\n  call malloc\n  pop rcx\n  pop rdi\n  push rax\n  cmp rbx, rcx\n  mov rcx, rdi\n  jle _lower\n_upper:\n  mov rsi, rcx\n  mov rdi, rax\n  movsb\n  cmp byte [rcx], 0\n  je _end\n  cmp byte [rcx], 97\n  jl _endupper\n  cmp byte [rcx], 122\n  jg _endupper\n  sub byte [rax], 32\n_endupper:\n  inc rax\n  inc rcx\n  jmp _upper\n_lower:\n  mov rsi, rcx\n  mov rdi, rax\n  movsb\n  cmp byte [rcx], 0\n  je _end\n  cmp byte [rcx], 65\n  jl _endlower\n  cmp byte [rcx], 90\n  jg _endlower\n  add byte [rax], 32\n_endlower:\n  inc rax\n  inc rcx\n  jmp _lower\n_end:\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214243,"user_id":null,"body":"SECTION .text\nglobal solve\nextern malloc\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n  xor ebx, ebx ;count of lowercase\n  xor ecx, ecx ;counter\n  xor edx, edx ;count of uppercase\n.count:\n  cmp byte [edi+ecx], 0\n  je .decide\n  cmp byte [edi+ecx], 97\n  jl .upper\n  inc ebx\n  jmp .count_end\n.upper:\n  inc edx\n.count_end:\n  inc ecx\n  jmp .count\n.decide:\n  push rdi\n  push rdx\n  inc ecx\n  mov edi, ecx\n  call malloc\n  pop rdx\n  pop rdi\n  xor ecx, ecx\n  cmp ebx, edx\n  jge .lowercase\n.uppercase:\n  xor edx, edx\n  cmp byte [edi+ecx], 0\n  je .end\n  cmp byte [edi+ecx], 'Z'\n  jle .uppercase_end\n  mov dh, 32\n.uppercase_end:\n  mov bh, [edi+ecx]\n  mov [eax+ecx], bh\n  sub [eax+ecx], dh\n  inc ecx\n  jmp .uppercase\n.lowercase:\n  xor edx, edx\n  cmp byte [edi+ecx], 0\n  je .end\n  cmp byte [edi+ecx], 'a'\n  jge .lowercase_end\n  mov dh, 32\n.lowercase_end:\n  mov bh, [edi+ecx]\n  mov [eax+ecx], bh\n  add [eax+ecx], dh\n  inc ecx\n  jmp .lowercase\n.end:\n  mov byte [eax+ecx], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214244,"user_id":null,"body":"SECTION .text\nglobal solve\nextern malloc, strlen, strcpy\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n  push rdi\n  call strlen\n  pop rdi\n  inc rax\n  push rdi\n  mov rdi, rax\n  call malloc\n  pop rdi\n  mov rsi, rdi\n  mov rdi, rax\n  push rax\n  call strcpy\n  pop rax\n  xor rdi, rdi\n  push rax\n.loop:\n  cmp byte [rax], 0\n  je .loop1_end\n  cmp byte [rax], 'A'\n  jl .loop1_update\n  cmp byte [rax], 'Z'\n  jg .check_lowercase\n  inc rdi\n  jmp .loop1_update\n.check_lowercase:\n  cmp byte [rax], 'a'\n  jl .loop1_update\n  cmp byte [rax], 'z'\n  jg .loop1_update\n  dec rdi\n.loop1_update:\n  inc rax\n  jmp .loop\n.loop1_end:\n  pop rax\n  push rax\n  cmp rdi, 0\n  jle .tolower_loop\n.toupper_loop:\n  cmp byte [rax], 0\n  je .end\n  cmp byte [rax], 'a'\n  jl .toupper_loop_update\n  cmp byte [rax], 'z'\n  jg .toupper_loop_update\n  sub byte [rax], 32\n.toupper_loop_update:\n  inc rax\n  jmp .toupper_loop\n.tolower_loop:\n  cmp byte [rax], 0\n  je .end\n  cmp byte [rax], 'A'\n  jl .tolower_loop_update\n  cmp byte [rax], 'Z'\n  jg .tolower_loop_update\n  add byte [rax], 32\n.tolower_loop_update:\n  inc rax\n  jmp .tolower_loop\n.end:\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214245,"user_id":null,"body":"SECTION .text\nglobal solve\nextern malloc, strlen, strcpy\n\n; Returns pointer to new string, the value of which is defined by the description\n; NOTE: Please allocate the memory for the new string using C's malloc\n; arg0         = (const char*) original string\n; return value = (char*)       new string\nsolve:\n  push rdi\n  call strlen\n  lea rdi, [rax+1]\n  call malloc\n  pop rsi         ; this gets original pushed rdi value; now rsi = source string, rdi = dest string  for strcpy \n  mov rdi, rax\n  push rax\n  call strcpy\n  pop rax         ; rax is base of new output string  - this remains unmodified hereafter     \n  xor edi, edi    ; this will count number of upper\/lower case chars\n  xor esi, esi    ; this is offset from rax\n  xor edx, edx    ; this is used to detect lower or upper case characters\n  \n.loop:\n  mov bl, [rax+rsi]\n  test bl, bl     ; exit at zero char\n  jz .done\n  cmp bl, 'a'\n  setge cl\n  cmp bl, 'z'\n  setg dl\n  xor dl, cl      ; dl = 1 if bl is a lower case char\n  add edi, edx    ; inc count if lower case\n  cmp bl, 'A'\n  setge cl\n  cmp bl, 'Z'\n  setg dl\n  xor dl, cl      ; dl = 1 if bl is an upper case char\n  sub edi, edx    ; dec count if upper case\n  inc esi         ; count up through the string\n  jmp .loop\n  \n.done:\n  dec esi         ; point to last character in string\n  js .exit\n  test edi, edi\n  js .toupper     ; convert to upper only if n(upper) > n(lower)\n  \n.tolower:\n  or byte [rax+rsi], 32     ; make lower case\n  dec esi                   ; and count back down through the string\n  jns .tolower\n  jmp .exit\n  \n.toupper:\n  and byte [rax+rsi], ~32   ; make upper case\n  dec esi                   ; and count back down through the string\n  jns .toupper\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b24bcecd74b5be066000054":[{"id":214246,"user_id":null,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern malloc, free\nsection .text\n; <----- void stack_push(Stack *stack, int data) ----->\nstack_push:\n  push rdi            ; saving the pointer to <stack>\n  push rsi            ; saving <data>\n  mov edi, 16         ; setting the Node size\n  call malloc\n  cmp rax, 0          ; checking whether memory allocated\n  je .exit\n  pop rdx             ; restoring <data>\n  mov [rax], rdx      ; saving in the allocated node\n  pop rdi             ; restoring <stack>\n  mov rdx, [rdi]      ; the pointer to <root>\n  mov [rax+8], rdx    ; saving <root> in the allocated <next>\n  mov [rdi], rax      ; setting <next> as new <root>\n.exit:\n  ret\n; ---------> end of push <---------\n\n; <----- int stack_pop(Stack *stack) ----->\nstack_pop:\n  mov rdx, [rdi]      ; getting the pointer to <root>\n  push qword [rdx]    ; saving <data>\n  mov rdx, [rdx+8]    ; getting the pointer to <next>\n  push rdx            ; saving <next>\n  push rdi            ; saving <stack>\n  mov rdi, [rdi]      ; the pointer to remove <root>\n  call free\n  pop rdi             ; restoring <stack>\n  pop rdx             ; restoring <next>\n  mov [rdi], rdx      ; setting <next> as new <root>\n  pop rax             ; restoring <data> to return\n  ret\n; ---------> end of pop <---------\n\n; <----- int stack_peek(const Stack *stack) ----->\nstack_peek:\n  mov rdx, [rdi]      ; getting the pointer to <root>\n  mov rax, [rdx]      ; getting <data> to return\n  ret\n; ---------> end of peek <---------\n\n; <----- bool stack_is_empty(const Stack *stack) ----->\nstack_is_empty:\n  xor rax, rax        ; resetting RAX  \n  cmp qword [rdi], 0  ; checking whether the pointer to <root> is set to null\n  jne .exit\n  inc rax             ; otherwise, setting as true to return\n.exit:\n  ret\n; ---------> end of is_empty <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214247,"user_id":17,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern malloc, free\nsection .text\nstack_push:\n  push rdi\n  push rsi\n  mov rdi, 16\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov dword [rax + 4], 0\n  mov rdx, qword [rdi]\n  mov qword [rax + 8], rdx\n  mov qword [rdi], rax\n  ret\nstack_pop:\n  mov rsi, qword [rdi]\n  xor rax, rax\n  mov eax, dword [rsi]\n  push rax\n  push rdi\n  mov rdx, qword [rsi + 8]\n  push rdx\n  mov rdi, rsi\n  call free\n  pop rdx\n  pop rdi\n  pop rax\n  mov qword [rdi], rdx\n  ret\nstack_peek:\n  mov rsi, qword [rdi]\n  xor rax, rax\n  mov eax, dword [rsi]\n  ret\nstack_is_empty:\n  cmp qword [rdi], 0\n  je .is_empty\n  xor rax, rax\n  ret\n.is_empty:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214248,"user_id":168,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern malloc, free\nsection .text\nstack_push:\n  push rbx\n  push rdi\n  push rsi\n  mov rbx, [rdi]\n  mov rdi, 16\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov [rax + 8], rbx\n  mov [rdi], rax\n  pop rbx\n  ret\nstack_pop:\n  mov rdx, [rdi]\n  push qword [rdx]\n  mov rax, [rdx + 8]\n  mov [rdi], rax\n  mov rdi, rdx\n  call free\n  pop rax\n  ret\nstack_peek:\n  mov rdx, [rdi]\n  mov eax, dword [rdx]\n  ret\nstack_is_empty:\n  mov rax, [rdi]\n  test rax, rax\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214249,"user_id":null,"body":"extern malloc,free\nglobal stack_push, stack_pop, stack_peek, stack_is_empty\nsection .text\nstack_push:\n  push rbp\n  push rbx\n  push rax\n  mov ebp, esi\n  mov rbx, rdi\n  mov edi, 16\n  call malloc\n  mov [rax], ebp\n  mov rcx, [rbx]\n  mov [rax + 8], rcx\n  mov [rbx], rax\n  add rsp, 8\n  pop rbx\n  pop rbp\n  ret\n\nstack_pop:\n  push rbp\n  push r14\n  push rbx\n  mov rbx, rdi\n  mov rdi, [rdi]\n  mov r14d, [rdi]\n  mov rbp, [rdi + 8]\n  call free\n  mov [rbx], rbp\n  mov eax, r14d\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n\nstack_peek:\n  mov rax, [rdi]\n  mov eax, [rax]\n  ret\n\nstack_is_empty:\n  cmp qword [rdi], 0\n  sete al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214250,"user_id":null,"body":"struc node\n.data: resd 1\nalignb 8\n.next: resq 1\nendstruc\n\nglobal stack_push, stack_pop, stack_peek, stack_is_empty\nextern malloc, free\nsection .text\nstack_push:\n  push rdi\n  push rsi\n  push rbp\n  mov rdi, node_size\n  call malloc\n  pop rbp\n  pop rsi\n  pop rdi\n  test rax, rax\n  jz .fail\n  \n  mov [rax+node.data], esi\n  mov rdx, [rdi]\n  mov [rax+node.next], rdx\n  mov [rdi], rax\n.fail:  \n  ret\n\nstack_pop:\n  mov rsi, rdi\n  mov rdi, [rdi]\n  mov eax, [rdi+node.data]\n  push rax\n  mov rax, [rdi+node.next]\n  mov [rsi], rax\n  call free\n  pop rax\n  ret\n  \nstack_peek:\n  mov rdi, [rdi]\n  mov eax, [rdi+node.data]\n  ret\n  \nstack_is_empty:\n  xor eax, eax\n  cmp qword [rdi], 0\n  setz al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214251,"user_id":null,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\n\nextern malloc, free\nextern printf\n\nsection .data\n  fmt db 'inside push: [ %d ]', 10, 0\n  fmtp db 'inside push: [ %p ]', 10, 0\n\nsection .text\n\nstack_push:\n.allocate:\n  push rdi\n  push rsi\n  mov rdi, 16\n  call malloc\n  pop rsi\n  pop rdi\n  \n  mov qword [rax], rsi\n  mov qword [rax + 8], 0\n  mov rcx, [rdi]\n  test rcx, rcx\n  jz .exit\n  mov qword [rax + 8], rcx\n  \n.exit:\n  mov qword [rdi], rax\n  ret\n  \nstack_pop:\n  mov rdx, qword [rdi]\n  mov rax, qword [rdx]\n  \n  mov rcx, qword [rdx + 8]\n  test rcx, rcx\n  jz .exit\n  \n  push rcx\n  push rdi\n  push rax\n  mov rdi, rdx\n  call free\n  pop rax\n  pop rdi\n  pop rcx\n   \n.exit:\n  mov qword [rdi], rcx\n  ret\n  \nstack_peek:\n  mov rdx, qword [rdi]\n  mov rax, qword [rdx]\n  ret\n  \nstack_is_empty:\n  xor rax, rax\n  lea rdx, [rdi]\n  cmp qword [rdx], 0\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214252,"user_id":77,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern malloc, free\nsection .text\nstack_push:\n  push rdi\n  push rsi\n  mov rdi, 16\n  call malloc\n  pop qword [rax]\n  pop rbx\n  mov rcx, [rbx]\n  mov [rax+8], rcx\n  mov [rbx], rax\n  ret\nstack_pop:\n  mov rbx, [rdi]\n  mov rdx, [rbx+8]\n  mov rax, [rbx]\n  mov [rdi], rdx\n  push rax\n  mov rdi, rbx\n  call free\n  pop rax\n  ret\nstack_peek:\n  mov rbx, [rdi]\n  mov rax, [rbx]\n  ret\nstack_is_empty:\n  xor rax, rax\n  cmp qword [rdi], 0\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214253,"user_id":null,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern malloc\n\nsection .text\n%define stack_ptr rdi\n%define in_data   esi\n%define node_ptr  r11\n\nstack_push:\n  \n  push rdi\n  push rsi\n  mov rdi, 12\n  call malloc\n  pop rsi\n  pop rdi\n  \n  mov node_ptr, [stack_ptr]\n  \n  mov [rax], esi ; set data\n  mov [rax + 4], node_ptr ; set \"prev\" to old node\n  mov [stack_ptr], rax\n  \n  ret\n  \nstack_pop:\n  mov node_ptr, [stack_ptr]\n  mov eax, [node_ptr]\n  mov rdx, [node_ptr + 4]\n  \n  mov [stack_ptr], rdx\n  \n  ret\n  \nstack_peek:\n  mov node_ptr, [stack_ptr]\n  mov eax, [node_ptr]\n  ret\n  \nstack_is_empty:\n  xor rax, rax\n  mov node_ptr, [stack_ptr]\n  cmp node_ptr, 0\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214254,"user_id":527,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern free, malloc\nsection .text\n\nstack_push:\n                push    rdi\n                push    qword [rdi]\n                push    rsi\n                mov     edi, 16\n                call    malloc\n                pop     qword [rax]\n                pop     qword [rax + 8]\n                pop     rdi\n                mov     [rdi], rax\n                ret\n\nstack_pop:\n                mov     rax, [rdi]\n                mov     rdx, [rax + 8]\n                mov     [rdi], rdx\n                push    qword [rax]\n                mov     rdi, rax\n                call    free\n                pop     rax\n                ret\n\nstack_peek:\n                mov     rax, [rdi]\n                mov     eax, [rax]\n                ret\n\nstack_is_empty:\n                cmp     qword [rdi], 0\n                sete    al\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214255,"user_id":null,"body":"global stack_push, stack_pop, stack_peek, stack_is_empty\nextern abort, calloc, free\nsection .text\nstack_push:\n  push rdi\n  push rsi\n  mov rdi, 1\n  mov rsi, 16\n  call calloc\n  test rax, rax\n  je .oom\n  pop rsi\n  pop rdi\n  \n  mov dword [rax], esi\n  mov rdx, qword [rdi]\n  mov qword [rax+8], rdx\n  mov qword [rdi], rax\n  ret\n.oom:\n  call abort\n  \nstack_pop:\n  mov rsi, qword [rdi]\n  mov eax, dword [rsi]\n  mov rdx, qword [rsi+8]\n  \n  push rax\n  mov qword [rdi], rdx\n  mov rdi, rsi\n  call free\n  pop rax\n  ret\n  \nstack_peek:\n  mov rsi, qword [rdi]\n  mov eax, dword [rsi]\n  ret\n  \nstack_is_empty:\n  xor rax, rax\n  mov rdi, qword [rdi]\n  mov rsi, 1\n  test rdi, rdi\n  cmovz rax, rsi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b26360bd74b5b2ea5000026":[{"id":214256,"user_id":null,"body":"global queue_enqueue, queue_dequeue\nglobal queue_front, queue_is_empty\nextern malloc, free\n\nsection .text\n\n; <----- Node *queue_enqueue(Queue *queue, int data) ----->\nqueue_enqueue:\n    test rdi, rdi           ; if the passed <queue> is NULL\n    je .exit                ; then jumping to exit\n    push rdi                ; saving <queue>\n    push rsi                ; saving <data>\n    sub rsp, 8              ; aligning the stack\n    mov rdi, 16             ; the size of Node\n    call malloc             ; allocating memory for <node>\n    add rsp, 8              ; restoring the stack boundary\n    pop rsi                 ; restoring <data>\n    pop rdi                 ; restoring <queue>\n    test rax, rax           ; if failed to allocate memory\n    je .exit                ; then jumping to exit\n    mov [rax], rsi          ; saving <data> in <node>\n    mov qword [rax+8], 0    ; setting <next> to NULL\n    cmp qword [rdi], 0      ; whether <front> is NULL\n    je .empty\n    mov rdx, [rdi+8]        ; the pointer to <back>\n    mov [rdx+8], rax        ; saving <node> as <next>\n    jmp .tail\n.empty:\n    mov [rdi], rax          ; saving <node> as new <front>\n.tail:\n    mov [rdi+8], rax        ; saving <node> as new <back>\n.exit:\n    ret\n; ---------> end of enqueue <---------\n\n; <----- int queue_dequeue(Queue *queue) ----->\nqueue_dequeue:\n    xor rax, rax            ; resetting RAX\n    test rdi, rdi           ; whether <queue> is NULL\n    je .exit\n    mov rax, [rdi]          ; coppying <front>\n    test rax, rax           ; whether <front> is NULL\n    je .exit\n    mov rdx, [rax+8]        ; getting the pointer to <next>\n    mov [rdi], rdx          ; setting <next> as new <front>\n    push qword [rax]        ; saving <data> in the stack\n    mov rdi, rax            ; the node to delete\n    call free\n    pop rax                 ; restoring <data>\n.exit:\n    ret\n; ---------> end of dequeue <---------\n\n; <----- int queue_front(const Queue *queue) ----->\nqueue_front:\n    xor rax, rax            ; resetting RAX\n    test rdi, rdi           ; whether <queue> is NULL\n    je .exit\n    cmp qword [rdi], 0      ; whether <front> is not NULL\n    cmovne rax, [rdi]       ; getting the pointer to <front>\n    je .exit                ; otherwise, jumping to exit\n    cmovne rax, [rax]       ; coppying <data> to return\n.exit:\n    ret\n; ---------> end of front <---------\n\n; <----- int queue_is_empty(const Queue *queue) ----->\nqueue_is_empty:\n    xor rax, rax            ; resetting RAX\n    test rdi, rdi           ; whether <queue> is NULL\n    sete al                 ; setting to true\n    je .exit                ; jumping to exit in case <queue> is NULL\n    cmp qword [rdi], 0      ; whether <front> is NULL\n    setz al                 ; setting to true\n.exit:\n    ret\n; ---------> is_empty <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214257,"user_id":17,"body":"global queue_enqueue, queue_dequeue, queue_front, queue_is_empty\nextern malloc, free\nsection .text\nqueue_enqueue:\n  push rdi\n  push rsi\n  mov rdi, 16\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov dword [rax + 4], 0\n  mov qword [rax + 8], 0\n  cmp qword [rdi + 8], 0\n  je .enqueue_first_item\n  mov rdx, qword [rdi + 8]\n  mov qword [rdx + 8], rax\n  mov qword [rdi + 8], rax\n  ret\n.enqueue_first_item:\n  mov qword [rdi], rax\n  mov qword [rdi + 8], rax\n  ret\nqueue_dequeue:\n  mov rsi, qword [rdi]\n  xor rax, rax\n  mov eax, dword [rsi]\n  cmp rsi, qword [rdi + 8]\n  je .dequeue_last_item\n  push rax\n  push rdi\n  mov rdx, qword [rsi + 8]\n  push rdx\n  mov rdi, rsi\n  call free\n  pop rdx\n  pop rdi\n  pop rax\n  mov qword [rdi], rdx\n  ret\n.dequeue_last_item:\n  push rax\n  push rdi\n  mov rdi, rsi\n  call free\n  pop rdi\n  pop rax\n  mov qword [rdi], 0\n  mov qword [rdi + 8], 0\n  ret\nqueue_front:\n  mov rsi, qword [rdi]\n  xor rax, rax\n  mov eax, dword [rsi]\n  ret\nqueue_is_empty:\n  cmp qword [rdi], 0\n  je .is_empty\n  xor rax, rax\n  ret\n.is_empty:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214258,"user_id":null,"body":"extern malloc,free\nglobal queue_enqueue, queue_dequeue, queue_front, queue_is_empty\nsection .text\nqueue_enqueue:\n  push rbp\n  push rbx\n  push rax\n  mov ebp, esi\n  mov rbx, rdi\n  mov edi, 16\n  call malloc\n  mov [rax], ebp\n  mov qword [rax + 8], 0\n  mov rcx, [rbx + 8]\n  lea rdx, [rcx + 8]\n  test rcx, rcx\n  cmove rdx, rbx\n  mov [rdx], rax\n  mov [rbx + 8], rax\n  add rsp, 8\n  pop rbx\n  pop rbp\n  ret\n  \nqueue_dequeue:\n  push rbp\n  push r14\n  push rbx\n  mov rbx, rdi\n  mov rdi, [rdi]\n  mov r14d, [rdi]\n  mov rbp, [rdi + 8]\n  call free\n  mov [rbx], rbp\n  test rbp, rbp\n  jne .empty\n  mov qword [rbx + 8], 0\n.empty:\n  mov eax, r14d\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n  \nqueue_front:\n  mov rax, [rdi]\n  mov eax, [rax]\n  ret\n  \nqueue_is_empty:\n  cmp qword [rdi], 0\n  je .nofront\n  xor eax, eax\n  ret\n.nofront:\n  cmp qword [rdi + 8], 0\n  sete al\n  ret\n  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214259,"user_id":null,"body":"struc node\n.data: resd 1\nalignb 8\n.next: resq 1\nendstruc\n\nstruc queue\n.front: resq 1\n.back: resq 1\nendstruc\n\nglobal queue_enqueue, queue_dequeue, queue_front, queue_is_empty\nextern malloc, free\nsection .text\n\nqueue_enqueue:\n  push rdi\n  push rsi\n  push rbp\n  mov rdi, node_size\n  call malloc\n  pop rbp\n  pop rsi\n  pop rdi\n  test rax, rax\n  jz .quit\n  \n  mov [rax+node.data], esi\n  mov qword [rax+node.next], 0\n  mov rdx, [rdi+queue.back]\n  mov [rdi+queue.back], rax\n  test rdx, rdx\n  jz .firstitem\n  mov [rdx+node.next], rax\n  ret\n  \n.firstitem:\n  mov [rdi+queue.front], rax\n.quit:\n  ret\n\nqueue_dequeue:\n  mov rdx, [rdi+queue.front]\n  mov eax, [rdx+node.data]\n  push rax\n  cmp rdx, [rdi+queue.back]\n  je .lastitem\n  mov rcx, [rdx+node.next]\n  mov [rdi+queue.front], rcx\n  jmp .next\n  \n.lastitem:\n  mov qword [rdi+queue.front], 0\n  mov qword [rdi+queue.back], 0\n\n.next:\n  mov rdi, rdx\n  call free\n  pop rax\n  ret\n\nqueue_front:\n  mov rdx, [rdi+queue.front]\n  mov eax, [rdx+node.data]\n  ret\n\nqueue_is_empty:\n  xor eax, eax\n  cmp qword [rdi+queue.front], 0\n  setz al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214260,"user_id":null,"body":"extern malloc, free\n\nglobal queue_enqueue, queue_dequeue, queue_front, queue_is_empty\n\nsection .text\n\nqueue_enqueue:\n  push rdi\n  push rsi\n  mov rdi, 16\n  call malloc\n  pop rsi\n  pop rdi\n  \n  mov qword [rax], rsi\n  mov qword [rax + 8], 0\n  cmp qword [rdi], 0\n  jz .empty_queue\n  \n  mov rdx, qword [rdi + 8]\n  mov qword [rdi + 8], rax\n  test rdx, rdx\n  jz .empty_back\n  mov qword [rdx + 8], rax\n  mov rax, rdx\n  ret\n  \n.empty_back:\n  mov rcx, qword [rdi]\n  mov qword [rcx + 8], rax\n  ret\n  \n.empty_queue:\n  mov [rdi], rax\n  ret \n  \nqueue_dequeue:\n  mov rcx, qword [rdi]\n  mov rax, qword [rcx]\n  mov rdx, qword [rcx + 8]\n  \n  push rax\n  push rdx\n  push rdi\n  mov rdi, rcx\n  call free\n  pop rdi\n  pop rdx\n  pop rax\n  \n  ; todo\n  mov qword [rdi], rdx\n  ret \n  \nqueue_front:\n  mov rcx, qword [rdi]\n  mov rax, qword [rcx]\n  ret \n  \nqueue_is_empty:\n  xor rax, rax\n  cmp qword [rdi], 0\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214261,"user_id":null,"body":"global queue_enqueue, queue_dequeue, queue_front, queue_is_empty\nextern calloc, free\n\nstruc node\n  .data resd 1\n        alignb 4\n  .next resq 1\nendstruc\n\nnode_sz equ 0x10\n\nstruc queue\n  .front resq 1\n  .back  resq 1\nendstruc\n\nsection .text\nqueue_enqueue:\n  push rbp\n  mov rbp, rsp\n  \n  ; Allocate memory for a Node.\n  push rdi\n  push rsi\n  \n  mov rdi, node_sz\n  mov rsi, 0x01\n  call calloc\n  \n  pop rsi\n  pop rdi\n  \n  ; Set .data in Node.\n  mov [rax + node.data], rsi \n  \ncheck_queue:\n  push rax\n  call queue_is_empty\n  \n  test al, al\n  pop rax\n  jz nonempty_queue_enqueue\n  \nempty_queue_enqueue:\n  ; Update .front and .back in Queue.\n  mov [rdi + queue.front], rax\n  mov [rdi + queue.back], rax\n  \n  jmp queue_enqueue_done\n  \nnonempty_queue_enqueue:\n  ; Update .next field from .back in Queue.\n  mov rdx, [rdi + queue.back]\n  mov [rdx + node.next], rax\n  \n  ; Update the .back field in Queue.\n  mov [rdi + queue.back], rax\n  \nqueue_enqueue_done:\n  mov rsp, rbp\n  pop rbp\n  \n  ret\n\nqueue_dequeue:\n  push rbp\n  mov rbp, rsp\n  \n  ; Save the value to be returned\n  mov rax, [rdi + queue.front]\n  mov rax, [rax + node.data]\n  push rax\n  \n  ; Save the pointer to be free'd on stack.\n  push qword [rdi]\n  \n  ; Move .front pointer to the second element.\n  mov rax, [rdi + queue.front]\n  mov rax, [rax + node.next]\n  mov [rdi + queue.front], rax\n  \n  ; If queue becomes empty then update .back too.\n  call queue_is_empty\n  test al, al\n  jz update_back_done\n  \nupdate_back:\n  mov qword [rdi + queue.back], 0x00\n  \nupdate_back_done:\n  \n  ; Free the Node.\n  pop rdi\n  call free\n  \n  ; Return value is placed in <RAX>.\n  pop rax\n  \n  mov rsp, rbp\n  pop rbp\n  \n  ret\n  \nqueue_front:\n  mov rax, [rdi + queue.front]\n  mov rax, [rax + node.data]\n  \n  ret\n  \nqueue_is_empty:\n  mov rax, [rdi + queue.front]\n  test rax, rax\n  sete al\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214262,"user_id":168,"body":"global queue_enqueue, queue_dequeue, queue_front, queue_is_empty\nextern malloc, free\nsection .text\nqueue_enqueue:\n  push rbx\n  push rdi\n  push rsi\n  mov rbx, [rdi + 8]\n  mov rdi, 16\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov qword [rax + 8], 0\n  test rbx, rbx\n  jz .empty\n  mov [rbx + 8], rax\n  mov [rdi + 8], rax\n  pop rbx\n  ret\n.empty:\n  mov [rdi], rax\n  mov [rdi + 8], rax\n  pop rbx\n  ret\nqueue_dequeue:\n  mov rdx, [rdi]\n  push qword [rdx]\n  mov rax, [rdx + 8]\n  mov [rdi], rax\n  test rax, rax\n  jnz .continue\n  mov [rdi + 8], rax\n.continue:\n  mov rdi, rdx\n  call free\n  pop rax\n  ret\nqueue_front:\n  mov rdx, [rdi]\n  mov eax, dword [rdx]\n  ret\nqueue_is_empty:\n  cmp qword [rdi], 0\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b2771fab6989dd87d0000f1":[{"id":214263,"user_id":17,"body":"global deque_push_front, deque_pop_front, deque_peek_front, deque_push_back, deque_pop_back, deque_peek_back, deque_is_empty\nextern malloc, free\nsection .text\ndeque_push_front:\n  push rdi\n  push rsi\n  mov rdi, 24\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov dword [rax + 4], 0\n  mov qword [rax + 8], 0\n  cmp qword [rdi], 0\n  je .push_front_first_item\n  mov rdx, qword [rdi]\n  mov qword [rax + 16], rdx\n  mov qword [rdx + 8], rax\n  mov qword [rdi], rax\n  ret\n.push_front_first_item:\n  mov qword [rax + 16], 0\n  mov qword [rdi], rax\n  mov qword [rdi + 8], rax\n  ret\ndeque_pop_front:\n  mov rsi, qword [rdi]\n  xor rax, rax\n  mov eax, dword [rsi]\n  cmp rsi, qword [rdi + 8]\n  je .pop_front_last_item\n  mov rdx, qword [rsi + 16]\n  push rax\n  push rdi\n  push rdx\n  mov rdi, rsi\n  call free\n  pop rdx\n  pop rdi\n  pop rax\n  mov qword [rdi], rdx\n  mov qword [rdx + 8], 0\n  ret\n.pop_front_last_item:\n  push rax\n  push rdi\n  mov rdi, rsi\n  call free\n  pop rdi\n  pop rax\n  mov qword [rdi], 0\n  mov qword [rdi + 8], 0\n  ret\ndeque_peek_front:\n  mov rsi, qword [rdi]\n  xor rax, rax\n  mov eax, dword [rsi]\n  ret\ndeque_push_back:\n  push rdi\n  push rsi\n  mov rdi, 24\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov dword [rax + 4], 0\n  mov qword [rax + 16], 0\n  cmp qword [rdi + 8], 0\n  je .push_back_first_item\n  mov rdx, qword [rdi + 8]\n  mov qword [rax + 8], rdx\n  mov qword [rdx + 16], rax\n  mov qword [rdi + 8], rax\n  ret\n.push_back_first_item:\n  mov qword [rax + 8], 0\n  mov qword [rdi + 8], rax\n  mov qword [rdi], rax\n  ret\ndeque_pop_back:\n  mov rsi, qword [rdi + 8]\n  xor rax, rax\n  mov eax, dword [rsi]\n  cmp rsi, qword [rdi]\n  je .pop_back_last_item\n  mov rdx, qword [rsi + 8]\n  push rax\n  push rdi\n  push rdx\n  mov rdi, rsi\n  call free\n  pop rdx\n  pop rdi\n  pop rax\n  mov qword [rdi + 8], rdx\n  mov qword [rdx + 16], 0\n  ret\n.pop_back_last_item:\n  push rax\n  push rdi\n  mov rdi, rsi\n  call free\n  pop rdi\n  pop rax\n  mov qword [rdi + 8], 0\n  mov qword [rdi], 0\n  ret\ndeque_peek_back:\n  mov rsi, qword [rdi + 8]\n  xor rax, rax\n  mov eax, dword [rsi]\n  ret\ndeque_is_empty:\n  cmp qword [rdi], 0\n  je .is_empty\n  xor rax, rax\n  ret\n.is_empty:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214264,"user_id":null,"body":"global deque_push_front, deque_pop_front, deque_peek_front, deque_push_back, deque_pop_back, deque_peek_back, deque_is_empty\nextern malloc, free\n\nsection .text\ndeque_push_front:\n  push rbp\n  push rbx\n  push rax\n  mov ebp, esi\n  mov rbx, rdi\n  mov edi, 24\n  call malloc\n  mov [rax], ebp\n  mov qword [rax + 8], 0\n  mov rcx, [rbx]\n  test rcx, rcx\n  je .nofront\n  mov [rcx + 8], rax\n.nofront:\n  mov [rax + 16], rcx\n  mov [rbx], rax\n  cmp qword [rbx + 8], 0\n  jne .hasback\n  mov [rbx + 8], rax\n.hasback:\n  add rsp, 8\n  pop rbx\n  pop rbp\n  ret\n\ndeque_pop_front:\n  push rbp\n  push r14\n  push rbx\n  mov rbx, rdi\n  mov rdi, [rdi]\n  mov ebp, [rdi]\n  cmp rdi, [rbx + 8]\n  je .notempty\n  mov r14, [rdi + 16]\n  call free\n  mov [rbx], r14\n  jmp .done\n.notempty:\n  call free\n  vxorps xmm0, xmm0, xmm0\n  vmovups [rbx], xmm0\n.done:\n  mov eax, ebp\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n\ndeque_peek_front:\n  mov rax, qword [rdi]\n  mov eax, dword [rax]\n  ret\n\ndeque_push_back:\n  push rbp\n  push rbx\n  push rax\n  mov ebp, esi\n  mov rbx, rdi\n  mov edi, 24\n  call malloc\n  mov [rax], ebp\n  mov rcx, qword [rbx + 8]\n  mov [rax + 8], rcx\n  mov qword [rax + 16], 0\n  test rcx, rcx\n  je .noback\n  mov [rcx + 16], rax\n.noback:\n  mov [rbx + 8], rax\n  cmp qword [rbx], 0\n  jne .hasfront\n  mov [rbx], rax\n.hasfront:\n  add rsp, 8\n  pop rbx\n  pop rbp\n  ret\n\ndeque_pop_back:\n  push rbp\n  push r14\n  push rbx\n  mov rbx, rdi\n  mov rdi, [rdi + 8]\n  mov r14d, [rdi]\n  cmp [rbx], rdi\n  je .notempty\n  mov rbp, [rdi + 8]\n  call free\n  jmp .done\n.notempty:\n  call free\n  mov qword [rbx], 0\n  xor ebp, ebp\n.done:\n  mov [rbx + 8], rbp\n  mov eax, r14d\n  pop rbx\n  pop r14\n  pop rbp\n  ret\n\ndeque_peek_back:\n  mov rax, [rdi + 8]\n  mov eax, [rax]\n  ret\n\ndeque_is_empty:\n  cmp qword [rdi], 0\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214265,"user_id":null,"body":"global deque_push_front, deque_pop_front\nglobal deque_push_back, deque_pop_back\nglobal deque_peek_front, deque_peek_back, deque_is_empty\nextern malloc, free\n\nsection .text\n\n; <----- Node *deque_push_front(Deque *deque, int data) ----->\ndeque_push_front:\n    xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi           ; whether <deque> is NULL\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  push rdi\t\t\t\t        ; saving <deque>\n\t  push rsi\t\t\t\t        ; saving <data>\n\t  sub rsp, 8\t\t\t\t      ; aligning the stack\n  \tmov rdi, 24\t\t\t\t      ; the size for <node> considering alignment \n\t  call malloc\t\t\t\t      ; allocating memory for <node>\n\t  add rsp, 8\t\t\t\t      ; restoring the stack boundary\n\t  pop rsi\t\t\t\t\t        ; restoring <data>\n\t  pop rdi\t\t \t\t\t        ; restoring <deque>\n\t  test rax, rax\t\t\t      ; if failed to allocate memory\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  mov [rax], rsi\t\t\t    ; saving <data> in <node>\n\t  mov qword [rax+8], 0\t  ; setting <prev> to NULL\n\t  cmp qword [rdi], 0\t\t  ; whether <front> is NULL\n\t  je .empty\n\t  mov rdx, [rdi]\t\t\t    ; the pointer to <front>\n\t  mov [rdx+8], rax\t\t    ; setting <front->prev> to <node>\n\t  mov [rax+16], rdx\t\t    ; setting <node->next> to <front>\n\t  jmp .setfront\n.empty:\n\t  mov qword [rax+16], 0\t  ; resetting <node->next>\n\t  mov [rdi+8], rax\t\t    ; setting <back> to <node>\n.setfront:\n\t  mov [rdi], rax\t\t\t    ; saving <node> as new <front>\n.exit:\n\t  ret\n; ---------> end of push_front <---------\n\n; <----- int deque_pop_front(Deque *deque) ----->\ndeque_pop_front:\n\t  xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi\t\t\t      ; if the passed <deque> is NULL\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  mov rax, [rdi]\t\t\t    ; the pointer to <front>\n\t  test rax, rax\t\t\t      ; if <front> is NULL\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  push qword [rax]\t\t    ; saving <data> in the stack\n\t  mov rdx, [rax+16]\t\t    ; the pointer to <next>\n\t  mov [rdi], rdx\t\t\t    ; saving <next> as new <front>\n\t  test rdx, rdx\t\t\t      ; whether <next> is not NULL\n\t  je .empty\n\t  mov qword [rdx+8], 0\t  ; setting <front->prev> to NULL\n\t  jmp .free\n.empty:\n\t  mov qword [rdi+8], 0\t  ; setting <back> to NULL\n.free:\n\t  mov rdi, rax\t\t\t      ; the node to delete\n\t  call free\n\t  pop rax\t\t\t\t\t        ; restoring <data>\t\n.exit:\n\t  ret\n; ---------> end of pop_front <---------\n\n; <----- int deque_peek_front(const Deque *deque) ----->\ndeque_peek_front:\n\t  xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi\t\t\t      ; whether <deque> is NULL\n\t  je .exit\n\t  cmp qword [rdi], 0\t\t  ; whether <front> is not NULL\n\t  cmovne rax, [rdi]\t\t    ; getting the pointer to <front>\n    je .exit                ; jumping to exit if <front> is NULL\n\t  cmovne rax, [rax]\t\t    ; coppying <data> to return\n.exit:\n\t  ret\n; ---------> end of peek_front <---------\n\n; <----- Node *deque_push_back(Deque *deque, int data) ----->\ndeque_push_back:\n\t  xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi\t\t\t      ; whether <deque> is NULL\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  push rdi\t\t\t\t        ; saving <deque>\n\t  push rsi\t\t\t\t        ; saving <data>\n\t  sub rsp, 8\t\t\t\t      ; aligning the stack\n\t  mov rdi, 24\t\t\t\t      ; the size to allocate bytes for <node> considering alignment\n\t  call malloc\t\t\t\t      ; allocating memory\n\t  add rsp, 8\t\t\t\t      ; restoring the stack boundary\n\t  pop rsi\t\t\t\t\t        ; restoring <data>\n\t  pop rdi\t\t\t\t\t        ; restoring <deque>\n\t  test rax, rax\t\t\t      ; whether <node> is allocated\n\t  je .exit\t\t\t\t        ; jumping to exit if failed\n\t  mov [rax], rsi\t\t\t    ; saving <data> in <node>\n\t  mov qword [rax+16], 0\t  ; setting <next> to NULL\n\t  cmp qword [rdi+8], 0\t  ; whether <back> is NULL\n\t  je .empty\n\t  mov rdx, [rdi+8]\t\t    ; the pointer to <back>\n\t  mov [rdx+16], rax\t\t    ; setting <back->next> to <node>\n\t  mov [rax+8], rdx\t\t    ; setting <node->prev> to <back>\n\t  jmp .setback\n.empty:\n\t  mov qword [rax+8], 0\t  ; setting <node->prev> to NULL\n\t  mov [rdi], rax\t\t\t    ; saving <node> as new <front>\n.setback:\n\t  mov [rdi+8], rax\t\t    ; saving <node> as new <back>\n.exit:\n\t  ret\n; ---------> end of push_back <---------\n\n; <----- int deque_pop_back(Deque *deque) ----->\ndeque_pop_back:\n\t  xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi\t\t\t      ; if the passed <deque> is NULL\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  mov rax, [rdi+8]\t\t    ; the pointer to <back>\n\t  test rax, rax\t\t\t      ; if <back> is NULL\n\t  je .exit\t\t\t\t        ; then jumping to exit\n\t  push qword [rax]\t\t    ; saving <data> in the stack\n\t  mov rdx, [rax+8]\t\t    ; the pointer to <prev>\n\t  mov [rdi+8], rdx\t\t    ; saving <prev> as new <back>\n\t  test rdx, rdx\t\t\t      ; whether <prev> is not NULL\n\t  je .empty\n\t  mov qword [rdx+16], 0\t  ; setting <back->next> to NULL\n\t  jmp .free\n.empty:\n\t  mov qword [rdi], 0\t\t  ; setting <front> to NULL\n.free:\n    mov rdi, rax\t\t\t      ; the node to delete\n\t  call free\n\t  pop rax\t\t\t\t\t        ; restoring <data> to return\n.exit:\t\n\t  ret\n; --------> end of pop_back <---------\n\n; <----- int deque_peek_back(const Deque *deque) ----->\ndeque_peek_back:\n\t  xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi\t\t\t      ; whether <deque> is NULL\n\t  je .exit\n\t  cmp qword [rdi+8], 0\t  ; whether <back> is not NULL\n\t  cmovne rax, [rdi+8]\t\t  ; getting the pointer to <back>\n\t  je .exit                ; jumping to exit is <back> is NULL\n\t  cmovne rax, [rax]\t\t    ; coppying <data> to return\n.exit:\n\t  ret\n; ---------> end of peek_back <---------\n\n; <----- int deque_is_empty(const Deque *deque) ----->\ndeque_is_empty:\n\t  xor rax, rax\t\t\t      ; resetting RAX\n\t  test rdi, rdi\t\t\t      ; whether <deque> is NULL\n\t  sete al\t\t\t\t\t        ; setting to true\n\t  je .exit\t\t\t\t        ; jumping to exit in case <deque> is NULL\n\t  cmp qword [rdi], 0\t\t  ; whether <front> is NULL\n\t  setz al\t\t\t\t\t        ; then setting to true\n.exit:\t\n\t  ret\n; ---------> end of is_empty <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214266,"user_id":168,"body":"global deque_push_front, deque_pop_front, deque_peek_front, deque_push_back, deque_pop_back, deque_peek_back, deque_is_empty\nextern malloc, free\nsection .text\ndeque_push_front:\n  push rbx\n  push rdi\n  push rsi\n  mov rbx, [rdi]\n  mov edi, 24\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov qword [rax + 8], 0\n  mov qword [rax + 16], rbx\n  mov [rdi], rax\n  test rbx, rbx\n  cmovz rbx, rdi\n  mov [rbx + 8], rax\n  pop rbx\n  ret\ndeque_pop_front:\n  mov rdx, [rdi]\n  push qword [rdx]\n  mov rax, [rdx + 16]\n  mov [rdi], rax\n  test rax, rax\n  cmovz rax, rdi\n  mov qword [rax + 8], 0\n  mov rdi, rdx\n  call free\n  pop rax\n  ret\ndeque_peek_front:\n  mov rdx, [rdi]\n  mov eax, dword [rdx]\n  ret\ndeque_push_back:\n  push rbx\n  push rdi\n  push rsi\n  mov rbx, [rdi + 8]\n  mov edi, 24\n  call malloc\n  pop rsi\n  pop rdi\n  mov dword [rax], esi\n  mov qword [rax + 8], rbx\n  mov qword [rax + 16], 0\n  mov [rdi + 8], rax\n  sub rdi, 16\n  test rbx, rbx\n  cmovz rbx, rdi\n  mov [rbx + 16], rax\n  pop rbx\n  ret\ndeque_pop_back:\n  mov rdx, [rdi + 8]\n  push qword [rdx]\n  mov rax, [rdx + 8]\n  mov [rdi + 8], rax\n  sub rdi, 16\n  test rax, rax\n  cmovz rax, rdi\n  mov qword [rax + 16], 0\n  mov rdi, rdx\n  call free\n  pop rax\n  ret\ndeque_peek_back:\n  mov rdx, [rdi + 8]\n  mov eax, dword [rdx]\n  ret\ndeque_is_empty:\n  cmp qword [rdi], 0\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b2be37991c7460d17000009":[{"id":214267,"user_id":null,"body":"extern malloc\nglobal communication_module\n; Function signature:\n; char *communication_module(const char *packet)\nsection .text\ncommunication_module:\n  push rbx\n  mov rbx, rdi\n  mov edi, 21\n  call malloc\n  mov ecx, [rbx]\n  mov [rax], ecx\n  mov dword [rax + 4], 1179010630\n  movsx ecx, byte [rbx + 8]\n  lea ecx, [rcx + 4*rcx]\n  movsx edx, byte [rbx + 9]\n  lea ecx, [rdx + 2*rcx]\n  lea ecx, [rcx + 4*rcx]\n  movsx edx, byte [rbx + 10]\n  lea ecx, [rdx + 2*rcx]\n  lea ecx, [rcx + 4*rcx]\n  movsx edx, byte [rbx + 11]\n  lea ecx, [rdx + 2*rcx - 53328]\n  movsx edx, byte [rbx + 12]\n  lea edx, [rdx + 4*rdx]\n  movsx esi, byte [rbx + 13]\n  lea edx, [rsi + 2*rdx]\n  lea edx, [rdx + 4*rdx]\n  movsx esi, byte [rbx + 14]\n  lea edx, [rsi + 2*rdx]\n  lea edx, [rdx + 4*rdx]\n  movsx esi, byte [rbx + 15]\n  lea edx, [rsi + 2*rdx]\n  add edx, -53328\n  movsx esi, byte [rbx + 4]\n  cmp esi, 67\n  je .mult\n  cmp esi, 66\n  je .subt\n  cmp esi, 48\n  add edx, ecx\n  jmp .clamp\n.mult:\n  imul edx, ecx\n  jmp .clamp\n.subt:\n  sub ecx, edx\n  mov edx, ecx\n.clamp:\n  cmp edx, 9999\n  mov ecx, 9999\n  cmovl ecx, edx\n  xor edx, edx\n  test ecx, ecx\n  cmovg edx, ecx\n  movzx ecx, dx\n  imul esi, edx, 52429\n  shr esi, 19\n  lea edi, [rsi + rsi]\n  lea edi, [rdi + 4*rdi]\n  sub edx, edi\n  or dl, 48\n  mov [rax + 11], dl\n  imul edx, esi, 52429\n  shr edx, 18\n  and edx, -2\n  lea edx, [rdx + 4*rdx]\n  sub esi, edx\n  or sil, 48\n  mov [rax + 10], sil\n  mov edx, ecx\n  shr edx, 2\n  imul edx, edx, 5243\n  shr edx, 17\n  imul esi, edx, 205\n  shr esi, 10\n  and esi, 62\n  lea esi, [rsi + 4*rsi]\n  sub dl, sil\n  or dl, 48\n  mov [rax + 9], dl\n  shr ecx, 3\n  imul ecx, ecx, 8389\n  shr ecx, 20\n  imul edx, ecx, 205\n  shr edx, 10\n  and edx, -2\n  lea edx, [rdx + 4*rdx]\n  sub cl, dl\n  or cl, 48\n  mov [rax + 8], cl\n  mov dword [rax + 12], 808464432\n  mov ecx, [rbx + 16]\n  mov [rax + 16], ecx\n  mov byte [rax + 20], 0\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214268,"user_id":null,"body":"global communication_module\nextern calloc,memcpy,sprintf,sscanf\nsection .data\nvalue_1 dq 0\nvalue_2 dq 0\nbuffer dq 0\nfmt    db '%04d',0\nmax   dd 9999\nmin   dd 0\n.add   dw 0\n.sub   dw 0\n.mul   dw 0\nsection .text\ncommunication_module:\n      push rdi\n      mov rdi,21\n      mov esi,1\n      call calloc\n      \n      mov [buffer],rax\n      mov rdi,rax\n      pop rsi\n      push rdi\n      mov rdx,21\n      call memcpy\n      \n      mov rdi,[buffer]\n      add rdi,8\n      lea rsi,[fmt]\n      lea rdx,[value_1]\n      call sscanf\n\n      mov rdi,[buffer]\n      add rdi,12\n      lea rsi,[fmt]\n      lea rdx,[value_2]\n      call sscanf\n\n      mov r8,[value_1]\n      sub r8,[value_2]\n      mov r9,[value_1]\n      add r9,[value_2]\n      mov r10,[value_1]\n      imul r10,[value_2]\n      mov rdi,[buffer]\n      cmp dword [rdi + 4],\"B7A2\"\n      cmovl rdx,r9\n      cmovg rdx,r10\n      cmove rdx,r8\n      cmp edx, [max]  ; Test of greater than 9999\n      cmovg edx,[max]\n      test edx,edx    ; or negative number\n      cmovs edx,[min]\n      add rdi,8      ; Patch the copied input string\n      lea rsi,[fmt]\n      call sprintf\n      pop rax\n      mov dword [rax + 4], \"FFFF\"\n      mov dword [rax + 12],\"0000\"\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214269,"user_id":null,"body":"global communication_module  ; char *communication_module(const char *packet)\nextern calloc\nextern atoi\nextern sprintf\n\nsection .text\ncommunication_module:\n      mov r12, rdi            ;r12 -> source\n      ;allocate buffer\n      mov rdi, 32\n      mov rsi, 1\n      call calloc\n      mov r13, rax            ;r13 -> return buffer\n      ;retrieve d1\n      mov ebx, dword[r12+8]\n      mov dword[r13],ebx \n      mov rdi, r13\n      call atoi\n      mov r14, rax            ;r14 -> d1\n      ;retrieve d2\n      mov ebx, dword[r12+12]\n      mov dword[r13],ebx \n      mov rdi, r13\n      call atoi\n      mov r15, rax            ;r15 -> d2\n      ;retrieve instruction\n      cmp byte[r12+4], 48     ;addition ?\n      jz adi\n      cmp byte[r12+4], 66     ;substraction ?\n      jz sbs\nmlt:  xor rdx, rdx\n      mov rax, r14\n      mul r15\n      mov r14, rax\n      cmp r14, 9999\n      jbe cnt\n      mov r14, 9999\n      jmp cnt\nadi:  add r14, r15\n      cmp r14, 9999\n      jbe cnt\n      mov r14, 9999\n      jmp cnt\nsbs:  sub r14, r15\n      cmp r14, 0\n      jge cnt\n      xor r14, r14\n      jmp cnt\ncnt:  mov rbx, r13\n      add rbx, 8\n      mov rdi, rbx\n      mov rsi, fmt\n      mov rdx, r14\n      xor rax, rax\n      call sprintf\n      ;copy header\n      mov ebx,dword[r12]\n      mov dword[r13], ebx\n      ;copy instruction\n      mov ebx,[fff]\n      mov dword[r13+4], ebx\n      ;Zeros in d2\n      mov ebx,[zzz]\n      mov dword[r13+12], ebx\n      ;copy footer\n      mov ebx,dword[r12+16]\n      mov dword[r13+16], ebx\n      mov rax, r13\n      ret \n\nsection .data\nfmt:  db \"%04d\", 0, 0, 0, 0\nfff:  db \"FFFF\", 0, 0, 0, 0\nzzz:  db \"0000\", 0, 0, 0, 0\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214270,"user_id":null,"body":"global communication_module\nextern asprintf\ncommunication_module:\n  mov       eax,[rdi]\n  mov       edx,[rdi+16]\n  mov       [fmt],eax\n  mov       [fmt+16],edx\n  movdqu    xmm0,[rdi+8]\n  punpcklbw xmm0,xmm0\n  psubusb   xmm0,[ASCII]\n  psrlw     xmm0,8\n  pmaddwd   xmm0,[decconv]\n  phaddd    xmm0,xmm0\n  pshufd    xmm1,xmm0,1\n  movzx     rax,byte[rdi+4]\n  and       rax,15\n  jmp       [jumptable+rax*8]\n  print:\n  pminud    xmm0,[max]\n  movd      edx,xmm0\n  push      rsp\n  mov       rdi,rsp\n  mov       rsi,fmt\n  xor       rax,rax\n  call      asprintf\n  pop       rax\nret\n_add:\n  paddusw xmm0,xmm1\njmp print  \n_sub:\n  psubusw xmm0,xmm1\njmp print  \n_mul:\n  pmulld xmm0,xmm1\njmp print  \nsection .data\njumptable dq _add,_add,_sub,_mul\nASCII     db '0000000000000000'\ndecconv   dw 1000,100,10,1,1000,100,10,1\nmax       dd 9999,9999,9999,9999\nfmt       db 'H1H1FFFF%04u0000F4F4',0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214271,"user_id":null,"body":"global communication_module\nextern malloc\nextern free\nextern atoi\nextern snprintf\n\n; Function signature:\n; char *communication_module(const char *packet)\nsection .text\ncommunication_module:\n  enter 8, 0\n  mov [rbp-8], rbx\n  push rdi\n  mov edi, 24\n  call malloc\n  mov rbx, rax\n  test rbx, rbx\n  jz .error\n  \n  mov rdi, rbx\n  pop rsi\n  movsq\n  movsq\n  lodsd\n  stosq\n  \n  mov eax, [rbx+12]\n  call from_ascii\n  push rax\n  mov eax, [rbx+8]\n  call from_ascii\n  pop rdx\n  \n  mov ecx, [rbx+4]\n  cmp ecx, '0F12'\n  je .plus\n  cmp ecx, 'B7A2'\n  je .minus\n  cmp ecx, 'C3D9'\n  jne .error\n  \n.times:\n  mul edx\n  jmp .format_packet\n.plus:\n  add eax, edx\n  jmp .format_packet\n.minus:\n  sub eax, edx\n  jmp .format_packet\n\n.error:\n  mov rdi, rbx\n  call free\n  xor rax, rax\n  mov rbx, [rbp-8]\n  leave\n  ret\n  \n\n.format_packet:\n  call to_ascii\n  \n  mov dword [rbx+4], 'FFFF'\n  mov dword [rbx+8], eax\n  mov dword [rbx+12], '0000'\n  \n  mov rax, rbx\n  mov rbx, [rbp-8]\n  leave\n  ret\n  \nfrom_ascii:\n  push rax\n  mov rdi, rsp\n  call atoi\n  pop rdi\n  ret\n  \nto_ascii:\n  enter 8, 0\n  cmp eax, [.min]\n  cmovl eax, [.min]\n  cmp eax, [.max]\n  cmovg eax, [.max]\n  \n  mov rdi, rsp\n  mov esi, 8\n  mov rdx, .format\n  mov ecx, eax\n  call snprintf\n  mov eax, [rsp]\n  leave\n  ret\n.min: dd 0\n.max: dd 9999\n.format: db '%04d', 0\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214272,"user_id":null,"body":"global communication_module\nextern malloc\nextern strcpy\n\nsection .text\n; char *communication_module(const char *packet)\ncommunication_module:\n    push rdi ; *packet\n    mov rdi, 21\n    call malloc\n    mov rdi, rax\n    pop rsi ; *packet\n    call strcpy\n    add rax, 8\n    call .str_to_int\n    add rax, 4\n    call .str_to_int\n    mov ecx, [rax-8]\n    cmp ecx, 0x32314630\n    je .add\n    cmp ecx, 0x32413742\n    je .sub\n    cmp ecx, 0x39443343\n    je .mul\n    xor rax, rax\n    ret\n\n.add:\n    mov ecx, [rax-4]\n    add ecx, [rax]\n    jmp short .calc_done\n\n.sub:\n    mov ecx, [rax-4]\n    sub ecx, [rax]\n    jmp short .calc_done\n\n.mul:\n    mov ecx, [rax-4]\n    imul ecx, [rax]\n    jmp short .calc_done\n\n.calc_done:\n    sub rax, 4\n    cmp ecx, 9999\n    jg .trunc\n    test ecx, ecx\n    jns .end\n    xor ecx, ecx\n    jmp short .end\n\n.trunc:\n    mov ecx, 9999\n    jmp short .end\n\n.end:\n    mov [rax], ecx\n    call .int_to_str\n    sub rax, 8\n    mov dword [rax+4], 0x46464646 ; FFFF\n    mov dword [rax+12], 0x30303030 ; 0000\n    ret\n\n.str_to_int:\n    sub dword [rax], 0x30303030\n    xor edx, edx\n    movzx ecx, byte [rax]\n    imul ecx, 1000\n    add edx, ecx\n    movzx ecx, byte [rax+1]\n    imul ecx, 100\n    add edx, ecx\n    movzx ecx, byte [rax+2]\n    imul ecx, 10\n    add edx, ecx\n    movzx ecx, byte [rax+3]\n    add edx, ecx\n    mov dword [rax], edx\n    ret\n\n.int_to_str:\n    mov rcx, rax\n    mov eax, [rcx]\n    mov esi, 1000\n    xor rdx, rdx\n    idiv esi\n    mov [rcx], al\n    mov eax, edx\n    xor edx, edx\n    mov esi, 100\n    idiv esi\n    mov [rcx+1], al\n    mov eax, edx\n    xor edx, edx\n    mov esi, 10\n    idiv esi\n    mov [rcx+2], al\n    mov [rcx+3], dl\n    mov rax, rcx\n    add dword [rax], 0x30303030\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214273,"user_id":168,"body":"global communication_module\nextern atoi, sprintf\n; Function signature:\n; char *communication_module(const char *packet)\nsection .data\nformat: db 'FFFF%04d', 0\nbuf: times 5 db 0\nresult: times 21 db 0\nsection .text\ncommunication_module:\n  push rbx\n  mov rbx, rdi\n  mov rax, [rdi]\n  mov [result], rax\n  mov eax, [rdi + 16]\n  mov [result + 16], eax\n  mov eax, [rdi + 12]\n  mov [buf], eax\n  lea rdi, [buf]\n  call atoi\n  mov edx, [rbx + 8]\n  mov [buf], edx\n  mov ebx, eax\n  lea rdi, [buf]\n  call atoi\n  mov edx, [result + 4]\n  cmp edx, '0F12'\n  je .add\n  cmp edx, 'B7A2'\n  je .sub\n  mul ebx\n  jmp .check_overflow\n.sub:\n  xor edx, edx\n  sub eax, ebx\n  cmovl eax, edx\n  jmp .continue\n.add:\n  add eax, ebx\n.check_overflow:\n  mov edx, 9999\n  cmp eax, edx\n  cmovg eax, edx\n.continue:\n  lea rdi, [result + 4]\n  lea rsi, [format]\n  mov edx, eax\n  call sprintf\n  mov dword [result + 12], '0000'  \n  lea rax, [result]\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214274,"user_id":17,"body":"global communication_module\n; Function signature:\n; char *communication_module(const char *packet)\nextern strcpy\nsection .text\ncommunication_module:\n  mov rsi, rdi\n  mov rdi, result\n  call strcpy\n  mov rax, result\n  cmp byte [rax + 4], '0'\n  je .add\n  cmp byte [rax + 4], 'B'\n  je .sub\n  xor rdx, rdx\n  mov dl, byte [rax + 8]\n  sub dl, 48\n  mov rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 9]\n  sub dl, 48\n  add rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 10]\n  sub dl, 48\n  add rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 11]\n  sub dl, 48\n  add rdi, rdx\n  mov dl, byte [rax + 12]\n  sub dl, 48\n  mov rsi, rdx\n  imul rsi, 10\n  mov dl, byte [rax + 13]\n  sub dl, 48\n  add rsi, rdx\n  imul rsi, 10\n  mov dl, byte [rax + 14]\n  sub dl, 48\n  add rsi, rdx\n  imul rsi, 10\n  mov dl, byte [rax + 15]\n  sub dl, 48\n  add rsi, rdx\n  imul rdi, rsi\n  jmp .format\n.add:\n  xor rdx, rdx\n  mov dl, byte [rax + 8]\n  add dl, byte [rax + 12]\n  sub dl, 96\n  mov rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 9]\n  add dl, byte [rax + 13]\n  sub dl, 96\n  add rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 10]\n  add dl, byte [rax + 14]\n  sub dl, 96\n  add rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 11]\n  add dl, byte [rax + 15]\n  sub dl, 96\n  add rdi, rdx\n  jmp .format\n.sub:\n  xor rdx, rdx\n  mov dl, byte [rax + 8]\n  mov rdi, rdx\n  mov dl, byte [rax + 12]\n  sub rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 9]\n  add rdi, rdx\n  mov dl, byte [rax + 13]\n  sub rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 10]\n  add rdi, rdx\n  mov dl, byte [rax + 14]\n  sub rdi, rdx\n  imul rdi, 10\n  mov dl, byte [rax + 11]\n  add rdi, rdx\n  mov dl, byte [rax + 15]\n  sub rdi, rdx\n.format:\n  cmp rdi, 9999\n  jle .no_reassign\n  mov rdi, 9999\n.no_reassign:\n  mov byte [rax + 4], 'F'\n  mov byte [rax + 5], 'F'\n  mov byte [rax + 6], 'F'\n  mov byte [rax + 7], 'F'\n  mov byte [rax + 8], '0'\n  mov byte [rax + 9], '0'\n  mov byte [rax + 10], '0'\n  mov byte [rax + 11], '0'\n  mov byte [rax + 12], '0'\n  mov byte [rax + 13], '0'\n  mov byte [rax + 14], '0'\n  mov byte [rax + 15], '0'\n  mov rsi, 12\n.loop:\n  cmp rdi, 0\n  jle .end_loop\n  dec rsi\n  xor rdx, rdx\n  mov rax, rdi\n  mov r8, 10\n  idiv r8\n  mov rcx, rax\n  mov rax, result\n  add byte [rax + rsi], dl\n  mov rdi, rcx\n  jmp .loop\n.end_loop:\n  ret\n\nsection .bss\nresult resb 21","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b55c49d4a317adff500015f":[{"id":214275,"user_id":168,"body":"global points_num\n\nsection .text\n\n; <----- unsigned points_num(unsigned radius) ----->\npoints_num:\n  xor edx, edx\n  xor eax, eax\n.loop:\n  cvtsi2sd xmm0, eax\n  sqrtsd xmm0, xmm0\n  cvttsd2si ecx, xmm0\n  add edx, ecx\n  lea eax, [eax + 2 * edi - 1]\n  dec edi\n  jns .loop\n  lea eax, [4 * edx + 1]\n  ret\n; ---------> end of ptsnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214276,"user_id":743,"body":"global points_num\n\nsection .rodata\n\n; this is the magic\nChi dd 0, 1, 1, 0\n\nsection .text\n\n; eax                          edi\n; unsigned points_num(unsigned radius)\npoints_num:\n  xor r8d, r8d\n  test edi, edi\n  jz .end\n  xor r9d, r9d\n  imul edi, edi\n  mov ecx, 1\n.loop:\n  xor edx, edx\n  mov eax, edi\n  div ecx\n  mov esi, eax\n  xor edx, edx\n  mov eax, edi\n  div esi\n  lea ecx, [rax + 1]\n  and eax, 3\n  mov eax, [Chi + eax * 4]\n  mov r10d, eax\n  sub eax, r9d\n  mul esi\n  mov r9d, r10d\n  add r8d, eax\n  cmp ecx, edi\n  jbe .loop\n.end:\n  lea eax, [r8d * 4 + 1]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214277,"user_id":null,"body":"global points_num\n\nsection .text\n\n; <----- unsigned points_num(unsigned radius) ----->\npoints_num:\n  xor eax, eax\n  xor esi, esi\n  test edi, edi\n  jbe .done\n  mov ecx, edi\n  imul ecx, edi\n.loop:\n  mov edx, esi\n  imul edx, esi\n  inc esi\n  neg edx\n  add edx, ecx\n  cvtsi2sd xmm0, rdx\n  sqrtsd xmm0, xmm0\n  mov eax, eax\n  cmp esi, edi\n  cvtsi2sd xmm1, rax\n  addsd xmm1, xmm0\n  cvttsd2si rax, xmm1\n  jb .loop\n.done:\n  lea eax, [1+rax*4]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214278,"user_id":null,"body":"global points_num\nsection .text\n\n; <----- unsigned points_num(unsigned radius) ----->\npoints_num:\n  push rbx\n  xor rsi, rsi\n\n  mov r8, 1 ; x\n  mov r9, 0 ; y\n.loop:\n  ; h = sqrt(x*x + y*y)\n\n  ; x**2\n  mov rax, r8\n  mov rcx, r8\n  mul rcx\n  mov rbx, rax\n\n  ; y**2\n  mov rax, r9\n  mov rcx, r9\n  mul rcx\n  add rax, rbx\n\n  ; (int)ceil(sqrt())\n  pxor xmm0, xmm0\n  cvtsi2sd xmm0, rax\n  sqrtsd xmm0, xmm0\n  roundsd xmm0,xmm0,0xa\n  cvttsd2si rax, xmm0\n\n  cmp rax, rdi ; h < radius\n  ja .continue\n\n  inc r9\n  inc rsi\n  jmp .loop\n\n.continue:\n  inc r8\n  mov r9, 0\n  cmp r8, rdi\n  jbe .loop\n\n  mov rax, rsi\n  mov rcx, 4 ; get other quadrants\n  mul rcx\n  inc rax ; (0,0)\n\n  pop rbx\n  ret\n; ---------> end of ptsnum <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214279,"user_id":null,"body":"; The idea\n;\n;   ^            Take the graph on the left. The radius is set to 4. If we\n; 4 +            draw a circle an inspect the first quadrant, the stars will\n; 3 + * *        all be points inside the circle excluding points on the\n; 2 + * * *      axes. These points also exist in the other quadrants.\n; 1 + * * *      Therefore we can multiply the result by 4, i.e. 8 x 4 = 32.\n; 0 +-+-+-+-+->  We also have all the points on the axes, there are 4 parts\n;   0 1 2 3 4    of the axes (2 for the x-axis, and 2 for the y-axis) that\n;                contain points from 1 to 4 inclusive, i.e. 4 * 4 = 16.\n; Adding these to the overall amount makes 48.\n; Finally, we add the origin (0,0) to the list and get 49 points inside the\n; full circle.\n; The only difficulty is to calculate the first amount of points (stars in\n; the graph). An easy approach (not the best) is to simply count them out.\n; The following code does exactly that, it counts all points that are\n; below or at the circle's circumference. For our coordinate system that is:\n; x\u00b2 + y\u00b2 <= r\u00b2.\n; If this count is c, the number of points on one part of the x-axis is r,\n; then the result is:\n; (c + r) * 4 + 1\n;\nglobal points_num\n\nsection .text\n\n; <----- unsigned points_num(unsigned radius) ----->\n;;\n; C-signature:\n;     unsigned int points_num(unsigned int r);\n;     [eax]                   [edi]\n;\n; Calculate the number of coordinates (integer only) that are inside or\n; at the circumference of a circle of a given radius r.\n;\n; The value of radius r should be lower than or equal to 1000.\n;\n; @param r [edi] radius\n; @return number of points that are inside or on the circumference of a\n;         circle of radius r\n;\npoints_num:\n\t; Prolog\n\tpush rbp\n\tmov rbp, rsp\n\t; Save rbx because we use ebx.\n\tpush rbx\n\n\t; Calculate the square of r\n\tmov eax, edi\n\tmul eax\n\t; Store the square of r (r\u00b2) in r12d for later use\n\tmov r12d, eax\n\t; We use ecx as a loop counter (i = r - 1)\n\tmov ecx, edi\n\tdec ecx\n\t; The result will be accumulated in r14d (c)\n\tmov r14d, 0\n\n.L3:\n\t; This loop counts down from r - 1 to 0\n\tcmp ecx, 0\n\tjle .L1\n\n\t; First we calculate the square of i.\n\tmov eax, ecx\n\tmul ecx      \n\t; And store it in r13d (i\u00b2)\n\tmov r13d, eax\n\n\t; Then we reset ebx which we use as our inner loop counter j = r - 1\n\tmov ebx, edi\n\tdec ebx\n.L4:\n\t; This inner loop counts down from r - 1 to 0\n\tcmp ebx, 0\n\tjle .L2\n\t; Here, we calculate j\u00b2 first.\n\tmov eax, ebx\n\tmul ebx\n\t; Then, add i\u00b2 to it. This is equivalent to our introduction there we\n\t; wanted to calculate x\u00b2 and y\u00b2.\n\tadd eax, r13d\n\t; We add both values together (i\u00b2+j\u00b2)\n\tcmp eax, r12d\n\t; Now, if i\u00b2+j\u00b2>r\u00b2 we want continue to decrement j until we\n\t; find a sum that fits r\u00b2\n\tjg .L5\n\t; At this point, we have i\u00b2+j\u00b2<=r\u00b2 and we can add all points\n\t; (combinations: (1, [j...1])) to our result.\n\tadd r14d, ebx\n\t; Instead of continuing the loop we break out and continue\n\t; with the outer loop.\n\t; It's like counting the valid coordinates in slices of the circle\n\t; parallel to an axis.\n\tjmp .L2\n.L5:\n\t; Decrement the inner loop counter (j).\n\tdec ebx\n\tjmp .L4\n.L2:\n\t; Decrement the outer loop counter (i).\n\tdec ecx\n\tjmp .L3\n.L1:\n\t; Here, we have counted all points inside the circle that are not\n\t; on an axis.\t\n\tmov eax, r14d\n\t; So, we add the points that are part of the axes.\n\tadd eax, edi\n\t; And multiply that \"quadrant-count\" by 4.\n\tshl eax, 2\n\t; Finally, we add the origin as a valid coordinate and return the result.\n\tinc eax\n\n\t; Restore rbx\n\tpop rbx\n\t; Epilog\n\tmov rsp, rbp\n\tpop rbp\n\tret\n; ---------> end of ptsnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214280,"user_id":null,"body":"global points_num\n\nsection .text\n\n; <----- unsigned points_num(unsigned radius) ----->\npoints_num:\n    mov rax, rdi\n    mul rax\n    mov rdi, rax  ; RDI = n^2\n    mov r8, 4    \n    xor rsi, rsi  ; RSI = i\n    xor rcx, rcx\n\n.step:\n    mov rax, rsi\n    mul r8\n    inc rax\n    mov r9, rax\n    add rax, 2\n    mov r10, rax\n    \n    xor rdx, rdx\n    mov rax, rdi\n    div r9\n    mov r9, rax\n    xor rdx, rdx\n    mov rax, rdi\n    div r10\n    mov r10, rax\n    \n    add rcx, r9\n    sub rcx, r10\n    inc rsi\n    or r9, r10\n    jnz .step\n    \n    mov rax, rcx\n    mul r8\n    inc rax\n    \n    ret\n; ---------> end of ptsnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214281,"user_id":50,"body":"; I've just implemented Python's Dekar's solution https:\/\/www.codewars.com\/kata\/reviews\/5bd1f92779480f7e58000012\/groups\/5c00764581c9a20e20006464\nglobal points_num\n\nsection .text\n\n; <----- unsigned points_num(unsigned radius) ----->\npoints_num:\n    xor rax, rax        ; rax <- points\n    test rdi,rdi\n    jz _retOne\n    mov r8,rdi\n    imul r8,r8 ; compute n*n\n    xor rbx,rbx ; i=0\n_loop1:\n  cmp rbx,rdi ; if i==n it's over\n  je _exit\n  xor rcx,rcx ; j=0\n_loop2:\n  inc rcx\n  cmp rcx,rdi ; if j==n; i+=1; j=1 and back to loop1\n  je _up\n  mov r9,rbx ; r9=i\n  imul r9,r9 ; r9=i*i\n  mov r10,rcx ; r10=j\n  imul r10,r10 ; r10=j*j\n  add r9,r10 ; r9=i*i+j*j\n  cmp r9,r8 ; if i*i+j*j<=n*n\n  jle _in\n  jmp _loop2\n_in:\n  inc rax\n  jmp _loop2\n_up:\n  inc rbx\n  jmp _loop1\n_retOne:\n  mov rax,1\n  ret\n_exit:\n  imul rax,4\n  add rax,5\n  ret\n; ---------> end of ptsnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214282,"user_id":null,"body":"global points_num\n\nsection .text\n\n; uses the summation formula for Gauss's circle problem\n; <----- unsigned points_num(unsigned radius) ----->\npoints_num:\n    xor rsi, rsi ; will hold running sum\n    mov rcx, 1\n    mov rax, rdi\n    mul rdi\n    mov r9, rax ; r9 will hold radius squared\n.l1:\n    cmp rdi, rcx\n    jb .done_l1\n    mov rax, rcx\n    mul rcx\n    mov r8, rax\n    mov rdx, r9\n    sub rdx, r8\n    ; take square root, add to rsi\n    mov [rsp-8], rdx\n    fild QWORD [rsp-8]\n    fsqrt\n    fisttp QWORD [rsp-8]\n    fwait\n    mov rdx, [rsp-8]\n    add rsi, rdx\n    inc rcx\n    jmp .l1\n.done_l1:\n    shl rsi, 2\n    lea rax, [rdi*4+rsi]\n    inc rax\n    ;inc rsi\n    ;lea rax, [rdi*4+rsi]\n    ret\n; ---------> end of ptsnum <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214283,"user_id":null,"body":"global points_num\npoints_num:\n  mov  rsi,rdi\n  imul rsi,rsi\n  inc  rsi\n  mov  r8,1\n  xor  r10,r10\n  xor  rax,rax\n  .a:mov r9,1\n     mov rcx,r10\n     jmp .c\n     .b:adc rax,0\n     .c:add r10,r9\n        add r9,2\n        cmp r10,rsi\n     jc .b   \n     adc rax,0\n     lea r10,[rcx+r8]\n     add r8,2\n     dec rdi \n  jns .a   \n  lea rax,[rax*4+1]\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214284,"user_id":null,"body":"global points_num\n\nsection .text\n\n; unsigned points_num(unsigned radius)\npoints_num:\n    mov rax, 1\n    test rdi, rdi\n    jnz not_zero\n    ret\nnot_zero:\n    mov rsi, rdi\n    imul rsi, rsi\n    mov rdx, rdi\nouter_loop:\n    mov rcx, rdx\n    imul rcx, rcx\n    mov r8, rdi\ninner_loop:\n    mov r9, r8\n    imul r9, r9\n    add r9, rcx\n    cmp r9, rsi\n    jg outside\n    add rax, 4\noutside:\n    dec r8\n    jnz inner_loop\n    dec rdx\n    jns outer_loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b73fe9fb3d9776fbf00009e":[{"id":214285,"user_id":null,"body":"global diffsum\ndiffsum:\n  xor rax,rax\n  cmp rsi,2\n  jb @f\n    mov eax,0x80000000\n    mov edx,0x7FFFFFFF\n    @b:cmp   eax,[rdi+rsi*4-4]\n       cmovl eax,[rdi+rsi*4-4]\n       cmp   edx,[rdi+rsi*4-4]\n       cmovg edx,[rdi+rsi*4-4]\n       dec   rsi\n    jne @b   \n    sub eax,edx\n  @f:\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214286,"user_id":null,"body":"global diffsum\n\ndiffsum:\n  xor eax, eax\n  cmp rsi, 1\n  jbe .exit\n  mov eax, [rdi] ;max\n  mov ecx, [rdi] ;min\n.loop:\n  dec rsi\n  mov edx, [rdi+4*rsi]\n  cmp edx, eax\n  cmovg eax, edx\n  cmp edx, ecx\n  cmovl ecx, edx\n  test rsi, rsi\n  jnz .loop\n  sub eax, ecx\n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214287,"user_id":null,"body":"global diffsum\n\n; <-- EAX diffsum(ro [dword RDI] arr, RSI n) -->  \ndiffsum:\n\ttest\trsi, rsi\n\tje .zero\n\tmov\tr8d, [rdi]\n\tcmp\trsi, 1\n\tjne\t.gt1\n\tmov\teax, r8d\n\tjmp\t.done\n.zero:\n\txor\teax, eax\n\tret\n.gt1:\n\tmov\tedx, 1\n\tmov\teax, r8d\n.loop:\n\tmov\tecx, [rdi + 4*rdx]\n\tcmp\tecx, eax\n\tcmovg\teax, ecx\n\tcmp\tecx, r8d\n\tcmovl\tr8d, ecx\n\tinc\trdx\n\tcmp\trsi, rdx\n\tjne\t.loop\n.done:\n\tsub\teax, r8d\n\tret\n; -----> endof diffsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214288,"user_id":null,"body":"global diffsum\n\n; <-- EAX diffsum(ro [dword RDI] arr, RSI n) -->\ndiffsum:\n    ; check parameters\n    xor   eax, eax\n    test  rdi, rdi\n    jz    .exit           ; no array, return 0\n    test  rsi, rsi     \n    jz    .exit           ; no elements, return 0\n    ; prepare loop    \n    mov   rcx, rsi        ; rcx = counter\n    mov   rsi, rdi        ; rsi = running pointer in input array\n    lodsd\n    mov   ebx, eax        ; ebx = max of array\n    mov   edx, eax        ; edx = min of array\n    jmp   .next\n    ; find min and max of the items in the array\n.loop:    \n    lodsd\n    cmp   ebx, eax\n    cmovl ebx, eax\n    cmp   edx, eax\n    cmovg edx, eax\n.next: \n    loop  .loop\n    ; calculate the summ of differences\n    mov   eax, ebx\n    sub   eax, edx        ; result = max - min\n.exit:    \n    ret\n; -----> endof diffsum <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214289,"user_id":881,"body":"global diffsum\n\n; <-- EAX diffsum(ro [dword RDI] arr, RSI n) -->\ndiffsum:\n    xor rax, rax\n    cmp rsi, 1\n    jbe .end\n    mov eax, [rdi]\n    mov ecx, eax\n.for_each:\n    dec rsi\n    mov edx, [rdi + rsi * 4]\n    cmp ecx, edx\n    cmovg ecx, edx\n    cmp eax, edx\n    cmovl eax, edx\n    test rsi, rsi\n    jnz .for_each\n    sub eax, ecx\n.end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214290,"user_id":104,"body":"; 2021 nomennescio\nglobal diffsum\nextern qsort\n\ndescend:\n    mov eax, [rsi]\n    sub eax, [rdi]\n    ret\n\n; EAX diffsum (ro [dword RDI] arr, RSI n)\ndiffsum:\n    xor eax, eax\n    cmp rsi, 1\n    jbe exit\n    push rdi\n    push rsi\n    mov rdx, 4\n    mov rcx, descend\n    call qsort\n    pop rsi\n    pop rdi\n    mov eax, [rdi]\n    sub eax, [rdi+4*rsi-4]\nexit:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214291,"user_id":50,"body":"global diffsum\n\n; <-- EAX diffsum(ro [dword RDI] arr, RSI n) -->\ndiffsum:\n    xor eax, eax        ; EAX <- the result\n    cmp rsi,2\n    jl _retz\n    xor r8,r8 ; min\n    xor r9,r9 ; max\n    xor r10,r10 ; index\n    xor r11,r11 ; cur value\n    mov r8d,[rdi]\n    mov r9d,[rdi]\n_loop:\n    inc r10\n    cmp r10,rsi\n    je _exit\n    add rdi,4\n    mov r11d,[rdi]\n    cmp r8d,r11d\n    jg _updateMin\n    cmp r9d,r11d\n    jl _updateMax\n    jmp _loop\n_updateMin:\n  mov r8d,r11d\n  jmp _loop\n_updateMax:\n  mov r9d,r11d\n  jmp _loop\n_exit:\n  mov eax,r9d\n  sub eax,r8d\n  ret\n_retz:\n  ret\n; -----> endof diffsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214292,"user_id":null,"body":"global diffsum\n; <-- EAX diffsum(ro [dword RDI] arr, RSI n) -->\ndiffsum:\n    xor rax, rax\n    cmp rsi, 1\n    jbe end\n    xor rbx, rbx\n    xor rdx, rdx\n    dec rsi\n    mov eax, dword[rdi+rsi*4] ;max\n    mov ebx, eax              ;min\nmain:\n    test rsi, rsi\n    jz en0\n    dec rsi\n    mov edx, dword[rdi+rsi*4]        ; EAX <- the result\n    cmp eax, edx\n    jge cnt\n    mov eax, edx\n    jmp main\ncnt:\n    cmp ebx, edx\n    jle cn2\n    mov ebx, edx\ncn2:\n    jmp main\nen0:\n    sub eax, ebx\nend:\n    ret\n; -----> endof diffsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214293,"user_id":null,"body":"global diffsum\nsegment .bss\narr:    resw 200\nsegment .text\ndiffsum:\n    xor rax, rax\n    cmp rsi, 1\n    jle end      ; Bail if array length less than 2\n    mov r14, arr\n    mov rbx, rsi\ncp_array:\n    mov r11, [rdi + rbx * 4 -4]  ; Copy the array, although it seems to be OK to mangle the input\n    mov [r14 + rbx * 4 -4], r11\n    dec rbx\n    jnz cp_array\n    sub rsi, 1\nsort:\n    mov r15, rsi        ; Simple bubblesort, I assume only small arrays in a level 8\n    xor r10, r10\nsort_2:    \n    mov r11d, [r14 + r15 * 4]\n    cmp r11d, [r14 + r15 * 4 -4]\n    jge  noswap\n    mov r12d, [r14 + r15 * 4 -4]\n    mov [r14 + r15 * 4 -4], r11d\n    mov [r14 + r15 * 4], r12d\n    mov r10d, 1\nnoswap:\n    dec r15\n    jnz sort_2\n    cmp r10d, 0\n    jne sort\n\nsub_loop:\n    mov r11d, [r14 + rsi * 4] ; Add up the differences\n    sub r11d, [r14 + rsi * 4 -4]\n    add eax, r11d\n    dec rsi\n    jnz sub_loop\nend:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214294,"user_id":null,"body":"global diffsum\n\n; <-- EAX diffsum(ro [dword RDI] arr, RSI n) -->\ndiffsum:\n  xor eax, eax        ; EAX = 0\n  cmp rsi, 02h        ; If the array has only one element or 0\n  cmovb edx, eax      ; EDX = EAX = 0\n  jb .exit            ; Jump to exit and return 0\n  mov eax, [rdi]      ; EAX = First element of the array\n  mov edx, eax        ; EAX will contain the maximum element, EDX will contain the minimum element of the array\n  mov rcx, rsi\n  dec rcx             ; RCX = Length of the array\n.loop:\n  mov ebx, [rdi+rcx*4]\n  cmp eax, ebx\n  cmovl eax, ebx\n  cmp edx, ebx\n  cmovg edx, ebx\n  dec rcx\n  jnz .loop\n.exit:\n  sub eax, edx\n  ret\n; -----> endof diffsum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b7ea71db90cc0f17c000a5a":[{"id":214295,"user_id":null,"body":"section .data\n  K dq 273.15\n  R dq 0.082\n  \nsection .text\nglobal total_pressure\n\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\n\ntotal_pressure:\n.moles:\n  divsd xmm2, xmm0\n  divsd xmm3, xmm1\n  addsd xmm2, xmm3\n  \n.pressure:\n  addsd xmm5, [K]\n  mulsd xmm2, [R]\n  mulsd xmm2, xmm5\n  divsd xmm2, xmm4\n  \n  movq xmm0, xmm2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214296,"user_id":168,"body":"section .text\nglobal total_pressure\n\nR dq 0.082\nK dq 273.15\n\n; double total_pressure(\n;        double mM1 (xmm0), double mM2 (xmm1), double gM1 (xmm2), \n;        double gM2 (xmm3), double v (xmm4), double t (xmm5));\n\ntotal_pressure:\n  vunpcklpd xmm0, xmm1\n  vunpcklpd xmm2, xmm3\n  vdivpd xmm2, xmm0\n  vhaddpd xmm0, xmm2, xmm2\n  vaddsd xmm5, [K]\n  vmulsd xmm0, [R]\n  vmulsd xmm0, xmm5\n  vdivsd xmm0, xmm4\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214297,"user_id":null,"body":"section .text\nglobal total_pressure\n\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\nc1: dq  0.082\nc2: dq  273.15\n\ntotal_pressure:\n\tvunpcklpd\txmm2, xmm2, xmm3\n\tvunpcklpd\txmm0, xmm0, xmm1\n\tvdivpd\txmm0, xmm2, xmm0\n\tvpermilpd\txmm1, xmm0, 1\n\tvaddsd\txmm0, xmm0, xmm1\n\tvmulsd\txmm0, xmm0, [rel c1]\n\tvaddsd\txmm1, xmm5, [rel c2]\n\tvmulsd\txmm0, xmm0, xmm1\n\tvdivsd\txmm0, xmm0, xmm4\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214298,"user_id":null,"body":"section .data\n  K dq 273.15\n  R dq 0.082\n  \nsection .text\nglobal total_pressure\n\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\n\ntotal_pressure:\n ; result = xmm0\n.molews:    \n  divsd xmm2, xmm0\n  divsd xmm3, xmm1\n  addsd xmm2, xmm3\n  \n.pressure:\n  addsd xmm5, [K]\n  mulsd xmm2, [R]\n  mulsd xmm2, xmm5\n  divsd xmm2, xmm4\n  \n  movq xmm0, xmm2\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214299,"user_id":104,"body":"; 2021 nomennescio\n\nsection .text\nglobal total_pressure\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\n\nK:   dq 273.15\nR:   dq 0.082\n\ntotal_pressure:\n    divsd xmm2, xmm0\n    divsd xmm3, xmm1\n    addsd xmm2, xmm3\n    addsd xmm5, [K]\n    mulsd xmm2, xmm5\n    mulsd xmm2, [R]\n    divsd xmm2, xmm4\n    movsd xmm0, xmm2\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214300,"user_id":null,"body":"section .data\n  K dq 273.15\n  R dq 0.082\n  \nsection .text\nglobal total_pressure\n\n; double total_pressure( double M1, double M2, double m1, double m2, double v, double t)\ntotal_pressure:\n  divsd xmm2, xmm0\n  divsd xmm3, xmm1\n  addsd xmm2, xmm3\n  addsd xmm5, [K]\n  vmulsd xmm0, xmm2, xmm5\n  mulsd xmm0, [R]\n  divsd xmm0, xmm4\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214301,"user_id":null,"body":"section .data\n  K dq 273.15\n  R dq 0.082\n  \nsection .text\nglobal total_pressure\n\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\n\ntotal_pressure:\n  xorpd xmm8, xmm8\n  \n.moles:\n  divsd xmm2, xmm0\n  divsd xmm3, xmm1\n  addsd xmm2, xmm3\n  \n.pressure:\n  addsd xmm5, [K]\n  mulsd xmm2, [R]\n  mulsd xmm2, xmm5\n  divsd xmm2, xmm4\n  \n  movq xmm0, xmm2\n \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214302,"user_id":50,"body":"section .data\n  a dq 0.082\n  b dq 273.15\nsection .text\nglobal total_pressure\n\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\n\ntotal_pressure:\n  divsd xmm2,xmm0\n  divsd xmm3,xmm1\n  addsd xmm2,xmm3\n  movq xmm0,qword[a]\n  mulsd xmm2,xmm0\n  movq xmm0,qword[b]\n  addsd xmm5,xmm0\n  mulsd xmm2,xmm5\n  divsd xmm2,xmm4\n  movsd xmm0,xmm2\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214303,"user_id":null,"body":"global total_pressure\ntotal_pressure:\n  divsd  xmm2,xmm0\n  divsd  xmm3,xmm1\n  addsd  xmm2,xmm3\n  divsd  xmm2,xmm4\n  addsd  xmm5,[K]\n  mulsd  xmm2,xmm5\n  vmulsd xmm0,xmm2,[R]\nret\nR dq 0.082\nK dq 273.15","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214304,"user_id":null,"body":"section .text\nglobal total_pressure\n\n; double total_pressure(\n;        double molar_mass1 (xmm0), double molar_mass2 (xmm1),\n;        double given_mass1 (xmm2), double given_mass2 (xmm3),\n;        double v (xmm4), double t (xmm5));\n\ntotal_pressure:\n    divsd xmm2, xmm0\n    divsd xmm3, xmm1\n    addsd xmm2, xmm3\n    mulsd xmm2, [$R]    ; couldn't find a better way to do this\n    addsd xmm5, [$CK]   ; or this\n    mulsd xmm2, xmm5\n    divsd xmm2, xmm4\n    movsd xmm0, xmm2\n    ret\n\nsection .data\n    $R: dq 0.082\n    $CK: dq 273.15","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b853229cfde412a470000d0":[{"id":214305,"user_id":null,"body":"section .text\nglobal twice_as_old\ntwice_as_old:\n  shl rsi, 1\n  sub rdi, rsi\n  mov rax, rdi\n  cmp rax, 0\n  jge _exit\n  neg rax\n_exit:\n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214306,"user_id":null,"body":"section .text\nglobal twice_as_old\ntwice_as_old:\n        add     esi, esi      ; son_age + son_age\n        sub     edi, esi      ; diff = father - (son_age + son_age)\n        mov     eax, edi\n        neg     eax           ; -diff\n        cmovs   eax, edi      ; (-diff < 0)? diff : -diff\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214307,"user_id":null,"body":"global twice_as_old\ntwice_as_old: \n  lea rax,[rsi+rsi]\n  sub rax,rdi\n  cdq\n  xor rax,rdx\n  sub rax,rdx  \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214308,"user_id":null,"body":"section .text\nglobal twice_as_old\ntwice_as_old:              ; int twice_as_old(int dad, int son)\n                           ; input:  rdi = dad, rsi = son\n                           ; output: rax\n  lea rax, [rsi*2]\n  sub rax, rdi\n  jge .end\n  neg rax\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214309,"user_id":527,"body":"section .text\nglobal twice_as_old\n; int twice_as_old(int dad, int son)\ntwice_as_old:\n                mov     eax, edi\n                add     esi, esi\n                sub     eax, esi\n                sub     esi, edi\n                cmova   eax, esi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214310,"user_id":168,"body":"section .text\nglobal twice_as_old\ntwice_as_old:              ; int twice_as_old(int dad, int son)\n                           ; input:  edi = dad, esi = son\n                           ; output: rax\n  add esi, esi\n  sub edi, esi\n  mov eax, edi\n  neg edi\n  cmovns eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214311,"user_id":1277,"body":"section .text\nglobal twice_as_old\nextern abs\n\ntwice_as_old:\n  shl rsi, 1\n  sub rdi, rsi\n  jmp $abs","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214312,"user_id":null,"body":"section .text\nglobal twice_as_old\n; int twice_as_old(int dad, int son)\ntwice_as_old:\n  shl rsi,1\n  sub rdi,rsi\n  mov rax,rdi\n  mov rdx,rdi\n  neg rdx\n  cmovns rax,rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214313,"user_id":null,"body":"section .text\nglobal twice_as_old\ntwice_as_old:              ; int twice_as_old(int dad, int son)\n                           ; input:  rdi = dad, rsi = son\n                           ; output: rax\n  shl rsi, 1\n  sub rdi, rsi\n  mov rax, rdi\n  cmp rdi, 0\n  jl minus\n  ret\n  \nminus:\n  neg rdi\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214314,"user_id":null,"body":"section .text\nglobal twice_as_old\ntwice_as_old:              ; int twice_as_old(int dad, int son)\n                           ; input:  rdi = dad, rsi = son\n                           ; output: rax\n  xor rax, rax             ; Do your magic!\n  mov rax, rdi\n  sub rax, rsi\n  imul rax, 2\n  sub rax, rdi\n  cmp rax, 0\n  jge positive\n  imul rax, -1\npositive:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b93fecd8463745630001d05":[{"id":214315,"user_id":168,"body":"section .text\n\nglobal snail\nsnail:         ; int snail(int column, int day, int night) \n               ; edi = column\n               ; esi = day\n               ; edx = night\n  lea eax, [edi - 1]\n  sub eax, esi\n  js .one\n  sub esi, edx\n  xor edx, edx\n  div esi\n  add eax, 2\n  ret\n.one:\n  mov eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214316,"user_id":null,"body":"extern ceil\nsection .text\nglobal snail\nsnail:         ; int snail(int column, int day, int night) \n  cvtsi2ss xmm0, edi\n  cvtsi2ss xmm1, edx\n  sub esi, edx\n  cvtsi2ss xmm2, esi\n  subss xmm0, xmm1\n  divss xmm0, xmm2\n  roundss xmm0, xmm0, 10\n  cvttss2si ecx, xmm0\n  test ecx, ecx\n  push 1\n  pop rax\n  cmovg eax, ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214317,"user_id":null,"body":"section .text\nglobal snail\n\n; int snail(int column, int day, int night); rdi = column, rsi = day, rdx = night\nsnail:\n  xor rax, rax\n  mov r8, rdi\n  \n.walk:\n  inc rax\n  sub r8, rsi\n  jz .exit\n  js .exit\n\n.sleep:\n  add r8, rdx\n  jmp .walk\n  \n.exit:\n  ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214318,"user_id":50,"body":"section .text\nglobal snail\nsnail:         ; int snail(int column, int day, int night) \n               ; rdi = column\n               ; rsi = day\n               ; rdx = night\n  mov rax,1 ;\n_loop:\n  cmp rdi,rsi\n  jle _exit\n  inc rax\n  add rdi,rdx\n  sub rdi,rsi\n  jmp _loop\n_exit:\n  ret          ; return 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214319,"user_id":null,"body":"section .text\nglobal snail\n; <--- int {rax} snail(int {rdi} column, int {rsi} day, int {rdx} night) --->\nsnail:\n  mov rax, 1\n  sub rdi, rsi\n  jle end\n  sub rdx, rsi\nloop1:\n  inc rax\n  add rdi, rdx\n  jg loop1\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214320,"user_id":null,"body":"section .text\nglobal snail\nsnail:         ; int snail(int column, int day, int night) \n               ; rdi = column\n               ; rsi = day\n               ; rdx = night\n  sub rdi, rdx\n  mov rax, rdi\n  mov rcx, rsi\n  sub rcx, rdx\n  xor edx, edx\n  div rcx\n  test rdx, rdx\n  jz $+5\n  inc rax\n  ret          ; return 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214321,"user_id":null,"body":"section .text\nglobal snail\n\n; int snail(int column, int day, int night) \n; rdi = column\n; rsi = day\n; rdx = night\nsnail:\n  xor eax, eax\n  \n.Lloopstart:\n  inc rax\n  sub rdi, rsi ; with implicit compare with zero\n  jle .Lend\n  add rdi, rdx\n  jmp .Lloopstart\n  \n.Lend: \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214322,"user_id":null,"body":"section .text\nglobal snail\n\n; int snail(int column, int day, int night) \n; rdi = column\n; rsi = day\n; rdx = night\nsnail:\n  xor rax, rax\n  \n.Lloopstart:\n  inc rax\n  sub rdi, rsi\n  cmp rdi, 0\n  jle .Lend\n  add rdi, rdx\n  jmp .Lloopstart\n  \n.Lend: \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214323,"user_id":null,"body":"section .text\nglobal snail\nsnail:         ; int snail(int column, int day, int night) \n               ; rdi = column\n               ; rsi = day\n               ; rdx = night\n  xor rax, rax ; time\n  xor rcx, rcx ; heigth\n@mainloop:\n  inc rax\n  add rcx, rsi\n  cmp rcx, rdi\n  jge @end\n  sub rcx, rdx\n  jmp @mainloop\n@end:  \n  ret           ; return 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214324,"user_id":77,"body":"section .text\nglobal snail\nsnail:         ; int snail(int column, int day, int night) \n               ; rdi = column\n               ; rsi = day\n               ; rdx = night\n  sub rdi, rsi\n  jle .one\n  sub rsi, rdx\n  lea rax, [2*rsi+rdi-1]\n  xor rdx, rdx\n  div rsi\n  ret\n.one:\n  mov rax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5bb904724c47249b10000131":[{"id":214325,"user_id":null,"body":"global points\n\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n    \n    ; clear the register because the function will be\n    ; called multiple times\n    xor r15, r15 \n    \n    mov rcx, 10; number of strings in array\n    \n    ; the result will be stored to r15 and then\n    ; loaded to rax\n.loop:\n    ; move the address of string in rsi\n    mov rsi, rdi\n    mov rsi, [rsi]\n    \n    ; move first byte of string in rax\n    xor rax, rax\n    lodsb\n    \n    ; move that byte into rbx for later\n    mov rbx, rax\n    \n    ; ignore the ':' character\n    lodsb\n    \n    ; move the third byte to rax\n    xor rax, rax\n    lodsb\n    \n    ; if the string is '1:2' for ex\n    ; we will compare '1'(rax) with '2'(rbx)\n    cmp rbx, rax\n    jl .loop.back; if rbx < rax do nothing\n    je .loop.equal; if rbx = rax add 1 to r15\n    \n    ; if rbx > rax add 3 to r15\n    add r15, 3\n    jmp .loop.back\n    \n.loop.equal:\n    inc r15\n    \n.loop.back:\n    ; go to next string\n    add rdi, 8\n    loop .loop\n    \n    mov rax, r15\n    \n    ret\n; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214326,"user_id":null,"body":"global points\n\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n    xor eax, eax\n    xor rcx, rcx\n.loop:\n    mov rdx, qword [rdi + 8*rcx]\n    mov sil, byte [rdx]\n    mov dl, byte [rdx + 2]\n    cmp sil, dl\n    jl .loss\n    je .tie\n    add rax, 2\n.tie\n    add rax, 1\n.loss:\n    add rcx, 1\n    cmp rcx, 10\n    jl .loop \n    ret\n; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214327,"user_id":null,"body":"global points\nsection .text\npoints:\n    xor   eax,eax\n    mov   rcx,10\n    mov   r8w,3\n    xor   r9,r9\n    \n@l: mov    r10,[rdi + 8 * rcx - 8]\n    mov    dl,byte [r10 + 2]\n    cmp    dl,[r10]\n    sete   r9b\n    cmovl  r9w,r8w\n    add    eax,r9d\n    loop   @l\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214328,"user_id":null,"body":"global points\n\nsection .text\n; <--- unsigned points(const char *games[]) --->\npoints:\n    xor eax, eax        ; EAX <- the result\n    xor rsi, rsi\n    lppp:\n    cmp rsi, 10\n    je end\n    mov rcx, [rdi+rsi*8]\n    mov bl, [rcx]\n    sub bl, [rcx+2]\n    jz only\n    cmp bl, 0\n    jl nosc\n    add eax, 2\n    only:\n    add eax, 1\n    nosc:\n    add rsi, 1\n    jmp lppp\n    end:\n    ret\n; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214329,"user_id":null,"body":"global points\n\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n\txor\tecx, ecx\n\txor\teax, eax\nloop:\n\tmov\tr9, [rdi + 8*rcx]\n\tmov\tr8b, [r9]\n\txor\tesi, esi\n\txor\tedx, edx\n\tcmp\tr8b, [r9 + 2]\n\tsetg\tsil\n\tsetl\tdl\n\tsub\teax, edx\n\tlea\teax, [rax + 2*rsi]\n\tinc\teax\n\tinc\trcx\n\tcmp\trcx, 10\n\tjne\tloop\n  ret\n; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214330,"user_id":null,"body":"global points\n\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n    xor r8d, r8d        ; edx = sum of points so far\n    mov dx,'0:'         ; cached constants: dl = '0', dh = ':'\n    mov rcx, 10         ; 10 strings in games[]\n.loop:    \n    mov rsi, [rdi]      ; rsi = string item\n    add rdi, 8          ; to next item\n    lodsw\n    sub al, dl          ; char[0] must be a digit\n    jb .invalid         ; invalid format\n    mov bl, al          ; bl = first part of result (x)\n    cmp ah, dh          ; char[1] must be a colon\n    jne .invalid        ; invalid format\n    lodsw               ; al = second part of result (y)\n    sub al, dl          ; char[2] must be a digit\n    jb .invalid         ; invalid format\n    test ah, ah         ; char[3] must be 0 = end of string\n    jnz .invalid        ; invalid format\n    cmp bl,al\n    jb .zero            ; case x < y   : 0 points\n    je .one             ; case x == y  : add 1 point\n    add r8d, 2          ; other, x > y : add 2 + 1 = 3 points\n.one:\n    inc r8d\n.zero:\n.invalid:               ; ignore invalid result format\n    loop .loop\n    mov eax, r8d        ; return sum of points\n    ret\n; ---------> endof pts <---------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214331,"user_id":null,"body":"global points\nextern puts\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n    mov   ecx, 10\n    mov   r9d , 3\n    mov   r11d, 1\n    xor   eax, eax\n    .loop:\n    mov   r8, [rdi] ;current string ptr\n    mov   bl, byte [r8]\n    mov   dl, byte [r8+2]\n    xor   r12d, r12d\n    cmp   bl, dl\n    cmovg r12d, r9d\n    cmove r12d, r11d\n    add   eax, r12d\n    add   rdi, 8\n    loop  .loop\n    ret\n; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214332,"user_id":null,"body":"global points\n\nsection .text\n\npoints:\n; <--- unsigned points(const char *games[]) --->\n        lea     rcx, [ rdi + 80 ]             ; games+10\n        xor     r8d, r8d                      ; points = 0\n.loop:\n        mov     rax, [ rdi ]                  ; *g \n        movsx   edx, byte [ rax ]             ; (*g)[0]\n        movsx   eax, byte [ rax + 2 ]         ; (*g)[2]\n        sub     edx, eax                      ; diff\n        xor     eax, eax\n        test    edx, edx\n        mov     edx, 3\n        setz    al                            ; 1 if diff 0\n        cmovg   eax, edx                      ; 2 if diff > 0\n        add     r8d, eax                      ; points += diff\n        add     rdi, 8                        ; g++\n        cmp     rcx, rdi                      ; g == games+10\n        jne     .loop\n        mov     eax, r8d\n        ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214333,"user_id":null,"body":"global points\n\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n    xor  eax, eax        ; EAX <- the result\n    xor  r9, r9\n    xor  r10, r10\n    xor  r11, r11\n    xor  rbx, rbx\n    \n_loop:\n  cmp  r9, 10\n  je   _exit\n  mov  rbx, [rdi + r9 * 8]\n  inc  r9\n  movsx r10, byte[rbx]  ;byte to quadword\n  movsx r11, byte[rbx + 2]\n  cmp  r10, r11\n  jg  _plus3  ;great\n  je  _plus1\n  jmp _loop\n_plus3:\n  add eax, 3\n  jmp _loop\n_plus1:\n  inc  eax\n  jmp  _loop\n_exit:\n    \n    ret; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214334,"user_id":50,"body":"global points\n\nsection .text\n\n; <--- unsigned points(const char *games[]) --->\npoints:\n    xor eax, eax        ; EAX <- the result\n    xor r9,r9 ; index\n    xor r10,r10 ; first value\n    xor r11,r11 ; snd value\n    xor rbx,rbx ; tmp\n_loop:\n  cmp r9,10\n  je _exit\n  mov rbx,[rdi+r9*8]\n  inc r9\n  movsx r10,byte[rbx]\n  movsx r11,byte[rbx+2]\n  cmp r10,r11\n  jg _plus3\n  je _plus1\n  jmp _loop\n_plus3:\n  add eax,3\n  jmp _loop\n_plus1:\n  inc eax\n  jmp _loop\n_exit:\n    ret\n; ---------> endof pts <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5bbb8887484fcd36fb0020ca":[{"id":214335,"user_id":null,"body":"section .text\n\nglobal catch_sign_change\n\n;; int catch_sign_change(const int* arr, size_t sz)\n;; sizeof(int) == 4\n;; sizeof(size_t) == 8\ncatch_sign_change:\n  xor eax, eax\n  test rsi, rsi\n  je .done\n  mov rcx, 1\n.loop:\n  cmp rsi, rcx\n  je .done\n  mov edx, [rdi + 4*rcx]\n  xor edx, [rdi + 4*rcx - 4]\n  shr edx, 31\n  add eax, edx\n  inc rcx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214336,"user_id":50,"body":"section .text\n\nglobal catch_sign_change\n\ncatch_sign_change:\n  xor eax, eax\n  cmp rsi,2\n  jl _exit\n  xor r8,r8 \n  xor r9,r9\n  xor r11,r11\n  mov r10,1\n  mov r11d,[rdi]\n  cmp r11d,0\n  jl _a\n  jmp _loop\n_a:\n  mov r8,1\n_loop:\n  cmp r10,rsi \n  jge _exit\n  mov r11d,[rdi+4*r10]\n  cmp r11d,0\n  jl _b ; n<0\n  mov r9,0\n  jmp _cmp\n_b:\n  mov r9,1\n_cmp:\n  cmp r8,r9\n  jne _inc\n  inc r10\n  mov r8,r9\n  jmp _loop\n_inc:\n  inc rax\n  inc r10\n  mov r8,r9\n  jmp _loop\n_exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214337,"user_id":null,"body":"section .text\nglobal catch_sign_change\ncatch_sign_change:\n  xor eax, eax\n  dec rsi\n  jmp .s\n  .b:mov edx,[rdi+rsi*4+4]\n     xor edx,[rdi+rsi*4]\n     shr edx,31\n     add eax,edx\n  .s:dec rsi\n  jnl .b\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214338,"user_id":null,"body":"section .text\n\nglobal catch_sign_change\n\ncatch_sign_change:\n  xor rax, rax ; counter\n  cmp rsi, 2\n  jl  .end\n  \n.check_last:\n  dec rsi\n  cmp rsi, 0\n  je  .end\n  xor rdx, rdx       ; last number is negative\n  xor rcx, rcx       ; current number is negative\n  cmp dword[rdi], 0\n  jnl .check_this\n\n.last_neg:\n  mov rdx, 1\n  \n.check_this:\n  cmp dword[rdi + 4], 0\n  jnl  .compare\n\n.this_neg:\n  mov rcx, 1\n\n.compare:\n  cmp rdx, rcx\n  je  .next\n  inc rax\n\n.next:\n  add rdi, 4\n  jmp .check_last\n  \n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214339,"user_id":null,"body":"section .text\n\nglobal catch_sign_change\n\n;; int catch_sign_change(const int* arr, size_t sz)\n;; sizeof(int) == 4\n;; sizeof(size_t) == 8\n;rdi \/ rsi \/ rcx \/ rdx\n\ncatch_sign_change:\n  xor eax, eax\n  cmp rsi,1\n  jbe .end\n  \n    mov eax,[rdi]\n    cmp eax,0\n    jl .esmeno\n    mov dx,0\n    jmp .continue1\n    .esmeno:\n    mov dx,1 \n    .continue1:\n  \n  xor ebx,ebx\n  mov rcx,1\n  .loop:\n  mov eax,[rdi+rcx*4]\n  \n    cmp eax,0\n    jl .menor\n      cmp dx,0\n      je .continue\n      inc ebx\n      mov dx,0\n      jmp .continue\n    .menor:\n      cmp dx,1\n      je .continue\n      inc ebx\n      mov dx,1\n    .continue:\n  inc rcx\n  cmp rcx,rsi\n  jb .loop\n  mov eax,ebx\n  .end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214340,"user_id":null,"body":"global catch_sign_change\n\nsection .text\n\ncatch_sign_change:\n  xor  rax, rax\n  cmp  rsi, 2\n  js   return\n  mov  ecx, dword [rdi]\n  add  rdi, 4\n  dec  rsi\n.loop_start:\n  mov  edx, dword [rdi]\n  mov  r8d, edx\n  shr  ecx, 31\n  shr  edx, 31\n  xor  edx, ecx\n  add  eax, edx\n  mov  ecx, r8d\n  add  rdi, 4\n  dec  rsi\n  test rsi, rsi\n  jnz  .loop_start\nreturn:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214341,"user_id":168,"body":"section .text\n\nglobal catch_sign_change\n\n;; int catch_sign_change(const int* arr, size_t sz)\n;; sizeof(int) == 4\n;; sizeof(size_t) == 8\ncatch_sign_change:\n  xor eax, eax\n  xor ecx, ecx\n  jmp .loop_cond\n.loop:\n  mov edx, dword [rdi + rcx * 4 - 4]\n  xor edx, dword [rdi + rcx * 4]\n  rcl edx, 1\n  adc eax, 0\n.loop_cond:\n  inc rcx\n  cmp rsi, rcx\n  ja .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214342,"user_id":null,"body":"section .text\n\nglobal catch_sign_change\n\n;; int catch_sign_change(const int* arr, size_t sz)\n;; sizeof(int) == 4\n;; sizeof(size_t) == 8\ncatch_sign_change:\n  xor eax, eax       ; sum = 0\n  dec rsi            ; fix up iteration count\n.loop:\n  dec rsi            ; need at least one number left\n  test rsi, rsi      ; any iterations left?\n  js .done           ; exit if sz is negative\n  mov ecx, [rdi]     ; load first number\n  add rdi, 4\n  xor ecx, [rdi]     ; get bit difference from second number\n  shr ecx, 31        ; shift sign difference bit into LSB\n  add eax, ecx       ; add difference to accumulator\n  jmp .loop          ; loop\n.done:\n  ret                ; return sum\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5bdcd20478d24e664d00002c":[{"id":214343,"user_id":null,"body":"global wheat_from_chaff\nextern malloc\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n  push rbp\n  mov rbp, rsi\n  push rbx\n  mov rbx, rdi\n  lea rdi, [rsi*8]\n  push rcx\n  call malloc\n  lea rcx, [rbp-1]\n  xor edx, edx\n.loop:\n  cmp rdx, rcx\n  jg .done\n  cmp rdx, rbp\n  mov r9, rdx\n  jnb .endcurs\n  mov rsi, [rbx+rdx*8]\n  lea rdi, [rdx*8]\n  test rsi, rsi\n  jns .endcurs\n  mov [rax+rdi], rsi\n  inc rdx\n  mov rdi, rcx\n  jmp .next\n.endcurs:\n  test rcx, rcx\n  mov rsi, [rbx+rcx*8]\n  lea r8, [rax+rcx*8]\n  lea rdi, [rcx-1]\n  js .swap\n  test rsi, rsi\n  jle .swap\n  mov [r8], rsi\n  jmp .next\n.swap:\n  mov rcx, [rbx+r9*8]\n  mov [rax+r9*8], rsi\n  inc rdx\n  mov [r8], rcx\n.next:\n  mov rcx, rdi\n  jmp .loop\n.done:\n  pop rdx\n  pop rbx\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214344,"user_id":null,"body":"global wheat_from_chaff\nextern malloc\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n  push rdi\n  push rsi\n  push rbx\n  \n  lea rdi, [rsi*8]\n  call malloc\n  test rax, rax\n  je .done\n  \n  mov rcx, [rsp+8]\n  mov rdi, rax\n  mov rsi, [rsp+16]\n  rep movsq\n  \n  mov rcx, [rsp+8]\n  mov rsi, rax\n  lea rdi, [rax+rcx*8-8]\n  \n.loop1:\n  cmp qword [rsi], 0\n  jg .loop2\n  add rsi, 8\n  cmp rdi, rsi\n  jg .loop1\n  jmp .done\n\n.loop2:\n  cmp qword [rdi], 0\n  jl .next\n  sub rdi, 8\n  cmp rdi, rsi\n  jg .loop2\n  jmp .done\n\n.next:\n  mov rcx, [rsi]\n  mov rdx, [rdi]\n  mov [rsi], rdx\n  mov [rdi], rcx\n  add rsi, 8\n  sub rdi, 8\n  cmp rdi, rsi\n  jg .loop1\n\n.done:\n  pop rbx\n  pop rsi\n  pop rdi\n  ret\n; ---------> endof wheat_from_chaff <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214345,"user_id":null,"body":"global wheat_from_chaff\nextern malloc\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n  push rdi\n  push rsi\n  push rbx\n  \n  lea rdi, [rsi*8]\n  call malloc\n  test rax, rax\n  je .done\n  \n  mov rcx, [rsp+8]\n  mov rdi, rax\n  mov rsi, [rsp+16]\n  rep movsq\n  \n  mov rcx, [rsp+8]\n  mov rsi, rax\n  lea rdi, [rax+rcx*8-8]\n  \n.loop1:\n  cmp qword [rsi], 0\n  jg .loop2\n  add rsi, 8\n  cmp rdi, rsi\n  jle .done\n  jmp .loop1\n\n.loop2:\n  cmp qword [rdi], 0\n  jl .next\n  sub rdi, 8\n  cmp rdi, rsi\n  jle .done\n  jmp .loop2\n\n.next:\n  mov rcx, [rsi]\n  mov rdx, [rdi]\n  mov [rsi], rdx\n  mov [rdi], rcx\n  add rsi, 8\n  sub rdi, 8\n  cmp rdi, rsi\n  jg .loop1\n\n.done:\n  pop rbx\n  pop rsi\n  pop rdi\n  ret\n; ---------> endof wheat_from_chaff <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214346,"user_id":null,"body":"global wheat_from_chaff\n\nextern malloc\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n        push    r12\n        mov     r12d, esi\n        push    rbp\n        mov     rbp, rdi\n        push    rbx\n        mov     rbx, r12\n        sal     r12, 3\n        mov     rdi, r12\n        call    malloc\n        mov     rsi, rbp\n        mov     rcx, r12\n        mov     rdi, rax\n        rep movsb\n        lea     esi, [rbx-1]\nloop:\n        movsx   rdx, ecx\n        lea     r10, [rax+rdx*8]\n        mov     r9, QWORD [r10]\n        test    r9, r9\n        js      L3\nL6:\n        movsx   rdx, esi\n        jmp     L4\nL3:\n        cmp     ecx, ebx\n        jnb     L6\n        inc     ecx\n        jmp     loop\nL4:\n        mov     r11, QWORD [rax+rdx*8]\n        mov     edi, edx\n        mov     esi, edx\n        lea     rbp, [rax+rdx*8]\n        not     edi\n        dec     rdx\n        mov     r8, r11\n        shr     edi, 31\n        not     r8\n        shr     r8, 63\n        test    r8b, dil\n        jne     L4\n        cmp     ecx, esi\n        jge     done\n        mov     QWORD [r10], r11\n        mov     QWORD [rbp+0], r9\n        jmp     loop\ndone:\n        pop     rbx\n        pop     rbp\n        pop     r12\n        ret\n  ; ---------> endof wheat_from_chaff <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214347,"user_id":null,"body":"global wheat_from_chaff\nextern malloc, memcpy\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n    push rbx ; rbx will hold the len of the array\n    push rbp ; rbp will hold the ptr to the array\n    push r12 ; r12 will hold the ptr to the return array\n    mov rbp, rdi\n    mov rbx, rsi\n    lea rdi, [rbx*8]\n    call malloc\n    mov r12, rax\n    mov rdi, r12\n    mov rsi, rbp\n    lea rdx, [rbx*8]\n    call memcpy ; copy the const array to the new one\n    xor r8, r8 ; r8 will hold the negative index\n    lea r9, [rbx - 1] ; r9 will hold the positive index\n.find_positive:\n    cmp r8, r9\n    jae .done\n    cmp QWORD [r8*8+r12], 0\n    jg .find_negative\n    inc r8\n    jmp .find_positive\n.find_negative:\n    cmp r8, r9\n    jae .done\n    cmp QWORD [r9*8+r12], 0\n    jg .is_positive\n    mov rcx, [r9*8+r12]\n    xchg rcx, [r8*8+r12]\n    mov [r9*8+r12], rcx\n    inc r8\n    dec r9\n    jmp .find_positive\n.is_positive:\n    dec r9\n    jmp .find_negative\n.done:\n    mov rax, r12\n    pop r12\n    pop rbp\n    pop rbx\n    ret\n; ---------> endof wheat_from_chaff <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214348,"user_id":527,"body":"global wheat_from_chaff\nextern malloc\n\nsection .text\n\n; long long *wheat_from_chaff(const long long *crops, size_t count)\nwheat_from_chaff:\n                shl     rsi, 3\n                push    rdi\n                push    rsi\n                push    rbp\n                mov     rdi, rsi\n                call    malloc\n                pop     rbp\n                xor     esi, esi\n                pop     rdi\n                pop     rdx\n                sub     rsi, 8\n.loop_i:        add     rsi, 8\n                cmp     rsi, rdi\n                jae     .done\n                mov     rcx, [rdx + rsi]\n                mov     [rax + rsi], rcx\n                test    rcx, rcx\n                js      .loop_i\n.loop_j:        sub     rdi, 8\n                cmp     rsi, rdi\n                jae     .done\n                mov     rcx, qword [rdx + rdi]\n                mov     [rax + rdi], rcx\n                test    rcx, rcx\n                jns     .loop_j\n                mov     r8, [rdx + rsi]\n                mov     r9, [rdx + rdi]\n                mov     [rax + rdi], r8\n                mov     [rax + rsi], r9\n                jmp     .loop_i\n.done:          ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214349,"user_id":743,"body":"global wheat_from_chaff\nextern malloc\n\nsection .text\n; rax                                          rdi           rsi\n; long long* wheat_from_chaff(const long long* crops, size_t count);\nwheat_from_chaff:\n  push rcx\n  push rdi\n  push rsi\n  lea rdi, [rsi * 8]\n  call malloc\n  mov rdi, rax\n  pop rcx\n  pop rsi\n  rep movsq\n  pop rcx\n  mov rsi, rax\n  sub rdi, 8\n.loop1:\n.loop2:\n  cmp rsi, rdi\n  jnb .endl2\n.loop2_:\n  mov rdx, [rsi]\n  test rdx, rdx\n  jns .endl2\n  add rsi, 8\n  cmp rsi, rdi\n  jb .loop2_\n.endl2:\n.loop3:\n  cmp rsi, rdi\n  jnb .endl3\n.loop3_:\n  mov rcx, [rdi]\n  test rcx, rcx\n  js .endl3\n  sub rdi, 8\n  cmp rsi, rdi\n  jb .loop3_\n.endl3:\n  cmp rsi, rdi\n  jnb .endl1\n  mov [rdi], rdx\n  mov [rsi], rcx\n  sub rdi, 8\n  add rsi, 8\n  jmp .loop1\n.endl1:\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214350,"user_id":168,"body":"global wheat_from_chaff\nextern malloc, memcpy\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n  push rbp\n  push rbx\n  push rdx\n  mov rbp, rdi  ; crops\n  mov rbx, rsi  ; count\n  lea rdi, [rsi * 8]\n  call malloc\n  mov rdi, rax\n  mov rsi, rbp\n  lea rdx, [rbx * 8]\n  call memcpy\n  lea rdi, [rax - 8]\n  lea rsi, [rax + rbx * 8]\n.loop:\n.find_pos:\n  add rdi, 8\n  cmp rdi, rsi\n  jae .end\n  mov rdx, [rdi]\n  test rdx, rdx\n  js .find_pos\n.find_neg:\n  sub rsi, 8\n  cmp rdi, rsi\n  jae .end\n  mov rcx, [rsi]\n  test rcx, rcx\n  jns .find_neg\n  mov [rdi], rcx\n  mov [rsi], rdx\n  jmp .loop\n.end:\n  pop rdx\n  pop rbx\n  pop rbp\n  ret\n; ---------> endof wheat_from_chaff <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214351,"user_id":null,"body":"global wheat_from_chaff\nextern malloc\n\nsection .text\n\n; <--- long long *wheat_from_chaff(const long long *crops, size_t count) --->\nwheat_from_chaff:\n    push rbx                ; saving RBX in the stack\n    push rsi                ; saving <count> in the stack\n    push rdi                ; saving <crops> in the stack\n    lea rdi, [rsi*8]        ; the size for <sep>\n    call malloc             ; allocating memory for <sep>\n    pop rdi                 ; restoring <crops> from the stack\n    pop rcx                 ; restoring <count> from the stack as <n>\n    test rax, rax           ; whether the memory is allocated\n    je .exit                ; otherwise, jumping to exit\n    xor rsi, rsi            ; resetting RSI as <srch>\n    xor rbx, rbx            ; resetting RBX as <p>\n    dec rcx                 ; decrementing <n>\n.loop:\n    cmp rbx, rcx            ; whether <p> is less than <n>\n    jge .done               ; otherwise, jumping to the .done section\n    test rsi, rsi           ; whether <srch> is set\n    jne .srch               ; jumping to the .srch section\n    mov rdx, [rdi+rbx*8]    ; copying <*(crops+p)> to <crop>\n    test rdx, rdx           ; whether <crop> is greater than zero\n    setg sil                ; setting <srch> to true\n    jg .loop                ; jupming to the next iteration\n    mov [rax+rbx*8], rdx    ; copying <crop> to <*(sep+p)>\n    inc rbx                 ; incrementing <p>\n    jmp .loop               ; jumping to the next iteration\n.srch:\n    mov rdx, [rdi+rcx*8]    ; copying <*(crops+n)> to <crop>\n    test rdx, rdx           ; whether <crop> is greater than zero\n    jg .sep                 ; jumping to the .sep section\n    mov [rax+rbx*8], rdx    ; copying <crop> to <*(sep+p)>\n    mov rdx, [rdi+rbx*8]    ; copying <*(crops+p)> to <crop>\n    inc rbx                 ; incrementing <p>\n    xor rsi, rsi            ; restting <srch>\n.sep:\n    mov [rax+rcx*8], rdx    ; copying <crop> to <*(sep+n)>\n    dec rcx                 ; decrementing <n>\n    jmp .loop               ; jumping to the next iteration\n.done:\n    jg .exit                ; jumping to exit in case <p> is greater than <n>\n    mov rdx, [rdi+rbx*8]    ; copying <*(crops+p)> to <crop>\n    mov [rax+rcx*8], rdx    ; copying <crop> to <*(sep+p)>\n.exit:\n    pop rbx                 ; restoring the initial RBX from the stack\n    ret\n; ---------> endof wheat_from_chaff <---------","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5c5086287bc6600001c7589a":[{"id":214352,"user_id":1196,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  movd eax, xmm0\n  cmp eax, __float32__(-0.0)\n  sete al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214353,"user_id":168,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  movd eax, xmm0\n  rol eax, 1\n  cmp eax, 1\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214354,"user_id":null,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  movd eax, xmm0\n  cmp eax, -2147483648\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214355,"user_id":null,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  movd ecx, xmm0\n  cmp ecx, 0x80000000\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214356,"user_id":null,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  xor       al,  al\n  movd      ecx, xmm0\n  cmp       ecx, 0x80000000\n  setz      al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214357,"user_id":50,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  xor eax, eax\n  movd eax,xmm0\n  cmp eax, 0x80000000\n  je _retTrue\n  mov eax,0\n  ret\n_retTrue:\n  mov eax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214358,"user_id":null,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n    movq  rax,xmm0          ; load the float inti rax\n    cmp   rax,[neg_zero]    ; simple binary compare\n    setz  al                ; return true\/false in al\n    ret\n    \nSECTION .DATA\nneg_zero dq 0x80000000      ; = -0.0 (MSB is sign bit)","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214359,"user_id":null,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n; float parameter is in xmm0\n  movd eax, xmm0 ; move to the integer register\n  cmp eax, 0x80000000 ; and compare it with the bit pattern for -0.0f\n  sete al ; when equal then set to a value that is not zero\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214360,"user_id":null,"body":"global isNegativeZero\n\nsection .text\nisNegativeZero:\n    movd eax, xmm0\n    cmp eax, __float32__(-0.0)\n    sete al\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214361,"user_id":null,"body":"SECTION .TEXT\nglobal isNegativeZero\n\nisNegativeZero:\n  movq rax, xmm0\n  mov rbx, 0x80000000\n  cmp rax, rbx\n  jnz not_minus_zero\n  \nminus_zero:\n  mov rax, 1\n  jmp end\n\nnot_minus_zero:\n  xor rax, rax\n\nend:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5c80b55e95eba7650dc671ea":[{"id":214362,"user_id":null,"body":"global complete_binary_tree\n\nsection .text\n\n; size_t complete_binary_tree(int *tree, const int *input, const size_t length)\n; Parameters: RDI  tree - int[length] array to place tree nodes\n;             RSI  input - const int[length] array of in-order-traversal data\n;             RDX  length - size of tree, input array\n; Return value: RAX  number of elements in tree\ncomplete_binary_tree:\n  push rbx\n  sub rsp, 16\n  lea r8, [rsp + 8]\n  xor ecx, ecx\n  mov rbx, rdx\n  and qword [r8], 0\n  call recurse\n  mov rax, rbx\n  add rsp, 16\n  pop rbx\n  ret\nrecurse:\n  push r15\n  push r14\n  push r13\n  push r12\n  push rbx\n  mov r14, r8\n  mov rbx, rcx\n  mov r15, rdx\n  mov r12, rsi\n  mov r13, rdi\n.tailrecurse:\n  cmp rbx, r15\n  jae .done\n  lea rcx, [rbx + rbx + 1]\n  mov rdi, r13\n  mov rsi, r12\n  mov rdx, r15\n  mov r8, r14\n  call recurse\n  mov rax, [r14]\n  lea rcx, [rax + 1]\n  mov [r14], rcx\n  mov eax, [r12 + 4*rax]\n  mov [r13 + 4*rbx], eax\n  add rbx, rbx\n  add rbx, 2\n  jmp .tailrecurse\n.done:\n  pop rbx\n  pop r12\n  pop r13\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214363,"user_id":null,"body":"global complete_binary_tree\n\nsection .text\n\n; size_t complete_binary_tree(int *tree, const int *input, const size_t length)\n; Parameters: RDI  tree - int[length] array to place tree nodes\n;             RSI  input - const int[length] array of in-order-traversal data\n;             RDX  length - size of tree, input array\n; Return value: RAX  number of elements in tree\ncomplete_binary_tree:\n    push rbp\n    mov rbp, rsp\n    test rdx, rdx\n    jz .done\n    push -1\n.loop:\n    cmp rsp, rbp\n    je .done\n\n    pop rcx\n    test rcx, rcx\n    js .go_left\n    \n.visit:\n    lodsd\n    mov [rdi+rcx*4], eax\n    \n.go_right:\n    lea rax, [rcx*2+2]\n    cmp rax, rdx\n    jae .loop\n    \n.push_next:\n    neg rax\n    dec rax\n    push rax\n    jmp .loop\n    \n.go_left:\n    neg rcx\n    dec rcx\n    push rcx\n    lea rax, [rcx*2+1]\n    cmp rax, rdx\n    jb .push_next\n    jmp .loop\n    \n.done:\n    mov rax, rdx\n    pop rbp\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214364,"user_id":null,"body":"[BITS 64]\n\nsection .text\n\n;;\n; C-signature:\n;     void *calloc(size_t num_elements, size_t size_element)\n;     [rax]        [rdi]                [rsi]\nextern calloc\n\n;;\n; C-signature\n;     void free(void *ptr)\n;               [rdi]\nextern free\n\nglobal complete_binary_tree\n;;\n; C-signature:\n;     size_t *complete_binary_tree(int *tree, const int *input, const size_t length)\n;     [rax]                       [rdi]       [rsi]             [rdx]\n;\n; Build a complete binary tree from the given list of integers (input)\n; and store the result in array (tree) where the nodes of the tree are in\n; order of their levels and from left to right (breadth-first search order).\n; Return the number of elements in the result array (tree).\n;\n; This function assumes that:\n;     (1) the given result pointer (tree) is valid.\n;     (2) the given input pointer (input) is valid.\n;     (2) the given size (length) is equal to the actual size of the input\n;         array (input) and also the result array (tree)\n;\n; @param tree   [rdi] pointer to array (tree)\n; @param input  [rsi] pointer to array (input)\n; @param length [rdx] length of the arrays (tree) and (input)\n; @return the number of elements in (tree) after storing the complete binary\n;         tree generated from array (input) in breadth-first traversal order\n;\n; +-------------------------------------------------------+\n; | Memory Layout                                         |\n; +------------+------------------------------------------+\n; | rbp + 0x08 | return address                           |\n; | rbp        | previous rbp value                       |\n; | rbp - 0x08 | tree pointer                             |\n; | rbp - 0x10 | input pointer                            |\n; | rbp - 0x18 | length of tree and input                 |\n; | rbp - 0x20 | index array pointer (list of idx_triple) |\n; | rbp - 0x28 | saved rbx value                          |\n; | rbp - 0x30 | local variable: left                     |\n; | rbp - 0x38 | local variable: middle                   |\n; | rbp - 0x40 | local variable: right                    |\n; +------------+------------------------------------------+\n%define TREE_ARRAY    rbp - 0x08\n%define INPUT_ARRAY   rbp - 0x10\n%define INPUT_LENGTH  rbp - 0x18\n%define INDEX_ARRAY   rbp - 0x20\n%define SAVED_RBX     rbp - 0x28\n%define VAR_LEFT      rbp - 0x30\n%define VAR_MIDDLE    rbp - 0x38\n%define VAR_RIGHT     rbp - 0x40\n; typedef struct idx_triple\n; {\n;     long long int left;\n;     long long int middle;\n;     long long int right;\n; } idx_triple;\n%define OFFSET_LEFT         0x00\n%define OFFSET_MIDDLE       0x08\n%define OFFSET_RIGHT        0x10\ncomplete_binary_tree:\n\tpush rbp\n\tmov rbp, rsp\n\tsub rsp, 0x50\n\t; Note: We use rbx as a base pointer and rbx is a callee-saved register.\n\tmov [SAVED_RBX], rbx\n\n\t; We save our function arguments on the stack to free up some registers.\n\tmov [TREE_ARRAY], rdi\n\tmov [INPUT_ARRAY], rsi\n\tmov [INPUT_LENGTH], rdx\n\n\t; Note: For our solution, we first build an index list that contains\n\t; three values for each entry. The leftmost index, rightmost index, and\n\t; the calculated optimal midpoint of the respective range.\n\t; We build our binary tree by searching for the midpoint that is optimal\n\t; for filling the left side of the tree as complete as possible. \n\t; After finding the midpoint of the first range [0, length - 1], we save\n\t; the index of the midpoint and continue with the ranges on the left\n\t; [0, midpoint - 1] and on the right [midpoint + 1, length - 1]. This is\n\t; a recursive algorithm that we use iteratively. We stop on using up all\n\t; possible indices of our original array. We store the results of each step\n\t; further down the result list much like we would fill a heap-array where\n\t; child-nodes are stored at positions 2i and 2i + 1 (i >= 1) respectively.\n\t;\n\t; Each element in our list is 24 bytes wide. We use calloc to initialize\n\t; all elements with zero values.\n\tmov rdi, rdx\n\tmov rsi, 24\n\tcall calloc WRT ..plt\n\n\tmov [INDEX_ARRAY], rax\n\t; Here, we set our base pointer to the beginning of the index array.\n\tmov rbx, rax\n\t\n\t; Note: Our first element (the root) is calculated outside the loop.\n\tmov qword [VAR_LEFT], 0\n\tmov qword [rbx + OFFSET_LEFT], 0\n\tmov rax, [INPUT_LENGTH]\n\tmov rdi, rax\n\tdec rax\n\tmov [VAR_RIGHT], rax\n\tmov [rbx + OFFSET_RIGHT], rax\n\tcall partition\n\n\tmov [VAR_MIDDLE], rax\n\tmov [rbx + OFFSET_MIDDLE], rax\n\n\t; We interate over each element of our index array starting with element\n\t; zero (which we calculated before). At each step, we insert two new\n\t; elements if they do not lay outside of the index array's bounds. This\n\t; way we get a new valid element each time we increment our index.\n\txor ecx, ecx\n.while_loop:\n\tcmp rcx, [INPUT_LENGTH]\n\tjge .end_while_loop\n\t\n\t; We multiply the index with 24 to get the right offset from the beginning\n\t; of the index array. This calculate will be used multiple times in this\n\t; loop. Instead of using multiply we use shift and load effective address\n\t; calculation. (x = i << 3 = 8i => x' = 8i + 8i * 2 = 3 * 8i = 24*i)\n\tmov rdx, rcx\n\tshl rdx, 3\n\tlea rdx, [rdx + rdx * 2]\n\t; Now, rdx becomes the pointer to the element at index rcx.\n\tadd rdx, rbx\n\n\tmov rax, [rdx + OFFSET_LEFT]\n\tmov [VAR_LEFT], rax\n\n\tmov rax, [rdx + OFFSET_MIDDLE]\n\tdec rax\n\tmov [VAR_RIGHT], rax\n\n\t; If our left bound is greater that our right bound, we stop moving the\n\t; right bound to the left. In this case, there is no left subtree.\n\tcmp [VAR_LEFT], rax\n\tjg .no_left_subtree\n\t; Now, we have to check if our next index would point outside our index\n\t; list. ( 2 * index + 1 < length)\n\tmov rsi, rcx\n\tshl rsi, 1\n\tinc rsi\n\tcmp rsi, [INPUT_LENGTH]\n\t; If the index falls outside the array, we have no left subtree to add.\n\tjge .no_left_subtree\n\n\t; Here, we have a left subtree and add the respective index array element\n\t; with left, right, and middle indices.\n\tshl rsi, 3\n\tlea rsi, [rsi + rsi * 2]\n\tlea rsi, [rsi + rbx] ; index into the list at (index * 2 + 1)\n\tmov rax, [VAR_LEFT]\n\tmov [rsi + OFFSET_LEFT], rax\n\tmov rax, [VAR_RIGHT]\n\tmov [rsi + OFFSET_RIGHT], rax\n\t; We already point to our index array element with rsi, so we preserve it\n\t; while calculating the next midpoint.\n\tpush rsi\n\tmov rdi, [VAR_RIGHT]\n\tsub rdi, [VAR_LEFT]\n\tinc rdi\n\tcall partition\n\t; Note: We add the left bound to correct for the starting point of the\n\t; range the midpoint is calculated for. Otherwise, our index would point\n\t; somewhere into the left subtree relative to our original array.\n\tadd rax, [VAR_LEFT]\n\tpop rsi\n\tmov [rsi + OFFSET_MIDDLE], rax\n\n.no_left_subtree:\n\t; Now, we repeat our calculation of the right subtree. Here, we use\n\t; (2 * index + 2) as the next index into our index array.\n\tmov rdx, rcx\n\tshl rdx, 3\n\tlea rdx, [rdx + rdx * 2]\n\tadd rdx, rbx\n\n\tmov rax, [rdx + OFFSET_MIDDLE]\n\tinc rax\n\tmov [VAR_LEFT], rax\n\tmov rax, [rdx + OFFSET_RIGHT]\n\tmov [VAR_RIGHT], rax\n\tcmp [VAR_LEFT], rax\n\tjg .no_right_subtree\n\tmov rsi, rcx\n\tshl rsi, 1\n\tadd rsi, 2\n\tcmp rsi, [INPUT_LENGTH]\n\tjge .no_right_subtree\n\n\tshl rsi, 3\n\tlea rsi, [rsi + rsi * 2]\n\tlea rsi, [rsi + rbx]\n\n\tmov rax, [VAR_LEFT]\n\tmov [rsi + OFFSET_LEFT], rax\n\tmov rax, [VAR_RIGHT]\n\tmov [rsi + OFFSET_RIGHT], rax\n\n\tpush rsi\n\tmov rdi, [VAR_RIGHT]\n\tsub rdi, [VAR_LEFT]\n\tinc rdi\n\tcall partition\n\tadd rax, [VAR_LEFT]\n\tpop rsi\n\tmov [rsi + OFFSET_MIDDLE], rax\n\n.no_right_subtree:\n\t; Last but not least, we increment to the next index in our index array.\n\tinc rcx\n\tjmp .while_loop\n.end_while_loop:\n\n\t; Note: Now, we have calculated an array of indices. They represent the\n\t; permutation necessary to convert the original array into the resulting\n\t; complete binary tree. All we have to do now is to copy the elements at\n\t; the respective indices into our tree array.\n\txor ecx, ecx\n\tmov rdx, rbx\n\tmov rdi, [TREE_ARRAY]\n\t; Note: We add the offset into the array element here instead of adding\n\t; it to every element inside the loop.\n\tadd rdx, OFFSET_MIDDLE\n.for_loop:\n\tcmp rcx, [INPUT_LENGTH]\n\tjge .end_for_loop\n\n\t; First, we load our two addresses\n\tmov rax, [rdx]\n\tmov rsi, [INPUT_ARRAY]\n\t; Then, we copy the value from the original list using the index from\n\t; our index array into the tree array at the current loop index.\n\t; Note: We multiply the offset by 4 because we deal with dword entities.\n\tmov eax, dword [rsi + rax * 4]\n\tmov dword [rdi + rcx * 4], eax\n\n\t; Here, we advance our pointer to the next midpoint index in our index\n\t; array.\n\tadd rdx, 24\n\n\tinc rcx\n\tjmp .for_loop\n.end_for_loop:\n\n\t; Now, we clean up our allocated memory.\n\tmov rdi, rbx\n\tcall free WRT ..plt\n\n\t; The size of the result array is the same as the size of the input\n\t; array (otherwise we would not have used all elements or conjured up more).\n\tmov rax, [INPUT_LENGTH]\n\n\t; Restore the saved rbx value.\n\tmov rbx, [SAVED_RBX]\n\n\tmov rsp, rbp\n\tpop rbp\n\tret\n\n;;\n; C-signature\n;     int partition(int n)\n;    [rax]          [rdi]\n;\n; Find a partition of a range that would result in a perfect binary tree\n; root.\n;\n; This function uses the following registers: rax, rdi, rsi, rdx.\n;\n; @param n [rdi]  length of the range\n; @return an index of an element in the range that would be a perfect binary\n;         tree root\npartition:\n\t; Note: In order to find the desired index, we first calculate the smallest\n\t; power of two (x) that would be greater or equal to the half of the given\n\t; value (n).\n\t; Then, we determine: (x\/2 - 1) <= (n - x). If true, we subtract 1 from (x)\n\t; and return it, otherwise we return (n - x\/2).\n\tmov rsi, rdi\n\tmov rax, 1\n\tshr rdi, 1\n.L1:\n\tcmp rax, rdi\n\tjg .L2\n\tshl rax, 1\n\tjmp .L1\n.L2:\n\tmov rdx, rax\n\tmov rdi, rsi\n\tshr rdx, 1\n\tdec rdx\n\tsub rsi, rax\n\tcmp rdx, rsi\n\tjg .L3\n\tdec rax\n\tjmp .L4\n.L3:\n\tinc rdx\n\tsub rdi, rdx\n\tmov rax, rdi\n.L4:\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214365,"user_id":168,"body":"global complete_binary_tree\n\nsection .text\n\n; size_t complete_binary_tree(int *tree, const int *input, const size_t length)\n; Parameters: RDI  tree - int[length] array to place tree nodes\n;             RSI  input - const int[length] array of in-order-traversal data\n;             RDX  length - size of tree, input array\n; Return value: RAX  number of elements in tree\n\n; Translation of @lechevalier's Python solution\ncomplete_binary_tree:\n  xor eax, eax\n  call .walk\n  mov rax, rdx\n  ret\n.walk:\n  cmp rax, rdx\n  jae .ret\n  push rax\n  lea rax, [2 * rax + 1]\n  call .walk\n  pop rax\n  mov ecx, [rsi]\n  mov [rdi + 4 * rax], ecx\n  add rsi, 4\n  lea rax, [2 * rax + 2]\n  jmp .walk\n.ret:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214366,"user_id":null,"body":"global complete_binary_tree\n\nsection .text\n\n; size_t complete_binary_tree(int *tree, const int *input, const size_t length)\n; Parameters: RDI  tree - int[length] array to place tree nodes\n;             RSI  input - const int[length] array of in-order-traversal data\n;             RDX  length - size of tree, input array\n; Return value: RAX number of elements in tree\ncomplete_binary_tree:\n    xor rcx, rcx        ; i : heap index\n    xor rax, rax        ; a : array index\n    test rdx, rdx\n    jz .quit_empty\n    call .from_order    ; (rcx i, rax a) -> rax count\n.quit_empty:\n    ret\n\n.from_order:            ; (rcx i, rax a) -> rax count\n    push rcx            ; save i\n    shl rcx, 1\n    inc rcx             ; left_i\n    push rcx            ; save left_i\n    push rax            ; save a\n\n    cmp rcx, rdx        ; if left_i < length\n    jl .left_call       ;   then call\n    xor rax, rax        ;   else lefts_count = 0\n    jmp .lefts\n.left_call:\n    call .from_order    ; (left_i, a) -> lefts_count\n.lefts:\n    pop r8              ; restore a\n    push rax            ; save lefts_count\n\n    add rax, r8                     ; aindex = lefts_count + a\n    mov r9d, dword [rsi + rax * 4]  ; load array[aindex]\n    mov r10, [rsp + 16]             ; load i\n    mov dword [rdi + r10 * 4], r9d  ; store heap[i]\n    mov rcx, [rsp + 8]  ; load left_i\n    inc rcx             ; right_i = ++left_i\n    inc rax             ; ++aindex\n\n    pop r8              ; restore lefts_count\n    add rsp, 16         ; discard left_i, i\n    push r8             ; save lefts_count\n\n    cmp rcx, rdx        ; if right_i < length\n    jl .right_call      ;   then call\n    xor rax, rax        ;   else rights_count = 0\n    jmp .rights\n.right_call:\n    call .from_order    ; (right_i, ++aindex) -> rights_count\n.rights:\n\n    pop r8              ; restore lefts_count\n    add rax, r8\n    inc rax             ; return lefts_count + rights_count + 1\n    ret\n; ------------------------> endof complete_binary_tree <------------------------\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5cd4aec6abc7260028dcd942":[{"id":214367,"user_id":168,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n  popcnt eax, edi\n  bsr ecx, edi\n  lea eax, [rax + rcx - 1]\n  ret\n; -----> endof shortest_steps_to_num <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214368,"user_id":null,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n    xor eax, eax\n    jmp .step\n.count:\n    adc eax, 1\n.step:\n    shr edi, 1\n    jnz .count\n    ret\n; -----> endof shortest_steps_to_num <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214369,"user_id":null,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n    xor eax, eax\n    mov ebx, 0\n    mov ecx, 2\n.loop:\n    cmp edi, 1\n    je .end\n    cdq\n    mov eax, edi\n    idiv ecx\n    cmp edx, 0\n    jne .decr\n    mov edi, eax\n    jmp .endloop\n.decr:\n    dec edi\n.endloop:\n    inc ebx\n    jmp .loop\n.end:\n    mov eax, ebx\n    ret\n; -----> endof shortest_steps_to_num <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214370,"user_id":null,"body":"global shortest_steps_to_num\n\nshortest_steps_to_num:\n  bsr rax,rdi\n  mov rcx,64\n  loop1:\n  dec rcx\n  bt rdi,rcx\n  adc rax,0\n  cmp rcx,0\n  jge loop1\n  dec rax\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214371,"user_id":null,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n  popcnt eax, edi\n  bsr edi, edi\n  lea eax, [rax-1+rdi]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214372,"user_id":null,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n    xor eax, eax      ; eax = step counter, edi = num\nloop:\n    cmp  edi, 1\n    jbe  exit         ; 1 is reached\n    test edi, 1\n    jz   no_dec\n    dec  edi          ; +1 step\n    inc  eax\nno_dec:\n    sar  edi, 1       ; *2 step\n    inc  eax\n    jmp  loop\nexit:\n    ret\n; -----> endof shortest_steps_to_num <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214373,"user_id":null,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n  bsr edx, edi\n  popcnt eax, edi\n  lea eax, [rax+rdx-1]\n  ret\n; -----> endof shortest_steps_to_num <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214374,"user_id":null,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n    xor eax, eax\n    mov ecx, edi\n    dec ecx\n    jz e\nsexyloop:\n    inc ecx\n    shr ecx, 1\n    setc dl\n    add al, dl\n    inc eax\n    loop sexyloop\ne:  ret\n; -----> endof shortest_steps_to_num <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214375,"user_id":50,"body":"global shortest_steps_to_num\n\n; <-- EAX shortest_steps_to_num(EDI num) -->\nshortest_steps_to_num:\n    xor eax, eax\n_loop:\n  cmp edi,1\n  je _exit\n  inc eax\n  xor ebx,ebx\n  mov ebx,edi\n  and ebx,1\n  cmp ebx,0\n  je _div\n  dec edi\n  jmp _loop\n_div:\n  shr edi,1\n  jmp _loop\n_exit:\n    ret\n; -----> endof shortest_steps_to_num <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214376,"user_id":null,"body":"global shortest_steps_to_num\nshortest_steps_to_num:\n      mov eax,-1\n@main:inc eax\n      cmp edi,1\n      jle @bye\n      bt  edi,0\n      jnc @two\n      dec edi\n      jmp @main\n@two: shr edi,1\n      jmp @main\n@bye: ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ce399e0047a45001c853c2b":[{"id":214377,"user_id":null,"body":"global parts_sums\nextern malloc\n\n; <-- [qword RAX] parts_sums([qword RDI] len, ro [qword RSI] ls, qword RDX n) -->\nparts_sums:\n  push r12\n  push r13\n  push rax\n  lea r12, [rdx + 1]\n  mov [rdi], r12\n  mov r13, rsi\n  lea rdi, [r12 * 8]\n  call malloc\n  add rsp, 8\n  xor rdx, rdx\n  mov [rax + r12 * 8 - 8], rdx\n  jmp .cond\n.loop:\n  add rdx, [r13 + r12 * 8 - 8]\n  mov [rax + r12 * 8 - 8], rdx\n.cond:\n  dec r12\n  jnz .loop\n  pop r13\n  pop r12\n  ret\n; -----> endof parts_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214378,"user_id":null,"body":"global parts_sums\nextern malloc\n\n; <-- [qword RAX] parts_sums([qword RDI] len, ro [qword RSI] ls, qword RDX n) -->\nparts_sums:\n  lea rcx, [rdx + 1]\n  mov [rdi], rcx\n  push rax\n  push rcx\n  push rsi\n  lea rdi, [rcx * 8]\n  call malloc\n  pop rsi\n  pop rcx\n  add rsp, 8\n  xor rdx, rdx\n  mov [rax + rcx * 8 - 8], rdx\n  jmp .cond\n.loop:\n  add rdx, [rsi + rcx * 8 - 8]\n  mov [rax + rcx * 8 - 8], rdx\n.cond:\n  dec rcx\n  jnz .loop\n  ret\n; -----> endof parts_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214379,"user_id":null,"body":"extern malloc\nglobal parts_sums\n\nparts_sums:\n  push r14\n  push rbx\n  push rax\n  lea rax, [rdx + 1]\n  mov rbx, rdx\n  mov r14, rsi\n  mov qword [rdi], rax\n  lea rdi, [8*rdx + 8]\n  call malloc\n  dec rbx\n  xor ecx, ecx\n.loop:\n  test rbx, rbx\n  mov qword [rax + 8*rbx + 8], rcx\n  js .done\n  add rcx, qword [r14 + 8*rbx]\n  dec rbx\n  jmp .loop\n.done:\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214380,"user_id":null,"body":"global parts_sums\nextern malloc\nparts_sums:\n  push rsi\n  push rdx\n  inc  rdx\n  mov  [rdi],rdx\n  lea  rdi,[rdx*8+8]\n  call malloc\n  pop  rcx\n  pop  rsi\n  xor  rdx,rdx\n  mov  [rax+rcx*8],rdx\n  jrcxz @f  \n  @b:add rdx,[rsi+rcx*8-8]\n     mov [rax+rcx*8-8],rdx\n  loop @b\n  @f:\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214381,"user_id":null,"body":"global parts_sums\nextern calloc\n\n; <-- [qword RAX] parts_sums([qword RDI] len, ro [qword RSI] ls, qword RDX n) -->\nparts_sums:\n    mov [rdi], rdx          ; saving <n> in <*len>\n    inc qword [rdi]         ; incrementing <*len>\n    push rdi                ; saving <len> onto stack\n    push rsi                ; saving <ls> onto stack\n    push rdx                ; saving <n> onto stack\n    lea rdi, [rdx+1]        ; <n+1> elements to allocate for sums\n    mov rsi, 8              ; the size of each element to allocate\n    call calloc             ; allocating memory for <sums> and resetting it \n    pop rcx                 ; restoring <n> from stack\n    pop rsi                 ; restoring <ls> from stack\n    add rsp, 8              ; aligning the stack boundary\n    xor rdx, rdx            ; resetting RDX as su<m>\n    test rcx, rcx           ; testing <m> to set cpu flags\n    jmp .exit               ; jumping to exit\n.loop:\n    add rdx, [rsi+rcx*8-8]  ; adding <*ls[n-1]> to <m>\n    mov [rax+rcx*8-8], rdx  ; loading <*sums[n-1]> with <m>\n    dec rcx                 ; decrementing <n>\n.exit:\n    jne .loop               ; jumping to the next operation if <n> is not zero\n    ret\n; -----> endof parts_sum <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ce6cf94cb83dc0020da1929":[{"id":214382,"user_id":168,"body":"section .bss\n  dda resb 100\n\nsection .text\n  global uglify_word\n\nuglify_word:\n  lea rsi, [rel dda]\n  xor eax, eax    ; flag: 1 => 0, 0 => 32\n  jmp .loop_cond\n.loop:\n  mov ecx, edx\n  or ecx, 32\n  sub ecx, 'a'\n  cmp ecx, 25\n  lea ecx, [rcx + rax + 'A']\n  cmovbe edx, ecx\n  mov ecx, 32\n  cmova ecx, eax\n  xor eax, ecx\n  mov byte [rsi], dl\n  inc rdi\n  inc rsi\n.loop_cond:\n  movzx edx, byte [rdi]\n  test edx, edx\n  jnz .loop\n  mov byte [rsi], 0\n  lea rax, [rel dda]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214383,"user_id":null,"body":"extern strlen\nextern malloc\nsection .bss\n  dda resb 101\n\nsection .text\n  global uglify_word\n\n; char * uglify_word(const char *);\nuglify_word:\n  push r14\n  push rbx\n  push rax\n  mov r14, rdi\n  call strlen\n  lea rdi, [rax + 1]\n  call malloc\n  mov bl, 1\n  xor ecx, ecx\n.LBB0_1:\n  mov sil, [r14 + rcx]\n  test sil, sil\n  je .LBB0_7\n  lea edi, [rsi - 65]\n  cmp dil, 57\n  ja .LBB0_5\n  lea edi, [rsi - 97]\n  cmp dil, -7\n  ja .LBB0_5\n  and sil, -33\n  xor bl, 1\n  mov edx, ebx\n  and dl, 1\n  shl dl, 5\n  or dl, sil\n  mov [rax + rcx], dl\n  jmp .LBB0_6\n.LBB0_5:\n  mov [rax + rcx], sil\n  mov bl, 1\n.LBB0_6:\n  inc rcx\n  jmp .LBB0_1\n.LBB0_7:\n  mov byte [rax + rcx], 0\n  add rsp, 8\n  pop rbx\n  pop r14\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214384,"user_id":null,"body":"section .bss\n  dda resb 101\n\nsection .text\n  global uglify_word\n\n; char * uglify_word(const char *);\nuglify_word:\n  lea rax, [dda]\n  xor ecx, ecx\n  \n.loop:\n  mov dl, [rdi]\n  inc rdi\n  test dl, dl\n  jz .end\n  sub dl, 'A'\n  cmp dl, 26\n  jb .alphabet\n  sub dl, 0x20\n  cmp dl, 26\n  jb .alphabet\n  xor ecx, ecx\n  add dl, 'a'\n  jmp .write\n  \n.alphabet:\n  lea edx, [rdx+rcx+'A']\n  xor ecx, 0x20\n.write:\n  mov [rax], dl\n  inc rax\n  jmp .loop\n\n.end:\n  mov [rax], dl\n  lea rax, [dda]\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214385,"user_id":null,"body":"section .bss\n  dda resb 101\n\nsection .text\n  global uglify_word\n\n;flag will be in rcx\n\nis_alpha:\n  cmp dl, 122\n  jg .false\n  cmp dl, 65\n  jl .false\n  cmp dl, 90\n  jle .true\n  cmp dl, 97\n  jge .true\n  jmp .false\n.true:\n  mov rax,1\n  ret\n.false:\n  xor rax,rax\n  ret\n\nto_upper:\n  or dl, 32\n  ret\n\nto_lower:\n and dl, 223\n ret\n\n; char * uglify_word(const char *);\nuglify_word:\n  xor r11, r11\n  mov rcx, -1\n  xor rdx, rdx\n.main_loop:\n  mov dl, byte [rdi]\n  inc rdi \n  cmp dl, 0\n  je .end\n  call is_alpha\n  cmp rax,0\n  je .non_alpha\n  cmp rcx, -1\n  je .do_lower\n  call to_upper\n  jmp .end_alpha\n.do_lower:\n  call to_lower\n.end_alpha:\n  mov byte [dda+r11], dl\n  not rcx\n  jmp .end_loop\n.non_alpha:\n  mov rcx,-1\n  mov byte [dda+ r11], dl\n.end_loop:\n inc r11\n jmp .main_loop\n  \n.end:\n  mov byte[dda+r11],0\n  mov rax, dda\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214386,"user_id":null,"body":"section .bss\n  dda resb 101\n\nsection .text\n  global uglify_word\n\n; char * uglify_word(const char *);\nuglify_word:\n    mov rax, dda\n    mov rsi, 1\n    mov r8, 32\n    .lp:\n        mov dl, [rdi]\n        test dl, dl\n        jz .end_lp\n        cmp dl, 'A'\n        jl .non_alpha\n        cmp dl, 'Z'\n        ja .check_lower\n        xor rcx, rcx\n        test rsi, rsi\n        cmovz rcx, r8\n        add dl, cl\n        jmp .flip_flag\n        .check_lower:\n        cmp dl, 'a'\n        jl .non_alpha\n        cmp dl, 'z'\n        ja .non_alpha\n        xor rcx, rcx\n        test rsi, rsi\n        cmovnz rcx, r8\n        sub dl, cl\n        jmp .flip_flag\n        .non_alpha:\n        mov rsi, 1\n        jmp .copy_char\n        .flip_flag:\n        test rsi, rsi\n        setz sil\n        .copy_char:\n        mov [rax], dl\n        inc rax\n        inc rdi\n    jmp .lp\n    .end_lp:\n    mov byte [rax], 0    \n    mov rax, dda\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214387,"user_id":null,"body":"global uglify_word\nextern strdup\n\n; <--- [RAX] uglify_word(ro [RDI] s) --->\nuglify_word:\n    push rdi                ; saving <s> in the stack\n    call strdup             ; duplicating <s> as <w>\n    pop rdi                 ; aligning the stack boundary\n    test rax, rax           ; whether <w> is allocated\n    je .exit                ; otherwise, jumping to exit\n    lea rdi, [rax-1]        ; pointing RDI to the previous character in <w>\n.flg:\n    mov cx, 0hFFFF          ; settting CX to true as <flg>\n.loop:\n    inc rdi                 ; pointing <w> to the next character\n    mov dl, [rdi]           ; loading DL with <*w> as <c>           \n    test dl, dl             ; whether <c> is the null character\n    je .exit                ; jumping to exit\n    cmp dl, 'A'             ; whether <c> is bellow 'A'\n    jb .flg                 ; jumping to the .flg label\n    cmp dl, 'Z'             ; whether <c> is above 'Z'\n    ja .low                 ; jumping to the .low label\n    not cx                  ; reverting <flg>\n    test cx, cx             ; whether <flg> is not zero\n    je .loop                ; otherwise, jumping to the next iteration\n    jmp .res                ; jumping to the .res label\n.low:\n    cmp dl, 'a'             ; whether <c> is bellow 'a'\n    jb .flg                 ; jumping to the .flg label\n    cmp dl, 'z'             ; whether <c> is above 'z'\n    ja .flg                 ; jumping to the .flg label\n    not cx                  ; reverting <flg>\n    test cx, cx             ; whether <flg> is zero\n    jne .loop               ; otherwise, jumping to the next iteration\n.res:\n    xor dl, ' '             ; inversing <c>\n    mov [rdi], dl           ; resaving <c> in <*w>\n    jmp .loop               ; jumping to the next iteration\n.exit:\n    ret\n; -----> endof uglify_word <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214388,"user_id":1088,"body":"\nsection .bss\n  dda resb 100\n\nsection .text\n  global uglify_word\n\nuglify_word:\n  mov rax, 0\n  mov rdx, 1\n  jmp st\n dt:\n  mov [dda+rax], r9b\n  inc rax\n st:\n  mov r9b, [rdi+rax]\n  cmp rdx, 1\n  je llt_0\n  jmp ult_0\n  \n llt_0:\n  cmp r9b, 'a'\n  jge llt_1\n  jmp next\n llt_1:\n  cmp r9b, 'z'\n  jle llt_2\n  jmp next\n llt_2:\n  sub r9b, 32\n  jmp next\n\n ult_0:\n  cmp r9b, 'A'\n  jge ult_1\n  jmp next\n ult_1:\n  cmp r9b, 'Z'\n  jle ult_2\n  jmp next\n ult_2:\n  add r9b, 32\n  jmp next\n \n next:\n  cmp r9b, 'A'\n  jl gnext\n  cmp r9b, 'Z'\n  jle snext\n  cmp r9b, 'a'\n  jl gnext\n  cmp r9b, 'z'\n  jle snext\n gnext:\n  mov rdx, 1\n  jmp dnext\n\n snext:\n  not rdx\n dnext:\n  cmp r9b, 0\n  jne dt\n  mov r9b, 0\n  mov [dda+rax], r9b\n  mov rax, dda\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ce9c1000bab0b001134f5af":[{"id":214389,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  xor eax, eax\n  xor edx, edx\n  xor ecx, ecx    ; zeroing registers\n  \n  mov eax, edi    \n  add eax, 2\n  mov ecx, 3\n  div ecx         ; eax = edx:eax \/ ecx\n  \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214390,"user_id":864,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)  :  rdi = month, rsi = null\n  ; Explanation for everyone who's still learning NASM\n  mov rax, rdi  ; rdi contains the first argument passed to the function, in this case the integer month. We copy it into rax\n  cmp rax, 4    ; compare rax, meaning the month, with 4\n  js first      ; if rax is smaller than 4, then jump to the label 'first' (js = jump if smaller)\n  cmp rax, 7    ; compare rax with 7 now, we will only be here if the previous jump didn't happen, meaning month >= 4\n  js second     ; same as the first conditional jump but this time if rax is below 7 and we'll jump to the label 'second' if so\n  cmp rax, 10   ; compare with 10 now, we're only here if the previous jump didn't happen\n  js third      ; if rax is below 10 jump to the label 'third'\n  mov rax, 4    ; we don't need another check, there is only one outcome left so we don't jump from here and just set rax to 4\n  ret           ; return like in other languages but our return value will always be what's stored in rax at the moment (4 here)\n  \n  \nfirst:\n  mov rax, 1    ; It must be the first quarter so we set rax to contain 1\n  ret           ; return like in other languages but our return value will always be what's stored in rax at the moment (1 here)\n  \nsecond:\n  mov rax, 2    ; It must be the first quarter so we set rax to contain 1\n  ret           ; return like in other languages but our return value will always be what's stored in rax at the moment (2 here)\n  \nthird:\n  mov rax, 3    ; It must be the first quarter so we set rax to contain 1\n  ret           ; return like in other languages but our return value will always be what's stored in rax at the moment (3 here)","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214391,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  push rbp\n  mov rbp, rsp\n  xor rdx, rdx ; store zero in rdx\n  mov rax, rdi ; rdi stores first input argument\n  mov rbx, 3   ; number of month in a quarter is 3\n  idiv rbx     ; divide rdx:rax by rbx, quotient is stored in rax, remainder in rdx\n  xor rcx, rcx ; store zero in rcx\n  cmp rdx, rcx ; compare remainder with zero\n  je quit      ; if remainder is zero, do not increment the quotient\n  inc rax ; increment quotient by one if remainder is non-zero\n  ; rax stores the output variable\nquit:\n  mov rsp, rbp\n  pop rbp\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214392,"user_id":527,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  lea eax, [edi * 5 + 16]\n  shr eax, 4\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214393,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:\n  cmp edi, 4\n  jl first\n  cmp edi, 7\n  jl second\n  cmp edi, 10\n  jl third\n  mov eax, 4\n  ret\n  \nfirst:\n  mov eax, 1\n  ret\n  \nsecond:\n  mov eax, 2\n  ret\n  \nthird:\n  mov eax, 3\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214394,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  mov eax, edi\n  dec eax\n  \n  xor edx, edx\n  mov ebx, 3\n  div ebx\n  \n  inc eax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214395,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  xor eax, eax  ; Your code here\n  xor ebx, ebx\n  loop:\n  add eax, 1\n  add ebx, 3\n  cmp edi, ebx\n  jg loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214396,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  sub al, 1\n  mov bl, 3\n  div bl\n  mov ah, 0\n  add al, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214397,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n\tlea\teax, [rdi-1]\n\tmov\tecx, 3\n\tcdq\n\tidiv\tecx\n\tinc\teax\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214398,"user_id":null,"body":"section .text\nglobal quarter_of\nquarter_of:     ; int quarter_of(int month)\n  mov eax, edi\n  add eax, 2\n  xor rdx, rdx\n  mov ecx, 3\n  div ecx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5d5a7525207a674b71aa25b5":[{"id":214399,"user_id":null,"body":"global oddrow\nextern malloc\n\n  \n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n    push rbx\n    push rdi\n    \n    shl rdi, 3 ; sizeof (long long) * rdi\n    call malloc\n    \n    pop rdi\n    push rax\n    lea ecx, [edi-1]\n    \n    ; 1 + (x * (x+1))\n    lea rbx, [rdi-1]\n    imul rdi, rbx\n    lea rbx, [rdi+1]\n    \n    mov [rax], rbx\n    \n  loop:\n    cmp ecx, 0\n    jle end_l\n    add rbx, 2\n    \n    add rax, 8\n    mov [rax], rbx\n    dec ecx\n    \n   \tjmp loop\n  end_l:\n  \n    pop rax\n    pop rbx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214400,"user_id":527,"body":"global oddrow\nextern malloc\n\n; unsigned long long *oddrow(size_t n)\noddrow:\n                push    rdi\n                shl     rdi, 3\n                call    malloc\n                pop     rdi\n                lea     rcx, [rdi - 1]\n                imul    rcx, rdi\n                inc     rcx\n                lea     rdx, [rax + rdi * 8]\n                neg     rdi\n.loop:          mov     [rdx + rdi * 8], rcx\n                add     rcx, 2\n                inc     rdi\n                jnz     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214401,"user_id":null,"body":"global oddrow\nextern malloc\n\n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n  push rbx\n  mov rbx, rdi\n  lea rdi, [8*rdi]\n  call malloc\n  lea rcx, [rbx - 1]\n  mov rdx, rax\n  imul rcx, rbx\n  inc rcx\n.loop:\n  sub rbx, 1\n  jb .done\n  mov [rdx], rcx\n  add rcx, 2\n  add rdx, 8\n  jmp .loop\n.done:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214402,"user_id":null,"body":"global oddrow\nextern malloc\n\nsection .bss\n    ptr resq 1\n\nsection .text\n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n    xor eax, eax        ; RAX <- the result\n   \n    xor rdx, rdx\n    mov rax, 8\n    mul rdi\n    push rdi\n    mov rdi, rax\n    call malloc\n    mov [ptr], rax\n    pop rdi\n    \n    mov rcx, rdi\n    xor rax, rax\n    sub rcx, 1\n    cmp rcx, 0\n    je .continue_1\n\n.add_num:\n    add rax, rcx\n    loop .add_num\n    jmp .continue_2\n\n.continue_1:\n    mov rax, 0\n\n.continue_2:\n    mov rbx, 2\n    mul rbx\n    add rax, 1\n    xor rcx, rcx\n    mov rsi, [ptr]\n    \n.write_to_memory:\n    mov [rsi + rcx*8], rax\n    add rax, 2\n    inc rcx\n    cmp rcx, rdi\n    jne .write_to_memory\n    mov rax, rsi\n    ret\n; -----> endof oddrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214403,"user_id":null,"body":"global oddrow\nextern malloc\n\n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n  push rdi\n  lea rdi, [rdi*8]\n  call malloc\n  pop rdi\n  test rax, rax\n  jz .quit\n  \n  mov rsi, rax\n  mov rdx, rdi\n  imul rdx, rdx\n  sub rdx, rdi\n  dec rdx\n  \n.loop:\n  add rdx, 2\n  mov [rsi], rdx\n  add rsi, 8\n  dec rdi\n  jne .loop\n.quit:\n  ret\n; -----> endof oddrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214404,"user_id":460,"body":"global oddrow\nextern malloc\noddrow:\n    ; rax = n^2 + (n-1)\n    mov rax, rdi\n    mul rax\n    add rax, rdi\n    dec rax\n    mov rdx, rax\n    ; allocate n * 8 bytes\n    push rdx\n    push rdi\n    sal rdi, 3\n    call malloc\n    pop rdi\n    pop rdx\n    ; fill array starting from last item\n    @loop:\n      mov [rax+(rdi-1)*8], rdx\n      sub rdx, 2\n      dec rdi\n    jnz @loop\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214405,"user_id":null,"body":"global oddrow\nextern malloc\n\n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n    push rdi\n    shl rdi,3\n    call malloc\n    pop rcx\n    test rax,rax\n    jz .out           ; return NULL if memory allocation failed\n    mov rdi,rax\n    mov r8,rax\n    mov rax,rcx       ; we need to start at N*(N-1)+1\n    dec rax\n    mul rcx\n.gen:\n    inc rax           ; then we need N numbers\n    stosq\n    inc rax\n    loop .gen\n    mov rax,r8\n.out:\n    ret\n; -----> endof oddrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214406,"user_id":null,"body":"global oddrow\nextern malloc\n\n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n    ; The amount of odd numbers in all rows before and including row n is\n    ; sum(k from k = 1 to n) = n(1+n)\/2\n    ; the length of the nth row is n (n * 8 bytes)\n    ; the beginning odd number is of row n+1 is 1 + n(1+n)\n    ; so the beginning odd number of row n is 1 + n(n-1)\n    push rdi ; rsp = index\n    \n    mov rax, rdi\n    mov rcx, 8\n    mul rcx\n    mov rdi, rax\n    call malloc\n    push rax ; rsp = output array, rsp + 8 = index\n    \n    mov rax, [rsp + 8]\n    dec rax\n    mov rcx, [rsp + 8]\n    mul rcx\n    inc rax ; rax = 1 + n(n-1)\n    \n    mov rdi, rax ; rdi contains starting odd number\n    pop rax ; rax contains output array\n    ; rsp = index\n    xor rcx, rcx ; rcx is element counter\n    mov rdx, [rsp] ; mac rcx (out of bounds)\nloop_begin:\n    mov qword [rax + rcx*8], rdi\n    add rdi, 2\n    \n    inc rcx\n    cmp rcx, rdx\n    jl loop_begin\n    \n    add rsp, 8\n    ret\n; -----> endof oddrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214407,"user_id":null,"body":"global oddrow\nextern malloc\n\n\n; <-- [qword RAX] oddrow(RDI inx) -->\noddrow:\n    push rdi\n    lea rdi, [rdi*8]\n    call malloc\n    pop rdi\n    mov rdx, rdi\n    dec rdi\n    imul rdx, rdi\n    inc rdx\n    xor ecx, ecx\n    .loop:\n        mov [rax+rcx*8], rdx\n        mov r8, [rax+rcx*8]\n        add rdx, 2\n        inc rcx\n        cmp rcx, rdi\n        jle .loop\n    ret\n; -----> endof oddrow <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214408,"user_id":null,"body":"[BITS 64]\n\nsection .text\n\n;;\n; C-signature:\n;     void *malloc(size_t bytes)\nextern malloc\n\nglobal oddrow\n;;\n; C-signature:\n;     unsigned long long int *oddrow(size_t inx)\n;     [rax]                          [rdi]\n;\n; Find row (inx) of the triangle of odd numbers.\n;\n; This function assumes that the memory allocated for the solution\n; is freed by the caller with a call to free().\n;\n; @param inx [rdi] row index (inx >= 1)\n; @return row at index (inx) or NULL if the row could not be retrieved\n;\n%define ROW_INDEX     rbp - 0x08\n%define FIRST_ELEMENT rbp - 0x10\noddrow:\n\tpush rbp\n\tmov rbp, rsp\n\tsub rsp, 0x10\n\tcmp rdi, 0\n  ; Index (inx) has to be greater than zero.\n\tjz .error\n  ; We first calculate the square of n.\n\txor edx, edx\n\tmov rax, rdi\n\tmul rax\n\ttest rdx, rdx\n  ; If the result of n\u00b2 does not fit in rax, we cannot calculate\n  ; the beginning of the selected row using n\u00b2-n+1.\n\tjnz .error\n\tsub rax, rdi\n\tinc rax\n  ; Here, we have calculated n\u00b2-n+1 which is the first element of\n  ; the selected row. We store the row index and the first element\n  ; on the stack before allocating memory.\n\tmov [ROW_INDEX], rdi\n\tmov [FIRST_ELEMENT], rax\n  ; Each result element is 8 bytes wide (64-bit) so we multiply\n  ; our row index by 8 (each row has a number of elements equal\n  ; to the row index).\n\tshl rdi, 3\n\tcall malloc WRT ..plt\n\tcmp rax, 0\n  ; If malloc could not allocate the memory, we fail.\n\tjz .error\n\tmov rsi, rax\n\txor ecx, ecx\n\tmov rdi, [ROW_INDEX]\n\tmov rax, [FIRST_ELEMENT]\n  ; At each iteration we now only have to increase the element's\n  ; value by 2.\n.loop:\n\tmov [rsi + rcx * 8], rax\n\tadd rax, 2\n\tinc rcx\n\tcmp rcx, rdi\n\tjl .loop\n\tmov rax, rsi\n\tjmp .end\n.error:\n\txor eax, eax\n.end:\n\tmov rsp, rbp\n\tpop rbp\n\tret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5d5ee4c35162d9001af7d699":[{"id":214409,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n    xor eax, eax            ; resetting RAX as <sum>\n.loop:\n    mov r10, [rdi+rsi*8-8]  ; pointing R10 to <*(nums+rows-1)> as <rp>\n    mov rcx, rdx            ; loading RCX with <cols> as <j>\n    mov r8d, [r10]          ; loading R8D with <*rp> as <min>\n.lp:\n    mov r9d, [r10+rcx*4-4]  ; loading R9D with <*(rp+j-1)> as <num>\n    cmp r8d, r9d            ; whether <min> is greater than <num>\n    cmovg r8d, r9d          ; updating <min> with <num>\n    dec rcx                 ; decrementing <j>\n    jg .lp                  ; jumping to the next .lp iteration if <j> is greater than zero\n    add rax, r8             ; adding <min> to <sum>\n    dec rsi                 ; decrementing <rows>\n    jg .loop                ; jumping to the next iteration if <rows> is greater than zero\n    ret\n; -----> endof sumofmin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214410,"user_id":null,"body":"global sumofmin\nsumofmin:\n  xor r8,r8\n  mov rdi,[rdi]\n  .a:mov rcx,rdx\n     mov eax,0x7FFFFFFF\n     .b:scasd\n        cmova eax,[rdi-4]\n     loop .b\n     add r8d,eax\n     dec rsi\n   jne .a\n   mov rax,r8\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214411,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n  push rbx\n  xor eax, eax\n  mov r8, 1\n  xor r9d, r9d\n.rowloop:\n  cmp r9, rsi\n  je .done\n  mov r10, [rdi + 8*r9]\n  mov r11d, [r10]\n  mov rcx, r8\n.colloop:\n  cmp rcx, rdx\n  jae .addmin\n  mov ebx, [r10 + 4*rcx]\n  cmp ebx, r11d\n  cmovl r11d, ebx\n  inc rcx\n  jmp .colloop\n.addmin:\n  movsxd rcx, r11d\n  add rax, rcx\n  inc r9\n  jmp .rowloop\n.done:\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214412,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n    xor eax, eax            ; RAX <- the result\n    mov rcx, rsi\n  .lp1:\n      push rcx\n      push rdi\n      \n      mov rcx, rdx\n      mov rdi, [rdi]\n      mov ebx, [rdi]\n    .lp2:\n        cmp ebx, [rdi]\n        jle .less\n        mov ebx, [rdi]\n        .less:\n        add rdi, 4\n        loop .lp2\n      add eax, ebx   \n      pop rdi\n      pop rcx \n      \n      add rdi, 8\n      loop .lp1\n    \n    ret\n; -----> endof sumofmin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214413,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n    xor eax, eax            ; RAX <- the result\n    mov rcx, rsi\n  .lp1:\n      push rcx\n      push rdi\n      \n      mov rcx, rdx\n      mov rdi, [rdi]\n      mov ebx, [rdi]\n    .lp2:\n        cmp ebx, [rdi]\n        jle .not_less\n        mov ebx, [rdi]\n        .not_less:\n        add rdi, 4\n        loop .lp2\n      add eax, ebx   \n      pop rdi\n      pop rcx \n      \n      add rdi, 8\n      loop .lp1\n    \n    ret\n; -----> endof sumofmin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214414,"user_id":50,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n    xor rax, rax            ; RAX <- the result\n    xor r9,r9 ; min\n    xor r11,r11 ;tmp\n    xor rbx,rbx\n    mov r12,rdx ; save num of columns to r1\n_loop:\n  test rsi,rsi ; if rsi == 0 it's over\n  jz _exit\n  dec rsi ; decrement rsi\n  mov rbx,[rdi+8*rsi] ; pointer on current line\n  mov r10,r12 ;index on line\n  mov r9,0x7fffffff ; max int\n _findMin:\n  test r10,r10 ; if r10 == 0 the whole line has been parsed\n  jz _found\n  dec r10 ; decrement index on line\n  mov r11d,dword[rbx+4*r10] ; move current value to r11\n  cmp r9,r11 ; compare with r9\n  jg _isInf ; r9 is greater, update\n  jmp _findMin ; else continue to parse the line\n_isInf:\n  mov r9,r11 ; update r9 to inferior r11\n  jmp _findMin ; continue parse line\n _found:\n  add rax,r9\n  jmp _loop\n_exit:\n    ret\n; -----> endof sumofmin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214415,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n    mov r8,rdi        ; r8 = array of arrays\n    mov r9,rsi        ; r9 = rows\n    mov r10,rdx       ; r10 = columns\n    xor r11,r11       ; r11 = total\n.row:\n    xchg rsi,r8       ; grab next column\n    lodsq\n    xchg r8,rsi\n    mov rsi,rax       ; load column address into source index\n    mov rcx,r10       ; set column counter\n    mov edx,-1        ; set EDX to INT_MAX\n    shr edx,1\n.item:\n    lodsd             ; get item\n    cmp eax,edx       ; less than current minimum?\n    cmovl edx,eax     ; then update current minimum\n    loop .item\n    add r11,rdx       ; add row minimum to total\n    dec r9\n    jnz .row\n    mov rax,r11       ; return total\n    ret\n; -----> endof sumofmin <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214416,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n    mov r9, rdi\n    xor r8, r8\n  .next_row:\n    dec rsi\n    js .all_done\n    mov rdi, [r9+rsi*8]\n    mov rcx, rdx\n    mov eax, [rdi+rcx*4-4]\n  .scan:\n    dec rcx\n    jz .scan_done\n    scasd\n    cmovg eax, [rdi-4]\n    jmp .scan\n  .scan_done:\n    movsx rax, eax\n    add r8, rax\n    jmp .next_row\n  .all_done:\n    mov rax, r8\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214417,"user_id":null,"body":"global sumofmin\n\n; extern long sumofmin(const int **nums, size_t rows, size_t cols); \nsumofmin:\n  xor r9, r9\n  dec rdx\n\nL_row_loop:\n  mov rcx, [rdi]\n  add rdi, 8\n  \n  mov eax, [rcx]              ; First element (eax = min)\n  lea r10, [rcx + 4*rdx]      ; End of row\n  \n  test rdx, rdx\n  jz L_after_col_loop\n  \nL_col_loop:\n  add rcx, 4\n  mov r8d, [rcx]\n  \n  cmp eax, r8d\n  cmovg eax, r8d            ; eax = min row element\n  \n  cmp rcx, r10\n  jne L_col_loop\n  \nL_after_col_loop:\n  \n  add r9d, eax\n  \n  dec rsi\n  jnz L_row_loop\n  \n  mov eax, r9d\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214418,"user_id":null,"body":"global sumofmin\n\n; Optimization Tip:\n;    Remember that you are given non-empty matrix!\n\n; <-- RAX sumofmin(ro [qword [dword RDI]] nums, RSI rows, RDX cols) -->\nsumofmin:\n  push rbp\n  xor eax, eax            ; RAX <- the result\n  xor r8, r8\n  xor r9, r9\n\n.loop.row:\n  mov r10, qword [rdi + r8 * 8]\n  mov ecx, dword [r10 + r9 * 4]\n  inc r9\n  cmp r9, rdx\n  jge .loop.col.end\n  \n.loop.col:\n  mov r10, qword [rdi + r8 * 8]\n  mov r10d, dword [r10 + r9 * 4]\n  \n  cmp ecx, r10d\n  cmovg ecx, r10d\n\n  inc r9\n  cmp r9, rdx\n  jl .loop.col\n  \n.loop.col.end:\n  xor r9, r9\n  add eax, ecx\n  inc r8\n  cmp r8, rsi\n  jl .loop.row\n  \n  pop rbp\n  ret\n; -----> endof sumofmin <-----\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5d6f49d85e45290016bf4718":[{"id":214419,"user_id":645,"body":"global anyodd\nanyodd:\n  xor eax, eax\n  and edi, 0xAAAAAAAA\n  setne al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214420,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    and edi, 0hAAAAAAAA     ; whether <x> contains any odd bit\n    setne al                ; setting the result\n    movzx eax, al           ; extending to fit 32bit\n    ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214421,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    xor eax, eax            ; EAX <- the result\n    mov edx, 16\n    mov ebx, 0\n.loop:\n    dec edx\n    shr edi, 1\n    mov eax, 1\n    and eax, edi\n    cmp eax, 1\n    cmove ebx, eax\n    cmp edx, 0\n    shr edi, 1\n    ja .loop\n    mov eax, ebx\n    ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214422,"user_id":null,"body":"global anyodd\nanyodd:\n  mov rax,1010101010101010101010101010101010101010101010101010101010101010b\n  and rax,rdi\n  popcnt rax,rax\n  setnz al\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214423,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n  xor eax, eax\n  test edi, 0xaaaaaaaa\n  setne al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214424,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    xor eax, eax            ; EAX <- the result\n    shr edi, 1\n    jz  .end\n    .loop:\n    mov   ecx, edi\n    and   ecx, 1\n    cmp   ecx, 1\n    je    .1\n    shr   edi, 2\n    jnz   .loop\n    .end:\n    ret\n    .1:\n    mov   eax,1\n    ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214425,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    xor   eax, eax\n    and   edi, 0xaaaaaaaa\n    jz    done\n    inc   eax\ndone:\n    ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214426,"user_id":50,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    xor eax, eax            ; EAX <- the result\n    and edi, 0xaaaaaaaa\n    setnz al\n    ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214427,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    mov rcx, 16\n    mov rdx, 2\n    .loop:\n        test rdi, rdx\n        jnz .true\n        shl rdx, 2\n        loop .loop\n    xor eax, eax\n    ret\n    .true:\n        mov rax, 1\n        ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214428,"user_id":null,"body":"global anyodd\n\n; <-- EAX anyodd(EDI x) -->\nanyodd:\n    xor eax, eax\n    test edi, 0xAAAAAAAA\n    setnz al ; set to 1 when test is non-zero\n    ret\n; -----> endof anyodd <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5d9f95424a336600278a9632":[{"id":214429,"user_id":null,"body":"global powers\nextern malloc\n\n; <-- [qword RAX] powers([qword RDI] outlen, RSI n) -->\npowers:\n  push r15\n  push r14\n  push rbx\n  mov r15, rsi\n  mov r14, rdi\n  mov edi, 512\n  call malloc\n  mov qword [r14], 0\n  mov ecx, 1\n  mov edx, 64\n  xor ebx, ebx\n.loop:\n  mov rdi, rcx\n  and rdi, r15\n  je .next\n  lea rsi, [rbx + 1]\n  mov [r14], rsi\n  mov [rax + 8*rbx], rdi\n  mov rbx, rsi\n.next:\n  add rcx, rcx\n  dec edx\n  jne .loop\n  pop rbx\n  pop r14\n  pop r15\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214430,"user_id":null,"body":"global powers\nextern malloc\n\n; <-- [qword RAX] powers([qword RDI] outlen, RSI n) -->\npowers:\n  mov qword [rdi], 0\n  push rdi\n  push rsi\n  push rbp\n  mov edi, 512\n  call malloc\n  pop rbp\n  pop rsi\n  pop rdi\n  test rax, rax\n  jz .quit\n  \n  xor ecx, ecx\n  mov edx, 1\n.loop:\n  test rsi, rdx\n  jz .skip\n  mov [rax+rcx*8], rdx\n  inc ecx\n.skip:\n  shl rdx, 1\n  jnz .loop\n    \n  mov [rdi], rcx\n.quit:\n  ret\n; -----> endof powers <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214431,"user_id":77,"body":"global powers\nextern malloc\n\n; <-- [qword RAX] powers([qword RDI] outlen, RSI n) -->\npowers:\n    push rdi\n    push rsi\n    mov rdi, 512\n    call malloc\n    pop rdx\n    mov rcx, 1\n    xor rdi, rdi\n    pop rbx\n.loop:\n    test rcx, rdx\n    jz .zero\n    mov [rax+rdi*8], rcx\n    inc rdi\n.zero:\n    shl rcx, 1\n    jnz .loop\n    mov [rbx], rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214432,"user_id":null,"body":"global powers\nextern malloc\npowers:\n  push   rsi\n  popcnt rax,rsi\n  mov    [rdi],rax\n  lea    rdi,[rax*8+8]\n  call   malloc \n  xor    r8,r8\n  mov    rdx,1\n  pop    rsi\n  @b:mov   [rax+r8*8],rsi\n     and   [rax+r8*8],rdx\n     setne cl\n     add   r8b,cl\n     add   rdx,rdx\n  jne @b   \nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214433,"user_id":null,"body":"global powers\nextern malloc\npowers:\n    push rdi\n    push rsi\n    mov  rdi, 8*64\n    call malloc\n    pop  rsi\n    pop  rdi\n    xor  rcx, rcx\n    mov  rbx, 1\nnext_loop:\n    test rsi, rbx\n    jz   next_bit\n    mov  [rax+8*rcx], rbx\n    inc  rcx\nnext_bit:\n    shl  rbx, 1\n    jno  next_loop\n    mov  [rdi], rcx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214434,"user_id":168,"body":"global powers\nextern malloc\n\n; <-- [qword RAX] powers([qword RDI] outlen, RSI n) -->\npowers:\n  push rdx\n  push rdi\n  push rsi\n  mov edi, 64 * 8\n  call malloc\n  pop rsi\n  pop rdi\n  pop rdx\n  xor ecx, ecx\n.loop:\n  mov rdx, rsi\n  neg rdx\n  and rdx, rsi\n  mov qword [rax + 8 * rcx], rdx\n  inc ecx\n  xor rsi, rdx\n  jnz .loop\n  mov qword [rdi], rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214435,"user_id":null,"body":"global powers\nextern malloc\n\n; <-- [qword RAX] powers([qword RDI] outlen, RSI n) -->\npowers:\n    push rbx                ; saving RBX onto the stack\n    sub rsp, 0h200          ; reserving space for powers <pwrs>\n    xor ebx, ebx            ; resetting RBX as <i>\n    xor eax, eax            ; resetting RAX as <shf>\n    inc rax                 ; setting <shf> to one\n.loop:\n    test rsi, 1             ; whterh <n> is odd\n    je .shf                 ; otherwise, jumping to shifting\n    mov [rsp+rbx*0h8], rax  ; copying <shf> to <*(prws+i)>\n    inc rbx                 ; incrementing <i>\n.shf:\n    shl rax, 1              ; multiplying <shf> by two\n    shr rsi, 1              ; dividing <n> by two\n    jne .loop               ; jumping to the next iteration in case <n> is not zero\n    mov [rdi], rbx          ; saving the number in <*outlen>\n    lea rdi, [rbx*0h8]      ; getting the target bytes for the resulting powers <repwrs>\n    call malloc             ; allocating memory\n    test rbx, rbx           ; setting CPU flags\n    jmp .exit               ; jumping to exit\n.lpcpy:\n    lea rsi, [rbx*0h8-0h8]  ; computing the index <inx>\n    mov rdx, [rsp+rsi]      ; copying <*(pwrs+inx)> to RDX as <num>\n    mov [rax+rsi], rdx      ; copying <num> to <*(repwrs+inx)>\n    dec rbx                 ; decrementing <i>\n.exit:\n    jne .lpcpy              ; jumping to the next copy iteration in case <i> is not zero\n    add rsp, 0h200          ; destroying the local storage\n    pop rbx                 ; restoring the original RBX\n    ret\n; -----> endof powers <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5dd462a573ee6d0014ce715b":[{"id":214436,"user_id":null,"body":"global samecase\nsamecase:\n  cmp dil,'A'\n  jl uh_oh\n  cmp sil,'A'\n  jl uh_oh\n  cmp dil,'z'\n  jg uh_oh\n  cmp sil,'z'\n  jg uh_oh\n  cmp dil,'Z'\n  jle capi_dil\n  cmp dil,'a'\n  jge lower_dil\n  uh_oh:\n  mov rax,-1\n  jmp end\n  capi_dil:\n  cmp sil,'Z'\n  setle al\n  jmp end\n  lower_dil:\n  cmp sil,'a'\n  setge al\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214437,"user_id":527,"body":"global samecase\n\n; int samecase(char a, char b)\nsamecase:\n                xor     eax, eax\n                mov     edx, edi\n                xor     edx, esi\n                test    dl, 'A' ^ 'a'\n                setz    al\n                mov     edx, -1\n                and     edi, ~('A' ^ 'a') & 0xff\n                sub     edi, 'A'\n                cmp     edi, 'Z' - 'A' + 1\n                cmova   eax, edx\n                and     esi, ~('A' ^ 'a') & 0xff\n                sub     esi, 'A'\n                cmp     esi, 'Z' - 'A' + 1\n                cmova   eax, edx\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214438,"user_id":null,"body":"global samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n    xor eax, eax\n    mov ecx, 1\n    mov dl, byte [rel lut + rdi]\n    add dl, byte [rel lut + rsi]\n    cmovpo eax, ecx\n    cmovnc eax, dword [rel lut + 256]\n    ret\n; -----> endof samecase <-----\n\nlut:\n    db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,0,0,0,0,0,0,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n    dd -1","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214439,"user_id":881,"body":"extern isalpha\nglobal samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n    mov al, sil\n    xor al, dil\n    and al, 32\n    shr al, 5\n    xor al, 1           ; compare cases\n    push rax\n    push rsi\n    call isalpha        ; isalpha(a)\n    pop rdi \n    test eax, eax\n    jz .isntalpha\n    call isalpha        ; isalpha(b)\n    test eax, eax\n    jz .isntalpha\n    pop rax\n    ret\n.isntalpha:\n    pop rax\n    mov eax, -1\n    ret\n; -----> endof samecase <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214440,"user_id":null,"body":"global samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n    mov cl, dil\n    call classify\n    cmp al, -1\n    je not_a_letter\n    mov r8b, al\n    mov cl, sil\n    call classify\n    cmp al, -1\n    je not_a_letter\n    cmp al, r8b\n    je case_matches\ncase_diff:\n    mov rax, 0\n    ret\ncase_matches:\n    mov rax, 1\n    ret\nnot_a_letter:\n    mov rax, -1\n    ret\n    \nclassify:\n    cmp cl, 65 ; 65 = 'A'\n    jb classify_not_a_letter\n    cmp cl, 122 ; 122 ='z'\n    ja classify_not_a_letter\n    cmp cl, 97 ; 97 = 'a'\n    jae is_lower\n    cmp cl, 90 ; 90 = 'Z'\n    jbe is_upper\nclassify_not_a_letter:\n    mov rax, -1\n    ret\nis_lower:\n    mov rax, 0\n    ret\nis_upper:\n    mov rax, 1\n    ret\n  \n; -----> endof samecase <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214441,"user_id":null,"body":"global samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n  mov eax, 0x20\n  mov cl, dil\n  or cl, al\n  sub cl, 'a'\n  cmp cl, 'z'-'a'\n  ja .not_alpha\n  mov cl, sil\n  or cl, al\n  sub cl, 'a'\n  cmp cl, 'z'-'a'\n  ja .not_alpha\n  and dil, al\n  and sil, al\n  cmp dil, sil\n  sete al\n  ret\n.not_alpha:\n  mov eax, -1\n  ret\n; -----> endof samecase <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214442,"user_id":null,"body":"global samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n\tlea\teax, [rdi-65]\n\tcmp\tal, 57\n\tja\tnotalpha\n\tlea\teax, [rsi-65]\n\tcmp\tal, 57\n\tja\tnotalpha\n\tlea\tedx, [rdi-91]\n\tor\teax, -1\n\tcmp\tdl, 5\n\tjbe\tdone\n\tlea\teax, [rsi-91]\n\txor\tesi, edi\n\tshr\tsil, 5\n\txor\tesi, 1\n\tand\tesi, 1\n\tcmp\tal, 5\n\tmov\teax, -1\n\tcmova\teax, esi\n\tret\nnotalpha:\n\tor\teax, -1\ndone:\n\tret\n\n; -----> endof samecase <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214443,"user_id":null,"body":"global samecase\n\n; <-- BL casegroup(DIL c) -->\n; 1 = lower alpha\n; 2 = upper alpha\n; 3 = other\ncasegroup:\n    cmp dil, 'A'\n    jl  .no_alpha\n    cmp dil, 'Z'\n    ja  .no_upper\n    mov bl, 2\n    ret\n.no_upper:\n    cmp dil, 'a'\n    jl  .no_alpha\n    cmp dil, 'z'\n    ja  .no_alpha\n    mov bl, 1\n    ret\n.no_alpha:\n    mov bl, 3\n    ret\n; -----> endof casegroup <-----\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n    xor eax, eax\n    push rsi\n    call casegroup\n    mov bh,bl           ; bh = casegroup of a\n    pop rdi\n    call casegroup      ; bl = casegroup of b\n    cmp bl,3\n    je .other\n    cmp bh,3\n    je .other\n    cmp bl, bh\n    jne .different\n    inc eax           ; same case: return 1\n.different:\n    ret               ; not same case: return 0\n.other:\n    dec eax           ; not alpha: return -1\n    ret\n; -----> endof samecase <-----\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214444,"user_id":null,"body":"global samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\n    mov al,dil\n    call check\n    cmp eax,-1\n    je fail\n    mov al,sil\n    call check\n    cmp eax,-1\n    je fail\n    sub sil,92\n    sub dil,92\n    xor sil,dil\n    mov al,sil\n    shr al,7\n    xor al,1\n    ret\ncheck:\n    xor ebx,ebx\n    xor ecx,ecx\n    xor bl,bl\n    mov cl,32\n    cmp al,'Z'\n    cmovg ebx,ecx\n    sub al,bl\n    cmp al,'A'\n    jl fail\n    cmp al,'Z'\n    jg fail\n    ret\n\nfail:\n  mov eax,-1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214445,"user_id":null,"body":"global samecase\n\n; <-- EAX samecase(DIL a, SIL b) -->\nsamecase:\ncheck_a_upper:\n    cmp dil,'A'\n    jl return_no_letter\n    cmp dil,'Z'\n    jle a_is_upper\n    \n    cmp dil,'a'\n    jl return_no_letter\n    cmp dil,'z'\n    jle a_is_lower\n    jmp return_no_letter\n\ncheck_b_upper:\n    cmp sil,'A'\n    jl return_no_letter\n    cmp sil,'Z'\n    jle b_is_upper\n\n    cmp sil,'a'\n    jl return_no_letter\n    cmp sil,'z'\n    jle b_is_lower\n    jmp return_no_letter\n    \n\na_is_lower:\n    mov eax, 1\n    jmp check_b_upper\n\n\na_is_upper:\n    mov eax, 0\n    jmp check_b_upper\n\n\nb_is_lower:\n    cmp eax, 1\n    je return_equal_case\n    jmp return_distinct_case\n\nb_is_upper:\n    cmp eax, 0\n    je return_equal_case\n    jmp return_distinct_case\n\nreturn_equal_case:\n    mov eax, 1\n    ret\nreturn_distinct_case:\n    mov eax, 0\n    ret\n\n       \nreturn_no_letter:\n    mov eax, -1\n    ret\n; -----> endof samecase <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5e296e18ca02cc00297859bc":[{"id":214446,"user_id":168,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:            ; int whichIsLarger(int a, int b)\n  mov eax, edi\n  cmp edi, esi\n  cmovl eax, esi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214447,"user_id":null,"body":"section .text\n  global whichIsLarger\n  whichIsLarger:\n    mov rax, rdi\n    cmp rsi, rdi\n    cmovge rax, rsi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214448,"user_id":527,"body":"section .text\nglobal whichIsLarger\n; int whichIsLarger(int a, int b)\nwhichIsLarger:\n                mov     eax, edi\n                cmp     esi, edi\n                cmovg   eax, esi\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214449,"user_id":null,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:            ; int whichIsLarger(int a, int b)\n  mov eax, edi\n  cmp edi, esi\n  jl  s\n  \n  jmp end\n  \n  s:\n    mov eax, esi\n  \n  end:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214450,"user_id":null,"body":"section .text\nglobal whichIsLarger\n\nwhichIsLarger:\n  mov eax, esi\n  cmp esi, edi\n  cmovl eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214451,"user_id":null,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:            ; int whichIsLarger(int a, int b)\n  mov eax, edi\n  cmp edi, esi\n  jl less\n  ret\nless:\n  mov eax, esi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214452,"user_id":null,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:\n  cmp rdi, rsi\n  jl m1\n  mov rax, rdi\n  ret\n  m1:\n  mov rax, rsi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214453,"user_id":null,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:            ; int whichIsLarger(int a, int b)\n  cmp rdi, rsi\n  jl m1\n  mov rax, rdi\n  ret\n  m1:\n  mov rax, rsi\n  ; start coding here\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214454,"user_id":null,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:            ; int whichIsLarger(int a, int b)\n  ; start coding here\n  cmp EDI, ESI\n  jl secondLarger\nfirstLarger:\n  mov EAX, EDI\n  ret\nsecondLarger:\n  mov EAX, ESI\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214455,"user_id":null,"body":"section .text\nglobal whichIsLarger\nwhichIsLarger:\n  cmp rdi,rsi\n  cmovg rax,rdi\n  cmovle rax,rsi\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5efcaedf95d7110017896ced":[{"id":214456,"user_id":null,"body":"extern malloc\nglobal fp32toieee754\nglobal fp64toieee754\n\nsection .text\n\nfp32toieee754:\n  push rbx\n  movd ebx, xmm0\n  mov rdi, 35\n  call malloc\n  mov cl, 32\n  mov byte [rax + 34], 0\n  mov [rax + 10], cl\n  mov [rax + 1], cl\n  mov rcx, 33\n.exploop\n  cmp rcx, 10\n  jbe .expdone\n  mov edx, ebx\n  shr ebx, 1\n  and dl, 1\n  or dl, 48\n  mov [rax + rcx], dl\n  dec rcx\n  jmp .exploop\n.expdone:\n  mov rcx, 9\n.mantloop\n  mov edx, ebx\n  and dl, 1\n  or dl, 48\n  cmp rcx, 1\n  jbe .done\n  mov [rax + rcx], dl\n  shr ebx, 1\n  dec rcx\n  jmp .mantloop\n.done\n  mov [rax], dl\n  pop rbx\n  ret\n\nfp64toieee754:\n  push rbx\n  movq rbx, xmm0\n  mov rdi, 67\n  call malloc\n  mov cl, 32\n  mov byte [rax + 66], 0\n  mov [rax + 13], cl\n  mov [rax + 1], cl\n  mov rcx, 65\n.exploop\n  cmp rcx, 13\n  jbe .expdone\n  mov edx, ebx\n  shr rbx, 1\n  and dl, 1\n  or dl, 48\n  mov [rax + rcx], dl\n  dec rcx\n  jmp .exploop\n.expdone:\n  mov rcx, 12\n.mantloop\n  mov edx, ebx\n  and dl, 1\n  or dl, 48\n  cmp rcx, 1\n  jbe .done\n  mov [rax + rcx], dl\n  shr rbx, 1\n  dec rcx\n  jmp .mantloop\n.done\n  mov [rax], dl\n  pop rbx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214457,"user_id":null,"body":"global fp32toieee754\nglobal fp64toieee754\nextern malloc\n\n%macro write_bit 1\n  shl %1, 1\n  setc dl\n  add dl, '0'\n  mov [rdi], dl\n  inc rdi\n%endmacro\n\nsection .text\n\n; <-- [byte RAX] fp32toieee754(XMM0 fp32) -->\nfp32toieee754:\n  movd eax, xmm0\n  push rax\n  mov edi, 35\n  call malloc\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  \n  write_bit esi\n  mov byte [rdi], ' '\n  inc rdi\n  %rep 8\n  write_bit esi\n  %endrep\n  mov byte [rdi], ' '\n  inc rdi\n  %rep 23\n  write_bit esi\n  %endrep\n  mov byte [rdi], 0\n.quit:\n  ret\n; -----> endof fp32toieee754 <-----\n\n; <-- [byte RAX] fp64toieee754(XMM0 fp64) -->\nfp64toieee754:\n  movq rax, xmm0\n  push rax\n  mov edi, 67\n  call malloc\n  pop rsi\n  test rax, rax\n  jz .quit\n  mov rdi, rax\n  \n  write_bit rsi\n  mov byte [rdi], ' '\n  inc rdi\n  %rep 11\n  write_bit rsi\n  %endrep\n  mov byte [rdi], ' '\n  inc rdi\n  %rep 52\n  write_bit rsi\n  %endrep\n  mov byte [rdi], 0\n.quit:\n  ret\n; -----> fp64toieee754 <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214458,"user_id":null,"body":"global fp32toieee754\nglobal fp64toieee754\n\nextern malloc\n\nsection .text\n\n; <-- [byte RAX] fp32toieee754(XMM0 fp32) -->\nfp32toieee754:\n  mov rdi, 35\n  call malloc\n  push rax\n  \n  movd edi, xmm0\n  mov esi, 0x80000000\n  \n.loop:\n  test edi, esi\n  jz .zero\n  \n  mov BYTE [rax], '1'\n  jmp .test_space\n  \n.zero:\n  mov BYTE [rax], '0'\n  \n.test_space:\n  cmp esi, 0x80000000\n  je .space\n  \n  cmp esi, 0x800000\n  je .space\n  \n  jmp .continue\n\n.space:\n  inc rax\n  mov BYTE [rax], ' '\n\n.continue:\n  inc rax\n  \n  shr esi, 1\n  \n  test esi, esi\n  jnz .loop\n  \n  mov BYTE [rax], 0\n  pop rax\n  ret\n; -----> endof fp32toieee754 <-----\n\n; <-- [byte RAX] fp64toieee754(XMM0 fp64) -->\nfp64toieee754:\n  mov rdi, 67\n  call malloc\n  push rax\n  \n  movq rdi, xmm0\n  mov rsi, 0x8000000000000000\n  \n.loop:\n  test rdi, rsi\n  jz .zero\n  \n  mov BYTE [rax], '1'\n  jmp .test_space\n  \n.zero:\n  mov BYTE [rax], '0'\n  \n.test_space:\n  mov rcx, 0x8000000000000000\n  cmp rsi, rcx\n  je .space\n  \n  mov rcx, 0x10000000000000\n  cmp rsi, rcx\n  je .space\n  \n  jmp .continue\n\n.space:\n  inc rax\n  mov BYTE [rax], ' '\n  \n.continue:\n  inc rax\n  \n  shr rsi, 1\n  test rsi, rsi\n  jnz .loop\n  \n  mov BYTE [rax], 0\n  pop rax\n  ret\n; -----> fp64toieee754 <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214459,"user_id":null,"body":"global fp32toieee754\nglobal fp64toieee754\nextern malloc\nsection .text\n\n; <-- [byte RAX] fp32toieee754(XMM0 fp32) -->\nfp32toieee754:\n    mov edi,35\n    call malloc\n    lea rdx,[rax] ;rdx is now pointer to allocated string\n    movd ebx,xmm0\n    rol ebx,1\n    mov al,'1'\n    and al,bl\n    or al,'0'\n    mov ah,' '\n    mov [rdx],ax\n    lea rdx,[rdx+2]\n    mov ecx,8\n    call .fp32tostring\n    mov byte[rdx],' '\n    inc rdx\n    mov ecx,23\n    call .fp32tostring\n    lea rax,[rdx-34]\n    ret\n    \n.fp32tostring:\n    rol ebx,1\n    mov al,'1'\n    and al,bl\n    or al,'0'\n    mov [rdx],al\n    inc rdx\n    dec ecx\n    jne .fp32tostring\n    ret\n    \n; -----> endof fp32toieee754 <-----\n\n; <-- [byte RAX] fp64toieee754(XMM0 fp64) -->\nfp64toieee754:\n    mov edi,67\n    call malloc\n    lea rdx,[rax]\n    movq rbx,xmm0\n    rol rbx,1\n    mov al,'1'\n    and al,bl\n    or al,'0'\n    mov ah,' '\n    mov [rdx],ax\n    lea rdx,[rdx+2]\n    mov ecx,11\n    call .fp64tostring\n    mov byte[rdx],' '\n    inc rdx\n    mov ecx,52\n    call .fp64tostring\n    lea rax,[rdx-66]\n    ret\n.fp64tostring:\n    rol rbx,1\n    mov al,'1'\n    and al,bl\n    or al,'0'\n    mov [rdx],al\n    inc rdx\n    dec ecx\n    jne .fp64tostring\n    ret\n; -----> fp64toieee754 <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214460,"user_id":null,"body":"global fp32toieee754\nglobal fp64toieee754\nextern malloc\n\nprintbin:\n  add  rdx,rdx\n  mov  byte[rdi],'0'\n  adc  byte[rdi],0\n  inc  rdi\n  loop printbin\n  mov  byte[rdi],' '\n  inc  rdi\nret\n\nfp32toieee754:\n  mov   rdi,35\n  call  malloc\n  mov   rdi,rax\n  movq  rdx,xmm0\n  shl   rdx,32\n  mov   ecx,1\n  call  printbin\n  mov   ecx,8\n  call  printbin\n  mov   ecx,23\n  call  printbin\n  mov   byte[rdi-1],0\nret\n\nfp64toieee754:\n  mov   rdi,67\n  call  malloc\n  mov   rdi,rax\n  movq  rdx,xmm0  \n  mov   ecx,1\n  call  printbin\n  mov   ecx,11\n  call  printbin\n  mov   ecx,52\n  call  printbin\n  mov   byte[rdi-1],0\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214461,"user_id":null,"body":"; ----------------------------------------------------------------------\n;                         Written by Ali Muhammad\n;                             August 24, 2021\n; ----------------------------------------------------------------------\n\nglobal fp32toieee754\nglobal fp64toieee754\nextern malloc\n\nsection .text\n\n%macro fp2ieee754 0\n    push rdx                ; saving <bits> onto stack\n    push rsi                ; saving <exp> onto stack\n    push rdi                ; saving <n> onto stack\n    add rdi, 3              ; the number of bytes to allocate for <ieee754>\n    call malloc             ; allocating memory for <ieee754>\n    pop rcx                 ; restoring <n> from stack\n    pop rdx                 ; restoring <exp> from stack\n    pop rdi                 ; restoring <bits> from stack\n    mov rsi, rcx            ; copying <n> to RSI\n    sub rsi, 1              ; setting RSI to the <sign> location\n    mov r8, rsi             ; copying <sign> to R8\n    sub r8, rdx             ; setting R8 to the <exp> location\n    push rax                ; saving <ieee754> onto stack\n%%loop:\n    test rcx, rcx           ; whether <n> is not zero\n    je %%exit               ; otherwise, jumping to exit\n    dec ecx                 ; decrementing <n>\n    mov rdx, rdi            ; copying <bits> to RDX\n    shr rdx, cl             ; getting the necessary <ibit = bits >> n>\n    and rdx, 1              ; masking <ibit>\n    add edx, '0'            ; getting the ascii <digit>\n    mov [rax], dl           ; copying <digit> to <*ieee754>\n    inc rax                 ; pointing <ieee754> to the next location\n    cmp rcx, rsi            ; whether <n> is equal to <sign> location\n    je %%sp                 ; then, jumping to space  \n    cmp rcx, r8             ; whether <n> is equal to <exp> location\n    jne %%loop              ; otherwise, jumping to the next iteration\n%%sp:\n    mov [rax], byte ' '     ; copying a space character to <*ieee754>\n    inc rax                 ; pointing <ieee754> to the next character location \n    jmp %%loop              ; jumpint to the next iteration\n%%exit:\n    mov [rax], byte 0       ; terminating <*ieee754>\n    pop rax                 ; restoring the initial <ieee754>\n%endmacro\n\n; <-- [byte RAX] fp32toieee754(XMM0 fp32) -->\nfp32toieee754:\n    vmovd edx, xmm0         ; copying <bits> from fp32 to int32\n    mov esi, 8              ; the number of bits in <exp>onent\n    mov edi, 32             ; the <n>umber of bits in <fp32>\n    fp2ieee754\n    ret\n; -----> endof fp32toieee754 <-----\n\n; <-- [byte RAX] fp64toieee754(XMM0 fp64) -->\nfp64toieee754:\n    vmovq rdx, xmm0         ; copying <bits> from fp64 to int64\n    mov esi, 11             ; the number of bits in <exp>onent\n    mov edi, 64             ; the <n>umber of bits in <fp64>\n    fp2ieee754\n    ret\n; -----> fp64toieee754 <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5f70e4cce10f9e0001c8995a":[{"id":214462,"user_id":527,"body":"section .text\nglobal solution\n\n;; unsigned solution(const char* stones);\nsolution:\n                xor     eax, eax\n                mov     ecx, '-'\n.loop:          movzx   edx, byte [rdi]\n                inc     rdi\n                cmp     cl, dl\n                sete    cl\n                add     rax, rcx\n                mov     ecx, edx\n                test    dl, dl\n                jnz     .loop\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214463,"user_id":null,"body":"section .text\nglobal solution\n\n;; unsigned solution(const char* stones);\nsolution:\n  xor eax, eax\n  xor edx, edx\n.loop:\n  mov cl, [rdi]\n  test cl, cl\n  je .done\n  xor esi, esi\n  cmp cl, dl\n  sete sil\n  add eax, esi\n  inc rdi\n  mov edx, ecx\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214464,"user_id":null,"body":"section .text\nglobal solution\n\n;; unsigned solution(const char* stones);\nsolution:\n  xor eax, eax\n  xor edx, edx\n  \n.loop:\n  mov cl, [rdi]\n  inc rdi\n  test cl, cl\n  jz .end\n  cmp cl, dl\n  mov dl, cl\n  jnz .loop\n  inc eax\n  jmp .loop\n  \n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214465,"user_id":null,"body":"section .text\nglobal solution\n\n;; unsigned solution(const char* stones);\nsolution:\n  xor rax, rax\n  \n.loop:\n  mov sil, byte [rdi]\n  inc rdi\n  cmp byte [rdi], 0\n  jz .exit\n  \n  cmp sil, byte [rdi]\n  jne .next\n  inc rax\n  \n.next:\n  jmp .loop\n  \n.exit:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214466,"user_id":null,"body":"global solution\nextern strdup\nsolution:\n  call  strdup  ;I just want to use cmpxchg.... just for fun\n  mov   rdi,rax\n  xor   rcx,rcx\n  .b:cmpxchg [rdi],al\n     sete    dl\n     add     cl,dl\n     inc     rdi\n     cmp     byte[rdi],0\n  jne .b   \n  movzx rax,cl\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214467,"user_id":null,"body":"section .text\nglobal solution\n;extern printf\n;; unsigned solution(const char* stones);\nsolution:\n;      push rdi\n;      push rsi\n;      mov rsi, rdi\n;      mov rdi, fmt\n;      xor rax, rax\n;      xor rdx, rdx\n;      call printf\n;      pop rsi\n;      pop rdi\n      \n      xor rax, rax\n      inc rdi\nmnl:  mov bl, [rdi]\n      cmp bl, [rdi-1]\n      jnz cnt\n      inc rax\ncnt:  inc rdi\n      cmp byte[rdi], 0\n      jnz mnl\n      ret\n\n;fmt:    db \"%s     \", 10, 0","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214468,"user_id":168,"body":"section .text\nglobal solution\n\n;; unsigned solution(const char* stones);\nsolution:\n  xor eax, eax\n  xor esi, esi\n  movzx ecx, byte [rdi]\n  test ecx, ecx\n  jz .end\n.loop:\n  inc rdi\n  movzx edx, byte [rdi]\n  test edx, edx\n  jz .end\n  cmp ecx, edx\n  sete sil\n  add eax, esi\n  mov ecx, edx\n  jmp .loop\n.end:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214469,"user_id":881,"body":"section .text\nglobal solution\n\n;; unsigned solution(const char* stones);\nsolution:\n  xor rax, rax\n  xor rdx, rdx\n  xor rsi, rsi\n.next:\n  mov dl, sil\n  mov sil, byte[rdi]\n  test sil, sil\n  jz .done\n  inc rdi\n  cmp sil, dl\n  jnz .next\n  inc rax\n  jmp .next\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5f77d62851f6bc0033616bd8":[{"id":214470,"user_id":null,"body":"section .text\nglobal valid_spacing\n\n;; bool valid_spacing(const char *str_in);\nvalid_spacing:\n  movzx eax, byte [rdi]\n  test eax, eax\n  je .empty\n  cmp eax, 32\n  je .fail\n  inc rdi\n.loop:\n  mov ecx, eax\n  mov al, byte [rdi]\n  test al, al\n  je .checklast\n  inc rdi\n  cmp al, 32\n  jne .loop\n  cmp cl, 32\n  jne .loop\n.fail:\n  xor eax, eax\n  ret\n.empty:\n  mov al, 1\n  ret\n.checklast:\n  cmp cl, 32\n  setne al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214471,"user_id":null,"body":"section .text\nglobal valid_spacing\n\n;; bool valid_spacing(const char *str_in);\nvalid_spacing:\n    xor rcx, rcx\n    mov rdx, ' '\n    mov r9, 1\n    cmp byte [rdi+rcx], dl\n    jz false\nloop:\n    xor rax, rax\n    xor r10, r10\n    cmp byte [rdi+rcx], 0\n    jz end\n    cmp byte [rdi+rcx], dl\n    cmovz rax, r9\n    cmp byte [rdi+rcx+1], dl\n    cmovz r10, r9\n    and r10, rax\n    jnz false\n    inc rcx\n    jmp loop\n    \nend:\n    cmp byte [rdi+rcx-1], dl\n    jz false\ntrue:\n    mov rax, r9\n    ret\n    \nfalse:\n    xor rax, rax\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214472,"user_id":50,"body":"section .text\nglobal valid_spacing\n\n;; bool valid_spacing(const char *str_in);\nvalid_spacing:\n    xor rax, rax\n    cmp byte[rdi],0 ; empty string?\n    je _retTrue\n    cmp byte[rdi],32 ; starts with space\n    je _retFalse\n_loop:\n  inc rdi\n  cmp byte[rdi],0\n  je _retTrue\n  cmp byte[rdi],32 ; space\n  je _check\n  jmp _loop\n_check:\n  cmp byte[rdi+1],0\n  je _retFalse\n  cmp byte[rdi+1],32\n  je _retFalse\n  jmp _loop\n_retFalse:\n    mov rax,0\n    ret\n_retTrue:\n    mov rax,1\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214473,"user_id":null,"body":"global valid_spacing\nvalid_spacing:\n  xor rax,rax\n  cmp byte[rdi],0\n  je .null\n  cmp byte[rdi],' '\n  je .quit\n    .b:inc rdi\n       cmp word[rdi],'  '\n       je .quit\n       cmp byte[rdi],0\n    jne .b\n    cmp byte[rdi-1],' '\n    je .quit\n    .null:\n      mov rax,1\n  .quit:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214474,"user_id":76,"body":"section .text\nglobal valid_spacing\n\n;; bool valid_spacing(const char *str_in);\nvalid_spacing:\n  xor rax, rax\n  mov al, 1\n  cmp byte [rdi], 32\n  je .invalid\n.loop:\n  mov bl, byte [rdi]\n  cmp bl, 0\n  je .done\n  cmp bl, 32\n  je .space\n  inc rdi\n  jmp .loop\n.space:\n  inc rdi\n  cmp byte [rdi], 32\n  je .invalid\n  cmp byte [rdi], 0\n  jne .loop\n.invalid:\n  mov al, 0\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214475,"user_id":null,"body":"section .text\nglobal valid_spacing\nvalid_spacing:\n      mov rsi,rdi\n      xor rcx,rcx\n@l1:  lodsb    \n      test al,al\n      jz @rt\n      cmp al,' '\n      jne @nsp\n      test ch,ch\n      jz @rf\n      test cl,cl\n      jnz @rf\n      mov cx,0x0001\n      jmp @l1      \n@rf:  xor eax,eax\n      ret\n@nsp: mov cx,0x0100\n      jmp @l1\n@rt:  test cl,cl\n      jnz @rf\n      setz al\n      ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214476,"user_id":null,"body":"section .text\nglobal valid_spacing\n\n;; bool valid_spacing(const char *str_in);\nvalid_spacing:\n  mov eax, 0\n  cmp BYTE [rdi], 0\n  je end_of_string\n  mov eax, 1\nloop_top:\n  cmp BYTE [rdi], ' '\n  je is_space\nnot_space:\n  xor eax, eax\n  jmp check_valid\nis_space:\n  inc eax\ncheck_valid:\n  cmp eax, 1\n  ja ret_invalid\n  inc rdi\n  cmp BYTE [rdi], 0\n  je end_of_string\n  jmp loop_top\nend_of_string:\n  cmp eax, 0\n  ja ret_invalid\n  mov eax, 1\n  ret\nret_invalid:\n  mov eax, 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214477,"user_id":168,"body":"section .text\nglobal valid_spacing\n\n;; bool valid_spacing(const char *str_in);\nvalid_spacing:\n  mov eax, 1\n  movzx edx, byte [rdi]\n  test edx, edx\n  jz .end\n  xor eax, eax\n.loop:\n  sub edx, ' '\n  add eax, edx\n  jz .end\n  mov eax, edx\n  inc rdi\n  movzx edx, byte [rdi]\n  test edx, edx\n  jnz .loop\n  test eax, eax\n  setnz al\n.end:\n  ret  ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214478,"user_id":881,"body":"section .text\nglobal valid_spacing\n\n; bool valid_spacing(const char *str_in);\nvalid_spacing:\n    xor rax, rax\n    cmp byte[rdi], ' '\n    je .done\n    cmp byte[rdi], 0\n    je .true\n.next:\n    inc rdi\n    cmp byte[rdi], 0\n    je .true\n    cmp byte[rdi], ' '\n    jne .next\n    cmp byte[rdi+1], 0\n    je .done\n    cmp byte[rdi+1], ' '\n    je .done\n    jmp .next\n.true:\n    inc rax\n.done:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5f79b90c5acfd3003364a337":[{"id":214479,"user_id":null,"body":"section .text\nglobal  last_digit\n\n; int last_digit(long n)\n; n: rdi\n; return value: rax\nlast_digit:\n  push r15\n  push r14\n  push rbx\n  cmp rdi, 9\n  jg .gt9\n  mov eax, [4*rdi + .d]\n  jmp .done\n.gt9:\n  mov r14, 10\n  mov rax, rdi\n  xor edx, edx\n  div r14\n  mov r15, rdx\n  xor edx, edx\n  div r14\n  xor eax, eax\n  test dl, 1\n  sete al\n  lea rbx, [rax + rax + 4]\n  push 5\n  pop rcx\n  mov rax, rdi\n  xor edx, edx\n  div rcx\n  mov rdi, rax\n  call last_digit\n  movsxd rcx, eax\n  movsxd rax, dword [4*r15 + .d]\n  imul rax, rcx\n  imul rax, rbx\n  cqo\n  idiv r14\n  mov rax, rdx\n.done:\n  pop rbx\n  pop r14\n  pop r15\n  ret\n\nsection .data\n.d: dd 1,1,2,6,4,2,2,4,2,8\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214480,"user_id":168,"body":"section .text\nglobal  last_digit\n\nxs dd 1, 1, 2, 6, 4, 4, 4, 8, 4, 6\nys dd 1, 3, 9, 27\n\n; int last_digit(long n)\nlast_digit:\n  cmp rdi, 1\n  jle .one\n  \n  push rbx\n  xor edx, edx\n  mov rax, rdi\n  mov ecx, 5\n  div rcx\n  mov rdi, rax                    ; rdi = n \/ 5, rdx = n % 5\n  and eax, 3\n  mov ebx, dword [ys + rax * 4]   ; ebx = 3 ** (n \/ 5 % 4)\n  and eax, 1\n  lea eax, [5 * rax]\n  add eax, edx                    ; eax = n % 10\n  imul ebx, dword [xs + rax * 4]\n  imul ebx, 6                     ; ebx = 6 * xs[n % 10] * 3 ** (n \/ 5 % 4)\n  call last_digit\n  imul eax, ebx\n  \n  mov ecx, 10\n  xor edx, edx\n  div ecx\n  mov eax, edx\n  pop rbx\n  ret\n  \n.one:\n  mov eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214481,"user_id":77,"body":"section .data\n\nca:     dq      1, 1, 2, 1, 4, 4, 4, 3, 4, 1\nc2:     dq      1, 2, 4, 3\ndiv5p:  dq      0,0,0,0,0, 0,6,8,2,4, 0,2,6,4,8, 0,8,4,6,2, 0,4,2,8,6\n        \nsection .text\nglobal  last_digit\n\nlast_digit:\n        cmp     rdi, 2\n        jl      .one\n        mov     r8, 1\n        mov     r9, 0\n        mov     rcx, 5\n        mov     rsi, 10\n.loop:\n        mov     rax, rdi\n        xor     rdx, rdx\n        idiv    rsi\n        mov     rax, [ca+rdx*8]\n        imul    r8\n        idiv    rcx\n        mov     r8, rdx\n        mov     rax, rdi\n        xor     rdx, rdx\n        idiv    rcx\n        mov     rdi, rax\n        add     r9, rdi\n        cmp     rdi, 0\n        jg      .loop\n        and     r9, 3\n        mov     rdx, [c2+r9*8]\n        add     rdx, r8\n        shl     r8, 2\n        add     rdx, r8\n        mov     rax, [div5p+rdx*8]\n        ret\n.one:\n        mov     rax, 1\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214482,"user_id":77,"body":"section .data\n\nca:     dq      1, 1, 2, 1, 4, 4, 4, 3, 4, 1\nc2:     dq      1, 2, 4, 3\ndiv5p:  dq      0,0,0,0,0, 0,6,8,2,4, 0,2,6,4,8, 0,8,4,6,2, 0,4,2,8,6\n        \nsection .text\nglobal  last_digit\n\nlast_digit:\n        cmp     rdi, 2\n        jl      .one\n        mov     r8, 1\n        mov     r9, 0\n        mov     rcx, 5\n        mov     rsi, 10\n.loop:\n        mov     rax, rdi\n        xor     rdx, rdx\n        idiv    rsi\n        mov     rax, [ca+rdx*8]\n        imul    r8\n        idiv    rcx\n        mov     r8, rdx\n        mov     rax, rdi\n        xor     rdx, rdx\n        idiv    rcx\n        mov     rdi, rax\n        add     r9, rdi\n        cmp     rdi, 0\n        jg      .loop\n        and     r9, 3\n        mov     rdx, [c2+r9*8]\n        add     rdx, r8\n        shl     r8, 2\n        add     rdx, r8\n        mov     rax, [div5p+rdx*8]\n        ret\n.one:\n        mov     rax, 1\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5f7c38eb54307c002a2b8cc8":[{"id":214483,"user_id":null,"body":"section .text\nglobal remove_parentheses\n\n; my first assembly program!\n\n; void remove_parentheses(readonly byte ptr rdi, out byte ptr rsi)\nremove_parentheses:\n        xor   rcx, rcx ; used as the depth counter\n        \n.loop:  mov   al, byte [rdi]\n        cmp   al, 0\n        je    .end\n        \n        cmp   al, '('\n        jne   .notlp\n        inc   rcx            ; increase depth\n        jmp   .notrp         ; shortcut\n.notlp: cmp   al, ')'\n        jne   .notrp\n        dec   rcx            ; decrease depth\n        jmp   .lend          ; jump to loop end to prevent writing the byte\n\n.notrp: cmp   rcx, 0         ; if rcx > 0 dont write a byte and only increment rdi\n        jg    .lend          ; go to loop end\n        mov   byte [rsi], al\n        inc   rsi\n\n.lend:  inc   rdi\n        jmp   .loop\n\n.end:   mov   byte [rsi+1], 0      ; write null byte at end\n        ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214484,"user_id":null,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n    push rdi\n    push rsi\n    pop rdi\n    pop rsi\n    xor rcx,rcx\n@l1:lodsb\n    test al,al\n    jz @e\n    cmp al,'('\n    jne @l2    \n    inc rcx\n    jmp @l1\n@l2:cmp al,')'\n    jne @l3\n    dec rcx\n    jmp @l1\n@l3:test rcx,rcx\n    jnz @l1\n    stosb\n    jmp @l1\n@e: ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214485,"user_id":null,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n  mov rax,0\n  mov rcx,-1\n  mov rbx,0\n  mov r8,0\n  mov r9,1\n  loop1:\n  inc rcx\n  mov dl,[rdi+rcx]\n  \n  cmp dl,0\n  je end\n  \n  cmp dl,'('\n  jne no_open\n  inc rax\n  no_open:\n  \n  cmp dl,')'\n  jne no_close\n  dec rax\n  je loop1\n  no_close:\n  \n  cmp rax,0\n  jg loop1\n  \n  mov [rsi+r8],dl\n  inc r8\n  jmp loop1\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214486,"user_id":null,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n  xchg rdi,rsi\n  xor  edx,edx\n  @b:lodsb\n     mov ecx,'('\n     xor cl,al\n     cmp cl,1\n     ja @f\n       lea edx,[edx+ecx*2-1]\n       jmp @b\n     @f:\n     test edx,edx\n     jnz @f2\n       stosb\n     @f2:\n     test al,al\n   jnz @b  \nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214487,"user_id":null,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n  xor eax, eax\n.loop:\n  mov cl, [rdi]\n  mov edx, 1\n  cmp cl, 40\n  je .lparen\n  test cl, cl\n  je .done\n  test eax, eax\n  jne .inparens\n  mov [rsi], cl\n  inc rsi\n  mov cl, [rdi]\n.inparens:\n  xor edx, edx\n  cmp cl, 41\n  sete dl\n  neg edx\n.lparen:\n  add eax, edx\n  inc rdi\n  jmp .loop\n.done:\n  mov byte [rsi], 0\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214488,"user_id":881,"body":"section .text\nglobal remove_parentheses\n\n; void remove_parentheses(char *str_in, char *str_out)\n; rdi := str_in, rsi := str_out\nremove_parentheses:\n    xor rax, rax\n.loop:\n    mov cl, [rdi]\n    inc rdi\n    test cl, cl\n    jz .end\n    cmp cl, '('\n    jne .a\n    inc rax\n.a:\n    test rax, rax\n    jnz .b\n    mov [rsi], cl\n    inc rsi\n.b:\n    cmp cl, ')'\n    jne .loop\n    dec rax\n    jmp .loop   \n.end:\n    mov byte[rsi], 0\n    xor rax, rax\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214489,"user_id":50,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n                ; void remove_parentheses(char *str_in, char *str_out)\n                ; rdi := str_in\n                ; rsi := str_out\n  push rsi      ; save str_out\n  xor r8,r8     ; index out\n  xor r9,r9     ; count open parentheses\n_loop:\n  mov al,[rdi]\n  inc rdi\n  test al,al\n  jz _exit\n  cmp al,0x28\n  je _inc\n  test r9,r9\n  jz _pushChar\n  cmp al,0x29\n  je _dec\n  jmp _loop\n_inc:\n  inc r9\n  jmp _loop\n_dec:\n  dec r9\n  jmp _loop\n_pushChar:\n  mov [rsi],al\n  inc rsi\n  jmp _loop\n _exit:\n  mov [rsi],al\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214490,"user_id":null,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n                ; void remove_parentheses(char *str_in, char *str_out)\n                ; rdi := str_in\n                ; rsi := str_out\n\n  xor ecx, ecx\n  \n.loop:\n  mov al, [rdi]\n  inc rdi\n  test al, al\n  jz .done\n  cmp al, '('\n  je .open\n  cmp al, ')'\n  je .close\n  \n  test ecx, ecx\n  jnz .loop\n  mov [rsi], al\n  inc rsi\n  jmp .loop\n  \n.open:\n  inc ecx\n  jmp .loop\n.close:\n  dec ecx\n  jmp .loop\n\n.done:\n  mov [rsi], al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214491,"user_id":173,"body":"extern strcpy\n\nsection .data\ntrue:\n  db 1\nfalse:\n  db 0\n\nsection .text\nglobal remove_parentheses\nremove_parentheses:\n                ; void remove_parentheses(char *str_in, char *str_out)\n                ; rdi := str_in\n                ; rsi := str_out\n                \n                \n  push rdi\n  push rsi\n  xchg rdi, rsi\n  call strcpy\n  pop rsi\n  pop rdi\n\n  mov r12, rsi\n  \n  ; compute paren pairs\n  ; open paren r14, closed paren r15\nl1:\n  mov r13, r12\n  mov r14, 0\n  mov r15, 0\nl_loop:\n  cmp byte [r13], 0\n  je l_done\n  cmp byte [r13], '('\n  cmove r14, r13\n  cmp byte [r13], ')'\n  cmove r15, r13\n  cmp byte [r13], ')'\n  je l_done\n  inc r13\n  jmp l_loop\n  \nl_done:\n  cmp r14, 0\n  je l_exit\n  cmp r15, 0\n  je l_exit\n  cmp r14, r15\n  jae l_exit\n\n  \n  ; copy over paren content\n  mov r13, r14\n  mov rax, r15\n  inc rax\nl_lloop:\n  cmp byte [rax], 0\n  je l_ldone\n  mov cl, byte [rax]\n  mov byte [r13], cl\n  inc r13\n  inc rax\n  jmp l_lloop\n\nl_ldone:\n  mov byte [r13], 0\n  \n  ; look for next paren pair\n  jmp l1\n\nl_exit:\n  mov rsi, r12\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214492,"user_id":null,"body":"section .text\nglobal remove_parentheses\nremove_parentheses:\n                ; void remove_parentheses(char *str_in, char *str_out)\n                ; rdi := str_in\n                ; rsi := str_out\n  xor al, al\n  xor cl, cl    ; c\n  cmp [rdi], byte 0\n  je  .end\n  \n  .loop:\n  mov al, [rdi]\n  cmp al, '('\n  je  .open\n  cmp   cl, 0\n  je    .copy\n  .first:\n  cmp al, ')'\n  je  .close\n  .second:\n  inc rdi\n  cmp [rdi], byte 0\n  jne .loop\n  \n  .end:\n  mov [rsi], byte 0\n  ret\n  \n  .open:\n  inc cl\n  jmp .first\n  \n  .close:\n  dec cl\n  jmp .second\n  \n  .copy:\n  mov [rsi], al\n  inc rsi\n  jmp .second","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5f8341f6d030dc002a69d7e4":[{"id":214493,"user_id":null,"body":"section .text\nglobal least_larger\n\n; ssize_t least_larger(const int *array, size_t n, size_t index)\n; array -> rdi, n -> rsi, index -> rdx\nleast_larger:\n    mov rax, -1\n    mov ecx, [rdi + rdx * 4] ; ecx = index\n    mov rdx, 0x0000000007FFFFFF\n.first_loop:\n    dec rsi\n    mov ebx, [rdi + rsi * 4]\n    cmp ecx, ebx ; index vs current\n    jge .not_change\n    cmp edx, ebx\n    jle .not_change\n    mov edx, ebx\n    mov eax, esi\n.not_change:\n    cmp rsi, 0\n    jne .first_loop\n    ret\n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214494,"user_id":168,"body":"section .text\nglobal least_larger\n\n; ssize_t least_larger(const int *array, size_t n, size_t index)\n; array -> rdi, n -> rsi, index -> rdx\nleast_larger:\n  mov rax, -1\n  mov r9d, dword [rdi + 4 * rdx]\n  mov r8d, 0x7fffffff\n  xor ecx, ecx\n  jmp .loop_cond\n.loop:\n  mov edx, dword [rdi + 4 * rcx]\n  cmp edx, r9d\n  cmovle edx, r8d\n  cmp edx, r8d\n  cmovl rax, rcx\n  cmovl r8d, edx\n  inc rcx\n.loop_cond:\n  cmp rcx, rsi\n  jb .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214495,"user_id":null,"body":"section .text\nglobal least_larger\n\n; ssize_t least_larger(const int *array, size_t n, size_t index)\n; array -> rdi, n -> rsi, index -> rdx\nleast_larger:\n  test rsi, rsi\n  je .empty\n  mov r8d, dword [rdi + 4*rdx]\n  mov rax, -1\n  mov r11d, 2147483647\n  xor ecx, ecx\n.loop:\n  mov r9d, dword [rdi + 4*rcx]\n  cmp r9d, r8d\n  setg r10b\n  cmp r9d, r11d\n  setl dl\n  test r10b, dl\n  cmovne rax, rcx\n  cmovne r11d, r9d\n  inc rcx\n  cmp rsi, rcx\n  jne .loop\n  ret\n.empty:\n  mov rax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214496,"user_id":881,"body":"section .text\nglobal least_larger\n\n; ssize_t least_larger(const int *array, size_t n, size_t index)\nleast_larger:\n    mov rax, -1\n    mov rcx, -1\n    mov r10d, [rdi + rdx * 4]\n    xor r11d, r11d\n.for_each_value:\n    inc rcx\n    cmp rcx, rsi\n    jae .end_each_value\n    mov r9d, [rdi + rcx * 4]\n    sub r9d, r10d\n    jle .for_each_value\n    test r11d, r11d\n    jz .found_candidate\n    cmp r9d, r11d\n    jg .for_each_value\n.found_candidate:\n    mov r11d, r9d\n    mov rax, rcx\n    jmp .for_each_value\n.end_each_value:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5fb856190d5230001d48d721":[{"id":214497,"user_id":168,"body":"global pentagonal\n\n; <-- RAX pentagonal(RDI n) -->\npentagonal:\n    mov rax, rdi\n    imul rax, rax\n    sub rax, rdi\n    lea rax, [5 * rax + 2]\n    shr rax, 1\n    mov rdx, -1\n    cmp rdi, 1\n    cmovl rax, rdx\n    ret\n; -----> endof pentagonal <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214498,"user_id":null,"body":"global pentagonal\n\n; <-- RAX pentagonal(RDI n) -->\npentagonal:\n  test rdi, rdi\n  jle .invalid\n  lea rax, [rdi + 4*rdi]\n  add rax, -5\n  imul rax, rdi\n  shr rax, 1\n  inc rax\n  ret\n.invalid:\n  mov rax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214499,"user_id":null,"body":"global pentagonal\npentagonal:\n  mov rax,-1\n  dec rdi\n  js @f\n    mov rax,rdi\n    mul rax\n    sub rax,rdi\n    shr rax,1\n    add rax,rdi\n    lea rax,[rax*4+rax]\n    inc rax\n  @f:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214500,"user_id":527,"body":"global pentagonal\n\n; long long pentagonal(long long n)\npentagonal:\n                test    rdi, rdi\n                jle     .invalid\n                lea     rax, [5 * (rdi - 1)]\n                imul    rax, rdi\n                shr     rax, 1\n                inc     rax\n                ret\n.invalid:       mov     rax, -1\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214501,"user_id":50,"body":"global pentagonal\n\n; <-- RAX pentagonal(RDI n) -->\npentagonal:\n    cmp rdi,1\n    jl _retMinusOne\n    mov rax,rdi\n    imul rax, 5\n    dec rdi\n    imul rdi\n    shr rax,1\n    inc rax\n    ret\n_retMinusOne:\n    mov rax, -1     ; RAX <- the result\n    ret\n; -----> endof pentagonal <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214502,"user_id":null,"body":"global pentagonal\n\n; <-- RAX pentagonal(RDI n) -->\npentagonal:\n    mov rax, -1     ; setting the result to minus one\n    cmp rdi, 1      ; whether <n> is less than one\n    jl .exit        ; then, jumping to exit\n    mov rax, 5      ; setting RAX to five\n    mul rdi         ; multiplying by <n>\n    dec rdi         ; decrementing <n>\n    mul rdi         ; multiplying <5*n> by <n-1>\n    add rax, 2      ; adding two to the result\n    shr rax, 1      ; dividing the result by two\n.exit:\n    ret\n; -----> endof pentagonal <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"600fd9143eed6f0013361d55":[{"id":214503,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\n    cmp rdi, rsi\n    jb .lo\n    cmp rdi, rdx\n    ja .hi\n    mov rax, rdi\n    ret\n.lo mov rax, rsi\n    ret\n.hi mov rax, rdx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214504,"user_id":null,"body":"section .text\nglobal clamp\n\n; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\nclamp:\n  mov rax, rdi\n  cmp rax, rsi\n  cmovb rax, rsi\n  cmp rax, rdx\n  cmova rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214505,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\n\n\ncmp rdi, rsi\njae Label\nmov rax, rsi\nret\n\n\nLabel:\ncmp rdi, rdx\njbe Label2\nmov rax, rdx\nret\n\n\nLabel2:\nmov rax, rdi\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214506,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\ncheckbelow:\n  cmp rdi, rsi\n  ja checkabove\nclampbelow:\n  mov rax, rsi\n  ret\ncheckabove:\n  cmp rdx, rdi\n  ja noclamp\nclampabove:\n  mov rax, rdx\n  ret\nnoclamp:\n  mov rax, rdi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214507,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\nxor rax, rax\ncmp rdi, rsi\njbe lowend\ncmp rdi, rdx\njae hiend\nmov rax, rdi\nret\nlowend:\nmov rax, rsi\nret\nhiend:\nmov rax, rdx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214508,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\ncmp rdi, rsi\nja a_g_lo\nmov rax, rsi\nret\na_g_lo:\ncmp rdi, rdx\nja a_g_hi\nmov rax, rdi\nret\na_g_hi:\nmov rax, rdx\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214509,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\n  cmp rdi, rsi\n  jb retrs ; jb: unsigned less than\n  cmp rdx, rdi\n  jb retrd\n  mov rax, rdi\n  ret\n  retrs:\n  mov rax, rsi\n  ret\n  retrd:\n  mov rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214510,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\n  cmp rdi, rsi\n  cmovb rdi, rsi\n  \n  cmp rdi, rdx\n  cmova rdi, rdx\n  \n  mov rax, rdi\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214511,"user_id":null,"body":"section .text\nglobal clamp\nclamp:            ; uint64_t clamp(uint64_t a, uint64_t lo, uint64_t hi)\n  mov rax,rdi\n  cmp rdi,rsi\n  jb retLo\n  cmp rdx,rdi\n  jb retHi\n  mov rax, rdi\n  jmp ende\nretLo:\n  mov rax, rsi\n  jmp ende\nretHi:\n  mov rax,rdx\n  jmp ende\nretA:\n   mov rax,rdi\nende:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214512,"user_id":104,"body":"; 2022 nomennescio\nsection .text\nglobal clamp\nclamp:            ; uint64_t clamp (uint64_t a, uint64_t lo, uint64_t hi) rdi, rsi, rdx\n    mov rax, rdi\n    cmp rsi, rdi\n    cmova rax, rsi\n    cmp rdi, rdx\n    cmova rax, rdx\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"60576b180aef19001bce494d":[{"id":214513,"user_id":null,"body":"global count_checkerboard\n\nsection .text\n\n; unsigned long long count_checkerboard (unsigned long long width, unsigned long long height, unsigned long long resolution)\n; rdi := width\n; rsi := height\n; rdx := resolution\ncount_checkerboard:\n  mov rcx, rdx\n  lea r10, [rdx + rdx]\n  mov rax, rsi\n  xor edx, edx\n  mov r9, rsi\n  xor r11d, r11d\n  div r10\n  mov rsi, rdx\n  mov r8, rax\n  mov rax, rdi\n  imul r8, rcx\n  sub rsi, rcx\n  cmovb rsi, r11\n  xor edx, edx\n  div r10\n  add rsi, r8\n  sub rdx, rcx\n  cmovb rdx, r11\n  sub r9, rsi\n  imul rax, rcx\n  add rax, rdx\n  sub rdi, rax\n  imul r9, rax\n  imul rdi, rsi\n  lea rax, [rdi + r9]\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214514,"user_id":527,"body":"global count_checkerboard\n\nsection .text\n\n; unsigned long long count_checkerboard(unsigned long long width, unsigned long long height, unsigned long long resolution)\ncount_checkerboard:\n                mov     rcx, rdx\n                xor     edx, edx\n                mov     rax, rdi\n                div     rcx\n                shr     rax, 1\n                cmovc   rdx, rcx\n                imul    rax, rcx\n                lea     r8, [rax + rdx]\n                xor     edx, edx\n                mov     rax, rsi\n                div     rcx\n                shr     rax, 1\n                cmovc   rdx, rcx\n                imul    rax, rcx\n                add     rax, rdx\n                sub     rdi, r8\n                sub     rsi, rax\n                imul    rax, rdi\n                imul    rsi, r8\n                add     rax, rsi\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214515,"user_id":50,"body":"global count_checkerboard\n\nsection .text\n\n                ; unsigned long long count_checkerboard (unsigned long long width, unsigned long long height, unsigned long long resolution)\n                ; rdi := w\n                ; rsi := h\n                ; rdx := r (r8)\ncount_checkerboard:\n  mov r8,rdx ; save r to r8\n  mov r9,rdx ; r9 = r\n  shl r9,1 ; r9 = r * 2\n  mov rax,rdi ; rax = w\n  xor rdx,rdx\n  div r9 ; rax = w \/ (2 * r)\n  mul r8 ; rax = r * (w \/ (2 * r))\n  mov r9,rax ; r9 = x\n  shl r9,1 ; r9 = 2 * x\n  add r9,r8 ; r9 = 2 * x + r\n  cmp rdi,r9\n  jbe _skip ; if w <= 2 * x + r\n  add rax,rdi ; else rax += w\n  sub rax,r9 ; rax -= 2 * x + r\n_skip:\n  mov r10,rax ; save x to r10\n  mov r9,r8 ; r9 = r\n  shl r9,1 ; r9 = 2 * r\n  mov rax,rsi ; rax = h\n  xor rdx,rdx\n  div r9 ; rax = h \/ (2 * r)\n  mul r8 ; rax = r * (h \/ (2 * r)) (a)\n  mov r9,rax ; r9 = a\n  shl r9,1 ; r9 = 2 * a\n  add r9,r8 ; r9 = 2 * a + r\n  cmp rsi,r9\n  jbe _finish ; if h <= 2 * a + r\n  add rax,rsi ; else rax += h\n  sub rax,r9 ; rax -= 2 * a + r\n_finish:\n  mov r11,rax ; save a to r11\n  sub rdi,r10 ; w -= x\n  mul rdi ; rax = (w - x) * a\n  mov r9,rax ; r9 = (w - x) * a\n  sub rsi,r11 ; h -= a\n  mov rax,r10 ; rax = x\n  mul rsi ; rax = x * (h - a)\n  add rax,r9 ; rax = x * (h - a) + (w - x) * a\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214516,"user_id":168,"body":"global count_checkerboard\n\nsection .text\n\n; unsigned long long count_checkerboard (unsigned long long width, unsigned long long height, unsigned long long resolution)\n; rdi := width\n; rsi := height\n; rdx := resolution\ncount_checkerboard:\n  lea r8, [rdx + rdx]\n  mov rcx, rdx\n\n  mov rax, rdi\n  xor edx, edx\n  div r8\n  cmp rdx, rcx\n  cmova rdx, rcx\n  imul rax, rcx\n  lea r9, [rax + rdx]\n  \n  xor edx, edx\n  mov rax, rsi\n  div r8\n  cmp rdx, rcx\n  cmova rdx, rcx\n  imul rax, rcx\n  add rax, rdx\n  \n  sub rsi, rax\n  sub rdi, r9\n  imul r9, rsi\n  imul rax, rdi\n  add rax, r9 \n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214517,"user_id":50,"body":"global count_checkerboard\n\nsection .text\n\n                ; unsigned long long count_checkerboard (unsigned long long width, unsigned long long height, unsigned long long resolution)\n                ; rdi := w\n                ; rsi := h\n                ; rdx := r (r8)\ncount_checkerboard:\n  mov r8,rdx ; save r to r8\n  mov r9,rdx ; r9 = r\n  shl r9,1 ; r9 = r * 2\n  mov rax,rdi ; rax = w\n  xor rdx,rdx\n  div r9 ; rax = w \/ (2 * r)\n  mul r8 ; rax = r * (w \/ (2 * r))\n  mov r9,rax ; r9 = x\n  shl r9,1 ; r9 = 2 * x\n  add r9,r8 ; r9 = 2 * x + r\n  cmp rdi,r9\n  jbe _skip ; if w <= 2 * x + r\n  add rax,rdi ; else rax += w\n  sub rax,r9 ; rax -= 2 * x + r\n_skip:\n  mov r14,rax ; save x to r14\n  mov r9,r8 ; r9 = r\n  shl r9,1 ; r9 = 2 * r\n  mov rax,rsi ; rax = h\n  xor rdx,rdx\n  div r9 ; rax = h \/ (2 * r)\n  mul r8 ; rax = r * (h \/ (2 * r)) (a)\n  mov r9,rax ; r9 = a\n  shl r9,1 ; r9 = 2 * a\n  add r9,r8 ; r9 = 2 * a + r\n  cmp rsi,r9\n  jbe _finish ; if h <= 2 * a + r\n  add rax,rsi ; else rax += h\n  sub rax,r9 ; rax -= 2 * a + r\n_finish:\n  mov r15,rax ; save a to r15\n  sub rdi,r14 ; w -= x\n  mul rdi ; rax = (w - x) * a\n  mov r9,rax ; r9 = (w - x) * a\n  sub rsi,r15 ; h -= a\n  mov rax,r14 ; rax = x\n  mul rsi ; rax = x * (h - a)\n  add rax,r9 ; rax = x * (h - a) + (w - x) * a\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"605ae9e1d2be8a0023b494ed":[{"id":214518,"user_id":null,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor eax, eax\n  xor ecx, ecx\n  xor edx, edx\n.loop:\n  movzx esi, byte [rdi]\n  cmp esi, 60\n  je .left\n  cmp esi, 62\n  je .right\n  test esi, esi\n  jne .nextchar\n  jmp .done\n.left:\n  inc eax\n  jmp .nextchar\n.right:\n  inc ecx\n  sub edx, eax\n.nextchar:\n  inc rdi\n  jmp .loop\n.done:\n  imul eax, ecx\n  add eax, edx\n  add eax, eax\n  cdqe\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214519,"user_id":null,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor eax, eax\n  xor ecx, ecx\n  xor esi, esi\n  \n.loop1:\n  mov dl, [rdi]\n  inc rdi\n  cmp dl, '>'\n  sete sil\n  add rcx, rsi\n  cmp dl, '<'\n  jne .skip\n  add rax, rcx\n.skip:\n  test dl, dl\n  jnz .loop1\n\n  add rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214520,"user_id":null,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor     rax, rax\n  xor     rcx, rcx  ; > counter\n  mov     r8,   1\n  .loop:\n  xor     r9,  r9\n  xor     rdx,   rdx\n  cmp     [rdi], byte '>'\n  cmove   rdx,   r8\n  add     rcx,   rdx\n  cmp     [rdi], byte '<'\n  cmove   r9,    rcx\n  shl     r9,    1\n  add     rax,   r9\n  inc     rdi\n  cmp     [rdi], byte 0\n  jne     .loop\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214521,"user_id":50,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor rax, rax\n  xor rbx,rbx\n_loop:\n  cmp byte[rdi],0\n  je _exit\n  cmp byte[rdi],62\n  je _inca\n  cmp byte[rdi],60\n  je _incb\n  inc rdi\n  jmp _loop\n_incb:\n  add rax,rbx\n  inc rdi\n  jmp _loop\n_inca:\n  inc rbx\n  inc rdi\n  jmp _loop\n_exit:\n  shl rax,1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214522,"user_id":null,"body":"section .text\nglobal countSalutes\nend:\n  ret\nnext:\n  add rcx, 2\nstart:\n  mov dl, [rdi]\n  inc rdi\n  test dl, dl\n  jz end\n  cmp dl, \">\"\n  je next\n  cmp dl, \"<\"\n  jne start\n  add rax, rcx\n  jmp start\ncountSalutes:\n  xor rax, rax\n  xor rcx, rcx\n  jmp start\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214523,"user_id":null,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor eax, eax\n  mov rcx, -1\n  xor edx, edx\n  xor r8d, r8d\n  .loop:\n    inc rcx\n    mov r8b, [rdi+rcx]\n    cmp r8, '>'\n    je .right\n    cmp r8, '<'\n    je .left\n    test r8, r8\n    jnz .loop\n    jmp .break\n    .right:\n      add rdx, 2\n      jmp .loop\n    .left:\n      add rax, rdx\n      jmp .loop\n  .break:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214524,"user_id":null,"body":"global countSalutes\ncountSalutes:\n  xor rcx,rcx\n  xor rax,rax\n  @b:movzx r8,byte[rdi]\n     mov   r9,r8\n     and   r8,2\n     add   rcx,r8\n     cmp   r9b,'<'\n     jne @f\n       add rax,rcx\n     @f:\n     inc   rdi\n     cmp   byte[rdi],0\n  jne @b\nret\n\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214525,"user_id":null,"body":"section .text\nglobal countSalutes\n\ncountSalutes:   xor rax, rax\n                xor rcx, rcx\n@main_loop:     cmp byte [rdi], 0\n                je  @cooked\n                cmp byte [rdi], '>'\n                jne @check_next\n                inc rcx\n                jmp @loop_tail\n@check_next:    cmp byte [rdi], '<'\n                jne @loop_tail\n                add rax, rcx\n@loop_tail:     inc rdi\n                jmp @main_loop\n@cooked:        shl rax,1\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214526,"user_id":168,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor eax, eax\n  xor esi, esi\n.loop:\n  movzx edx, byte [rdi]\n  xor ecx, ecx\n  cmp dl, '<'\n  cmove rcx, rsi\n  lea rax, [rax + rcx]\n  mov ecx, 0\n  seta cl\n  add rsi, rcx\n  inc rdi\n  test edx, edx\n  jnz .loop\n  add rax, rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214527,"user_id":76,"body":"section .text\nglobal countSalutes\n\n; size_t countSalutes(char *hallway)\ncountSalutes:\n  xor rax, rax\n  xor rbx, rbx ; right arrows\n  xor rdx, rdx ; salutes\n.loop:\n  mov al, byte[rdi]\n  cmp al, 0\n  jz .done\n  cmp al, '>'\n  je .right\n  cmp al, '<'\n  je .left\n.continue:\n  inc rdi\n  jmp .loop\n.left:\n  mov rcx, rbx\n  sal rcx, 1\n  add rdx, rcx\n  jmp .continue\n.right:\n  inc rbx\n  jmp .continue\n.done:\n  mov rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"6076d4edc7bf5d0041b31dcf":[{"id":214528,"user_id":168,"body":"segment .text\nglobal sort_bytes\nextern qsort\n\ncmp_bytes:\n  movzx eax, byte [rdi]\n  movzx edx, byte [rsi]\n  sub eax, edx\n  ret\n\nsort_bytes:\n  push rdi\n  mov rdi, rsp\n  mov esi, 4\n  mov edx, 1\n  mov rcx, cmp_bytes\n  call qsort\n  pop rax\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214529,"user_id":3088,"body":"; The argument is passed in EDI\n; Return your answer in EAX\nsegment .text\nglobal sort_bytes\n\nsort_bytes:\n  xor edx, edx\n  mov eax, edi    ; ah, al contains two bytes\n  shr edi, 16\n  mov edx, edi    ; dh, dl contains two other bytes\n  \n  ; Now we sort ah, al, dh, dl in decreasing order\n  cmp  ah, al\n  jae  .s1\n  xchg ah, al\n.s1:                ; Now ah, al are sorted\n  cmp dh, dl\n  jae .s2\n  xchg dh, dl\n.s2:                ; [ah, al] and [dh, dl] are in order\n  cmp ah, dh\n  jae .s3\n  xchg ah, dh\n.s3                ; ah contains max\n  cmp al, dl\n  jae .s4\n  xchg al, dl\n.s4:                ; dl contains min\n  cmp al, dh\n  jae .s5\n  xchg al, dh\n.s5                ; now everything is in order. Let's put it together\n  shl eax, 16\n  or  eax, edx\n\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214530,"user_id":527,"body":"segment .text\nglobal sort_bytes\n\nsort_bytes:\n                mov     eax, edi\n                movzx   edx, ah\n                movd    xmm0, edx\n                bswap   eax\n                and     edi, 0ffh\n                movd    xmm1, edi\n                movzx   ecx, ah\n                movd    xmm2, ecx\n                and     eax, 0ffh\n                movd    xmm3, eax\n                vpminub xmm4, xmm0, xmm1\n                vpmaxub xmm5, xmm0, xmm1\n                vpminub xmm6, xmm2, xmm3\n                vpmaxub xmm7, xmm2, xmm3\n                vpminub xmm0, xmm4, xmm6\n                vpmaxub xmm1, xmm4, xmm6\n                vpminub xmm2, xmm5, xmm7\n                vpmaxub xmm3, xmm5, xmm7\n                vpminub xmm4, xmm1, xmm2\n                vpmaxub xmm5, xmm1, xmm2\n                movd    edi, xmm3\n                movd    eax, xmm0\n                movd    ecx, xmm4\n                movd    edx, xmm5\n                bswap   edi\n                or      eax, edi\n                mov     ah, cl\n                shl     edx, 16\n                or      eax, edx\n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214531,"user_id":null,"body":"extern qsort\nsegment .text\nglobal sort_bytes\n\ncmp:\n  movzx eax, byte [rdi]\n  movzx ecx, byte [rsi]\n  sub eax, ecx\n  ret\n\nsort_bytes:\n  push rax\n  mov dword [rsp + 4], edi\n  lea rcx, [cmp]\n  lea rdi, [rsp + 4]\n  mov esi, 4\n  mov edx, 1\n  call qsort\n  mov eax, [rsp + 4]\n  pop rcx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214532,"user_id":null,"body":"%macro compare_and_swap 2\n  cmp %1, %2\n  jae %%skip\n  xchg %1, %2\n%%skip:\n%endmacro\n\n; The argument is passed in EDI\n; Return your answer in EAX\nsegment .text\nglobal sort_bytes\n\nsort_bytes:\n  mov ecx, edi\n  mov edx, edi\n  shr edx, 16\n\n  ; ch >= cl >= dh >= dl\n  compare_and_swap ch, cl\n  compare_and_swap cl, dh\n  compare_and_swap dh, dl\n  compare_and_swap ch, cl\n  compare_and_swap cl, dh\n  compare_and_swap ch, cl\n  \n  mov eax, ecx\n  shl eax, 16\n  mov ax, dx\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214533,"user_id":null,"body":"segment .text\nglobal sort_bytes\n\nsort_bytes:\n;\n; The number given as input is made of four bytes placed in edi\n; Reorder these bytes so that the resulting (unsigned 32 bit) integer\n; is as large as possible.\n;\n; The sorting network implemented\n; see: https:\/\/en.wikipedia.org\/wiki\/Sorting_network\n;\n; rdi bytes are distributed to r8w - r11w, sorted by sorting network\n; and placed back to eax\n;\n \nSECTION .text\nglobal i4_func_i4\n \ni4_func_i4:\n \n                xor         rdx,     rdx\n                xor         rax,     rax\n \n; place ecx bytes to r8w-r11w\n \n                xor         r8w,    r8w\n                mov         r8b,    dil\n                shr         edi,    8\n                xor         r9w,    r9w\n                mov         r9b,    dil\n                xor         r10w,   r10w\n                shr         edi,    8\n                mov         r10b,   dil\n                xor         r11w,   r11w\n                shr         edi,    8\n                mov         r11b,   dil\n \n; sorting network on r8w-r11w registers\n \n                mov         ax,     r10w\n                mov         dx,     r8w\n                cmp         r10w,   r8w\n                cmovbe      r10w,   dx\n                cmovbe      r8w,    ax              ; a,c\n \n                mov         ax,     r11w\n                mov         dx,     r9w\n                cmp         r11w,   r9w\n                cmovbe      r11w,   dx\n                cmovbe      r9w,    ax              ; b,d\n \n                mov         ax,     r9w\n                mov         dx,     r8w\n                cmp         r9w,    r8w\n                cmovbe      r9w,    dx\n                cmovbe      r8w,    ax              ; a,b\n \n                mov         ax,     r11w\n                mov         dx,     r10w\n                cmp         r11w,   r10w\n                cmovbe      r11w,   dx\n                cmovbe      r10w,   ax              ; c,d\n \n                mov         ax,     r10w\n                mov         dx,     r9w\n                cmp         r10w,   r9w\n                cmovbe      r10w,   dx\n                cmovbe      r9w,    ax              ; b,c\n \n; place sorted bytes to eax\n \n                mov         al,     r11b\n                shl         eax,    8\n                mov         al,     r10b\n                shl         eax,    8\n                mov         al,     r9b\n                shl         eax,    8\n                mov         al,     r8b\n \n                ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214534,"user_id":881,"body":"; The argument is passed in EDI\n; Return your answer in EAX\nsegment .text\nglobal sort_bytes\n\nsort_bytes:\n    mov eax, edi\n    mov ecx, edi\n    shr ecx, 16\n    cmp ah, al\n    jae .a\n    xor ah, al\n    xor al, ah\n    xor ah, al\n.a:\n    cmp ch, cl\n    jae .b\n    xor ch, cl\n    xor cl, ch\n    xor ch, cl\n.b:\n    cmp al, ch\n    jae .c\n    xor al, ch\n    xor ch, al\n    xor al, ch\n.c:\n    cmp ah, al\n    jae .d\n    xor ah, al\n    xor al, ah\n    xor ah, al\n.d:\n    cmp ch, cl\n    jae .e\n    xor ch, cl\n    xor cl, ch\n    xor ch, cl\n.e:\n    cmp al, ch\n    jae .f\n    xor al, ch\n    xor ch, al\n    xor al, ch\n.f:\n    shl eax, 16\n    or eax, ecx\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214535,"user_id":null,"body":"segment .text\nglobal sort_bytes\n\nsort_bytes:\n  xor rax, rax\n  xor rdx, rdx\n  mov ax, di\n  shr edi, 16\n  mov dx, di\n  mov ecx, 3\n.loop:\n.dl:\n  cmp dl, dh\n  jbe .dh\n  xchg dl, dh\n.dh:\n  cmp dh, al\n  jbe .al\n  xchg dh, al\n.al:\n  cmp al, ah\n  jbe .next\n  xchg al, ah\n.next:\n  loopnz .loop\n  shl rax, 16\n  add rax, rdx\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214536,"user_id":50,"body":"; The argument is passed in EDI\n; Return your answer in EAX\nsegment .text\nglobal sort_bytes\n\nsort_bytes:\n  xor r8,r8 ; a\n  xor r9,r9 ; b\n  xor r10,r10 ; c\n  xor r11,r11 ; d\n  xor r12,r12 ; d\n  mov r14,256\n  xor rax,rax\n  mov rax,rdi\n  mov r8b,al\n  xor rdx,rdx\n  idiv r14\n  mov r9b,al\n  xor rdx,rdx\n  idiv r14\n  mov r10b,al\n  xor rdx,rdx\n  idiv r14\n  mov r11b,al\n  cmp r8,r9\n  jl _swapAB\n  jmp _sort1\n_swapAB:\n  mov r12,r8\n  mov r8,r9\n  mov r9,r12\n_sort1:\n  cmp r10,r11\n  jl _swapCD1\n  jmp _sort2\n_swapCD1:\n  mov r12,r10\n  mov r10,r11\n  mov r11,r12\n_sort2:\n  cmp r8,r10\n  jl _swapAC\n  jmp _sort3\n_swapAC:\n  mov r12,r8\n  mov r8,r10\n  mov r10,r12\n_sort3:\n  cmp r9,r10\n  jl _swapBC\n  jmp _sort4\n_swapBC:\n  mov r12,r9\n  mov r9,r10\n  mov r10,r12\n_sort4:\n  cmp r10,r11\n  jl _swapCD2\n  jmp _sort5\n_swapCD2:\n  mov r12,r10\n  mov r10,r11\n  mov r11,r12\n_sort5:\n  cmp r9,r10\n  jl _swapBC2\n  jmp _finalRound\n_swapBC2:\n  mov r12,r9\n  mov r9,r10\n  mov r10,r12\n_finalRound:\n  mov rax,r8\n  imul r14\n  add rax,r9\n  imul r14\n  add rax,r10\n  imul r14\n  add rax,r11\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214537,"user_id":null,"body":"segment .text\nglobal sort_bytes\nsort_bytes:\n  mov rcx, 4\ninitloop:\n    mov [bytes+rcx-1], dil\n    shr edi, 8\n  loop initloop\n  \n  mov rcx, 4\norderloop:\n    xor edx, edx\n    innerloop:\n      mov ax, word [bytes+edx]\n      cmp al, ah\n      jae skip\n        mov [bytes+edx], ah \n        mov [bytes+edx+1], al\n    skip:\n      inc edx\n      cmp edx, 2\n      jng innerloop\n  loop orderloop\n  \n    mov rcx, 4\nuninitloop:\n    mov al, [bytes+rcx-1]\n    ror eax, 8\n  loop uninitloop\n  ret\n\nsection .bss\nbytes resb 4","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"61123a6f2446320021db987d":[{"id":214538,"user_id":null,"body":"global prev_mult_of_three\nsection .text\nprev_mult_of_three:\n  mov rcx,3\n  mov rbx,10\n  loop1:\n  mov rdx,0\n  mov rax,rdi\n  div rcx\n  cmp rdx,0\n  mov rax,rdi\n  je end\n  loop2:\n  mov rdx,0\n  div rbx\n  mov rdi,rax\n  cmp rdi,3\n  jg loop1\n  je end\n  mov rax,-1\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214539,"user_id":null,"body":"global prev_mult_of_three\n\nsection .text\n\n; EDI = n, EAX = return \nprev_mult_of_three:\n  mov r8, -1\n  mov rsi, 3\n  mov rcx, 10\n.loop:\n  test edi, edi\n  je .notfound\n  mov eax, edi\n  cdq\n  idiv esi\n  test edx, edx\n  je .found\n  mov eax, edi\n  cdq\n  idiv ecx\n  mov edi, eax\n  jmp .loop\n.found:\n  mov r8d, edi\n.notfound:\n  mov eax, r8d\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214540,"user_id":null,"body":"global prev_mult_of_three\n\nsection .text\n\n; EDI = n, EAX = return \nprev_mult_of_three:\n    xor   rbx, rbx\n    xor   rax, rax\n    .loop:\n    xor   edx, edx\n    mov   eax, edi\n    mov   ebx, 3\n    div   ebx\n    cmp   edx, 0\n    je    .end\n    xor   edx, edx\n    mov   eax, edi\n    mov   ebx, 10\n    div   ebx\n    mov   edi, eax\n    cmp   edi, 0\n    jne   .loop\n    mov   eax, -1\n    ret\n    .end:\n    mov   eax, edi\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214541,"user_id":null,"body":"global prev_mult_of_three\n\nsection .text\n\n; EDI = n, EAX = return \nprev_mult_of_three:\n  mov esi, 3\n  mov ecx, 10\n  mov eax, edi\n  \n.loop:\n  xor edx, edx\n  div esi\n  test edx, edx\n  jz .done\n  mov eax, edi\n  xor edx, edx\n  div ecx\n  test eax, eax\n  jz .quit\n  mov edi, eax\n  jmp .loop  \n\n.done:\n  mov eax, edi\n  ret\n.quit:\n  mov eax, -1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214542,"user_id":null,"body":"global prev_mult_of_three\n\nsection .text\n\n;EDI = n, EAX = return \nprev_mult_of_three:\n    mov r8d, 3\n    mov ecx, 10\nloop:\n    xor edx, edx\n    mov eax, edi\n    div r8d\n    cmp edx, 0\n    jz return\n    xor edx, edx\n    mov eax, edi\n    div ecx\n    mov edi, eax\n    jmp loop\n    \nreturn:\n    cmp edi, 0\n    jg true\n    mov eax, -1\n    ret\ntrue:\n    mov eax, edi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214543,"user_id":168,"body":"global prev_mult_of_three\n\nsection .text\n\n; RDI = n, RAX = return \nprev_mult_of_three:\n    mov ecx, 10\n    mov esi, 3\n.loop:\n    mov rax, rdi\n    xor edx, edx\n    div rsi\n    test edx, edx\n    jz .end\n    mov rax, rdi\n    xor edx, edx\n    div rcx\n    mov rdi, rax\n    jmp .loop\n.end:\n    mov rax, -1\n    test rdi, rdi\n    cmovnz rax, rdi\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"619f200fd0ff91000eaf4a08":[{"id":214544,"user_id":168,"body":"global oddoreven\n\n%define EVEN    0\n%define ODD     1\n%define EITHER  2\n  \n; <-- EAX oddoreven(EDI n) -->\noddoreven:\n    mov eax, edi\n    mov edx, 2\n    and eax, 3\n    shr eax, 1\n    cmovc eax, edx\n    ret\n; -----> endof oddoreven <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214545,"user_id":527,"body":"global oddoreven\n\n; int oddoreven(unsigned n)\noddoreven:      and     edi, 3\n                movzx   eax, byte [.results + rdi]\n                ret\n.results        db 0, 2, 1, 2","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214546,"user_id":149,"body":"global oddoreven\n\n%define EVEN    0\n%define ODD     1\n%define EITHER  2\n  \noddoreven:\n  mov eax, 2\n  test edi, 1\n  jne r\n  mov eax, edi\n  and eax, 2\n  shr eax, 1\nr:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214547,"user_id":null,"body":"global oddoreven\n\n%define EVEN    0\n%define ODD     1\n%define EITHER  2\n\n; <-- EAX oddoreven(EDI n) -->\noddoreven:\n    mov eax, 2          ; setting EAX to EITHER\n    test edi, 1         ; whether <n> is EITHER\n    jne .exit           ; then jumping to exit\n    shr edi, 1          ; dividing <n> by two\n    and edi, 1          ; whether <n> is ODD\n    setne al            ; then setting the result to ODD, otherwise, to EVEN\n.exit:\n    ret\n; -----> endof oddoreven <-----","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214548,"user_id":null,"body":"global oddoreven\n\n%define EVEN    0\n%define ODD     1\n%define EITHER  2\n\noddoreven:\n    mov eax, edi\n    and eax, 3\n    test eax, eax\n    je .even\n    and edi, 1\n    test edi, edi\n    je .odd\n    mov eax, EITHER\n    jmp .exit\n.odd:\n    mov eax, ODD\n    jmp .exit\n.even:\n    mov eax, EVEN\n.exit:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214549,"user_id":null,"body":"global oddoreven\nresult dd 2,1,0\noddoreven:\n  bts edi,2\n  bsf eax,edi\n  mov eax,[result+eax*4]\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214550,"user_id":null,"body":"global oddoreven\noddoreven:\n  mov rax,2\n  bt edi,0\n  jc end\n  dec rax\n  bt edi,1\n  jc end\n  dec rax\n  end:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214551,"user_id":null,"body":"global oddoreven\n\noddoreven:\n  xor eax, eax\n  and edi, 3\n  setne al\n  and edi, 1\n  add eax, edi\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214552,"user_id":null,"body":"global oddoreven\n%define EVEN    0\n%define ODD     1\n%define EITHER  2\noddoreven:\n  mov eax, edi\n  and eax, 1\n  jz el\n  shl eax, 1\n  ret\nel mov eax, edi\n  shr eax, 1\n  and eax, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214553,"user_id":null,"body":"global oddoreven\n\n%define EVEN    0\n%define ODD     1\n%define EITHER  2\n  \n; <-- EAX oddoreven(EDI n) -->\nsection .code\n\noddoreven:\n  lea rax, [data]\n  and edi, 3\n  mov eax, [rax+rdi*4]\n  ret\n; -----> endof oddoreven <-----\n\nsection .rodata\ndata: dd EVEN, EITHER, ODD, EITHER","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"628e3ee2e1daf90030239e8a":[{"id":214554,"user_id":168,"body":"global interlockable\n\nsection .text\n      \ninterlockable:\n  and rdi, rsi\n  setz al\n  ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214555,"user_id":527,"body":"global interlockable\n\nsection .text\n      \n; bool interlockable(unsigned long long a, unsigned long long b)\ninterlockable:\n                test    rdi, rsi\n                setz    al\n                ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214556,"user_id":null,"body":"global interlockable\nsection .text\ninterlockable:          \n  test rdi, rsi\n  setz al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214557,"user_id":null,"body":"global interlockable\n\nsection .text\n      \ninterlockable:\n  test rsi, rdi\n  sete al\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214558,"user_id":null,"body":";  bool interlockable(unsigned long long a, unsigned long long b)\n;  rdi  :=  a\n;  rsi  :=  b\n\n\nglobal interlockable\n\nsection .text\n      \ninterlockable:\n    xor al, al  ; store result in al\n    and rdi, rsi\n    cmp rdi, 0\n    jne end\n    mov al, 1\n  end:\n    ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214559,"user_id":null,"body":"section .text\nglobal interlockable\n      \ninterlockable:\n    and rdi, rsi\n    setz al\n    ret\n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214560,"user_id":null,"body":"section .text\nglobal interlockable\n      \ninterlockable:\n    mov al, 1       \n    and rdi, rsi\n    cmp rdi, 0\n    jg _not\n    ret\n\n_not:\n  dec al\n  ret\n    ","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214561,"user_id":null,"body":"global interlockable\nsection .text\ninterlockable:          \n  test rdi, rsi\n  je i\n  mov al, 0     \n  ret\ni mov al, 1\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214562,"user_id":null,"body":"global interlockable\nsection .text     \ninterlockable:\n  xor  rax,rax\n  and  rsi,rdi\n  setz al\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214563,"user_id":null,"body":"global interlockable\n\nsection .text\n      \ninterlockable:          ; bool interlockable(unsigned long long a, unsigned long long b)\n                       ; a := rdi\n                       ; b := rsi\n    xor   eax, eax\n    and   rdi, rsi\n    jnz   false\n    mov   eax, 1\nfalse:\n    ret\n;<--    end of interlockable -->","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"62a611067274990047f431a8":[{"id":214564,"user_id":null,"body":"section .text\nglobal alternate\n\nalternate:\nxor eax, eax\n\n.loop:\ntest rdi, rdi\njz .exit\nmov [rcx + 4*rax], esi\nxchg esi, edx\ninc rax\ndec rdi\njmp .loop\n\n.exit:\nret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214565,"user_id":null,"body":"section .text\nglobal alternate\n\n; void alternate(size_t length, int first_value, int second_value, int array[length])\n; length -> rdi, first_value -> esi, second_value -> edx, array -> rcx\nalternate:\n    xor rbx, rbx  ; counter\n\n.loop\n    mov dword [rcx+4*rbx], esi\n    \n    mov eax, esi\n    mov esi, edx\n    mov edx, eax\n\n    inc rbx\n    cmp rbx, rdi\n    jl .loop\n\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214566,"user_id":null,"body":"section .text\nglobal alternate\nalternate:\n  jmp @f\n  @b:mov  [rcx],esi\n     xchg esi,edx\n     add  rcx,4\n  @f:dec  rdi\n  jns @b\nret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214567,"user_id":168,"body":"section .text\nglobal alternate\n\n; void alternate(size_t length, int first_value, int second_value, int array[length])\n; length -> rdi, first_value -> esi, second_value -> edx, array -> rcx\nloop_:\n  mov eax, esi\n  test edi, 1\n  cmovnz eax, edx\n  mov dword [rcx + 4 * rdi], eax\nalternate:\n  dec rdi\n  jns loop_\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214568,"user_id":null,"body":"section .text\nglobal alternate\n\n; void alternate(size_t length, int first_value, int second_value, int array[length])\n; length -> rdi, first_value -> esi, second_value -> edx, array -> rcx\nalternate:\n  xor r8d, r8d\n.loop:\n  cmp rdi, r8\n  je .done\n  test r8b, 1\n  mov eax, edx\n  cmove eax, esi\n  mov [rcx + 4*r8], eax\n  inc r8\n  jmp .loop\n.done:\n  ret","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":214569,"user_id":881,"body":"section .text\nglobal alternate\n\n; void alternate(size_t length, int first_value, int second_value, int array[length])\n; length -> rdi, first_value -> esi, second_value -> edx, array -> rcx\nalternate:\n    test rcx, rcx\n    jz .end\n    test rdi, rdi\n    jz .end\n.for_each:\n    mov [rcx], esi\n    add rcx, 4\n    dec rdi\n    jz .end\n    mov [rcx], edx\n    add rcx, 4\n    dec rdi\n    jnz .for_each\n.end:\n    ret\n","lang_id":32,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}]}