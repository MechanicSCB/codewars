{"50654ddff44f800200000004":[{"id":1,"user_id":527,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply a b = a * b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":2,"user_id":232,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply = _*_\n\n-- set multiply fn to *.\n-- The two underscore serve same purpose as () in Haskell (Note : to self)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":3,"user_id":489,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply a = a *_","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":4,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply a b = _*_ a b\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":5,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 -> \u2115 -> \u2115\nmultiply a b = a * b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":6,"user_id":522,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat public renaming (_*_ to multiply)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":7,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply = _*_","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":8,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply a b = a _*_ b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":9,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : \u2115 \u2192 \u2115 \u2192 \u2115\nmultiply a b = a * b\n--multiply = _*_\n--multiply a b = _*_ a b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":10,"user_id":1277,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\n\nmultiply : (a : \u2115) -> (b : \u2115) \u2192 \u2115\nmultiply a b = a * b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c36e827348b3e15a56edcbf":[{"id":11,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne a-b a-\u22a5-b = dne (\u03bb x \u2192 x (a-\u22a5-b (\u03bb z \u2192 x (a-b z))))\n\nto : AxiomPEM -> AxiomDNE\nto pem {a} a-\u22a5-\u22a5 = pem {a} {a} (\u03bb x \u2192 x) \u03bb x \u2192 \u22a5-elim (a-\u22a5-\u22a5 x)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":12,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\nopen import Data.Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Relation.Nullary using (\u00ac_)\nopen import Function using (_\u2218\u2032_)\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nem : AxiomPEM \u2192 \u2200{a : Set} \u2192 a \u228e (\u00ac a)\nem pem = pem inj\u2081 inj\u2082\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\ncontr : \u2200{a b : Set} \u2192 (a \u2192 b) \u2192 (\u00ac b \u2192 \u00ac a)\ncontr i \u00acb a = \u00acb (i a)\n\nundne : \u2200{a : Set} \u2192 a \u2192 \u00ac \u00ac a\nundne x = \u03bb \u00acx \u2192 \u00acx x\n\nuncontr : AxiomDNE \u2192 \u2200{a b : Set} \u2192 (\u00ac b \u2192 \u00ac a) \u2192 (a \u2192 b)\nuncontr dne ci = dne \u2218\u2032 contr ci \u2218\u2032 undne \n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne {a = a} {b = b} i1 = uncontr dne (\u03bb \u00acb i2 \u2192 \u00acb (i2 (contr i1 \u00acb)))\n\nto : AxiomPEM -> AxiomDNE\nto pem {a = a} with em pem {a = a}\n... | inj\u2081  x = \u03bb _ \u2192 x\n... | inj\u2082 \u00acx = \u03bb \u00ac\u00acx \u2192 \u22a5-elim (\u00ac\u00acx \u00acx)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":13,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne a\u2192b a\u2192\u22a5\u2192b = dne (\u03bb b\u2192\u22a5 \u2192 b\u2192\u22a5 (a\u2192\u22a5\u2192b (\u03bb a \u2192 b\u2192\u22a5 (a\u2192b a))))\n\nto : AxiomPEM -> AxiomDNE\nto pem a\u2192\u22a5\u2192\u22a5 = pem (\u03bb b \u2192 b) (\u03bb a\u2192\u22a5 \u2192 \u22a5-elim (a\u2192\u22a5\u2192\u22a5 a\u2192\u22a5))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":14,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne a\u2192b \u00aca\u2192b = dne \u03bb \u00acb \u2192 \u00acb (a\u2192b (dne \u03bb \u00aca \u2192 \u00acb (\u00aca\u2192b \u00aca)))\n\nto : AxiomPEM -> AxiomDNE\nto pem \u00ac\u00aca = pem (\u03bb a \u2192 a) (\u03bb \u00aca \u2192 \u22a5-elim (\u00ac\u00aca \u00aca))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":15,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom DNE h h' = DNE \u03bb x \u2192 x (h' (\u03bb x\u2081 \u2192 x (h x\u2081)))\n\nto : AxiomPEM -> AxiomDNE\nto PEM h = PEM (\u03bb a' \u2192 a') \u03bb h' \u2192 \u22a5-elim (h h')","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":16,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\nopen import Function using (id; _\u2218_)\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} \u2192 (a \u2192 b) \u2192 ((a \u2192 \u22a5) \u2192 b) \u2192 b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} \u2192 ((a \u2192 \u22a5) \u2192 \u22a5) \u2192 a\n\nfrom : AxiomDNE \u2192 AxiomPEM\nfrom = \u03bb z y x \u2192 z (\u03bb s \u2192 s (x (\u03bb t \u2192 s (y t))))\n\nto : AxiomPEM \u2192 AxiomDNE\nto x f = x id (\u03bb abs \u2192 \u22a5-elim (f abs))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":17,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\n\u00ac\u00acpem : {a b : Set0} -> (((a -> b) -> ((a -> \u22a5) -> b) -> b) -> \u22a5) -> \u22a5\n\u00ac\u00acpem \u00acpem = \u00acpem \\ a->b [a->\u22a5]->b -> [a->\u22a5]->b \\ a -> \u00acpem (\\ a->b [a->\u22a5]->b -> a->b a)\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne = dne \u00ac\u00acpem\n\nto : AxiomPEM -> AxiomDNE\nto pem \u00ac\u00aca = pem (\\ a -> a) (\\ \u00aca -> \u22a5-elim (\u00ac\u00aca \u00aca))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":18,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty using (\u22a5; \u22a5-elim)\nopen import Function using (id; _\u2218_)\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom adne a\u2192b a\u2192\u22a5\u2192b = adne \u03bb b\u2192\u22a5 \u2192 (b\u2192\u22a5 \u2218 a\u2192\u22a5\u2192b) (b\u2192\u22a5 \u2218 a\u2192b)\n\nto : AxiomPEM -> AxiomDNE\nto apem dneg = apem id \u03bb a\u2192\u22a5 \u2192 \u22a5-elim (dneg a\u2192\u22a5)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":19,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\nopen import Data.Sum\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne a2b na2b with dne (\u03bb k \u2192 k (inj\u2082 (\u03bb x \u2192 k (inj\u2081 x))))\n...                          | inj\u2081 a = a2b a\n...                          | inj\u2082 na = na2b na\n\nto : AxiomPEM -> AxiomDNE\nto pem nna = pem (\u03bb a \u2192 a) (\u03bb na \u2192 \u22a5-elim (nna na))\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":20,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule DndPem where\n\nopen import Data.Empty\n\n\nAxiomPEM : Set1\nAxiomPEM = {a b : Set0} -> (a -> b) -> ((a -> \u22a5) -> b) -> b\n\nAxiomDNE : Set1\nAxiomDNE = {a : Set0} -> ((a -> \u22a5) -> \u22a5) -> a\n\nfrom : AxiomDNE -> AxiomPEM\nfrom dne = \u03bb f x\u2081 \u2192 dne \u03bb g \u2192 g (x\u2081 \u03bb x \u2192 g (f x))\n\nto : AxiomPEM -> AxiomDNE\nto pem x = pem (\u03bb x\u2081 \u2192 x\u2081) \u03bb x\u2081 \u2192 \u22a5-elim (x x\u2081)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c7fdf0b00718714fd002bd2":[{"id":21,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.List.Properties\nopen import Rev\n\n{-\nWhat you've just imported:\n\n-- With this definition, Agda deduces better\nrev : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nrev [] = []\nrev (x \u2237 xs) = rev xs ++ x \u2237 [] \n-}\n\nrevconcat : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 (b : List A) \u2192 rev (a ++ b) \u2261 rev b ++ rev a\nrevconcat [] lt rewrite ++-identity\u02b3 (rev lt) = refl\nrevconcat (x \u2237 xs) lt rewrite revconcat xs lt \n                            | ++-assoc (rev lt) (rev xs) (x \u2237 [])= refl\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 []) = refl\nrevrevid (x \u2237 xs) rewrite (revconcat (rev xs) (x \u2237 [])) \n                        | (revrevid xs) = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":22,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Rev\n\n{-\nWhat you've just imported:\n\n-- With this definition, Agda deduces better\nrev : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nrev [] = []\nrev (x \u2237 xs) = rev xs ++ x \u2237 [] \n-}\n\n\n++-assoc : \u2200 {l} {A : Set l} (a b c : List A) \u2192 (a ++ b) ++ c \u2261 a ++ b ++ c\n++-assoc []       ys zs = refl\n++-assoc (x \u2237 xs) ys zs = cong (x \u2237_) (++-assoc xs ys zs)\n\n++-identity\u02b3 : \u2200 {l} {A : Set l} (a : List A) \u2192 a ++ [] \u2261 a\n++-identity\u02b3 []       = refl\n++-identity\u02b3 (x \u2237 xs) = cong (x \u2237_) (++-identity\u02b3 xs)\n\n\nlemma : \u2200 {l} {A : Set l} (a b : List A) \u2192 rev (a ++ b) \u2261 rev b ++ rev a\nlemma [] [] = refl\nlemma [] (x \u2237 b) rewrite ++-identity\u02b3 (rev b ++ x \u2237 []) = refl\nlemma (x \u2237 a) [] rewrite ++-identity\u02b3 a = refl\nlemma (a \u2237 as) (b \u2237 bs) rewrite lemma as (b \u2237 bs) | ++-assoc (rev bs ++ b \u2237 []) (rev as) (a \u2237 [])= refl\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 a) rewrite lemma (rev a) (x \u2237 []) = cong (\u03bb n \u2192 x \u2237 n) (revrevid a)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":23,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Rev\n\nopen \u2261-Reasoning\n\n{-\nWhat you've just imported:\n\n-- With this definition, Agda deduces better\nrev : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nrev [] = []\nrev (x \u2237 xs) = rev xs ++ x \u2237 [] \n-}\n\nr-id : \u2200 {\u2113} {A : Set \u2113} (xs : List A) \u2192 xs ++ [] \u2261 xs\nr-id [] = refl\nr-id (x \u2237 xs) = cong (x \u2237_) (r-id xs)\n\n++-assoc : \u2200 {\u2113} {A : Set \u2113} (xs ys zs : List A) \u2192 (xs ++ ys) ++ zs \u2261 xs ++ (ys ++ zs)\n++-assoc [] ys zs = refl\n++-assoc (x \u2237 xs) ys zs = cong (x \u2237_) (++-assoc xs ys zs)\n\nrev-distrib : \u2200 {\u2113} {A : Set \u2113} (xs ys : List A) \u2192 rev (xs ++ ys) \u2261 rev ys ++ rev xs\nrev-distrib [] ys = sym (r-id (rev ys))\nrev-distrib (x \u2237 xs) ys = begin\n                            rev ((x \u2237 xs) ++ ys)\n                          \u2261\u27e8 (cong (_++ (x \u2237 [])) (rev-distrib xs ys)) \u27e9\n                            ((rev ys) ++ (rev xs)) ++ (x \u2237 [])\n                          \u2261\u27e8 (++-assoc (rev ys) (rev xs) (x \u2237 [])) \u27e9\n                            rev ys ++ rev (x \u2237 xs)\n                          \u220e\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 xs) = begin\n                      rev (rev (x \u2237 xs))\n                    \u2261\u27e8 (rev-distrib (rev xs) (x \u2237 [])) \u27e9\n                      rev (x \u2237 []) ++ rev (rev xs)\n                    \u2261\u27e8 (cong ((x \u2237 []) ++_) (revrevid xs)) \u27e9\n                      x \u2237 xs\n                    \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":24,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Rev\nopen import Data.List.Properties using (++-assoc)\n\nopen \u2261-Reasoning\n\nrev-concat-nil : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 a ++ [] \u2261 a\nrev-concat-nil [] = refl\nrev-concat-nil (x \u2237 a) = begin\n    (x \u2237 a) ++ []\n  \u2261\u27e8 cong (\u03bb l \u2192 x \u2237 l) (rev-concat-nil a) \u27e9\n    x \u2237 a\n  \u220e\n\nrev-concat : \u2200 {\u2113} {A : Set \u2113} (a b : List A) \u2192 rev (a ++ b) \u2261 (rev b) ++ (rev a)\nrev-concat [] b = sym (rev-concat-nil (rev b))\nrev-concat (x \u2237 a) b = begin\n    rev (a ++ b) ++ x \u2237 []\n  \u2261\u27e8 cong (\u03bb l \u2192 l ++ x \u2237 []) (rev-concat a b) \u27e9\n    (rev b ++ rev a) ++ x \u2237 []\n  \u2261\u27e8 ++-assoc (rev b) (rev a) (x \u2237 []) \u27e9\n    rev b ++ rev a ++ x \u2237 []\n  \u220e\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 a) = begin\n    rev (rev a ++ x \u2237 [])\n  \u2261\u27e8 rev-concat (rev a) (x \u2237 []) \u27e9\n    rev (x \u2237 []) ++ rev (rev a)\n  \u2261\u27e8 refl \u27e9\n    (x \u2237 []) ++ rev (rev a)\n  \u2261\u27e8 cong (_\u2237_ x) (revrevid a) \u27e9\n    (x \u2237 []) ++ a\n  \u2261\u27e8 refl \u27e9\n    x \u2237 a\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":25,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Data.List\nopen import Data.List.Properties using (++-identity\u02b3; ++-assoc)\n\nopen import Rev\n\nrevrev-lemma : \u2200 {\u2113} {A : Set \u2113} (xs ys : List A) \u2192 rev (xs ++ ys) \u2261 rev ys ++ rev xs\nrevrev-lemma []       ys = sym (++-identity\u02b3 (rev ys))\nrevrev-lemma (x \u2237 xs) ys = begin\n  rev ((x \u2237 xs) ++ ys)         \u2261\u27e8\u27e9\n  rev (xs ++ ys) ++ x \u2237 []     \u2261\u27e8 cong (_++ x \u2237 []) (revrev-lemma xs ys) \u27e9\n  (rev ys ++ rev xs) ++ x \u2237 [] \u2261\u27e8 ++-assoc (rev ys) (rev xs) (x \u2237 []) \u27e9\n  rev ys ++ rev xs ++ x \u2237 []   \u220e\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid []       = refl\nrevrevid (a \u2237 as) = begin\n  rev (rev (a \u2237 as))           \u2261\u27e8\u27e9\n  rev (rev as ++ a \u2237 [])       \u2261\u27e8 revrev-lemma (rev as) (a \u2237 []) \u27e9\n  rev (a \u2237 []) ++ rev (rev as) \u2261\u27e8\u27e9\n  a \u2237 rev (rev as)             \u2261\u27e8 cong (a \u2237_) (revrevid as) \u27e9\n  a \u2237 as \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":26,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Rev\n\nopen \u2261-Reasoning\n\n++[] : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 a \u2261 a ++ []\n++[] []      = refl\n++[] (x \u2237 a) = cong (x \u2237_) (++[] a)\n\n++-assoc : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 (a ++ b) ++ c \u2261 a ++ b ++ c\n++-assoc []      b c = refl\n++-assoc (x \u2237 a) b c = cong (x \u2237_) (++-assoc a b c)\n\nrev++ : \u2200 {\u2113} {A : Set \u2113} (a b : List A) \u2192 rev (a ++ b) \u2261 rev b ++ rev a\nrev++ []      b = ++[] (rev b)\nrev++ (x \u2237 a) b = begin\n  rev (a ++ b) ++ x \u2237 []     \u2261\u27e8 cong (_++ x \u2237 []) (rev++ a b) \u27e9\n  (rev b ++ rev a) ++ x \u2237 [] \u2261\u27e8 ++-assoc (rev b) (rev a) (x \u2237 []) \u27e9\n  rev b ++ rev a ++ x \u2237 [] \u220e\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid []      = refl\nrevrevid (x \u2237 a) = begin\n  rev (rev a ++ x \u2237 []) \u2261\u27e8 rev++ (rev a) (x \u2237 []) \u27e9\n  x \u2237 rev (rev a)       \u2261\u27e8 cong (x \u2237_) (revrevid a) \u27e9\n  x \u2237 a \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":27,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Rev\n\n{-\nWhat you've just imported:\n\n-- With this definition, Agda deduces better\nrev : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nrev [] = []\nrev (x \u2237 xs) = rev xs ++ x \u2237 [] \n-}\n\n\nlem : \u2200 {a} {T : Set a} l (x : T) \u2192 rev (l ++ x \u2237 []) \u2261 x \u2237 (rev l)\nlem [] _ = refl\nlem (x \u2237 l) _ = cong (_++ x \u2237 []) (lem l _)\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 l) rewrite lem (rev l) x = cong (x \u2237_) (revrevid l)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":28,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; refl; cong; sym)\nopen Eq.\u2261-Reasoning\nopen import Data.List\nopen import Rev\n\n{-\nWhat you've just imported:\n\n-- With this definition, Agda deduces better\nrev : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nrev [] = []\nrev (x \u2237 xs) = rev xs ++ x \u2237 [] \n-}\n\n++-identity : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 a ++ [] \u2261 a\n++-identity [] = refl\n++-identity (x \u2237 xs) = cong (x \u2237_) (++-identity xs)\n\n++-assoc : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 (a ++ b) ++ c \u2261 a ++ (b ++ c)\n++-assoc [] ys zs = refl\n++-assoc (x \u2237 xs) ys zs = cong (x \u2237_) (++-assoc xs ys zs)\n\nrev-distrib : \u2200 {\u2113} {A : Set \u2113} (a b : List A) \u2192 rev (a ++ b) \u2261 rev b ++ rev a\nrev-distrib [] ys = sym (++-identity (rev ys))\nrev-distrib (x \u2237 xs) ys =\n  begin\n    rev ((x \u2237 xs) ++ ys)\n  \u2261\u27e8\u27e9\n    rev (x \u2237 (xs ++ ys))\n  \u2261\u27e8\u27e9\n    rev (xs ++ ys) ++ [ x ]\n  \u2261\u27e8 cong (_++ [ x ]) (rev-distrib xs ys) \u27e9\n    (rev ys ++ rev xs) ++ [ x ]\n  \u2261\u27e8 ++-assoc (rev ys) (rev xs) [ x ] \u27e9\n    rev ys ++ rev (x \u2237 xs)\n  \u220e\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 xs) =\n  begin\n    rev (rev (x \u2237 xs))\n  \u2261\u27e8\u27e9\n    rev (rev xs ++ [ x ])\n  \u2261\u27e8 rev-distrib (rev xs) [ x ] \u27e9\n    x \u2237 rev (rev xs)\n  \u2261\u27e8 cong (x \u2237_) (revrevid xs) \u27e9\n    x \u2237 xs\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":29,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Rev\nopen \u2261-Reasoning\n\nnilcomm : \u2200 {\u2113} {A : Set \u2113} (a : List A) -> a \u2261 a ++ []\nnilcomm [] = refl\nnilcomm (x \u2237 xs) = begin\n  x \u2237 xs\n  \u2261\u27e8 cong (x \u2237_) (nilcomm xs) \u27e9\n  x \u2237 (xs ++ [])\n  \u2261\u27e8\u27e9\n  x \u2237 xs ++ []\n  \u220e\n\n++-assoc : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 (b : List A) \u2192 (c : List A) \u2192 (a ++ b) ++ c \u2261 a ++ b ++ c\n++-assoc [] b c = refl\n++-assoc (x \u2237 xs) b c = begin\n  ((x \u2237 xs) ++ b) ++ c\n  \u2261\u27e8\u27e9\n  (x \u2237 (xs ++ b)) ++ c\n  \u2261\u27e8\u27e9\n  x \u2237 (xs ++ b) ++ c\n  \u2261\u27e8 cong (x \u2237_) (++-assoc xs b c) \u27e9\n  x \u2237 xs ++ b ++ c\n  \u220e\n\nrevflip : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 (b : List A) -> rev (a ++ b) \u2261 rev b ++ rev a\nrevflip [] ys = begin\n  rev ([] ++ ys)\n  \u2261\u27e8\u27e9\n  rev ys\n  \u2261\u27e8 nilcomm (rev ys) \u27e9\n  rev ys ++ []\n  \u220e\nrevflip (x \u2237 xs) ys = begin\n  rev ((x \u2237 xs) ++ ys)\n  \u2261\u27e8\u27e9\n  rev (x \u2237 (xs ++ ys))\n  \u2261\u27e8\u27e9\n  rev (xs ++ ys) ++ x \u2237 []\n  \u2261\u27e8 cong (_++(x \u2237 [])) (revflip xs ys) \u27e9\n  (rev ys ++ rev xs) ++ x \u2237 []\n  \u2261\u27e8 ++-assoc (rev ys) (rev xs) (x \u2237 []) \u27e9\n  rev ys ++ (rev xs ++ x \u2237 [])\n  \u2261\u27e8\u27e9\n  rev ys ++ rev (x \u2237 xs)\n  \u220e\n\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 xs) = begin\n  rev (rev (x \u2237 xs))\n  \u2261\u27e8\u27e9\n  rev (rev xs ++ x \u2237 [])\n  \u2261\u27e8 revflip (rev xs) (x \u2237 []) \u27e9\n  rev (x \u2237 []) ++ rev (rev xs)\n  \u2261\u27e8\u27e9\n  x \u2237 [] ++ rev (rev xs)\n  \u2261\u27e8 cong ((x \u2237 []) ++_) (revrevid xs) \u27e9\n  x \u2237 [] ++ xs\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":30,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule RevRev where\n\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; refl; cong)\nopen Eq.\u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\nopen import Data.List\nopen import Rev\n\n{-\nWhat you've just imported:\n\n-- With this definition, Agda deduces better\nrev : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nrev [] = []\nrev (x \u2237 xs) = rev xs ++ x \u2237 [] \n-}\n\nrevrevid : \u2200 {\u2113} {A : Set \u2113} (a : List A) \u2192 rev (rev a) \u2261 a\nrevrevid [] = refl\nrevrevid (x \u2237 xs) = begin\n  rev (rev (x \u2237 xs))\n    \u2261\u27e8\u27e9\n  rev (rev xs ++ [ x ])\n    \u2261\u27e8 rev-distr (rev xs) [ x ] \u27e9\n  rev [ x ] ++ rev (rev xs)\n    \u2261\u27e8\u27e9\n  x \u2237 rev (rev xs)\n    \u2261\u27e8 cong (x \u2237_) (revrevid xs) \u27e9\n  x \u2237 xs \u220e\n  where\n  ++-right-id : \u2200 {\u2113} {A : Set \u2113} (xs : List A) \u2192 (xs ++ []) \u2261 xs\n  ++-right-id [] = refl\n  ++-right-id (x \u2237 xs) rewrite ++-right-id xs = refl\n\n  ++-assoc : \u2200 {\u2113} {A : Set \u2113} (xs ys zs : List A) \u2192 (xs ++ ys) ++ zs \u2261 xs ++ (ys ++ zs)\n  ++-assoc [] ys zs = refl\n  ++-assoc (x \u2237 xs) ys zs rewrite ++-assoc xs ys zs = refl\n\n  rev-distr : \u2200 {\u2113} {A : Set \u2113} (xs ys : List A) \u2192 rev (xs ++ ys) \u2261 rev ys ++ rev xs\n  rev-distr [] ys rewrite ++-right-id (rev ys) = refl\n  rev-distr (x \u2237 xs) ys = begin\n    rev ((x \u2237 xs) ++ ys)\n      \u2261\u27e8\u27e9\n    rev (x \u2237 (xs ++ ys))\n      \u2261\u27e8\u27e9\n    rev (xs ++ ys) ++ [ x ]\n      \u2261\u27e8 cong (_++ [ x ]) (rev-distr xs ys) \u27e9\n    (rev ys ++ rev xs) ++ [ x ]\n      \u2261\u27e8 ++-assoc (rev ys) (rev xs) [ x ] \u27e9\n    rev ys ++ (rev xs ++ [ x ])\n      \u2261\u27e8\u27e9\n    rev ys ++ rev (x \u2237 xs) \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c85201e20f73f08df4216b1":[{"id":31,"user_id":489,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\ndata Tree (A : Set) : Set where\n  leaf : A \u2192 Tree A\n  branch : A \u2192 Tree A \u2192 Tree A \u2192 Tree A\n\nflipTree : {A : Set} \u2192 Tree A \u2192 Tree A\nflipTree (leaf x) = leaf x\nflipTree (branch x l r) = branch x (flipTree r) (flipTree l)\n-}\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) rewrite sym (flipTreeSym r) | sym (flipTreeSym l) = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":32,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) = cong\u2082 (branch x) (flipTreeSym l) (flipTreeSym r)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":33,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\ndata Tree (A : Set) : Set where\n  leaf : A \u2192 Tree A\n  branch : A \u2192 Tree A \u2192 Tree A \u2192 Tree A\n\nflipTree : {A : Set} \u2192 Tree A \u2192 Tree A\nflipTree (leaf x) = leaf x\nflipTree (branch x l r) = branch x (flipTree r) (flipTree l)\n-}\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf t) = refl\nflipTreeSym (branch t l r) = cong\u2082 (branch t) (flipTreeSym l) (flipTreeSym r)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":34,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\ndata Tree (A : Set) : Set where\n  leaf : A \u2192 Tree A\n  branch : A \u2192 Tree A \u2192 Tree A \u2192 Tree A\n\nflipTree : {A : Set} \u2192 Tree A \u2192 Tree A\nflipTree (leaf x) = leaf x\nflipTree (branch x l r) = branch x (flipTree r) (flipTree l)\n-}\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf _) = refl\nflipTreeSym (branch _ l r) = cong\u2082 (branch _) (flipTreeSym l) (flipTreeSym r)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":35,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\ndata Tree (A : Set) : Set where\n  leaf : A \u2192 Tree A\n  branch : A \u2192 Tree A \u2192 Tree A \u2192 Tree A\n\nflipTree : {A : Set} \u2192 Tree A \u2192 Tree A\nflipTree (leaf x) = leaf x\nflipTree (branch x l r) = branch x (flipTree r) (flipTree l)\n-}\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) = to-show\n  where\n  IH0 : l \u2261 flipTree (flipTree l)\n  IH0 = flipTreeSym l\n  IH1 : r \u2261 flipTree (flipTree r)\n  IH1 = flipTreeSym r\n  to-show : (branch x l r) \u2261 flipTree (flipTree (branch x l r))\n  to-show = cong\u2082 (branch x) IH0 IH1\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":36,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nflipTreeSym : \u2200 {A : Set} (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) rewrite sym (flipTreeSym l) | sym (flipTreeSym r) = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":37,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality as Eq\nopen Eq.\u2261-Reasoning\nopen import Preloaded\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) = begin\n  ((branch x) l) r\n  \u2261\u27e8 cong (branch x l) (flipTreeSym r) \u27e9\n  branch x l (flipTree (flipTree r))\n  \u2261\u27e8 cong (\u03bb { v \u2192 branch x v (flipTree (flipTree r)) }) (flipTreeSym l) \u27e9\n  branch x (flipTree (flipTree l)) (flipTree (flipTree r))\n  \u2261\u27e8\u27e9\n  flipTree (branch x (flipTree r) (flipTree l))\n  \u2261\u27e8\u27e9\n  flipTree (flipTree (branch x l r))\n  \u220e\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":38,"user_id":1507,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\ndata Tree (A : Set) : Set where\n  leaf : A \u2192 Tree A\n  branch : A \u2192 Tree A \u2192 Tree A \u2192 Tree A\n\nflipTree : {A : Set} \u2192 Tree A \u2192 Tree A\nflipTree (leaf x) = leaf x\nflipTree (branch x l r) = branch x (flipTree r) (flipTree l)\n-}\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) = cong\u2082 (branch x) (flipTreeSym l) (flipTreeSym r)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":39,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\ndata Tree (A : Set) : Set where\n  leaf : A \u2192 Tree A\n  branch : A \u2192 Tree A \u2192 Tree A \u2192 Tree A\n\nflipTree : {A : Set} \u2192 Tree A \u2192 Tree A\nflipTree (leaf x) = leaf x\nflipTree (branch x l r) = branch x (flipTree r) (flipTree l)\n-}\n\ncong\u2083 : \u2200 {A B C D : Set} (f : A \u2192 B \u2192 C \u2192 D) -- there's got to be a nicer way =_=\n          {a\u2081 a\u2082 : A} {b\u2081 b\u2082 : B} {c\u2081 c\u2082 : C}\n          \u2192 a\u2081 \u2261 a\u2082 \u2192 b\u2081 \u2261 b\u2082 \u2192 c\u2081 \u2261 c\u2082 \u2192 (f a\u2081 b\u2081 c\u2081) \u2261 (f a\u2082 b\u2082 c\u2082)\ncong\u2083 f refl refl refl = refl\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf _) = refl\nflipTreeSym (branch x l r) = cong\u2083 branch refl (flipTreeSym l) (flipTreeSym r)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":40,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule FlipTreeSym where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n-- just a binary function congruence\ncong\u2219 : {a b c : Set} \u2192 {x y : a} \u2192 {h j : b} \u2192 (_\u2219_ : a \u2192 b \u2192 c)\n      \u2192 x \u2261 y \u2192 h \u2261 j\n      \u2192 x \u2219 h \u2261 y \u2219 j\ncong\u2219 _ refl refl = refl\n\nflipTreeSym : {A : Set} \u2192 (t : Tree A) \u2192 t \u2261 flipTree (flipTree t)\nflipTreeSym (leaf x) = refl\nflipTreeSym (branch x l r) =\n      cong\u2219 (branch x) (flipTreeSym l) (flipTreeSym r)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8531a820089d04385a7faa":[{"id":41,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero zero _ = refl\ninvert (suc a) (suc b) eq rewrite +-comm a (suc a) | +-comm b (suc b) = cong suc (invert a b (cong pred (cong pred eq)))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":42,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Function.Base\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert a b p =\n  *-cancel\u02e1-\u2261 1 $ trans (cong (a +_) (+-identity\u02b3 a))\n                $ trans p\n                $ cong (b +_) (sym (+-identity\u02b3 b))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":43,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\n\nopen \u2261-Reasoning\n\nlemma : \u2200 n \u2192 \u230a n + n \/2\u230b \u2261 n\nlemma zero = refl\nlemma (suc n) rewrite +-suc n n | lemma n = refl\n\ninvert : \u2200 a b \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert a b a+a\u2261b+b =\n  begin\n    a\n  \u2261\u27e8 sym (lemma a) \u27e9\n    \u230a a + a \/2\u230b\n  \u2261\u27e8 cong ( \u03bb x \u2192 \u230a x \/2\u230b) a+a\u2261b+b \u27e9\n    \u230a b + b \/2\u230b\n  \u2261\u27e8 lemma b \u27e9\n    b\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":44,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero zero x = refl\ninvert (suc a) (suc b) x\n  with suc-injective x\n... | y rewrite +-comm a (suc a)\n              | +-comm b (suc b)\n   with suc-injective y\n... | z = cong suc (invert a b z)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":45,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\n\ninfix  3 _\u220e\ninfixr 2 step-\u2261\n\nstep-\u2261 : \u2200 {\u2113} {A : Set \u2113} (x {y z} : A) \u2192 y \u2261 z \u2192 x \u2261 y \u2192 x \u2261 z\nstep-\u2261 _ y\u2261z x\u2261y = trans x\u2261y y\u2261z\n\n_\u220e : \u2200 {\u2113} {A : Set \u2113} (x : A) \u2192 x \u2261 x\n_\u220e _ = refl\n\nsyntax step-\u2261  x y\u2261z x\u2261y = x \u2261\u27e8 x\u2261y \u27e9 y\u2261z\n\nsuc-injective : \u2200 {m n} \u2192 suc m \u2261 suc n \u2192 m \u2261 n\nsuc-injective refl = refl\n\n+-suc : \u2200 m n \u2192 m + suc n \u2261 suc (m + n)\n+-suc zero    n = refl\n+-suc (suc m) n = cong suc (+-suc m n)\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero zero x = refl\ninvert (suc a) (suc b) x = cong suc hyp\n  where\n  hyp = invert a b (suc-injective (suc-injective (\n    suc (suc (a + a)) \u2261\u27e8 cong suc (sym (+-suc a a)) \u27e9\n    suc (a + suc a)   \u2261\u27e8 x \u27e9\n    suc (b + suc b)   \u2261\u27e8 cong suc (+-suc b b) \u27e9\n    suc (suc (b + b)) \u220e)))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":46,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen \u2261-Reasoning\n\ndub : ( n : \u2115 ) -> n + n \u2261 2 * n\ndub n = begin\n  n + n\n  \u2261\u27e8\u27e9\n  (0 * n + n) + n\n  \u2261\u27e8 cong (_+ n) (+-comm (0 * n) n)\u27e9\n  1 * n + n\n  \u2261\u27e8 +-comm (1 * n) n \u27e9\n  2 * n\n  \u220e\n\nbud : ( n : \u2115 ) \u2192 2 * n \u2261 n + n\nbud n = begin\n  2 * n\n  \u2261\u27e8\u27e9\n  n + (n + 0)\n  \u2261\u27e8 cong (n +_ ) (+-comm n 0) \u27e9\n  n + n\n  \u220e\n\nhalf : \u2115 \u2192 \u2115\nhalf 0 = 0\nhalf 1 = 0\nhalf (suc (suc n)) = suc (half n)\n\ndubhalf : (n : \u2115) -> half (n + n) \u2261 n\ndubhalf zero = refl\ndubhalf (suc n) = begin\n  half (suc n + suc n)\n  \u2261\u27e8 cong half (cong suc (+-comm n (suc n))) \u27e9\n  half (suc (suc n + n))\n  \u2261\u27e8 cong suc (dubhalf n) \u27e9\n  suc n\n  \u220e\n\nhalfdub : (n : \u2115) \u2192 n \u2261 half (n + n)\nhalfdub zero = refl\nhalfdub (suc n) = begin\n  suc n\n  \u2261\u27e8 cong suc (halfdub n) \u27e9\n  half (suc (suc n + n))\n  \u2261\u27e8 cong half (cong suc (+-comm (suc n) n)) \u27e9\n  half (suc n + suc n)\n  \u220e\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert m n e = begin\n  m\n  \u2261\u27e8 halfdub m \u27e9\n  half (m + m)\n  \u2261\u27e8 cong half e \u27e9\n  half (n + n)\n  \u2261\u27e8 dubhalf n \u27e9\n  n\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":47,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Relation.Binary using (IsDecEquivalence; IsEquivalence)\nimport Data.Nat.Properties as \u2115p\nopen \u2261-Reasoning\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero zero p = refl\ninvert (suc a) (suc b) p = cong suc (invert a b (\u2115p.suc-injective (\u2115p.suc-injective a+2\u2261b+2)))\n  where\n    a+2\u2261b+2 : (suc (suc (a + a))) \u2261 (suc (suc (b + b)))\n    a+2\u2261b+2 =\n      begin\n        (suc (suc (a + a)))\n      \u2261\u02d8\u27e8 (\u2115p.+-suc (suc a) a) \u27e9\n        suc (a + suc a)\n      \u2261\u27e8 p \u27e9\n        suc (b + suc b)\n      \u2261\u27e8 \u2115p.+-suc (suc b) b \u27e9\n        suc (suc (b + b))\n      \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":48,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\n\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero zero p = refl\ninvert (suc a) (suc b) p rewrite +-suc a a | +-suc b b = \n    cong suc (invert a b (suc-injective (suc-injective p)))\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":49,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties \n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero = \u03bb b x \u2192 sym (i+j\u22610\u21d2i\u22610 b (sym x))\ninvert (suc a) zero = \u03bb x \u2192 i+j\u22610\u21d2i\u22610 (suc a) x\ninvert (suc a) (suc b) = \u03bb x \u2192 cong suc (invert a b (suc-injective \n    (suc-injective (subst\u2082 _\u2261_ (+-suc (suc a) a) (+-suc (suc b) b) x))))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":50,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Proof where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen Relation.Binary.PropositionalEquality.\u2261-Reasoning\n\nss : (a b : \u2115) \u2192 a + suc b \u2261 suc (a + b)\nss zero b = refl\nss (suc a) b = cong suc (ss a b)\n\nsss : (a : \u2115) \u2192 suc a + suc a \u2261 suc (suc (a + a))\nsss a = cong suc (ss a a)\n\npred\u2261 : (a b : \u2115) \u2192 a \u2261 b \u2192 pred a \u2261 pred b\npred\u2261 (suc a) (suc b) refl = refl\npred\u2261 zero zero _ = refl\n\nsseq2eq : (a b : \u2115) \u2192 suc (suc a) \u2261 suc (suc b) \u2192 a \u2261 b\nsseq2eq a b refl = refl\n\ninvert : (a b : \u2115) \u2192 a + a \u2261 b + b \u2192 a \u2261 b\ninvert zero zero refl = refl\ninvert (suc a) (suc b) what = cong suc\n    (invert a b (sseq2eq (a + a) (b + b) (ss\u2261ss what)))\n    where\n    ss\u2261ss : suc a + suc a \u2261 suc b + suc b\n        \u2192 suc (suc (a + a)) \u2261 suc (suc (b + b))\n    ss\u2261ss eq = begin\n        suc (suc (a + a))\n        \u2261\u27e8 sym (sss a) \u27e9\n        suc (a + suc a)\n        \u2261\u27e8 eq \u27e9\n        suc (b + suc b)\n        \u2261\u27e8 sss b \u27e9 refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c867173a2fc6d5263f4b4ea":[{"id":51,"user_id":489,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat a) = a\n  tail (repeat a) = repeat a\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  odd : \u2200 {A} -> Stream A -> Stream A\n  \n  head (even a) = head a\n  tail (even a) = odd (tail a)\n\n  odd a = even (tail a)\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a) = refl\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  oddEven a = refl\u2032 (odd a)\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a b) = head a\n  tail (merge a b) = merge b (tail a)\n\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-tail (moe a) = moe (tail a)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":52,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat x) = x\n  tail (repeat x) = repeat x\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a\n  tail (even a) = even (tail (tail a))\n\n  -- even (x :: y :: s) = x :: even s\n\n  odd : \u2200 {A} -> Stream A -> Stream A\n  head (odd a) = head (tail a)\n  tail (odd a) = odd (tail (tail a))\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a) = refl\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge xs ys) = head xs\n  head (tail (merge xs ys)) = head ys\n  tail (tail (merge xs ys)) = merge (tail xs) (tail ys)\n\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-head (refl-tail (moe a)) = refl\n  refl-tail (refl-tail (moe a)) = moe (tail (tail a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":53,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat a) = a\n  tail (repeat a) = repeat a\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a -- your turn\n  tail (even a) = even (tail (tail a))\n  \n  odd : \u2200 {A} -> Stream A -> Stream A\n  head (odd a) = head (tail a) -- your turn\n  tail (odd a) = odd (tail (tail a))\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 stream) = refl\n  refl-tail (refl\u2032 stream) = refl\u2032 (tail stream) -- your turn\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a _) = head a  -- your turn\n  tail (merge a b) = merge b (tail a)\n\n  \n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl -- your turn\n  refl-head (refl-tail (moe a)) = refl\n  refl-tail (refl-tail (moe a)) = moe (tail (tail a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":54,"user_id":29,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat x) = x\n  tail (repeat x) = repeat x\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a\n  tail (even a) = even (tail (tail a))\n\n  odd : \u2200 {A} -> Stream A -> Stream A\n  odd a = even (tail a)\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 x) = refl\n  refl-tail (refl\u2032 x) = refl\u2032 (tail x)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a b) = head a\n  tail (merge a b) = merge b (tail a)\n\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-tail (moe a) = moe (tail a)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":55,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat x) = x\n  tail (repeat x) = repeat x\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a\n  tail (even a) = even (tail (tail a))\n\n  odd : \u2200 {A} -> Stream A -> Stream A\n  head (odd a) = head (tail a)\n  tail (odd a) = odd (tail (tail a))\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a\u2081) = refl\n  refl-tail (refl\u2032 a\u2081) = refl\u2032 (tail a\u2081)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a _) = head a\n  head (tail (merge _ b)) = head b\n  tail (tail (merge a b)) = merge (tail a) (tail b)\n\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-head (refl-tail (moe a)) = refl\n  refl-tail (refl-tail (moe a)) = moe (tail (tail a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":56,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat a) = a -- your turn\n  tail (repeat a) = repeat a\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a -- your turn\n  tail (even a) = even (tail (tail a))\n  \n  odd : \u2200 {A} -> Stream A -> Stream A\n  odd a = even (tail a) -- your turn\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a) = refl -- your turn\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl -- your turn\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n  \nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a b) = head a -- your turn\n  head (tail (merge a b)) = head b\n  tail (tail (merge a b)) = merge (tail a) (tail b)\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-head (refl-tail (moe a)) = refl\n  refl-tail (refl-tail (moe a)) = moe (tail (tail a)) -- your turn","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":57,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  repeat {A} a = stream\n     where \n       stream : Stream A\n       head stream = a\n       tail stream = stream\n\n  -- Odd and Even, as you've implemented in:\n  -- https:\/\/www.codewars.com\/kata\/tear-me-apart-and-merge-the-pieces-together\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a\n  tail (even a) = even (tail (tail a))\n\n  odd : \u2200 {A} -> Stream A -> Stream A\n  head (odd a) = head (tail a)\n  tail (odd a) = odd (tail (tail a))\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a) = refl\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a b) = head a\n  tail (merge a b) = merge b (tail a)\n\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl \n  refl-tail (moe a) = record { refl-head = refl ; refl-tail = moe (tail (tail a)) }\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":58,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n\n-- Getting started:\nmodule Introduction where\n\n  -- Infinite sequence of `ones`.\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  -- Infinite sequence of give number\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat a) = a\n  tail (repeat a) = repeat a -- your turn\n\n  even : \u2200 {A} -> Stream A -> Stream A\n  head (even a) = head a\n  tail (even a) = even (tail (tail a))\n\n  odd : \u2200 {A} -> Stream A -> Stream A\n  head (odd a) = head (tail a) -- your turn\n  tail (odd a) = odd (tail (tail a))\n\nmodule Bisimulation where\n  open Introduction\n\n  -- Refl for bisimulation\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a) = refl\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = oddEven (tail (tail a))\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a b) = head a\n  tail (merge a b) = merge b (tail a)\n\n  -- Merge! Even! Odd!\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-head (refl-tail (moe a)) = refl\n  refl-tail (refl-tail (moe a)) = moe\u00a0(tail (tail a))\n  \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":59,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded:\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n\n-}\n\nmodule Introduction where\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  repeat : {A : Set} \u2192 A \u2192 Stream A\n  head (repeat a) = a\n  tail (repeat a) = repeat a\n\n  even : \u2200 {A} \u2192 Stream A \u2192 Stream A\n  head (even stream) = head stream\n  tail (even stream) = even (tail (tail stream))\n\n  odd : \u2200 {A} \u2192 Stream A \u2192 Stream A\n  odd stream = even (tail stream)\n\nmodule Bisimulation where\n  open Introduction\n\n  refl\u2032 : \u2200 {A} \u2192 (a : Stream A) \u2192 a == a\n  refl-head (refl\u2032 a) = refl\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} \u2192 (a : Stream A) \u2192 odd a == even (tail a)\n  refl-head (oddEven a) = refl\n  refl-tail (oddEven a) = refl\u2032 (odd (tail (tail a)))\n  \n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} \u2192 Stream A \u2192 Stream A \u2192 Stream A\n  head (merge a b) = head a\n  tail (merge a b) = merge b (tail a)\n  \n  moe : \u2200 {A} \u2192 (a : Stream A) \u2192 merge (even a) (odd a) == a\n  refl-head (moe a) = refl\n  refl-tail (moe a) = moe (tail a)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":60,"user_id":null,"body":"{-# OPTIONS --copattern --safe --no-sized-types --guardedness #-}\nmodule Copattern where\n\nopen import StreamDef\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\nopen import Function\n\nmodule Introduction where\n  ones : Stream \u2115\n  head ones = suc zero\n  tail ones = ones\n\n  repeat : {A : Set} -> A -> Stream A\n  head (repeat x) = x\n  tail (repeat x) = repeat x\n\n  even : \u2200 {A} -> Stream A -> Stream A\n  odd : \u2200 {A} -> Stream A -> Stream A\n\n  odd = even \u2218 tail\n  head (even a) = head a\n  tail (even a) = odd (tail a)\n\n\nmodule Bisimulation where\n  open Introduction\n\n  refl\u2032 : \u2200 {A} -> (a : Stream A) -> a == a\n  refl-head (refl\u2032 a) = refl\n  refl-tail (refl\u2032 a) = refl\u2032 (tail a)\n\n  oddEven : \u2200 {A} -> (a : Stream A) -> odd a == even (tail a)\n  oddEven a = refl\u2032 (odd a)\n\nmodule Merge where\n  open Bisimulation\n  open Introduction\n\n  merge : \u2200 {A} -> Stream A -> Stream A -> Stream A\n  head (merge a b) = head a\n  tail (merge a b) = merge b (tail a)\n\n  moe : \u2200 {A} -> (a : Stream A) -> (merge (even a) (odd a) == a)\n  refl-head (moe a) = refl\n  refl-head (refl-tail (moe a)) = refl\n  refl-tail (refl-tail (moe a)) = moe (tail (tail a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8689c6a2fc6d518df4b59c":[{"id":61,"user_id":106,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.List.Properties\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 a _ _ = ++-cancel\u02e1 a\n\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b _ = ++-cancel\u02b3 a b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":62,"user_id":490,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality using (refl; _\u2261_; sym)\nopen import Data.List\nopen import Data.List.Properties\nopen import Level\n-- you can import other functions from the stdlib here\n\nvariable\n  \u2113 : Level\n  A : Set \u2113\n\n++-injective\u02b3 : (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 [] b c p = p\n++-injective\u02b3 (x \u2237 a) b c p = ++-injective\u02b3 a b c (lemma a b c p)\n  where lemma : \u2200 {x} \u2192 (a b c : List A) \u2192 x \u2237 a ++ b \u2261 x \u2237 a ++ c \u2192 a ++ b \u2261 a ++ c\n        lemma [] b .b refl = refl\n        lemma (x \u2237 a) b c p rewrite \u2237-injective\u02b3 p = refl\n\n-- pretty hard\n-- try to use cong to convert to an eazier problem\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b [] p rewrite ++-identity\u02b3 a | ++-identity\u02b3 b = p\n++-injective\u02e1 a b (x \u2237 c) p\n  rewrite sym (++-assoc a [ x ] c)\n        | sym (++-assoc b [ x ] c)\n        = \u2237\u02b3-injective\u02e1 a b (++-injective\u02e1 (a \u2237\u02b3 x) (b \u2237\u02b3 x) c p)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":63,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\n-- you can import other functions from the stdlib here\n\nopen import Data.List.Properties\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 [] b c h = h\n++-injective\u02b3 (x \u2237 a) b c h = ++-injective\u02b3 a b c (\u2237-injective\u02b3 h)\n\n-- pretty hard\n-- try to use cong to convert to an eazier problem\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b c h = ++-cancel\u02b3 a b h","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":64,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.Maybe.Properties\nopen import Data.Empty\nopen import Level\n\nopen \u2261-Reasoning\n\nprivate variable\n  \u2113 : Level\n  A : Set \u2113\n\n++-injective\u02b3 : (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 []      b c p = p\n++-injective\u02b3 (x \u2237 a) b c p = ++-injective\u02b3 a b c (just-injective (cong tail p))\n\n++-right-id : (a : List A) \u2192 a ++ [] \u2261 a\n++-right-id []      = refl\n++-right-id (x \u2237 a) = cong (x \u2237_) (++-right-id a)\n\n\u2237\u2262[] : (x : A) (xs : List A) \u2192 x \u2237 xs \u2261 [] \u2192 \u22a5\n\u2237\u2262[] x xs ()\n\n++[x]-injective : (a b : List A) (x : A) \u2192 a ++ x \u2237 [] \u2261 b ++ x \u2237 [] \u2192 a \u2261 b\n++[x]-injective []           [] x p = refl\n++[x]-injective []  (x \u2237 [])    y p = \u22a5-elim (\u2237\u2262[] y [] (sym (just-injective (cong tail p))))\n++[x]-injective []  (x \u2237 y \u2237 b) z p = \u22a5-elim (\u2237\u2262[] y (b ++ z \u2237 []) (sym (just-injective (cong tail p))))\n++[x]-injective (x \u2237 [])     [] y p = \u22a5-elim (\u2237\u2262[] y [] (just-injective (cong tail p)))\n++[x]-injective (x \u2237 y \u2237 a)  [] z p = \u22a5-elim (\u2237\u2262[] y (a ++ z \u2237 []) (just-injective (cong tail p)))\n++[x]-injective (x \u2237 a) (y \u2237 b) z p = begin\n  x \u2237 a \u2261\u27e8 cong (_\u2237 a) (just-injective (cong head p)) \u27e9\n  y \u2237 a \u2261\u27e8 cong (y \u2237_) (++[x]-injective a b z (just-injective (cong tail p))) \u27e9\n  y \u2237 b \u220e\n\nlemma : (a b : List A) (x : A) \u2192 a ++ (x \u2237 b) \u2261 (a ++ x \u2237 []) ++ b\nlemma [] b x = refl\nlemma (z \u2237 a) b x = cong (z \u2237_) (lemma a b x)\n\n++-injective\u02e1 : (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b [] p      = trans (sym (++-right-id a)) (trans p (++-right-id b))\n++-injective\u02e1 a b (x \u2237 c) p = ++[x]-injective a b x (++-injective\u02e1 (a ++ x \u2237 []) (b ++ x \u2237 []) c (trans (sym (lemma a c x)) (trans p (lemma b c x))))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":65,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.List using (List; []; _\u2237_; _++_; length)\nopen import Data.List.Properties using (length-++; \u2237-injective)\nopen import Data.Nat using (\u2115; zero; suc; _\u2238_)\nopen import Data.Nat.Properties using (0\u22621+n; 1+n\u22620; +-suc; +-cancel\u02b3-\u2261)\nopen import Data.Product using (_,_)\nopen import Relation.Binary.PropositionalEquality using (_\u2261_; refl; sym; cong; cong\u2082)\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 [] b c p = p\n++-injective\u02b3 (a \u2237 as) b c p = ++-injective\u02b3 as b c (cong remove\u2237 p)\n  where\n    remove\u2237 : {\u2113 : _} {A : Set \u2113} \u2192 List A \u2192 List A\n    remove\u2237 [] = []\n    remove\u2237 (x \u2237 xs) = xs\n\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 [] [] c p = refl\n++-injective\u02e1 [] (b \u2237 bs) (c \u2237 cs) p with cong (\u03bb xs \u2192 length xs \u2238 1) p\n... | q\n  rewrite length-++ bs {c \u2237 cs}\n  rewrite +-suc (length bs) (length cs)\n  = let q' = +-cancel\u02b3-\u2261 zero (suc (length bs)) q\n    in \u22a5-elim (0\u22621+n q')\n++-injective\u02e1 (a \u2237 as) [] cs p with cong (\u03bb xs \u2192 length xs) p\n... | q\n  rewrite length-++ as {cs}\n  = let q' = +-cancel\u02b3-\u2261 (suc (length as)) zero q\n    in \u22a5-elim (1+n\u22620 q')\n++-injective\u02e1 (a \u2237 as) (b \u2237 bs) c p =\n  let (a\u2261b , as++c\u2261bs++c) = \u2237-injective p\n      as\u2261bs = ++-injective\u02e1 as bs c as++c\u2261bs++c\n  in cong\u2082 _\u2237_ a\u2261b as\u2261bs\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":66,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.List.Properties\nopen import Function\n\nreverse-injective : \u2200 {\u2113} {A : Set \u2113} {xs ys : List A} \u2192 reverse xs \u2261 reverse ys \u2192 xs \u2261 ys\nreverse-injective = subst\u2082 _\u2261_ (reverse-involutive _) (reverse-involutive _) \u2218 cong reverse\n\nsafe-tail : \u2200 {\u2113} {A : Set \u2113} \u2192 List A \u2192 List A\nsafe-tail [] = []\nsafe-tail (x \u2237 xs) = xs\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 [] b c e = e\n++-injective\u02b3 (x \u2237 a) b c e = ++-injective\u02b3 a b c (cong safe-tail e)\n\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b c e = reverse-injective (++-injective\u02b3 (reverse c) (reverse a) (reverse b)\n  (trans (sym (reverse-++-commute a c)) (trans (cong reverse e) (reverse-++-commute b c))))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":67,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.List.Properties\nopen import Data.Nat.Properties\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Relation.Nullary.Negation \n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 {\u2113} {A} [] b c eq = eq\n++-injective\u02b3 {\u2113} {A} (x \u2237 a) b c eq = ++-injective\u02b3 a b c (\u2237-injective\u02b3 eq)\n\n-- pretty hard\n-- try to use cong to convert to an eazier problem\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 {\u2113} {A} [] [] c eq = refl\n++-injective\u02e1 {\u2113} {A} [] (x \u2237 b) c eq = contradiction (trans (cong length eq) (length-++ (x \u2237 b) {c})) (m\u22621+n+m (length c))\n++-injective\u02e1 {\u2113} {A} (x \u2237 a) [] c eq = contradiction (trans (sym (cong length eq)) ((length-++ (x \u2237 a) {c}))) (m\u22621+n+m (length c))\n++-injective\u02e1 {\u2113} {A} (x1 \u2237 a) (x2 \u2237 b) c eq rewrite \u2237-injective\u02e1 eq = \n    cong (x2 \u2237_) (++-injective\u02e1 a b c (\u2237-injective\u02b3 eq))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":68,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\n-- you can import other functions from the stdlib here\nopen import Data.List.Properties hiding (reverse-injective)\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 [] b c eq = eq\n++-injective\u02b3 (x \u2237 a) b c eq = ++-injective\u02b3 a b c (\u2237-injective\u02b3 eq)\n\n-- copied from the stdlib for Codewars's Agda and stdlib versions\nopen import Function using (_\u2218_)\nreverse-injective : \u2200 {\u2113} {A : Set \u2113} {xs ys : List A} \u2192 reverse xs \u2261 reverse ys \u2192 xs \u2261 ys\nreverse-injective = subst\u2082 _\u2261_ (reverse-involutive _) (reverse-involutive _) \u2218 cong reverse\n\n-- pretty hard\n-- try to use cong to convert to an eazier problem\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b c eq =\n  let eq\u2081 = cong reverse eq\n      eq\u2082 = subst\u2082 _\u2261_ (reverse-++-commute a c) (reverse-++-commute b c) eq\u2081\n      eq\u2083 = ++-injective\u02b3 (reverse c) (reverse a) (reverse b) eq\u2082\n      eq\u2084 = reverse-injective {xs = a} {ys = b} eq\u2083\n  in  eq\u2084\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":69,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality hiding ([_])\nopen Relation.Binary.PropositionalEquality.\u2261-Reasoning\nopen import Data.List\nopen import Data.List.Properties\n-- you can import other functions from the stdlib here\n\n\u2237injective : \u2200 {\u2113} {A : Set \u2113} (x y : A) \u2192 (l l' : List A) \u2192 x \u2237 l \u2261 y \u2237 l' \u2192 l \u2261 l'\n\u2237injective _ _ _ _ refl = refl\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 [] b c p = p\n++-injective\u02b3 (x \u2237 xs) [] c p\n  rewrite ++-identity\u02b3 (x \u2237 xs)\n  = sym (++-identity\u02b3-unique (x \u2237 xs) p)\n++-injective\u02b3 (x \u2237 xs) b c p = ++-injective\u02b3 xs b c (\u2237injective x x (xs ++ b) (xs ++ c) p)\n\n-- pretty hard\n-- try to use cong to convert to an eazier problem\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b [] p rewrite ++-identity\u02b3 a | ++-identity\u02b3 b = p\n++-injective\u02e1 a b (c \u2237 cs) p\n  rewrite sym (++-assoc a [ c ] cs)\n  | sym (++-assoc b [ c ] cs)\n  = \u2237\u02b3-injective\u02e1 a b (++-injective\u02e1 (a \u2237\u02b3 c) (b \u2237\u02b3 c) cs p)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":70,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Injective where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Data.List\nopen import Data.List.Properties\n\n++-injective\u02b3 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ b \u2261 a ++ c \u2192 b \u2261 c\n++-injective\u02b3 []      b c h = h\n++-injective\u02b3 (x \u2237 a) b c h = ++-injective\u02b3 a b c (\u2237-injective\u02b3 h)\n\n++-injective\u02e1 : \u2200 {\u2113} {A : Set \u2113} (a b c : List A) \u2192 a ++ c \u2261 b ++ c \u2192 a \u2261 b\n++-injective\u02e1 a b c h =\n  begin\n    a\n  \u2261\u27e8 sym (reverse-involutive a) \u27e9\n    reverse (reverse a)\n  \u2261\u27e8 cong reverse lemma\u2081 \u27e9\n    reverse (reverse b)\n  \u2261\u27e8 reverse-involutive b \u27e9\n    b\n  \u220e\n  where\n  \n  lemma\u2080 : reverse c ++ reverse a \u2261 reverse c ++ reverse b\n  lemma\u2080 =\n    begin\n      reverse c ++ reverse a\n    \u2261\u27e8 sym (reverse-++-commute a c) \u27e9\n      reverse (a ++ c)\n    \u2261\u27e8 cong reverse h \u27e9\n      reverse (b ++ c)\n    \u2261\u27e8 reverse-++-commute b c \u27e9\n      reverse c ++ reverse b\n    \u220e\n    \n  lemma\u2081 : reverse a \u2261 reverse b\n  lemma\u2081 = ++-injective\u02b3 (reverse c) (reverse a) (reverse b) lemma\u2080","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c86de12bc56292fb465c77f":[{"id":71,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n\nzero e+e n = n\nsuc x e+e n = suc (x o+e n)\n\nsuc x o+e n = suc (x e+e n)\n\nsuc x o+o n = suc (x e+o n)\n\nzero e+o n = n\nsuc m e+o n = suc (m o+o n)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":72,"user_id":17,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n\nzero e+e m = m\nsuc (suc n) e+e m = suc (suc (n e+e m))\n\nsuc zero o+e m = suc (zero e+e m)\nsuc (suc n) o+e m = suc (suc (n o+e m))\n\nsuc zero o+o m = suc (zero e+o m)\nsuc (suc n) o+o m = suc (suc (n o+o m))\n\nzero e+o m = m\nsuc (suc n) e+o m = suc (suc (n e+o m))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":73,"user_id":1084,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n+-zero : \u2200 (n : \u2115) \u2192 n + zero \u2261 n\n+-zero zero = refl\n+-zero (suc n) rewrite +-zero n = refl\n\n+-comm : \u2200 (m n : \u2115) \u2192 m + n \u2261 n + m\n+-comm zero zero = refl\n+-comm zero (suc n) rewrite +-zero n = refl\n+-comm (suc m) zero rewrite +-zero m = refl\n+-comm (suc m) (suc n) rewrite +-comm m (suc n) | +-comm n (suc m) | +-comm m n = refl\n-- | Implement all these functions\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\nzero e+e y = y\nsuc (suc x) e+e y = suc (suc (x e+e y))\n\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\nsuc {m} x o+o suc {n} y rewrite +-comm m (suc n) | +-comm n m = suc (suc (x e+e y))\n\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n_e+o_ {m} x (suc {n} y) rewrite +-comm m (suc n) | +-comm n m = suc (x e+e y)\n\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+e_ {m} {n} x y rewrite +-comm m n = y e+o x\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":74,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n\nzero e+e b = b\nsuc a e+e b = suc (a o+e b)\nsuc a o+e b = suc (a e+e b)\nsuc a o+o b = suc (a e+o b)\nzero e+o b = b\nsuc a e+o b = suc (a o+o b)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":75,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\nmutual\n  infixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n  _o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n  _e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n  _o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n  _e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n  \n  (suc m) o+o n = suc (m e+o n)\n  zero    e+e n = n\n  (suc m) e+e n = suc (m o+e n)\n  (suc m) o+e n = suc (m e+e n)\n  zero    e+o n = n\n  (suc m) e+o n = suc (m o+o n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":76,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n\nzero e+e m = m\n(suc (suc n)) e+e m = (suc (suc (n e+e m)))\n\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n\n(suc n) o+e m = (suc (n e+e m))\n\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n\n(suc zero) o+o m = (suc m)\n(suc (suc n)) o+o m = (suc (suc (n o+o m)))\n\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n\nzero e+o m = m\n(suc (suc n)) e+o m = (suc (suc (n e+o m)))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":77,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\nzero  e+e n = n\nsuc m e+e n = suc (m o+e n)\nsuc m o+e n = suc (m e+e n)\nsuc m o+o n = suc (m e+o n)\nsuc m e+o n = suc (m o+o n)\nzero e+o n = n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":78,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n\n_o+e_ {(suc m)} {n} (suc m\u2081) n\u2081 = suc ( m\u2081 e+e n\u2081)\n\n_e+e_ {zero} {n} zero n\u2081 = n\u2081\n_e+e_ {suc m} {n} (suc m\u2081) n\u2081 = suc ( m\u2081 o+e n\u2081)\n\n\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n\n_e+o_ {zero} {n} (zero) n\u2081 = n\u2081\n_e+o_ {(suc m)} {n} (suc m\u2081) n\u2081 =  suc (m\u2081 o+o n\u2081)\n_o+o_ {(suc m)} {n} (suc m\u2081) n\u2081 =  suc (m\u2081 e+o n\u2081)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":79,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\n{- Preloaded code:\n\ndata Even : \u2115 \u2192 Set\ndata Odd  : \u2115 \u2192 Set\n\ndata Even where\n  zero : Even zero\n  suc  : \u2200 {n : \u2115} \u2192 Odd n \u2192 Even (suc n)\n\ndata Odd where\n  suc : \u2200 {n : \u2115} \u2192 Even n \u2192 Odd (suc n)\n  \n-}\n\n-- | Implement all these functions\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_e+e_ zero en = en\n_e+e_ {suc zero} (suc ()) en\n_e+e_ (suc (suc em)) zero = suc (suc (em e+e zero))\n_e+e_ (suc (suc em)) (suc (suc en)) = suc (suc (em e+e suc (suc en)))\n\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+e_ (suc em) en = suc (em e+e en)\n\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_o+o_ {suc m} {suc n} (suc em) (suc en) rewrite +-suc m n\n  = suc (suc (em e+e en))\n\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n_e+o_ zero on = on\n_e+o_ (suc om) on = suc (om o+o on)\n\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":80,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\ninfixl 6 _e+e_ _o+e_ _o+o_ _e+o_\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n\nzero e+e m = m\nsuc n e+e m = suc (n o+e m)\n\nsuc n o+e m = suc (n e+e m)\n\nsuc n o+o m = suc (n e+o m)\n\nzero e+o m = m\nsuc n e+o m = suc (n o+o m)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c86f708f545a031075e6b2a":[{"id":81,"user_id":1125,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\nzero e*e m = zero\n(suc n) e*e m = m e+e (n o*e m)\n(suc n) o*e m = m e+e (n e*e m)\n\nzero e*o m = zero\n(suc n) e*o m = m o+o (n o*o m)\n(suc n) o*o m = m o+e (n e*o m)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":82,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\nzero  e*e _ = zero\nsuc m e*e n = n e+e (m o*e n)\nsuc m o*e n = n e+e (m e*e n)\nzero  e*o n = zero\nsuc m e*o n = n o+o (m o*o n)\nsuc m o*o n = n o+e (m e*o n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":83,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\nzero e*e m = zero\n(suc (suc n)) e*e m = m e+e (m e+e (n e*e m))\n\n(suc n) o*e m = m e+e (n e*e m)\n\n(suc n) o*o m = m o+e (n e*o m)\n\nzero e*o m = zero\n(suc n) e*o m = m o+o (n o*o m)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":84,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\nzero  e*e n = zero\nsuc m e*e n = n e+e m o*e n\nsuc m o*e n = n e+e m e*e n\nsuc m o*o n = n o+e m e*o n\nzero  e*o n = zero\nsuc m e*o n = n o+o m o*o n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":85,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\nzero e*e b = zero\n(suc (suc a)) e*e b = (b e+e (b e+e (a e*e b)))\n\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n(suc zero) o*e b = b e+e (zero e*e b) \n(suc (suc a)) o*e b = (b e+e (b e+e (a o*e b)))\n\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\nzero e*o b = zero\n(suc (suc a)) e*o b = (b o+o (b o+e (a e*o b)))\n\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n(suc zero) o*o b = b o+e (zero e*o b)\n(suc (suc a)) o*o b = (b o+e (b o+o (a o*o b)))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":86,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties using (*-suc)\n\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\n \nzero e*e b = zero\nsuc x e*e b = b e+e x o*e b\n\nsuc x o*e b = b e+e x e*e b\n\nsuc x o*o b = b o+e x e*o b\n\n_e*o_ {m} {.suc n} a (suc x) rewrite *-suc m n = a e+e a e*e x\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":87,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\nzero e*e n = zero\n(suc m) e*e n = n e+e (m o*e n)\n\n(suc m) o*e n = n e+e (m e*e n)\n\n(suc m) o*o n = n o+e (m e*o n)\n\nzero e*o n = zero\n(suc m) e*o n = n o+o (m o*o n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":88,"user_id":10,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\n_e*e_ zero _ = zero\n_e*e_ (suc m) n = n e+e (m o*e n)\n\n_o*e_ (suc m) n = n e+e (m e*e n)\n\n_o*o_ (suc m) n = n o+e (m e*o n)\n\n_e*o_ zero n = zero\n_e*o_ (suc m) n = n o+o (m o*o n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":89,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement all these functions\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\nzero e*e n = zero\n(suc m) e*e n = n e+e (m o*e n)\n\n(suc m) o*e n = n e+e (m e*e n)\n\n(suc m) o*o n = n o+e (m e*o n)\n\nzero e*o n = zero\n(suc m) e*o n = n o+o (m o*o n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":90,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule OddsAndEvens where\n\nopen import Preloaded\nopen import Data.Nat\n\n{- Preloaded functions:\n_e+e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m + n)\n_o+e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Odd  (m + n)\n_o+o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Even (m + n)\n_e+o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Odd  (m + n)\n-}\n\n-- | Implement these functions:\ninfixl 7 _e*e_ _o*e_ _o*o_ _e*o_\n_e*e_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Even n \u2192 Even (m * n)\n_o*e_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Even n \u2192 Even (m * n)\n_o*o_ : \u2200 {m n : \u2115} \u2192 Odd  m \u2192 Odd  n \u2192 Odd  (m * n)\n_e*o_ : \u2200 {m n : \u2115} \u2192 Even m \u2192 Odd  n \u2192 Even (m * n)\n\nzero e*e hn = zero\nsuc x e*e hn = hn e+e (x o*e hn)\nsuc x o*e hn = hn e+e (x e*e hn)\nsuc x o*o hn = hn o+e (x e*o hn)\nzero e*o hn = zero\nsuc x e*o hn = hn o+o (x o*o hn)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c87786accafc44db95eb8cc":[{"id":91,"user_id":1125,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Relation.Binary.HeterogeneousEquality\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Vec\n\n-- ++-identity : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2261 xs\n-- ++-identity xs = refl\n\n-- ++-identity\u02b3-0 : [] ++ [] \u2245 []\n-- ++-identity\u02b3-0 = refl\n\nassoc-id : \u2200 {n} {A : Set} (x : A) (a : Vec A n) \u2192  x \u2237 a ++ [] \u2245 x \u2237 (a ++ [])\nassoc-id x [] = refl\nassoc-id {suc n} x (y \u2237 a) = refl\n\nconcat-id : \u2200 {n m} {A : Set} (x : A) (a : Vec A n) (b : Vec A m) \u2192 n \u2261 m \u2192 a \u2245 b \u2192 x \u2237 a \u2245 x \u2237 b\nconcat-id x a b refl refl = refl\n\nzero-eq : (n : \u2115) \u2192 n + zero \u2261 n\nzero-eq zero = refl\nzero-eq (suc n) = Relation.Binary.PropositionalEquality.cong suc (zero-eq n)\n\n-- (suc n) + zero = suc n\n-- (suc n) + zero = suc (n + zero)\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {suc n} (x \u2237 xs) = Relation.Binary.HeterogeneousEquality.trans (assoc-id x xs) (concat-id x (xs ++ []) xs (zero-eq n) (++-identity\u02b3 xs))\n\n-- x :: xs ++ [] ~ x :: xs\n-- \u5df2\u77e5 xs ++ [] ~ xs\n\n-- (x :: xs) ++ [] ~ x :: xs\n\n-- (xs ++ []) ~ xs\n-- x :: (xs ++ []) ~ x :: xs\n-- (x :: xs) ++ [] ~ x :: (xs ++ [])","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":92,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary.HeterogeneousEquality\nopen import Data.Vec\n\ncong-\u2237 : \u2200 {A : Set} {x} {m n : \u2115} {xs : Vec A m} {ys : Vec A n} \u2192 m \u2261 n \u2192 xs \u2245 ys \u2192 x \u2237 xs \u2245 x \u2237 ys\ncong-\u2237 refl refl = refl\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {A} (x \u2237 xs) = cong-\u2237 (+-comm _ 0) (++-identity\u02b3 xs)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":93,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Relation.Binary.HeterogeneousEquality\nopen import Data.Vec\n\nopen import Data.Nat.Properties \n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 (x \u2237 xs) = icong (Vec _) (+-identity\u02b3 _) (\u03bb z \u2192 x \u2237 z) (++-identity\u02b3 xs)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":94,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality as PE\nopen import Relation.Binary.HeterogeneousEquality as HE\nopen import Data.Vec\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {(suc n)} {A} (x \u2237 xs) = cong-plus (PE.cong (\u03bb c \u2192 Vec A c) (+-comm n 0)) (PE.cong (\u03bb c \u2192 Vec A (suc c)) (+-comm n 0)) (HE.cong (\u03bb n (xs : Vec A n) \u2192 x \u2237 xs) (\u2261-to-\u2245 (+-comm n 0))) (++-identity\u02b3 xs)\n  where\n    cong-plus : \u2200 {A B C D} {f : A \u2192 B} {g : C \u2192 D} {x : A} {y : C} \u2192 A \u2261 C \u2192 B \u2261 D \u2192 f \u2245 g \u2192 x \u2245 y \u2192 f x \u2245 g y\n    cong-plus {x = x} refl refl refl refl = refl\n\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":95,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.HeterogeneousEquality\nopen import Data.Vec\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 {0} [] = refl\n++-identity\u02b3 {suc n} (x \u2237 xs) = cong\u2082 (consn x) (\u2261-to-\u2245 (+-identity\u02b3 n)) (++-identity\u02b3 xs)\n  where\n    consn : \u2200 {A : Set} -> A -> (n : \u2115) \u2192 Vec A n \u2192 Vec A (suc n)\n    consn x n xs = x \u2237 xs\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":96,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.HeterogeneousEquality\nopen import Data.Vec\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {suc n} {A} (x \u2237 xs) = icong (Vec A) (+-identity\u02b3 n) (x \u2237_) (++-identity\u02b3 xs)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":97,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Data.Nat.Properties using (+-identity\u02b3)\nopen import Relation.Binary.HeterogeneousEquality\nopen import Data.Vec\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {n = suc n} {A = A} (x \u2237 xs) =\n  icong (Vec A) (+-identity\u02b3 n) (\u03bb xs \u2192 x \u2237 xs) (++-identity\u02b3 xs)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":98,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Relation.Binary.HeterogeneousEquality\nopen import Relation.Binary.PropositionalEquality as Eq hiding ( cong ) \nopen import Data.Vec\nopen \u2245-Reasoning\n\n+0=id : \u2200 { n : \u2115 } \u2192 n + 0 \u2261 n\n+0=id { zero } = Eq.refl\n+0=id { suc m } rewrite +0=id { m } = Eq.refl\n\n++-identity\u02b3 : \u2200 { n : \u2115 } {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 { suc n } { A } ( x \u2237 xs ) =\n  begin\n    ( x \u2237 xs ) ++ []\n  \u2261\u27e8\u27e9\n    x \u2237 ( xs ++ [] )\n  \u2245\u27e8 icong ( Vec A ) +0=id ( x \u2237_ ) ( ++-identity\u02b3 xs ) \u27e9\n    x \u2237 xs\n  \u220e ","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":99,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Relation.Binary.HeterogeneousEquality\nopen import Data.Vec\n\n+-id\u02b3 : \u2200 n \u2192 n + 0 \u2245 n\n+-id\u02b3 zero = refl\n+-id\u02b3 (suc n) with n + 0 | +-id\u02b3 n\n+-id\u02b3 (suc n) | .n | refl = refl\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {A = A} (x \u2237 xs) = icong (Vec A) (\u2245-to-\u2261 (+-id\u02b3 _)) (_\u2237_ x) (++-identity\u02b3 xs)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":100,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ++-Identity where\n\nopen import Data.Nat\nopen import Data.Nat.Properties using (+-identity\u02b3)\nopen import Relation.Binary.HeterogeneousEquality\nopen import Relation.Binary.PropositionalEquality hiding (cong\u2082)\nopen import Data.Vec\n\nn+0\u2245n : (n : \u2115) \u2192 (n + 0) \u2245 n\nn+0\u2245n n = \u2261-to-\u2245 (+-identity\u02b3 n)\n\n++-identity\u02b3 : \u2200 {n} {A : Set} (xs : Vec A n) \u2192 xs ++ [] \u2245 xs\n++-identity\u02b3 [] = refl\n++-identity\u02b3 {n} {A} (x \u2237 xs) = \n    cong\u2082 \n        {A = \u2115} \n        {B = \u03bb m \u2192 Vec A m}\n        {C = \u03bb m _ \u2192 Vec A (suc m)} \n        (\u03bb m ys \u2192 x \u2237 ys) (n+0\u2245n _) (++-identity\u02b3 xs)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c879811bc562909bf65c8e6":[{"id":101,"user_id":490,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S n) = cong S (a+0 n)\n\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":102,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n{-# BUILTIN EQUALITY Eq #-}\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S n) rewrite a+0 n = refl\n\n-- by using something you've already learnt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":103,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- plus-zero : (n : Nat) -> Eq (plus Z n) n\n-- plus-comm-z : (n : Nat) -> Eq (plus n Z) (plus Z n)\n-- plus-comm-z Z = refl\n-- plus-comm-z (S n) = \n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S n) = cong S (a+0 n)\n\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":104,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl = refl\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl \na+0 (S n) = cong S (a+0 n)\n\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":105,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\n--a+0 (S n) = let recursiveResult = a+0 n in cong S recursiveResult\na+0 (S n) = cong S recursiveResult where recursiveResult = a+0 n\n\n\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":106,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\ndata Nat : Set where\n  Z : Nat\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\npred : Nat -> Nat\npred Z = Z\npred (S n) = n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\nplus Z n = n\nplus (S n) m = let recursiveResult = plus n m in S recursiveResult\n\ndata Eq {A : Set} (x : A) : A -> Set where\n  refl : Eq x x\n\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\nevenMoreC : Eq (plus two Z) (plus Z two)\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S n) = cong S (a+0 n)\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":107,"user_id":1507,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S a) = cong S (a+0 a)\n\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":108,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S n) = cong (plus (S Z)) (a+0 n)\n\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":109,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n\n\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 Z = refl\na+0 (S m) with (plus m Z ) | a+0 m\na+0 _ | _  | refl  = refl\n\n-- by using something you've already learnt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":110,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule 8kyu where\n\n-- Define a datatype\ndata Nat : Set where\n  -- which can be a zero\n  Z : Nat\n  -- or the successor of another `Nat`\n  S : Nat -> Nat\n\n-- Two is the successor of the successor of zero\ntwo : Nat\ntwo = S (S Z)\n\n-- So we can find the predeccessor\npred : Nat -> Nat\n-- we can investigate the input `Nat`: is it zero?\n-- if so, return zero\npred Z = Z\n-- .. or is it the successor of another `Nat`?\n-- we call the other nat `n`.\npred (S n) =\n  -- `n`'s successor's predeccessor is obviously `n` itself\n  n\n\n-- plus takes two nats\nplus : Nat -> Nat -> Nat\n-- if the first nat is zero, return the second nat\nplus Z n = n\n-- otherwise the first nat must be the successor of someone `n`.\n-- we recursively call `plus` by `plus m n`\nplus (S n) m = let recursiveResult = plus n m\n               -- and return the successor.\n               in S recursiveResult\n\n-- equality type\n-- oh, so f* complicated, let's just see how to use it\ndata Eq {A : Set} (x : A) : A -> Set where\n  -- a constructor whose type is `Eq x x`\n  refl : Eq x x\n\n-- So we get reflexivity for free\n-- everything is equivalent to itself\n\n-- specialize `Eq x x` to `Eq (S Z) (S Z)` can be\nfreeOhYeah : Eq (S Z) (S Z)\nfreeOhYeah = refl\n\n-- And we can write more complex things like\nevenMoreC : Eq (plus two Z) (plus Z two)\n-- Agda will compute the value of `plus two Z` and `plus Z two`\n-- the results are identical so `refl`\nevenMoreC = refl\n\n-- The most useful proving helper function: cong\ncong : {n m : Nat} ->\n       -- this is a specialized version\n       -- because I want to keep everything simple\n       (f : Nat -> Nat) ->\n       Eq n m -> Eq (f n) (f m)\n-- if we pattern match `Eq n m` with `refl`, Agda will try to unify\n-- two statements: `Eq x x` and `Eq n m`, resulting `n` and `m` are identical\ncong f refl =\n  -- Agda keeps this in mind, and replace `m` with `n` in the context.\n  -- Now the return type becomes `Eq (f n) (f n)`, which is yet another\n  -- specialized `refl`.\n  refl\n\n-- And we can prove this trivially\n-- because `plus` is defined with `plus Z n = n`\n0+a : (n : Nat) -> Eq (plus Z n) n\n-- so Agda replaces `plus Z n` with `n`\n-- making this super easy to prove\n0+a n = refl\n\n-- And we can prove this in a little bit more complex way\na+0 : (n : Nat) -> Eq (plus n Z) n\n-- because `plus` is *not* defined with `plus n Z`\n-- how do we prove this?\na+0 (S n) = cong S (a+0 n)\na+0 Z = refl\n-- by using something you've already learnt\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c87e641a2fc6d2b42f4b610":[{"id":111,"user_id":490,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B\nopen import Relation.Nullary.Decidable\n\nrecord Eq (A : Set) : Set where\n  field _===_ : A \u2192 A \u2192 Bool\n  _=\/=_ : A \u2192 A \u2192 Bool\n  a =\/= b = not (a === b)\n\nmodule Instances where\n  open Eq\n  instance\n    IntEq : Eq \u2124\n    _===_ IntEq a b = \u230a a I.\u225f b \u230b\n    NatEq : Eq \u2115\n    _===_ NatEq a b = a == b\n    CharEq : Eq Char\n    _===_ CharEq a b = toNat a == toNat b\n    StrEq : Eq String\n    _===_ StrEq a b = primStringEquality a b\n    BoolEq : Eq Bool\n    _===_ BoolEq a b = \u230a a B.\u225f b \u230b\n\nopen Instances public\nopen Eq {{ ... }} public\n\nmodule ListInstance where\n  instance\n   ListEq : {A : Set} \u2192 {{ _ : Eq A }} \u2192 Eq (List A)\n   Eq._===_ ListEq a b = (length a === length b) \u2227 (foldr _\u2227_ true (zipWith _===_ a b))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":112,"user_id":490,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char hiding (_==_)\nopen import Data.String hiding (length) renaming (_==_ to primStringEquality)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B\nopen import Function\nopen import Relation.Nullary\n\nrecord Eq (A : Set) : Set where\n  inductive\n  constructor eq\n  field _===_ : A \u2192 A \u2192 Bool\n  _=\/=_ : A \u2192 A \u2192 Bool\n  a =\/= b = not (a === b)\n\nmodule Instances where\n  open Eq\n  instance\n    IntEq : Eq \u2124\n    _===_ IntEq a b with a I.\u225f b\n    (IntEq === a) b | yes p = true\n    (IntEq === a) b | no \u00acp = false\n\n    NatEq : Eq \u2115\n    _===_ NatEq a b = a == b\n\n    CharEq : Eq Char\n    _===_ CharEq a b = toNat a == toNat b\n\n    StrEq : Eq String\n    _===_ StrEq a b = primStringEquality a b\n\n    BoolEq : Eq Bool\n    _===_ BoolEq a b with a B.\u225f b\n    (BoolEq === a) b | yes p = true\n    (BoolEq === a) b | no \u00acp = false\n\nopen Instances public\nopen Eq {{ ... }} public\n\nmodule ListInstance where\n  instance\n   ListEq : {A : Set} \u2192 {{ _ : Eq A }} \u2192 Eq (List A)\n   Eq._===_ ListEq a b = (length a === length b) \u2227 (foldr _\u2227_ true (zipWith _===_ a b))\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":113,"user_id":106,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B\n\nrecord Eq {a} (A : Set a) : Set a where\n  field\n    _===_ : A \u2192 A \u2192 Bool\n    _=\/=_ : A \u2192 A \u2192 Bool\n\nopen Eq {{...}} public\n\n_Z\u2264\u1d47_ : \u2124 \u2192 \u2124 \u2192 Bool\n-[1+ m ] Z\u2264\u1d47 -[1+ n ] = n N.<\u1d47 (N.suc m)\n(+ m)    Z\u2264\u1d47 -[1+ n ] = false\n-[1+ m ] Z\u2264\u1d47 (+ n)    = true\n(+ m)    Z\u2264\u1d47 (+ n)    = m N.<\u1d47 (N.suc n)\n\ninstance\n  eqInt : Eq \u2124\n  _===_ {{eqInt}} a b = (a Z\u2264\u1d47 b) \u2227 (b Z\u2264\u1d47 a)\n  _=\/=_ {{eqInt}} a b = not ((a Z\u2264\u1d47 b) \u2227 (b Z\u2264\u1d47 a))\n\ninstance\n  eqNat : Eq \u2115\n  _===_ {{eqNat}} = Agda.Builtin.Nat._==_\n  _=\/=_ {{eqNat}} a b = not (a Agda.Builtin.Nat.== b)\n\ninstance\n  eqChar : Eq Char\n  _===_ {{eqChar}} = Data.Char._==_\n  _=\/=_ {{eqChar}} a b = not (a Data.Char.== b)\n\ninstance\n  eqBool : Eq Bool\n  _===_ {{eqBool}} a b = not (a xor b)\n  _=\/=_ {{eqBool}} = _xor_\n\ninstance\n  eqString : Eq String\n  _===_ {{eqString}} = Data.String._==_\n  _=\/=_ {{eqString}} a b = not (a Data.String.== b)\n\ninstance\n  eqList : \u2200 {a} {A : Set a} \u2192 {{_ : Eq A}} \u2192 Eq (List A)\n  _===_ {{eqList}} []       []       = true\n  _===_ {{eqList}} (x \u2237 xs) (y \u2237 ys) = (x === y) \u2227 (xs === ys)\n  _===_ {{eqList}} _        _        = false\n  _=\/=_ {{eqList}} []       []       = false\n  _=\/=_ {{eqList}} (x \u2237 xs) (y \u2237 ys) = not ((x === y) \u2227 (xs === ys))\n  _=\/=_ {{eqList}} _        _        = true","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":114,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char as C\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat renaming (_==_ to _==\u2115_)\nopen import Data.Bool as B\nopen import Data.Bool public\n\nrecord Eq (A : Set) : Set where\n  field\n    eq : A \u2192 A \u2192 Bool\n\nopen Eq {{...}}\n\neqL : {A : Set} \u2192 (A \u2192 A \u2192 Bool) \u2192 List A \u2192 List A \u2192 Bool\neqL e [] [] = true\neqL e [] (x \u2237 ys) = false\neqL e (x \u2237 xs) [] = false\neqL e (x \u2237 xs) (y \u2237 ys) = e x y \u2227 eqL e xs ys\n\n_==B_ : Bool \u2192 Bool \u2192 Bool\nx ==B y = not (x xor y)\n\n\n_==I_ : \u2124 \u2192 \u2124 \u2192 Bool\n+_ n ==I +_ m = n ==\u2115 m\n+_ n ==I -[1+_] m = false\n-[1+_] n ==I +_ m = false\n-[1+_] n ==I -[1+_] m = n ==\u2115 m\n\n_===_ : {A : Set} \u2192 {{_ : Eq A}} \u2192 A \u2192 A \u2192 Bool\n_===_ = eq\n\n_=\/=_ : {A : Set} \u2192 {{_ : Eq A}} \u2192 A \u2192 A \u2192 Bool\na =\/= b = not (a === b)\n\n\ninstance\n  NatEq : Eq \u2115\n  NatEq = record { eq = _==\u2115_ }\n  \n  CharEq : Eq Char\n  CharEq = record { eq = \u03bb x y \u2192 C.toNat x === C.toNat y }\n\n  ListEq : {A : Set} \u2192 {{_ : Eq A}} \u2192 Eq (List A)\n  ListEq = record { eq = eqL eq }\n\n  StringEq : Eq String\n  StringEq = record { eq = \u03bb x y \u2192 toList x === toList y }\n  \n  BoolEq : Eq Bool\n  BoolEq = record { eq = _==B_ }\n  \n  IntEq : Eq \u2124\n  IntEq = record { eq = _==I_ }\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":115,"user_id":29,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool\n\nrecord Eq {a} (A : Set a) : Set a where\n  field\n    _===_ : A \u2192 A \u2192 Bool\n    _=\/=_ : A \u2192 A \u2192 Bool\n\nopen Eq {{...}} public\n\ninstance\n  Eq\u2115 : Eq \u2115\n  _===_ \u2983 Eq\u2115 \u2984 = Agda.Builtin.Nat._==_\n  _=\/=_ \u2983 Eq\u2115 \u2984 a b = not (a === b)\n\ninstance\n  Eq\u2124 : Eq \u2124\n  _===_ \u2983 Eq\u2124 \u2984 (+_ n) (+_ m) = n === m\n  _===_ \u2983 Eq\u2124 \u2984 (+_ n) (-[1+_] m) = false\n  _===_ \u2983 Eq\u2124 \u2984 (-[1+_] n) (+_ m) = false\n  _===_ \u2983 Eq\u2124 \u2984 (-[1+_] n) (-[1+_] m) = n === m\n  _=\/=_ \u2983 Eq\u2124 \u2984 x y = not (x === y)\n\ninstance\n  EqC : Eq Char\n  _===_ \u2983 EqC \u2984 = Data.Char._==_\n  _=\/=_ \u2983 EqC \u2984 a b = not (a === b)\n\ninstance\n  EqB : Eq Bool\n  _===_ \u2983 EqB \u2984 = _\u2227_\n  _=\/=_ \u2983 EqB \u2984 = _xor_\n\ninstance\n  EqL : \u2200 {a} {A : Set a} \u2192 {{_ : Eq A}} \u2192 Eq (List A)\n  _===_ \u2983 EqL \u2984 [] [] = true\n  _===_ \u2983 EqL \u2984 [] (x \u2237 ys) = false\n  _===_ \u2983 EqL \u2984 (x \u2237 xs) [] = false\n  _===_ \u2983 EqL \u2984 (x \u2237 xs) (y \u2237 ys) = (x === y) \u2227 (xs === ys)\n  _=\/=_ \u2983 EqL \u2984 a b = not (a === b)\n\ninstance\n  EqS : Eq String\n  _===_ \u2983 EqS \u2984 a b = (toList a) === (toList b)\n  _=\/=_ \u2983 EqS \u2984 a b = not (a === b)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":116,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B\n\n-- write something\nrecord decEq (A : Set) : Set where \n  field \n    _==d_ : A \u2192 A \u2192 Bool \n  \nopen decEq {{...}} public\n\n_===_ : {A : Set} {{decA : decEq A}} \u2192 A \u2192 A \u2192 Bool\n_===_ = _==d_\n\n_=\/=_ : {A : Set} {{decA : decEq A}} \u2192 A \u2192 A \u2192 Bool\nx =\/= y = not (x === y)\n\ninstance \n  natEq : decEq \u2115\n  _==d_ \u2983 natEq \u2984 = N._\u2261\u1d47_\n\n  intEq : decEq \u2124\n  _==d_ \u2983 intEq \u2984 (+_ n) (+_ m) = n === m\n  _==d_ \u2983 intEq \u2984 (+_ n) (-[1+_] m) = false\n  _==d_ \u2983 intEq \u2984 (-[1+_] n) (+_ m) = false\n  _==d_ \u2983 intEq \u2984 (-[1+_] n) (-[1+_] m) = n === m\n\n  charEq : decEq Char\n  _==d_ \u2983 charEq \u2984 = Data.Char._==_ \n\n  boolEq : decEq Bool \n  _==d_ \u2983 boolEq \u2984 x y = not (x xor y)\n\n  stringEq : decEq String\n  _==d_ \u2983 stringEq \u2984 = Data.String._==_ \n\n  listEq : {e : Set} \u2192 {{decEqE : decEq e}} \u2192 decEq (List e)\n  _==d_ \u2983 listEq \u2984 [] [] = true\n  _==d_ \u2983 listEq \u2984 [] (x \u2237 xs) = false\n  _==d_ \u2983 listEq \u2984 (x \u2237 xs) [] = false\n  _==d_ \u2983 listEq \u2984 (x \u2237 xs) (y \u2237 ys) = (x === y) \u2227 (xs ==d ys)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":117,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char as C\nopen import Data.String as S hiding (length)\nopen import Data.List as L\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B\n\n-- write something\n\nrecord Eq (A : Set) : Set where\n  field\n    _===\u2032_ : A \u2192 A \u2192 Bool\n\n_===_ : \u2200 {A} {{eqA : Eq A}} \u2192 A \u2192 A \u2192 Bool\n_===_ {{eqA}} = Eq._===\u2032_ eqA\n\n_=\/=_ : \u2200 {A} {{eqA : Eq A}} \u2192 A \u2192 A \u2192 Bool\nx =\/= y = not (x === y)\n\nopen import Relation.Nullary.Decidable using (\u230a_\u230b)\nopen import Relation.Binary.PropositionalEquality using (_\u2261_)\n--open import Relation.Binary.Definitions using (DecidableEquality)\n\n-- for Codewars' Agda version 2.6.0 and stdlib version v1.0.1\nopen import Relation.Nullary using (Dec)\nDecidableEquality : Set \u2192 Set\nDecidableEquality A = (x : A) \u2192 (y : A) \u2192 Dec (x \u2261 y) \n\n_\u225f_\u2192Eq : \u2200 {A} \u2192 DecidableEquality A \u2192 Eq A\n_\u225f_\u2192Eq _\u225f_ = record { _===\u2032_ = \u03bb x y \u2192 \u230a x \u225f y \u230b }\n\ninstance\n  eq\u2124 = _\u225f_\u2192Eq I._\u225f_\n  eq\u2115 = _\u225f_\u2192Eq N._\u225f_\n  eq-Char = _\u225f_\u2192Eq C._\u225f_\n  eq-Bool = _\u225f_\u2192Eq B._\u225f_\n  eq-String = _\u225f_\u2192Eq S._\u225f_\n\n  open Eq {{...}}\n  \n  eq-List : \u2200 {A} \u2192 {{eq : Eq A}} \u2192 Eq (List A)\n  _===\u2032_ {{eq-List}} [] [] = true\n  _===\u2032_ {{eq-List}} (x \u2237 xs) (y \u2237 ys) = x ===\u2032 y \u2227 xs ===\u2032 ys\n  _===\u2032_ {{eq-List}} _ _ = false\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":118,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B public\nopen import Relation.Nullary\n\nrecord Eq {\u2113} (A : Set \u2113) : Set \u2113 where\n  field\n    _===_ : A \u2192 A \u2192 Bool\n    _=\/=_ : A \u2192 A \u2192 Bool\n    \nopen Eq {{...}} public\n\n\ninstance\n  IntEq : Eq \u2124\n  _===_ {{IntEq}} = eq \n   where\n    eq : \u2124 \u2192 \u2124 \u2192 Bool\n    eq x y with (x I.\u225f y)\n    ... | (yes p) = true\n    ... | (no p) = false\n  _=\/=_ {{IntEq}} = \u03bb x y \u2192 not (x === y)\n\n  NatEq : Eq \u2115\n  _===_ {{NatEq}} = Agda.Builtin.Nat._==_\n  _=\/=_ {{NatEq}} = \u03bb x y \u2192 not (x === y)\n  \n  CharEq : Eq Char\n  _===_ {{CharEq}} = Data.Char._==_\n  _=\/=_ {{CharEq}} = \u03bb x y \u2192 not (x === y)\n  \n  BoolEq : Eq Bool\n  _===_ {{BoolEq}} = eq \n    where\n      eq : Bool \u2192 Bool \u2192 Bool\n      eq false false = true\n      eq true true = true\n      eq _ _ = false\n  _=\/=_ {{BoolEq}} = \u03bb x y \u2192 not (x === y)\n\n  StringEq : Eq String\n  _===_ {{StringEq}} = Data.String._==_\n  _=\/=_ {{StringEq}} = \u03bb x y \u2192 not (x === y)\n  \n  ListEq : \u2200 {A : Set} \u2192 {{eq : Eq A}} \u2192 Eq (List A)\n  _===_ {{ListEq}} = \u03bb { \n    [] [] \u2192 true ; \n    (x \u2237 xs) (y \u2237 ys) \u2192 x === y \u2227 xs === ys;\n    _ _ \u2192 false}\n  _=\/=_ {{ListEq}} = \u03bb x y \u2192 not (x === y)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":119,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char\nopen import Data.String hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat as N\nopen import Agda.Builtin.Nat using (_==_)\nopen import Data.Bool as B\n\nopen import Relation.Nullary using (Dec; yes; no)\n\nrecord Eq (A : Set) : Set where\n  field\n    _===_ : A \u2192 A \u2192 Bool\n\nopen Eq {{...}} public\n\n_=\/=_ : \u2200 {A : Set} \u2192 {{ eqA : Eq A }} \u2192 A \u2192 A \u2192 Bool\n_=\/=_ {{ eqA }} x y = B.not (Eq._===_ eqA x y)\n\ninstance\n  eqChar : Eq Char\n  eqChar = record { _===_ = Data.Char._==_ }\n\n  eqString : Eq String\n  eqString = record { _===_ = Data.String._==_ }\n\n  eqList : \u2200 {A : Set} \u2192 {{eqA : Eq A}} \u2192 Eq (List A)\n  _===_ {{ eqList }} [] [] = true\n  _===_ {{ eqList }} (x \u2237 xs) (y \u2237 ys) = if (x === y) then (xs === ys) else false\n  _===_ {{ eqList }} _ _ = false\n\n  eqInteger : Eq \u2124\n  _===_ {{ eqInteger }} x y with x I.\u225f y\n  ... | yes _ = true\n  ... | no _ = false\n\n  eqNat : Eq \u2115\n  eqNat = record { _===_ = Agda.Builtin.Nat._==_ }\n\n  eqBool : Eq Bool\n  _===_ {{ eqBool }} true true = true\n  _===_ {{ eqBool }} false false = true\n  _===_ {{ eqBool }} _ _ = false\n  \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":120,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule AdHoc where\n\nopen import Data.Char as C\nopen import Data.String as S hiding (length)\nopen import Data.List\nopen import Data.Integer as I\nopen import Data.Nat\nopen import Agda.Builtin.Nat as N using (_==_)\nopen import Data.Bool as B\n\nrecord Eq (A : Set) : Set where\n  field\n    _===_ : A \u2192 A \u2192 Bool\n\nopen Eq {{...}} public\n\ninstance\n  \u2261-nat : Eq \u2115\n  _===_ \u2983 \u2261-nat \u2984 = N._==_\n\n  \u2261-int : Eq \u2124\n  _===_ \u2983 \u2261-int \u2984 (   +_  m) (   +_  n) = m === n\n  _===_ \u2983 \u2261-int \u2984 (   +_  _) (-[1+_] _) = false\n  _===_ \u2983 \u2261-int \u2984 (-[1+_] _) (   +_  _) = false\n  _===_ \u2983 \u2261-int \u2984 (-[1+_] m) (-[1+_] n) = m === n\n\n  \u2261-char : Eq Char\n  _===_ \u2983 \u2261-char \u2984 = C._==_\n\n  \u2261-bool : Eq Bool\n  _===_ \u2983 \u2261-bool \u2984 x y = not (x xor y)\n\n  \u2261-string : Eq String\n  _===_ \u2983 \u2261-string \u2984 = S._==_\n\n  \u2261-list : \u2200 {A : Set} \u2192 \u2983 \u2261-arb : Eq A \u2984 \u2192 Eq (List A)\n  _===_ \u2983 \u2261-list \u2984 []        []        = true\n  _===_ \u2983 \u2261-list \u2984 (_  \u2237 _ ) []        = false\n  _===_ \u2983 \u2261-list \u2984 []        (_  \u2237 _ ) = false\n  _===_ \u2983 \u2261-list \u2984 (h\u2081 \u2237 t\u2081) (h\u2082 \u2237 t\u2082) = h\u2081 === h\u2082 \u2227 t\u2081 === t\u2082\n\n_=\/=_ : {A : Set} \u2192 \u2983 \u2261-arb : Eq A \u2984 \u2192 A \u2192 A \u2192 Bool\nx =\/= y = not (x === y)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c88365acab0b90014f24f8c":[{"id":121,"user_id":885,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing thatMoney = znots (injSuc (injSuc thatMoney))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":122,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing thatMoney = znots (inj-m+ thatMoney)\n\ntheWrongThing\u2081 : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing\u2081 thatMoney = transp (\u03bb i \u2192 f (thatMoney i)) i0 tt\n  where f : \u2115 \u2192 Set\n        f 3 = \u22a5\n        f _ = Unit","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":123,"user_id":60,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit\nopen import Cubical.Foundations.Prelude\n\nf : \u2115 \u2192 Set\nf 2 = Unit\nf _ = \u22a5\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing thatMoney = (subst f thatMoney) tt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":124,"user_id":106,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Prelude\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing eq = znots (injSuc (injSuc eq))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":125,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing 1+1\u22613 = transp (\u03bb i \u2192 tyFam (1+1\u22613 i)) i0 tt\n  where\n    tyFam : \u2115 \u2192 Type \u2113-zero\n    tyFam 3 = \u22a5\n    tyFam _ = Unit\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":126,"user_id":429,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Prelude\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\n\nf : \u2115 \u2192 Set\nf 2 = 1 + 1 \u2261 3\nf _ = \u22a5\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing p = transport (\u03bb i \u2192 f (p i)) p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":127,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit\n\nThing : \u2115 -> Set\nThing 3 = \u22a5\nThing _ = Unit\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing thatMoney = subst Thing thatMoney tt\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":128,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit renaming (Unit to \u22a4)\nopen import Cubical.Foundations.Prelude\n\neven : \u2115 \u2192 Set\neven zero = \u22a4\neven (suc zero) = \u22a5\neven (suc (suc n)) = even n\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing thatMoney = subst even thatMoney tt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":129,"user_id":29,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Foundations.Prelude\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\n\ncase : \u2115 \u2192 Set\ncase 0 = \u22a5\ncase 1 = \u22a5\ncase 2 = \u2115\ncase (suc n) = \u22a5\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing a = subst case a 2\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":130,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule ProvingTheWrongThing where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit\n\ntheWrongThing : 1 + 1 \u2261 3 \u2192 \u22a5\ntheWrongThing thatMoney = transp (\u03bb i \u2192 helper (thatMoney i)) i0 tt\n  where\n  helper : \u2115 \u2192 Set\n  helper 2 = Unit\n  helper _ = \u22a5\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c88f7c01131b81217fdaa6e":[{"id":131,"user_id":1084,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\nopen import Agda.Builtin.Size\n\ndata SNat : Size -> Set where\n  zero : {i : Size} -> SNat (\u2191 i)\n  suc : {i : Size} -> SNat i -> SNat (\u2191 i)\n\nSubType = {i j : Size} -> SNat i -> SNat j -> SNat i\nDivType = {i j : Size} -> SNat i -> SNat j -> SNat i\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":132,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\n\nopen import Agda.Builtin.Size\n\ndata SNat : Size \u2192 Set where\n  zero : {i : Size} \u2192 SNat i\n  suc : {i : Size} \u2192 SNat i \u2192 SNat (\u2191 i)\n\nSubType = {i j : Size} \u2192 SNat i -> SNat j -> SNat i\nDivType = {i j : Size} \u2192 SNat i -> SNat j -> SNat i\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":133,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\n\nopen import Data.Nat public\nopen import Size\n\ndata Nat (i : Size) : Set where\n  zero : Nat i\n  suc : {j : Size< i} \u2192 Nat j \u2192 Nat i\n\nSubType = {i j : Size} \u2192 Nat i \u2192 Nat j \u2192 Nat i\nDivType = {i j : Size} \u2192 Nat i \u2192 Nat j \u2192 Nat i\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":134,"user_id":10,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\n\nopen import Size\n\ndata Nat : {i : Size} \u2192 Set where\n    zero : {i : Size} \u2192 Nat {\u2191 i}\n    suc : {i : Size} \u2192 Nat {i} \u2192 Nat {\u2191 i}\n\nSubType = {i : Size} \u2192 Nat {i} \u2192 Nat {\u221e} \u2192 Nat {i}\nDivType = {i : Size} \u2192 Nat {i} \u2192 Nat {\u221e} \u2192 Nat {i}\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":135,"user_id":null,"body":"{-# OPTIONS  --safe --sized-types #-}\n--open import Nat\n\n--module Nat where\n\n--open import Agda.Builtin.Nat public\n\nmodule Nat where\nopen import Size \n\ndata Nat : {i : Size} -> Set where\n  zero : {i : Size } -> Nat {\u2191 i}\n  suc : {i : Size} -> Nat {i} -> Nat {\u2191 i}\n  \nSubType = {i : Size} -> Nat {i} -> Nat {\u221e} \u2192 Nat {i}\n\nDivType = {i : Size} -> Nat {i} -> Nat -> Nat {i}\n\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":136,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\n\nopen import Agda.Builtin.Nat public\nopen import Size\n\ndata Natu : {i : Size} -> Set where\n  zero : {i : Size} -> Natu {\u2191 i}\n  suc : {i : Size} -> Natu {i} -> Natu {\u2191 i}\n\n\nSubType = {i : Size} -> Natu {i} -> Natu {\u221e} -> Natu {i}\nDivType = {i : Size} -> Natu {i} -> Natu {\u221e} -> Natu {i}\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":137,"user_id":null,"body":"{-# OPTIONS --safe  --sized-types  #-}\nmodule Nat where\n\nopen import Agda.Builtin.Nat public\nopen import Agda.Builtin.Size\n\n\ndata SNat : {i : Size} \u2192 Set where\n    zero : {i : Size} \u2192 SNat {\u2191 i}\n    suc : {i : Size} \u2192 SNat {i} \u2192 SNat {\u2191 i}\n\nSubType = {i : Size} \u2192 SNat {i} \u2192 SNat {\u221e} \u2192 SNat {i}\nDivType = {i : Size} \u2192 SNat {i} \u2192 SNat {\u221e} \u2192 SNat {i}\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":138,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\nopen import Size\n\n{-\ndata Nat : Set where\n  suc : Nat \u2192 Nat\n  zero : Nat\n-}\n\ndata Nat : {i : Size} -> Set where\n  zero : {i : Size} -> Nat {\u2191 i}\n  suc : {i : Size} -> Nat {i} -> Nat {\u2191 i}\n\nSubType = {i : Size} \u2192 Nat {i} -> Nat {\u221e} -> Nat {i}\nDivType = {i : Size} \u2192 Nat {i} -> Nat {\u221e} -> Nat {i}\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":139,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\nopen import Size\n\n{-\ndata Nat : Set where\n  suc : Nat \u2192 Nat\n  zero : Nat\n-}\n\ndata Nat : {i : Size} -> Set where\n  zero : {i : Size} -> Nat {\u2191 i}\n  suc : {i : Size} -> Nat {i} -> Nat {\u2191 i}\n\nSubType = {i : Size} \u2192 Nat {i} -> Nat {\u221e} -> Nat {i}\nDivType = {i : Size} \u2192 Nat {i} -> Nat -> Nat {i}\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":140,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule Nat where\n\nopen import Agda.Builtin.Size\n\ndata Nat : Size \u2192 Set where\n  zero : \u2200 {i} \u2192 Nat i\n  suc : \u2200{i} \u2192 Nat i \u2192 Nat (\u2191 i)\n\nSubType = \u2200{i j} \u2192 Nat i -> Nat j -> Nat i\nDivType = \u2200{i j} \u2192 Nat i -> Nat j -> Nat i","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8b332197eb04000887fd63":[{"id":141,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nhalf-lemma : \u2200 (k n) \u2192 \u230a k + (k + n) \/2\u230b \u2261 k + \u230a n \/2\u230b\nhalf-lemma zero n = refl\nhalf-lemma (suc k) n\n  rewrite +-comm k (suc (k + n))\n  | +-comm (k + n) k\n  | half-lemma k n\n  = refl\n\narith-eq : \u2200 n \u2192 arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n)\n  rewrite sym (arith-eq n)\n  | +-comm n 1\n  | *-comm n (2 + n)\n  | half-lemma n (n + n * n)\n  | *-comm n (suc n)\n  = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":142,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties using (+-assoc; +-identity\u02b3; +-suc; +-comm)\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Preloaded\n\n-- apparently wasn't exported by Data.Nat.Properties??\n-- so i've copied the stdlib's proof here\n*-suc : \u2200 m n \u2192 m * suc n \u2261 m + m * n\n*-suc zero    n = refl\n*-suc (suc m) n = begin\n  suc m * suc n         \u2261\u27e8\u27e9\n  suc n + m * suc n     \u2261\u27e8 cong (suc n +_) (*-suc m n) \u27e9\n  suc n + (m + m * n)   \u2261\u27e8\u27e9\n  suc (n + (m + m * n)) \u2261\u27e8 cong suc (sym (+-assoc n m (m * n))) \u27e9\n  suc (n + m + m * n)   \u2261\u27e8 cong (\u03bb x \u2192 suc (x + m * n)) (+-comm n m) \u27e9\n  suc (m + n + m * n)   \u2261\u27e8 cong suc (+-assoc m n (m * n)) \u27e9\n  suc (m + (n + m * n)) \u2261\u27e8\u27e9\n  suc m + suc m * n     \u220e\n\narith-eq : (n : \u2115) -> arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) = begin\n  \u230a suc n * (suc n + 1) \/2\u230b                  \u2261\u27e8\u27e9\n  \u230a suc n + 1 + n * suc (n + 1) \/2\u230b          \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc (n + 1 + z) \/2\u230b) (*-suc n (n + 1)) \u27e9\n  \u230a suc n + 1 + (n + n * (n + 1)) \/2\u230b        \u2261\u27e8 cong \u230a_\/2\u230b (sym (+-assoc (suc n + 1) n (n * (n + 1)))) \u27e9\n  \u230a suc n + 1 + n + n * (n + 1) \/2\u230b          \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc z + n + n * (n + 1) \/2\u230b) (+-suc n zero) \u27e9\n  \u230a suc (suc n) + zero + n + n * (n + 1) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc (suc z) + n + n * (n + 1) \/2\u230b ) (+-identity\u02b3 n) \u27e9\n  \u230a suc (suc n) + n + n * (n + 1) \/2\u230b        \u2261\u27e8\u27e9\n  suc \u230a n + n + n * (n + 1) \/2\u230b              \u2261\u27e8 cong suc (lemma n (n * (n + 1))) \u27e9\n  suc n + \u230a n * (n + 1) \/2\u230b                  \u2261\u27e8 cong (suc n +_) (arith-eq n) \u27e9\n  arith-sum (suc n)                          \u220e\n  where\n    lemma : \u2200 m n \u2192 \u230a m + m + n \/2\u230b \u2261 m + \u230a n \/2\u230b\n    lemma zero n = refl\n    lemma (suc m) n = begin\n      \u230a suc m + suc m + n \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc z + n \/2\u230b) (+-suc m m) \u27e9\n      \u230a suc (suc m) + m + n \/2\u230b \u2261\u27e8 cong suc (lemma m n) \u27e9\n      suc (m + \u230a n \/2\u230b) \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":143,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Preloaded\n\nlem : (n m : \u2115) \u2192 \u230a n + n + m \/2\u230b \u2261 n + \u230a m \/2\u230b\nlem zero m = refl\nlem (suc n) m =\n  \u230a suc (n + (1 + n) + m) \/2\u230b\n    \u2261\u27e8 cong (\u03bb x \u2192 \u230a suc (x + m) \/2\u230b) (sym (+-assoc n 1 n)) \u27e9\n  \u230a suc (n + 1 + n + m) \/2\u230b\n    \u2261\u27e8 cong (\u03bb x\u00a0\u2192 \u230a suc (x + n + m) \/2\u230b) (+-comm n 1) \u27e9\n  suc \u230a n + n + m \/2\u230b\n    \u2261\u27e8 cong suc (lem n m) \u27e9\n  suc (n + \u230a m \/2\u230b)\n    \u220e\n\narith-eq : (n : \u2115) \u2192 arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) =\n  \u230a suc n * (suc n + 1) \/2\u230b\n    \u2261\u27e8 cong (\u03bb x \u2192 \u230a suc n * suc x \/2\u230b) (+-comm n 1) \u27e9\n  suc \u230a n + n * suc (suc n) \/2\u230b\n    \u2261\u27e8 cong (\u03bb x \u2192 suc \u230a n + x \/2\u230b) (*-suc n (suc n)) \u27e9\n  suc \u230a n + (n + n * suc n) \/2\u230b\n    \u2261\u27e8 cong (\u03bb x \u2192 suc \u230a x \/2\u230b) (sym (+-assoc n n (n * suc n))) \u27e9\n  suc \u230a n + n + n * suc n \/2\u230b\n    \u2261\u27e8 cong suc (lem n (n * suc n)) \u27e9\n  suc (n + \u230a n * suc n \/2\u230b)\n    \u2261\u27e8 cong (\u03bb x \u2192 suc (n + \u230a n * x \/2\u230b)) (+-comm 1 n) \u27e9\n  suc (n + \u230a n * (n + 1) \/2\u230b)\n    \u2261\u27e8 cong (\u03bb x \u2192 suc (n + x)) (arith-eq n) \u27e9\n  suc (n + arith-sum n)\n    \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":144,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nopen \u2261-Reasoning\n\nlemma\u2080 : \u2200 n \u2192 n + n \u2261 n * 2\nlemma\u2080 n =\n  begin\n    n + n\n  \u2261\u27e8 cong (n +_) (+-comm 0 n) \u27e9\n    n + (n + 0)\n  \u2261\u27e8 *-comm 2 n \u27e9\n    n * 2\n  \u220e\n\nlemma\u2081 : \u2200 n \u2192 suc n * (suc n + 1) \u2261 suc n * 2 + n * (n + 1)\nlemma\u2081 n =\n  begin\n    suc n * (suc n + 1)\n  \u2261\u27e8 *-distrib\u02e1-+ (suc n) 1 (n + 1) \u27e9\n    suc n * 1 + suc n * (n + 1)\n  \u2261\u27e8 cong (\u03bb x \u2192 x + suc n * (n + 1)) (*-identity\u02b3 (suc n)) \u27e9\n    suc n + suc n * (n + 1)\n  \u2261\u27e8\u27e9\n    suc n + ((n + 1) + n * (n + 1))\n  \u2261\u27e8 sym (+-assoc (suc n) (n + 1) (n * (n + 1))) \u27e9\n    suc n + (n + 1) + n * (n + 1)\n  \u2261\u27e8 cong (\u03bb x \u2192 suc n + x + n * (n + 1)) (+-comm n 1) \u27e9\n    suc n + suc n + n * (n + 1)\n  \u2261\u27e8 cong (\u03bb x \u2192 x + n * (n + 1)) (lemma\u2080 (suc n)) \u27e9\n    suc n * 2 + n * (n + 1)\n  \u220e\n\nlemma\u2082 : \u2200 n m \u2192 \u230a n * 2 + m \/2\u230b \u2261 n + \u230a m \/2\u230b\nlemma\u2082 zero m = refl\nlemma\u2082 (suc n) m = cong suc (lemma\u2082 n m)\n\narith-eq : \u2200 n \u2192 arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) =\n  begin\n    arith-formula (suc n)\n  \u2261\u27e8\u27e9\n    \u230a suc n * (suc n + 1) \/2\u230b\n  \u2261\u27e8 cong \u230a_\/2\u230b (lemma\u2081 n) \u27e9\n    \u230a suc n * 2 + n * (n + 1) \/2\u230b\n  \u2261\u27e8 lemma\u2082 (suc n) (n * (n + 1)) \u27e9\n    suc n + \u230a n * (n + 1) \/2\u230b\n  \u2261\u27e8\u27e9\n    suc n + arith-formula n\n  \u2261\u27e8 cong (\u03bb x \u2192 suc n + x) (arith-eq n) \u27e9\n    suc n + arith-sum n\n  \u2261\u27e8\u27e9\n    arith-sum (suc n)\n  \u220e\n ","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":145,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen \u2261-Reasoning\n\none-mul-id : (n : \u2115) -> 1 * n \u2261 n\none-mul-id zero = refl\none-mul-id (suc n) = +-comm (suc n) 0\n\none-mul-di : (n : \u2115) \u2192 n \u2261 1 * n\none-mul-di n = +-comm 0 n\n\nsuc-+-1 : (n : \u2115) -> suc n \u2261 n + 1\nsuc-+-1 n = begin\n  suc n\n  \u2261\u27e8\u27e9\n  0 + suc n\n  \u2261\u27e8 +-comm 0 (suc n) \u27e9\n  suc (n + 0)\n  \u2261\u27e8 cong suc (+-comm n 0) \u27e9\n  1 + n\n  \u2261\u27e8 +-comm 1 n \u27e9\n  n + 1\n  \u220e\n\nwork : (n : \u2115) \u2192 suc n + 1 + (n * suc n + n) \u2261 2 * (n + 1) + n * (n + 1)\nwork n = begin\n  suc n + 1 + (n * suc n + n)\n  \u2261\u27e8 cong (_+ (n * suc n + n)) (cong (_+ 1) (suc-+-1 n)) \u27e9\n  n + 1 + 1 + (n * suc n + n)\n  \u2261\u27e8 cong (\u03bb { x \u2192 n + 1 + 1 + (n * x + n) }) (suc-+-1 n) \u27e9\n  n + 1 + 1 + (n * (n + 1) + n)\n  \u2261\u27e8 +-assoc (n + 1) 1 (n * (n + 1) + n) \u27e9\n  n + 1 + (1 + n * (n + 1) + n)\n  \u2261\u27e8 cong ((n + 1) +_) (+-assoc 1 (n * (n + 1)) n) \u27e9\n  n + 1 + (1 + (n * (n + 1) + n))\n  \u2261\u27e8 cong ((n + 1) +_) (+-comm 1 (n * (n + 1) + n)) \u27e9\n  n + 1 + (n * (n + 1) + n + 1)\n  \u2261\u27e8 cong ((n + 1) +_) (+-assoc (n * (n + 1)) n 1) \u27e9\n  n + 1 + (n * (n + 1) + (n + 1))\n  \u2261\u27e8 +-comm (n + 1) (n * (n + 1) + (n + 1)) \u27e9\n  n * (n + 1) + (n + 1) + (n + 1)\n  \u2261\u27e8 +-assoc (n * (n + 1)) (n + 1) (n + 1) \u27e9\n  n * (n + 1) + ((n + 1) + (n + 1))\n  \u2261\u27e8 +-comm (n * (n + 1)) ((n + 1) + (n + 1)) \u27e9\n  (n + 1) + (n + 1) + n * (n + 1)\n  \u2261\u27e8 cong (\u03bb {x \u2192 (n + 1) + x + n * (n + 1)}) (one-mul-di (n + 1)) \u27e9\n  2 * (n + 1) + n * (n + 1)\n  \u220e\n\ndiv-distrib : (a : \u2115) \u2192 (b : \u2115) \u2192 \u230a 2 * a + b \/2\u230b \u2261 a + \u230a b \/2\u230b\ndiv-distrib 0 _ = refl\ndiv-distrib (suc n) m = begin\n  \u230a_\/2\u230b (2 * (suc n) + m)\n  \u2261\u27e8 cong (\u03bb {x \u2192 \u230a_\/2\u230b (2 * x + m)}) (suc-+-1 n) \u27e9\n  \u230a_\/2\u230b (2 * (n + 1) + m)\n  \u2261\u27e8 cong (\u03bb {x \u2192 \u230a_\/2\u230b (x + m)}) (*-distrib\u02e1-+ 2 n 1) \u27e9\n  \u230a_\/2\u230b (2 * n + 2 + m)\n  \u2261\u27e8 cong (\u03bb {x \u2192 \u230a_\/2\u230b (x + m)}) (+-comm (2 * n) 2) \u27e9\n  \u230a_\/2\u230b (2 + 2 * n + m)\n  \u2261\u27e8 cong \u230a_\/2\u230b (+-assoc 2 (2 * n) m) \u27e9\n  \u230a_\/2\u230b (suc (suc (2 * n + m)))\n  \u2261\u27e8\u27e9\n  suc (\u230a 2 * n + m \/2\u230b)\n  \u2261\u27e8 cong suc (div-distrib n m) \u27e9\n  suc n + \u230a m \/2\u230b\n  \u220e\n\narith-eq : (n : \u2115) -> arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) = begin\n  \u230a_\/2\u230b ((suc n) * ((suc n) + 1))\n  \u2261\u27e8\u27e9\n  \u230a_\/2\u230b ((suc n + 1) + n * (suc n + 1))\n  \u2261\u27e8 cong ( \u230a_\/2\u230b ) (cong ((suc n + 1) +_) (*-distrib\u02e1-+ n (suc n) 1)) \u27e9\n  \u230a_\/2\u230b ((suc n + 1) + (n * suc n + n * 1))\n  \u2261\u27e8 cong ( \u230a_\/2\u230b ) (cong ((suc n + 1) +_) (cong ((n * suc n) +_) (*-comm n 1))) \u27e9\n  \u230a_\/2\u230b ((suc n + 1) + (n * suc n + 1 * n))\n  \u2261\u27e8 cong ( \u230a_\/2\u230b ) (cong ((suc n + 1) +_) (cong ((n * suc n) +_) (one-mul-id n))) \u27e9\n  \u230a_\/2\u230b (suc n + 1 + (n * suc n + n))\n  \u2261\u27e8 cong ( \u230a_\/2\u230b ) (work n) \u27e9\n  \u230a_\/2\u230b (2 * (n + 1) + n * (n + 1))\n  \u2261\u27e8 div-distrib (n + 1) (n * (n + 1)) \u27e9\n  (n + 1) + \u230a n * (n + 1) \/2\u230b\n  \u2261\u27e8 cong ((n + 1) +_) (arith-eq n) \u27e9\n  (n + 1) + (arith-sum n)\n  \u2261\u27e8 cong (_+ (arith-sum n)) (+-comm n 1) \u27e9\n  arith-sum (suc n)\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":146,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Function using (_\u2218_)\nopen import Preloaded\nopen \u2261-Reasoning\n\n{-\nmodule Preloaded where\n\nopen import Data.Nat\n\narith-sum : \u2115 \u2192 \u2115\narith-sum zero = zero\narith-sum (suc n) = suc n + arith-sum n\n\narith-formula : \u2115 \u2192 \u2115\narith-formula n = \u230a n * (n + 1) \/2\u230b\n-}\n\n\ndiv-lemma : \u2200 (m n : \u2115) \u2192 \u230a m + m + n \/2\u230b \u2261 m + \u230a n \/2\u230b\ndiv-lemma zero n = refl\ndiv-lemma (suc m) n = begin\n      \u230a suc (m + suc m + n) \/2\u230b\n    \u2261\u27e8 cong (\u230a_\/2\u230b \u2218 suc \u2218 (_+ n)) (+-comm m (suc m)) \u27e9\n      suc \u230a m + m + n \/2\u230b\n    \u2261\u27e8 cong suc (div-lemma m n) \u27e9\n      refl\n\narith-eq : (n : \u2115) \u2192 arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) rewrite\n    *-distrib\u02e1-+ (suc n) (suc n) 1\n  | +-comm (n + n * suc n) (suc (n * 1))\n  | *-identity\u02b3 n\n  | sym (+-assoc n n (n * suc n))\n  | div-lemma n (n * suc n)\n  | sym (arith-eq n)\n  | +-comm n 1\n  = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":147,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen +-*-Solver\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Preloaded\n\n{-\nmodule Preloaded where\n\nopen import Data.Nat\n\narith-sum : \u2115 \u2192 \u2115\narith-sum zero = zero\narith-sum (suc n) = suc n + arith-sum n\n\narith-formula : \u2115 \u2192 \u2115\narith-formula n = \u230a n * (n + 1) \/2\u230b\n-}\n\n\u2261-elim : \u2200 {a b : \u2115} (P : \u2115 \u2192 Set) \u2192 a \u2261 b \u2192 P b \u2192 P a\n\u2261-elim _ refl p = p\n\ndata even : \u2115 \u2192 Set where\n  z-even : even zero\n  s-even : {n : \u2115} \u2192 even n \u2192 even (suc (suc n))\n\n+-even : \u2200 {p q : \u2115} \u2192 even p \u2192 even q \u2192 even (p + q)\n+-even z-even q = q\n+-even (s-even p) q = s-even (+-even p q)\n\n2*-even : (n : \u2115) \u2192 even (2 * n)\n2*-even zero = z-even\n2*-even (suc n) = \u2261-elim even (inner-lemma n) (s-even (2*-even n))\n  where\n  inner-lemma : (x : \u2115) \u2192 1 + (x + (1 + (x + zero))) \u2261 1 + (1 + 2 * x)\n  inner-lemma = solve 1 (\u03bb x \u2192 con 1 :+ (x :+ (con 1 :+ (x :+ con 0))) := con 1 :+ (con 1 :+ con 2 :* x)) refl\n\nx*sucx-even : (n : \u2115) \u2192 even (n * (n + 1))\nx*sucx-even zero = z-even\nx*sucx-even (suc n) = \u2261-elim even (inner-lemma n) (s-even (+-even (2*-even n) (x*sucx-even n)))\n  where\n  inner-lemma : (x : \u2115) \u2192 (1 + x) * ((1 + x) + 1) \u2261 1 + (1 + (2 * x + x * (x + 1)))\n  inner-lemma = solve 1 (\u03bb x \u2192 (con 1 :+ x) :* ((con 1 :+ x) :+ con 1) := con 1 :+ (con 1 :+ (con 2 :* x :+ x :* (x :+ con 1)))) refl\n\n\/2-split : {p q : \u2115} \u2192 even p \u2192 even q \u2192 \u230a p + q \/2\u230b \u2261 \u230a p \/2\u230b + \u230a q \/2\u230b\n\/2-split z-even q = refl\n\/2-split (s-even p) q = cong suc (\/2-split p q)\n\n\/2-elim : (n : \u2115) \u2192 \u230a 2 * n \/2\u230b \u2261 n\n\/2-elim zero = refl\n\/2-elim (suc n) = begin\n  \u230a 2 * suc n \/2\u230b\n    \u2261\u27e8\u27e9\n  \u230a 2 * (1 + n) \/2\u230b\n    \u2261\u27e8 cong \u230a_\/2\u230b (*-distrib\u02e1-+ 2 1 n) \u27e9\n  \u230a 2 + 2 * n \/2\u230b\n    \u2261\u27e8 \/2-split (s-even z-even) (2*-even n) \u27e9\n  \u230a 2 \/2\u230b + \u230a 2 * n \/2\u230b\n    \u2261\u27e8\u27e9\n  1 + \u230a 2 * n \/2\u230b\n    \u2261\u27e8 cong (1 +_) (\/2-elim n) \u27e9\n  1 + n\n    \u2261\u27e8\u27e9\n  suc n \u220e\n\n-- (x + 1)(x + 2)\/2 = (x^2 + 3x + 2)\/2\n--                  = (x^2 + x + 2x + 2)\/2\n--                  = (x^2 + x)\/2 + x + 1\n--                  = x + 1 + x(x + 1)\/2\nfmla-lemma : (n : \u2115) \u2192 arith-formula (suc n) \u2261 suc n + arith-formula n\nfmla-lemma n = begin\n  arith-formula (suc n)\n    \u2261\u27e8\u27e9\n  \u230a (1 + n) * (1 + n + 1) \/2\u230b\n    \u2261\u27e8 cong \u230a_\/2\u230b (inner-lemma n) \u27e9\n  \u230a 2 * (1 + n) + n * (n + 1) \/2\u230b\n    \u2261\u27e8 \/2-split (2*-even (1 + n)) (x*sucx-even n) \u27e9\n  \u230a 2 * (1 + n) \/2\u230b + \u230a n * (n + 1) \/2\u230b\n    \u2261\u27e8 cong (_+ \u230a n * (n + 1) \/2\u230b) (\/2-elim (1 + n)) \u27e9\n  suc n + arith-formula n \u220e\n  where\n    inner-lemma : (x : \u2115) \u2192 (1 + x) * (1 + x + 1) \u2261 2 * (1 + x) + x * (x + 1)\n    inner-lemma = solve 1 (\u03bb x \u2192 (con 1 :+ x) :* (con 1 :+ x :+ con 1) := con 2 :* (con 1 :+ x) :+ x :* (x :+ con 1)) refl\n\narith-eq : (n : \u2115) -> arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) = sym (arith-eq-rev n)\n  where\n  arith-eq-rev : (n : \u2115) \u2192 arith-sum (suc n) \u2261 arith-formula (suc n)\n  arith-eq-rev n = begin\n    arith-sum (suc n)\n      \u2261\u27e8\u27e9\n    suc n + arith-sum n\n      \u2261\u27e8 cong (suc n +_) (sym (arith-eq n)) \u27e9\n    suc n + arith-formula n\n      \u2261\u27e8 sym (fmla-lemma n) \u27e9\n    arith-formula (suc n) \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":148,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen import Data.Nat.Properties\n\n*-suc : \u2200 m n \u2192 m * suc n \u2261 m + m * n\n*-suc zero    n = refl\n*-suc (suc m) n = begin\n  suc m * suc n         \u2261\u27e8\u27e9\n  suc n + m * suc n     \u2261\u27e8 cong (suc n +_) (*-suc m n) \u27e9\n  suc n + (m + m * n)   \u2261\u27e8\u27e9\n  suc (n + (m + m * n)) \u2261\u27e8 cong suc (sym (+-assoc n m (m * n))) \u27e9\n  suc (n + m + m * n)   \u2261\u27e8 cong (\u03bb x \u2192 suc (x + m * n)) (+-comm n m) \u27e9\n  suc (m + n + m * n)   \u2261\u27e8 cong suc (+-assoc m n (m * n)) \u27e9\n  suc (m + (n + m * n)) \u2261\u27e8\u27e9\n  suc m + suc m * n     \u220e where open \u2261-Reasoning\n\n\n\u230an+n+m\/2\u2309\u2261n : \u2200 n m \u2192 ( \u230a (n + n + m) \/2\u230b ) \u2261 n + \u230a m \/2\u230b\n\u230an+n+m\/2\u2309\u2261n zero m = refl\n\u230an+n+m\/2\u2309\u2261n (suc n) m = begin\n    \u230a suc (n + suc n + m) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc (z + m) \/2\u230b) (+-comm n (suc n)) \u27e9\n    \u230a suc (suc (n + n + m)) \/2\u230b \u2261\u27e8 cong suc (\u230an+n+m\/2\u2309\u2261n n m) \u27e9\n    suc (n + \u230a m \/2\u230b)    \u220e where open \u2261-Reasoning\n\n\narith-eq : (n : \u2115) -> arith-formula n \u2261 arith-sum n\narith-eq 0 = refl\narith-eq (suc n) = begin\n    \u230a suc (n + 1 + n * suc (n + 1)) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc (n + 1 + z) \/2\u230b)  (*-suc n (n + 1)) \u27e9\n    \u230a suc (n + 1 + (n + n * (n + 1))) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc z \/2\u230b) (sym (+-assoc (n + 1) n (n * (n + 1)))) \u27e9\n    \u230a suc (n + 1 + n + n * (n + 1)) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 \u230a suc (z + n + n * (n + 1)) \/2\u230b) (+-comm n 1) \u27e9\n    \u230a suc (suc (n + n + n * (n + 1))) \/2\u230b \u2261\u27e8 refl \u27e9\n    suc \u230a (n + n + n * (n + 1)) \/2\u230b \u2261\u27e8 cong suc (\u230an+n+m\/2\u2309\u2261n n (n * (n + 1))) \u27e9\n    suc (n + \u230a (n * (n + 1)) \/2\u230b) \u2261\u27e8 cong (\u03bb z \u2192 suc (n + z)) (arith-eq n) \u27e9\n    suc (n + arith-sum n)    \u220e where open \u2261-Reasoning\n ","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":149,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Agda.Builtin.Sigma\nopen import Data.Sum \nopen import Data.Empty \n\nopen \u2261-Reasoning \n\nmodule codewars where\n  \n--defs \n\nEven : (n : \u2115) \u2192 Set \nEven n = \u03a3 \u2115 (\u03bb k \u2192 2 * k \u2261 n)\n\n\n--lemmas \n*-suc : \u2200 m n \u2192 m * suc n \u2261 m + m * n\n*-suc zero    n = refl\n*-suc (suc m) n = begin\n  suc m * suc n         \u2261\u27e8\u27e9\n  suc n + m * suc n     \u2261\u27e8 cong (suc n +_) (*-suc m n) \u27e9\n  suc n + (m + m * n)   \u2261\u27e8\u27e9\n  suc (n + (m + m * n)) \u2261\u27e8 cong suc (sym (+-assoc n m (m * n))) \u27e9\n  suc (n + m + m * n)   \u2261\u27e8 cong (\u03bb x \u2192 suc (x + m * n)) (+-comm n m) \u27e9\n  suc (m + n + m * n)   \u2261\u27e8 cong suc (+-assoc m n (m * n)) \u27e9\n  suc (m + (n + m * n)) \u2261\u27e8\u27e9\n  suc m + suc m * n     \u220e\n  \neven-zero : Even 0 \neven-zero = 0 , refl\n\nsuc-not-zero : {n : \u2115} \u2192 0 \u2261 suc n \u2192 \u22a5\nsuc-not-zero ()\n\nneven-one : Even 1 \u2192 \u22a5\nneven-one (suc k , hk) = suc-not-zero (sym (suc-injective \n  (trans (cong suc (sym (+-suc k (k + zero)))) hk)))\n\n\neven-suc-suc : {n : \u2115} \u2192 Even n \u2192 Even (suc (suc n))\neven-suc-suc (k , hk) = (suc k) , (cong suc (trans (+-suc k (k + zero)) \n  (cong suc hk)))\n\nsuc-suc-even : {n : \u2115} \u2192 Even (suc (suc n)) \u2192 Even n \nsuc-suc-even (suc k , hk) = k , (suc-injective (suc-injective \n  (trans (cong suc (sym (+-suc k (k + zero)))) hk)))\n  \neven-n-or-suc : (n : \u2115) \u2192 Even n \u228e Even (suc n)\neven-n-or-suc zero = inj\u2081 even-zero\neven-n-or-suc (suc n) = [ (\u03bb h \u2192 inj\u2082 (even-suc-suc h)) , (\u03bb h \u2192 inj\u2081 h) ]\u2032 \n  (even-n-or-suc n) \n\neven-div2 : {n : \u2115} \u2192 Even n \u2192 \u230a n \/2\u230b + \u230a n \/2\u230b \u2261 n\neven-div2 {zero} hn = refl\neven-div2 {suc zero} hn = \u22a5-elim (neven-one hn)\neven-div2 {suc (suc n)} hn = trans (cong suc (  +-suc \u230a n \/2\u230b \u230a n \/2\u230b)) \n  (cong (\u03bb x \u2192 suc (suc x)) (even-div2 (suc-suc-even hn)))\n\neven-prod : {a b : \u2115} \u2192 Even a \u228e Even b \u2192 Even (a * b)\neven-prod {b = b} (inj\u2081 (k , hk)) = k * b , trans (sym (*-assoc 2 k b)) \n  (cong (_* b) hk)\neven-prod {a = a} (inj\u2082 (k , hk)) = k * a , trans (sym (*-assoc 2 k a)) \n  (trans (cong (_* a) hk) (*-comm _ a))\n\nlemma : (n : \u2115) \u2192 arith-formula n + arith-formula n \u2261 n * (n + 1)\nlemma n = even-div2 (subst (\u03bb x \u2192 Even (n * x)) (+-comm 1 n) \n  (even-prod (even-n-or-suc n)))\n  \nlemma2 : (n : \u2115) \u2192 arith-sum n + arith-sum n \u2261 n * suc n \nlemma2 zero = refl\nlemma2 (suc n) = cong suc (trans (+-suc (n + arith-sum n) (n + arith-sum n)) \n  (cong suc (trans (+-assoc n (arith-sum n) (n + arith-sum n)) (cong (n +_) \n  (begin\n    arith-sum n + (n + arith-sum n) \n      \u2261\u27e8 cong (arith-sum n +_) (+-comm n (arith-sum n)) \u27e9\n    arith-sum n + (arith-sum n + n) \n      \u2261\u27e8 sym (+-assoc (arith-sum n) (arith-sum n) n) \u27e9 \n    (arith-sum n + arith-sum n) + n\n      \u2261\u27e8 cong (_+ n) (lemma2 n) \u27e9 \n    (n * suc n) + n\n      \u2261\u27e8 trans (+-comm (n * suc n) n) (sym (*-suc n (suc n))) \u27e9 \n    n * suc (suc n)\n  \u220e)))))\n  \nlemma3 : {a b : \u2115} \u2192 a + a \u2261 b + b \u2192 a \u2261 b \nlemma3 {a} {b = zero} h = i+j\u22610\u21d2i\u22610 a h\nlemma3 {suc a} {b = suc b} h = cong suc (lemma3 (suc-injective \n  (trans (sym (+-suc a a)) (trans (suc-injective h) (+-suc b b))) ))\n--solution\narith-eq : (n : \u2115) -> arith-formula n \u2261 arith-sum n\narith-eq n = lemma3 (trans (lemma n) (trans \n  (cong (n *_) (+-comm n 1)) (sym (lemma2 n))))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":150,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ArithSeq where\n\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; refl; cong; sym)\nopen Eq.\u2261-Reasoning\nopen import Data.Nat.Properties using (*-distrib\u02e1-+; +-comm; +-assoc; *-identity\u02b3; +-identity\u02b3)\nopen import Preloaded\n\n{-\nmodule Preloaded where\n\nopen import Data.Nat\n\narith-sum : \u2115 \u2192 \u2115\narith-sum zero = zero\narith-sum (suc n) = suc n + arith-sum n\n\narith-formula : \u2115 \u2192 \u2115\narith-formula n = \u230a n * (n + 1) \/2\u230b\n-}\n\narith-eq : (n : \u2115) -> arith-formula n \u2261 arith-sum n\narith-eq zero = refl\narith-eq (suc n) = arith-formula (suc n)        \n  \u2261\u27e8 refl \u27e9 \u230a suc (n + 1 + n * suc (n + 1)) \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 \u230a suc (n + 1 + n * x) \/2\u230b) (+-comm 1 (n + 1))\u27e9 \u230a suc (n + 1 + n * (n + 1 + 1)) \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 \u230a suc (n + 1 + n * x) \/2\u230b) (+-assoc n 1 1) \u27e9  \u230a suc (n + 1 + n * (n + 2)) \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 \u230a suc (n + 1 + x) \/2\u230b) (*-distrib\u02e1-+ n n 2) \u27e9 \u230a suc (n + 1 + (n * n + n * 2)) \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 \u230a suc (x + (n * n + n * 2)) \/2\u230b) (+-comm n 1) \u27e9 suc \u230a n + (n * n + n * 2) \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 suc \u230a x \/2\u230b) (sym (+-assoc n (n * n) (n * 2))) \u27e9 suc \u230a n + n * n + n * 2 \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 suc \u230a x + n * n + n * 2 \/2\u230b) (sym (*-identity\u02b3 n)) \u27e9 suc \u230a n * 1 + n * n + n * 2 \/2\u230b\n  \u2261\u27e8 cong (\u03bb x \u2192 suc \u230a x + n * 2 \/2\u230b) (sym (*-distrib\u02e1-+ n 1 n)) \u27e9 suc \u230a n * suc n + n * 2 \/2\u230b\n  \u2261\u27e8 cong suc (helper (n * suc n) n) \u27e9 suc (n + \u230a n * suc n \/2\u230b)\n  \u2261\u27e8 cong (\u03bb x \u2192 suc (n + \u230a n * x \/2\u230b)) (+-comm 1 n) \u27e9 suc (n + \u230a n * (n + 1) \/2\u230b)\n  \u2261\u27e8 cong (\u03bb x \u2192 suc (n + x)) (arith-eq n) \u27e9 suc (n + arith-sum n)\n  \u220e\n  where\n    helper : \u2200 (x y : \u2115) \u2192  \u230a x + y * 2 \/2\u230b \u2261 y + \u230a x \/2\u230b\n    helper x zero rewrite +-identity\u02b3 x = refl\n    helper x (suc y) rewrite +-comm x (suc (suc (y * 2))) | +-comm (y * 2) x | helper x y = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8b3e55b9d1190016bd3cca":[{"id":151,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\n\nsuc-\u2238 : {m n : \u2115} \u2192 n \u2264 m \u2192 suc m \u2238 n \u2261 suc (m \u2238 n)\nsuc-\u2238 {m}     {zero}  n\u2264m = refl\nsuc-\u2238 {suc m} {suc n} sn\u2264sm = suc-\u2238 (\u2264-pred sn\u2264sm)\n\ncycle-invariant : (n k : \u2115) \u2192 k \u2264 n \u2192\n  fib2 n \u2261 fibAux (fib k) (fib (suc k)) (n \u2238 k)\ncycle-invariant _       zero    k\u2264n   = refl\ncycle-invariant (suc n) (suc k) sk\u2264sn\n  rewrite cycle-invariant (suc n) k (\u2264-trans (n\u22641+n k) sk\u2264sn)\n        | suc-\u2238 (\u2264-pred sk\u2264sn)\n        | +-comm (fib k) (fib (suc k))\n  = refl\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq n rewrite cycle-invariant n n \u2264-refl | n\u2238n\u22610 n = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":152,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq n = helper 0 n\n  where\n  helper : (m n : \u2115) -> fibAux (fib m) (fib (suc m)) n \u2261 fib (m + n)\n  helper m zero rewrite +-identity\u02b3 m = refl\n  helper m (suc n) rewrite +-comm (fib m) (fib (suc m)) | +-suc m n = helper (suc m) n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":153,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\nlemma : \u2200 m n \u2192 fibAux (fib m) (fib (suc m)) n \u2261 fib (m + n)\nlemma m zero = cong fib (+-comm 0 m)\nlemma m (suc zero) = cong fib (+-comm 1 m)\nlemma m (suc (suc n)) =\n  begin\n    fibAux (fib m) (fib (suc m)) (suc (suc n))\n  \u2261\u27e8\u27e9\n    fibAux (fib (suc m)) (fib m + fib (suc m)) (suc n)\n  \u2261\u27e8 cong (\u03bb x \u2192 fibAux (fib (suc m)) x (suc n)) (+-comm (fib m) (fib (suc m))) \u27e9\n    fibAux (fib (suc m)) (fib (suc (suc m))) (suc n)\n  \u2261\u27e8 lemma (suc m) (suc n) \u27e9\n    fib (suc m + suc n)\n  \u2261\u27e8 cong fib (sym (+-suc m (suc n))) \u27e9\n    fib (m + suc (suc n))\n  \u220e\n\nfibEq : (n : \u2115) \u2192 fib2 n \u2261 fib n\nfibEq = lemma 0","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":154,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen \u2261-Reasoning\n\n-- Number 3 referring to the iterations this took to solve\nfibAuxLemma3 : ( a b n : \u2115 ) \u2192 fibAux a b (suc (suc n)) \u2261 fibAux a b (suc n) + fibAux a b n\nfibAuxLemma3 a b zero = +-comm a b\nfibAuxLemma3 a b (suc n) = begin\n  fibAux a b (suc (suc (suc n)))\n  \u2261\u27e8\u27e9\n  fibAux b (a + b) (suc (suc n))\n  \u2261\u27e8 fibAuxLemma3 b (a + b) n \u27e9\n  fibAux b (a + b) (suc n) + fibAux b (a + b) n\n  \u2261\u27e8\u27e9\n  fibAux a b (suc (suc n)) + fibAux a b (suc n)\n  \u220e\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq 0 = refl\nfibEq 1 = refl\nfibEq (suc (suc n)) = begin\n  fib2 (suc (suc n))\n  \u2261\u27e8 fibAuxLemma3 0 1 n \u27e9\n  fib2 (suc n) + fib2 n\n  \u2261\u27e8 cong ((fib2 (suc n)) +_) (fibEq n) \u27e9\n  fib2 (suc n) + fib n\n  \u2261\u27e8 cong (_+ (fib n)) (fibEq (suc n)) \u27e9\n  fib (suc n) + fib n\n  \u2261\u27e8\u27e9\n  fib (suc (suc n))\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":155,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\nlem-fibAuxStep : (a b n : \u2115) \u2192 fibAux a b (suc (suc n)) \u2261 fibAux a b (suc n) + fibAux a b n\nlem-fibAuxStep a b 0 = +-comm (fibAux a b 0) (fibAux a b 1)\nlem-fibAuxStep a b (suc n)\n  with lem-fibAuxStep b (a + b) n\n... | p = begin\n  fibAux a b (suc (suc (suc n)))                    \u2261\u27e8\u27e9\n  fibAux b (a + b) (suc (suc n))                    \u2261\u27e8 p \u27e9\n  fibAux b (a + b) (suc n) + fibAux b (a + b) n     \u2261\u27e8\u27e9\n  fibAux a b (suc (suc n)) + fibAux a b (suc n)     \u220e\n\nfibEq : (n : \u2115) \u2192 fib2 n \u2261 fib n\nfibEq 0 = refl\nfibEq 1 = refl\nfibEq (suc (suc n))\n  with fibEq n | fibEq (suc n)\n... | p | q = begin\n  fib2 (suc (suc n))                     \u2261\u27e8 lem-fibAuxStep 0 1 n \u27e9\n  fib2 (suc n) + fib2 n                  \u2261\u27e8 cong (fib2 (suc n) +_) p \u27e9\n  fib2 (suc n) + fib n                   \u2261\u27e8 cong (_+ fib n) q \u27e9\n  fib (suc n) + fib n                    \u2261\u27e8\u27e9\n  fib (suc (suc n))                      \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":156,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nlemma : (a b n : \u2115) -> fibAux a b (suc (suc n)) \u2261 fibAux a b (suc n) + fibAux a b n\nlemma a b zero = begin\n  fibAux a b (suc (suc zero)) \u2261\u27e8 refl \u27e9\n  fibAux b (a + b) (suc zero) \u2261\u27e8 refl \u27e9\n  fibAux (a + b) (a + b + b) zero \u2261\u27e8 refl \u27e9\n  (a + b) \u2261\u27e8 +-comm a b \u27e9\n  (b + a) \u2261\u27e8 refl \u27e9\n  fibAux a b (suc zero) + fibAux a b zero \u220e\nlemma a b (suc n) = begin\n  fibAux a b (suc (suc (suc n))) \u2261\u27e8 refl \u27e9\n  fibAux b (a + b) (suc (suc n)) \u2261\u27e8 lemma b (a + b) n \u27e9\n  fibAux b (a + b) (suc n) + fibAux b (a + b) n \u2261\u27e8 cong (_+ fibAux b (a + b) n) refl \u27e9\n  fibAux a b (suc (suc n)) + fibAux b (a + b) n \u2261\u27e8 cong (fibAux a b (suc (suc n)) +_) refl \u27e9\n  fibAux a b (suc (suc n)) + fibAux a b (suc n) \u220e\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq 0 = refl\nfibEq 1 = refl\nfibEq (suc (suc n)) = begin\n  fibAux 0 1 (suc (suc n)) \u2261\u27e8 lemma 0 1 n \u27e9\n  fibAux 0 1 (suc n) + fibAux 0 1 n \u2261\u27e8 cong (_+ fibAux 0 1 n) (fibEq (suc n)) \u27e9\n  fib (suc n) + fibAux 0 1 n \u2261\u27e8 cong (fib (suc n) +_) (fibEq n) \u27e9\n  fib (suc n) + fib n \u2261\u27e8 refl \u27e9\n  fib (suc (suc n)) \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":157,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq\nopen Eq.\u2261-Reasoning\n\nfibAux-lemma : \u2200 m n \u2192 fibAux (fib m) (fib (suc m)) n \u2261 fib (m + n)\nfibAux-lemma m 0 rewrite +-identity\u02b3 m = refl\nfibAux-lemma m (suc n) =\n  begin\n    fibAux (fib m) (fib (suc m)) (suc n)\n  \u2261\u27e8\u27e9\n    fibAux (fib (suc m)) (fib m + fib (suc m)) n\n  \u2261\u27e8 cong (\u03bb x \u2192 fibAux (fib (suc m)) x n) (+-comm (fib m) (fib (suc m))) \u27e9\n    fibAux (fib (suc m)) (fib (suc m) + fib m) n\n  \u2261\u27e8\u27e9\n    fibAux (fib (suc m)) (fib (suc (suc m))) n\n  \u2261\u27e8 fibAux-lemma (suc m) n \u27e9\n    fib (suc m + n)\n  \u2261\u27e8 cong fib (sym (+-suc m n)) \u27e9\n    fib (m + suc n)\n  \u220e\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq n = fibAux-lemma 0 n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":158,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nlemma : (a b n : \u2115) \u2192 fibAux a b (suc (suc n)) \u2261 fibAux a b (suc n) + fibAux a b n\nlemma a b zero = +-comm a b\nlemma a b (suc n)\n  rewrite lemma b (a + b) n\n  = refl\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq 0 = refl\nfibEq 1 = refl\nfibEq (suc (suc n)) =\n  sym (begin\n  fib (suc n) + fib n\n    \u2261\u27e8 cong\u2082 _+_ (sym (fibEq (suc n))) (sym (fibEq n)) \u27e9\n  fib2 (suc n) + fib2 n\n    \u2261\u27e8 sym (lemma 0 1 n) \u27e9\n  fib2 (suc (suc n))\n    \u220e)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":159,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nfiba : \u2200 a b c n \u2192 c \u2261 b + a \u2192 fibAux c (b + c) n \u2261 fibAux b c n + fibAux a b n\nfiba a b c zero cba = cba\nfiba a b c (suc n) cba = begin\n                    fibAux (b + c) (c +     (b + c)) n              \u2261\u27e8 cong (\u03bb t \u2192 fibAux (b + c) (t + (b + c)) n) cab \u27e9\n                    fibAux (b + c) (a + b + (b + c)) n              \u2261\u27e8 fiba b (a + b) (b + c) n (trans (+-comm b c) (cong (\u03bb t \u2192 t + b) cab))  \u27e9\n                    fibAux (a + b) (b + c) n + fibAux b (a + b) n   \u2261\u27e8 cong (\u03bb t \u2192 fibAux t (b + c) n + fibAux b (a + b) n ) (sym cab) \u27e9\n                    fibAux c (b + c) n + fibAux b (a + b) n         \u220e\n                  where \n                    cab = trans cba (+-comm b a)\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq 0             = refl \nfibEq 1             = refl\nfibEq (suc (suc n)) = sym (begin\n                      fib (suc (suc n)) \u2261\u27e8\u27e9 \n                      fib (suc n) + fib n \u2261\u27e8 cong\u2082 _+_ (sym (fibEq (suc n))) (sym (fibEq n)) \u27e9\n                      fibAux 1 1 n + fibAux 0 1 n \u2261\u27e8 sym (fiba 0 1 1 n refl) \u27e9\n                      fibAux 1 2 n \u220e)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":160,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Fib where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\n\n\n+sucRightSuc : \u2200 (x y : \u2115) -> suc (x + y) \u2261 x + suc y\n+sucRightSuc zero y = refl\n+sucRightSuc (suc x) y rewrite +sucRightSuc x y = refl\n\n+0 : \u2200 (n : \u2115) -> n + 0 \u2261 n\n+0 0 = refl\n+0 (suc n) rewrite +0 n = refl\n\n+c : \u2200 (n m : \u2115) -> n + m \u2261 m + n\n+c zero m rewrite +0 m = refl\n+c (suc n) m rewrite +c n m | +sucRightSuc m n = refl\n\nfibAuxLemma : (m n : \u2115) -> fibAux (fib m) (fib (suc m)) n \u2261 fib (m + n)\nfibAuxLemma m zero rewrite +0 m = refl\nfibAuxLemma m (suc n) rewrite +c (fib m) (fib (suc m))\n                      | fibAuxLemma (suc m) n\n                      | +sucRightSuc m n = refl\n\n\nfibEq : (n : \u2115) -> fib2 n \u2261 fib n\nfibEq = fibAuxLemma 0\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8b4215a99b9c000d07d7b2":[{"id":161,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nsumEqLemma : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 (acc : \u2115)\n  \u2192 sumAux acc f n \u2261 sumSimple f n + acc\nsumEqLemma f zero acc = refl\nsumEqLemma f (suc n) acc \n  rewrite sumEqLemma f n (f (suc n) + acc) | +-comm (f (suc n)) (sumSimple f n) | +-assoc (sumSimple f n) (f (suc n)) acc = refl\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f n rewrite sym (+-identity\u02b3 (sumSimple f n)) = sumEqLemma f n 0\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":162,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat\n\nsumSimple : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumSimple f zero = f zero\nsumSimple f (suc n) = f (suc n) + sumSimple f n\n\nsumAux : \u2115 \u2192 (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumAux acc f zero = f zero + acc\nsumAux acc f (suc n) = sumAux (f (suc n) + acc) f n\n\nsumTail : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumTail = sumAux zero\n-}\n\nlemma : \u2200 m f n \u2192 sumAux m f n \u2261 sumSimple f n + m\nlemma m f zero = refl\nlemma m f (suc n) = begin\n  sumAux (f (suc n) + m) f n \u2261\u27e8 lemma (f (suc n) + m) f n \u27e9\n  sumSimple f n + (f (suc n) + m) \u2261\u27e8 sym (+-assoc (sumSimple f n) (f (suc n)) m) \u27e9\n  sumSimple f n + f (suc n) + m \u2261\u27e8 cong (_+ m) (+-comm (sumSimple f n) (f (suc n))) \u27e9\n  f (suc n) + sumSimple f n + m \u220e\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f n = begin\n  sumAux zero f n \u2261\u27e8 lemma zero f n \u27e9\n  sumSimple f n + zero \u2261\u27e8 +-identity\u02b3 (sumSimple f n) \u27e9\n  sumSimple f n \u220e\n  \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":163,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat\n\nsumSimple : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumSimple f zero = f zero\nsumSimple f (suc n) = f (suc n) + sumSimple f n\n\nsumAux : \u2115 \u2192 (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumAux acc f zero = f zero + acc\nsumAux acc f (suc n) = sumAux (f (suc n) + acc) f n\n\nsumTail : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumTail = sumAux zero\n-}\n\n\nsubgoal2 : \u2200 (f : \u2115 \u2192 \u2115) (n init : \u2115) \u2192 sumAux (suc init) f n \u2261 suc (sumAux init f n)\nsubgoal2 f zero init rewrite +-suc (f 0) init = refl\nsubgoal2 f (suc n) init rewrite +-suc (f (suc n)) init = subgoal2 f n (f (suc n) + init)\n\nsubgoal : \u2200 (f : \u2115 \u2192 \u2115) (n init : \u2115) \u2192 sumAux init f n \u2261 init + sumTail f n\nsubgoal f n zero = refl\nsubgoal f n (suc init) rewrite subgoal2 f n init = cong suc (subgoal f n init) \n\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f zero rewrite +-identity\u02b3 (f 0) = refl\nsumEq f (suc n) rewrite +-identity\u02b3 (f (suc n)) rewrite subgoal f n (f (suc n)) rewrite sumEq f n = refl\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":164,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nopen \u2261-Reasoning\n\nlemma : \u2200 acc f n \u2192 sumAux acc f n \u2261 sumSimple f n + acc\nlemma acc f zero = refl\nlemma acc f (suc n) =\n  begin\n    sumAux acc f (suc n)\n  \u2261\u27e8\u27e9\n    sumAux (f (suc n) + acc) f n\n  \u2261\u27e8 lemma (_ + acc) f n \u27e9\n    sumSimple f n + (f (suc n) + acc)\n  \u2261\u27e8 sym (+-assoc _ (f (suc n)) acc) \u27e9\n    sumSimple f n + f (suc n) + acc\n  \u2261\u27e8 cong (_+ acc) (+-comm _ (f (suc n))) \u27e9\n    f (suc n) + sumSimple f n + acc\n  \u2261\u27e8\u27e9\n    sumSimple f (suc n) + acc\n  \u220e\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f n = trans (lemma 0 f n) (+-comm _ 0)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":165,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Preloaded\n\nsumAuxLemma : (m : \u2115) \u2192 (f : (\u2115 \u2192 \u2115)) \u2192 (n : \u2115) \u2192 (x : \u2115) \u2192 sumAux (f x + m) f n \u2261 f x + sumAux m f n\nsumAuxLemma m f zero x = begin\n  sumAux (f x + m) f 0                      \u2261\u27e8\u27e9\n  f 0 + (f x + m)                           \u2261\u27e8 +-comm (f 0) (f x + m) \u27e9\n  f x + m + f 0                             \u2261\u27e8 +-assoc (f x) m (f 0) \u27e9\n  f x + (m + f 0)                           \u2261\u27e8 cong ((f x) +_) (+-comm m (f 0)) \u27e9\n  f x + sumAux m f 0                        \u220e\nsumAuxLemma m f (suc n) x = begin\n  sumAux (f x + m) f (suc n)                \u2261\u27e8\u27e9\n  sumAux (f (suc n) + (f x + m)) f n        \u2261\u27e8 cong (\u03bb y \u2192 sumAux y f n) (+-comm (f (suc n)) (f x + m)) \u27e9\n  sumAux (f x + m + f (suc n)) f n          \u2261\u27e8 cong (\u03bb y \u2192 sumAux y f n) (+-assoc (f x) m (f (suc n))) \u27e9\n  sumAux (f x + (m + f (suc n))) f n        \u2261\u27e8 sumAuxLemma (m + f (suc n)) f n x \u27e9\n  f x + sumAux (m + f (suc n)) f n          \u2261\u27e8 cong (\u03bb y \u2192 f x + sumAux y f n) (+-comm m (f (suc n))) \u27e9\n  f x + sumAux m f (suc n)                  \u220e\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f zero = +-comm (f 0) 0\nsumEq f (suc n) = begin\n  sumAux 0 f (suc n)                        \u2261\u27e8\u27e9\n  sumAux (f (suc n) + 0) f n                \u2261\u27e8 sumAuxLemma 0 f n (suc n) \u27e9\n  f (suc n) + sumAux 0 f n                  \u2261\u27e8 cong ((f (suc n)) +_) (sumEq f n) \u27e9\n  f (suc n) + sumSimple f n                 \u2261\u27e8\u27e9\n  sumSimple f (suc n)                       \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":166,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen import Function using (_\u2218_)\nopen \u2261-Reasoning\n\nlem : \u2200 {f : \u2115 \u2192 \u2115} {n : \u2115} (acc : \u2115) \u2192 sumAux acc f n \u2261 acc + sumAux zero f n\nlem {f} {zero} acc rewrite +-identity\u02b3 (f zero) | +-comm (f zero) acc = refl\nlem {f} {suc n} acc rewrite\n      lem {f} {n} (f (suc n) + acc)\n    | +-comm (f (suc n)) acc\n    | +-assoc acc (f (suc n)) (sumAux 0 f n)\n    | sym (lem {f} {n} (f (suc n)))\n    | +-identity\u02b3 (f (suc n))\n    = refl\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f zero rewrite +-identity\u02b3 (f zero) = refl\nsumEq f (suc n) = begin\n      sumAux 0 f (suc n)\n    \u2261\u27e8\u27e9\n      sumAux (f (suc n) + 0) f n\n    \u2261\u27e8 cong (\u03bb x -> sumAux x f n) (+-identity\u02b3 (f (suc n))) \u27e9\n      sumAux (f (suc n)) f n\n    \u2261\u27e8 lem {f} {n} (f (suc n)) \u27e9\n      f (suc n) + sumTail f n\n    \u2261\u27e8 cong (f (suc n) +_) (sumEq f n) \u27e9\n      refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":167,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f n rewrite sym (+-identity\u02b3 (sumSimple f n)) = aux n zero\n  where\n  aux : (n acc : \u2115) \u2192 sumAux acc f n \u2261 sumSimple f n + acc\n  aux zero acc = refl\n  aux (suc n) acc rewrite +-comm (f (suc n)) (sumSimple f n) | +-assoc (sumSimple f n) (f (suc n)) acc = aux n (f (suc n) + acc)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":168,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nsumSimpleOfLength : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115 \u2192 \u2115\nsumSimpleOfLength f n zero = zero\nsumSimpleOfLength f zero (suc l) = f zero\nsumSimpleOfLength f (suc n) (suc l) = f (suc n) + sumSimpleOfLength f n l\n\nl=0 : \u2200 f n \u2192 sumSimpleOfLength f n (suc n) \u2261 sumSimple f n\nl=0 f zero = refl\nl=0 f (suc n) rewrite l=0 f n = refl\n\nfn+ : \u2200 f n l \u2192 f n + sumSimpleOfLength f (l + n) l \u2261 sumSimpleOfLength f (l + n) (suc l)\nfn+ f zero zero = +-identity\u02b3 (f zero)\nfn+ f (suc n) zero = refl\nfn+ f n (suc l)\n  rewrite sym (+-assoc (f n) (f (suc (l + n))) (sumSimpleOfLength f (l + n) l))\n  | +-comm (f n) (f (suc (l + n)))\n  | +-assoc (f (suc (l + n))) (f n) (sumSimpleOfLength f (l + n) l)\n  | fn+ f n l = refl\n\nf0+ : \u2200 f l \u2192 f zero + sumSimpleOfLength f l l \u2261 sumSimpleOfLength f l (suc l)\nf0+ f l = subst (\u03bb l+0|l \u2192 f 0 + sumSimpleOfLength f l+0|l l \u2261 sumSimpleOfLength f l+0|l (suc l)) (+-identity\u02b3 l) (fn+ f 0 l)\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f n = aux n 0\n  where\n  aux : (n l : \u2115) \u2192 sumAux (sumSimpleOfLength f (l + n) l) f n \u2261 sumSimple f (l + n)\n  aux zero zero = +-identity\u02b3 (f zero)\n  aux zero (suc l)\n    rewrite +-identity\u02b3 l\n    | sym (+-assoc (f zero) (f (suc l)) (sumSimpleOfLength f l l))\n    | +-comm (f 0) (f (suc l))\n    | +-assoc (f (suc l)) (f zero) (sumSimpleOfLength f l l)\n    | f0+ f l\n    | l=0 f l\n    = refl\n  aux (suc n) l rewrite fn+ f (suc n) l | +-suc l n = aux n (suc l)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":169,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen \u2261-Reasoning\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat\n\nsumSimple : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumSimple f zero = f zero\nsumSimple f (suc n) = f (suc n) + sumSimple f n\n\nsumAux : \u2115 \u2192 (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumAux acc f zero = f zero + acc\nsumAux acc f (suc n) = sumAux (f (suc n) + acc) f n\n\nsumTail : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumTail = sumAux zero\n-}\n\nsumAuxLemma : (acc n : \u2115) (f : \u2115 \u2192 \u2115) \u2192 sumAux acc f n \u2261 sumAux 0 f n + acc \nsumAuxLemma acc zero f = cong (_+ acc) (sym (+-identity\u02b3 (f zero)))\nsumAuxLemma acc (suc n) f = \n  begin \n    sumAux (f (suc n) + acc) f n \n      \u2261\u27e8 sumAuxLemma (f (suc n) + acc) n f \u27e9\n    sumAux 0 f n + (f (suc n) + acc) \n      \u2261\u27e8 sym (+-assoc (sumAux zero f n) (f (suc n)) acc) \u27e9\n    (sumAux 0 f n + f (suc n)) + acc \n      \u2261\u27e8 cong (_+ acc) (sym (sumAuxLemma (f (suc n)) n f)) \u27e9\n    sumAux (f (suc n)) f n + acc \n      \u2261\u27e8 cong (\u03bb m \u2192 sumAux m f n + acc) (sym (+-identity\u02b3 (f (suc n)))) \u27e9\n    sumAux (f (suc n) + 0) f n + acc\n  \u220e\n  \nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f zero = +-identity\u02b3 (f zero)\nsumEq f (suc n) =\n  begin \n    sumAux (f (suc n) + 0) f n\n      \u2261\u27e8 sumAuxLemma (f (suc n) + zero) n f \u27e9\n    sumAux 0 f n + (f (suc n) + 0)\n      \u2261\u27e8 cong (sumAux 0 f n +_) (+-identity\u02b3 (f (suc n))) \u27e9\n    sumAux 0 f n + f (suc n)\n      \u2261\u27e8 +-comm (sumAux zero f n) (f (suc n)) \u27e9\n    f (suc n) + sumAux zero f n\n      \u2261\u27e8 cong (f (suc n) +_) (sumEq f n) \u27e9\n    f (suc n) + sumSimple f n \n  \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":170,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sum where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n{-\nPreloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat\n\nsumSimple : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumSimple f zero = f zero\nsumSimple f (suc n) = f (suc n) + sumSimple f n\n\nsumAux : \u2115 \u2192 (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumAux acc f zero = f zero + acc\nsumAux acc f (suc n) = sumAux (f (suc n) + acc) f n\n\nsumTail : (\u2115 \u2192 \u2115) \u2192 \u2115 \u2192 \u2115\nsumTail = sumAux zero\n-}\n\n\nsumAuxStep : (a1 a2 : \u2115) \u2192 (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumAux (a1 + a2) f n \u2261 a2 + sumAux a1 f n \nsumAuxStep a1 a2 f zero = begin\n    f zero + (a1 + a2) \u2261\u27e8 sym (+-assoc (f 0) a1 a2) \u27e9\n    f zero + a1 + a2 \u2261\u27e8 +-comm (f 0 + a1) a2 \u27e9\n    a2 + (f zero + a1)    \u220e where open \u2261-Reasoning\nsumAuxStep a1 a2 f (suc n) =  begin\n    sumAux (f (suc n) + (a1 + a2)) f n \u2261\u27e8 sym (cong (\u03bb x \u2192 sumAux x f n) (+-assoc (f (suc n)) a1 a2)) \u27e9\n    sumAux (f (suc n) + a1 + a2) f n \u2261\u27e8 sumAuxStep (f (suc n) + a1) a2 f n \u27e9\n    a2 + sumAux (f (suc n) + a1) f n    \u220e where open \u2261-Reasoning\n\n\nsumEq : (f : \u2115 \u2192 \u2115) \u2192 (n : \u2115) \u2192 sumTail f n \u2261 sumSimple f n\nsumEq f zero rewrite +-identity\u02b3 (f 0) = refl\nsumEq f (suc n) = begin\n    sumAux (f (suc n) + zero) f n \u2261\u27e8 cong (\u03bb x \u2192 sumAux x f n) (+-identity\u02b3 (f (suc n))) \u27e9\n    sumAux (0 + f (suc n)) f n \u2261\u27e8 sumAuxStep 0 (f (suc n)) f n \u27e9\n    f (suc n) + (sumAux 0 f n) \u2261\u27e8 cong (f (suc n) +_) (sumEq f n) \u27e9\n    f (suc n) + sumSimple f n    \u220e where open \u2261-Reasoning\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8b4799133e6c0009c7b096":[{"id":171,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool hiding (_\u2264_)\nopen import Data.Nat.Properties\nopen import Function.Base\nopen import Preloaded\n\nopen \u2261-Reasoning\n\ndiv-mod2-eq : \u2200 e \u2192 let (e' , b) = div-mod2 e in if b then e \u2261 1 + 2 * e' else e \u2261 2 * e'\ndiv-mod2-eq zero = refl\ndiv-mod2-eq (suc zero) = refl\ndiv-mod2-eq (suc (suc e)) with div-mod2 e in p | div-mod2-eq e\n... | e' , false | refl = cong suc (sym (+-suc _ _))\n... | e' , true  | refl = cong (suc \u2218 suc) (sym (+-suc _ _))\n\nlemma : \u2200 n k \u2192 2 * n \u2264 1 + k \u2192 n \u2264 k\nlemma zero k _ = z\u2264n\nlemma (suc n) k p = \u2264-trans (\u2264-reflexive (cong suc (sym (+-identity\u02b3 n)))) (m+n\u2264o\u21d2n\u2264o _ (\u2264-pred p)) \n\npow-aux-eq : \u2200 k b e \u2192 e \u2264 k \u2192 pow-sqr-aux k b e \u2261 b ^ e\npow-aux-eq zero b zero p = refl\npow-aux-eq (suc k) b zero p = refl\npow-aux-eq (suc k) b e@(suc n) p with div-mod2 e | div-mod2-eq e\n... | e' , false | q =\n      trans (pow-aux-eq k (b * b) e'\n              (lemma _ _ (\u2264-trans (\u2264-reflexive (sym q)) p))) $\n            begin (b * b) ^ e'       \u2261\u02d8\u27e8 cong ((_^ e') \u2218 (b *_)) (*-identity\u02b3 b) \u27e9\n                  (b * (b * 1)) ^ e' \u2261\u27e8 ^-*-assoc b 2 e' \u27e9\n                  b ^ (2 * e')       \u2261\u02d8\u27e8 cong (b ^_) q \u27e9\n                  b * (b ^ n)        \u220e \n... | e' , true  | q = cong (b *_) $\n      trans (pow-aux-eq k (b * b) e'\n              (\u2264-trans (m+n\u2264o\u21d2m\u2264o e' (\u2264-pred (\u2264-reflexive (sym q)))) (\u2264-pred p))) $\n            begin (b * b) ^ e'       \u2261\u02d8\u27e8 cong ((_^ e') \u2218 (b *_)) (*-identity\u02b3 b) \u27e9\n                  (b * (b * 1)) ^ e' \u2261\u27e8 ^-*-assoc b 2 e' \u27e9\n                  b ^ (2 * e')       \u2261\u02d8\u27e8 cong (b ^_) (suc-injective q) \u27e9\n                  b ^ n              \u220e\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = pow-aux-eq e b e \u2264-refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":172,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat.Properties\nopen import Preloaded\nopen \u2261-Reasoning\n\nx*x\u2261x^2 : \u2200 a \u2192 a * a \u2261 a ^ 2\nx*x\u2261x^2 a = begin\n  (0 * a + a) * a \u2261\u27e8 cong (_* a) (+-comm 0 a) \u27e9\n  (a ^ 0) * a * a \u2261\u27e8 cong (_* a) (*-comm 1 a) \u27e9\n  a ^ 1 * a       \u2261\u27e8 *-comm (a ^ 1) a \u27e9\n  a ^ 2           \u220e\n\nx+x\u22612*x : \u2200 a \u2192 a + a \u2261 2 * a\nx+x\u22612*x a rewrite +-comm a 0 = refl\n\nunsuc : \u2115 \u2192 \u2115\nunsuc zero = zero\nunsuc (suc n) = n\n\ndiv-lemma1 : \u2200 a b \u2192 div-mod2 (suc a) \u2261 (b , true) \u2192 2 * b \u2261 a\ndiv-lemma1 zero zero e = refl\ndiv-lemma1 (suc (suc a)) (suc b) e rewrite +-comm b 0 | +-comm b (suc b) | x+x\u22612*x b = cong suc (cong suc (div-lemma1 a b (cong (map\u2081 unsuc) e)))\n\ndiv-lemma3 : \u2200 a b \u2192 div-mod2 a \u2261 (b , false) \u2192 2 * b \u2261 a\ndiv-lemma3 zero zero e = refl\ndiv-lemma3 (suc (suc a)) (suc b) e rewrite +-comm b 0 | +-comm b (suc b) | x+x\u22612*x b = cong suc (cong suc (div-lemma3 a b (cong (map\u2081 unsuc) e)))\n\nfst : \u2115 \u00d7 Bool \u2192 \u2115\nfst (a , b) = a\n\ndiv-lemma2 : \u2200 a \u2192 a \u2265 fst (div-mod2 a)\ndiv-lemma2 zero = z\u2264n\ndiv-lemma2 (suc zero) = z\u2264n\ndiv-lemma2 (suc (suc a)) = s\u2264s (\u2264-step (div-lemma2 a))\n\nhelper2 : \u2200 a b \u2192 (suc a) \u2261 (suc b) \u2192 a \u2261 b\nhelper2 a .a refl = refl\n\nhelper : \u2200 a b \u2192 div-mod2 (suc a) \u2261 (b , true) \u2192 a \u2265 b\nhelper zero zero e = z\u2264n\nhelper (suc (suc a)) (suc b) e with cong fst e\n... | refl = s\u2264s (\u2264-step (helper a b (cong (map\u2081 unsuc) e)))\n\nhelper3 : \u2200 a b \u2192 div-mod2 (suc a) \u2261 (b , false) \u2192 a \u2265 b\nhelper3 (suc zero) (suc zero) e = s\u2264s z\u2264n\nhelper3 (suc (suc (suc a))) (suc (suc b)) e with cong fst e\n... | refl = s\u2264s (s\u2264s (\u2264-step (div-lemma2 a)))\n\n\nlemma : \u2200 a b c \u2192 a \u2265 c \u2192 pow-sqr-aux a b c \u2261 b ^ c\nlemma zero b zero lt = refl\nlemma (suc a) b zero lt = refl\nlemma (suc a) b (suc c) (s\u2264s lt) with div-mod2 (suc c) | inspect div-mod2 (suc c)\n... | c' , false | [ eq ] = begin\n  pow-sqr-aux a (b * b) c' \u2261\u27e8 lemma a (b * b) c' (\u2264-trans (helper3 c c' eq) lt) \u27e9\n  (b * b) ^ c'             \u2261\u27e8 cong (_^ c') (x*x\u2261x^2 b) \u27e9\n  (b ^ 2) ^ c'             \u2261\u27e8 ^-*-assoc b 2 c' \u27e9\n  b ^ (2 * c')             \u2261\u27e8 cong (b ^_) (div-lemma3 (suc c) c' eq) \u27e9\n  b * b ^ c                \u220e\n... | c' , true | [ eq ] = begin\n  b * pow-sqr-aux a (b * b) c' \u2261\u27e8 cong (b *_) (lemma a (b * b) c' (\u2264-trans (helper c c' eq) lt)) \u27e9\n  b * ((b * b) ^ c') \u2261\u27e8 cong (\u03bb v \u2192 b * (v ^ c')) (x*x\u2261x^2 b) \u27e9\n  b * ((b ^ 2) ^ c') \u2261\u27e8 cong (b *_) (^-*-assoc b 2 c') \u27e9\n  b * (b ^ (2 * c')) \u2261\u27e8 cong (\u03bb v \u2192 b * (b ^ v)) (div-lemma1 c c' eq) \u27e9\n  b * b ^ c \u220e\n\n\na\u2265a : \u2200 a \u2192 a \u2265 a\na\u2265a zero = z\u2264n\na\u2265a (suc a) = s\u2264s (a\u2265a a)\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = lemma e b e (a\u2265a e)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":173,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool hiding (_<_; _\u2264_)\nopen import Data.Nat.Properties\nopen import Preloaded\n\nopen \u2261-Reasoning\n\ndiv-mod2-spec : \u2200 n \u2192 let q , r = div-mod2 n in 2 * q + (if r then 1 else 0) \u2261 n\ndiv-mod2-spec 0 = refl\ndiv-mod2-spec 1 = refl\ndiv-mod2-spec (suc (suc n)) with div-mod2 n | div-mod2-spec n\n... | q , r | eq rewrite +-suc q (q + 0) | eq = refl\n\ndiv-mod2-lt : \u2200 n \u2192 0 < n \u2192 proj\u2081 (div-mod2 n) < n\ndiv-mod2-lt 0 lt = lt\ndiv-mod2-lt 1 lt = lt\ndiv-mod2-lt 2 lt = s\u2264s (s\u2264s z\u2264n)\ndiv-mod2-lt (suc (suc (suc n))) lt with\n  div-mod2 (suc n) | div-mod2-lt (suc n) (s\u2264s z\u2264n)\n... | q , r | ih = \u2264-step (s\u2264s ih)\n\npow-lemma : \u2200 b e \u2192 (b * b) ^ e \u2261 b ^ (2 * e)\npow-lemma b e = begin\n  (b * b) ^ e \u2261\u27e8 cong (\u03bb t \u2192 (b * t) ^ e) (sym (*-identity\u02b3 b)) \u27e9\n  (b ^ 2) ^ e \u2261\u27e8 ^-*-assoc b 2 e \u27e9\n  b ^ (2 * e) \u220e\n\npow-sqr-lemma : \u2200 k b e \u2192 e \u2264 k \u2192 pow-sqr-aux k b e \u2261 b ^ e\npow-sqr-lemma 0 _ 0 _ = refl\npow-sqr-lemma (suc k) _ 0 _ = refl\npow-sqr-lemma (suc k) b (suc e) (s\u2264s le) with\n  div-mod2 (suc e) | div-mod2-spec (suc e) | div-mod2-lt (suc e) (s\u2264s z\u2264n)\n... | e' , false | eq | lt = begin\n  pow-sqr-aux k (b * b) e' \u2261\u27e8 pow-sqr-lemma k (b * b) e' (\u2264-trans (\u2264-pred lt) le) \u27e9\n  (b * b) ^ e' \u2261\u27e8 pow-lemma b e' \u27e9\n  b ^ (2 * e') \u2261\u27e8 cong (b ^_) (trans (sym (+-identity\u02b3 (e' + (e' + 0)))) eq) \u27e9\n  b ^ suc e \u220e\n... | e' , true | eq | lt = cong (b *_) (begin\n  pow-sqr-aux k (b * b) e' \u2261\u27e8 pow-sqr-lemma k (b * b) e' (\u2264-trans (\u2264-pred lt) le) \u27e9\n  (b * b) ^ e' \u2261\u27e8 pow-lemma b e' \u27e9\n  b ^ (2 * e') \u2261\u27e8 cong (b ^_) (suc-injective (trans (+-comm 1 _) eq)) \u27e9\n  b ^ e \u220e)\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = pow-sqr-lemma e b e \u2264-refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":174,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat.Properties\nopen import Data.Sum\nopen import Data.Empty\nopen import Data.Product.Properties\n\nopen import Preloaded\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool\n\ndiv-mod2 : \u2115 \u2192 \u2115 \u00d7 Bool\ndiv-mod2 0 = 0 , false\ndiv-mod2 (suc 0) = 0 , true\ndiv-mod2 (suc (suc n)) = let q , r = div-mod2 n in suc q , r\n\n-- The first argument (k) helps Agda to prove\n-- that the function terminates\npow-sqr-aux : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115\npow-sqr-aux 0 _ _ = 1\npow-sqr-aux _ _ 0 = 1\npow-sqr-aux (suc k) b e with div-mod2 e\n... | e' , false = pow-sqr-aux k (b * b) e'\n... | e' , true = b * pow-sqr-aux k (b * b) e'\n\npow-sqr : \u2115 \u2192 \u2115 \u2192 \u2115\npow-sqr b e = pow-sqr-aux e b e\n-}\n\n-- product lemmas \n\neq-couple : \u2200 {l} {A B : Set l} {a c : A} {b d : B} \u2192 a \u2261 c \u2192 b \u2261 d \u2192 (a , b) \u2261 (c , d)\neq-couple refl refl = refl\n\neq-p1 : \u2200 {l} {A B : Set l} {a c : A} {b d : B} \u2192 (a , b) \u2261 (c , d) \u2192 a \u2261 c \neq-p1 refl = refl\n\neq-p2 : \u2200 {l} {A B : Set l} {a c : A} {b d : B} \u2192 (a , b) \u2261 (c , d) \u2192 b \u2261 d\neq-p2 refl = refl\n\n-- div-mod2 lemmas\n\nlemma-ineq-div2 : \u2200 e \u2192 proj\u2081 (div-mod2 (suc e)) \u2264 e \nlemma-ineq-div2 zero = z\u2264n\nlemma-ineq-div2 (suc zero) = s\u2264s z\u2264n\nlemma-ineq-div2 (suc (suc e)) = s\u2264s (\u2264-trans (lemma-ineq-div2 e) (n\u22641+n e))\n\ndiv-mod2-suc : \u2200 e \u2192 let q , r = div-mod2 e in div-mod2 (suc e) \u2261 \n    (if r then ((suc q) , false) else (q , true))\ndiv-mod2-suc zero = refl\ndiv-mod2-suc (suc zero) = refl\ndiv-mod2-suc (suc (suc e)) with proj\u2082 (div-mod2 e) | div-mod2-suc e \n... | true  | h = eq-couple (cong suc (eq-p1 h)) (eq-p2 h)\n... | false | h = eq-couple (cong suc (eq-p1 h)) (eq-p2 h)\n--\n-- rec lemmas \n\nstrong-induction : (P : \u2115 \u2192 Set) \u2192 (\u2200 n \u2192 (\u2200 m \u2192 m < n \u2192 P m) \u2192 P n) \u2192 (\u2200 n \u2192 P n)\nstrong-induction P hrec n = helper-strong n n \u2264-refl where \n    helper-strong : \u2200 t p \u2192 p \u2264 t \u2192 P p \n    helper-strong zero .zero z\u2264n = hrec zero (\u03bb m ())\n    helper-strong (suc t) .zero z\u2264n = helper-strong t zero z\u2264n\n    helper-strong (suc t) .(suc _) (s\u2264s p\u2264t) = hrec (suc _) \n        \u03bb {r (s\u2264s r\u2264m) \u2192 helper-strong t r (\u2264-trans r\u2264m p\u2264t)}\n        \n--- pow lemmas \n\nterm-arg-irr : \u2200 e k b \u2192 e \u2264 k \u2192 pow-sqr b e \u2261 pow-sqr-aux k b e \nterm-arg-irr = strong-induction (\u03bb e \u2192\n    (k b : \u2115) (h : e \u2264 k) \u2192 pow-sqr-aux e b e \u2261 pow-sqr-aux k b e) lemma-strong-ind where \n\n    lemma-strong-ind : (e : \u2115) \u2192\n        ((m : \u2115) \u2192\n        m < e \u2192 (k b : \u2115) \u2192 m \u2264 k \u2192 pow-sqr-aux m b m \u2261 pow-sqr-aux k b m) \u2192\n        (k b : \u2115) \u2192 e \u2264 k \u2192 pow-sqr-aux e b e \u2261 pow-sqr-aux k b e\n    lemma-strong-ind e hrec zero b h = subst (\u03bb x \u2192 pow-sqr b e \u2261 pow-sqr-aux x b e) \n        (n\u22640\u21d2n\u22610 h) refl\n    lemma-strong-ind zero hrec (suc k) b h = refl\n    lemma-strong-ind (suc e) hrec (suc k) b h with div-mod2 (suc e) | lemma-ineq-div2 e\n    ...  | q , false | he = trans (sym (hrec q (s\u2264s he) e (b * b) he)) \n        (hrec q (s\u2264s he) k (b * b) (\u2264-trans he (\u2264-pred h)))\n    ...  | q , true  | he = cong (b *_) (trans (sym (hrec q (s\u2264s he) e (b * b) he)) \n        (hrec q (s\u2264s he) k (b * b) (\u2264-trans he (\u2264-pred h))))\n\nrem-aux-lemma : \u2200 b e \u2192 let q , r = div-mod2 e in \n    pow-sqr b e \u2261 (if r then b else 1) * pow-sqr (b * b) q \nrem-aux-lemma b zero = refl\nrem-aux-lemma b (suc e) with div-mod2 (suc e) | lemma-ineq-div2 e\n... | q , true  | he = cong (b *_) (sym (term-arg-irr q e (b * b) he))\n... | q , false | he = trans (sym (term-arg-irr q e (b * b) he)) \n    (sym (+-identity\u02b3 (pow-sqr-aux q (b * b) q)))\n\nsame-rec-rel : \u2200 e b \u2192 pow-sqr b (suc e) \u2261 b * pow-sqr b e\nsame-rec-rel e = strong-induction (\u03bb e \u2192 \u2200 b \u2192 pow-sqr b (suc e) \u2261 b * pow-sqr b e) \n    lemma-strong-ind e where \n\n    lemma-strong-ind : (e : \u2115) \u2192 ((r : \u2115) \u2192 r < e \u2192 (b : \u2115) \n        \u2192 pow-sqr b (suc r) \u2261 b * pow-sqr b r) \u2192 (b : \u2115) \n        \u2192 pow-sqr b (suc e) \u2261 b * pow-sqr b e\n    lemma-strong-ind e hrec b with div-mod2 e | div-mod2 (suc e) | lemma-ineq-div2 e \n        | div-mod2-suc e | rem-aux-lemma b e\n    ... | q2 , false | q , true  | he | he2 | he3 = cong (b *_) (trans (sym \n        (term-arg-irr q e (b * b) he)) (subst\u2082 (\u03bb n m \u2192 pow-sqr (b * b) n \u2261 m) \n        (sym (eq-p1 he2)) (sym (trans he3 (+-identity\u02b3 (pow-sqr-aux q2 (b * b) q2)))) \n        refl))\n    ... | q2 , true  | q , false | he | he2 | he3 = trans (sym (term-arg-irr q e (b * b) he)) \n        (subst\u2082 (\u03bb n m \u2192 pow-sqr (b * b) n \u2261 b * m) (sym (eq-p1 he2)) (sym he3) \n        (trans (hrec q2 (subst (\u03bb u \u2192 u \u2264 e) (eq-p1 he2) he) (b * b)) \n        (*-assoc b b (pow-sqr-aux q2 (b * b) q2))))\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b zero = refl\npow-eq b (suc e) = trans (same-rec-rel e b) (cong (b *_) (pow-eq b e))  ","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":175,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties using (\u2264-refl; \u2264-step; \u2264-trans; +-comm; +-assoc; *-assoc)\nopen import Data.Product\nopen import Data.Bool\nopen import Preloaded\n\n-- stdlib Data.Nat.Properties:\n\u230an\/2\u230b\u2264n : \u2200 n \u2192 \u230a n \/2\u230b \u2264 n\n\u230an\/2\u230b\u2264n zero          = z\u2264n\n\u230an\/2\u230b\u2264n (suc zero)    = z\u2264n\n\u230an\/2\u230b\u2264n (suc (suc n)) = s\u2264s (\u2264-step (\u230an\/2\u230b\u2264n n))\n\ndiv\u2261\u230a\/2\u230b : (n : \u2115) \u2192 proj\u2081 (div-mod2 n) \u2261 \u230a n \/2\u230b\ndiv\u2261\u230a\/2\u230b zero = refl\ndiv\u2261\u230a\/2\u230b (suc zero) = refl\ndiv\u2261\u230a\/2\u230b (suc (suc n)) = cong suc (div\u2261\u230a\/2\u230b n)\n\ndiv-n\u2264n : (n : \u2115) \u2192 proj\u2081 (div-mod2 n) \u2264 n\ndiv-n\u2264n n rewrite div\u2261\u230a\/2\u230b n = \u230an\/2\u230b\u2264n n\n\ndiv-s\u2264n : (n : \u2115) \u2192 proj\u2081 (div-mod2 (suc n)) \u2264 n\ndiv-s\u2264n zero = z\u2264n\ndiv-s\u2264n (suc n) = s\u2264s (div-n\u2264n n)\n\ndiv-mod2-alter : (n : \u2115) \u2192 proj\u2082 (div-mod2 n) \u2261 not (proj\u2082 (div-mod2 (suc n)))\ndiv-mod2-alter zero = refl\ndiv-mod2-alter (suc zero) = refl\ndiv-mod2-alter (suc (suc n)) = div-mod2-alter n\n\nbin-to-int : Bool \u2192 \u2115\nbin-to-int false = 0\nbin-to-int true = 1\n\ndiv-mod2-\u2261 : (n : \u2115) \u2192 bin-to-int (proj\u2082 (div-mod2 n)) + proj\u2081 (div-mod2 n) \u2261 proj\u2081 (div-mod2 (suc n))\ndiv-mod2-\u2261 zero = refl\ndiv-mod2-\u2261 (suc zero) = refl\ndiv-mod2-\u2261 (suc (suc n))\n  rewrite sym (+-assoc (bin-to-int (proj\u2082 (div-mod2 n))) 1 (proj\u2081 (div-mod2 n)))\n        | +-comm (bin-to-int (proj\u2082 (div-mod2 n))) 1\n  = cong suc (div-mod2-\u2261 n)\n\npow-sqr-aux-hasten : (aux mid base power : \u2115) \u2192 power \u2264 mid \u2192 mid \u2264 aux \u2192 pow-sqr-aux aux base power \u2261 pow-sqr-aux mid base power\npow-sqr-aux-hasten zero zero _ _ _ _ = refl\npow-sqr-aux-hasten (suc _) zero _ zero _ _ = refl\npow-sqr-aux-hasten (suc _) (suc _) _ zero _ _ = refl\npow-sqr-aux-hasten (suc aux) (suc mid) base (suc power) (s\u2264s power\u2264mid) (s\u2264s mid\u2264aux) with div-mod2 (suc power) | div-s\u2264n power\n... | sp\/2 , true | sp\/2\u2264power = cong (base *_) (pow-sqr-aux-hasten aux mid (base * base) sp\/2 (\u2264-trans sp\/2\u2264power power\u2264mid) mid\u2264aux)\n... | sp\/2 , false | sp\/2\u2264power = pow-sqr-aux-hasten aux mid (base * base) sp\/2 (\u2264-trans sp\/2\u2264power power\u2264mid) mid\u2264aux\n\npow-sqr-aux-suc : (aux base power : \u2115) \u2192 power \u2264 aux \u2192 pow-sqr-aux (suc aux) base (suc power) \u2261 base * pow-sqr-aux aux base power\npow-sqr-aux-suc zero _ zero _ = refl\npow-sqr-aux-suc (suc _) _ zero _ = refl\npow-sqr-aux-suc (suc aux) base (suc power) (s\u2264s power\u2264aux) with div-mod2 power | div-mod2 (suc power) | div-mod2-alter power | div-n\u2264n power | div-s\u2264n power | div-mod2-\u2261 power\n... | p\/2 , false | .(bin-to-int false + p\/2) , true | _ | spower\/2\u2264power | power\/2\u2264power | refl\n  rewrite pow-sqr-aux-suc aux (base * base) p\/2 (\u2264-trans power\/2\u2264power power\u2264aux)\n        | *-assoc base base (pow-sqr-aux aux (base * base) p\/2)\n  = refl\n... | p\/2 , true | .(bin-to-int true + p\/2) , false | _ | spower\/2\u2264power | power\/2\u2264power | refl\n  rewrite pow-sqr-aux-hasten aux (suc p\/2) (base * base) (suc p\/2) \u2264-refl (\u2264-trans power\/2\u2264power power\u2264aux)\n        | pow-sqr-aux-hasten (suc aux) (suc p\/2) (base * base) (suc p\/2) \u2264-refl (\u2264-trans (\u2264-step power\/2\u2264power) (s\u2264s power\u2264aux))\n  = refl\n\npow-eq : \u2200 base power \u2192 pow-sqr base power \u2261 base ^ power\npow-eq _ zero = refl\npow-eq base (suc power)\n  rewrite pow-sqr-aux-suc power base power \u2264-refl\n        | pow-eq base power\n  = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":176,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule Solution where\n\nopen import Data.Bool\n  using (Bool; false; true; if_then_else_)\nopen import Data.Nat\n  using (\u2115; zero; suc; _\u2264_; z\u2264n; s\u2264s; _*_; _^_)\nopen import Data.Nat.Properties\n  using (suc-injective; \u2264-pred; \u2264-refl; n\u22641+n; *-identity\u02e1;\n         *-mono\u02e1-<; +-*-suc; ^-*-assoc; ^-distrib\u02e1-+-*; ^-identity\u02b3;\n         module \u2264-Reasoning)\nopen import Data.Product\n  using (_\u00d7_; _,_)\nopen import Function\n  using (_\u2218_; id)\nopen import Relation.Binary.PropositionalEquality\n  using (_\u2261_; refl; cong; sym; module \u2261-Reasoning)\n\nopen import Preloaded\n\ndiv-mod2-inv : \u2115 \u00d7 Bool \u2192 \u2115\ndiv-mod2-inv (q , r) = (if r then suc else id) (2 * q)\n\n\u2115\u2192\u2115\u00d7Bool\u2192\u2115 : \u2200 n \u2192 div-mod2-inv (div-mod2 n) \u2261 n\n\u2115\u2192\u2115\u00d7Bool\u2192\u2115 zero = refl\n\u2115\u2192\u2115\u00d7Bool\u2192\u2115 (suc zero) = refl\n\u2115\u2192\u2115\u00d7Bool\u2192\u2115 (suc (suc n)) with div-mod2 n | \u2115\u2192\u2115\u00d7Bool\u2192\u2115 n\n... | (q , false) | ih = begin\n        div-mod2-inv (suc q , false)  \u2261\u27e8\u27e9\n        2 * suc q                     \u2261\u27e8 +-*-suc 2 q \u27e9\n        suc (suc (2 * q))             \u2261\u27e8 cong (suc \u2218 suc) ih \u27e9\n        suc (suc n)                   \u220e\n        where open \u2261-Reasoning\n... | (q , true) | ih = begin\n        div-mod2-inv (suc q , true)  \u2261\u27e8\u27e9\n        suc (2 * suc q)              \u2261\u27e8 cong suc (+-*-suc 2 q) \u27e9\n        suc (suc (suc (2 * q)))      \u2261\u27e8 cong (suc \u2218 suc) ih \u27e9\n        suc (suc n)                  \u220e\n        where open \u2261-Reasoning\n\npow-eq-aux : \u2200 k b e \u2192 e \u2264 k \u2192 pow-sqr-aux k b e \u2261 b ^ e\npow-eq-aux 0 _ 0 \u2264-refl = refl\npow-eq-aux 0 _ (suc e) ()\npow-eq-aux (suc k) _ 0 z\u2264s = refl\npow-eq-aux (suc k) b (suc e) (s\u2264s e\u2264k) with div-mod2 (suc e) | \u2115\u2192\u2115\u00d7Bool\u2192\u2115 (suc e)\n... | 0 , false | ()\n... | 0 , true | ev rewrite sym (suc-injective ev) = begin\n        b * pow-sqr-aux k (b * b) 0  \u2261\u27e8 cong (b *_) (pow-eq-aux k (b * b) 0 e\u2264k) \u27e9\n        b * (b * b) ^ 0              \u2261\u27e8\u27e9\n        b * 1                        \u2261\u27e8\u27e9\n        b * b ^ 0                    \u220e\n        where open \u2261-Reasoning\n... | suc e' , false | ev = begin\n        pow-sqr-aux k (b * b) (suc e')  \u2261\u27e8 pow-eq-aux k (b * b) (suc e') (\u2264-pred ev') \u27e9\n        (b * b) ^ (suc e')              \u2261\u27e8 sym (cong (\u03bb z \u2192 (b * z) ^ (suc e')) (^-identity\u02b3 b)) \u27e9\n        (b * b ^ 1) ^ (suc e')          \u2261\u27e8\u27e9\n        (b ^ 2) ^ (suc e')              \u2261\u27e8 ^-*-assoc b 2 (suc e') \u27e9\n        b ^ (2 * (suc e'))              \u2261\u27e8 cong (b ^_) ev \u27e9\n        b ^ (suc e)                     \u220e\n        where ev' : suc (suc e') \u2264 suc k\n              ev' = begin-strict\n                      suc e'        \u2261\u27e8 sym (*-identity\u02e1 (suc e')) \u27e9\n                      1 * (suc e')  <\u27e8 *-mono\u02e1-< e' (s\u2264s (s\u2264s (z\u2264n {0}))) \u27e9\n                      2 * (suc e')  \u2261\u27e8 ev \u27e9\n                      suc e         \u2264\u27e8 s\u2264s e\u2264k \u27e9\n                      suc k         \u220e\n                      where open \u2264-Reasoning\n              open \u2261-Reasoning\n... | suc e' , true  | ev = begin\n        b * pow-sqr-aux k (b * b) (suc e')  \u2261\u27e8 cong (b *_) (pow-eq-aux k (b * b) (suc e') (\u2264-pred ev')) \u27e9\n        b * (b * b) ^ (suc e')              \u2261\u27e8 sym (cong (\u03bb z \u2192 b * (b * z) ^ (suc e')) (^-identity\u02b3 b)) \u27e9\n        b * (b * b ^ 1) ^ (suc e')          \u2261\u27e8\u27e9\n        b * (b ^ 2) ^ (suc e')              \u2261\u27e8 cong (b *_) (^-*-assoc b 2 (suc e')) \u27e9\n        b * b ^ (2 * (suc e'))              \u2261\u27e8\u27e9\n        b ^ (suc (2 * (suc e')))            \u2261\u27e8 cong (b ^_) ev \u27e9\n        b ^ (suc e)                         \u220e\n        where ev' : suc (suc e') \u2264 suc k\n              ev' = begin-strict\n                      suc e'        \u2261\u27e8 sym (*-identity\u02e1 (suc e')) \u27e9\n                      1 * (suc e')  <\u27e8 *-mono\u02e1-< e' (s\u2264s (s\u2264s (z\u2264n {0}))) \u27e9\n                      2 * (suc e')  \u2261\u27e8 suc-injective ev \u27e9\n                      e             \u2264\u27e8 e\u2264k \u27e9\n                      k             \u2264\u27e8 n\u22641+n k \u27e9\n                      suc k         \u220e\n                      where open \u2264-Reasoning\n              open \u2261-Reasoning\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b zero = refl\npow-eq b (suc e) = pow-eq-aux (suc e) b (suc e) \u2264-refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":177,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat.Properties\nopen import Preloaded\nopen \u2261-Reasoning\n\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool\n\ndiv-mod2 : \u2115 \u2192 \u2115 \u00d7 Bool\ndiv-mod2 0 = 0 , false\ndiv-mod2 (suc 0) = 0 , true\ndiv-mod2 (suc (suc n)) = let q , r = div-mod2 n in suc q , r\n\n-- The first argument (k) helps Agda to prove\n-- that the function terminates\npow-sqr-aux : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115\npow-sqr-aux 0 _ _ = 1\npow-sqr-aux _ _ 0 = 1\npow-sqr-aux (suc k) b e with div-mod2 e\n... | e' , false = pow-sqr-aux k (b * b) e'\n... | e' , true = b * pow-sqr-aux k (b * b) e'\n\npow-sqr : \u2115 \u2192 \u2115 \u2192 \u2115\npow-sqr b e = pow-sqr-aux e b e\n-}\n\n\neval : Bool \u2192 \u2115\neval true = 1\neval false = 0\n\nrevert-div-mod : \u2200 (n q : \u2115) \u2192 (r : Bool) \u2192 div-mod2 n \u2261 (q , r) \u2192 2 * q + eval r \u2261 n  \nrevert-div-mod 0 .0 .false refl = refl\nrevert-div-mod 1 .0 .true refl = refl\nrevert-div-mod (suc (suc n)) (suc q) r refl = begin\n  2 * (suc q) + eval r \u2261\u27e8 cong (_+ eval r) (*-distrib\u02e1-+ 2 1 q) \u27e9\n  2 + 2 * q + eval r \u2261\u27e8 cong (2 +_) (revert-div-mod n q r refl) \u27e9\n  2 + n \u220e\n\nsimple-ineq : \u2200 a b \u2192 a Data.Nat.\u2264 b + a\nsimple-ineq zero b = z\u2264n\nsimple-ineq (suc n) b rewrite +-comm b (suc n) | +-comm n b = s\u2264s (simple-ineq n b)\n\nreduce-sum : \u2200 (n b : \u2115) \u2192  n + n \u2261 (suc b) \u2192 n Data.Nat.\u2264 b\nreduce-sum (suc n) b refl = simple-ineq (suc n) n \n\nreduce-sum-refl : \u2200 (n b : \u2115) \u2192 n + n \u2261 b \u2192 n Data.Nat.\u2264 b\nreduce-sum-refl zero b p = z\u2264n\nreduce-sum-refl (suc n) b refl rewrite +-comm n (suc n) = s\u2264s (simple-ineq n (suc n))\n\nnormalize : \u2200 (a b n : \u2115) \u2192 (a + (a + zero) + n) \u2261 b \u2192 n + a + a \u2261 b\nnormalize a b n p rewrite cong (n +_) (sym (+-identity\u02b3 a)) | +-assoc n (a + 0) a | +-comm n (a + 0 + a) | +-comm (a + 0) a = p\n\ninterchange-power : \u2200 b e \u2192 (b * b) ^ e \u2261 b ^ (e + e)\ninterchange-power b e rewrite cong (b *_) (sym (*-identity\u02b3 b)) | ^-*-assoc b 2 e  | +-identity\u02b3 e = refl\n\nproof:aux\u2261pow : \u2200 (k b e : \u2115) \u2192 (e Data.Nat.\u2264 k) \u2192 pow-sqr-aux k b e \u2261 b ^ e\nproof:aux\u2261pow zero b zero p = refl\nproof:aux\u2261pow (suc k) b zero p = refl\nproof:aux\u2261pow (suc k) b (suc e) p with div-mod2 (suc e) | inspect div-mod2 (suc e)\n... | (e' , false) | [ pf ] = let proofeq = normalize e' (suc e) 0 (revert-div-mod (suc e) e' false pf) in begin\n  pow-sqr-aux k (b * b) e' \u2261\u27e8 proof:aux\u2261pow k (b * b) e' (\u2264-trans (reduce-sum e' e proofeq) (\u2264-pred p)) \u27e9\n  (b * b) ^ e' \u2261\u27e8 interchange-power b e' \u27e9\n  b ^ (e' + e') \u2261\u27e8 cong (b ^_) (proofeq) \u27e9\n  b ^ (suc e) \u220e\n... | e' , true | [ pf ]  = let proofeq = normalize e' (suc e) 1 (revert-div-mod (suc e) e' true pf) in begin\n  b * pow-sqr-aux k (b * b) e' \u2261\u27e8 cong (b *_) (proof:aux\u2261pow k (b * b) e' (\u2264-trans (reduce-sum-refl e' e (suc-injective proofeq)) (\u2264-pred p))) \u27e9\n  b * (b * b) ^ e' \u2261\u27e8 cong (b *_) (interchange-power b e') \u27e9\n  b * b ^ (e' + e') \u2261\u27e8 cong (\u03bb x \u2192 b * b ^ x) (suc-injective proofeq) \u27e9\n  b * b ^ e \u2261\u27e8\u27e9 \n  (b ^ (suc e)) \u220e\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = proof:aux\u2261pow e b e \u2264-refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":178,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Function\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool hiding (_\u2264_)\nopen import Data.Nat.Properties\nopen import Relation.Binary.Reasoning.PartialOrder (\u2264-poset)\nopen import Data.Empty\nopen import Data.Nat.Solver\nopen import Data.Product.Properties\n\nopen +-*-Solver\n\nopen import Preloaded\n\ndiv-mod2-\u2264 : \u2200 n \u2192 proj\u2081 (div-mod2 n) \u2264 n\ndiv-mod2-\u2264 zero = z\u2264n\ndiv-mod2-\u2264 (suc zero) = z\u2264n\ndiv-mod2-\u2264 (suc (suc n)) = begin\n    suc (proj\u2081 (div-mod2 n))\n  \u2264\u27e8 s\u2264s (div-mod2-\u2264 n) \u27e9\n    suc n\n  \u2264\u27e8 n\u22641+n (suc n) \u27e9\n    suc (suc n)\n  \u220e\n\ndiv-mod2-suc-\u2264 : \u2200 n \u2192 proj\u2081 (div-mod2 (suc n)) \u2264 n\ndiv-mod2-suc-\u2264 zero = z\u2264n\ndiv-mod2-suc-\u2264 (suc n) = s\u2264s (div-mod2-\u2264 n)\n\npow-sqr-aux-sound : \u2200 b e \u2192 \u2200 k\u2081 k\u2082 \u2192 e \u2264 k\u2081 \u2192 e \u2264 k\u2082 \u2192 pow-sqr-aux k\u2081 b e \u2261 pow-sqr-aux k\u2082 b e\npow-sqr-aux-sound b .0 zero zero z\u2264n z\u2264n = refl\npow-sqr-aux-sound b .0 zero (suc k\u2082) z\u2264n e\u2264k\u2082 = refl\npow-sqr-aux-sound b .0 (suc k\u2081) zero e\u2264k\u2081 z\u2264n = refl\npow-sqr-aux-sound b zero (suc k\u2081) (suc k\u2082) e\u2264k\u2081 e\u2264k\u2082 = refl\npow-sqr-aux-sound b e@(suc e-1) (suc k\u2081) (suc k\u2082) (s\u2264s e-1\u2264k\u2081) (s\u2264s e-1\u2264k\u2082) with div-mod2 e | inspect div-mod2 e\n... | e' , false | [ eq ] = let eq' = ,-injective\u02e1 eq in\n  pow-sqr-aux-sound (b * b) e' k\u2081 k\u2082\n    (begin\n      e'\n    \u2261\u02d8\u27e8 eq' \u27e9\n      proj\u2081 (div-mod2 e)\n    \u2264\u27e8 div-mod2-suc-\u2264 e-1 \u27e9\n      e-1\n    \u2264\u27e8 e-1\u2264k\u2081 \u27e9\n      k\u2081\n    \u220e)\n    ((begin\n      e'\n    \u2261\u02d8\u27e8 eq' \u27e9\n      proj\u2081 (div-mod2 e)\n    \u2264\u27e8 div-mod2-suc-\u2264 e-1 \u27e9\n      e-1\n    \u2264\u27e8 e-1\u2264k\u2082 \u27e9\n      k\u2082\n    \u220e))\n... | e' , true  | [ eq ] = let eq' = ,-injective\u02e1 eq in\n  cong (_*_ b) (pow-sqr-aux-sound (b * b) e' k\u2081 k\u2082\n    (begin\n      e'\n    \u2261\u02d8\u27e8 eq' \u27e9\n      proj\u2081 (div-mod2 e)\n    \u2264\u27e8 div-mod2-suc-\u2264 e-1 \u27e9\n      e-1\n    \u2264\u27e8 e-1\u2264k\u2081 \u27e9\n      k\u2081\n    \u220e)\n    (begin\n      e'\n    \u2261\u02d8\u27e8 eq' \u27e9\n      proj\u2081 (div-mod2 e)\n    \u2264\u27e8 div-mod2-suc-\u2264 e-1 \u27e9\n      e-1\n    \u2264\u27e8 e-1\u2264k\u2082 \u27e9\n      k\u2082\n    \u220e))\n  \nlemma-sqr-exp : \u2200 b e \u2192 b ^ (2 * e) \u2261 (b * b) ^ e\nlemma-sqr-exp b zero = refl\nlemma-sqr-exp zero (suc e) = refl\nlemma-sqr-exp b@(suc b-1) (suc e) = begin-equality\n    b ^ (2 * suc e)\n  \u2261\u27e8 cong (_^_ b) {2 * suc e} {suc (suc (2 * e))} (cong suc (+-suc e (e + zero))) \u27e9\n    b * (b * b ^ (2 * e))\n  \u2261\u27e8 sym (*-assoc b b (b ^ (2 * e))) \u27e9\n    (b * b) * b ^ (2 * e)\n  \u2261\u27e8 (cong (_*_ (b * b)) \u2218 lemma-sqr-exp b) e \u27e9\n    (b * b) * (b * b) ^ e\n  \u2261\u27e8\u27e9\n    (b * b) ^ suc e\n  \u220e\n\nlemma-divmod2-suc : \u2200 n m b \u2192 div-mod2 (suc (suc n)) \u2261 (suc m , b) \u2192 div-mod2 n \u2261 (m , b)\nlemma-divmod2-suc zero zero false eq = refl\nlemma-divmod2-suc (suc zero) zero true eq = refl\nlemma-divmod2-suc (suc (suc n)) (suc m) b eq with div-mod2 n\nlemma-divmod2-suc (suc (suc n)) (suc .m') .b' refl | m' , b' = refl\n\nlemma-even : \u2200 n m \u2192 div-mod2 n \u2261 (m , false) \u2192 n \u2261 2 * m\nlemma-even zero zero eq = refl\nlemma-even (suc (suc n)) (suc m) eq = cong suc (trans ((cong suc \u2218 lemma-even n m \u2218 lemma-divmod2-suc n m false) eq) (sym (+-suc m (m + 0))))\n\nlemma-odd : \u2200 n m \u2192 div-mod2 n \u2261 (m , true) \u2192 n \u2261 suc (2 * m)\nlemma-odd (suc zero) zero eq = refl\nlemma-odd (suc (suc n)) (suc m) eq = cong (suc \u2218 suc) (trans ((lemma-odd n m \u2218 lemma-divmod2-suc n m true) eq) (sym (+-suc m (m + zero))))\n\npow-eq-aux : \u2200 k b e \u2192 e \u2264 k \u2192 pow-sqr-aux k b e \u2261 b ^ e\npow-eq-aux zero b zero e\u2264k = refl\npow-eq-aux (suc k) b zero e\u2264k = refl\npow-eq-aux (suc k) b e@(suc e-1) (s\u2264s e-1\u2264k) with div-mod2 e | inspect div-mod2 e\n... | e' , false | [ eq ] = let eq' = ,-injective\u02e1 eq in begin-equality\n    pow-sqr-aux k (b * b) e'\n  \u2261\u27e8 pow-eq-aux k (b * b) e' (begin\n        e'\n      \u2261\u02d8\u27e8 eq' \u27e9\n        proj\u2081 (div-mod2 e)\n      \u2264\u27e8 div-mod2-suc-\u2264 e-1 \u27e9\n        e-1\n      \u2264\u27e8 e-1\u2264k \u27e9\n        k\n      \u220e) \u27e9\n    (b * b) ^ e'\n  \u2261\u02d8\u27e8 lemma-sqr-exp b e' \u27e9\n    b ^ (2 * e')\n  \u2261\u02d8\u27e8 cong (_^_ b) (lemma-even e e' eq) \u27e9\n    b ^ e\n  \u220e\n... | e' , true  | [ eq ] = let eq' = ,-injective\u02e1 eq in begin-equality\n    b * pow-sqr-aux k (b * b) e'\n  \u2261\u27e8 cong (_*_ b) (pow-eq-aux k (b * b) e' (begin\n        e'\n      \u2261\u02d8\u27e8 eq' \u27e9\n        proj\u2081 (div-mod2 e)\n      \u2264\u27e8 div-mod2-suc-\u2264 e-1 \u27e9\n        e-1\n      \u2264\u27e8 e-1\u2264k \u27e9\n        k\n      \u220e)) \u27e9\n    b * ((b * b) ^ e')\n  \u2261\u02d8\u27e8 cong (_*_ b) (lemma-sqr-exp b e') \u27e9\n    b * (b ^ (2 * e'))\n  \u2261\u27e8\u27e9\n    b ^ (suc (2 * e'))\n  \u2261\u02d8\u27e8 cong (_^_ b) (lemma-odd e e' eq) \u27e9\n    b ^ e\n  \u220e\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = pow-eq-aux e b e \u2264-refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":179,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; refl; cong; sym)\nopen Eq.\u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\nopen import Data.Nat\nimport Data.Bool\nopen Data.Bool using (Bool; true; false)\nopen import Data.Product\nopen import Data.Nat.Properties\nopen import Preloaded\n\npow-aux : \u2200 b e \u2192 (b * b) ^ e \u2261 b ^ (2 * e)\npow-aux b zero = refl\npow-aux b (suc e) =\n  begin\n    b * b * ((b * b) ^ e)\n  \u2261\u27e8 cong (b * b *_) (pow-aux b e) \u27e9\n    b * b * (b ^ (e + (e + zero)))\n  \u2261\u27e8 *-assoc b b (b ^ (e + (e + zero))) \u27e9\n    b * (b * (b ^ (e + (e + zero))))\n  \u2261\u27e8 cong (\u03bb{x \u2192 b * (b ^ x)}) (sym (+-suc e (e + zero))) \u27e9\n    b * b ^ (e + suc (e + zero))\n  \u220e\n\ndiv2< : \u2200 n \u2192 n > 0 \u2192 proj\u2081 (div-mod2 n) < n\ndiv2< (suc zero)          n>0 = n>0\ndiv2< (suc (suc zero))    n>0 = s\u2264s (s\u2264s z\u2264n)\ndiv2< (suc (suc (suc n))) n>0 = \u2264-step (s\u2264s (div2< (suc n) (s\u2264s z\u2264n)))\n\nbool\u2192int : Bool \u2192 \u2115\nbool\u2192int true = 1\nbool\u2192int false = 0\n\ndiv2-prop : \u2200 n \u2192 (bool\u2192int (proj\u2082 (div-mod2 n))) + 2 * (proj\u2081 (div-mod2 n)) \u2261 n\ndiv2-prop zero          = refl\ndiv2-prop (suc zero)    = refl\ndiv2-prop (suc (suc n)) with div-mod2 n | div2-prop n\n... | q , r | pf =\n  begin\n    bool\u2192int r + suc (q + suc (q + zero))\n  \u2261\u27e8 cong (\u03bb{x \u2192 bool\u2192int r + suc x}) (+-suc _ _) \u27e9\n    bool\u2192int r + suc (suc (q + (q + zero)))\n  \u2261\u27e8 +-suc _ _ \u27e9\n    suc (bool\u2192int r + (suc (q + (q + zero))))\n  \u2261\u27e8 cong suc (+-suc _ _) \u27e9\n    suc (suc (bool\u2192int r + (q + (q + zero))))\n  \u2261\u27e8 cong suc (cong suc pf) \u27e9\n    suc (suc n)\n  \u220e\n\n+-mono : \u2200 a b \u2192 a \u2264 a + b\n+-mono zero b    = z\u2264n\n+-mono (suc a) b = s\u2264s (+-mono a b)\n\n+-mono\u2032 : \u2200 a \u2192 a \u2264 suc a\n+-mono\u2032 zero = z\u2264n\n+-mono\u2032 (suc a) = s\u2264s (+-mono\u2032 a)\n\npow-eq-aux : \u2200 k b e \u2192 k \u2265 e \u2192 pow-sqr-aux k b e \u2261 b ^ e\npow-eq-aux zero    b zero          k\u2265e = refl\npow-eq-aux (suc k) b zero          k\u2265e = refl\npow-eq-aux (suc k) b (suc zero)    k\u2265e = cong (_*_ b) (pow-eq-aux k (b * b) zero z\u2264n)\npow-eq-aux (suc k) b (suc (suc e)) (s\u2264s k\u2265e) with div-mod2 e | div2-prop e\n... | q , false | refl =\n  begin\n    pow-sqr-aux k (b * b) (suc q)\n  \u2261\u27e8 pow-eq-aux k (b * b) (suc q) (\u2264-trans (s\u2264s (+-mono q (q + 0))) k\u2265e) \u27e9\n    (b * b) ^ (suc q)\n  \u2261\u27e8\u27e9\n    b * b * (b * b) ^ q\n  \u2261\u27e8 cong (b * b *_) (pow-aux b q) \u27e9\n    b * b * b ^ (2 * q)\n  \u2261\u27e8 *-assoc b b (b ^ (2 * q)) \u27e9\n    b ^ (2 + 2 * q)\n  \u2261\u27e8\u27e9\n    b ^ (suc (suc e))\n  \u220e\n... | q , true | refl =\n  begin\n    b * pow-sqr-aux k (b * b) (suc q)\n  \u2261\u27e8 cong (b *_) (pow-eq-aux k (b * b) (suc q) ( \u2264-trans (+-mono\u2032 _) (\u2264-trans (s\u2264s (s\u2264s (+-mono q (q + 0)))) k\u2265e))) \u27e9\n    b * (b * b) ^ (suc q)\n  \u2261\u27e8\u27e9\n    b * (b * b * (b * b) ^ q)\n  \u2261\u27e8 cong (b *_) (cong (b * b *_) (pow-aux b q)) \u27e9\n    b * (b * b * b ^ (2 * q))\n  \u2261\u27e8 cong (b *_) (*-assoc b b (b ^ (2 * q))) \u27e9\n    b * (b ^ (2 + 2 * q))\n  \u2261\u27e8\u27e9\n    b ^ (suc (suc e))\n  \u220e\n\npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = pow-eq-aux e b e \u2264-refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":180,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool hiding (_\u2264_)\nopen import Data.Nat.Properties\nopen import Preloaded\n\nbool-to-nat : Bool \u2192 \u2115\nbool-to-nat true = 1\nbool-to-nat false = 0\n\ndata Divmod (n : \u2115) : (\u2115 \u00d7 Bool) \u2192 Set where\n  mk-divmod : \u2200 r b \u2192 bool-to-nat b + r * 2 \u2261 n \u2192 (n > 0 \u2192 n > r) \u2192 Divmod n (r , b)\n\ninspect-divmod : \u2200 n \u2192 Divmod n (div-mod2 n)\ninspect-divmod zero = mk-divmod zero false refl (\u03bb z \u2192 z)\ninspect-divmod (suc zero) = mk-divmod zero true refl (\u03bb z \u2192 z)\ninspect-divmod (suc (suc n)) with inspect-divmod n\ninspect-divmod (suc (suc n)) | mk-divmod .(proj\u2081 (div-mod2 n)) .(proj\u2082 (div-mod2 n)) good small =\n  mk-divmod\n    (suc (proj\u2081 (div-mod2 n)))\n    (proj\u2082 (div-mod2 n))\n    (trans (sym (+-assoc (bool-to-nat (proj\u2082 (div-mod2 n))) 2 _)) (trans (cong (\u03bb q \u2192 q + proj\u2081 (div-mod2 n) * 2) (+-comm (bool-to-nat (proj\u2082 (div-mod2 n))) 2)) (cong (\u03bb q \u2192 suc (suc q)) good)))\n    \u03bb _ \u2192 small2 small where\n\n  if-zero : \u2200 n \u2192 n \u2261 0 \u2192 suc (suc n) > suc (proj\u2081 (div-mod2 n))\n  if-zero .0 refl = s\u2264s (s\u2264s z\u2264n)\n\n  small2 : \u2200 {n} \u2192 (n > 0 \u2192 n > (proj\u2081 (div-mod2 n))) \u2192 suc (suc n) > suc (proj\u2081 (div-mod2 n))\n  small2 {zero} small = s\u2264s (s\u2264s z\u2264n)\n  small2 {suc n} small = \u2264-trans (s\u2264s (small (s\u2264s z\u2264n))) (\u2264-step \u2264-refl)\n\nalgebra-lemma1 : \u2200 b e \u2192 (b * b) ^ e \u2261 b ^ (e * 2)\nalgebra-lemma1 b e = trans (cong (\u03bb x \u2192 (b * x) ^ e) (sym (*-identity\u02b3 b))) (trans (^-*-assoc b 2 e) (cong (\u03bb q \u2192 b ^ q) (*-comm 2 e)))\n\npow-sqr-aux-correct : \u2200 k b e \u2192 k \u2265 e \u2192 pow-sqr-aux k b e \u2261 b ^ e\npow-sqr-aux-correct zero b zero geq = refl\npow-sqr-aux-correct (suc _) b zero geq = refl\npow-sqr-aux-correct (suc k) b (suc e-1) geq with div-mod2 (suc e-1) | inspect-divmod (suc e-1)\npow-sqr-aux-correct (suc k) b (suc .(suc (e' * 2))) geq | suc e' , false | mk-divmod .(suc e') .false refl divmod-smaller =\n  trans rec (algebra-lemma1 b (suc e')) where\n    rec = (pow-sqr-aux-correct k (b * b) (suc e') (\u2264-pred (\u2264-trans (divmod-smaller (s\u2264s z\u2264n)) geq) ))\npow-sqr-aux-correct (suc k) b (suc .(e' * 2)) geq | e' , true | mk-divmod .e' .true refl divmod-smaller =\n  cong (\u03bb q \u2192 b * q) (trans rec (algebra-lemma1 b e')) where\n    rec = (pow-sqr-aux-correct k (b * b) e' (\u2264-pred (\u2264-trans (divmod-smaller (s\u2264s z\u2264n)) geq) ))\n  \npow-eq : \u2200 b e \u2192 pow-sqr b e \u2261 b ^ e\npow-eq b e = pow-sqr-aux-correct e b e \u2264-refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8bc557802fcd5a53b3c75c":[{"id":181,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show; _\u225f_)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\n\nopen import Data.Product\n\nmodule TypeCheck where\n  open Erase\n\n  pure : {A : Set} \u2192 A \u2192 TCM A\n  pure = inj\u2082\n\n  fail : {A : Set} \u2192 String \u2192 TCM A\n  fail = inj\u2081\n\n  _>>=_ : {A B : Set} \u2192 TCM A \u2192 (A \u2192 TCM B) \u2192 TCM B\n  inj\u2081 x >>= B = inj\u2081 x\n  inj\u2082 y >>= B = B y\n\n  findVar : (\u0393 : Ctx) (n : Name) \u2192 TCM (\u2203[ a ] ((n , a) \u2208 \u0393))\n  findVar [] n = fail (\"Variable out of scope: \" ++ show n)\n  findVar ((fst , snd) \u2237 \u0393) n with fst \u225f n\n  ...                            | yes refl = pure (snd , emm \u0393)\n  ...                            | no \u00acp = do (ty , p) \u2190 findVar \u0393 n\n                                              pure (ty , hmm p)\n\n  unify : (m n : Type) \u2192 TCM (m \u2261 n)\n  unify nat nat = pure refl\n  unify (m => m\u2081) (n => n\u2081) = do refl \u2190 unify m n\n                                 refl \u2190 unify m\u2081 n\u2081\n                                 pure refl\n  unify _ _ = fail \"Argument type mismatch!\"\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) = do (ty , p) \u2190 findVar \u0393 x\n                           pure (ok ty (var x p))\n  typeCheck \u0393 (lit x) = pure (ok nat (lit x))\n  typeCheck \u0393 suc = pure (ok (nat => nat) suc)\n  typeCheck \u0393 (app term term\u2081) = do (ok (param => ret) funTm) \u2190 typeCheck \u0393 term\n                                      where _ \u2192 fail \"Nat is not a function!\"\n                                    (ok argTy argTm) \u2190 typeCheck \u0393 term\u2081\n                                    refl \u2190 unify param argTy\n                                    pure (ok ret (app funTm argTm))\n  typeCheck \u0393 (lam x x\u2081 term) = do (ok ret bodyTm) \u2190 typeCheck ((x , x\u2081) \u2237 \u0393) term\n                                   pure (ok (x\u2081 => ret) (lam x x\u2081 bodyTm))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":182,"user_id":60,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_) renaming (_\u2237_ to _::_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\nopen import Data.Product\n\nmodule TypeCheck where\n  open Erase\n\n  either : \u2200 {a b c} {A : Set a} {B : Set b} {C : Set c} \u2192 (A \u2192 C) \u2192 (B \u2192 C) \u2192 A \u228e B \u2192 C\n  either f _ (inj\u2081 x) = f x\n  either _ g (inj\u2082 y) = g y\n\n  _<$>_ : \u2200 {A B} \u2192 (A \u2192 B) \u2192 TCM A \u2192 TCM B\n  f <$> inj\u2081 x = inj\u2081 x\n  f <$> inj\u2082 y = inj\u2082 (f y)\n\n  _<*>_ : \u2200 {A B} \u2192 TCM (A \u2192 B) \u2192 TCM A \u2192 TCM B\n  inj\u2081 x <*> _      = inj\u2081 x\n  inj\u2082 _ <*> inj\u2081 x = inj\u2081 x\n  inj\u2082 f <*> inj\u2082 y = inj\u2082 (f y)\n\n  _>>=_ : \u2200 {A B} \u2192 TCM A \u2192 (A \u2192 TCM B) \u2192 TCM B\n  inj\u2081 x >>= _ = inj\u2081 x\n  inj\u2082 y >>= f = f y\n\n  _\u2261\u207f_ : (a b : Name) \u2192 TCM (a \u2261 b)\n  zero \u2261\u207f zero   = inj\u2082 refl\n  suc n \u2261\u207f suc m = cong suc <$> (n \u2261\u207f m)\n  _ \u2261\u207f _         = inj\u2081 \"\"\n\n  _\u2261\u1d57_ : (a b : Type) \u2192 TCM (a \u2261 b)\n  nat \u2261\u1d57 nat           = inj\u2082 refl\n  (a => b) \u2261\u1d57 (c => d) = (cong\u2082 _=>_ <$> (a \u2261\u1d57 c)) <*> (b \u2261\u1d57 d)\n  _ \u2261\u1d57 _               = inj\u2081 \"Argument type mismatch!\"\n\n  lookupCtx : (\u0393 : Ctx) (x : Name) \u2192 TCM (\u2203 \u03bb a \u2192 (x , a) \u2208 \u0393)\n  lookupCtx [] x              = inj\u2081 (\"Variable out of scope: \" ++ show x)\n  lookupCtx ((y , a) :: \u0393) x = either f g (x \u2261\u207f y)\n    where f : TypeError \u2192 TCM (\u2203 \u03bb a' \u2192 (x , a') \u2208 (y , a) :: \u0393)\n          f _ = (\u03bb { (a , i) \u2192 (a , hmm i) }) <$> lookupCtx \u0393 x\n          g : x \u2261 y \u2192 TCM (\u2203 \u03bb a' \u2192 (x , a') \u2208 (y , a) :: \u0393)\n          g refl = inj\u2082 (a , emm \u0393)\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) = (\u03bb { (a , i) \u2192 ok a (var x i) }) <$> lookupCtx \u0393 x\n  typeCheck \u0393 (lit x) = inj\u2082 (ok nat (lit x))\n  typeCheck \u0393 suc = inj\u2082 (ok (nat => nat) suc)\n  typeCheck \u0393 (app ft xt) = typeCheck \u0393 ft >>= (\u03bb f \u2192 typeCheck \u0393 xt >>= apply f)\n    where apply : Success \u0393 ft \u2192 Success \u0393 xt \u2192 TCM (Success \u0393 (app ft xt))\n          apply (ok nat f) (ok a' x) = inj\u2081 \"Nat is not a function!\"\n          apply (ok (a => b) f) (ok a' x) = (\u03bb { refl \u2192 ok b (app f x) }) <$> (a \u2261\u1d57 a')\n  typeCheck \u0393 (lam x a t) = (\u03bb { (ok b v) \u2192 ok (a => b) (lam x a v) }) <$> typeCheck ((x , a) :: \u0393) t","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":183,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat \nopen import Data.Nat.Properties \nopen import Induction.WellFounded\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation \nopen import Data.List renaming (and to listAnd ; or to listOr)\nopen import Data.Empty\n\nopen import Agda.Primitive\n\nopen import Data.Nat\nopen import Data.Bool renaming (_\u2228_ to _\u2228\u1d47_ ; _\u2227_ to _\u2227\u1d47_ )\nopen import Data.Product renaming (_\u00d7_ to _\u2227_ ; proj\u2081 to fst ; proj\u2082 to snd)\nopen import Data.Unit\n\nopen import Data.String hiding (show)\nopen import Data.Sum renaming (_\u228e_ to _\u2228_ ; inj\u2081 to orLeft ; inj\u2082 to orRight)\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat\nopen import Data.Nat.Show\nopen import Function\n\n{- Preloaded\nopen import Data.Product\nopen import Data.List\nopen import Function\n\nName = Nat\n\ninfixr 7 _=>_\ndata Type : Set where\n  nat  : Type\n  _=>_ : Type -> Type -> Type\nprivate variable a b c d : Type\n\nCtx = List (Name \u00d7 Type)\nvariable \u0393 : Ctx\n\ninfix 4 _\u2208_\ndata _\u2208_ {A : Set} (a : A) : List A -> Set where\n  emm : (as : List A) -> a \u2208 a \u2237 as\n  hmm : \u2200 {as c} -> (a \u2208 as) -> a \u2208 c \u2237 as\n\nmodule Untyped where\n  data Term : Set where\n    var : Name -> Term\n    lit : Nat  -> Term\n    suc : Term\n    app : Term -> Term -> Term\n    lam : Name -> Type -> Term -> Term\n\nmodule Typed where\n  data Term (\u0393 : Ctx) : Type -> Set where\n    var : \u2200 {a} (x : Name) (i : (x , a) \u2208 \u0393) -> Term \u0393 a\n    lit : (n : Nat) -> Term \u0393 nat\n    suc : Term \u0393 (nat => nat)\n    app : Term \u0393 (a => b) -> Term \u0393 a -> Term \u0393 b\n    lam : (x : Name) (a : Type) -> Term ((x , a) \u2237 \u0393) b\n        -> Term \u0393 (a => b)\n\nmodule Erase where\n  open Typed public\n  open Untyped renaming (Term to Expr) public\n\n  eraseType : Term \u0393 a -> Expr\n  eraseType (var x _) = var x\n  eraseType (lit n) = lit n\n  eraseType suc = suc\n  eraseType (app f x) = app (eraseType f) $ eraseType x\n  eraseType (lam x t e) = lam x t $ eraseType e\n\nTypeError = String\nTCM : Set -> Set\nTCM A = TypeError \u228e A\n\ndata Success (\u0393 : Ctx) : Untyped.Term -> Set where\n  ok : \u2200 a (v : Typed.Term \u0393 a) -> Success \u0393 (Erase.eraseType v)\n\n-}\n\nmodule TypeCheck where\n  open Erase\n\n  =>Inj : {a b c d : Type} \u2192 a => b \u2261 c => d \u2192 a \u2261 c \u2227 b \u2261 d\n  =>Inj {a} {b} {.a} {.b} refl = refl , refl \n\n  _\u225ft_ : (a b : Type) \u2192 Dec (a \u2261 b)\n  nat \u225ft nat = yes refl\n  nat \u225ft (b => b\u2081) = no \u03bb ()\n  (a1 => a2) \u225ft nat = no \u03bb ()\n  (a1 => a2) \u225ft (b1 => b2) with a1 \u225ft b1 | a2 \u225ft b2\n  (a1 => a2) \u225ft (b1 => b2) | yes ab1 | yes ab2 rewrite ab1 | ab2 = yes refl\n  (a1 => a2) \u225ft (b1 => b2) | yes ab1 | no \u00acab2 = no (\u03bb z \u2192 contradiction (snd (=>Inj z)) \u00acab2)\n  (a1 => a2) \u225ft (b1 => b2) | no \u00acab1 | yes ab2 = no (\u03bb z \u2192 contradiction (fst (=>Inj z)) \u00acab1)\n  (a1 => a2) \u225ft (b1 => b2) | no \u00acab1 | no \u00acab2 = no (\u03bb z \u2192 contradiction (fst (=>Inj z)) \u00acab1)\n\n  typeCheckVar : (\u0393 : Ctx) \u2192 (x : Name) \u2192 String \u2228 (\u2203 (\u03bb (type : Type) \u2192 (x , type) \u2208 \u0393))\n  typeCheckVar [] x = orLeft (\"Variable out of scope: \" Data.String.++ show x)\n  typeCheckVar ((cname , ctype) \u2237 \u0393) x with cname Data.Nat.\u225f x\n  typeCheckVar ((cname , ctype) \u2237 \u0393) x | yes cname\u2261x rewrite cname\u2261x = orRight (ctype , emm \u0393)\n  typeCheckVar ((cname , ctype) \u2237 \u0393) x | no \u00accname\u2261x with typeCheckVar \u0393 x\n  typeCheckVar ((cname , ctype) \u2237 \u0393) x | no \u00accname\u2261x | orLeft err = orLeft err\n  typeCheckVar ((cname , ctype) \u2237 \u0393) x | no \u00accname\u2261x | orRight (type , x\u2208\u0393) = orRight (type , (hmm x\u2208\u0393))\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) with typeCheckVar \u0393 x \n  typeCheck \u0393 (var x) | orLeft err = orLeft err\n  typeCheck \u0393 (var x) | orRight (type , x\u2208\u0393) = orRight (ok type (var x x\u2208\u0393))\n  typeCheck \u0393 (lit x) = orRight (ok nat (lit x))\n  typeCheck \u0393 suc = orRight (ok (nat => nat) suc)\n  typeCheck \u0393 (app f arg) with typeCheck \u0393 f\n  typeCheck \u0393 (app f arg) | orLeft x = orLeft x\n  typeCheck \u0393 (app .(eraseType fTyped) arg) | orRight (ok fType fTyped) with typeCheck \u0393 arg\n  typeCheck \u0393 (app .(eraseType fTyped) arg) | orRight (ok fType fTyped) | orLeft x = orLeft x\n  typeCheck \u0393 (app .(eraseType fTyped) .(eraseType argTyped)) | \n        orRight (ok nat fTyped) | orRight (ok argType argTyped) = orLeft \"Nat is not a function!\"\n  typeCheck \u0393 (app .(eraseType fTyped) .(eraseType argTyped)) | \n        orRight (ok (fFromType => fToType) fTyped) | orRight (ok argType argTyped) with fFromType \u225ft argType \n  typeCheck \u0393 (app .(eraseType fTyped) .(eraseType argTyped)) | \n        orRight (ok (fFromType => fToType) fTyped) | orRight (ok argType argTyped) | no \u00acfType\u2261ArgType = \n            orLeft \"Argument type mismatch!\"\n  typeCheck \u0393 (app _ _) | \n        orRight (ok (fFromType => fToType) fTyped) | orRight (ok argType argTyped) | yes fType\u2261ArgType rewrite fType\u2261ArgType\n             = orRight (ok fToType (app fTyped argTyped))\n  typeCheck \u0393 (lam name type term) with typeCheck ((name , type) \u2237 \u0393) term\n  typeCheck \u0393 (lam name type term) | orLeft x = orLeft x\n  typeCheck \u0393 (lam name type .(eraseType termTyped)) | orRight (ok termType termTyped) =\n        orRight (ok (type => termType) (lam name type termTyped))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":184,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat) hiding (_\u2261\u1d47_)\nopen import Data.Nat.Show\n\nopen import Data.Product\nopen import Data.List\nopen import Data.Bool\nopen import Function\n\n{- Preloaded\nopen import Data.Product\nopen import Data.List\nopen import Function\n\nName = Nat\n\ninfixr 7 _=>_\ndata Type : Set where\n  nat  : Type\n  _=>_ : Type -> Type -> Type\nprivate variable a b c d : Type\n\nCtx = List (Name \u00d7 Type)\nvariable \u0393 : Ctx\n\ninfix 4 _\u2208_\ndata _\u2208_ {A : Set} (a : A) : List A -> Set where\n  emm : (as : List A) -> a \u2208 a \u2237 as\n  hmm : \u2200 {as c} -> (a \u2208 as) -> a \u2208 c \u2237 as\n\nmodule Untyped where\n  data Term : Set where\n    var : Name -> Term\n    lit : Nat  -> Term\n    suc : Term\n    app : Term -> Term -> Term\n    lam : Name -> Type -> Term -> Term\n\nmodule Typed where\n  data Term (\u0393 : Ctx) : Type -> Set where\n    var : \u2200 {a} (x : Name) (i : (x , a) \u2208 \u0393) -> Term \u0393 a\n    lit : (n : Nat) -> Term \u0393 nat\n    suc : Term \u0393 (nat => nat)\n    app : Term \u0393 (a => b) -> Term \u0393 a -> Term \u0393 b\n    lam : (x : Name) (a : Type) -> Term ((x , a) \u2237 \u0393) b\n        -> Term \u0393 (a => b)\n\nmodule Erase where\n  open Typed public\n  open Untyped renaming (Term to Expr) public\n\n  eraseType : Term \u0393 a -> Expr\n  eraseType (var x _) = var x\n  eraseType (lit n) = lit n\n  eraseType suc = suc\n  eraseType (app f x) = app (eraseType f) $ eraseType x\n  eraseType (lam x t e) = lam x t $ eraseType e\n\nTypeError = String\nTCM : Set -> Set\nTCM A = TypeError \u228e A\n\ndata Success (\u0393 : Ctx) : Untyped.Term -> Set where\n  ok : \u2200 a (v : Typed.Term \u0393 a) -> Success \u0393 (Erase.eraseType v)\n\n-}\n\nmodule TypeCheck where\n  open Erase\n\n  _\u225f\u1d57_ : Decidable {A = Type} _\u2261_\n  nat \u225f\u1d57 nat = yes refl\n  nat \u225f\u1d57 (y => y\u2081) = no (\u03bb ())\n  (x => x\u2081) \u225f\u1d57 nat = no (\u03bb ())\n  (x => z) \u225f\u1d57 (y => t) with x \u225f\u1d57 y | z \u225f\u1d57 t\n  ... | yes p | yes q = yes (cong\u2082 _=>_ p q)\n  ... | _ | no  q = no (\u03bb {refl \u2192 q refl})\n  ... | no  p | _ = no (\u03bb {refl \u2192 p refl})\n\n  _\u2208?_ : (x : Name) (\u0393 : Ctx) \u2192 Dec (\u03a3 Type \u03bb t \u2192 (x , t) \u2208 \u0393)\n  x \u2208? [] = no \u03bb ()\n  x \u2208? ((y , t) \u2237 \u0393) with x Data.Nat.\u225f y | x \u2208? \u0393\n  ... | no  p | no  q = no (\u03bb {(t' , emm .\u0393) \u2192 p refl\n                             ; (t' , hmm x\u2208\u0393) \u2192 q (t' , x\u2208\u0393)})\n  ... | no p | yes (t' , x\u2208\u0393) = yes (t' , hmm x\u2208\u0393)\n  ... | yes refl | _ = yes (t , (emm \u0393))\n  \n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) with x \u2208? \u0393 \n  ... | yes (t , x\u2208\u0393) = inj\u2082 (ok t (var x x\u2208\u0393))\n  ... | no  p = inj\u2081 (\"Variable out of scope: \" Data.String.++ show x)\n  typeCheck \u0393 (lit n) = inj\u2082 (ok nat (lit n))\n  typeCheck \u0393 suc = inj\u2082 (ok (nat => nat) suc)\n  typeCheck \u0393 (app expr expr') with typeCheck \u0393 expr | typeCheck \u0393 expr'\n  ... | inj\u2081 s | _ = inj\u2081 s\n  ... | inj\u2082 _ | inj\u2081 s = inj\u2081 s\n  ... | inj\u2082 (ok nat _) | inj\u2082 _ = inj\u2081 \"Nat is not a function!\"\n  ... | inj\u2082 (ok (b => b\u2081) v) | inj\u2082 (ok a w) with a \u225f\u1d57 b\n  ... | no p = inj\u2081 \"Argument type mismatch!\"\n  ... | yes p with p \n  ... | refl = inj\u2082 (ok b\u2081 (app v w))\n  typeCheck \u0393 (lam x t expr) with typeCheck ((x , t) \u2237 \u0393) expr \n  ... | inj\u2081 s = inj\u2081 s\n  ... | inj\u2082 (ok a v) = inj\u2082 (ok (t => a) (lam x t v))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":185,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Agda.Builtin.Sigma\nopen import Data.Bool hiding (_\u225f_)\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\nopen import Data.Product\nopen import Data.String hiding (show; _\u225f_)\nopen import Data.Sum\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen Erase\nopen Success\n\nmodule TypeCheck where\n\n_>>=_ : \u2200 {A B} \u2192 TCM A \u2192 (A \u2192 (TCM B)) \u2192 TCM B\n_>>=_ (inj\u2081 message) f = inj\u2081 message\n_>>=_ (inj\u2082 success) f = f success\n\nunify : (a : Type) \u2192 (b : Type) \u2192 Dec (a \u2261 b)\nunify nat nat = yes refl\nunify nat (z => w) = no (\u03bb ())\nunify (x => y) nat = no (\u03bb ())\nunify (x => y) (z => w) with (unify x z) | (unify y w)\n...                        | (yes refl)  | (yes refl) = yes refl\n...                        | (no t0) | (no t1) = no (\u03bb { refl \u2192 t1 refl })\n...                        | (yes refl) | (no t1) = no (\u03bb { refl \u2192 t1 refl })\n...                        | (no t0) | (yes refl) = no (\u03bb { refl \u2192 t0 refl })\n\nhelper : \u2200 {\u0393 e y t} \u2192 Success \u0393 e \u2192 TCM (Success ((y , t) \u2237 \u0393) e)\nhelper (ok t (var x i)) = inj\u2082 (ok t (var x (hmm i)))\nhelper _ = inj\u2081 \"Impossible\"\n\nlookctx : (\u0393 : Ctx) \u2192 (x : Name) \u2192 TCM (Success \u0393 (var x))\nlookctx [] x = inj\u2081 (\"Variable out of scope: \" ++ show x)\nlookctx ((y , t) \u2237 \u0393) x with y \u225f x\n...                         | yes refl = inj\u2082 (ok t (var x (emm \u0393)))\n...                         | no _ = do\n                                       success <- lookctx \u0393 x\n                                       helper success\n\ndolam : \u2200 {\u0393 x t body} \u2192 Success ((x , t) \u2237 \u0393) body \u2192 Success \u0393 (lam x t body)\ndolam {\u0393} {x} {t} {body} (ok ty v) = ok (t => ty) (lam x t v)\n\ndoapp : \u2200 {\u0393 funexpr argexpr} \u2192 (fun : Success \u0393 funexpr) \u2192 (arg : Success \u0393 argexpr) \u2192 TCM (Success \u0393 (app funexpr argexpr))\ndoapp (ok nat _) _ = inj\u2081 \"Nat is not a function!\"\ndoapp (ok (xtype => ytype) funterm) (ok argtype argterm) with unify xtype argtype\n...                                                         | no _ = inj\u2081 \"Argument type mismatch!\"\n...                                                         | yes refl = inj\u2082 (ok ytype (app funterm argterm))\n\ntypeCheck : (\u0393 : Ctx) (e : Expr) \u2192 TCM (Success \u0393 e)\ntypeCheck \u0393 (var x) = lookctx \u0393 x\ntypeCheck \u0393 (lit n) = inj\u2082 (ok nat (lit n))\ntypeCheck \u0393 (suc) = inj\u2082 (ok (nat => nat) suc)\ntypeCheck \u0393 (app fun arg) = do\n                              fun' <- typeCheck \u0393 fun\n                              arg' <- typeCheck \u0393 arg\n                              doapp fun' arg'\ntypeCheck \u0393 (lam x t body) = do\n                               body <- typeCheck ((x , t) \u2237 \u0393) body\n                               inj\u2082 (dolam body)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":186,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\nopen import Data.Product\n\n{- Preloaded\nopen import Data.Product\nopen import Data.List\nopen import Function\n\nName = Nat\n\ninfixr 7 _=>_\ndata Type : Set where\n  nat  : Type\n  _=>_ : Type -> Type -> Type\nprivate variable a b c d : Type\n\nCtx = List (Name \u00d7 Type)\nvariable \u0393 : Ctx\n\ninfix 4 _\u2208_\ndata _\u2208_ {A : Set} (a : A) : List A -> Set where\n  emm : (as : List A) -> a \u2208 a \u2237 as\n  hmm : \u2200 {as c} -> (a \u2208 as) -> a \u2208 c \u2237 as\n\nmodule Untyped where\n  data Term : Set where\n    var : Name -> Term\n    lit : Nat  -> Term\n    suc : Term\n    app : Term -> Term -> Term\n    lam : Name -> Type -> Term -> Term\n\nmodule Typed where\n  data Term (\u0393 : Ctx) : Type -> Set where\n    var : \u2200 {a} (x : Name) (i : (x , a) \u2208 \u0393) -> Term \u0393 a\n    lit : (n : Nat) -> Term \u0393 nat\n    suc : Term \u0393 (nat => nat)\n    app : Term \u0393 (a => b) -> Term \u0393 a -> Term \u0393 b\n    lam : (x : Name) (a : Type) -> Term ((x , a) \u2237 \u0393) b\n        -> Term \u0393 (a => b)\n\nmodule Erase where\n  open Typed public\n  open Untyped renaming (Term to Expr) public\n\n  eraseType : Term \u0393 a -> Expr\n  eraseType (var x _) = var x\n  eraseType (lit n) = lit n\n  eraseType suc = suc\n  eraseType (app f x) = app (eraseType f) $ eraseType x\n  eraseType (lam x t e) = lam x t $ eraseType e\n\nTypeError = String\nTCM : Set -> Set\nTCM A = TypeError \u228e A\n\ndata Success (\u0393 : Ctx) : Untyped.Term -> Set where\n  ok : \u2200 a (v : Typed.Term \u0393 a) -> Success \u0393 (Erase.eraseType v)\n\n-}\n\nmodule TypeCheck where\n  open Erase\n  \n  _>>=_ : \u2200 {A B} \u2192 TCM A -> (A -> TCM B) -> TCM B\n  inj\u2081 x >>= f = inj\u2081 x\n  inj\u2082 y >>= f = f y\n\n\n  find : (x : Name) (\u0393 : Ctx) \u2192 TCM (\u03a3[ a \u2208 Type ] (x , a) \u2208 \u0393)\n  find x [] = inj\u2081 (\"Variable out of scope: \" ++ show x)\n  find x ((y , a) \u2237 \u0393) with x Data.Nat.\u225f y\n  ... | yes refl = inj\u2082 (a , emm \u0393)\n  ... | no _ = do\n    (a , a\u2208\u0393) <- find x \u0393\n    inj\u2082 (a , hmm a\u2208\u0393)\n\n  Type-Eq : (x y : Type) \u2192 TCM (x \u2261 y)\n  Type-Eq nat nat = inj\u2082 refl\n  Type-Eq nat (y => y\u2081) = inj\u2081 \"Argument type mismatch!\"\n  Type-Eq (x => x\u2081) nat = inj\u2081 \"Argument type mismatch!\"\n  Type-Eq (x => x\u2081) (y => y\u2081) = do\n    refl <- Type-Eq x y\n    refl <- Type-Eq x\u2081 y\u2081\n    inj\u2082 refl\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) = do\n    (a , a\u2208\u0393) <- find x \u0393\n    inj\u2082 (ok a (var x a\u2208\u0393))\n  typeCheck \u0393 (lit x) = inj\u2082 (ok nat (lit x))\n  typeCheck \u0393 suc = inj\u2082 (ok (nat => nat) suc)\n  typeCheck \u0393 (app term term\u2081) = do\n    ok (a => b) term' <- typeCheck \u0393 term\n      where _ -> inj\u2081 \"Nat is not a function!\"\n    ok a' term\u2081' <- typeCheck \u0393 term\u2081\n    refl <- Type-Eq a a'\n    inj\u2082 (ok b (app term' term\u2081'))\n  typeCheck \u0393 (lam x a term) = do\n    ok b term' <- typeCheck ((x , a) \u2237 \u0393) term\n    inj\u2082 (ok (a => b) (lam x a term'))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":187,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show; _\u225f_)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\n\nopen import Data.Product\n\nmodule TypeCheck where\n  open Erase\n\n  pure : {A : Set} \u2192 A \u2192 TCM A\n  pure = inj\u2082\n\n  fail : {A : Set} \u2192 String \u2192 TCM A\n  fail = inj\u2081\n\n  _>>=_ : {A B : Set} \u2192 TCM A \u2192 (A \u2192 TCM B) \u2192 TCM B\n  inj\u2081 x >>= B = inj\u2081 x\n  inj\u2082 y >>= B = B y\n  \n  _>>_ : {A B : Set} \u2192 TCM A \u2192 TCM B \u2192 TCM B\n  A >> B = A >>= (\u03bb _ \u2192 B)\n\n  findVar : (\u0393 : Ctx) (n : Name) \u2192 TCM (\u2203[ a ] ((n , a) \u2208 \u0393))\n  findVar [] n = fail (\"Variable out of scope: \" ++ show n)\n  findVar ((fst , snd) \u2237 \u0393) n with fst \u225f n\n  ...                            | yes p rewrite (sym p) = pure (snd , emm \u0393)\n  ...                            | no \u00acp = do (ty , p) \u2190 findVar \u0393 n\n                                              pure (ty , hmm p)\n\n  unify : (m n : Type) \u2192 TCM (m \u2261 n)\n  unify nat nat = pure refl\n  unify (m => m\u2081) (n => n\u2081) = do p \u2190 unify m n\n                                 q \u2190 unify m\u2081 n\u2081\n                                 pure (proof p q)\n                                 where proof : \u2200 {m n p q} \u2192 m \u2261 n \u2192 p \u2261 q \u2192 m => p \u2261 n => q\n                                       proof p q rewrite p | q = refl\n  unify _ _ = fail \"Argument type mismatch!\"\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) = do (ty , p) \u2190 findVar \u0393 x\n                           pure (ok ty (var x p))\n  typeCheck \u0393 (lit x) = pure (ok nat (lit x))\n  typeCheck \u0393 suc = pure (ok (nat => nat) suc)\n  typeCheck \u0393 (app term term\u2081) = do (ok (param => ret) funTm) \u2190 typeCheck \u0393 term\n                                      where _ \u2192 fail \"Nat is not a function!\"\n                                    (ok argTy argTm) \u2190 typeCheck \u0393 term\u2081\n                                    p \u2190 unify param argTy\n                                    pure (coerce p funTm argTm)\n                                    where coerce : \u2200 {\u0393\u2032} {a b c} (p : a \u2261 b) (f : Term \u0393\u2032 (a => c)) (x : Term \u0393\u2032 b)\n                                                \u2192 Success \u0393\u2032 (app (eraseType f) (eraseType x)) -- god why\n                                          coerce {c = c} p f x rewrite p = ok c (app f x)\n  typeCheck \u0393 (lam x x\u2081 term) = do (ok ret bodyTm) \u2190 typeCheck ((x , x\u2081) \u2237 \u0393) term\n                                   pure (ok (x\u2081 => ret) (lam x x\u2081 bodyTm))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":188,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show; _\u225f_)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\n\nopen import Data.Product\n\nmodule TypeCheck where\n  open Erase\n\n  pure : {A : Set} \u2192 A \u2192 TCM A\n  pure = inj\u2082\n\n  fail : {A : Set} \u2192 String \u2192 TCM A\n  fail = inj\u2081\n\n  _>>=_ : {A B : Set} \u2192 TCM A \u2192 (A \u2192 TCM B) \u2192 TCM B\n  inj\u2081 x >>= B = inj\u2081 x\n  inj\u2082 y >>= B = B y\n\n  _>>_ : {A B : Set} \u2192 TCM A \u2192 TCM B \u2192 TCM B\n  A >> B = A >>= (\u03bb _ \u2192 B)\n\n  findVar : (\u0393 : Ctx) (n : Name) \u2192 TCM (\u2203[ a ] ((n , a) \u2208 \u0393))\n  findVar [] n = fail (\"Variable out of scope: \" ++ show n)\n  findVar ((fst , snd) \u2237 \u0393) n with fst \u225f n\n  ...                            | yes p rewrite (sym p) = pure (snd , emm \u0393)\n  ...                            | no \u00acp = do (ty , p) \u2190 findVar \u0393 n\n                                              pure (ty , hmm p)\n\n  paramTy : Type \u2192 Type\n  paramTy nat = nat\n  paramTy (x => y) = x\n\n  retTy : Type \u2192 Type\n  retTy nat = nat\n  retTy (x => y) = y\n\n  unify : (m n : Type) \u2192 Dec (m \u2261 n)\n  unify nat nat = yes refl\n  unify nat (n => n\u2081) = no \u03bb()\n  unify (m => m\u2081) nat = no \u03bb()\n  unify (m => m\u2081) (n => n\u2081) with unify m n\n  unify (m => m\u2081) (n => n\u2081) | yes p with unify m\u2081 n\u2081\n  ...                                  | yes q rewrite p | q = yes refl\n  ...                                  | no \u00acq = no (\u03bb q \u2192 \u00acq (cong retTy q))\n  unify (m => m\u2081) (n => n\u2081) | no \u00acp = no (\u03bb p \u2192 \u00acp (cong paramTy p))\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) = do (ty , p) \u2190 findVar \u0393 x\n                           pure (ok ty (var x p))\n  typeCheck \u0393 (lit x) = pure (ok nat (lit x))\n  typeCheck \u0393 suc = pure (ok (nat => nat) suc)\n  typeCheck \u0393 (app term term\u2081) = do (ok (param => ret) funTm) \u2190 typeCheck \u0393 term\n                                      where _ \u2192 fail \"Nat is not a function!\"\n                                    (ok argTy argTm) \u2190 typeCheck \u0393 term\u2081\n                                    (yes p) \u2190 pure (unify param argTy)\n                                      where _ \u2192 fail \"Argument type mismatch!\"\n                                    pure (coerce p funTm argTm)\n                                    where coerce : \u2200 {\u0393\u2032} {a b c} (p : a \u2261 b) (f : Term \u0393\u2032 (a => c)) (x : Term \u0393\u2032 b)\n                                                \u2192 Success \u0393\u2032 (app (eraseType f) (eraseType x)) -- god why\n                                          coerce {c = c} p f x rewrite p = ok c (app f x)\n  typeCheck \u0393 (lam x x\u2081 term) = do (ok ret bodyTm) \u2190 typeCheck ((x , x\u2081) \u2237 \u0393) term\n                                   pure (ok (x\u2081 => ret) (lam x x\u2081 bodyTm))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":189,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\n\n{- Preloaded\nopen import Data.Product\nopen import Data.List\nopen import Function\n\nName = Nat\n\ninfixr 7 _=>_\ndata Type : Set where\n  nat  : Type\n  _=>_ : Type -> Type -> Type\nprivate variable a b c d : Type\n\nCtx = List (Name \u00d7 Type)\nvariable \u0393 : Ctx\n\ninfix 4 _\u2208_\ndata _\u2208_ {A : Set} (a : A) : List A -> Set where\n  emm : (as : List A) -> a \u2208 a \u2237 as\n  hmm : \u2200 {as c} -> (a \u2208 as) -> a \u2208 c \u2237 as\n\nmodule Untyped where\n  data Term : Set where\n    var : Name -> Term\n    lit : Nat  -> Term\n    suc : Term\n    app : Term -> Term -> Term\n    lam : Name -> Type -> Term -> Term\n\nmodule Typed where\n  data Term (\u0393 : Ctx) : Type -> Set where\n    var : \u2200 {a} (x : Name) (i : (x , a) \u2208 \u0393) -> Term \u0393 a\n    lit : (n : Nat) -> Term \u0393 nat\n    suc : Term \u0393 (nat => nat)\n    app : Term \u0393 (a => b) -> Term \u0393 a -> Term \u0393 b\n    lam : (x : Name) (a : Type) -> Term ((x , a) \u2237 \u0393) b\n        -> Term \u0393 (a => b)\n\nmodule Erase where\n  open Typed public\n  open Untyped renaming (Term to Expr) public\n\n  eraseType : Term \u0393 a -> Expr\n  eraseType (var x _) = var x\n  eraseType (lit n) = lit n\n  eraseType suc = suc\n  eraseType (app f x) = app (eraseType f) $ eraseType x\n  eraseType (lam x t e) = lam x t $ eraseType e\n\nTypeError = String\nTCM : Set -> Set\nTCM A = TypeError \u228e A\n\ndata Success (\u0393 : Ctx) : Untyped.Term -> Set where\n  ok : \u2200 a (v : Typed.Term \u0393 a) -> Success \u0393 (Erase.eraseType v)\n\n-}\n\nmodule TypeCheck where\n  open Erase\n  open import Data.Product\n\n  lookupType : \u2200 (\u0393 : Ctx) (x : Name) \u2192 Dec (\u2203[ a ] ((x , a) \u2208 \u0393))\n  lookupType [] x = no (\u03bb ())\n  lookupType ((y , a) \u2237 \u0393) x with x Data.Nat.\u225f y\n  ... | yes refl = yes (a , emm \u0393)\n  ... | no x\u2262y with lookupType \u0393 x\n  ...   | yes (b , b\u2208\u0393) = yes (b , hmm b\u2208\u0393)\n  ...   | no x\u2209\u0393 = no (\u03bb{(b , emm .\u0393) \u2192 x\u2262y refl\n                      ; (b , hmm b\u2208\u0393) \u2192 x\u2209\u0393 (b , b\u2208\u0393)})\n\n  typeEq : (a : Type) \u2192 (b : Type) \u2192 Dec (a \u2261 b)\n  typeEq nat nat = yes refl\n  typeEq nat (b => b\u2081) = no (\u03bb ())\n  typeEq (a => a\u2081) nat = no (\u03bb ())\n  typeEq (a => a\u2081) (b => b\u2081) with typeEq a b | typeEq a\u2081 b\u2081\n  ... | yes a\u2261b | yes a\u2081\u2261b\u2081 = yes (cong\u2082 _=>_ a\u2261b a\u2081\u2261b\u2081)\n  ... | no a\u2262b | _ = no (\u03bb{ refl \u2192 a\u2262b refl })\n  ... | _ | no a\u2081\u2262b\u2081 = no (\u03bb{refl \u2192 a\u2081\u2262b\u2081 refl})\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) with lookupType \u0393 x\n  ... | no _ = inj\u2081 (\"Variable out of scope: \" ++ show x)\n  ... | yes (a , a\u2208\u0393) = inj\u2082 (ok a (var x a\u2208\u0393))\n  typeCheck \u0393 (lit x) = inj\u2082 (ok nat (lit x))\n  typeCheck \u0393 suc = inj\u2082 (ok (nat => nat) suc)\n  typeCheck \u0393 (app m n) with typeCheck \u0393 m\n  ... | inj\u2081 err = inj\u2081 err\n  ... | inj\u2082 (ok nat v) = inj\u2081 \"Nat is not a function!\"\n  ... | inj\u2082 (ok (a => b) v) with typeCheck \u0393 n\n  ...   | inj\u2081 err = inj\u2081 err\n  ...   | inj\u2082 (ok a\u2081 v\u2081) with typeEq a a\u2081\n  ...     | yes refl = inj\u2082 (ok b (app v v\u2081))\n  ...     | no a\u2262a\u2081 = inj\u2081 \"Argument type mismatch!\"\n  typeCheck \u0393 (lam x a term) with typeCheck ((x , a) \u2237 \u0393) term\n  ... | inj\u2081 err = inj\u2081 err\n  ... | inj\u2082 (ok b v) = inj\u2082 (ok (a => b) (lam x a v))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":190,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule LambdaCalculusTypeChecker where\n\nopen import LambdaCalculus\nopen import Data.String hiding (show)\nopen import Data.Sum\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.List hiding (_++_)\nopen import Data.Nat renaming (\u2115 to Nat)\nopen import Data.Nat.Show\nopen import Data.Product\n\n\n{- Preloaded\nopen import Data.Product\nopen import Data.List\nopen import Function\n\nName = Nat\n\ninfixr 7 _=>_\ndata Type : Set where\n  nat  : Type\n  _=>_ : Type -> Type -> Type\nprivate variable a b c d : Type\n\nCtx = List (Name \u00d7 Type)\nvariable \u0393 : Ctx\n\ninfix 4 _\u2208_\ndata _\u2208_ {A : Set} (a : A) : List A -> Set where\n  emm : (as : List A) -> a \u2208 a \u2237 as\n  hmm : \u2200 {as c} -> (a \u2208 as) -> a \u2208 c \u2237 as\n\nmodule Untyped where\n  data Term : Set where\n    var : Name -> Term\n    lit : Nat  -> Term\n    suc : Term\n    app : Term -> Term -> Term\n    lam : Name -> Type -> Term -> Term\n\nmodule Typed where\n  data Term (\u0393 : Ctx) : Type -> Set where\n    var : \u2200 {a} (x : Name) (i : (x , a) \u2208 \u0393) -> Term \u0393 a\n    lit : (n : Nat) -> Term \u0393 nat\n    suc : Term \u0393 (nat => nat)\n    app : Term \u0393 (a => b) -> Term \u0393 a -> Term \u0393 b\n    lam : (x : Name) (a : Type) -> Term ((x , a) \u2237 \u0393) b\n        -> Term \u0393 (a => b)\n\nmodule Erase where\n  open Typed public\n  open Untyped renaming (Term to Expr) public\n\n  eraseType : Term \u0393 a -> Expr\n  eraseType (var x _) = var x\n  eraseType (lit n) = lit n\n  eraseType suc = suc\n  eraseType (app f x) = app (eraseType f) $ eraseType x\n  eraseType (lam x t e) = lam x t $ eraseType e\n\nTypeError = String\nTCM : Set -> Set\nTCM A = TypeError \u228e A\n\ndata Success (\u0393 : Ctx) : Untyped.Term -> Set where\n  ok : \u2200 a (v : Typed.Term \u0393 a) -> Success \u0393 (Erase.eraseType v)\n\n-}\n\nmodule TypeCheck where\n  open Erase\n  \n  data _\u220b_\u2982_ : Ctx \u2192 Name \u2192 Type \u2192 Set where\n    Z : \u2200 {\u0393 : Ctx} {x : Name} {a : Type}\n      \u2192 ((x , a) \u2237 \u0393) \u220b x \u2982 a\n\n    S : \u2200 {\u0393 : Ctx} {x y : Name} {a b : Type}\n      \u2192 x \u2262 y\n      \u2192 \u0393 \u220b x \u2982 a\n      \u2192 ((y , b) \u2237 \u0393) \u220b x \u2982 a\n\n  lookupType : \u2200 (\u0393 : Ctx) (x : Name) \u2192 Dec (\u2203[ a ] (\u0393 \u220b x \u2982 a))\n  lookupType [] x = no (\u03bb ())\n  lookupType ((y , a) \u2237 \u0393) x with x Data.Nat.\u225f y\n  ... | yes refl = yes (a , Z)\n  ... | no x\u2262y with lookupType \u0393 x\n  ...   | no err = no \u03bb{(_ , Z) \u2192 x\u2262y refl\n                    ; (fst , S _ snd) \u2192 err (fst , snd) }\n  ...   | yes (b , \u0393\u220bx\u2982b) = yes (b , S x\u2262y \u0393\u220bx\u2982b)\n\n  \u220b\u2192\u2208 : \u2200{\u0393 x a} \u2192 \u0393 \u220b x \u2982 a \u2192 (x , a) \u2208 \u0393\n  \u220b\u2192\u2208 (Z {\u039b}) = emm \u039b\n  \u220b\u2192\u2208 (S _ \u039b\u220by\u2982a) = hmm (\u220b\u2192\u2208 \u039b\u220by\u2982a)\n\n  typeEq : (a : Type) \u2192 (b : Type) \u2192 Dec (a \u2261 b)\n  typeEq nat nat = yes refl\n  typeEq nat (b => b\u2081) = no (\u03bb ())\n  typeEq (a => a\u2081) nat = no (\u03bb ())\n  typeEq (a => a\u2081) (b => b\u2081) with typeEq a b | typeEq a\u2081 b\u2081\n  ... | yes a\u2261b | yes a\u2081\u2261b\u2081 = yes (cong\u2082 _=>_ a\u2261b a\u2081\u2261b\u2081)\n  ... | no a\u2262b | _ = no (\u03bb{ refl \u2192 a\u2262b refl })\n  ... | _ | no a\u2081\u2262b\u2081 = no (\u03bb{refl \u2192 a\u2081\u2262b\u2081 refl})\n\n  typeCheck : (\u0393 : Ctx) (e : Expr) -> TCM (Success \u0393 e)\n  typeCheck \u0393 (var x) with lookupType \u0393 x\n  ... | no _ = inj\u2081 (\"Variable out of scope: \" ++ show x)\n  ... | yes (a , \u0393\u220b\u2982a) = inj\u2082 (ok a (var x (\u220b\u2192\u2208 \u0393\u220b\u2982a)))\n  typeCheck \u0393 (lit x) = inj\u2082 (ok nat (lit x))\n  typeCheck \u0393 suc = inj\u2082 (ok (nat => nat) suc)\n  typeCheck \u0393 (app m n) with typeCheck \u0393 m\n  ... | inj\u2081 err = inj\u2081 err\n  ... | inj\u2082 (ok nat v) = inj\u2081 \"Nat is not a function!\"\n  ... | inj\u2082 (ok (a => b) v) with typeCheck \u0393 n\n  ...   | inj\u2081 err = inj\u2081 err\n  ...   | inj\u2082 (ok a\u2081 v\u2081) with typeEq a a\u2081\n  ...     | yes refl = inj\u2082 (ok b (app v v\u2081))\n  ...     | no a\u2262a\u2081 = inj\u2081 \"Argument type mismatch!\"\n  typeCheck \u0393 (lam x a term) with typeCheck ((x , a) \u2237 \u0393) term\n  ... | inj\u2081 err = inj\u2081 err\n  ... | inj\u2082 (ok b v) = inj\u2082 (ok (a => b) (lam x a v))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8dda57b0a26000015f1a7a":[{"id":191,"user_id":1084,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.Nat.Solver using (module +-*-Solver)\nopen +-*-Solver\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand = solve 1 (\n \u2192 (n :+ con 1) :^ 2 := n :^ 2 :+ con 2 :* n :+ con 1) refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":192,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\n*\u2261^2 : \u2200 (n : \u2115) \u2192 n * n \u2261 n ^ 2\n*\u2261^2 n = sym (begin \n    n ^ 2       \u2261\u27e8 sym (*-assoc n n 1) \u27e9 \n    n * n * 1   \u2261\u27e8 *-identity\u02b3 (n * n) \u27e9\n    n * n       \u220e)\n\n+\u22612* : \u2200 (n : \u2115) \u2192 n + n \u2261 2 * n\n+\u22612* n = sym (begin \n    2 * n           \u2261\u27e8 sym (+-assoc n n zero) \u27e9 \n    n + n + zero    \u2261\u27e8 +-identity\u02b3 (n + n) \u27e9\n    n + n           \u220e)\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1  -- n ^ 2 + 2 * n + 1\nexpand n = begin\n    (n + 1) ^ 2                 \u2261\u27e8 cong (\u03bb x \u2192 (n + 1) * x) (*-identity\u02b3 (n + 1)) \u27e9\n    (n + 1) * (n + 1)           \u2261\u27e8 *-distrib\u02e1-+ (n + 1) n 1 \u27e9\n    (n + 1) * n + (n + 1) * 1   \u2261\u27e8 cong (\u03bb x \u2192 (n + 1) * n + x) (*-identity\u02b3 (n + 1)) \u27e9 \n    (n + 1) * n + (n + 1)       \u2261\u27e8 cong (\u03bb x \u2192 x + (n + 1)) (*-distrib\u02b3-+ n n 1) \u27e9\n    n * n + 1 * n + (n + 1)     \u2261\u27e8 sym (+-assoc (n * n + 1 * n) n 1 ) \u27e9\n    n * n + 1 * n + n + 1       \u2261\u27e8 cong (\u03bb x \u2192 n * n + x + n + 1) (*-identity\u02e1 n) \u27e9\n    n * n + n + n + 1           \u2261\u27e8 cong (\u03bb x \u2192 x + n + n + 1) (*\u2261^2 n) \u27e9\n    n ^ 2 + n + n + 1           \u2261\u27e8 cong (\u03bb x \u2192 x + 1) (+-assoc (n ^ 2) n n) \u27e9\n    n ^ 2 + (n + n) + 1         \u2261\u27e8 cong (\u03bb x \u2192 n ^ 2 + x + 1) (+\u22612* n) \u27e9 \n    n ^ 2 + 2 * n + 1           \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":193,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat using (_+_; _*_; _^_)\n\nimport Data.Nat.Solver as Solver\nopen Solver.+-*-Solver using (con; solve; _:*_; _:+_; _:=_; _:^_)\n\nopen import Relation.Binary.PropositionalEquality using (_\u2261_; refl)\n\nexpand : \u2200 n \u2192 (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand = solve 1 (\u03bb n' \u2192 (n' :+ con 1) :^ 2 := n' :^ 2 :+ con 2 :* n' :+ con 1) refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":194,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand n rewrite\n       *-identity\u02b3 (n + 1)\n     | *-identity\u02b3 n\n     | +-comm n 1\n     | *-suc n n\n     | +-identity\u02b3 n\n     | +-suc (n * n + (n + n)) 0\n     | +-identity\u02b3 (n * n + (n + n))\n     | sym (+-assoc n n (n * n))\n     | +-comm (n + n) (n * n)\n     = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":195,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand n = begin\n  (n + 1) ^ 2 \u2261\u27e8 cong (_^ 2) (+-suc n 0) \u27e9\n  (suc n + 0) ^ 2 \u2261\u27e8 cong (\u03bb z \u2192 suc z ^ 2) (+-identity\u02b3 n) \u27e9\n  suc n ^ 2 \u2261\u27e8\u27e9\n  suc n * (suc n * 1) \u2261\u27e8 cong (\u03bb z \u2192 suc n * suc z) (*-identity\u02b3 n) \u27e9\n  suc n * suc n \u2261\u27e8\u27e9\n  suc n + n * suc n \u2261\u27e8 cong (suc n +_) (*-suc n n) \u27e9\n  suc n + (n + n * n) \u2261\u27e8 sym (+-assoc (suc n) n (n * n)) \u27e9\n  suc n + n + n * n \u2261\u27e8 +-comm (suc n + n) (n * n) \u27e9\n  n * n + (suc n + n) \u2261\u27e8 cong (\u03bb z \u2192 n * z + (suc n + n)) (sym (*-identity\u02b3 n)) \u27e9\n  n * (n * 1) + (suc n + n) \u2261\u27e8 cong (\u03bb z \u2192 (n * (n * 1)) + (suc n + z)) (sym (+-identity\u02b3 n)) \u27e9\n  n * (n * 1) + (suc n + (n + 0)) \u2261\u27e8\u27e9\n  n ^ 2 + suc (2 * n) \u2261\u27e8 cong (\u03bb z \u2192 n ^ 2 + suc z) (sym (+-identity\u02b3 (2 * n))) \u27e9\n  n ^ 2 + suc (2 * n + 0) \u2261\u27e8 cong (\u03bb z \u2192 n ^ 2 + z) (sym (+-suc (2 * n) 0)) \u27e9\n  n ^ 2 + (2 * n + 1) \u2261\u27e8 sym (+-assoc (n ^ 2) (2 * n) 1) \u27e9\n  n ^ 2 + 2 * n + 1 \u220e\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":196,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nlemma1-1 : \u2200 (n : \u2115) \u2192 n ^ 1 \u2261 n\nlemma1-1 zero = refl\nlemma1-1 (suc n)\n    rewrite (*-comm (suc n) 1)\n    | +-comm n 0 = refl\n\nlemma1 : \u2200 (n : \u2115) \u2192 n ^ 2 \u2261 n * n\nlemma1 zero = refl\nlemma1 (suc n)\n    rewrite (lemma1-1 (suc n))\n    | *-comm n 1\n    | +-comm n 0 = refl\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand zero = refl\nexpand (suc n)\n    rewrite (lemma1 (suc n + 1))\n    | +-comm n 1\n    | *-comm n 1\n    | +-comm n 0\n    | +-comm (n + n * suc n + suc (n + suc n)) 1\n    | *-comm n (suc (suc n))\n    | *-comm n (suc n)\n    | +-assoc n  (n + n * n) (suc (n + suc n))\n    | +-comm (n + n * n) (suc (n + suc n))\n    | +-comm n (suc n)\n    | +-comm n (n + n * n)\n    | +-assoc n (n * n) n\n    | +-comm (n * n) n\n    | +-assoc n n (n + n * n) = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":197,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\ndist : ( m : \u2115 ) -> ( n : \u2115 ) -> ( o : \u2115 ) -> m * (n + o) \u2261 m * n + m * o\ndist zero _ _ = refl\ndist (suc m) n o = begin\n  suc m * (n + o)\n  \u2261\u27e8\u27e9\n  n + o + m * (n + o)\n  \u2261\u27e8 cong ((n + o) +_ ) (dist m n o) \u27e9\n  (n + o) + (m * n + m * o)\n  \u2261\u27e8 +-comm (n + o) (m * n + m * o) \u27e9\n  (m * n + m * o) + (n + o)\n  \u2261\u27e8 +-assoc (m * n) (m * o) (n + o) \u27e9\n  m * n + (m * o + (n + o))\n  \u2261\u27e8 cong ((m * n) +_ ) (+-comm (m * o) (n + o))\u27e9\n  m * n + ((n + o) + m * o)\n  \u2261\u27e8 cong ((m * n) +_ ) (+-assoc n o (m * o))\u27e9\n  m * n + (n + (o + m * o))\n  \u2261\u27e8\u27e9\n  m * n + (n + (suc m * o))\n  \u2261\u27e8 +-comm (m * n) (n + (suc m * o)) \u27e9\n  (n + (suc m * o)) + m * n\n  \u2261\u27e8 cong ( _+ (m * n)  ) (+-comm n (suc m * o))\u27e9\n  ((suc m * o) + n) + m * n\n  \u2261\u27e8 +-assoc (suc m * o) n (m * n) \u27e9\n  suc m * o + (suc m * n)\n  \u2261\u27e8 +-comm (suc m * o) (suc m * n) \u27e9\n  suc m * n + suc m * o\n  \u220e\n\nmulid : ( x : \u2115 ) -> x \u2261 1 * x\nmulid zero = refl\nmulid (suc n) = begin\n  (suc n)\n  \u2261\u27e8\u27e9\n  zero + (suc n)\n  \u2261\u27e8\u27e9\n  (zero * (suc n)) + (suc n)\n  \u2261\u27e8 +-comm (zero * (suc n)) (suc n) \u27e9\n  (suc n) + (zero * (suc n))\n  \u2261\u27e8\u27e9\n  1 * (suc n)\n  \u220e\n\nsqr : ( x : \u2115 ) -> x * x \u2261 x ^ 2\nsqr zero = refl\nsqr (suc n) = begin\n  (suc n) * (suc n)\n  \u2261\u27e8 mulid (suc n * suc n) \u27e9\n  1 * (suc n * suc n)\n  \u2261\u27e8\u27e9\n  (suc n) ^ zero * (suc n * suc n)\n  \u2261\u27e8 *-comm (suc n ^ zero) (suc n * suc n) \u27e9\n  suc n * suc n * suc n ^ zero\n  \u2261\u27e8 *-assoc (suc n) (suc n) (suc n ^ zero) \u27e9\n  suc n * (suc n * suc n ^ zero)\n  \u2261\u27e8\u27e9\n  suc n * suc n ^ 1\n  \u2261\u27e8\u27e9\n  suc n ^ 2\n  \u220e\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand zero = refl\nexpand (suc n) = begin\n  ((suc n + 1) ^ 2)\n  \u2261\u27e8\u27e9\n  (suc n + 1) * ((suc n + 1) ^ 1)\n  \u2261\u27e8\u27e9\n  (suc n + 1) * ((suc n + 1) * ((suc n + 1) ^ zero))\n  \u2261\u27e8\u27e9\n  (suc n + 1) * ((suc n + 1) * 1)\n  \u2261\u27e8  cong ((suc n + 1) *_ ) (*-comm (suc n + 1) 1)  \u27e9\n  (suc n + 1) * (1 * (suc n + 1))\n  \u2261\u27e8 cong ((suc n + 1) *_ ) refl \u27e9\n  (suc n + 1) * ((suc n + 1) + 0 * (suc n + 1))\n  \u2261\u27e8\u27e9\n  (suc n + 1) * ((suc n + 1) + 0)\n  \u2261\u27e8 cong ((suc n + 1) *_ ) (+-comm (suc n + 1) 0) \u27e9\n  (suc n + 1) * (suc n + 1)\n  \u2261\u27e8 dist (suc n + 1) (suc n) 1 \u27e9\n  (suc n + 1) * (suc n) + (suc n + 1) * 1\n  \u2261\u27e8 cong (((suc n + 1) * (suc n)) +_ ) (*-comm (suc n + 1) 1) \u27e9\n  (suc n + 1) * (suc n) + (1 * (suc n + 1))\n  \u2261\u27e8\u27e9\n  (suc n + 1) * (suc n) + ((suc n + 1) + 0)\n  \u2261\u27e8 cong (((suc n + 1) * (suc n)) +_ ) (+-comm (suc n + 1) 0) \u27e9\n  (suc n + 1) * (suc n) + (suc n + 1)\n  \u2261\u27e8 cong ( _+ (suc n + 1) ) (*-comm (suc n + 1) (suc n)) \u27e9\n  (suc n) * (suc n + 1) + (suc n + 1)\n  \u2261\u27e8 cong ( _+ (suc n + 1) ) (dist (suc n) (suc n) 1) \u27e9\n  (suc n * suc n + suc n * 1) + (suc n + 1)\n  \u2261\u27e8 cong (_+ (suc n + 1)) (cong ( _+ (suc n * 1)) (sqr (suc n))) \u27e9\n  (suc n ^ 2 + suc n * 1) + (suc n + 1)\n  \u2261\u27e8 +-comm (suc n ^ 2 + suc n * 1) (suc n + 1) \u27e9\n  (suc n + 1) + (suc n ^ 2 + suc n * 1)\n  \u2261\u27e8 +-assoc (suc n) 1 (suc n ^ 2 + suc n * 1) \u27e9\n  suc n + (1 + (suc n ^ 2 + suc n * 1))\n  \u2261\u27e8 cong ((suc n) +_) (+-comm 1 (suc n ^ 2 + suc n * 1))\u27e9\n  suc n + (suc n ^ 2 + suc n * 1 + 1)\n  \u2261\u27e8 +-comm (suc n) (suc n ^ 2 + suc n * 1 + 1) \u27e9\n  suc n ^ 2 + suc n * 1 + 1 + suc n\n  \u2261\u27e8 cong (_+ (suc n)) (cong (_+ 1) (cong ((suc n ^ 2) +_) (*-comm (suc n) 1))) \u27e9\n  suc n ^ 2 + 1 * suc n + 1 + suc n\n  \u2261\u27e8 cong ( _+ (suc n)) (+-assoc (suc n ^ 2) (1 * suc n) 1) \u27e9\n  suc n ^ 2 + (1 * suc n + 1) + suc n\n  \u2261\u27e8 +-assoc (suc n ^ 2) (1 * suc n + 1) (suc n) \u27e9\n  suc n ^ 2 + (1 * suc n + 1 + suc n)\n  \u2261\u27e8 cong ((suc n ^ 2) +_) ( +-assoc (1 * suc n) 1 (suc n)) \u27e9\n  suc n ^ 2 + ( 1 * suc n + ( 1 + suc n ) )\n  \u2261\u27e8 cong ((suc n ^ 2) +_) ( +-comm (1 * suc n) (1 + suc n) ) \u27e9\n  suc n ^ 2 + (1 + suc n + 1 * suc n)\n  \u2261\u27e8 cong ((suc n ^ 2) +_) ( +-assoc 1 (suc n) (1 * suc n) ) \u27e9\n  suc n ^ 2 + (1 + 2 * suc n)\n  \u2261\u27e8 cong ((suc n ^ 2) +_) ( +-comm 1 (2 * suc n)) \u27e9\n  suc n ^ 2 + ( 2 * suc n + 1 )\n  \u2261\u27e8 +-comm (suc n ^ 2) (2 * suc n + 1) \u27e9\n  2 * suc n + 1 + suc n ^ 2\n  \u2261\u27e8 cong (_+ (suc n ^ 2)) (+-comm (2 * suc n) 1 ) \u27e9\n  1 + 2 * suc n + suc n ^ 2\n  \u2261\u27e8 +-assoc 1 (2 * suc n) (suc n ^ 2)\u27e9\n  1 + ( 2 * suc n + suc n ^ 2 )\n  \u2261\u27e8 +-comm 1 (2 * suc n + suc n ^ 2) \u27e9\n  2 * suc n + suc n ^ 2 + 1\n  \u2261\u27e8 cong (_+ 1) (+-comm (2 * suc n) (suc n ^ 2)) \u27e9\n  suc n ^ 2 + 2 * suc n + 1\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":198,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Function using (_\u2218_)\nopen \u2261-Reasoning\n\n*-suc : \u2200 m n \u2192 m * suc n \u2261 m + m * n\n*-suc zero    n = refl\n*-suc (suc m) n = begin\n  suc m * suc n         \u2261\u27e8\u27e9\n  suc n + m * suc n     \u2261\u27e8 cong (suc n +_) (*-suc m n) \u27e9\n  suc n + (m + m * n)   \u2261\u27e8\u27e9\n  suc (n + (m + m * n)) \u2261\u27e8 cong suc (sym (+-assoc n m (m * n))) \u27e9\n  suc (n + m + m * n)   \u2261\u27e8 cong (\u03bb x \u2192 suc (x + m * n)) (+-comm n m) \u27e9\n  suc (m + n + m * n)   \u2261\u27e8 cong suc (+-assoc m n (m * n)) \u27e9\n  suc (m + (n + m * n)) \u2261\u27e8\u27e9\n  suc m + suc m * n     \u220e\n\nexpand : \u2200 n \u2192 (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand zero = refl\nexpand (suc n) = begin\n      (suc n + 1) ^ 2\n    \u2261\u27e8 cong (_^ 2) (+-comm (suc n) 1) \u27e9\n      suc (suc n) ^ 2\n    \u2261\u27e8 cong (suc (suc n) *_) (*-identity\u02b3 (suc (suc n))) \u27e9\n      suc (suc n) + suc n * suc (suc n)\n    \u2261\u27e8 cong (suc (suc n) +_) (*-suc (suc n) (suc n)) \u27e9\n      1 + suc n + (suc n + suc n * suc n)\n    \u2261\u27e8 sym (+-assoc (1 + suc n) (suc n) (suc n * suc n)) \u27e9\n      1 + suc n + suc n + suc n * suc n\n    \u2261\u27e8 +-comm (1 + suc n + suc n) (suc n * suc n) \u27e9\n      suc n * suc n + (1 + suc n + suc n)\n    \u2261\u27e8 cong (suc n * suc n +_) (+-assoc 1 (suc n) (suc n)) \u27e9\n      suc n * suc n + (1 + (suc n + suc n))\n    \u2261\u27e8 cong (suc n * suc n +_) (+-comm 1 (suc n + suc n)) \u27e9\n      suc n * suc n + (suc n + suc n + 1)\n    \u2261\u27e8 cong (_+ (suc n + suc n + 1)) (sym (*-identity\u02b3 (suc n * suc n))) \u27e9\n      suc n * suc n * 1 + (suc n + suc n + 1)\n    \u2261\u27e8 cong (_+ (suc n + suc n + 1)) (*-assoc (suc n) (suc n) 1) \u27e9\n      (suc n) ^ 2 + ((suc n + suc n) + 1)\n    \u2261\u27e8 cong (((suc n) ^ 2 +_) \u2218 (_+ 1)) (sym (+-identity\u02b3 (suc n + suc n))) \u27e9\n      (suc n) ^ 2 + ((suc n + suc n + 0) + 1)\n    \u2261\u27e8 cong (((suc n) ^ 2 +_) \u2218 (_+ 1)) (+-assoc (suc n) (suc n) 0) \u27e9\n      (suc n) ^ 2 + (2 * suc n + 1)\n    \u2261\u27e8 sym (+-assoc ((suc n) ^ 2) (2 * suc n) 1)\u27e9\n      refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":199,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver using (module +-*-Solver)\nopen +-*-Solver using (solve; _:*_; _:+_; con; _:=_)\nopen import Relation.Binary.PropositionalEquality\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand = solve 1 (\u03bb n \u2192 (n :+ con 1) :* ((n :+ con 1) :* con 1) := n :* (n :* con 1) :+ (n :+ (n :+ con 0)) :+ con 1) refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":200,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule PerfectSquare where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen import Data.Nat.Solver using (module +-*-Solver)\nopen +-*-Solver using (solve; _:*_; _:+_; con; _:=_)\n\nexpand : \u2200 n -> (n + 1) ^ 2 \u2261 n ^ 2 + 2 * n + 1\nexpand = solve 1 (\u03bb x \u2192 (x :+ con 1) :* ((x :+ con 1) :*  con 1) := x :* (x :* con 1) :+ (x :+ (x :+ con zero)) :+ con 1) refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8f5d3a542ce10001c284c3":[{"id":201,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative {A} _\u2219_ (record { left = left ; right = right }) = record { comm = com }\n  where\n  com : (a b : A) \u2192 a \u2219 b \u2261 b \u2219 a\n  com a b = step4\n    where\n      step1 : a \u2219 b \u2261 ((a \u2219 b) \u2219 a) \u2219 a\n      step1 = sym (left (a \u2219 b) a)\n\n      step2 : ((a \u2219 b) \u2219 a) \u2219 (a \u2219 b) \u2261 a\n      step2 = trans (cong (((a \u2219 b) \u2219 a) \u2219_) step1) (right a ((a \u2219 b) \u2219 a))\n\n      step3 : (a \u2219 b) \u2219 a \u2261 b\n      step3 = trans (sym (left ((a \u2219 b) \u2219 a) (a \u2219 b))) (trans (cong (_\u2219 (a \u2219 b)) step2) (right b a))\n\n      step4 : a \u2219 b \u2261 b \u2219 a\n      step4 = trans (sym (left (a \u2219 b) a)) (cong (_\u2219 a) step3)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":202,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality as Eq using (_\u2261_; cong; sym)\nopen Eq.\u2261-Reasoning\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative {A} (_\u2219_) record { left = left ; right = right } = record { comm = proof }\n  where\n    proof : (x y : A) \u2192 (x \u2219 y) \u2261 (y \u2219 x)\n    proof x y = begin\n                  (x \u2219 y)\n                \u2261\u27e8 sym (left (x \u2219 y) x) \u27e9\n                  ((x \u2219 y) \u2219 x) \u2219 x\n                \u2261\u27e8 cong (_\u2219 x) (cong ((x \u2219 y) \u2219_) (sym (left x y))) \u27e9\n                   ((x \u2219 y) \u2219 ((x \u2219 y) \u2219 y)) \u2219 x\n                \u2261\u27e8 cong (_\u2219 x) (right y (x \u2219 y)) \u27e9\n                   (y \u2219 x)\n                \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":203,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative _\u2219_ record { left = left ; right = right } .comm x y = begin\n  x \u2219 y \u2261\u27e8 sym (left (x \u2219 y) y) \u27e9\n  ((x \u2219 y) \u2219 y) \u2219 y \u2261\u27e8 cong (_\u2219 y) (lemma x y) \u27e9\n  ((y \u2219 x) \u2219 y) \u2219 y \u2261\u27e8 left (y \u2219 x) y \u27e9\n  y \u2219 x \u220e\n  where\n    lemma : \u2200 x y \u2192 (x \u2219 y) \u2219 y \u2261 (y \u2219 x) \u2219 y\n    lemma x y = begin\n      (x \u2219 y) \u2219 y \u2261\u27e8 left x y \u27e9\n      x \u2261\u27e8 sym (right x (y \u2219 x)) \u27e9\n      (y \u2219 x) \u2219 ((y \u2219 x) \u2219 x) \u2261\u27e8 cong ((y \u2219 x) \u2219_) (left y x) \u27e9\n      (y \u2219 x) \u2219 y \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":204,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\ncomm (magic-is-commutative _\u2219_ p) x y =\n  x \u2219 y\n    \u2261\u27e8 sym (right p (x \u2219 y) y) \u27e9\n  y \u2219 (y \u2219 (x \u2219 y))\n    \u2261\u27e8 cong (\u03bb z \u2192 y \u2219 (z \u2219 (x \u2219 y))) (sym (right p y x)) \u27e9\n  y \u2219 ((x \u2219 (x \u2219 y)) \u2219 (x \u2219 y))\n    \u2261\u27e8 cong (y \u2219_) (left p x (x \u2219 y)) \u27e9\n  y \u2219 x\n    \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":205,"user_id":1125,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality using (_\u2261_; cong; trans; sym)\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\ncomm (magic-is-commutative _\u2219_ is-magical) x y = let \n  L = left is-magical\n  R = right is-magical\n  in \n    sym (\n      trans \n        (sym (R (y \u2219 x) x)) \n        (cong (\\t -> x \u2219 t) \n          (\n            trans \n              (sym \n                (cong (\\t -> t \u2219 (y \u2219 x)) \n                  (R x y)\n                )\n              ) \n              (L y (y \u2219 x))\n            )\n        )\n    )","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":206,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nhelp-comm : {A : Set} (_\u00b7_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u00b7_ \u2192 (\u2200 x y \u2192 x \u00b7 y \u2261 y \u00b7 x)\nhelp-comm _\u00b7_ j a b = begin\n  a \u00b7 b\n  \u2261\u27e8 cong (_\u00b7 b) (sym (right j a (b \u00b7 a))) \u27e9\n  ((b \u00b7 a) \u00b7 ((b \u00b7 a) \u00b7 a)) \u00b7 b\n  \u2261\u27e8 cong (\u03bb x \u2192 ((b \u00b7 a) \u00b7 x) \u00b7 b) (left j b a) \u27e9\n  ((b \u00b7 a) \u00b7 b) \u00b7 b\n  \u2261\u27e8 left j (b \u00b7 a) b \u27e9\n  b \u00b7 a\n  \u220e\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative k j = record{ comm = help-comm k j}","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":207,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; sym; cong)\nopen Eq.\u2261-Reasoning\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative _\u2219_ m = record { comm = comm-lemma }\n  where\n  conj-lemma : \u2200 x y \u2192 y \u2261 (x \u2219 y) \u2219 x\n  conj-lemma x y = begin\n    y\n      \u2261\u27e8 sym (right m y (x \u2219 y)) \u27e9\n    (x \u2219 y) \u2219 ((x \u2219 y) \u2219 y)\n      \u2261\u27e8 cong ((x \u2219 y) \u2219_) (left m x y) \u27e9\n    (x \u2219 y) \u2219 x \u220e\n\n  comm-lemma : \u2200 x y \u2192 x \u2219 y \u2261 y \u2219 x\n  comm-lemma x y = begin\n    x \u2219 y\n      \u2261\u27e8 cong (_\u2219 y) (conj-lemma y x) \u27e9\n    ((y \u2219 x) \u2219 y) \u2219 y\n      \u2261\u27e8 left m (y \u2219 x) y \u27e9\n    y \u2219 x \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":208,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning \n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\ncomm (magic-is-commutative _\u2219_ record { left = left ; right = right }) x y = \n  begin\n    x \u2219 y \u2261\u27e8 cong (x \u2219_) (sym (left y (y \u2219 x))) \u27e9\n    x \u2219 ((y \u2219 (y \u2219 x)) \u2219 (y \u2219 x)) \u2261\u27e8 cong (\u03bb u \u2192 x \u2219 (u \u2219 (y \u2219 x))) (right x y) \u27e9\n    x \u2219 (x \u2219 (y \u2219 x)) \u2261\u27e8 right (y \u2219 x) x \u27e9\n    y \u2219 x\n  \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":209,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality using (_\u2261_; sym; cong)\nopen Relation.Binary.PropositionalEquality.\u2261-Reasoning\n\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative _\u2219_ magic = record { comm = com }\n  where  com : _\n         com x y = begin\n           x \u2219 y \u2261\u27e8 cong (\u03bb z \u2192 x \u2219 z) (sym (left magic y (y \u2219 x))) \u27e9\n           x \u2219 ((y \u2219 (y \u2219 x)) \u2219 (y \u2219 x)) \u2261\u27e8 cong (\u03bb z \u2192 x \u2219 (z \u2219 (y \u2219 x))) (right magic x y) \u27e9 \n           x \u2219 (x \u2219 (y \u2219 x)) \u2261\u27e8 right magic (y \u2219 x) x \u27e9 \n           y \u2219 x \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":210,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule MagicIsCommutative where\n\nopen import Relation.Binary.PropositionalEquality using (_\u2261_; trans; sym; cong)\n\nimport Relation.Binary.EqReasoning as EqR\n\nrecord IsMagical {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    left         : \u2200 x y \u2192 (x \u2219 y) \u2219 y  \u2261  x\n    right        : \u2200 x y \u2192 y \u2219 (y \u2219 x)  \u2261  x\n\nrecord IsCommuntative {A : Set} (_\u2219_ : A \u2192 A \u2192 A) : Set where\n  field\n    comm         : \u2200 x y \u2192 x \u2219 y  \u2261 y \u2219 x\n\nopen IsMagical\nopen IsCommuntative\n\nmagic-is-commutative : {A : Set} (_\u2219_ : A \u2192 A \u2192 A) \u2192 IsMagical _\u2219_ \u2192 IsCommuntative _\u2219_\nmagic-is-commutative {A} _\u00b7_ record { left = left ; right = right }\n  = record { comm = theorem }\n    where theorem : \u2200 (x y : A) \u2192 x \u00b7 y \u2261 y \u00b7 x\n          theorem x y = trans (sym (left (x \u00b7 y) x)) (cong (_\u00b7 x) (trans (cong ((x \u00b7 y) \u00b7_) (sym (left x y))) (right y (x \u00b7 y))))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8feaf38cf201351776dd99":[{"id":211,"user_id":null,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import StreamDef\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\n\npath\u2261bisim : {A : Set} \u2192 {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\npath\u2261bisim = isoToPath (iso f g (\u03bb b \u2192 inv2 b) \u03bb p \u2192 inv1 p) where \n  f : {S : Set} \u2192 {a b : Stream S} \u2192 (a \u2261 b) \u2192 (a == b)\n  refl-head (f p) = cong head p\n  refl-tail (f p) = f (cong tail p)\n\n  g : {S : Set} \u2192 {a b : Stream S} \u2192 (a == b) \u2192 (a \u2261 b)\n  head (g bs i) = refl-head bs i\n  tail (g bs i) = g (refl-tail bs) i\n\n  inv1 : {S : Set} \u2192 {a b : Stream S} \u2192 (p : a \u2261 b) \u2192  g (f p) \u2261 p \n  head (inv1 p i j) = head (p j)\n  tail (inv1 p i j) = inv1 (cong tail p) i j\n\n  inv2 : {S : Set} \u2192 {a b : Stream S} \u2192 (bs : a == b) \u2192  f (g bs) \u2261 bs\n  refl-head (inv2 bs i) = refl-head bs\n  refl-tail (inv2 bs i) = inv2 (refl-tail bs) i\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":212,"user_id":522,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import StreamDef\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\n\n{-\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n-}\n\n\npath\u2261bisim : {A : Set} \u2192 {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\npath\u2261bisim = isoToPath (iso to from to\u2218from from\u2218to)\n  where\n    to : \u2200 {x y} \u2192 x \u2261 y \u2192 x == y\n    refl-head (to p) = cong head p\n    refl-tail (to p) = to (cong tail p)\n\n    from : \u2200 {x y} \u2192 x == y \u2192 x \u2261 y\n    head (from p i) = refl-head p i\n    tail (from p i) = from (refl-tail p) i\n\n    to\u2218from : \u2200 {x y} (p : x == y) \u2192 to (from p) \u2261 p\n    refl-head (to\u2218from p _) = refl-head p\n    refl-tail (to\u2218from p i) = to\u2218from (refl-tail p) i\n\n    from\u2218to : \u2200 {x y} (p : x \u2261 y) \u2192 from (to p) \u2261 p\n    head (from\u2218to p _ j) = head (p j)\n    tail (from\u2218to p i j) = from\u2218to (cong tail p) i j","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":213,"user_id":null,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import Agda.Builtin.Cubical.Path using (_\u2261_)\nopen import Cubical.Foundations.Isomorphism using (iso; isoToPath)\n\nopen import StreamDef\n\n{-\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n-}\n\nbisim\u2192path : {A : Set} \u2192 {x y : Stream A} \u2192 x == y \u2192 x \u2261 y\nhead (bisim\u2192path x==y i) = refl-head x==y i\ntail (bisim\u2192path x==y i) = bisim\u2192path (refl-tail x==y) i\n\npath\u2192bisim : {A : Set} \u2192 {x y : Stream A} \u2192 x \u2261 y \u2192 x == y\nrefl-head (path\u2192bisim x\u2261y) = \u03bb i \u2192 head (x\u2261y i)\nrefl-tail (path\u2192bisim x\u2261y) = path\u2192bisim (\u03bb i \u2192 tail (x\u2261y i))\n\npath\u2192bisim\u2192path : {A : Set} \u2192 {x y : Stream A} \u2192 (x\u2261y : x \u2261 y) \u2192 bisim\u2192path (path\u2192bisim x\u2261y) \u2261 x\u2261y\nhead (path\u2192bisim\u2192path x\u2261y i j) = head (x\u2261y j)\ntail (path\u2192bisim\u2192path x\u2261y i j) = path\u2192bisim\u2192path (\u03bb i \u2192 tail (x\u2261y i)) i j\n\nbisim\u2192path\u2192bisim : {A : Set} \u2192 {x y : Stream A} \u2192 (x==y : x == y) \u2192 path\u2192bisim (bisim\u2192path x==y) \u2261 x==y\nrefl-head (bisim\u2192path\u2192bisim x==y i) = refl-head x==y\nrefl-tail (bisim\u2192path\u2192bisim x==y i) = bisim\u2192path\u2192bisim (refl-tail x==y) i\n  \npath\u2261bisim : {A : Set} \u2192 {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\npath\u2261bisim = isoToPath (iso path\u2192bisim bisim\u2192path bisim\u2192path\u2192bisim path\u2192bisim\u2192path)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":214,"user_id":490,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import StreamDef\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Isomorphism\nopen import Cubical.Foundations.Equiv\nopen import Cubical.Foundations.Univalence\n\nprivate variable A : Set\n\n{-\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n-}\n\nbisim : {x y : Stream A} \u2192 x == y \u2192 x \u2261 y\nhead (bisim x==y i) = refl-head x==y i\ntail (bisim x==y i) = bisim (refl-tail x==y) i\n\nmisib : {x y : Stream A} \u2192 x \u2261 y \u2192 x == y\nrefl-head (misib p) = \u03bb i \u2192 head (p i)\nrefl-tail (misib p) = misib (\u03bb i \u2192 tail (p i))\n\niso1 : {x y : Stream A} \u2192 (p : x \u2261 y) \u2192 bisim (misib p) \u2261 p\nhead (iso1 p i j) = head (p j)\ntail (iso1 p i j) = iso1 (\u03bb i \u2192 tail (p i)) i j\n\niso2 : {x y : Stream A} \u2192 (p : x == y) \u2192 misib (bisim p) \u2261 p\nrefl-head (iso2 p i) = refl-head p\nrefl-tail (iso2 p i) = iso2 (refl-tail p) i\n\npath\u2243bisim : {x y : Stream A} \u2192 (x \u2261 y) \u2243 (x == y)\npath\u2243bisim = isoToEquiv (iso misib bisim iso2 iso1)\n\npath\u2261bisim : {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\npath\u2261bisim = ua path\u2243bisim\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":215,"user_id":568,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import StreamDef\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\n\n\nmodule _ {A : Set} where\n  ==-refl : (x : Stream A) \u2192 x == x\n  refl-head (==-refl x) = refl\n  refl-tail (==-refl x) = ==-refl (tail x)\n\n  path-bisim : {x y : Stream A} \u2192 (x \u2261 y) \u2192 (x == y)\n  refl-head (path-bisim pa) = cong head pa\n  refl-tail (path-bisim pa) = path-bisim (cong tail pa)\n\n  bisim-path : {x y : Stream A} \u2192 (x == y) \u2192 (x \u2261 y)\n  head (bisim-path bi i) = refl-head bi i\n  tail (bisim-path bi i) = bisim-path (refl-tail bi) i\n\n  lem-section : {x y : Stream A} (bi : x == y) \u2192 path-bisim (bisim-path bi) \u2261 bi\n  refl-head (lem-section bi i) = refl-head bi\n  refl-tail (lem-section bi i) = lem-section (refl-tail bi) i\n\n  lem-retract : {x y : Stream A} (pa : x \u2261 y) \u2192 bisim-path (path-bisim pa) \u2261 pa\n  head (lem-retract pa i j) = head (pa j)\n  tail (lem-retract pa i j) = lem-retract (cong tail pa) i j\n\n  path\u2261bisim : {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\n  path\u2261bisim = isoToPath (iso path-bisim bisim-path lem-section lem-retract)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":216,"user_id":1163,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import StreamDef\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\n\n{-\nrecord Stream (A : Set) : Set where\n  coinductive\n  field\n    head : A\n    tail : Stream A\nopen Stream public\n\n-- | Bisimulation as equality\nrecord _==_ {A : Set} (x : Stream A) (y : Stream A) : Set where\n  coinductive\n  field\n    refl-head : head x \u2261 head y\n    refl-tail : tail x == tail y\nopen _==_ public\n-}\n\n\npath\u2192bisim : {A : Set} {x y : Stream A} \u2192 (x \u2261 y) \u2192 (x == y)\npath\u2192bisim p .refl-head i = head (p i)\npath\u2192bisim p .refl-tail = path\u2192bisim \u03bb i \u2192 tail (p i)\n\nbisim\u2192path : {A : Set} {x y : Stream A} \u2192 (x == y) \u2192 x \u2261 y\nbisim\u2192path b i .head = b .refl-head i\nbisim\u2192path b i .tail = bisim\u2192path (b .refl-tail) i\n\npath\u2192bisim\u2192path : {A : Set} {x y : Stream A} (p : x \u2261 y) \u2192\n                  bisim\u2192path (path\u2192bisim p) \u2261 p\npath\u2192bisim\u2192path p i j .head = p j .head\npath\u2192bisim\u2192path p i j .tail = path\u2192bisim\u2192path (\u03bb i \u2192 p i .tail) i j\n\nbisim\u2192path\u2192bisim : {A : Set} {x y : Stream A} (p : x == y) \u2192\n                   path\u2192bisim (bisim\u2192path p) \u2261 p\nbisim\u2192path\u2192bisim p i .refl-head = p .refl-head\nbisim\u2192path\u2192bisim p i .refl-tail = bisim\u2192path\u2192bisim (p .refl-tail) i\n\npath\u2261bisim : {A : Set} {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\npath\u2261bisim = ua (isoToEquiv (iso path\u2192bisim bisim\u2192path bisim\u2192path\u2192bisim path\u2192bisim\u2192path))\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":217,"user_id":168,"body":"{-# OPTIONS --copattern --cubical --safe --no-sized-types --guardedness #-}\nmodule CPP where\n\nopen import StreamDef\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Isomorphism\n\npath-imp-bisim : {A : Set} \u2192 {x y : Stream A} \u2192 (x \u2261 y) \u2192 x == y\nrefl-head (path-imp-bisim p) = cong head p\nrefl-tail (path-imp-bisim p) = path-imp-bisim (cong tail p)\n\nbisim-imp-path : {A : Set} \u2192 {x y : Stream A} \u2192 x == y \u2192 x \u2261 y\nhead (bisim-imp-path b i) = refl-head b i\ntail (bisim-imp-path b i) = bisim-imp-path (refl-tail b) i\n\nsection-lemma : {A : Set} {x y : Stream A} \u2192 section (path-imp-bisim {A} {x} {y}) bisim-imp-path\nrefl-head (section-lemma b i) = refl-head b\nrefl-tail (section-lemma b i) = section-lemma (refl-tail b) i\n\nretract-lemma : {A : Set} {x y : Stream A} \u2192 retract (path-imp-bisim {A} {x} {y}) bisim-imp-path\nhead (retract-lemma p i j) = head (p j)\ntail (retract-lemma p i j) = retract-lemma (cong tail p) i j\n\nisoBisim : {A : Set} \u2192 (x y : Stream A) \u2192 Iso (x \u2261 y) (x == y)\nisoBisim x y = iso path-imp-bisim bisim-imp-path section-lemma retract-lemma\n\npath\u2261bisim : {A : Set} \u2192 {x y : Stream A} \u2192 (x \u2261 y) \u2261 (x == y)\npath\u2261bisim {A} {x} {y} = isoToPath (isoBisim x y)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c91bfdaac8b333b7f2fb5c7":[{"id":218,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL# m' = m'\n(top+ m) SL# m' = top+ (m SL# m')\n(bot+ m) SL# m' = bot+ (m SL# m')\n\n_+0 : \u2200 {a b c : \u2115} {{p : c \u2261 zero}} \u2192 a \u2261 b \u2192 a \u2261 b + c\n_+0 {{p = p}} eq rewrite p = trans eq (sym (+-identity\u02b3 _))\n\ninfixr 4 _+0\n\n_\u2263_ = trans\ninfixl 4 _\u2263_\n\nred : \u2200 {m : Mat} {e f : \u2115} \u2192 a m * e + b m * f + (c m * e + d m * f) \u2261 (a m + c m) * e + (b m + d m) * f\nred {mat a b c d} {e} {f} =\n  swap {a * e} {b * f} {c * e} {d * f} \u2263 sym (cong\u2082 _+_ (*-distrib\u02b3-+ e a c) (*-distrib\u02b3-+ f b d))\n  where\n    open \u2261-Reasoning\n    swap : \u2200 {a b c d : \u2115} \u2192 (a + b) + (c + d) \u2261 (a + c) + (b + d)\n    swap {a} {b} {c} {d} = begin\n        a + b + (c + d)\n      \u2261\u27e8 sym (+-assoc (a + b) c d) \u27e9\n        a + b + c + d\n      \u2261\u27e8 cong (\u03bb x \u2192 x + d) (+-assoc a b c)  \u27e9\n        a + (b + c) + d\n      \u2261\u27e8 cong (\u03bb x \u2192 a + x + d) (+-comm b c)  \u27e9\n        a + (c + b) + d\n      \u2261\u27e8 cong (\u03bb x \u2192 x + d) (sym (+-assoc a c b))  \u27e9\n        a + c + b + d\n      \u2261\u27e8 +-assoc (a + c) b d \u27e9\n        (a + c) + (b + d)\n      \u220e\n\n#-identity\u02e1 : \u2200 m \u2192 m \u2261 (eval I) # m\n#-identity\u02e1 m = congMat (refl +0 +0) (refl +0 +0) (refl +0) (refl +0)\n\n#-identity\u02b3 : \u2200 m \u2192 m \u2261 m # (eval I)\n#-identity\u02b3 (mat a b c d) =\n  congMat (_+0 {{*-zero\u02b3 b}} (sym (*-identity\u02b3 a)))\n          (sym (cong\u2082 _+_ (*-zero\u02b3 a) (*-identity\u02b3 b)))\n          (_+0 {{*-zero\u02b3 d}} (sym (*-identity\u02b3 c)))\n          (sym (cong\u2082 _+_ (*-zero\u02b3 c) (*-identity\u02b3 d)))\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' = #-identity\u02e1 (eval m')\nSL#-eq-# (top+ m) m' rewrite SL#-eq-# m m' =\n  congMat (red {eval m} {a (eval m')} {c (eval m')})\n          (red {eval m} {b (eval m')} {d (eval m')}) refl refl\nSL#-eq-# (bot+ m) m' rewrite SL#-eq-# m m' =\n  congMat refl refl (red {eval m} {a (eval m')} {c (eval m')})\n                    (red {eval m} {b (eval m')} {d (eval m')})\n\n-- Task 2-1. Define transpose in SL2N domain.\nhelpT : SL2N \u2192 SL2N \u2192 SL2N\nhelpT m I = m\nhelpT m (top+ m') = helpT (bot+ m) m'\nhelpT m (bot+ m') = helpT (top+ m) m'\n\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nm SL^T = helpT I m\n\nred2 : \u2200 (a b c d : \u2115) \u2192 a * b + c * (b + d) \u2261 (a + c) * b + c * d\nred2 a b c d = begin\n    a * b + c * (b + d)\n  \u2261\u27e8 cong (\u03bb x \u2192 a * b + x) (*-distrib\u02e1-+ c b d) \u27e9\n    a * b + (c * b + c * d)\n  \u2261\u27e8 sym (+-assoc (a * b) (c * b) (c * d)) \u27e9\n    a * b + c * b + c * d\n  \u2261\u27e8 cong (\u03bb x \u2192 x + c * d) (sym (*-distrib\u02b3-+ b a c)) \u27e9\n    (a + c) * b + c * d\n  \u220e\n  where open \u2261-Reasoning\n\nred3 : \u2200 (a b c d : \u2115) \u2192 a * (b + c) + d * c \u2261 a * b + (a + d) * c\nred3 a b c d =\n  (+-comm (a * (b + c)) (d * c)) \u2263\n  (cong (\u03bb x \u2192 d * c + a * x) (+-comm b c)) \u2263\n  (red2 d c a b) \u2263\n  (cong (\u03bb x \u2192 x * c + a * b) (+-comm d a)) \u2263\n  (+-comm ((a + d) * c) (a * b))\n\nlemma : \u2200 {m m' : SL2N} \u2192 eval (helpT m m') \u2261 (eval m' ^T) # eval m\nlemma {m} {I} = #-identity\u02e1 (eval m)\nlemma {m} {top+ m'} rewrite lemma {bot+ m} {m'} with eval m | eval m'\n... | mat a b c d | mat a' b' c' d' = congMat (red2 a' a c' c) (red2 a' b c' d) (red2 b' a d' c) (red2 b' b d' d)\nlemma {m} {bot+ m'} rewrite lemma {top+ m} {m'} with eval m | eval m'\n... | mat a b c d | mat a' b' c' d' = congMat (red3 a' a c c') (red3 a' b d c') (red3 b' a c d') (red3 b' b d d')\n\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T m rewrite lemma {I} {m} = sym (#-identity\u02b3 (eval m ^T))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":219,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Solver using (module +-*-Solver)\nopen +-*-Solver using (solve; _:*_; _:+_; con; _:=_)\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI    SL# m' = m'\n(top+ m) SL# m' = top+ (m SL# m')\n(bot+ m) SL# m' = bot+ (m SL# m')\n\nrightZ : \u2200 n \u2192 n \u2261 n + 0\nrightZ n = sym (+-identity\u02b3 n)\n\nrightZZ : \u2200 n \u2192 n \u2261 n + 0 + 0\nrightZZ n =  trans (rightZ n) (rightZ (n + 0))\n\nmotherExpr : \u2200 a b c d x z \u2192 a * x + b * z + (c * x + d * z) \u2261 (a + c) * x + (b + d) * z\nmotherExpr = solve 6 (\u03bb a b c d x z \u2192 (a :* x) :+ (b :* z) :+ (c :* x :+ d :* z) := ((a :+ c) :* x) :+ (b :+ d) :* z) refl\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' with eval m'\n... | mat w x y z = congMat (rightZZ w) (rightZZ x) (rightZ y) (rightZ z)\nSL#-eq-# (top+ m) m' with eval m | eval m' | eval (m SL# m') | SL#-eq-# m m'\n... | mat a b c d | mat w x y z | _ | refl = congMat (motherExpr a b c d w y) (motherExpr a b c d x z) refl refl\nSL#-eq-# (bot+ m) m' with eval m | eval m' | eval (m SL# m') | SL#-eq-# m m'\n... | mat a b c d | mat w x y z | _ | refl = congMat refl refl (motherExpr a b c d w y) (motherExpr a b c d x z)\n\nappend : (SL2N \u2192 SL2N) \u2192 SL2N \u2192 SL2N\nappend f I = f I\nappend f (top+ m) = top+ (append f m)\nappend f (bot+ m) = bot+ (append f m)\n\nrev : SL2N \u2192 SL2N\nrev I = I\nrev (top+ m) = append top+ (rev m)\nrev (bot+ m) = append bot+ (rev m)\n\nflip : SL2N \u2192 SL2N\nflip I = I\nflip (top+ n) = bot+ (flip n)\nflip (bot+ n) = top+ (flip n)\n\n-- Task 2-1. Define transpose in SL2N domain.\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nm SL^T = flip (rev m)\n\nwow : \u2200 a\u2081 a\u2082 a\u2083 b\u2081 b\u2082 c\u2082 c\u2083 d\u2082 \u2192\n  a\u2081 * (a\u2082 * a\u2083 + b\u2082 * c\u2083) + b\u2081 * (c\u2082 * a\u2083 + d\u2082 * c\u2083) \u2261\n  (a\u2081 * a\u2082 + b\u2081 * c\u2082) * a\u2083 + (a\u2081 * b\u2082 + b\u2081 * d\u2082) * c\u2083\nwow = solve 8 (\u03bb a\u2081 a\u2082 a\u2083 b\u2081 b\u2082 c\u2082 c\u2083 d\u2082 \u2192\n  a\u2081 :* (a\u2082 :* a\u2083 :+ b\u2082 :* c\u2083) :+ b\u2081 :* (c\u2082 :* a\u2083 :+ d\u2082 :* c\u2083) :=\n  (a\u2081 :* a\u2082 :+ b\u2081 :* c\u2082) :* a\u2083 :+ (a\u2081 :* b\u2082 :+ b\u2081 :* d\u2082) :* c\u2083) refl\n\nassoc : \u2200 a b c \u2192 a # (b # c) \u2261 (a # b) # c\nassoc (mat a\u2081 b\u2081 c\u2081 d\u2081) (mat a\u2082 b\u2082 c\u2082 d\u2082) (mat a\u2083 b\u2083 c\u2083 d\u2083) = congMat\n  (wow a\u2081 a\u2082 a\u2083 b\u2081 b\u2082 c\u2082 c\u2083 d\u2082) (wow a\u2081 a\u2082 b\u2083 b\u2081 b\u2082 c\u2082 d\u2083 d\u2082)\n  (wow c\u2081 a\u2082 a\u2083 d\u2081 b\u2082 c\u2082 c\u2083 d\u2082) (wow c\u2081 a\u2082 b\u2083 d\u2081 b\u2082 c\u2082 d\u2083 d\u2082)\n\ni uu : Mat\ni = mat 1 0 0 1\nuu = mat 1 1 0 1\n--dd = mat 1 0 1 1 = uu ^T\n\neval4 : (m : SL2N) \u2192 Mat\neval4 I = i\neval4 (top+ m) = uu # eval4 m\neval4 (bot+ m) = (uu ^T) # eval4 m\n\nzeroes : \u2200 a b \u2192 a + b \u2261 a + 0 + (b + 0)\nzeroes = solve 2 (\u03bb a b \u2192 a :+ b := a :+ con 0 :+ (b :+ con 0)) refl\n\nlemfattop : \u2200 m \u2192 flip (append top+ m) \u2261 append bot+ (flip m)\nlemfattop I = refl\nlemfattop (top+ x) = cong bot+ (lemfattop x)\nlemfattop (bot+ x) = cong top+ (lemfattop x)\n\nlemfatbot : \u2200 m \u2192 flip (append bot+ m) \u2261 append top+ (flip m)\nlemfatbot I = refl\nlemfatbot (top+ x) = cong bot+ (lemfatbot x)\nlemfatbot (bot+ x) = cong top+ (lemfatbot x)\n\nappendtop : \u2200 m \u2192 (top+ m) SL^T \u2261 append bot+ (m SL^T)\nappendtop I = refl\nappendtop (top+ m) = lemfattop (append top+ (rev m))\nappendtop (bot+ m) = lemfattop (append bot+ (rev m))\n\nappendbot : \u2200 m \u2192 (bot+ m) SL^T \u2261 append top+ (m SL^T)\nappendbot I = refl\nappendbot (top+ m) = lemfatbot (append top+ (rev m))\nappendbot (bot+ m) = lemfatbot (append bot+ (rev m))\n\nappendboteval : \u2200 m \u2192 eval4 (append bot+ m) \u2261 eval4 m # (uu ^T)\nappendboteval I = refl\nappendboteval (top+ m) = trans (cong (_#_ uu) (appendboteval m)) (assoc uu (eval4 m) (uu ^T))\nappendboteval (bot+ m) = trans (cong (_#_ (uu ^T)) (appendboteval m)) (assoc (uu ^T) (eval4 m) (uu ^T))\n\nappendtopeval : \u2200 m \u2192 eval4 (append top+ m) \u2261 eval4 m # uu\nappendtopeval I = refl\nappendtopeval (top+ m) = trans (cong (_#_ uu) (appendtopeval m)) (assoc uu (eval4 m) uu)\nappendtopeval (bot+ m) = trans (cong (_#_ (uu ^T)) (appendtopeval m)) (assoc (uu ^T) (eval4 m) uu)\n\nlem0 : \u2200 m \u2192 eval4 (top+ m SL^T) \u2261 eval4 (m SL^T) # (uu ^T)\nlem0 m = trans (cong eval4 (appendtop m)) (appendboteval (flip (rev m)))\n\nlem1 : \u2200 m \u2192 eval4 (bot+ m SL^T) \u2261 eval4 (m SL^T) # uu\nlem1 m = trans (cong eval4 (appendbot m)) (appendtopeval (flip (rev m)))\n\nbabyExpr : \u2200 a b c d \u2192 a * b + c * d \u2261 b * a + d * c\nbabyExpr = solve 4 (\u03bb a b c d \u2192 (a :* b) :+ (c :* d) := (b :* a) :+ (d :* c)) refl\n\n-- transpose distributes and reverses order\ndistrib^T : \u2200 m n \u2192 (m ^T) # (n ^T) \u2261 (n # m) ^T\ndistrib^T (mat a b c d) (mat w x y z) = congMat\n  (babyExpr a w c x) (babyExpr a y c z)\n  (babyExpr b w d x) (babyExpr b y d z)\n\nlem3 : \u2200 m \u2192 eval4 (m SL^T) \u2261 eval4 m ^T \u2192 eval4 (m SL^T) # uu ^T \u2261 (uu # eval4 m) ^T\nlem3 m p = trans (cong (\u03bb x \u2192 x # (uu ^T)) p) (distrib^T (eval4 m) uu)\n\nlem4 : \u2200 m \u2192 eval4 (m SL^T) \u2261 eval4 m ^T \u2192 eval4 (m SL^T) # uu \u2261 (uu ^T # eval4 m) ^T\nlem4 m p = trans (cong (\u03bb x \u2192 x # uu) p) (distrib^T (eval4 m) (uu ^T))\n\neval\u2261eval4 : \u2200 m \u2192 eval m \u2261 eval4 m\neval\u2261eval4 I = refl\neval\u2261eval4 (top+ m) with eval m | eval4 m | eval\u2261eval4 m\n... | mat a b c d | .(mat a b c d) | refl = congMat (zeroes a c) (zeroes b d) (rightZ c) (rightZ d)\neval\u2261eval4 (bot+ m) with eval m | eval4 m | eval\u2261eval4 m\n... | mat a b c d | .(mat a b c d) | refl = congMat (rightZZ a) (rightZZ b) (zeroes a c) (zeroes b d)\n\nSLeqT : \u2200 m \u2192 eval4 (m SL^T) \u2261 (eval4 m) ^T\nSLeqT I = refl\nSLeqT (top+ m) = trans (lem0 m) (lem3 m (SLeqT m))\nSLeqT (bot+ m) = trans (lem1 m) (lem4 m (SLeqT m))\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T m = trans (eval\u2261eval4 (m SL^T)) (trans (SLeqT m) (cong _^T (sym (eval\u2261eval4 m))))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":220,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL# m' = m'\ntop+ m SL# m' = top+ (m SL# m')\nbot+ m SL# m' = bot+ (m SL# m')\n\nmul-left-id : \u2200 (m : Mat) \u2192 m \u2261 (mat 1 0 0 1) # m\nmul-left-id m rewrite *-identity\u02e1 (a m) | +-identity\u02b3 (a m) | +-identity\u02b3 (b m) | +-identity\u02b3 (b m) | +-identity\u02b3 (c m) | +-identity\u02b3 (d m) = congMat refl refl refl refl\n\nresort : \u2200 (a b c d) \u2192 (a + b) + (c + d) \u2261 (a + c) + (b + d)\nresort a b c d rewrite +-assoc a b (c + d) | sym (+-assoc b c d) | +-comm b c | +-assoc c b d | sym (+-assoc a c (b + d)) = refl\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' = begin\n  eval (I SL# m') \u2261\u27e8\u27e9\n  eval m' \u2261\u27e8 mul-left-id (eval m') \u27e9\n  eval I # eval m' \u220e\nSL#-eq-# (top+ m) m' = let \n  em = eval m\n  en = eval m'\n  pr = eval (m SL# m')\n  in\n  begin\n  eval ((top+ m) SL# m') \u2261\u27e8\u27e9\n  eval (top+ (m SL# m')) \u2261\u27e8\u27e9\n  mat ((a pr) + (c pr)) ((b pr) + (d pr)) (c pr) (d pr) \u2261\u27e8 cong (\u03bb p \u2192 mat ((a p) + (c p)) ((b p) + (d p)) (c p) (d p)) (SL#-eq-# m m') \u27e9\n  mat ((a em * a en + b em * c en) + (c em * a en + d em * c en))\n      ((a em * b en + b em * d en) + (c em * b en + d em * d en))\n      (c em * a en + d em * c en)\n      (c em * b en + d em * d en) \u2261\u27e8 congMat (resort (a em * a en) (b em * c en) (c em * a en) (d em * c en)) (resort (a em * b en) (b em * d en) (c em * b en) (d em * d en)) refl refl \u27e9\n  mat ((a em * a en + c em * a en) + (b em * c en + d em * c en))\n      ((a em * b en + c em * b en) + (b em * d en + d em * d en))\n      (c em * a en + d em * c en)\n      (c em * b en + d em * d en) \u2261\u27e8 congMat (cong\u2082 (_+_) (sym (*-distrib\u02b3-+ (a en) (a em) (c em))) (sym (*-distrib\u02b3-+ (c en) (b em) (d em)))) (cong\u2082 (_+_) (sym (*-distrib\u02b3-+ (b en) (a em) (c em))) (sym (*-distrib\u02b3-+ (d en) (b em) (d em)))) refl refl \u27e9\n  mat ((a em + c em) * a en + (b em + d em) * c en)\n      ((a em + c em) * b en + (b em + d em) * d en)\n      (c em * a en + d em * c en)\n      (c em * b en + d em * d en) \u2261\u27e8\u27e9\n  mat (a em + c em) (b em + d em) (c em) (d em) # en \u2261\u27e8\u27e9\n  eval (top+ m) # eval m' \u220e\nSL#-eq-# (bot+ m) m' = let\n  em = eval m\n  en = eval m'\n  pr = eval (m SL# m')\n  in\n  begin\n  eval ((bot+ m) SL# m') \u2261\u27e8\u27e9\n  eval (bot+ (m SL# m')) \u2261\u27e8\u27e9\n  mat (a pr) (b pr) (a pr + c pr) (b pr + d pr) \u2261\u27e8 cong (\u03bb p \u2192 mat (a p) (b p) (a p + c p) (b p + d p)) (SL#-eq-# m m') \u27e9\n  mat (a em * a en + b em * c en)\n      (a em * b en + b em * d en)\n      ((a em * a en + b em * c en) + (c em * a en + d em * c en)) \n      ((a em * b en + b em * d en) + (c em * b en + d em * d en)) \u2261\u27e8 congMat refl refl (resort (a em * a en) (b em * c en) (c em * a en) (d em * c en)) (resort (a em * b en) (b em * d en) (c em * b en) (d em * d en)) \u27e9\n  mat (a em * a en + b em * c en)\n      (a em * b en + b em * d en)\n      ((a em * a en + c em * a en) + (b em * c en + d em * c en))\n      ((a em * b en + c em * b en) + (b em * d en + d em * d en)) \u2261\u27e8 congMat refl refl (cong\u2082 (_+_) (sym (*-distrib\u02b3-+ (a en) (a em) (c em))) (sym (*-distrib\u02b3-+ (c en) (b em) (d em)))) (cong\u2082 (_+_) (sym (*-distrib\u02b3-+ (b en) (a em) (c em))) (sym (*-distrib\u02b3-+ (d en) (b em) (d em)))) \u27e9\n  mat (a em * a en + b em * c en)\n      (a em * b en + b em * d en)\n      ((a em + c em) * a en + (b em + d em) * c en)\n      ((a em + c em) * b en + (b em + d em) * d en) \u2261\u27e8\u27e9\n  mat (a em) (b em) (a em + c em) (b em + d em) # en \u2261\u27e8\u27e9\n  eval (bot+ m) # eval m' \u220e\n\n-- Task 2-1. Define transpose in SL2N domain.\n\n\nmirror : SL2N \u2192 SL2N \u2192 SL2N\nmirror acc I = acc\nmirror acc (top+ matrix) = mirror (top+ acc) matrix\nmirror acc (bot+ matrix) = mirror (bot+ acc) matrix\n\nrotate : SL2N \u2192 SL2N\nrotate I = I\nrotate (top+ matrix) = bot+ (rotate matrix)\nrotate (bot+ matrix) = top+ (rotate matrix)\n\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nm SL^T = mirror I (rotate m)\n\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\n\n\nSL#-assoc : \u2200 (m n k : SL2N) \u2192 (m SL# n) SL# k \u2261 m SL# (n SL# k)\nSL#-assoc I n k = refl\nSL#-assoc (top+ m) n k rewrite cong top+ (SL#-assoc m n k) = refl\nSL#-assoc (bot+ m) n k rewrite cong bot+ (SL#-assoc m n k) = refl\n\n\nmirror-mult : \u2200 (m acc : SL2N) \u2192 mirror acc m \u2261 (mirror I m) SL# acc\nmirror-mult I acc = refl\nmirror-mult (top+ m) acc = begin\n  mirror acc (top+ m) \u2261\u27e8\u27e9\n  mirror (top+ acc) m \u2261\u27e8 mirror-mult m (top+ acc) \u27e9\n  (mirror I m) SL# ((top+ I) SL# acc) \u2261\u27e8 sym (SL#-assoc (mirror I m) (top+ I) (acc)) \u27e9\n  ((mirror I m) SL# (top+ I)) SL# acc \u2261\u27e8 cong (_SL# acc) (sym (mirror-mult m (top+ I))) \u27e9\n  (mirror I (top+ m)) SL# acc \u220e\nmirror-mult (bot+ m) acc = begin\n  mirror acc (bot+ m) \u2261\u27e8\u27e9\n  mirror (bot+ acc) m \u2261\u27e8 mirror-mult m (bot+ acc) \u27e9\n  (mirror I m) SL# ((bot+ I) SL# acc) \u2261\u27e8 sym (SL#-assoc (mirror I m) (bot+ I) (acc)) \u27e9\n  ((mirror I m) SL# (bot+ I)) SL# acc \u2261\u27e8 cong (_SL# acc) (sym (mirror-mult m (bot+ I))) \u27e9\n  (mirror I (bot+ m)) SL# acc \u220e\n\n\nproof-mirror : \u2200 (m : SL2N) \u2192 (a b c d : \u2115) \u2192 (eval m \u2261 mat a b c d) \u2192 eval (mirror I m) \u2261 mat d b c a\nproof-mirror I .1 .0 .0 .1 refl = refl\nproof-mirror (top+ m) .(a (eval m) + c (eval m)) .(b (eval m) + d (eval m)) .(c (eval m)) .(d (eval m)) refl = let\n  am = a (eval m)\n  bm = b (eval m)\n  cm = c (eval m)\n  dm = d (eval m)\n  in begin\n    (eval (mirror I (top+ m))) \u2261\u27e8\u27e9\n    eval (mirror (top+ I) m) \u2261\u27e8 cong eval (mirror-mult m (top+ I)) \u27e9\n    eval ((mirror I m) SL# (top+ I)) \u2261\u27e8 SL#-eq-# (mirror I m) (top+ I) \u27e9\n    eval (mirror I m) # eval (top+ I) \u2261\u27e8 cong (_# eval (top+ I)) (proof-mirror m am bm cm dm refl) \u27e9\n    mat dm bm cm am # mat 1 1 0 1 \u2261\u27e8\u27e9\n    mat (dm * 1 + bm * 0) (dm * 1 + bm * 1) (cm * 1 + am * 0) (cm * 1 + am * 1) \u2261\u27e8 congMat (cong\u2082 (_+_) (*-identity\u02b3 dm) (*-comm bm 0)) (cong\u2082 (_+_) (*-identity\u02b3 dm) (*-identity\u02b3 bm)) (cong\u2082 (_+_) (*-identity\u02b3 cm) (*-comm am 0)) (cong\u2082 (_+_) (*-identity\u02b3 cm) (*-identity\u02b3 am)) \u27e9\n    mat (dm + 0) (dm + bm) (cm + 0) (cm + am) \u2261\u27e8 congMat (+-identity\u02b3 dm) (+-comm dm bm) (+-identity\u02b3 cm) (+-comm cm am) \u27e9\n    mat dm (bm + dm) (cm) (am + cm) \u220e \nproof-mirror (bot+ m) .(a (eval m)) .(b (eval m)) .(a (eval m) + c (eval m)) .(b (eval m) + d (eval m)) refl = let\n  am = a (eval m)\n  bm = b (eval m)\n  cm = c (eval m)\n  dm = d (eval m)\n  in begin\n    (eval (mirror I (bot+ m))) \u2261\u27e8\u27e9\n    eval (mirror (bot+ I) m) \u2261\u27e8 cong eval (mirror-mult m (bot+ I)) \u27e9\n    eval ((mirror I m) SL# (bot+ I)) \u2261\u27e8 SL#-eq-# (mirror I m) (bot+ I) \u27e9\n    eval (mirror I m) # eval (bot+ I) \u2261\u27e8 cong (_# eval (bot+ I)) (proof-mirror m am bm cm dm refl) \u27e9\n    mat dm bm cm am # mat 1 0 1 1 \u2261\u27e8\u27e9\n    mat (dm * 1 + bm * 1) (dm * 0 + bm * 1) (cm * 1 + am * 1) (cm * 0 + am * 1) \u2261\u27e8 congMat (cong\u2082 (_+_) (*-identity\u02b3 dm) (*-identity\u02b3 bm)) (cong\u2082 (_+_) (*-comm dm 0) (*-identity\u02b3 bm)) (cong\u2082 (_+_) (*-identity\u02b3 cm) (*-identity\u02b3 am)) (cong\u2082 (_+_) (*-comm cm 0) (*-identity\u02b3 am)) \u27e9\n    mat (dm + bm) bm (cm + am) am \u2261\u27e8 congMat (+-comm dm bm) refl (+-comm cm am) refl \u27e9\n    mat (bm + dm) bm (am + cm) am \u220e \n\n\nproof-rotate : \u2200 (m : SL2N) \u2192 (a b c d : \u2115) \u2192 (eval m \u2261 mat a b c d) \u2192 eval (rotate m) \u2261 mat d c b a\nproof-rotate I .1 .0 .0 .1 refl = refl\nproof-rotate (top+ m) .(a (eval m) + c (eval m)) .(b (eval m) + d (eval m)) .(c (eval m)) .(d (eval m)) refl = let\n  am = a (eval m)\n  bm = b (eval m)\n  cm = c (eval m)\n  dm = d (eval m)\n  rm = eval (rotate m)\n  in begin\n    eval (rotate (top+ m)) \u2261\u27e8\u27e9\n    eval (bot+ (rotate m)) \u2261\u27e8\u27e9\n    mat (a rm) (b rm) (a rm + c rm) (b rm + d rm) \u2261\u27e8 cong (\u03bb p \u2192 mat (a p) (b p) (a p + c p) (b p + d p)) (proof-rotate m am bm cm dm refl) \u27e9\n    mat dm cm (dm + bm) (cm + am) \u2261\u27e8 cong\u2082 (mat dm cm) (+-comm dm bm) (+-comm cm am) \u27e9\n    mat dm cm (bm + dm) (am + cm) \u220e\nproof-rotate (bot+ m) .(a (eval m)) .(b (eval m)) .(a (eval m) + c (eval m)) .(b (eval m) + d (eval m)) refl = let\n  am = a (eval m)\n  bm = b (eval m)\n  cm = c (eval m)\n  dm = d (eval m)\n  rm = eval (rotate m)\n  in begin\n    eval (rotate (bot+ m)) \u2261\u27e8\u27e9\n    eval (top+ (rotate m)) \u2261\u27e8\u27e9\n    mat (a rm + c rm) (b rm + d rm) (c rm) (d rm) \u2261\u27e8 cong (\u03bb p \u2192 mat (a p + c p) (b p + d p) (c p) (d p)) (proof-rotate m am bm cm dm refl) \u27e9\n    mat (dm + bm) (cm + am) bm am \u2261\u27e8 congMat (+-comm dm bm) (+-comm cm am) refl refl \u27e9\n    mat (bm + dm) (am + cm) bm am \u220e\n\n\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T m = let\n  mirr = eval (rotate m)\n  ma = a mirr\n  mb = b mirr\n  mc = c mirr\n  md = d mirr\n  aa = a (eval m)\n  bb = b (eval m)\n  cc = c (eval m)\n  dd = d (eval m)\n  rem-rot = proof-rotate m aa bb cc dd refl\n  in begin\n  eval (m SL^T) \u2261\u27e8\u27e9\n  eval (mirror I (rotate m)) \u2261\u27e8 proof-mirror (rotate m) ma mb mc md refl \u27e9\n  mat md mb mc ma \u2261\u27e8 congMat (cong d rem-rot) (cong b rem-rot) (cong c rem-rot) (cong a rem-rot) \u27e9\n  mat aa cc bb dd \u2261\u27e8 refl \u27e9\n  (eval m) ^T \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":221,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Data.Nat using (\u2115; _+_; _*_)\n\nimport Data.Nat.Solver as Solver\nopen Solver.+-*-Solver using (con; solve; _:*_; _:+_; _:=_)\n    \nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; cong; cong\u2082; refl)\nopen Eq.\u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\n\nopen import Matrix\nopen Mat\n\n-- Task 1-1. Define matmul in SL2N domain.\n\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI        SL# m' = m'\n(top+ m) SL# m' = top+ (m SL# m')\n(bot+ m) SL# m' = bot+ (m SL# m')\n\n-- Task 1-2. Prove that SL# is equivalent to #.\n\nprivate\n\n  lincomb\u2081\u2080\u02e1 : \u2200 (x y : \u2115) \u2192 1 * x + 0 * y \u2261 x\n  lincomb\u2081\u2080\u02e1 = solve 2 (\u03bb x y \u2192 con 1 :* x :+ con 0 :* y := x) refl\n\n  lincomb\u2080\u2081\u02e1 : \u2200 (x y : \u2115) \u2192 0 * x + 1 * y \u2261 y\n  lincomb\u2080\u2081\u02e1 = solve 2 (\u03bb x y \u2192 con 0 :* x :+ con 1 :* y := y) refl\n\n  lincomb\u2080\u2081\u02b3 : \u2200 (x y : \u2115) \u2192 x * 0 + y * 1 \u2261 y\n  lincomb\u2080\u2081\u02b3 = solve 2 (\u03bb x y \u2192 x :* con 0 :+ y :* con 1 := y) refl\n\n  lincomb\u2081\u2080\u02b3 : \u2200 (x y : \u2115) \u2192 x * 1 + y * 0 \u2261 x\n  lincomb\u2081\u2080\u02b3 = solve 2 (\u03bb x y \u2192 x :* con 1 :+ y :* con 0 := x) refl\n\n  lincomb\u2081\u2081\u02b3 : \u2200 (x y : \u2115) \u2192 x * 1 + y * 1 \u2261 x + y\n  lincomb\u2081\u2081\u02b3 = solve 2 (\u03bb x y \u2192 x :* con 1 :+ y :* con 1 := x :+ y) refl\n\n  #-identity\u02e1 : \u2200 (m : Mat) \u2192 eval I # m \u2261 m\n  #-identity\u02e1 m = congMat (lincomb\u2081\u2080\u02e1 (a m) (c m))\n                          (lincomb\u2081\u2080\u02e1 (b m) (d m))\n                          (lincomb\u2080\u2081\u02e1 (a m) (c m))\n                          (lincomb\u2080\u2081\u02e1 (b m) (d m))\n\n  lemma : \u2200 (x y z w s t : \u2115) \u2192\n          (x * s + y * t) + (z * s + w * t) \u2261 (x + z) * s + (y + w) * t\n  lemma = solve 6\n                (\u03bb x y z w s t \u2192 \n                  (x :* s :+ y :* t) :+ (z :* s :+ w :* t) :=\n                  (x :+ z) :* s :+ (y :+ w) :* t)\n                refl\n        \n  module Abbreviations (m : SL2N) where\n\n    a\u1d50 b\u1d50 c\u1d50 d\u1d50 : \u2115\n    a\u1d50 = a (eval m)\n    b\u1d50 = b (eval m)\n    c\u1d50 = c (eval m)\n    d\u1d50 = d (eval m)\n\n  module Abbreviations' (m : SL2N) where\n\n    a\u1d50' b\u1d50' c\u1d50' d\u1d50' : \u2115\n    a\u1d50' = a (eval m)\n    b\u1d50' = b (eval m)\n    c\u1d50' = c (eval m)\n    d\u1d50' = d (eval m)\n\nSL#-eq-# : \u2200 (m m' : SL2N) \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' rewrite #-identity\u02e1 (eval m') = refl \nSL#-eq-# (top+ m) m' =\n  begin\n    eval ((top+ m) SL# m')\n  \u2261\u27e8\u27e9\n    eval (top+ (m SL# m'))\n  \u2261\u27e8\u27e9\n    mat (a (eval (m SL# m')) + c (eval (m SL# m')))\n        (b (eval (m SL# m')) + d (eval (m SL# m')))\n        (c (eval (m SL# m')))\n        (d (eval (m SL# m')))\n  \u2261\u27e8 cong (\u03bb z \u2192 mat (a z + c z) (b z + d z) (c z) (d z)) (SL#-eq-# m m') \u27e9\n    mat (a (eval m # eval m') + c (eval m # eval m'))\n        (b (eval m # eval m') + d (eval m # eval m'))\n        (c (eval m # eval m'))\n        (d (eval m # eval m'))\n  \u2261\u27e8\u27e9\n    mat ((a\u1d50 * a\u1d50' + b\u1d50 * c\u1d50') + (c\u1d50 * a\u1d50' + d\u1d50 * c\u1d50'))\n        ((a\u1d50 * b\u1d50' + b\u1d50 * d\u1d50') + (c\u1d50 * b\u1d50' + d\u1d50 * d\u1d50'))\n        (c\u1d50 * a\u1d50' + d\u1d50 * c\u1d50')\n        (c\u1d50 * b\u1d50' + d\u1d50 * d\u1d50')\n  \u2261\u27e8 cong\u2082 (\u03bb z z' \u2192 mat z z' (c\u1d50 * a\u1d50' + d\u1d50 * c\u1d50') (c\u1d50 * b\u1d50' + d\u1d50 * d\u1d50'))\n           (lemma a\u1d50 b\u1d50 c\u1d50 d\u1d50 a\u1d50' c\u1d50')\n           (lemma a\u1d50 b\u1d50 c\u1d50 d\u1d50 b\u1d50' d\u1d50') \u27e9\n    mat ((a\u1d50 + c\u1d50) * a\u1d50' + (b\u1d50 + d\u1d50) * c\u1d50')\n        ((a\u1d50 + c\u1d50) * b\u1d50' + (b\u1d50 + d\u1d50) * d\u1d50')\n        (c\u1d50 * a\u1d50' + d\u1d50 * c\u1d50')\n        (c\u1d50 * b\u1d50' + d\u1d50 * d\u1d50')\n  \u2261\u27e8\u27e9\n    mat (a\u1d50 + c\u1d50) (b\u1d50 + d\u1d50) c\u1d50 d\u1d50 # mat a\u1d50' b\u1d50' c\u1d50' d\u1d50'\n  \u2261\u27e8\u27e9\n    eval (top+ m) # eval m'\n  \u220e\n  where open Abbreviations m\n        open Abbreviations' m'\nSL#-eq-# (bot+ m) m' =\n  begin\n    eval ((bot+ m) SL# m')\n  \u2261\u27e8\u27e9\n    eval (bot+ (m SL# m'))\n  \u2261\u27e8\u27e9\n    mat (a (eval (m SL# m')))\n        (b (eval (m SL# m')))\n        (a (eval (m SL# m')) + c (eval (m SL# m')))\n        (b (eval (m SL# m')) + d (eval (m SL# m')))\n  \u2261\u27e8 cong (\u03bb z \u2192 mat (a z) (b z) (a z + c z) (b z + d z)) (SL#-eq-# m m') \u27e9\n    mat (a (eval m # eval m'))\n        (b (eval m # eval m'))\n        (a (eval m # eval m') + c (eval m # eval m'))\n        (b (eval m # eval m') + d (eval m # eval m'))\n  \u2261\u27e8\u27e9\n    mat (a\u1d50 * a\u1d50' + b\u1d50 * c\u1d50')\n        (a\u1d50 * b\u1d50' + b\u1d50 * d\u1d50')\n        ((a\u1d50 * a\u1d50' + b\u1d50 * c\u1d50') + (c\u1d50 * a\u1d50' + d\u1d50 * c\u1d50'))\n        ((a\u1d50 * b\u1d50' + b\u1d50 * d\u1d50') + (c\u1d50 * b\u1d50' + d\u1d50 * d\u1d50'))   \n  \u2261\u27e8 cong\u2082 (\u03bb z z' \u2192 mat (a\u1d50 * a\u1d50' + b\u1d50 * c\u1d50') (a\u1d50 * b\u1d50' + b\u1d50 * d\u1d50') z z')\n           (lemma a\u1d50 b\u1d50 c\u1d50 d\u1d50 a\u1d50' c\u1d50')\n           (lemma a\u1d50 b\u1d50 c\u1d50 d\u1d50 b\u1d50' d\u1d50') \u27e9\n    mat (a\u1d50 * a\u1d50' + b\u1d50 * c\u1d50')\n        (a\u1d50 * b\u1d50' + b\u1d50 * d\u1d50')\n        ((a\u1d50 + c\u1d50) * a\u1d50' + (b\u1d50 + d\u1d50) * c\u1d50')\n        ((a\u1d50 + c\u1d50) * b\u1d50' + (b\u1d50 + d\u1d50) * d\u1d50')\n  \u2261\u27e8\u27e9\n    mat a\u1d50 b\u1d50 (a\u1d50 + c\u1d50) (b\u1d50 + d\u1d50) # mat a\u1d50' b\u1d50' c\u1d50' d\u1d50'\n  \u2261\u27e8\u27e9\n    eval (bot+ m) # eval m'\n  \u220e\n  where open Abbreviations m\n        open Abbreviations' m'\n\n-- Task 2-1. Define transpose in SL2N domain.\n\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nI        SL^T = I\n(top+ m) SL^T = (m SL^T) SL# (bot+ I)\n(bot+ m) SL^T = (m SL^T) SL# (top+ I)\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\n\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T I        = refl\nSL^T-eq-^T (top+ m) =\n  begin\n    eval ((top+ m) SL^T)\n  \u2261\u27e8\u27e9\n    eval ((m SL^T) SL# (bot+ I))\n  \u2261\u27e8 SL#-eq-# (m SL^T) (bot+ I) \u27e9\n    eval (m SL^T) # eval (bot+ I)\n  \u2261\u27e8 cong (_# eval (bot+ I)) (SL^T-eq-^T m) \u27e9\n    (eval m) ^T # eval (bot+ I)\n  \u2261\u27e8\u27e9\n    mat a\u1d50 c\u1d50 b\u1d50 d\u1d50 # mat 1 0 1 1\n  \u2261\u27e8 congMat (lincomb\u2081\u2081\u02b3 a\u1d50 c\u1d50)\n             (lincomb\u2080\u2081\u02b3 a\u1d50 c\u1d50)\n             (lincomb\u2081\u2081\u02b3 b\u1d50 d\u1d50)\n             (lincomb\u2080\u2081\u02b3 b\u1d50 d\u1d50) \u27e9\n    mat (a\u1d50 + c\u1d50) c\u1d50 (b\u1d50 + d\u1d50) d\u1d50\n  \u2261\u27e8\u27e9\n    eval (top+ m) ^T\n  \u220e\n  where open Abbreviations m\nSL^T-eq-^T (bot+ m) =\n  begin\n    eval ((bot+ m) SL^T)\n  \u2261\u27e8\u27e9\n    eval ((m SL^T) SL# (top+ I))\n  \u2261\u27e8 SL#-eq-# (m SL^T) (top+ I) \u27e9\n    eval (m SL^T) # eval (top+ I)\n  \u2261\u27e8 cong (_# eval (top+ I)) (SL^T-eq-^T m) \u27e9\n    (eval m) ^T # eval (top+ I)\n  \u2261\u27e8\u27e9\n    mat a\u1d50 c\u1d50 b\u1d50 d\u1d50 # mat 1 1 0 1\n  \u2261\u27e8 congMat (lincomb\u2081\u2080\u02b3 a\u1d50 c\u1d50)\n             (lincomb\u2081\u2081\u02b3 a\u1d50 c\u1d50)\n             (lincomb\u2081\u2080\u02b3 b\u1d50 d\u1d50)\n             (lincomb\u2081\u2081\u02b3 b\u1d50 d\u1d50) \u27e9\n    mat a\u1d50 (a\u1d50 + c\u1d50) b\u1d50 (b\u1d50 + d\u1d50)\n  \u2261\u27e8\u27e9\n    eval (bot+ m) ^T\n  \u220e\n  where open Abbreviations m","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":222,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\n\nopen import Data.Empty\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Function\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\nopen +-*-Solver\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL# m' = m'\ntop+ m SL# m' = top+ (m SL# m')\nbot+ m SL# m' = bot+ (m SL# m')\n\n+0+0 : \u2200 n \u2192 n + 0 + 0 \u2261 n\n+0+0 n = trans (+-identity\u02b3 (n + zero)) (+-identity\u02b3 n)\na+0+b+0 : \u2200 a b \u2192 a + 0 + (b + 0) \u2261 a + b\na+0+b+0 = solve 2 (\u03bb a c \u2192 a :+ con 0 :+ (c :+ con 0) := a :+ c) refl \n\n#-identity\u02e1 : \u2200 m \u2192 mat 1 0 0 1 # m \u2261 m\n#-identity\u02e1 (mat a b c d) = congMat (+0+0 a) (+0+0 b) (+-identity\u02b3 c) (+-identity\u02b3 d)\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' = sym (#-identity\u02e1 (eval m'))\nSL#-eq-# (top+ m) m' with eval (m SL# m') | inspect eval (m SL# m')\n... | p @ (mat a b c d) | [ eq ] =\n  let (mat a\u2081 b\u2081 c\u2081 d\u2081) = eval m\n      (mat a\u2082 b\u2082 c\u2082 d\u2082) = eval m'\n      lem = solve 8 (\u03bb a\u2081 b\u2081 c\u2081 d\u2081 a\u2082 b\u2082 c\u2082 d\u2082 \u2192 a\u2081 :* a\u2082 :+ b\u2081 :* c\u2082 :+ con 0 :+ (c\u2081 :* a\u2082 :+ d\u2081 :* c\u2082 :+ con 0) := (a\u2081 :+ c\u2081) :* a\u2082 :+ (b\u2081 :+ d\u2081) :* c\u2082) refl\n      in begin\n        mat (a + c) (b + d) c d\n      \u2261\u27e8 congMat (sym (a+0+b+0 a c)) (sym (a+0+b+0 b d)) (sym (+-identity\u02b3 c)) (sym (+-identity\u02b3 d)) \u27e9\n        mat 1 1 0 1 # p\n      \u2261\u02d8\u27e8 cong (_#_ (mat 1 1 0 1)) eq \u27e9\n        mat 1 1 0 1 # eval (m SL# m')\n      \u2261\u27e8 (cong (_#_ (mat 1 1 0 1)) (SL#-eq-# m m')) \u27e9\n        mat 1 1 0 1 # (eval m # eval m')\n      \u2261\u27e8 congMat (lem a\u2081 b\u2081 c\u2081 d\u2081 a\u2082 b\u2082 c\u2082 d\u2082) (lem a\u2081 b\u2081 c\u2081 d\u2081 b\u2082 a\u2082 d\u2082 c\u2082) (+-identity\u02b3 (c\u2081 * a\u2082 + d\u2081 * c\u2082)) (+-identity\u02b3 (c\u2081 * b\u2082 + d\u2081 * d\u2082)) \u27e9\n        eval (top+ m) # eval m'\n      \u220e\nSL#-eq-# (bot+ m) m' with eval (m SL# m') | inspect eval (m SL# m')\n... | p @ (mat a b c d) | [ eq ] = \n  let (mat a\u2081 b\u2081 c\u2081 d\u2081) = eval m\n      (mat a\u2082 b\u2082 c\u2082 d\u2082) = eval m'\n      lem = solve 8 (\u03bb a\u2081 b\u2081 c\u2081 d\u2081 a\u2082 b\u2082 c\u2082 d\u2082 \u2192 a\u2081 :* a\u2082 :+ b\u2081 :* c\u2082 :+ con 0 :+ (c\u2081 :* a\u2082 :+ d\u2081 :* c\u2082 :+ con 0) := (a\u2081 :+ c\u2081) :* a\u2082 :+ (b\u2081 :+ d\u2081) :* c\u2082) refl\n      in begin\n        mat a b (a + c) (b + d)\n      \u2261\u02d8\u27e8 congMat (+0+0 a) (+0+0 b) (a+0+b+0 a c) (a+0+b+0 b d) \u27e9\n        (mat 1 0 1 1 # p)\n      \u2261\u02d8\u27e8 cong (_#_ (mat 1 0 1 1)) eq \u27e9\n        mat 1 0 1 1 # eval (m SL# m')\n      \u2261\u27e8 (cong (_#_ (mat 1 0 1 1)) (SL#-eq-# m m')) \u27e9\n        mat 1 0 1 1 # (eval m # eval m')\n      \u2261\u27e8 congMat (+0+0 (a\u2081 * a\u2082 + b\u2081 * c\u2082)) (+0+0 (a\u2081 * b\u2082 + b\u2081 * d\u2082)) (lem a\u2081 b\u2081 c\u2081 d\u2081 a\u2082 b\u2082 c\u2082 d\u2082) ((lem a\u2081 b\u2081 c\u2081 d\u2081 b\u2082 a\u2082 d\u2082 c\u2082)) \u27e9\n        _ --eval (bot+ m) # eval m'\n      \u220e\n\n-- Task 2-1. Define transpose in SL2N domain.\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nI SL^T = I\ntop+ m SL^T = m SL^T SL# bot+ I\nbot+ m SL^T = m SL^T SL# top+ I\n\n#-identity\u02b3 : \u2200 m \u2192 m # mat 1 0 0 1 \u2261 m\n#-identity\u02b3 (mat a b c d) =\n  let lem\u2081 = solve 2 (\u03bb x y \u2192 x :* con 1 :+ y :* con 0 := x) refl\n      lem\u2082 = solve 2 (\u03bb x y \u2192 x :* con 0 :+ y :* con 1 := y) refl in congMat (lem\u2081 a b) (lem\u2082 a b) (lem\u2081 c d) (lem\u2082 c d)\n\n#-^T : \u2200 m m' \u2192 (m # m') ^T \u2261 m' ^T # m ^T\n#-^T (mat a\u2081 b\u2081 c\u2081 d\u2081) (mat a\u2082 b\u2082 c\u2082 d\u2082) = let lem = solve 4 (\u03bb x y z w \u2192 x :* y :+ z :* w := y :* x :+ w :* z) refl in congMat (lem a\u2081 a\u2082 b\u2081 c\u2082) (lem c\u2081 a\u2082 d\u2081 c\u2082) (lem a\u2081 b\u2082 b\u2081 d\u2082) (lem c\u2081 b\u2082 d\u2081 d\u2082)\n\n^T-involutive : \u2200 m \u2192 m ^T ^T \u2261 m\n^T-involutive m = refl\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T I = refl\nSL^T-eq-^T (top+ m) = begin\n    eval (m SL^T SL# bot+ I)\n  \u2261\u27e8 SL#-eq-# (m SL^T) (bot+ I) \u27e9\n    eval (m SL^T) # eval (bot+ I)\n  \u2261\u27e8 cong (\u03bb t \u2192 t # eval (bot+ I)) (SL^T-eq-^T m) \u27e9\n    eval m ^T # eval (bot+ I)\n  \u2261\u27e8 cong (_#_ (eval m ^T)) refl \u27e9\n    eval m ^T # eval (top+ I) ^T\n  \u2261\u02d8\u27e8 #-^T (eval (top+ I)) (eval m) \u27e9\n    (eval (top+ I) # eval m) ^T\n  \u2261\u27e8 cong _^T (congMat (a+0+b+0 (Mat.a (eval m)) (Mat.c (eval m))) (a+0+b+0 (Mat.b (eval m)) (Mat.d (eval m))) (+-identity\u02b3 (Mat.c (eval m))) (+-identity\u02b3 (Mat.d (eval m)))) \u27e9\n    eval (top+ m) ^T\n  \u220e\nSL^T-eq-^T (bot+ m) = begin\n    eval (m SL^T SL# top+ I)\n  \u2261\u27e8 SL#-eq-# (m SL^T) (top+ I) \u27e9\n    eval (m SL^T) # eval (top+ I)\n  \u2261\u27e8 cong (\u03bb t \u2192 t # eval (top+ I)) (SL^T-eq-^T m) \u27e9\n    eval m ^T # eval (top+ I)\n  \u2261\u27e8 cong (_#_ (eval m ^T)) refl \u27e9\n    eval m ^T # eval (bot+ I) ^T\n  \u2261\u02d8\u27e8 #-^T (eval (bot+ I)) (eval m) \u27e9\n    (eval (bot+ I) # eval m) ^T\n  \u2261\u27e8 cong _^T (congMat (+0+0 (Mat.a (eval m))) (+0+0 (Mat.b (eval m))) (a+0+b+0 (Mat.a (eval m)) (Mat.c (eval m))) (a+0+b+0 (Mat.b (eval m)) (Mat.d (eval m)))) \u27e9\n    eval (bot+ m) ^T\n  \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":223,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\nopen +-*-Solver\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL# m' = m'\ntop+ m SL# m' = top+ (m SL# m')\nbot+ m SL# m' = bot+ (m SL# m')\n\nlem\u2081 = solve 1 (\u03bb a \u2192 a :+ con 0 :+ con 0 := a) refl\nlem\u2082 = solve 2 (\u03bb a b \u2192 a :* con 1 :+ b :* con 0 := a) refl\nlem\u2083 = solve 2 (\u03bb a b \u2192 a :* con 0 :+ b :* con 1 := b) refl\nlem\u2084 = solve 6 (\u03bb a b c d a' c' \u2192 a :* a' :+ b :* c' :+ (c :* a' :+ d :* c') := (a :+ c) :* a' :+ (b :+ d) :* c') refl\nlem\u2085 = solve 4 (\u03bb a c a' c' \u2192 a :* a' :+ c :* (a' :+ c') := (a :+ c) :* a' :+ c :* c') refl\nlem\u2086 = solve 4 (\u03bb a c a' c' \u2192 a :* (a' :+ c') :+ c :* c' := a :* a' :+ (a :+ c) :* c') refl\n\n#-identity\u02e1 : \u2200 m \u2192 mat 1 0 0 1 # m \u2261 m\n#-identity\u02e1 (mat a b c d) = congMat (lem\u2081 a) (lem\u2081 b) (+-identity\u02b3 c) (+-identity\u02b3 d)\n#-identity\u02b3 : \u2200 m \u2192 m # mat 1 0 0 1 \u2261 m\n#-identity\u02b3 (mat a b c d) = congMat (lem\u2082 a b) (lem\u2083 a b) (lem\u2082 c d) (lem\u2083 c d)\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' = sym (#-identity\u02e1 (eval m'))\nSL#-eq-# (top+ m) m' rewrite SL#-eq-# m m' with eval m | eval m'\n... | mat a b c d | mat a' b' c' d' = congMat (lem\u2084 a b c d a' c') (lem\u2084 a b c d b' d') refl refl\nSL#-eq-# (bot+ m) m' rewrite SL#-eq-# m m' with eval m | eval m'\n... | mat a b c d | mat a' b' c' d' = congMat refl refl (lem\u2084 a b c d a' c') (lem\u2084 a b c d b' d')\n\n-- Task 2-1. Define transpose in SL2N domain.\ninfix 7 _SL^T#_\n_SL^T#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL^T# m' = m'\ntop+ m SL^T# m' = m SL^T# bot+ m'\nbot+ m SL^T# m' = m SL^T# top+ m'\n\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nm SL^T = m SL^T# I\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\nSL^T#-eq-^T# : \u2200 m m' \u2192 eval (m SL^T# m') \u2261 eval m ^T # eval m'\nSL^T#-eq-^T# I m' = sym (#-identity\u02e1 (eval m'))\nSL^T#-eq-^T# (top+ m) m' rewrite SL^T#-eq-^T# m (bot+ m') with eval m | eval m'\n... | mat a b c d | mat a' b' c' d' = congMat (lem\u2085 a c a' c') (lem\u2085 a c b' d') (lem\u2085 b d a' c') (lem\u2085 b d b' d')\nSL^T#-eq-^T# (bot+ m) m' rewrite SL^T#-eq-^T# m (top+ m') with eval m | eval m'\n... | mat a b c d | mat a' b' c' d' = congMat (lem\u2086 a c a' c') (lem\u2086 a c b' d') (lem\u2086 b d a' c') (lem\u2086 b d b' d')\n\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 eval m ^T\nSL^T-eq-^T m rewrite SL^T#-eq-^T# m I = #-identity\u02b3 (eval m ^T)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":224,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Solver\nopen +-*-Solver\n\n#-left-id : \u2200 m \u2192 mat 1 0 0 1 # m \u2261 m\n#-left-id (mat a b c d)\n  rewrite +-identity\u02b3 a | +-identity\u02b3 a\n  | +-identity\u02b3 b | +-identity\u02b3 b\n  | +-identity\u02b3 c | +-identity\u02b3 d\n  = refl\n\n#-right-id : \u2200 m \u2192 m # mat 1 0 0 1 \u2261 m\n#-right-id (mat a b c d)\n  rewrite *-comm b 0 | *-comm a 1 | *-comm a 0 | *-comm b 1\n  | *-comm c 1 | *-comm d 1 | *-comm d 0 | *-comm c 0\n  | +-identity\u02b3 a | +-identity\u02b3 a | +-identity\u02b3 b\n  | +-identity\u02b3 c | +-identity\u02b3 c | +-identity\u02b3 d\n  = refl\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL# m' = m'\n(top+ m) SL# m' = top+ (m SL# m')\n(bot+ m) SL# m' = bot+ (m SL# m')\n\nmat-top : Mat \u2192 Mat\nmat-top (mat a b c d) = mat (a + c) (b + d) c d\n\nmat-bot : Mat \u2192 Mat\nmat-bot (mat a b c d) = mat a b (a + c) (b + d)\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' = sym (#-left-id (eval m'))\nSL#-eq-# (top+ m) m' with eval m | eval m' | eval (m SL# m') | cong mat-top (SL#-eq-# m m')\n... | mat a b c d | mat x y u v | mat q w e r | ih =\n  trans ih (congMat eq1 eq2 refl refl)\n  where\n    eq1 = (solve 6 (\u03bb a b c d x u \u2192 a :* x :+ b :* u :+ (c :* x :+ d :* u)\n                 := (a :+ c) :* x :+ (b :+ d) :* u) refl) a b c d x u\n    eq2 = (solve 6 (\u03bb a b c d y v \u2192 a :* y :+ b :* v :+ (c :* y :+ d :* v)\n                  := (a :+ c) :* y :+ (b :+ d) :* v) refl) a b c d y v\nSL#-eq-# (bot+ m) m' with eval m | eval m' | eval (m SL# m') | cong mat-bot (SL#-eq-# m m')\n... | mat a b c d | mat x y u v | mat q w e r | ih =\n  trans ih (congMat refl refl eq1 eq2)\n  where\n    eq1 = (solve 6 (\u03bb a b c d x u \u2192 a :* x :+ b :* u :+ (c :* x :+ d :* u)\n                 := (a :+ c) :* x :+ (b :+ d) :* u) refl) a b c d x u\n    eq2 = (solve 6 (\u03bb a b c d y v \u2192 a :* y :+ b :* v :+ (c :* y :+ d :* v)\n                  := (a :+ c) :* y :+ (b :+ d) :* v) refl) a b c d y v\n\n-- Task 2-1. Define transpose in SL2N domain.\n\ntranspose-aux : SL2N \u2192 SL2N \u2192 SL2N\ntranspose-aux acc I = acc\ntranspose-aux acc (top+ m) = transpose-aux (bot+ acc) m\ntranspose-aux acc (bot+ m) = transpose-aux (top+ acc) m\n\ntranspose-aux-invariant : \u2200 (A B X) \u2192 (eval B) ^T # (eval A) \u2261 (eval X) ^T\n  \u2192 eval (transpose-aux A B) \u2261 ((eval X) ^T)\ntranspose-aux-invariant A I X rewrite #-left-id (eval A) = \u03bb z \u2192 z\ntranspose-aux-invariant A (top+ B) X eq with eval A | eval B | inspect eval A | inspect eval B\n... | mat a b c d | mat x y u v | [ eqa ] | [ eqb ] =\n  transpose-aux-invariant (bot+ A) B X lemma\n  where\n    eq1 = solve 4 (\u03bb a c x u \u2192 x :* a :+ u :* (a :+ c) := (x :+ u) :* a :+ u :* c) refl a c x u\n    eq2 = solve 4 (\u03bb b d x u \u2192 x :* b :+ u :* (b :+ d) := (x :+ u) :* b :+ u :* d) refl b d x u\n    eq3 = solve 4 (\u03bb a c y v \u2192 y :* a :+ v :* (a :+ c) := (y :+ v) :* a :+ v :* c) refl a c y v\n    eq4 = solve 4 (\u03bb b d y v \u2192 y :* b :+ v :* (b :+ d) := (y :+ v) :* b :+ v :* d) refl b d y v\n    lemma : eval B ^T # (eval (bot+ A)) \u2261 eval X ^T\n    lemma rewrite eqb | eqa =\n      congMat (trans eq1 (cong Mat.a eq))\n              (trans eq2 (cong Mat.b eq))\n              (trans eq3 (cong Mat.c eq))\n              (trans eq4 (cong Mat.d eq))\ntranspose-aux-invariant A (bot+ B) X eq with eval A | eval B | inspect eval A | inspect eval B\n... | mat a b c d | mat x y u v | [ eqa ] | [ eqb ] =\n  transpose-aux-invariant (top+ A) B X lemma\n  where\n    eq1 = solve 4 (\u03bb a c x u \u2192 x :* (a :+ c) :+ u :* c := x :* a :+ (x :+ u) :* c) refl a c x u\n    eq2 = solve 4 (\u03bb b d x u \u2192 x :* (b :+ d) :+ u :* d := x :* b :+ (x :+ u) :* d) refl b d x u\n    eq3 = solve 4 (\u03bb a c y v \u2192 y :* (a :+ c) :+ v :* c := y :* a :+ (y :+ v) :* c) refl a c y v\n    eq4 =  solve 4 (\u03bb b d y v \u2192 y :* (b :+ d) :+ v :* d := y :* b :+ (y :+ v) :* d) refl b d y v\n    lemma : eval B ^T # (eval (top+ A)) \u2261 eval X ^T\n    lemma rewrite eqb | eqa =\n      congMat (trans eq1 (cong Mat.a eq))\n              (trans eq2 (cong Mat.b eq))\n              (trans eq3 (cong Mat.c eq))\n              (trans eq4 (cong Mat.d eq))\n\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nm SL^T = transpose-aux I m\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T m = transpose-aux-invariant I m m (#-right-id (eval m ^T))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":225,"user_id":489,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-properties where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\n-- Task 1-1. Define matmul in SL2N domain.\ninfixl 7 _SL#_\n_SL#_ : SL2N \u2192 SL2N \u2192 SL2N\nI SL# m' = m'\n(top+ m) SL# m' = top+ (m SL# m')\n(bot+ m) SL# m' = bot+ (m SL# m')\n\n+-shuffle : \u2200 a b c d \u2192 a + b + (c + d) \u2261 a + c + (b + d)\n+-shuffle a b c d = begin\n  (a + b) + (c + d) \u2261\u27e8 sym (+-assoc (a + b) c d) \u27e9\n  ((a + b) + c) + d \u2261\u27e8 cong (\u03bb z \u2192 z + d) (+-assoc a b c) \u27e9\n  (a + (b + c)) + d \u2261\u27e8 sym (cong (\u03bb z \u2192 a + z + d) (+-comm c b)) \u27e9\n  (a + (c + b)) + d \u2261\u27e8 sym (cong (\u03bb z \u2192 z + d) (+-assoc a c b)) \u27e9\n  ((a + c) + b) + d \u2261\u27e8 +-assoc (a + c) b d \u27e9\n  (a + c) + (b + d) \u220e\n  where open \u2261-Reasoning\n+-*-shuffle : \u2200 a b c d a' b' \u2192 a * a' + b * b' + (c * a' + d * b') \u2261 (a + c) * a' + (b + d) * b'\n+-*-shuffle a b c d a' b' = begin\n  a * a' + b * b' + (c * a' + d * b') \u2261\u27e8 +-shuffle (a * a') (b * b') (c * a') (d * b') \u27e9\n  a * a' + c * a' + (b * b' + d * b') \u2261\u27e8 sym (cong (\u03bb z \u2192 z + (b * b' + d * b')) (*-distrib\u02b3-+ a' a c)) \u27e9\n  (a + c) * a' + (b * b' + d * b') \u2261\u27e8 sym (cong (_+_ ((a + c) * a')) (*-distrib\u02b3-+ b' b d)) \u27e9\n  (a + c) * a' + (b + d) * b' \u220e\n  where open \u2261-Reasoning\ncong-double : \u2200 {A : Set} {x y : A} (f g : A \u2192 \u2115) \u2192 x \u2261 y \u2192 f x + g x \u2261 f y + g y\ncong-double f g refl = refl\n\n-- Task 1-2. Prove that SL# is equivalent to #.\nSL#-eq-# : \u2200 m m' \u2192 eval (m SL# m') \u2261 eval m # eval m'\nSL#-eq-# I m' = congMat lemma-a lemma-b lemma-c lemma-d where\n  open \u2261-Reasoning\n  lemma-00 : \u2200 x \u2192 x \u2261 x + 0 + 0\n  lemma-00 x = begin\n    x \u2261\u27e8 +-comm 0 x \u27e9\n    x + 0 \u2261\u27e8 +-comm 0 (x + 0) \u27e9\n    x + 0 + 0 \u220e\n  lemma-a : a (eval m') \u2261 a (eval m') + 0 + 0\n  lemma-a = lemma-00 (a (eval m'))\n  lemma-b : b (eval m') \u2261 b (eval m') + 0 + 0\n  lemma-b = lemma-00 (b (eval m'))\n  lemma-c : c (eval m') \u2261 c (eval m') + 0\n  lemma-c = +-comm 0 (c (eval m'))\n  lemma-d : d (eval m') \u2261 d (eval m') + 0\n  lemma-d = +-comm 0 (d (eval m'))\n\nSL#-eq-# (top+ m) m' = congMat lemma-a lemma-b lemma-c lemma-d where\n  open \u2261-Reasoning\n  lemma-a : a (eval (m SL# m')) + c (eval (m SL# m')) \u2261\n              (a (eval m) + c (eval m)) * a (eval m') +\n              (b (eval m) + d (eval m)) * c (eval m')\n  lemma-a = begin\n    a (eval (m SL# m')) + c (eval (m SL# m')) \u2261\u27e8 cong-double a c (SL#-eq-# m m') \u27e9\n    a (eval m # eval m') + c (eval m # eval m') \u2261\u27e8\u27e9\n    a (eval m) * a (eval m') + b (eval m) * c (eval m') +\n      (c (eval m) * a (eval m') + d (eval m) * c (eval m'))\n        \u2261\u27e8 +-*-shuffle (a (eval m)) (b (eval m)) (c (eval m)) (d (eval m)) (a (eval m')) (c (eval m')) \u27e9\n    (a (eval m) + c (eval m)) * a (eval m') + (b (eval m) + d (eval m)) * c (eval m') \u220e\n\n  lemma-b : b (eval (m SL# m')) + d (eval (m SL# m')) \u2261\n              (a (eval m) + c (eval m)) * b (eval m') +\n              (b (eval m) + d (eval m)) * d (eval m')\n  lemma-b = begin\n    b (eval (m SL# m')) + d (eval (m SL# m')) \u2261\u27e8 cong-double b d (SL#-eq-# m m') \u27e9\n    b (eval m # eval m') + d (eval m # eval m') \u2261\u27e8\u27e9\n    a (eval m) * b (eval m') + b (eval m) * d (eval m') +\n      (c (eval m) * b (eval m') + d (eval m) * d (eval m'))\n        \u2261\u27e8 +-*-shuffle (a (eval m)) (b (eval m)) (c (eval m)) (d (eval m)) (b (eval m')) (d (eval m')) \u27e9\n    (a (eval m) + c (eval m)) * b (eval m') + (b (eval m) + d (eval m)) * d (eval m') \u220e\n\n  lemma-c : c (eval (m SL# m')) \u2261\n              c (eval m) * a (eval m') + d (eval m) * c (eval m')\n  lemma-c = cong c (SL#-eq-# m m')\n  \n  lemma-d : d (eval (m SL# m')) \u2261\n              c (eval m) * b (eval m') + d (eval m) * d (eval m')\n  lemma-d = cong d (SL#-eq-# m m')\n\nSL#-eq-# (bot+ m) m' = congMat lemma-a lemma-b lemma-c lemma-d where\n  open \u2261-Reasoning\n  lemma-a : a (eval (m SL# m')) \u2261\n              a (eval m) * a (eval m') + b (eval m) * c (eval m')\n  lemma-a = cong a (SL#-eq-# m m')\n  lemma-b : b (eval (m SL# m')) \u2261\n              a (eval m) * b (eval m') + b (eval m) * d (eval m')\n  lemma-b = cong b (SL#-eq-# m m')\n  lemma-c : a (eval (m SL# m')) + c (eval (m SL# m')) \u2261\n              (a (eval m) + c (eval m)) * a (eval m') +\n              (b (eval m) + d (eval m)) * c (eval m')\n  lemma-c = begin\n    a (eval (m SL# m')) + c (eval (m SL# m')) \u2261\u27e8 cong-double a c (SL#-eq-# m m') \u27e9\n    a (eval m # eval m') + c (eval m # eval m') \u2261\u27e8 +-*-shuffle (a (eval m)) (b (eval m)) (c (eval m))\n                                                      (d (eval m)) (a (eval m')) (c (eval m')) \u27e9\n    (a (eval m) + c (eval m)) * a (eval m') +\n      (b (eval m) + d (eval m)) * c (eval m') \u220e\n  lemma-d : b (eval (m SL# m')) + d (eval (m SL# m')) \u2261\n              (a (eval m) + c (eval m)) * b (eval m') +\n              (b (eval m) + d (eval m)) * d (eval m')\n  lemma-d = begin\n    b (eval (m SL# m')) + d (eval (m SL# m')) \u2261\u27e8 cong-double b d (SL#-eq-# m m') \u27e9\n    b (eval m # eval m') + d (eval m # eval m') \u2261\u27e8 +-*-shuffle (a (eval m)) (b (eval m)) (c (eval m))\n                                                      (d (eval m)) (b (eval m')) (d (eval m')) \u27e9\n    (a (eval m) + c (eval m)) * b (eval m') +\n      (b (eval m) + d (eval m)) * d (eval m') \u220e\n\n-- Task 2-1. Define transpose in SL2N domain.\ninfix 8 _SL^T\n_SL^T : SL2N \u2192 SL2N\nI SL^T = I\n(top+ m) SL^T = (m SL^T) SL# (bot+ I)\n(bot+ m) SL^T = (m SL^T) SL# (top+ I)\n\n-- Task 2-2. Prove that SL^T is equivalent to ^T.\n\nx*1+y*1 : \u2200 x y \u2192 x * 1 + y * 1 \u2261 x + y\nx*1+y*1 x y = begin\n  x * 1 + y * 1 \u2261\u27e8 cong (\u03bb z \u2192 z + y * 1) (*-identity\u02b3 x) \u27e9\n  x + y * 1 \u2261\u27e8 cong (_+_ x) (*-identity\u02b3 y) \u27e9\n  x + y \u220e\n  where open \u2261-Reasoning\n\nx*0+y*1 : \u2200 x y \u2192 x * 0 + y * 1 \u2261 y\nx*0+y*1 x y = begin\n  x * 0 + y * 1 \u2261\u27e8 cong (\u03bb z \u2192 z + y * 1) (*-zero\u02b3 x) \u27e9\n  0 + y * 1 \u2261\u27e8\u27e9\n  y * 1 \u2261\u27e8 *-identity\u02b3 y \u27e9\n  y \u220e\n  where open \u2261-Reasoning\n\nx*1+y*0 : \u2200 x y \u2192 x * 1 + y * 0 \u2261 x\nx*1+y*0 x y = begin\n  x * 1 + y * 0 \u2261\u27e8 cong (_+_ (x * 1)) (*-zero\u02b3 y) \u27e9\n  x * 1 + 0 \u2261\u27e8 +-comm (x * 1) zero \u27e9\n  x * 1 \u2261\u27e8 *-identity\u02b3 x \u27e9\n  x \u220e\n  where open \u2261-Reasoning\n\nSL^T-eq-^T : \u2200 m \u2192 eval (m SL^T) \u2261 (eval m) ^T\nSL^T-eq-^T I = refl\nSL^T-eq-^T (top+ m) = begin\n  eval (m SL^T SL# bot+ I) \u2261\u27e8 SL#-eq-# (m SL^T) (bot+ I) \u27e9\n  eval (m SL^T) # eval (bot+ I) \u2261\u27e8 cong (\u03bb z \u2192 z # eval (bot+ I)) (SL^T-eq-^T m) \u27e9\n  (eval m) ^T # eval (bot+ I) \u2261\u27e8 congMat lemma-a lemma-b lemma-c lemma-d \u27e9\n  mat (a (eval m) + c (eval m)) (c (eval m))\n    (b (eval m) + d (eval m)) (d (eval m)) \u220e\n  where\n    open \u2261-Reasoning\n    lemma-a : a (eval m ^T) * 1 + b (eval m ^T) * 1 \u2261 a (eval m) + c (eval m)\n    lemma-a = x*1+y*1 (a (eval m)) (c (eval m))\n    lemma-b : a (eval m ^T) * zero + b (eval m ^T) * 1 \u2261 c (eval m)\n    lemma-b = x*0+y*1 (a (eval m)) (c (eval m))\n    lemma-c : c (eval m ^T) * 1 + d (eval m ^T) * 1 \u2261 b (eval m) + d (eval m)\n    lemma-c = x*1+y*1 (b (eval m)) (d (eval m))\n    lemma-d : c (eval m ^T) * zero + d (eval m ^T) * 1 \u2261 d (eval m)\n    lemma-d = x*0+y*1 (b (eval m)) (d (eval m))\nSL^T-eq-^T (bot+ m) = begin\n  eval (m SL^T SL# top+ I) \u2261\u27e8 SL#-eq-# (m SL^T) (top+ I) \u27e9\n  eval (m SL^T) # eval (top+ I) \u2261\u27e8 cong (\u03bb z \u2192 z # eval (top+ I)) (SL^T-eq-^T m) \u27e9\n  (eval m) ^T # eval (top+ I) \u2261\u27e8 congMat lemma-a lemma-b lemma-c lemma-d \u27e9\n  mat (a (eval m)) (a (eval m) + c (eval m)) (b (eval m))\n    (b (eval m) + d (eval m)) \u220e\n  where\n    open \u2261-Reasoning\n    lemma-a : a (eval m ^T) * 1 + b (eval m ^T) * zero \u2261 a (eval m)\n    lemma-a = x*1+y*0 (a (eval m)) (c (eval m))\n    lemma-b : a (eval m ^T) * 1 + b (eval m ^T) * 1 \u2261 a (eval m) + c (eval m)\n    lemma-b = x*1+y*1 (a (eval m)) (c (eval m))\n    lemma-c : c (eval m ^T) * 1 + d (eval m ^T) * zero \u2261 b (eval m)\n    lemma-c = x*1+y*0 (b (eval m)) (d (eval m))\n    lemma-d : c (eval m ^T) * 1 + d (eval m ^T) * 1 \u2261 b (eval m) + d (eval m)\n    lemma-d = x*1+y*1 (b (eval m)) (d (eval m))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c930224c4661143a6666add":[{"id":226,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule SL2N-unique where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation\nopen import Data.Nat.Properties \nopen import Data.Sum \nopen import Data.Empty\nopen \u2261-Reasoning\n \n-- lemmas \neq-a : \u2200 {a b c d a' b' c' d'} \u2192 mat a b c d \u2261 mat a' b' c' d' \u2192 a \u2261 a'\neq-a refl = refl\n\neq-b : \u2200 {a b c d a' b' c' d'} \u2192 mat a b c d \u2261 mat a' b' c' d' \u2192 b \u2261 b'\neq-b refl = refl\n\neq-c : \u2200 {a b c d a' b' c' d'} \u2192 mat a b c d \u2261 mat a' b' c' d' \u2192 c \u2261 c'\neq-c refl = refl\n\neq-d : \u2200 {a b c d a' b' c' d'} \u2192 mat a b c d \u2261 mat a' b' c' d' \u2192 d \u2261 d'\neq-d refl = refl\n\na\u22620\u228eb\u22620 : \u2200 m \u2192 Mat.a (eval m) \u2262  0 \u228e Mat.b (eval m) \u2262  0\na\u22620\u228eb\u22620 I = inj\u2081 (\u03bb ())\na\u22620\u228eb\u22620 (top+ m) with eval m | inspect eval m | a\u22620\u228eb\u22620 m\n... | mat a b c d | [ heq ] | inj\u2081 ha = inj\u2081 (\u03bb hac \u2192 ha (i+j\u22610\u21d2i\u22610 a hac))\n... | mat a b c d | [ heq ] | inj\u2082 hb = inj\u2082 (\u03bb hbd \u2192 hb (i+j\u22610\u21d2i\u22610 b hbd))\na\u22620\u228eb\u22620 (bot+ m) with eval m | inspect eval m | a\u22620\u228eb\u22620 m\n... | mat a b c d | [ heq ] | hab = hab\n\n-- Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique.\neval-injective : \u2200 m n \u2192 eval m \u2261 eval n \u2192 m \u2261 n\neval-injective I I h = refl\neval-injective I (top+ n) h with eval n \n...   | mat a b c d = contradiction (eq-d h) (subst (\u03bb n \u2192 \u00ac 1 \u2261 n) \n        (sym (i+j\u22610\u21d2j\u22610 b (sym (eq-b h)))) \u03bb ())\neval-injective I (bot+ n) h with eval n \n...   | mat a b c d = contradiction (eq-a h) (subst (\u03bb n \u2192 \u00ac 1 \u2261 n) \n        (sym (i+j\u22610\u21d2i\u22610 a (sym (eq-c h)))) \u03bb ())\neval-injective (top+ m) I h with eval m \n...   | mat a b c d = contradiction (eq-d h) (subst (\u03bb n \u2192 \u00ac n \u2261 1)\n        (sym (i+j\u22610\u21d2i\u22610 d (trans (+-comm d b) (eq-b h)))) \u03bb ())\neval-injective (top+ m) (top+ n) h with eval m | eval n | inspect eval m | inspect eval n\n...   | mat a b c d | mat a' b' c' d' | [ heqm ] | [ heqn ] = cong top+ (eval-injective m n \n        (subst\u2082 _\u2261_ (sym heqm) (sym heqn) (congMat equ-a equ-b equ-c equ-d))) where \n        equ-c : c \u2261 c'\n        equ-c = eq-c h \n\n        equ-d : d \u2261 d'\n        equ-d = eq-d h\n\n        equ-a : a \u2261 a'\n        equ-a = +-cancel\u02b3-\u2261 a a' (subst (\u03bb v \u2192 a + v \u2261 a' + c') equ-c (eq-a h))\n\n        equ-b : b \u2261 b'\n        equ-b = +-cancel\u02b3-\u2261 b b' (subst (\u03bb v \u2192 b + v \u2261 b' + d') equ-d (eq-b h))\neval-injective (top+ m) (bot+ n) h \n  with eval m | eval n | inspect eval m | inspect eval n | a\u22620\u228eb\u22620 m\n... | mat a b c d | mat a' b' c' d' | [ heqm ] | [ heqn ] | inj\u2081 ha = contradiction \n      (i+j\u22610\u21d2i\u22610 a (+-cancel\u02b3-\u2261 (a + c') 0\n      (begin \n        a + c' + a' \u2261\u27e8 +-assoc a c' a' \u27e9  \n        a + (c' + a') \u2261\u27e8 cong (a +_) (trans (+-comm c' a') (sym (eq-c h)))  \u27e9\n        a + c \u2261\u27e8 eq-a h \u27e9\n        a'\n      \u220e))) ha\n... | mat a b c d | mat a' b' c' d' | [ heqm ] | [ heqn ] | inj\u2082 hb = contradiction \n      (i+j\u22610\u21d2i\u22610 b (+-cancel\u02b3-\u2261 (b + d') 0\n      (begin \n        b + d' + b' \u2261\u27e8 +-assoc b d' b' \u27e9  \n        b + (d' + b') \u2261\u27e8 cong (b +_) (trans (+-comm d' b') (sym (eq-d h))) \u27e9  \n        b + d \u2261\u27e8 eq-b h \u27e9  \n        b'\n      \u220e))) hb\neval-injective (bot+ m) I h with eval m \n...   | mat a b c d = contradiction (eq-a h) (subst (\u03bb n \u2192 \u00ac n \u2261 1)\n        (sym (i+j\u22610\u21d2i\u22610 a (eq-c h))) \u03bb ())\neval-injective (bot+ m) (top+ n) h \n  with eval n | eval m | inspect eval n | inspect eval m | a\u22620\u228eb\u22620 n\n... | mat a b c d | mat a' b' c' d' | [ heqm ] | [ heqn ] | inj\u2081 ha = contradiction \n      (i+j\u22610\u21d2i\u22610 a (+-cancel\u02b3-\u2261 (a + c') 0\n      (begin \n        a + c' + a' \u2261\u27e8 +-assoc a c' a' \u27e9  \n        a + (c' + a') \u2261\u27e8 cong (a +_) (trans (+-comm c' a') (sym (eq-c (sym h))))  \u27e9\n        a + c \u2261\u27e8 eq-a (sym h) \u27e9\n        a'\n      \u220e))) ha\n... | mat a b c d | mat a' b' c' d' | [ heqm ] | [ heqn ] | inj\u2082 hb = contradiction \n      (i+j\u22610\u21d2i\u22610 b (+-cancel\u02b3-\u2261 (b + d') 0\n      (begin \n        b + d' + b' \u2261\u27e8 +-assoc b d' b' \u27e9  \n        b + (d' + b') \u2261\u27e8 cong (b +_) (trans (+-comm d' b') (sym (eq-d (sym h)))) \u27e9  \n        b + d \u2261\u27e8 eq-b (sym h) \u27e9  \n        b'\n      \u220e))) hb\neval-injective (bot+ m) (bot+ n) h with eval m | eval n | inspect eval m | inspect eval n\n...   | mat a b c d | mat a' b' c' d' | [ heqm ] | [ heqn ] = cong bot+ (eval-injective m n \n        (subst\u2082 _\u2261_ (sym heqm) (sym heqn) (congMat equ-a equ-b equ-c equ-d))) where \n        equ-a : a \u2261 a'\n        equ-a = eq-a h \n\n        equ-b : b \u2261 b'\n        equ-b = eq-b h\n\n        equ-c : c \u2261 c'\n        equ-c = +-cancel\u02e1-\u2261 a (subst (\u03bb v \u2192 a + c \u2261 v + c') (sym equ-a) (eq-c h))\n\n        equ-d : d \u2261 d'\n        equ-d = +-cancel\u02e1-\u2261 b (subst (\u03bb v \u2192 b + d \u2261 v + d') (sym equ-b) (eq-d h))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":227,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule SL2N-unique where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\neval-nonzero : \u2200 m c\u2081 d\u2081 \u2192 eval m \u2262 mat 0 0 c\u2081 d\u2081\neval-nonzero (top+ m) c\u2081 d\u2081 e with eval m | inspect eval m | cong a e | cong b e\n... | mat 0 0 0 0 | [ em ] | refl | refl = eval-nonzero m 0 0 em\neval-nonzero (bot+ m) c\u2081 d\u2081 e with eval m | inspect eval m | cong a e | cong b e\n... | mat 0 0 c\u2082 d\u2082 | [ em ] | refl | refl = eval-nonzero m c\u2082 d\u2082 em\n\neval-injective : \u2200 m n \u2192 eval m \u2261 eval n \u2192 m \u2261 n\neval-injective I I refl = refl\neval-injective (top+ m) (top+ n) e with eval m | inspect eval m | eval n | inspect eval n\n... | mat a\u2081 b\u2081 _ _ | [ em ] | mat a\u2082 b\u2082 _ _ | [ en ] with cong c e | cong d e\n... | refl | refl\n  rewrite +-cancel\u02b3-\u2261 a\u2081 a\u2082 (cong a e) | +-cancel\u02b3-\u2261 b\u2081 b\u2082 (cong b e)\n        | eval-injective m n (trans em (sym en))\n  = refl\neval-injective (bot+ m) (bot+ n) e with eval m | inspect eval m | eval n | inspect eval n\n... | mat a\u2081 b\u2081 _ _ | [ em ] | mat _ _ _ _ | [ en ] with cong a e | cong b e\n... | refl | refl\n  rewrite +-cancel\u02e1-\u2261 a\u2081 (cong c e) | +-cancel\u02e1-\u2261 b\u2081 (cong d e)\n        | eval-injective m n (trans em (sym en))\n  = refl\neval-injective (top+ m) I e with eval m | cong b e | cong d e\n... | mat _ b\u2081 _ .1 | eb | refl rewrite +-comm b\u2081 1 with eb\n... | ()\neval-injective I (top+ n) e with eval n | cong b e | cong d e\n... | mat _ b\u2081 _ .1 | eb | refl rewrite +-comm b\u2081 1 with eb\n... | ()\neval-injective (bot+ m) I e with eval m | cong a e | cong c e\n... | mat .1 _ _ _ | refl | ()\neval-injective I (bot+ n) e with eval n | cong a e | cong c e\n... | mat .1 _ _ _ | refl | ()\neval-injective (top+ m) (bot+ n) e with eval m | inspect eval m | eval n\n... | mat a\u2081 b\u2081 _ _ | [ em ] | mat a\u2082 b\u2082 c\u2082 d\u2082 with cong c e | cong d e\n... | refl | refl\n  rewrite +-comm a\u2082 c\u2082 | sym (+-assoc a\u2081 c\u2082 a\u2082) | +-comm b\u2082 d\u2082 | sym (+-assoc b\u2081 d\u2082 b\u2082)\n  with +-cancel\u02b3-\u2261 (a\u2081 + c\u2082) 0 (cong a e) | +-cancel\u02b3-\u2261 (b\u2081 + d\u2082) 0 (cong b e)\neval-injective (top+ m) (bot+ n) e | mat 0 0 .(a\u2082 + 0) .(b\u2082 + 0) | [ em ] | mat a\u2082 b\u2082 0 0 | refl | refl | refl | refl\n  with eval-nonzero m a\u2082 b\u2082 em\n... | ()\neval-injective (bot+ m) (top+ n) e with eval m | eval n | inspect eval n\n... | mat a\u2081 b\u2081 c\u2081 d\u2081 | mat a\u2082 b\u2082 _ _ | [ en ] with cong c e | cong d e\n... | refl | refl\n  rewrite +-comm a\u2081 c\u2081 | sym (+-assoc a\u2082 c\u2081 a\u2081) | +-comm b\u2081 d\u2081 | sym (+-assoc b\u2082 d\u2081 b\u2081)\n  with +-cancel\u02b3-\u2261 0 (a\u2082 + c\u2081) (cong a e) | +-cancel\u02b3-\u2261 0 (b\u2082 + d\u2081) (cong b e)  \neval-injective (bot+ m) (top+ n) e | mat a\u2081 b\u2081 0 0 | mat 0 0 .(a\u2081 + 0) .(b\u2081 + 0) | [ en ] | refl | refl | refl | refl\n  with eval-nonzero n a\u2081 b\u2081 en\n... | ()\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":228,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule SL2N-unique where\n\n--Super ugly solution. But hey, it typechecks.\n\nopen import Matrix\nopen Mat\n\nopen import Function\nopen import Data.Empty\nopen import Data.Nat\nopen import Data.Nat.Properties hiding (0\u22621+n)\nopen import Data.Nat.Solver\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\nopen +-*-Solver\n\nproja : \u2200 {n m} \u2192 n \u2261 m \u2192 a n \u2261 a m\nproja refl = refl\n\nprojb : \u2200 {n m} \u2192 n \u2261 m \u2192 b n \u2261 b m\nprojb refl = refl\n\nprojc : \u2200 {n m} \u2192 n \u2261 m \u2192 c n \u2261 c m\nprojc refl = refl\n\nprojd : \u2200 {n m} \u2192 n \u2261 m \u2192 d n \u2261 d m\nprojd refl = refl\n\nall-projs : \u2200{n m} \u2192 n \u2261 m \u2192 a n \u2261 a m \u00d7 b n \u2261 b m \u00d7 c n \u2261 c m \u00d7 d n \u2261 d m\nall-projs refl = refl , refl , refl , refl\n\nlem-+0+0 : \u2200 x \u2192 x + 0 + 0 \u2261 x\nlem-+0+0 x = trans (+-identity\u02b3 (x + zero)) (+-identity\u02b3 x)\n\n--codewars uses a dinosaur stdlib, so I'll just implement this myself\n0\u22621+n : \u2200 {n} \u2192 0 \u2262 suc n\n0\u22621+n ()\n\nlem-x+y+y\u22611 : \u2200 x y \u2192 x + y + y \u2261 1 \u2192 x \u2261 1 \u00d7 y \u2261 0\nlem-x+y+y\u22611 x zero e = trans (sym (lem-+0+0 x)) e , refl\nlem-x+y+y\u22611 x (suc y) e = \u22a5-elim (0\u22621+n (suc-injective (sym (begin\n    suc (suc (x + y + y))\n  \u2261\u27e8 solve 2 (\u03bb x y \u2192 con 2 :+ (x :+ y :+ y) := x :+ (con 1 :+ y) :+ (con 1 :+ y)) refl x y \u27e9\n    x + suc y + suc y\n  \u2261\u27e8 e \u27e9\n    1\n  \u220e))))\n\nlem-x+x+y\u22611 : \u2200 x y \u2192 x + (x + y) \u2261 1 \u2192 x \u2261 0 \u00d7 y \u2261 1\nlem-x+x+y\u22611 x y e = let l , r = lem-x+y+y\u22611 y x (trans (solve 2 (\u03bb x y \u2192 y :+ x :+ x := x :+ (x :+ y)) refl x y) e) in r , l\n\nlem-x+y\u22610 : \u2200 x y \u2192 x + y \u2261 0 \u2192 x \u2261 0 \u00d7 y \u2261 0\nlem-x+y\u22610 zero zero e = refl , refl\n\nlem-x+y+y\u22610 : \u2200 x y \u2192 x + y + y \u2261 0 \u2192 x \u2261 0 \u00d7 y \u2261 0\nlem-x+y+y\u22610 0 0 e = refl , refl\n\neI-ne-et : \u2200 m \u2192 eval I \u2262 eval (top+ m)\neI-ne-et (top+ m) e =\n  let e' = sym e\n      _ , d\u22610 = lem-x+y+y\u22610 (b (eval m)) (d (eval m)) (projb e')\n      d\u22611 = projd e' in 0\u22621+n (trans (sym d\u22610) d\u22611)\neI-ne-et (bot+ m) e =\n  let e' = sym e\n      _ , c\u22611 = lem-x+x+y\u22611 (a (eval m)) (c (eval m)) (proja e')\n      _ , c\u22610 = lem-x+y\u22610   (a (eval m)) (c (eval m)) (projc e') in 0\u22621+n (trans (sym c\u22610) c\u22611)\n\n\neI-ne-eb : \u2200 m \u2192 eval I \u2262 eval (bot+ m)\neI-ne-eb (top+ m) e =\n  let e' = sym e\n      b\u22610 , _ = lem-x+y\u22610   (b (eval m)) (d (eval m)) (projb e')\n      b\u22611 , _ = lem-x+y+y\u22611 (b (eval m)) (d (eval m)) (projd e') in 0\u22621+n (trans (sym b\u22610) b\u22611)\neI-ne-eb (bot+ m) e =\n  let e' = sym e\n      a\u22611 = proja e'\n      a\u22610 , _ = lem-x+y\u22610 (a (eval m)) (a (eval m) + c (eval m)) (projc e') in 0\u22621+n (trans (sym a\u22610) a\u22611)\n\na-ne-0 : \u2200 m \u2192 a (eval m) \u2262 0\na-ne-0 I ()\na-ne-0 (top+ m) eq with eval m | inspect eval m\n... | mat a b c d | [ em ] = let ea = proja em in a-ne-0 m (trans ea (proj\u2081 (lem-x+y\u22610 a c eq)))\na-ne-0 (bot+ m) eq with eval m | inspect eval m\n... | mat a b c d | [ em ] = let ea = proja em in a-ne-0 m (trans ea eq)\n\nlemma-add-regress : \u2200 x y z w \u2192 x + y \u2261 z \u2192 y \u2261 z + w \u2192 x \u2261 0 \u00d7 w \u2261 0 \u00d7 y \u2261 z\nlemma-add-regress x y z w eq\u2081 eq\u2082 =\n  let x\u22610 , w\u22610 = lem-x+y\u22610 x w (+-cancel\u02b3-\u2261 (x + w) 0 (trans (solve 3 (\u03bb a b c \u2192 a :+ b :+ c := a :+ (c :+ b)) refl x w z) (subst (\u03bb t \u2192 x + t \u2261 z) eq\u2082 eq\u2081)))\n      in x\u22610 , w\u22610 , (begin\n          y\n        \u2261\u27e8 eq\u2082 \u27e9\n          z + w\n        \u2261\u27e8 cong (_+_ z) w\u22610 \u27e9\n          z + 0\n        \u2261\u27e8 +-identity\u02b3 z \u27e9\n          z\n        \u220e)\n        \net-ne-eb : \u2200 n m \u2192 eval (top+ n) \u2262 eval (bot+ m)\net-ne-eb n m e with eval n | eval m | inspect eval n\n... | mat a\u2081 b\u2081 c\u2081 d\u2081 | mat a\u2082 b\u2082 c\u2082 d\u2082 | [ en ] =\n  let eq\u2081 , eq\u2082 , eq\u2083 , eq\u2084 = all-projs e\n      a\u2081\u22610 , _ = lemma-add-regress a\u2081 c\u2081 a\u2082 c\u2082 eq\u2081 eq\u2083\n      ea = proja en\n      in a-ne-0 n (trans ea a\u2081\u22610)\n\n-- Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique.\neval-injective : \u2200 m n \u2192 eval m \u2261 eval n \u2192 m \u2261 n\neval-injective I I e = refl\neval-injective I (top+ n) e = \u22a5-elim (eI-ne-et n e)\neval-injective I (bot+ n) e = \u22a5-elim (eI-ne-eb n e)\neval-injective (top+ m) I e = \u22a5-elim (eI-ne-et m (sym e))\neval-injective (top+ m) (top+ n) e with eval (top+ m) | eval (top+ n) | inspect (eval \u2218 top+) m | inspect (eval \u2218 top+) n\n... | m' | n' | [ em ] | [ en ] = let eq\u2081 , eq\u2082 , eq\u2083 , eq\u2084 = all-projs (trans em (trans e (sym en))) in\n  cong top+ (eval-injective m n (congMat\n      (+-cancel\u02b3-\u2261 (a (eval m)) (a (eval n)) (subst (\u03bb t \u2192 a (eval m) + t \u2261 a (eval n) + c (eval n)) eq\u2083 eq\u2081))\n      (+-cancel\u02b3-\u2261 (b (eval m)) (b (eval n)) (subst (\u03bb t \u2192 b (eval m) + t \u2261 b (eval n) + d (eval n)) eq\u2084 eq\u2082))\n      eq\u2083\n      eq\u2084\n    ))\neval-injective (top+ m) (bot+ n) e = \u22a5-elim (et-ne-eb m n e)\neval-injective (bot+ m) I e = \u22a5-elim (eI-ne-eb m (sym e))\neval-injective (bot+ m) (top+ n) e = \u22a5-elim (et-ne-eb n m (sym e))\neval-injective (bot+ m) (bot+ n) e with eval (bot+ m) | eval (bot+ n) | inspect (eval \u2218 bot+) m | inspect (eval \u2218 bot+) n\n... | m' | n' | [ em ] | [ en ] = let eq\u2081 , eq\u2082 , eq\u2083 , eq\u2084 = all-projs (trans em (trans e (sym en))) in\n  cong bot+ (eval-injective m n (congMat\n     eq\u2081\n     eq\u2082\n     (+-cancel\u02e1-\u2261 (a (eval n)) (subst (\u03bb t \u2192 t + c (eval m) \u2261 a (eval n) + c (eval n)) eq\u2081 eq\u2083))\n     (+-cancel\u02e1-\u2261 (b (eval n)) (subst (\u03bb t \u2192 t + d (eval m) \u2261 b (eval n) + d (eval n)) eq\u2082 eq\u2084))\n    ))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":229,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule SL2N-unique where\n\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.Nat using (\u2115; zero; suc; _+_)\nopen import Data.Nat.Properties using (+-assoc; +-comm; +-identity\u02b3;\n                                       +-cancel\u02e1-\u2261; +-cancel\u02b3-\u2261; i+j\u22610\u21d2i\u22610)\nopen import Function using (_\u2218_)\n\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; _\u2262_; cong; refl; sym; trans)\nopen Eq.\u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\n\nopen import Matrix\nopen Mat\n\nprivate\n\n  0\u22621+n : \u2200 {n : \u2115} \u2192 zero \u2262 suc n\n  0\u22621+n ()\n\n  module Coefficients\u1d50 (m : SL2N) where\n    a\u1d50 b\u1d50 c\u1d50 d\u1d50 : \u2115\n    a\u1d50 = a (eval m)\n    b\u1d50 = b (eval m)\n    c\u1d50 = c (eval m)\n    d\u1d50 = d (eval m)\n\n  module Coefficients\u207f (n : SL2N) where\n    a\u207f b\u207f c\u207f d\u207f : \u2115\n    a\u207f = a (eval n)\n    b\u207f = b (eval n)\n    c\u207f = c (eval n)\n    d\u207f = d (eval n)\n\n  a-eval-m\u22620 : \u2200 (m : SL2N) \u2192 a (eval m) \u2262 0\n  a-eval-m\u22620 I        = \u03bb()\n  a-eval-m\u22620 (top+ m) = (a-eval-m\u22620 m) \u2218 (i+j\u22610\u21d2i\u22610 a\u1d50)\n    where open Coefficients\u1d50 m\n  a-eval-m\u22620 (bot+ m) = a-eval-m\u22620 m\n\n  eval-I\u2262eval-top+n : \u2200 {n : SL2N} \u2192 eval I \u2262 eval (top+ n)\n  eval-I\u2262eval-top+n {n} eval-I\u2261eval-top+n =\n    0\u22621+n 0\u22611+b\u207f\n    where open Coefficients\u207f n\n          0\u2261b\u207f+d\u207f : 0 \u2261 b\u207f + d\u207f\n          0\u2261b\u207f+d\u207f = cong b eval-I\u2261eval-top+n\n          1\u2261d\u207f : 1 \u2261 d\u207f\n          1\u2261d\u207f = cong d eval-I\u2261eval-top+n\n          0\u2261b\u207f+1 : 0 \u2261 b\u207f + 1\n          0\u2261b\u207f+1 = trans 0\u2261b\u207f+d\u207f (sym (cong (b\u207f +_) 1\u2261d\u207f))\n          0\u22611+b\u207f : 0 \u2261 1 + b\u207f\n          0\u22611+b\u207f = trans 0\u2261b\u207f+1 (+-comm b\u207f 1)\n\n  eval-top+m\u2262eval-I : \u2200 {m : SL2N} \u2192 eval (top+ m) \u2262 eval I\n  eval-top+m\u2262eval-I {m} = eval-I\u2262eval-top+n {m} \u2218 sym\n\n  eval-I\u2262eval-bot+n : \u2200 {n : SL2N} \u2192 eval I \u2262 eval (bot+ n)\n  eval-I\u2262eval-bot+n {n} eval-I\u2261eval-bot+n =\n    0\u22621+n 0\u22611+c\u207f\n    where open Coefficients\u207f n\n          1\u2261a\u207f : 1 \u2261 a\u207f\n          1\u2261a\u207f = cong a eval-I\u2261eval-bot+n\n          0\u2261a\u207f+c\u207f : 0 \u2261 a\u207f + c\u207f\n          0\u2261a\u207f+c\u207f = cong c eval-I\u2261eval-bot+n\n          0\u22611+c\u207f : 0 \u2261 1 + c\u207f\n          0\u22611+c\u207f = trans 0\u2261a\u207f+c\u207f (sym (cong (_+ c\u207f) 1\u2261a\u207f))\n\n  eval-bot+m\u2262eval-I : \u2200 {m : SL2N} \u2192 eval (bot+ m) \u2262 eval I\n  eval-bot+m\u2262eval-I {m} = eval-I\u2262eval-bot+n {m} \u2218 sym\n\n  eval-top+m\u2262eval-bot+n : \u2200 {m n : SL2N} \u2192 eval (top+ m) \u2262 eval (bot+ n)\n  eval-top+m\u2262eval-bot+n {m} {n} eval-top+m\u2261eval-bot+n =\n    a-eval-m\u22620 m a\u1d50\u22610\n    where open Coefficients\u1d50 m\n          open Coefficients\u207f n\n          a\u1d50+c\u1d50\u2261a\u207f : a\u1d50 + c\u1d50 \u2261 a\u207f\n          a\u1d50+c\u1d50\u2261a\u207f = cong a eval-top+m\u2261eval-bot+n\n          c\u1d50\u2261a\u207f+c\u207f : c\u1d50 \u2261 a\u207f + c\u207f\n          c\u1d50\u2261a\u207f+c\u207f = cong c eval-top+m\u2261eval-bot+n\n          a\u1d50\u22610 : a\u1d50 \u2261 0\n          a\u1d50\u22610 = lemma a\u1d50+c\u1d50\u2261a\u207f c\u1d50\u2261a\u207f+c\u207f\n            where lemma : \u2200 {x y x' y' : \u2115} \u2192 x + y \u2261 x' \u2192 y \u2261 x' + y' \u2192 x \u2261 0\n                  lemma {x} {y} {x'} {y'} x+y\u2261x' y\u2261x'+y' =\n                    i+j\u22610\u21d2i\u22610 x x+y'\u22610\n                    where x'+[x+y']\u2261x'+0 : x' + (x + y') \u2261 x' + 0\n                          x'+[x+y']\u2261x'+0 = begin\n                                             x' + (x + y')\n                                           \u2261\u27e8 sym (+-assoc x' x y') \u27e9\n                                             x' + x + y'\n                                           \u2261\u27e8 cong (_+ y') (+-comm x' x) \u27e9\n                                             x + x' + y'\n                                           \u2261\u27e8 +-assoc x x' y' \u27e9\n                                             x + (x' + y')\n                                           \u2261\u27e8 sym (cong (x +_) y\u2261x'+y') \u27e9\n                                             x + y\n                                           \u2261\u27e8 x+y\u2261x' \u27e9\n                                             x'\n                                           \u2261\u27e8 sym (+-identity\u02b3 x') \u27e9\n                                             x' + 0\n                                           \u220e\n                          x+y'\u22610 : x + y' \u2261 0\n                          x+y'\u22610 = +-cancel\u02e1-\u2261 x' x'+[x+y']\u2261x'+0\n\n  eval-bot+m\u2262eval-top+n : \u2200 {m n : SL2N} \u2192 eval (bot+ m) \u2262 eval (top+ n)\n  eval-bot+m\u2262eval-top+n {m} {n} = eval-top+m\u2262eval-bot+n {n} {m} \u2218 sym\n\neval-injective : \u2200 m n \u2192 eval m \u2261 eval n \u2192 m \u2261 n\neval-injective I I refl = refl\neval-injective (top+ m) (top+ n) eval-top+m\u2261eval-top+n =\n  cong top+ (eval-injective m n (congMat a\u1d50\u2261a\u207f b\u1d50\u2261b\u207f c\u1d50\u2261c\u207f d\u1d50\u2261d\u207f))\n  where open Coefficients\u1d50 m\n        open Coefficients\u207f n\n        c\u1d50\u2261c\u207f : c\u1d50 \u2261 c\u207f\n        c\u1d50\u2261c\u207f = cong c eval-top+m\u2261eval-top+n\n        d\u1d50\u2261d\u207f : d\u1d50 \u2261 d\u207f\n        d\u1d50\u2261d\u207f = cong d eval-top+m\u2261eval-top+n\n        a\u1d50\u2261a\u207f : a\u1d50 \u2261 a\u207f\n        a\u1d50\u2261a\u207f = +-cancel\u02b3-\u2261 a\u1d50 a\u207f (trans (cong a eval-top+m\u2261eval-top+n) (sym (cong (a\u207f +_) c\u1d50\u2261c\u207f)))\n        b\u1d50\u2261b\u207f : b\u1d50 \u2261 b\u207f\n        b\u1d50\u2261b\u207f = +-cancel\u02b3-\u2261 b\u1d50 b\u207f (trans (cong b eval-top+m\u2261eval-top+n) (sym (cong (b\u207f +_) d\u1d50\u2261d\u207f)))\neval-injective (bot+ m) (bot+ n) eval-bot+m\u2261eval-bot+n =\n  cong bot+ (eval-injective m n (congMat a\u1d50\u2261a\u207f b\u1d50\u2261b\u207f c\u1d50\u2261c\u207f d\u1d50\u2261d\u207f))\n  where open Coefficients\u1d50 m\n        open Coefficients\u207f n\n        a\u1d50\u2261a\u207f : a\u1d50 \u2261 a\u207f\n        a\u1d50\u2261a\u207f = cong a eval-bot+m\u2261eval-bot+n\n        b\u1d50\u2261b\u207f : b\u1d50 \u2261 b\u207f\n        b\u1d50\u2261b\u207f = cong b eval-bot+m\u2261eval-bot+n\n        c\u1d50\u2261c\u207f : c\u1d50 \u2261 c\u207f\n        c\u1d50\u2261c\u207f = +-cancel\u02e1-\u2261 a\u1d50 (trans (cong c eval-bot+m\u2261eval-bot+n) (sym (cong (_+ c\u207f) a\u1d50\u2261a\u207f)))\n        d\u1d50\u2261d\u207f : d\u1d50 \u2261 d\u207f\n        d\u1d50\u2261d\u207f = +-cancel\u02e1-\u2261 b\u1d50 (trans (cong d eval-bot+m\u2261eval-bot+n) (sym (cong (_+ d\u207f) b\u1d50\u2261b\u207f)))\neval-injective I (top+ n) eval-I\u2261eval-top+n =\n  \u22a5-elim (eval-I\u2262eval-top+n {n} eval-I\u2261eval-top+n)\neval-injective (top+ m) I eval-top+m\u2261eval-I =\n  \u22a5-elim (eval-top+m\u2262eval-I {m} eval-top+m\u2261eval-I)\neval-injective I (bot+ n) eval-I\u2261eval-bot+n =\n  \u22a5-elim (eval-I\u2262eval-bot+n {n} eval-I\u2261eval-bot+n)\neval-injective (bot+ m) I eval-bot+m\u2261eval-I =\n  \u22a5-elim (eval-bot+m\u2262eval-I {m} eval-bot+m\u2261eval-I)\neval-injective (top+ m) (bot+ n) eval-top+m\u2261eval-bot+n =\n  \u22a5-elim (eval-top+m\u2262eval-bot+n {m} {n} eval-top+m\u2261eval-bot+n)\neval-injective (bot+ m) (top+ n) eval-bot+m\u2261eval-top+n =\n  \u22a5-elim (eval-bot+m\u2262eval-top+n {m} {n} eval-bot+m\u2261eval-top+n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":230,"user_id":168,"body":"{-# OPTIONS --safe #-}\n\nmodule SL2N-unique where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Empty\nopen \u2261-Reasoning\n\naNot0 : \u2200 s \u2192 eval s .a \u2262 0\naNot0 I = \u03bb ()\naNot0 (top+ m) eq with eval m | aNot0 m\n... | mat a b c d | eq2 = eq2 (i+j\u22610\u21d2i\u22610 a eq)\naNot0 (bot+ m) eq with eval m | aNot0 m\n... | mat a b c d | eq2 = eq2 eq\n\n1neq0 : 1 \u2262 0\n1neq0 eq = (m\u22621+m+n 0 {0}) (sym eq)\n\n-- Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique.\n\neval-injective-I : \u2200 n \u2192 eval n \u2261 mat 1 0 0 1 \u2192 n \u2261 I\neval-injective-I I eq = refl\neval-injective-I (top+ n) eq with eval n\n... | mat a b c d =\n  let d1 = cong Mat.d eq in\n  let d2 = (i+j\u22610\u21d2j\u22610 b (cong Mat.b eq)) in\n  \u22a5-elim (1neq0 (trans (sym d1) d2))\neval-injective-I (bot+ n) eq with eval n\n... | mat a b c d  =\n  let a1 = i+j\u22610\u21d2i\u22610 a (cong Mat.c eq) in\n  let a2 = cong Mat.a eq in\n  \u22a5-elim (1neq0 (trans (sym a2) a1))\n\neval-injective-top-bot : \u2200 (m n) \u2192 eval (top+ m) \u2262 eval (bot+ n)\neval-injective-top-bot m n eq with eval m | eval n | inspect eval m\n... | mat a b c d | mat x y u v | [ meq ] =\n  let r = i+j\u22610\u21d2i\u22610 a (sym (+-cancel\u02b3-\u2261 0 (a + u) lemma1)) in\n  aNot0 m (trans (cong Mat.a meq) r)\n  where lemma1 : 0 + x \u2261 (a + u) + x\n        lemma1 = x \u2261\u27e8 sym (cong Mat.a eq) \u27e9\n                 a + c \u2261\u27e8 cong (a +_) (cong Mat.c eq) \u27e9\n                 a + (x + u) \u2261\u27e8 cong (a +_) (+-comm x u) \u27e9\n                 a + (u + x) \u2261\u27e8 sym (+-assoc a u x) \u27e9\n                 (a + u) + x \u220e\n\neval-injective : \u2200 m n \u2192 eval m \u2261 eval n \u2192 m \u2261 n\neval-injective I n eq = sym (eval-injective-I n (sym eq))\neval-injective m I eq = eval-injective-I m eq\neval-injective (top+ m) (top+ n) eq with eval m | eval n | eval-injective m n\n... | mat a b c d | mat x y u v | eq2 =\n  let eqa = cong Mat.a eq in\n  let eqb = cong Mat.b eq in\n  let eqc = cong Mat.c eq in\n  let eqd = cong Mat.d eq in\n  cong top+ (eq2 (congMat\n    (+-cancel\u02b3-\u2261 a x (trans eqa (cong (x +_) (sym eqc))))\n    (+-cancel\u02b3-\u2261 b y (trans eqb (cong (y +_) (sym eqd))))\n    eqc eqd))\neval-injective (bot+ m) (bot+ n) eq with eval m | eval n | eval-injective m n\n... | mat a b c d | mat x y u v | eq2 =\n  let eqa = cong Mat.a eq in\n  let eqb = cong Mat.b eq in\n  let eqc = cong Mat.c eq in\n  let eqd = cong Mat.d eq in\n  cong bot+ (eq2 (congMat eqa eqb\n    (+-cancel\u02e1-\u2261 a (trans eqc (cong (_+ u) (sym eqa))))\n    (+-cancel\u02e1-\u2261 b (trans eqd (cong (_+ v) (sym eqb))))))\neval-injective (top+ m) (bot+ n) eq = \u22a5-elim (eval-injective-top-bot m n eq)\neval-injective (bot+ n) (top+ m) eq = \u22a5-elim (eval-injective-top-bot m n (sym eq))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":231,"user_id":489,"body":"{-# OPTIONS --safe #-}\n\nmodule SL2N-unique where\n\nopen import Matrix\nopen Mat\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver using (module +-*-Solver)\nopen +-*-Solver\nopen import Data.Empty\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\n-- Prove that eval is injective, i.e. for any 2x2 matrix in the set SL2N, the representation is unique.\n\nz\u2261d\u21d2\u22a5 : \u2200 m \u2192 zero \u2261 d (eval m) \u2192 \u22a5\nz\u2261d\u21d2\u22a5 I = \u03bb ()\nz\u2261d\u21d2\u22a5 (top+ m) = z\u2261d\u21d2\u22a5 m\nz\u2261d\u21d2\u22a5 (bot+ m) pf = z\u2261d\u21d2\u22a5 m (sym (i+j\u22610\u21d2j\u22610 (b (eval m)) (sym pf)))\n\nz\u2261a\u21d2\u22a5 : \u2200 m \u2192 zero \u2261 a (eval m) \u2192 \u22a5\nz\u2261a\u21d2\u22a5 I = \u03bb ()\nz\u2261a\u21d2\u22a5 (top+ m) pf = z\u2261a\u21d2\u22a5 m (sym (i+j\u22610\u21d2i\u22610 (a (eval m)) (sym pf)))\nz\u2261a\u21d2\u22a5 (bot+ m) = z\u2261a\u21d2\u22a5 m\n\nz\u2261bt\u21d2\u22a5 : \u2200 m \u2192 zero \u2261 b (eval (top+ m)) \u2192 \u22a5\nz\u2261bt\u21d2\u22a5 m = z\u2261d\u21d2\u22a5 (bot+ m)\n\nz\u2261cb\u21d2\u22a5 : \u2200 m \u2192 zero \u2261 c (eval (bot+ m)) \u2192 \u22a5\nz\u2261cb\u21d2\u22a5 m = z\u2261a\u21d2\u22a5 (top+ m)\n\n+-cancel\u02b3 : \u2200 {a a' b b'} \u2192 a + b \u2261 a' + b' \u2192 b \u2261 b' \u2192 a \u2261 a'\n+-cancel\u02b3 {a} {a'} pf+ pf\u02b3 = +-cancel\u02b3-\u2261 a a' (trans (cong (a +_) (sym pf\u02b3)) pf+)\n\ntop+-cancel : \u2200 {a b c d a' b' c' d'} \u2192\n  mat (a + c) (b + d) c d \u2261 mat (a' + c') (b' + d') c' d' \u2192 mat a b c d \u2261 mat a' b' c' d'\ntop+-cancel pf = \n  congMat (+-cancel\u02b3 (cong a pf) (cong c pf))\n          (+-cancel\u02b3 (cong b pf) (cong d pf))\n          (cong c pf)\n          (cong d pf)\n\n+-cancel\u02e1 : \u2200 {a a' b b'} \u2192 a \u2261 a' \u2192 a + b \u2261 a' + b' \u2192 b \u2261 b'\n+-cancel\u02e1 {a} {a'} {b} {b'} pf\u02e1 pf+ = +-cancel\u02b3 (trans (trans (+-comm b a) pf+) (+-comm a' b')) pf\u02e1\n\nbot+-cancel : \u2200 {a b c d a' b' c' d'} \u2192\n  mat a b (a + c) (b + d) \u2261 mat a' b' (a' + c') (b' + d') \u2192 mat a b c d \u2261 mat a' b' c' d'\nbot+-cancel pf =\n  congMat (cong a pf)\n          (cong b pf)\n          (+-cancel\u02e1 (cong a pf) (cong c pf))\n          (+-cancel\u02e1 (cong b pf) (cong d pf))\n\ncross-+-a : \u2200 {a b a' b'} \u2192 a + b \u2261 a' \u2192 b \u2261 a' + b' \u2192 a \u2261 0\ncross-+-a {a} {b} {a'} {b'} pf1 pf2 = i+j\u22610\u21d2i\u22610 a (+-cancel\u02b3-\u2261 (a + b') 0 (begin\n  (a + b') + b \u2261\u27e8 solve 3 (\u03bb a b b' \u2192 a :+ b' :+ b := a :+ b :+ b') refl a b b' \u27e9\n  (a + b) + b' \u2261\u27e8 cong (\u03bb z \u2192 z + b') pf1 \u27e9\n  a' + b' \u2261\u27e8 sym pf2 \u27e9\n  b \u220e))\n\neval-injective : \u2200 m n \u2192 eval m \u2261 eval n \u2192 m \u2261 n\neval-injective I I pf = refl\neval-injective I (top+ n) pf = \u22a5-elim (z\u2261bt\u21d2\u22a5 n (cong b pf))\neval-injective I (bot+ n) pf = \u22a5-elim (z\u2261cb\u21d2\u22a5 n (cong c pf))\neval-injective (top+ m) I pf = \u22a5-elim (z\u2261bt\u21d2\u22a5 m (sym (cong b pf)))\neval-injective (top+ m) (top+ n) pf = cong top+ (eval-injective m n (top+-cancel pf))\neval-injective (top+ m) (bot+ n) pf = \u22a5-elim (z\u2261a\u21d2\u22a5 m (sym (cross-+-a (cong a pf) (cong c pf))))\neval-injective (bot+ m) I pf = \u22a5-elim (z\u2261cb\u21d2\u22a5 m (sym (cong c pf)))\neval-injective (bot+ m) (top+ n) pf = \u22a5-elim (z\u2261a\u21d2\u22a5 n (sym (cross-+-a (cong a (sym pf)) (cong c (sym pf)))))\neval-injective (bot+ m) (bot+ n) pf = cong bot+ (eval-injective m n (bot+-cancel pf))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c9c5b04cc9b0830cd270cb6":[{"id":232,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Empty\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z = \u03bb ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\n\u2264-id-+k : \u2200 (m k : \u2115) \u2192 m \u2264 k + m\n\u2264-id-+k zero k = z\u2264n\n\u2264-id-+k (suc m) k with \u2264-id-+k m k\n... | r rewrite +-comm k m with s\u2264s r\n... | q rewrite +-comm (suc m) k = q\n\n\u2264-cong-+k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 k + m \u2264 k + n\n\u2264-cong-+k zero e = e\n\u2264-cong-+k (suc k) e = s\u2264s (\u2264-cong-+k k e)\n\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k {m} k e = \u2264-trans (\u2264-id-+k m k) (\u2264-cong-+k k e)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero z\u2264n = z\u2264n\n+-\u2264-inj\u02e1 zero (s\u2264s ab\u2264ac) = s\u2264s ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n+-<-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b < a + c \u2192 b < c\n+-<-inj\u02e1 zero e = e\n+-<-inj\u02e1 (suc a) (s\u2264s e) = +-<-inj\u02e1 a e\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 (suc a) zero zero e = *-<-inj\u02e1 a zero zero e\n*-<-inj\u02e1 (suc a) zero (suc c) e = s\u2264s z\u2264n\n*-<-inj\u02e1 (suc a) (suc b) zero e rewrite *-comm a 0 = \u22a5-elim (s\u2270z e)\n*-<-inj\u02e1 (suc a) (suc b) (suc c) e rewrite *-comm (suc a) (suc b) | *-comm (suc a) (suc c) with +-<-inj\u02e1 (suc a) e\n... | r rewrite *-comm b (suc a) | *-comm c (suc a) = s\u2264s (*-<-inj\u02e1 (suc a) b c r)\n\n-- Task 5. Prove this.\n\nlemma : \u2200 (a b c d : \u2115) \u2192 a + b < c + d \u2192 c \u2264 a \u2192 b < d\nlemma zero b .zero d e z\u2264n = e\nlemma (suc a) zero .zero (suc d) e z\u2264n = s\u2264s z\u2264n\nlemma (suc a) (suc b) .zero (suc d) (s\u2264s e) z\u2264n = s\u2264s (\u2264-trans (\u2264-id-+k (suc b) (suc a)) e)\nlemma (suc a) b (suc c) d (s\u2264s e) (s\u2264s f) = lemma a b c d e f\n\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a zero c zero ab<cd c\u2264a rewrite *-comm a 0 | *-comm c 0 = ab<cd\n*-<-cross a zero c (suc d) ab<cd c\u2264a = s\u2264s z\u2264n\n*-<-cross a (suc b) c zero ab<cd c\u2264a rewrite *-comm c 0 = \u22a5-elim (s\u2270z ab<cd)\n*-<-cross a (suc b) c (suc d) ab<cd c\u2264a rewrite *-comm a (suc b) | *-comm c (suc d) with lemma a (b * a) c (d * c) ab<cd c\u2264a\n... | r rewrite *-comm b a | *-comm d c = s\u2264s (*-<-cross a b c d r c\u2264a)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":233,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Data.Empty\nopen import Data.Sum\nopen import Relation.Binary.PropositionalEquality\n\n-- lemmas\n\ntotal-lemma : \u2200 x y \u2192 x \u2264 y \u228e y < x\ntotal-lemma zero y = inj\u2081 z\u2264n\ntotal-lemma (suc x) zero = inj\u2082 (s\u2264s z\u2264n)\ntotal-lemma (suc x) (suc y) with total-lemma x y\n... | inj\u2081 x\u2081 = inj\u2081 (s\u2264s x\u2081)\n... | inj\u2082 y\u2081 = inj\u2082 (s\u2264s y\u2081)\n\nlemma-ineq : \u2200 r \u2192 \u2200 {m n} \u2192 m \u2264 n \u2192 r * m \u2264 r * n \nlemma-ineq zero m\u2264n = z\u2264n\nlemma-ineq (suc r) m\u2264n = lemma1 m\u2264n (lemma-ineq r m\u2264n) where \n    lemma1 : \u2200 {u v w x} \u2192 u \u2264 w \u2192 v \u2264 x \u2192 u + v \u2264 w + x \n    lemma1 z\u2264n z\u2264n = z\u2264n\n    lemma1 z\u2264n (s\u2264s v\u2264x) = \u2264-trans (s\u2264s (lemma1 z\u2264n v\u2264x)) (\u2264-reflexive (sym (+-suc _ _)))\n    lemma1 (s\u2264s u\u2264w) z\u2264n = s\u2264s (lemma1 u\u2264w z\u2264n)\n    lemma1 {u = suc a} {v = suc b} {w = suc c} {x = suc d} (s\u2264s u\u2264w) (s\u2264s v\u2264x) = s\u2264s \n        (subst\u2082 (\u03bb l r \u2192 l \u2264 r) (sym (+-suc a b)) (sym (+-suc c d)) (s\u2264s (lemma1 u\u2264w v\u2264x)))\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z {n} = \u03bb ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k k z\u2264n = z\u2264n\n\u2264-step-k k (s\u2264s m\u2264n) = \u2264-trans (s\u2264s (\u2264-step-k k m\u2264n)) (\u2264-reflexive (sym (+-suc k _)))\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 (suc a) b c ab<ac = [ (\u03bb h \u2192 \u22a5-elim (<\u21d2\u2271 ab<ac (lemma-ineq (suc a) h))) , \n    (\u03bb z \u2192 z) ]\u2032 (total-lemma c b)\n    \n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = [ (\u03bb h \u2192 \u22a5-elim (<\u21d2\u2271 ab<cd (\u2264-trans (lemma-ineq c h) \n    (subst\u2082 _\u2264_ (*-comm b c) (*-comm b a) (lemma-ineq b c\u2264a))))) , (\u03bb z \u2192 z) ]\u2032 \n    (total-lemma d b)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":234,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Relation.Binary.PropositionalEquality as Eq\nopen import Data.Nat public\nopen import Data.Nat.Properties\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k 0 m\u2264n = m\u2264n\n\u2264-step-k (suc k) m\u2264n = \u2264-step (\u2264-step-k k m\u2264n)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 0 ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n\nlemma : \u2200 {x} y z \u2192 y * x < z * x \u2192 y < z\nlemma {zero} zero (suc o) _ = s\u2264s z\u2264n\nlemma {suc m} zero (suc o) _ = s\u2264s z\u2264n\nlemma {m} (suc n) (suc o) nm<om = s\u2264s (lemma n o (+-cancel\u02e1-< m nm<om))\n\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 a b c p rewrite *-comm a b | *-comm a c = lemma b c p\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = *-<-inj\u02e1 c b d (<-trans\u02b3 (*-mono\u02e1-\u2264 b c\u2264a) ab<cd)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":235,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Data.Empty\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k k z\u2264n = z\u2264n\n\u2264-step-k {n = suc n} k (s\u2264s m\u2264n) rewrite +-suc k n = +-mono\u02b3-\u2264 1 (\u2264-step-k k m\u2264n)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n+-<-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b < a + c \u2192 b < c\n+-<-inj\u02e1 zero ab<ac = ab<ac\n+-<-inj\u02e1 (suc a) (s\u2264s ab<ac) = +-<-inj\u02e1 a ab<ac\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 (suc a) zero zero ab<ac = *-<-inj\u02e1 a zero zero ab<ac\n*-<-inj\u02e1 (suc a) zero (suc c) ab<ac = s\u2264s z\u2264n\n*-<-inj\u02e1 (suc a) (suc b) zero ab<ac rewrite *-zero\u02b3 a = \u22a5-elim (s\u2270z ab<ac)\n*-<-inj\u02e1 (suc a) (suc b) (suc c) ab<ac\n  rewrite *-comm (suc a) (suc b)\n  | *-comm (suc a) (suc c)\n  | *-comm b (suc a)\n  | *-comm c (suc a)\n    = s\u2264s (*-<-inj\u02e1 (suc a) b c (+-<-inj\u02e1 (suc a) ab<ac))\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = *-<-inj\u02e1 a b d (\u2264-trans ab<cd (*-mono\u02e1-\u2264 d c\u2264a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":236,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule Nat-properties where\n\nopen import Data.Empty\n  using (\u22a5-elim)\nopen import Data.Nat \n  using (\u2115; zero; suc; _\u2264_; z\u2264n; s\u2264s; _<_; _\u2270_; _+_; _*_) public\nopen import Data.Nat.Properties\n  using (\u2264-pred; \u2264-step; <-trans\u02e1; +-cancel\u02e1-<;\n         +-*-suc; *-identity\u02e1; *-zero\u02b3; *-mono\u02e1-\u2264)\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k zero m\u2264n = m\u2264n\n\u2264-step-k (suc k) m\u2264n = \u2264-step (\u2264-step-k k m\u2264n)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero p = p\n+-\u2264-inj\u02e1 (suc a) p = +-\u2264-inj\u02e1 a (\u2264-pred p)\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 zero b c ()\n*-<-inj\u02e1 (suc a) _ zero p rewrite *-zero\u02b3 (suc a) = \u22a5-elim (s\u2270z p)\n*-<-inj\u02e1 (suc a) zero (suc c) _ = s\u2264s z\u2264n\n*-<-inj\u02e1 (suc a) (suc b) (suc c) p rewrite +-*-suc (suc a) b | +-*-suc (suc a) c =\n  s\u2264s (*-<-inj\u02e1 (suc a) b c (+-cancel\u02e1-< (suc a) p))\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = *-<-inj\u02e1 a b d (<-trans\u02e1 ab<cd (*-mono\u02e1-\u2264 d c\u2264a))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":237,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Empty\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2264-Reasoning\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z = \u03bb ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k zero m\u2264n = m\u2264n\n\u2264-step-k (suc k) z\u2264n = z\u2264n\n\u2264-step-k (suc k) (s\u2264s m\u2264n) = s\u2264s (\u2264-step-k k (\u2264-trans m\u2264n (n\u22641+n _)))\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n+-<-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b < a + c \u2192 b < c\n+-<-inj\u02e1 zero ab<ac = ab<ac\n+-<-inj\u02e1 (suc a) (s\u2264s ab<ac) = +-<-inj\u02e1 a ab<ac\n\n*-<-inj\u02b3 : \u2200 (a b c : \u2115) \u2192 b * a < c * a \u2192 b < c\n*-<-inj\u02b3 zero zero (suc c) _ = s\u2264s z\u2264n\n*-<-inj\u02b3 (suc a) zero (suc c) _ = s\u2264s z\u2264n\n*-<-inj\u02b3 a (suc b) (suc c) ba<ca = s\u2264s (*-<-inj\u02b3 a b c (+-<-inj\u02e1 a ba<ca))\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 a b c ab<ac = subst\u2082 (\u03bb s t \u2192 s < t \u2192 b < c) (*-comm b a) (*-comm c a) (*-<-inj\u02b3 a b c) ab<ac\n\n\u2264+\u2264 : \u2200 {a b c d} \u2192 a \u2264 b \u2192 c \u2264 d \u2192 a + c \u2264 b + d\n\u2264+\u2264 {zero} {b} {c} {d} a\u2264b c\u2264d = \u2264-step-k b c\u2264d\n\u2264+\u2264 {suc a} {suc b} {c} {d} (s\u2264s a\u2264b) c\u2264d = s\u2264s (\u2264+\u2264 a\u2264b c\u2264d)\n\n\u2264-mul\u02e1 : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 k * m \u2264 k * n\n\u2264-mul\u02e1 zero m\u2264n = z\u2264n\n\u2264-mul\u02e1 (suc k) m\u2264n = \u2264+\u2264 m\u2264n (\u2264-mul\u02e1 k m\u2264n)\n\n\u2264-mul\u02b3 : \u2200{m n} (k : \u2115) \u2192 m \u2264 n \u2192 m * k \u2264 n * k\n\u2264-mul\u02b3 {m} {n} k m\u2264n = subst\u2082 _\u2264_ (*-comm k m) (*-comm k n) (\u2264-mul\u02e1 k m\u2264n)\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = *-<-inj\u02e1 a b d (<-trans\u02e1 ab<cd (\u2264-mul\u02b3 d c\u2264a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":238,"user_id":1163,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Relation.Nullary\nopen import Data.Empty\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k zero m\u2264n = m\u2264n\n\u2264-step-k (suc k) m\u2264n = \u2264-step (\u2264-step-k k m\u2264n)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 (suc a) b c ab<ac\n  rewrite *-comm (suc a) b\n        | *-comm (suc a) c = *-<-inj\u02b3 a b c ab<ac\n  where\n    *-<-inj\u02b3 : \u2200 (a b c : \u2115) \u2192 b * suc a < c * suc a \u2192 b < c\n    *-<-inj\u02b3 a zero (suc c) ba<ca = s\u2264s z\u2264n\n    *-<-inj\u02b3 a (suc b) (suc c) (s\u2264s ba<ca)\n      rewrite +-comm a (b * suc a)\n            | +-comm (suc (b * suc a)) a\n            = s\u2264s (*-<-inj\u02b3 a b c (+-\u2264-inj\u02e1 a ba<ca))\n\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a\n  with b <? d\n...  | yes p = p\n...  | no p = \u22a5-elim (\u2264\u21d2\u226f (*-mono-\u2264 c\u2264a (\u226e\u21d2\u2265 p)) ab<cd)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":239,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary.Negation using (contradiction)\nopen import Relation.Nullary.Decidable\nopen import Relation.Nullary\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z {n} ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k zero m\u2264n = m\u2264n\n\u2264-step-k (suc k) m\u2264n = \u2264-step (\u2264-step-k k m\u2264n)\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) ab\u2264ac = +-\u2264-inj\u02e1 a (\u2264-pred ab\u2264ac)\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\nlemma\u00b9 : \u2200 {m n : \u2115} \u2192 m < n \u2192 0 < n \u2238 m\nlemma\u00b9 {m} {n} m<n with \u2238-mono\u02e1-\u2264 m m<n\n... | H rewrite m+n\u2238n\u2261m 1 m = H\n\nlemma\u00b2 : \u2200 {m n : \u2115} \u2192 0 < n \u2238 m \u2192 m < n\nlemma\u00b2 {m} {zero} 0<n\u2238m\n  rewrite 0\u2238n\u22610 m = contradiction 0<n\u2238m (\u03bb ())\nlemma\u00b2 {zero} {suc n} 0<n\u2238m = 0<n\u2238m\nlemma\u00b2 {suc m} {suc n} 0<n\u2238m = s\u2264s (lemma\u00b2 0<n\u2238m)\n\nlemma\u00b3 : \u2200 m n \u2192 0 < m * n \u2192 0 < n\nlemma\u00b3 m zero 0<m*n rewrite *-comm m zero = 0<m*n\nlemma\u00b3 m (suc n) 0<m*n = s\u2264s z\u2264n\n\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 a b c ab<ac with lemma\u00b9 ab<ac\n... | H rewrite sym (*-distrib\u02e1-\u2238 a c b) = lemma\u00b2 (lemma\u00b3 a (c \u2238 b) H)\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = *-<-inj\u02e1 a b d (\u2264-trans ab<cd (*-mono\u02e1-\u2264 d c\u2264a))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":240,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Data.Empty\nopen import Relation.Nullary\n\n-- Task 1. Prove that the successor of a Nat cannot be \u2264 zero.\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z = \u03bb ()\n\n-- Task 2. Prove that you can add any Nat to the right side of a \u2264-property.\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k = \u2264-steps\u02e1\n\n-- Task 3. Prove that you can remove \"addition on the left\" from both sides of a \u2264-property.\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 = +-cancel\u02e1-\u2264\n\n-- Task 4. Prove that you can remove \"multiplication on the left\" from both sides of a <-property.\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 a b c ab<ac with b <? c\n... | yes bc = bc\n... | no nbc = \u22a5-elim (\u2264\u21d2\u226f (*-mono\u02b3-\u2264 a (\u226e\u21d2\u2265 nbc)) ab<ac)\n\n-- Task 5. Prove this.\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a with b <? d\n... | yes bd = bd\n... | no nbd = \u22a5-elim (\u2264\u21d2\u226f (*-mono-\u2264 c\u2264a (\u226e\u21d2\u2265 nbd)) ab<cd)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":241,"user_id":489,"body":"{-# OPTIONS --safe #-}\nmodule Nat-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Empty\n\ns\u2270z : \u2200 {n} \u2192 suc n \u2270 zero\ns\u2270z ()\n\n\u2264-step-k : \u2200 {m n} (k : \u2115) \u2192 m \u2264 n \u2192 m \u2264 k + n\n\u2264-step-k zero m\u2264n = m\u2264n\n\u2264-step-k (suc k) m\u2264n = \u2264-step (\u2264-step-k k m\u2264n)\n\n+-\u2264-inj\u02e1 : \u2200 (a : \u2115) {b c} \u2192 a + b \u2264 a + c \u2192 b \u2264 c\n+-\u2264-inj\u02e1 zero ab\u2264ac = ab\u2264ac\n+-\u2264-inj\u02e1 (suc a) (s\u2264s ab\u2264ac) = +-\u2264-inj\u02e1 a ab\u2264ac\n\n*-<-inj\u02e1 : \u2200 (a b c : \u2115) \u2192 a * b < a * c \u2192 b < c\n*-<-inj\u02e1 a zero zero ab<ac rewrite *-comm a 0 = ab<ac\n*-<-inj\u02e1 a zero (suc c) ab<ac = s\u2264s z\u2264n\n*-<-inj\u02e1 a (suc b) zero ab<ac rewrite *-comm a 0 = \u22a5-elim (s\u2270z ab<ac)\n*-<-inj\u02e1 a (suc b) (suc c) ab<ac\n  rewrite +-*-suc a b | +-*-suc a c | sym (+-suc a (a * b)) = s\u2264s (*-<-inj\u02e1 a b c (+-\u2264-inj\u02e1 a ab<ac))\n\n*-<-cross : \u2200 (a b c d : \u2115) \u2192 a * b < c * d \u2192 c \u2264 a \u2192 b < d\n*-<-cross a b c d ab<cd c\u2264a = *-<-inj\u02e1 a b d (<-trans\u02e1 ab<cd (*-mono\u02e1-\u2264 d c\u2264a))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5ca3fcc8f7fb0800201ba88f":[{"id":242,"user_id":105,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n\ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl {A} = Bijection A\u2192A A\u2192A A\u2192A\u2192A A\u2192A\u2192A where\n  A\u2192A : A \u2192 A\n  A\u2192A a = a\n\n  A\u2192A\u2192A : \u2200 (a : A) \u2192 A\u2192A (A\u2192A a) \u2261 a\n  A\u2192A\u2192A _ = refl\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans {A} {B} {C} (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = Bijection A\u2192C C\u2192A A\u2192C\u2192A C\u2192A\u2192C where\n  A\u2192C : A \u2192 C\n  A\u2192C a = B\u2192C (A\u2192B a)\n\n  C\u2192A : C \u2192 A\n  C\u2192A c = B\u2192A (C\u2192B c)\n\n  A\u2192C\u2192A : \u2200 (a : A) \u2192 C\u2192A (A\u2192C a) \u2261 a\n  A\u2192C\u2192A a rewrite B\u2192C\u2192B (A\u2192B a) = A\u2192B\u2192A a\n\n  C\u2192A\u2192C : \u2200 (c : C) \u2192 A\u2192C (C\u2192A c) \u2261 c\n  C\u2192A\u2192C c rewrite B\u2192A\u2192B (C\u2192B c) = C\u2192B\u2192C c\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt {A} {B} A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B' where\n  B\u2192A\u2192B' : \u2200 (b : B) \u2192 A\u2192B (B\u2192A b) \u2261 b\n  B\u2192A\u2192B' b = B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n{- Preloaded code\ndata \u2115+1 : Set where\n  null : \u2115+1\n  nat : \u2115 \u2192 \u2115+1\n-}\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection \u2115\u2192\u2115+1 \u2115+1\u2192\u2115 \u2115\u2192\u2115+1\u2192\u2115 \u2115+1\u2192\u2115\u2192\u2115+1 where\n  \u2115\u2192\u2115+1 : \u2115 \u2192 \u2115+1\n  \u2115\u2192\u2115+1 zero    = null\n  \u2115\u2192\u2115+1 (suc n) = nat n\n\n  \u2115+1\u2192\u2115 : \u2115+1 \u2192 \u2115\n  \u2115+1\u2192\u2115 null    = zero\n  \u2115+1\u2192\u2115 (nat n) = suc n\n\n  \u2115\u2192\u2115+1\u2192\u2115 : \u2200 (n : \u2115) \u2192 \u2115+1\u2192\u2115 (\u2115\u2192\u2115+1 n) \u2261 n\n  \u2115\u2192\u2115+1\u2192\u2115 zero    = refl\n  \u2115\u2192\u2115+1\u2192\u2115 (suc _) = refl\n\n  \u2115+1\u2192\u2115\u2192\u2115+1 : \u2200 (n+1 : \u2115+1) \u2192 \u2115\u2192\u2115+1 (\u2115+1\u2192\u2115 n+1) \u2261 n+1\n  \u2115+1\u2192\u2115\u2192\u2115+1 null    = refl\n  \u2115+1\u2192\u2115\u2192\u2115+1 (nat _) = refl\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n{- Preloaded code\ndata \u2115+\u2115 : Set where\n  left : \u2115 \u2192 \u2115+\u2115\n  right : \u2115 \u2192 \u2115+\u2115\n-}\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\ndouble : \u2115 \u2192 \u2115\ndouble zero = zero\ndouble (suc n) = suc (suc (double n))\n\ndata \u2115-parity : \u2115 \u2192 Set where\n  even : \u2200 (n : \u2115) \u2192 \u2115-parity (double n)\n  odd  : \u2200 (n : \u2115) \u2192 \u2115-parity (suc (double n))\n\nparity : \u2200 (n : \u2115) \u2192 \u2115-parity n\nparity zero          = even zero\nparity (suc zero)    = odd zero\nparity (suc (suc n)) with parity n\n...                     | even x = even (suc x)\n...                     | odd x  = odd (suc x)\n\ndouble-even : \u2200 (n : \u2115) \u2192 parity (double n) \u2261 even n\ndouble-even zero    = refl\ndouble-even (suc n) rewrite double-even n = refl\n\nsuc-double-odd : \u2200 (n : \u2115) \u2192 parity (suc (double n)) \u2261 odd n\nsuc-double-odd zero = refl\nsuc-double-odd (suc n) rewrite suc-double-odd n = refl\n\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection \u2115\u2192\u2115+\u2115 \u2115+\u2115\u2192\u2115 \u2115\u2192\u2115+\u2115\u2192\u2115 \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 where\n  \u2115\u2192\u2115+\u2115 : \u2115 \u2192 \u2115+\u2115\n  \u2115\u2192\u2115+\u2115 n with parity n\n  ...        | even x = left x\n  ...        | odd x  = right x\n\n  \u2115+\u2115\u2192\u2115 : \u2115+\u2115 \u2192 \u2115\n  \u2115+\u2115\u2192\u2115 (left n)  = double n\n  \u2115+\u2115\u2192\u2115 (right n) = suc (double n)\n\n  \u2115\u2192\u2115+\u2115\u2192\u2115 : \u2200 (n : \u2115) \u2192 \u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 n) \u2261 n\n  \u2115\u2192\u2115+\u2115\u2192\u2115 n with parity n\n  ...          | even x = refl\n  ...          | odd x  = refl\n\n  \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 : \u2200 (n+n : \u2115+\u2115) \u2192 \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 n+n) \u2261 n+n\n  \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left n) rewrite double-even n     = refl\n  \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right n) rewrite suc-double-odd n = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":243,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Data.Nat.Properties\n\nopen import Iso\nopen _\u21d4_\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection (\u03bb z \u2192 z) (\u03bb z \u2192 z) (\u03bb a \u2192 refl) (\u03bb b \u2192 refl)\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans {A} {B} {C} (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = Bijection (\u03bb z \u2192 B\u2192C (A\u2192B z)) (\u03bb z \u2192 B\u2192A (C\u2192B z)) A\u2192C\u2192A C\u2192A\u2192C\n  where \n    A\u2192C\u2192A : (a : A) \u2192 B\u2192A (C\u2192B (B\u2192C (A\u2192B a))) \u2261 a\n    A\u2192C\u2192A a rewrite (B\u2192C\u2192B (A\u2192B a)) | (A\u2192B\u2192A a) = refl\n    \n    C\u2192A\u2192C : (c : C) \u2192 B\u2192C (A\u2192B (B\u2192A (C\u2192B c))) \u2261 c\n    C\u2192A\u2192C c rewrite (B\u2192A\u2192B (C\u2192B c)) | (C\u2192B\u2192C c) = refl\n\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A \u03bb b \u2192 B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n{- Preloaded code\ndata \u2115+1 : Set where\n  null : \u2115+1\n  nat : \u2115 \u2192 \u2115+1\n-}\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection \n  (\u03bb { zero \u2192 null ; (suc x) \u2192 nat x}) \n  (\u03bb { null \u2192 0 ; (nat x) \u2192 suc x}) \n  (\u03bb { zero \u2192 refl ; (suc a) \u2192 refl}) \n  (\u03bb { null \u2192 refl ; (nat x) \u2192 refl})\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n{- Preloaded code\ndata \u2115+\u2115 : Set where\n  left : \u2115 \u2192 \u2115+\u2115\n  right : \u2115 \u2192 \u2115+\u2115\n-}\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\nsuc-inj : \u2115+\u2115 \u2192 \u2115+\u2115\nsuc-inj (left x) = left (suc x)\nsuc-inj (right x) = right (suc x)\n\ninject : \u2115 \u2192 \u2115+\u2115\ninject zero = left zero\ninject (suc zero) = right zero\ninject (suc (suc x)) = suc-inj (inject x)\n\ninject-inv : \u2115+\u2115 \u2192 \u2115\ninject-inv (left zero) = zero\ninject-inv (left (suc x)) = suc (suc (inject-inv (left x)))\ninject-inv (right zero) = suc zero\ninject-inv (right (suc x)) = suc (suc (inject-inv (right x)))\n\ninject-inv-suc : \u2200 x \u2192 inject-inv (suc-inj x) \u2261 suc (suc (inject-inv x))\ninject-inv-suc (left x) = refl\ninject-inv-suc (right x) = refl\n\ninverse-1 : (a : \u2115) \u2192 inject-inv (inject a) \u2261 a\ninverse-1 zero = refl\ninverse-1 (suc zero) = refl\ninverse-1 (suc (suc x)) rewrite inject-inv-suc (inject x) | inverse-1 x = refl\n\ninverse-2 : (a : \u2115+\u2115) \u2192 inject (inject-inv a) \u2261 a\ninverse-2 (left zero) = refl\ninverse-2 (left (suc x)) rewrite inverse-2 (left x) = refl\ninverse-2 (right zero) = refl\ninverse-2 (right (suc x)) rewrite inverse-2 (right x) = refl\n\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection \n  inject \n  inject-inv \n  inverse-1 \n  inverse-2\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":244,"user_id":60,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Function using (id; _\u2218_)\nopen import Iso\nopen _\u21d4_\n\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection id id (\u03bb _ \u2192 refl) (\u03bb _ \u2192 refl)\n\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans {A} {B} {C} (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = Bijection A\u2192C C\u2192A A\u2192C\u2192A C\u2192A\u2192C\n  where A\u2192C : A \u2192 C\n        A\u2192C = B\u2192C \u2218 A\u2192B\n        C\u2192A : C \u2192 A\n        C\u2192A = B\u2192A \u2218 C\u2192B\n        A\u2192C\u2192A : (a : A) \u2192 C\u2192A (A\u2192C a) \u2261 a\n        A\u2192C\u2192A a = trans (cong B\u2192A (B\u2192C\u2192B (A\u2192B a))) (A\u2192B\u2192A a)\n        C\u2192A\u2192C : (c : C) \u2192 A\u2192C (C\u2192A c) \u2261 c\n        C\u2192A\u2192C c = trans (cong B\u2192C (B\u2192A\u2192B (C\u2192B c))) (C\u2192B\u2192C c)\n\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt {A} {B} A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B'\n  where B\u2192A\u2192B' : (b : B) \u2192 A\u2192B (B\u2192A b) \u2261 b\n        B\u2192A\u2192B' b = B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b))\n\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection \u2115\u2192\u2115+1 \u2115+1\u2192\u2115 \u2115\u2192\u2115+1\u2192\u2115 \u2115+1\u2192\u2115\u2192\u2115+1\n  where \u2115\u2192\u2115+1 : \u2115 \u2192 \u2115+1\n        \u2115\u2192\u2115+1 zero    = null\n        \u2115\u2192\u2115+1 (suc n) = nat n\n        \u2115+1\u2192\u2115 : \u2115+1 \u2192 \u2115\n        \u2115+1\u2192\u2115 null    = zero\n        \u2115+1\u2192\u2115 (nat n) = (suc n)\n        \u2115\u2192\u2115+1\u2192\u2115 : (n : \u2115) \u2192 \u2115+1\u2192\u2115 (\u2115\u2192\u2115+1 n) \u2261 n\n        \u2115\u2192\u2115+1\u2192\u2115 zero    = refl\n        \u2115\u2192\u2115+1\u2192\u2115 (suc n) = refl\n        \u2115+1\u2192\u2115\u2192\u2115+1 : (n : \u2115+1) \u2192 \u2115\u2192\u2115+1 (\u2115+1\u2192\u2115 n) \u2261 n\n        \u2115+1\u2192\u2115\u2192\u2115+1 null    = refl\n        \u2115+1\u2192\u2115\u2192\u2115+1 (nat n) = refl\n\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection \u2115\u2192\u2115+\u2115 \u2115+\u2115\u2192\u2115 \u2115\u2192\u2115+\u2115\u2192\u2115 \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115\n  where double\u2115 : \u2115 \u2192 \u2115\n        double\u2115 zero    = zero\n        double\u2115 (suc n) = suc (suc (double\u2115 n))\n        succ\u2115+\u2115 : \u2115+\u2115 \u2192 \u2115+\u2115\n        succ\u2115+\u2115 (left n)  = right n\n        succ\u2115+\u2115 (right n) = left (suc n)\n        \u2115\u2192\u2115+\u2115 : \u2115 \u2192 \u2115+\u2115\n        \u2115\u2192\u2115+\u2115 zero    = left zero\n        \u2115\u2192\u2115+\u2115 (suc n) = succ\u2115+\u2115 (\u2115\u2192\u2115+\u2115 n)\n        \u2115+\u2115\u2192\u2115 : \u2115+\u2115 \u2192 \u2115\n        \u2115+\u2115\u2192\u2115 (left n)  = double\u2115 n\n        \u2115+\u2115\u2192\u2115 (right n) = suc (double\u2115 n)\n        lemma0 : (n : \u2115+\u2115) \u2192 \u2115+\u2115\u2192\u2115 (succ\u2115+\u2115 n) \u2261 suc (\u2115+\u2115\u2192\u2115 n)\n        lemma0 (left n)  = refl\n        lemma0 (right n) = refl\n        lemma1 : (n : \u2115) \u2192 \u2115\u2192\u2115+\u2115 (double\u2115 n) \u2261 left n\n        lemma1 zero    = refl\n        lemma1 (suc n) = cong succ\u2115+\u2115 (cong succ\u2115+\u2115 (lemma1 n))\n        \u2115\u2192\u2115+\u2115\u2192\u2115 : (n : \u2115) \u2192 \u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 n) \u2261 n\n        \u2115\u2192\u2115+\u2115\u2192\u2115 zero    = refl\n        \u2115\u2192\u2115+\u2115\u2192\u2115 (suc n) = trans (lemma0 (\u2115\u2192\u2115+\u2115 n)) (cong suc (\u2115\u2192\u2115+\u2115\u2192\u2115 n))\n        \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 : (n : \u2115+\u2115) \u2192 \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 n) \u2261 n\n        \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left n)  = lemma1 n\n        \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right n) = cong succ\u2115+\u2115 (lemma1 n)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":245,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\nopen \u2261-Reasoning\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection (\u03bb a \u2192 a) (\u03bb a \u2192 a) (\u03bb a \u2192 refl) (\u03bb b \u2192 refl)\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) =\n  Bijection\n    (\u03bb a \u2192 B\u2192C (A\u2192B a))\n    (\u03bb c \u2192 B\u2192A (C\u2192B c))\n    (\u03bb a \u2192 begin\n      B\u2192A (C\u2192B (B\u2192C (A\u2192B a))) \u2261\u27e8 cong B\u2192A (B\u2192C\u2192B (A\u2192B a)) \u27e9\n      B\u2192A (A\u2192B a) \u2261\u27e8 A\u2192B\u2192A a \u27e9\n      a \u220e)\n    \u03bb c \u2192 begin\n      B\u2192C (A\u2192B (B\u2192A (C\u2192B c))) \u2261\u27e8 cong B\u2192C (B\u2192A\u2192B (C\u2192B c)) \u27e9\n      B\u2192C (C\u2192B c) \u2261\u27e8 C\u2192B\u2192C c \u27e9\n      c \u220e\n    \n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection\n  A\u2192B\n  B\u2192A\n  A\u2192B\u2192A\n  (\u03bb b \u2192 B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b)))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection\n  (\u03bb { zero \u2192 null\n     ; (suc n) \u2192 nat n })\n  (\u03bb { null \u2192 zero\n     ; (nat x) \u2192 suc x})\n  (\u03bb { zero \u2192 refl\n     ; (suc n) \u2192 refl})\n  (\u03bb { null \u2192 refl\n    ; (nat x) \u2192 refl})\n\nopen import Data.Nat.Properties using (+-suc)\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection f g p q\n  where\n    mapsuc : \u2115+\u2115 \u2192 \u2115+\u2115\n    mapsuc (left n) = left (suc n)\n    mapsuc (right n) = right (suc n)\n\n    f : \u2115 \u2192 \u2115+\u2115\n    f zero = left zero\n    f (suc zero) = right zero\n    f (suc (suc n)) = mapsuc (f n)\n\n    g : \u2115+\u2115 \u2192 \u2115\n    g (left x) = x + x\n    g (right x) = suc (x + x)\n\n    p : \u2200 n \u2192 g (f n) \u2261 n\n    p zero = refl\n    p (suc zero) = refl\n    p (suc (suc n)) with f n | p n\n    ... | left n | refl = cong suc (+-suc n n)\n    ... | right n | refl = cong (\u03bb x \u2192 suc (suc x)) (+-suc n n)\n\n    q : \u2200 n \u2192 f (g n) \u2261 n\n    q (left zero) = refl\n    q (left (suc x)) = begin\n      f (suc (x + suc x)) \u2261\u27e8 cong (\u03bb n \u2192 f (suc n)) (+-suc x x) \u27e9\n      f (suc (suc (x + x))) \u2261\u27e8\u27e9\n      mapsuc (f (x + x)) \u2261\u27e8 cong mapsuc (q (left x)) \u27e9\n      mapsuc (left x) \u2261\u27e8\u27e9\n      left (suc x) \u220e\n    q (right zero) = refl\n    q (right (suc zero)) = refl\n    q (right (suc (suc x))) = begin\n      mapsuc (f (suc (x + suc (suc x)))) \u2261\u27e8 cong (\u03bb z \u2192 mapsuc (f (suc z))) (+-suc x (suc x)) \u27e9\n      mapsuc (f (suc (suc (x + suc x)))) \u2261\u27e8\u27e9\n      mapsuc (mapsuc (f (x + suc x))) \u2261\u27e8 cong (\u03bb z \u2192 mapsuc (mapsuc (f z))) (+-suc x x) \u27e9\n      mapsuc (mapsuc (f (suc (x + x)))) \u2261\u27e8 (cong (\u03bb z \u2192 mapsuc (mapsuc z))) (q (right x)) \u27e9\n      right (suc (suc x)) \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":246,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Data.Nat\nopen import Data.Empty\nopen import Data.Nat.Properties\nopen import Function using (id; _\u2218_)\n\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n\ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection id id (\u03bb _ \u2192 refl) (\u03bb _ \u2192 refl)\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = Bijection (B\u2192C \u2218 A\u2192B) (B\u2192A \u2218 C\u2192B) (\u03bb a \u2192 begin\n  B\u2192A (C\u2192B (B\u2192C (A\u2192B a)))   \u2261\u27e8 cong B\u2192A (B\u2192C\u2192B (A\u2192B a)) \u27e9\n  B\u2192A (A\u2192B a)               \u2261\u27e8 A\u2192B\u2192A a \u27e9\n  a                         \u220e\n  ) (\u03bb c \u2192 begin\n  B\u2192C (A\u2192B (B\u2192A (C\u2192B c)))   \u2261\u27e8 cong B\u2192C (B\u2192A\u2192B (C\u2192B c)) \u27e9\n  B\u2192C (C\u2192B c)               \u2261\u27e8 C\u2192B\u2192C c \u27e9\n  c                         \u220e\n  )\n\n-- task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A \u03bb b \u2192 B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u2192\u2115+1 : \u2115 \u2192 \u2115+1\n\u2115\u2192\u2115+1 zero = null\n\u2115\u2192\u2115+1 (suc n) = nat n\n\n\u2115+1\u2192\u2115 : \u2115+1 \u2192 \u2115\n\u2115+1\u2192\u2115 null = zero\n\u2115+1\u2192\u2115 (nat n) = suc n\n\n\u2115\u2192\u2115+1\u2192\u2115 : (n : \u2115) \u2192 \u2115+1\u2192\u2115 (\u2115\u2192\u2115+1 n) \u2261 n\n\u2115\u2192\u2115+1\u2192\u2115 zero = refl\n\u2115\u2192\u2115+1\u2192\u2115 (suc n) = refl\n\n\u2115+1\u2192\u2115\u2192\u2115+1 : (n : \u2115+1) \u2192 \u2115\u2192\u2115+1 (\u2115+1\u2192\u2115 n) \u2261 n\n\u2115+1\u2192\u2115\u2192\u2115+1 null = refl\n\u2115+1\u2192\u2115\u2192\u2115+1 (nat x) = refl\n\n\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection \u2115\u2192\u2115+1 \u2115+1\u2192\u2115 \u2115\u2192\u2115+1\u2192\u2115 \u2115+1\u2192\u2115\u2192\u2115+1\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n\nsuc\u2115+\u2115 : \u2115+\u2115 \u2192 \u2115+\u2115\nsuc\u2115+\u2115 (left x) = right x\nsuc\u2115+\u2115 (right x) = left (suc x)\n\n\u2115\u2192\u2115+\u2115 : \u2115 \u2192 \u2115+\u2115\n\u2115\u2192\u2115+\u2115 zero = left zero\n\u2115\u2192\u2115+\u2115 (suc n) = suc\u2115+\u2115 (\u2115\u2192\u2115+\u2115 n)\n\n\u2115+\u2115\u2192\u2115 : \u2115+\u2115 \u2192 \u2115\n\u2115+\u2115\u2192\u2115 (left x) = x * 2\n\u2115+\u2115\u2192\u2115 (right x) = 1 + x * 2\n\nmoveSuc : (n : \u2115+\u2115) \u2192 \u2115+\u2115\u2192\u2115 (suc\u2115+\u2115 n) \u2261 suc (\u2115+\u2115\u2192\u2115 n)\nmoveSuc (left x) = refl\nmoveSuc (right x) = refl\n\n\u2115\u2192\u2115+\u2115\u2192\u2115 : (n : \u2115) \u2192 \u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 n) \u2261 n\n\u2115\u2192\u2115+\u2115\u2192\u2115 zero = refl\n\u2115\u2192\u2115+\u2115\u2192\u2115 (suc n) = begin\n  \u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 (suc n))      \u2261\u27e8\u27e9\n  \u2115+\u2115\u2192\u2115 (suc\u2115+\u2115 (\u2115\u2192\u2115+\u2115 n))   \u2261\u27e8 moveSuc (\u2115\u2192\u2115+\u2115 n) \u27e9\n  suc (\u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 n))      \u2261\u27e8 cong suc (\u2115\u2192\u2115+\u2115\u2192\u2115 n) \u27e9\n  suc n                      \u220e\n\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 : (n : \u2115+\u2115) \u2192 \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 n) \u2261 n\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left zero) = refl\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left (suc x)) = begin\n  \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 (left (suc x)))    \u2261\u27e8\u27e9\n  \u2115\u2192\u2115+\u2115 (suc x * 2)               \u2261\u27e8 cong \u2115\u2192\u2115+\u2115 (*-distrib\u02b3-+ 2 1 x) \u27e9\n  \u2115\u2192\u2115+\u2115 (2 + x * 2)               \u2261\u27e8\u27e9\n  suc\u2115+\u2115 (suc\u2115+\u2115 (\u2115\u2192\u2115+\u2115 (x * 2))) \u2261\u27e8 cong (\u03bb y \u2192 suc\u2115+\u2115 (suc\u2115+\u2115 y)) (\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left x)) \u27e9\n  suc\u2115+\u2115 (suc\u2115+\u2115 (left x))        \u2261\u27e8\u27e9\n  left (suc x)                    \u220e\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right zero) = refl\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right (suc x)) = begin\n  \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 (right (suc x)))       \u2261\u27e8\u27e9\n  \u2115\u2192\u2115+\u2115 (1 + suc x * 2)                \u2261\u27e8 cong (\u03bb y \u2192 \u2115\u2192\u2115+\u2115 (1 + y)) (*-distrib\u02b3-+ 2 1 x) \u27e9\n  \u2115\u2192\u2115+\u2115 (1 + (2 + x * 2))              \u2261\u27e8\u27e9\n  suc\u2115+\u2115 (suc\u2115+\u2115 (\u2115\u2192\u2115+\u2115 (1 + x * 2)))  \u2261\u27e8 cong (\u03bb y \u2192 suc\u2115+\u2115 (suc\u2115+\u2115 y)) (\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right x)) \u27e9\n  suc\u2115+\u2115 (suc\u2115+\u2115 (right x))            \u2261\u27e8\u27e9\n  right (suc x)                        \u220e\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection \u2115\u2192\u2115+\u2115 \u2115+\u2115\u2192\u2115 \u2115\u2192\u2115+\u2115\u2192\u2115 \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":247,"user_id":429,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\nopen \u2261-Reasoning\nopen import Function using (id; _\u2218_)\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = record { A\u2192B = id; B\u2192A = id; A\u2192B\u2192A = \u03bb _ \u2192 refl; B\u2192A\u2192B = \u03bb _ \u2192 refl }\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = record\n  { A\u2192B = B\u2192C \u2218 A\u2192B\n  ; B\u2192A = B\u2192A \u2218 C\u2192B\n  ; A\u2192B\u2192A = \u03bb a \u2192 begin\n      B\u2192A (C\u2192B (B\u2192C (A\u2192B a)))\n        \u2261\u27e8 cong B\u2192A (B\u2192C\u2192B (A\u2192B a)) \u27e9\n      B\u2192A (A\u2192B a)\n        \u2261\u27e8 A\u2192B\u2192A a \u27e9\n      a \u220e\n  ; B\u2192A\u2192B = \u03bb c \u2192 begin\n      B\u2192C (A\u2192B (B\u2192A (C\u2192B c)))\n        \u2261\u27e8 cong B\u2192C (B\u2192A\u2192B (C\u2192B c)) \u27e9\n      B\u2192C (C\u2192B c)\n        \u2261\u27e8 C\u2192B\u2192C c \u27e9\n      c \u220e\n  }\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = record\n  { A\u2192B = A\u2192B\n  ; B\u2192A = B\u2192A\n  ; A\u2192B\u2192A = A\u2192B\u2192A\n  ; B\u2192A\u2192B = \u03bb b \u2192 B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b))\n  }\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n{- Preloaded code\ndata \u2115+1 : Set where\n  null : \u2115+1\n  nat : \u2115 \u2192 \u2115+1\n-}\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = record\n  { A\u2192B = \u03bb{ 0 \u2192 null ; (suc n) \u2192 nat n }\n  ; B\u2192A = \u03bb{ null \u2192 0 ; (nat n) \u2192 suc n }\n  ; A\u2192B\u2192A = \u03bb{ 0 \u2192 refl ; (suc _) \u2192 refl }\n  ; B\u2192A\u2192B = \u03bb{ null \u2192 refl ; (nat n) \u2192 refl }\n  }\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n{- Preloaded code\ndata \u2115+\u2115 : Set where\n  left : \u2115 \u2192 \u2115+\u2115\n  right : \u2115 \u2192 \u2115+\u2115\n-}\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = record\n  { A\u2192B = evenOdd\n  ; B\u2192A = unEvenOdd\n  ; A\u2192B\u2192A = fwdImp\n  ; B\u2192A\u2192B = revImp\n  }\n    where\n    \u2115+\u2115-suc : \u2115+\u2115 \u2192 \u2115+\u2115\n    \u2115+\u2115-suc (left n) = left (suc n)\n    \u2115+\u2115-suc (right n) = right (suc n)\n\n    evenOdd : \u2115 \u2192 \u2115+\u2115\n    evenOdd 0 = left 0\n    evenOdd (suc 0) = right 0\n    evenOdd (suc (suc n)) = \u2115+\u2115-suc (evenOdd n)\n\n    unEvenOdd : \u2115+\u2115 \u2192 \u2115\n    unEvenOdd (left 0) = 0\n    unEvenOdd (right 0) = 1\n    unEvenOdd (left (suc n)) = suc (suc (unEvenOdd (left n)))\n    unEvenOdd (right (suc n)) = suc (suc (unEvenOdd (right n)))\n\n    suc-unEvenOdd : (q : \u2115+\u2115) \u2192 unEvenOdd (\u2115+\u2115-suc q) \u2261 suc (suc (unEvenOdd q))\n    suc-unEvenOdd (left n) = refl\n    suc-unEvenOdd (right n) = refl\n\n    fwdImp : (n : \u2115) \u2192 unEvenOdd (evenOdd n) \u2261 n\n    fwdImp 0 = refl\n    fwdImp (suc 0) = refl\n    fwdImp (suc (suc n)) = begin\n      unEvenOdd (evenOdd (suc (suc n)))\n        \u2261\u27e8\u27e9\n      unEvenOdd (\u2115+\u2115-suc (evenOdd n))\n        \u2261\u27e8 suc-unEvenOdd (evenOdd n) \u27e9\n      suc (suc (unEvenOdd (evenOdd n)))\n        \u2261\u27e8 cong (suc \u2218 suc) (fwdImp n) \u27e9\n      suc (suc n) \u220e\n\n    suc-evenOdd : (n : \u2115) \u2192 evenOdd (suc (suc n)) \u2261 \u2115+\u2115-suc (evenOdd n)\n    suc-evenOdd 0 = refl\n    suc-evenOdd (suc n) = refl\n\n    revImp : (q : \u2115+\u2115) \u2192 evenOdd (unEvenOdd q) \u2261 q\n    revImp (left 0) = refl\n    revImp (right 0) = refl\n    revImp (left (suc n)) = begin\n      evenOdd (unEvenOdd (left (suc n)))\n        \u2261\u27e8\u27e9\n      evenOdd (suc (suc (unEvenOdd (left n))))\n        \u2261\u27e8 suc-evenOdd (unEvenOdd (left n)) \u27e9\n      \u2115+\u2115-suc (evenOdd (unEvenOdd (left n)))\n        \u2261\u27e8 cong \u2115+\u2115-suc (revImp (left n)) \u27e9\n      \u2115+\u2115-suc (left n)\n        \u2261\u27e8\u27e9\n      left (suc n) \u220e\n    revImp (right (suc n)) = begin\n      evenOdd (unEvenOdd (right (suc n)))\n        \u2261\u27e8\u27e9\n      evenOdd (suc (suc (unEvenOdd (right n))))\n        \u2261\u27e8 suc-evenOdd (unEvenOdd (right n)) \u27e9\n      \u2115+\u2115-suc (evenOdd (unEvenOdd (right n)))\n        \u2261\u27e8 cong \u2115+\u2115-suc (revImp (right n)) \u27e9\n      \u2115+\u2115-suc (right n)\n        \u2261\u27e8\u27e9\n      right (suc n) \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":248,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Relation.Nullary.Negation \nopen import Data.Product renaming (_\u00d7_ to _\u2227_ ; proj\u2081 to fst ; proj\u2082 to snd)\nopen import Data.Sum renaming (_\u228e_ to _\u2228_ ; inj\u2081 to orLeft ; inj\u2082 to orRight)\nimport Data.List \nimport Data.List.Properties\n\n0\u22621+n : \u2200 {n} \u2192 0 \u2262 suc n\n0\u22621+n ()\n\n1+n\u22620 : \u2200 {n} \u2192 suc n \u2262 0\n1+n\u22620 ()\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection (\u03bb x \u2192 x) (\u03bb x \u2192 x) (\u03bb a \u2192 refl) (\u03bb b \u2192 refl)\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans {A} {B} {C} (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) \n    = Bijection (\u03bb z \u2192 B\u2192C (A\u2192B z)) (\u03bb z \u2192 B\u2192A (C\u2192B z)) helper1 helper2\n        where   helper1 : (a : A) \u2192 B\u2192A (C\u2192B (B\u2192C (A\u2192B a))) \u2261 a\n                helper1 a rewrite B\u2192C\u2192B (A\u2192B a) = A\u2192B\u2192A a\n                helper2 : (b : C) \u2192 B\u2192C (A\u2192B (B\u2192A (C\u2192B b))) \u2261 b\n                helper2 b rewrite B\u2192A\u2192B (C\u2192B b) = C\u2192B\u2192C b\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt {A} {B} A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A helper\n    where   A\u2192B-inj : (a1 a2 : A) \u2192 A\u2192B a1 \u2261 A\u2192B a2 \u2192 a1 \u2261 a2\n            A\u2192B-inj a1 a2 eq = begin \n                a1 \u2261\u27e8 sym (A\u2192B\u2192A a1) \u27e9\n                B\u2192A (A\u2192B a1) \u2261\u27e8 cong B\u2192A eq \u27e9\n                B\u2192A (A\u2192B a2) \u2261\u27e8 (A\u2192B\u2192A a2) \u27e9\n                a2     \u220e where open \u2261-Reasoning\n            helper : (b : B) \u2192 A\u2192B (B\u2192A b) \u2261 b\n            helper b = B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b)) \n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n\n\u2115+1\u2192\u2115 : \u2115+1 \u2192 \u2115\n\u2115+1\u2192\u2115 null = zero\n\u2115+1\u2192\u2115 (nat x) = suc x\n\n\u2115\u2192\u2115+1 : \u2115 \u2192 \u2115+1\n\u2115\u2192\u2115+1 zero = null\n\u2115\u2192\u2115+1 (suc n) = nat n\n\n\u2115\u2192\u2115+1\u2192\u2115 : (n : \u2115) \u2192 \u2115+1\u2192\u2115 (\u2115\u2192\u2115+1 n) \u2261 n\n\u2115\u2192\u2115+1\u2192\u2115 zero = refl\n\u2115\u2192\u2115+1\u2192\u2115 (suc n) = refl\n\n\u2115+1\u2192\u2115\u2192\u2115+1 : (n : \u2115+1) \u2192 \u2115\u2192\u2115+1 (\u2115+1\u2192\u2115 n) \u2261 n\n\u2115+1\u2192\u2115\u2192\u2115+1 null = refl\n\u2115+1\u2192\u2115\u2192\u2115+1 (nat x) = refl\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection \u2115\u2192\u2115+1 \u2115+1\u2192\u2115 \u2115\u2192\u2115+1\u2192\u2115 \u2115+1\u2192\u2115\u2192\u2115+1\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n\n\u2115+\u2115\u2192\u2115 : \u2115+\u2115 \u2192 \u2115\n\u2115+\u2115\u2192\u2115 (left x) = x * 2\n\u2115+\u2115\u2192\u2115 (right x) = x * 2 + 1\n\ndata Even (n : \u2115) : Set where\n    even : (x : \u2115) \u2192 x * 2 \u2261 n \u2192 Even n \n\npredEven : {n : \u2115} \u2192 Even (suc (suc n)) \u2192 Even n\npredEven {n} (even (suc x) p) = even x (suc-injective (suc-injective p))\n\nsucEven : {n : \u2115} \u2192 Even n \u2192 Even (suc (suc n))\nsucEven {n} (even x p) = even (suc x) (cong suc (cong suc p))\n\nsuc\u00acEven : {n : \u2115} \u2192 \u00ac Even n \u2192 \u00ac Even (suc (suc n))\nsuc\u00acEven {n} \u00acevenN evenSSN = contradiction (predEven evenSSN) \u00acevenN\n\npred\u00acEven : {n : \u2115} \u2192 \u00ac Even (suc (suc n)) \u2192 \u00ac Even n\npred\u00acEven {n} p p2 = contradiction (sucEven p2) p\n\nEven0 : Even 0\nEven0 = even zero refl\n\n\u00acEven1 : \u00ac Even 1\n\u00acEven1 (even zero p)  = contradiction p 0\u22621+n\n\u00acEven1 (even (suc x) p)  = contradiction (suc-injective p) 1+n\u22620\n\nevenStep : {n : \u2115} \u2192 Even n \u2192 \u00ac Even (suc n)\nevenStep {zero} p = \u00acEven1\nevenStep {suc zero} p = contradiction p \u00acEven1\nevenStep {suc (suc n)} p = suc\u00acEven (evenStep (predEven p))\n\n\u00acevenStep : {n : \u2115} \u2192 \u00ac Even n \u2192 Even (suc n)\n\u00acevenStep {zero} p = contradiction Even0 p\n\u00acevenStep {suc zero} p = sucEven Even0\n\u00acevenStep {suc (suc n)} p = sucEven (\u00acevenStep (pred\u00acEven p))\n\n\nevenDec : (n : \u2115) \u2192 Dec (Even n)\nevenDec zero = yes (even 0 refl)\nevenDec (suc zero) = no \u00acEven1\nevenDec (suc (suc n)) with evenDec n\nevenDec (suc (suc n)) | yes evenN = yes (sucEven evenN)\nevenDec (suc (suc n)) | no \u00acevenN = no (suc\u00acEven \u00acevenN)\n\n\u2115\u2192\u2115+\u2115 : \u2115 \u2192 \u2115+\u2115\n\u2115\u2192\u2115+\u2115 n with evenDec n\n\u2115\u2192\u2115+\u2115 n | yes evenN = left (\u230a n \/2\u230b)\n\u2115\u2192\u2115+\u2115 zero | no \u00acevenN = contradiction Even0 \u00acevenN\n\u2115\u2192\u2115+\u2115 (suc n) | no \u00acevenN = right (\u230a n \/2\u230b)\n\n\u230an*2\/2\u230b\u2261n : {n : \u2115} \u2192 \u230a n * 2 \/2\u230b \u2261 n\n\u230an*2\/2\u230b\u2261n {zero} = refl\n\u230an*2\/2\u230b\u2261n {suc zero} = refl\n\u230an*2\/2\u230b\u2261n {suc (suc n)} = cong suc (cong suc (\u230an*2\/2\u230b\u2261n {n})) \n\n\u230an\/2\u230b*2\u2261n : {n : \u2115} \u2192 Even n \u2192 \u230a n \/2\u230b * 2 \u2261 n\n\u230an\/2\u230b*2\u2261n {n} (even x p) = begin \n                \u230a n \/2\u230b * 2 \u2261\u27e8 cong (\u03bb z \u2192 \u230a z \/2\u230b * 2) (sym p) \u27e9\n                \u230a (x * 2) \/2\u230b * 2 \u2261\u27e8 cong (_* 2) (\u230an*2\/2\u230b\u2261n {x}) \u27e9\n                x * 2 \u2261\u27e8 p \u27e9\n                n       \u220e where open \u2261-Reasoning\n\n\u2115\u2192\u2115+\u2115\u2192\u2115 : (n : \u2115) \u2192 \u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 n) \u2261 n\n\u2115\u2192\u2115+\u2115\u2192\u2115 n with evenDec n\n\u2115\u2192\u2115+\u2115\u2192\u2115 n | yes evenN = \u230an\/2\u230b*2\u2261n evenN\n\u2115\u2192\u2115+\u2115\u2192\u2115 zero | no \u00acevenN = contradiction Even0 \u00acevenN\n\u2115\u2192\u2115+\u2115\u2192\u2115 (suc n) | no \u00acevenN = begin \n                \u230a n \/2\u230b * 2 + 1 \u2261\u27e8 +-comm (\u230a n \/2\u230b * 2) 1 \u27e9\n                suc (\u230a n \/2\u230b * 2) \u2261\u27e8 suc-injective (\u230an\/2\u230b*2\u2261n (\u00acevenStep \u00acevenN)) \u27e9\n                suc n       \u220e where open \u2261-Reasoning\n\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 : (n : \u2115+\u2115) \u2192 \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 n) \u2261 n\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left x) with evenDec (x * 2)\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left x) | yes evenX2 = cong left (\u230an*2\/2\u230b\u2261n {x})\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left x) | no \u00acevenX2 = contradiction (even x refl) \u00acevenX2\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right x) with evenDec (x * 2 + 1)\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right x) | yes evenX21 = contradiction evenX21 (helper (evenStep {x * 2} (even x refl)))\n    where   helper : \u00ac Even (suc (x * 2)) \u2192 \u00ac Even (x * 2 + 1)\n            helper \u00acesx ex21 = contradiction (subst (Even) (+-comm (x * 2) 1) ex21) \u00acesx\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right zero) | no \u00acevenX21 = refl\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right (suc x)) | no \u00acevenX21 = begin\n    right \u230a suc (x * 2 + 1) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 right \u230a suc z \/2\u230b) (+-comm (x * 2) 1) \u27e9\n    right \u230a suc (suc (x * 2)) \/2\u230b \u2261\u27e8 cong (\u03bb z \u2192 right (suc z)) (\u230an*2\/2\u230b\u2261n {x}) \u27e9\n    right (suc x)       \u220e where open \u2261-Reasoning\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection \u2115\u2192\u2115+\u2115 \u2115+\u2115\u2192\u2115 \u2115\u2192\u2115+\u2115\u2192\u2115 \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 ","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":249,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\nA\u2192B \u21d4-refl = \u03bb x \u2192 x\nB\u2192A \u21d4-refl = \u03bb x \u2192 x\nA\u2192B\u2192A \u21d4-refl = \u03bb a \u2192 refl\nB\u2192A\u2192B \u21d4-refl = \u03bb b \u2192 refl\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = \n    Bijection (\u03bb z \u2192 B\u2192C (A\u2192B z)) (\u03bb z \u2192 B\u2192A (C\u2192B z)) \n    (\u03bb a \u2192 trans (cong B\u2192A (B\u2192C\u2192B (A\u2192B a))) (A\u2192B\u2192A a)) \n    \u03bb c \u2192 trans (cong B\u2192C (B\u2192A\u2192B (C\u2192B c))) (C\u2192B\u2192C c)\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A \n    (\u03bb b \u2192 B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b)))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection (\u03bb {zero \u2192 null\n                    ; (suc x) \u2192 nat x}) \n                    (\u03bb {null \u2192 zero ;\n                     (nat n) \u2192 suc n}) \n                     (\u03bb {zero \u2192 refl ;\n                     (suc x) \u2192 refl}) \n                     (\u03bb {null \u2192 refl ;\n                     (nat n) \u2192 refl}) \n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\ng : \u2115+\u2115 \u2192 \u2115+\u2115\ng (left x) = left (suc x)\ng (right x) = right (suc x)\n\nf : \u2115 \u2192 \u2115+\u2115\nf 0 = left 0\nf 1 = right 0 \nf (suc (suc n)) = g (f n)\n\nh : \u2115+\u2115 \u2192 \u2115\nh (left zero) = 0\nh (left (suc x)) = suc (suc (h (left x)))\nh (right zero) = 1\nh (right (suc x)) = suc (suc (h (right x)))\n\nl0 : \u2200 x \u2192 h (g x) \u2261 suc (suc (h x))\nl0 (left zero) = refl\nl0 (left (suc n)) = cong (\u03bb m \u2192 suc (suc m)) (l0 (left n))\nl0 (right zero) = refl\nl0 (right (suc n)) = cong (\u03bb m \u2192 suc (suc m)) (l0 (right n))\n\nl1 : \u2200 n \u2192 h (f n) \u2261 n\nl1 zero = refl\nl1 (suc zero) = refl\nl1 (suc (suc n)) = trans (l0 _) (cong (\u03bb m \u2192 suc (suc m)) (l1 n))\n\nl2 : \u2200 x \u2192 f (h x) \u2261 x\nl2 (left zero) = refl\nl2 (left (suc n)) = cong g (l2 (left n))\nl2 (right zero) = refl\nl2 (right (suc n)) = cong g (l2 (right n))\n\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection f h l1 l2","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":250,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Function\n\nopen import Iso\nopen _\u21d4_\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection id id (\u03bb x \u2192 refl) (\u03bb x \u2192 refl)\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = Bijection A\u2192C C\u2192A A\u2192C\u2192A C\u2192A\u2192C\n  where\n  \n  A\u2192C = B\u2192C \u2218 A\u2192B\n  \n  C\u2192A = B\u2192A \u2218 C\u2192B\n  \n  A\u2192C\u2192A : \u2200 a \u2192 C\u2192A (A\u2192C a) \u2261 a\n  A\u2192C\u2192A a rewrite B\u2192C\u2192B (A\u2192B a) | A\u2192B\u2192A a = refl\n  \n  C\u2192A\u2192C : \u2200 c \u2192 A\u2192C (C\u2192A c) \u2261 c\n  C\u2192A\u2192C c rewrite (B\u2192A\u2192B) (C\u2192B c) | C\u2192B\u2192C c = refl\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B'\n  where\n  B\u2192A\u2192B' : \u2200 b \u2192 A\u2192B (B\u2192A b) \u2261 b\n  B\u2192A\u2192B' b = B\u2192A-inj (A\u2192B (B\u2192A b)) b (A\u2192B\u2192A (B\u2192A b))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n{- Preloaded code\ndata \u2115+1 : Set where\n  null : \u2115+1\n  nat : \u2115 \u2192 \u2115+1\n-}\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u2192\u2115+1 : \u2115 \u2192 \u2115+1\n\u2115\u2192\u2115+1 zero    = null\n\u2115\u2192\u2115+1 (suc n) = nat n\n\n\u2115+1\u2192\u2115 : \u2115+1 \u2192 \u2115\n\u2115+1\u2192\u2115 null    = zero\n\u2115+1\u2192\u2115 (nat n) = suc n\n\n\u2115\u2192\u2115+1\u2192\u2115 : \u2200 n \u2192 \u2115+1\u2192\u2115 (\u2115\u2192\u2115+1 n) \u2261 n\n\u2115\u2192\u2115+1\u2192\u2115 zero    = refl\n\u2115\u2192\u2115+1\u2192\u2115 (suc n) = refl\n\n\u2115+1\u2192\u2115\u2192\u2115+1 : \u2200 n \u2192 \u2115\u2192\u2115+1 (\u2115+1\u2192\u2115 n) \u2261 n\n\u2115+1\u2192\u2115\u2192\u2115+1 null    = refl\n\u2115+1\u2192\u2115\u2192\u2115+1 (nat n) = refl\n\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection \u2115\u2192\u2115+1 \u2115+1\u2192\u2115 \u2115\u2192\u2115+1\u2192\u2115 \u2115+1\u2192\u2115\u2192\u2115+1\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n{- Preloaded code\ndata \u2115+\u2115 : Set where\n  left : \u2115 \u2192 \u2115+\u2115\n  right : \u2115 \u2192 \u2115+\u2115\n-}\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\u2115\u2192\u2115+\u2115 : \u2115 \u2192 \u2115+\u2115\n\u2115\u2192\u2115+\u2115 zero       = left zero\n\u2115\u2192\u2115+\u2115 (suc zero) = right zero\n\u2115\u2192\u2115+\u2115 (suc (suc n)) with \u2115\u2192\u2115+\u2115 n\n... | left m  = left (suc m)\n... | right m = right (suc m)\n\n\u2115+\u2115\u2192\u2115 : \u2115+\u2115 \u2192 \u2115\n\u2115+\u2115\u2192\u2115 (left zero)     = zero\n\u2115+\u2115\u2192\u2115 (left (suc n))  = suc (suc (\u2115+\u2115\u2192\u2115 (left n)))\n\u2115+\u2115\u2192\u2115 (right zero)    = suc zero\n\u2115+\u2115\u2192\u2115 (right (suc n)) = suc (suc (\u2115+\u2115\u2192\u2115 (right n)))\n\n\u2115\u2192\u2115+\u2115\u2192\u2115 : \u2200 n \u2192 \u2115+\u2115\u2192\u2115 (\u2115\u2192\u2115+\u2115 n) \u2261 n\n\u2115\u2192\u2115+\u2115\u2192\u2115 zero       = refl\n\u2115\u2192\u2115+\u2115\u2192\u2115 (suc zero) = refl\n\u2115\u2192\u2115+\u2115\u2192\u2115 (suc (suc n)) with \u2115\u2192\u2115+\u2115 n | \u2115\u2192\u2115+\u2115\u2192\u2115 n\n... | left _  | refl = refl\n... | right _ | refl = refl\n\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 : \u2200 n \u2192 \u2115\u2192\u2115+\u2115 (\u2115+\u2115\u2192\u2115 n) \u2261 n\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left zero) = refl\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left (suc n)) rewrite \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (left n) = refl\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right zero) = refl\n\u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right (suc n)) rewrite \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115 (right n) = refl\n\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection \u2115\u2192\u2115+\u2115 \u2115+\u2115\u2192\u2115 \u2115\u2192\u2115+\u2115\u2192\u2115 \u2115+\u2115\u2192\u2115\u2192\u2115+\u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":251,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Relation.Binary.PropositionalEquality as Eq public\nopen import Data.Nat public\nopen import Iso\nopen Eq.\u2261-Reasoning\n\n-- Task 0 : Example of _\u21d4_ in finite sets\n-- Task 0-1. Find a bijection between Bool and Bit. (provided for you as an example)\ndata Bool : Set where\n  true false : Bool\n  \ndata Bit : Set where\n  0b 1b : Bit\n\nBool\u2192Bit : Bool \u2192 Bit\nBool\u2192Bit false = 0b\nBool\u2192Bit true = 1b\n\nBit\u2192Bool : Bit \u2192 Bool\nBit\u2192Bool 0b = false\nBit\u2192Bool 1b = true\n\nBool\u2192Bit\u2192Bool : \u2200 (b : Bool) \u2192 Bit\u2192Bool (Bool\u2192Bit b) \u2261 b\nBool\u2192Bit\u2192Bool true = refl\nBool\u2192Bit\u2192Bool false = refl\n\nBit\u2192Bool\u2192Bit : \u2200 (b : Bit) \u2192 Bool\u2192Bit (Bit\u2192Bool b) \u2261 b\nBit\u2192Bool\u2192Bit 0b = refl\nBit\u2192Bool\u2192Bit 1b = refl\n\nBool\u21d4Bit : Bool \u21d4 Bit\nBool\u21d4Bit = Bijection Bool\u2192Bit Bit\u2192Bool Bool\u2192Bit\u2192Bool Bit\u2192Bool\u2192Bit\n\n--------------------------------------------------------------------\n-- Task 1 : General properties of \u21d4\n-- Task 1-1. Prove that any set has the same cardinality as itself.\n\u21d4-refl : \u2200 {A : Set} \u2192 A \u21d4 A\n\u21d4-refl = Bijection (\u03bb x \u2192 x) (\u03bb x \u2192 x) (\u03bb a \u2192 refl) (\u03bb b \u2192 refl)\n\n-- Task 1-2. Prove that _\u21d4_ relation is symmetric.\n\u21d4-sym : \u2200 {A B : Set} \u2192 A \u21d4 B \u2192 B \u21d4 A\n\u21d4-sym (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) = (Bijection B\u2192A A\u2192B B\u2192A\u2192B A\u2192B\u2192A)\n\n-- Task 1-3. Prove that _\u21d4_ relation is transitive.\ncompose : \u2200 {A B C : Set} \u2192 (A \u2192 B) \u2192 (B \u2192 C) \u2192 (A \u2192 C)\ncompose f g x = g (f x)\n\n\u21d4-trans : \u2200 {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4-trans {A} {B} {C} (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C)\n    = Bijection A\u2192C C\u2192A r1 r2\n    where A\u2192C = compose A\u2192B B\u2192C\n          C\u2192A = compose C\u2192B B\u2192A\n          r1 : \u2200 (a : A) \u2192 C\u2192A (A\u2192C a) \u2261 a\n          r1 a rewrite B\u2192C\u2192B (A\u2192B a) | A\u2192B\u2192A a = refl\n          r2 : \u2200 (c : C) \u2192 A\u2192C (C\u2192A c) \u2261 c\n          r2 c rewrite B\u2192A\u2192B (C\u2192B c) | C\u2192B\u2192C c = refl\n\n-- Task 1-4. Prove the following statement:\n--   Given two functions A\u2192B and B\u2192A, if A\u2192B\u2192A is satisfied and B\u2192A is injective, A \u21d4 B.\nbijection-alt :\n  \u2200 {A B : Set} \u2192\n  (A\u2192B : A \u2192 B) \u2192\n  (B\u2192A : B \u2192 A) \u2192\n  (\u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a) \u2192\n  (\u2200 b b' \u2192 B\u2192A b \u2261 B\u2192A b' \u2192 b \u2261 b') \u2192\n  A \u21d4 B\nbijection-alt {A} {B} A\u2192B B\u2192A A\u2192B\u2192A B\u2192A-inj = Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B\n    where B\u2192A\u2192B : \u2200 (b : B) \u2192 A\u2192B (B\u2192A b) \u2261 b\n          B\u2192A\u2192B b = B\u2192A-inj (A\u2192B (B\u2192A b)) b (trans refl (A\u2192B\u2192A (B\u2192A b)))\n\n--------------------------------------------------------------------\n-- Task 2 : \u21d4-relations between \u2115 and various supersets of \u2115\n\n-- \u2115+1 : A set having one more element than \u2115.\n\n-- Task 2-1. Prove that \u2115 has the same cardinality as \u2115+1.\n\u2115\u21d4\u2115+1 : \u2115 \u21d4 \u2115+1\n\u2115\u21d4\u2115+1 = Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B\n    where A\u2192B : \u2115 \u2192 \u2115+1\n          A\u2192B 0 = null\n          A\u2192B (suc n) = nat n\n          B\u2192A : \u2115+1 \u2192 \u2115\n          B\u2192A null = 0\n          B\u2192A (nat n) = (suc n)\n          A\u2192B\u2192A : \u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a\n          A\u2192B\u2192A 0 = refl\n          A\u2192B\u2192A (suc n) = refl\n          B\u2192A\u2192B : \u2200 b \u2192 A\u2192B (B\u2192A b) \u2261 b\n          B\u2192A\u2192B null = refl\n          B\u2192A\u2192B (nat n) = refl\n\n-- \u2115+\u2115 : A set having size(\u2115) more elements than \u2115.\n\n-- Task 2-2. Prove that \u2115 has the same cardinality as \u2115+\u2115.\n\u2115\u21d4\u2115+\u2115 : \u2115 \u21d4 \u2115+\u2115\n\u2115\u21d4\u2115+\u2115 = Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B\n    where add : \u2115+\u2115 \u2192 \u2115+\u2115\n          add (left n) = left (suc n)\n          add (right n) = right (suc n)\n          A\u2192B : \u2115 \u2192 \u2115+\u2115\n          A\u2192B 0 = left 0\n          A\u2192B 1 = right 0\n          A\u2192B (suc (suc n)) = add (A\u2192B n)\n          B\u2192A : \u2115+\u2115 \u2192 \u2115\n          B\u2192A (left 0) = 0\n          B\u2192A (right 0) = 1\n          B\u2192A (left (suc n)) = suc (suc (B\u2192A (left n)))\n          B\u2192A (right (suc n)) = suc (suc (B\u2192A (right n)))\n          B\u2192A\u2192B : \u2200 b \u2192 A\u2192B (B\u2192A b) \u2261 b\n          B\u2192A\u2192B (left 0) = refl\n          B\u2192A\u2192B (right 0) = refl\n          B\u2192A\u2192B (left (suc k)) rewrite B\u2192A\u2192B (left k) = refl\n          B\u2192A\u2192B (right (suc k)) rewrite B\u2192A\u2192B (right k) = refl\n          strong : \u2200 nn \u2192 suc (suc (B\u2192A nn)) \u2261 B\u2192A (add nn)\n          strong (left 0) = refl\n          strong (right 0) = refl\n          strong (left (suc n)) = refl\n          strong (right (suc n)) = refl\n          A\u2192B\u2192A : \u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a\n          A\u2192B\u2192A 0 = refl\n          A\u2192B\u2192A 1 = refl\n          A\u2192B\u2192A (suc (suc n)) = trans (sym s) c\n              where s = strong (A\u2192B n)\n                    r = A\u2192B\u2192A n\n                    c = cong (\u03bb c \u2192 suc (suc c)) r\n\n\n\n\n\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5cc10885658d6f001281038a":[{"id":252,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Data.Nat.Properties\nopen import Preloaded\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\neval-expr-tail-correct-lemma : \u2200 n e \u2192 eval-expr-tail' e n \u2261 n + eval-expr e\neval-expr-tail-correct-lemma n (const x) = +-comm x n\neval-expr-tail-correct-lemma n (plus e\u2081 e\u2082) = begin\n  eval-expr-tail' e\u2082 (eval-expr-tail' e\u2081 n) \u2261\u27e8 cong (eval-expr-tail' e\u2082) (eval-expr-tail-correct-lemma n e\u2081) \u27e9\n  eval-expr-tail' e\u2082 (n + eval-expr e\u2081)     \u2261\u27e8 eval-expr-tail-correct-lemma (n + eval-expr e\u2081) e\u2082 \u27e9\n  (n + eval-expr e\u2081) + eval-expr e\u2082         \u2261\u27e8 (+-assoc n (eval-expr e\u2081) (eval-expr e\u2082)) \u27e9\n  n + (eval-expr e\u2081 + eval-expr e\u2082)         \u220e\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct = eval-expr-tail-correct-lemma zero\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\neval-expr-cont-correct-lemma : \u2200 (f : \u2115 \u2192 \u2115) e \u2192 eval-expr-cont' e f \u2261 f (eval-expr e)\neval-expr-cont-correct-lemma f (const x) = refl\neval-expr-cont-correct-lemma f (plus e\u2081 e\u2082) = begin\n  eval-expr-cont' e\u2082 (\u03bb n2 \u2192 eval-expr-cont' e\u2081 (\u03bb n1 \u2192 f (n1 + n2))) \u2261\u27e8 eval-expr-cont-correct-lemma _ e\u2082 \u27e9\n  (\u03bb n2 \u2192 eval-expr-cont' e\u2081 (\u03bb n1 \u2192 f (n1 + n2))) (eval-expr e\u2082)     \u2261\u27e8\u27e9\n  eval-expr-cont' e\u2081 (\u03bb n1 \u2192 f (n1 + eval-expr e\u2082))                    \u2261\u27e8 eval-expr-cont-correct-lemma (\u03bb z \u2192 f (z + eval-expr e\u2082)) e\u2081 \u27e9\n  (\u03bb n1 \u2192 f (n1 + eval-expr e\u2082)) (eval-expr e\u2081)                        \u2261\u27e8\u27e9\n  f (eval-expr e\u2081 + eval-expr e\u2082)                                       \u220e\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct = eval-expr-cont-correct-lemma (\u03bb n \u2192 n)\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\nrun-lemma : \u2200 is\u2081 is\u2082 s \u2192 run (is\u2081 ++ is\u2082) s \u2261 run is\u2082 (run is\u2081 s)\nrun-lemma []             is\u2082 s           = refl\nrun-lemma (push x \u2237 is\u2081) is\u2082 s           = run-lemma is\u2081 is\u2082 (x \u2237 s)\nrun-lemma (add \u2237 is\u2081)    is\u2082 []          = run-lemma is\u2081 is\u2082 []\nrun-lemma (add \u2237 is\u2081)    is\u2082 (m \u2237 [])    = run-lemma is\u2081 is\u2082 (m \u2237 [])\nrun-lemma (add \u2237 is\u2081)    is\u2082 (m \u2237 n \u2237 s) = run-lemma is\u2081 is\u2082 (m + n \u2237 s)\n\ncompile-correct-lemma : \u2200 s e \u2192 run (compile e) s \u2261 eval-expr e \u2237 s\ncompile-correct-lemma s (const x)    = refl\ncompile-correct-lemma s (plus e\u2081 e\u2082) = begin\n  run (compile e\u2081 ++ compile e\u2082 ++ add \u2237 []) s           \u2261\u27e8 run-lemma (compile e\u2081) (compile e\u2082 ++ add \u2237 []) s \u27e9\n  run (compile e\u2082 ++ add \u2237 []) (run (compile e\u2081) s)      \u2261\u27e8 run-lemma (compile e\u2082) (add \u2237 []) (run (compile e\u2081) s) \u27e9\n  run (add \u2237 []) (run (compile e\u2082) (run (compile e\u2081) s)) \u2261\u27e8 cong (\u03bb z \u2192 run (add \u2237 []) (run (compile e\u2082) z)) (compile-correct-lemma s e\u2081) \u27e9 \n  run (add \u2237 []) (run (compile e\u2082) (eval-expr e\u2081 \u2237 s))   \u2261\u27e8 cong (run (add \u2237 [])) (compile-correct-lemma (eval-expr e\u2081 \u2237 s) e\u2082) \u27e9\n  run (add \u2237 []) (eval-expr e\u2082 \u2237 eval-expr e\u2081 \u2237 s)       \u2261\u27e8\u27e9\n  eval-expr e\u2082 + eval-expr e\u2081 \u2237 s                        \u2261\u27e8 cong (_\u2237 s) (+-comm (eval-expr e\u2082) (eval-expr e\u2081)) \u27e9\n  eval-expr e\u2081 + eval-expr e\u2082 \u2237 s \u220e\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct = compile-correct-lemma []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":253,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\nlem1 : \u2200 e k \u2192 eval-expr-tail' e k \u2261 k + eval-expr e\nlem1 (const n) k = +-comm n k\nlem1 (plus e\u2081 e\u2082) k =\n  eval-expr-tail' e\u2082 (eval-expr-tail' e\u2081 k)\n    \u2261\u27e8 cong (eval-expr-tail' e\u2082) (lem1 e\u2081 k) \u27e9\n  eval-expr-tail' e\u2082 (k + eval-expr e\u2081)\n    \u2261\u27e8 lem1 e\u2082 (k + eval-expr e\u2081) \u27e9\n  k + eval-expr e\u2081 + eval-expr e\u2082\n    \u2261\u27e8 +-assoc k (eval-expr e\u2081) (eval-expr e\u2082) \u27e9\n  k + (eval-expr e\u2081 + eval-expr e\u2082)\n    \u220e\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct e = lem1 e 0\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\nlem2 : \u2200 e \u2192 (f : \u2115 \u2192 \u2115) \u2192 eval-expr-cont' e f \u2261 f (eval-expr e)\nlem2 (const n) f = refl\nlem2 (plus e\u2081 e\u2082) f =\n  eval-expr-cont' e\u2082 (\u03bb n2 \u2192 eval-expr-cont' e\u2081 (\u03bb n1 \u2192 f (n1 + n2)))\n    \u2261\u27e8 lem2 e\u2082 (\u03bb n2 \u2192 eval-expr-cont' e\u2081 (\u03bb n1 \u2192 f (n1 + n2))) \u27e9\n  eval-expr-cont' e\u2081 (\u03bb n1 \u2192 f (n1 + eval-expr e\u2082))\n    \u2261\u27e8 lem2 e\u2081 (\u03bb n1 \u2192 f (n1 + eval-expr e\u2082)) \u27e9\n  f (eval-expr e\u2081 + eval-expr e\u2082)\n    \u220e\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e = lem2 e (\u03bb n \u2192 n)\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nlem3 : \u2200 p\u2081 p\u2082 s \u2192 run (p\u2081 ++ p\u2082) s \u2261 run p\u2082 (run p\u2081 s)\nlem3 [] p\u2082 s = refl\nlem3 (push n \u2237 p\u2081) p\u2082 s = lem3 p\u2081 p\u2082 (n \u2237 s)\nlem3 (add \u2237 p\u2081) p\u2082 [] = lem3 p\u2081 p\u2082 []\nlem3 (add \u2237 p\u2081) p\u2082 (n \u2237 []) = lem3 p\u2081 p\u2082 (n \u2237 [])\nlem3 (add \u2237 p\u2081) p\u2082 (n \u2237 m \u2237 s) = lem3 p\u2081 p\u2082 (n + m \u2237 s)\n\nlem4 : \u2200 e s \u2192 run (compile e) s \u2261 eval-expr e \u2237 s\nlem4 (const n) s = refl\nlem4 (plus e\u2081 e\u2082) s =\n  run (compile e\u2081 ++ compile e\u2082 ++ add \u2237 []) s\n    \u2261\u27e8 lem3 (compile e\u2081) (compile e\u2082 ++ add \u2237 []) s \u27e9\n  run (compile e\u2082 ++ add \u2237 []) (run (compile e\u2081) s)\n    \u2261\u27e8 lem3 (compile e\u2082) (add \u2237 []) (run (compile e\u2081) s) \u27e9\n  run (add \u2237 []) (run (compile e\u2082) (run (compile e\u2081) s))\n    \u2261\u27e8 cong (\u03bb x\u00a0\u2192 run (add \u2237 []) (run (compile e\u2082) x)) (lem4 e\u2081 s) \u27e9\n  run (add \u2237 []) (run (compile e\u2082) (eval-expr e\u2081 \u2237 s))\n    \u2261\u27e8 cong (run (add \u2237 [])) (lem4 e\u2082 (eval-expr e\u2081 \u2237 s)) \u27e9\n  eval-expr e\u2082 + eval-expr e\u2081 \u2237 s\n    \u2261\u27e8 cong (_\u2237 s) (+-comm (eval-expr e\u2082) (eval-expr e\u2081)) \u27e9\n  eval-expr e\u2081 + eval-expr e\u2082 \u2237 s\n    \u220e\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e = lem4 e []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":254,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Data.Nat public\nopen import Data.List public\n\ndata Expr : Set where\n  const : \u2115 \u2192 Expr\n  plus : Expr \u2192 Expr \u2192 Expr\n\neval-expr : Expr \u2192 \u2115\neval-expr (const n) = n\neval-expr (plus e1 e2) = eval-expr e1 + eval-expr e2\n\neval-expr-tail' : Expr \u2192 \u2115 \u2192 \u2115\neval-expr-tail' (const n) acc = n + acc\neval-expr-tail' (plus e1 e2) acc = eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n\neval-expr-tail : Expr \u2192 \u2115\neval-expr-tail e = eval-expr-tail' e 0\n\neval-expr-cont' : {A : Set} \u2192 Expr \u2192 (\u2115 \u2192 A) \u2192 A\neval-expr-cont' (const n) k = k n\neval-expr-cont' (plus e1 e2) k = eval-expr-cont' e2 \u03bb n2 \u2192\n                                 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)\n\neval-expr-cont : Expr \u2192 \u2115\neval-expr-cont e = eval-expr-cont' e (\u03bb n \u2192 n)\n\ndata Instr : Set where\n  push : \u2115 \u2192 Instr\n  add : Instr\n\nProg = List Instr\n\nStack = List \u2115\n\nrun : Prog \u2192 Stack \u2192 Stack\nrun [] s = s\nrun (push n \u2237 p) s = run p (n \u2237 s)\nrun (add \u2237 p) (a1 \u2237 a2 \u2237 s) = run p (a1 + a2 \u2237 s)\nrun (add \u2237 p) s = run p s\n\ncompile : Expr \u2192 Prog\ncompile (const n) = push n \u2237 []\ncompile (plus e1 e2) = compile e1 ++ compile e2 ++ add \u2237 []\n\n-}\n\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\neval-expr-tail'\u2261sum : {e : Expr} {acc : \u2115} \u2192 eval-expr-tail' e acc \u2261 (eval-expr e) + acc\neval-expr-tail'\u2261sum {const x} {acc} = refl\neval-expr-tail'\u2261sum {plus e1 e2} {acc} \n        rewrite eval-expr-tail'\u2261sum {e1} {acc} | \n                eval-expr-tail'\u2261sum {e2} {eval-expr e1 + acc} |\n                sym (+-assoc (eval-expr e2) (eval-expr e1) (acc))\n        = cong (_+ acc) (+-comm (eval-expr e2) (eval-expr e1))\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct (const x) = +-identity\u02b3 x\neval-expr-tail-correct (plus e1 e2) = begin\n                eval-expr-tail' e2 (eval-expr-tail' e1 zero) \u2261\u27e8 eval-expr-tail'\u2261sum {e2} {(eval-expr-tail' e1 zero)} \u27e9\n                eval-expr e2 + (eval-expr-tail' e1 zero) \u2261\u27e8 cong (eval-expr e2 +_) (eval-expr-tail'\u2261sum {e1} {0}) \u27e9\n                eval-expr e2 + (eval-expr e1 + 0) \u2261\u27e8 +-comm (eval-expr e2) (eval-expr e1 + 0) \u27e9\n                eval-expr e1 + 0 + eval-expr e2 \u2261\u27e8 cong (_+ eval-expr e2) (+-identity\u02b3 (eval-expr e1)) \u27e9\n                eval-expr e1 + eval-expr e2    \u220e where open \u2261-Reasoning\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\neval-expr-cont'\u2261app : {e : Expr} {f : (\u2115 \u2192 \u2115)} \u2192  eval-expr-cont' e f \u2261 f (eval-expr e)\neval-expr-cont'\u2261app {const x} {f} = refl\neval-expr-cont'\u2261app {plus e1 e2} {f} = begin\n                eval-expr-cont' e2 (\u03bb z \u2192 eval-expr-cont' e1 (\u03bb z\u2081 \u2192 f (z\u2081 + z)))  \u2261\u27e8 eval-expr-cont'\u2261app {e2} {(\u03bb n2 \u2192 eval-expr-cont' e1 (\u03bb n1 \u2192 f (n1 + n2)))} \u27e9\n                eval-expr-cont' e1 (\u03bb n1 \u2192 f (n1 + eval-expr e2))  \u2261\u27e8 eval-expr-cont'\u2261app {e1} {(\u03bb n1 \u2192 f (n1 + eval-expr e2))} \u27e9\n                f (eval-expr e1 + eval-expr e2)    \u220e where open \u2261-Reasoning\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e = eval-expr-cont'\u2261app {e} {\u03bb z \u2192 z}\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nsplitProgConcat : {x y : Prog} {s : Stack} \u2192 run (x ++ y) s \u2261 run y (run x s)\nsplitProgConcat {[]} {y} {s} = refl\nsplitProgConcat {push c \u2237 x} {y} {s} = splitProgConcat {x} {y} {c \u2237 s}\nsplitProgConcat {add \u2237 x} {y} {[]} = splitProgConcat {x} {y} {[]}\nsplitProgConcat {add \u2237 x} {y} {a \u2237 []} = splitProgConcat {x} {y} {a \u2237 []}\nsplitProgConcat {add \u2237 x} {y} {a \u2237 b \u2237 s} = splitProgConcat {x} {y} {a + b \u2237 s}  \n\ncompile-correct-extend : \u2200 e s \u2192 run (compile e) s \u2261 eval-expr e \u2237 s\ncompile-correct-extend (const x) s = refl\ncompile-correct-extend (plus e1 e2) s = begin \n                run (compile e1 ++ compile e2 ++ add \u2237 []) s \u2261\u27e8 splitProgConcat {compile e1} {compile e2 ++ add \u2237 []} {s} \u27e9\n                run (compile e2 ++ add \u2237 []) (run (compile e1) s) \u2261\u27e8 splitProgConcat {compile e2} {add \u2237 []} {(run (compile e1) s)} \u27e9\n                run (add \u2237 []) (run (compile e2) (run (compile e1) s)) \u2261\u27e8 cong (\u03bb z \u2192 (run (add \u2237 []) (run (compile e2) z))) (compile-correct-extend e1 s) \u27e9\n                run (add \u2237 []) (run (compile e2) (eval-expr e1 \u2237 s)) \u2261\u27e8 cong (\u03bb z \u2192 run (add \u2237 []) z) (compile-correct-extend e2 (eval-expr e1 \u2237 s)) \u27e9\n                eval-expr e2 + eval-expr e1 \u2237 s \u2261\u27e8 cong (_\u2237 s) (+-comm (eval-expr e2) (eval-expr e1)) \u27e9\n                eval-expr e1 + eval-expr e2 \u2237 s       \u220e where open \u2261-Reasoning\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e = compile-correct-extend e []","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":255,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\nopen \u2261-Reasoning\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Data.Nat public\nopen import Data.List public\n\ndata Expr : Set where\n  const : \u2115 \u2192 Expr\n  plus : Expr \u2192 Expr \u2192 Expr\n\neval-expr : Expr \u2192 \u2115\neval-expr (const n) = n\neval-expr (plus e1 e2) = eval-expr e1 + eval-expr e2\n\neval-expr-tail' : Expr \u2192 \u2115 \u2192 \u2115\neval-expr-tail' (const n) acc = n + acc\neval-expr-tail' (plus e1 e2) acc = eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n\neval-expr-tail : Expr \u2192 \u2115\neval-expr-tail e = eval-expr-tail' e 0\n\neval-expr-cont' : {A : Set} \u2192 Expr \u2192 (\u2115 \u2192 A) \u2192 A\neval-expr-cont' (const n) k = k n\neval-expr-cont' (plus e1 e2) k = eval-expr-cont' e2 \u03bb n2 \u2192\n                                 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)\n\neval-expr-cont : Expr \u2192 \u2115\neval-expr-cont e = eval-expr-cont' e (\u03bb n \u2192 n)\n\ndata Instr : Set where\n  push : \u2115 \u2192 Instr\n  add : Instr\n\nProg = List Instr\n\nStack = List \u2115\n\nrun : Prog \u2192 Stack \u2192 Stack\nrun [] s = s\nrun (push n \u2237 p) s = run p (n \u2237 s)\nrun (add \u2237 p) (a1 \u2237 a2 \u2237 s) = run p (a1 + a2 \u2237 s)\nrun (add \u2237 p) s = run p s\n\ncompile : Expr \u2192 Prog\ncompile (const n) = push n \u2237 []\ncompile (plus e1 e2) = compile e1 ++ compile e2 ++ add \u2237 []\n\n-}\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\neval-expr-tail'-plus : \u2200 (e : Expr) \u2192 \u2200 (acc : \u2115) \u2192  eval-expr-tail' e acc \u2261 \n    eval-expr-tail' e 0 + acc\neval-expr-tail'-plus (const x) acc = cong (_+ acc) (sym (+-identity\u02b3 x))\neval-expr-tail'-plus (plus e e\u2081) acc =   \n    begin\n        eval-expr-tail' e\u2081 (eval-expr-tail' e acc) \n            \u2261\u27e8 (cong (\u03bb x \u2192 eval-expr-tail' e\u2081 x) (eval-expr-tail'-plus e acc))  \u27e9 \n        eval-expr-tail' e\u2081 (eval-expr-tail' e 0 + acc) \n            \u2261\u27e8 eval-expr-tail'-plus e\u2081 _ \u27e9 \n        eval-expr-tail' e\u2081 0 + (eval-expr-tail' e 0 + acc) \n            \u2261\u27e8 sym (+-assoc (eval-expr-tail' e\u2081 zero) (eval-expr-tail' e zero) acc) \u27e9\n        (eval-expr-tail' e\u2081 0 + eval-expr-tail' e 0) + acc \n            \u2261\u27e8 cong (_+ acc) (sym (eval-expr-tail'-plus e\u2081 _)) \u27e9 \n        eval-expr-tail' e\u2081 (eval-expr-tail' e 0) + acc\n    \u220e\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct (const x) = +-identity\u02b3 x\neval-expr-tail-correct (plus e e') = \n    begin\n        eval-expr-tail' e' (eval-expr-tail' e 0)\n            \u2261\u27e8 eval-expr-tail'-plus e' (eval-expr-tail' e zero)  \u27e9 \n        eval-expr-tail' e' 0 + (eval-expr-tail' e 0)\n            \u2261\u27e8 cong\u2082 _+_ (eval-expr-tail-correct e') (eval-expr-tail-correct e)  \u27e9\n        eval-expr e' + eval-expr e\n            \u2261\u27e8 +-comm (eval-expr e') (eval-expr e) \u27e9\n        eval-expr e + eval-expr e'\n    \u220e\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\neval-expr-cont'-lemma : \u2200 (e : Expr) \u2192 \u2200 (k : \u2115 \u2192 \u2115) \u2192 \n    eval-expr-cont' e k \u2261 k (eval-expr-cont' e (\u03bb n \u2192 n))\neval-expr-cont'-lemma (const x) k = refl\neval-expr-cont'-lemma (plus e e\u2081) k = \n    begin\n        eval-expr-cont' e\u2081\n         (\u03bb n2 \u2192 eval-expr-cont' e (\u03bb n1 \u2192 k (n1 + n2)))\n            \u2261\u27e8 eval-expr-cont'-lemma e\u2081 _  \u27e9 \n         eval-expr-cont' e (\u03bb n1 \u2192 k (n1 + (eval-expr-cont' e\u2081 (\u03bb n \u2192 n))))\n            \u2261\u27e8 eval-expr-cont'-lemma e _  \u27e9 \n        k ((eval-expr-cont' e (\u03bb n \u2192 n)) + (eval-expr-cont' e\u2081 (\u03bb n \u2192 n)))\n            \u2261\u27e8 cong k (sym (eval-expr-cont'-lemma e _)) \u27e9 \n        k (eval-expr-cont' e (\u03bb n1 \u2192 n1 + eval-expr-cont' e\u2081 (\u03bb n \u2192 n)))\n            \u2261\u27e8 cong k (sym (eval-expr-cont'-lemma e\u2081 _)) \u27e9 \n        k (eval-expr-cont' e\u2081 (\u03bb n2 \u2192 eval-expr-cont' e (\u03bb n1 \u2192 n1 + n2)))\n    \u220e\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct (const x) = refl\neval-expr-cont-correct (plus e e\u2081) = \n    begin\n        eval-expr-cont' e\u2081 (\u03bb n2 \u2192 eval-expr-cont' e (\u03bb n1 \u2192 n1 + n2))\n            \u2261\u27e8 eval-expr-cont'-lemma e\u2081 _  \u27e9 \n        eval-expr-cont' e (\u03bb n1 \u2192 n1 + (eval-expr-cont' e\u2081 (\u03bb n \u2192 n)))\n            \u2261\u27e8 eval-expr-cont'-lemma e _ \u27e9 \n        (eval-expr-cont' e (\u03bb n \u2192 n)) + (eval-expr-cont' e\u2081 (\u03bb n \u2192 n))\n            \u2261\u27e8 cong\u2082 _+_ (eval-expr-cont-correct e) (eval-expr-cont-correct e\u2081) \u27e9 \n        eval-expr e + eval-expr e\u2081    \n    \u220e\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\ncompile-lemma : \u2200 (p1 p2 : Prog) \u2192 \u2200 (s : Stack) \u2192 \n    run (p1 ++ p2) s \u2261 run p2 (run p1 s)\ncompile-lemma [] p2 s = refl\ncompile-lemma (push x \u2237 p1) p2 s = compile-lemma p1 p2 (x \u2237 s)\ncompile-lemma (add \u2237 p1) p2 [] = compile-lemma p1 p2 []\ncompile-lemma (add \u2237 p1) p2 (x \u2237 []) = compile-lemma p1 p2 (x \u2237 [])\ncompile-lemma (add \u2237 p1) p2 (x \u2237 x\u2081 \u2237 s) = compile-lemma p1 p2 (x + x\u2081 \u2237 s)\n\ncompile-correct' : \u2200 e \u2192 \u2200 u \u2192  run (compile e) u \u2261 eval-expr e \u2237 u\ncompile-correct' (const x) u = refl\ncompile-correct' (plus e e') u =\n    begin \n        run (compile e ++ compile e' ++ add \u2237 []) u\n            \u2261\u27e8 compile-lemma (compile e) ((compile e') ++ add \u2237 [])  u \u27e9\n        run (compile e' ++ add \u2237 []) (run (compile e) u) \n            \u2261\u27e8 cong (run (compile e' ++ add \u2237 [])) (compile-correct' e _) \u27e9\n        run (compile e' ++ add \u2237 []) (eval-expr e \u2237 u) \n            \u2261\u27e8 compile-lemma (compile e') (add \u2237 []) (eval-expr e \u2237 u) \u27e9\n        run (add \u2237 []) (run (compile e') (eval-expr e \u2237 u))\n            \u2261\u27e8 cong (\u03bb s \u2192 run (add \u2237 []) s) (compile-correct' e' (eval-expr e \u2237 u)) \u27e9\n        run (add \u2237 [])  (eval-expr e' \u2237 eval-expr e \u2237 u)\n            \u2261\u27e8 cong (_\u2237 u) (+-comm (eval-expr e') (eval-expr e)) \u27e9\n        eval-expr e + eval-expr e' \u2237 u\n    \u220e\n \ncompile-correct : \u2200 e \u2192  run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e = compile-correct' e []","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":256,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Data.Nat public\nopen import Data.List public\n\ndata Expr : Set where\n  const : \u2115 \u2192 Expr\n  plus : Expr \u2192 Expr \u2192 Expr\n\neval-expr : Expr \u2192 \u2115\neval-expr (const n) = n\neval-expr (plus e1 e2) = eval-expr e1 + eval-expr e2\n\neval-expr-tail' : Expr \u2192 \u2115 \u2192 \u2115\neval-expr-tail' (const n) acc = n + acc\neval-expr-tail' (plus e1 e2) acc = eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n\neval-expr-tail : Expr \u2192 \u2115\neval-expr-tail e = eval-expr-tail' e 0\n\neval-expr-cont' : {A : Set} \u2192 Expr \u2192 (\u2115 \u2192 A) \u2192 A\neval-expr-cont' (const n) k = k n\neval-expr-cont' (plus e1 e2) k = eval-expr-cont' e2 \u03bb n2 \u2192\n                                 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)\n\neval-expr-cont : Expr \u2192 \u2115\neval-expr-cont e = eval-expr-cont' e (\u03bb n \u2192 n)\n\ndata Instr : Set where\n  push : \u2115 \u2192 Instr\n  add : Instr\n\nProg = List Instr\n\nStack = List \u2115\n\nrun : Prog \u2192 Stack \u2192 Stack\nrun [] s = s\nrun (push n \u2237 p) s = run p (n \u2237 s)\nrun (add \u2237 p) (a1 \u2237 a2 \u2237 s) = run p (a1 + a2 \u2237 s)\nrun (add \u2237 p) s = run p s\n\ncompile : Expr \u2192 Prog\ncompile (const n) = push n \u2237 []\ncompile (plus e1 e2) = compile e1 ++ compile e2 ++ add \u2237 []\n\n-}\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\neval-expr-tail'-correct : \u2200 e acc \u2192 eval-expr-tail' e acc \u2261 acc + eval-expr e\neval-expr-tail'-correct (const x) acc rewrite (+-comm x acc) = refl\neval-expr-tail'-correct (plus e1 e2) acc \n  rewrite (eval-expr-tail'-correct e1 acc) \n        | (eval-expr-tail'-correct e2 (acc + eval-expr e1)) \n        | (+-assoc acc (eval-expr e1) (eval-expr e2)) = refl\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct e = eval-expr-tail'-correct e 0\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\neval-expr-cont-correct' : {A : Set} \u2192 (e : Expr) \u2192 (k : \u2115 \u2192 A) \u2192 eval-expr-cont' e k \u2261 k (eval-expr e)\neval-expr-cont-correct' (const x) k = refl\neval-expr-cont-correct' (plus e1 e2) k \n  rewrite eval-expr-cont-correct' e2 (\u03bb n2 \u2192 eval-expr-cont' e1 (\u03bb n1 \u2192 k (n1 + n2))) \n  | eval-expr-cont-correct' e1 (\u03bb n1 \u2192 k (n1 + eval-expr e2)) = refl\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e = eval-expr-cont-correct' e (\u03bb n \u2192 n) \n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\ncompile-lemma : \u2200 e b st \u2192 run (compile e ++ b) st \u2261 run b (eval-expr e \u2237 st)\ncompile-lemma (const x) b st = refl\ncompile-lemma (plus e\u2081 e\u2082) b st \n  rewrite ++-assoc (compile e\u2081) (compile e\u2082 ++ add \u2237 []) b \n  | compile-lemma e\u2081 ((compile e\u2082 ++ add \u2237 []) ++ b) st \n  | ++-assoc (compile e\u2082) (add \u2237 []) b \n  | compile-lemma e\u2082 (add \u2237 b) (eval-expr e\u2081 \u2237 st) \n  | +-comm (eval-expr e\u2082) (eval-expr e\u2081) = refl\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e \n  rewrite (sym (++-identity\u02b3 (compile e))) = compile-lemma e [] [] \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":257,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Data.Nat public\nopen import Data.List public\n\ndata Expr : Set where\n  const : \u2115 \u2192 Expr\n  plus : Expr \u2192 Expr \u2192 Expr\n\neval-expr : Expr \u2192 \u2115\neval-expr (const n) = n\neval-expr (plus e1 e2) = eval-expr e1 + eval-expr e2\n\neval-expr-tail' : Expr \u2192 \u2115 \u2192 \u2115\neval-expr-tail' (const n) acc = n + acc\neval-expr-tail' (plus e1 e2) acc = eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n\neval-expr-tail : Expr \u2192 \u2115\neval-expr-tail e = eval-expr-tail' e 0\n\neval-expr-cont' : {A : Set} \u2192 Expr \u2192 (\u2115 \u2192 A) \u2192 A\neval-expr-cont' (const n) k = k n\neval-expr-cont' (plus e1 e2) k = eval-expr-cont' e2 \u03bb n2 \u2192\n                                 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)\n\neval-expr-cont : Expr \u2192 \u2115\neval-expr-cont e = eval-expr-cont' e (\u03bb n \u2192 n)\n\ndata Instr : Set where\n  push : \u2115 \u2192 Instr\n  add : Instr\n\nProg = List Instr\n\nStack = List \u2115\n\nrun : Prog \u2192 Stack \u2192 Stack\nrun [] s = s\nrun (push n \u2237 p) s = run p (n \u2237 s)\nrun (add \u2237 p) (a1 \u2237 a2 \u2237 s) = run p (a1 + a2 \u2237 s)\nrun (add \u2237 p) s = run p s\n\ncompile : Expr \u2192 Prog\ncompile (const n) = push n \u2237 []\ncompile (plus e1 e2) = compile e1 ++ compile e2 ++ add \u2237 []\n\n-}\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\neval-expr-tail'-correct : \u2200 e acc \u2192 eval-expr-tail' e acc \u2261 acc + eval-expr e\neval-expr-tail'-correct (const x) acc rewrite (+-comm x acc) = refl\neval-expr-tail'-correct (plus e1 e2) acc \n  rewrite (eval-expr-tail'-correct e1 acc) \n        | (eval-expr-tail'-correct e2 (acc + eval-expr e1)) \n        | (+-assoc acc (eval-expr e1) (eval-expr e2)) = refl\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct e = eval-expr-tail'-correct e 0\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\neval-expr-cont-correct' : {A : Set} \u2192 (e : Expr) \u2192 (k : \u2115 \u2192 A) \u2192 eval-expr-cont' e k \u2261 k (eval-expr e)\neval-expr-cont-correct' (const x) k = refl\neval-expr-cont-correct' (plus e1 e2) k \n  rewrite eval-expr-cont-correct' e2 (\u03bb n2 \u2192 eval-expr-cont' e1 (\u03bb n1 \u2192 k (n1 + n2))) \n  | eval-expr-cont-correct' e1 (\u03bb n1 \u2192 k (n1 + eval-expr e2)) = refl\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e = eval-expr-cont-correct' e (\u03bb n \u2192 n) \n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrun-compile : \u2200 e st \u2192 run (compile e) st \u2261 eval-expr e \u2237 st\ncompile-lemma : \u2200 e b st \u2192 run ((compile e) ++ b) st \u2261 run b (eval-expr e \u2237 st)\n\nrun-compile (const x) st = refl\nrun-compile (plus e\u2081 e\u2082) st \n  rewrite compile-lemma e\u2081 (compile e\u2082 ++ add \u2237 []) st \n  | compile-lemma e\u2082 (add \u2237 []) (eval-expr e\u2081 \u2237 st) \n  | +-comm (eval-expr e\u2082) (eval-expr e\u2081)= refl\n\ncompile-lemma (const x) b st = refl\ncompile-lemma (plus e\u2081 e\u2082) b st \n  rewrite ++-assoc (compile e\u2081) (compile e\u2082 ++ add \u2237 []) b \n  | compile-lemma e\u2081 ((compile e\u2082 ++ add \u2237 []) ++ b) st \n  | ++-assoc (compile e\u2082) (add \u2237 []) b \n  | compile-lemma e\u2082 (add \u2237 b) (eval-expr e\u2081 \u2237 st) \n  | +-comm (eval-expr e\u2082) (eval-expr e\u2081) = refl\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e = run-compile e []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":258,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\nopen import Data.Nat.Properties\nopen import Data.List.Properties\n\nopen import Preloaded\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\neval-expr-tail-lemma : \u2200 e acc \u2192 eval-expr-tail' e acc \u2261 eval-expr e + acc\neval-expr-tail-lemma (const n)    acc = refl\neval-expr-tail-lemma (plus e1 e2) acc =\n  begin\n    eval-expr-tail' (plus e1 e2) acc\n  \u2261\u27e8\u27e9\n    eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n  \u2261\u27e8 eval-expr-tail-lemma e2 (eval-expr-tail' e1 acc) \u27e9\n    eval-expr e2 + (eval-expr-tail' e1 acc)\n  \u2261\u27e8 cong (eval-expr e2 +_) (eval-expr-tail-lemma e1 acc) \u27e9\n    eval-expr e2 + (eval-expr e1 + acc)\n  \u2261\u27e8 sym (+-assoc (eval-expr e2) (eval-expr e1) acc) \u27e9\n    eval-expr e2 + eval-expr e1 + acc\n  \u2261\u27e8 cong (_+ acc) (+-comm (eval-expr e2) (eval-expr e1)) \u27e9\n    eval-expr e1 + eval-expr e2 + acc\n  \u2261\u27e8\u27e9\n    eval-expr (plus e1 e2) + acc\n  \u220e\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct e rewrite sym (+-identity\u02b3 (eval-expr e)) = eval-expr-tail-lemma e 0\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\neval-expr-cont-lemma : \u2200 {A} e (k : \u2115 \u2192 A) \u2192 eval-expr-cont' e k \u2261 k (eval-expr e)\neval-expr-cont-lemma (const n)    k = refl\neval-expr-cont-lemma (plus e1 e2) k =\n  begin\n    eval-expr-cont' (plus e1 e2) k\n  \u2261\u27e8\u27e9\n    eval-expr-cont' e2 (\u03bb n2 \u2192 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2))\n  \u2261\u27e8 eval-expr-cont-lemma e2 (\u03bb n2 \u2192 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)) \u27e9\n    (\u03bb n2 \u2192 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)) (eval-expr e2)\n  \u2261\u27e8\u27e9\n    eval-expr-cont' e1 (\u03bb n1 \u2192 k (n1 + eval-expr e2))\n  \u2261\u27e8 eval-expr-cont-lemma e1 (\u03bb n1 \u2192 k (n1 + eval-expr e2)) \u27e9\n    (\u03bb n1 \u2192 k (n1 + eval-expr e2)) (eval-expr e1)\n  \u2261\u27e8\u27e9\n    k (eval-expr e1 + eval-expr e2)\n  \u2261\u27e8\u27e9\n    k (eval-expr (plus e1 e2))\n  \u220e\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e = eval-expr-cont-lemma e (\u03bb n \u2192 n)\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\ncompile-lemma : \u2200 e p s \u2192 run (compile e ++ p) s \u2261 run p (eval-expr e \u2237 s)\ncompile-lemma (const n)    p s = refl\ncompile-lemma (plus e1 e2) p s =\n  begin\n    run (compile (plus e1 e2) ++ p) s\n  \u2261\u27e8\u27e9\n    run ((compile e1 ++ compile e2 ++ add \u2237 []) ++ p) s\n  \u2261\u27e8 cong (\u03bb x \u2192 run x s) (++-assoc (compile e1) (compile e2 ++ add \u2237 []) p) \u27e9\n    run (compile e1 ++ (compile e2 ++ add \u2237 []) ++ p) s\n  \u2261\u27e8 compile-lemma e1 ((compile e2 ++ add \u2237 []) ++ p) s \u27e9\n    run ((compile e2 ++ add \u2237 []) ++ p) (eval-expr e1 \u2237 s)\n  \u2261\u27e8 cong (\u03bb x \u2192 run x (eval-expr e1 \u2237 s)) (++-assoc (compile e2) (add \u2237 []) p) \u27e9\n    run (compile e2 ++ ((add \u2237 []) ++ p)) (eval-expr e1 \u2237 s)\n  \u2261\u27e8 compile-lemma e2 ((add \u2237 []) ++ p) (eval-expr e1 \u2237 s) \u27e9\n    run ((add \u2237 []) ++ p) (eval-expr e2 \u2237 eval-expr e1 \u2237 s)\n  \u2261\u27e8\u27e9\n    run (add \u2237 p) (eval-expr e2 \u2237 eval-expr e1 \u2237 s)\n  \u2261\u27e8\u27e9\n    run p (eval-expr e2 + eval-expr e1 \u2237 s)\n  \u2261\u27e8 cong (\u03bb x \u2192 run p (x \u2237 s)) (+-comm (eval-expr e2) (eval-expr e1)) \u27e9\n    run p (eval-expr e1 + eval-expr e2 \u2237 s)\n  \u2261\u27e8\u27e9\n    run p (eval-expr (plus e1 e2) \u2237 s)\n  \u220e\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e rewrite sym (++-identity\u02b3 (compile e)) = compile-lemma e [] []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":259,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\nopen Relation.Binary.PropositionalEquality.\u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Data.Nat public\nopen import Data.List public\n\ndata Expr : Set where\n  const : \u2115 \u2192 Expr\n  plus : Expr \u2192 Expr \u2192 Expr\n\neval-expr : Expr \u2192 \u2115\neval-expr (const n) = n\neval-expr (plus e1 e2) = eval-expr e1 + eval-expr e2\n\neval-expr-tail' : Expr \u2192 \u2115 \u2192 \u2115\neval-expr-tail' (const n) acc = n + acc\neval-expr-tail' (plus e1 e2) acc = eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n\neval-expr-tail : Expr \u2192 \u2115\neval-expr-tail e = eval-expr-tail' e 0\n\neval-expr-cont' : {A : Set} \u2192 Expr \u2192 (\u2115 \u2192 A) \u2192 A\neval-expr-cont' (const n) k = k n\neval-expr-cont' (plus e1 e2) k = eval-expr-cont' e2 \u03bb n2 \u2192\n                                 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)\n\neval-expr-cont : Expr \u2192 \u2115\neval-expr-cont e = eval-expr-cont' e (\u03bb n \u2192 n)\n\ndata Instr : Set where\n  push : \u2115 \u2192 Instr\n  add : Instr\n\nProg = List Instr\n\nStack = List \u2115\n\nrun : Prog \u2192 Stack \u2192 Stack\nrun [] s = s\nrun (push n \u2237 p) s = run p (n \u2237 s)\nrun (add \u2237 p) (a1 \u2237 a2 \u2237 s) = run p (a1 + a2 \u2237 s)\nrun (add \u2237 p) s = run p s\n\ncompile : Expr \u2192 Prog\ncompile (const n) = push n \u2237 []\ncompile (plus e1 e2) = compile e1 ++ compile e2 ++ add \u2237 []\n\n-}\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\n\neval-expr-tail'-eq-eval-expr : \u2200 e acc \u2192 eval-expr-tail' e acc \u2261 eval-expr e + acc\neval-expr-tail'-eq-eval-expr (const x) acc = refl\neval-expr-tail'-eq-eval-expr (plus e1 e2) acc =\n  begin\n    eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n  \u2261\u27e8 eval-expr-tail'-eq-eval-expr e2 (eval-expr-tail' e1 acc) \u27e9\n    eval-expr e2 + eval-expr-tail' e1 acc\n  \u2261\u27e8 cong (eval-expr e2 +_) (eval-expr-tail'-eq-eval-expr e1 acc) \u27e9\n    eval-expr e2 + (eval-expr e1 + acc)\n  \u2261\u27e8 sym (+-assoc (eval-expr e2) (eval-expr e1) acc) \u27e9\n    eval-expr e2 + eval-expr e1 + acc\n  \u2261\u27e8 cong (_+ acc) (+-comm (eval-expr e2) (eval-expr e1)) \u27e9\n    eval-expr e1 + eval-expr e2 + acc\n  \u220e\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct e =\n  begin\n    eval-expr-tail e\n  \u2261\u27e8\u27e9\n    eval-expr-tail' e 0\n  \u2261\u27e8 eval-expr-tail'-eq-eval-expr e 0 \u27e9\n    eval-expr e + 0\n  \u2261\u27e8 +-identity\u02b3 (eval-expr e) \u27e9\n    eval-expr e\n  \u220e\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\neval-expr-cont'-correct : \u2200 e {A} (k : \u2115 \u2192 A) \u2192 eval-expr-cont' e k \u2261 k (eval-expr e)\neval-expr-cont'-correct (const x) k = refl\neval-expr-cont'-correct (plus e1 e2) k =\n  begin\n    eval-expr-cont' e2\n      (\u03bb n2 \u2192 eval-expr-cont' e1 (\u03bb n1 \u2192 k (n1 + n2)))\n  \u2261\u27e8 eval-expr-cont'-correct e2 (\u03bb n2 \u2192 eval-expr-cont' e1 (\u03bb n1 \u2192 k (n1 + n2))) \u27e9\n    eval-expr-cont' e1 (\u03bb n1 \u2192 k (n1 + eval-expr e2))\n  \u2261\u27e8 eval-expr-cont'-correct e1 (\u03bb n1 \u2192 k (n1 + eval-expr e2)) \u27e9\n    k (eval-expr e1 + eval-expr e2)\n  \u220e\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e = eval-expr-cont'-correct e (\u03bb n \u2192 n)\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrun-dist : \u2200 p1 p2 s \u2192 run (p1 ++ p2) s \u2261 run p2 (run p1 s)\nrun-dist [] p2 s = refl\nrun-dist (push n \u2237 p1) p2 s = run-dist p1 p2 (n \u2237 s)\nrun-dist (add \u2237 p1) p2 s with s\n... | n1 \u2237 n2 \u2237 s' = run-dist p1 p2 (n1 + n2 \u2237 s')\n... | [] = run-dist p1 p2 []\n... | ins \u2237 [] = run-dist p1 p2 (ins \u2237 [])\n\ncompile-correct' : \u2200 e s \u2192 run (compile e) s \u2261 eval-expr e \u2237 s\ncompile-correct' (const x) s = refl\ncompile-correct' (plus e1 e2) s =\n  begin\n    run (compile e1 ++ compile e2 ++ add \u2237 []) s\n  \u2261\u27e8 run-dist (compile e1) (compile e2 ++ add \u2237 []) s \u27e9\n    run (compile e2 ++ add \u2237 []) (run (compile e1) s)\n  \u2261\u27e8 cong (run (compile e2 ++ add \u2237 [])) (compile-correct' e1 s) \u27e9\n    run (compile e2 ++ add \u2237 []) (eval-expr e1 \u2237 s)\n  \u2261\u27e8 run-dist (compile e2) (add \u2237 []) (eval-expr e1 \u2237 s) \u27e9\n    run (add \u2237 []) (run (compile e2) (eval-expr e1 \u2237 s))\n  \u2261\u27e8 cong (run (add \u2237 [])) (compile-correct' e2 (eval-expr e1 \u2237 s)) \u27e9\n    eval-expr e2 + eval-expr e1 \u2237 s\n  \u2261\u27e8 cong (_\u2237 s) (+-comm (eval-expr e2) (eval-expr e1)) \u27e9\n    eval-expr e1 + eval-expr e2 \u2237 s\n  \u220e\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e = compile-correct' e []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":260,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality hiding ([_])\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\nopen \u2261-Reasoning\n\neval-expr-tail'-correct : \u2200 m e \u2192 eval-expr-tail' e m \u2261 m + eval-expr e\neval-expr-tail'-correct m (const x) = +-comm x m\neval-expr-tail'-correct m (plus e\u2081 e\u2082) = begin\n  et e\u2082 (et e\u2081 m) \u2261\u27e8 cong (et e\u2082) (eval-expr-tail'-correct m e\u2081) \u27e9\n  et e\u2082 (m + e e\u2081) \u2261\u27e8 eval-expr-tail'-correct (m + e e\u2081) e\u2082 \u27e9\n  m + e e\u2081 + e e\u2082 \u2261\u27e8 +-assoc m (e e\u2081)(e e\u2082) \u27e9\n  m + (e e\u2081 + e e\u2082) \u220e\n  where e = eval-expr\n        et = eval-expr-tail'\n  \n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct = eval-expr-tail'-correct 0\n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\nopen import Function\n\neval-expr-cont-correct' : \u2200{A}(f : \u2115 \u2192 A) e \u2192 eval-expr-cont' e f \u2261 f (eval-expr e)\neval-expr-cont-correct' f (const x) = refl\neval-expr-cont-correct' f (plus e\u2081 e\u2082) = begin\n  ec e\u2082 f' \u2261\u27e8 eval-expr-cont-correct' f' e\u2082  \u27e9\n  ec e\u2081 (f \u2218 (_+ e e\u2082)) \u2261\u27e8 eval-expr-cont-correct' (f \u2218 (_+ e e\u2082)) e\u2081 \u27e9\n  f (e e\u2081 + e e\u2082) \u220e\n  where e = eval-expr\n        ec = eval-expr-cont'\n        f' = \u03bb n2 \u2192 ec e\u2081 $ f \u2218 (_+ n2)\n\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct = eval-expr-cont-correct' id\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrun++ : \u2200 a b s \u2192 run (a ++ b) s \u2261 run b (run a s)\nrun++ [] b s = refl\nrun++ (push x \u2237 a) b s = run++ a b (x \u2237 s)\nrun++ (add \u2237 a) b [] = run++ a b []\nrun++ (add \u2237 a) b (x \u2237 []) = run++ a b (x \u2237 [])\nrun++ (add \u2237 a) b (a1 \u2237 a2 \u2237 s) = run++ a b (a1 + a2 \u2237 s)\n\ncompile-correct' : \u2200 s e \u2192 run (compile e) s \u2261 eval-expr e \u2237 s\ncompile-correct' s (const x) = refl\ncompile-correct' s (plus e\u2081 e\u2082) = begin\n  run (c\u2081 ++ c\u2082 ++ [ add ]) s \u2261\u27e8 run++ c\u2081 (c\u2082 ++ [ add ]) s \u27e9\n  run (c\u2082 ++ [ add ]) (run c\u2081 s) \u2261\u27e8 cong (run (c\u2082 ++ [ add ])) $ compile-correct' s e\u2081 \u27e9\n  run (c\u2082 ++ [ add ]) (n\u2081 \u2237 s) \u2261\u27e8 run++ c\u2082 [ add ] (n\u2081 \u2237 s) \u27e9\n  run [ add ] (run c\u2082 (n\u2081 \u2237 s)) \u2261\u27e8 cong (run [ add ]) $ compile-correct' (n\u2081 \u2237 s) e\u2082 \u27e9\n  run [ add ] (n\u2082 \u2237 n\u2081 \u2237 s) \u2261\u27e8 cong (_\u2237 s) $ +-comm n\u2082 n\u2081 \u27e9\n  n\u2081 + n\u2082 \u2237 s \u220e\n  where c\u2081 = compile e\u2081\n        c\u2082 = compile e\u2082\n        n\u2081 = eval-expr e\u2081\n        n\u2082 = eval-expr e\u2082\n\ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct = compile-correct' []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":261,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Properties\nopen import Data.List.Properties\nopen import Preloaded\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Data.Nat public\nopen import Data.List public\n\ndata Expr : Set where\n  const : \u2115 \u2192 Expr\n  plus : Expr \u2192 Expr \u2192 Expr\n\neval-expr : Expr \u2192 \u2115\neval-expr (const n) = n\neval-expr (plus e1 e2) = eval-expr e1 + eval-expr e2\n\neval-expr-tail' : Expr \u2192 \u2115 \u2192 \u2115\neval-expr-tail' (const n) acc = n + acc\neval-expr-tail' (plus e1 e2) acc = eval-expr-tail' e2 (eval-expr-tail' e1 acc)\n\neval-expr-tail : Expr \u2192 \u2115\neval-expr-tail e = eval-expr-tail' e 0\n\neval-expr-cont' : {A : Set} \u2192 Expr \u2192 (\u2115 \u2192 A) \u2192 A\neval-expr-cont' (const n) k = k n\neval-expr-cont' (plus e1 e2) k = eval-expr-cont' e2 \u03bb n2 \u2192\n                                 eval-expr-cont' e1 \u03bb n1 \u2192 k (n1 + n2)\n\neval-expr-cont : Expr \u2192 \u2115\neval-expr-cont e = eval-expr-cont' e (\u03bb n \u2192 n)\n\ndata Instr : Set where\n  push : \u2115 \u2192 Instr\n  add : Instr\n\nProg = List Instr\n\nStack = List \u2115\n\nrun : Prog \u2192 Stack \u2192 Stack\nrun [] s = s\nrun (push n \u2237 p) s = run p (n \u2237 s)\nrun (add \u2237 p) (a1 \u2237 a2 \u2237 s) = run p (a1 + a2 \u2237 s)\nrun (add \u2237 p) s = run p s\n\ncompile : Expr \u2192 Prog\ncompile (const n) = push n \u2237 []\ncompile (plus e1 e2) = compile e1 ++ compile e2 ++ add \u2237 []\n\n-}\n\n-- Task 1 - 1. Prove that eval-expr-tail is equivalent to eval-expr.\nlemma\u2081 : \u2200 e acc \u2192 eval-expr-tail' e acc \u2261 eval-expr e + acc\nlemma\u2081 (const x) acc = refl\nlemma\u2081 (plus e e\u2081) acc\n  rewrite lemma\u2081 e acc\n        | lemma\u2081 e\u2081 (eval-expr e + acc)\n        | sym (+-assoc (eval-expr e\u2081) (eval-expr e) acc)\n        | +-comm (eval-expr e) (eval-expr e\u2081) = refl\n\neval-expr-tail-correct : \u2200 e \u2192 eval-expr-tail e \u2261 eval-expr e\neval-expr-tail-correct e rewrite lemma\u2081 e 0 = +-identity\u02b3 (eval-expr e) \n\n-- Task 1 - 2. Prove that eval-expr-cont is equivalent to eval-expr.\n\nlemma\u2082 : \u2200 e (k : \u2115 \u2192 \u2115) \u2192 eval-expr-cont' e k \u2261 k (eval-expr e)\nlemma\u2082 (const x) k = refl\nlemma\u2082 (plus e e\u2081) k\n  rewrite lemma\u2082 e\u2081 (\u03bb n2 \u2192 eval-expr-cont' e (\u03bb n1 \u2192 k (n1 + n2)))\n        | lemma\u2082 e (\u03bb n1 \u2192 k (n1 + eval-expr e\u2081)) = refl\n\neval-expr-cont-correct : \u2200 e \u2192 eval-expr-cont e \u2261 eval-expr e\neval-expr-cont-correct e rewrite lemma\u2082 e (\u03bb x \u2192 x) = refl\n\n-- Task 2. Prove that you get the expected result when you compile and run the program.\n\nrun-dist-++ : \u2200 p\u2081 p\u2082 s \u2192 run (p\u2081 ++ p\u2082) s \u2261 run p\u2082 (run p\u2081 s)\nrun-dist-++ [] [] s = refl\nrun-dist-++ [] (x \u2237 p\u2082) s = refl\nrun-dist-++ (x \u2237 p\u2081) [] s rewrite ++-identity\u02b3 (x \u2237 p\u2081) = refl\nrun-dist-++ (push x \u2237 p\u2081) (x\u2082 \u2237 p\u2082) s = run-dist-++ p\u2081 (x\u2082 \u2237 p\u2082) (x \u2237 s)\nrun-dist-++ (add \u2237 p\u2081) (x\u2082 \u2237 p\u2082) [] = run-dist-++ p\u2081 (x\u2082 \u2237 p\u2082) []\nrun-dist-++ (add \u2237 p\u2081) (x\u2082 \u2237 p\u2082) (z \u2237 []) = run-dist-++ p\u2081 (x\u2082 \u2237 p\u2082) (z \u2237 [])\nrun-dist-++ (add \u2237 p\u2081) (x\u2082 \u2237 p\u2082) (x \u2237 x\u2081 \u2237 s) = run-dist-++ p\u2081 (x\u2082 \u2237 p\u2082) (x + x\u2081 \u2237 s)\n\nlemma\u2083 : \u2200 e s \u2192 run (compile e) s \u2261 eval-expr e \u2237 s\nlemma\u2083 (const x) s = refl\nlemma\u2083 (plus e e\u2081) s\n  rewrite run-dist-++ (compile e) (compile e\u2081 ++ add \u2237 []) s\n        | run-dist-++ (compile e\u2081) (add \u2237 []) (run (compile e) s)\n        | lemma\u2083 e s\n        | lemma\u2083 e\u2081 (eval-expr e \u2237 s)\n        | +-comm (eval-expr e) (eval-expr e\u2081) = refl\n  \ncompile-correct : \u2200 e \u2192 run (compile e) [] \u2261 eval-expr e \u2237 []\ncompile-correct e = lemma\u2083 e []\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5cc29e3128b420000c85cc19":[{"id":262,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\n\nopen import Data.Nat\nopen import Data.Vec\n\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Relation.Nullary.Negation \nimport Data.List\nopen import Data.Product renaming (_\u00d7_ to _\u2227_ ; proj\u2081 to fst ; proj\u2082 to snd)\nopen import Data.Sum renaming (_\u228e_ to _\u2228_ ; inj\u2081 to orLeft ; inj\u2082 to orRight)\n\nopen import Data.Bool renaming (_\u2228_ to _\u2228\u1d47_ ; _\u2227_ to _\u2227\u1d47_ )\nopen import Data.Bool.Properties\n\n\nnot-injective : \u2200 {x y} \u2192 not x \u2261 not y \u2192 x \u2261 y\nnot-injective {false} {false} nx\u2262ny = refl\nnot-injective {true}  {true}  nx\u2262ny = refl\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\n\neven : \u2115 \u2192 Bool\neven 0 = true\neven (suc n) = not (even n)\n\nEM = (A : Set) \u2192 A \u228e \u00ac A\n\nLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n \u2192 f n \u2261 false) \u228e (\u2203 \u03bb n \u2192 f n \u2261 true)\n\nLLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u228e f m \u2261 false) \u2192\n  (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n\n-}\n\n\nnotExists\u21d2All : (f : \u2115 \u2192 Bool) \u2192 \u00ac (\u2203 \u03bb n \u2192 f n \u2261 true) \u2192 (\u2200 n \u2192 f n \u2261 false)\nnotExists\u21d2All f ne = helper\n    where   helper : (n : \u2115) \u2192 f n \u2261 false\n            helper n with f n | inspect f n\n            helper n | false | [ ifn ] = refl\n            helper n | true | [ ifn ] = contradiction (n , ifn) ne\n\nallOtherFalse : (f : \u2115 \u2192 Bool) \u2192 \n                (index : \u2115) \u2192 \n                (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u2228 f m \u2261 false) \u2192 \n                f index \u2261 true \u2192 \n                (\u2200 x \u2192 x \u2262 index \u2192 f x \u2261 false)\nallOtherFalse f index step fIndexTrue x x\u2262index with step x index x\u2262index\nallOtherFalse f index step fIndexTrue x x\u2262index | orLeft fxFalse = fxFalse\nallOtherFalse f index step fIndexTrue x x\u2262index | orRight fIndexFalse = contradiction fIndexTrue (not-\u00ac fIndexFalse)\n\nn\u2262m\u21d2sn\u2262sm : {n m : \u2115} \u2192 n \u2262 m \u2192 suc n \u2262 suc m\nn\u2262m\u21d2sn\u2262sm {n} {m} neq seq = contradiction (suc-injective seq) neq\n\nodd\u2262even : {n m : \u2115} {b : Bool} \u2192 even n \u2261 b \u2192 even m \u2261 not b \u2192 n \u2262 m\nodd\u2262even {zero} {zero} {.true} refl ()\nodd\u2262even {zero} {suc m} {.true} refl em = \u03bb ()\nodd\u2262even {suc n} {zero} {.(not (even n))} refl em = \u03bb ()\nodd\u2262even {suc n} {suc m} {.(not (even n))} refl em = n\u2262m\u21d2sn\u2262sm (odd\u2262even {n} {m} refl (not-injective em))\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em = helper\n    where   helper : (f : \u2115 \u2192 Bool) \u2192 (\u2200 n \u2192 f n \u2261 false) \u2228 (\u2203 \u03bb n \u2192 f n \u2261 true)\n            helper f with em (\u2203 \u03bb n \u2192 f n \u2261 true)\n            helper f | orLeft eTrue = orRight eTrue\n            helper f | orRight \u00aceTrue = orLeft (notExists\u21d2All f \u00aceTrue)\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo = helper\n    where   helper : (f : \u2115 \u2192 Bool) \u2192 (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u2228 f m \u2261 false) \u2192\n                    (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u2228 (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n            helper f n\u2228m\u2261false with lpo f\n            helper f n\u2228m\u2261false | orLeft allFalse = orLeft (\u03bb n \u2192 \u03bb peq \u2192 allFalse n)\n            helper f n\u2228m\u2261false | orRight (trueIndex , trueProof) with even trueIndex | inspect even trueIndex\n            helper f n\u2228m\u2261false | orRight (trueIndex , trueProof) | false | [ iti ] = \n                orLeft \u03bb n \u2192 \u03bb evenN \u2192 allOtherFalse f trueIndex n\u2228m\u2261false trueProof n (odd\u2262even evenN iti)\n            helper f n\u2228m\u2261false | orRight (trueIndex , trueProof) | true | [ iti ] = \n                orRight \u03bb n \u2192 \u03bb oddN \u2192 allOtherFalse f trueIndex n\u2228m\u2261false trueProof n (odd\u2262even oddN iti)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":263,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Empty\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Bool.Properties\nopen import Data.Nat\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\n\neven : \u2115 \u2192 Bool\neven 0 = true\neven (suc n) = not (even n)\n\nEM = (A : Set) \u2192 A \u228e \u00ac A\n\nLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n \u2192 f n \u2261 false) \u228e (\u2203 \u03bb n \u2192 f n \u2261 true)\n\nLLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u228e f m \u2261 false) \u2192\n  (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n\n-}\n\n-- lemmas \n\nfalse-or-true : \u2200 b \u2192 b \u2261 true \u228e b \u2261 false \nfalse-or-true false = inj\u2082 refl\nfalse-or-true true = inj\u2081 refl\n\nfromInj\u2081 : \u2200 {A B : Set} \u2192 (B \u2192 A) \u2192 A \u228e B \u2192 A\nfromInj\u2081 = [ (\u03bb z \u2192 z) ,_]\u2032\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO hem f = [ (\u03bb h \u2192 inj\u2082 h) , \n  (\u03bb h \u2192 inj\u2081 \u03bb n \u2192 [ (\u03bb z \u2192 \u22a5-elim (h (n , z))) , (\u03bb z \u2192 z) ]\u2032 \n    (false-or-true (f n)))]\u2032 \n  (hem ((\u2203 \u03bb n \u2192 f n \u2261 true)))\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO hlpo f h = [ (\u03bb h' \u2192 inj\u2081 (\u03bb n _ \u2192 h' n)) , \n  (\u03bb h' \u2192 [ (\u03bb hef \u2192 inj\u2082 (\u03bb n hen \u2192 fromInj\u2081 \n    (\u03bb x \u2192 \u22a5-elim (not-\u00ac x (proj\u2082 h'))) \n      (h n (proj\u2081 h') \u03bb x \u2192 not-\u00ac refl (trans (sym hef) \n      (trans (cong even (sym x)) hen))))) \n    , (\u03bb hef \u2192 inj\u2081 (\u03bb n hen \u2192 fromInj\u2081 \n      (\u03bb x \u2192 \u22a5-elim (not-\u00ac x (proj\u2082 h'))) \n      (h n (proj\u2081 h') (\u03bb x \u2192 not-\u00ac refl (trans (sym hef) \n      (trans (cong even (sym x)) hen)))))) ]\u2032 \n    (false-or-true (even (proj\u2081 h')))) ]\u2032 \n  (hlpo f)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":264,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality hiding ( [_] )\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\nopen import Data.Empty\n\nexists-neg : {A : Set} {P : A \u2192 Set} \u2192 (\u00ac \u2203 (\u03bb x \u2192 P x)) \u2192 (\u2200 (x : A) \u2192 \u00ac P x)\nexists-neg \u00acex_p x Px = \u00acex_p (x , Px)\n\nnot-true-is-false : {x : Bool} \u2192 \u00ac (x \u2261 true) \u2192 x \u2261 false\nnot-true-is-false {false} = \u03bb _ \u2192 refl\nnot-true-is-false {true} = \u03bb x \u2192 \u22a5-elim (x refl)\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f = Data.Sum.map\u2081 (\u03bb ex m \u2192 not-true-is-false (exists-neg ex m)) (Data.Sum.swap (em (\u2203 (\u03bb n \u2192 f n \u2261 true))))\n\neven-or-odd : (x : \u2115) \u2192 even x \u2261 true \u228e even x \u2261 false\neven-or-odd zero = inj\u2081 refl\neven-or-odd (suc x) with (even x)\n... | true = inj\u2082 refl\n... | false = inj\u2081 refl\n\ntrue-false-contra : {x : Bool} \u2192 x \u2261 true \u2192 x \u2261 false \u2192 \u22a5\ntrue-false-contra x-true x-false with trans (sym x-true) x-false\n... | ()\n\neven-is-not-odd : (x y : \u2115) \u2192 even x \u2261 true \u2192 even y \u2261 false \u2192 x \u2262 y\neven-is-not-odd x y even-x odd-y x\u2261y rewrite x\u2261y = \u22a5-elim (true-false-contra even-x odd-y)\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f atmost-one-true = \n  [ (\u03bb all-false \u2192 inj\u2081 \u03bb n x \u2192 all-false n) , g ] (lpo f)\n  where \n    g : (\u2203 (\u03bb n \u2192 f n \u2261 true)) \u2192 ((n : \u2115) \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e ((n : \u2115) \u2192 even n \u2261 false \u2192 f n \u2261 false)\n    g (x , fx-true) with (even-or-odd x)\n    ... | inj\u2081 x-is-even = inj\u2082 \u03bb y y-odd \u2192 [ (\u03bb fx-false \u2192 \u22a5-elim (true-false-contra fx-true fx-false)) , (\u03bb x \u2192 x) ] (atmost-one-true x y (even-is-not-odd x y x-is-even y-odd))\n    ... | inj\u2082 x-is-odd = inj\u2081 \u03bb y y-even \u2192 [ (\u03bb x \u2192 x) , (\u03bb fx-false \u2192 \u22a5-elim (true-false-contra fx-true fx-false) ) ] (atmost-one-true y x (even-is-not-odd y x y-even x-is-odd)) \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":265,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Bool\nopen import Data.Bool.Properties\nopen import Data.Product\nopen import Data.Sum\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation\nopen import Relation.Binary.PropositionalEquality\n\nopen import Preloaded\n\neven\u2262odd : \u2200 {m n} \u2192 even m \u2261 true \u2192 even n \u2261 false \u2192 m \u2262 n\neven\u2262odd em on refl = not-\u00ac em on\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f with em (\u2203 \u03bb n \u2192 f n \u2261 true)\n...            | inj\u2081  \u2203n = inj\u2082 \u2203n\n...            | inj\u2082 \u00ac\u2203n = inj\u2081 \u03bb n \u2192 \u00ac-not \u03bb fn \u2192 \u00ac\u2203n (n , fn)\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f h\n  with lpo f\n...  | inj\u2081 \u00acf = inj\u2081 (\u03bb n _ \u2192 \u00acf n)\n...  | inj\u2082 (n , fn)\n         with even n \u225f true\n...         | yes en = inj\u2082 \u00acf-odd\n                where\n                \u00acf-odd : \u2200 m \u2192 even m \u2261 false \u2192 f m \u2261 false\n                \u00acf-odd m om with h n m (even\u2262odd en om)\n                ...            | inj\u2081 \u00acfn = contradiction fn (not-\u00ac \u00acfn)\n                ...            | inj\u2082 \u00acfm = \u00acfm\n...         | no \u00acen = inj\u2081 \u00acf-even\n                where\n                \u00acf-even : \u2200 m \u2192 even m \u2261 true \u2192 f m \u2261 false\n                \u00acf-even m em with h m n (even\u2262odd em (\u00ac-not \u00acen))\n                ...             | inj\u2081 \u00acfm = \u00acfm\n                ...             | inj\u2082 \u00acfn = contradiction fn (not-\u00ac \u00acfn)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":266,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\nopen import Data.Empty\nopen import Agda.Builtin.Sigma\n\nopen import Preloaded\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\n\neven : \u2115 \u2192 Bool\neven 0 = true\neven (suc n) = not (even n)\n\nEM = (A : Set) \u2192 A \u228e \u00ac A\n\nLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n \u2192 f n \u2261 false) \u228e (\u2203 \u03bb n \u2192 f n \u2261 true)\n\nLLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u228e f m \u2261 false) \u2192\n  (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n\n-}\n\ndec-even : \u2200 n \u2192 (even n \u2261 true) \u228e (even n \u2261 false)\ndec-even 0 = inj\u2081 refl\ndec-even (suc n) with dec-even n\n...                 | inj\u2081 p = inj\u2082 (cong not p)\n...                 | inj\u2082 p = inj\u2081 (cong not p)\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f with em (\u2203 \u03bb n \u2192 f n \u2261 true)\n...             | inj\u2081 p = inj\u2082 p\n...             | inj\u2082 bot = inj\u2081 (\u03bb n \u2192 c (f n) n refl)\n                    where c : \u2200 b n \u2192 f n \u2261 b \u2192 f n \u2261 false\n                          c false n p = p\n                          c true n p = \u22a5-elim (bot (n , p))\n\nmodule Solver (f : \u2115 \u2192 Bool) (pr : \u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u228e f m \u2261 false) (n : \u2115) (N : f n \u2261 true) where\n  lemma : \u2200 m \u2192 n \u2262  m \u2192 f m \u2261 false\n  lemma m negeq with pr n m negeq\n  ...              | inj\u2081 nfalse with trans (sym N) nfalse\n  ...                               | ()\n  lemma m negeq    | inj\u2082 mfalse = mfalse\n  for-even-n-true : (even n \u2261 true) \u2192 (\u2200 m \u2192 even m \u2261 false \u2192 f m \u2261 false)\n  for-even-n-true evenntrue = seq\n    where nonsense : \u2200 m \u2192 even m \u2261 false \u2192 n \u2262  m\n          nonsense m evenmfalse refl with trans (sym evenmfalse) evenntrue\n          ...                                   | ()\n          seq : \u2200 m \u2192 even m \u2261 false \u2192 f m \u2261 false\n          seq m evenmfalse = lemma m (nonsense m evenmfalse)\n  for-even-n-false : (even n \u2261 false) \u2192 (\u2200 m \u2192 even m \u2261 true \u2192 f m \u2261 false)\n  for-even-n-false evennfalse = seq\n    where nonsense : \u2200 m \u2192 even m \u2261 true \u2192 n \u2262  m\n          nonsense m evenmtrue refl with trans (sym evenmtrue) evennfalse\n          ...                                   | ()\n          seq : \u2200 m \u2192 even m \u2261 true \u2192 f m \u2261 false\n          seq m evenmtrue = lemma m (nonsense m evenmtrue)\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f pr with lpo f\n...                   | inj\u2081 p = inj\u2081 (\u03bb n _ \u2192 p n)\n...                   | inj\u2082 (n , N) with dec-even n\n...                                     | inj\u2081 ttrue = inj\u2082 (Solver.for-even-n-true f pr n N ttrue)\n...                                     | inj\u2082 ffalse = inj\u2081 (Solver.for-even-n-false f pr n N ffalse)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":267,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\n\nopen import Relation.Binary.PropositionalEquality\nopen import Function\nopen import Data.Empty\nopen import Data.Sum\nopen import Data.Product renaming (_,_ to _,,_)\nopen import Data.Bool\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f with em $ \u2203[ n ] (f n \u2261 true)\n... | inj\u2081 exists = inj\u2082 exists\n... | inj\u2082 none-true = inj\u2081 all-false\n  where all-false : \u2200 n \u2192 f n \u2261 false\n        all-false n with f n | inspect f n\n        ... | false | _ = refl\n        ... | true | [ fn\u2261true ] = \u22a5-elim $ none-true (n ,, fn\u2261true)\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f one-true with lpo f\n... | inj\u2081 all-false = inj\u2081 \u03bb n _ \u2192 all-false n\n... | inj\u2082 (n ,, fn\u2261t) with even n | inspect even n\n... | false | [ en\u2261f ] =\n  inj\u2081 \u03bb m em\u2261t \u2192 [ id , (\u03bb fn\u2261f \u2192 case trans (sym fn\u2261f) fn\u2261t of \u03bb()) ] $\n                  one-true m n \u03bb { refl \u2192\n                  case trans (sym em\u2261t) en\u2261f of \u03bb() }\n... | true | [ en\u2261t ] =\n  inj\u2082 \u03bb m em\u2261f \u2192 [ id , (\u03bb fn\u2261f \u2192 case trans (sym fn\u2261f) fn\u2261t of \u03bb()) ] $\n                  one-true m n \u03bb { refl \u2192\n                  case trans (sym em\u2261f) en\u2261t of \u03bb() }\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":268,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\nopen import Data.Empty using (\u22a5; \u22a5-elim)\nopen import Data.Bool.Properties using (\u00ac-not; not-\u00ac)\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\n\neven : \u2115 \u2192 Bool\neven 0 = true\neven (suc n) = not (even n)\n\nEM = (A : Set) \u2192 A \u228e \u00ac A\n\nLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n \u2192 f n \u2261 false) \u228e (\u2203 \u03bb n \u2192 f n \u2261 true)\n\nLLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u228e f m \u2261 false) \u2192\n  (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n\n-}\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f with em (\u2203 \u03bb n \u2192 f n \u2261 true)\n... | inj\u2081 x = inj\u2082 x\n... | inj\u2082 y = inj\u2081 (lemma y)\n  where\n    lemma : \u00ac (\u03a3 \u2115 (\u03bb n \u2192 f n \u2261 true)) \u2192 (\u2200 (n : \u2115) \u2192 f n \u2261 false)\n    lemma g n with f n Data.Bool.\u225f true\n    ... | yes fn\u2261true = \u22a5-elim (g (n , fn\u2261true))\n    ... | no fn\u2261false = \u00ac-not fn\u2261false\n\n\u228e-inj\u2081 : \u2200 {A B : Set} \u2192 A \u228e B \u2192 \u00ac A \u2192 B\n\u228e-inj\u2081 (inj\u2081 A) \u00acA = \u22a5-elim (\u00acA A)\n\u228e-inj\u2081 (inj\u2082 B) \u00acA = B\n\neven-injective : \u2200 (m n : \u2115) \u2192 even m \u2262 even n \u2192 m \u2262 n\neven-injective zero zero en\u2262em = \u03bb _ \u2192 en\u2262em refl\neven-injective zero (suc n) en\u2262em = \u03bb ()\neven-injective (suc m) zero en\u2262em = \u03bb ()\neven-injective (suc m) (suc .m) en\u2262em refl = en\u2262em refl\n\na\u2262b : \u2200 {a b : Bool} \u2192 a \u2261 true \u2192 b \u2261 false \u2192 a \u2262 b\na\u2262b refl refl = \u03bb ()\n\na\u2262b-rev : \u2200 {a b : Bool} \u2192 a \u2261 false \u2192 b \u2261 true \u2192 a \u2262 b\na\u2262b-rev refl refl = \u03bb ()\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f fn with lpo f\n... | inj\u2081 fn\u2261false = inj\u2081 (\u03bb n en \u2192 fn\u2261false n)\n... | inj\u2082 (n , fn\u2261true) with even n Data.Bool.\u225f true\n... | yes en\u2261true = inj\u2082 \u03bb m em\u2261false \u2192 \u228e-inj\u2081 (fn n m (even-injective n m (a\u2262b en\u2261true em\u2261false))) (not-\u00ac fn\u2261true)\n... | no en\u2262true = inj\u2081 \u03bb m em\u2261true \u2192 \u228e-inj\u2081 (fn n m (even-injective n m (a\u2262b-rev (\u00ac-not en\u2262true) em\u2261true))) (not-\u00ac fn\u2261true)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":269,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\nopen import Data.Product\nopen import Data.Bool\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Empty\n\nopen import Preloaded\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f with em (\u2203 \u03bb n \u2192 f n \u2261 true)\n... | inj\u2081 a = inj\u2082 a\n... | inj\u2082 b = inj\u2081 g\n  where\n    g : \u2200 (n : \u2115) \u2192 f n \u2261 false\n    g n with f n | inspect f n\n    ... | false | _ = refl\n    ... | true | [ p ] with b (n , p)\n    ... | ()\n\nlemma : \u2200 {a b} \u2192 a \u2261 true \u2192 a \u2261 false \u228e b \u2261 false \u2192 b \u2261 false\nlemma refl (inj\u2081 ())\nlemma _ (inj\u2082 a) = a\n\nlemma2 : true \u2261 false \u2192 \u22a5\nlemma2 ()\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f uniq with lpo f\n... | inj\u2081 a = inj\u2082 \u03bb x _ \u2192 a x\n... | inj\u2082 (n , p) with even n | inspect even n\n...                | true  | [ pp ] = inj\u2082 \u03bb n' p' \u2192 lemma p (uniq n n' \u03bb eq \u2192 lemma2 (trans (sym pp) (trans (cong even eq) p')))\n...                | false | [ pp ] = inj\u2081 \u03bb n' p' \u2192 lemma p (uniq n n' \u03bb eq \u2192 lemma2 (sym (trans (sym pp) (trans (cong even eq) p'))))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":270,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule Solution where\n\nopen import Data.Bool using (Bool; true; false; not)\nopen import Data.Bool.Properties using (not-involutive; not-\u00ac; \u00ac-not)\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.Nat using (\u2115; zero; suc; _+_; _*_)\nopen import Data.Nat.Properties using (+-suc; *-identity\u02e1)\nopen import Data.Product using (_,_; \u2203-syntax)\nopen import Data.Sum using (inj\u2081; inj\u2082; [_,_]; swap; map\u2081)\nopen import Function using (_\u2218_; _$_)\nopen import Relation.Nullary using (\u00ac_)\nopen import Relation.Nullary.Negation using (\u00ac\u2203\u27f6\u2200\u00ac)\n\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq using (_\u2261_; _\u2262_; cong; refl; sym; trans)\nopen Eq.\u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\n\nopen import Preloaded\n\n{- Preloaded:\n\n{-# OPTIONS --safe #-}\nmodule Preloaded where\n\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Sum\nopen import Data.Product\nopen import Data.Bool\nopen import Data.Nat\n\neven : \u2115 \u2192 Bool\neven 0 = true\neven (suc n) = not (even n)\n\nEM = (A : Set) \u2192 A \u228e \u00ac A\n\nLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n \u2192 f n \u2261 false) \u228e (\u2203 \u03bb n \u2192 f n \u2261 true)\n\nLLPO = (f : \u2115 \u2192 Bool) \u2192 (\u2200 n m \u2192 n \u2262 m \u2192 f n \u2261 false \u228e f m \u2261 false) \u2192\n  (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n\n-}\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f = map\u2081 lemma $ swap $ em $ \u2203[ n ] (f n \u2261 true)\n  where lemma : \u00ac \u2203[ n ] (f n \u2261 true) \u2192 \u2200 n \u2192 f n \u2261 false\n        lemma \u00ace = \u00ac-not \u2218 \u00ac\u2203\u27f6\u2200\u00ac \u00ace\n\nprivate\n  2*n\u2261n+n : (n : \u2115) \u2192 2 * n \u2261 n + n\n  2*n\u2261n+n n = begin\n    2 * n               \u2261\u27e8\u27e9\n    n + 1 * n           \u2261\u27e8 cong (n +_) (*-identity\u02e1 n) \u27e9\n    n + n               \u220e\n  \n  2*suc[n]\u2261suc[suc[2*n]] : (n : \u2115) \u2192 2 * suc n \u2261 suc (suc (2 * n))\n  2*suc[n]\u2261suc[suc[2*n]] n = begin\n    2 * suc n                     \u2261\u27e8 2*n\u2261n+n (suc n) \u27e9\n    suc n + suc n                 \u2261\u27e8 +-suc (suc n) n \u27e9\n    suc (suc (n + n))             \u2261\u27e8 sym (cong (suc \u2218 suc) (2*n\u2261n+n n)) \u27e9\n    suc (suc (2 * n))             \u220e\n\n  even[2*n] : \u2200 n \u2192 even (2 * n) \u2261 true\n  even[2*n] zero = refl\n  even[2*n] (suc n) = begin\n    even (2 * (suc n))            \u2261\u27e8 cong even (2*suc[n]\u2261suc[suc[2*n]] n) \u27e9\n    even (suc (suc (2 * n)))      \u2261\u27e8\u27e9\n    not (even (suc (2 * n)))      \u2261\u27e8\u27e9\n    not (not (even (2 * n)))      \u2261\u27e8 not-involutive (even (2 * n)) \u27e9\n    even (2 * n)                  \u2261\u27e8 even[2*n] n \u27e9\n    true                          \u220e\n\n  odd[1+2*n] : \u2200 n \u2192 even (1 + 2 * n) \u2261 false\n  odd[1+2*n] n = cong not (even[2*n] n)\n\n  even[n]\u21d2n\u22612*m : \u2200 n \u2192 even n \u2261 true \u2192 \u2203[ m ] (n \u2261 2 * m)\n  even[n]\u21d2n\u22612*m zero refl = (zero , refl)\n  even[n]\u21d2n\u22612*m (suc zero) ()\n  even[n]\u21d2n\u22612*m (suc (suc n)) e\n    with even[n]\u21d2n\u22612*m n (trans (sym (not-involutive (even n))) e)\n  ...  | (m , n\u22612*m) = (suc m , suc[e])\n                        where suc[e] : suc (suc n) \u2261 2 * (suc m)\n                              suc[e] = begin\n                                suc (suc n)         \u2261\u27e8 cong (suc \u2218 suc) n\u22612*m \u27e9\n                                suc (suc (2 * m))   \u2261\u27e8 sym (2*suc[n]\u2261suc[suc[2*n]] m) \u27e9\n                                2 * suc m           \u220e\n    \n  odd[n]\u21d2n\u22611+2*m : \u2200 n \u2192 even n \u2261 false \u2192 \u2203[ m ] (n \u2261 1 + 2 * m)\n  odd[n]\u21d2n\u22611+2*m zero ()\n  odd[n]\u21d2n\u22611+2*m (suc n) e\n    with even[n]\u21d2n\u22612*m n (trans (sym (not-involutive (even n))) (cong not e))\n  ...  | (m , n\u22612*m) = (m , cong suc n\u22612*m)\n\n  even\u2262odd : \u2200 n m \u2192 even n \u2261 true \u2192 even m \u2261 false \u2192 n \u2262 m\n  even\u2262odd n m e \u00ace n\u2261m = not-\u00ac (trans (cong even n\u2261m) \u00ace) e\n\n  lemma-even : {f : \u2115 \u2192 Bool} {b : Bool} \u2192 (\u2200 n \u2192 f (2 * n) \u2261 b) \u2192 (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 b)\n  lemma-even {f} p n e\n    with even[n]\u21d2n\u22612*m n e\n  ...  | (m , n\u22612*m) = trans (cong f n\u22612*m) (p m)\n  \n  lemma-odd : {f : \u2115 \u2192 Bool} {b : Bool} \u2192 (\u2200 n \u2192 f (1 + 2 * n) \u2261 b) \u2192 (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 b)\n  lemma-odd {f} p n e\n    with odd[n]\u21d2n\u22611+2*m n e\n  ...  | (m , n\u22611+2*m) = trans (cong f n\u22611+2*m) (p m)\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f h\n  with lpo (f \u2218 (2 *_)) | lpo (f \u2218 suc \u2218 (2 *_))\n...  | inj\u2081 p           | _               = inj\u2081 (lemma-even p)\n...  | _                | inj\u2081 q          = inj\u2082 (lemma-odd q)\n...  | inj\u2082 (n\u2081 , ev\u2081)  | inj\u2082 (n\u2082 , ev\u2082) = \u22a5-elim\n                                          $ [ not-\u00ac ev\u2081 , not-\u00ac ev\u2082 ]\n                                          $ h (2 * n\u2081) (1 + 2 * n\u2082)\n                                          $ even\u2262odd (2 * n\u2081) (1 + 2 * n\u2082) (even[2*n] n\u2081) (odd[1+2*n] n\u2082)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":271,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Relation.Nullary.Negation\nopen import Data.Empty\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Sum\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\n\nprove-lpo : EM \u2192 (f : \u2115 \u2192 Bool) \u2192 \u00ac (\u2203 \u03bb n \u2192 f n \u2261 true) \u2192 \u2200 (n : \u2115) \u2192  f n \u2261 false\nprove-lpo em f notrue n with f n | inspect f n\n... | false | _ = refl\n... | true  | [ p ] = \u22a5-elim (notrue (n , p))\n\nEM\u21d2LPO : EM \u2192 LPO\nEM\u21d2LPO em f with (em (\u2203 \u03bb n \u2192 f n \u2261 true))\n... | inj\u2081 proof-existence = inj\u2082 proof-existence\n... | inj\u2082 proof-notrue = inj\u2081 (prove-lpo em f proof-notrue)\n\nsuc-is-not-equal : (x : \u2115) \u2192 x \u2262 (suc x)\nsuc-is-not-equal x ()\n\nbottom-bool : {b : Bool} \u2192 b \u2261 true \u2192 b \u2261 false \u2192 \u22a5\nbottom-bool refl ()\n\npdiff : (n m : \u2115) \u2192 even n \u2261 true \u2192 even m \u2261 false \u2192 n \u2262 m\npdiff n m p1 p2 refl = bottom-bool p1 p2 \n\npdiff2 : (n m : \u2115) \u2192 even n \u2261 false \u2192 even m \u2261 true \u2192 n \u2262 m\npdiff2 n m p1 p2 refl = bottom-bool p2 p1\n\naway-disjunction : {A B : Set} \u2192 A \u228e B \u2192 \u00ac A \u2192 B\naway-disjunction p n with p\n... | inj\u2081 a = contradiction a n\n... | inj\u2082 b = b\n\nLPO\u21d2LLPO : LPO \u2192 LLPO\nLPO\u21d2LLPO lpo f proof-falses with lpo f\n... | inj\u2081 all-false = inj\u2081 \u03bb n _ \u2192 all-false n\n... | inj\u2082 (x , x-truth) = prove-llpo x x-truth\n  where\n  prove-llpo : (x : \u2115) \u2192 (f x \u2261 true) \u2192 (\u2200 n \u2192 even n \u2261 true \u2192 f n \u2261 false) \u228e (\u2200 n \u2192 even n \u2261 false \u2192 f n \u2261 false)\n  prove-llpo x x-truth with proof-falses x (suc x) (suc-is-not-equal x)\n  ... | inj\u2081 x-lie = \u22a5-elim (bottom-bool x-truth x-lie)\n  ... | inj\u2082 n-lie with even x | inspect even x\n  ... | true  | [ x-even ] = inj\u2082 \u03bb n n-odd  \u2192 away-disjunction (proof-falses x n (pdiff  x n x-even n-odd)) (bottom-bool x-truth) \n  ... | false | [ x-odd  ] = inj\u2081 \u03bb n n-even \u2192 away-disjunction (proof-falses x n (pdiff2 x n x-odd n-even)) (bottom-bool x-truth)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5cc47f8c4b8fea001de6d226":[{"id":272,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = diff-mult zero 30 30 30-mult 30-mult refl\nmult-imp-mult' (SSS-mult n p) =\n  sum-mult 3 n\n    (diff-mult 3 60 63\n     (sum-mult 30 30 30-mult 30-mult)\n     (sum-mult 21 42 21-mult\n      (sum-mult 21 21 21-mult 21-mult))\n      refl)\n    (mult-imp-mult' p)\n\nmult-over-sum : {n m : \u2115} \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nmult-over-sum 0-mult q = q\nmult-over-sum (SSS-mult _ p) q = SSS-mult _ (mult-over-sum p q)\n\nmult-over-diff : {l n : \u2115} \u2192 Mult3 n \u2192 Mult3 (n + l) \u2192 Mult3 l\nmult-over-diff 0-mult q = q\nmult-over-diff (SSS-mult _ p) (SSS-mult _ q) = mult-over-diff p q\n\nnormal-human-mult : (n : \u2115) \u2192 Mult3 (n * 3)\nnormal-human-mult zero = 0-mult\nnormal-human-mult (suc n) = SSS-mult (n * 3) (normal-human-mult n)\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = normal-human-mult 10\nmult'-imp-mult 21-mult = normal-human-mult 7\nmult'-imp-mult (sum-mult _ _ p q) =\n  mult-over-sum (mult'-imp-mult p) (mult'-imp-mult q)\nmult'-imp-mult (diff-mult l n _ p q refl) rewrite +-comm l n =\n  mult-over-diff (mult'-imp-mult p) (mult'-imp-mult q)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":273,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen import Data.Nat.Properties using (+-comm; +-identity\u02b3)\n\nPPP-mult : \u2200 n \u2192 Mult3 (suc (suc (suc n))) \u2192 Mult3 n\nPPP-mult n (SSS-mult .n m3_n) = m3_n\n\nsum-Mult : \u2200 m n \u2192 Mult3 m \u2192 Mult3 n \u2192 Mult3 (m + n)\nsum-Mult .0 n 0-mult m3_n = m3_n\nsum-Mult .(suc (suc (suc n\u2081))) n (SSS-mult n\u2081 m3_m) m3_n = SSS-mult (n\u2081 + n) (sum-Mult n\u2081 n m3_m m3_n)\n\ndiff-Mult : \u2200 l n m \u2192 Mult3 n \u2192 Mult3 m \u2192 l + n \u2261 m \u2192 Mult3 l\ndiff-Mult l .0 .(l + 0) 0-mult m3_m refl rewrite +-identity\u02b3 l = m3_m\ndiff-Mult l .(suc (suc (suc n))) .(l + suc (suc (suc n))) (SSS-mult n m3_n) m3_m refl\n  rewrite +-comm l (suc (suc (suc n))) | +-comm n l = diff-Mult l n (l + n) m3_n (PPP-mult (l + n) m3_m) refl\n\n9-mult' : Mult3' 9\n9-mult' = diff-mult 9 21 30 21-mult 30-mult refl\n\n0-mult' : Mult3' 0\n0-mult' = diff-mult zero 30 30 30-mult 30-mult refl\n\n12-mult' : Mult3' 12\n12-mult' = diff-mult 12 9 21 9-mult' 21-mult refl\n\n3-mult' : Mult3' 3\n3-mult' = diff-mult 3 9 12 9-mult' 12-mult' refl\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = 0-mult'\nmult-imp-mult' (SSS-mult n m3_n) = sum-mult 3 n 3-mult' (mult-imp-mult' m3_n)\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = SSS-mult 27\n                           (SSS-mult 24\n                            (SSS-mult 21\n                             (SSS-mult 18\n                              (SSS-mult 15\n                               (SSS-mult 12\n                                (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult zero 0-mult)))))))))\nmult'-imp-mult 21-mult = SSS-mult 18\n                           (SSS-mult 15\n                            (SSS-mult 12\n                             (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult zero 0-mult))))))\nmult'-imp-mult (sum-mult n m m3'_n m3'_m) = sum-Mult n m (mult'-imp-mult m3'_n) (mult'-imp-mult m3'_m)\nmult'-imp-mult (diff-mult l n ._ m3'_n m3'_m refl) = diff-Mult l n (l + n) (mult'-imp-mult m3'_n) (mult'-imp-mult m3'_m)\n                                                       refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":274,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nmult3'-0 : Mult3' 0\nmult3'-0 = diff-mult zero 30 30 30-mult 30-mult refl\n\nmult3'-3 : Mult3' 3\nmult3'-3 = diff-mult 3 9 12 mult3'-9 mult3'-12 refl\n  where\n    mult3'-9 : Mult3' 9\n    mult3'-9 = diff-mult 9 21 30 21-mult 30-mult refl\n\n    mult3'-12 : Mult3' 12\n    mult3'-12 = diff-mult 12 9 21 mult3'-9 21-mult refl\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = mult3'-0\nmult-imp-mult' (SSS-mult n m) = sum-mult 3 n mult3'-3 (mult-imp-mult' m)\n\nmult3-21 : Mult3 21\nmult3-21 = SSS-mult 18\n             (SSS-mult 15\n              (SSS-mult 12\n               (SSS-mult 9\n                 (SSS-mult 6\n                   (SSS-mult 3\n                     (SSS-mult zero 0-mult))))))\n\nmult3-30 : Mult3 30\nmult3-30 = SSS-mult 27 (SSS-mult 24 (SSS-mult 21 mult3-21))\n\nmult3-sum : \u2200 n m \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nmult3-sum zero m n3 m3 = m3\nmult3-sum (suc (suc (suc n))) m (SSS-mult .n n3) m3 = SSS-mult (n + m) (mult3-sum n m n3 m3)\n\nmult3-diff : \u2200 l n m \u2192 Mult3 n \u2192 Mult3 m \u2192 l + n \u2261 m \u2192 Mult3 l\nmult3-diff l zero _ _ m3 p\n  rewrite (+-identity\u02b3 l)\n  rewrite p\n  = m3\n\nmult3-diff l (suc (suc (suc n))) m (SSS-mult .n n3) m3 p\n  rewrite (+-suc l (suc (suc n)))\n  rewrite (+-suc l (suc n))\n  rewrite (+-suc l n)\n  with m | m3\n... | suc (suc (suc m)) | SSS-mult .m m3\n    = mult3-diff l n m n3 m3 (cong remove-three-suc p)\n  where\n    remove-three-suc : \u2115 \u2192 \u2115\n    remove-three-suc (suc (suc (suc n))) = n\n    remove-three-suc _ = zero\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = mult3-30\nmult'-imp-mult 21-mult = mult3-21\nmult'-imp-mult (sum-mult n m n3 n4) = mult3-sum n m (mult'-imp-mult n3) (mult'-imp-mult n4)\nmult'-imp-mult (diff-mult n\u2081 n m n3 n4 p) = mult3-diff n\u2081 n m (mult'-imp-mult n3) (mult'-imp-mult n4) p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":275,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n0-Mult3' : Mult3' 0\n0-Mult3' = diff-mult 0 21 21 21-mult 21-mult refl\n\n9-Mult3' : Mult3' 9\n9-Mult3' = diff-mult 9 21 30 21-mult 30-mult refl\n\n18-Mult3' : Mult3' 18\n18-Mult3' = sum-mult 9 9 9-Mult3' 9-Mult3'\n\n3-Mult3' : Mult3' 3\n3-Mult3' = diff-mult 3 18 21 18-Mult3' 21-mult refl\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = diff-mult 0 21 21 21-mult 21-mult refl\nmult-imp-mult' (SSS-mult n p) = sum-mult 3 n 3-Mult3' (mult-imp-mult' p)\n\n3n-Mult3 : (n : \u2115) \u2192 Mult3 (n * 3)\n3n-Mult3 zero = 0-mult\n3n-Mult3 (suc n) = SSS-mult (n * 3) (3n-Mult3 n)\n\nn+m-Mult3 : {n m : \u2115} \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nn+m-Mult3 0-mult q = q\nn+m-Mult3 {m = m} (SSS-mult n p) q = SSS-mult (n + m) (n+m-Mult3 p q)\n\nm-n-Mult3 : (l : \u2115) {n m : \u2115} \u2192 Mult3 n \u2192 Mult3 m \u2192 l + n \u2261 m \u2192 Mult3 l\nm-n-Mult3 0 p q eq = 0-mult\nm-n-Mult3 1 (SSS-mult n p) (SSS-mult m q) eq = m-n-Mult3 1 p q (cong \u2223 3 -_\u2223 eq)\nm-n-Mult3 2 (SSS-mult n p) (SSS-mult m q) eq = m-n-Mult3 2 p q (cong \u2223 3 -_\u2223 eq)\nm-n-Mult3 (suc (suc (suc l))) p (SSS-mult m q) eq = SSS-mult l (m-n-Mult3 l p q (cong \u2223 3 -_\u2223 eq))\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = 3n-Mult3 10\nmult'-imp-mult 21-mult = 3n-Mult3 7\nmult'-imp-mult (sum-mult n m p q) = n+m-Mult3 (mult'-imp-mult p) (mult'-imp-mult q)\nmult'-imp-mult (diff-mult l n m p q eq) = m-n-Mult3 l (mult'-imp-mult p) (mult'-imp-mult q) eq\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":276,"user_id":29,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n9-mult : Mult3' 9\n9-mult = diff-mult 9 21 30 21-mult 30-mult refl\n\n18-mult : Mult3' 18\n18-mult = sum-mult 9 9 9-mult 9-mult\n\n3-mult : Mult3' 3\n3-mult = diff-mult 3 18 21 18-mult 21-mult refl\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = diff-mult 0 21 21 21-mult 21-mult refl\nmult-imp-mult' (SSS-mult n m) = sum-mult 3 n 3-mult (mult-imp-mult' m)\n\nsum-m : {a b : \u2115} \u2192 Mult3 a \u2192 Mult3 b \u2192 Mult3 (a + b)\nsum-m 0-mult b = b\nsum-m (SSS-mult n a) 0-mult = SSS-mult (n + zero) (sum-m a 0-mult)\nsum-m (SSS-mult n a) (SSS-mult m b) = SSS-mult (n + suc (suc (suc m))) (sum-m a (SSS-mult m b))\n\ndiff-m : {a b c : \u2115} \u2192 Mult3 a \u2192 Mult3 b \u2192 b + c \u2261 a \u2192 Mult3 c\ndiff-m a 0-mult refl = a\ndiff-m (SSS-mult .(n + _) a) (SSS-mult n b) refl = diff-m a b refl\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = SSS-mult 27 (SSS-mult 24 (SSS-mult 21 (mult'-imp-mult 21-mult)))\nmult'-imp-mult 21-mult = SSS-mult 18 (SSS-mult 15 (SSS-mult 12 (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult 0 0-mult))))))\nmult'-imp-mult (sum-mult n m o p) = sum-m (mult'-imp-mult o) (mult'-imp-mult p)\nmult'-imp-mult (diff-mult l n m o p refl) = diff-m (mult'-imp-mult p) (mult'-imp-mult o) (+-comm n l)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":277,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen import Function using (_\u2218_)\nopen \u2261-Reasoning\n\nM12 : Mult3' 12\nM12 = diff-mult 12 9 21 (diff-mult 9 21 30 21-mult 30-mult refl) 21-mult refl\n\nM18 : Mult3' 18\nM18 = diff-mult 18 12 30 M12 30-mult refl\n\nM6 : Mult3' 6\nM6 = diff-mult 6 12 18 M12 M18 refl\n\nM24 : Mult3' 24\nM24 = diff-mult 24 6 30 M6 30-mult refl\n\nM3 : Mult3' 3\nM3 = diff-mult 3 21 24 21-mult M24 refl\n\nMult3'SSS : \u2200 {n} \u2192 Mult3' n \u2192 Mult3' (suc (suc (suc n)))\nMult3'SSS {n} p = sum-mult 3 n M3 p\n\nMult3-sum : \u2200 {n m} \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nMult3-sum 0-mult q = q\nMult3-sum {_} {m} (SSS-mult n p) q = SSS-mult (n + m) (Mult3-sum p q)\n\nMult3-diff : \u2200 {l n m} \u2192 Mult3 n \u2192 Mult3 m \u2192 l + n \u2261 m \u2192 Mult3 l\nMult3-diff {zero} {.0} {.0} 0-mult 0-mult eqn = 0-mult\nMult3-diff {suc l} {.0} {.3} 0-mult (SSS-mult .0 0-mult) eqn = lem\n    where\n        eqn' : suc l \u2261 3\n        eqn' = begin\n            suc l        \u2261\u27e8 cong suc (sym (+-identity\u02b3 l)) \u27e9\n            suc (l + 0)  \u2261\u27e8 eqn \u27e9\n            3            \u220e\n\n        lem : Mult3 (suc l)\n        lem rewrite eqn' = SSS-mult zero 0-mult\nMult3-diff {l} {.0} {.(suc (suc (suc (suc (suc (suc n))))))} 0-mult (SSS-mult .(suc (suc (suc n))) (SSS-mult n q)) eqn rewrite +-identity\u02b3 l | eqn = SSS-mult (suc (suc (suc n))) (SSS-mult n q)\nMult3-diff {zero} {.(suc (suc (suc n)))} {.0} (SSS-mult n p) 0-mult eqn = 0-mult\nMult3-diff {suc l} {.(suc (suc (suc n)))} {.0} (SSS-mult n p) 0-mult ()\nMult3-diff {l} {.(suc (suc (suc n)))} {.(suc (suc (suc n\u2081)))} (SSS-mult n p) (SSS-mult n\u2081 q) eqn = Mult3-diff p q eqn''\n    where\n        eqn' : (l + (suc (suc (suc n)))) \u2238 1 \u2238 1 \u2238 1 \u2261 n\u2081\n        eqn' = cong ((_\u2238 1) \u2218 (_\u2238 1) \u2218 (_\u2238 1)) eqn\n\n        lem : \u2200 (x : \u2115) \u2192 (l + suc x) \u2238 1 \u2261 l + x\n        lem zero rewrite +-identity\u02b3 l | +-comm l 1 = refl\n        lem (suc x) rewrite +-comm l (suc (suc x)) | +-comm l (suc x) = refl\n\n        eqn'' : l + n \u2261 n\u2081\n        eqn'' = begin\n            l + n                               \u2261\u27e8 sym (lem n) \u27e9\n            l + suc n \u2238 1                       \u2261\u27e8 cong (_\u2238 1) (sym (lem (suc n))) \u27e9\n            l + suc (suc n) \u2238 1 \u2238 1             \u2261\u27e8 cong ((_\u2238 1) \u2218 (_\u2238 1)) (sym (lem (suc (suc n)))) \u27e9\n            l + suc (suc (suc n)) \u2238 1 \u2238 1 \u2238 1   \u2261\u27e8 eqn' \u27e9\n            n\u2081                                  \u220e\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = diff-mult zero 30 30 30-mult 30-mult refl\nmult-imp-mult' (SSS-mult n p) = Mult3'SSS (mult-imp-mult' p)\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = SSS-mult 27\n                           (SSS-mult 24\n                            (SSS-mult 21\n                             (SSS-mult 18\n                              (SSS-mult 15\n                               (SSS-mult 12\n                                (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult zero 0-mult)))))))))\nmult'-imp-mult 21-mult = SSS-mult 18\n                           (SSS-mult 15\n                            (SSS-mult 12\n                             (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult zero 0-mult))))))\nmult'-imp-mult (sum-mult n m p p\u2081) = Mult3-sum (mult'-imp-mult p) (mult'-imp-mult p\u2081)\nmult'-imp-mult (diff-mult _ n m p p\u2081 x) = Mult3-diff (mult'-imp-mult p) (mult'-imp-mult p\u2081) x\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":278,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n\nzeroMult3' : Mult3' 0\nzeroMult3' = diff-mult zero 30 30 30-mult 30-mult refl\n\nnineMult3' : Mult3' 9\nnineMult3' = diff-mult 9 21 30 21-mult 30-mult refl\n\neighteenMult3' : Mult3' 18\neighteenMult3' = sum-mult 9 9 nineMult3' nineMult3' \n\nthreeMult3' : Mult3' 3\nthreeMult3' = diff-mult 3 18 21 eighteenMult3' 21-mult refl\n\nsssMult3' : {n : \u2115} \u2192 Mult3' n \u2192 Mult3' (suc (suc (suc n)))\nsssMult3' {n} p = sum-mult 3 n threeMult3' p\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = zeroMult3'\nmult-imp-mult' (SSS-mult n mn') = sssMult3' (mult-imp-mult' mn')\n\nsumMult3 : {n m : \u2115} \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nsumMult3 {.0} {m} 0-mult pm = pm\nsumMult3 {.(suc (suc (suc n)))} {m} (SSS-mult n pn) pm =\n    SSS-mult (n + m) (sumMult3 {n} {m} pn pm)\n\ntimesMult3 : {n : \u2115} \u2192 Mult3 (3 * n)\ntimesMult3 {zero} = 0-mult\ntimesMult3 {suc n}  = subst Mult3 (sym helper) (sumMult3 (SSS-mult 0 0-mult) (timesMult3 {n}))\n    where   helper : (suc (n + suc (n + suc (n + zero)))) \u2261 (suc (suc (suc (n + (n + (n + zero))))))\n            helper = begin\n                (suc (n + suc (n + suc (n + zero)))) \u2261\u27e8 refl \u27e9\n                (1 + (n + (1 + (n + (1 + (n + zero)))))) \u2261\u27e8 cong (1 +_) (+-suc n (n + (1 + (n + zero)))) \u27e9\n                (1 + (1 + (n + (n + (1 + (n + zero)))))) \u2261\u27e8 cong (\u03bb z \u2192 (1 + (1 + (n + z)))) (+-suc n (n + zero)) \u27e9\n                (1 + (1 + (n + (1 + (n + (n + zero)))))) \u2261\u27e8 cong (\u03bb z \u2192 (1 + (1 + z))) (+-suc n (n + (n + zero))) \u27e9\n                (1 + (1 + (1 + (n + (n + (n + zero)))))) \u2261\u27e8 refl \u27e9\n                (suc (suc (suc (n + (n + (n + zero))))))    \u220e where open \u2261-Reasoning\n\ndiffMult3 : {n m : \u2115} \u2192 Mult3 m \u2192 Mult3 (n + m) \u2192 Mult3 n\ndiffMult3 {n} {.0} 0-mult mnm = subst Mult3 (+-identity\u02b3 n) mnm\ndiffMult3 {n} {.(suc (suc (suc m)))} (SSS-mult m mm) mnm = \n        diffMult3 {n} {m} mm \n            (helper (subst Mult3 (trans (+-comm n (3 + m)) (cong (3 +_) (+-comm m n))) mnm))\n    where   helper : Mult3 (suc (suc (suc (n + m)))) \u2192 Mult3 (n + m)\n            helper (SSS-mult .(n + m) sssnm) = sssnm\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = timesMult3 {10}\nmult'-imp-mult 21-mult = timesMult3 {7}\nmult'-imp-mult (sum-mult n m mn mm) = \n    sumMult3 {n} {m} (mult'-imp-mult mn) (mult'-imp-mult mm)\nmult'-imp-mult (diff-mult l n .(l + n) mn mm refl) = \n    diffMult3 {l} {n} (mult'-imp-mult mn) (mult'-imp-mult mm)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":279,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nmult-3 : Mult3' 3\nmult-3 = diff-mult 3 18 21\n    (diff-mult 18 12 30\n    (diff-mult 12 9 21 (diff-mult 9 21 30 21-mult 30-mult refl) 21-mult\n    refl)\n    30-mult refl)\n    21-mult refl\n\nmult-sum : \u2200 {n m} \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nmult-sum 0-mult hm = hm\nmult-sum (SSS-mult n hn) hm = SSS-mult (n + _) (mult-sum hn hm)\n\nmult-diff : \u2200 {l n m} \u2192 Mult3 n \u2192 Mult3 m \u2192 l + n \u2261 m \u2192 Mult3 l\nmult-diff 0-mult hm p = subst Mult3 (sym (trans (sym (+-identity\u02b3 _)) p)) hm\nmult-diff (SSS-mult n hn) 0-mult p = subst Mult3 (sym (i+j\u22610\u21d2i\u22610 _ p)) 0-mult\nmult-diff (SSS-mult n hn) (SSS-mult m hm) p = mult-diff hn hm \n    (suc-injective (suc-injective (suc-injective \n    ( trans (sym (trans (+-suc _ (suc (suc _))) (cong suc (trans (+-suc _ (suc _)) \n    (cong suc (+-suc _ _)))))) p))))\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = diff-mult zero 30 30 30-mult 30-mult refl\nmult-imp-mult' (SSS-mult n h) = sum-mult 3 n mult-3 (mult-imp-mult' h)\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = SSS-mult 27\n    (SSS-mult 24\n (SSS-mult 21\n  (SSS-mult 18\n   (SSS-mult 15\n    (SSS-mult 12\n     (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult zero 0-mult)))))))))\nmult'-imp-mult 21-mult = SSS-mult 18\n    (SSS-mult 15\n (SSS-mult 12\n  (SSS-mult 9 (SSS-mult 6 (SSS-mult 3 (SSS-mult zero 0-mult))))))\nmult'-imp-mult (sum-mult n m h h\u2081) = mult-sum (mult'-imp-mult h) (mult'-imp-mult h\u2081)\nmult'-imp-mult (diff-mult _ n m h h\u2081 x) = mult-diff (mult'-imp-mult h) (mult'-imp-mult h\u2081) x\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":280,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n\nmult-over-sum : {n m : \u2115} \u2192 Mult3 n \u2192 Mult3 m \u2192 Mult3 (n + m)\nmult-over-sum 0-mult q = q\nmult-over-sum (SSS-mult _ p) q = SSS-mult _ (mult-over-sum p q)\n\nmult-over-diff : {l n : \u2115} \u2192 Mult3 n \u2192 Mult3 (n + l) \u2192 Mult3 l\nmult-over-diff 0-mult q = q\nmult-over-diff (SSS-mult _ p) (SSS-mult _ q) = mult-over-diff p q\n\nnh-mult : (n : \u2115) \u2192 Mult3 (n * 3)\nnh-mult zero = 0-mult\nnh-mult (suc n) = SSS-mult (n * 3) (nh-mult n)\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\n-- 30(-7) + 21(10) = 0\nmult-imp-mult' 0-mult = diff-mult 0 30 30 30-mult 30-mult refl\n-- 30a + 21b = 3:\n{-\na = -2 ; b = 3 : -60 + 21 * 3 = 3\n-}\nmult-imp-mult' (SSS-mult n n\u22613k)\n  = sum-mult 3 n (diff-mult 3 60 63 60-mult 63-mult refl) (mult-imp-mult' n\u22613k)\n    where\n      60-mult : Mult3' 60\n      60-mult = sum-mult 30 30 30-mult 30-mult\n      63-mult : Mult3' 63\n      63-mult = sum-mult 21 42 21-mult (sum-mult 21 21 21-mult 21-mult)\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = nh-mult 10\nmult'-imp-mult 21-mult = nh-mult 7\n  where\n    9-mult : Mult3 9\n    9-mult = mult'-imp-mult (diff-mult 9 21 30 21-mult 30-mult refl)\nmult'-imp-mult (sum-mult _ _ p q)\n  = mult-over-sum (mult'-imp-mult p) (mult'-imp-mult q)\nmult'-imp-mult (diff-mult l n _ p q refl) rewrite +-comm l n\n  = mult-over-diff (mult'-imp-mult p) (mult'-imp-mult q)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":281,"user_id":null,"body":"{-# OPTIONS --without-K --safe #-}\nmodule Mult3 where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n\n0-Mult3' : Mult3' 0\n0-Mult3' = diff-mult 0 21 21 21-mult 21-mult refl\n\n9-Mult3' : Mult3' 9\n9-Mult3' = diff-mult 9 21 30 21-mult 30-mult refl\n\n12-Mult3' : Mult3' 12\n12-Mult3' = diff-mult 12 9 21  9-Mult3' 21-mult refl\n\n3-Mult3' : Mult3' 3\n3-Mult3' = diff-mult 3 9 12  9-Mult3' 12-Mult3' refl\n\n3-Mult3 : Mult3 3\n3-Mult3 = SSS-mult 0 0-mult\n\n6-Mult3 : Mult3 6\n6-Mult3 = SSS-mult 3 3-Mult3\n\n9-Mult3 : Mult3 9\n9-Mult3 = SSS-mult 6 6-Mult3\n\n12-Mult3 : Mult3 12\n12-Mult3 = SSS-mult 9 9-Mult3\n\n15-Mult3 : Mult3 15\n15-Mult3 = SSS-mult 12 12-Mult3\n\n18-Mult3 : Mult3 18\n18-Mult3 = SSS-mult 15 15-Mult3\n\n21-Mult3 : Mult3 21\n21-Mult3 = SSS-mult 18 18-Mult3\n\n24-Mult3 : Mult3 24\n24-Mult3 = SSS-mult 21 21-Mult3\n\n27-Mult3 : Mult3 27\n27-Mult3 = SSS-mult 24 24-Mult3\n\n30-Mult3 : Mult3 30\n30-Mult3 = SSS-mult 27 27-Mult3\n\n\n+sucRightSuc : \u2200 (x y : \u2115) -> suc (x + y) \u2261 x + suc y\n+sucRightSuc zero y = refl\n+sucRightSuc (suc x) y rewrite +sucRightSuc x y = refl\n \n+0 : \u2200 (n : \u2115) -> n + 0 \u2261 n\n+0 0 = refl\n+0 (suc n) rewrite +0 n = refl\n\n+c : \u2200 (n m : \u2115) -> n + m \u2261 m + n\n+c zero m rewrite +0 m = refl\n+c (suc n) m rewrite +c n m | +sucRightSuc m n = refl\n\nmult-imp-mult' : \u2200 {n : \u2115} \u2192 Mult3 n \u2192 Mult3' n\nmult-imp-mult' 0-mult = 0-Mult3'\nmult-imp-mult' (SSS-mult n x) = sum-mult 3 n 3-Mult3' (mult-imp-mult' x)\n\nmult3Sum : \u2200 {n m : \u2115} -> Mult3 n -> Mult3 m -> Mult3 (n + m)\nmult3Sum 0-mult y = y\nmult3Sum {m = m} (SSS-mult n x) y = (SSS-mult (n + m) (mult3Sum x y))\n\nmult3Diff : \u2200 l n m \u2192 Mult3 n \u2192 Mult3 m \u2192 l + n \u2261 m \u2192 Mult3 l\nmult3Diff zero _ _ _ _ _ = 0-mult\nmult3Diff (suc l) .0 m 0-mult y p rewrite +0 l | p = y\nmult3Diff (suc l) .(suc (suc (suc n))) .(suc (suc (suc m))) (SSS-mult n x) (SSS-mult m y) p\n                            rewrite +c l (3 + n)\n                            | +c n l = mult3Diff (suc l) n m x y  (cong pred (cong pred (cong pred p)))\n\nmult'-imp-mult : \u2200 {n : \u2115} \u2192 Mult3' n \u2192 Mult3 n\nmult'-imp-mult 30-mult = 30-Mult3\nmult'-imp-mult 21-mult = 21-Mult3\nmult'-imp-mult (sum-mult n m x y) = mult3Sum (mult'-imp-mult x) (mult'-imp-mult y) \nmult'-imp-mult (diff-mult l n m x y p) = mult3Diff l n m (mult'-imp-mult x) (mult'-imp-mult y) p","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5cca3e90701f0d000d5922bf":[{"id":282,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\nopen Data.Nat.Solver.+-*-Solver\n  using (prove; solve; _:=_; con; var; _:+_; _:*_; :-_; _:-_)\nopen import Preloaded\n\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.Nat public\n\n_! : \u2115 \u2192 \u2115\nzero ! = 1\n(suc n) ! = (suc n) * n !\n\n-}\n\npr : \u2115 \u2192 \u2115 \u2192 \u2115 \npr d zero = 1\npr d (suc k) = (d + k) * (pr d k) \n\npr1\u2261fact : \u2200 k \u2192 pr 1 k \u2261 k !\npr1\u2261fact zero = refl\npr1\u2261fact (suc k) = subst (\u03bb x \u2192 (pr 1 k) + k * (pr 1 k) \u2261 x + k * x) \n    (pr1\u2261fact k) refl\n\npr0\u22610 : \u2200 k \u2192 pr 0 (suc k) \u2261 0\npr0\u22610 zero = refl\npr0\u22610 (suc k) rewrite pr0\u22610 k = *-zero\u02b3 k\n\npr+1 : \u2200 d k \u2192 d * (pr (suc d) k) \u2261 pr d (suc k)\npr+1 d zero = cong (_* 1) (sym (+-identity\u02b3 d))\npr+1 d (suc k) =  \n    begin \n        d * ((suc d + k) * pr (suc d) k) \n            \u2261\u27e8 sym (*-assoc d (suc (d + k)) (pr (suc d) k)) \u27e9\n        (d * (suc d + k)) * pr (suc d) k\n            \u2261\u27e8 cong (_* pr (suc d) k) (*-comm d (suc (d + k))) \u27e9\n        ((suc d + k) * d) * pr (suc d) k\n            \u2261\u27e8 *-assoc (suc (d + k)) d (pr (suc d) k) \u27e9\n        (suc d + k) * (d * pr (suc d) k)\n            \u2261\u27e8 cong\u2082 _*_ (sym (+-suc d k)) (pr+1 d k) \u27e9\n        (d + suc k) * ((d + k) * pr d k)\n    \u220e\n\npr-sum : \u2200 d k \u2192 pr (suc d) (suc k) \u2261 (suc k) * (pr (suc d) k) + pr d (suc k)\npr-sum d k = \n    begin \n        pr (suc d) (suc k) \n            \u2261\u27e8 refl \u27e9  \n        (suc d + k) * (pr (suc d) k) \n            \u2261\u27e8 cong (_* (pr (suc d) k)) (sym (+-suc d k)) \u27e9 \n        (d + suc k) * (pr (suc d) k) \n            \u2261\u27e8 *-distrib\u02b3-+ (pr (suc d) k) d (suc k) \u27e9 \n        d * (pr (suc d) k) + (suc k) * (pr (suc d) k) \n            \u2261\u27e8 cong (_+  (suc k) * (pr (suc d) k)) (pr+1 d k) \u27e9 \n       pr d (suc k) + (suc k) * (pr (suc d) k) \n            \u2261\u27e8 +-comm ((d + k) * pr d k) (pr (suc d) k + k * pr (suc d) k) \u27e9 \n        (suc k) * (pr (suc d) k) + pr d (suc k)\n    \u220e\n_\u2223_ : \u2115 \u2192 \u2115 \u2192 Set \nd \u2223 a = \u2203 \u03bb e \u2192 d * e \u2261 a\n\nrefl-| : \u2200 {a} \u2192 a \u2223 a \nrefl-| = 1 , (*-identity\u02b3 _)\n\nd|a\u2227d|b\u21d2d|a+b : \u2200 {d a b} \u2192 d \u2223 a \u2192 d \u2223 b \u2192 d \u2223 (a + b)\nd|a\u2227d|b\u21d2d|a+b {d = d} (xa , ha) (xb , hb) = (xa + xb) , \n    trans (*-distrib\u02e1-+ d xa xb) (cong\u2082 _+_ ha hb)\n\nc|a\u2227d|b\u21d2cd|ab : \u2200 {a b c d} \u2192 c \u2223 a \u2192 d \u2223 b \u2192 (c * d) \u2223 (a * b)\nc|a\u2227d|b\u21d2cd|ab {c = c} {d = d} (xa , ha) (xb , hb) rewrite (sym ha) | (sym hb)\n    = (xa * xb) , \n    solve 4 ((\u03bb xa xb xc xd \u2192 xc :* xd :* (xa :* xb) := (xc :* xa) :* (xd :* xb))) \n    refl xa xb c d \n\n\npr|fact : \u2200 d k \u2192 (k !) \u2223 (pr d k)\npr|fact d zero = 1 , refl\npr|fact zero (suc k) = 0 , (trans (*-zero\u02b3 ((k !) + k * (k !))) (sym (pr0\u22610 k)))\npr|fact (suc d) (suc k) rewrite pr-sum d k = d|a\u2227d|b\u21d2d|a+b \n    {d = (suc k) !} {a = (suc k) * (pr (suc d) k)} {b = pr d (suc k)}\n    (c|a\u2227d|b\u21d2cd|ab {suc k} {pr (suc d) k} {suc k} {k !} \n        refl-| (pr|fact (suc d) k)) \n    (pr|fact d (suc k))\n\nsum!-exp : \u2200 x y \u2192 (x + y)! \u2261 x ! * pr (suc x) y\nsum!-exp x zero = trans (cong _! (+-identity\u02b3 x)) (sym (*-identity\u02b3 (x !)))\nsum!-exp x (suc y) = \n    begin \n        ((x + suc y) !) \n            \u2261\u27e8 cong _! (+-suc x y) \u27e9 \n        ((suc x + y) !) \n            \u2261\u27e8 sum!-exp (suc x) y \u27e9 \n        (suc x) ! * pr (suc (suc x)) y \n            \u2261\u27e8 cong (_* pr (suc (suc x)) y) (*-comm (suc x) (x !)) \u27e9 \n        ((x !) * suc x) * pr (suc (suc x)) y \n            \u2261\u27e8 *-assoc (x !) (suc x) (pr (suc (suc x)) y) \u27e9 \n        (x !) * (suc x * pr (suc (suc x)) y) \n            \u2261\u27e8 cong ((x !) *_) (pr+1 (suc x) y) \u27e9 \n        (x !) * ((suc x + y) * pr (suc x) y)\n    \u220e\n\n\nfact' : \u2200 x y \u2192 (x ! * y !) \u2223 ((x + y)!)\nfact' x y rewrite (sum!-exp x y) = \n    c|a\u2227d|b\u21d2cd|ab {x !} {pr (suc x) y} {x !} {y !}\n    refl-| \n    (pr|fact (suc x) y) \n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus x y with fact' x y\n...     | (e , he) = e , (trans (sym he) (*-comm ((x !) * (y !)) e))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":283,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\nopen import Relation.Nullary\nopen import Relation.Binary\nopen import Function\nopen import Data.Empty\nopen import Data.Nat\n\nopen +-*-Solver using (solve; _:*_; _:+_; con; _:=_)\nopen \u2261-Reasoning\n\nlemma : \u2200 {n k} (k\u2264n : k \u2264 n) \u2192 \u2203 \u03bb e \u2192 n ! \u2261 e * (k ! * (n \u2238 k)!)\nlemma {zero} {zero} k\u2264n = 1 , refl\nlemma {suc n} {zero} k\u2264n = 1 , solve 1 (\u03bb x \u2192 x := x :+ con 0 :+ con 0) refl ((suc n)!)\nlemma {suc n} {suc k} (s\u2264s k\u2264n) with <-cmp k n\n... | tri\u2248 _ refl _ = 1 , (\n  begin suc n ! \u2261\u27e8 solve 1 (\u03bb x \u2192 x := x :* con 1 :+ con 0) refl (suc n !) \u27e9\n        suc n ! * 1 + 0 \u2261\u27e8 cong (\u03bb x \u2192 (suc n !) * x ! + 0) $ sym $ n\u2238n\u22610 n \u27e9\n        suc n ! * (n \u2238 n) ! + 0 \u220e)\n... | tri> _ _ sn\u2264k = \u22a5-elim $ \u2264\u21d2\u226f k\u2264n sn\u2264k\n... | tri< sk\u2264n _ _ with lemma k\u2264n | lemma sk\u2264n\nlemma {suc n@(suc m)} {suc k} (s\u2264s k\u2264n) | tri< (s\u2264s k\u2264m) _ _ | a\u2081 , p\u2081 | a\u2082 , p\u2082 =\n  a\u2081 + a\u2082 , (begin\n  (suc n) ! \u2261\u27e8 cong (_* n !) $ sym $ m\u2238n+n\u2261m $ s\u2264s k\u2264n \u27e9\n  (n \u2238 k + suc k) * n ! \u2261\u27e8 *-distrib\u02b3-+ (n !)(n \u2238 k)(suc k) \u27e9\n  (n \u2238 k) * n ! + suc k * n ! \u2261\u27e8 cong\u2082 (\u03bb x y \u2192 (n \u2238 k) * x + suc k * y) p\u2082 p\u2081 \u27e9\n  (n \u2238 k) * (a\u2082 * ((suc k) ! * (n \u2238 suc k) !)) + suc k * (a\u2081 * (k ! * (n \u2238 k) !))\n    \u2261\u27e8 solve 8 (\u03bb n-k a\u2082 k+1! m-k! k+1 a\u2081 k! n-k! \u2192\n       n-k :* (a\u2082 :* (k+1! :* m-k!)) :+ k+1 :* (a\u2081 :* (k! :* n-k!)) :=\n       a\u2081 :* (k+1 :* k! :* n-k!) :+ a\u2082 :* (k+1! :* (n-k :* m-k!)))\n       refl (n \u2238 k) a\u2082 (suc k !) ((m \u2238 k) !) (suc k) a\u2081 (k !) ((n \u2238 k) !)\u27e9\n  a\u2081 * (suc k ! * (n \u2238 k) !) + a\u2082 * (suc k ! * ((suc m \u2238 k) * (m \u2238 k) !))\n    \u2261\u27e8 cong (\u03bb x \u2192 a\u2081 * (suc k ! * (n \u2238 k) !) + a\u2082 * (suc k ! * x)) $\n       begin (suc m \u2238 k) * (m \u2238 k) ! \u2261\u27e8 cong (_* ((m \u2238 k) !)) $ +-\u2238-assoc 1 k\u2264m \u27e9\n             suc (m \u2238 k) ! \u2261\u27e8 cong _! $ sym $ +-\u2238-assoc 1 k\u2264m \u27e9\n             (n \u2238 k) ! \u220e \u27e9\n  a\u2081 * (suc k ! * (n \u2238 k) !) + a\u2082 * (suc k ! * (n \u2238 k) !)\n    \u2261\u27e8 sym $ *-distrib\u02b3-+ (suc k ! * (n \u2238 k) !) a\u2081 a\u2082 \u27e9\n  (a\u2081 + a\u2082) * ((suc k) ! * (n \u2238 k) !)  \u220e)\n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus x y =\n  subst (\u03bb y' \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y' !))\n    (begin x + y \u2238 x \u2261\u27e8 cong (_\u2238 x) $ +-comm x y \u27e9\n           y + x \u2238 x \u2261\u27e8 m+n\u2238n\u2261m y x \u27e9\n           y \u220e)\n    (lemma {x + y}{x} (m\u2264m+n x y))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":284,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule Solution where\n\nopen import Data.List\n  using (List; []; _\u2237_; [_]; _++_; product; _\u2237\u02b3_)\nopen import Data.List.Properties\n  using (++-identity\u02b3)\nopen import Data.Nat\n  using (\u2115; zero; suc; _+_; _*_)\nopen import Data.Nat.Divisibility\n  using (_\u2223_; \u2223-reflexive; \u2223-refl; \u2223-trans; _\u22230; \u2223m\u2223n\u21d2\u2223m+n; *-cong; module \u2223-Reasoning)\nopen import Data.Nat.Properties\n  using (+-suc; +-comm; +-identity\u02b3; *-assoc; *-comm; *-identity\u02e1; *-identity\u02b3; *-distrib\u02b3-+)\nopen import Data.Product\n  using (\u2203; _,_)\nopen import Function\n  using (_\u2218_)\nopen import Relation.Binary.PropositionalEquality\n  using (_\u2261_; refl; cong; sym; module \u2261-Reasoning)\n\nopen import Preloaded\n  using (_!)\n\n-- A datatype to minimally encode a range of natural numbers.\nrecord Range : Set where\n  constructor [_>>+_]\n  field left-endpoint : \u2115\n        ilength : \u2115\n\nmodule _ where\n\n  -- Reify a `Range` as a list of natural numbers.\n  --   Interestingly, the obvious implementation of this function\n  --     toList : Range \u2192 List \u2115\n  --     toList [ _ >>+ zero ] = []\n  --     toList [ n >>+ suc k ] = n \u2237 toList [ suc n >>= k ]\n  --   does not work because Agda cannot see it terminates. This roundabout\n  --   implementation avoids having to stick a {-# TERMINATING #-} pragma\n  --   to the code above, while guaranteeing that both clauses hold judgmentally.\n  toList : Range \u2192 List \u2115\n  toList [ n >>+ k ] = toList' n k\n    where toList' : \u2115 \u2192 \u2115 \u2192 List \u2115\n          toList' _ zero = []\n          toList' n (suc k) = n \u2237 toList' (suc n) k\n\n  _ : \u2200 {n} \u2192 toList [ n >>+ zero ] \u2261 []\n  _ = refl\n  \n  _ : \u2200 {n k} \u2192 toList [ n >>+ suc k ] \u2261 n \u2237 toList [ suc n >>+ k ]\n  _ = refl\n\n  -- Split a reified `Range` into the concatenation of two reified `Range`s\n  toList-+ : \u2200 {n} k l \u2192 toList [ n >>+ k + l ] \u2261 toList [ n >>+ k ] ++ toList [ n + k >>+ l ]\n  toList-+ {n} zero l rewrite +-identity\u02b3 n = refl\n  toList-+ {n} k zero = begin\n    toList [ n >>+ k + 0 ]                       \u2261\u27e8 cong (\u03bb z \u2192 toList [ n >>+ z ]) (+-identity\u02b3 k) \u27e9\n    toList [ n >>+ k ]                           \u2261\u27e8 sym (++-identity\u02b3 (toList [ n >>+ k ])) \u27e9\n    toList [ n >>+ k ] ++ []                     \u2261\u27e8\u27e9 \n    toList [ n >>+ k ] ++ toList [ n + k >>+ 0 ] \u220e\n    where open \u2261-Reasoning\n  toList-+ {n} (suc k) (suc l) = begin\n    toList [ n >>+ suc k + suc l ]                                  \u2261\u27e8\u27e9\n    n \u2237 toList [ suc n >>+ k + suc l ]                              \u2261\u27e8 cong (n \u2237_) (toList-+ k (suc l)) \u27e9\n    n \u2237 (toList [ suc n >>+ k ] ++ toList [ suc n + k >>+ suc l ])  \u2261\u27e8\u27e9\n    (n \u2237 toList [ suc n >>+ k ]) ++ toList [ suc n + k >>+ suc l ]  \u2261\u27e8\u27e9\n    toList [ n >>+ suc k ] ++ toList [ suc n + k >>+ suc l ]        \u2261\u27e8 cong (\u03bb z \u2192 toList [ n >>+ suc k ] ++ toList [ z >>+ suc l ]) (sym (+-suc n k)) \u27e9\n    toList [ n >>+ suc k ] ++ toList [ n + suc k >>+ suc l ]        \u220e\n    where open \u2261-Reasoning\n    \n  -- Split just the last element of a reified `Range`\n  toList-\u2237\u02b3 : \u2200 k l \u2192 toList [ k >>+ suc l ] \u2261 toList [ k >>+ l ] \u2237\u02b3 (k + l)\n  toList-\u2237\u02b3 k l = begin\n    toList [ k >>+ suc l ]                       \u2261\u27e8 cong (\u03bb z \u2192 toList [ k >>+ z ]) (+-comm 1 l) \u27e9\n    toList [ k >>+ l + 1 ]                       \u2261\u27e8 toList-+ l 1 \u27e9\n    toList [ k >>+ l ] ++ toList [ k + l >>+ 1 ] \u2261\u27e8\u27e9\n    toList [ k >>+ l ] ++ [ k + l ]              \u2261\u27e8\u27e9\n    toList [ k >>+ l ] \u2237\u02b3 (k + l)                \u220e\n    where open \u2261-Reasoning\n\nmodule _ where\n\n  -- The product of a concatenation of lists of natural numbers is the product\n  --   of the products of the constituent lists\n  product-++ : \u2200 xs ys \u2192 product (xs ++ ys) \u2261 product xs * product ys\n  product-++ [] ys = begin\n    product ([] ++ ys)       \u2261\u27e8\u27e9\n    product ys               \u2261\u27e8 sym (*-identity\u02e1 (product ys)) \u27e9\n    1 * product ys           \u2261\u27e8\u27e9\n    product [] * product ys  \u220e\n    where open \u2261-Reasoning\n  product-++ (x \u2237 xs) ys = begin\n    product (x \u2237 xs ++ ys)         \u2261\u27e8\u27e9\n    product (x \u2237 (xs ++ ys))       \u2261\u27e8\u27e9\n    x * product (xs ++ ys)         \u2261\u27e8 cong (x *_) (product-++ xs ys) \u27e9\n    x * (product xs * product ys)  \u2261\u27e8 sym (*-assoc x (product xs) (product ys)) \u27e9\n    x * product xs * product ys    \u2261\u27e8\u27e9\n    product (x \u2237 xs) * product ys  \u220e\n    where open \u2261-Reasoning\n\nmodule _ where\n\n  -- Take the product of all the natural numbers in a certain `Range`.\n  --   The following equalities hold judgmentally:\n  --     \u03a0 [ n >>+ 0 ] \u2261 1\n  --     \u03a0 [ n >>+ suc k ] \u2261 n * \u03a0 [ suc n >>+ k ]\n  \u03a0 : Range \u2192 \u2115\n  \u03a0 = product \u2218 toList\n\n  _ : \u2200 {n} \u2192 \u03a0 [ n >>+ 0 ] \u2261 1\n  _ = refl\n  \n  _ : \u2200 {n k} \u2192 \u03a0 [ n >>+ suc k ] \u2261 n * \u03a0 [ suc n >>+ k ]\n  _ = refl\n  \n  -- Taking the product of all the natural numbers in a certain `Range` behaves\n  --   well with respect to splitting said `Range`\n  \u03a0-+ : \u2200 {n} k l \u2192 \u03a0 [ n >>+ k + l ] \u2261 \u03a0 [ n >>+ k ] * \u03a0 [ n + k >>+ l ]\n  \u03a0-+ {n} k l = begin\n    \u03a0 [ n >>+ k + l ]                                                \u2261\u27e8\u27e9\n    product (toList [ n >>+ k + l ])                                 \u2261\u27e8 cong product (toList-+ k l) \u27e9\n    product (toList [ n >>+ k ] ++ toList [ n + k >>+ l ])           \u2261\u27e8 product-++ (toList [ n >>+ k ]) (toList [ n + k >>+ l ]) \u27e9\n    product (toList [ n >>+ k ]) * product (toList [ n + k >>+ l ])  \u2261\u27e8\u27e9\n    \u03a0 [ n >>+ k ] * \u03a0 [ n + k >>+ l ]                                \u220e\n    where open \u2261-Reasoning\n  \n  -- The special case of splitting just the last element\n  \u03a0-\u2237\u02b3 : \u2200 k l \u2192 \u03a0 [ k >>+ suc l ] \u2261 \u03a0 [ k >>+ l ] * (k + l)\n  \u03a0-\u2237\u02b3 k l = begin\n    \u03a0 [ k >>+ suc l ]                                      \u2261\u27e8\u27e9\n    product (toList [ k >>+ suc l ])                       \u2261\u27e8 cong product (toList-\u2237\u02b3 k l) \u27e9\n    product (toList [ k >>+ l ] \u2237\u02b3 (k + l))                \u2261\u27e8\u27e9\n    product (toList [ k >>+ l ] ++ [ k + l ])              \u2261\u27e8 product-++ (toList [ k >>+ l ]) [ k + l ] \u27e9\n    product (toList [ k >>+ l ]) * product [ k + l ]       \u2261\u27e8\u27e9\n    product (toList [ k >>+ l ]) * ((k + l) * product [])  \u2261\u27e8\u27e9\n    product (toList [ k >>+ l ]) * ((k + l) * 1)           \u2261\u27e8 cong (product (toList [ k >>+ l ]) *_) (*-identity\u02b3 (k + l)) \u27e9\n    product (toList [ k >>+ l ]) * (k + l)                 \u2261\u27e8\u27e9\n    \u03a0 [ k >>+ l ] * (k + l)                                \u220e\n    where open \u2261-Reasoning\n\n  -- \u03a0 is really a generalization of the factorial function\n  !-from-\u03a0 : \u2200 k \u2192 \u03a0 [ 1 >>+ k ] \u2261 k !\n  !-from-\u03a0 zero = refl\n  !-from-\u03a0 (suc k) = begin\n    \u03a0 [ 1 >>+ suc k ]                                    \u2261\u27e8 cong (\u03bb z \u2192 \u03a0 [ 1 >>+ z ]) (+-comm 1 k) \u27e9\n    \u03a0 [ 1 >>+ k + 1 ]                                    \u2261\u27e8 \u03a0-+ k 1 \u27e9\n    \u03a0 [ 1 >>+ k ] * \u03a0 [ suc k >>+ 1 ]                    \u2261\u27e8\u27e9\n    \u03a0 [ 1 >>+ k ] * ((suc k) * \u03a0 [ suc (suc k) >>+ 0 ])  \u2261\u27e8\u27e9\n    \u03a0 [ 1 >>+ k ] * ((suc k) * 1)                        \u2261\u27e8 cong (\u03a0 [ 1 >>+ k ] *_) (*-identity\u02b3 (suc k)) \u27e9\n    \u03a0 [ 1 >>+ k ] * (suc k)                              \u2261\u27e8 *-comm (\u03a0 [ 1 >>+ k ]) (suc k) \u27e9\n    (suc k) * \u03a0 [ 1 >>+ k ]                              \u2261\u27e8 cong ((suc k) *_) (!-from-\u03a0 k) \u27e9\n    (suc k) * k !                                        \u2261\u27e8\u27e9\n    (suc k) !                                            \u220e\n    where open \u2261-Reasoning\n\nmodule _ where\n\n  -- The crucial lemma: the product of the first l nonzero natural numbers divides the product\n  --   of any l consecutive natural numbers\n  \u03a0-1\u2223\u03a0-suc : \u2200 k l \u2192 \u03a0 [ 1 >>+ l ] \u2223 \u03a0 [ k >>+ l ]\n  \u03a0-1\u2223\u03a0-suc k zero = \u2223-refl\n  \u03a0-1\u2223\u03a0-suc zero (suc l) = \u03a0 [ 1 >>+ suc l ] \u22230\n  \u03a0-1\u2223\u03a0-suc (suc k) (suc l) = \u2223-trans (\u2223m\u2223n\u21d2\u2223m+n f1 f2) (\u2223-reflexive (sym lemma))\n    where f1 : \u03a0 [ 1 >>+ suc l ] \u2223 \u03a0 [ k >>+ suc l ]\n          f1 = \u03a0-1\u2223\u03a0-suc k (suc l)\n          f2 : \u03a0 [ 1 >>+ suc l ] \u2223 (suc l) * \u03a0 [ suc k >>+ l ]\n          f2 = begin\n                 \u03a0 [ 1 >>+ suc l ]        \u2261\u27e8 \u03a0-\u2237\u02b3 1 l \u27e9\n                 \u03a0 [ 1 >>+ l ] * (suc l)  \u2261\u27e8 *-comm (\u03a0 [ 1 >>+ l ]) (suc l) \u27e9\n                 (suc l) * \u03a0 [ 1 >>+ l ]  \u2223\u27e8 *-cong (suc l) (\u03a0-1\u2223\u03a0-suc (suc k) l) \u27e9\n                 (suc l) * \u03a0 [ suc k >>+ l ] \u220e\n                 where open \u2223-Reasoning\n          lemma : \u03a0 [ suc k >>+ suc l ] \u2261 \u03a0 [ k >>+ suc l ] + (suc l) * \u03a0 [ suc k >>+ l ]\n          lemma = begin\n                    \u03a0 [ suc k >>+ suc l ]                                \u2261\u27e8 \u03a0-\u2237\u02b3 (suc k) l \u27e9\n                    \u03a0 [ suc k >>+ l ] * (suc k + l)                      \u2261\u27e8 sym (cong (\u03a0 [ suc k >>+ l ] *_) (+-suc k l)) \u27e9\n                    \u03a0 [ suc k >>+ l ] * (k + suc l)                      \u2261\u27e8 *-comm (\u03a0 [ suc k >>+ l ]) (k + suc l) \u27e9\n                    (k + suc l) * \u03a0 [ suc k >>+ l ]                      \u2261\u27e8 *-distrib\u02b3-+ (\u03a0 [ suc k >>+ l ]) k (suc l) \u27e9\n                    k * \u03a0 [ suc k >>+ l ] + (suc l) * \u03a0 [ suc k >>+ l ]  \u2261\u27e8\u27e9\n                    \u03a0 [ k >>+ suc l ] + (suc l) * \u03a0 [ suc k >>+ l ]      \u220e\n                    where open \u2261-Reasoning\n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus x y with \u03a0-1\u2223\u03a0-suc (suc x) y\n... | _\u2223_.divides e p = ( e , p' )\n                        where p' = begin\n                                     (x + y) !                          \u2261\u27e8 sym (!-from-\u03a0 (x + y)) \u27e9\n                                     \u03a0 [ 1 >>+ x + y ]                  \u2261\u27e8 \u03a0-+ x y \u27e9\n                                     \u03a0 [ 1 >>+ x ] * \u03a0 [ suc x >>+ y ]  \u2261\u27e8 cong (_* \u03a0 [ suc x >>+ y ]) (!-from-\u03a0 x) \u27e9\n                                     x ! * \u03a0 [ suc x >>+ y ]            \u2261\u27e8 cong (x ! *_) p \u27e9\n                                     x ! * (e * \u03a0 [ 1 >>+ y ])          \u2261\u27e8 cong (\u03bb z \u2192 x ! * (e * z))(!-from-\u03a0 y) \u27e9\n                                     x ! * (e * y !)                    \u2261\u27e8 sym (*-assoc (x !) e (y !)) \u27e9\n                                     (x ! * e) * y !                    \u2261\u27e8 cong (_* y !) (*-comm (x !) e) \u27e9\n                                     (e * x !) * y !                    \u2261\u27e8 *-assoc e (x !) (y !) \u27e9\n                                     e * (x ! * y !)                    \u220e\n                                     where open \u2261-Reasoning","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":285,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen +-*-Solver\n\nlemma\u2081 : \u2200 x y \u2192 (2 + x + y)! \u2261 (1 + y) * (1 + x + y)! + (1 + x) * (1 + x + y)!\nlemma\u2081 x y = solve 3\n  (\u03bb x y 1+x+y! \u2192\n    (con 2 :+ x :+ y) :* 1+x+y!\n    := (con 1 :+ y) :* 1+x+y! :+ (con 1 :+ x) :* 1+x+y!)\n  refl x y ((1 + x + y)!)\n\nlemma\u2082 : \u2200 x y a b\n  \u2192 ((1 + x) + y)! \u2261 a * ((1 + x)! * y !)\n  \u2192 (x + (1 + y))! \u2261 b * (x ! * (1 + y)!)\n  \u2192 ((1 + x) + (1 + y))!\n    \u2261 (1 + y) * (a * ((1 + x)! * y !)) + (1 + x) * (b * (x ! * (1 + y)!))\nlemma\u2082 x y a b ea eb rewrite +-suc x y | sym ea | sym eb = solve 3\n  (\u03bb x y 1+x+y! \u2192\n    (con 2 :+ x :+ y) :* 1+x+y!\n    := (con 1 :+ y) :* 1+x+y! :+ (con 1 :+ x) :* 1+x+y!)\n  refl x y ((1 + x + y)!)\n\nlemma\u2083 : \u2200 x y a b\n  \u2192 (1 + y) * (a * ((1 + x)! * y !)) + (1 + x) * (b * (x ! * (1 + y)!))\n    \u2261 (a + b) * ((1 + x)! * (1 + y)!)\nlemma\u2083 x y a b = solve 6\n  (\u03bb x y a b x! y! \u2192\n    (con 1 :+ y) :* (a :* (((con 1 :+ x) :* x!) :* y!))\n    :+ (con 1 :+ x) :* (b :* (x! :* ((con 1 :+ y) :* y!)))\n    := (a :+ b) :* (((con 1 :+ x) :* x!) :* ((con 1 :+ y) :* y!)))\n  refl x y a b (x !) (y !)\n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus zero zero = 1 , refl\nfact-times-fact-divides-fact-plus x zero\n  rewrite +-identity\u02b3 x\n  = 1 , solve 1 (\u03bb x! \u2192 x! := x! :* con 1 :+ con 0) refl (x !)\nfact-times-fact-divides-fact-plus zero y\n  = 1 , solve 1 (\u03bb y! \u2192 y! := y! :+ con 0 :+ con 0) refl (y !)\nfact-times-fact-divides-fact-plus (suc x) (suc y)\n  with fact-times-fact-divides-fact-plus (suc x) y\n     | fact-times-fact-divides-fact-plus x (suc y)\n... | a , ea | b , eb\n  = a + b , trans (lemma\u2082 x y a b ea eb) (lemma\u2083 x y a b)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":286,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\nopen \u2261-Reasoning\n\ninfixl 20 _\u203c_\n_\u203c_ : \u2115 \u2192 \u2115 \u2192 \u2115\nn \u203c zero = 1\nn \u203c (suc x) = n * (suc n) \u203c x\n\n\nexclude-last-multiplier : \u2200 (n k : \u2115) \u2192 n \u203c (suc k) \u2261 n \u203c k * (n + k)\nexclude-last-multiplier zero (suc k) rewrite +-identity\u02e1 k | *-comm (0 \u203c k) k = refl\nexclude-last-multiplier n zero = begin\n  n \u203c 1 \u2261\u27e8\u27e9\n  n * (n \u203c 0) \u2261\u27e8 cong (_* (n \u203c 0)) (sym (+-identity\u02b3 n)) \u27e9\n  (n + 0) * (n \u203c 0) \u2261\u27e8 *-comm (n + 0) (n \u203c 0) \u27e9\n  (n \u203c 0) * (n + 0) \u220e\nexclude-last-multiplier n@(suc m) (suc k) = begin\n  n \u203c (suc (suc k)) \u2261\u27e8\u27e9\n  n * (suc n) \u203c (suc k) \u2261\u27e8 cong (n *_) (exclude-last-multiplier (suc n) k) \u27e9\n  n * ((suc n) \u203c k * ((suc n) + k)) \u2261\u27e8 sym (*-assoc n (suc n \u203c k) (suc n + k)) \u27e9\n  n \u203c (suc k) * (suc n + k) \u2261\u27e8 cong (\u03bb x \u2192 n \u203c (suc k) * (x + k)) (+-comm 1 n) \u27e9\n  n \u203c (suc k) * (n + 1 + k) \u2261\u27e8 cong (n \u203c (suc k) *_) (+-assoc n 1 k) \u27e9\n  n \u203c (suc k) * (n + (suc k)) \u220e\n\nconsecutive-division : \u2200 n k \u2192 \u2203[ e ] (n \u203c k \u2261 e * k !)\nconsecutive-division n zero = 1 , refl\nconsecutive-division zero (suc k) = 0 , refl\nconsecutive-division (suc n) (suc k) =\n  let suc-k-proof = consecutive-division n (suc k)\n      suc-n-proof = consecutive-division (suc n) k\n      res\u2081 = proj\u2081 suc-k-proof\n      res\u2082 = proj\u2081 suc-n-proof\n      res = res\u2081 + res\u2082\n      proof = begin\n       (suc n) \u203c (suc k)                                       \u2261\u27e8 exclude-last-multiplier (suc n) k \u27e9\n       (suc n) \u203c k * ((suc n) + k)                             \u2261\u27e8 *-distrib\u02e1-+ ((suc n) \u203c k) (suc n) (k) \u27e9\n       (suc n) \u203c k * (suc n) + (suc n) \u203c k * k                 \u2261\u27e8 cong (\u03bb x \u2192 x + (suc n) \u203c k * k) (*-distrib\u02e1-+ (suc n \u203c k) 1 n) \u27e9\n       ((suc n) \u203c k * 1) + ((suc n) \u203c k * n) + (suc n) \u203c k * k \u2261\u27e8 cong (\u03bb x \u2192 (suc n) \u203c k * 1 + x + (suc n) \u203c k * k) (*-comm ((suc n) \u203c k) n) \u27e9\n       ((suc n) \u203c k * 1) + n \u203c (suc k) + (suc n) \u203c k * k       \u2261\u27e8 cong (_+ (suc n) \u203c k * k) (+-comm ((suc n) \u203c k * 1) (n \u203c (suc k))) \u27e9\n       n \u203c (suc k) + (suc n) \u203c k * 1 + (suc n) \u203c k * k         \u2261\u27e8 +-assoc (n \u203c (suc k)) ((suc n) \u203c k * 1) ((suc n) \u203c k * k) \u27e9\n       n \u203c (suc k) + ((suc n) \u203c k * 1 + (suc n) \u203c k * k)       \u2261\u27e8 cong (n \u203c (suc k) +_) (sym (*-distrib\u02e1-+ ((suc n) \u203c k ) 1 k)) \u27e9\n       n \u203c (suc k) + ((suc n) \u203c k * (suc k))                   \u2261\u27e8 cong\u2082 (\u03bb x y \u2192 x + y * (suc k)) (proj\u2082 suc-k-proof) (proj\u2082 suc-n-proof) \u27e9\n       res\u2081 * (suc k) ! + (res\u2082 * k !) * (suc k)               \u2261\u27e8 cong (\u03bb x \u2192 res\u2081 * (suc k) ! + x) (*-assoc res\u2082 (k !) (suc k)) \u27e9\n       res\u2081 * (suc k) ! + res\u2082 * (k ! * (suc k))               \u2261\u27e8 cong (\u03bb x \u2192 res\u2081 * (suc k) ! + res\u2082 * x) (*-comm (k !) (suc k)) \u27e9\n       res\u2081 * (suc k) ! + res\u2082 * (suc k) !                     \u2261\u27e8 sym (*-distrib\u02b3-+ ((suc k) !) res\u2081 res\u2082) \u27e9\n       (res\u2081 + res\u2082) * (suc k) ! \u2261\u27e8\u27e9\n       res * (suc k) ! \u220e\n  in res   , proof\n\nsplit-fact : \u2200 x y \u2192 (x + y) ! \u2261 x ! * (suc x) \u203c y\nsplit-fact x zero rewrite +-identity\u02b3 x | *-identity\u02b3 (x !) = refl\nsplit-fact x (suc y) = begin\n  (x + (suc y)) ! \u2261\u27e8 cong (_!) (+-comm x (suc y)) \u27e9\n  (suc (y + x)) ! \u2261\u27e8 cong (\u03bb x \u2192 (suc x) !) (+-comm y x) \u27e9\n  (suc x + y) ! \u2261\u27e8 split-fact (suc x) y \u27e9\n  (suc x) ! * (suc (suc x)) \u203c y \u2261\u27e8 cong (_* (suc (suc x)) \u203c y) (*-comm (suc x) (x !)) \u27e9\n  x ! * (suc x) * (suc (suc x)) \u203c y \u2261\u27e8 *-assoc (x !) (suc x) ((suc (suc x)) \u203c y) \u27e9\n  x ! * (suc x) \u203c (suc y) \u220e\n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus x y =\n  let\n    splitproof = consecutive-division (suc x) y\n    res = proj\u2081 splitproof\n    proof = begin\n      (x + y) ! \u2261\u27e8 split-fact x y \u27e9\n      x ! * (suc x) \u203c y \u2261\u27e8 cong (x ! *_) (proj\u2082 splitproof) \u27e9\n      x ! * (res * y !) \u2261\u27e8 sym (*-assoc (x !) res (y !)) \u27e9\n      x ! * res * y ! \u2261\u27e8 cong (_* y !) (*-comm (x !) (res)) \u27e9\n      res * x ! * y ! \u2261\u27e8 *-assoc res (x !) (y !) \u27e9\n      res * (x ! * y !) \u220e\n  in\n  res , proof\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":287,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\n\nopen +-*-Solver\nopen \u2261-Reasoning\n\nopen import Preloaded\n\n-- binom' x y = binom (x+y) x\nbinom' : \u2115 \u2192 \u2115 \u2192 \u2115\nbinom' zero y = 1\nbinom' (suc x) zero = 1\nbinom' (suc x) (suc y) = binom' x (suc y) + binom' (suc x) y\n\nbinom'-closedform : \u2200 x y \u2192 binom' x y * (x ! * y !) \u2261 (x + y) !\nbinom'-closedform zero y = solve 1 (\u03bb t \u2192 t :+ con 0 :+ con 0 := t) refl (y !)\nbinom'-closedform (suc x) zero = trans (solve 1 (\u03bb t \u2192 t :* con 1 :+ con 0 := t) refl (suc x !)) (cong (\u03bb t \u2192 t ! + t * t !) (sym (+-identity\u02b3 x)))\nbinom'-closedform (suc x) (suc y) = begin\n    (binom' x (suc y) + binom' (suc x) y) * (suc x ! * suc y !)\n  \u2261\u27e8 solve 6\n       (\u03bb b b' x y x! y! \u2192 (b :+ b') :* ((x! :+ x :* x!) :* (y! :+ y :* y!)) := b :* (x! :* (y! :+ y :* y!)) :+ x :* (b :* (x! :* (y! :+ y :* y!))) :+ (b' :* ((x! :+ x :* x!) :* y!) :+ y :* (b' :* ((x! :+ x :* x!) :* y!))))refl (binom' x (suc y)) (binom' (suc x) y) x y (x !) (y !) \u27e9\n    suc x * (binom' x (suc y) * (x ! * suc y !)) + suc y * (binom' (suc x) y * (suc x ! * y !))\n  \u2261\u27e8 cong\u2082 (\u03bb s t \u2192 suc x * s + suc y * t) (binom'-closedform x (suc y)) (binom'-closedform (suc x) y) \u27e9\n    suc x * (x + suc y) ! + suc y * (suc x + y) !\n  \u2261\u02d8\u27e8 cong (\u03bb t \u2192 suc x * (x + suc y) ! + suc y * t !) (+-suc x y) \u27e9\n    suc x * (x + suc y) ! + suc y * (x + suc y) !\n  \u2261\u02d8\u27e8 *-distrib\u02b3-+ ((x + suc y) !) (suc x) (suc y) \u27e9\n    (suc x + suc y) * (x + suc y) !\n  \u2261\u27e8\u27e9\n    (suc x + suc y) !\n  \u220e\n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus x y = (binom' x y) , (sym (binom'-closedform x y))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":288,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat.Properties\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat.Solver\nopen import Preloaded\n\nbinom : \u2115 \u2192 \u2115 \u2192 \u2115\nbinom n 0 = 1\nbinom 0 (suc k) = 0\nbinom (suc n) (suc k) = binom n (suc k) + binom n k\n\nbinom-lt : \u2200 (n k) \u2192 n < k \u2192 binom n k \u2261 0\nbinom-lt _ zero ()\nbinom-lt zero (suc k) nk = refl\nbinom-lt (suc n) (suc k) (s\u2264s nk) =\n  let ih = binom-lt n k nk in\n  let ih2 = binom-lt n (suc k) (\u2264-step nk) in\n  cong\u2082 (_+_) ih2 ih\n\nbinom-nn : \u2200 n \u2192 binom n n \u2261 1\nbinom-nn 0 = refl\nbinom-nn (suc n) = cong\u2082 (_+_) (binom-lt n (suc n) \u2264-refl) (binom-nn n)\n\nbinom-div : \u2200 x y \u2192 binom (x + y) x * (x ! * y !) \u2261 (x + y)!\nbinom-div zero y rewrite +-comm (y !) 0 | +-comm (y !) 0 = refl\nbinom-div x zero rewrite +-comm x 0\n  | binom-nn x | *-identity\u02b3 (x !) | +-comm (x !) 0 = refl\nbinom-div (suc x) (suc y) = begin\n  binom (m + n) m * (m ! * n !)\n  \u2261\u27e8 *-distrib\u02b3-+ (m ! * n !) (binom (x + n) m) (binom (x + n) x) \u27e9\n  binom (x + n) m * (m ! * n !) + binom (x + n) x * (m ! * n !)\n  \u2261\u27e8 cong\u2082 (_+_) eq1 eq2 \u27e9\n  (x + n)! * n + (x + n)! * m \u2261\u27e8 sym (*-distrib\u02e1-+ ((x + n)!) n m) \u27e9\n  (x + n)! * (n + m)          \u2261\u27e8 *-comm ((x + n) !) (n + m) \u27e9\n  (n + m) * (x + n)!          \u2261\u27e8 cong (_* (x + n)!) (+-comm n m) \u27e9\n  (m + n)! \u220e\n  where\n    open +-*-Solver\n    open \u2261-Reasoning\n    m : \u2115\n    m = suc x\n    n : \u2115\n    n = suc y\n    eq1 : binom (x + n) m * (m ! * n !) \u2261 (x + n)! * n\n    eq1 = begin\n      binom (x + n) m * (m ! * n !) \u2261\u27e8 cong (\u03bb t \u2192 binom t m * (m ! * n !)) (+-suc x y) \u27e9\n      binom (m + y) m * (m ! * (n * y !))\n      \u2261\u27e8 solve 4 (\u03bb b m n y \u2192 b :* (m :* (n :* y)) := (b :* (m :* y)) :* n) refl (binom (m + y) m) (m !) n (y !) \u27e9\n      (binom (m + y) m * (m ! * y !)) * n \u2261\u27e8 cong (_* n) (binom-div m y) \u27e9\n      (m + y)! * n \u2261\u27e8 cong (\u03bb t \u2192 t ! * n) (sym (+-suc x y)) \u27e9\n      (x + n)! * n \u220e\n    eq2 : binom (x + n) x * (m ! * n !) \u2261 (x + n)! * m\n    eq2 = begin\n      binom (x + n) x * (m * x ! * n !)\n      \u2261\u27e8 solve 4 (\u03bb b m x n \u2192 b :* (m :* x :* n) := (b :* (x :* n)) :* m) refl (binom (x + n) x) m (x !) (n !) \u27e9\n      (binom (x + n) x * (x ! * n !)) * m \u2261\u27e8 cong (_* m) (binom-div x n) \u27e9\n      (x + n)! * m \u220e\n\nfact-times-fact-divides-fact-plus : \u2200 x y \u2192 \u2203 \u03bb e \u2192 (x + y)! \u2261 e * (x ! * y !)\nfact-times-fact-divides-fact-plus x y = (binom (x + y) x) , sym (binom-div x y)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5ce5b742035e19001425ec7c":[{"id":289,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Agda.Builtin.Size\nopen import Data.Nat\n\nrecord Stream {i : Size} (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : \u2200 {j : Size< i} \u2192 Stream {j} A\n\nZipWith = \u2200 {i} {A B C : Set} -> (A -> B -> C)\n        -> Stream {i} A -> Stream {i} B -> Stream {i} C\nCofib = \u2200 {i} \u2192 Stream {i} \u2115\nCoones = \u2200 {i} \u2192 Stream {i} \u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":290,"user_id":29,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Agda.Builtin.Size\n\nrecord Stream {i : Size} (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : {j : Size< i} \u2192 Stream {j} A \n\nZipWith = \u2200 {i : Size} {A B C : Set} -> (A -> B -> C)\n        -> Stream {i} A -> Stream {i} B -> Stream {i} C\nCofib = {i : Size} \u2192 Stream {i} \u2115\nCoones = {i : Size} \u2192 Stream {i} \u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":291,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Size\n\nrecord Stream {i : Size} (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : \u2200 {j : Size< i} \u2192 Stream {j} A\n\nopen Stream\n\nZipWith = \u2200 {i} {A B C : Set} \u2192 (A \u2192 B \u2192 C) \u2192 Stream {i} A \u2192 Stream {i} B \u2192 Stream {i} C\nCofib = \u2200 {i} \u2192 Stream {i} \u2115\nCoones = \u2200 {i} \u2192 Stream {i} \u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":292,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Size\nopen import Data.Nat\n\nrecord Stream {i : Size} (A : Set) :  Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : \u2200 {j : Size< i} \u2192 Stream {j} A\n\n\nZipWith = \u2200 {A B C : Set} {i : Size} {j : Size< i} -> (A -> B -> C)\n        -> Stream {i} A -> Stream {j} B -> Stream {j} C\nCofib = {i : Size} {j : Size< i} \u2192 Stream {j} \u2115\nCoones = {i : Size} {j : Size< i} \u2192 Stream {j} \u2115","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":293,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Agda.Builtin.Size\n\nrecord Stream {i : Size} (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : {j : Size< i} \u2192 Stream {j} A \n\nZipWith = \u2200 {A B C : Set} {i : Size} {j : Size< i} -> (A -> B -> C)\n        -> Stream {i} A -> Stream {j} B -> Stream {j} C\nCofib = {i : Size} {j : Size< i} \u2192 Stream {j} \u2115\nCoones = {i : Size} {j : Size< i} \u2192 Stream {j} \u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":294,"user_id":106,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Size\n\nrecord Stream {i : Size} (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : \u2200{j : Size< i} -> Stream {j} A\n\nZipWith = \u2200 {i : Size} {A B C : Set} -> (A -> B -> C) -> Stream {i} A -> Stream {i} B -> Stream {i} C\nCofib = \u2200 {i : Size} \u2192 Stream {i} \u2115\nCoones = \u2200 {i : Size} \u2192 Stream {i} \u2115\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":295,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Size\n\nrecord Stream (i : Size) (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : \u2200 {j : Size< i} \u2192 Stream j A\n\nZipWith = \u2200 {i : Size} {A B C : Set} \u2192 (A \u2192 B \u2192 C)\n  \u2192 Stream i A \u2192 Stream i B \u2192 Stream i C\nCofib = \u2200 {i} \u2192 Stream i \u2115\nCoones = Cofib\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":296,"user_id":null,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Size using (Size; Size<_)\n\nrecord Stream {i : Size} (A : Set) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : \u2200 {j : Size< i} \u2192 Stream {j} A\n\nZipWith = \u2200 {i : Size} {A B C : Set} -> (A -> B -> C)\n        -> Stream {i} A -> Stream {i} B -> Stream {i} C\nCofib = \u2200 {i : Size} \u2192 Stream {i} \u2115\nCoones = \u2200 {i : Size} \u2192 Stream {i} \u2115","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":297,"user_id":527,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Size\n\nrecord Stream (A : Set) (i : Size) : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : {j : Size< i} -> Stream A j\n\nZipWith = \u2200 {A B C : Set} {i : Size} -> (A -> B -> C)\n        -> Stream A i -> Stream B i -> Stream C i\nCofib = \u2200 {i} -> Stream \u2115 i\nCoones = \u2200 {i} -> Stream \u2115 i","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":298,"user_id":522,"body":"{-# OPTIONS --safe --sized-types #-}\nmodule SizedCoin where\n\nopen import Data.Nat\nopen import Size\n\n\nrecord Stream (A : Set) {i : Size} : Set where\n  coinductive\n  constructor _\u2237_\n  field\n    head : A\n    tail : {j : Size< i} \u2192 Stream A {j}\n\nZipWith = \u2200 {A B C : Set} {i j : Size} -> (A -> B -> C)\n        -> Stream A {i} -> Stream B {i} -> Stream C {i}\nCofib  = {i : Size} \u2192 Stream \u2115 {i}\nCoones = {i : Size} \u2192 Stream \u2115 {i}","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5cf8dc6acb266c00242d7ba3":[{"id":299,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Preloaded\n\ntrim : \u2200 {X x y} {xs ys : List X} \u2192 Suf (x \u2237 xs) (y \u2237 ys) \u2192 Suf xs ys\ntrim (sinit (z \u2237 zs)) = sinit zs\ntrim (scons k (v \u2237 vs) (p \u2237 ps) s) = scons v vs ps (trim s)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more v (x \u2237 xs) s with less-is-not-more x xs\n... | r = \u22a5-elim (r (trim s))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":300,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\n\nsuf-length : \u2200 {X} {l l' : List X} \u2192 Suf l l' \u2192 length l' \u2264 length l\nsuf-length (sinit l) = \u2264-refl\nsuf-length (scons x l l' suf) = \u2264-step (suf-length suf)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x l suf = n\u226en _ (suf-length suf)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":301,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Preloaded\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.List public\n\ndata Suf {X : Set} : List X \u2192 List X \u2192 Set where\n  sinit : \u2200 l \u2192 Suf l l\n  scons : \u2200 x l l' \u2192 Suf l l' \u2192 Suf (x \u2237 l) l'\n-}\n\nless : \u2200 {X} x (l l' : List X) \u2192 Suf l (x \u2237 l') \u2192 Suf l l'\nless x .(x \u2237 l') l' (sinit .(x \u2237 l'))        = scons x l' l' (sinit l')\nless x .(x\u2081 \u2237 l) l' (scons x\u2081 l .(x \u2237 l') p) = scons x\u2081 l l' (less x l l' p)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x []      = \u03bb ()\nless-is-not-more x (y \u2237 l) = \u03bb p \u2192 less-is-not-more y l (q p)\n  where\n    q : Suf (y \u2237 l) (x \u2237 y \u2237 l) \u2192 Suf l (y \u2237 l)\n    q (scons .y .l .(x \u2237 y \u2237 l) p) = less x l (y \u2237 l) p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":302,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\n\nlen-lem : {X : Set} {l\u2081 l\u2082 : List X} \u2192 Suf l\u2081 l\u2082 \u2192 length l\u2081 \u2265 length l\u2082\nlen-lem (sinit l) = \u2264-refl\nlen-lem (scons x l\u2081 l\u2082 \ud835\udcc8) = \u2264-step (len-lem \ud835\udcc8)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x l \ud835\udcc8 = 1+n\u2270n (len-lem \ud835\udcc8)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":303,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Data.List \nopen import Data.Nat\nimport Data.List.Properties\nopen import Data.Nat.Properties\nopen import Data.Empty\nopen import Data.Sum renaming (_\u228e_ to _\u2228_ ; inj\u2081 to orLeft ; inj\u2082 to orRight)\nopen import Data.Product renaming (_\u00d7_ to _\u2227_ ; proj\u2081 to fst ; proj\u2082 to snd)\nopen import Relation.Binary.PropositionalEquality\n\nopen import Preloaded\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.List public\n\ndata Suf {X : Set} : List X \u2192 List X \u2192 Set where\n  sinit : \u2200 l \u2192 Suf l l\n  scons : \u2200 x l l' \u2192 Suf l l' \u2192 Suf (x \u2237 l) l'\n-}\n\n\nfind-prefix : {X : Set} \u2192 (l : List X) \u2192 (s : List X) \u2192 Suf l s \u2192 \u2203 (\u03bb (pre : List X) \u2192 pre ++ s \u2261 l)\nfind-prefix {X} [] [] p = [] , refl\nfind-prefix {X} (x \u2237 l) .(x \u2237 l) (sinit .(x \u2237 l)) = [] , refl\nfind-prefix {X} (x \u2237 l) s (scons .x .l .s p) = \n    x \u2237 (fst (find-prefix l s p)) , cong (x \u2237_) (snd (find-prefix l s p))\n\n\u2261\u21d2\u2264 : {a b : \u2115} \u2192 a \u2261 b \u2192 a \u2264 b\n\u2261\u21d2\u2264 {zero} {.0} refl = z\u2264n\n\u2261\u21d2\u2264 {suc a} {.(suc a)} refl = s\u2264s (\u2261\u21d2\u2264 {a} {a} refl)\n\na\u2264a+b : {a b : \u2115} \u2192 a \u2264 a + b\na\u2264a+b {a} {zero} rewrite +-identity\u02b3 a = \u2261\u21d2\u2264 refl\na\u2264a+b {a} {suc b} rewrite +-comm a (suc b) | +-comm b a = \u2264-step (a\u2264a+b {a} {b})\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more {X} x l p = helper (snd (find-prefix l (x \u2237 l) p)) (length<length++\u2237 (fst (find-prefix l (x \u2237 l) p)) l x)\n    where   length<length++\u2237 : {X : Set} (pre l : List X) \u2192 (x : X) \u2192 \n                             length l < length (pre ++ x \u2237 l) \n            length<length++\u2237 {X} pre l x = begin\n                suc (length l) \u2261\u27e8 sym (Data.List.Properties.length-++ (x \u2237 []) {l}) \u27e9\n                (length (x \u2237 l)) \u2264\u27e8 a\u2264a+b {(length (x \u2237 l))} {length pre} \u27e9\n                (length (x \u2237 l)) + (length pre) \u2261\u27e8 +-comm (suc (foldr (\u03bb _ \u2192 suc) zero l)) (foldr (\u03bb _ \u2192 suc) zero pre) \u27e9\n                (length pre) + (length (x \u2237 l)) \u2261\u27e8 sym (Data.List.Properties.length-++ pre {x \u2237 l}) \u27e9\n                length (pre ++ x \u2237 l)    \u220e where open \u2264-Reasoning\n\n            helper : {X : Set} {pre : List X} {x : X} {l : List X} \u2192 \n                     pre ++ x \u2237 l \u2261 l \u2192 length l < length (pre ++ x \u2237 l) \u2192 \u22a5\n            helper {X} {pre} {x} {l} p1 p2 rewrite p1 = 1+n\u2270n p2","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":304,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Data.Nat.Base\nopen import Data.Nat.Properties \nopen import Preloaded\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.List public\n\ndata Suf {X : Set} : List X \u2192 List X \u2192 Set where\n  sinit : \u2200 l \u2192 Suf l l\n  scons : \u2200 x l l' \u2192 Suf l l' \u2192 Suf (x \u2237 l) l'\n-}\n\nsuffix-smaller : \u2200 {X} {l l' : List X} \u2192 Suf l l' \u2192 length l' \u2264 length l\nsuffix-smaller (sinit _) = \u2264-refl\nsuffix-smaller (scons x l _ h) = \u2264-trans (suffix-smaller h) (n\u22641+n _)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x l h = 1+n\u2270n (suffix-smaller h)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":305,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Preloaded\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.List public\n\ndata Suf {X : Set} : List X \u2192 List X \u2192 Set where\n  sinit : \u2200 l \u2192 Suf l l\n  scons : \u2200 x l l' \u2192 Suf l l' \u2192 Suf (x \u2237 l) l'\n-}\n\nSuf-lem : \u2200 {X} {x} {l1 l2 : List X} \u2192 Suf l1 (x \u2237 l2) \u2192 Suf l1 l2\nSuf-lem {X} {x} {.(x \u2237 l2)} {l2} (sinit .(x \u2237 l2)) = scons x l2 l2 (sinit l2)\nSuf-lem {X} {x} {.(y \u2237 l)} {l2} (scons y l .(x \u2237 l2) suf) = scons y l l2 (Suf-lem suf)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x (y \u2237 l) (scons .y .l .(x \u2237 y \u2237 l) suf) = (less-is-not-more y l) (Suf-lem suf) \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":306,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Relation.Nullary\n\nopen import Preloaded\n\nn<1+n : \u2200 n \u2192 n < 1 + n\nn<1+n n = \u2264-refl\n\nsuf\u21d2len\u2265 : \u2200 {X : Set} {xs ys : List X} \u2192 Suf xs ys \u2192 length xs \u2265 length ys\nsuf\u21d2len\u2265 (sinit xs)          = \u2264-refl\nsuf\u21d2len\u2265 (scons x xs ys suf) = \u2264-step (suf\u21d2len\u2265 suf)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x l suf = \u2264\u21d2\u226f len-suf len-cons\n  where\n  len-suf : length l \u2265 length (x \u2237 l)\n  len-suf = suf\u21d2len\u2265 suf\n  \n  len-cons : length l < length (x \u2237 l)\n  len-cons = n<1+n (length l)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":307,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Nullary\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\n{- Preloaded:\n\nmodule Preloaded where\n\nopen import Data.List public\n\ndata Suf {X : Set} : List X \u2192 List X \u2192 Set where\n  sinit : \u2200 l \u2192 Suf l l\n  scons : \u2200 x l l' \u2192 Suf l l' \u2192 Suf (x \u2237 l) l'\n-}\n\n\nlem : \u2200 {X : Set} {l l' : List X} \u2192 Suf l l' \u2192 length l' \u2264 length l\nlem (sinit _) = \u2264-refl\nlem (scons x l _ p) = \u2264-step (lem p)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x l suf = n\u226en _ (lem suf)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":308,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Function\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary.Negation\n\nlemma : \u2200 {A} \u2192 (l1 l2 : List A) \u2192 Suf l1 l2 \u2192 length l1 \u2265 length l2\nlemma l1 .l1 (sinit .l1) = \u2264-reflexive refl\nlemma .(x \u2237 l) l2 (scons x l .l2 s) = \u2264-step (lemma l l2 s)\n\nless-is-not-more : \u2200 {X} x (l : List X) \u2192 \u00ac Suf l (x \u2237 l)\nless-is-not-more x l =\n  let p = (length l < length (x \u2237 l)) \u220b (\u2264-reflexive refl) in\n  contraposition (lemma l (x \u2237 l)) (<\u21d2\u2271 p)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5d0e57ec1c5fdd000146b7d9":[{"id":309,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties using (+-identity\u02b3; +-assoc; +-comm; *-assoc; *-identity\u02b3; *-distrib\u02b3-+)\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\n-- my sincere apologies for this artisanal, handcrafted mess\n-- i didn't feel like learning the API for the old semiring solver\n-- so i did it all by hand :)\nlemma : \u2200 acc x cs \u2192 horner-loop acc x cs \u2261 eval-poly x cs + acc * x ^ length cs\nlemma acc x [] = sym (*-identity\u02b3 acc)\nlemma acc x (c \u2237 cs) = begin\n  horner-loop (acc * x + c) x cs                                       \u2261\u27e8 lemma (acc * x + c) x cs \u27e9\n  eval-poly x cs + (acc * x + c) * x ^ length cs                       \u2261\u27e8 cong (eval-poly x cs +_) helper \u27e9\n  eval-poly x cs + (c * x ^ length cs + acc * (x * (x ^ length cs)))   \u2261\u27e8 sym (+-assoc (eval-poly x cs) (c * (x ^ length cs)) (acc * (x * (x ^ length cs)))) \u27e9\n  eval-poly x cs + c * x ^ length cs + acc * (x * (x ^ length cs))     \u220e\n  where\n    helper : (acc * x + c) * x ^ length cs \u2261 (c * (x ^ length cs) + acc * (x * (x ^ length cs)))\n    helper = begin\n      (acc * x + c) * x ^ length cs                 \u2261\u27e8 *-distrib\u02b3-+ _ (acc * x) c \u27e9\n      acc * x * x ^ length cs + c * x ^ length cs   \u2261\u27e8 +-comm (acc * x * _) (c * _) \u27e9\n      c * x ^ length cs + acc * x * x ^ length cs   \u2261\u27e8 cong (c * (x ^ length cs) +_) (*-assoc acc x (x ^ length cs)) \u27e9\n      c * x ^ length cs + acc * (x * x ^ length cs) \u220e\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x cs = begin\n  eval-poly x cs                        \u2261\u27e8 sym (+-identity\u02b3 (eval-poly x cs)) \u27e9\n  eval-poly x cs + zero * x ^ length cs \u2261\u27e8 sym (lemma zero x cs) \u27e9\n  horner x cs                           \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":310,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\nlemma\u2081 : \u2200 acc an x n \u2192 an * x ^ n + acc * x ^ suc n \u2261 (acc * x + an) * x ^ n\nlemma\u2081 acc an x n =\n  begin\n    an * x ^ n + acc * x ^ suc n\n  \u2261\u27e8\u27e9\n    an * x ^ n + acc * (x * x ^ n)\n  \u2261\u02d8\u27e8 cong (an * (x ^ n) +_) (*-assoc acc x (x ^ n)) \u27e9\n    an * x ^ n + acc * x * x ^ n\n  \u2261\u27e8 +-comm (an * (x ^ n)) (acc * x * (x ^ n)) \u27e9\n    acc * x * x ^ n + an * x ^ n\n  \u2261\u02d8\u27e8 *-distrib\u02b3-+ (x ^ n) (acc * x) an \u27e9\n    (acc * x + an) * x ^ n\n  \u220e\n\nlemma\u2082 : \u2200 acc x cf \u2192 eval-poly x cf + acc * x ^ length cf  \u2261 horner-loop acc x cf\nlemma\u2082 acc x [] = *-identity\u02b3 acc \nlemma\u2082 acc x (an \u2237 cf) =\n  begin\n    eval-poly x (an \u2237 cf) + acc * x ^ length (an \u2237 cf)\n  \u2261\u27e8\u27e9\n    eval-poly x cf + an * x ^ length cf + acc * (x * x ^ length cf)\n  \u2261\u27e8 +-assoc (eval-poly x cf) (an * (x ^ length cf)) _ \u27e9\n    eval-poly x cf + (an * x ^ length cf + acc * (x * x ^ length cf))\n  \u2261\u27e8 cong (eval-poly x cf +_) (lemma\u2081 acc an x (length cf)) \u27e9\n    eval-poly x cf + (acc * x + an) * x ^ length cf\n  \u2261\u27e8 lemma\u2082 (acc * x + an) x cf \u27e9\n    horner-loop (acc * x + an) x cf\n  \u2261\u27e8\u27e9\n    horner-loop acc x (an \u2237 cf)\n  \u220e\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x cf =\n  begin\n    eval-poly x cf\n  \u2261\u02d8\u27e8 +-identity\u02b3 (eval-poly x cf) \u27e9\n    eval-poly x cf + 0\n  \u2261\u27e8 lemma\u2082 zero x cf \u27e9\n    horner-loop 0 x cf\n  \u220e\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":311,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.List\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nsafe-last : List \u2115 \u2192 \u2115\nsafe-last [] = 0\nsafe-last (x \u2237 []) = x\nsafe-last (x \u2237 xs) = safe-last xs\n\nlem1 : (xs : List \u2115) \u2192 horner 0 xs \u2261 safe-last xs\nlem1 [] = refl\nlem1 (x \u2237 []) = refl\nlem1 (x \u2237 y \u2237 xs) = begin\n  horner-loop (x * 0 + y) 0 xs    \u2261\u27e8 cong (\u03bb v \u2192 horner-loop (v + y) 0 xs) (*-comm x 0) \u27e9\n  horner-loop 0 0 (y \u2237 xs)        \u2261\u27e8 lem1 (y \u2237 xs) \u27e9\n  safe-last (y \u2237 xs)              \u220e\n\nlem2 : (xs : List \u2115) \u2192 eval-poly 0 xs \u2261 safe-last xs\nlem2 [] = refl\nlem2 (x \u2237 []) = *-identity\u02b3 x\nlem2 (x \u2237 y \u2237 xs) = begin\n  eval-poly 0 (y \u2237 xs) + x * 0    \u2261\u27e8 cong\u2082 _+_ (lem2 (y \u2237 xs)) (*-comm x 0) \u27e9\n  safe-last (y \u2237 xs) + 0          \u2261\u27e8 +-comm (safe-last (y \u2237 xs)) 0 \u27e9\n  safe-last (y \u2237 xs)              \u220e\n\nlem3 : (a : \u2115) \u2192 (v : \u2115) \u2192 (w : \u2115) \u2192 (xs : List \u2115) \u2192 horner-loop (a + w) v xs \u2261 horner-loop a v xs + w * v ^ length xs\nlem3 acc v o [] = cong (acc +_) (sym (^-identity\u02b3 o))\nlem3 acc v o (x \u2237 xs) = begin\n  horner-loop ((acc + o) * v + x) v xs                   \u2261\u27e8 cong (\u03bb k \u2192 horner-loop (k + x) v xs) (*-distrib\u02b3-+ v acc o) \u27e9\n  horner-loop (acc * v + o * v + x) v xs                 \u2261\u27e8 cong (\u03bb k \u2192 horner-loop k v xs) (+-assoc (acc * v) (o * v) x) \u27e9\n  horner-loop (acc * v + (o * v + x)) v xs               \u2261\u27e8 cong (\u03bb k \u2192 horner-loop (acc * v + k) v xs) (+-comm (o * v) x) \u27e9\n  horner-loop (acc * v + (x + o * v)) v xs               \u2261\u27e8 cong (\u03bb k \u2192 horner-loop k v xs) (sym (+-assoc (acc * v) x (o * v))) \u27e9\n  horner-loop (acc * v + x + o * v) v xs                 \u2261\u27e8 lem3 (acc * v + x) v (o * v) xs \u27e9\n  horner-loop acc v (x \u2237 xs) + (o * v) * v ^ length xs   \u2261\u27e8 cong ((horner-loop acc v (x \u2237 xs)) +_) (*-assoc o v (v ^ length xs)) \u27e9\n  horner-loop acc v (x \u2237 xs) + o * v ^ length (x \u2237 xs)   \u220e\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct n [] = refl\nhorner-correct zero (x \u2237 xs) = trans (lem2 (x \u2237 xs)) (sym (lem1 (x \u2237 xs)))\nhorner-correct (suc n) (x \u2237 xs) = begin\n  eval-poly (suc n) xs + x * (suc n) ^ length xs   \u2261\u27e8 cong (_+ (x * (suc n) ^ length xs)) (horner-correct (suc n) xs) \u27e9\n  horner (suc n) xs + x * (suc n) ^ length xs      \u2261\u27e8 sym (lem3 0 (suc n) x xs) \u27e9\n  horner (suc n) (x \u2237 xs)                          \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":312,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\n\nopen Data.Nat.Solver.+-*-Solver\n  using (prove; solve; _:=_; con; var; _:+_; _:*_; :-_; _:-_ ; _:^_)\n\n\n--lemmas \nsolver-lemma : \u2200 (h acc x xn an : \u2115) \u2192 h + (acc * x + an) * xn \u2261\n  h + (an * xn) + (acc * (x * xn))\nsolver-lemma h acc x xn an = solve 5 (\u03bb ht acct xt xnt ant \u2192 \n    (ht :+ (acct :* xt :+ ant) :* xnt) := \n    (ht :+ (ant :* xnt)) :+ (acct :* (xt :* xnt)))\n  refl h acc x xn an\n\nhorner-loop-lemma : \u2200 acc x cf -> horner-loop acc x cf \u2261 horner-loop 0 x cf\n  + acc * x ^ length cf\nhorner-loop-lemma acc x [] = sym (*-identity\u02b3 acc)\nhorner-loop-lemma acc x (an \u2237 cf) rewrite horner-loop-lemma (acc * x + an) x cf \n | horner-loop-lemma an x cf = \n    solver-lemma (horner-loop zero x cf) acc x (x ^ foldr (\u03bb _ \u2192 suc) zero cf) an\n\n--solution\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x [] = refl\nhorner-correct x (an \u2237 cf) rewrite horner-correct x cf = (sym (horner-loop-lemma an x cf))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":313,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\nopen Relation.Binary.PropositionalEquality.\u2261-Reasoning\n\n\nlem : (m x : \u2115) -> (cf : List \u2115) -> horner-loop 0 x cf + m * (x ^ length cf) \u2261 horner-loop m x cf\nlem m x [] = *-identity\u02b3 _\nlem m x (an \u2237 cf) = begin\n  horner-loop 0 x (an \u2237 cf) + m * (x ^ length (an \u2237 cf))\n    \u2261\u27e8 cong f (sym (lem an x cf)) \u27e9\n  horner-loop 0 x cf + an * (x ^ length cf) + m * (x ^ length (an \u2237 cf))\n    \u2261\u27e8 +-assoc (horner-loop 0 x cf) (an * (x ^ length cf)) (m * (x ^ length (an \u2237 cf))) \u27e9\n  horner-loop 0 x cf + (an * (x ^ length cf) + m * (x * x ^ length cf))\n    \u2261\u27e8 cong g (sym (*-assoc m x (x ^ length cf))) \u27e9 -- assoc\n  horner-loop 0 x cf + (an * (x ^ length cf) + m * x * x ^ length cf)\n    \u2261\u27e8 cong h (sym (*-distrib\u02b3-+ (x ^ length cf) an (m * x))) \u27e9\n  horner-loop 0 x cf + (an + m * x) * x ^ length cf\n    \u2261\u27e8 lem (an + m * x) x cf \u27e9\n  horner-loop (an + m * x) x cf\n    \u2261\u27e8 cong z (+-comm an (m * x)) \u27e9\n  horner-loop m x (an \u2237 cf)\n  \u220e\n  where\n    f : \u2115 \u2192 \u2115\n    f t = t + m * (x ^ length (an \u2237 cf))\n    g : \u2115 \u2192 \u2115\n    g t = horner-loop 0 x cf + (an * (x ^ length cf) + t)\n    h : \u2115 \u2192 \u2115\n    h t = horner-loop 0 x cf + t\n    z : \u2115 \u2192 \u2115\n    z t = horner-loop t x cf\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x [] = refl\nhorner-correct x (a \u2237 as) = begin\n  eval-poly x as + a * (x ^ length as)     \u2261\u27e8 cong (\u03bb t \u2192 t + a * (x ^ length as)) (horner-correct x as) \u27e9\n  horner-loop 0 x as + a * (x ^ length as) \u2261\u27e8 lem a x as \u27e9\n  horner x (a \u2237 as)                        \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":314,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nlemma : \u2200 x a ks \u2192 horner-loop a x ks \u2261 horner x ks + a * (x ^ length ks)\nlemma x a [] = sym (*-identity\u02b3 a)\nlemma x a (k \u2237 ks) = sym (begin\n                              horner-loop k x ks + a * (x * (x ^ length ks)) \u2261\u27e8 cong (\u03bb t \u2192 t + a * (x * (x ^ length ks))) (lemma x k ks) \u27e9\n                              horner x ks + k * (x ^ length ks) + a * (x * (x ^ length ks)) \u2261\u27e8 cong (\u03bb t \u2192  horner x ks + k * (x ^ length ks) + t) (sym (*-assoc a x (x ^ length ks))) \u27e9\n                              horner x ks + k * (x ^ length ks) + a * x * (x ^ length ks) \u2261\u27e8 +-assoc (horner-loop 0 x ks) (k * (x ^ length ks)) (a * x * (x ^ length ks)) \u27e9\n                              horner x ks + (k * (x ^ length ks) + a * x * (x ^ length ks)) \u2261\u27e8 cong (\u03bb t \u2192 horner x ks + t) (sym (*-distrib\u02b3-+ (x ^ length ks) k (a * x))) \u27e9\n                              horner x ks + (k + a * x) * (x ^ length ks)  \u2261\u27e8 sym (lemma x (k + a * x) ks) \u27e9\n                              horner-loop (k + a * x) x ks \u2261\u27e8 cong (\u03bb t \u2192 horner-loop t x ks) (+-comm k (a * x)) \u27e9\n                              horner-loop (a * x + k) x ks \u220e)\n\n\nhorner-correct : \u2200 x ks \u2192 eval-poly x ks \u2261 horner x ks\nhorner-correct x [] = refl\nhorner-correct x (k \u2237 ks) = begin\n                                  eval-poly x ks + k * (x ^ length ks) \u2261\u27e8 cong (\u03bb t \u2192 t + k * (x ^ length ks)) (horner-correct x ks) \u27e9\n                                  horner x ks + k * (x ^ length ks) \u2261\u27e8 sym (lemma x k ks) \u27e9\n                                  horner-loop 0 x (k \u2237 ks) \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":315,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x [] = refl\nhorner-correct x (an \u2237 cf) = begin\n  _ \u2261\u27e8 cong (\u03bb z -> z + an * x ^ length cf) (horner-correct x cf) \u27e9\n  _ \u2261\u27e8 lem an cf \u27e9\n  _ \u220e\n  where\n  lem : (m : \u2115) -> (cf : List \u2115) ->\n        horner-loop 0 x cf + m * (x ^ length cf) \u2261\n        horner-loop m x cf\n  lem m [] = *-identity\u02b3 _\n  lem m (an \u2237 cf) = begin\n    _ \u2261\u27e8 sym (cong (\u03bb z -> z + m * (x * (x ^ length cf))) (lem an cf)) \u27e9\n    _ \u2261\u27e8 +-assoc (horner-loop 0 x cf) (an * (x ^ length cf)) (m * (x * (x ^ length cf))) \u27e9\n    _ \u2261\u27e8 cong (\u03bb z -> horner-loop 0 x cf + z)\n              (+-comm (an * (x ^ length cf)) (m * (x * (x ^ length cf)))) \u27e9\n    _ \u2261\u27e8 sym (cong (\u03bb z -> horner-loop 0 x cf + (z + an * (x ^ length cf)))\n                   (*-assoc m x (x ^ length cf))) \u27e9\n    _ \u2261\u27e8 sym (cong (\u03bb z -> horner-loop 0 x cf + z)\n                   (*-distrib\u02b3-+ (x ^ length cf) (m * x) an)) \u27e9\n    _ \u2261\u27e8 lem (m * x + an) cf \u27e9\n    _ \u220e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":316,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\n\nopen \u2261-Reasoning\nopen +-*-Solver using (solve; _:*_; _:+_; con; _:=_)\n\nhorner-invariant : \u2200 a x cf \u2192 eval-poly x cf + a * x ^ length cf \u2261 horner-loop a x cf\nhorner-invariant a x [] = *-identity\u02b3 a\nhorner-invariant a x (a' \u2237 cf) = begin\n  v + a' * x' + a * (x * x')\n    \u2261\u27e8 solve 5 (\u03bb v a x a' x' \u2192\n         v :+ a' :* x' :+ a :* (x :* x') := v :+ (a :* x :+ a') :* x')\n              refl v a x a' x' \u27e9\n  v + (a * x + a') * x'\n    \u2261\u27e8 horner-invariant (a * x + a') x cf \u27e9\n  horner-loop (a * x + a') x cf \u220e\n  where v = eval-poly x cf\n        x' = x ^ length cf\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x cf = begin\n  v \u2261\u27e8 sym (+-identity\u02b3 v) \u27e9\n  v + 0 \u2261\u27e8 horner-invariant 0 x cf \u27e9\n  horner x cf \u220e\n  where v = eval-poly x cf\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":317,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\n\nhorner-loop-acc-addition : \u2200 acc x ys \u2192 horner-loop acc x ys \u2261 (horner-loop 0 x ys) + acc * x ^ length ys\nhorner-loop-acc-addition acc x []\n  rewrite *-identity\u02b3 acc = refl\nhorner-loop-acc-addition acc x (y \u2237 ys)\n  rewrite horner-loop-acc-addition (acc * x + y) x ys\n  | *-distrib\u02b3-+ (x ^ length ys) (acc * x) y\n  | +-comm (acc * x * x ^ (length ys)) (y * x ^ (length ys))\n  | sym (horner-loop-acc-addition y x ys)\n  | *-assoc acc x (x ^ length ys)\n  | (horner-loop-acc-addition y x ys)\n  | +-assoc (horner-loop 0 x ys) (y * x ^ length ys) (acc * (x * (x ^ length ys))) = refl\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x [] = refl\nhorner-correct x (an \u2237 cf)\n  rewrite horner-correct x cf\n  | horner-loop-acc-addition an x cf = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":318,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.Solver\nopen import Relation.Binary.PropositionalEquality\n\nhorner-loop-acc-prop : \u2200 (a x : \u2115) (cs : List \u2115) \u2192 horner-loop a x cs \u2261 horner-loop 0 x cs + a * (x ^ length cs)\nhorner-loop-acc-prop a x [] rewrite *-identity\u02b3 a = refl\nhorner-loop-acc-prop a x (c \u2237 cs)\n  rewrite horner-loop-acc-prop (a * x + c) x cs\n        | horner-loop-acc-prop c x cs\n        | +-comm (a * x) c\n        | *-distrib\u02b3-+ (x ^ length cs) c (a * x)\n        | sym (+-assoc (horner-loop 0 x cs) (c * (x ^ length cs)) (a * x * (x ^ length cs)))\n        | *-assoc a x (x ^ length cs)\n  = refl\n\nhorner-correct : \u2200 x cf \u2192 eval-poly x cf \u2261 horner x cf\nhorner-correct x [] = refl\nhorner-correct x (c \u2237 cf)\n  rewrite horner-correct x cf\n        | horner-loop-acc-prop c x cf\n  = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5d172f6bc193ae00117c914c":[{"id":319,"user_id":1163,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection renaming (returnTC to return ; bindTC to _>>=_)\n\nopen import Relation.Nullary\nopen import Eval\n{- Preloaded code are in the Eval module:\n\ndata Eval : Set where\n  _!+_ : Eval \u2192 Eval \u2192 Eval\n  _!*_ : Eval \u2192 Eval \u2192 Eval\n  !lit : \u2115 \u2192 Eval\n  !zro : Eval\n  !suc : Eval \u2192 Eval\n-}\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Maybe using (Maybe; just; nothing; maybe\u2032)\n\n\n_>>_ : \u2200 {a b} {A : Set a} {B : Set b} \u2192 TC A \u2192 TC B \u2192 TC B\na >> b = a >>= \u03bb _ \u2192 b\n\nparseTerm : Term \u2192 Eval\nparseTerm (con (quote zero) []) = !zro\nparseTerm (con (quote suc) (arg _ x \u2237 [])) = !suc (parseTerm x)\nparseTerm (lit (nat n)) = !lit n\nparseTerm (def (quote _+_) (arg _ x \u2237 arg _ y \u2237 [])) = parseTerm x !+ parseTerm y\nparseTerm (def (quote _*_) (arg _ x \u2237 arg _ y \u2237 [])) = parseTerm x !* parseTerm y\nparseTerm _ = !zro\n\nmacro\n  parse\u2115 : Term \u2192 Type \u2192 TC \u22a4\n  parse\u2115 n hole = do\n    let eval = parseTerm n\n    eval' \u2190 quoteTC eval\n    unify hole eval'\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":320,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\n\nopen import Relation.Nullary\nopen import Eval\n{- Preloaded code are in the Eval module:\n\ndata Eval : Set where\n  _!+_ : Eval \u2192 Eval \u2192 Eval\n  _!*_ : Eval \u2192 Eval \u2192 Eval\n  !lit : \u2115 \u2192 Eval\n  !zro : Eval\n  !suc : Eval \u2192 Eval\n-}\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Maybe using (Maybe; just; nothing; maybe\u2032)\n\nactual-parse : Term \u2192 Term\nactual-parse (def (quote _+_) (arg i a \u2237 arg i\u2082 b \u2237 [])) = con (quote _!+_) (arg i (actual-parse a) \u2237 arg i\u2082 (actual-parse b) \u2237 [])\nactual-parse (def (quote _*_) (arg i a \u2237 arg i\u2082 b \u2237 [])) = con (quote _!*_) (arg i (actual-parse a) \u2237 arg i\u2082 (actual-parse b) \u2237 [])\nactual-parse (con (quote suc) (arg i a \u2237 []))            = con (quote !suc) (arg i (actual-parse a) \u2237 [])\nactual-parse (con (quote zero) [])                       = con (quote !zro) []\nactual-parse n@(lit (nat _))                             = con (quote !lit) ((arg (arg-info visible relevant) n)  \u2237 [])\nactual-parse v = v\n\nmacro\n    parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n    parse\u2115 v hole = unify hole (actual-parse v)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":321,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\n\nopen import Relation.Nullary\nopen import Eval\n{- Preloaded code are in the Eval module:\n\ndata Eval : Set where\n  _!+_ : Eval \u2192 Eval \u2192 Eval\n  _!*_ : Eval \u2192 Eval \u2192 Eval\n  !lit : \u2115 \u2192 Eval\n  !zro : Eval\n  !suc : Eval \u2192 Eval\n-}\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Maybe using (Maybe; just; nothing; maybe\u2032)\nopen import Agda.Builtin.Reflection renaming (returnTC to return ; bindTC to _>>=_)\n\n-- ??? How can I prevent the evaluation of the argument ???\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 t hole = do\n    let eval = go t\n    eval' \u2190 quoteTC eval\n    unify hole eval'\n    where\n      go : Term \u2192 Eval\n      go (def (quote _+_) (arg i x \u2237 arg j y \u2237 [])) = (go x) !+ (go y)\n      go (def (quote _*_) (arg i x \u2237 arg j y \u2237 [])) = (go x) !* (go y)\n      go (lit (nat x)) = !lit x\n      go (con (quote zero) []) = !zro \n      go (con (quote suc) (arg i x \u2237 [])) = !suc (go x)\n      go _ = !zro","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":322,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\n\nopen import Eval\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\n\n-- ??? How can I prevent the evaluation of the argument ???\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 t hole = unify hole (go t) \n    where\n      go : Term \u2192 Term\n      go (def (quote _+_) (arg i x \u2237 arg j y \u2237 [])) = con (quote _!+_) ((arg i (go x)) \u2237 (arg j (go y)) \u2237 [])\n      go (def (quote _*_) (arg i x \u2237 arg j y \u2237 [])) = con (quote _!*_) ((arg i (go x)) \u2237 (arg j (go y)) \u2237 [])\n      go (lit x) = (con (quote !lit) (arg (arg-info visible relevant) (lit x) \u2237 []))\n      go (con (quote zero) []) = con (quote !zro) []\n      go (con (quote suc) (arg i x \u2237 [])) = con (quote !suc) (arg i (go x) \u2237 [])\n      go _ = con (quote !zro) [] -- Default case\n\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":323,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\n\nopen import Relation.Nullary\nopen import Eval\n{- Preloaded code are in the Eval module:\n\ndata Eval : Set where\n  _!+_ : Eval \u2192 Eval \u2192 Eval\n  _!*_ : Eval \u2192 Eval \u2192 Eval\n  !lit : \u2115 \u2192 Eval\n  !zro : Eval\n  !suc : Eval \u2192 Eval\n-}\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Maybe using (Maybe; just; nothing; maybe\u2032)\n\n-- ??? How can I prevent the evaluation of the argument ???\n_>>=_ = bindTC\n\nparse : Term \u2192 TC Eval\nparse (lit (nat n)) = returnTC (!lit n)\nparse (def (quote _*_) ((arg _ left) \u2237 (arg _ right) \u2237 [])) = \n  do\n    left <- parse left\n    right <- parse right\n    returnTC (_!*_ left right)\nparse (def (quote _+_) ((arg _ left) \u2237 (arg _ right) \u2237 [])) = \n  do\n    left <- parse left\n    right <- parse right\n    returnTC (_!+_ left right)\nparse (con (quote zero) []) = returnTC (!zro)\nparse (con (quote suc) ((arg _ n) \u2237 [])) =\n  do\n    n <- parse n\n    returnTC (!suc n)\nparse _ = typeError []\n\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 expr hole =\n    do\n      eval <- parse expr\n      term <- quoteTC eval\n      unify hole term\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":324,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\nopen import Data.Nat\nopen import Eval\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\n\nvra : {A : Set} (x : A) \u2192 Arg A\nvra = arg (arg-info visible relevant)\n\nparseTerm : Term \u2192 Term\nparseTerm (lit (nat n)) = con (quote !lit) (vra (lit (nat n)) \u2237 [])\nparseTerm (con (quote zero) []) = con (quote !zro) []\nparseTerm (con (quote suc) (arg _ t \u2237 [])) = con (quote !suc) (vra (parseTerm t) \u2237 [])\nparseTerm (def (quote _+_) (arg _ l \u2237 arg _ r \u2237 [])) = con (quote _!+_) (vra (parseTerm l) \u2237 vra (parseTerm r) \u2237 [])\nparseTerm (def (quote _*_) (arg _ l \u2237 arg _ r \u2237 [])) = con (quote _!*_) (vra (parseTerm l) \u2237 vra (parseTerm r) \u2237 [])\nparseTerm _ = unknown\n\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 t goal = unify goal (parseTerm t)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":325,"user_id":522,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\n\nopen import Eval\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\n\n\nuwu : Term \u2192 Term\nuwu (con (quote zero) []) = con (quote !zro) []\nuwu (con (quote suc) (arg i x \u2237 [])) =\n  con (quote !suc) (arg i (uwu x) \u2237 [])\nuwu (def (quote _+_) (arg i x \u2237 arg j y \u2237 [])) =\n  con (quote _!+_) (arg i (uwu x) \u2237 arg j (uwu y) \u2237 [])\nuwu (def (quote _*_) (arg i x \u2237 arg j y \u2237 [])) =\n  con (quote _!*_) (arg i (uwu x) \u2237 arg j (uwu y) \u2237 [])\nuwu n = con (quote !lit)\n  ((arg (arg-info visible relevant) n \u2237 []))\n\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 t hole = unify hole (uwu t)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":326,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\nimport Level as Level\nopen import Agda.Builtin.Reflection\nopen import Data.Nat\nopen import Relation.Nullary\nopen import Eval\n\n\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Maybe using (Maybe; just; nothing; maybe\u2032)\n\npattern vArg ty            = arg (arg-info visible relevant)   ty\npattern hArg ty            = arg (arg-info hidden relevant)    ty\n\n_>>=_ : \u2200 {a b} {A : Set a} {B : Set b} \u2192 TC A \u2192 (A \u2192 TC B) \u2192 TC B\nma >>= f = bindTC ma f\n\n_>>_ :  \u2200 {a b} {A : Set a} {B : Set b} \u2192 TC A \u2192 TC B \u2192 TC B\nma >> mb = ma >>= (\u03bb _ \u2192 mb)\n--\ntrans : Term \u2192 Term\ntrans (def (quote _+_) (vArg a \u2237 vArg b \u2237 [])) = con (quote _!+_) (vArg (trans a) \u2237 vArg (trans b) \u2237 [])\ntrans (def (quote _*_) (vArg a \u2237 vArg b \u2237 [])) = con (quote _!*_) (vArg (trans a) \u2237 vArg (trans b) \u2237 [])\ntrans (con (quote zero) []) = con (quote !zro) []\ntrans (con (quote suc) (vArg a \u2237 [])) = con (quote !suc) (vArg (trans a) \u2237 [])\ntrans t = con (quote !lit) (vArg t \u2237 [])\n\nann : \u2200 {a} (A : Set a) \u2192 A \u2192 A\nann _ a = a\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 num goal = do\n    ty \u2190 inferType goal\n    unify ty (quoteTerm Eval)\n    unify goal (trans num)\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":327,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\nopen import Eval\nopen import Data.Unit\nopen import Data.List using ([]; _\u2237_)\n\na = arg-info visible relevant\n\nparse : Term \u2192 Term\nparse (con (quote zero) []) = quoteTerm !zro\nparse v@(lit (nat n)) = con (quote !lit) (arg a v \u2237 [])\nparse (def (quote _+_) (arg _ x \u2237 arg _ y \u2237 [])) =\n  con (quote _!+_) (arg a (parse x) \u2237 arg a (parse y) \u2237 [])\nparse (def (quote _*_) (arg _ x \u2237 arg _ y \u2237 [])) =\n  con (quote _!*_) (arg a (parse x) \u2237 arg a (parse y) \u2237 [])\nparse (con (quote suc) (arg _ x \u2237 [])) =\n  con (quote !suc) (arg a (parse x) \u2237 [])\nparse x = x\n\nmacro parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\nparse\u2115 t hole = unify hole (parse t)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":328,"user_id":490,"body":"{-# OPTIONS --safe #-}\nmodule Uneval where\n\nopen import Agda.Builtin.Reflection\n\nopen import Relation.Nullary\nopen import Function\nopen import Eval\n\nopen import Data.Unit\nopen import Data.Bool\nopen import Data.String using (String)\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Maybe using (Maybe; just; nothing; maybe\u2032)\n\n_==_ : Name \u2192 Name \u2192 Bool\n_==_ = primQNameEquality\n\ndefaultArg = arg-info visible relevant\ninfixl 1 _>>=_\nmodule _ where\n  private\n    _>>=_ : \u2200 {A B : Set} \u2192 Maybe A \u2192 (A \u2192 Maybe B) \u2192 Maybe B\n    nothing >>= f = nothing\n    just a  >>= f = f a\n\n  parse\u2115\u2032 : Term \u2192 Maybe Term\n  parse\u2115\u2032 (lit n) = just $ con (quote !lit) (arg defaultArg (lit n) \u2237 [])\n  parse\u2115\u2032 (def (quote _+_) ((arg x a) \u2237 (arg y b) \u2237 [])) = do\n    a <- parse\u2115\u2032 a\n    b <- parse\u2115\u2032 b\n    just (con (quote _!+_) (arg x a \u2237 arg y b \u2237 []))\n  parse\u2115\u2032 (def (quote _*_) ((arg x a) \u2237 (arg y b) \u2237 [])) = do\n    a <- parse\u2115\u2032 a\n    b <- parse\u2115\u2032 b\n    just (con (quote _!*_) (arg x a \u2237 arg y b \u2237 []))\n  parse\u2115\u2032 (con c []) = if (c == quote \u2115.zero) then just (quoteTerm !zro) else nothing\n  parse\u2115\u2032 (con (quote \u2115.suc) (arg i x \u2237 [])) = do\n    x <- parse\u2115\u2032 x\n    just (con (quote !suc) (arg i x \u2237 []))\n  parse\u2115\u2032 _ = nothing\n\n\nprivate\n  _>>=_ = bindTC\n  _>>_ : \u2200 {a b} {A : Set a} {B : Set b} \u2192 TC A \u2192 TC B \u2192 TC B\n  a >> b = a >>= const b\n\nmacro\n  parse\u2115 : Term \u2192 Term \u2192 TC \u22a4\n  parse\u2115 t hole with parse\u2115\u2032 t\n  ... | just a = unify hole a\n  ... | nothing = typeError (strErr \"Failed to parse term\" \u2237 [])\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5d19e7669dd9860024d3c5bc":[{"id":329,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Empty\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] eq = subseq-nil\nsubseq-match\u21d2subseq [] (x \u2237 ys) eq = subseq-drop x [] ys (subseq-match\u21d2subseq [] ys eq)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) eq with x \u225f y\n... | yes refl = subseq-take x xs ys (subseq-match\u21d2subseq xs ys eq)\n... | no _ = subseq-drop y (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys eq)\n\ndropSub : \u2200 x xs ys \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys\ndropSub x xs .(x \u2237 ys) (subseq-take .x .xs ys ss) = subseq-drop x xs ys ss\ndropSub x xs .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys ss) = subseq-drop a xs ys (dropSub x xs ys ss)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match .[] .[] subseq-nil = refl\nsubseq\u21d2subseq-match .(a \u2237 xs) .(a \u2237 ys) (subseq-take a xs ys ss) with a \u225f a\n... | yes refl = subseq\u21d2subseq-match xs ys ss\n... | no \u00acp = \u22a5-elim (\u00acp refl)\nsubseq\u21d2subseq-match [] .(a \u2237 ys) (subseq-drop a .[] ys ss) = refl\nsubseq\u21d2subseq-match (x \u2237 xs) (a \u2237 ys) (subseq-drop .a .(x \u2237 xs) .ys ss) with x \u225f a\n... | yes p = subseq\u21d2subseq-match xs ys (dropSub x xs ys ss)\n... | no \u00acp = subseq\u21d2subseq-match (x \u2237 xs) ys ss\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":330,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Empty\n\nsubseq-lemma : \u2200 (x : \u2115) (xs ys : List \u2115) \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys \nsubseq-lemma x xs .(x \u2237 ys) (subseq-take .x .xs ys h) = subseq-drop x xs ys h\nsubseq-lemma x xs .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys h) = subseq-drop a xs ys \n    (subseq-lemma x xs ys h)\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] h = subseq-nil\nsubseq-match\u21d2subseq [] (y \u2237 ys) h = subseq-drop y [] ys (subseq-match\u21d2subseq [] ys h)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) h with x \u225f y\n... | yes t = subst (\u03bb z \u2192 Subseq (x \u2237 xs) (z \u2237 ys)) t \n        (subseq-take x xs ys (subseq-match\u21d2subseq xs ys h))\n... | no t = subseq-drop y (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys h)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match [] ys h = refl\nsubseq\u21d2subseq-match (x \u2237 xs) (.x \u2237 ys) (subseq-take .x .xs .ys h) with (x \u225f x)\n... | yes _ = subseq\u21d2subseq-match xs ys h\n... | no t = \u22a5-elim (t refl)\nsubseq\u21d2subseq-match (x \u2237 xs) (y \u2237 ys) (subseq-drop .y .(x \u2237 xs) .ys h) with x \u225f y\n... | yes t = subseq\u21d2subseq-match xs ys (subseq-lemma x xs ys h)\n... | no t = subseq\u21d2subseq-match (x \u2237 xs) ys h","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":331,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.List\nopen import Data.Nat\nopen import Data.Empty\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] proof = subseq-nil\nsubseq-match\u21d2subseq [] (y \u2237 ys) proof = subseq-drop y [] ys (subseq-match\u21d2subseq [] ys proof)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) proof with x \u225f y\n... | yes p rewrite p = subseq-take y xs ys (subseq-match\u21d2subseq xs ys proof)\n... | no _ = subseq-drop y (x \u2237 xs) ys ((subseq-match\u21d2subseq (x \u2237 xs) ys proof))\n\nlemma-boh : \u2200 {xs ys x} \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys\nlemma-boh (subseq-take x xs ys p) = subseq-drop x xs ys p\nlemma-boh (subseq-drop a (x \u2237 xs) ys p) = subseq-drop a xs ys (lemma-boh p)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match [] _ _ = refl\nsubseq\u21d2subseq-match (x \u2237 xs) (y \u2237 ys) (subseq-take x xs ys p) with x \u225f y\n... | yes refl = subseq\u21d2subseq-match xs ys p\n... | no q  = contradiction refl q\nsubseq\u21d2subseq-match (x \u2237 xs) (y \u2237 ys) (subseq-drop y (x \u2237 xs) ys p) with x \u225f y\n... | yes p' rewrite p' = subseq\u21d2subseq-match xs ys (lemma-boh p)\n... | no q   = subseq\u21d2subseq-match (x \u2237 xs) ys p","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":332,"user_id":522,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Empty\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] refl = subseq-nil\nsubseq-match\u21d2subseq [] (y \u2237 ys) refl =\n  subseq-drop y [] ys (subseq-match\u21d2subseq [] ys refl)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) p with x \u225f y\n... | yes refl =\n  subseq-take x xs ys (subseq-match\u21d2subseq xs ys p)\n... | no _ =\n  subseq-drop y (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys p)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match [] _ _ = refl\nsubseq\u21d2subseq-match (x \u2237 xs) (y \u2237 ys) s with x \u225f y\n... | yes refl = subseq\u21d2subseq-match xs ys (subseq-drop2 s)\n  where\n    subseq-drop2 : \u2200 {xs ys x y} \u2192 Subseq (x \u2237 xs) (y \u2237 ys) \u2192 Subseq xs ys\n    subseq-drop2 (subseq-take _ _ _ s) = s\n    subseq-drop2 (subseq-drop _ (_ \u2237 xs) (y \u2237 ys) s) =\n      subseq-drop y xs ys (subseq-drop2 s)\nsubseq\u21d2subseq-match (_ \u2237 _) (_ \u2237 _) (subseq-take _ _ _ _)\n  | no oh = \u22a5-elim (oh refl)\nsubseq\u21d2subseq-match (x \u2237 xs) (_ \u2237 ys) (subseq-drop _ .(x \u2237 xs) .ys s)\n  | no _ = subseq\u21d2subseq-match (x \u2237 xs) ys s","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":333,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation\nopen import Relation.Binary.PropositionalEquality\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] refl = subseq-nil\nsubseq-match\u21d2subseq [] (y \u2237 ys) refl = subseq-drop y [] ys (subseq-match\u21d2subseq [] ys refl)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) prf with x \u225f y\n... | yes p rewrite p = subseq-take y xs ys (subseq-match\u21d2subseq xs ys prf)\n... | no _  = subseq-drop y (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys prf)\n\ndrop-first : \u2200 x xs ys \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys\ndrop-first x xs .(x \u2237 ys) (subseq-take .x .xs ys subseq) = subseq-drop x xs ys subseq\ndrop-first x xs .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys subseq) = subseq-drop a xs ys (drop-first x xs ys subseq)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match .[] .[] subseq-nil = refl\nsubseq\u21d2subseq-match [] (a \u2237 ys) (subseq-drop a [] ys prf) = refl \nsubseq\u21d2subseq-match (x \u2237 xs) (y \u2237 ys) (subseq-take a xs ys prev) with x \u225f y\n... | yes p = subseq\u21d2subseq-match xs ys prev\n... | no  p = contradiction refl p\nsubseq\u21d2subseq-match (x \u2237 xs) (y \u2237 ys) (subseq-drop a (x \u2237 xs) ys prev) with x \u225f y\n... | yes p = subseq\u21d2subseq-match xs ys (drop-first x xs ys prev)\n... | no p  = subseq\u21d2subseq-match (x \u2237 xs) ys prev\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":334,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Bool using (true) renaming (_\u225f_ to _\u225f\u1d47_)\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.List using ([]; _\u2237_)\nopen import Data.Nat using (_\u225f_)\nopen import Function using (_\u2218_; _$_; const)\nopen import Relation.Nullary using (yes; no)\nopen import Relation.Binary.PropositionalEquality\n  using (_\u2261_; refl; subst)\n\nopen import Preloaded\n\nprivate\n  subseq-refl : \u2200 (xs) -> Subseq xs xs\n  subseq-refl [] = subseq-nil\n  subseq-refl (a \u2237 xs) = subseq-take a xs xs $ subseq-refl xs\n\n  subseq-trans : \u2200 {xs ys zs} \u2192 Subseq xs ys \u2192 Subseq ys zs \u2192 Subseq xs zs\n  subseq-trans subseq-nil p = p\n  subseq-trans {xs = xs} p (subseq-drop a ys zs p') =\n    subseq-drop a xs zs (subseq-trans p p')\n  subseq-trans (subseq-drop a xs ys p) (subseq-take a ys zs p') =\n    subseq-drop a xs zs (subseq-trans p p')\n  subseq-trans (subseq-take a xs ys p) (subseq-take a ys zs p') =\n    subseq-take a xs zs (subseq-trans p p')\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] _ = subseq-nil\nsubseq-match\u21d2subseq (x \u2237 xs) [] ()\nsubseq-match\u21d2subseq [] (y \u2237 ys) _ = subseq-drop y [] ys\n                                   $ subseq-match\u21d2subseq [] ys refl\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) with x \u225f y\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys)    | no x\u2262y\n  with subseq-match (x \u2237 xs) ys \u225f\u1d47 true\n...  | yes e = const $ subseq-drop y (x \u2237 xs) ys\n                     $ subseq-match\u21d2subseq (x \u2237 xs) ys e\n...  | no \u00ace = \u22a5-elim \u2218 \u00ace\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys)    | yes x\u2261y\n  with subseq-match xs ys \u225f\u1d47 true\n...  | yes e = const $ subst (\u03bb z \u2192 Subseq (x \u2237 xs) (z \u2237 ys)) x\u2261y\n                     $ subseq-take x xs ys\n                     $ subseq-match\u21d2subseq xs ys e\n...  | no \u00ace = \u22a5-elim \u2218 \u00ace\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match .[] .[] subseq-nil = refl\nsubseq\u21d2subseq-match .(x \u2237 xs) .(x \u2237 ys) (subseq-take x xs ys ev) with x \u225f x\n... | yes _   = subseq\u21d2subseq-match xs ys ev\n... | no  x\u2262x = \u22a5-elim $ x\u2262x refl\nsubseq\u21d2subseq-match .[] .(y \u2237 ys) (subseq-drop y [] ys ev) =\n  subseq\u21d2subseq-match [] ys ev\nsubseq\u21d2subseq-match .(x \u2237 xs) .(y \u2237 ys) (subseq-drop y (x \u2237 xs) ys ev) with x \u225f y\n... | no  _ = subseq\u21d2subseq-match (x \u2237 xs) ys ev\n... | yes _ = subseq\u21d2subseq-match xs ys\n            $ subseq-trans (subseq-drop x xs xs $ subseq-refl xs) ev","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":335,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.Empty\nopen import Data.List\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] e = subseq-nil\nsubseq-match\u21d2subseq [] (x \u2237 ys) e = subseq-drop x [] ys (subseq-match\u21d2subseq [] ys refl)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) e with x \u225f y\n... | yes x\u2261y = subst (\u03bb t \u2192 Subseq (x \u2237 xs) (t \u2237 ys)) x\u2261y (subseq-take x xs ys (subseq-match\u21d2subseq xs ys e))\n... | no _ = subseq-drop y (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys e)\n\nsubseq-dropl : \u2200 a xs ys \u2192 Subseq (a \u2237 xs) ys \u2192 Subseq xs ys\nsubseq-dropl a xs .(a \u2237 ys) (subseq-take .a .xs ys s) = subseq-drop a xs ys s\nsubseq-dropl a xs .(y \u2237 ys) (subseq-drop y .(a \u2237 xs) ys s) = subseq-drop y xs ys (subseq-dropl a xs ys s)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match .[] .[] subseq-nil = refl\nsubseq\u21d2subseq-match .(a \u2237 xs) .(a \u2237 ys) (subseq-take a xs ys s) with a \u225f a\n... | yes _ = subseq\u21d2subseq-match xs ys s\n... | no a\u2262a = \u22a5-elim (a\u2262a refl)\nsubseq\u21d2subseq-match [] .(a \u2237 ys) (subseq-drop a .[] ys s) = refl\nsubseq\u21d2subseq-match (x \u2237 xs) .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys s) with x \u225f a\n... | yes x\u2261a = subseq\u21d2subseq-match xs ys (subseq-dropl x xs ys s)\n... | no _ = subseq\u21d2subseq-match (x \u2237 xs) ys s\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":336,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.Empty\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] _ = subseq-nil\nsubseq-match\u21d2subseq [] (x \u2237 ys) H = subseq-drop x [] ys (subseq-match\u21d2subseq [] ys H)\nsubseq-match\u21d2subseq (x \u2237 xs) [] ()\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) H with x \u225f y\n... | yes refl = subseq-take x xs ys (subseq-match\u21d2subseq xs ys H)\nsubseq-match\u21d2subseq (x \u2237 xs) (y \u2237 ys) H | no  x\u2262y = subseq-drop y (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys H)\n\nenlarge : \u2200 x xs ys \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys\nenlarge x xs .(x \u2237 ys) (subseq-take .x .xs ys subseq) = subseq-drop x xs ys subseq\nenlarge x xs .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys subseq) = subseq-drop a xs ys (enlarge x xs ys subseq)\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match .[] .[] subseq-nil = refl\nsubseq\u21d2subseq-match .(a \u2237 xs) .(a \u2237 ys) (subseq-take a xs ys subseq) with a \u225f a\n... | yes refl = subseq\u21d2subseq-match xs ys subseq\n... | no abs   = \u22a5-elim (abs refl)\nsubseq\u21d2subseq-match [] .(a \u2237 ys) (subseq-drop a .[] ys subseq) = refl\nsubseq\u21d2subseq-match (x \u2237 xs) .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys subseq) with x \u225f a\n... | yes refl = subseq\u21d2subseq-match xs ys (enlarge x xs ys subseq)\n... | no  x\u2262a  = subseq\u21d2subseq-match (x \u2237 xs) ys subseq\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":337,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Empty\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Function.Equivalence\nopen import Function.Equality using (_\u27e8$\u27e9_)\n\nequiv : Bool \u2192 Set \u2192 Set\nequiv b X = b \u2261 true \u21d4 X\n\nboth-true : \u2200 {X} \u2192 X \u2192 equiv true X\nboth-true {X} x = equivalence (\u03bb _ \u2192 x) (\u03bb _ \u2192 refl)\n\nboth-false : \u2200 {X} \u2192 \u00ac X \u2192 equiv false X\nboth-false nx = equivalence (\u03bb ()) \u03bb x \u2192 \u22a5-elim (nx x)\n\nsubseq-weaken : \u2200 x xs ys \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys\nsubseq-weaken x xs .(x \u2237 ys) (subseq-take .x .xs ys s) = subseq-drop x xs ys s\nsubseq-weaken x xs .(a \u2237 ys) (subseq-drop a .(x \u2237 xs) ys s) =\n subseq-drop a xs ys (subseq-weaken x xs ys s)\n\nempty-subseq : \u2200 ys \u2192 Subseq [] ys\nempty-subseq [] = subseq-nil\nempty-subseq (x \u2237 ys) = subseq-drop x [] ys (empty-subseq ys)\n\nnot-empty-subseq : \u2200 {x xs} \u2192 \u00ac Subseq (x \u2237 xs) []\nnot-empty-subseq {x} {xs} ()\n\nsubseq-cons : \u2200 {x y xs ys} \u2192 x \u2261 y \u2192 (Subseq xs ys) \u21d4 (Subseq (x \u2237 xs) (y \u2237 ys))\nsubseq-cons {x} {xs = xs} {ys} refl = equivalence to from where\n  to : (Subseq xs ys) \u2192 (Subseq (x \u2237 xs) (x \u2237 ys))\n  to s = subseq-take x xs ys s\n\n  from : (Subseq (x \u2237 xs) (x \u2237 ys)) \u2192 (Subseq xs ys)\n  from (subseq-take a xs ys x) = x\n  from (subseq-drop a .(a \u2237 xs) ys x) = subseq-weaken _ xs ys x\n\nsubseq-cons-ne : \u2200 {x y xs ys} \u2192 \u00ac (x \u2261 y) \u2192 (Subseq (x \u2237 xs) ys) \u21d4 (Subseq (x \u2237 xs) (y \u2237 ys))\nsubseq-cons-ne {x} {y} {xs = xs} {ys} neq = equivalence to from where\n  to : (Subseq (x \u2237 xs) ys) \u2192 (Subseq (x \u2237 xs) (y \u2237 ys))\n  to s = subseq-drop y (x \u2237 xs) ys s\n\n  from : (Subseq (x \u2237 xs) (y \u2237 ys)) \u2192 (Subseq (x \u2237 xs) ys)\n  from (subseq-take a xs ys s) = \u22a5-elim (neq refl)\n  from (subseq-drop a .(x \u2237 xs) ys s) = s\n\nprf : \u2200 xs ys \u2192 equiv (subseq-match xs ys) (Subseq xs ys)\nprf [] ys = both-true (empty-subseq ys)\nprf (x \u2237 xs) [] = both-false not-empty-subseq\nprf (x \u2237 xs) (y \u2237 ys) with x \u225f y\nprf (x \u2237 xs) (y \u2237 ys) | yes p = subseq-cons p \u2218 prf xs ys\nprf (x \u2237 xs) (y \u2237 ys) | no \u00acp = subseq-cons-ne \u00acp \u2218 prf (x \u2237 xs) ys\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq xs ys eq = Equivalence.to (prf xs ys) \u27e8$\u27e9 eq\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match xs ys eq = Equivalence.from (prf xs ys) \u27e8$\u27e9 eq\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":338,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Preloaded\nopen import Data.List\nopen import Data.Nat\nopen import Data.Bool hiding (_\u225f_)\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\n\nsubseq-match\u21d2subseq : \u2200 xs ys \u2192 subseq-match xs ys \u2261 true \u2192 Subseq xs ys\nsubseq-match\u21d2subseq [] [] _ = subseq-nil\nsubseq-match\u21d2subseq [] (x \u2237 ys) _ = subseq-drop x [] ys (subseq-match\u21d2subseq [] ys refl)\nsubseq-match\u21d2subseq (x \u2237 xs) (x\u2081 \u2237 ys) prf with x \u225f x\u2081\n... | yes refl = subseq-take x xs ys (subseq-match\u21d2subseq xs ys prf)\n... | no _ = subseq-drop x\u2081 (x \u2237 xs) ys (subseq-match\u21d2subseq (x \u2237 xs) ys prf)\n\nlemma\u2081 : (n : \u2115) \u2192 (n \u225f n) \u2261 (yes refl)\nlemma\u2081 n = \u2261-\u225f-identity _\u225f_ refl\n\nmutual\n  lemma\u2082 : (x : \u2115) (xs ys : List \u2115) \u2192 subseq-match (x \u2237 xs) ys \u2261 true \u2192 subseq-match xs ys \u2261 true\n  lemma\u2082 x xs (x\u2081 \u2237 ys) prf with x \u225f x\u2081\n  lemma\u2082 x xs (x\u2081 \u2237 ys) prf | yes _ = lemma\u2083 x\u2081 xs ys prf\n  lemma\u2082 x xs (x\u2081 \u2237 ys) prf | no \u00acp = lemma\u2083 x\u2081 xs ys (lemma\u2082 x xs ys prf)\n\n  lemma\u2083 : (y : \u2115) (xs ys : List \u2115) \u2192 subseq-match xs ys \u2261 true \u2192 subseq-match xs (y \u2237 ys) \u2261 true\n  lemma\u2083 y [] ys prf = refl\n  lemma\u2083 y (x \u2237 xs) ys prf with x \u225f y\n  lemma\u2083 y (x \u2237 xs) ys prf | yes _ = lemma\u2082 x xs ys prf\n  lemma\u2083 y (x \u2237 xs) ys prf | no _ = prf\n\nsubseq\u21d2subseq-match : \u2200 xs ys \u2192 Subseq xs ys \u2192 subseq-match xs ys \u2261 true\nsubseq\u21d2subseq-match .[] .[] subseq-nil = refl\nsubseq\u21d2subseq-match .(a \u2237 xs) .(a \u2237 ys) (subseq-take a xs ys prf) rewrite lemma\u2081 a = subseq\u21d2subseq-match xs ys prf\nsubseq\u21d2subseq-match xs .(a \u2237 ys) (subseq-drop a .xs ys prf) = lemma\u2083 a xs ys (subseq\u21d2subseq-match xs ys prf)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5de035e4b0285b002248ff7c":[{"id":339,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Data.List\nopen import Data.Nat\nopen import Data.Product\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary.Core\nopen import Data.Empty\nopen import Data.Nat.Properties\nopen import Preloaded\n\nnil-subseq : \u2200 {n} {A : Set n} (ys : List A) \u2192 Subseq [] ys\nnil-subseq [] = subseq-nil\nnil-subseq (y \u2237 ys) = subseq-drop y [] ys (nil-subseq ys)\n\nsubseq-tail : \u2200 {n} {A : Set n} {a : A} {xs ys} \u2192 Subseq (a \u2237 xs) ys \u2192 Subseq xs ys\nsubseq-tail (subseq-take a xs ys sub) = subseq-drop a xs ys sub\nsubseq-tail (subseq-drop a _ ys sub) = subseq-drop a _ ys (subseq-tail sub)\n\nsubseq-tail2 : \u2200 {n} {A : Set n} {a b : A} {xs ys} \u2192 Subseq (a \u2237 xs) (b \u2237 ys) \u2192 Subseq xs ys\nsubseq-tail2 (subseq-take a xs ys sub) = sub\nsubseq-tail2 (subseq-drop a _ ys sub) = subseq-tail sub\n\nlcs-subseq : \u2200 {n} {A : Set n} (dec : Decidable {A = A} _\u2261_) (xs ys : List A)\n                \u2192 Subseq (lcs dec xs ys) xs \u00d7 Subseq (lcs dec xs ys) ys\nlcs-subseq _ [] ys = subseq-nil , nil-subseq ys\nlcs-subseq _ (x \u2237 xs) [] = nil-subseq _ , subseq-nil\nlcs-subseq dec (x \u2237 xs) (y \u2237 ys) with dec x y\n... | yes refl = subseq-take x _ xs (proj\u2081 (lcs-subseq dec xs ys)) ,\n                 subseq-take x _ ys (proj\u2082 (lcs-subseq dec xs ys))\n... | no neq with length (lcs dec (x \u2237 xs) ys) \u2264? length (lcs dec xs (y \u2237 ys))\n...   | yes _ = subseq-drop x _ xs (proj\u2081 (lcs-subseq dec xs _)) ,\n                proj\u2082 (lcs-subseq dec xs _)\n...   | no _ =  proj\u2081 (lcs-subseq dec _ ys) ,\n                subseq-drop y _ ys (proj\u2082 (lcs-subseq dec (x \u2237 xs) ys))\n\nlength-longest1 : \u2200 {n} {A : Set n} (xs ys : List A) \u2192 length xs \u2264 length (longest xs ys)\nlength-longest1 xs ys with length xs \u2264? length ys\n... | yes h = h\n... | no _ = \u2264-refl\n\nlength-longest2 : \u2200 {n} {A : Set n} (xs ys : List A) \u2192 length ys \u2264 length (longest xs ys)\nlength-longest2 xs ys with length xs \u2264? length ys\n... | yes h = \u2264-refl\n... | no h = \u2270\u21d2\u2265 h \n\nopen \u2264-Reasoning\n\nlcs-longest : \u2200 {n} {A : Set n} (dec : Decidable {A = A} _\u2261_) (xs ys zs : List A)\n                \u2192 Subseq zs xs \u2192 Subseq zs ys \u2192 length zs \u2264 length (lcs dec xs ys)\nlcs-longest _ [] ys .[] subseq-nil s2 = z\u2264n\nlcs-longest _ (x \u2237 xs) [] .[] s1 subseq-nil = z\u2264n\nlcs-longest _ (x \u2237 xs) (y \u2237 ys) [] s1 s2 = z\u2264n\nlcs-longest dec (x \u2237 xs) (y \u2237 ys) (z \u2237 zs) s1 s2 with dec x y\n... | yes refl = s\u2264s (lcs-longest dec xs ys zs (subseq-tail2 s1) (subseq-tail2 s2))\n... | no neq with s1 | s2\n...   | subseq-take _ _ _ _ | subseq-take _ _ _ _ = \u22a5-elim (neq refl)\n...   | subseq-drop _ _ _ h | subseq-take _ _ _ h2 = begin\n  length (y \u2237 zs)          \u2264\u27e8 lcs-longest dec xs (y \u2237 ys) (y \u2237 zs) h s2 \u27e9\n  length (lcs dec xs (y \u2237 ys)) \u2264\u27e8 length-longest2 (lcs dec (x \u2237 xs) ys) _ \u27e9\n  length (longest (lcs dec (x \u2237 xs) ys) (lcs dec xs (y \u2237 ys))) \u220e\n...   | _                   | subseq-drop _ _ _ h2 = begin\n  length (z \u2237 zs)          \u2264\u27e8 lcs-longest dec (x \u2237 xs) ys (z \u2237 zs) s1 h2 \u27e9\n  length (lcs dec (x \u2237 xs) ys) \u2264\u27e8 length-longest1 (lcs dec (x \u2237 xs) ys) _ \u27e9\n  length (longest (lcs dec (x \u2237 xs) ys) (lcs dec xs (y \u2237 ys))) \u220e\n\nlcs-correct : \u2200 {n} {A : Set n} (dec : Decidable {A = A} _\u2261_) (xs ys : List A) \u2192 is-lcs (lcs dec xs ys) xs ys\nlcs-correct dec xs ys = lcs-subseq dec xs ys , lcs-longest dec xs ys","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":340,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nmodule Solution where\n\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.List using (List; []; _\u2237_; length)\nopen import Data.Nat using (_\u2264_; s\u2264s)\nopen import Data.Nat.Properties using (\u2264-refl; \u2264-trans; \u2264-step; _\u2264?_; \u2270\u21d2\u2265)\nopen import Data.Product using (_,_)\nopen import Function using (_$_)\nopen import Relation.Binary.Core using (Decidable)\nopen import Relation.Binary.PropositionalEquality using (_\u2261_; refl; sym)\nopen import Relation.Nullary using (yes; no)\n\nopen import Preloaded\n\nprivate\n  subseq-[] : \u2200 {n} {A : Set n} \u2192 (xs : List A) \u2192 Subseq [] xs\n  subseq-[] [] = subseq-nil\n  subseq-[] (x \u2237 xs) = subseq-drop x [] xs $ subseq-[] xs\n  \n  subseq-refl : \u2200 {n} {A : Set n} \u2192 (xs : List A) \u2192 Subseq xs xs\n  subseq-refl [] = subseq-nil\n  subseq-refl (a \u2237 xs) = subseq-take a xs xs $ subseq-refl xs\n  \n  subseq-trans : \u2200 {n} {A : Set n} \u2192 {xs ys zs : List A} \u2192 Subseq xs ys \u2192 Subseq ys zs \u2192 Subseq xs zs\n  subseq-trans subseq-nil p = p\n  subseq-trans {xs = xs} p (subseq-drop a _ zs p') = subseq-drop a xs zs $ subseq-trans p p'\n  subseq-trans (subseq-drop a xs ys p) (subseq-take .a .ys zs p') = subseq-drop a xs zs $ subseq-trans p p'\n  subseq-trans (subseq-take a xs ys p) (subseq-take .a .ys zs p') = subseq-take a xs zs $ subseq-trans p p'\n  \n  subseq-longest : \u2200 {n} {A : Set n} \u2192 {xs\u2081 xs\u2082 ys : List A} \u2192\n                   Subseq xs\u2081 ys \u2192 Subseq xs\u2082 ys \u2192 Subseq (longest xs\u2081 xs\u2082) ys\n  subseq-longest {xs\u2081 = xs\u2081} {xs\u2082 = xs\u2082} s\u2081 s\u2082 with length xs\u2081 \u2264? length xs\u2082\n  ... | yes _ = s\u2082\n  ... | no _ = s\u2081\n  \n  length-longest\u02e1 : \u2200 {n} {A : Set n} \u2192 (xs ys\u2081 ys\u2082 : List A) \u2192\n                    length xs \u2264 length ys\u2081 \u2192 length xs \u2264 length (longest ys\u2081 ys\u2082)\n  length-longest\u02e1 xs ys\u2081 ys\u2082 l[xs]\u2264l[ys\u2081] with length ys\u2081 \u2264? length ys\u2082\n  ... | yes l[ys\u2081]\u2264l[ys\u2082] = \u2264-trans l[xs]\u2264l[ys\u2081] l[ys\u2081]\u2264l[ys\u2082]\n  ... | no _ = l[xs]\u2264l[ys\u2081]\n\n  length-longest\u02b3 : \u2200 {n} {A : Set n} \u2192 (xs ys\u2081 ys\u2082 : List A) \u2192\n                    length xs \u2264 length ys\u2082 \u2192 length xs \u2264 length (longest ys\u2081 ys\u2082)\n  length-longest\u02b3 xs ys\u2081 ys\u2082 l[xs]\u2264l[ys\u2082] with length ys\u2081 \u2264? length ys\u2082\n  ... | yes _ = l[xs]\u2264l[ys\u2082]\n  ... | no l[ys\u2081]\u2270l[ys\u2082] = \u2264-trans l[xs]\u2264l[ys\u2082] (\u2270\u21d2\u2265 l[ys\u2081]\u2270l[ys\u2082])\n\nlcs-correct : \u2200 {n} {A : Set n} (dec : Decidable {A = A} _\u2261_) (xs ys : List A) \u2192 is-lcs (lcs dec xs ys) xs ys\nlcs-correct _ [] ys = ((subseq-[] [] , subseq-[] ys) , \u03bb { [] subseq-nil _ \u2192 \u2264-refl })\nlcs-correct _ (x \u2237 xs) [] = ((subseq-[] (x \u2237 xs) , subseq-[] []) , \u03bb { [] _ subseq-nil \u2192 \u2264-refl })\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) with dec x y\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | yes x\u2261y with lcs-correct dec xs ys \nlcs-correct {A = A} dec (x \u2237 xs) (y \u2237 ys) | yes x\u2261y | ((s , s') , ev) rewrite sym x\u2261y =\n  ((subseq-take x zs xs s , subseq-take x zs ys s') , ev')\n  where zs : List A\n        zs = lcs dec xs ys\n        ev' : \u2200 ts \u2192 Subseq ts (x \u2237 xs) \u2192 Subseq ts (x \u2237 ys) \u2192 length ts \u2264 length (x \u2237 zs)\n        ev' .ts (subseq-drop x ts xs p) (subseq-drop .x .ts ys p') = \u2264-step (ev ts p p')\n        ev' .(x \u2237 ts) (subseq-take x ts xs p) (subseq-take .x .ts ys p') = s\u2264s (ev ts p p')\n        ev' .(x \u2237 ts) (subseq-take x ts xs p) (subseq-drop .x .(x \u2237 ts) ys p') = s\u2264s (ev ts p ph')\n          where ph' : Subseq ts ys\n                ph' = subseq-trans (subseq-drop x ts ts $ subseq-refl ts) p'\n        ev' .(x \u2237 ts) (subseq-drop x (x \u2237 ts) xs p) (subseq-take .x .ts ys p') = s\u2264s (ev ts ph p')\n          where ph : Subseq ts xs\n                ph = subseq-trans (subseq-drop x ts ts $ subseq-refl ts) p\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | no _ with lcs-correct dec (x \u2237 xs) ys | lcs-correct dec xs (y \u2237 ys)\nlcs-correct {A = A} dec (x \u2237 xs) (y \u2237 ys) | no x\u2262y | ((s\u2081 , s\u2081') , ev\u2081) | ((s\u2082 , s\u2082') , ev\u2082) =\n  ((subseq-longest s\u2081 (subseq-drop x zs\u2082 xs s\u2082) , subseq-longest (subseq-drop y zs\u2081 ys s\u2081') s\u2082') , ev')\n  where zs\u2081 : List A\n        zs\u2081 = lcs dec (x \u2237 xs) ys\n        zs\u2082 : List A\n        zs\u2082 = lcs dec xs (y \u2237 ys)\n        ev' : \u2200 ts \u2192 Subseq ts (x \u2237 xs) \u2192 Subseq ts (y \u2237 ys) \u2192 length ts \u2264 length (longest zs\u2081 zs\u2082)\n        ev' .ts (subseq-drop x ts xs p) p' = length-longest\u02b3 ts zs\u2081 zs\u2082 (ev\u2082 ts p p')\n        ev' .ts p (subseq-drop y ts ys p') = length-longest\u02e1 ts zs\u2081 zs\u2082 (ev\u2081 ts p p')\n        ev' .(x \u2237 ts) (subseq-take x ts xs p) (subseq-take .y .ts ys p') = \u22a5-elim (x\u2262y refl)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":341,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Function\nopen import Data.Empty\nopen import Data.List\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Product\nopen import Relation.Nullary\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary\nopen import Preloaded\n\nnil-subseq : \u2200 {n}{A : Set n} (ys : List A) \u2192 Subseq [] ys\nnil-subseq [] = subseq-nil\nnil-subseq (x \u2237 ys) = subseq-drop x [] ys (nil-subseq ys)\n\nsubseq-length-\u2264 : \u2200 {n}{A : Set n}{xs ys : List A} \u2192 Subseq xs ys \u2192 length xs \u2264 length ys\nsubseq-length-\u2264 {xs = []} {ys} s = z\u2264n\nsubseq-length-\u2264 {xs = x \u2237 xs} {.x \u2237 ys} (subseq-take .x .xs .ys s) = s\u2264s (subseq-length-\u2264 s)\nsubseq-length-\u2264 {xs = x \u2237 xs} {y \u2237 ys} (subseq-drop .y .(x \u2237 xs) .ys s) = \u2264-trans (subseq-length-\u2264 s) (n\u22641+n (length ys))\n\nsubseq-dropl : \u2200 {n}{A : Set n} {x : A}{xs ys : List A} \u2192 Subseq (x \u2237 xs) ys \u2192 Subseq xs ys\nsubseq-dropl {x = x} {xs} {.x \u2237 ys} (subseq-take .x .xs .ys s) = subseq-drop x xs ys s\nsubseq-dropl {x = x} {xs} {y \u2237 ys} (subseq-drop .y .(x \u2237 xs) .ys s) = subseq-drop y xs ys (subseq-dropl s)\n\nsubseq-dropr : \u2200 {n}{A : Set n} {x y : A}{xs ys : List A} \u2192 x \u2262 y \u2192 Subseq (x \u2237 xs) (y \u2237 ys) \u2192 Subseq (x \u2237 xs) ys\nsubseq-dropr {x = .a} {.a} {xs} {ys} x\u2262y (subseq-take a xs ys s) = \u22a5-elim (x\u2262y refl)\nsubseq-dropr {x = x} {.a} {xs} {ys} x\u2262y (subseq-drop a .(x \u2237 xs) ys s) = s\n\nsubseq-take' : \u2200 {n}{A : Set n} {x y : A}{xs ys : List A} \u2192 Subseq (x \u2237 xs) (y \u2237 ys) \u2192 Subseq xs ys\nsubseq-take' {x = .a} {.a} {xs} {ys} (subseq-take a xs ys s) = s\nsubseq-take' {x = x} {.a} {xs} {ys} (subseq-drop a .(x \u2237 xs) ys s) = subseq-dropl s\n\nsubseq-trans : \u2200{n}{A : Set n}{xs ys zs : List A} \u2192 Subseq xs ys \u2192 Subseq ys zs \u2192 Subseq xs zs\nsubseq-trans {xs = []} {ys} {zs} sxy syz = nil-subseq zs\nsubseq-trans {xs = x \u2237 xs} {.x \u2237 ys} {.x \u2237 zs} (subseq-take .x .xs .ys sxy) (subseq-take .x .ys .zs syz) = subseq-take x xs zs (subseq-trans sxy syz)\nsubseq-trans {xs = x \u2237 xs} {.x \u2237 ys} {z \u2237 zs} (subseq-take .x .xs .ys sxy) (subseq-drop .z .(x \u2237 ys) .zs syz) = subseq-drop z (x \u2237 xs) zs (subseq-trans (subseq-take x xs ys sxy) syz)\nsubseq-trans {xs = x \u2237 xs} {y \u2237 ys} {.y \u2237 zs} (subseq-drop .y .(x \u2237 xs) .ys sxy) (subseq-take .y .ys .zs syz) = subseq-drop y (x \u2237 xs) zs (subseq-trans sxy syz)\nsubseq-trans {xs = x \u2237 xs} {y \u2237 ys} {z \u2237 zs} (subseq-drop .y .(x \u2237 xs) .ys sxy) (subseq-drop .z .(y \u2237 ys) .zs syz) = subseq-drop z (x \u2237 xs) zs (subseq-trans sxy (subseq-dropl syz))\n\n\u2264-lemma : \u2200 {n m} \u2192 \u00ac n \u2264 m \u2192 m \u2264 n\n\u2264-lemma {zero} {m} f = \u22a5-elim (f z\u2264n)\n\u2264-lemma {suc n} {zero} f = z\u2264n\n\u2264-lemma {suc n} {suc m} f = s\u2264s (\u2264-lemma (f \u2218 s\u2264s))\n\nlcs-correct : \u2200 {n} {A : Set n} (dec : Decidable {A = A} _\u2261_) (xs ys : List A) \u2192 is-lcs (lcs dec xs ys) xs ys\nlcs-correct dec [] ys = (subseq-nil , nil-subseq ys) , \u03bb ts sx sy \u2192 subseq-length-\u2264 sx\nlcs-correct dec (x \u2237 xs) [] = ((nil-subseq (x \u2237 xs)) , subseq-nil) , (\u03bb ts sx sy \u2192 subseq-length-\u2264 sy)\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) with dec x y\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | no x\u2262y with length (lcs dec (x \u2237 xs) ys) \u2264? length (lcs dec xs (y \u2237 ys))\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | no x\u2262y | yes ineq with lcs-correct dec xs (y \u2237 ys) | lcs-correct dec (x \u2237 xs) ys\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | no x\u2262y | yes ineq | (sx , sy) , f | _ , f' = let cs = lcs dec xs (y \u2237 ys) in (subseq-drop x cs xs sx , sy) ,\n  \u03bb {\n    .(x \u2237 ts) (subseq-take t ts xs sx') sy' \u2192 \u2264-trans (f' (x \u2237 ts) (subseq-take x ts xs sx') (subseq-dropr x\u2262y sy')) ineq  ;\n    ts (subseq-drop a .ts ys sx') sy' \u2192 f ts sx' sy'}\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | no x\u2262y | no ineq  with lcs-correct dec (x \u2237 xs) ys | lcs-correct dec xs (y \u2237 ys)\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | no x\u2262y | no ineq' | (sx , sy) , f | _ , f' = let ineq = \u2264-lemma ineq'\n                                                                                     cs = lcs dec (x \u2237 xs) ys in\n  (sx , subseq-drop y cs ys sy) ,\n  \u03bb {\n    .(t \u2237 ts) sx' (subseq-take t ts ys sy') \u2192 \u2264-trans (f' (y \u2237 ts) (subseq-dropr (x\u2262y \u2218 sym) sx') (subseq-take y ts ys sy')) ineq ;\n    ts sx' (subseq-drop a .ts ys sy') \u2192 f ts sx' sy'}\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | yes x\u2261y with lcs-correct dec xs ys\nlcs-correct dec (x \u2237 xs) (y \u2237 ys) | yes x\u2261y | (sx , sy) , f = let cs = lcs dec xs ys in\n  (subseq-take x cs xs sx ,\n  subst (\u03bb t \u2192 Subseq (x \u2237 cs) (t \u2237 ys)) x\u2261y (subseq-take x cs ys sy)) ,\n  \u03bb { [] sx' sy' \u2192 z\u2264n ; (t \u2237 ts) sx' sy' \u2192  s\u2264s (f ts (subseq-take' sx') (subseq-take' sy')) }\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5e3cd88fa5b6a8001fa84ed5":[{"id":342,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Product\nopen import Relation.Nullary\nopen import Relation.Unary\n\ncontradiction : \u2200 {\u2113 \u2113' : _} {P : Set \u2113} {Anything : Set \u2113'} \u2192 \u00ac P \u2192 P \u2192 Anything\ncontradiction \u00acP P with \u00acP P\n... | ()\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192 \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {A = A} {r = r} e with em {P = \u2203[ x ] (\u00ac (r x))}\n... | yes (x , \u00acrx) = x , \u03bb rx \u2192 contradiction \u00acrx rx \n... | no ra = e , \u03bb x {y} \u2192 all-yes y\n  where\n    all-yes : \u2200 x \u2192 r x\n    all-yes x with em {P = r x}\n    ... | yes p = p\n    ... | no \u00acp = contradiction ra (x , \u00acp)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":343,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\nopen import Relation.Nullary\nopen import Data.Empty using (\u22a5-elim)\nopen import Agda.Builtin.Bool\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Product\nopen import Relation.Unary\n\n\u00ac\u2203\u00ac : \u2200 {\u2113} {A : Set \u2113} (r : Pred A \u2113) \u2192 \u00ac (\u2203[ x ] \u00ac r x) \u2192 (x : A) \u2192 r x\n\u00ac\u2203\u00ac r p x with em {P = r x}\n...| no \u00acq = \u22a5-elim (p (x , \u00acq))\n...| yes q = q\n\n\u00ac\u2200 : \u2200 {\u2113} {A : Set \u2113} (r : Pred A \u2113) \u2192 \u00ac((x : A) \u2192 r x) \u2192 \u2203[ x ] \u00ac r x\n\u00ac\u2200 r q with em {P = \u2203[ x ] \u00ac r x}\n...| no \u00acp = \u22a5-elim (q (\u00ac\u2203\u00ac r \u00acp))\n...| yes p = p\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192 (e : A) \u2192 \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {_} {A} {r} e with em {P = (y : A) \u2192 r y}\n... | yes p = e , (\u03bb _ {y} \u2192 p y)\n... | no \u00acp with \u00ac\u2200 r \u00acp\n...            | z , q = z , \u03bb o \u2192 \u22a5-elim (q o)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":344,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\nopen import Axiom.DoubleNegationElimination\nopen import Relation.Nullary\nopen import Data.Bool\nopen import Data.Empty\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Product\nopen import Relation.Unary\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192\n  \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {A = A} {r} a with em {P = \u03a3 A (\u03bb a \u2192 \u00ac (r a))}\n... | no \u00acp = a , \u03bb _ {b} \u2192 em\u21d2dne em (\u03bb \u00acrb \u2192 \u00acp (b , \u00acrb))\n... | yes (a , \u00acra) = a , (\u03bb ra \u2192 \u22a5-elim (\u00acra ra))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":345,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Product\nopen import Relation.Unary\nopen import Relation.Nullary using (\u00ac_; yes; no)\nopen import Function using (_$_)\nopen import Data.Empty using (\u22a5-elim)\n\n\u00ac\u00acA\u21d2A : \u2200{\u2113} {A : Set \u2113} \u2192 \u00ac \u00ac A \u2192 A\n\u00ac\u00acA\u21d2A {A = A} \u00ac\u00acp with em {P = A} \n... | yes p = p\n... | no \u00acp = \u22a5-elim $ \u00ac\u00acp \u00acp\n\n\u2203\u00ac\u21d2\u00ac\u2200 : \u2200{\u2113} {A : Set \u2113} {P : A \u2192 Set \u2113} \u2192 \u2203[ x ] (\u00ac (P x)) \u2192 \u00ac(\u2200 x \u2192 P x)\n\u2203\u00ac\u21d2\u00ac\u2200 (x , npx) = \u03bb all \u2192 npx (all x)\n\n\u00ac\u2203\u00ac\u21d2\u2200 : \u2200{\u2113} {A : Set \u2113} {P : A \u2192 Set \u2113} \u2192 \u00ac (\u2203[ x ] (\u00ac (P x))) \u2192 \u2200 x \u2192 P x\n\u00ac\u2203\u00ac\u21d2\u2200 {P = P} \u00ac\u2203\u00ac x with em {P = P x}\n... | yes p = p\n... | no \u00acp = \u22a5-elim $ \u00ac\u2203\u00ac (x , \u00acp)\n\n\u00ac\u2200\u21d2\u2203\u00ac : \u2200{\u2113} {A : Set \u2113} {P : A \u2192 Set \u2113} \u2192 \u00ac(\u2200 x \u2192 P x) \u2192 \u2203[ x ] (\u00ac (P x))\n\u00ac\u2200\u21d2\u2203\u00ac {P = P} \u00ac\u2200  with em {P = \u2203[ x ] (\u00ac (P x))}\n... | yes p = p\n... | no \u00acp = \u22a5-elim (\u00ac\u2200 (\u00ac\u2203\u00ac\u21d2\u2200 \u00acp))\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192\n  \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {A = A} {r = r} e with em {P = (y : A) \u2192 r y}\n... | yes p = e , \u03bb _ \u2192 p _\n... | no \u00acp = let (x , \u00acrx) = \u00ac\u2200\u21d2\u2203\u00ac \u00acp in x , \u03bb rx \u2192 \u22a5-elim $ \u00acrx rx\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":346,"user_id":29,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Product\nopen import Data.Empty\nopen import Relation.Unary\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation\n\n\n\u00ac\u00acAtoA : {\u2113 : Level} {A : Set \u2113} \u2192 \u00ac (\u00ac A) \u2192 A\n\u00ac\u00acAtoA {\u2113} {A} \u00ac\u00acA with em {P = A}\n... | yes p = p\n... | no \u00acp = \u22a5-elim (\u00ac\u00acA \u00acp)\n\nexpToImp : {\u2113 : Level} {A : Set \u2113} {x : A} {r : Pred A \u2113} \u2192 ((x : A) \u2192 r x) \u2192 r x\nexpToImp {\u2113} {A} {x} {r} f = f x\n\n\u00acAtoE : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192 (e : A) \u2192 (({y : A} \u2192 r y) \u2192 \u22a5) \u2192 \u2203 \u03bb y \u2192 \u00ac r y\n\u00acAtoE {\u2113} {A} {r} e \u00acq with em {P = \u2203 \u03bb y \u2192 \u00ac r y }\n... | yes p = p\n... | no \u00acp with \u03bb x \u2192 \u00ac\u00acAtoA (\u00ac\u2203\u27f6\u2200\u00ac \u00acp x)\n... | v = \u22a5-elim (\u00acq (expToImp v))\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192\n  \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {\u2113} {A} {r} e with em {P = ({y : A} \u2192 r y)}\n... | yes p = e , (\u03bb x \u2192 p)\n... | no \u00acq with \u00acAtoE e \u00acq\n... | a , b = a , (\u03bb x \u2192 \u22a5-elim (b x))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":347,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Empty using (\u22a5 ; \u22a5-elim)\nopen import Data.Product using (\u03a3 ; \u2203-syntax ; _,_ )\nopen import Relation.Nullary using (\u00ac_ ; yes ; no)\nopen import Relation.Nullary.Negation renaming (contradiction to _\u21af_)\nopen import Relation.Unary using (Pred)\n\n\u00ac\u2203\u00acP\u21d2\u2200P : \u2200 {\u2113} {A : Set \u2113} {P : Pred A \u2113} \u2192 \u00ac (\u2203[ x ] (\u00ac P x)) \u2192 \u2200 x \u2192 P x\n\u00ac\u2203\u00acP\u21d2\u2200P {P = P} \u00ac\u2203\u00acP x with em {P = P x}\n...                    | yes Px = Px\n...                    | no \u00acPx = \u22a5-elim (\u00ac\u2203\u00acP (x , \u00acPx))\n\nparadox : \u2200 {\u2113} {P : Set \u2113} {D : Pred P \u2113} \u2192\n  (witness : P) \u2192 \u2203[ x ] (D x \u2192 \u2200 {y} \u2192 D y)\nparadox {D = D} w with em {P = \u2200 x \u2192 D x }\n...               | yes \u2200D = w , (\u03bb _ {y} \u2192 \u2200D y)\n...               | no \u00ac\u2200D with em {P = \u2203[ x ] (\u00ac D x)}\n...                        | yes (nd , \u00acDnd) = nd , \u03bb Dnd \u2192 Dnd \u21af \u00acDnd\n...                        | no \u00ac\u2203\u00acD = \u00ac\u2203\u00acP\u21d2\u2200P \u00ac\u2203\u00acD \u21af \u00ac\u2200D\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":348,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Empty\nopen import Data.Product\nopen import Relation.Nullary\nopen import Relation.Unary\n\n\u00ac\u2203\u2192\u2200\u00ac : \u2200 {\u2113} {A : Set \u2113} {P : Pred A \u2113} \u2192\n  \u00ac \u2203 P \u2192 (\u2200 x \u2192 \u00ac P x)\n\u00ac\u2203\u2192\u2200\u00ac \u00ac\u2203 = \u03bb x Px \u2192 \u00ac\u2203 (x , Px)\n\n\u00ac\u00ac-elim : \u2200 {\u2113} {A : Set \u2113} \u2192\n  \u00ac \u00ac A \u2192 A\n\u00ac\u00ac-elim {A = A} H with em {P = A}\n... | yes G = G\n... | no \u00acG = \u22a5-elim (H \u00acG)\n\n\u00ac\u2200\u2192\u2203\u00ac : \u2200 {\u2113} {A : Set \u2113} {P : Pred A \u2113} \u2192\n  (e : A) \u2192 (\u00ac \u2200 x \u2192 P x) \u2192 \u2203 (\u03bb x \u2192 \u00ac (P x))\n\u00ac\u2200\u2192\u2203\u00ac {A = A} {P = P} e \u00ac\u2200 with em {P = P e}\n... | no \u00acPe = e , \u00acPe\n... | yes Pe with em {P = \u2203 \u03bb x \u2192 \u00ac P x}\n...     | yes \u2203\u00acx = \u2203\u00acx\n...     | no \u00ac\u2203\u00acx with \u00ac\u2203\u2192\u2200\u00ac \u00ac\u2203\u00acx\n...         | \u2200\u00ac\u00ac =  \u22a5-elim (\u00ac\u2200 (\u03bb x \u2192 \u00ac\u00ac-elim (\u2200\u00ac\u00ac x)))\n\nparadox : \u2200 {\u2113} {A : Set \u2113} {D : Pred A \u2113} \u2192\n  (e : A) \u2192 \u2203[ x ] (D x -> \u2200 {y : A} -> D y)\nparadox {D = D} e with em {P = \u2200 y \u2192 D y}\n... | yes \u2200D = e , (\u03bb _ \u2192 \u03bb {y} \u2192 \u2200D y)\n... | no \u00ac\u2200D with \u00ac\u2200\u2192\u2203\u00ac e \u00ac\u2200D\n...     | w , \u00acDw = w , (\u03bb Dw \u2192 \u22a5-elim (\u00acDw Dw))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":349,"user_id":429,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Empty\nopen import Data.Product\nopen import Relation.Nullary\nopen import Relation.Unary\n\ndne : {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192 \u00ac (\u2200 {y : A} -> r y) \u2192 \u2203[ x ] (\u00ac r x)\ndne {_} {A} {r} \u00ac\u2200A = unLem em -- could be cleaner \u00af\\_(\u30c4)_\/\u00af\n  where\n  unLem\u02b9 : (y : A) \u2192 \u00ac (\u2203[ x ] (\u00ac r x)) \u2192 Dec (r y) \u2192 r y\n  unLem\u02b9 _ _ (yes p) = p\n  unLem\u02b9 y f (no \u00acp) = \u22a5-elim (f (y , \u00acp))\n\n  unLem : Dec (\u2203[ x ] (\u00ac r x)) \u2192 \u2203[ x ] (\u00ac r x)\n  unLem (yes p) = p\n  unLem (no \u00acp) = \u22a5-elim (\u00ac\u2200A (\u03bb {y} \u2192 unLem\u02b9 y \u00acp em))\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192\n  \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {_} {A} {r} e = unLem e em\n  where\n  unLem : A \u2192 Dec (\u2200 {y : A} \u2192 r y) \u2192 \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\n  unLem e (yes p) = e , \u03bb _ \u2192 p\n  unLem _ (no \u00acp) = proj\u2081 ce , \u03bb rx \u2192 \u22a5-elim (proj\u2082 ce rx)\n    where\n    ce : \u2203[ x ] (\u00ac r x)\n    ce = dne \u00acp\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":350,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Data.Product\nopen import Relation.Unary\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Relation.Nullary.Negation \n\n\nparadox : \u2200 {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192\n  \u2203[ x ] (r x -> \u2200 {y : A} -> r y)\nparadox {\u2113} {A} {r} e with em {_} {(z : A) \u2192 r z}  \nparadox {\u2113} {A} {r} e | yes everybodyDrinks = e , \u03bb (re : r e) {y : A} \u2192 everybodyDrinks y\nparadox {\u2113} {A} {r} e | no \u00aceverybodyDrinks with em {_} {\u2203 (\u03bb w \u2192 \u00ac r w)}\nparadox {\u2113} {A} {r} e | no \u00aceverybodyDrinks | yes (fst , snd)  = fst , \u03bb (rfst : r fst) \u2192 contradiction rfst snd\nparadox {\u2113} {A} {r} e | no \u00aceverybodyDrinks | no \u00acnonDrinker  = \u22a5-elim (\u00aceverybodyDrinks helper)\n    where helper : (z : A) \u2192 r z\n          helper z with em {_} {r z}\n          helper z | yes rz = rz\n          helper z | no \u00acrz = \u22a5-elim (\u00acnonDrinker (z , \u00acrz)) \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":351,"user_id":null,"body":"{-# OPTIONS --safe #-}\n\nopen import Level\nopen import Axiom.ExcludedMiddle\n\nmodule DrinkerParadox (em : \u2200 {\u2113 : Level} \u2192 ExcludedMiddle \u2113) where\n\nopen import Axiom.DoubleNegationElimination\n\nopen import Data.Empty\nopen import Data.Product\nopen import Function\nopen import Relation.Nullary\nopen import Relation.Unary\n\nvacuous : {\u2113\u2081 \u2113\u2082 : Level} {A : Set \u2113\u2081} {B : Set \u2113\u2082} \u2192 (\u00ac A) \u2192 A \u2192 B\nvacuous \u00aca a = \u22a5-elim (\u00aca a)\n\n\u00ac\u00ac-elim : {\u2113 : Level} {A : Set \u2113} \u2192 (\u00ac \u00ac A) \u2192 A\n\u00ac\u00ac-elim = em\u21d2dne em\n\n\u2200\u21d2\u2204\u00ac : {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192 \u2204[ x ] (\u00ac (r x)) \u2192 \u2200 {y} \u2192 r y\n\u2200\u21d2\u2204\u00ac {\u2113} {_} {r} \u00acp {y}\n  with em {\u2113} {\u00ac (r y)}\n... | yes q = \u22a5-elim (\u00acp (y , q))\n... | no \u00acq = \u00ac\u00ac-elim \u00acq\n\ncontrapositive : {\u2113\u2081 \u2113\u2082 : Level} {A : Set \u2113\u2081} {B : Set \u2113\u2082} \u2192 (A \u2192 B) \u2192 \u00ac B \u2192 \u00ac A\ncontrapositive p \u00acb = \u00acb \u2218 p\n\n\u00ac\u2200\u21d2\u2203\u00ac : {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192 \u00ac (\u2200 {y} \u2192 r y) \u2192 \u2203[ x ] (\u00ac (r x))\n\u00ac\u2200\u21d2\u2203\u00ac {\u2113} {A} {r} \u00acp = \u00ac\u00ac-elim (contrapositive {B = (\u2200 {y} \u2192 r y)} \u2200\u21d2\u2204\u00ac \u00acp)\n\nvac-exists : {\u2113\u2081 \u2113\u2082 : Level} {A : Set \u2113\u2081} {r : Pred A \u2113\u2081} {B : Set \u2113\u2082} \u2192 \u2203[ x ] (\u00ac (r x)) \u2192 \u2203[ x ] (r x \u2192 B)\nvac-exists (x , \u00acp) = x , vacuous \u00acp\n\nparadox : {\u2113 : Level} {A : Set \u2113} {r : Pred A \u2113} \u2192\n  (e : A) \u2192\n  \u2203[ x ] (r x \u2192 \u2200 {y} \u2192 r y)\nparadox {\u2113} {_} {r} e\n  with em {\u2113} {\u2200 {y} \u2192 r y}\n-- Everyone (including `e`) is drinking.\n... | yes p = e , const p\n-- Someone isn't drinking.\n... | no \u00acp = vac-exists (\u00ac\u2200\u21d2\u2203\u00ac \u00acp)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5e90c3814af7f4002e2535af":[{"id":352,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Empty\n\ndata One : Set where\n  a : One\n\nconv : {a b : Set} \u2192 a \u2261 b \u2192 a \u2192 b\nconv refl x = x\n\nwut : ((One \u2192 One) \u2261 (One \u2192 \u22a5)) \u2192 \u22a5\nwut f = (conv f) (\u03bb x \u2192 x) a\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = (One \u2192 One) , ((One \u2192 \u22a5) , wut)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":353,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Empty\nopen import Data.Unit\n\nlemma : {A B : Set} \u2192 A \u2261 B \u2192 B \u2192 A \nlemma refl b = b\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = \u22a5 , \u22a4 , \u03bb h \u2192 lemma h tt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":354,"user_id":490,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Unit\nopen import Data.Empty\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = \u22a4 , \u22a5 , \\ p -> subst (\\ x -> x) p _","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":355,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Empty\nopen import Data.Unit\n\nnope : \u2200 {A : Set} -> \u22a4 \u2261 A -> A\nnope refl = tt\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = \u22a4 , \u22a5 , nope","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":356,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Empty\n\ndata One : Set where\n  a : One\n\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\nproj\u2081 \u2203-type-ne = \u22a5\nproj\u2081 (proj\u2082 \u2203-type-ne) = One\nproj\u2082 (proj\u2082 \u2203-type-ne) x with a \n... | b rewrite sym x = b","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":357,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Unit using (\u22a4; tt)\nopen import Data.Empty using (\u22a5)\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = \u22a4 , \u22a5 , \u03bb p \u2192 subst (\u03bb x \u2192 x) p tt\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":358,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Unit\nopen import Data.Empty\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = \u22a4 , \u22a5 , \u03bb eq \u2192 subst (\u03bb x \u2192 x) eq tt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":359,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Solution where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Product\nopen import Data.Unit\nopen import Data.Empty\n\ninhabited : Set \u2192 Set\ninhabited A = \u2203 \u03bb (x : A) \u2192 \u22a4\n\ninhabited-\u22a4 : inhabited \u22a4\ninhabited-\u22a4 = tt , tt\n\n\u00acinhabited-\u22a5 : \u00ac inhabited \u22a5\n\u00acinhabited-\u22a5 = proj\u2081\n\n\u2203-type-ne : \u2203 \u03bb (A : Set) \u2192 \u2203 \u03bb B \u2192 A \u2262 B\n\u2203-type-ne = \u22a5 , \u22a4 , \u03bb eq \u2192 \u00acinhabited-\u22a5 (subst inhabited (sym eq) inhabited-\u22a4)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"60b49f44080926003a20bbed":[{"id":360,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule ListMaxZ where\n\nopen import Data.Integer\nopen import Data.Integer.Properties using (m\u2264m\u2294n; n\u2264m\u2294n; \u2294-sel; \u2264-trans)\nopen import Data.List\nopen import Data.List.Membership.Propositional\nopen import Data.List.Relation.Unary.Any\nopen import Data.Product\nopen import Data.Sum\nopen import Relation.Binary.PropositionalEquality\n\nopen import Preloaded\n\ni\u2264j\u21d2i\u2264k\u2294j : \u2200 {i j} k \u2192 i \u2264 j \u2192 i \u2264 k \u2294 j\ni\u2264j\u21d2i\u2264k\u2294j {_} {j} k i\u2264j = \u2264-trans i\u2264j (n\u2264m\u2294n k j)\n\nlist-max-\u2124-max : \u2200 (l : List \u2124) x \u2192 x \u2208 l \u2192 x \u2264 list-max-\u2124 l\nlist-max-\u2124-max (.x \u2237 xs) x (here refl) = m\u2264m\u2294n x (foldr _\u2294_ (+ 0) xs)\nlist-max-\u2124-max (y \u2237 xs) x (there el) = i\u2264j\u21d2i\u2264k\u2294j y (list-max-\u2124-max xs x el)\n\nlist-max-\u2124-\u2208 : \u2200 (l : List \u2124) -> let m = list-max-\u2124 l in m \u2208 l \u228e m \u2261 + 0\nlist-max-\u2124-\u2208 [] = inj\u2082 refl\nlist-max-\u2124-\u2208 (x \u2237 xs) with \u2294-sel x (list-max-\u2124 xs)\n... | inj\u2081 x\u2294m\u2261x = inj\u2081 (here x\u2294m\u2261x)\n... | inj\u2082 x\u2294m\u2261m with list-max-\u2124-\u2208 xs\n...   | inj\u2081 m\u2208xs rewrite x\u2294m\u2261m = inj\u2081 (there m\u2208xs)\n...   | inj\u2082 m\u22610 = inj\u2082 (trans x\u2294m\u2261m m\u22610)\n\nlist-max-\u2124-spec : \u2200 (l : List \u2124) -> let m = list-max-\u2124 l in (\u2200 x \u2192 x \u2208 l \u2192 x \u2264 m) \u00d7 (m \u2208 l \u228e m \u2261 + 0)\nlist-max-\u2124-spec l = list-max-\u2124-max l , list-max-\u2124-\u2208 l\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":361,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule ListMaxZ where\n\nopen import Data.Nat using (\u2115)\nopen import Data.Integer\nopen import Data.Integer.Properties renaming (m\u2264m\u2294n to i\u2264i\u2294j)\nopen import Data.List\nopen import Data.List.Membership.Propositional\nopen import Data.List.Relation.Unary.Any\nopen import Data.Product\nopen import Data.Sum\nopen import Relation.Binary.PropositionalEquality\nopen import Preloaded\n\n\nnat-\u2294 : (a : \u2115) \u2192 (b : \u2115) \u2192 Data.Nat._\u2294_ a b \u2261 a \u228e Data.Nat._\u2294_ a b \u2261 b\nnat-\u2294 \u2115.zero b = inj\u2082 refl\nnat-\u2294 (\u2115.suc a) \u2115.zero = inj\u2081 refl\nnat-\u2294 (\u2115.suc a) (\u2115.suc b) with nat-\u2294 a b\n... | inj\u2081 x = inj\u2081 (cong \u2115.suc x)\n... | inj\u2082 y = inj\u2082 (cong \u2115.suc y)\n\nnat-\u2293 : (a : \u2115) \u2192 (b : \u2115) \u2192 Data.Nat._\u2293_ a b \u2261 a \u228e Data.Nat._\u2293_ a b \u2261 b\nnat-\u2293 \u2115.zero b = inj\u2081 refl\nnat-\u2293 (\u2115.suc a) \u2115.zero = inj\u2082 refl\nnat-\u2293 (\u2115.suc a) (\u2115.suc b) with nat-\u2293 a b\n... | inj\u2081 x = inj\u2081 (cong \u2115.suc x)\n... | inj\u2082 y = inj\u2082 (cong \u2115.suc y)\n\nlemma-\u2294 : (a : \u2124) \u2192 (b : \u2124) \u2192 a \u2294 b \u2261 a \u228e a \u2294 b \u2261 b\nlemma-\u2294 (-[1+ a ]) (-[1+ b ]) with nat-\u2293 a b\n... | inj\u2081 x = inj\u2081 (cong -[1+_] x)\n... | inj\u2082 y = inj\u2082 (cong -[1+_] y)\nlemma-\u2294 (-[1+ a ]) (+ b) = inj\u2082 refl\nlemma-\u2294 (+ a) (-[1+ b ]) = inj\u2081 refl\nlemma-\u2294 (+ a) (+ b) with nat-\u2294 a b\n... | inj\u2081 x = inj\u2081 (cong +_ x)\n... | inj\u2082 y = inj\u2082 (cong +_ y)\n\ni\u2264j\u21d2i\u2264k\u2294j : {i j : \u2124} (k : \u2124) \u2192 i \u2264 j \u2192 i \u2264 k \u2294 j\ni\u2264j\u21d2i\u2264k\u2294j {j = j} k e with lemma-\u2294 k j\n... | inj\u2081 x rewrite x = \u2264-trans e (m\u2294n\u2261m\u21d2m\u2265n x)\n... | inj\u2082 y rewrite y = e\n\npart2 : \u2200 (l : List \u2124) \u2192 let m = list-max-\u2124 l in (m \u2208 l \u228e m \u2261 + 0)\npart2 [] = inj\u2082 refl\npart2 (x \u2237 xs) with list-max-\u2124 (x \u2237 xs) | inspect list-max-\u2124 (x \u2237 xs)\n... | .(x \u2294 foldr _\u2294_ (+ 0) xs) | [ refl ] with lemma-\u2294 x (foldr _\u2294_ (+ 0) xs)\n... | inj\u2081 z = inj\u2081 (here z)\n... | inj\u2082 y with part2 xs\n... | inj\u2081 r rewrite y = inj\u2081 (there r)\n... | inj\u2082 q rewrite y = inj\u2082 q\n\npart1 : \u2200 (l : List \u2124) \u2192 \u2200 x \u2192 x \u2208 l \u2192 x \u2264 list-max-\u2124 l\npart1 [] z ()\npart1 (x \u2237 []) .x (here refl) with lemma-\u2294 x (+ 0)\n... | inj\u2081 z rewrite z = \u2264-reflexive refl\n... | inj\u2082 y = i\u2264i\u2294j x (+ 0)\npart1 (x \u2237 y \u2237 xs) .x (here refl) = i\u2264i\u2294j x (list-max-\u2124 (y \u2237 xs))\npart1 (x \u2237 y \u2237 xs) z (there i) with part1 (y \u2237 xs) z i\n... | r = i\u2264j\u21d2i\u2264k\u2294j x r\n\nlist-max-\u2124-spec : \u2200 (l : List \u2124) \u2192 let m = list-max-\u2124 l in\n                    (\u2200 x \u2192 x \u2208 l \u2192 x \u2264 m) \u00d7 (m \u2208 l \u228e m \u2261 + 0)\nlist-max-\u2124-spec xs = part1 xs , part2 xs\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":362,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule ListMaxZ where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Integer\nopen import Data.Integer.Properties\nopen import Data.List\nopen import Data.List.Membership.Propositional\nopen import Data.Product\nopen import Data.Sum\nopen import Data.List.Relation.Unary.Any\nopen import Relation.Nullary\nopen import Data.Nat.Properties using (\u2294-identity\u02b3)\n\nopen import Preloaded\n\nlist-max1 : \u2200 l x \u2192 x \u2208 l \u2192 x \u2264 list-max-\u2124 l\nlist-max1 (x \u2237 xs) x (here refl) = m\u2264m\u2294n _ _\nlist-max1 (_ \u2237 xs) x (there h)   = \u2264-trans (list-max1 xs x h) (n\u2264m\u2294n _ _)\n\nlist-max2 : \u2200 l \u2192 let m = list-max-\u2124 l in m \u2208 l \u228e m \u2261 + 0\nlist-max2 [] = inj\u2082 refl\nlist-max2 (x \u2237 xs) with list-max2 xs | x\n... | inj\u2082 eq | + z rewrite eq | \u2294-identity\u02b3 z = inj\u2081 (here refl)\n... | inj\u2082 eq | -[1+ z ] rewrite eq = inj\u2082 refl\n... | inj\u2081 t  | z with z \u2264? list-max-\u2124 xs\n...               | yes h rewrite m\u2264n\u21d2m\u2294n\u2261n h = inj\u2081 (there t)\n...               | no  h = inj\u2081 (here (m\u2265n\u21d2m\u2294n\u2261m (<\u21d2\u2264 (\u2270\u21d2> h))))\n\nlist-max-\u2124-spec : \u2200 (l : List \u2124) \u2192 let m = list-max-\u2124 l in\n                    (\u2200 x \u2192 x \u2208 l \u2192 x \u2264 m) \u00d7 (m \u2208 l \u228e m \u2261 + 0)\nlist-max-\u2124-spec l = list-max1 l , list-max2 l","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"62528562983b3500648ff989":[{"id":363,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.Empty\n\nlemma\u00b2 : \u2200 {A : Set} (x : A) (xs : List A) \u2192 xs \u2262 [] \u2192 last (x \u2237 xs) \u2261 last xs\nlemma\u00b2 x [] proof = \u22a5-elim (proof refl)\nlemma\u00b2 x (x\u2081 \u2237 xs) proof = refl\n\nlemma\u00b3 : \u2200 {A : Set} (ys xs : List A) \u2192 xs \u2262 [] \u2192 ys ++ xs \u2262 []\nlemma\u00b3 ys [] proof = \u22a5-elim (proof refl)\nlemma\u00b3 [] (x \u2237 xs) proof = proof\nlemma\u00b3 (x\u2081 \u2237 ys) (x \u2237 xs) proof = \u03bb ()\n\nlemma\u2074 : \u2200 {A : Set} (y x : A) (ys xs : List A) \u2192 x \u2237 xs \u2262 [] \u2192 last (y \u2237 ys ++ x \u2237 xs) \u2261 last (ys ++ x \u2237 xs)\nlemma\u2074 y x ys xs xempty = lemma\u00b2 y (ys ++ x \u2237 xs) (lemma\u00b3 ys (x \u2237 xs) xempty)\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end ys [] proof = \u22a5-elim (proof refl)\ninevitable-end [] (x \u2237 xs) _ = refl\ninevitable-end (y \u2237 ys) (x \u2237 xs) xempty rewrite lemma\u2074 y x ys xs xempty = inevitable-end ys (x \u2237 xs) xempty\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":364,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end [] xs _ = refl\ninevitable-end (y \u2237 []) [] p with p refl\n... | ()\ninevitable-end (y \u2237 []) (x \u2237 xs) _ = refl\ninevitable-end (y\u2081 \u2237 y\u2082 \u2237 ys) xs p = inevitable-end (y\u2082 \u2237 ys) xs p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":365,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.Empty\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end [] xs p = refl\ninevitable-end (x \u2237 []) [] p = \u22a5-elim (p refl)\ninevitable-end (x \u2237 []) (y \u2237 xs) p = refl\ninevitable-end (x \u2237 y \u2237 ys) xs p = inevitable-end (y \u2237 ys) xs p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":366,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.Empty\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end ys [] e = \u22a5-elim (e refl)\ninevitable-end [] (x \u2237 xs) e = refl\ninevitable-end (y \u2237 []) (x \u2237 xs) e = refl\ninevitable-end (y \u2237 z \u2237 ys) (x \u2237 xs) e = inevitable-end (z \u2237 ys) (x \u2237 xs) e\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":367,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Preloaded\n\ndata NonEmpty {A : Set} : List A \u2192 Set where\n  _\u2237_ : (x : A) \u2192 (xs : List A) \u2192 NonEmpty (x \u2237 xs)\n\nnon-empty : \u2200 {A : Set} {xs : List A} \u2192 xs \u2262 [] \u2192 NonEmpty xs\nnon-empty {xs = []} xs\u2262[] with xs\u2262[] refl\n... | ()\nnon-empty {xs = x \u2237 xs} _ = x \u2237 xs\n\ninevitable-end : \u2200 {A : Set} (ys xs : List A) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end (_ \u2237 y \u2237 ys) _ xs\u2262[] = inevitable-end (y \u2237 ys) _ xs\u2262[]\ninevitable-end (y \u2237 [])     _ xs\u2262[] with non-empty xs\u2262[]\n... | _ \u2237 _ = refl\ninevitable-end []           _ _     = refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":368,"user_id":522,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Data.List\nopen import Data.Empty\nopen import Preloaded\nimport Relation.Binary.PropositionalEquality as Eq\nopen Eq\nopen Eq.\u2261-Reasoning\n\n\nlast-lemma : \u2200 {A : Set} {x : A} xs \u2192 xs \u2262 [] \u2192 last (x \u2237 xs) \u2261 last xs\nlast-lemma [] p = \u22a5-elim (p refl)\nlast-lemma (_ \u2237 _) _ = refl\n\nhelper : \u2200 {A : Set} {xs} (ys : List A) \u2192 xs \u2262 [] \u2192 (ys ++ xs) \u2262 []\nhelper [] p = p\nhelper (_ \u2237 _) _ ()\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end [] _ _ = refl\ninevitable-end (y \u2237 ys) xs p =\n  begin\n    last (y \u2237 (ys ++ xs))\n  \u2261\u27e8 last-lemma (ys ++ xs) (helper ys p) \u27e9\n    last (ys ++ xs)\n  \u2261\u27e8 inevitable-end ys xs p \u27e9\n    last xs\n  \u220e","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":369,"user_id":106,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Empty\nopen import Data.List\nopen import Preloaded\n\nlemma : {a : Set} (x : a) (xs : List a) \u2192 xs \u2262 [] \u2192 last (x \u2237 xs) \u2261 last xs\nlemma x [] p = \u22a5-elim (p refl)\nlemma x (y \u2237 ys) _ = refl\n\nempty-ext : {a : Set} (xs ys : List a) \u2192 xs \u2262 [] \u2192 (ys ++ xs) \u2262 []\nempty-ext xs [] p = p\nempty-ext xs (y \u2237 ys) p ()\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end [] xs _ = refl\ninevitable-end (y \u2237 ys) xs p = trans (lemma y _ (empty-ext xs ys p)) (inevitable-end ys xs p)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":370,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\n\nopen import Preloaded\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.List.Properties\nopen import Data.Maybe \nopen import Data.Maybe.Properties\nopen import Data.Empty\n \nopen \u2261-Reasoning \n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end [] xs h = refl\ninevitable-end (y \u2237 ys) xs h with (ys ++ xs) | inspect (ys ++_) xs | inevitable-end ys xs h\n... | [] | [ eq ] | rec = \u22a5-elim (h (++-conical\u02b3 ys xs eq))\n... | x \u2237 u | _ | rec = rec","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":371,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule InevitableEnd where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.List\nopen import Data.Empty\nopen import Preloaded\n\nlemma : {A : Set} \u2192 \u2200 (x : A) (xs : List A) \u2192 xs \u2262 [] \u2192 last (x \u2237 xs) \u2261 last xs\nlemma x [] neq = \u22a5-elim (neq refl)\nlemma x (x\u2081 \u2237 xs) neq = refl\n\nappend-not-nil : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 ys ++ xs \u2262 []\nappend-not-nil [] xs neq = neq\nappend-not-nil (x \u2237 xs\u2081) xs neq = \u03bb ()\n\ninevitable-end : {a : Set} (ys xs : List a) \u2192 xs \u2262 [] \u2192 last (ys ++ xs) \u2261 last xs\ninevitable-end [] xs neq = refl\ninevitable-end (x \u2237 ys) xs neq = trans (lemma x (ys ++ xs) (append-not-nil ys xs neq)) (inevitable-end ys xs neq)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5424e3bc430ca2e577000048":[{"id":372,"user_id":1163,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\nopen import Function\nopen import Relation.Nullary\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a -- if true then return left term, else return right term\n\nopen Language {{...}} public\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\nrecord Arrow (a b : Set) : Set where\n  constructor mkArrow\n  field arrow : a \u2192 b\nopen Arrow\n\npure : \u2200 {H A : Set} \u2192 A \u2192 Arrow H A\npure a = mkArrow (\u03bb _ \u2192 a)\n\n_<*>_ : \u2200 {A B H : Set} \u2192\n        (Arrow H (A \u2192 B)) \u2192 (Arrow H A) \u2192 (Arrow H B)\nmkArrow f <*> mkArrow x = mkArrow \u03bb h \u2192 f h (x h)\n\n{-# TERMINATING #-}\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\ninstance\n  LanguageArrow : Language Arrow\n  LanguageArrow = \u03bb where\n    .here \u2192 mkArrow proj\u2081\n    .before a \u2192 mkArrow \u03bb {(_ , h) \u2192 arrow a h}\n    .lambda b \u2192 mkArrow $ \u03bb h a \u2192 arrow b (a , h)\n    .apply \u2192 _<*>_\n    .loop f \u2192 fix (\u03bb loop \u2192 \u2987 f $ loop \u2988)\n    .nat \u2192 pure\n    .add a b \u2192 \u2987 a + b \u2988\n    .down n \u2192 \u2987 pred n \u2988\n    .up n \u2192 \u2987 suc n \u2988\n    .mult a b \u2192 \u2987 a * b \u2988\n    .gte a b \u2192 mkArrow \u03bb h \u2192 case arrow a h \u2265? arrow b h of \u03bb\n      { (yes _) \u2192 true\n      ; (no _) \u2192 false\n      }\n    .bool \u2192 pure\n    .and a b \u2192 \u2987 a \u2227 b \u2988\n    .or a b \u2192 \u2987 a \u2228 b \u2988\n    .neg b \u2192 \u2987 not b \u2988\n    .ifte cond p1 p2 \u2192 \u2987 if cond then p1 else p2 \u2988\n  \n\nrun = arrow\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret t = run t tt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":373,"user_id":null,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\nopen import Relation.Binary.PropositionalEquality\nopen import Function using (_$_; _\u02e2_; const; _\u27e8_\u27e9_)\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n\n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n\n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n\n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n\n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n    -- if true then return left term, else return right term\n\nopen Language {{...}} public -- use instance arguments to simulate type classes\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\n{-# TERMINATING #-} -- maybe you need this to implement loop\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\n\ninstance\n  l : Language (\u03bb h a \u2192 (h \u2192 a))\n  here   {{l}} (x , _) = x\n  before {{l}} N (_ , y) = N y\n  lambda {{l}} N env x = N (x , env)\n  apply  {{l}} L N = L \u02e2 N\n  loop   {{l}} N env = fix $ N env\n  nat    {{l}} = const\n  add    {{l}} M N env = M env + N env\n  down   {{l}} M env = pred (M env)\n  up     {{l}} M env = suc (M env)\n  mult   {{l}} M N env = M env * N env\n  gte    {{l}} M N env = not $ (M env \u27e8 _<\u1d47_ \u27e9 N env)\n  bool   {{l}} = const\n  and    {{l}} M N env = M env \u2227 N env\n  or     {{l}} M N env = M env \u2228 N env\n  neg    {{l}} M env = not (M env)\n  ifte   {{l}} L M N env = if L env then M env else N env\n\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret t = t tt\n\n_ : interpret (apply (lambda here) (nat 3)) \u2261 3\n_ = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":374,"user_id":522,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\nopen import Function\nopen import Relation.Nullary.Decidable\n\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a \u2192 r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n\nopen Language {{...}} public\n\n\n{-# TERMINATING #-}\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\nliftM2 : {A B C : Set} \u2192 (B \u2192 B \u2192 C) \u2192 (f g : A \u2192 B) \u2192 A \u2192 C\nliftM2 op f g x = op (f x) (g x)\n\n\nrecord R (A B : Set) : Set where\n  constructor r\n  field\n    unR : A \u2192 B\nopen R \n\ninstance\n  l : Language R\n  here   \u2983 l \u2984             = r proj\u2081\n  before \u2983 l \u2984 (r f)       = r $ f \u2218 proj\u2082\n  lambda \u2983 l \u2984 (r f)       = r \u03bb h a \u2192 f (a , h) \n  apply  \u2983 l \u2984 (r f) (r g) = r \u03bb h \u2192 f h (g h)\n\n  loop   \u2983 l \u2984 (r f)       = r $ fix \u2218 f\n\n  nat    \u2983 l \u2984 n           = r (const n)\n  add    \u2983 l \u2984 (r f) (r g) = r $ liftM2 _+_ f g\n  down   \u2983 l \u2984 (r f)       = r (pred \u2218 f)\n  up     \u2983 l \u2984 (r f)       = r (suc \u2218 f)\n  mult   \u2983 l \u2984 (r f) (r g) = r $ liftM2 _*_ f g\n  gte    \u2983 l \u2984 (r f) (r g) = r $ liftM2 ((\u230a_\u230b \u2218_) \u2218 _\u2265?_) f g\n\n  bool   \u2983 l \u2984 b           = r (const b)\n  and    \u2983 l \u2984 (r f) (r g) = r $ liftM2 _\u2227_ f g\n  or     \u2983 l \u2984 (r f) (r g) = r $ liftM2 _\u2228_ f g\n  neg    \u2983 l \u2984 (r f)       = r (not \u2218 f)\n\n  ifte   \u2983 l \u2984 (r p) (r f) (r g)\n    = r \u03bb x \u2192 if p x then f x else g x\n\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\ninterpret : \u2200 {a : Set} \u2192 Term a \u2192 a\ninterpret t = unR t zero\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":375,"user_id":null,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n    -- if true then return left term, else return right term\n\nopen Language {{...}} public -- use instance arguments to simulate type classes\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\n{-# TERMINATING #-} -- maybe you need this to implement loop\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\n\ndata R (h a : Set) : Set where\n  r : (h \u2192 a) \u2192 R h a\n\nunR : \u2200 {h a} \u2192 R h a \u2192 h \u2192 a\nunR (r f) = f\n\n-- yeah...\ninfix 4 _\u2264\u1d47_\n_\u2264\u1d47_ : (m n : \u2115) \u2192 Bool\nzero  \u2264\u1d47 n = true\nsuc m \u2264\u1d47 n = m <\u1d47 n\n\n\ninstance    \n  Lan : Language R\n  Lan = record\n          { here   = r (\u03bb { (x , _) \u2192 x } )\n          ; before = \u03bb v \u2192 r (\u03bb { (_ , h) \u2192 unR v h }) \n          ; lambda = \u03bb b \u2192 r \u03bb h a \u2192 unR b (a , h)\n          ; apply  = \u03bb f a \u2192 r (\u03bb h \u2192 unR f h (unR a h))\n          ; loop = \u03bb f \u2192 r \u03bb h \u2192 fix (unR f h)\n          ; nat = \u03bb n \u2192 r \u03bb _ \u2192 n\n          ; add = \u03bb n m \u2192 r \u03bb h \u2192 unR n h + unR m h\n          ; down = \u03bb n \u2192 r \u03bb h \u2192 pred (unR n h)\n          ; up = \u03bb n \u2192 r \u03bb h \u2192 suc (unR n h)\n          ; mult = \u03bb n m \u2192 r \u03bb h \u2192 unR n h * unR m h\n          ; gte = \u03bb n m \u2192 r \u03bb h \u2192 not (suc (unR n h) \u2264\u1d47 unR m h)\n          ; bool = \u03bb b \u2192 r \u03bb _ \u2192 b\n          ; and = \u03bb a b \u2192 r \u03bb h \u2192 unR a h \u2227 unR b h\n          ; or = \u03bb a b \u2192 r \u03bb h \u2192 unR a h \u2228 unR b h\n          ; neg = \u03bb a \u2192 r \u03bb h \u2192 not (unR a h)\n          ; ifte = \u03bb i t e \u2192 r \u03bb h \u2192 if unR i h then unR t h else unR e h \n          }\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret t with t {h = \u22a4} {{l = Lan}}\n... | r x = x tt\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":376,"user_id":null,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n    -- if true then return left term, else return right term\n\nopen Language {{...}} public -- use instance arguments to simulate type classes\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\n{-# TERMINATING #-} -- maybe you need this to implement loop\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\ninstance\n  open Language\n  impl : Language (\u03bb x y \u2192 x \u2192 y)\n  here impl (a , h) = a\n  before impl f (_ , h) = f h\n  lambda impl f h a = f (a , h)\n  apply impl f g h = f h (g h)\n  loop impl f h = fix (f h) \n  nat impl n h = n\n  add impl f g h = f h + g h\n  down impl f h = pred (f h)\n  up impl f h = suc (f h)\n  mult impl f g h = (f h) * (g h)\n  gte impl f g h = not ((f h) <\u1d47 (g h))\n  bool impl n h = n\n  and impl f g h = (f h) \u2227 (g h)\n  or impl f g h = (f h) \u2228 (g h)\n  neg impl f h = not (f h)\n  ifte impl f m n h = if f h then m h else n h\n\nrun : \u2200 {a h} \u2192 Term a -> h -> a\nrun u = u\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret t = run t tt","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":377,"user_id":53,"body":"module Tagless where\n\nopen import Function\nopen import Relation.Nullary\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a -- if true then return left term, else return right term\n\nopen Language {{...}} public\n\nrecord Fn (x y : Set) : Set where\n  constructor gen\n  field fn : x \u2192 y\n  \nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\nopen Fn\n\npure : \u2200 {X Y : Set} \u2192 Y \u2192 Fn X Y\npure x = gen (\u03bb _ \u2192 x)\n\n_<*>_ : \u2200 {X Y N : Set} \u2192 (Fn N (X \u2192 Y)) \u2192 (Fn N X) \u2192 (Fn N Y)\ngen f <*> gen g = gen \u03bb n \u2192 f n (g n)\n\n{-# TERMINATING #-}\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\ninstance\n  ln : Language Fn\n  ln = \u03bb where\n    .here \u2192 gen proj\u2081\n    .before x \u2192 gen \u03bb {(_ , n) \u2192 fn x n}\n    .lambda y \u2192 gen (\u03bb n x \u2192 fn y (x , n))\n    .apply \u2192 _<*>_\n    .loop f \u2192 fix (\u03bb loop \u2192 \u2987 f $ loop \u2988)\n    .nat \u2192 pure\n    .add x y \u2192 \u2987 x + y \u2988\n    .down n \u2192 \u2987 pred n \u2988\n    .up n \u2192 \u2987 suc n \u2988\n    .mult x y \u2192 \u2987 x * y \u2988\n    .gte x y \u2192 gen \u03bb n \u2192 case fn x n \u2265? fn y n of \u03bb\n      { (yes _) \u2192 true ; (no _) \u2192 false\n      }\n    .bool \u2192 pure\n    .and x y \u2192 \u2987 x \u2227 y \u2988\n    .or x y \u2192 \u2987 x \u2228 y \u2988\n    .neg x \u2192 \u2987 not x \u2988\n    .ifte pred a b \u2192 \u2987 if pred then a else b \u2988\n  \nrun = fn\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret term = run term tt\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":378,"user_id":null,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n    -- if true then return left term, else return right term\n\nopen Language {{...}} public -- use instance arguments to simulate type classes\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\n{-# TERMINATING #-} -- maybe you need this to implement loop\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\nopen import Data.Bool\nopen import Function\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret {a} t = t tt\n  where r : Set \u2192 Set \u2192 Set\n        r \u0393 T = \u0393 \u2192 T\n        instance L : Language r\n        app : \u2200{a b \u0393}(f : a \u2192 b) \u2192 r \u0393 a \u2192 r \u0393 b\n        app f \u0393\u2192a \u0393 = f (\u0393\u2192a \u0393)\n        app\u2082 : \u2200{a b c \u0393}(f : a \u2192 b \u2192 c) \u2192 r \u0393 a \u2192 r \u0393 b \u2192 r \u0393 c\n        app\u2082 f\u2082 \u0393\u2192a\u2081 \u0393\u2192a\u2082 \u0393 = f\u2082 (\u0393\u2192a\u2081 \u0393)(\u0393\u2192a\u2082 \u0393)\n        L .here (x , _) = x\n        L .before \u0393\u2192T (_ , \u0393) = \u0393\u2192T \u0393\n        L .lambda [x,\u0393]\u2192T \u0393 = \u03bb x \u2192 [x,\u0393]\u2192T (x , \u0393)\n        L .apply = app\u2082 _$_\n        L .loop = app fix\n        L .nat n _ = n\n        L .add = app\u2082 _+_\n        L .down = app pred\n        L .up = app suc\n        L .mult = app\u2082 _*_\n        L .gte = app\u2082 \u03bb n\u2081 n\u2082 \u2192 (n\u2082 <\u1d47 n\u2081) \u2228 (n\u2081 \u2261\u1d47 n\u2082)\n        L .bool b _ = b\n        L .and = app\u2082 _\u2227_\n        L .or = app\u2082 _\u2228_\n        L .neg = app not\n        L .ifte \u0393\u2192b \u0393\u2192a\u2081 \u0393\u2192a\u2082 \u0393 = if \u0393\u2192b \u0393 then \u0393\u2192a\u2081 \u0393 else \u0393\u2192a\u2082 \u0393\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":379,"user_id":null,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\nopen import Relation.Nullary\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n    -- if true then return left term, else return right term\n\n--open Language {{...}} -- use instance arguments to simulate type classes\n\n\nhere   : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {a h} \u2192 r (a \u00d7 h) a\nhere {{l = l}} = Language.here l\nbefore : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\nbefore {{l = l}} = Language.before l\n\nlambda : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\nlambda {{l = l}} = Language.lambda l\napply  : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\napply {{l = l}} = Language.apply l    \nloop   : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\nloop {{l = l}} = Language.loop l\nnat    : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\nnat {{l = l}} = Language.nat l\nadd    : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\nadd {{l = l}} = Language.add l\ndown   : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\ndown {{l = l}} = Language.down l\nup     : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\nup {{l = l}} = Language.up l\nmult   : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\nmult {{l = l}} = Language.mult l\ngte    : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\ngte {{l = l}} = Language.gte l\n  \nbool   : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 Bool \u2192 r h Bool\nbool {{l = l}} = Language.bool l\nand    : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\nand {{l = l}} = Language.and l\nor     : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\nor {{l = l}} = Language.or l\nneg    : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {h} \u2192 r h Bool \u2192 r h Bool\nneg {{l = l}} = Language.neg l\nifte   : \u2200 {r} \u2192 {{l : Language r}} \u2192 \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\nifte {{l = l}} = Language.ifte l\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\n{-# TERMINATING #-} -- maybe you need this to implement loop\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\ninstance\n  imply-lang : Language (\u03bb x \u2192 \u03bb y \u2192 x \u2192 y)\n  imply-lang = record\n                 { here = \u03bb {a} {h} \u2192 proj\u2081\n                 ; before = \u03bb {a} {h} {any} z z\u2081 \u2192 z (proj\u2082 z\u2081)\n                 ; lambda = \u03bb {a} {b} {h} z z\u2081 z\u2082 \u2192 z (z\u2082 , z\u2081)\n                 ; apply = \u03bb {a} {b} {h} z z\u2081 z\u2082 \u2192 z z\u2082 (z\u2081 z\u2082)\n                 ; loop = \u03bb x x\u2081 \u2192 fix (x x\u2081)\n                 ; nat = \u03bb {h} z _ \u2192 z\n                 ; add = \u03bb {h} x y z \u2192 x z + y z\n                 ; down = \u03bb x x\u2081 \u2192 pred (x x\u2081)\n                 ; up = \u03bb x x\u2081 \u2192 suc (x x\u2081)\n                 ; mult = \u03bb {h} x y z \u2192 x z * y z\n                 ; gte = \u03bb x x\u2081 x\u2082 \u2192 match (x x\u2082 \u2265? x\u2081 x\u2082)\n\n                 ; bool = \u03bb {h} z _ \u2192 z\n                 ; and = \u03bb x x\u2081 x\u2082 \u2192 (x x\u2082) \u2227 (x\u2081 x\u2082)\n                 ; or = \u03bb x x\u2081 x\u2082 \u2192 (x x\u2082) \u2228 (x\u2081 x\u2082)\n                 ; neg = \u03bb x x\u2081 \u2192 not (x x\u2081)\n                 ; ifte = \u03bb x x\u2081 x\u2082 x\u2083 \u2192 if (x x\u2083) then (x\u2081 x\u2083) else (x\u2082 x\u2083)\n                 }\n     where match : \u2200 {x} \u2192 Dec x \u2192 Bool\n           match (yes _) = true\n           match (no _) = false\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret t = t {{l = imply-lang}} 0\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":380,"user_id":null,"body":"module Tagless where\n\nopen import Data.Nat\nopen import Data.Bool\nopen import Data.Product\nopen import Data.Unit\nopen import Relation.Nullary\n\nrecord Language (r : Set \u2192 Set \u2192 Set) : Set\u2081 where\n  field\n    here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n    before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n\n    lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n    apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n    \n    loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  \n    nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n    add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n    up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n    mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n    gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  \n    bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n    and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n    neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  \n    ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n    -- if true then return left term, else return right term\n\nNaive-interp : Set \u2192 Set \u2192 Set\nNaive-interp Env R = Env \u2192 R\n\n{-# TERMINATING #-} -- maybe you need this to implement loop\nfix : \u2200 {A : Set} \u2192 (A \u2192 A) \u2192 A\nfix f = f (fix f)\n\ngte-bool : \u2115 \u2192 \u2115 \u2192 Bool\ngte-bool x y with x \u2265? y\ngte-bool x y | Relation.Nullary.Dec.yes p = true\ngte-bool x y | Relation.Nullary.Dec.no \u00acp = false\n\nmodule Naive-lang where\n  r = Naive-interp\n\n  here   : \u2200 {a h} \u2192 r (a \u00d7 h) a\n  here (x , _) = x\n\n  before : \u2200 {a h any} \u2192 r h a -> r (any \u00d7 h) a\n  before f (_ , env) = f env\n\n  lambda : \u2200 {a b h} \u2192 r (a \u00d7 h) b \u2192 r h (a \u2192 b)\n  lambda body env x = body (x , env)\n  \n  apply  : \u2200 {a b h} \u2192 r h (a \u2192 b) \u2192 (r h a \u2192 r h b)\n  apply f x env = f env (x env)\n  \n  loop   : \u2200 {a h} \u2192 r h (a \u2192 a) \u2192 r h a\n  loop f env = fix (\u03bb r \u2192 f env r)\n\n  nat    : \u2200 {h} \u2192 \u2115 \u2192 r h \u2115\n  nat n _ = n\n  \n  add    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n  add x y env = x env + y env\n\n  down   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- pred\n  down x env = pred (x env)\n\n  up     : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115    -- succ\n  up x env = suc (x env)\n  \n  mult   : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h \u2115\n  mult x y env = x env * y env\n  \n  gte    : \u2200 {h} \u2192 r h \u2115 \u2192 r h \u2115 \u2192 r h Bool -- greater than or equal\n  gte x y env = gte-bool (x env) (y env)\n\n  bool   : \u2200 {h} \u2192 Bool \u2192 r h Bool\n  bool x env = x\n  \n  and    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n  and x y env = x env \u2227 y env\n\n  or     : \u2200 {h} \u2192 r h Bool \u2192 r h Bool \u2192 r h Bool\n  or x y env = x env \u2228 y env\n\n  neg    : \u2200 {h} \u2192 r h Bool \u2192 r h Bool\n  neg x env = not (x env)\n\n  ifte   : \u2200 {a h} \u2192 r h Bool \u2192 r h a \u2192 r h a \u2192 r h a\n  ifte cond x y env =\n    if cond env then x env else y env\n\n  lang : Language Naive-interp\n  lang = record\n           { here = here\n           ; before = before\n           ; lambda = lambda\n           ; apply = apply\n           ; loop = loop\n           ; nat = nat\n           ; add = add\n           ; down = down\n           ; up = up\n           ; mult = mult\n           ; gte = gte\n           ; bool = bool\n           ; and = and\n           ; or = or\n           ; neg = neg\n           ; ifte = ifte\n           }\n\nopen Language {{...}} public -- use instance arguments to simulate type classes\n\nTerm : Set \u2192 Set\u2081\nTerm a = \u2200 {r h} {{l : Language r}} \u2192 r h a\n\ninterpret : \u2200 {a} \u2192 Term a \u2192 a\ninterpret t = t {r = Naive-interp} {h = \u22a4} {{l = Naive-lang.lang}} tt\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c7fe5c859036f142eccaabb":[{"id":381,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char\nopen import Data.Integer as D\nopen import Data.Float as F\nopen import Data.String as S\nopen import Data.List\nopen import Data.Product\n\nsprintfProduct : (fmt : List Char) \u2192 \u03a3[ A \u2208 Set ] (String \u2192 A)\nsprintfProduct [] = String , \\s -> s\nsprintfProduct ('%' \u2237 'd' \u2237 fmt) = (\u2124 \u2192 proj\u2081 (sprintfProduct fmt)) , \\s d \u2192 proj\u2082 (sprintfProduct fmt) (s S.++ D.show d)\nsprintfProduct ('%' \u2237 'f' \u2237 fmt) = (Float \u2192 proj\u2081 (sprintfProduct fmt)) , \\s f \u2192 proj\u2082 (sprintfProduct fmt) (s S.++ F.show f)\nsprintfProduct ('%' \u2237 'c' \u2237 fmt) = (Char \u2192 proj\u2081 (sprintfProduct fmt)) , \\s c \u2192 proj\u2082 (sprintfProduct fmt) (s S.++ fromList [ c ])\nsprintfProduct ('%' \u2237 '%' \u2237 fmt) = proj\u2081 (sprintfProduct fmt) , \\s \u2192 proj\u2082 (sprintfProduct fmt) (s S.++ \"%\")\nsprintfProduct (c \u2237 fmt) = proj\u2081 (sprintfProduct fmt) , \\s \u2192 proj\u2082 (sprintfProduct fmt) (s S.++ fromList [ c ])\n\nsprintf : (fmt : String) \u2192 proj\u2081 (sprintfProduct (toList fmt))\nsprintf fmt = proj\u2082 (sprintfProduct (toList fmt)) \"\"","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":382,"user_id":60,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char\nopen import Data.Empty\nopen import Data.Float renaming (show to show\u211d)\nopen import Data.Integer renaming (show to show\u2124)\nopen import Data.List hiding (_++_) renaming (_\u2237_ to _::_)\nopen import Data.String\n\ndata Format : Set where\n  lit : Char -> Format\n  arg : Char -> Format\n\nfromChar : Char -> String\nfromChar c = fromList [ c ]\n\nparse : List Char -> List Format\nparse ('%' :: '%' :: xs) = lit '%' :: parse xs\nparse ('%' :: c :: xs)   = arg c :: parse xs\nparse (c :: xs)          = lit c :: parse xs\nparse []                 = []\n\ntoType' : Char -> Set\ntoType' 'c' = Char\ntoType' 'd' = \u2124\ntoType' 'f' = Float\ntoType' _   = \u22a5\n\ntoType : List Format -> Set\ntoType []            = String\ntoType (lit _ :: xs) = toType xs\ntoType (arg c :: xs) = toType' c -> toType xs\n\ntoFunc' : (c : Char) -> toType' c -> String\ntoFunc' 'c' = fromChar\ntoFunc' 'd' = show\u2124\ntoFunc' 'f' = show\u211d\ntoFunc' _ _ = \"\"\n\ntoFunc : (a : List Format) -> String -> toType a\ntoFunc [] s              = s\ntoFunc (lit c :: xs) s   = toFunc xs (s ++ fromChar c)\ntoFunc (arg c :: xs) s a = toFunc xs (s ++ toFunc' c a)\n\nsprintf : (s : String) -> toType (parse (toList s))\nsprintf s = toFunc (parse (toList s)) \"\"","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":383,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char renaming (_==_ to _c=_)\nopen import Data.Integer renaming (show to show\u2124)\nopen import Data.Float renaming (show to showF)\nopen import Data.String\nopen import Data.Bool\nopen import Data.Empty\nopen import Data.Maybe\nopen import Data.Product\nopen import Data.List hiding (_++_)\n\n\nmutual\n  format' : (xs : List Char) \u2192 List Set\n  format' [] = []\n  format' (c \u2237 cs) with c c= '%'\n  ... | false = format' cs\n  ... | true = format'' cs\n\n  format'' : (xs : List Char) \u2192 List Set\n  format'' [] = [ \u22a5 ]\n  format'' (d \u2237 cs)  with d c= '%'\n  ... | true = format' cs\n  ... | false with d c= 'd'\n  ... | true = \u2124 \u2237 format' cs\n  ... | false with d c= 'f'\n  ... | true = Float \u2237 format' cs\n  ... | false with d c= 'c'\n  ... | true = Char \u2237 format' cs\n  ... | false = [ \u22a5 ]\n\ndata HList : List Set \u2192 Set where\n  hnil  : HList []\n  hcons : \u2200 {a as} \u2192 a \u2192 HList as \u2192 HList (a \u2237 as)\n\nmutual\n  sprintf' : (fmt : List Char) \u2192 HList (format' fmt) \u2192 String\n  sprintf' [] = \u03bb _ \u2192 \"\"\n  sprintf' (c \u2237 cs) with c c= '%'\n  ... | false = \u03bb ps \u2192 fromList [ c ] ++ sprintf' cs ps\n  ... | true = \u03bb ps \u2192 sprintf'' cs ps\n\n  sprintf'' : (fmt : List Char) \u2192 HList (format'' fmt) \u2192 String\n  sprintf'' [] = \u03bb { (hcons () _) }\n  sprintf'' (d \u2237 cs') with d c= '%'\n  ... | true = \u03bb ps \u2192 \"%\" ++ sprintf' cs' ps\n  ... | false with d c= 'd'\n  ... | true = \u03bb { (hcons p ps) \u2192 show\u2124 p ++ sprintf' cs' ps }\n  ... | false with d c= 'f'\n  ... | true = \u03bb { (hcons p ps) \u2192 showF p ++ sprintf' cs' ps }\n  ... | false with d c= 'c'\n  ... | true = \u03bb { (hcons p ps) \u2192 fromList [ p ] ++ sprintf' cs' ps }\n  ... | false = \u03bb { (hcons () _) }\n\ncurried : (as : List Set) (b : Set) \u2192 Set\ncurried [] b = b\ncurried (a \u2237 as) b = a \u2192 curried as b\n\nformat : String \u2192 Set\nformat s = curried (format' (toList s)) String\n\ncurry' : \u2200 {as b} \u2192 (HList as \u2192 b) \u2192 curried as b\ncurry' {[]}     f = f hnil\ncurry' {a \u2237 as} f = \u03bb x \u2192 curry' (\u03bb xs \u2192 f (hcons x xs))\n\nsprintf : (fmt : String) -> format fmt\nsprintf fmt = curry' (sprintf' (toList fmt))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":384,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat \nopen import Data.Nat.Properties \nopen import Induction.WellFounded\nopen import Relation.Nullary\nopen import Relation.Nullary.Negation \nopen import Data.List\nopen import Data.Empty\n\nopen import Data.Char\nopen import Data.Integer\nopen import Data.Float\nopen import Data.String\n\nopen import Agda.Primitive\n\nsprintfArgType : Char \u2192 Set\nsprintfArgType c with c Data.Char.\u225f 'd'\nsprintfArgType c | yes isInt = \u2124\nsprintfArgType c | no \u00acisInt with c Data.Char.\u225f 'f'\nsprintfArgType c | no \u00acisInt | yes isFloat = Float\nsprintfArgType c | no \u00acisInt | no \u00acisFloat with c Data.Char.\u225f 'c'\nsprintfArgType c | no \u00acisInt | no \u00acisFloat | yes isChar = Char\nsprintfArgType c | no \u00acisInt | no \u00acisFloat | no \u00acisChar = \u22a5\n\ntypeListToFunc : {\u2113 : Level} \u2192 Set \u2113 \u2192 List Set \u2192 Set \u2113\ntypeListToFunc finalReturnType [] = finalReturnType\ntypeListToFunc finalReturnType (x \u2237 ls) = x \u2192 (typeListToFunc finalReturnType ls)\n\ndata SprintfArg : Set\u2081  where\n    sprintfArg : {c : Char} \u2192 {t : Set} \u2192 t \u2261 sprintfArgType c \u2192 SprintfArg\n    sprintfText : String \u2192 SprintfArg\n\nshowArg : {c : Char} \u2192 {t : Set} \u2192 t \u2261 sprintfArgType c \u2192 t \u2192 String\nshowArg {c} {t} eq v with c Data.Char.\u225f 'd'\nshowArg {c} {t} eq v | yes isInt rewrite eq = Data.Integer.show v\nshowArg {c} {t} eq v | no \u00acisInt with c Data.Char.\u225f 'f'\nshowArg {c} {t} eq v | no \u00acisInt | yes isFloat rewrite eq = Data.Float.show v\nshowArg {c} {t} eq v | no \u00acisInt | no \u00acisFloat with c Data.Char.\u225f 'c'\nshowArg {c} {t} eq v | no \u00acisInt | no \u00acisFloat | yes isChar rewrite eq = fromList (v \u2237 [])\nshowArg {c} {t} eq v | no \u00acisInt | no \u00acisFloat | no \u00acisChar rewrite eq = \u22a5-elim v\n\nsprintfList : (ls : List Char) \u2192 List SprintfArg\nsprintfList [] = []\nsprintfList (x \u2237 ls) with x Data.Char.\u225f '%'\nsprintfList (x \u2237 []) | yes x% = sprintfList []\nsprintfList (x \u2237 xt \u2237 ls) | yes x% with xt Data.Char.\u225f '%'\nsprintfList (x \u2237 xt \u2237 ls) | yes x% | yes xt% = (sprintfText (fromList (xt \u2237 []))) \u2237 (sprintfList ls)\nsprintfList (x \u2237 xt \u2237 ls) | yes x% | no \u00acxt% = (sprintfArg {xt} {sprintfArgType xt} refl) \u2237 (sprintfList ls)\nsprintfList (x \u2237 ls) | no \u00acx% = (sprintfText (fromList (x \u2237 []))) \u2237 (sprintfList ls)\n\nsprintfListTypes : List SprintfArg \u2192 List Set\nsprintfListTypes [] = []\nsprintfListTypes (sprintfArg {c} {t} eq \u2237 ls) = t \u2237 sprintfListTypes ls\nsprintfListTypes (sprintfText x \u2237 ls) = sprintfListTypes ls\n\n\nsprintfFromArgList : (ls : List SprintfArg) \u2192 String \u2192 typeListToFunc String (sprintfListTypes ls)\nsprintfFromArgList [] preString = preString\nsprintfFromArgList (sprintfArg {c} {t} eq \u2237 ls) preString arg0 = \n    sprintfFromArgList ls ((preString Data.String.++ (showArg {c} {t} eq arg0)))\nsprintfFromArgList (sprintfText x \u2237 ls) preString = sprintfFromArgList ls (preString Data.String.++ x)\n\nsprintf : (fs : String) \u2192 typeListToFunc String (sprintfListTypes (sprintfList (toList fs)))\nsprintf fs = sprintfFromArgList (sprintfList (toList fs)) \"\"\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":385,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char\nopen import Data.Integer\nopen import Data.Float\nopen import Data.String\nopen import Data.List hiding ( _++_ )\n\ndata Format : Set where\n  addEnd : Format\n  addString : String \u2192 Format \u2192 Format\n  add\u2124 : Format \u2192 Format\n  addFloat : Format \u2192 Format\n  addChar : Format \u2192 Format\n\nformat\u2192Type : Format \u2192 Set\nformat\u2192Type addEnd = String\nformat\u2192Type (addString s f) = format\u2192Type f\nformat\u2192Type (add\u2124 f) = \u2124 \u2192 format\u2192Type f\nformat\u2192Type (addFloat f) = Float \u2192 format\u2192Type f\nformat\u2192Type (addChar f) = Char \u2192 format\u2192Type f\n\nsprintfType : List Char -> Format\nsprintfType [] = addEnd\nsprintfType ('%' \u2237 '%' \u2237 s) = addString \"%\" (sprintfType s)\nsprintfType ('%' \u2237 'd' \u2237 s) = add\u2124 (sprintfType s)\nsprintfType ('%' \u2237 'f' \u2237 s) = addFloat (sprintfType s)\nsprintfType ('%' \u2237 'c' \u2237 s) = addChar (sprintfType s)\nsprintfType (c \u2237 s) = addString (fromList (c \u2237 [])) (sprintfType s) \n\nsprintf' : (f : Format) \u2192 String \u2192 format\u2192Type f\nsprintf' addEnd acc = acc\nsprintf' (addString x f) acc = sprintf' f (acc ++ x)\nsprintf' (add\u2124 f) acc = \u03bb x \u2192 sprintf' f (acc ++ Data.Integer.show x)\nsprintf' (addFloat f) acc = \u03bb x \u2192 sprintf' f (acc ++ Data.Float.show x)\nsprintf' (addChar f) acc = \u03bb x \u2192 sprintf' f (acc ++ fromList (x \u2237 []))\n\nsprintf : (s : String) \u2192 format\u2192Type (sprintfType (toList s))\nsprintf s = sprintf' (sprintfType (toList s)) \"\"\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":386,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char hiding (show)\nopen import Data.Integer renaming (show to iShow)\nopen import Data.Float renaming (show to fShow)\nopen import Data.String renaming ({-fromChar to cShow ; -}_++_ to _+++_)\nopen import Data.List\nopen import Relation.Binary.PropositionalEquality\n\ncShow : Char \u2192 String\ncShow c = fromList (c \u2237 [])\n\nrecord FmtPair : Set\u2081 where\n  constructor fmtpair\n  field\n    arrowsType : Set\u2080\n    arrows : arrowsType\nopen FmtPair\n\nfmt : String \u2192 List Char \u2192 FmtPair\nfmt be [] = fmtpair String be\nfmt be ('%' \u2237 '%' \u2237 xs) = fmt (be +++ cShow '%') xs\nfmt be ('%' \u2237 'c' \u2237 xs) = fmtpair AT AR\n  where\n    AT = (c : Char) \u2192 arrowsType (fmt (be +++ cShow c) xs)\n    AR = \u03bb (c : Char) \u2192 arrows (fmt (be +++ cShow c) xs)\nfmt be ('%' \u2237 'f' \u2237 xs) = fmtpair AT AR\n  where\n    AT = (c : Float) \u2192 arrowsType (fmt (be +++ fShow c) xs)\n    AR = \u03bb (c : Float) \u2192 arrows (fmt (be +++ fShow c) xs)\nfmt be ('%' \u2237 'd' \u2237 xs) = fmtpair AT AR\n  where\n    AT = (c : \u2124) \u2192 arrowsType (fmt (be +++ iShow c) xs)\n    AR = \u03bb (c : \u2124) \u2192 arrows (fmt (be +++ iShow c) xs)\nfmt be (x \u2237 xs) = fmt (be +++ cShow x) xs\n\nsprintf : (format : String) -> arrowsType (fmt \"\" (toList format))\nsprintf format = arrows (fmt \"\" (toList format))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":387,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char as Char\nopen import Data.Integer as Int\nopen import Data.Float as Float\nopen import Data.String as Str\n\nopen import Data.List\nopen import Function\n\ndata Token : Set where\n  char : Char \u2192 Token\n  d f c : Token\n\ntokenise : List Char \u2192 List Token\ntokenise [] = []\ntokenise ('%' \u2237 'd' \u2237 xs) = d \u2237 tokenise xs\ntokenise ('%' \u2237 'f' \u2237 xs) = f \u2237 tokenise xs\ntokenise ('%' \u2237 'c' \u2237 xs) = c \u2237 tokenise xs\ntokenise ('%' \u2237 '%' \u2237 xs) = char '%' \u2237 tokenise xs\n{-# CATCHALL #-}\ntokenise (x \u2237 xs) = char x \u2237 tokenise xs\n\nargs : List Token \u2192 List Set\nargs [] = []\nargs (d \u2237 xs) = \u2124 \u2237 args xs\nargs (f \u2237 xs) = Float \u2237 args xs\nargs (c \u2237 xs) = Char \u2237 args xs\nargs (char _ \u2237 xs) = args xs\n\n_\u2192String : List Set \u2192 Set\n[] \u2192String = String\n(X \u2237 Xs) \u2192String = X \u2192 Xs \u2192String\n\nprepend : String \u2192 {xs : List Set} \u2192 xs \u2192String \u2192 xs \u2192String\nprepend s {[]} s' = s Str.++ s'\nprepend s {x \u2237 xs} g z = prepend s (g z)\n\nfromChar' : Char \u2192 String\nfromChar' = fromList \u2218 [_]\n\nlistprintf : (l : List Token) \u2192 (args l) \u2192String\nlistprintf [] = \"\"\nlistprintf (d \u2237 xs) x = prepend (Int.show x) (listprintf xs) \nlistprintf (f \u2237 xs) x = prepend (Float.show x) (listprintf xs)\nlistprintf (c \u2237 xs) x = prepend (fromChar' x) (listprintf xs)\nlistprintf (char x \u2237 xs) = prepend (fromChar' x) (listprintf xs)\n\nsprintf : (s : String) -> args (tokenise $ toList s) \u2192String\nsprintf = listprintf \u2218 tokenise \u2218 toList\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":388,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char\nopen import Data.Integer\nopen import Data.Float\nopen import Data.String\nopen import Data.List\nopen import Function using (_\u2218_)\n\n-- tc : template char\n-- rc : result char\n-- tu : template unit\n-- tv : type value\n-- v : value\n\ndata TypeValue : Set where\n  integer : TypeValue\n  float : TypeValue\n  char : TypeValue\n\nToType : TypeValue \u2192 Set\nToType integer = \u2124\nToType float = Float\nToType char = Char\n\ndata TemplateUnit : Set where\n  char : Char \u2192 TemplateUnit\n  specifier : TypeValue \u2192 TemplateUnit\n\nto-template : List Char \u2192 List TemplateUnit\nto-template [] = []\nto-template ('%' \u2237 '%' \u2237 tcs) = char '%' \u2237 to-template tcs\nto-template ('%' \u2237 'd' \u2237 tcs) = specifier integer \u2237 to-template tcs\nto-template ('%' \u2237 'f' \u2237 tcs) = specifier float \u2237 to-template tcs\nto-template ('%' \u2237 'c' \u2237 tcs) = specifier char \u2237 to-template tcs\nto-template (tc \u2237 tcs) = char tc \u2237 to-template tcs\n\nFormatter : Set \u2192 List TemplateUnit \u2192 Set\nFormatter T [] = T\nFormatter T (char c \u2237 tus) = Formatter T tus\nFormatter T (specifier tv \u2237 tus) = ToType tv \u2192 Formatter T tus\n\nmap-result : {T1 T2 : Set} \u2192 (tus : List TemplateUnit) \u2192 (T1 \u2192 T2) \u2192 Formatter T1 tus \u2192 Formatter T2 tus\nmap-result [] f rcs = f rcs\nmap-result (char c \u2237 tus) f fmt = map-result tus f fmt\nmap-result (specifier _ \u2237 tus) f fmt v = map-result tus f (fmt v)\n\nshow-cs : {tv : TypeValue} \u2192 ToType tv \u2192 List Char\nshow-cs {integer} z = toList (Data.Integer.show z)\nshow-cs {float} f = toList (Data.Float.show f)\nshow-cs {char} c = [ c ]\n\nsprintf-t-cs : (tus : List TemplateUnit) \u2192 Formatter (List Char) tus\nsprintf-t-cs [] = []\nsprintf-t-cs (char c \u2237 tus) = map-result tus (c \u2237_) (sprintf-t-cs tus)\nsprintf-t-cs (specifier tv \u2237 tus) v = map-result tus (show-cs v Data.List.++_) (sprintf-t-cs tus)\n\n\nstring-to-template : String \u2192 List TemplateUnit\nstring-to-template = to-template \u2218 toList\n\nFormatterFromString : String \u2192 Set\nFormatterFromString = Formatter String \u2218 string-to-template\n\nsprintf : (s : String) \u2192 FormatterFromString s\nsprintf s = let tus = string-to-template s\n            in  map-result tus fromList (sprintf-t-cs tus)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":389,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char\nopen import Data.Integer renaming (show to showInt) hiding (suc)\nopen import Data.Float renaming (show to showFloat)\nopen import Data.String\n\nopen import Agda.Builtin.Reflection\nopen import Data.Unit\nopen import Data.Nat\nopen import Data.List hiding (_++_)\n\nvra : {A : Set} \u2192 A \u2192 Arg A\nvra = arg (arg-info visible relevant)\n\nrecord Result : Set where\n  constructor _,_,_\n  field\n    header : Term \u2192 Term\n    content : Term\n    n : \u2115\nopen Result\n\ncharToString : Char \u2192 String\ncharToString c = fromList [ c ]\n\nsprintf-one : (r : Result) (show : Name) \u2192 Result\nsprintf-one r show =\n  record { header = \u03bb t \u2192 lam visible (abs (\"x\" ++ showInt (\u2124.pos (r .n))) (r .header t)); content = def (quote _++_) (vra (def show [ vra (var (r .n) []) ]) \u2237 [ vra (r .content) ]); n = suc (r .n) }\n\nsprintf-impl : List Char \u2192 Result\nsprintf-impl ('%' \u2237 'd' \u2237 fmt) = sprintf-one (sprintf-impl fmt) (quote showInt)\nsprintf-impl ('%' \u2237 'f' \u2237 fmt) = sprintf-one (sprintf-impl fmt) (quote showFloat)\nsprintf-impl ('%' \u2237 'c' \u2237 fmt) = sprintf-one (sprintf-impl fmt) (quote charToString)\nsprintf-impl ('%' \u2237 '%' \u2237 fmt) = let r = sprintf-impl fmt in\n  record r { content = def (quote _++_) (vra (lit (string \"%\")) \u2237 [ vra (r .content) ]) }\nsprintf-impl (c \u2237 fmt) = let r = sprintf-impl fmt in\n  record r { content = def (quote _++_) (vra (def (quote charToString) [ vra (lit (char c)) ]) \u2237 [ vra (r .content) ]) }\nsprintf-impl [] = record { header = \u03bb t \u2192 t; content = lit (string \"\"); n = zero }\n\nsprintf' : String \u2192 Term\nsprintf' fmt = let r = sprintf-impl (toList fmt) in r .header (r .content)\n\nmacro\n  sprintf : String \u2192 Term \u2192 TC \u22a4\n  sprintf fmt goal = unify goal (sprintf' fmt)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":390,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Sprintf where\n\nopen import Data.Char\nopen import Data.Integer renaming (show to showInt) hiding (suc)\nopen import Data.Float renaming (show to showFloat)\nopen import Data.String\n\nopen import Agda.Builtin.Reflection\nopen import Data.Unit\nopen import Data.Nat\nopen import Data.List hiding (_++_)\n\nvra : {A : Set} \u2192 A \u2192 Arg A\nvra = arg (arg-info visible relevant)\n\n\u03bbv : \u2115 \u2192 Term \u2192 Term\n\u03bbv n t = lam visible (abs (\"x\" ++ showInt (\u2124.pos n)) t)\n\nrecord Result : Set where\n  constructor _,_,_\n  field\n    header : Term \u2192 Term\n    content : Term\n    n : \u2115\nopen Result\n\nchar-to-string : Char \u2192 String\nchar-to-string c = fromList [ c ]\n\nsprintf-impl : List Char \u2192 Result\nsprintf-impl ('%' \u2237 '%' \u2237 fmt) = let r = sprintf-impl fmt in\n  record { header = r .header; content = def (quote _++_) (vra (lit (string \"%\")) \u2237 [ vra (r .content) ]); n = r .n }\n\nsprintf-impl ('%' \u2237 'd' \u2237 fmt) = let r = sprintf-impl fmt in\n  record { header = \u03bb t \u2192 \u03bbv (r .n) (r .header t); content = def (quote _++_) (vra (def (quote showInt) [ vra (var (r .n) []) ]) \u2237 [ vra (r .content) ]); n = suc (r .n) }\n\nsprintf-impl ('%' \u2237 'f' \u2237 fmt) = let r = sprintf-impl fmt in\n  record { header = \u03bb t \u2192 \u03bbv (r .n) (r .header t); content = def (quote _++_) (vra (def (quote showFloat) [ vra (var (r .n) []) ]) \u2237 [ vra (r .content) ]); n = suc (r .n) }\n\nsprintf-impl ('%' \u2237 'c' \u2237 fmt) = let r = sprintf-impl fmt in\n  record { header = \u03bb t \u2192 \u03bbv (r .n) (r .header t); content = def (quote _++_) (vra (def (quote char-to-string) [ vra (var (r .n) []) ]) \u2237 [ vra (r .content) ]); n = suc (r .n) }\n\nsprintf-impl (c \u2237 fmt) = let r = sprintf-impl fmt in\n  record { header = r .header; content = def (quote _++_) (vra (def (quote char-to-string) [ vra (lit (char c)) ]) \u2237 [ vra (r .content) ]); n = r .n }\n\nsprintf-impl [] = record { header = \u03bb t \u2192 t; content = lit (string \"\"); n = zero }\n\nsprintf' : String \u2192 Term\nsprintf' fmt = let r = sprintf-impl (toList fmt) in r .header (r .content)\n\nmacro\n  sprintf : String \u2192 Term \u2192 TC \u22a4\n  sprintf fmt goal = unify goal (sprintf' fmt)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8607124c6e850009ff5ef7":[{"id":391,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; suc)\nopen import Data.Nat.DivMod\n\nprivate variable k : \u2115\n\nadd : Fin k \u2192 Fin k \u2192 Fin k\nadd {suc k\u2081} n m = (to\u2115 n \u2115.+ to\u2115 m) mod (suc k\u2081)\n\nnegate : Fin k \u2192 Fin k\nnegate {suc k\u2081} n = (k\u2081 \u2115.* to\u2115 n) mod (suc k\u2081)\n\nsubt : Fin k \u2192 Fin k \u2192 Fin k\nsubt n m = add n (negate m)\n\nmult : Fin k \u2192 Fin k \u2192 Fin k\nmult {suc k\u2081} a b = (to\u2115 a \u2115.* to\u2115 b) mod (suc k\u2081)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":392,"user_id":168,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Function\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; zero; suc; z\u2264n; s\u2264s)\n\nprivate variable k : \u2115\n\nfpow : {A : Set} \u2192 \u2115 \u2192 (A \u2192 A) \u2192 A \u2192 A\nfpow zero f = id\nfpow (suc n) f = fpow n f \u2218 f \n\nlast : Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\nsub1 : Fin k \u2192 Fin k\nsub1 zero = last\nsub1 (suc n) = inject\u2081 n\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = fpow (to\u2115 m) sub1 n\n\nnegate : Fin k -> Fin k\nnegate {k = suc _} n = subt zero n\n\nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmult : Fin k -> Fin k -> Fin k\nmult {k = suc _} n m = fpow (to\u2115 n) (add m) zero\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":393,"user_id":60,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; zero; suc; z\u2264n; s\u2264s)\n\nprivate variable k : \u2115\n\nlast : Fin (suc k)\nlast {k = zero}  = zero\nlast {k = suc _} = suc last\n\nopposite : Fin k -> Fin k\nopposite zero    = last\nopposite (suc n) = inject\u2081 (opposite n)\n\nsucc : Fin (suc k) -> Fin (suc k)\nsucc {k = zero} zero     = zero\nsucc {k = suc _} zero    = suc zero\nsucc {k = suc _} (suc n) with succ n\n...| zero = zero\n...| m    = suc m\n\nfrom\u2115\u2032 : \u2115 -> Fin (suc k)\nfrom\u2115\u2032 zero    = zero\nfrom\u2115\u2032 (suc n) = succ (from\u2115\u2032 n)\n\nadd : Fin k -> Fin k -> Fin k\nadd {k = suc _}  n m = from\u2115\u2032 (to\u2115 n \u2115.+ to\u2115 m)\n\nnegate : Fin k -> Fin k\nnegate zero    = zero\nnegate (suc n) = suc (opposite n)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = add n (negate m)\n\nmult : Fin k -> Fin k -> Fin k\nmult {k = suc _} n m = from\u2115\u2032(to\u2115 n \u2115.* to\u2115 m)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":394,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; zero; suc; z\u2264n; s\u2264s)\n\nprivate variable k : \u2115\n\nlast : Fin (suc k)\nlast {k = zero}  = zero\nlast {k = suc _} = suc last\n\n\nsubt'' : \u2200 {k'} \u2192 Fin k \u2192 Fin k' \u2192 Fin k\nsubt'' n       zero    = n\nsubt'' zero    (suc m) = subt'' last m\nsubt'' (suc n) (suc m) = subt'' (inject\u2081 n) m\n\nnegate : Fin k -> Fin k\nnegate {k = suc k} n = subt'' zero n\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = subt'' n m\n\nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmult : \u2200 {k'} \u2192 Fin k -> Fin k' -> Fin k\nmult {k = suc k} n zero    = zero\nmult {k = suc k} n (suc m) = add (mult n m) n \n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":395,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; zero; suc; z\u2264n; s\u2264s)\n\nopen import Data.Nat.Properties as \u2115-props\n\nprivate variable k : \u2115\n\nlast : Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\nnegate : Fin k -> Fin k\nnegate zero = zero\nnegate (suc zero) = last\nnegate (suc n) = inject\u2264 (negate n) (n\u22641+n _)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt zero m = negate m\nsubt (suc n) zero = suc n\nsubt (suc n) (suc m) with compare n m\n... | less _ _ = raise 1 (subt n m)\n... | _ = inject\u2264 (subt n m) (n\u22641+n _)\n\nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmult-helper : {k j : \u2115} \u2192 (p : j \u2115.\u2264 k) \u2192 Fin j -> Fin k -> Fin k\nmult-helper (s\u2264s p) zero n = zero\nmult-helper (s\u2264s p) (suc m) n = add n (mult-helper (\u2115-props.\u2264-step p) m n)\n\nmult : {k : \u2115} \u2192 Fin k -> Fin k -> Fin k\nmult {k} m n = mult-helper \u2115-props.\u2264-refl m n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":396,"user_id":10,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin hiding (_+_; _*_)\nopen import Data.Nat as \u2115 using (\u2115; zero; suc; z\u2264n; s\u2264s; _+_; _*_)\nopen import Data.Nat.DivMod\n\nprivate variable k : \u2115\n\nlast : Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\nadd : Fin k -> Fin k -> Fin k\n-- {suc k} to prevent Relation.Nullary.Decidable.Core.False (k \u2115.\u225f 0)\nadd {suc k} n m = (to\u2115 n + to\u2115 m) mod (suc k)\n\nnegate : Fin k -> Fin k\nnegate zero = zero\nnegate (suc zero) = last\nnegate (suc n) = inject\u2081 (negate n)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = add n (negate m)\n\nmult : Fin k -> Fin k -> Fin k\nmult {suc k} n m = (to\u2115 n * to\u2115 m) mod (suc k)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":397,"user_id":10,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin\nopen import Data.Nat as \u2115 using (\u2115; zero; suc; z\u2264n; s\u2264s)\nopen import Data.Nat.DivMod\n\nprivate variable k : \u2115\n\nlast : Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\nadd : Fin k -> Fin k -> Fin k\n-- {suc k} to prevent Relation.Nullary.Decidable.Core.False (k \u2115.\u225f 0)\nadd {suc k} n m = (to\u2115 n \u2115.+ to\u2115 m) mod (suc k)\n\nnegate : Fin k -> Fin k\nnegate zero = zero\nnegate (suc zero) = last\nnegate (suc n) = inject\u2081 (negate n)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = add n (negate m)\n\nmult : Fin k -> Fin k -> Fin k\nmult {suc k} n m = (to\u2115 n \u2115.* to\u2115 m) mod (suc k)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":398,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Function\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; zero; suc; z\u2264n; s\u2264s)\n\nprivate variable k : \u2115\n\n\nlast : Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\nsubt'' : Fin k -> \u2115 -> Fin k\nsubt'' zero zero = zero\nsubt'' {k = suc zero} zero (suc m) = zero\nsubt'' {k = suc (suc k')} zero (suc m) = suc (subt'' last m)\nsubt'' (suc n) zero = suc n\nsubt'' {k = suc (suc k')} (suc n) (suc m) = (subt'' (inject\u2081 n) m)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = subt'' n (to\u2115 m)\n\nnegate : Fin k -> Fin k\nnegate zero = zero\nnegate {k = suc (suc k')} (suc n) = suc  (subt last n)\n\nadd : Fin k -> Fin k -> Fin k\nadd n m = subt n (negate m)\n\nmult'' : \u2115 -> Fin k -> Fin k\nmult'' {k = zero} n ()\nmult'' {k = suc k'} zero m = zero\nmult'' (suc n) m = add m (mult'' n m)\n\nmult : Fin k -> Fin k -> Fin k\nmult n m = mult'' (to\u2115 n) m\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":399,"user_id":29,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Data.Fin\nopen import Data.Nat as \u2115\n  using (\u2115; zero; suc; z\u2264n; s\u2264s)\n\nprivate variable k : \u2115\n\nlast : Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\npredfin : Fin k \u2192 Fin k\npredfin zero = last\npredfin (suc i) = inject\u2081 i\n\ntoNat : Fin k \u2192 \u2115\ntoNat zero = zero\ntoNat (suc n) = suc (toNat n)\n\nsubNat : Fin k \u2192 \u2115 \u2192 Fin k\nsubNat n zero = n\nsubNat n (suc m) = predfin (subNat n m)\n\nsubt : Fin k -> Fin k -> Fin k\nsubt n m = subNat n (toNat m)\n\nnegate : Fin k -> Fin k\nnegate zero = zero\nnegate (suc n) = subt last (inject\u2081 n)\n\nadd : Fin k \u2192 Fin k \u2192 Fin k\nadd n m = subt n (negate m)\n\nmulNat : Fin k \u2192 \u2115 \u2192 Fin k\nmulNat n zero = n -- Why doesnt it work with zero?\nmulNat n (suc zero) = n\nmulNat n (suc m) = add n (mulNat n m)\n\nmult : Fin k -> Fin k -> Fin k\nmult n zero = zero\nmult n (suc m) = mulNat n (toNat (suc m))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":400,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Mod where\n\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat renaming (_<_ to _<\u2115_ ; _\u2264_ to _\u2264\u2115_ ; _+_ to _+\u2115_ ; _\u225f_ to _\u225f\u2115_ )\nopen import Data.Nat.Properties renaming (\u2264-refl to \u2264-refl\u2115 ; \u2264-reflexive to \u2264-reflexive\u2115 ; _\u225f_ to _\u225f\u2115_ ; \u2264-trans to \u2264-trans\u2115 ; <-trans to <-trans\u2115 )\nopen import Induction.WellFounded\nopen import Relation.Nullary\nimport Relation.Binary.Construct.On as On\nopen import Data.Fin\nopen import Data.Fin.Properties \nopen import Relation.Nullary.Negation \n\nn\u226e0 : \u2200 {n} \u2192 n \u226e 0\nn\u226e0 ()\n\nm\u2238n\u2264m : \u2200 m n \u2192 m \u2238 n \u2264\u2115 m\nm\u2238n\u2264m n       zero    = \u2264-refl\u2115\nm\u2238n\u2264m zero    (suc n) = \u2264-refl\u2115\nm\u2238n\u2264m (suc m) (suc n) = \u2264-trans\u2115 (m\u2238n\u2264m m n) (n\u22641+n m)\n\n<-WellFounded\u2115 : (a : \u2115) \u2192 Acc _<\u2115_  a\n<-WellFounded\u2115 a = acc (helper a)\n    where   helper : (x y : \u2115) \u2192 y <\u2115 x \u2192 Acc _<\u2115_ y\n            helper (suc x) .0 (s\u2264s z\u2264n) = acc (\u03bb z z<0 \u2192 contradiction z<0 n\u226e0)\n            helper (suc (suc x)) (suc y) (s\u2264s (s\u2264s y<x)) = \n                acc (\u03bb z z<sy \u2192 helper (suc x) z (\u2264-trans\u2115 z<sy (s\u2264s y<x)))\n\nto\u2115-cancel-< : {n : \u2115} \u2192 {x y : Fin n} \u2192 to\u2115 x <\u2115 to\u2115 y \u2192 x < y\nto\u2115-cancel-< {n} {x} {y} x<\u2115y = x<\u2115y\n\nto\u2115-cancel-\u2264 : {n : \u2115} \u2192 {x y : Fin n} \u2192 to\u2115 x \u2264\u2115 to\u2115 y \u2192 x \u2264 y\nto\u2115-cancel-\u2264 {n} {x} {y} x\u2264\u2115y = x\u2264\u2115y\n\n\n<-\u2264-trans\u2115 : {x y z : \u2115} \u2192 x <\u2115 y \u2192 y \u2264\u2115 z \u2192 x <\u2115 z\n<-\u2264-trans\u2115 {x} {y} {z} x<\u2115y y\u2264\u2115z = \u2264-trans\u2115 x<\u2115y y\u2264\u2115z\n\n\n<-\u2264-trans : {n : \u2115} \u2192 {x y z : Fin n} \u2192 x < y \u2192 y \u2264 z \u2192 x < z\n<-\u2264-trans {n} {x} {y} {z} x<y y\u2264z = <-\u2264-trans\u2115 x<y y\u2264z\n\nto\u2115\u2264\u2115to\u2115-inject : {n : \u2115} \u2192 {x : Fin (suc n)} \u2192 {y : Fin n} \u2192 to\u2115 x \u2264\u2115 to\u2115 y \u2192 to\u2115 x \u2264\u2115 to\u2115 (inject\u2081 y)\nto\u2115\u2264\u2115to\u2115-inject {n} {x} {y} x\u2264\u2115y rewrite to\u2115-inject\u2081 y = x\u2264\u2115y\n\n<-WellFounded : {n : \u2115} \u2192 (a : Fin n) \u2192 Acc _<_ a\n<-WellFounded {n} a = acc (helper a)\n    where   \n            helper : {m n : \u2115} \u2192  (x : Fin m) \u2192 (y : Fin n) \u2192 to\u2115 y <\u2115 to\u2115 x \u2192 Acc _<_ y\n            helper x zero y<x = acc (\u03bb z z<0 \u2192 contradiction z<0 n\u226e0)\n            helper {suc m} {suc n} (suc x) (suc y) (s\u2264s y<x) = acc (\u03bb z z<sy \u2192 helper x z (<-\u2264-trans\u2115 z<sy y<x))\n\nlast : {k : \u2115} \u2192 Fin (suc k)\nlast {k = zero} = zero\nlast {k = suc _} = suc last\n\n\u2264\u0304\u21d2inject\u2081< : {n : \u2115} \u2192 {i j : Fin n} \u2192 i \u2264 j \u2192 inject\u2081 i < suc j\n\u2264\u0304\u21d2inject\u2081< {i = i} i\u2264j rewrite sym (to\u2115-inject\u2081 i) = s\u2264s  i\u2264j\n\naddHelper : {k : \u2115} \u2192 (a b : Fin k) -> Acc _<_ a -> Fin k\naddHelper {suc k} zero b (acc rs) = b\naddHelper {suc k} (suc a) b (acc rs) with suc k \u225f\u2115 suc (to\u2115 (addHelper {suc k} (inject\u2081 a) b ((rs (inject\u2081 a) (\u2264\u0304\u21d2inject\u2081< (\u2264-reflexive refl))))))\naddHelper {suc k} (suc a) b (acc rs) | yes lastNumber = zero\naddHelper {suc k} (suc a) b (acc rs) | no \u00aclastNumber = \n    lower\u2081 (suc (addHelper {suc k} (inject\u2081 a) b ((rs (inject\u2081 a) (\u2264\u0304\u21d2inject\u2081< (\u2264-reflexive refl)))))) \u00aclastNumber\n\nadd : {k : \u2115} \u2192 Fin k -> Fin k -> Fin k\nadd {k} a b = addHelper {k} a b (<-WellFounded a)\n\nnegate : {k : \u2115} \u2192 Fin k -> Fin k\nnegate {suc k} zero = zero\nnegate {suc k} (suc n) = from\u2115\u2264 {(suc k \u2238 (suc (to\u2115 n)))} {suc k} (s\u2264s (m\u2238n\u2264m k (to\u2115 n)))\n\nsubt : {k : \u2115} \u2192 Fin k -> Fin k -> Fin k\nsubt n m = add n (negate m)\n\nmultHelper : {k : \u2115} \u2192 (a b : Fin k) \u2192 Acc _<_ a \u2192 Fin k\nmultHelper {(suc k)} zero b (acc rs) = zero\nmultHelper {(suc k)} (suc a) b (acc rs) = \n    add b (multHelper (inject\u2081 a) b (rs (inject\u2081 a) (\u2264\u0304\u21d2inject\u2081< (\u2264-reflexive refl))))\n\nmult : {k : \u2115} \u2192 Fin k -> Fin k -> Fin k\nmult {k} n m = multHelper {k} n m (<-WellFounded (n))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c878cc8a2fc6d10eff4b691":[{"id":401,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Primitives public\nopen import Cubical.Data.Nat using (zero; suc)\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero (pos zero) i j = posneg (i \u2227 ~ j)\n+-i-zero (pos (suc n)) i j = suc\u2124 (+-i-zero (pos n) i j)\n+-i-zero (neg zero) i j = posneg (i \u2228 j)\n+-i-zero (neg (suc n)) i j = pred\u2124 (+-i-zero (neg n) i j)\n+-i-zero (posneg j) i k = posneg ((i \u2227 ~ k) \u2228 (i \u2227 j) \u2228 (j \u2227 k))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":402,"user_id":1084,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything public\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\nopen import Agda.Builtin.Nat using (zero; suc)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero (pos zero) i j = posneg (i \u2227 ~ j)\n+-i-zero (pos (suc n)) i j = suc\u2124 (+-i-zero (pos n) i j)\n+-i-zero (neg zero) i j = posneg (i \u2228 j)\n+-i-zero (neg (suc n)) i j = pred\u2124 (+-i-zero (neg n) i j)\n+-i-zero (posneg p) i j =\n  hcomp (\\k \u2192 (\u03bb {\n    (p = i0) \u2192 posneg ((i \u2227 ~ j) \u2227 k);\n    (p = i1) \u2192 posneg ((i \u2228 j) \u2227 k);\n    (j = i0) \u2192 posneg (i \u2227 k);\n    (j = i1) \u2192 posneg (p \u2227 k)}))\n  (pos 0)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":403,"user_id":29,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything \nopen import Cubical.Foundations.Prelude\nopen import Cubical.Data.Nat hiding (_+_)\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero (pos zero) i = \u03bb j \u2192 posneg (~ j \u2227 i)\n+-i-zero (pos (suc n)) i = cong suc\u2124 (+-i-zero (pos n) i)\n+-i-zero (neg zero) i = \u03bb j \u2192 posneg ((~ j \u2227 i) \u2228 j)\n+-i-zero (neg (suc n)) i = cong pred\u2124 (+-i-zero (neg n) i)\n+-i-zero (posneg j) i = \u03bb k \u2192 posneg ((~ k \u2227 i) \u2228 (k \u2227 j))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":404,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything public\nopen import Cubical.Data.Nat hiding (_+_)\nopen import Cubical.Foundations.Prelude using (cong)\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero (pos zero)    i = \u03bb j \u2192 posneg (i \u2227 ~ j)\n+-i-zero (pos (suc n)) i = cong suc\u2124 (+-i-zero (pos n) i)\n+-i-zero (neg zero)    i = \u03bb j \u2192 posneg (i \u2228 j)\n+-i-zero (neg (suc n)) i = cong pred\u2124 (+-i-zero (neg n) i)\n+-i-zero (posneg k)    i = \u03bb j \u2192 posneg ((i \u2227 ~ j) \u2228 (k \u2227 (i \u2228 j)))\n\n{- The 2-dimensional cube for +-i-zero (posneg k) i\n                               \u03bb k \u2192 posneg k\n                    pos zero -----------------> neg zero\n                       ^                           ^\n                       |                           |\n\u03bb j \u2192 posneg (i \u2227 ~ j) |                           |  \u03bb j \u2192 posneg (i \u2228 j)\n                       |                           |\n                    posneg i -----------------> posneg i\n                              \u03bb k \u2192 posneg i\n-}","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":405,"user_id":490,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat\n  renaming ( +-comm to :+:-comm\n           ; +-zero to :+:-zero\n           ; _+_ to _:+:_\n           )\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\n\n+-zero : \u2200 a \u2192 pos 0 + a \u2261 a\n+-zero (pos zero) = refl\n+-zero (pos (suc n)) = cong suc\u2124 (+-zero (pos n))\n+-zero (neg zero) = posneg\n+-zero (neg (suc n)) = cong pred\u2124 (+-zero (neg n))\n+-zero (posneg i) j = posneg (i \u2227 j)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero a i = cong (_+ a) (\u03bb j \u2192 posneg (i \u2227 ~ j)) \u2219 +-zero a\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":406,"user_id":60,"body":"{-# OPTIONS --cubical --safe #-}\n\nmodule SymInt where\n\nopen import Agda.Builtin.Nat using (zero; suc)\nopen import Cubical.Core.Everything\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\n\ncong : {A B : Set}{a b : A} -> (f : A -> B) -> a \u2261 b -> f a \u2261 f b\ncong f p i = f (p i)\n\nlemma : \u2200 i j -> posneg i \u2261 posneg j\nlemma i j k = hcomp (\\ l -> \\ { (k = i0) -> posneg (i \u2227 l)\n                              ; (k = i1) -> posneg (j \u2227 l) }) (pos zero)\n\n+-i-zero : \u2200 a i -> posneg i + a \u2261 a\n+-i-zero (pos (suc n)) i = cong suc\u2124 (+-i-zero (pos n) i)\n+-i-zero (neg (suc n)) i = cong pred\u2124 (+-i-zero (neg n) i)\n+-i-zero (pos zero) i    = lemma i i0\n+-i-zero (neg zero) i    = lemma i i1\n+-i-zero (posneg j) i    = lemma i j","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":407,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\nopen import Cubical.Foundations.Prelude\nopen import Cubical.Data.Nat using (\u2115; zero; suc)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero (pos zero)    i = \u03bb j \u2192 posneg (i \u2227 ~ j)\n+-i-zero (pos (suc n)) i = cong suc\u2124 (+-i-zero (pos n) i)\n+-i-zero (neg zero)    i = \u03bb j \u2192 posneg (i \u2228 j)\n+-i-zero (neg (suc n)) i = cong pred\u2124 (+-i-zero (neg n) i)\n+-i-zero (posneg l)    k = \u03bb j \u2192 posneg (((k \u2227 ~ j) \u2228 l) \u2227 (k \u2228 j))\n \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":408,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Nat using (zero ; suc)\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+_; \u2124 to Z)\n\n+-i-zero : \u2200 a i \u2192 posneg i + a \u2261 a\n+-i-zero (pos zero) i j = posneg (i \u2227 ~ j)\n+-i-zero (pos (suc n)) i j = suc\u2124 (+-i-zero (pos n) i j)\n+-i-zero (neg zero) i j = posneg (i \u2228 j)\n+-i-zero (neg (suc n)) i j = pred\u2124 (+-i-zero (neg n) i j)\n+-i-zero (posneg k) i j = posneg ((i \u2227 ~ j) \u2228 (i \u2227 k) \u2228 (j \u2227 k))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":409,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\nopen import Cubical.Data.Nat\nopen import Cubical.Foundations.Prelude\nopen import Cubical.Core.Everything\nopen import Cubical.HITs.HitInt renaming (_+\u2124_ to _+Z_; \u2124 to Z)\n\n\n+-i-zero : \u2200 a i \u2192 posneg i +Z a \u2261 a\n+-i-zero (pos zero) i j = posneg (~ j \u2227 j \u2228 i)\n+-i-zero (pos (suc n)) i j = cong suc\u2124 (+-i-zero (pos n) i) j\n+-i-zero (neg zero) i j = posneg (j \u2228 i)\n+-i-zero (neg (suc n)) i j = cong pred\u2124 (+-i-zero (neg n) i) j\n+-i-zero (posneg i) j k = posneg ((~ k \u2228 i) \u2227 (k \u2228 j))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":410,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule SymInt where\n\nopen import Cubical.Core.Everything\nopen import Cubical.HITs.HitInt \nopen import Cubical.Core.Primitives public\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Nat\n\n\n{-\nj1 pos 0 ------------- pos 0\n    |                    |\n    |                    |\n    |                    |\nj0 pos 0 ------------- neg 0\n   i0                  i1\n-}\n\nposneg\u2261pzero : (i : I) \u2192 posneg i \u2261 pos zero\nposneg\u2261pzero i j = posneg (i \u2227 (~ j))\n\n{-\nj1 neg 0 ------------- neg 0\n    |                    |\n    |                    |\n    |                    |\nj0 pos 0 ------------- neg 0\n   i0                  i1\n-}\nposneg\u2261nzero : (i : I) \u2192 posneg i \u2261 neg zero\nposneg\u2261nzero i j = posneg (i \u2228 j)\n\n\n+-i-zero : \u2200 a i \u2192 posneg i +\u2124 a \u2261 a\n+-i-zero (pos 0) i = posneg\u2261pzero i\n+-i-zero (pos (suc n)) i = cong suc\u2124 (+-i-zero (pos n) i)\n+-i-zero (neg 0) i = posneg\u2261nzero i\n+-i-zero (neg (suc n)) i = cong pred\u2124  (+-i-zero (neg n) i)\n+-i-zero (posneg j) i k = posneg ((i \u2227 j) \u2228 (j \u2227 k) \u2228 (i \u2227 ~ k))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8bd0997f1f6c5a24f48371":[{"id":411,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\n\nvariable A : Set\n\nfrom-maybe : (a : A) \u2192 maybe A \u2192 A\nfrom-maybe a (just b) = b\nfrom-maybe a nothing = a\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective a b p i = from-maybe a (p i)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":412,"user_id":1084,"body":"{-# OPTIONS --cubical --safe --without-K #-}\nmodule JustBeInjective where\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\nopen import Cubical.Data.Empty\nopen import Maybe\n\njust-neq-nothing : \u2200 {A : Set} {a : A} \u2192 just a == nothing \u2192 \u22a5\njust-neq-nothing {A = A} {a = a} x = transport (cong f x) a\n  where\n    f : maybe A \u2192 Set\n    f (just x) = A\n    f nothing = \u22a5\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective {A = A} a b p i = f (p i) (\\j \u2192 (p (i \u2227 j)))\n  where\n    f : (ma : maybe A) \u2192 just a == ma \u2192 A\n    f (just x) _ = x\n    f nothing p = \u22a5-elim (just-neq-nothing p)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":413,"user_id":60,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Foundations.Prelude\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\n\nunwrap : {A : Set} \u2192 A \u2192 maybe A \u2192 Set\nunwrap a (just b) = a == b\nunwrap _ nothing  = Unit\n\njust-injective : {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective a b p = subst (unwrap a) p refl","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":414,"user_id":106,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\nopen import Cubical.Foundations.Everything\n\nvariable A : Set\n\n-- the answer is literally inside Cubical.Data.Maybe.Properties source code omegaLUL\n\nfromJust-def : A \u2192 maybe A \u2192 A\nfromJust-def a nothing = a\nfromJust-def _ (just a) = a\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective a b eq = cong (fromJust-def a) eq","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":415,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\n\nunwrap-or : {A : Set} \u2192 A \u2192 (a : maybe A) \u2192 A\nunwrap-or _ (just a) = a\nunwrap-or a nothing  = a\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective a b p = \u03bb i \u2192 unwrap-or a (p i)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":416,"user_id":29,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Prelude\n\nvariable A : Set\n\nunwrap : A \u2192 maybe A \u2192 A\nunwrap _ (just x) = x\nunwrap x _ = x\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a \u2261 just b \u2192 a \u2261 b\njust-injective a b p = cong (unwrap a) p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":417,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Foundations.Prelude\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\n\n{- What you've just imported:\n\n{-# OPTIONS --safe --without-K #-}\nmodule Maybe where\n\ndata maybe (A : Set) : Set where\n  just : A -> maybe A\n  nothing : maybe A\n-}\n\nvariable A : Set\n\n-- Maybe helpful\nmaybeDefault : {A : Set} \u2192 A \u2192 maybe A \u2192 A\nmaybeDefault {A} a (just x) = x\nmaybeDefault {A} a nothing = a\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective a b p = cong (maybeDefault a) p \n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":418,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\nopen import Cubical.Foundations.Prelude using (refl; subst)\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective {A} a b p = subst (\u03bb { (just x) \u2192 a == x ; nothing \u2192 Unit} ) p refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":419,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\n\nopen import Cubical.Core.Everything renaming (_\u2261_ to _==_)\nopen import Cubical.Data.Unit\n\n{- What you've just imported:\n\n{-# OPTIONS --safe --without-K #-}\nmodule Maybe where\n\ndata maybe (A : Set) : Set where\n  just : A -> maybe A\n  nothing : maybe A\n-}\n\nvariable A : Set\n\n-- Maybe helpful\nUnwrap : (a : maybe A) \u2192 Set\nUnwrap {A = A} (just x) = A\nUnwrap nothing = Unit\n\nunwrap : (u : A) (a : maybe A) \u2192 A\nunwrap u (just x) = x\nunwrap u nothing = u\n\ntransport : \u2200 {\u2113} {A B : Set \u2113} \u2192 A == B \u2192 A \u2192 B\ntransport p a = transp (\u03bb i \u2192 p i) i0 a\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a == just b \u2192 a == b\njust-injective a b p i = unwrap a (p i)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":420,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule JustBeInjective where\n\nopen import Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Empty\n\nprivate\n  variable A : Set\n\ncode : \u2200 (a : A) \u2192 (x : maybe A) \u2192 Set\ncode a (just x) = a \u2261 x\ncode a nothing = \u22a5\n\nencode : \u2200 (a : A) x \u2192 just a \u2261 x \u2192 code a x\nencode a x p = subst (code a) p refl \n\njust-injective : \u2200 (x y : A) \u2192 just x \u2261 just y \u2192 x \u2261 y\njust-injective x y p = encode x (just y) p\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8ca6e0eca75e0001511bc6":[{"id":421,"user_id":60,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Data.Everything hiding([_])\nopen import Cubical.Foundations.Everything\n\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nlemma0 : \u2200 {\u2113} {A B : Set \u2113} {a b : A} \u2192 (p : A \u2261 B) \u2192 transport p a \u2261 transport p b \u2192 a \u2261 b\nlemma0 {a = a} {b} p p' = sym (transport\u207bTransport p a) \u2219 cong (transport\u207b p) p' \u2219 transport\u207bTransport p b\n\n--Shamelessly copied from [https:\/\/github.com\/agda\/cubical\/issues\/77#issuecomment-546633758]\nlemma1 : \u2200 {\u2113} {A B : Set \u2113} {p q : A \u2261 B} \u2192 ((a : A) \u2192 transport p a \u2261 transport q a) \u2192 p \u2261 q\nlemma1 {p = p} {q} w i = hcomp (\u03bb j \u2192 \u03bb\n  { (i = i0) \u2192 secEq univalence p j\n  ; (i = i1) \u2192 secEq univalence q j\n  }) (invEq univalence ((\u03bb a \u2192 w a i) , t i))\n  where t : PathP (\u03bb i \u2192 isEquiv (\u03bb a \u2192 w a i)) (pathToEquiv p .snd) (pathToEquiv q .snd)\n        t = isProp\u2192isContrPathP isPropIsEquiv (\u03bb i a \u2192 w a i) _ _ .fst\n\nBool' : Set\u2081\nBool' = Lift Bool\n\nfun : Bool' \u2192 Bool \u2261 Bool\nfun (lift false) = refl\nfun (lift true)  = notEq\n\ninv : Bool \u2261 Bool \u2192 Bool'\ninv p = lift (transport p false)\n\nrec : (b : Bool') \u2192 inv (fun b) \u2261 b\nrec (lift false) = refl\nrec (lift true)  = refl\n\nsec : (p : Bool \u2261 Bool) \u2192 fun (inv p) \u2261 p\nsec p with transport p false | inspect (transport p) false\n         | transport p true  | inspect (transport p) true\n...| false | [ q ] | false | [ r ] = \u22a5-elim (false\u2262true (lemma0 p (q \u2219 sym r)))\n...| false | [ q ] | true  | [ r ] = lemma1 \u03bb { true \u2192 sym r; false \u2192 sym q }\n...| true  | [ q ] | false | [ r ] = lemma1 \u03bb { true \u2192 sym r; false \u2192 sym q }\n...| true  | [ q ] | true  | [ r ] = \u22a5-elim (false\u2262true (lemma0 p (q \u2219 sym r)))\n\nBool\u2261[Bool\u2261Bool] : Bool' \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = isoToPath (iso fun inv sec rec)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":422,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Foundations.Transport\nopen import Cubical.Data.Bool\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Sigma.Properties\nopen import Agda.Primitive using (lzero; lsuc)\n\n-- maybe helpful when case splitting\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\n-- stolen from the newer cubical library\nisoFunInjective : \u2200 {a} {A B : Set a} (f : Iso A B) \u2192 (x y : A) \u2192 Iso.fun f x \u2261 Iso.fun f y \u2192 x \u2261 y\nisoFunInjective f x y h = sym (Iso.leftInv f x) \u2219\u2219 cong (Iso.inv f) h \u2219\u2219 Iso.leftInv f y\n\npathToIso : \u2200 {\u2113} {A B : Type \u2113} \u2192 A \u2261 B \u2192 Iso A B\nIso.fun (pathToIso x) = transport x\nIso.inv (pathToIso x) = transport\u207b x\nIso.rightInv (pathToIso x) = transportTransport\u207b x\nIso.leftInv (pathToIso x) = transport\u207bTransport x\n\nua-au : \u2200 {\u2113} {A B : Type \u2113} (au : \u2200 {\u2113} {A B : Type \u2113} \u2192 A \u2261 B \u2192 A \u2243 B) (aurefl : \u2200 {\u2113} {A : Type \u2113} \u2192 au refl \u2261 idEquiv A) (p : A \u2261 B) \u2192 ua (au p) \u2261 p\nua-au {B = B} au aurefl = J (\u03bb _ p \u2192 ua (au p) \u2261 p) (cong ua aurefl \u2219 uaIdEquiv)\n\nua-pathToEquiv : \u2200 {\u2113} {A B : Type \u2113} (p : A \u2261 B) \u2192 ua (pathToEquiv p) \u2261 p\nua-pathToEquiv = ua-au pathToEquiv pathToEquivRefl\n\n-- end of copy-pasted code\n\n\n-- Lift is necessary for Bool and Bool \u2261 Bool are of different level. :-P\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = isoToPath (iso left right sec ret)\n  where\n    left : Lift {j = lsuc lzero} Bool \u2192 Bool \u2261 Bool\n    left (lift false) = refl\n    left (lift true) = notEq\n\n    right : Bool \u2261 Bool \u2192 Lift {j = lsuc lzero} Bool\n    right p = lift (transport p false)\n      \n    sec : section left right\n    sec p with f false | inspect f false | f true | inspect f true\n      where\n        f = transport p\n    ... | false | [ eq ] | false | [ eq' ] = \u22a5-elim (true\u2262false (isoFunInjective (pathToIso p) true false (eq' \u2219 sym eq)))\n        \n    ... | false | [ eq ] | true  | [ eq' ] = (sym (ua-pathToEquiv refl) \u2219 cong ua h) \u2219 ua-pathToEquiv p\n      where\n        g : \u2200 b \u2192 equivFun (pathToEquiv refl) b \u2261 equivFun (pathToEquiv p) b\n        g false = sym eq\n        g true = sym eq'\n\n        h : pathToEquiv refl \u2261 pathToEquiv p\n        h = \u03a3Prop\u2261 isPropIsEquiv (\u03bb i b \u2192 g b i)\n    ... | true | [ eq ] | false | [ eq' ] = (sym (ua-pathToEquiv notEq) \u2219 cong ua h) \u2219 ua-pathToEquiv p\n      where\n        g : \u2200 b \u2192 equivFun (pathToEquiv notEq) b \u2261 equivFun (pathToEquiv p) b\n        g false = sym eq\n        g true = sym eq'\n\n        h : pathToEquiv notEq \u2261 pathToEquiv p\n        h = \u03a3Prop\u2261 isPropIsEquiv (\u03bb i b \u2192 g b i)\n    ... | true | [ eq ] | true  | [ eq' ] = \u22a5-elim (true\u2262false (isoFunInjective (pathToIso p) true false (eq' \u2219 sym eq)))\n\n    ret : retract left right\n    ret (lift false) = refl\n    ret (lift true) = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":423,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Bool\nopen import Cubical.Data.Sum\nopen import Cubical.Data.Empty as Empty\n\nisoFunInjective : \u2200 {a b} {A : Type a} {B : Type b} (f : Iso A B) \u2192 (x y : A) \u2192 Iso.fun f x \u2261 Iso.fun f y \u2192 x \u2261 y\nisoFunInjective f x y h = sym (Iso.leftInv f x) \u2219\u2219 cong (Iso.inv f) h \u2219\u2219 Iso.leftInv f y\n\nisProp\u2192PathP' : \u2200 {\u2113} {B : I \u2192 Type \u2113} \u2192 ((i : I) \u2192 isProp (B i))\n               \u2192 (b0 : B i0) (b1 : B i1)\n               \u2192 PathP (\u03bb i \u2192 B i) b0 b1\nisProp\u2192PathP' hB b0 b1 = toPathP (hB _ _ _)\n\nisInjectiveTransport : \u2200 {\u2113 : Level} {A B : Type \u2113} {p q : A \u2261 B}\n  \u2192 transport p \u2261 transport q \u2192 p \u2261 q\nisInjectiveTransport {p = p} {q} \u03b1 = sym (secEq univalence p) \u2219 cong (invEq univalence) ueq \u2219 secEq univalence q\n  where\n  t : PathP (\u03bb i \u2192 isEquiv (\u03bb a \u2192 \u03b1 i a)) (pathToEquiv p .snd) (pathToEquiv q .snd)\n  t = isProp\u2192PathP' (\u03bb i \u2192 isPropIsEquiv (\u03b1 i)) _ _\n  \n  ueq : fst univalence p \u2261 fst univalence q\n  ueq = cong\u2082 _,_ \u03b1 t\n  \nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\n\u2261-id : Bool \u2261 Bool\n\u2261-id = refl\n\nnot-involutive : \u2200 x \u2192 not (not x) \u2261 x\nnot-involutive false = refl\nnot-involutive true = refl\n\n\u2243-not : Bool \u2243 Bool\n\u2243-not = (not , isoToIsEquiv (iso not not not-involutive not-involutive))\n\n\u2261-not : Bool \u2261 Bool\n\u2261-not = ua \u2243-not\n\n\u2113-one : Level\n\u2113-one = \u2113-suc \u2113-zero\n\nf : Lift {j = \u2113-one} Bool \u2192 Bool \u2261 Bool\nf (lift false) = \u2261-id\nf (lift true) = \u2261-not\n\ng : Bool \u2261 Bool \u2192 Lift {j = \u2113-one} Bool\ng p = lift (transport p false)\n\n\u2243Bool\u2208[id,not] : \u2200 (e : Bool \u2243 Bool) \u2192 (fst e \u2261 idfun Bool) \u228e (fst e \u2261 not)\n\u2243Bool\u2208[id,not] e with fst e false | fst e true | inspect (fst e) false | inspect (fst e) true\n... | false | false | [ e[false]\u2261false ] | [ e[true]\u2261false ] = \u22a5-elim (false\u2262true (isoFunInjective (equivToIso e) false true (e[false]\u2261false \u2219 sym e[true]\u2261false)))\n... | false | true  | [ e[false]\u2261false ] | [ e[true]\u2261true  ] = inl (funExt \u03bb {false \u2192 e[false]\u2261false; true \u2192 e[true]\u2261true})\n... | true  | false | [ e[false]\u2261true  ] | [ e[true]\u2261false ] = inr (funExt \u03bb {false \u2192 e[false]\u2261true; true \u2192 e[true]\u2261false})\n... | true  | true  | [ e[false]\u2261true  ] | [ e[true]\u2261true  ] = \u22a5-elim (false\u2262true (isoFunInjective (equivToIso e) false true (e[false]\u2261true \u2219 sym e[true]\u2261true)))\n\nsection[f,g] : section f g\nsection[f,g] p with \u2243Bool\u2208[id,not] (transportEquiv p)\n... | inl eq = isInjectiveTransport (subst (\u03bb tp \u2192 transport (f (lift (tp false))) \u2261 tp) (sym eq) (funExt transportRefl))\n... | inr eq = isInjectiveTransport (subst (\u03bb tp \u2192 transport (f (lift (tp false))) \u2261 tp) (sym eq) (funExt (ua\u03b2 \u2243-not)))\n\nretract[f,g] : retract f g\nretract[f,g] (lift false) = refl\nretract[f,g] (lift true) = refl\n\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = ua (f , isoToIsEquiv (iso f g section[f,g] retract[f,g]))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":424,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything hiding (Iso; compIso)\nopen import Cubical.Data.Bool\nopen import Cubical.Data.Empty renaming (\u22a5-elim to rec)\n\nopen Iso\n\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] =\n  isoToPath (compIso e1 (equivToIso (invEquiv univalence))) where\n  \n  fun-e1 : Lift Bool -> (Bool \u2243 Bool)\n  fun-e1 (lift false) = notEquiv\n  fun-e1 (lift true)  = idEquiv Bool\n\n  rightInv-e1 : (e2 : Bool \u2243 Bool) ->\n                (b1 : Bool) -> b1 \u2261 fst e2 false ->\n                (b2 : Bool) -> b2 \u2261 fst e2 true  ->\n                fun-e1 (lift b2) \u2261 e2\n  rightInv-e1 e2 false v false w =\n    rec (true\u2262false (sym (\u03b7 _) \u2219 cong g (sym w \u2219 v) \u2219 \u03b7 _))\n    where open Iso (equivToIso e2) renaming (inv to g; leftInv to \u03b7)\n  rightInv-e1 e2 false v true  w =\n    equivEq _ _ (funExt (\u03bb {false -> v ; true -> w}))\n  rightInv-e1 e2 true  v false w =\n    equivEq _ _ (funExt (\u03bb {false -> v ; true -> w}))\n  rightInv-e1 e2 true  v true  w =\n    rec (true\u2262false (sym (\u03b7 _) \u2219 cong g (sym w \u2219 v) \u2219 \u03b7 _))\n    where open Iso (equivToIso e2) renaming (inv to g; leftInv to \u03b7)\n  \n  e1 : Iso (Lift Bool) (Bool \u2243 Bool)\n  fun e1                   = fun-e1\n  inv e1      e2           = lift (fst e2 true)\n  rightInv e1 e2           = rightInv-e1 e2 _ refl _ refl\n  leftInv e1  (lift false) = refl\n  leftInv e1  (lift true)  = refl\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":425,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything hiding (isProp\u2192PathP)\nopen import Cubical.Foundations.Prelude hiding (isProp\u2192PathP)\n\n-- maybe helpful when case splitting\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nopen import Cubical.Data.Bool\nopen import Cubical.Data.Empty\n\nprivate variable \u2113 : Level\n\nLift1 : (A : Set \u2113) \u2192 Set (\u2113-max \u2113 (\u2113-suc \u2113-zero))\nLift1 = Lift {j = \u2113-suc \u2113-zero}\n\nidIso' : {A : Set \u2113} \u2192 Iso A A\nidIso' {A = A} = iso (idfun A)(idfun A)(\u03bb _ \u2192 refl)(\u03bb _ \u2192 refl)\n\npathToIso' : {A B : Set \u2113} \u2192 A \u2261 B \u2192 Iso A B\npathToIso' {A = A} eq = subst (Iso A) eq idIso'\n\nf : Lift1 Bool \u2192 Bool \u2261 Bool\nf (lift false) = notEq\nf (lift true) = refl\n\nf\u207b\u00b9 : Bool \u2261 Bool \u2192 Lift1 Bool\nf\u207b\u00b9 eq = lift (transport eq true)\n\n-- from latest cubical library as of 11 Feb\nisProp\u2192PathP : \u2200 {B : I \u2192 Type \u2113} \u2192 ((i : I) \u2192 isProp (B i))\n               \u2192 (b0 : B i0) (b1 : B i1)\n               \u2192 PathP (\u03bb i \u2192 B i) b0 b1\nisProp\u2192PathP hB b0 b1 = toPathP (hB _ _ _)\n\nisInjectiveTransport : {A B : Type \u2113} {p q : A \u2261 B}\n  \u2192 transport p \u2261 transport q \u2192 p \u2261 q\nisInjectiveTransport {p = p} {q} \u03b1 i =\n  hcomp\n    (\u03bb j \u2192 \u03bb\n      { (i = i0) \u2192 secEq univalence p j\n      ; (i = i1) \u2192 secEq univalence q j\n      })\n    (invEq univalence ((\u03bb a \u2192 \u03b1 i a) , t i))\n  where\n  t : PathP (\u03bb i \u2192 isEquiv (\u03bb a \u2192 \u03b1 i a)) (pathToEquiv p .snd) (pathToEquiv q .snd)\n  t = isProp\u2192PathP (\u03bb i \u2192 isPropIsEquiv (\u03bb a \u2192 \u03b1 i a)) _ _\n\nisInjectiveTransportEq :\n  \u2200{A B : Set \u2113}{a a' : A}(eq : A \u2261 B)\n  \u2192 --------------------------------------------------\n  transport eq a \u2261 transport eq a' \u2192 a \u2261 a'\nisInjectiveTransportEq {a = a} {a'} eq p =\n  a \u2261\u27e8 transport\u207bTransport eq a \u207b\u00b9 \u27e9\n  transport\u207b eq (transport eq a) \u2261\u27e8 cong (transport\u207b eq) p \u27e9\n  transport\u207b eq (transport eq a') \u2261\u27e8 transport\u207bTransport eq a' \u27e9\n  a' \u220e\n\nf\u2218f\u207b\u00b9 : section f f\u207b\u00b9\nf\u2218f\u207b\u00b9 eq = isInjectiveTransport (funExt aux)\n  where b\u2192b = transport eq\n        b\u2192b\u207b\u00b9 = transport\u207b eq\n        aux : \u2200 b \u2192 transport (f (f\u207b\u00b9 eq)) b \u2261 b\u2192b b\n        aux false with b\u2192b true | inspect b\u2192b true | b\u2192b false | inspect b\u2192b false\n        ... | false | [ t-false\u2261false ] | false | [ t-true\u2261false ] =\n          \u22a5-elim (false\u2262true (isInjectiveTransportEq eq (\n          t-true\u2261false \u2219 t-false\u2261false \u207b\u00b9)))\n        ... | false | _ | true | _ = refl\n        ... | true | [ _ ] | false | [ _ ] = refl\n        ... | true | [ t-false\u2261true ] | true | [ t-true\u2261true ] =\n          \u22a5-elim (false\u2262true (isInjectiveTransportEq eq (\n          t-true\u2261true \u2219 t-false\u2261true \u207b\u00b9)))\n        aux true with b\u2192b true | inspect b\u2192b true | b\u2192b false | inspect b\u2192b false\n        ... | false | [ t-true\u2261false ] | false | [ t-false\u2261false ] =\n          \u22a5-elim (false\u2262true (isInjectiveTransportEq eq (\n          t-false\u2261false \u2219 t-true\u2261false \u207b\u00b9)))\n        ... | false | [ t-true\u2261false ] | true | [ t-false\u2261true ] = refl\n        ... | true | _ | false | _ = refl\n        ... | true | _ | true | _ = refl\n\nf\u207b\u00b9\u2218f : retract f f\u207b\u00b9\nf\u207b\u00b9\u2218f (lift false) = refl\nf\u207b\u00b9\u2218f (lift true) = refl\n\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = isoToPath (iso f f\u207b\u00b9 f\u2218f\u207b\u00b9 f\u207b\u00b9\u2218f)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":426,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything\n\n-- maybe helpful when case splitting\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\n-- two paths between Bool\n{-\nnotnot : \u2200 x \u2192 not (not x) \u2261 x\nnotnot true  = refl\nnotnot false = refl\nnotIsEquiv : isEquiv not\nnotIsEquiv = isoToIsEquiv (iso not not notnot notnot) \nnotEquiv : Bool \u2243 Bool\nnotEquiv = (not , notIsEquiv)\nnotEq : Bool \u2261 Bool\nnotEq = ua notEquiv\nrefl : Bool \u2261 Bool\nrefl = \u03bb _ \u2192 Bool\n-}\n\nltr : Bool -> (Bool \u2261 Bool)\nltr true = refl\nltr false = notEq\n\nrtl : (Bool \u2261 Bool) -> Bool\nrtl eq = transport eq true\n\nltrtl : forall x -> rtl (ltr x) \u2261 x\nltrtl true = refl\nltrtl false = refl\n\nfromtf : forall {P} -> true \u2261 false -> P\nfromtf {P} eq = subst help eq refl\n  where help : Bool -> Set\n        help true = true \u2261 true\n        help false = P\n\nlemma1 : forall x -> transport x false \u2261 not (transport x true)\nlemma1 x with transport x false | transport x true | inspect (transport x) false | inspect (transport x) true\nlemma1 x | false | true | _ | _ = refl\nlemma1 x | true | false | _ | _ = refl\nlemma1 x | false | false | [ prf1 ] | [ prf2 ] =\n  fromtf (subst (\\{y -> y \u2261 false})\n                (subst (\\{y -> transport\u207b x y \u2261 true }) prf2 (transport\u207bTransport x true))\n                (subst (\\{y -> transport\u207b x y \u2261 false}) prf1 (transport\u207bTransport x false)))\nlemma1 x | true | true | [ prf1 ] | [ prf2 ] =\n  fromtf (subst (\\{y -> y \u2261 false})\n                (subst (\\{y -> transport\u207b x y \u2261 true }) prf2 (transport\u207bTransport x true))\n                (subst (\\{y -> transport\u207b x y \u2261 false}) prf1 (transport\u207bTransport x false)))\n\nlemma2 : forall x -> transport (ltr (rtl x)) true \u2261 transport x true\nlemma2 tsn with transport tsn true | inspect (\u03bb { x -> transport x true }) tsn\n... | true  | [ prf ] = refl\n... | false | [ prf ] = refl\n\n-- stolen from the standard library\nisInjectiveTransport : \u2200 {\u2113 : Level} {A B : Type \u2113} {p q : A \u2261 B}\n  \u2192 transport p \u2261 transport q \u2192 p \u2261 q\nisInjectiveTransport {p = p} {q} \u03b1 i =\n  hcomp\n    (\u03bb j \u2192 \u03bb\n      { (i = i0) \u2192 secEq univalence p j\n      ; (i = i1) \u2192 secEq univalence q j\n      })\n    (invEq univalence ((\u03bb a \u2192 \u03b1 i a) , t i))\n  where\n  t : PathP (\u03bb i \u2192 isEquiv (\u03bb a \u2192 \u03b1 i a)) (pathToEquiv p .snd) (pathToEquiv q .snd)\n  t = isProp\u2192isContrPathP isPropIsEquiv (\u03bb i a \u2192 \u03b1 i a) _ _ .fst\n\nrtltr' : forall x y -> transport (ltr (rtl x)) y \u2261 transport x y\nrtltr' tsn true = lemma2 tsn\nrtltr' tsn false =\n  subst (\\{z -> transport (ltr (rtl tsn)) false \u2261 z})\n        (sym (lemma1 tsn))\n        (subst (\\{z -> z \u2261 not (transport tsn true)})\n               (sym (lemma1 (ltr (rtl tsn))))\n               (cong not (lemma2 tsn)))\nrtltr : forall x -> ltr (rtl x) \u2261 x\nrtltr x = isInjectiveTransport (funExt (rtltr' x))\n\nltrIsEquiv : Bool \u2243 (Bool \u2261 Bool)\nltrIsEquiv = (ltr , isoToIsEquiv (iso ltr rtl rtltr ltrtl))\n\nltrIsEquiv' : Lift {i = \u2113-zero} {j = \u2113-suc \u2113-zero} Bool \u2243 (Bool \u2261 Bool)\nltrIsEquiv' = compEquiv (invEquiv LiftEquiv) ltrIsEquiv\n\n-- Lift is necessary for Bool and Bool \u2261 Bool are of different level. :-P\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = ua ltrIsEquiv'","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":427,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Bool\n\n-- maybe helpful when case splitting\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nBool\u2192[Bool\u2243Bool] : Bool \u2192 (Bool \u2243 Bool)\nBool\u2192[Bool\u2243Bool] false = notEquiv\nBool\u2192[Bool\u2243Bool] true = idEquiv Bool\n\n[Bool\u2243Bool]\u2192Bool : (Bool \u2243 Bool) \u2192 Bool\n[Bool\u2243Bool]\u2192Bool e = equivFun e true\n\nisInjective : \u2200 {A B : Set} (f : A \u2192 B) \u2192 Set\nisInjective f = \u2200 {x y} \u2192 f x \u2261 f y \u2192 x \u2261 y\n\nequivIsInj : \u2200 {A B : Set} (e : A \u2243 B) \u2192 isInjective (e .fst)\nequivIsInj e {x = x} {y = y} eq = sym (secEq e x) \u2219 cong (invEq e) eq \u2219 secEq e y\n\nlemma\u2081 : \u2200 (f : Bool \u2192 Bool) (b b' : Bool) \u2192 isInjective f \u2192 f true \u2261 b \u2192 f false \u2261 b' \u2192 b' \u2261 not b\nlemma\u2081 f false false isInj e e' = isInj (e' \u2219 sym e)\nlemma\u2081 f false true isInj e e' = refl\nlemma\u2081 f true false isInj e e' = refl\nlemma\u2081 f true true isInj e e' = isInj (e \u2219 sym e')\n\nlemma\u2082 : \u2200 (f g : Bool \u2192 Bool) \u2192 isInjective f \u2192 isInjective g \u2192 f true \u2261 g true \u2192 f \u2261 g\nlemma\u2082 f g fInj gInj e = funExt (\u03bb { true \u2192 e\n                                   ; false \u2192 lemma\u2081 f (g true) (f false) fInj e refl \u2219 sym (lemma\u2081 g (g true) (g false) gInj refl refl) })\n\nlemma\u2083 : \u2200 (e : Bool \u2243 Bool) (b : Bool) \u2192 (e .fst true \u2261 b) \u2192 Bool\u2192[Bool\u2243Bool] b .fst \u2261 e .fst\nlemma\u2083 e false eq = lemma\u2082 not (e .fst) (equivIsInj notEquiv) (equivIsInj e) (sym eq)\nlemma\u2083 e true eq = lemma\u2082 (idfun Bool) (e .fst) (equivIsInj (idEquiv Bool)) (equivIsInj e) (sym eq)\n\nisomorphism : Iso Bool (Bool \u2243 Bool)\nIso.fun isomorphism = Bool\u2192[Bool\u2243Bool]\nIso.inv isomorphism = [Bool\u2243Bool]\u2192Bool\nIso.rightInv isomorphism e = equivEq _ _ (lemma\u2083 e (e .fst true) refl)\nIso.leftInv isomorphism false = refl\nIso.leftInv isomorphism true = refl\n\n-- Lift is necessary for Bool and Bool \u2261 Bool are of different level. :-P\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = cong Lift (isoToPath isomorphism) \u2219 (sym univalencePath)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":428,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Agda.Primitive\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything hiding (Iso)\n\n-- maybe helpful when case splitting\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nopen Iso\n\nabsurd : (f : Bool \u2243 Bool) \u2192 (b : Bool) \u2192 fst f b \u2261 fst f (not b) \u2192 b \u2261 not b\nabsurd f b p = sym (leftInv f' b) \u2219 cong g p \u2219 (leftInv f' (not b))\n  where\n    f' : Iso Bool Bool\n    f' = equivToIso f\n\n    g : Bool \u2192 Bool\n    g = inv (equivToIso f)\n\nequiv-not : (f : Bool \u2243 Bool) \u2192 (b : Bool) \u2192 (fst f (not b)) \u2261 not (fst f b)\nequiv-not f false with fst f false | fst f true | inspect (fst f) false | inspect (fst f) true\n...                  | false       | false      | [ p ]                 | [ q ] = absurd f false (p \u2219 (sym q))\n...                  | false       | true       | [ _ ]                 | [ _ ] = refl\n...                  | true        | false      | [ _ ]                 | [ _ ] = refl\n...                  | true        | true       | [ p ]                 | [ q ] = absurd f true (q \u2219 (sym p))\nequiv-not f true  with fst f false | fst f true | inspect (fst f) false | inspect (fst f) true\n...                  | false       | false      | [ p ]                 | [ q ] = absurd f false (p \u2219 (sym q))\n...                  | false       | true       | [ _ ]                 | [ _ ] = refl\n...                  | true        | false      | [ _ ]                 | [ _ ] = refl\n...                  | true        | true       | [ p ]                 | [ q ] = absurd f true (q \u2219 (sym p))\n\nequiv-false-fun : (f g : Bool \u2243 Bool) \u2192 fst f false \u2261 fst g false \u2192 fst f \u2261 fst g\nequiv-false-fun f g p i false = p i\nequiv-false-fun f g p i true = q i\n  where\n    q : fst f true \u2261 fst g true \n    q = equiv-not f false \u2219 (cong not p) \u2219 (sym (equiv-not g false))\n\nequiv-false : (f g : Bool \u2243 Bool) \u2192 fst f false \u2261 fst g false \u2192 f \u2261 g\nequiv-false f g p = equivEq f g (equiv-false-fun f g p)\n\nequiv-is-idEquiv : (f : Bool \u2243 Bool) \u2192 fst f false \u2261 false \u2192 f \u2261 idEquiv Bool\nequiv-is-idEquiv f p = equiv-false f (idEquiv Bool) p\n\nequiv-is-notEquiv : (f : Bool \u2243 Bool) \u2192 fst f false \u2261 true \u2192 f \u2261 notEquiv\nequiv-is-notEquiv f p = equiv-false f notEquiv p\n\nf : Bool \u2192 Bool \u2243 Bool\nf false = idEquiv Bool\nf true  = notEquiv\n\ng : Bool \u2243 Bool \u2192 Bool\ng e = fst e false\n\ngf\u2261id : \u2200 b \u2192 g (f b) \u2261 b\ngf\u2261id false = refl\ngf\u2261id true  = refl\n\nfg\u2261id : \u2200 e \u2192 f (g e) \u2261 e\nfg\u2261id e = equiv-false (f (g e)) e lemma\n  where\n    lemma : fst (f (fst e false)) false \u2261 fst e false\n    lemma with fst e false\n    ...      | false   = refl  \n    ...      | true    = refl \n\nBool\u2243[Bool\u2243Bool] : Bool \u2243 (Bool \u2243 Bool)\nBool\u2243[Bool\u2243Bool] = isoToEquiv (iso f g fg\u2261id gf\u2261id)\n\n[Bool\u2243Bool]\u2243[Bool\u2261Bool] : (Bool \u2243 Bool) \u2243 (Bool \u2261 Bool)\n[Bool\u2243Bool]\u2243[Bool\u2261Bool] = invEquiv univalence\n\nLift-Iso : \u2200 {\u2113} \u2192 Iso {\u2113} {lzero} (Lift Bool) Bool\nLift-Iso = iso lower lift (\u03bb b \u2192 refl) lemma\n  where\n    lemma : (b : Lift Bool) \u2192 lift (lower b) \u2261 b\n    lemma (lift false) = refl\n    lemma (lift true)  = refl\n\nLift\u2243 : \u2200 {\u2113} \u2192 Lift Bool \u2243 Bool\nLift\u2243 {\u2113} = isoToEquiv (Lift-Iso {\u2113})\n\nBool\u2243[Bool\u2261Bool] : \u2200 {\u2113} \u2192 Lift Bool \u2243 (Bool \u2261 Bool)\nBool\u2243[Bool\u2261Bool] {\u2113} = compEquiv (Lift\u2243 {\u2113}) (compEquiv Bool\u2243[Bool\u2243Bool] [Bool\u2243Bool]\u2243[Bool\u2261Bool])\n\n-- Lift is necessary for Bool and Bool \u2261 Bool are of different level. :-P\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = ua Bool\u2243[Bool\u2261Bool]","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":429,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything hiding ([_] ; Iso ; compIso )\n\n-- maybe helpful when case splitting\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nisInjectiveTransport : \u2200 {\u2113 : Level} {A B : Type \u2113} {p q : A \u2261 B} \u2192 transport p \u2261 transport q \u2192 p \u2261 q\nisInjectiveTransport {p = p} {q} \u03b1 i =\n  hcomp\n    (\u03bb j \u2192 \u03bb\n      { (i = i0) \u2192 secEq univalence p j\n      ; (i = i1) \u2192 secEq univalence q j\n      })\n    (invEq univalence ((\u03bb a \u2192 \u03b1 i a) , t i))\n  where\n  t : PathP (\u03bb i \u2192 isEquiv (\u03bb a \u2192 \u03b1 i a)) (pathToEquiv p .snd) (pathToEquiv q .snd)\n  t = isProp\u2192isContrPathP isPropIsEquiv ((\u03bb i a \u2192 \u03b1 i a)) _ _ .fst\n\nisInjectiveTransport' : \u2200 {\u2113 : Level} {A B : Type \u2113} (p : A \u2261 B) {x y : A} \u2192 transport p x \u2261 transport p y \u2192 x \u2261 y\nisInjectiveTransport' p {x} {y} q = \n    x\n  \u2261\u27e8 sym (transport\u207bTransport p x) \u27e9\n    transport\u207b p (transport p x)\n  \u2261\u27e8 cong (transport\u207b p) q \u27e9\n    transport\u207b p (transport p y)\n  \u2261\u27e8 transport\u207bTransport p y \u27e9\n    y\n  \u220e\n\nlem-false : (p : Bool \u2261 Bool) \u2192 transport p false \u2261 false \u2192 p \u2261 refl\nlem-false p pf with transport p true | inspect (transport p) true\n... | true  | [ pt ] = isInjectiveTransport (funExt (\u03bb {false \u2192 pf ; true \u2192 pt}))\n... | false | [ pt ] = \u22a5-elim (false\u2262true (isInjectiveTransport' p (pf \u2219 sym pt)))\n\nlem-true : (p : Bool \u2261 Bool) \u2192 transport p false \u2261 true \u2192 p \u2261 notEq\nlem-true p pf with transport p true | inspect (transport p) true\n... | true  | [ pt ] = \u22a5-elim (true\u2262false (isInjectiveTransport' p (pt \u2219 sym pf)))\n... | false | [ pt ] = isInjectiveTransport (funExt (\u03bb {false \u2192 pf ; true \u2192 pt}))\n\n\n[Bool\u2261Bool]-dec : (p : Bool \u2261 Bool) \u2192 (p \u2261 refl) \u228e (p \u2261 notEq)\n[Bool\u2261Bool]-dec p with transport p false | inspect (transport p) false\n... | false | [ q ] = inl (lem-false p q)\n... | true  | [ q ] = inr (lem-true p q)\n\nBool\u21d2[Bool\u2261Bool] : Bool \u2192 Bool \u2261 Bool\nBool\u21d2[Bool\u2261Bool] false = refl\nBool\u21d2[Bool\u2261Bool] true = notEq\n\n[Bool\u2261Bool]\u21d2Bool : Bool \u2261 Bool \u2192 Bool\n[Bool\u2261Bool]\u21d2Bool p with [Bool\u2261Bool]-dec p\n... | inl _ = false\n... | inr _ = true\n\nBool\u21d2[Bool\u2261Bool]\u21d2Bool : (b : Bool) \u2192 [Bool\u2261Bool]\u21d2Bool (Bool\u21d2[Bool\u2261Bool] b) \u2261 b\nBool\u21d2[Bool\u2261Bool]\u21d2Bool false = refl\nBool\u21d2[Bool\u2261Bool]\u21d2Bool true = refl\n\n[Bool\u2261Bool]\u21d2Bool\u21d2[Bool\u2261Bool] : (p : Bool \u2261 Bool) \u2192 Bool\u21d2[Bool\u2261Bool] ([Bool\u2261Bool]\u21d2Bool p) \u2261 p\n[Bool\u2261Bool]\u21d2Bool\u21d2[Bool\u2261Bool] p with [Bool\u2261Bool]-dec p\n... | inl q = sym q\n... | inr q = sym q\n\nBool-iso-[Bool\u2261Bool] : Iso Bool (Bool \u2261 Bool)\nBool-iso-[Bool\u2261Bool] = iso Bool\u21d2[Bool\u2261Bool] [Bool\u2261Bool]\u21d2Bool [Bool\u2261Bool]\u21d2Bool\u21d2[Bool\u2261Bool] Bool\u21d2[Bool\u2261Bool]\u21d2Bool\n\nLiftA-iso-A : {\u2113 : Level} (A : Type \u2113) \u2192 Iso (Lift {\u2113}{\u2113-suc \u2113} A) A\nLiftA-iso-A _ = iso lower lift (\u03bb _ \u2192 refl) \u03bb _ \u2192 refl\n\n-- Lift is necessary for Bool and Bool \u2261 Bool are of different level. :-P\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = isoToPath (compIso (LiftA-iso-A Bool) Bool-iso-[Bool\u2261Bool])\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":430,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule 2=2=2 where\n\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything\n\nxor : Bool \u2192 Bool \u2192 Bool\nxor false = idfun Bool\nxor true = not\n\nxorIsEquiv : (b : Bool) \u2192 isEquiv (xor b)\nxorIsEquiv false = idIsEquiv Bool\nxorIsEquiv true = notIsEquiv\n\nequivIsXor : (p : Bool \u2243 Bool) \u2192 {pf pt : Bool} \u2192 pf \u2261 p .fst false \u2192 pt \u2261 p .fst true \u2192 (b : Bool) \u2192 xor pf b \u2261 p .fst b\nequivIsXor p {false} q _ false = q\nequivIsXor p {true} q _ false = q\nequivIsXor p {false} {false} q r true with p .snd .equiv-proof false\n... | (false , _) , c = sym (cong fst (c (true , sym r))) \u2219 r\n... | (true , _) , c = cong fst (c (false , sym q)) \u2219 r\nequivIsXor p {false} {true} q r true = r\nequivIsXor p {true} {false} q r true = r\nequivIsXor p {true} {true} q r true with p .snd .equiv-proof true\n... | (false , _) , c = cong fst (c (true , sym r)) \u2219 r\n... | (true , _) , c = sym (cong fst (c (false , sym q))) \u2219 r\n\nBool\u2192[Bool\u2243Bool] : Bool \u2192 (Bool \u2243 Bool)\nBool\u2192[Bool\u2243Bool] b = xor b , xorIsEquiv b\n\n[Bool\u2243Bool]\u2192Bool : (Bool \u2243 Bool) \u2192 Bool\n[Bool\u2243Bool]\u2192Bool p = p .fst false\n\n[Bool\u2243Bool]\u2192Bool\u2192[Bool\u2243Bool] : section Bool\u2192[Bool\u2243Bool] [Bool\u2243Bool]\u2192Bool\n[Bool\u2243Bool]\u2192Bool\u2192[Bool\u2243Bool] p = equivEq (Bool\u2192[Bool\u2243Bool] ([Bool\u2243Bool]\u2192Bool p)) p (funExt (equivIsXor p refl refl))\n\nBool\u2192[Bool\u2243Bool]\u2192Bool : retract Bool\u2192[Bool\u2243Bool] [Bool\u2243Bool]\u2192Bool\nBool\u2192[Bool\u2243Bool]\u2192Bool false = refl\nBool\u2192[Bool\u2243Bool]\u2192Bool true = refl\n\nBool\u2261[Bool\u2261Bool] : Lift Bool \u2261 (Bool \u2261 Bool)\nBool\u2261[Bool\u2261Bool] = cong Lift (isoToPath (iso Bool\u2192[Bool\u2243Bool] [Bool\u2243Bool]\u2192Bool [Bool\u2243Bool]\u2192Bool\u2192[Bool\u2243Bool] Bool\u2192[Bool\u2243Bool]\u2192Bool)) \u2219 sym univalencePath","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5c8cf813eca75e00015121b0":[{"id":431,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything\n\n-- maybe helpful\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nlemma1 : {P : Set} -> {A B : Set} -> (p : Maybe A \u2261 Maybe B) -> (a : A) -> (transport p (just a)) \u2261 nothing -> transport p nothing \u2261 nothing -> P\nlemma1 p a prf1 prf2 =\n  subst (\\{(just a) -> 1 \u2261 1; nothing -> _})\n        (subst (\\x -> x \u2261 nothing)\n               (subst (\\x -> transport\u207b p x \u2261 just a) prf1 (transport\u207bTransport p (just a)))\n               (subst (\\x -> transport\u207b p x \u2261 nothing) prf2 (transport\u207bTransport p nothing)))\n        refl\n        \nlemma2 : forall {P : Set} {A : Set} {a : A} -> nothing \u2261 just a -> P\nlemma2 {P} p = subst (\\{(just a) -> P; nothing -> 1 \u2261 1}) p refl\n\nltr : {A B : Set} -> Maybe A \u2261 Maybe B \u2192 A -> B\nltr p a with transport p (just a) | inspect (transport p) (just a)\nltr p a | just b | _ = b\nltr p a | nothing | [ prf1 ] with transport p nothing | inspect (transport p) nothing\nltr p a | nothing | [ prf1 ] | just b | _ = b\nltr p a | nothing | [ prf1 ] | nothing | [ prf2 ] = lemma1 p a prf1 prf2\n\nrtl : {A B : Set} -> Maybe A \u2261 Maybe B -> B -> A\nrtl p = ltr (sym p)\n\nunwrap : forall {A : Set} -> (b : A) -> (a : Maybe A) -> A\nunwrap b nothing = b\nunwrap b (just a) = a\n\njust-injective : \u2200 {A : Set} (a b : A) \u2192 just a \u2261 just b \u2192 a \u2261 b\njust-injective a b p = cong (unwrap a) p\n\nltrtl : forall {A B : Set} (p : Maybe A \u2261 Maybe B) (a : A) -> (rtl p (ltr p a)) \u2261 a\nltrtl p a with transport p (just a) | inspect (transport p) (just a)\nltrtl p a | just b | [ prf1 ] with transport (sym p) (just b) | inspect (transport (sym p)) (just b)\nltrtl p a | just b | [ prf1 ] | just a' | [ prf2 ] =\n  just-injective _ _ (subst (\\x -> x \u2261 just a) prf2 (subst (\\x -> transport (sym p) x \u2261 just a) prf1 (transport\u207bTransport p (just a))))\nltrtl p a | just b | [ prf1 ] | nothing | [ prf2 ] =\n  lemma2 (subst (\\x -> x \u2261 just a) prf2 (subst (\\x -> transport (sym p) x \u2261 just a) prf1 (transport\u207bTransport p (just a))))\nltrtl p a | nothing | [ prf1 ] with transport p nothing | inspect (transport p) nothing\nltrtl p a | nothing | [ prf1 ] | just b | [ prf2 ] with transport (sym p) (just b) | inspect (transport (sym p)) (just b)\nltrtl p a | nothing | [ prf1 ] | just b | [ prf2 ] | just b' | [ prf3 ] =\n  lemma2 (sym (subst (\\x -> x \u2261 nothing) prf3 (subst (\\x -> transport (sym p) x \u2261 nothing) prf2 (transport\u207bTransport p nothing))))\nltrtl p a | nothing | [ prf1 ] | just b | [ prf2 ] | nothing | [ prf3 ] with transport (sym p) nothing | inspect (transport (sym p)) nothing\nltrtl p a | nothing | [ prf1 ] | just b | [ prf2 ] | nothing | [ prf3 ] | just b' | [ prf4 ] =\n  just-injective _ _ (subst (\\x -> x \u2261 just a) prf4 (subst (\\x -> transport (sym p) x \u2261 just a) prf1 (transport\u207bTransport p (just a))))\nltrtl p a | nothing | [ prf1 ] | just b | [ prf2 ] | nothing | [ prf3 ] | nothing | [ prf4 ] = lemma1 (sym p) b prf3 prf4\nltrtl p a | nothing | [ prf1 ] | nothing | [ prf2 ] = lemma1 p a prf1 prf2\n\nrtltr : forall {A B : Set} (p : Maybe A \u2261 Maybe B) (a : B) -> (ltr p (rtl p a)) \u2261 a\nrtltr p b = ltrtl (sym p) b\n\nmaybeInjective' : {A B : Set} -> Maybe A \u2261 Maybe B \u2192 A \u2243 B\nmaybeInjective' p = (ltr p , isoToIsEquiv (iso (ltr p) (rtl p) (rtltr p) (ltrtl p)))\n\n-- prove it!\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective p = ua (maybeInjective' p)","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":432,"user_id":168,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything\n\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nopen Iso\n\nisoRefl : {A : Set} \u2192 Iso A A\nisoRefl = iso (\u03bb a \u2192 a) (\u03bb a \u2192 a) (\u03bb a \u2192 refl) (\u03bb a \u2192 refl)\n\nisoSym : {A B : Set} \u2192 Iso A B \u2192 Iso B A\nisoSym ab = iso (inv ab) (fun ab) (leftInv ab) (rightInv ab)\n\npathToIso : {A B : Set} \u2192 A \u2261 B \u2192 Iso A B\npathToIso {A} eq = subst (Iso A) eq isoRefl\n\njustNeqNothing : {A : Set} (a : A) \u2192 just a \u2261 nothing \u2192 \u22a5\njustNeqNothing {A} a eq = subst aux eq (just a)\n  where aux : Maybe A \u2192 Set\n        aux (just _) = Maybe A\n        aux nothing = \u22a5\n\njustInjective : {A : Set} {a b : A} \u2192 just a \u2261 just b \u2192 a \u2261 b\njustInjective {A} {a} eq i = aux (eq i)\n  where aux : Maybe A \u2192 A\n        aux (just x) = x\n        aux nothing = a\n\nisoFunInjective : {A B : Set} \u2192 (ab : Iso A B) \u2192 {a1 a2 : A} \u2192\n  fun ab a1 \u2261 fun ab a2 \u2192 a1 \u2261 a2\nisoFunInjective ab {a1} {a2} eq =\n  let p1 = leftInv ab a1 in\n  let p2 = leftInv ab a2 in\n  sym p1 \u2219 (cong (inv ab) eq) \u2219 p2\n\nisoInvInjective : {A B : Set} \u2192 (ab : Iso A B) \u2192 {b1 b2 : B} \u2192\n  inv ab b1 \u2261 inv ab b2 \u2192 b1 \u2261 b2\nisoInvInjective ab = isoFunInjective (isoSym ab)\n\nto : {A B : Set} \u2192 Iso (Maybe A) (Maybe B) \u2192 A \u2192 B\nto mab a with fun mab (just a) | inspect (fun mab) (just a)\n... | just b  | _ = b\n... | nothing | [ feq ] with fun mab nothing | inspect (fun mab) nothing\n...      | just b  | _ = b\n...      | nothing | [ feq2 ] = \u22a5-elim (justNeqNothing a (isoFunInjective mab (feq \u2219 sym feq2)))\n\nfrom : {A B : Set} \u2192 Iso (Maybe A) (Maybe B) \u2192 B \u2192 A\nfrom mab b = to (isoSym mab) b\n\nsectionToFrom : {A B : Set} \u2192 (mab : Iso (Maybe A) (Maybe B)) \u2192 section (to mab) (from mab)\nsectionToFrom mab b with inv mab (just b) | inspect (inv mab) (just b)\n... | just a | [ eq1 ] with fun mab (just a) | inspect (fun mab) (just a)\n... | just b' | [ eq2 ] = justInjective (sym eq2 \u2219 cong (fun mab) (sym eq1) \u2219 rightInv mab (just b))\n... | nothing | [ eq2 ] = \u22a5-elim (justNeqNothing b (( sym (rightInv mab (just b)) \u2219 cong (fun mab) eq1) \u2219 eq2))\nsectionToFrom mab b | nothing | [ eq1 ] with inv mab nothing | inspect (inv mab) nothing\n... | nothing | [ eq2 ] = \u22a5-elim (justNeqNothing b (isoInvInjective mab (eq1 \u2219 sym eq2)))\n... | just a  | [ eq2 ] with fun mab (just a) | inspect (fun mab) (just a)\n... | just b' | [ eq3 ] = \u22a5-elim (justNeqNothing b' (sym eq3 \u2219 cong (fun mab) (sym eq2) \u2219 rightInv mab nothing))\n... | nothing | [ eq3 ] with fun mab nothing  | inspect (fun mab) nothing\n... | just b' | [ eq4 ] = justInjective (sym eq4 \u2219 cong (fun mab) (sym eq1) \u2219 rightInv mab (just b))\n... | nothing | [ eq4 ] = \u22a5-elim (justNeqNothing a (isoFunInjective mab (eq3 \u2219 sym eq4)))\n\nisoUnMaybe : {A B : Set} \u2192 Iso (Maybe A) (Maybe B) \u2192 Iso A B\nisoUnMaybe mab = iso (to mab) (from mab) (sectionToFrom mab) (sectionToFrom (isoSym mab))\n\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective = isoToPath \u2218 isoUnMaybe \u2218 pathToIso\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":433,"user_id":60,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Cubical.Data.Everything hiding ([_]; Iso)\nopen import Cubical.Foundations.Everything\nopen import Data.Maybe\n\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\ntranspInj : \u2200{\u2113}{A B : Set \u2113}{a b : A} \u2192 (p : A \u2261 B) \u2192 transport p a \u2261 transport p b \u2192 a \u2261 b\ntranspInj {a = a}{b = b} p p' = sym (transport\u207bTransport p a) \u2219 cong (transport\u207b p) p' \u2219 transport\u207bTransport p b\n\njustInj : \u2200{\u2113}{A : Set \u2113}{a b : A} \u2192 just a \u2261 just b \u2192 a \u2261 b\njustInj {a = a} = cong (fromMaybe a)\n\nimpossible : \u2200{\u2113}{A : Set \u2113}{a : A} \u2192 just a \u2261 nothing \u2192 \u22a5\nimpossible p = subst (maybe (\u03bb _ \u2192 Unit) \u22a5) p tt\n\nlemma : \u2200{\u2113}{A B : Set \u2113}{a a' : A}{b : B} \u2192 (p : A \u2261 B) \u2192 transport p a \u2261 b \u2192 transport\u207b p b \u2261 a' \u2192 a \u2261 a'\nlemma {a = a} p q r = sym (transport\u207bTransport p a) \u2219 cong (transport\u207b p) q \u2219 r\n\ngetFun : \u2200{\u2113}{A B : Set \u2113} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2192 B\ngetFun p a with transport p (just a) | inspect (transport p) (just a)\n              | transport p nothing  | inspect (transport p) nothing\n...| just b  | _     | _       | _     = b\n...| nothing | _     | just b  | _     = b\n...| nothing | [ q ] | nothing | [ r ] = \u22a5-elim (impossible (transpInj p (q \u2219 sym r)))\n\ngetRec : \u2200{\u2113}{A B : Set \u2113} \u2192 (p : Maybe A \u2261 Maybe B) \u2192 (a : A) \u2192 getFun (sym p) (getFun p a) \u2261 a\ngetRec p a with transport p (just a) | inspect (transport p) (just a)\n              | transport p nothing  | inspect (transport p) nothing\n              | transport\u207b p (just (getFun p a)) | inspect (transport\u207b p) (just (getFun p a))\n              | transport\u207b p nothing             | inspect (transport\u207b p) nothing\n...| just b  | [ q ] | _       | _     | just a' | [ r ] | _       | _     = sym (justInj (lemma p q r))\n...| just b  | [ q ] | _       | _     | nothing | [ r ] | _       | _     = \u22a5-elim (impossible (lemma p q r))\n...| nothing | _     | just b  | [ q ] | just a' | [ r ] | _       | _     = \u22a5-elim (impossible (sym (lemma p q r)))\n...| nothing | [ q ] | just b  | _     | nothing | _     | just a' | [ r ] = sym (justInj (lemma p q r))\n...| nothing | [ q ] | nothing | [ r ] | _       | _     | _       | _     = \u22a5-elim (impossible (transpInj p (q \u2219 sym r)))\n...| _       | _     | _       | _     | nothing | [ q ] | nothing | [ r ] = \u22a5-elim (impossible (transpInj (sym p) (q \u2219 sym r)))\n\nmaybeInj : \u2200{\u2113}{A B : Set \u2113} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInj p = isoToPath (iso (getFun p) (getFun (sym p)) (getRec (sym p)) (getRec p))\n\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective = maybeInj","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":434,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\n\nmodule MaybeInjective where\n\nopen import Level\nopen import Data.Maybe\nopen import Cubical.Relation.Nullary\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Empty\nopen import Cubical.Foundations.Isomorphism\nopen import Cubical.Foundations.Transport\n\n\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\u1d62 \n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\u1d62 \n\n-- prove it!\n\nhelper : {A : Set} \u2192 A \u2192 Maybe A \u2192 Set\nhelper x nothing  = nothing \u2261 just x\nhelper x (just _) = \u22a5\n\nnothing\u2262just : {A : Set} (x : A) \u2192 \u00ac(nothing \u2261 just x)\nnothing\u2262just x = \u03bb p \u2192 transp (\u03bb i \u2192 (helper x (p i))) i0 p\n\nfromJust : {A : Set} \u2192 A \u2192 Maybe A \u2192 A\nfromJust a nothing  = a\nfromJust _ (just a) = a\n\njust-inj : {A : Set} (x y : A) \u2192 just x \u2261 just y \u2192 x \u2261 y\njust-inj x _ eq = cong (fromJust x) eq \n\n-- from the newer Cubical git\nisoFunInjective : {A B : Set} (f : Iso A B) \u2192 (x y : A) \u2192 Iso.fun f x \u2261 Iso.fun f y \u2192 x \u2261 y\nisoFunInjective f x y h = sym (Iso.leftInv f x) \u2219\u2219 cong (Iso.inv f) h \u2219\u2219 Iso.leftInv f y\n\nisoInvInjective : {A B : Set}  (f : Iso A B) \u2192 (x y : B) \u2192 Iso.inv f x \u2261 Iso.inv f y \u2192 x \u2261 y\nisoInvInjective f x y h = sym (Iso.rightInv f x) \u2219\u2219 cong (Iso.fun f) h \u2219\u2219 Iso.rightInv f y\n\npathToIso : \u2200 {\u2113} {A B : Type \u2113} \u2192 A \u2261 B \u2192 Iso A B\nIso.fun (pathToIso x) = transport x\nIso.inv (pathToIso x) = transport\u207b x\nIso.rightInv (pathToIso x) = transportTransport\u207b x\nIso.leftInv (pathToIso x) = transport\u207bTransport x\n-- end of copy pasted code\n\nmaybeInjectiveIso : {A B : Set} \u2192 Iso (Maybe A) (Maybe B) \u2192 Iso A B\nmaybeInjectiveIso {A} {B} i = iso f g sec ret\n  where\n    open Iso\n  \n    h : Maybe A \u2192 Maybe B\n    h = fun i\n\n    k : Maybe B \u2192 Maybe A\n    k = inv i\n\n    sec' : section h k\n    sec' = rightInv i\n\n    ret' : retract h k\n    ret' = leftInv i\n\n    f'' : (x : A) \u2192 (m : Maybe B) \u2192 h (just x) \u2261 nothing \u2192 h nothing \u2261 m \u2192 B\n    f'' _ (just y) _ _ = y\n    f'' x nothing  p q = \u22a5-elim (nothing\u2262just x (isoFunInjective i nothing (just x) (q \u2219 sym p)))\n\n    f' : (x : A) \u2192 (m : Maybe B) \u2192 h (just x) \u2261 m \u2192 B\n    f' _ (just y) _ = y\n    f' x nothing  p = f'' x (h nothing) p refl\n\n    f : A \u2192 B\n    f x = f' x (h (just x)) refl\n\n    g'' : (x : B) \u2192 (m : Maybe A) \u2192 k (just x) \u2261 nothing \u2192 k nothing \u2261 m \u2192 A\n    g'' _ (just y) _ _ = y\n    g'' x nothing  p q = \u22a5-elim (nothing\u2262just x (isoInvInjective i nothing (just x) (q \u2219 sym p)))\n\n    g' : (x : B) \u2192 (m : Maybe A) \u2192 k (just x) \u2261 m \u2192 A\n    g' _ (just y) _ = y\n    g' x nothing  p = g'' x (k nothing) p refl\n\n    g : B \u2192 A\n    g x = g' x (k (just x)) refl\n\n    sec : section f g\n    sec x with k (just x) | inspect k (just x)\n    sec x | just y  | [ p ]\u1d62 with h (just y) | inspect h (just y)\n    sec x | just y | [ p ]\u1d62 | just z | [ q ]\u1d62 = just-inj z x (sym q \u2219 cong (fun i) (sym p) \u2219 sec' (just x))\n    sec x | just y | [ p ]\u1d62 | nothing | [ q ]\u1d62 = \u22a5-elim (nothing\u2262just x (sym q \u2219 cong h (sym p) \u2219 sec' (just x)))\n    sec x | nothing | [ p ]\u1d62 with k nothing | inspect k nothing\n    sec x | nothing | [ p ]\u1d62 | just z  | [ q ]\u1d62 with h (just z) | inspect h (just z)\n    sec x | nothing | [ p ]\u1d62 | just z | [ q ]\u1d62 | just w  | [ r ]\u1d62 = \u22a5-elim (nothing\u2262just w ((sym (sec' nothing) \u2219 cong h q) \u2219 r))\n    sec x | nothing | [ p ]\u1d62 | just z | [ q ]\u1d62 | nothing | [ r ]\u1d62 with h nothing | inspect h nothing\n    sec x | nothing | [ p ]\u1d62 | just z | [ q ]\u1d62 | nothing | [ r ]\u1d62 | just v  | [ s ]\u1d62 = just-inj v x (sym s \u2219 cong h (sym p) \u2219 sec' (just x))\n    sec x | nothing | [ p ]\u1d62 | just z | [ q ]\u1d62 | nothing | [ r ]\u1d62 | nothing | [ s ]\u1d62 = \u22a5-elim (nothing\u2262just z (sym (ret' nothing) \u2219 cong k s \u2219 q))\n    sec x | nothing | [ p ]\u1d62 | nothing | [ q ]\u1d62 = \u22a5-elim (nothing\u2262just x (isoInvInjective i nothing (just x) (q \u2219 sym p)))\n\n    ret : retract f g\n    ret x with h (just x) | inspect h (just x)\n    ret x | just y | [ p ]\u1d62 with k (just y) | inspect k (just y)\n    ret x | just y | [ p ]\u1d62 | just z | [ q ]\u1d62 = just-inj z x (sym q \u2219 cong k (sym p) \u2219 ret' (just x)) \n    ret x | just y | [ p ]\u1d62 | nothing | [ q ]\u1d62 = \u22a5-elim (nothing\u2262just x (sym q \u2219 cong k (sym p) \u2219 ret' (just x))) \n    ret x | nothing | [ p ]\u1d62 with h nothing | inspect h nothing\n    ret x | nothing | [ p ]\u1d62 | just z  | [ q ]\u1d62 with k (just z) | inspect k (just z)\n    ret x | nothing | [ p ]\u1d62 | just z  | [ q ]\u1d62 | just w  | [ r ]\u1d62 = \u22a5-elim (nothing\u2262just w ((sym (ret' nothing) \u2219 cong k q) \u2219 r))\n    ret x | nothing | [ p ]\u1d62 | just z  | [ q ]\u1d62 | nothing | [ r ]\u1d62 with k nothing | inspect k nothing\n    ret x | nothing | [ p ]\u1d62 | just z  | [ q ]\u1d62 | nothing | [ r ]\u1d62 | just v  | [ s ]\u1d62 = just-inj v x (sym s \u2219 cong k (sym p) \u2219 ret' (just x))\n    ret x | nothing | [ p ]\u1d62 | just z  | [ q ]\u1d62 | nothing | [ r ]\u1d62 | nothing | [ s ]\u1d62 = \u22a5-elim (nothing\u2262just z ((sym (sec' nothing) \u2219 cong h s) \u2219 q))\n    ret x | nothing | [ p ]\u1d62 | nothing | [ q ]\u1d62 = \u22a5-elim (nothing\u2262just x (isoFunInjective i nothing (just x) (q \u2219 sym p)))\n  \n\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective \u03b3 = isoToPath (maybeInjectiveIso (pathToIso \u03b3))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":435,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything hiding (Iso)\nopen import Cubical.Relation.Nullary\nopen Iso\n\n-- maybe helpful\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\n-- prove it!\ntransport\u2192transport\u207b :\n  \u2200 {A B : Set} (p : A \u2261 B) {a b} \u2192 transport p a \u2261 b \u2192 a \u2261 transport\u207b p b\ntransport\u2192transport\u207b p q = sym (fromPathP (symP {A = \u03bb i \u2192 p i} (toPathP q)))\n\njustInj : \u2200 {A : Set} {x y : A} \u2192 just x \u2261 just y \u2192 x \u2261 y\njustInj {A} {x} p = cong f p\n  where\n  f : Maybe A \u2192 A\n  f nothing = x\n  f (just z) = z\n\nnothing\u2262just : \u2200 {A : Set} {a : A} \u2192 \u00ac (nothing \u2261 just a)\nnothing\u2262just {A} p = subst P p tt\n  where\n  P : Maybe A \u2192 Set\n  P nothing = Unit\n  P (just a) = \u22a5\n\nmaybeInjFun : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2192 B\nmaybeInjFun p a with transport p (just a) | inspect (transport p) (just a)\n... | just b  | q = b\n... | nothing | [ q ] with transport p nothing | inspect (transport p) nothing\n...   | just b  | r = b\n...   | nothing | [ r ] =\n  \u22a5-elim\n    (nothing\u2262just (transport\u2192transport\u207b p r \u2219 sym (transport\u2192transport\u207b p q)))\n\nmaybeInjInv :\n  \u2200 {A B : Set} (p : Maybe A \u2261 Maybe B) a \u2192\n  maybeInjFun (sym p) (maybeInjFun p a) \u2261 a\nmaybeInjInv p a with transport p (just a) | inspect (transport p) (just a)\nmaybeInjInv p a | just b | [ q ]\n  with transport (sym p) (just b) | inspect (transport (sym p)) (just b)\n... | just a\u2032 | [ r ] = justInj (sym r \u2219 sym (transport\u2192transport\u207b p q))\n... | nothing | [ r ] =\n  \u22a5-elim (nothing\u2262just (sym r \u2219 sym (transport\u2192transport\u207b p q)))\nmaybeInjInv p a | nothing | [ q ]\n  with transport p nothing | inspect (transport p) nothing\nmaybeInjInv p a | nothing | [ q ] | just b | [ r ]\n  with transport (sym p) (just b) | inspect (transport (sym p)) (just b)\n... | just a\u2032 | [ s ] = \u22a5-elim (nothing\u2262just (transport\u2192transport\u207b p r \u2219 s))\n... | nothing | [ s ]\n  with transport (sym p) nothing | inspect (transport (sym p)) nothing\n...   | just a\u2032 | [ t ] = justInj (sym t \u2219 sym (transport\u2192transport\u207b p q))\n...   | nothing | [ t ] =\n  \u22a5-elim (nothing\u2262just (sym t \u2219 sym (transport\u2192transport\u207b p q)))\nmaybeInjInv p a | nothing | [ q ] | nothing | [ r ] =\n  \u22a5-elim\n    (nothing\u2262just (transport\u2192transport\u207b p r \u2219 sym (transport\u2192transport\u207b p q)))\n\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective {A} {B} p = isoToPath \u03bb where\n  .fun \u2192 maybeInjFun p\n  .inv \u2192 maybeInjFun (sym p)\n  .leftInv \u2192 maybeInjInv p\n  .rightInv \u2192 maybeInjInv (sym p)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":436,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\n\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Empty as Empty\nopen import Cubical.Data.Unit\nopen import Cubical.Relation.Nullary\n\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nisoFunInjective : \u2200 {a b} {A : Type a} {B : Type b} (f : Iso A B) \u2192 (x y : A) \u2192 Iso.fun f x \u2261 Iso.fun f y \u2192 x \u2261 y\nisoFunInjective f x y h = sym (Iso.leftInv f x) \u2219\u2219 cong (Iso.inv f) h \u2219\u2219 Iso.leftInv f y\n\npathToIso : \u2200 {\u2113} {A B : Type \u2113} \u2192 A \u2261 B \u2192 Iso A B\nIso.fun (pathToIso x) = transport x\nIso.inv (pathToIso x) = transport\u207b x\nIso.rightInv (pathToIso x) = transportTransport\u207b x\nIso.leftInv (pathToIso x) = transport\u207bTransport x\n\njust\u2262nothing : \u2200 {a} {A : Type a} {x : A} \u2192 \u00ac (just x \u2261 nothing)\njust\u2262nothing p = subst (\u03bb {(just _) \u2192 Unit; nothing \u2192 \u22a5}) p tt\n\njust-inj : \u2200 {a} {A : Type a} {x y : A} \u2192 just x \u2261 just y \u2192 x \u2261 y\njust-inj {x = x} p = subst (\u03bb {(just t) \u2192 x \u2261 t; nothing \u2192 Lift \u22a5}) p refl\n\naux : \u2200 {\u2113} {A B : Type \u2113} (p : Maybe A \u2261 Maybe B) (x : A) a b \u2192\n      transport p (just x) \u2261 a \u2192 transport p nothing \u2261 b \u2192 B\naux p x (just y) _ _ _ = y\naux p x nothing (just y) _ _ = y\naux p x nothing nothing q\u2081 q\u2082 = \u22a5-elim (just\u2262nothing (isoFunInjective (pathToIso p) _ _ (q\u2081 \u2219 q\u2082 \u207b\u00b9)))\n\nmodule _ {\u2113} {A B : Type \u2113} (p : Maybe A \u2261 Maybe B) where\n  private\n    f : A \u2192 B\n    f x = aux p x _ _ refl refl\n\n    g : B \u2192 A\n    g y = aux (p \u207b\u00b9) y _ _ refl refl\n    \n    section[f,g] : section f g\n    section[f,g] y with transport\u207b p (just y) | inspect (transport\u207b p) (just y)\n    section[f,g] y | just x  | [ r\u2081 ] with transport p (just x) | cong (transport p) r\u2081\n    section[f,g] y | just x  | [ r\u2081 ] | just t  | q = just-inj (q \u207b\u00b9 \u2219 transportTransport\u207b p (just y))\n    section[f,g] y | just x  | [ r\u2081 ] | nothing | q = \u22a5-elim (just\u2262nothing (transportTransport\u207b p (just y) \u207b\u00b9 \u2219 q))\n    section[f,g] y | nothing | [ r\u2081 ] with transport\u207b p nothing | inspect (transport\u207b p) nothing\n    section[f,g] y | nothing | [ r\u2081 ] | just x  | [ r\u2082 ] with transport p (just x) | cong (transport p) r\u2082\n    section[f,g] y | nothing | [ r\u2081 ] | just x  | [ r\u2082 ] | just t  | q = \u22a5-elim (just\u2262nothing (q \u207b\u00b9 \u2219 transportTransport\u207b p nothing))\n    section[f,g] y | nothing | [ r\u2081 ] | just x  | [ r\u2082 ] | nothing | q with transport p nothing | cong (transport p) r\u2081\n    section[f,g] y | nothing | [ r\u2081 ] | just x  | [ r\u2082 ] | nothing | q | just t  | q' = just-inj (q' \u207b\u00b9 \u2219 transportTransport\u207b p (just y))\n    section[f,g] y | nothing | [ r\u2081 ] | just x  | [ r\u2082 ] | nothing | q | nothing | q' = \u22a5-elim (just\u2262nothing (transportTransport\u207b p (just y) \u207b\u00b9 \u2219 q'))\n    section[f,g] y | nothing | [ r\u2081 ] | nothing | [ r\u2082 ] = \u22a5-elim (just\u2262nothing (isoFunInjective (pathToIso (p \u207b\u00b9)) _ _ (r\u2081 \u2219 r\u2082 \u207b\u00b9)))\n    \n    retract[f,g] : retract f g\n    retract[f,g] x with transport p (just x) | inspect (transport p) (just x)\n    retract[f,g] x | just y  | [ r\u2081 ] with transport\u207b p (just y) | cong (transport\u207b p) r\u2081\n    retract[f,g] x | just y  | [ r\u2081 ] | just t  | q = just-inj (q \u207b\u00b9 \u2219 transport\u207bTransport p (just x))\n    retract[f,g] x | just y  | [ r\u2081 ] | nothing | q = \u22a5-elim (just\u2262nothing (transport\u207bTransport p (just x) \u207b\u00b9 \u2219 q))\n    retract[f,g] x | nothing | [ r\u2081 ] with transport p nothing | inspect (transport p) nothing\n    retract[f,g] x | nothing | [ r\u2081 ] | just y  | [ r\u2082 ] with transport\u207b p (just y) | cong (transport\u207b p) r\u2082\n    retract[f,g] x | nothing | [ r\u2081 ] | just y  | [ r\u2082 ] | just t  | q = \u22a5-elim (just\u2262nothing (q \u207b\u00b9 \u2219 transport\u207bTransport p nothing))\n    retract[f,g] x | nothing | [ r\u2081 ] | just y  | [ r\u2082 ] | nothing | q with transport\u207b p nothing | cong (transport\u207b p) r\u2081\n    retract[f,g] x | nothing | [ r\u2081 ] | just y  | [ r\u2082 ] | nothing | q | just t  | q' = just-inj (q' \u207b\u00b9 \u2219 transport\u207bTransport p (just x))\n    retract[f,g] x | nothing | [ r\u2081 ] | just y  | [ r\u2082 ] | nothing | q | nothing | q' = \u22a5-elim (just\u2262nothing (transport\u207bTransport p (just x) \u207b\u00b9 \u2219 q'))\n    retract[f,g] x | nothing | [ r\u2081 ] | nothing | [ r\u2082 ] = \u22a5-elim (just\u2262nothing (isoFunInjective (pathToIso p) _ _ (r\u2081 \u2219 r\u2082 \u207b\u00b9)))\n    \n  maybeInjective : A \u2261 B\n  maybeInjective = isoToPath (iso f g section[f,g] retract[f,g])\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":437,"user_id":105,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\n\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\nfromJust-def : {A : Set} \u2192 A \u2192 Maybe A \u2192 A\nfromJust-def a nothing = a\nfromJust-def _ (just a) = a\n\njust-inj : {A : Set} (x y : A) \u2192 just x \u2261 just y \u2192 x \u2261 y\njust-inj x _ eq = cong (fromJust-def x) eq\n\n\u00acnothing\u2261just : {A B : Set} {x : A} \u2192 (nothing \u2261 just x) \u2192 B\n\u00acnothing\u2261just {A = A} {B = B} {x = x} p = subst (\u03bb { nothing \u2192 Maybe B ; (just a) \u2192 B }) p nothing\n\n\u00acjust\u2261nothing : {A B : Set} {x : A} \u2192 (just x \u2261 nothing) \u2192 B\n\u00acjust\u2261nothing {A = A} {B = B} {x = x} p = subst (\u03bb { (just a) \u2192 Maybe B ; nothing \u2192 B }) p nothing\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nlemma-iso-inj : {A B C : Set} (f : Maybe A \u2192 Maybe B) (g : Maybe B \u2192 Maybe A) (a : A)\n  (p : f (just a) \u2261 nothing) (q : f nothing \u2261 nothing) \u2192\n  (g\u2218f : (x : Maybe A) \u2192 g (f x) \u2261 x) \u2192\n  C\nlemma-iso-inj {C = C} f g a p q g\u2218f = \u00acjust\u2261nothing just\u2261nothing\n  where\n    g\u2218f-just : g nothing \u2261 just a\n    g\u2218f-just = sym (cong g p) \u2219 g\u2218f (just a)\n\n    g\u2218f-nothing : g nothing \u2261 nothing\n    g\u2218f-nothing = sym (cong g q) \u2219 g\u2218f nothing\n\n    just\u2261nothing : just a \u2261 nothing\n    just\u2261nothing = sym g\u2218f-just \u2219 g\u2218f-nothing\n\nopen Iso\n\nlemma-iso : {A B : Set} \u2192 Iso (Maybe A) (Maybe B) \u2192 Iso A B\nfun (lemma-iso (iso to from to\u2218from from\u2218to)) a with to (just a) | inspect to (just a)\nfun (lemma-iso (iso to from to\u2218from from\u2218to)) a    | just b      | [ p ] = b\nfun (lemma-iso (iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ] with to nothing | inspect to nothing\nfun (lemma-iso (iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | just b     | [ q ] = b\nfun (lemma-iso (iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | nothing    | [ q ] = lemma-iso-inj to from a p q from\u2218to\ninv (lemma-iso (iso to from to\u2218from from\u2218to)) b with from (just b) | inspect from (just b)\ninv (lemma-iso (iso to from to\u2218from from\u2218to)) b    | just a      | [ p ] = a\ninv (lemma-iso (iso to from to\u2218from from\u2218to)) b    | nothing     | [ p ] with from nothing | inspect from nothing\ninv (lemma-iso (iso to from to\u2218from from\u2218to)) b    | nothing     | [ p ]      | just a     | [ q ] = a\ninv (lemma-iso (iso to from to\u2218from from\u2218to)) b    | nothing     | [ p ]      | nothing    | [ q ] = lemma-iso-inj from to b p q to\u2218from\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b with from (just b) | inspect from (just b)\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | just a        | [ p ] with to (just a) | inspect to (just a)\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | just a        | [ p ]    | just b'     | [ p' ] = just-inj b' b (sym p' \u2219 sym (cong to p) \u2219 to\u2218from (just b))\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | just a        | [ p ]    | nothing     | [ p' ] = \u00acnothing\u2261just (sym p' \u2219 sym (cong to p) \u2219 to\u2218from (just b))\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ] with from nothing | inspect from nothing\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ]    | just a       | [ q ] with to (just a) | inspect to (just a)\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ]    | just a       | [ q ]    | just b'     | [ p' ] = \u00acjust\u2261nothing (sym p' \u2219 sym (cong to q) \u2219 to\u2218from nothing)\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ]    | just a       | [ q ]    | nothing     | [ p' ] with to nothing | inspect to nothing\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ]    | just a       | [ q ]    | nothing     | [ p' ]    | just b'    |  [ q' ] = just-inj b' b (sym q' \u2219 sym (cong to p) \u2219 to\u2218from (just b))\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ]    | just a       | [ q ]    | nothing     | [ p' ]    | nothing    |  [ q' ] = \u00acnothing\u2261just (sym q' \u2219 sym (cong to p) \u2219 to\u2218from (just b))\nrightInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) b    | nothing       | [ p ]    | nothing      | [ q ] = lemma-iso-inj from to b p q to\u2218from\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a with to (just a) | inspect to (just a)\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | just b      | [ p ] with from (just b) | inspect from (just b)\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | just b      | [ p ]    | just a'       | [ p' ] = just-inj a' a (sym p' \u2219 sym (cong from p) \u2219 from\u2218to (just a))\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | just b      | [ p ]    | nothing       | [ p' ] = \u00acnothing\u2261just (sym p' \u2219 sym (cong from p) \u2219 from\u2218to (just a))\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ] with to nothing | inspect to nothing\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | just b     | [ q ] with from (just b) | inspect from (just b)\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | just b     | [ q ]    | just a'       | [ p' ] = \u00acjust\u2261nothing (sym p' \u2219 sym (cong from q) \u2219 from\u2218to nothing)\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | just b     | [ q ]    | nothing       | [ p' ] with from nothing | inspect from nothing\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | just b     | [ q ]    | nothing       | [ p' ]    | just a'      | [ q' ] = just-inj a' a (sym q' \u2219 sym (cong from p) \u2219 from\u2218to (just a))\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | just b     | [ q ]    | nothing       | [ p' ]    | nothing      | [ q' ] = \u00acnothing\u2261just (sym q' \u2219 sym (cong from p) \u2219 from\u2218to (just a))\nleftInv (lemma-iso i@(iso to from to\u2218from from\u2218to)) a    | nothing     | [ p ]    | nothing    | [ q ] = lemma-iso-inj to from a p q from\u2218to\n\nlemma-equiv : {A B : Set} \u2192 Maybe A \u2243 Maybe B \u2192 A \u2243 B\nlemma-equiv equiv = isoToEquiv (lemma-iso (equivToIso equiv))\n\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective p = ua (lemma-equiv (pathToEquiv p))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":438,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything hiding (Iso)\nopen import Cubical.Data.Empty renaming (\u22a5-elim to rec)\nopen Iso\n\nmodule MaybeCode {A : Set} {a1 : A} where\n  code : Maybe A -> Set\n  code nothing   = \u22a5\n  code (just a2) = a1 \u2261 a2\n\n  encode : {a2 : Maybe A} -> just a1 \u2261 a2 -> code a2\n  encode {a2} p = transport (cong code p) refl\n  \nopen MaybeCode\n\nmodule MaybeInjective {A B : Set} (e : Iso (Maybe A) (Maybe B)) where\n  open Iso e renaming\n    ( fun to f\n    ; inv to g\n    ; rightInv to \u03b5\n    ; leftInv to \u03b7 )\n\n  module _ (u : f nothing \u2261 nothing) (v : g nothing \u2261 nothing) where\n    fun-aux-nn : (a : A) -> (b : Maybe B) -> f (just a) \u2261 b -> B\n    fun-aux-nn a nothing  w =\n      rec (encode (sym (\u03b7 _) \u2219 cong g (w \u2219 sym u) \u2219 \u03b7 _))\n    fun-aux-nn a (just b) _ = b\n\n    inv-aux-nn : (b : B) -> (a : Maybe A) -> g (just b) \u2261 a -> A\n    inv-aux-nn b nothing  w =\n      rec (encode (sym (\u03b5 _) \u2219 cong f (w \u2219 sym v) \u2219 \u03b5 _))\n    inv-aux-nn b (just a) _ = a\n\n    rightInv-aux-nn : (b : B) ->\n                      (a : Maybe A) -> (w : g (just b) \u2261 a) ->\n                      (c : Maybe B) -> (x : f (just (inv-aux-nn b a w)) \u2261 c) ->\n                      fun-aux-nn (inv-aux-nn b a w) c x \u2261 b\n    rightInv-aux-nn b nothing w c x =\n      rec (encode (sym (\u03b5 _) \u2219 cong f (w \u2219 sym v) \u2219 \u03b5 _))\n    rightInv-aux-nn b (just a) w nothing x =\n      rec (encode (sym (\u03b7 _) \u2219 cong g (x \u2219 sym u) \u2219 \u03b7 _))\n    rightInv-aux-nn b (just a) w (just c) x =\n      encode (sym x \u2219 sym (cong f w) \u2219 \u03b5 _)\n\n    leftInv-aux-nn : (a : A) ->\n                     (b : Maybe B) -> (w : f (just a) \u2261 b) ->\n                     (c : Maybe A) -> (x : g (just (fun-aux-nn a b w)) \u2261 c) ->\n                     inv-aux-nn (fun-aux-nn a b w) c x \u2261 a\n    leftInv-aux-nn a nothing w c x =\n      rec (encode (sym (\u03b7 _) \u2219 cong g (w \u2219 sym u) \u2219 \u03b7 _))\n    leftInv-aux-nn a (just b) w nothing x =\n      rec (encode (sym (\u03b5 _) \u2219 cong f (x \u2219 sym v) \u2219 \u03b5 _))\n    leftInv-aux-nn a (just b) w (just c) x =\n      encode (sym x \u2219 sym (cong g w) \u2219 \u03b7 _)\n\n    aux-nn : Iso A B\n    fun aux-nn a = fun-aux-nn a _ refl\n    inv aux-nn b = inv-aux-nn b _ refl\n    rightInv aux-nn b = rightInv-aux-nn b _ refl _ refl\n    leftInv aux-nn a = leftInv-aux-nn a _ refl _ refl\n\n  module _ (b0 : B) (u : f nothing \u2261 just b0)\n           (a0 : A) (v : g nothing \u2261 just a0) where\n    fun-aux-jj : (a : A) -> (b : Maybe B) -> B\n    fun-aux-jj a nothing  = b0\n    fun-aux-jj a (just b) = b\n\n    inv-aux-jj : (b : B) -> (a : Maybe A) -> A\n    inv-aux-jj b nothing  = a0\n    inv-aux-jj b (just a) = a\n\n    rightInv-aux-jj : (b : B) ->\n                      (a : Maybe A) -> g (just b) \u2261 a ->\n                      (c : Maybe B) -> f (just (inv-aux-jj b a)) \u2261 c ->\n                      fun-aux-jj (inv-aux-jj b a) c \u2261 b\n    rightInv-aux-jj b nothing w nothing x =\n      encode (sym u \u2219 sym (cong f w) \u2219 \u03b5 _)\n    rightInv-aux-jj b nothing w (just c) x =\n      rec (encode (sym x \u2219 sym (cong f v) \u2219 \u03b5 _))\n    rightInv-aux-jj b (just a) w nothing x =\n      rec (encode (sym (\u03b5 _) \u2219 cong f w \u2219 x))\n    rightInv-aux-jj b (just a) w (just c) x =\n      encode (sym x \u2219 sym (cong f w) \u2219 \u03b5 _)\n\n    leftInv-aux-jj : (a : A) ->\n                     (b : Maybe B) -> f (just a) \u2261 b ->\n                     (c : Maybe A) -> g (just (fun-aux-jj a b)) \u2261 c ->\n                     inv-aux-jj (fun-aux-jj a b) c \u2261 a\n    leftInv-aux-jj a nothing w nothing x =\n      encode (sym v \u2219 sym (cong g w) \u2219 \u03b7 _)\n    leftInv-aux-jj a nothing w (just c) x =\n      rec (encode (sym x \u2219 sym (cong g u) \u2219 \u03b7 _))\n    leftInv-aux-jj a (just b) w nothing x =\n      rec (encode (sym (\u03b7 _) \u2219 cong g w \u2219 x))\n    leftInv-aux-jj a (just b) w (just c) x =\n      encode (sym x \u2219 sym (cong g w) \u2219 \u03b7 _)\n\n    aux-jj : Iso A B\n    fun aux-jj a = fun-aux-jj a (f (just a))\n    inv aux-jj b = inv-aux-jj b (g (just b))\n    rightInv aux-jj b = rightInv-aux-jj b _ refl _ refl\n    leftInv aux-jj a = leftInv-aux-jj a _ refl _ refl\n\n\n  aux : (b : Maybe B) -> f nothing \u2261 b ->\n        (a : Maybe A) -> g nothing \u2261 a ->\n        Iso A B\n  aux nothing  u nothing   v = aux-nn u v\n  aux nothing  v (just a)  w = rec (encode (sym w \u2219 sym (cong g v) \u2219 \u03b7 _))\n  aux (just b) v nothing   w = rec (encode (sym v \u2219 sym (cong f w) \u2219 \u03b5 _))\n  aux (just b) v (just a)  w = aux-jj b v a w \n\n\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective {A} {B} p = isoToPath (MaybeInjective.aux (equivToIso (pathToEquiv p)) _ refl _ refl)\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":439,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\n\n-- maybe helpful\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\nopen import Cubical.Data.Empty\nopen import Cubical.Data.Unit\nopen import Cubical.Data.Sum\n\nprivate variable A B : Set\n                 a b : A\n\njust\u2262nothing : \u2200{\u2113}{C : Set \u2113}{a : A} \u2192 just a \u2261 nothing \u2192 C\njust\u2262nothing {A = A}{\u2113}{C} p = transport (cong f p) (lift tt)\n  where f : Maybe A \u2192 Set \u2113\n        f (just _) = Lift Unit\n        f nothing = C\n\nmodule _ (i : Iso (Maybe A)(Maybe B)) where\n  open Iso i\n\n  nothing-cases : (fun nothing \u2261 nothing) \u228e (\u03a3 B \u03bb b \u2192 fun nothing \u2261 just b)\n  nothing-cases with fun nothing\n  ... | nothing = inl refl\n  ... | just b = inr (b , refl)\n\n  module CaseNothingCore (case-nothing : fun nothing \u2261 nothing) where\n    inv-nothing : inv nothing \u2261 nothing\n    inv-nothing = inv nothing \u2261\u27e8 cong inv case-nothing \u207b\u00b9 \u27e9\n                  inv (fun nothing) \u2261\u27e8 leftInv nothing \u27e9\n                  nothing \u220e\n\n    fun-just\u2262nothing : \u2200{\u2113}{C : Set \u2113} \u2192 fun (just a) \u2261 nothing \u2192 C\n    fun-just\u2262nothing {a} p = \u22a5-elim (just\u2262nothing (\n      just a \u2261\u27e8 leftInv (just a) \u207b\u00b9 \u27e9\n      inv (fun (just a)) \u2261\u27e8 cong inv p \u27e9\n      inv nothing \u2261\u27e8 inv-nothing \u27e9\n      nothing \u220e))\n\n    forward : A \u2192 B\n    forward a with fun (just a) | inspect fun (just a)\n    ... | just b | _ = b\n    ... | nothing | [ eq ] = fun-just\u2262nothing eq\n\n  module CaseJustCore (case-just : fun nothing \u2261 just b) where\n    inv-just : \u03a3 A \u03bb a \u2192 inv nothing \u2261 just a\n    inv-just with inv nothing | inspect inv nothing\n    ... | nothing | [ eq ] = \u22a5-elim (just\u2262nothing (\n      just b \u2261\u27e8 case-just \u207b\u00b9 \u27e9\n      fun nothing \u2261\u27e8 cong fun (eq \u207b\u00b9) \u27e9\n      fun (inv nothing) \u2261\u27e8 rightInv nothing \u27e9\n      nothing \u220e))\n    ... | just a | _ = a , refl\n\n    forward : A \u2192 B\n    forward a = fromMaybe b (fun (just a))\n\njust-injective : {a : A} \u2192 just a \u2261 just b \u2192 a \u2261 b\njust-injective {A = A}{a = a} p = cong f p\n  where f : Maybe A \u2192 A\n        f (just x) = x\n        f nothing = a\n\ninvIso' : \u2200 {\u2113 \u2113'} {X : Type \u2113} {Y : Type \u2113'} \u2192 Iso X Y \u2192 Iso Y X\nIso.fun (invIso' isom) = Iso.inv isom\nIso.inv (invIso' isom) = Iso.fun isom\nIso.rightInv (invIso' isom) = Iso.leftInv isom\nIso.leftInv (invIso' isom) = Iso.rightInv isom\n\nmodule _ (i : Iso (Maybe A)(Maybe B)) where\n  open Iso i\n\n  module CaseNothing' (case-fun-nothing : fun nothing \u2261 nothing)\n                      (case-inv-nothing : inv nothing \u2261 nothing) where\n    open CaseNothingCore\n\n    i\u207b\u00b9 = invIso' i\n    f = forward i case-fun-nothing\n    f\u207b\u00b9 = forward i\u207b\u00b9 case-inv-nothing\n\n    fLeftInv : \u2200 a \u2192 f\u207b\u00b9 (f a) \u2261 a\n    fLeftInv a with fun (just a) | inspect fun (just a)\n    ... | just b | [ eq-b ] with inv (just b) | inspect inv (just b)\n    ... | just a' | [ eq-a ] = just-injective (\n      just a' \u2261\u27e8 eq-a \u207b\u00b9 \u27e9\n      inv (just b) \u2261\u27e8 cong inv eq-b \u207b\u00b9 \u27e9\n      inv (fun (just a)) \u2261\u27e8 leftInv (just a) \u27e9\n      just a \u220e)\n    ... | nothing | [ eq ] = fun-just\u2262nothing i\u207b\u00b9 case-inv-nothing eq\n    fLeftInv a | nothing | [ eq ] = fun-just\u2262nothing i case-fun-nothing eq\n\n  module CaseJust' (case-fun-just : fun nothing \u2261 just b)\n                   (case-inv-just : inv nothing \u2261 just a) where\n    open CaseJustCore\n\n    i\u207b\u00b9 = invIso' i\n    f = forward i case-fun-just\n    f\u207b\u00b9 = forward i\u207b\u00b9 case-inv-just\n\n    fLeftInv : \u2200 a \u2192 f\u207b\u00b9 (f a) \u2261 a\n    fLeftInv a' with fun (just a') | inspect fun (just a')\n    ... | nothing | [ eq ] with inv nothing | inspect inv nothing\n    ... | nothing | [ eq' ] = just\u2262nothing (case-inv-just \u207b\u00b9)\n    ... | just a\u2033 | [ eq' ] = subst (\u03bb k \u2192 fromMaybe a k \u2261 a') (\n        nothing \u2261\u27e8 leftInv nothing \u207b\u00b9 \u27e9\n        inv (fun nothing) \u2261\u27e8 cong inv case-fun-just \u27e9\n        inv (just b) \u220e)\n      (just-injective (\n        just a \u2261\u27e8 case-inv-just \u207b\u00b9 \u27e9\n        just a\u2033 \u2261\u27e8 eq' \u207b\u00b9 \u27e9\n        inv nothing \u2261\u27e8 cong inv (eq \u207b\u00b9) \u27e9\n        inv (fun (just a')) \u2261\u27e8 leftInv (just a') \u27e9\n        just a' \u220e))\n    fLeftInv a | just b' | [ eq ] with inv (just b') | inspect inv (just b')\n    ... | nothing | [ eq' ] = just\u2262nothing (\n      just a \u2261\u27e8 leftInv (just a) \u207b\u00b9 \u27e9\n      inv (fun (just a)) \u2261\u27e8 cong inv eq \u27e9\n      inv (just b') \u2261\u27e8 eq' \u27e9\n      nothing \u220e)\n    ... | just a' | [ eq' ] = just-injective (\n      just a' \u2261\u27e8 eq' \u207b\u00b9 \u27e9\n      inv (just b') \u2261\u27e8 cong inv eq \u207b\u00b9 \u27e9\n      inv (fun (just a)) \u2261\u27e8 leftInv (just a) \u27e9\n      just a \u220e)\n\nmodule _ (i : Iso (Maybe A)(Maybe B)) where\n  open Iso i\n\n  module CaseNothing (case-fun-nothing : fun nothing \u2261 nothing) where\n    open CaseNothingCore i case-fun-nothing using (inv-nothing)\n    \n    open CaseNothing' i case-fun-nothing inv-nothing public\n    open CaseNothing' i\u207b\u00b9 inv-nothing case-fun-nothing\n      renaming (fLeftInv to fRightInv) using () public\n  \n  module CaseJust (case-fun-just : fun nothing \u2261 just b) where\n    open CaseJustCore i case-fun-just using (inv-just)\n    \n    open CaseJust' i case-fun-just (snd inv-just) public\n    open CaseJust' i\u207b\u00b9 (snd inv-just) case-fun-just\n      renaming (fLeftInv to fRightInv) using () public\n  \npathToIso' : \u2200 {\u2113} {A B : Type \u2113} \u2192 A \u2261 B \u2192 Iso A B\npathToIso' x = iso (transport x) (transport\u207b x ) ( transportTransport\u207b x) (transport\u207bTransport x)\n\nmodule _ (p : Maybe A \u2261 Maybe B) where\n  i = pathToIso' p\n  open Iso i\n\n  maybeInjective : A \u2261 B\n  maybeInjective with nothing-cases i\n  ... | inl case-nothing = isoToPath (iso f f\u207b\u00b9 fRightInv fLeftInv)\n    where open CaseNothing i case-nothing\n  ... | inr (b , case-just) = isoToPath (iso f f\u207b\u00b9 fRightInv fLeftInv)\n    where open CaseJust i case-just\n\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":440,"user_id":null,"body":"{-# OPTIONS --cubical --safe #-}\nmodule MaybeInjective where\n\nopen import Data.Maybe\nopen import Cubical.Core.Everything\nopen import Cubical.Foundations.Everything\nopen import Cubical.Data.Everything hiding (Iso)\n\n-- maybe helpful\nrecord Reveal_\u00b7_is_ {a b} {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {a b} {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\ncaseMaybe : {k l : Level} \u2192 {A : Set k} \u2192 {B : Set l} \u2192 (n j : B) \u2192 Maybe A \u2192 B\ncaseMaybe n _ nothing  = n\ncaseMaybe _ j (just _) = j\n\nfromJust-def : {l : Level} \u2192 {A : Set l} \u2192 A \u2192 Maybe A \u2192 A\nfromJust-def a nothing = a\nfromJust-def _ (just a) = a\n\njust-inj : {l : Level} \u2192 (A B : Set l) \u2192 (x y : A) \u2192 just x \u2261 just y \u2192 x \u2261 y\njust-inj _ _ x _ eq = cong (fromJust-def x) eq\n\n\u00ac-just-nothing : {A B : Set} \u2192 (a : A) \u2192 just a \u2261 nothing \u2192 B\n\u00ac-just-nothing {A = A} a p = \u22a5-elim (transp (\u03bb i \u2192 caseMaybe \u22a5 A (p i)) i0 a)\n\nopen Iso\n\nmodule _ {A B : Set} (f : Iso (Maybe A) (Maybe B)) where\n\n    f-inj : \u2200 a\u2081 a\u2082 \u2192 fun f a\u2081 \u2261 fun f a\u2082 \u2192 a\u2081 \u2261 a\u2082\n    f-inj a\u2081 a\u2082 q = (sym (leftInv f a\u2081)) \u2219 ((cong (inv f) q) \u2219 (leftInv f a\u2082))\n\n    f-inv : \u2200 a b \u2192 fun f a \u2261 b \u2192 inv f b \u2261 a\n    f-inv a b q = cong (inv f) (sym q) \u2219 leftInv f a\n\n    isEasy : Set\n    isEasy = \u2200 a \u2192 \u03a3[ b \u2208 B ] fun f (just a) \u2261 just b\n\n    isHard : Set\n    isHard = \u03a3[ a \u2208 A ] fun f (just a) \u2261 nothing\n\n    inverse : Iso (Maybe B) (Maybe A)\n    inverse = iso (inv f) (fun f) (leftInv f) (rightInv f)\n\nmodule _ {A B : Set} (f : Iso (Maybe A) (Maybe B)) where\n\n    easy-or-hard : isEasy f \u228e isHard f\n    easy-or-hard with fun f nothing | inspect (fun f) nothing\n    ...             | nothing       | [ r ] = inl e\n      where\n        e : isEasy f\n        e a with fun f (just a) | inspect (fun f) (just a)\n        ...    | nothing        | [ s ] = \u00ac-just-nothing a ((sym (f-inv f (just a) nothing s)) \u2219 (f-inv f nothing nothing r))\n        ...    | just b         | [ s ] = b , refl\n    ...             | just b        | [ r ] with inv f nothing | inspect (inv f) nothing\n    ...                                        | nothing       | [ s ] = \u00ac-just-nothing b ((sym r) \u2219 (f-inv (inverse f) nothing nothing s))\n    ...                                        | just a        | [ s ] = inr (a , f-inv (inverse f) nothing (just a) s)\n\n    easy-nothing : isEasy f \u2192 fun f nothing \u2261 nothing\n    easy-nothing p with fun f nothing | inspect (fun f) nothing\n    ...                 | nothing | [ q ] = refl\n    ...                 | just b  | [ q ] with inv f nothing | inspect (inv f) nothing\n    ...                                      | nothing       | [ r ] = (sym q) \u2219 (f-inv (inverse f) nothing nothing r)\n    ...                                      | just a        | [ r ] with p a\n    ...                                                                 | (b' , \u03b2) = \u00ac-just-nothing b' ((sym \u03b2) \u2219 (f-inv (inverse f) nothing (just a) r))\n\n    easy-absurd : {C : Set} \u2192 isEasy f \u2192 \u2200 a \u2192 fun f (just a) \u2261 nothing \u2192 C\n    easy-absurd p a q = \u00ac-just-nothing (fst (p a)) ((sym (snd (p a))) \u2219 q)\n\n    hard-nothing : {C : Set} \u2192 isHard f \u2192 fun f nothing \u2261 nothing \u2192 C\n    hard-nothing (a , \u03b1) p = \u00ac-just-nothing a ((sym (f-inv f (just a) nothing \u03b1)) \u2219 (f-inv f nothing nothing p))\n\n    easy-easy : isEasy f \u2192 isEasy (inverse f)\n    easy-easy p b with inv f (just b) | inspect (inv f) (just b)\n    ...              | nothing        | [ q ] = \u00ac-just-nothing b ((sym (f-inv (inverse f) (just b) nothing q)) \u2219 (easy-nothing p))\n    ...              | just a         | [ q ] = a , refl\n\n    hard-hard : isHard f \u2192 isHard (inverse f)\n    hard-hard (a , p) with fun f nothing | inspect (fun f) nothing\n    ...                        | nothing       | [ r ] = hard-nothing (a , p) r\n    ...                        | just b        | [ r ] = b , (f-inv f nothing (just b) r)\n\n    easy-A\u2192B : isEasy f \u2192 A \u2192 B\n    easy-A\u2192B p a = fst (p a)\n\n    hard-A\u2192B : isHard f \u2192 A \u2192 B\n    hard-A\u2192B (a , p) a' with fun f (just a') | inspect (fun f) (just a')\n    ...                    | nothing         | [ r ] = fst (hard-hard (a , p))\n    ...                    | just b          | [ r ] = b\n\nmodule Easy {A B : Set} (f : Iso (Maybe A) (Maybe B)) (p : isEasy f) where\n\n    A\u2192B : A \u2192 B\n    A\u2192B = easy-A\u2192B f p\n\n    B\u2192A : B \u2192 A\n    B\u2192A = easy-A\u2192B (inverse f) (easy-easy f p)\n    \n    A\u2192B\u2192A : \u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a\n    A\u2192B\u2192A a with p a\n    ...        | (b , q) with easy-easy f p b\n    ...                     | (a' , r) = just-inj A A a' a ((sym r) \u2219 (f-inv f (just a) (just b) q))\n\nmodule Hard {A B : Set} (f : Iso (Maybe A) (Maybe B)) (p : isHard f) where\n\n    A\u2192B : A \u2192 B\n    A\u2192B = hard-A\u2192B f p\n\n    B\u2192A : B \u2192 A\n    B\u2192A = hard-A\u2192B (inverse f) (hard-hard f p)\n    \n    A\u2192B\u2192A : \u2200 a \u2192 B\u2192A (A\u2192B a) \u2261 a\n    A\u2192B\u2192A a with fun f nothing | inspect (fun f) nothing\n    ...        | nothing       | [ \u03b2 ] = hard-nothing f p \u03b2\n    ...        | just b'       | [ \u03b2 ] with fun f (just a) | inspect (fun f) (just a)\n    ...                                   | nothing        | [ r ] with hard-hard f p\n    ...                                                               | (b'' , \u03b2') with inv f (just b'') | inspect (inv f) (just b'')\n    ...                                                                               | just a'          | [ s ] = \u00ac-just-nothing a' \u03b2'\n    ...                                                                               | nothing          | [ s ] with inv f nothing | inspect (inv f) nothing\n    ...                                                                                                             | nothing       | [ t ] = \n        hard-nothing (inverse f) (hard-hard f p) t\n    ...                                                                                                             | just a'       | [ t ] = \n        just-inj A A a' a ((sym t) \u2219 (f-inv f (just a) nothing r))\n\n    A\u2192B\u2192A a    | just _        | [ _ ]    | just b         | [ r ] with inv f (just b) | inspect (inv f) (just b)\n    ...                                                               | just a'        | [ s ] = just-inj A A a' a ((sym s) \u2219 (f-inv f (just a) (just b) r))\n    ...                                                               | nothing        | [ s ] = \u00ac-just-nothing a ((sym (f-inv f (just a) (just b) r)) \u2219 s)\n\nmodule EasyIso {A B : Set} (f : Iso (Maybe A) (Maybe B)) (p : isEasy f) where\n\n    private\n\n        ab : A \u2192 B\n        ab = Easy.A\u2192B f p\n\n        ba : B \u2192 A\n        ba = Easy.B\u2192A f p\n\n        aba : \u2200 a \u2192 ba (ab a) \u2261 a\n        aba = Easy.A\u2192B\u2192A f p\n\n        ab' : \u2200 a \u2192 ab a \u2261 Easy.B\u2192A (inverse f) (easy-easy f p) a\n        ab' a with fun f (just a) | inspect (fun f) (just a)\n        ...      | nothing        | [ r ] = easy-absurd f p a r\n        ...      | just b         | [ r ] with inv f (just b) | inspect (inv f) (just b)\n        ...                                  | nothing        | [ s ] = easy-absurd (inverse f) (easy-easy f p) b s\n        ...                                  | just a'        | [ s ] = just-inj B B (fst (p a)) b ((sym (snd (p a))) \u2219 r)\n\n        ba' : \u2200 b \u2192 ba b \u2261 Easy.A\u2192B (inverse f) (easy-easy f p) b\n        ba' b = refl\n\n        bab : \u2200 b \u2192 ab (ba b) \u2261 b\n        bab b = (ab' (ba b)) \u2219 (Easy.A\u2192B\u2192A (inverse f) (easy-easy f p) b)\n\n    A\u2261B : A \u2261 B\n    A\u2261B = ua (isoToEquiv (iso ab ba bab aba))\n\nmodule HardIso {A B : Set} (f : Iso (Maybe A) (Maybe B)) (p : isHard f) where\n\n    private\n\n        ab : A \u2192 B\n        ab = Hard.A\u2192B f p\n\n        ba : B \u2192 A\n        ba = Hard.B\u2192A f p\n\n        aba : \u2200 a \u2192 ba (ab a) \u2261 a\n        aba = Hard.A\u2192B\u2192A f p\n\n        ab' : \u2200 a \u2192 ab a \u2261 Hard.B\u2192A (inverse f) (hard-hard f p) a\n        ab' a with fun f (just a) | inspect (fun f) (just a)\n        ...      | just b         | [ r ] = refl\n        ...      | nothing        | [ r ] with fun f nothing | inspect (fun f) nothing\n        ...                                  | just b        | [ s ] = refl\n        ...                                  | nothing       | [ s ] = hard-nothing f p s\n\n        ba' : \u2200 b \u2192 ba b \u2261 Hard.A\u2192B (inverse f) (hard-hard f p) b\n        ba' b = refl\n\n        bab : \u2200 b \u2192 ab (ba b) \u2261 b\n        bab b = (ab' (ba b)) \u2219 (Hard.A\u2192B\u2192A (inverse f) (hard-hard f p) b)\n\n    A\u2261B : A \u2261 B\n    A\u2261B = ua (isoToEquiv (iso ab ba bab aba))\n\nmodule _ {A B : Set} (f : Iso (Maybe A) (Maybe B)) where\n\n    A\u2261B : A \u2261 B\n    A\u2261B with easy-or-hard f\n    ... | inl p = EasyIso.A\u2261B f p\n    ... | inr p = HardIso.A\u2261B f p\n\n-- prove it!\nmaybeInjective : {A B : Set} \u2192 Maybe A \u2261 Maybe B \u2192 A \u2261 B\nmaybeInjective p = A\u2261B (equivToIso (pathToEquiv p))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}],"5ca40e41bfaf24001980d07a":[{"id":441,"user_id":60,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Agda.Primitive renaming (_\u2294_ to \u2113-max)\nopen import Data.Empty\nopen import Data.Nat.Properties\nopen import Function\nopen import Iso\nopen _\u21d4_\nopen _\u00d7_\n\nrecord Reveal_\u00b7_\u2219_is_ {a b} {A : Set a} {B : A \u2192 A \u2192 Set b}\n                    (f : (x y : A) \u2192 B x y) (x y : A) (z : B x y) :\n                    Set (\u2113-max a b) where\n  constructor [_]\n  field eq : f x y \u2261 z\n\ninspect\u2082 : \u2200 {a b} {A : Set a} {B : A \u2192 A \u2192 Set b}\n          (f : (x y : A) \u2192 B x y) (x y : A) \u2192 Reveal f \u00b7 x \u2219 y  is f x y\ninspect\u2082 f x y = [ refl ]\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = bijection-alt \u2115\u2192\u2115\u00d7\u2115 \u2115\u00d7\u2115\u2192\u2115 \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 \u2115\u00d7\u2115\u2192\u2115-inj\n  where succ\u2115\u00d7\u2115 : (\u2115 \u00d7 \u2115) \u2192 (\u2115 \u00d7 \u2115)\n        succ\u2115\u00d7\u2115 (zero , m)  = (suc m , zero)\n        succ\u2115\u00d7\u2115 (suc n , m) = (n , suc m)\n        \u2115\u2192\u2115\u00d7\u2115 : \u2115 \u2192 (\u2115 \u00d7 \u2115)\n        \u2115\u2192\u2115\u00d7\u2115 zero    = (zero , zero)\n        \u2115\u2192\u2115\u00d7\u2115 (suc n) = succ\u2115\u00d7\u2115 (\u2115\u2192\u2115\u00d7\u2115 n)\n        \u2115\u00d7\u2115\u2192\u2115 : (\u2115 \u00d7 \u2115) \u2192 \u2115\n        \u2115\u00d7\u2115\u2192\u2115 (zero , zero)  = zero\n        \u2115\u00d7\u2115\u2192\u2115 (zero , suc m) = suc (suc (m + \u2115\u00d7\u2115\u2192\u2115 (zero , m)))\n        \u2115\u00d7\u2115\u2192\u2115 (suc n , m)    = suc (m + n + \u2115\u00d7\u2115\u2192\u2115 (n , m))\n        wtf : (a b c : \u2115) \u2192 a + suc (b + c) \u2261 a + suc b + c\n        wtf a b c = trans (cong (\u03bb x \u2192 a + x) refl) (sym (+-assoc a (suc b) _))\n        lemma : (n : \u2115 \u00d7 \u2115) \u2192 \u2115\u00d7\u2115\u2192\u2115 (succ\u2115\u00d7\u2115 n) \u2261 suc (\u2115\u00d7\u2115\u2192\u2115 n)\n        lemma (zero , zero)  = refl\n        lemma (zero , suc m) = cong suc (cong suc (trans (cong (\u03bb x \u2192 m + x) (lemma (zero , m))) (+-suc m (\u2115\u00d7\u2115\u2192\u2115 (zero , m)))))\n        lemma (suc zero , m)    = cong (\u03bb x \u2192 suc (suc (x + \u2115\u00d7\u2115\u2192\u2115 (zero , m)))) (sym (+-identity\u02b3 m))\n        lemma (suc (suc n) , m) = cong suc (cong suc (trans (trans (+-assoc m n _) (cong (\u03bb x \u2192 m + x) (trans (cong (\u03bb x \u2192 n + x) (lemma (suc n , m))) (+-suc _ _)))) (wtf _ n _) ))\n        lemma1 : (n m : \u2115) \u2192 m + \u2115\u00d7\u2115\u2192\u2115 (n + m , 0) \u2261 \u2115\u00d7\u2115\u2192\u2115 (n , m)\n        lemma1 zero zero = refl\n        lemma1 zero (suc m) = cong suc (trans (cong (\u03bb x \u2192 m + (suc x)) (lemma1 zero m)) (+-suc _ _))\n        lemma1 (suc n) m = trans (trans (cong (\u03bb x \u2192 m + (suc x)) (trans (+-assoc n m _) (cong (\u03bb x \u2192 n + x) (lemma1 n m)))) (+-suc _ _)) (cong suc (sym (+-assoc m n _)))\n        lemma2 : (n m : \u2115) \u2192 n < m \u2192 n + \u2115\u00d7\u2115\u2192\u2115 (n , 0) < \u2115\u00d7\u2115\u2192\u2115 (m , 0)\n        lemma2 zero (suc m) p = s\u2264s z\u2264n\n        lemma2 (suc n) (suc m) (s\u2264s p) = s\u2264s (<-trans\u02b3 (\u2264-reflexive (+-suc n _)) (+-mono-\u2264-< p (lemma2 n m p)))\n        lemma3 : (n m p q : \u2115) \u2192 m \u2261 q \u2192 n + m \u2261 p + q \u2192 (n , m) \u2261 (p , q)\n        lemma3 n m p q eq0 eq1 = cong\u2082 _,_ (sym (+-cancel\u02b3-\u2261 p n (trans (sym eq1)  (cong (\u03bb x \u2192 n + x) eq0)))) eq0\n        lemma4 : (n m : \u2115) \u2192 n < suc (n + m)\n        lemma4 zero m = s\u2264s z\u2264n\n        lemma4 (suc n) m = s\u2264s (lemma4 n m)\n        n<0 : (n : \u2115) \u2192 (n < 0) \u2192 \u22a5\n        n<0 n ()\n        \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 : (n : \u2115) \u2192 \u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n) \u2261 n\n        \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 zero = refl\n        \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 (suc n) = trans (lemma (\u2115\u2192\u2115\u00d7\u2115 n)) (cong suc (\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 n))\n        \u2115\u00d7\u2115\u2192\u2115-inj : (n m : \u2115 \u00d7 \u2115) \u2192 \u2115\u00d7\u2115\u2192\u2115 n \u2261 \u2115\u00d7\u2115\u2192\u2115 m \u2192 n \u2261 m\n        \u2115\u00d7\u2115\u2192\u2115-inj (n , m) (p , q) eq with  n + m | inspect\u2082 _+_ n m  | p + q | inspect\u2082 _+_ p q | compare (n + m) (p + q)\n        ...| s0 | [ eq0 ] | s1 | [ eq1 ] | greater s1 k  = \u22a5-elim (n<0 _ (+-cancel\u02b3-< _ 0 (<-trans\u02e1 (<-trans\u02b3 (\u2264-reflexive (+-assoc p m _)) (+-mono-\u2264-< (\u2264-reflexive (refl {x = p}))  (+-cancel\u02b3-< _ q (<-trans\u02b3 (\u2264-reflexive (+-assoc m s1 _))  (<-trans\u02e1 (+-mono-\u2264-< (\u2264-reflexive (refl {x = m})) (lemma2 s1 s0 (lemma4 s1 k))) (\u2264-reflexive (trans (trans (trans (sym (cong (\u03bb x \u2192 m + \u2115\u00d7\u2115\u2192\u2115 (x , 0)) eq0)) (lemma1 n m)) eq) (sym (trans (sym (cong (\u03bb x \u2192 q + \u2115\u00d7\u2115\u2192\u2115 (x , 0)) eq1)) (lemma1 p q)))))))))) (\u2264-reflexive eq1))))\n        ...| s  | [ eq0 ] | s  | [ eq1 ] | equal s = lemma3 n m p q (+-cancel\u02b3-\u2261 m _ (trans (trans (trans (sym (cong (\u03bb x \u2192 m + \u2115\u00d7\u2115\u2192\u2115 (x , 0)) eq0)) (lemma1 n m)) eq) (sym (trans (sym (cong (\u03bb x \u2192 q + \u2115\u00d7\u2115\u2192\u2115 (x , 0)) eq1)) (lemma1 p q))))) (trans eq0 (sym eq1))\n        ...| s0 | [ eq0 ] | s1 | [ eq1 ] | less s0 k = \u22a5-elim (n<0 _ (+-cancel\u02b3-< _ 0 (<-trans\u02e1 (<-trans\u02b3 (\u2264-reflexive (+-assoc n q _)) (+-mono-\u2264-< (\u2264-reflexive (refl {x = n}))  (+-cancel\u02b3-< _ m (<-trans\u02b3 (\u2264-reflexive (+-assoc q s0 _))  (<-trans\u02e1 (+-mono-\u2264-< (\u2264-reflexive (refl {x = q})) (lemma2 s0 s1 (lemma4 s0 k))) (\u2264-reflexive (trans (trans (trans (sym (cong (\u03bb x \u2192 q + \u2115\u00d7\u2115\u2192\u2115 (x , 0)) eq1)) (lemma1 p q)) (sym eq)) (sym (trans (sym (cong (\u03bb x \u2192 m + \u2115\u00d7\u2115\u2192\u2115 (x , 0)) eq0)) (lemma1 n m)))))))))) (\u2264-reflexive eq0))))\n\nwtf0 : {a b : \u22a4} \u2192 a \u2261 b\nwtf0 {tt} {tt} = refl\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc zero = Bijection (\u03bb n \u2192 (n , tt)) fst (\u03bb _ \u2192 refl) (\u03bb _ \u2192 cong\u2082 _,_ refl wtf0)\n\u2115\u21d4\u2115^suc (suc n) = Bijection \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n\n  where \u2115\u21d4\u2115\u00d7\u2115^n : \u2115 \u21d4 (\u2115 \u00d7 \u2115^ n)\n        \u2115\u21d4\u2115\u00d7\u2115^n = \u2115\u21d4\u2115^suc n\n        \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n : \u2115 \u2192 \u2115 \u00d7 (\u2115 \u00d7 \u2115^ n)\n        \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n n with A\u2192B \u2115\u21d4\u2115\u00d7\u2115 n\n        ...| (n' , m) = (n' , A\u2192B \u2115\u21d4\u2115\u00d7\u2115^n m)\n        \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 : \u2115 \u00d7 (\u2115 \u00d7 \u2115^ n) \u2192 \u2115\n        \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 (n , m) = B\u2192A \u2115\u21d4\u2115\u00d7\u2115 (n , B\u2192A \u2115\u21d4\u2115\u00d7\u2115^n m)\n        \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 : (n : \u2115) \u2192 \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n n) \u2261 n\n        \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 n with _\u21d4_.A\u2192B \u2115\u21d4\u2115\u00d7\u2115 n | inspect (A\u2192B \u2115\u21d4\u2115\u00d7\u2115) n\n        ...| (n' , m) | [ eq ] = trans (cong (B\u2192A \u2115\u21d4\u2115\u00d7\u2115) (trans (cong (n' ,_) (_\u21d4_.A\u2192B\u2192A \u2115\u21d4\u2115\u00d7\u2115^n m)) (sym eq))) (_\u21d4_.A\u2192B\u2192A \u2115\u21d4\u2115\u00d7\u2115 n)\n        \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n : (m : \u2115 \u00d7 (\u2115 \u00d7 \u2115^ n)) \u2192 \u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n (\u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 m) \u2261 m\n        \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115\u00d7\u2115^n (n , m) with _\u21d4_.A\u2192B \u2115\u21d4\u2115\u00d7\u2115 (\u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115 (n , m)) | inspect (_\u21d4_.A\u2192B \u2115\u21d4\u2115\u00d7\u2115 \u2218 \u2115\u00d7\u2115\u00d7\u2115^n\u2192\u2115) (n , m)\n        ...| (n' , m') | [ eq ] = trans (cong (\u03bb x \u2192 (fst x , _\u21d4_.A\u2192B \u2115\u21d4\u2115\u00d7\u2115^n (snd x))) (trans (sym eq) (_\u21d4_.B\u2192A\u2192B \u2115\u21d4\u2115\u00d7\u2115 (n , _\u21d4_.B\u2192A \u2115\u21d4\u2115\u00d7\u2115^n m)))) (cong (\u03bb x \u2192 (n , x)) (_\u21d4_.B\u2192A\u2192B \u2115\u21d4\u2115\u00d7\u2115^n m))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":442,"user_id":null,"body":"\n\n{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\nopen import Data.Empty\nopen import Relation.Nullary\nopen import Data.Nat.Properties\nopen import Data.Product hiding (_\u00d7_) renaming (_,_ to _,,_)\n\n\nisomorph : {A B : Set} \u2192 (f : A \u2192 B) \u2192 (\u2200 {a\u2081} {a\u2082} \u2192 f a\u2081 \u2261 f a\u2082 \u2192 a\u2081 \u2261 a\u2082) \u2192 (\u2200 b \u2192 \u03a3[ a \u2208 A ] (f a \u2261 b)) \u2192 A \u21d4 B\nisomorph {A} {B} f inj surj = Bijection \n    f \n    (\u03bb b \u2192 proj\u2081 (surj b))\n    (\u03bb a \u2192 inj (proj\u2082 (surj (f a))))\n    (\u03bb b \u2192 proj\u2082 (surj b))\n\n\u00d7\u2261 : {A B : Set} \u2192 {a\u2081 a\u2082 : A} \u2192 {b\u2081 b\u2082 : B} \u2192 a\u2081 \u2261 a\u2082 \u2192 b\u2081 \u2261 b\u2082 \u2192 (a\u2081 , b\u2081) \u2261 (a\u2082 , b\u2082)\n\u00d7\u2261 {A} {B} {a\u2081} {.a\u2081} {b\u2081} {.b\u2081} refl refl = refl\n\netale : (\u2115 \u00d7 \u2115) \u2192 (\u2115 \u00d7 \u2115)\netale (0     , n) = suc n , 0\netale (suc m , n) = m     , suc n\n\nzeroDouble : (x : \u2115 \u00d7 \u2115) \u2192 \u00ac (etale x \u2261 (0 , 0))\nzeroDouble (0     , n) ()\nzeroDouble (suc m , n) ()\n\netale-inj : {x y : \u2115 \u00d7 \u2115} \u2192 etale x \u2261 etale y \u2192 x \u2261 y\netale-inj {zero   , n\u2081} {0      , n\u2082} p = \u00d7\u2261 refl (suc-injective (cong _\u00d7_.fst p))\netale-inj {suc m\u2081 , n\u2081} {suc m\u2082 , n\u2082} p = \u00d7\u2261 (cong (\u03bb { (m , _) \u2192 suc m }) p) (suc-injective (cong _\u00d7_.snd p))\n\n\u2115\u2192\u2115\u00d7\u2115 : \u2115 \u2192 (\u2115 \u00d7 \u2115)\n\u2115\u2192\u2115\u00d7\u2115 0       = 0 , 0\n\u2115\u2192\u2115\u00d7\u2115 (suc n) = etale (\u2115\u2192\u2115\u00d7\u2115 n)\n\n\u2115\u2192\u2115\u00d7\u2115-inj : {m n : \u2115} \u2192 \u2115\u2192\u2115\u00d7\u2115 m \u2261 \u2115\u2192\u2115\u00d7\u2115 n \u2192 m \u2261 n\n\u2115\u2192\u2115\u00d7\u2115-inj {zero}  {zero}  p = refl\n\u2115\u2192\u2115\u00d7\u2115-inj {zero}  {suc n} p = \u22a5-elim (zeroDouble (\u2115\u2192\u2115\u00d7\u2115 n) (sym p))\n\u2115\u2192\u2115\u00d7\u2115-inj {suc m} {zero}  p = \u22a5-elim (zeroDouble (\u2115\u2192\u2115\u00d7\u2115 m) p)\n\u2115\u2192\u2115\u00d7\u2115-inj {suc m} {suc n} p = cong suc (\u2115\u2192\u2115\u00d7\u2115-inj (etale-inj p))\n\nlemma : (l n m : \u2115) \u2192 l \u2261 m + n \u2192 \u03a3[ r \u2208 \u2115 ] (\u2115\u2192\u2115\u00d7\u2115 r \u2261 (m , n))\nlemma 0       n       m p = 0 ,, (\u00d7\u2261 (sym (i+j\u22610\u21d2i\u22610 m (sym p))) (sym (i+j\u22610\u21d2j\u22610 m (sym p))))\nlemma (suc l) 0       m p = let (r ,, q) = lemma l l 0 refl in (suc r) ,, (trans (cong etale q) (cong (\u03bb s \u2192 s , 0) (trans p (+-comm m 0))))\nlemma (suc l) (suc n) m p = let (r ,, q) = lemma (suc l) n (suc m) (trans p (trans (+-comm m (suc n)) (cong suc (+-comm n m)))) in (suc r) ,, (trans (cong etale q) refl)\n\n\u2115\u2192\u2115\u00d7\u2115-surj : (x : \u2115 \u00d7 \u2115) \u2192 \u03a3[ r \u2208 \u2115 ] (\u2115\u2192\u2115\u00d7\u2115 r \u2261 x)\n\u2115\u2192\u2115\u00d7\u2115-surj (m , n) = lemma (m + n) n m refl\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = isomorph \u2115\u2192\u2115\u00d7\u2115 \u2115\u2192\u2115\u00d7\u2115-inj \u2115\u2192\u2115\u00d7\u2115-surj\n\nA\u21d4A\u00d7\u22a4 : \u2200 A \u2192 A \u21d4 (A \u00d7 \u22a4)\nA\u21d4A\u00d7\u22a4 A = Bijection \n    (\u03bb a \u2192 a , tt) \n    _\u00d7_.fst \n    (\u03bb a \u2192 refl) \n    (\u03bb { (a , tt) \u2192 refl })\n\n\u00d7\u21d4 : \u2200 A {B} {C} \u2192 B \u21d4 C \u2192 (A \u00d7 B) \u21d4 (A \u00d7 C)\n\u00d7\u21d4 A i = Bijection \n    (\u03bb { (a , b) \u2192 a , (A\u2192B i b) })\n    (\u03bb { (a , c) \u2192 a , (B\u2192A i c) })\n    (\u03bb { (a , b) \u2192 cong (\u03bb b' \u2192 a , b') (A\u2192B\u2192A i b)})\n    (\u03bb { (a , c) \u2192 cong (\u03bb c' \u2192 a , c') (B\u2192A\u2192B i c)})\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc 0       = A\u21d4A\u00d7\u22a4 \u2115\n\u2115\u21d4\u2115^suc (suc n) = \u21d4-trans \u2115\u21d4\u2115\u00d7\u2115 (\u00d7\u21d4 \u2115 (\u2115\u21d4\u2115^suc n))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":443,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\nopen import Data.Empty\nopen import Data.Nat.Properties\nopen import Data.Product hiding (_\u00d7_) renaming (_,_ to _,,_)\nopen import Relation.Nullary\n\netale : (\u2115 \u00d7 \u2115) \u2192 (\u2115 \u00d7 \u2115)\netale (0     , n) = suc n , 0\netale (suc m , n) = m     , suc n\n\n\u00d7\u2261 : {A B : Set} \u2192 {a\u2081 a\u2082 : A} \u2192 {b\u2081 b\u2082 : B} \u2192 a\u2081 \u2261 a\u2082 \u2192 b\u2081 \u2261 b\u2082 \u2192 (a\u2081 , b\u2081) \u2261 (a\u2082 , b\u2082)\n\u00d7\u2261 {A} {B} {a\u2081} {.a\u2081} {b\u2081} {.b\u2081} refl refl = refl\n\nisomorph : {A B : Set} \u2192 (f : A \u2192 B) \u2192 (\u2200 {a\u2081} {a\u2082} \u2192 f a\u2081 \u2261 f a\u2082 \u2192 a\u2081 \u2261 a\u2082) \u2192 (\u2200 b \u2192 \u03a3[ a \u2208 A ] (f a \u2261 b)) \u2192 A \u21d4 B\nisomorph {A} {B} f inj surj = Bijection \n    f \n    (\u03bb b \u2192 proj\u2081 (surj b))\n    (\u03bb a \u2192 inj (proj\u2082 (surj (f a))))\n    (\u03bb b \u2192 proj\u2082 (surj b))\n\nzero-zero : (x : \u2115 \u00d7 \u2115) \u2192 \u00ac (etale x \u2261 (0 , 0))\nzero-zero (0     , n) ()\nzero-zero (suc m , n) ()\n\netale-inj : {x y : \u2115 \u00d7 \u2115} \u2192 etale x \u2261 etale y \u2192 x \u2261 y\netale-inj {zero   , n\u2081} {0      , n\u2082} p = \u00d7\u2261 refl (suc-injective (cong _\u00d7_.fst p))\netale-inj {suc m\u2081 , n\u2081} {suc m\u2082 , n\u2082} p = \u00d7\u2261 (cong (\u03bb { (m , _) \u2192 suc m }) p) (suc-injective (cong _\u00d7_.snd p))\n\n\u2115\u2192\u2115\u00d7\u2115 : \u2115 \u2192 (\u2115 \u00d7 \u2115)\n\u2115\u2192\u2115\u00d7\u2115 0       = 0 , 0\n\u2115\u2192\u2115\u00d7\u2115 (suc n) = etale (\u2115\u2192\u2115\u00d7\u2115 n)\n\n\u2115\u2192\u2115\u00d7\u2115-inj : {m n : \u2115} \u2192 \u2115\u2192\u2115\u00d7\u2115 m \u2261 \u2115\u2192\u2115\u00d7\u2115 n \u2192 m \u2261 n\n\u2115\u2192\u2115\u00d7\u2115-inj {zero}  {zero}  p = refl\n\u2115\u2192\u2115\u00d7\u2115-inj {zero}  {suc n} p = \u22a5-elim (zero-zero (\u2115\u2192\u2115\u00d7\u2115 n) (sym p))\n\u2115\u2192\u2115\u00d7\u2115-inj {suc m} {zero}  p = \u22a5-elim (zero-zero (\u2115\u2192\u2115\u00d7\u2115 m) p)\n\u2115\u2192\u2115\u00d7\u2115-inj {suc m} {suc n} p = cong suc (\u2115\u2192\u2115\u00d7\u2115-inj (etale-inj p))\n\nlemma : (l n m : \u2115) \u2192 l \u2261 m + n \u2192 \u03a3[ r \u2208 \u2115 ] (\u2115\u2192\u2115\u00d7\u2115 r \u2261 (m , n))\nlemma 0       n       m p = 0 ,, (\u00d7\u2261 (sym (i+j\u22610\u21d2i\u22610 m (sym p))) (sym (i+j\u22610\u21d2j\u22610 m (sym p))))\nlemma (suc l) 0       m p = let (r ,, q) = lemma l l 0 refl in (suc r) ,, (trans (cong etale q) (cong (\u03bb s \u2192 s , 0) (trans p (+-comm m 0))))\nlemma (suc l) (suc n) m p = let (r ,, q) = lemma (suc l) n (suc m) (trans p (trans (+-comm m (suc n)) (cong suc (+-comm n m)))) in (suc r) ,, (trans (cong etale q) refl)\n\n\u2115\u2192\u2115\u00d7\u2115-surj : (x : \u2115 \u00d7 \u2115) \u2192 \u03a3[ r \u2208 \u2115 ] (\u2115\u2192\u2115\u00d7\u2115 r \u2261 x)\n\u2115\u2192\u2115\u00d7\u2115-surj (m , n) = lemma (m + n) n m refl\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = isomorph \u2115\u2192\u2115\u00d7\u2115 \u2115\u2192\u2115\u00d7\u2115-inj \u2115\u2192\u2115\u00d7\u2115-surj\n\nA\u21d4A\u00d7\u22a4 : \u2200 A \u2192 A \u21d4 (A \u00d7 \u22a4)\nA\u21d4A\u00d7\u22a4 A = Bijection \n    (\u03bb a \u2192 a , tt) \n    _\u00d7_.fst \n    (\u03bb a \u2192 refl) \n    (\u03bb { (a , tt) \u2192 refl })\n\n\u00d7\u21d4 : \u2200 A {B} {C} \u2192 B \u21d4 C \u2192 (A \u00d7 B) \u21d4 (A \u00d7 C)\n\u00d7\u21d4 A i = Bijection \n    (\u03bb { (a , b) \u2192 a , (A\u2192B i b) })\n    (\u03bb { (a , c) \u2192 a , (B\u2192A i c) })\n    (\u03bb { (a , b) \u2192 cong (\u03bb b' \u2192 a , b') (A\u2192B\u2192A i b)})\n    (\u03bb { (a , c) \u2192 cong (\u03bb c' \u2192 a , c') (B\u2192A\u2192B i c)})\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc 0       = A\u21d4A\u00d7\u22a4 \u2115\n\u2115\u21d4\u2115^suc (suc n) = \u21d4-trans \u2115\u21d4\u2115\u00d7\u2115 (\u00d7\u21d4 \u2115 (\u2115\u21d4\u2115^suc n))\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":444,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary\nopen import Data.Empty\nopen import Relation.Nullary.Negation \nopen import Data.Product renaming (_\u00d7_ to _\u2227_ ; proj\u2081 to fstP ; proj\u2082 to sndP ; _,_ to _,P_)\nopen import Data.Sum renaming (_\u228e_ to _\u2228_ ; inj\u2081 to orLeft ; inj\u2082 to orRight)\nopen import Data.List \nopen import Data.List.Properties\nopen import Data.Unit hiding (_\u2264_ ; _\u225f_ ) renaming (\u22a4 to \u22a4b ; tt to ttb)\nopen import Induction.WellFounded\nopen import Data.Product.Properties\nopen import Function.Inverse renaming (sym to fsym ; _\u2218_ to _i\u2218_) \nopen import Data.List.Relation.Unary.All renaming (head to allHead)\nopen import Data.List.Relation.Unary.All.Properties\nopen import Data.Maybe\nopen import Agda.Primitive renaming (_\u2294_ to _\u2294\u2113_) \nopen import Function using (_\u2218_)\nopen import Data.Bool hiding (_\u225f_) renaming (T to Tb)\n\nrecord NonZero (n : \u2115) : Set where\n  field\n    nonZero : Tb (not (n \u2261\u1d47 0))\n\nm+n\u22610\u21d2m\u22610 : \u2200 m {n} \u2192 m + n \u2261 0 \u2192 m \u2261 0\nm+n\u22610\u21d2m\u22610 zero eq = refl\n\nm+n\u22610\u21d2n\u22610 : \u2200 m {n} \u2192 m + n \u2261 0 \u2192 n \u2261 0\nm+n\u22610\u21d2n\u22610 m {n} m+n\u22610 = m+n\u22610\u21d2m\u22610 n (trans (+-comm n m) (m+n\u22610))\n\nfst : {A B : Set} \u2192 A \u00d7 B \u2192 A\nfst ab = Iso._\u00d7_.fst ab\n\nsnd : {A B : Set} \u2192 A \u00d7 B \u2192 B\nsnd ab = Iso._\u00d7_.snd ab\n\n0\u22621+n : \u2200 {n} \u2192 0 \u2262 suc n\n0\u22621+n ()\n\n1+n\u22620 : \u2200 {n} \u2192 suc n \u2262 0\n1+n\u22620 ()\n\nm+1+n\u22620 : \u2200 m {n} \u2192 m + suc n \u2262 0\nm+1+n\u22620 m {n} rewrite +-suc m n = \u03bb()\n\n\nm+[n\u2238m]\u2261n : \u2200 {m n} \u2192 m \u2264 n \u2192 m + (n \u2238 m) \u2261 n\nm+[n\u2238m]\u2261n {m} {n} m\u2264n = begin\n  m + (n \u2238 m)  \u2261\u27e8 sym (+-\u2238-assoc m m\u2264n) \u27e9\n  (m + n) \u2238 m  \u2261\u27e8 cong (_\u2238 m) (+-comm m n) \u27e9\n  (n + m) \u2238 m  \u2261\u27e8 m+n\u2238n\u2261m n m \u27e9\n  n            \u220e      where open \u2261-Reasoning\n\n\u230an\/2\u230b\u2264n : \u2200 n \u2192 \u230a n \/2\u230b \u2264 n\n\u230an\/2\u230b\u2264n zero          = z\u2264n\n\u230an\/2\u230b\u2264n (suc zero)    = z\u2264n\n\u230an\/2\u230b\u2264n (suc (suc n)) = s\u2264s (\u2264-step (\u230an\/2\u230b\u2264n n))\n\n\u230an\/2\u230b<n : \u2200 n \u2192 \u230a suc n \/2\u230b < suc n\n\u230an\/2\u230b<n zero    = s\u2264s (z\u2264n)\n\u230an\/2\u230b<n (suc n) = s\u2264s (s\u2264s (\u230an\/2\u230b\u2264n n))\n\ndata Even (n : \u2115) : Set where\n    even : (x : \u2115) \u2192 x * 2 \u2261 n \u2192 Even n \n\n\u00acEven1 : \u00ac Even 1\n\u00acEven1 (even zero p)  = contradiction p 0\u22621+n\n\u00acEven1 (even (suc x) p)  = contradiction (suc-injective p) 1+n\u22620\n\npredEven : {n : \u2115} \u2192 Even (suc (suc n)) \u2192 Even n\npredEven {n} (even (suc x) p) = even x (suc-injective (suc-injective p))\n\nsuc\u00acEven : {n : \u2115} \u2192 \u00ac Even n \u2192 \u00ac Even (suc (suc n))\nsuc\u00acEven {n} \u00acevenN evenSSN = contradiction (predEven evenSSN) \u00acevenN\n\nsucEven : {n : \u2115} \u2192 Even n \u2192 Even (suc (suc n))\nsucEven {n} (even x p) = even (suc x) (cong suc (cong suc p))\n\nevenDec : (n : \u2115) \u2192 Dec (Even n)\nevenDec zero = yes (even 0 refl)\nevenDec (suc zero) = no \u00acEven1\nevenDec (suc (suc n)) with evenDec n\nevenDec (suc (suc n)) | yes evenN = yes (sucEven evenN)\nevenDec (suc (suc n)) | no \u00acevenN = no (suc\u00acEven \u00acevenN)\n\nevenStep : {n : \u2115} \u2192 Even n \u2192 \u00ac Even (suc n)\nevenStep {zero} p = \u00acEven1\nevenStep {suc zero} p = contradiction p \u00acEven1\nevenStep {suc (suc n)} p = suc\u00acEven (evenStep (predEven p))\n\nEven0 : Even 0\nEven0 = even zero refl\n\npred\u00acEven : {n : \u2115} \u2192 \u00ac Even (suc (suc n)) \u2192 \u00ac Even n\npred\u00acEven {n} p p2 = contradiction (sucEven p2) p\n\n\u00acevenStep : {n : \u2115} \u2192 \u00ac Even n \u2192 Even (suc n)\n\u00acevenStep {zero} p = contradiction Even0 p\n\u00acevenStep {suc zero} p = sucEven Even0\n\u00acevenStep {suc (suc n)} p = sucEven (\u00acevenStep (pred\u00acEven p))\n\n\n\u230an*2\/2\u230b\u2261n : {n : \u2115} \u2192 \u230a n * 2 \/2\u230b \u2261 n\n\u230an*2\/2\u230b\u2261n {zero} = refl\n\u230an*2\/2\u230b\u2261n {suc zero} = refl\n\u230an*2\/2\u230b\u2261n {suc (suc n)} = cong suc (cong suc (\u230an*2\/2\u230b\u2261n {n})) \n\n\u230an\/2\u230b*2\u2261n : {n : \u2115} \u2192 Even n \u2192 \u230a n \/2\u230b * 2 \u2261 n\n\u230an\/2\u230b*2\u2261n {n} (even x p) = begin \n                \u230a n \/2\u230b * 2 \u2261\u27e8 cong (\u03bb z \u2192 \u230a z \/2\u230b * 2) (sym p) \u27e9\n                \u230a (x * 2) \/2\u230b * 2 \u2261\u27e8 cong (_* 2) (\u230an*2\/2\u230b\u2261n {x}) \u27e9\n                x * 2 \u2261\u27e8 p \u27e9\n                n       \u220e where open \u2261-Reasoning\n\n\n-- Task 1. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115.\n\n\u230a_\/4\u230b : \u2115 \u2192 \u2115\n\u230a_\/4\u230b n = \u230a (\u230a n \/2\u230b) \/2\u230b\n\n\u230an\/4\u230b\u2264\u230an\/2\u230b : (n : \u2115) \u2192 \u230a n \/4\u230b \u2264 \u230a n \/2\u230b\n\u230an\/4\u230b\u2264\u230an\/2\u230b n = \u230an\/2\u230b\u2264n (\u230a n \/2\u230b)\n\n\u230an\/4\u230b<n : (n : \u2115) \u2192 \u230a (suc n) \/4\u230b < suc n\n\u230an\/4\u230b<n n = \u2264-trans (s\u2264s (\u230an\/4\u230b\u2264\u230an\/2\u230b (suc n))) (\u230an\/2\u230b<n n)\n\nn\u226e0 : \u2200 {n} \u2192 n \u226e 0\nn\u226e0 ()\n\n\n<-WellFounded : (n : \u2115) \u2192 Acc _<_ n\n<-WellFounded n = acc (helper n)\n    where   x\u2264y\u2227y\u2264z : {x y z : \u2115} \u2192 x \u2264 y \u2192 y \u2264 z \u2192 x \u2264 z\n            x\u2264y\u2227y\u2264z {x} {y} {z} x\u2264y y\u2264z = begin \n                x \u2264\u27e8 x\u2264y \u27e9\n                y \u2264\u27e8 y\u2264z \u27e9\n                z       \u220e where open \u2264-Reasoning\n            helper : (n y : \u2115) \u2192 y < n \u2192 Acc _<_ y\n            helper (suc n) .0 (s\u2264s z\u2264n) = acc (\u03bb y y<0 \u2192 contradiction y<0 n\u226e0)\n            helper (suc (suc n)) (suc y) (s\u2264s (s\u2264s y<n)) = \n                acc (\u03bb z z<sy \u2192 helper (suc n) z (x\u2264y\u2227y\u2264z z<sy (s\u2264s y<n)))\n\n\nlowerBit : \u2115 \u2192 \u2115\nlowerBit n with evenDec n\nlowerBit n | yes evenN = 0\nlowerBit n | no \u00acevenN = 1\n\nZ\u00d7\u2115\u2192\u2115helper : (s : \u2115) \u2192 (acc<s : Acc _<_ s) \u2192 \u2115\nZ\u00d7\u2115\u2192\u2115helper zero acc<s = 0\nZ\u00d7\u2115\u2192\u2115helper (suc s) (acc rs) = lowerBit (suc s) + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (suc s) \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s)) )\n\n\u2115,\u2115\u2192\u2115helper : (f : \u2115) \u2192 (s : \u2115) \u2192 (acc<f : Acc _<_ f) \u2192 \u2115\n\u2115,\u2115\u2192\u2115helper zero s acc<f = Z\u00d7\u2115\u2192\u2115helper s (<-WellFounded s)\n\u2115,\u2115\u2192\u2115helper (suc f) s (acc rs) = 2 * lowerBit (suc f) + lowerBit s + 4 * (\u2115,\u2115\u2192\u2115helper \u230a (suc f) \/2\u230b \u230a s \/2\u230b ((rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))) )\n\n\u2115\u00d7\u2115\u2192\u2115helper : (nxn : \u2115 \u00d7 \u2115) \u2192 (acc<f : Acc _<_ (fst nxn)) \u2192 \u2115\n\u2115\u00d7\u2115\u2192\u2115helper nxn acc<f = \u2115,\u2115\u2192\u2115helper (fst nxn) (snd nxn) acc<f\n\n\u2115\u2192\u2115\u00d7\u2115helper : (n : \u2115) \u2192 (acc<n : Acc _<_ n) \u2192 \u2115 \u00d7 \u2115\n\u2115\u2192\u2115\u00d7\u2115helper zero acc<n = 0 , 0\n\u2115\u2192\u2115\u00d7\u2115helper (suc n) (acc rs) = \n    (lowerBit (\u230a (suc n) \/2\u230b) + (2 * fst (\u2115\u2192\u2115\u00d7\u2115helper (\u230a suc n \/4\u230b) (rs \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))) , \n    (lowerBit (suc n) + (2 * snd (\u2115\u2192\u2115\u00d7\u2115helper (\u230a suc n \/4\u230b) ((rs \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))))\n\nZ\u00d7\u2115\u2192\u2115helperAccIrr : (s1 s2 : \u2115) \u2192 (acc<s1 : Acc _<_ s1) \u2192 (acc<s2 : Acc _<_ s2) \u2192 s1 \u2261 s2 \u2192 \n                    Z\u00d7\u2115\u2192\u2115helper s1 acc<s1 \u2261 Z\u00d7\u2115\u2192\u2115helper s2 acc<s2\nZ\u00d7\u2115\u2192\u2115helperAccIrr zero zero acc<s1 acc<s2 eq = refl\nZ\u00d7\u2115\u2192\u2115helperAccIrr (suc s1) (suc s2) (acc rs1) (acc rs2) eq = \n    cong\u2082 (\u03bb z1 z2 \u2192 lowerBit z1 + 4 * z2) \n        eq \n        (Z\u00d7\u2115\u2192\u2115helperAccIrr (\u230a suc s1 \/2\u230b) (\u230a suc s2 \/2\u230b) (rs1 \u230a suc s1 \/2\u230b (\u230an\/2\u230b<n s1)) (rs2 \u230a suc s2 \/2\u230b (\u230an\/2\u230b<n s2)) (cong \u230a_\/2\u230b eq))\n\ncong\u2083 : {\u21131 : Level} {A : Set \u21131} {\u21132 : Level} {B : Set \u21132}\n      {\u21133 : Level} {C : Set \u21133} {\u21134 : Level} {D : Set \u21134} \n      (f : A \u2192 B \u2192 C \u2192 D) {x y : A} {u v : B} \u2192 {a b : C} \u2192\n      x \u2261 y \u2192 u \u2261 v \u2192 a \u2261 b \u2192 f x u a \u2261 f y v b\ncong\u2083 f refl refl refl = refl\n\n\n\u2115,\u2115\u2192\u2115helperAccIrr :     (f1 f2 s1 s2 : \u2115) \u2192 (acc<f1 : Acc _<_ f1) \u2192 (acc<f2 : Acc _<_ f2) \u2192 f1 \u2261 f2 \u2192 s1 \u2261 s2 \u2192 \n                        \u2115,\u2115\u2192\u2115helper f1 s1 acc<f1 \u2261 \u2115,\u2115\u2192\u2115helper f2 s2 acc<f2\n\u2115,\u2115\u2192\u2115helperAccIrr zero zero s1 s2 acc<f1 acc<f2 feq seq rewrite seq = refl\n\u2115,\u2115\u2192\u2115helperAccIrr (suc f1) (suc f2) s1 s2 (acc rs1) (acc rs2) feq seq = \n    cong\u2083 (\u03bb z1 z2 z3 \u2192 2 * lowerBit z1 + lowerBit z2 + 4 * z3) \n        feq \n        seq \n        (\u2115,\u2115\u2192\u2115helperAccIrr \u230a suc f1 \/2\u230b \u230a suc f2 \/2\u230b \u230a s1 \/2\u230b \u230a s2 \/2\u230b \n            (rs1 \u230a suc f1 \/2\u230b (\u230an\/2\u230b<n f1)) (rs2 \u230a suc f2 \/2\u230b (\u230an\/2\u230b<n f2)) (cong \u230a_\/2\u230b feq) (cong \u230a_\/2\u230b seq))\n\n\u2115\u2192\u2115\u00d7\u2115helperAccIrr :     (n1 n2 : \u2115) \u2192 (acc<n1 : Acc _<_ n1) \u2192 (acc<n2 : Acc _<_ n2) \u2192 n1 \u2261 n2 \u2192 \n                        \u2115\u2192\u2115\u00d7\u2115helper n1 acc<n1 \u2261 \u2115\u2192\u2115\u00d7\u2115helper n2 acc<n2\n\u2115\u2192\u2115\u00d7\u2115helperAccIrr zero zero (acc rs1) (acc rs2) eq = refl\n\u2115\u2192\u2115\u00d7\u2115helperAccIrr (suc n1) (suc n2) (acc rs1) (acc rs2) eq = \n    cong\u2082 (\u03bb z1 z2 \u2192 (lowerBit \u230a z1 \/2\u230b + 2 * fst z2) , (lowerBit (z1) + 2 * snd z2)) eq \n        (\u2115\u2192\u2115\u00d7\u2115helperAccIrr (\u230a suc n1 \/4\u230b) (\u230a suc n2 \/4\u230b) (rs1 \u230a suc n1 \/4\u230b (\u230an\/4\u230b<n n1)) (rs2 \u230a suc n2 \/4\u230b (\u230an\/4\u230b<n n2)) (cong \u230a_\/4\u230b eq))\n\nZ\u00d7\u2115\u2192\u2115helperStep : (s : \u2115) \u2192 (acc<s : Acc _<_ s) \u2192 (acc<s\/2 : Acc _<_ \u230a s \/2\u230b) \u2192 Z\u00d7\u2115\u2192\u2115helper s acc<s \u2261 lowerBit s + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a s \/2\u230b acc<s\/2 )\nZ\u00d7\u2115\u2192\u2115helperStep zero (acc rs) acc<s\/2 = refl\nZ\u00d7\u2115\u2192\u2115helperStep (suc s) (acc rs) acc<s\/2 = \n    cong (\u03bb z \u2192 lowerBit (suc s) + 4 * z) (Z\u00d7\u2115\u2192\u2115helperAccIrr \u230a suc s \/2\u230b \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s)) acc<s\/2 refl)\n\n\u2115,\u2115\u2192\u2115helperStep :   (f : \u2115) \u2192 (s : \u2115) \u2192 (acc<f : Acc _<_ f) \u2192 (acc<f\/2 : Acc _<_ \u230a f \/2\u230b) \u2192 \n                    \u2115,\u2115\u2192\u2115helper f s acc<f \u2261 2 * (lowerBit f) + lowerBit s + 4 * (\u2115,\u2115\u2192\u2115helper \u230a f \/2\u230b \u230a s \/2\u230b acc<f\/2)\n\u2115,\u2115\u2192\u2115helperStep zero s acc<f acc<f\/2 = Z\u00d7\u2115\u2192\u2115helperStep s (<-WellFounded s) (<-WellFounded \u230a s \/2\u230b)\n\u2115,\u2115\u2192\u2115helperStep (suc f) s (acc rs) acc<f\/2 = \n    cong (\u03bb z \u2192 2 * lowerBit (suc f) + lowerBit s + 4 * z) \n            (\u2115,\u2115\u2192\u2115helperAccIrr \u230a suc f \/2\u230b \u230a suc f \/2\u230b \u230a s \/2\u230b  \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f)) acc<f\/2 refl refl)\n\n\n\u2115\u2192\u2115\u00d7\u2115helperStep : (n : \u2115) \u2192 (acc<n : Acc _<_ n) \u2192 (acc<n\/4 : Acc _<_ \u230a n \/4\u230b) \u2192 n \u2262 0 \u2192 \n                    \u2115\u2192\u2115\u00d7\u2115helper n acc<n \u2261 \n                        ((lowerBit (\u230a n \/2\u230b) + (2 * fst (\u2115\u2192\u2115\u00d7\u2115helper (\u230a n \/4\u230b) acc<n\/4))) , \n                        (lowerBit (n) + (2 * snd (\u2115\u2192\u2115\u00d7\u2115helper (\u230a n \/4\u230b) acc<n\/4))))\n\u2115\u2192\u2115\u00d7\u2115helperStep zero acc<n acc<n\/4 n\u22620 = contradiction refl n\u22620\n\u2115\u2192\u2115\u00d7\u2115helperStep (suc n) (acc rs) acc<n\/4 n\u22620 = \n    cong (\u03bb z \u2192 (lowerBit \u230a suc n \/2\u230b + 2 * fst z) , (lowerBit (suc n) + 2 * snd z) ) \n        (\u2115\u2192\u2115\u00d7\u2115helperAccIrr (\u230a suc n \/4\u230b) (\u230a suc n \/4\u230b) (rs \u230a suc n \/4\u230b (\u230an\/4\u230b<n n)) (acc<n\/4) refl)\n\n\nlowerBitEven\u22610 : (n : \u2115) \u2192 Even n \u2192 lowerBit n \u2261 0\nlowerBitEven\u22610 n evenN with evenDec n \nlowerBitEven\u22610 n evenN | yes evenN' = refl\nlowerBitEven\u22610 n evenN | no \u00acevenN = contradiction evenN \u00acevenN\n\nlowerBit\u00acEven\u22611 : (n : \u2115) \u2192 \u00ac (Even n) \u2192 lowerBit n \u2261 1\nlowerBit\u00acEven\u22611 n \u00acevenN with evenDec n\nlowerBit\u00acEven\u22611 n \u00acevenN | yes evenN = contradiction evenN \u00acevenN\nlowerBit\u00acEven\u22611 n \u00acevenN | no \u00acevenN' = refl\n\nlowerBit\u22641 : (n : \u2115) \u2192 lowerBit n \u2264 1\nlowerBit\u22641 n with evenDec n\nlowerBit\u22641 n | yes evenN = z\u2264n\nlowerBit\u22641 n | no \u00acevenN = s\u2264s z\u2264n\n\n\n\u00aclowerBit>1 : {n x : \u2115} \u2192 lowerBit n \u2261 2 + x \u2192 \u22a5\n\u00aclowerBit>1 {n} {x} eq = 1+n\u2270n (\u2264-trans (s\u2264s (lowerBit\u22641 n)) helper)\n    where   helper : 2 \u2264 lowerBit n\n            helper = begin\n                2\n                    \u2264\u27e8 s\u2264s (s\u2264s z\u2264n) \u27e9\n                suc (suc x)\n                    \u2261\u27e8 sym eq \u27e9\n                lowerBit n        \u220e where open \u2264-Reasoning \n\n\nlowerBitRemoveLowerBit : (m n : \u2115) \u2192 lowerBit (lowerBit m + 2 * n) \u2261 lowerBit m\nlowerBitRemoveLowerBit m n with evenDec m\nlowerBitRemoveLowerBit m n | yes evenM = lowerBitEven\u22610 (2 * n) (even n (*-comm n 2))\nlowerBitRemoveLowerBit m n | no \u00acevenM = lowerBit\u00acEven\u22611 (suc (2 * n)) (evenStep {2 * n} ((even n (*-comm n 2))))\n\n\u230a2*n\/2\u230b\u2261n : (n : \u2115) \u2192 \u230a 2 * n \/2\u230b \u2261 n\n\u230a2*n\/2\u230b\u2261n zero = refl\n\u230a2*n\/2\u230b\u2261n (suc n) = trans \n    (cong (\u03bb z \u2192 \u230a suc z \/2\u230b) (trans (sym (+-assoc n 1 (n + 0))) (cong (_+ (n + 0)) (+-comm n 1)))) (cong suc (\u230a2*n\/2\u230b\u2261n n))\n\n\n\nEvenN\u230a1+n\/2\u230b\u2261\u230an\/2\u230b : {n : \u2115} \u2192 Even n \u2192 \u230a suc n \/2\u230b \u2261 \u230a n \/2\u230b\nEvenN\u230a1+n\/2\u230b\u2261\u230an\/2\u230b {zero} evenN = refl\nEvenN\u230a1+n\/2\u230b\u2261\u230an\/2\u230b {suc zero} evenN = contradiction evenN \u00acEven1\nEvenN\u230a1+n\/2\u230b\u2261\u230an\/2\u230b {suc (suc n)} evenN = cong suc (EvenN\u230a1+n\/2\u230b\u2261\u230an\/2\u230b {n} (predEven evenN))\n\n\u230alowerBitm+2*n\/2\u230b\u2261n : (m n : \u2115) \u2192 \u230a (lowerBit m + 2 * n) \/2\u230b \u2261 n\n\u230alowerBitm+2*n\/2\u230b\u2261n m n with evenDec m\n\u230alowerBitm+2*n\/2\u230b\u2261n m n | yes evenM = \u230a2*n\/2\u230b\u2261n n\n\u230alowerBitm+2*n\/2\u230b\u2261n m n | no \u00acevenM = trans (EvenN\u230a1+n\/2\u230b\u2261\u230an\/2\u230b {2 * n} (even n (*-comm n 2))) (\u230a2*n\/2\u230b\u2261n n)\n\nn\u22620\u21d2\u230an\/2\u230b<n : {n : \u2115} \u2192 n \u2262 0 \u2192 \u230a n \/2\u230b < n \nn\u22620\u21d2\u230an\/2\u230b<n {zero} n\u22620 = contradiction refl n\u22620\nn\u22620\u21d2\u230an\/2\u230b<n {suc n} n\u22620 = \u230an\/2\u230b<n n\n\nm+2*sn\u22620 : (m n : \u2115) \u2192 m + 2 * (suc n) \u2262 0\nm+2*sn\u22620 m n = m+1+n\u22620 m {n + suc (n + 0)}\n\nZ\u00d7\u2115\u2192\u2115helperLowerBit : (o p : \u2115) \u2192 (acc<o : Acc _<_ (lowerBit o + 2 * p)) \u2192 (acc<p : Acc _<_ p) \u2192 \n                        Z\u00d7\u2115\u2192\u2115helper (lowerBit o + 2 * p) acc<o \u2261 lowerBit o + 4 * Z\u00d7\u2115\u2192\u2115helper p acc<p\nZ\u00d7\u2115\u2192\u2115helperLowerBit o p (acc rs1) (acc rs2) = begin\n    Z\u00d7\u2115\u2192\u2115helper (lowerBit o + 2 * p) (acc rs1)\n        \u2261\u27e8 (Z\u00d7\u2115\u2192\u2115helperStep (lowerBit o + 2 * p) (acc rs1) (subst (Acc _<_) (sym (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) (acc rs2))) \u27e9\n    lowerBit (lowerBit o + 2 * p) + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o) + 2 * p \/2\u230b ((subst (Acc _<_) (sym (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) (acc rs2))))\n        \u2261\u27e8 cong (\u03bb z \u2192 z + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o) + 2 * p \/2\u230b ((subst (Acc _<_) (sym (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) (acc rs2))))) (lowerBitRemoveLowerBit o p)  \u27e9\n    lowerBit o + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o) + 2 * p \/2\u230b ((subst (Acc _<_) (sym (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) (acc rs2))))\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit o + 4 * z) (Z\u00d7\u2115\u2192\u2115helperAccIrr _ _ (((subst (Acc _<_) (sym (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) (acc rs2)))) (acc rs2) (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) \u27e9\n    lowerBit o + 4 * (Z\u00d7\u2115\u2192\u2115helper p (acc rs2))        \u220e where open \u2261-Reasoning \n\n\u2115,\u2115\u2192\u2115helperLowerBit : (m n o p : \u2115) \u2192 (acc<f : Acc _<_ (lowerBit m + 2 * n)) \u2192 (acc<n : Acc _<_ n) \u2192 \n                        \u2115,\u2115\u2192\u2115helper (lowerBit m + 2 * n) (lowerBit o + 2 * p) acc<f \u2261\n                        2 * lowerBit m + lowerBit o + 4 * (\u2115,\u2115\u2192\u2115helper n p acc<n)\n\u2115,\u2115\u2192\u2115helperLowerBit zero zero o p (acc rs) acc<n = Z\u00d7\u2115\u2192\u2115helperLowerBit o p (<-WellFounded (lowerBit o + 2 * p)) (<-WellFounded p)\n\u2115,\u2115\u2192\u2115helperLowerBit zero (suc n) o p (acc rs) acc<n = begin\n    \u2115,\u2115\u2192\u2115helper (2 * (suc n)) (lowerBit o + 2 * p) (acc rs)\n        \u2261\u27e8 refl \u27e9\n    2 * lowerBit (2 * suc n) + lowerBit (lowerBit o + 2 * p) + 4 * ((\u2115,\u2115\u2192\u2115helper \u230a 2 * suc n \/2\u230b \u230a lowerBit o + 2 * p \/2\u230b) (rs \u230a suc (n + suc (n + zero)) \/2\u230b (\u230an\/2\u230b<n (n + suc (n + zero))))  )\n        \u2261\u27e8 cong\u2082 (\u03bb z1 z2 \u2192 2 * z1 + z2 + 4 * ((\u2115,\u2115\u2192\u2115helper \u230a 2 * suc n \/2\u230b \u230a lowerBit o + 2 * p \/2\u230b) ((rs \u230a suc (n + suc (n + zero)) \/2\u230b (\u230an\/2\u230b<n (n + suc (n + zero))))))) (lowerBitEven\u22610 (2 * suc n) (even (suc n) (*-comm (suc n) 2))) (lowerBitRemoveLowerBit o p) \u27e9\n    2 * 0 + lowerBit o + 4 * ((\u2115,\u2115\u2192\u2115helper \u230a 2 * suc n \/2\u230b \u230a lowerBit o + 2 * p \/2\u230b) ((rs \u230a suc (n + suc (n + zero)) \/2\u230b (\u230an\/2\u230b<n (n + suc (n + zero))))))\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit o + 4 * z) (\u2115,\u2115\u2192\u2115helperAccIrr (\u230a 2 * suc n \/2\u230b) (suc n) (\u230a lowerBit o + 2 * p \/2\u230b) p ((rs \u230a suc (n + suc (n + zero)) \/2\u230b (\u230an\/2\u230b<n (n + suc (n + zero))))) acc<n (\u230a2*n\/2\u230b\u2261n (suc n)) (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) \u27e9\n    lowerBit o + 4 * (\u2115,\u2115\u2192\u2115helper (suc n) p acc<n)         \u220e where open \u2261-Reasoning \n\u2115,\u2115\u2192\u2115helperLowerBit (suc m) zero o p (acc rs) acc<n with (lowerBit (suc m)) | inspect lowerBit (suc m)\n\u2115,\u2115\u2192\u2115helperLowerBit (suc m) zero o p (acc rs) acc<n | zero | i = Z\u00d7\u2115\u2192\u2115helperLowerBit o p (<-WellFounded (lowerBit o + 2 * p)) (<-WellFounded p)\n\u2115,\u2115\u2192\u2115helperLowerBit (suc m) zero o p (acc rs) acc<n | suc zero | i = cong (\u03bb z \u2192 suc (suc z)) helper\n    where helper : lowerBit ((lowerBit o) + 2 * p) + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o ) + 2 * p \/2\u230b (<-WellFounded \u230a (lowerBit o) + 2 * p \/2\u230b)) \u2261 lowerBit o + 4 * (Z\u00d7\u2115\u2192\u2115helper p (<-WellFounded p))\n          helper = begin\n            lowerBit ((lowerBit o) + 2 * p) + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o ) + 2 * p \/2\u230b (<-WellFounded \u230a (lowerBit o) + 2 * p \/2\u230b))\n                \u2261\u27e8 cong (\u03bb z \u2192 z + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o ) + 2 * p \/2\u230b (<-WellFounded \u230a (lowerBit o) + 2 * p \/2\u230b))) (lowerBitRemoveLowerBit o p) \u27e9\n            (lowerBit o) + 4 * (Z\u00d7\u2115\u2192\u2115helper \u230a (lowerBit o ) + 2 * p \/2\u230b (<-WellFounded \u230a (lowerBit o) + 2 * p \/2\u230b))\n                \u2261\u27e8 cong (\u03bb z \u2192 lowerBit o + 4 * z) (Z\u00d7\u2115\u2192\u2115helperAccIrr _ _ (<-WellFounded \u230a lowerBit o + (p + (p + zero)) \/2\u230b) (<-WellFounded p) (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) \u27e9\n            (lowerBit o) + 4 * (Z\u00d7\u2115\u2192\u2115helper p (<-WellFounded p))         \u220e where open \u2261-Reasoning \n\u2115,\u2115\u2192\u2115helperLowerBit (suc m) zero o p (acc rs) acc<n | suc (suc q) | [ i ] = \u22a5-elim (\u00aclowerBit>1 {suc m} {q} i)\n\u2115,\u2115\u2192\u2115helperLowerBit (suc m) (suc n) o p (acc rs) acc<n = begin\n    \u2115,\u2115\u2192\u2115helper (lowerBit (suc m) + 2 * (suc n)) (lowerBit o + 2 * p) (acc rs)\n        \u2261\u27e8 \u2115,\u2115\u2192\u2115helperStep (lowerBit (suc m) + 2 * (suc n)) (lowerBit o + 2 * p) (acc rs) ((rs (\u230a lowerBit (suc m) + 2 * (suc n) \/2\u230b) (n\u22620\u21d2\u230an\/2\u230b<n (m+2*sn\u22620 _ _)))) \u27e9\n    2 * (lowerBit (lowerBit (suc m) + 2 * (suc n))) + lowerBit (lowerBit o + 2 * p) + 4 * (\u2115,\u2115\u2192\u2115helper (\u230a ((lowerBit (suc m) + 2 * (suc n))) \/2\u230b) (\u230a lowerBit o + 2 * p \/2\u230b) (rs (\u230a lowerBit (suc m) + 2 * (suc n) \/2\u230b) (n\u22620\u21d2\u230an\/2\u230b<n (m+2*sn\u22620 _ _))))    \n        \u2261\u27e8 cong\u2082 (\u03bb z1 z2 \u2192 2 * z1 + z2 + 4 * (\u2115,\u2115\u2192\u2115helper (\u230a ((lowerBit (suc m) + 2 * (suc n))) \/2\u230b) (\u230a lowerBit o + 2 * p \/2\u230b) ((rs (\u230a lowerBit (suc m) + 2 * (suc n) \/2\u230b) (n\u22620\u21d2\u230an\/2\u230b<n (m+2*sn\u22620 _ _)))))) (lowerBitRemoveLowerBit (suc m) (suc n)) (lowerBitRemoveLowerBit o p) \u27e9\n    2 * (lowerBit (suc m)) + lowerBit o + 4 * (\u2115,\u2115\u2192\u2115helper (\u230a ((lowerBit (suc m) + 2 * (suc n))) \/2\u230b) (\u230a lowerBit o + 2 * p \/2\u230b) ((rs (\u230a lowerBit (suc m) + 2 * (suc n) \/2\u230b) (n\u22620\u21d2\u230an\/2\u230b<n (m+2*sn\u22620 _ _)))))\n        \u2261\u27e8 cong (\u03bb z \u2192 2 * (lowerBit (suc m)) + lowerBit o + 4 * z) (\u2115,\u2115\u2192\u2115helperAccIrr _ _ _ _ ((rs (\u230a lowerBit (suc m) + 2 * (suc n) \/2\u230b) (n\u22620\u21d2\u230an\/2\u230b<n (m+2*sn\u22620 _ _)))) acc<n (\u230alowerBitm+2*n\/2\u230b\u2261n (suc m) (suc n)) (\u230alowerBitm+2*n\/2\u230b\u2261n o p)) \u27e9\n    2 * lowerBit (suc m) + lowerBit o + 4 * (\u2115,\u2115\u2192\u2115helper (suc n) p acc<n)         \u220e where open \u2261-Reasoning \n\n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230bhelper : (n : \u2115) \u2192 \u00ac (Even (suc n)) \u2192 \u230a (suc n) \/2\u230b \u2261 \u230a n \/2\u230b \n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230bhelper zero \u00acevenN = refl\n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230bhelper (suc zero) \u00acevenN = contradiction (sucEven Even0) \u00acevenN\n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230bhelper (suc (suc n)) \u00acevenN = cong suc (\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230bhelper n (pred\u00acEven \u00acevenN))\n\n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230b : (n : \u2115) \u2192  \u00ac (Even n) \u2192 \u230a n \/2\u230b \u2261 \u230a n \u2238 1 \/2\u230b \n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230b zero \u00acevenN = contradiction Even0 \u00acevenN\n\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230b (suc n) \u00acevenN = \u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230bhelper n \u00acevenN\n\n\u00acevenN\u21d2evenN\u22381 : {n : \u2115} \u2192 \u00ac (Even n) \u2192 Even (n \u2238 1)\n\u00acevenN\u21d2evenN\u22381 {zero} \u00acevenN = contradiction Even0 \u00acevenN\n\u00acevenN\u21d2evenN\u22381 {suc n} \u00acevenN = predEven (\u00acevenStep \u00acevenN)\n\n2*\u230an\/2\u230b\u2227\u00acevenN\u2261n\u22381 : (n : \u2115) \u2192 \u00ac (Even n) \u2192 2 * \u230a n \/2\u230b \u2261 n \u2238 1\n2*\u230an\/2\u230b\u2227\u00acevenN\u2261n\u22381 n \u00acevenN = trans \n    (cong (2 *_) (\u230an\/2\u230b\u2227\u00acevenN\u2261\u230an\u22381\/2\u230b n \u00acevenN)) (trans (*-comm 2 \u230a n \u2238 1 \/2\u230b) (\u230an\/2\u230b*2\u2261n {n \u2238 1} (\u00acevenN\u21d2evenN\u22381 \u00acevenN)))\n\n\u00acevenN\u21d21\u2264n : {n : \u2115} \u2192 \u00ac (Even n) \u2192 1 \u2264 n\n\u00acevenN\u21d21\u2264n {zero} \u00acevenN = contradiction Even0 \u00acevenN\n\u00acevenN\u21d21\u2264n {suc n} \u00acevenN = s\u2264s z\u2264n\n\nlowerBit+n\/2\u2261n : (n : \u2115) \u2192 lowerBit n + 2 * \u230a n \/2\u230b \u2261 n\nlowerBit+n\/2\u2261n n with evenDec n\nlowerBit+n\/2\u2261n n | yes evenN = trans (*-comm 2 \u230a n \/2\u230b) (\u230an\/2\u230b*2\u2261n {n} evenN)\nlowerBit+n\/2\u2261n n | no \u00acevenN = trans (cong suc (2*\u230an\/2\u230b\u2227\u00acevenN\u2261n\u22381 n \u00acevenN)) (m+[n\u2238m]\u2261n {1} {n} (\u00acevenN\u21d21\u2264n \u00acevenN))\n\nlowerTwoBits+n\/4\u2261n : (n : \u2115) \u2192 2 * (lowerBit \u230a n \/2\u230b) + lowerBit n + 4 * \u230a n \/4\u230b \u2261 n\nlowerTwoBits+n\/4\u2261n n = begin\n    2 * (lowerBit \u230a n \/2\u230b) + lowerBit n + 4 * \u230a n \/4\u230b\n        \u2261\u27e8 cong (_+ 4 * \u230a n \/4\u230b) (+-comm (2 * (lowerBit \u230a n \/2\u230b)) (lowerBit n))  \u27e9\n    lowerBit n + 2 * (lowerBit \u230a n \/2\u230b) + 4 * \u230a n \/4\u230b \n        \u2261\u27e8 +-assoc (lowerBit n) (2 * (lowerBit \u230a n \/2\u230b)) (4 * \u230a n \/4\u230b)  \u27e9\n    lowerBit n + (2 * (lowerBit \u230a n \/2\u230b) + 4 * \u230a n \/4\u230b) \n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit n + (2 * (lowerBit \u230a n \/2\u230b) + z)) (*-assoc 2 2 \u230a n \/4\u230b)  \u27e9\n    lowerBit n + (2 * (lowerBit \u230a n \/2\u230b) + 2 * (2 * \u230a n \/4\u230b))\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit n + z) (sym ((*-distrib\u02e1-+ 2 (lowerBit \u230a n \/2\u230b) (2 * \u230a n \/4\u230b))))  \u27e9\n    lowerBit n + (2 * ((lowerBit \u230a n \/2\u230b) + 2 * \u230a n \/4\u230b))\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit n + (2 * z)) (lowerBit+n\/2\u2261n \u230a n \/2\u230b)  \u27e9\n    lowerBit n + 2 * \u230a n \/2\u230b \n        \u2261\u27e8 lowerBit+n\/2\u2261n n  \u27e9\n    n        \u220e where open \u2261-Reasoning \n\n\nlowerBit*2 : (f s r : \u2115) \u2192 (lowerBit ((2 * lowerBit f) + lowerBit s + 4 * r)) \u2261 lowerBit s\nlowerBit*2 f s r = begin\n    lowerBit ((2 * lowerBit f) + lowerBit s + 4 * r)\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit (z + 4 * r)) (+-comm (2 * lowerBit f) (lowerBit s))  \u27e9 \n    lowerBit (lowerBit s + (2 * lowerBit f) + 4 * r)\n        \u2261\u27e8 cong lowerBit (+-assoc (lowerBit s) (2 * lowerBit f) (4 * r)) \u27e9 \n    lowerBit (lowerBit s + ((2 * lowerBit f) + 4 * r))\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit (lowerBit s + ((2 * lowerBit f) + z))) (*-assoc 2 2 r)  \u27e9 \n    lowerBit (lowerBit s + ((2 * lowerBit f) + 2 * (2 * r)))\n        \u2261\u27e8 cong (\u03bb z \u2192 lowerBit (lowerBit s + z)) (sym (*-distrib\u02e1-+ 2 (lowerBit f) (2 * r)))  \u27e9 \n    lowerBit (lowerBit s + 2 * (lowerBit f + 2 * r))\n        \u2261\u27e8 lowerBitRemoveLowerBit s (lowerBit f + 2 * r)  \u27e9 \n    lowerBit s        \u220e where open \u2261-Reasoning \n\nlowerBit*4\/2 : (f s r : \u2115) \u2192 (\u230a ((2 * lowerBit f) + lowerBit s + 4 * r) \/2\u230b) \u2261 lowerBit f + 2 * r\nlowerBit*4\/2 f s r = begin\n    (\u230a ((2 * lowerBit f) + lowerBit s + 4 * r) \/2\u230b)\n        \u2261\u27e8 cong (\u03bb z \u2192 \u230a (z + 4 * r) \/2\u230b) (+-comm (2 * lowerBit f) (lowerBit s)) \u27e9 \n    (\u230a (lowerBit s + 2 * lowerBit f + 4 * r) \/2\u230b)\n        \u2261\u27e8 cong (\u03bb z \u2192 \u230a z \/2\u230b) (+-assoc (lowerBit s) (2 * lowerBit f) (4 * r)) \u27e9 \n    (\u230a (lowerBit s + (2 * lowerBit f + 4 * r)) \/2\u230b)\n        \u2261\u27e8 cong (\u03bb z \u2192 (\u230a (lowerBit s + (2 * lowerBit f + z)) \/2\u230b)) (*-assoc 2 2 r) \u27e9 \n    (\u230a (lowerBit s + (2 * lowerBit f + 2 * (2 * r))) \/2\u230b)\n        \u2261\u27e8 cong (\u03bb z \u2192 (\u230a (lowerBit s + z) \/2\u230b)) (sym (*-distrib\u02e1-+ 2 (lowerBit f) (2 * r))) \u27e9 \n    (\u230a (lowerBit s + 2 * (lowerBit f + 2 * r)) \/2\u230b)\n        \u2261\u27e8 (\u230alowerBitm+2*n\/2\u230b\u2261n (s) (lowerBit f + 2 * r)) \u27e9 \n    (lowerBit f + 2 * r)        \u220e where open \u2261-Reasoning \n\n\nlowerBit*4\/4 : (f s r : \u2115) \u2192 (\u230a ((2 * lowerBit f) + lowerBit s + 4 * r) \/4\u230b) \u2261 r\nlowerBit*4\/4 f s r = begin\n    (\u230a ((2 * lowerBit f) + lowerBit s + 4 * r) \/4\u230b)\n        \u2261\u27e8 cong \u230a_\/2\u230b (lowerBit*4\/2 f s r) \u27e9 \n    (\u230a (lowerBit f + 2 * r) \/2\u230b)\n        \u2261\u27e8 \u230alowerBitm+2*n\/2\u230b\u2261n (f) (r) \u27e9 \n    r        \u220e where open \u2261-Reasoning \n\nlowerBit*2\/2 : (f s r : \u2115) \u2192 (lowerBit \u230a ((2 * lowerBit f) + lowerBit s + 4 * r) \/2\u230b) \u2261 lowerBit f\nlowerBit*2\/2 f s r = trans (cong lowerBit (lowerBit*4\/2 f s r)) (lowerBitRemoveLowerBit f r)\n\n\n\u2115\u2192\u2115\u00d7\u2115helperLowerBits\u22620 : (f s r : \u2115) \u2192 (acc<n : Acc _<_ ((2 * lowerBit (f)) + lowerBit s + 4 * r)) \u2192 (acc<r : Acc _<_ r) \u2192 \n                        ((2 * lowerBit (f)) + lowerBit s + 4 * r) \u2262 0 \u2192 \n                        \u2115\u2192\u2115\u00d7\u2115helper ((2 * lowerBit (f)) + lowerBit s + 4 * r) acc<n \u2261 \n                            ((lowerBit (f) + 2 * fst (\u2115\u2192\u2115\u00d7\u2115helper r acc<r)) , \n                            (lowerBit s + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper r acc<r))))\n\u2115\u2192\u2115\u00d7\u2115helperLowerBits\u22620 f s r acc<n acc<r \u22620 = begin\n    \u2115\u2192\u2115\u00d7\u2115helper ((2 * lowerBit (f)) + lowerBit s + 4 * r) acc<n\n        \u2261\u27e8 \u2115\u2192\u2115\u00d7\u2115helperStep ((2 * lowerBit (f)) + lowerBit s + 4 * r) acc<n (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b)) \u22620  \u27e9\n    (((lowerBit \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/2\u230b) + 2 * (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b))))) ,\n            ((lowerBit ((2 * lowerBit (f)) + lowerBit s + 4 * r)) + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b))))))\n        \u2261\u27e8 cong\u2082 (\u03bb z1 z2 \u2192 (z1 + 2 * (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b))))) , (z2 + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b)))))) (lowerBit*2\/2 (f) s r) (lowerBit*2 (f) s r)  \u27e9\n    ((lowerBit (f) + 2 * (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b))))) ,\n            ((lowerBit s) + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper \u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b))))))\n        \u2261\u27e8 cong (\u03bb z \u2192 ((lowerBit (f) + 2 * (fst z)) , ((lowerBit s + 2 * (snd z)))))  (\u2115\u2192\u2115\u00d7\u2115helperAccIrr (\u230a((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b) r (<-WellFounded (\u230a ((2 * lowerBit (f)) + lowerBit s + 4 * r) \/4\u230b)) acc<r ((lowerBit*4\/4 (f) s r)))  \u27e9 \n    (((lowerBit (f) + 2 * fst (\u2115\u2192\u2115\u00d7\u2115helper r acc<r)) ,  (lowerBit s + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper r acc<r)))))        \u220e where open \u2261-Reasoning \n\n\nm*n\u22610\u21d2n\u22610 : \u2200 m n \u2192 {m\u22620 : m \u2262 0} \u2192 m * n \u2261 0 \u2192 n \u2261 0\nm*n\u22610\u21d2n\u22610 0 n {m\u22620} eq = contradiction refl m\u22620\nm*n\u22610\u21d2n\u22610 (suc _) zero eq = refl\n\n2*lowerBit+lowerBit+4*Split : {f s r : \u2115} \u2192 (2 * lowerBit f) + lowerBit s + 4 * r \u2261 0 \u2192 lowerBit f \u2261 0 \u2227 lowerBit s \u2261 0 \u2227 r \u2261 0\n2*lowerBit+lowerBit+4*Split {f} {s} {r} eq = \n    (m+n\u22610\u21d2m\u22610 (lowerBit f) (m+n\u22610\u21d2m\u22610 (2 * lowerBit f) (m+n\u22610\u21d2m\u22610 (2 * lowerBit f + lowerBit s) eq))) ,P \n    ((m+n\u22610\u21d2n\u22610 (2 * lowerBit f) (m+n\u22610\u21d2m\u22610 (2 * lowerBit f + lowerBit s) eq)) ,P \n    m*n\u22610\u21d2n\u22610 4 r {\u03bb ()} (m+n\u22610\u21d2n\u22610 (2 * lowerBit f + lowerBit s) eq))\n\n\u2115\u2192\u2115\u00d7\u2115helperLowerBits : (f s r : \u2115) \u2192 (acc<n : Acc _<_ ((2 * lowerBit (f)) + lowerBit s + 4 * r)) \u2192 (acc<r : Acc _<_ r) \u2192 \n                        \u2115\u2192\u2115\u00d7\u2115helper ((2 * lowerBit (f)) + lowerBit s + 4 * r) acc<n \u2261 \n                            ((lowerBit (f) + 2 * fst (\u2115\u2192\u2115\u00d7\u2115helper r acc<r)) , \n                            (lowerBit s + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper r acc<r))))\n\u2115\u2192\u2115\u00d7\u2115helperLowerBits f s r acc<n acc<r with ((2 * lowerBit (f)) + lowerBit s + 4 * r) \u225f 0\n\u2115\u2192\u2115\u00d7\u2115helperLowerBits f s r acc<n acc<r | yes n\u22610 rewrite n\u22610 | \n        fstP (2*lowerBit+lowerBit+4*Split {f} {s} {r} n\u22610) | \n        fstP (sndP (2*lowerBit+lowerBit+4*Split {f} {s} {r} n\u22610)) | \n        sndP (sndP (2*lowerBit+lowerBit+4*Split {f} {s} {r} n\u22610)) = refl\n\u2115\u2192\u2115\u00d7\u2115helperLowerBits f s r acc<n acc<r | no \u00acn\u22610 = \u2115\u2192\u2115\u00d7\u2115helperLowerBits\u22620 f s r acc<n acc<r \u00acn\u22610\n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115helper :   (n : \u2115) \u2192 (acc<n : Acc _<_ n) \u2192 (acc<f : Acc _<_ (fst (\u2115\u2192\u2115\u00d7\u2115helper n acc<n))) \u2192 \n                    \u2115\u00d7\u2115\u2192\u2115helper (\u2115\u2192\u2115\u00d7\u2115helper n acc<n) acc<f \u2261 n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115helper zero acc<n acc<f = refl\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115helper (suc n) (acc rs1) (acc rs2) = begin\n    \u2115\u00d7\u2115\u2192\u2115helper ((lowerBit \u230a suc n \/2\u230b + 2 * (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n)))))\n            , (lowerBit (suc n) + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n)))))) (acc rs2)\n        \u2261\u27e8 \u2115,\u2115\u2192\u2115helperLowerBit (\u230a suc n \/2\u230b) (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n)))) (suc n) ((snd (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))) (acc rs2) (<-WellFounded (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n)))))  \u27e9\n    2 * (lowerBit \u230a suc n \/2\u230b) + lowerBit (suc n) + 4 *\n            (\u2115,\u2115\u2192\u2115helper\n                (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))\n                (snd (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))\n                (<-WellFounded (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))))\n        \u2261\u27e8 cong (\u03bb z \u2192 2 * (lowerBit \u230a suc n \/2\u230b) + lowerBit (suc n) + 4 * z) (\u2115\u2192\u2115\u00d7\u2115\u2192\u2115helper \u230a suc n \/4\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n)) (<-WellFounded (fst (\u2115\u2192\u2115\u00d7\u2115helper \u230a \u230a suc n \/2\u230b \/2\u230b (rs1 \u230a suc n \/4\u230b (\u230an\/4\u230b<n n))))))  \u27e9\n    2 * (lowerBit \u230a suc n \/2\u230b) + lowerBit (suc n) + 4 * \u230a suc n \/4\u230b\n        \u2261\u27e8 lowerTwoBits+n\/4\u2261n (suc n)  \u27e9\n    suc n        \u220e where open \u2261-Reasoning \n\nZ\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper : (s : \u2115) \u2192 (acc<s : Acc _<_ s) \u2192 (acc<n : Acc _<_ (Z\u00d7\u2115\u2192\u2115helper s acc<s)) \u2192 \n                    (\u2115\u2192\u2115\u00d7\u2115helper (Z\u00d7\u2115\u2192\u2115helper s acc<s) acc<n) \u2261 (0 , s)\nZ\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper zero acc<s acc<n = refl\nZ\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper (suc s) (acc rs) (acc rs2) = \n     (\u2115\u2192\u2115\u00d7\u2115helper (Z\u00d7\u2115\u2192\u2115helper (suc s) (acc rs)) (acc rs2))\n        \u2261\u27e8 \u2115\u2192\u2115\u00d7\u2115helperLowerBits 0 (suc s) (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s))) (acc rs2) (<-WellFounded (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s))))  \u27e9\n    (2 * (fst (\u2115\u2192\u2115\u00d7\u2115helper (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s))) (<-WellFounded (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s)))) ))) ,\n            (lowerBit (suc s) + 2 * snd ((\u2115\u2192\u2115\u00d7\u2115helper (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s))) (<-WellFounded (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s)))) )))   \n        \u2261\u27e8 cong (\u03bb z \u2192 (2 * (fst z) , lowerBit (suc s) + 2 * (snd z))) (Z\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper (\u230a suc s \/2\u230b) ((rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s))) ((<-WellFounded (Z\u00d7\u2115\u2192\u2115helper \u230a suc s \/2\u230b (rs \u230a suc s \/2\u230b (\u230an\/2\u230b<n s)))))) \u27e9\n    (0 , lowerBit (suc s) + 2 * (\u230a suc s \/2\u230b ))\n        \u2261\u27e8 cong (\u03bb z \u2192 (0 , z)) (lowerBit+n\/2\u2261n (suc s))  \u27e9\n    (0 , (suc s))        \u220e where open \u2261-Reasoning \n\n\u2115,\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper : (f s : \u2115) \u2192 (acc<f : Acc _<_ f) \u2192 (acc<n : Acc _<_ (\u2115,\u2115\u2192\u2115helper f s acc<f)) \u2192 \n                    (\u2115\u2192\u2115\u00d7\u2115helper (\u2115,\u2115\u2192\u2115helper f s acc<f) acc<n) \u2261 (f , s)\n\u2115,\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper zero zero acc<f acc<n = refl\n\u2115,\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper zero (suc s) (acc rs) (acc rs2) = Z\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper (suc s) (<-WellFounded (suc s)) (acc rs2)\n\u2115,\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper (suc f) s (acc rs) (acc rs2) = begin\n    \u2115\u2192\u2115\u00d7\u2115helper (2 * (lowerBit (suc f)) + lowerBit s + 4 * (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f)))) (acc rs2)\n        \u2261\u27e8 \u2115\u2192\u2115\u00d7\u2115helperLowerBits (suc f) s (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))) (acc rs2) (<-WellFounded (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))))  \u27e9\n    ((lowerBit (suc f)) + 2 * \n            (fst (\u2115\u2192\u2115\u00d7\u2115helper (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))) \n                (<-WellFounded (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))))))) , \n            (lowerBit s + 2 * (snd (\u2115\u2192\u2115\u00d7\u2115helper (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))) \n                (<-WellFounded (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f)))))))\n        \u2261\u27e8 cong (\u03bb z \u2192 ((lowerBit (suc f)) + 2 * (fst z)) , ((lowerBit s) + 2 * (snd z))) \n            (\u2115,\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper (\u230a suc f \/2\u230b) (\u230a s \/2\u230b) ((rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f))) \n            (<-WellFounded (\u2115,\u2115\u2192\u2115helper \u230a suc f \/2\u230b \u230a s \/2\u230b (rs \u230a suc f \/2\u230b (\u230an\/2\u230b<n f)))))  \u27e9\n    (lowerBit (suc f) + (2 * \u230a suc f \/2\u230b)) , (lowerBit s + (2 * \u230a s \/2\u230b))\n        \u2261\u27e8 cong\u2082 _,_ (lowerBit+n\/2\u2261n (suc f)) (lowerBit+n\/2\u2261n s)  \u27e9\n    (suc f , s)        \u220e where open \u2261-Reasoning \n\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper : (nn : \u2115 \u00d7 \u2115) \u2192 (acc<f : Acc _<_ (fst nn)) \u2192  (acc<n : Acc _<_ (\u2115\u00d7\u2115\u2192\u2115helper nn acc<f))  \u2192 \n                    (\u2115\u2192\u2115\u00d7\u2115helper (\u2115\u00d7\u2115\u2192\u2115helper nn acc<f) acc<n) \u2261 nn\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper (f , s) acc<n acc<f = \u2115,\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper f s acc<n acc<f\n\n\u2115\u00d7\u2115\u2192\u2115 : \u2115 \u00d7 \u2115 \u2192 \u2115\n\u2115\u00d7\u2115\u2192\u2115 nxn = \u2115\u00d7\u2115\u2192\u2115helper nxn (<-WellFounded (fst nxn))\n\n\u2115\u2192\u2115\u00d7\u2115 : \u2115 \u2192 \u2115 \u00d7 \u2115\n\u2115\u2192\u2115\u00d7\u2115 n = \u2115\u2192\u2115\u00d7\u2115helper n (<-WellFounded n)\n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 : (n : \u2115) \u2192 \u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n) \u2261 n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 n = \u2115\u2192\u2115\u00d7\u2115\u2192\u2115helper n (<-WellFounded n) (<-WellFounded (fst (\u2115\u2192\u2115\u00d7\u2115helper n (<-WellFounded n))))\n\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 : (nn : \u2115 \u00d7 \u2115) \u2192 \u2115\u2192\u2115\u00d7\u2115 (\u2115\u00d7\u2115\u2192\u2115 nn) \u2261 nn\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 nn = \u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115helper nn (<-WellFounded (fst nn)) (<-WellFounded (\u2115\u00d7\u2115\u2192\u2115helper nn (<-WellFounded (fst nn))))\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = Bijection \u2115\u2192\u2115\u00d7\u2115 \u2115\u00d7\u2115\u2192\u2115 \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 \u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115 ^ n, where n is finite.\n\nfstnn,tt\u2261\u2115\u00d7\u22a4 : (nn : \u2115 \u00d7 \u22a4) \u2192 (fst nn , tt) \u2261 nn\nfstnn,tt\u2261\u2115\u00d7\u22a4 (nn1 , Iso.tt) = refl\n\n\u2115\u21d4\u2115\u00d7\u22a4 : \u2115 \u21d4 (\u2115 \u00d7 \u22a4)\n\u2115\u21d4\u2115\u00d7\u22a4 = Bijection (\u03bb n \u2192 n , Iso.tt) (\u03bb nn \u2192 fst nn) (\u03bb a \u2192 refl) (fstnn,tt\u2261\u2115\u00d7\u22a4)\n\n\u21d4trans : {A B C : Set} \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\n\u21d4trans {A} {B} {C} (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection B\u2192C C\u2192B B\u2192C\u2192B C\u2192B\u2192C) = \n    Bijection (B\u2192C \u2218 A\u2192B) (B\u2192A \u2218 C\u2192B) \n        (\u03bb a \u2192 trans (cong B\u2192A (B\u2192C\u2192B (A\u2192B a))) (A\u2192B\u2192A a)) \n        (\u03bb b \u2192 trans (cong B\u2192C (B\u2192A\u2192B (C\u2192B b))) (C\u2192B\u2192C b))\n\n\u2115\u00d7\u2115^n\u2192\u2115 : {n : \u2115} \u2192 \u2115 \u00d7 \u2115^ (suc n) \u2192 \u2115\n\u2115\u00d7\u2115^n\u2192\u2115 {zero} (x1 , x2) = \u2115\u00d7\u2115\u2192\u2115 (x1 , (fst x2))\n\u2115\u00d7\u2115^n\u2192\u2115 {suc n} (x1 , x2) = \u2115\u00d7\u2115\u2192\u2115 (x1 , (\u2115\u00d7\u2115^n\u2192\u2115 x2))\n\n\u2115\u2192\u2115\u00d7\u2115^n : {n : \u2115} \u2192 \u2115 \u2192 \u2115 \u00d7 \u2115^ (suc n)\n\u2115\u2192\u2115\u00d7\u2115^n {zero} x = (fst (\u2115\u2192\u2115\u00d7\u2115 x)) , ((snd (\u2115\u2192\u2115\u00d7\u2115 x)) , tt)\n\u2115\u2192\u2115\u00d7\u2115^n {suc n} x = (fst (\u2115\u2192\u2115\u00d7\u2115 x)) , \u2115\u2192\u2115\u00d7\u2115^n {n} ((snd (\u2115\u2192\u2115\u00d7\u2115 x)))\n\n\u2115\u2192\u2115\u00d7\u2115^n\u2192\u2115 : {n : \u2115} \u2192 (a : \u2115) \u2192 \u2115\u00d7\u2115^n\u2192\u2115 {n} (\u2115\u2192\u2115\u00d7\u2115^n {n} a) \u2261 a\n\u2115\u2192\u2115\u00d7\u2115^n\u2192\u2115 {zero} a = \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 a\n\u2115\u2192\u2115\u00d7\u2115^n\u2192\u2115 {suc n} a = trans (cong (\u03bb z \u2192 \u2115\u00d7\u2115\u2192\u2115 (fst (\u2115\u2192\u2115\u00d7\u2115 a) , z)) (\u2115\u2192\u2115\u00d7\u2115^n\u2192\u2115 {n} (snd (\u2115\u2192\u2115\u00d7\u2115 a)))) (\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 a)\n\n\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115^n : {n : \u2115} \u2192 (b : (\u2115 \u00d7 \u2115^ (suc n))) \u2192 \u2115\u2192\u2115\u00d7\u2115^n {n} (\u2115\u00d7\u2115^n\u2192\u2115 {n} b) \u2261 b\n\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115^n {zero} (x1 , (x2 , tt)) = cong (\u03bb z \u2192 fst z , (snd z , tt)) (\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 (x1 , x2))\n\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115^n {suc n} b = trans \n    (cong (\u03bb z \u2192 fst z , (\u2115\u2192\u2115\u00d7\u2115^n (snd (\u2115\u2192\u2115\u00d7\u2115 (\u2115\u00d7\u2115\u2192\u2115 (fst b , \u2115\u00d7\u2115^n\u2192\u2115 (snd b))))))) (\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 (fst b , \u2115\u00d7\u2115^n\u2192\u2115 (snd b))))\n    (trans (cong (\u03bb z \u2192 (fst b , \u2115\u2192\u2115\u00d7\u2115^n (snd z))) (\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 (fst b , \u2115\u00d7\u2115^n\u2192\u2115 (snd b)))) \n    (cong (\u03bb z \u2192 (fst b , z)) (\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115^n {n} (snd b))))\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc zero = \u2115\u21d4\u2115\u00d7\u22a4\n\u2115\u21d4\u2115^suc (suc n) = Bijection (\u2115\u2192\u2115\u00d7\u2115^n) \u2115\u00d7\u2115^n\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115^n\u2192\u2115 {n}) (\u2115\u00d7\u2115^n\u2192\u2115\u2192\u2115\u00d7\u2115^n {n}) ","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":445,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Data.Nat public\nopen import Data.Nat.Properties\nopen import Relation.Binary.PropositionalEquality public\nopen \u2261-Reasoning \nopen import Iso\nopen _\u21d4_\n\n-- Definition of singleton type\n\n-- Task 1. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115.\n\n-- lemmas \neq-product : {A B : Set} {a1 a2 : A} {b1 b2 : B} \u2192 a1 \u2261 a2 \u2192 b1 \u2261 b2 \u2192 \n    (a1 , b1) \u2261 (a2 , b2)  \neq-product refl refl = refl \n\nproduct-bij : {A1 A2 B1 B2 : Set} \u2192 A1 \u21d4 B1 \u2192 A2 \u21d4 B2 \u2192 (A1 \u00d7 A2) \u21d4 (B1 \u00d7 B2) \nproduct-bij h1 h2 = Bijection (pA h1 h2) (pB h1 h2) (pAB h1 h2) (pBA h1 h2) where\n  pA : {A1 A2 B1 B2 : Set} \u2192 A1 \u21d4 B1 \u2192 A2 \u21d4 B2 \u2192 (A1 \u00d7 A2) \u2192 (B1 \u00d7 B2) \n  pA h1 h2 (a\u2081 , a\u2082) = (A\u2192B h1 a\u2081) , (A\u2192B h2 a\u2082)\n\n  pB : {A1 A2 B1 B2 : Set} \u2192 A1 \u21d4 B1 \u2192 A2 \u21d4 B2 \u2192 (B1 \u00d7 B2) \u2192 (A1 \u00d7 A2) \n  pB h1 h2 (b\u2081 , b\u2082) = (B\u2192A h1 b\u2081) , (B\u2192A h2 b\u2082)\n\n  pAB : {A1 A2 B1 B2 : Set} (h1 : A1 \u21d4 B1) (h2 : A2 \u21d4 B2) \u2192 \n    (\u2200 a \u2192 pB h1 h2 (pA h1 h2 a) \u2261 a)\n  pAB h1 h2 (fst\u2081 , snd\u2081) = eq-product (A\u2192B\u2192A h1 fst\u2081) (A\u2192B\u2192A h2 snd\u2081) \n\n  pBA : {A1 A2 B1 B2 : Set} (h1 : A1 \u21d4 B1) (h2 : A2 \u21d4 B2) \u2192 \n    (\u2200 b \u2192 pA h1 h2 (pB h1 h2 b) \u2261 b)\n  pBA h1 h2 (fst\u2081 , snd\u2081) = eq-product (B\u2192A\u2192B h1 fst\u2081) (B\u2192A\u2192B h2 snd\u2081) \n-- \nnext : \u2115 \u00d7 \u2115 \u2192 \u2115 \u00d7 \u2115 \nnext (0 , y) = (suc y , 0)\nnext (suc x , y) = (x , suc y)\n\n\u2115\u2192\u2115\u00d7\u2115 : \u2115 \u2192 \u2115 \u00d7 \u2115\n\u2115\u2192\u2115\u00d7\u2115 zero = 0 , 0\n\u2115\u2192\u2115\u00d7\u2115 (suc n) = next (\u2115\u2192\u2115\u00d7\u2115 n)\n\nsum : \u2115 \u2192 \u2115\nsum 0 = 0\nsum (suc n) = (suc n) + sum n \n\n\u2115\u00d7\u2115\u2192\u2115 : \u2115 \u00d7 \u2115 \u2192 \u2115\n\u2115\u00d7\u2115\u2192\u2115 (x , y) = sum (x + y) + y\n\nlemma : (n : \u2115) (c : \u2115 \u00d7 \u2115) \u2192 \u2115\u00d7\u2115\u2192\u2115 c \u2261 n \u2192 c \u2261 \u2115\u2192\u2115\u00d7\u2115 n \nlemma zero (zero , b) h = eq-product refl (i+j\u22610\u21d2j\u22610 (sum b) h)\nlemma (suc n) (a , b) h with (\u2115\u2192\u2115\u00d7\u2115 n) | inspect \u2115\u2192\u2115\u00d7\u2115 n \nlemma (suc n) (suc a , zero) h | zero , y | [ eq ] =\n   begin \n    (suc a , zero) \n      \u2261\u27e8 refl \u27e9\n    next (zero , a) \n      \u2261\u27e8 cong next (lemma n (zero , a) \n       (begin \n          \u2115\u00d7\u2115\u2192\u2115 (zero , a) \n            \u2261\u27e8 trans (+-comm (sum a) a) (sym (+-identity\u02b3 (a + sum a))) \u27e9 \n          a + sum a + zero\n            \u2261\u27e8 cong (\u03bb x \u2192 x + sum x + zero) (sym (+-identity\u02b3 a)) \u27e9 \n          a + zero + sum (a + zero) + zero\n            \u2261\u27e8 suc-injective h \u27e9 \n          n\n        \u220e) )\u27e9\n    next (\u2115\u2192\u2115\u00d7\u2115 n) \n      \u2261\u27e8 cong next eq \u27e9\n    next (0 , y) \n      \u2261\u27e8 refl \u27e9\n    (suc y , 0)\n  \u220e\nlemma (suc n) (a , suc b) h | zero , y | [ eq ] = cong next (\n  begin \n    (suc a , b )\n      \u2261\u27e8 lemma n (suc a , b) (\n        begin \n          \u2115\u00d7\u2115\u2192\u2115 (suc a , b )\n            \u2261\u27e8 cong (\u03bb x \u2192 sum x + b) (sym (+-suc a b)) \u27e9\n          sum (a + suc b) + b\n            \u2261\u27e8 suc-injective (trans (sym (+-suc (sum (a + suc b)) b)) h) \u27e9 \n          n\n        \u220e)\u27e9\n    \u2115\u2192\u2115\u00d7\u2115 n\n      \u2261\u27e8 eq \u27e9 \n    (zero , y)\n  \u220e)\nlemma (suc n) (suc a , zero) h | suc x , y | [ eq ] = cong next (\n  begin \n    (zero , a )\n      \u2261\u27e8 lemma n (zero , a) (\n        begin \n          \u2115\u00d7\u2115\u2192\u2115 (zero , a )\n            \u2261\u27e8 trans (+-comm (sum a) a) (sym (+-identity\u02b3 (a + sum a))) \u27e9\n          a + sum a + 0\n            \u2261\u27e8 cong (\u03bb x \u2192 x + sum x + 0) (sym (+-identity\u02b3 a)) \u27e9\n          a + zero + sum (a + zero) + zero\n            \u2261\u27e8 suc-injective h \u27e9\n          n\n        \u220e)\u27e9\n    \u2115\u2192\u2115\u00d7\u2115 n\n      \u2261\u27e8 eq \u27e9 \n    (suc x , y)\n  \u220e)\nlemma (suc n) (a , suc b) h | suc x , y | [ eq ] = cong next (\n  begin \n    (suc a , b )\n      \u2261\u27e8 lemma n (suc a , b) (\n        begin \n          \u2115\u00d7\u2115\u2192\u2115 (suc a , b )\n            \u2261\u27e8 cong (\u03bb x \u2192 sum x + b) (sym (+-suc a b)) \u27e9\n          sum (a + suc b) + b\n            \u2261\u27e8 suc-injective (trans (sym (+-suc (sum (a + suc b)) b)) h) \u27e9 \n          n\n        \u220e)\u27e9\n    \u2115\u2192\u2115\u00d7\u2115 n\n      \u2261\u27e8 eq \u27e9 \n    (suc x , y)\n  \u220e)\n\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 : \u2200 p \u2192 \u2115\u2192\u2115\u00d7\u2115 (\u2115\u00d7\u2115\u2192\u2115 p) \u2261 p \n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 (x , y) = sym (lemma (sum (x + y) + y) (x , y) refl)\n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115\u00d7\u2115 : \u2200 n \u2192 \u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n) \u2261 n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115\u00d7\u2115 zero = refl\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115\u00d7\u2115 (suc n) with (\u2115\u2192\u2115\u00d7\u2115 n) | inspect \u2115\u2192\u2115\u00d7\u2115 n \n... | zero , y | [ eq ] = cong suc \n  (begin\n    y + 0 + sum (y + 0) + 0\n      \u2261\u27e8 cong (\u03bb x \u2192 x + sum x + 0) (+-identity\u02b3 y) \u27e9\n    y + sum y + 0\n      \u2261\u27e8 trans (cong (_+ 0) (+-comm y (sum y))) (+-identity\u02b3 (sum y + y)) \u27e9\n    sum y + y\n      \u2261\u27e8 refl \u27e9\n    \u2115\u00d7\u2115\u2192\u2115 (zero , y)\n      \u2261\u27e8 cong \u2115\u00d7\u2115\u2192\u2115 (sym eq) \u27e9\n    \u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n)\n      \u2261\u27e8 \u2115\u2192\u2115\u00d7\u2115\u2192\u2115\u00d7\u2115 n \u27e9\n    n\n  \u220e)\n... | suc x , y | [ eq ] = trans (cong (\u03bb a \u2192 sum a + suc y) (+-suc x y)) \n  (cong suc \n  (begin\n    x + y + sum (x + y) + suc y\n      \u2261\u27e8 +-suc (x + y + sum (x + y)) y \u27e9\n    suc (x + y + sum (x + y) + y)\n      \u2261\u27e8 refl \u27e9\n    \u2115\u00d7\u2115\u2192\u2115 (suc x , y)\n      \u2261\u27e8 cong \u2115\u00d7\u2115\u2192\u2115 (sym eq) \u27e9\n    \u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n)\n      \u2261\u27e8 \u2115\u2192\u2115\u00d7\u2115\u2192\u2115\u00d7\u2115 n \u27e9\n    n\n    \u220e))\n    \n--\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = Bijection \u2115\u2192\u2115\u00d7\u2115 \u2115\u00d7\u2115\u2192\u2115 \u2115\u2192\u2115\u00d7\u2115\u2192\u2115\u00d7\u2115 \u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115 ^ n, where n is finite.\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc zero = Bijection (\u03bb z \u2192 z , tt) (\u03bb {(b , tt) \u2192 b}) (\u03bb a \u2192 refl) \n  (\u03bb {(b , tt) \u2192 refl})\n\u2115\u21d4\u2115^suc (suc n) = \u21d4-trans \u2115\u21d4\u2115\u00d7\u2115 (product-bij \u21d4-refl (\u2115\u21d4\u2115^suc n))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":446,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso renaming (_\u21d4_ to _<->_)\ninfix 0 _\u21d4_\nprivate\n  _\u21d4_ = _<->_\n  module _\u21d4_ = _<->_\nopen _\u21d4_\nopen _\u00d7_\n\nopen import Data.Sum as Sum using (_\u228e_; inj\u2081; inj\u2082; [_,_]\u2032)\nimport Data.Nat as \u2115\nopen import Data.Fin using (Fin; suc; zero)\nopen import Function hiding (id)\n\nprivate variable A B C D A' B' C' D' : Set\n                 k l m n : \u2115\n\ninfix 6 _+1 _+2\npattern _+1 a = suc a\npattern _+2 a = (a +1) +1\n\ninfix  0 _\u25a0\ninfixr -1 step-\u21d4\n\nstep-\u21d4 : (A {B C} : Set) \u2192 A \u21d4 B \u2192 B \u21d4 C \u2192 A \u21d4 C\nstep-\u21d4 A = \u21d4-trans\n\n_\u25a0 : (A : Set) \u2192 A \u21d4 A\n_ \u25a0 = \u21d4-refl\n\nsyntax step-\u21d4 A A\u21d4B B\u21d4C = A \u21d4\u27e8 A\u21d4B \u27e9 B\u21d4C\n\nopen \u2261-Reasoning\n\nmodule Prod where\n  map : (A \u2192 C) \u2192 (B \u2192 D) \u2192 A \u00d7 B \u2192 C \u00d7 D\n  map f g (x , y) = (f x , g y)\n\n  map\u2081 : (A \u2192 C) \u2192 A \u00d7 B \u2192 C \u00d7 B\n  map\u2081 f = map f id\n\n  swap : A \u00d7 B \u2192 B \u00d7 A\n  swap (x , y) = (y , x)\n\n  assoc\u02b3 : (A \u00d7 B) \u00d7 C \u2192 A \u00d7 (B \u00d7 C)\n  assoc\u02b3 ((a , b) , c) = (a , (b , c))\n\n  assoc\u02e1 : A \u00d7 (B \u00d7 C) \u2192 (A \u00d7 B) \u00d7 C\n  assoc\u02e1 (a , (b , c)) = ((a , b) , c)\n\n\n\u21d4-\u00d7-cong : A \u21d4 A' \u2192 B \u21d4 B' \u2192 A \u00d7 B \u21d4 A' \u00d7 B'\n\u21d4-\u00d7-cong\u02e1 : B \u21d4 B' \u2192 A \u00d7 B \u21d4 A \u00d7 B'\n\u21d4-\u00d7-cong\u02b3 : A \u21d4 A' \u2192 A \u00d7 B \u21d4 A' \u00d7 B\nA\u2192B (\u21d4-\u00d7-cong A\u21d4A' B\u21d4B') = Prod.map (A\u21d4A' .A\u2192B) (B\u21d4B' .A\u2192B)\nB\u2192A (\u21d4-\u00d7-cong A\u21d4A' B\u21d4B') = Prod.map (A\u21d4A' .B\u2192A) (B\u21d4B' .B\u2192A)\nA\u2192B\u2192A (\u21d4-\u00d7-cong A\u21d4A' B\u21d4B') (a , b) = cong\u2082 _,_ (A\u21d4A' .A\u2192B\u2192A a)(B\u21d4B' .A\u2192B\u2192A b)\nB\u2192A\u2192B (\u21d4-\u00d7-cong A\u21d4A' B\u21d4B') (a , b) = cong\u2082 _,_ (A\u21d4A' .B\u2192A\u2192B a)(B\u21d4B' .B\u2192A\u2192B b)\n\n\u21d4-\u00d7-cong\u02e1 = \u21d4-\u00d7-cong \u21d4-refl\n\u21d4-\u00d7-cong\u02b3 = flip \u21d4-\u00d7-cong \u21d4-refl\n\n\u21d4-\u228e-cong : A \u21d4 A' \u2192 B \u21d4 B' \u2192 A \u228e B \u21d4 A' \u228e B'\n\u21d4-\u228e-cong\u02e1 : B \u21d4 B' \u2192 A \u228e B \u21d4 A \u228e B'\n\u21d4-\u228e-cong\u02b3 : A \u21d4 A' \u2192 A \u228e B \u21d4 A' \u228e B\nA\u2192B (\u21d4-\u228e-cong A\u21d4A' B\u21d4B') = Sum.map (A\u21d4A' .A\u2192B) (B\u21d4B' .A\u2192B)\nB\u2192A (\u21d4-\u228e-cong A\u21d4A' B\u21d4B') = Sum.map (A\u21d4A' .B\u2192A) (B\u21d4B' .B\u2192A)\nA\u2192B\u2192A (\u21d4-\u228e-cong A\u21d4A' B\u21d4B') (inj\u2081 x) = cong inj\u2081 $ A\u21d4A' .A\u2192B\u2192A x\nA\u2192B\u2192A (\u21d4-\u228e-cong A\u21d4A' B\u21d4B') (inj\u2082 x) = cong inj\u2082 $ B\u21d4B' .A\u2192B\u2192A x\nB\u2192A\u2192B (\u21d4-\u228e-cong A\u21d4A' B\u21d4B') (inj\u2081 x) = cong inj\u2081 $ A\u21d4A' .B\u2192A\u2192B x\nB\u2192A\u2192B (\u21d4-\u228e-cong A\u21d4A' B\u21d4B') (inj\u2082 x) = cong inj\u2082 $ B\u21d4B' .B\u2192A\u2192B x\n\n\u21d4-\u228e-cong\u02e1 = \u21d4-\u228e-cong \u21d4-refl\n\u21d4-\u228e-cong\u02b3 = flip \u21d4-\u228e-cong \u21d4-refl\n\n\u21d4-\u00d7-comm : A \u00d7 B \u21d4 B \u00d7 A\n\u21d4-\u00d7-comm = Bijection Prod.swap Prod.swap (\u03bb _ \u2192 refl)(\u03bb _ \u2192 refl)\n\n-- from standard library\n-- Rewriting non-dependent products\nassoc\u02b3\u2032 : (A \u00d7 B) \u00d7 C \u2192 A \u00d7 (B \u00d7 C)\nassoc\u02b3\u2032 ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1\u2032 : A \u00d7 (B \u00d7 C) \u2192 (A \u00d7 B) \u00d7 C\nassoc\u02e1\u2032 (a , (b , c)) = ((a , b) , c)\n\n\u21d4-\u00d7-assoc : (A \u00d7 B) \u00d7 C \u21d4 A \u00d7 (B \u00d7 C)\n\u21d4-\u00d7-assoc = Bijection assoc\u02b3\u2032 assoc\u02e1\u2032 (\u03bb _ \u2192 refl)(\u03bb _ \u2192 refl)\n\n\u21d4-\u22a4\u00d7 : A \u21d4 (\u22a4 \u00d7 A)\n\u21d4-\u22a4\u00d7 = Bijection (tt ,_) snd (\u03bb _ \u2192 refl) \u03bb { (tt , _) \u2192 refl}\n\n\u22a4\u21d4Fin1 : \u22a4 \u21d4 Fin 1\n\u22a4\u21d4Fin1 = Bijection (const zero) (const tt) (\u03bb {tt \u2192 refl})(\u03bb {zero \u2192 refl})\n\nA\u228eFin\u00d7A\u21d4Fin+1\u00d7A : A \u228e Fin k \u00d7 A \u21d4 Fin (k +1) \u00d7 A\nA\u228eFin\u00d7A\u21d4Fin+1\u00d7A = Bijection\n  [ (zero ,_) , Prod.map\u2081 suc ]\u2032\n  (\u03bb { (zero , a) \u2192 inj\u2081 a\n     ; (suc k , a) \u2192 inj\u2082 (k , a)})\n  (\u03bb { (inj\u2081 _) \u2192 refl ; (inj\u2082 _) \u2192 refl})\n  \u03bb { (zero , _) \u2192 refl ; (suc _ , _) \u2192 refl}\n\n\u2115\u21d4\u2115\u228eFin_ : \u2200 k \u2192 \u2115 \u21d4 \u2115 \u228e Fin k\n\u2115\u21d4\u2115\u228eFin zero = Bijection inj\u2081 [ id , (\u03bb ()) ]\u2032 (\u03bb _ \u2192 refl) \u03bb { (inj\u2081 _) \u2192 refl}\n\u2115\u21d4\u2115\u228eFin (k +1) = \u2115 \u21d4\u27e8 \u2115\u21d4\u2115\u228eFin k \u27e9\n                   \u2115 \u228e Fin k \u21d4\u27e8 \u2115\u228ek\u21d4\u2115\u228ek+1 \u27e9\n                   \u2115 \u228e Fin (k +1)\n                   \u25a0\n  where\n  \u2115\u228ek\u21d4\u2115\u228ek+1 = Bijection\n    [ (\u03bb { zero \u2192 inj\u2082 zero ; (x +1) \u2192 inj\u2081 x}) , inj\u2082 \u2218 suc ]\u2032\n    [ inj\u2081 \u2218 suc , (\u03bb { zero \u2192 inj\u2081 0 ; (suc x) \u2192 inj\u2082 x}) ]\u2032\n    (\u03bb { (inj\u2081 zero) \u2192 refl ; (inj\u2081 (_ +1)) \u2192 refl ; (inj\u2082 _) \u2192 refl})\n    \u03bb { (inj\u2081 _) \u2192 refl ; (inj\u2082 zero) \u2192 refl ; (inj\u2082 (suc _)) \u2192 refl}\n\n\u2115\u21d4\u2115\u228e\u22a4 : \u2115 \u21d4 \u2115 \u228e \u22a4\n\u2115\u21d4\u2115\u228e\u22a4 = \u2115 \u21d4\u27e8 \u2115\u21d4\u2115\u228eFin 1 \u27e9\n         \u2115 \u228e Fin 1 \u21d4\u27e8 \u21d4-\u228e-cong\u02e1 $ \u21d4-sym \u22a4\u21d4Fin1 \u27e9\n         \u2115 \u228e \u22a4 \u25a0\n\n\u2115\u21d4\u2115\u228e\u2115 : \u2115 \u21d4 \u2115 \u228e \u2115\n\u2115\u21d4\u2115\u228e\u2115 = Bijection split join join\u2218split split\u2218join\n  where split : \u2115 \u2192 \u2115 \u228e \u2115\n        split 0 = inj\u2081 0\n        split 1 = inj\u2082 0\n        split (x +2) = Sum.map suc suc (split x)\n        join : \u2115 \u228e \u2115 \u2192 \u2115\n        join (inj\u2081 0) = zero\n        join (inj\u2081 (x +1)) = join (inj\u2081 x) +2\n        join (inj\u2082 0) = 1\n        join (inj\u2082 (x +1)) = join (inj\u2082 x) +2\n        join-map-suc : \u2200 x \u2192 join (Sum.map suc suc x) \u2261 join x +2\n        join-map-suc (inj\u2081 x) = refl\n        join-map-suc (inj\u2082 x) = refl\n        join\u2218split : join \u2218 split \u2257 id\n        join\u2218split 0 = refl\n        join\u2218split 1 = refl\n        join\u2218split (x +2) = begin\n          join (Sum.map suc suc (split x)) \u2261\u27e8 join-map-suc (split x) \u27e9\n          join (split x) +2 \u2261\u27e8 cong _+2 (join\u2218split x) \u27e9\n          x +2 \u220e\n        split\u2218join : split \u2218 join \u2257 id\n        split\u2218join (inj\u2081 zero) = refl\n        split\u2218join (inj\u2081 (x +1)) = cong (Sum.map suc suc) $ split\u2218join (inj\u2081 x)\n        split\u2218join (inj\u2082 zero) = refl\n        split\u2218join (inj\u2082 (x +1)) = cong (Sum.map suc suc) $ split\u2218join (inj\u2082 x)\n\n\u2115\u21d4Fin_+1\u00d7\u2115 : \u2200 k \u2192 \u2115 \u21d4 Fin (suc k) \u00d7 \u2115\n\u2115\u21d4Fin 0 +1\u00d7\u2115 = \u2115 \u21d4\u27e8 \u21d4-\u22a4\u00d7 \u27e9\n                 \u22a4 \u00d7 \u2115 \u21d4\u27e8 \u21d4-\u00d7-cong \u22a4\u21d4Fin1 \u21d4-refl \u27e9\n                 Fin 1 \u00d7 \u2115 \u25a0\n\u2115\u21d4Fin k +1 +1\u00d7\u2115 = \u2115 \u21d4\u27e8 \u2115\u21d4\u2115\u228e\u2115 \u27e9\n                    \u2115 \u228e \u2115 \u21d4\u27e8 \u21d4-\u228e-cong\u02e1 $ \u2115\u21d4Fin k +1\u00d7\u2115 \u27e9\n                    \u2115 \u228e Fin (k +1) \u00d7 \u2115 \u21d4\u27e8 A\u228eFin\u00d7A\u21d4Fin+1\u00d7A \u27e9\n                    Fin (k +2) \u00d7 \u2115 \u25a0\n\nopen import Data.List\nopen import Data.Bool using (Bool; true; false)\n\nbits = List Bool  \n\n\u2115\u1d47 = \u22a4 \u228e bits\n\ninfixl 5 _\u2236\u1d47_\ninfix 4 b1\u2236\u1d47_\npattern b0 = false\npattern b1 = true\npattern zero\u1d47 = inj\u2081 tt\npattern _\u2236\u1d47_ a b = b \u2237 a\npattern b1\u2236\u1d47_ a = inj\u2082 a\npattern one\u1d47 = b1\u2236\u1d47 []\n\nsuc-bits : bits \u2192 bits\nsuc-bits [] = b0 \u2237 []\nsuc-bits (x \u2236\u1d47 b0) = x \u2236\u1d47 b1\nsuc-bits (x \u2236\u1d47 b1) = suc-bits x \u2236\u1d47 b0\n\nsuc\u1d47 : \u2115\u1d47 \u2192 \u2115\u1d47\nsuc\u1d47 zero\u1d47 = one\u1d47\nsuc\u1d47 (b1\u2236\u1d47 x) = b1\u2236\u1d47 suc-bits x\n\nfrom\u2115 : \u2115 \u2192 \u2115\u1d47\nfrom\u2115 zero = zero\u1d47\nfrom\u2115 (x +1) = suc\u1d47 (from\u2115 x)\n\nto\u2115 : \u2115\u1d47 \u2192 \u2115\nto\u2115 zero\u1d47 = 0\nto\u2115 (one\u1d47) = 1\nto\u2115 (b1\u2236\u1d47 x \u2236\u1d47 b0) = to\u2115 (b1\u2236\u1d47 x) * 2\nto\u2115 (b1\u2236\u1d47 x \u2236\u1d47 b1) = to\u2115 (b1\u2236\u1d47 x) * 2 +1 \n\nopen import Data.Nat.Properties\n\n-- heavily inspired by standard library Data.Nat.Binary\nto\u2115-suc : to\u2115 \u2218 suc\u1d47 \u2257 suc \u2218 to\u2115\nto\u2115-suc zero\u1d47 = refl\nto\u2115-suc (one\u1d47) = refl\nto\u2115-suc (b1\u2236\u1d47 _ \u2236\u1d47 b0) = refl\nto\u2115-suc (b1\u2236\u1d47 x \u2236\u1d47 b1) =\n  to\u2115 (b1\u2236\u1d47 suc-bits x) * 2 \u2261\u27e8 cong (_* 2) $ to\u2115-suc (b1\u2236\u1d47 x) \u27e9\n  (x' +1) * 2 \u2261\u27e8 *-distrib\u02b3-+ 2 1 x' \u27e9\n  x' * 2 +2 \u220e\n  where x' = to\u2115 (b1\u2236\u1d47 x)\n\nto\u2115-from\u2115 : to\u2115 \u2218 from\u2115 \u2257 id\nto\u2115-from\u2115 zero = refl\nto\u2115-from\u2115 (x +1) =\n  to\u2115 (suc\u1d47 $ from\u2115 x) \u2261\u27e8 to\u2115-suc (from\u2115 x) \u27e9\n  to\u2115 (from\u2115 x) +1 \u2261\u27e8 cong _+1 (to\u2115-from\u2115 x) \u27e9\n  x +1 \u220e\n\n0<to\u2115-bits : \u2200 bs  \u2192 0 < to\u2115 (b1\u2236\u1d47 bs)\n0<to\u2115-bits [] = s\u2264s z\u2264n\n0<to\u2115-bits (bs \u2236\u1d47 b0) = *-mono\u02e1-< 1 (0<to\u2115-bits bs)\n0<to\u2115-bits (bs \u2236\u1d47 b1) = s\u2264s z\u2264n\n\n1<to\u2115-somebits : \u2200 bs x \u2192 1 < to\u2115 (b1\u2236\u1d47 bs \u2236\u1d47 x)\n1<to\u2115-somebits bs b0 = *-mono\u02e1-\u2264 2 (0<to\u2115-bits bs)\n1<to\u2115-somebits bs b1 = s\u2264s (0<to\u2115-bits (bs \u2236\u1d47 b0))\n\nopen import Data.Nat.DivMod\nm*n%n\u22610 = kn%n\u22610\n\nto\u2115-%2 : \u2200 bs x \u2192 to\u2115 (b1\u2236\u1d47 bs \u2236\u1d47 x) % 2 \u2261 to\u2115 (b1\u2236\u1d47 x \u2237 []) % 2\nto\u2115-%2 bs b0 = m*n%n\u22610 (to\u2115 (b1\u2236\u1d47 bs)) 1\nto\u2115-%2 bs b1 = (x * 2 +1) % 2 \u2261\u27e8 %-distrib\u02e1-+ 1 (x * 2) 1 \u27e9\n                ((x * 2) % 2 +1) % 2 \u2261\u27e8 cong (\u03bb x \u2192 (x +1) % 2) $ m*n%n\u22610 x 1 \u27e9\n                1 \u220e\n  where x = to\u2115 (b1\u2236\u1d47 bs)\n\nopen import Data.Empty\n\nInjective : (A \u2192 B) \u2192 Set\nInjective f = \u2200 {x y} \u2192 f x \u2261 f y \u2192 x \u2261 y\n\nto\u2115-bits-injective : Injective (to\u2115 \u2218 b1\u2236\u1d47_)\nto\u2115-bits-injective {[]} {bs \u2236\u1d47 b} eq =\n  \u22a5-elim $ <-irrefl eq $ 1<to\u2115-somebits bs b\nto\u2115-bits-injective {bs \u2236\u1d47 b} {[]} eq =\n  \u22a5-elim $ <-irrefl (sym eq) $ 1<to\u2115-somebits bs b\nto\u2115-bits-injective {bs \u2236\u1d47 b0} {bs' \u2236\u1d47 b1} eq =\n  case (0 \u2261\u27e8 sym $ to\u2115-%2 bs b0 \u27e9\n        to\u2115 (b1\u2236\u1d47 bs \u2236\u1d47 b0) % 2 \u2261\u27e8 cong (_% 2) eq \u27e9\n        to\u2115 (b1\u2236\u1d47 bs' \u2236\u1d47 b1) % 2 \u2261\u27e8 to\u2115-%2 bs' b1 \u27e9\n        1 \u220e)\n  of \u03bb ()\nto\u2115-bits-injective {bs \u2236\u1d47 b1} {bs' \u2236\u1d47 b0} eq =\n  case (0 \u2261\u27e8 sym $ to\u2115-%2 bs' b0 \u27e9\n        to\u2115 (b1\u2236\u1d47 bs' \u2236\u1d47 b0) % 2 \u2261\u27e8 cong (_% 2) $ sym eq \u27e9\n        to\u2115 (b1\u2236\u1d47 bs \u2236\u1d47 b1) % 2 \u2261\u27e8 to\u2115-%2 bs b1 \u27e9\n        1 \u220e)\n  of \u03bb ()\n\nto\u2115-bits-injective {[]} {[]} _ = refl\nto\u2115-bits-injective {bs \u2236\u1d47 b0} {bs' \u2236\u1d47 b0} =\n  cong (_\u2236\u1d47 b0) \u2218\n  to\u2115-bits-injective \u2218\n  *-cancel\u02b3-\u2261 x x'\n  where x = to\u2115 (b1\u2236\u1d47 bs)\n        x' = to\u2115 (b1\u2236\u1d47 bs')\nto\u2115-bits-injective {bs \u2236\u1d47 b1} {bs' \u2236\u1d47 b1} =\n  cong (_\u2236\u1d47 b1) \u2218\n  to\u2115-bits-injective \u2218\n  *-cancel\u02b3-\u2261 x x' \u2218\n  suc-injective\n  where x = to\u2115 (b1\u2236\u1d47 bs)\n        x' = to\u2115 (b1\u2236\u1d47 bs')\n\nopen import Data.Sum.Properties\n\nto\u2115-injective : Injective to\u2115\nto\u2115-injective {zero\u1d47} {zero\u1d47} _ = refl\nto\u2115-injective {b1\u2236\u1d47 bs} {b1\u2236\u1d47 bs'} = cong (b1\u2236\u1d47_) \u2218 to\u2115-bits-injective\n\nto\u2115-injective {zero\u1d47} {b1\u2236\u1d47 bs} p = \u22a5-elim $ <-irrefl p $ 0<to\u2115-bits bs\nto\u2115-injective {b1\u2236\u1d47 bs} {zero\u1d47} p = \u22a5-elim $ <-irrefl (sym p) $ 0<to\u2115-bits bs\n\nfrom\u2115-to\u2115 : from\u2115 \u2218 to\u2115 \u2257 id\nfrom\u2115-to\u2115 = to\u2115-injective \u2218 to\u2115-from\u2115 \u2218 to\u2115\n\n_<<1 : \u2115\u1d47 \u2192 \u2115\u1d47\nzero\u1d47 <<1 = zero\u1d47\n(b1\u2236\u1d47 bs) <<1 = b1\u2236\u1d47 bs \u2236\u1d47 b0\n\n\u2115\u21d4\u2115\u1d47 = Bijection from\u2115 to\u2115 to\u2115-from\u2115 from\u2115-to\u2115\n\nprivate\n  0run-len : \u2115\u1d47 \u2192 \u2115 \u00d7 \u2115\u1d47 \u228e \u22a4\n  0run-unlen : \u2115 \u00d7 \u2115\u1d47 \u228e \u22a4 \u2192 \u2115\u1d47\n  len-unlen : 0run-len \u2218 0run-unlen \u2257 id\n  unlen-len : 0run-unlen \u2218 0run-len \u2257 id\n  suc\u2082 : \u2115 \u00d7 \u2115\u1d47 \u228e \u22a4 \u2192 \u2115 \u00d7 \u2115\u1d47 \u228e \u22a4\n  0run-len_<<1\u2257 : 0run-len \u2218 _<<1 \u2257 suc\u2082 \u2218 0run-len\n  unlen-suc\u2082 : 0run-unlen \u2218 suc\u2082 \u2257 _<<1 \u2218 0run-unlen\n\nsuc\u2082 = Sum.map\u2081 (Prod.map\u2081 suc)\n\n-- 0 \u2192 \u22a4\n-- 100...n...0 \u2192 (n , 0)\n-- x@(1.....)100...n...0 \u2192 (n , x)\n0run-len zero\u1d47 = inj\u2082 tt\n0run-len one\u1d47 = inj\u2081 (0 , zero\u1d47)\n0run-len (b1\u2236\u1d47 bs \u2236\u1d47 b1) = inj\u2081 (0 , b1\u2236\u1d47 bs)\n0run-len (b1\u2236\u1d47 bs \u2236\u1d47 b0) = suc\u2082 $ 0run-len (b1\u2236\u1d47 bs)\n\n0run-unlen (inj\u2082 _) = zero\u1d47\n0run-unlen (inj\u2081 (0 , zero\u1d47)) = one\u1d47\n0run-unlen (inj\u2081 (0 , b1\u2236\u1d47 bs)) = b1\u2236\u1d47 bs \u2236\u1d47 b1\n0run-unlen (inj\u2081 (n +1 , x)) = 0run-unlen (inj\u2081 (n , x)) <<1\n\n0run-len zero\u1d47 <<1\u2257 = refl\n0run-len b1\u2236\u1d47 _ <<1\u2257 = refl\n\nlen-unlen (inj\u2082 tt) = refl\nlen-unlen (inj\u2081 (0 , zero\u1d47)) = refl\nlen-unlen (inj\u2081 (0 , b1\u2236\u1d47 bs)) = refl\nlen-unlen (inj\u2081 (n +1 , x)) =\n  0run-len (0run-unlen (inj\u2081 (n , x)) <<1)\n    \u2261\u27e8 0run-len 0run-unlen (inj\u2081 (n , x)) <<1\u2257 \u27e9\n  suc\u2082 (0run-len $ 0run-unlen $ inj\u2081 (n , x))\n    \u2261\u27e8 cong suc\u2082 $ len-unlen $ inj\u2081 (n , x) \u27e9\n  inj\u2081 (n +1 , x) \u220e\n\nunlen-suc\u2082 (inj\u2082 _) = refl\nunlen-suc\u2082 (inj\u2081 _) = refl\n\nunlen-len zero\u1d47 = refl\nunlen-len one\u1d47 = refl\nunlen-len (b1\u2236\u1d47 bs \u2236\u1d47 b1) = refl\nunlen-len (b1\u2236\u1d47 bs \u2236\u1d47 b0) =\n  0run-unlen (suc\u2082 $ 0run-len $ b1\u2236\u1d47 bs) \u2261\u27e8 unlen-suc\u2082 $ 0run-len (b1\u2236\u1d47 bs) \u27e9\n  0run-unlen (0run-len $ b1\u2236\u1d47 bs) <<1 \u2261\u27e8 cong _<<1 $ unlen-len (b1\u2236\u1d47 bs) \u27e9\n  b1\u2236\u1d47 bs \u2236\u1d47 b0 \u220e \n\nopen import Relation.Nullary\nopen import Relation.Unary using (Decidable)\nopen import Data.Bool\n\nswap-\u21d4 : \u2200{a b}(bij : A \u21d4 B) \u2192 bij .A\u2192B a \u2261 b \u2192 a \u2261 bij .B\u2192A b\nswap-\u21d4 bij refl = sym (bij .A\u2192B\u2192A _)\n\nopen import Relation.Nullary.Decidable\n\n\u228e-\u21d4-to-\u00d7-\u228e-\u21d4 : (c : C)(c\u225f_ : Decidable (c \u2261_)) \u2192\n  A \u228e B \u21d4 A \u2192 A \u00d7 C \u228e B \u21d4 A \u00d7 C\n\u228e-\u21d4-to-\u00d7-\u228e-\u21d4 {C = C}{A}{B} c c\u225f_ bij = Bijection to from from-to to-from\n  where module f = _\u21d4_ bij\n        to : A \u00d7 C \u228e B \u2192 A \u00d7 C\n        to (inj\u2081 p@(a , c')) = if \u230a c\u225f c' \u230b then f.A\u2192B (inj\u2081 a) , c' else p\n        to (inj\u2082 b) = f.A\u2192B (inj\u2082 b) , c\n        from : A \u00d7 C \u2192 A \u00d7 C \u228e B\n        from p@(a , c') =\n          if \u230a c\u225f c' \u230b then Sum.map\u2081 (_, c') (f.B\u2192A a) else inj\u2081 p\n        to-from : to \u2218 from \u2257 id\n        to-from (a , c') with c\u225f c'\n        ... | no c\u2262c' with c\u225f c'\n        ... | no _ = refl\n        ... | yes c\u2261c' = \u22a5-elim (c\u2262c' c\u2261c')\n        to-from (a , c') | yes refl with f.B\u2192A a | inspect f.B\u2192A a\n        ... | inj\u2082 _ | [ eq ] = cong (_, c') $ sym $ swap-\u21d4 (\u21d4-sym bij) eq\n        ... | inj\u2081 a' | [ eq ] with c\u225f c'\n        ... | yes refl = cong (_, c') $ sym $ swap-\u21d4 (\u21d4-sym bij) eq\n        ... | no c\u2262c' = \u22a5-elim (c\u2262c' refl)\n        from-to : from \u2218 to \u2257 id\n        from-to (inj\u2082 b) with c\u225f c\n        ... | yes _ = cong (Sum.map\u2081 (_, c)) $ f.A\u2192B\u2192A (inj\u2082 b)\n        ... | no c\u2262b = \u22a5-elim (c\u2262b refl)\n        from-to (inj\u2081 (a , c')) with c\u225f c'\n        ... | yes refl with c\u225f c'\n        ... | yes _ = cong (Sum.map\u2081 (_, c)) $ f.A\u2192B\u2192A (inj\u2081 a)\n        ... | no c\u2262b = \u22a5-elim (c\u2262b refl)\n        from-to (inj\u2081 (a , c')) | no c\u2262c' with c\u225f c'\n        ... | no _ = refl\n        ... | yes c\u2261c' = \u22a5-elim (c\u2262c' c\u2261c')\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 \u2115 \u00d7 \u2115\n\u2115\u21d4\u2115\u00d7\u2115 = \u2115 \u21d4\u27e8 \u2115\u21d4\u2115\u1d47 \u27e9\n         \u2115\u1d47 \u21d4\u27e8 Bijection 0run-len 0run-unlen unlen-len len-unlen \u27e9\n         \u2115 \u00d7 \u2115\u1d47 \u228e \u22a4 \u21d4\u27e8 \u21d4-\u228e-cong\u02b3 $ \u21d4-\u00d7-cong\u02e1 $ \u21d4-sym \u2115\u21d4\u2115\u1d47 \u27e9\n         \u2115 \u00d7 \u2115 \u228e \u22a4 \u21d4\u27e8 \u228e-\u21d4-to-\u00d7-\u228e-\u21d4 0 (0 \u2115.\u225f_) $ \u21d4-sym \u2115\u21d4\u2115\u228e\u22a4  \u27e9\n         \u2115 \u00d7 \u2115 \u25a0\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115 ^ n, where n is finite.\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc zero = \u21d4-trans \u21d4-\u22a4\u00d7 \u21d4-\u00d7-comm\n\u2115\u21d4\u2115^suc (n +1) =\n  \u21d4-trans (\u2115\u21d4\u2115^suc n) $\n  \u21d4-trans (\u21d4-\u00d7-cong \u2115\u21d4\u2115\u00d7\u2115 \u21d4-refl)\n          \u21d4-\u00d7-assoc\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":447,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\nopen import Function using (_$_; _\u220b_; _\u27e8_\u27e9_)\nopen import Data.Nat.Properties\nopen import Relation.Nullary.Decidable using (True)\nopen import Relation.Nullary.Product using (_\u00d7-dec_)\nopen import Relation.Nullary.Sum using (_\u228e-dec_)\n\n-- Task 1. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115.\n\nbound : \u2200 x y \u2192 \u2115\nbound x y = x + (x + y) * (x + y)\n\nbound-1 : \u2200 (x y : \u2115) {p : True (0 <? x \u228e-dec (0 \u225f x \u00d7-dec 0 <? y))} \u2192 \u2115\nbound-1 zero (suc y) = y + y * suc y\nbound-1 (suc x) y = x + (suc x + y) * (suc x + y)\n\nhelp1 : \u2200 y b \u2192 bound-1 0 (suc y) \u2264 b \u2192 bound y 0 \u2264 b\nhelp1 y b p rewrite +-comm y 0 | *-comm y (suc y) = \u2264-steps\u02e1 y \u2264-refl \u27e8 \u2264-trans \u27e9 p\n\nhelp2 : \u2200 x y b \u2192 bound-1 (suc x) y \u2264 b \u2192 bound x (suc y) \u2264 b\nhelp2 x y b p rewrite +-suc x y = p\n\nto : \u2115 \u2192 \u2115 \u00d7 \u2115\nto zero = zero , zero\nto (suc n) with to n\n... | x , zero = zero , suc x\n... | x , suc y = suc x , y\n\nfrom : \u2200 (b x y : \u2115) \u2192 \u2115\nfrom zero x y = y\nfrom (suc b) zero zero = zero\nfrom (suc b) zero (suc y) = suc (from b y zero)\nfrom (suc b) (suc x) y = suc (from b x (suc y))\n\nfromLemma : \u2200 (s1 s2 x y : \u2115) \u2192 bound x y \u2264 s1 \u2192 bound x y \u2264 s2 \u2192 from s1 x y \u2261 from s2 x y\nfromLemma zero zero x y p1 p2 = refl\nfromLemma zero (suc s2) zero zero p1 p2 = refl\nfromLemma (suc s1) zero zero zero p1 p2 = refl\nfromLemma (suc s1) (suc s2) zero zero p1 p2 = refl\nfromLemma (suc s1) (suc s2) zero (suc y) (s\u2264s p1) (s\u2264s p2) =\n    cong suc (fromLemma _ _ y 0 (help1 y s1 p1) (help1 y s2 p2))\nfromLemma (suc s1) (suc s2) (suc x) y (s\u2264s p1) (s\u2264s p2) =\n    cong suc (fromLemma _ _ x (suc y) (help2 x y s1 p1) (help2 x y s2 p2))\n\nfrom\u2218to : \u2200 n \u2192 (\n    let (x , y) = to n\n    in from (bound x y) x y \u2261 n)\nfrom\u2218to zero = refl\nfrom\u2218to (suc n) with to n | from\u2218to n\nfrom\u2218to (suc n) | x , zero | eq =\n    let pp = fromLemma _ _ x 0 p2 \u2264-refl\n    in cong suc (trans pp eq)\n  where\n    p2 : bound x 0 \u2264 bound-1 0 (suc x)\n    p2 rewrite +-comm x 0 | *-comm x (suc x) = \u2264-steps\u02e1 x \u2264-refl\nfrom\u2218to (suc n) | x , suc y | eq rewrite +-suc x y = cong suc eq\n\nto\u2218from : \u2200 (b x y : \u2115) \u2192 (\n    let b' = bound x y\n        (x' , y') = to (from b x y)\n    in b' \u2264 b \u2192 x \u2261 x' \u00d7 y \u2261 y')\nto\u2218from zero zero zero b'\u2264b = refl , refl\nto\u2218from (suc b) zero zero b'\u2264b = refl , refl\nto\u2218from (suc b) zero (suc y) (s\u2264s b'\u2264b) with to (from b y zero) | to\u2218from b y zero (help1 y b b'\u2264b)\n... | x' , zero | refl , refl = refl , refl\nto\u2218from (suc b) (suc x) y (s\u2264s b'\u2264b) with to (from b x (suc y)) | to\u2218from b x (suc y) (help2 x y b b'\u2264b)\n... | x' , suc y' | refl , refl = refl , refl\n\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\nA\u2192B   \u2115\u21d4\u2115\u00d7\u2115 = to\nB\u2192A   \u2115\u21d4\u2115\u00d7\u2115 (x , y) = from (bound x y) x y\nA\u2192B\u2192A \u2115\u21d4\u2115\u00d7\u2115 = from\u2218to\nB\u2192A\u2192B \u2115\u21d4\u2115\u00d7\u2115 (x , y) with to (from (bound x y) x y) | to\u2218from (bound x y) x y \u2264-refl\n... | (x' , y') | eq1 , eq2 rewrite eq1 | eq2 = refl\n\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115 ^ n, where n is finite.\n\nlemma : \u2200 {A A\u2032 B B\u2032} \u2192 A \u21d4 A\u2032 \u2192 B \u21d4 B\u2032 \u2192 (A \u00d7 B) \u21d4 (A\u2032 \u00d7 B\u2032)\nA\u2192B   (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x , y) = A\u2192B A\u21d4A\u2032 x , A\u2192B B\u21d4B\u2032 y\nB\u2192A   (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x' , y') = B\u2192A A\u21d4A\u2032 x' , B\u2192A B\u21d4B\u2032 y'\nA\u2192B\u2192A (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x , y) rewrite A\u2192B\u2192A A\u21d4A\u2032 x | A\u2192B\u2192A B\u21d4B\u2032 y = refl\nB\u2192A\u2192B (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x' , y') rewrite B\u2192A\u2192B A\u21d4A\u2032 x' | B\u2192A\u2192B B\u21d4B\u2032 y' = refl\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\nA\u2192B   (\u2115\u21d4\u2115^suc zero) n = n , tt\nB\u2192A   (\u2115\u21d4\u2115^suc zero) (n , tt) = n\nA\u2192B\u2192A (\u2115\u21d4\u2115^suc zero) a = refl\nB\u2192A\u2192B (\u2115\u21d4\u2115^suc zero) (n , tt) = refl\n\u2115\u21d4\u2115^suc (suc k) with lemma (\u2115 \u21d4 \u2115 \u220b \u21d4-refl) (\u2115\u21d4\u2115^suc k)\n... | \u21d4k = \u2115\u21d4\u2115\u00d7\u2115 \u27e8 \u21d4-trans \u27e9 \u21d4k","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":448,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso using (_\u21d4_; \u21d4-trans; \u21d4-refl; \u2115^; _\u00d7_; _,_; tt)\n-- open import Iso\nopen _\u21d4_\n\n\nopen import Function using (_$_; _\u220b_; _\u27e8_\u27e9_)\nopen import Relation.Binary.PropositionalEquality\nopen import Data.Nat\nopen import Data.Nat.Properties\n\n\n-- Task 1. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115.\n\nhelp1 : \u2200 y b \u2192 y + y * suc y \u2264 b \u2192 y + (y + 0) * (y + 0) \u2264 b\nhelp1 y b p rewrite +-comm y 0 | *-comm y (suc y) = \u2264-steps\u02e1 y \u2264-refl \u27e8 \u2264-trans \u27e9 p\n\nhelp2 : \u2200 x y b \u2192 x + suc (x + y + (x + y) * suc (x + y)) \u2264 b \u2192 x + (x + suc y) * (x + suc y) \u2264 b\nhelp2 x y b p rewrite +-suc x y = p\n\nto : \u2115 \u2192 \u2115 \u00d7 \u2115\nto zero = zero , zero\nto (suc n) with to n\n... | x , zero = zero , suc x\n... | x , suc y = suc x , y\n\nfrom : \u2200 (b x y : \u2115) \u2192 \u2115\nfrom zero x y = y\nfrom (suc b) zero zero = zero\nfrom (suc b) zero (suc y) = suc (from b y zero)\nfrom (suc b) (suc x) y = suc (from b x (suc y))\n\nfromLemma : \u2200 (s1 s2 x y : \u2115) \u2192 (\n    let s = x + y\n        s\u00b2 = s * s\n        b = x + s\u00b2\n    in b \u2264 s1 \u2192 b \u2264 s2 \u2192 from s1 x y \u2261 from s2 x y)\nfromLemma zero zero x y p1 p2 = refl\nfromLemma zero (suc s2) zero zero p1 p2 = refl\nfromLemma (suc s1) zero zero zero p1 p2 = refl\nfromLemma (suc s1) (suc s2) zero zero p1 p2 = refl\nfromLemma (suc s1) (suc s2) zero (suc y) (s\u2264s p1) (s\u2264s p2) =\n    cong suc (fromLemma s1 s2 y 0 (help1 y s1 p1) (help1 y s2 p2))\nfromLemma (suc s1) (suc s2) (suc x) y (s\u2264s p1) (s\u2264s p2) =\n    cong suc (fromLemma s1 s2 x (suc y) (help2 x y s1 p1) (help2 x y s2 p2))\n\nfrom\u2218to : \u2200 n \u2192 (\n    let (x , y) = to n\n        s = x + y\n        s\u00b2 = s * s\n        b = x + s\u00b2\n    in from b x y \u2261 n)\nfrom\u2218to zero = refl\nfrom\u2218to (suc n) with to n | from\u2218to n\nfrom\u2218to (suc n) | x , zero | eq =\n    let pp = fromLemma (x + x * suc x) _ x 0 p2 \u2264-refl\n    in cong suc (trans pp eq)\n  where\n    p2 : x + (x + 0) * (x + 0) \u2264 x + x * suc x\n    p2 rewrite +-comm x 0 | *-comm x (suc x) = \u2264-steps\u02e1 x \u2264-refl\nfrom\u2218to (suc n) | x , suc y | eq rewrite +-suc x y = cong suc eq\n\nto\u2218from : \u2200 (b x y : \u2115) \u2192 (\n    let s = x + y\n        s\u00b2 = s * s\n        b' = x + s\u00b2\n        (x' , y') = to (from b x y)\n    in b' \u2264 b \u2192 x \u2261 x' \u00d7 y \u2261 y')\nto\u2218from zero zero zero b'\u2264b = refl , refl\nto\u2218from (suc b) zero zero b'\u2264b = refl , refl\nto\u2218from (suc b) zero (suc y) (s\u2264s b'\u2264b) with to (from b y zero) | to\u2218from b y zero (help1 y b b'\u2264b)\nto\u2218from (suc b) zero (suc y) b'\u2264b | x' , zero | refl , refl = refl , refl\nto\u2218from (suc b) (suc x) y (s\u2264s b'\u2264b) with to (from b x (suc y)) | to\u2218from b x (suc y) (help2 x y b b'\u2264b)\nto\u2218from (suc b) (suc x) y b'\u2264b | x' , suc y' | refl , refl = refl , refl\n\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\nA\u2192B   \u2115\u21d4\u2115\u00d7\u2115 = to\nB\u2192A   \u2115\u21d4\u2115\u00d7\u2115 (x , y) = from (x + (x + y) * (x + y)) x y\nA\u2192B\u2192A \u2115\u21d4\u2115\u00d7\u2115 = from\u2218to\nB\u2192A\u2192B \u2115\u21d4\u2115\u00d7\u2115 (x , y) with to (from (x + (x + y) * (x + y)) x y) | to\u2218from (x + (x + y) * (x + y)) x y \u2264-refl\n... | (x' , y') | eq1 , eq2 rewrite eq1 | eq2 = refl\n\n\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115 ^ n, where n is finite.\n\nlemma : \u2200 {A A\u2032 B B\u2032} \u2192 A \u21d4 A\u2032 \u2192 B \u21d4 B\u2032 \u2192 (A \u00d7 B) \u21d4 (A\u2032 \u00d7 B\u2032)\nA\u2192B   (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x , y) = A\u2192B A\u21d4A\u2032 x , A\u2192B B\u21d4B\u2032 y\nB\u2192A   (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x' , y') = B\u2192A A\u21d4A\u2032 x' , B\u2192A B\u21d4B\u2032 y'\nA\u2192B\u2192A (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x , y) rewrite A\u2192B\u2192A A\u21d4A\u2032 x | A\u2192B\u2192A B\u21d4B\u2032 y = refl\nB\u2192A\u2192B (lemma A\u21d4A\u2032 B\u21d4B\u2032) (x' , y') rewrite B\u2192A\u2192B A\u21d4A\u2032 x' | B\u2192A\u2192B B\u21d4B\u2032 y' = refl\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\nA\u2192B   (\u2115\u21d4\u2115^suc zero) n = n , tt\nB\u2192A   (\u2115\u21d4\u2115^suc zero) (n , tt) = n\nA\u2192B\u2192A (\u2115\u21d4\u2115^suc zero) a = refl\nB\u2192A\u2192B (\u2115\u21d4\u2115^suc zero) (n , tt) = refl\n\u2115\u21d4\u2115^suc (suc k) with lemma (\u2115 \u21d4 \u2115 \u220b \u21d4-refl) (\u2115\u21d4\u2115^suc k)\n... | \u21d4k = \u2115\u21d4\u2115\u00d7\u2115 \u27e8 \u21d4-trans \u27e9 \u21d4k\n","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":449,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Iso\nopen _\u21d4_\n\n-- Task 1. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115.\n\ncpf : \u2115 \u00d7 \u2115 \u2192 \u2115\ncpf-y\u22610 : \u2115 \u2192 \u2115\ncpf-y\u22610 zero = zero\ncpf-y\u22610 x @ (suc px) = x + cpf-y\u22610 px\ncpf (x , y) = y + cpf-y\u22610 (y + x) --cpf-y\u22610 (x + y) + y\n\n\nopen import Data.Integer using (+_; -[1+_]; _\u2296_)\nopen import Induction.WellFounded using (Acc; acc)\n--open import Data.Nat.Induction using (<-wellFounded)\n-- for Codewars' Agda and agda-stdlib versions\nopen import Induction.Nat using (<-wellFounded)\n\nicpf : \u2115 \u2192 \u2115 \u00d7 \u2115\nicpf-from-kth-diagonal : \u2115 \u2192 \u2115 \u2192 \u2115 \u00d7 \u2115\nicpf-from-kth-diagonal-wf : \u2115 \u2192 (n : \u2115) \u2192 Acc _<_ n \u2192 \u2115 \u00d7 \u2115\nk\u2296n\u2261-[1+r]\u2192r<n : \u2200 (k n r : \u2115) \u2192 k \u2296 n \u2261 -[1+ r ] \u2192 r < n\n--open import Data.Nat.Properties using (n<1+n; <-trans)\n-- for Codewars' Agda and agda-stdlib versions\nopen import Data.Nat.Properties using (\u2264-refl; <-trans)\nn<1+n : \u2200 n \u2192 n < suc n\nn<1+n n = \u2264-refl\nk\u2296n\u2261-[1+r]\u2192r<n zero (suc n) n refl = n<1+n n\nk\u2296n\u2261-[1+r]\u2192r<n (suc k) (suc n) r k\u2296n\u2261-[1+r] = <-trans (k\u2296n\u2261-[1+r]\u2192r<n k n r k\u2296n\u2261-[1+r]) (n<1+n n)\nicpf-from-kth-diagonal-wf k n (acc rs)\n  with k \u2296 n | inspect (k \u2296_) n\n...  | + x | _ = x , n\n...  | -[1+ r ] | [ k\u2296n\u2261-[1+r] ] = icpf-from-kth-diagonal-wf (suc k) r (rs r (k\u2296n\u2261-[1+r]\u2192r<n k n r k\u2296n\u2261-[1+r]))\nicpf-from-kth-diagonal k n = icpf-from-kth-diagonal-wf k n (<-wellFounded n)\nicpf = icpf-from-kth-diagonal zero\n\n{-\nopen import Relation.Binary using (Rel)\nopen import Level using (0\u2113)\nacc\u2261acc : \u2200 {A : Set} {_<_ : Rel A 0\u2113} v (acca accb : Acc _<_ v) \u2192 acca \u2261 accb\nacc\u2261acc v (acc rsa) (acc rsb) = {!!} --seems to require extensionality\n-}\n\nicpf-from-kth-diagonal-wf-irrelevant : \u2200 k n acca accb \u2192 icpf-from-kth-diagonal-wf k n acca \u2261 icpf-from-kth-diagonal-wf k n accb\nicpf-from-kth-diagonal-wf-irrelevant k n (acc rsa) (acc rsb)\n  with k \u2296 n | inspect (k \u2296_) n\n...  | + x | _ = refl\n...  | -[1+ r ] | [ k\u2296n\u2261-[1+r] ] = icpf-from-kth-diagonal-wf-irrelevant (suc k) r (rsa r (k\u2296n\u2261-[1+r]\u2192r<n k n r k\u2296n\u2261-[1+r])) (rsb r (k\u2296n\u2261-[1+r]\u2192r<n k n r k\u2296n\u2261-[1+r]))\nicpf-from-kth-diagonal-wf-irrelevant\u2032 : \u2200 k n acc \u2192 icpf-from-kth-diagonal-wf k n acc \u2261 icpf-from-kth-diagonal k n\nicpf-from-kth-diagonal-wf-irrelevant\u2032 k n acc\u2032 = icpf-from-kth-diagonal-wf-irrelevant k n acc\u2032 (<-wellFounded n)\n\n\nopen import Data.Nat.Properties using (+-identity\u02b3; +-assoc; +-comm)\n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 : \u2200 (n : \u2115) \u2192 cpf (icpf n) \u2261 n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115-rec-on-k\u2296n : \u2200 k n \u2192 (acc : Acc _<_ n) \u2192 cpf (icpf-from-kth-diagonal-wf k n acc) \u2261 n + cpf-y\u22610 k\nm\u2296n\u2261+l\u2192m\u2261n+l : \u2200 m n l \u2192 m \u2296 n \u2261 + l \u2192 m \u2261 n + l\nm\u2296n\u2261+l\u2192m\u2261n+l m zero m refl = refl\nm\u2296n\u2261+l\u2192m\u2261n+l (suc m) (suc n) l eq rewrite m\u2296n\u2261+l\u2192m\u2261n+l m n l eq = refl\nm\u2296n\u2261-[1+l]\u2192n\u22611+[m+l] : \u2200 m n l \u2192 m \u2296 n \u2261 -[1+ l ] \u2192 n \u2261 suc (m + l)\nm\u2296n\u2261-[1+l]\u2192n\u22611+[m+l] zero (suc l) l refl = refl\nm\u2296n\u2261-[1+l]\u2192n\u22611+[m+l] (suc m) (suc n) l [1+m]\u2296[1+n]\u2261-[1+l] rewrite m\u2296n\u2261-[1+l]\u2192n\u22611+[m+l] m n l [1+m]\u2296[1+n]\u2261-[1+l] = refl\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115-rec-on-k\u2296n k n (acc rs)\n  with k \u2296 n | inspect (k \u2296_) n\n...  | + x | [ k\u2296n\u2261+x ] rewrite m\u2296n\u2261+l\u2192m\u2261n+l k n x k\u2296n\u2261+x = refl\n...  | -[1+ r ] | [ k\u2296n\u2261-[1+r] ]\n       rewrite cong (_+ cpf-y\u22610 k) (m\u2296n\u2261-[1+l]\u2192n\u22611+[m+l] k n r k\u2296n\u2261-[1+r]) | cong (_+ cpf-y\u22610 k) (+-comm (suc k) r) | +-assoc r (suc k) (cpf-y\u22610 k) =\n       \u2115\u2192\u2115\u00d7\u2115\u2192\u2115-rec-on-k\u2296n (suc k) r (rs r (k\u2296n\u2261-[1+r]\u2192r<n k n r k\u2296n\u2261-[1+r]))\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 n = trans (\u2115\u2192\u2115\u00d7\u2115\u2192\u2115-rec-on-k\u2296n zero n (<-wellFounded n)) (+-identity\u02b3 n)\n\n\n-- This is the core function needed to prove \u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115.\nelim-summed : \u2200 (k r : \u2115) \u2192 icpf (r + cpf-y\u22610 k) \u2261 icpf-from-kth-diagonal k r\nk\u2296[r+[1+k]]\u2261-[1+r] : \u2200 k r \u2192 k \u2296 (r + suc k) \u2261 -[1+ r ]\nk\u2296[r+[1+k]]\u2261-[1+r] zero r rewrite +-comm r 1 = refl\nk\u2296[r+[1+k]]\u2261-[1+r] (suc k) r rewrite +-comm r (suc (suc k)) | +-comm (suc k) r = k\u2296[r+[1+k]]\u2261-[1+r] k r\nelim-summed zero r rewrite +-identity\u02b3 r = refl\nelim-summed (suc k) r rewrite sym (+-assoc r (suc k) (cpf-y\u22610 k)) | elim-summed k (r + suc k)\n  with k \u2296 (r + suc k) | inspect (k \u2296_) (r + suc k) | k\u2296[r+[1+k]]\u2261-[1+r] k r\n...  | -[1+ r ] | [ k\u2296n\u2261-[1+r] ] | refl\n       with <-wellFounded (r + suc k) | inspect <-wellFounded (r + suc k)\n...       | acc rs | [ refl ] = icpf-from-kth-diagonal-wf-irrelevant\u2032 (suc k) r (rs r (k\u2296n\u2261-[1+r]\u2192r<n k (r + suc k) r k\u2296n\u2261-[1+r]))\n\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 : \u2200 (x,y : \u2115 \u00d7 \u2115) \u2192 icpf (cpf x,y) \u2261 x,y\ny+x\u2296y\u2261+x : \u2200 x y \u2192 y + x \u2296 y \u2261 + x\ny+x\u2296y\u2261+x x zero = refl\ny+x\u2296y\u2261+x x (suc y) = y+x\u2296y\u2261+x x y\n\u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115 (x , y) rewrite elim-summed (y + x) y\n  with y + x \u2296 y | inspect (y + x \u2296_) y | y+x\u2296y\u2261+x x y\n...  | + x | [ _ ] | refl = refl\n\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = Bijection icpf cpf \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 \u2115\u00d7\u2115\u2192\u2115\u2192\u2115\u00d7\u2115\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115 ^ n, where n is finite.\n\n--open \u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; step-\u2261; _\u220e)\n-- for Codewars' Agda and agda-stdlib versions\nopen \u2261-Reasoning using (begin_; _\u2261\u27e8\u27e9_; _\u2261\u27e8_\u27e9_; _\u220e)\n\n\u21d4-subst : \u2200 {A B C D : Set} \u2192 A \u21d4 B \u2192 C \u21d4 D \u2192 (A \u00d7 C) \u21d4 (B \u00d7 D)\n\u21d4-subst (Bijection A\u2192B B\u2192A A\u2192B\u2192A B\u2192A\u2192B) (Bijection C\u2192D D\u2192C C\u2192D\u2192C D\u2192C\u2192D) =\n  Bijection\n    (\u03bb { (a , c) \u2192 A\u2192B a , C\u2192D c })\n    (\u03bb { (b , d) \u2192 B\u2192A b , D\u2192C d })\n    (\u03bb { (a , c) \u2192\n      begin\n        B\u2192A (A\u2192B a) , D\u2192C (C\u2192D c)\n      \u2261\u27e8 cong (_, D\u2192C (C\u2192D c)) (A\u2192B\u2192A a) \u27e9\n        a , D\u2192C (C\u2192D c)\n      \u2261\u27e8 cong (a ,_) (C\u2192D\u2192C c) \u27e9\n        a , c\n      \u220e })\n    (\u03bb { (b , d) \u2192\n      begin\n        A\u2192B (B\u2192A b) , C\u2192D (D\u2192C d)\n      \u2261\u27e8 cong (_, C\u2192D (D\u2192C d)) (B\u2192A\u2192B b) \u27e9\n        b , C\u2192D (D\u2192C d)\n      \u2261\u27e8 cong (b ,_) (D\u2192C\u2192D d) \u27e9\n        b , d\n      \u220e })\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc zero = Bijection (_, tt) _\u00d7_.fst (\u03bb _ \u2192 refl) (\u03bb { (_ , tt) \u2192 refl })\n\u2115\u21d4\u2115^suc (suc n) = \u21d4-trans \u2115\u21d4\u2115\u00d7\u2115 (\u21d4-subst \u21d4-refl (\u2115\u21d4\u2115^suc n))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"},{"id":450,"user_id":null,"body":"{-# OPTIONS --safe #-}\nmodule Iso-properties where\n\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.Nat using (\u2115; zero; suc; _+_; _\u2264_; _<_; s\u2264s; z\u2264n)\nopen import Data.Nat.Properties using (+-identity\u02b3; +-assoc; +-comm; +-suc;\n                                       +-cancel\u02e1-\u2261; +-cancel\u02b3-\u2261;\n                                       \u2264-refl; +-mono\u02b3-\u2264; +-mono\u02e1-\u2264; <-cmp;\n                                       <\u21d2\u2262; n\u22641+n; m\u2264m+n; n\u2264m+n;\n                                       module \u2264-Reasoning)\nopen import Function using (_\u2218_; _$_; id)\nopen import Relation.Binary using (_Preserves_\u27f6_; tri<; tri\u2248; tri>)\nopen import Relation.Binary.PropositionalEquality\n  using (_\u2261_; _\u2262_; sym; trans; cong; refl; inspect; [_]; module \u2261-Reasoning)\n\nopen import Iso\n\n-- Task 1. Prove that \u2115 has the same cardinality as \u2115 \u00d7 \u2115.\n\n\u0394 : \u2115 \u2192 \u2115\n\u0394 zero    = zero\n\u0394 (suc n) = suc n + \u0394 n\n\nmodule \u0394-properties where\n  \u0394-mono-\u2264 : \u0394 Preserves _\u2264_ \u27f6 _\u2264_\n  \u0394-mono-\u2264 z\u2264n = z\u2264n\n  \u0394-mono-\u2264 {suc m} {suc n} (s\u2264s m\u2264n) = begin\n    \u0394 (suc m)           \u2261\u27e8\u27e9\n    suc m + \u0394 m         \u2264\u27e8 +-mono\u02e1-\u2264 (\u0394 m) (s\u2264s m\u2264n) \u27e9\n    suc n + \u0394 m         \u2264\u27e8 +-mono\u02b3-\u2264 (suc n) (\u0394-mono-\u2264 m\u2264n) \u27e9\n    suc n + \u0394 n         \u2261\u27e8\u27e9\n    \u0394 (suc n)           \u220e\n    where open \u2264-Reasoning\n        \n\u2115\u2192\u2115\u00d7\u2115 : \u2115 \u2192 \u2115 \u00d7 \u2115\n\u2115\u2192\u2115\u00d7\u2115 zero         = (zero , zero)\n\u2115\u2192\u2115\u00d7\u2115 (suc n) with \u2115\u2192\u2115\u00d7\u2115 n\n... | (zero , y)  = (suc y , zero)\n... | (suc x , y) = (x , suc y)\n\n\u2115\u00d7\u2115\u2192\u2115 : \u2115 \u00d7 \u2115 \u2192 \u2115\n\u2115\u00d7\u2115\u2192\u2115 (x , y) = \u0394 (x + y) + y\n\nmodule \u2115\u00d7\u2115\u2192\u2115-properties where\n  \u2115\u00d7\u2115\u2192\u2115-diag-ub : \u2200 x y \u2192 \u2115\u00d7\u2115\u2192\u2115 (x , y) < \u0394 (suc (x + y))\n  \u2115\u00d7\u2115\u2192\u2115-diag-ub x y = begin-strict\n    \u2115\u00d7\u2115\u2192\u2115 (x , y)                 \u2261\u27e8\u27e9\n    \u0394 (x + y) + y                  \u2264\u27e8 +-mono\u02b3-\u2264 (\u0394 (x + y)) (n\u2264m+n x y) \u27e9\n    \u0394 (x + y) + (x + y)            \u2261\u27e8 +-comm (\u0394 (x + y)) (x + y) \u27e9\n    (x + y) + \u0394 (x + y)            <\u27e8 \u2264-refl \u27e9\n    suc ((x + y) + \u0394 (x + y))      \u2261\u27e8\u27e9\n    suc (x + y) + \u0394 (x + y)        \u2261\u27e8\u27e9\n    \u0394 (suc (x + y)) \u220e\n    where open \u2264-Reasoning\n\n  \u2115\u00d7\u2115\u2192\u2115-diag-lb : \u2200 x y \u2192 \u0394 (x + y) \u2264 \u2115\u00d7\u2115\u2192\u2115 (x , y)\n  \u2115\u00d7\u2115\u2192\u2115-diag-lb x y = begin\n    \u0394 (x + y)           \u2264\u27e8 m\u2264m+n (\u0394 (x + y)) y \u27e9\n    \u0394 (x + y) + y       \u2261\u27e8\u27e9\n    \u2115\u00d7\u2115\u2192\u2115 (x , y)      \u220e\n    where open \u2264-Reasoning\n\n  \u2115\u00d7\u2115\u2192\u2115-diag-inj : \u2200 (x y x' y') \u2192 x + y < x' + y' \u2192 \u2115\u00d7\u2115\u2192\u2115 (x , y) < \u2115\u00d7\u2115\u2192\u2115 (x' , y')\n  \u2115\u00d7\u2115\u2192\u2115-diag-inj x y x' y' x+y<x'+y' = begin-strict\n    \u2115\u00d7\u2115\u2192\u2115 (x , y)      <\u27e8 \u2115\u00d7\u2115\u2192\u2115-diag-ub x y \u27e9\n    \u0394 (suc (x + y))     \u2264\u27e8 \u0394-mono-\u2264 x+y<x'+y' \u27e9\n    \u0394 (x' + y')         \u2264\u27e8 \u2115\u00d7\u2115\u2192\u2115-diag-lb x' y' \u27e9\n    \u2115\u00d7\u2115\u2192\u2115 (x' , y')    \u220e\n    where open \u2264-Reasoning\n          open \u0394-properties\n\n  \u2115\u00d7\u2115\u2192\u2115-inj : \u2200 b b' \u2192 \u2115\u00d7\u2115\u2192\u2115 b \u2261 \u2115\u00d7\u2115\u2192\u2115 b' \u2192 b \u2261 b'\n  \u2115\u00d7\u2115\u2192\u2115-inj (x , y) (x' , y') eq with <-cmp (x + y) (x' + y')\n  ... | tri< ev< _ _ = \u22a5-elim $ <\u21d2\u2262 (\u2115\u00d7\u2115\u2192\u2115-diag-inj x y x' y' ev<) eq\n  ... | tri\u2248 _ ev\u2248 _ = trans (cong (_, y) x\u2261x') (cong (x' ,_) y\u2261y')\n                       where y\u2261y' : y \u2261 y'\n                             y\u2261y' = +-cancel\u02e1-\u2261 (\u0394 (x + y))\n                                  $ trans eq\n                                  $ cong (_+ y')\n                                  $ sym (cong \u0394 ev\u2248)\n                             x\u2261x' : x \u2261 x'\n                             x\u2261x' = +-cancel\u02b3-\u2261 x x'\n                                  $ trans ev\u2248\n                                  $ cong (x' +_)\n                                  $ sym y\u2261y'\n  ... | tri> _ _ ev> = \u22a5-elim $ <\u21d2\u2262 (\u2115\u00d7\u2115\u2192\u2115-diag-inj x' y' x y ev>) (sym eq)\n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 : \u2200 n \u2192 \u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n) \u2261 n\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 zero = refl\n\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 (suc n) with \u2115\u2192\u2115\u00d7\u2115 n | inspect \u2115\u2192\u2115\u00d7\u2115 n\n... | (zero , y)  | [ eq ] = begin\n        \u2115\u00d7\u2115\u2192\u2115 (suc y , zero)         \u2261\u27e8\u27e9\n        \u0394 (suc y + zero) + zero       \u2261\u27e8 cong (\u03bb z \u2192 \u0394 z + zero) (+-identity\u02b3 (suc y)) \u27e9\n        \u0394 (suc y) + zero              \u2261\u27e8 +-identity\u02b3 (\u0394 (suc y)) \u27e9\n        \u0394 (suc y)                     \u2261\u27e8\u27e9\n        suc y + \u0394 y                   \u2261\u27e8 cong suc (+-comm y (\u0394 y)) \u27e9\n        suc (\u0394 y + y)                 \u2261\u27e8 sym (cong (suc \u2218 \u2115\u00d7\u2115\u2192\u2115) eq) \u27e9\n        suc (\u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n))       \u2261\u27e8 cong suc (\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 n) \u27e9\n        suc n                         \u220e\n        where open \u2261-Reasoning\n... | (suc x , y) | [ eq ] = begin\n        \u2115\u00d7\u2115\u2192\u2115 (x , suc y)            \u2261\u27e8\u27e9\n        \u0394 (x + suc y) + suc y         \u2261\u27e8 cong (\u03bb z \u2192 \u0394 z + suc y) (+-suc x y) \u27e9\n        \u0394 (suc x + y) + suc y         \u2261\u27e8 +-suc (\u0394 (suc x + y)) y \u27e9\n        suc (\u0394 (suc x + y) + y)       \u2261\u27e8 sym (cong (suc \u2218 \u2115\u00d7\u2115\u2192\u2115) eq) \u27e9\n        suc (\u2115\u00d7\u2115\u2192\u2115 (\u2115\u2192\u2115\u00d7\u2115 n))       \u2261\u27e8 cong suc (\u2115\u2192\u2115\u00d7\u2115\u2192\u2115 n) \u27e9\n        suc n                         \u220e\n        where open \u2261-Reasoning\n\n\u2115\u21d4\u2115\u00d7\u2115 : \u2115 \u21d4 (\u2115 \u00d7 \u2115)\n\u2115\u21d4\u2115\u00d7\u2115 = bijection-alt \u2115\u2192\u2115\u00d7\u2115 \u2115\u00d7\u2115\u2192\u2115 \u2115\u2192\u2115\u00d7\u2115\u2192\u2115 \u2115\u00d7\u2115\u2192\u2115-inj\n  where open \u2115\u00d7\u2115\u2192\u2115-properties using (\u2115\u00d7\u2115\u2192\u2115-inj)\n\n-- Task 2. Prove that \u2115 has the same cardinality as \u2115 ^ n, where n is finite.\n\n\u00d7-mono\u02e1-\u21d4 : \u2200 {B B'} A \u2192 B \u21d4 B' \u2192 (A \u00d7 B) \u21d4 (A \u00d7 B')\n\u00d7-mono\u02e1-\u21d4 {B} {B'} A (Bijection B\u2192B' B'\u2192B B\u2192B'\u2192B B'\u2192B\u2192B') = Bijection\n  (\u03bb { (a , b) \u2192 (a , B\u2192B' b) })\n  (\u03bb { (a , b') \u2192 (a , B'\u2192B b') })\n  (\u03bb { (a , b) \u2192 cong (a ,_) (B\u2192B'\u2192B b) })\n  (\u03bb { (a , b') \u2192 cong (a ,_) (B'\u2192B\u2192B' b') })\n\n\u2115\u21d4\u2115^suc : \u2200 n \u2192 \u2115 \u21d4 \u2115^ (suc n)\n\u2115\u21d4\u2115^suc zero = Bijection\n  (\u03bb n \u2192 (n , tt) )\n  (\u03bb { (n , tt) \u2192 n })\n  (\u03bb _ \u2192 refl )\n  (\u03bb { (n , tt) \u2192 refl } )\n\u2115\u21d4\u2115^suc (suc n) = \u21d4-trans \u2115\u21d4\u2115\u00d7\u2115 (\u00d7-mono\u02e1-\u21d4 \u2115 (\u2115\u21d4\u2115^suc n))","lang_id":1,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:19","updated_at":"2023-01-14 13:23:19"}]}