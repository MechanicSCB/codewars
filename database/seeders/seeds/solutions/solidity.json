{"50654ddff44f800200000004":[{"id":338278,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract DummyToken {\n  function multiply(int a, int b) public pure returns (int) {\n    return a * b;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338279,"user_id":null,"body":"pragma solidity >=0.6.2;\n\ncontract DummyToken {\n  function multiply(int a, int b) pure public returns (int) {\n    return a * b;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338280,"user_id":381,"body":"pragma solidity >=0.4.19;\n\ncontract DummyToken {\n  function multiply(int a, int b) pure public returns (int) {\n    return a * b;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338281,"user_id":2293,"body":"pragma solidity ^0.4.13;\n\ncontract DummyToken {\n  function multiply(int a, int b) constant returns (int) {\n    int c = a * b;\n    assert(a == 0 || c \/ a == b);\n    return c;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338282,"user_id":null,"body":"\/\/SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\ncontract DummyToken {\n  function multiply(int a, int b) pure public returns (int) {\n    return a * b;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338283,"user_id":null,"body":"\/\/SPDX-License-Identifier: Unlicense\npragma solidity >=0.4.19;\n\ncontract DummyToken {\n  function multiply(int a, int b) pure public returns (int) {\n    return a * b;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338284,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract DummyToken {\n  function multiply(int a, int b) pure public returns (int) {\n    int c = a * b;\n    return (c);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338285,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract DummyToken {\n  function multiply(int a, int b) pure public returns (int) {\n    int answer = a * b ;\n    return answer;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338286,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract DummyToken {\n  function multiply(int256 a, int256 b) pure public returns (int256) {\n    return a * b;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338287,"user_id":null,"body":"pragma solidity ^0.6.2;\ncontract DummyToken {\n  function multiply(int a, int b) public pure returns (int) { return a * b; }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"51b62bf6a9c58071c600001b":[{"id":338288,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n    \n    uint[13] key = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string[13] numerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n    \n    function solution(uint n) public view returns (string) {\n        \/\/ Convert the positive integer to a Roman Numeral\n        string memory res = \"\";\n        for (uint i = 0; i < key.length; i++) {\n            while (n >= key[i]) {\n                n -= key[i];\n                res = strConcat(res, numerals[i]);\n            } \n        }\n        return res;\n    }\n    \n    function strConcat(string _a, string _b) internal pure returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        string memory ret = new string(_ba.length + _bb.length);\n        bytes memory bret = bytes(ret);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++)bret[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\n        return string(bret);\n   } \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338289,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  \n  uint[] key = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n  string[] numerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n  \n  function solution(uint n) returns (string) {\n    string memory res = \"\";\n        for (uint i = 0; i < key.length; i++) {\n            while (n >= key[i]) {\n                n -= key[i];\n                res = strConcat(res, numerals[i]);\n            } \n        }\n        return res;\n    }\n    \n    function strConcat(string _a, string _b) internal pure returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        string memory ret = new string(_ba.length + _bb.length);\n        bytes memory bret = bytes(ret);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++)bret[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\n        return string(bret);\n    } \/\/ Convert the positive integer to a Roman Numeral\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338290,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  \n  uint256[] keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n  \n  string[] nums = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];\n  \n  function solution(uint n) public view returns (string) {\n    string memory res = \"\";\n    for (uint i = 0; i < keys.length; i++) {\n      while (n >= keys[i]) {\n        n -= keys[i];\n        res = stingfy(res, nums[i]);\n      }\n    }\n    return res;\n  }\n  \n  function stingfy (string _a, string _b) internal pure returns (string) {\n    bytes memory _ba = bytes(_a);\n    bytes memory _bb = bytes(_b);\n    string memory ret = new string(_ba.length + _bb.length);\n    bytes memory bret = bytes(ret);\n    uint k = 0;\n    for (uint i = 0; i < _ba.length; i++) {\n      bret[k++] = _ba[i];\n    }\n    for (i = 0; i < _bb.length; i++) {\n      bret[k++] = _bb[i];\n    }\n    return string(bret);\n  }\n  \n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338291,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n    \n    uint[13] key = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string[13] numerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n    \n    function solution(uint n) public view returns (string) {\n        string memory res = \"\";\n        for (uint i = 0; i < key.length; i++) {\n            while (n >= key[i]) {\n                n -= key[i];\n                res = strConcat(res, numerals[i]);\n            } \n        }\n        return res;\n    }\n    \n    function strConcat(string _a, string _b) internal pure returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        string memory ret = new string(_ba.length + _bb.length);\n        bytes memory bret = bytes(ret);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++)bret[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\n        return string(bret);\n   } \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338292,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function solution(uint n) public returns (string) {\n    string memory roman=\"\";\n    while(n>0)\n      {\n        while(n>=5)\n          {\n             while(n>=10)\n            {\n               while(n>=50)\n              {\n                 while(n>=100)\n                {\n                   while(n>=500)\n                  {\n                     while(n>=1000)\n                    {\n                      roman = concat(roman,\"M\");\n                      n-=1000;\n                    } \n                    if(n>=900)\n                      {\n                        n-=900;\n                        roman = concat(roman,\"CM\");\n                      }\n                    if(n>=500)\n                      {\n                        n-=500;\n                        roman = concat(roman, \"D\");\n                      }\n                  } \n                         if(n>=400)\n                      {\n                        n-=400;\n                        roman = concat(roman,\"CD\");\n                      }\n                     if(n>=100)\n                     { \n                       n-=100;                  \n                      roman = concat(roman, \"C\");\n                     }\n                } \n                             if(n>=90)\n                      {\n                        n-=90;\n                        roman = concat(roman,\"XC\");\n                      }\n                   if(n>=50)\n                     { n-=50;          \n                      roman = concat(roman, \"L\");}\n              }                if(n>=40)\n                      {\n                        n-=40;\n                        roman = concat(roman,\"XL\");\n                      }\n            \n                   if(n>=10)\n                     { n-=10;\n                      roman = concat(roman, \"X\");}\n            } \n                             if(n>=9)\n                      {\n                        n-=9;\n                        roman = concat(roman,\"IX\");\n                      }\n                 if(n>=5)\n                   { n-=5;   \n                      roman = concat(roman, \"V\");}\n          }\n             if(n>=4)\n                      {\n                        n-=4;\n                        roman = concat(roman,\"IV\");\n                      }\n                 if(n>0)\n                   {  n-=1; \n                      roman = concat(roman, \"I\");}\n      }\n    return roman;\n  }\n  \n  function concat (string _a, string _b) internal returns (string)\n  {\n    bytes memory _ba = bytes(_a);\n    bytes memory _bb = bytes(_b);\n    string memory ab = new string(_ba.length + _bb.length);\n    bytes memory bab = bytes(ab);\n    uint k=0;\n    for(uint i=0;i<_ba.length; i++)bab[k++] = _ba[i];\n    for(i=0;i<_bb.length; i++)bab[k++] = _bb[i];\n    return string(bab);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338293,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  uint[] key = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n  string[] numerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n    \n  function solution(uint n) returns (string) {\n    \/\/ Convert the positive integer to a Roman Numeral, \"C\"\n    \n     string memory res = \"\";\n        for (uint i = 0; i < key.length; i++) {\n            while (n >= key[i]) {\n                n -= key[i];\n                res = strConcat(res, numerals[i]);\n            } \n        }\n        return res;\n  }\n  \n     function strConcat(string _a, string _b) internal pure returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        string memory ret = new string(_ba.length + _bb.length);\n        bytes memory bret = bytes(ret);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++)bret[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\n        return string(bret);\n   } \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338294,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n    uint[] nums;\n    function solution(uint n) returns (string) {\n        delete nums;\n        string memory result = \"\";\n        while (n > 0) {\n            nums.push(n % 10);\n            n = n \/ 10;\n        }\n        for (uint i = 0; i < nums.length; i++) result = concat(getRomNum(i + 1, nums[i]), result);\n        return result;\n    }\n    \n    function getRomNum(uint pos, uint n) returns(string) {\n        if (n == 0) return '';\n        string memory symb1;\n        string memory symb5;\n        string memory symb10;    \n        if (pos == 4) {\n            return nChar(n, \"M\");\n        } else if (pos == 3) {\n            symb1 = \"C\";\n            symb5 = \"D\";\n            symb10 = \"M\";\n        } else if (pos == 2) {\n            symb1 = \"X\";\n            symb5 = \"L\";\n            symb10 = \"C\";\n        } else if (pos == 1) {\n            symb1 = \"I\";\n            symb5 = \"V\";\n            symb10 = \"X\";\n        }\n\n        if ((n <= 3) && (n >= 1)) {\n            return nChar(n, symb1);\n        } else if (n == 4) {\n            return concat(symb1, symb5);\n        } else if (n == 5) {\n            return symb5;   \n        } else if ((n <= 8) && (n >= 6)) {\n            return concat(symb5, nChar(n - 5, symb1));\n        } else if (n == 9) {\n            return concat(symb1, symb10);\n        } else return \"\";\n    }\n\n    \/\/Returns ch n times\n    function nChar(uint n, string memory ch) returns(string) {\n      string memory res = '';\n      for (uint i = 0; i < n; i++) res = concat(res, ch);\n      return res;\n    }\n\n    function concat(string a, string b) constant returns (string){\n        bytes memory bytes_a = bytes(a);\n        bytes memory bytes_b = bytes(b);\n        string memory length_ab = new string(bytes_a.length + bytes_b.length);\n        bytes memory bytes_c = bytes(length_ab);\n        uint k = 0;\n        for (uint i = 0; i < bytes_a.length; i++) bytes_c[k++] = bytes_a[i];\n        for (i = 0; i < bytes_b.length; i++) bytes_c[k++] = bytes_b[i];\n        return string(bytes_c);\n    }\n\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338295,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  string public romanNumeral;\n  uint public t = 0;\n  string public tRoman = \"\";\n  uint public h;\n  string public hRoman = \"\";\n  uint public d;\n  string public dRoman;\n  uint public u;\n  string public uRoman;\n  bytes public test;\n    \n  function solution(uint n) public returns (string memory) {\n    \/\/ Convert the positive integer to a Roman Numeral\n    uint romanNumeralInt = n;\n    tRoman = \"\";\n    hRoman = \"\";\n    dRoman = \"\";\n    uRoman = \"\";\n    \n    if (10000 > romanNumeralInt && romanNumeralInt > 999) {\n      t = romanNumeralInt \/ 1000;\n\n      if (t == 1) {tRoman = \"M\";}\n      else if  (t == 2) {tRoman = \"MM\";}\n      else if  (t == 3) {tRoman = \"MMM\";}\n      else {tRoman = \"\";}\n\n      romanNumeral = tRoman;\n\n      romanNumeralInt = romanNumeralInt - t*1000;\n    }\n    \n    if (1000 > romanNumeralInt && romanNumeralInt > 99) {\n      h = romanNumeralInt \/ 100;\n\n      if (h == 1) {hRoman = \"C\";}\n      else if  (h == 2) {hRoman = \"CC\";}\n      else if  (h == 3) {hRoman = \"CCC\";}\n      else if  (h == 4) {hRoman = \"CD\";}\n      else if  (h == 5) {hRoman = \"D\";}\n      else if  (h == 6) {hRoman = \"DC\";}\n      else if  (h == 7) {hRoman = \"DCC\";}\n      else if  (h == 8) {hRoman = \"DCCC\";}\n      else if  (h == 9) {hRoman = \"CM\";}\n      else {hRoman = \"\";}\n\n      romanNumeral = concatenate(romanNumeral,hRoman);\n\n      romanNumeralInt = romanNumeralInt - h*100;\n    }\n    \n    if (100 > romanNumeralInt && romanNumeralInt > 9) {\n      d = romanNumeralInt \/ 10;\n\n      if (d == 1) {dRoman = \"X\";}\n      else if  (d == 2) {dRoman = \"XX\";}\n      else if  (d == 3) {dRoman = \"XXX\";}\n      else if  (d == 4) {dRoman = \"XL\";}\n      else if  (d == 5) {dRoman = \"L\";}\n      else if  (d == 6) {dRoman = \"LX\";}\n      else if  (d == 7) {dRoman = \"LXX\";}\n      else if  (d == 8) {dRoman = \"LXXX\";}\n      else if  (d == 9) {dRoman = \"XC\";}\n      else {dRoman = \"\";}\n\n      romanNumeral = concatenate(romanNumeral,dRoman);\n\n      romanNumeralInt = romanNumeralInt - d*10;\n    }\n    \n    if (10 > romanNumeralInt && romanNumeralInt >= 0) {\n      if (romanNumeralInt == 1) {uRoman = \"I\";}\n      else if  (romanNumeralInt == 2) {uRoman = \"II\";}\n      else if  (romanNumeralInt == 3) {uRoman = \"III\";}\n      else if  (romanNumeralInt == 4) {uRoman = \"IV\";}\n      else if  (romanNumeralInt == 5) {uRoman = \"V\";}\n      else if  (romanNumeralInt == 6) {uRoman = \"VI\";}\n      else if  (romanNumeralInt == 7) {uRoman = \"VII\";}\n      else if  (romanNumeralInt == 8) {uRoman = \"VIII\";}\n      else if  (romanNumeralInt == 9) {uRoman = \"IX\";}\n      else {uRoman = \"\";}\n\n      romanNumeral = concatenate(romanNumeral,uRoman);\n    }\n    \n    \/\/ romanNumeral = string(abi.encodePacked(tRoman, hRoman, dRoman, uRoman));\n    \n    return(romanNumeral);\n  }\n  \n\/\/   function concatenate(string memory a,string memory b) public pure returns (string memory){\n\/\/     \/\/   return string(bytes.concat(bytes(a), \" \", bytes(b)));\n\/\/       return string(a);\n\/\/   }\n\n  function concatenate(string memory _a, string memory _b)\n        internal\n        pure\n        returns (string memory _concatenatedString)\n    {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        string memory abcde = new string(_ba.length + _bb.length);\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        uint256 i = 0;\n        for (i = 0; i < _ba.length; i++) {\n            babcde[k++] = _ba[i];\n        }\n        for (i = 0; i < _bb.length; i++) {\n            babcde[k++] = _bb[i];\n        }\n        return string(babcde);\n    }\n\n  function getRomanNumeral() public view returns(string){\n      return romanNumeral;\n  }\n\n  function getURoman() public view returns(string){\n      return uRoman;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338296,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {  \n  function solution(uint n) public returns (string) {\n    \/\/ Convert the positive integer to a Roman Numeral\n    bytes memory _result = new bytes(32);\n    uint8 index = 0;\n    uint current = n;\n    \n    while (current > 0) {\n      if (current \/ 1000 > 0) {\n        _result[index++] = 'M';\n        current = current - 1000;\n      }\n      else if (current \/ 900 == 1) {\n        _result[index++] = 'C';\n        _result[index++] = 'M';\n        current = current - 900;\n      }\n      else if (current \/ 500 > 0) {\n        _result[index++] = 'D';\n        current = current - 500;\n      }\n      else if (current \/ 400 == 1) {\n        _result[index++] = 'C';\n        _result[index++] = 'D';\n        current = current - 400;\n      }\n      else if (current \/ 100 > 0) {\n        _result[index++] = 'C';\n        current = current - 100;\n      }\n      else if (current \/ 90 == 1) {\n        _result[index++] = 'X';\n        _result[index++] = 'C';\n        current = current - 90;\n      }\n      else if (current \/ 50 > 0) {\n        _result[index++] = 'L';\n        current = current - 50;\n      }\n      else if (current \/ 40 == 1) {\n        _result[index++] = 'X';\n        _result[index++] = 'L';\n        current = current - 40;\n      }\n      else if (current \/ 10 > 0) {\n        _result[index++] = 'X';\n        current = current - 10;\n      }\n      else if (current == 9) {\n        _result[index++] = 'I';\n        _result[index++] = 'X';\n        current = current - 9;\n      }\n      else if (current \/ 5 > 0) {\n        _result[index++] = 'V';\n        current = current - 5;\n      }\n      else if (current == 4) {\n        _result[index++] = 'I';\n        _result[index++] = 'V';\n        current = current - 4;\n      }\n      else if (current > 0) {\n        _result[index++] = 'I';\n        current = current - 1;\n      }\n    }\n    \n    return string(_result);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338297,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n    uint[] numbers = [1000, 500, 100, 50, 10, 5, 1];\n    string roman = \"MDCLXVI\";\n\n  function solution(uint n) public view returns(string){\n    \/\/ Convert the positive integer to a Roman Numeral\n    bytes memory str = bytes(roman);\n    string memory tmp = new string(256);\n    bytes memory number = bytes(tmp);\n    uint[] memory numOfEach = new uint[](numbers.length);\n    uint mod = n;\n    for(uint i=0; i<numbers.length; i++) {\n        if(i == numbers.length - 1){\n            numOfEach[i] = mod;\n            break;\n        }\n        numOfEach[i] = (mod - n % numbers[i]) \/ numbers[i];  \n        mod = mod % numbers[i];\n    }\n\n    \/\/Byte manipulation dark magic\n    uint8 count;\n    for(i=0;i<numbers.length;i++){\n        for(uint j=0; j<numOfEach[i]; j++){\n            if(numOfEach[i] > 3 && (numOfEach[i-1] >= 1)){\n                number[count - 1] = str[i];\n                number[count] = str[i - 2];\n                count += 1;\n                break;\n            }\n            if(numOfEach[i] > 3){\n                number[count] = str[i];\n                number[count + 1] = str[i - 1];\n                count += 2;\n                break;\n            }\n            number[count] = str[i];\n            count++;\n        }\n    }\n    return string(number);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"525caa5c1bf619d28c000335":[{"id":338298,"user_id":676,"body":"pragma solidity ^0.4.13;\n\ncontract TicTacToe {\n  function is_solved(int[3][] board) returns (int) {\n    if (isWinner(board, 1)) return 1;\n    if (isWinner(board, 2)) return 2;\n    \n    for (uint i = 0; i < 3; ++i)\n    for (uint j = 0; j < 3; ++j) if (board[i][j] == 0) return -1;\n    return 0;\n  }\n  \n  function isWinner(int[3][] b, int p) returns (bool) {\n    if (p == b[0][0]) {\n      if (p == b[0][1] && p == b[0][2]) return true;\n      if (p == b[1][0] && p == b[2][0]) return true;\n      if (p == b[1][1] && p == b[2][2]) return true;\n    }\n    if (p == b[1][1]) {\n      if (p == b[1][0] && p == b[1][2]) return true;\n      if (p == b[0][1] && p == b[2][1]) return true;\n      if (p == b[0][2] && p == b[2][0]) return true;\n    }\n    if (p == b[2][2]) {\n      if (p == b[2][0] && p == b[2][1]) return true;\n      if (p == b[0][2] && p == b[1][2]) return true;\n    }\n    return false;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338299,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n  function is_solved(int[3][] board) returns (int) {\n    \n    for (uint256 i = 0; i <= 2; i++){\n    \/\/check vertical win\n    if (board[0][i] == board[1][i] && board[0][i] == board[2][i] && board[0][i] != 0){\n      return board[0][i];\n    }\n    \/\/check horizontal win\n    if (board[i][0] == board[i][1] && board[i][0] == board[i][2] && board[i][0] != 0){\n      return board[i][0];\n    }\n  }\n  \/\/check diagonal\n  if (board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[0][0] != 0){\n    return board[0][0];\n  }\n  \/\/other diagonal\n  if (board[2][0] == board[1][1] && board[2][0] == board[0][2] && board[2][0] != 0){\n    return board[2][0];\n  }\n  \/\/check for unsolved board\n  for (i = 0; i <= 2; i++){\n    for (uint256 j = 0; j <= 2; j++){\n      if (board[i][j] == 0){\n        return -1;\n      }\n    }\n  }\n  \/\/by default, the only thing left is a cat\n  return 0;\n    \n    \/*\n    int count = 0;\n    int zero_count = 0;\n    for(uint256 i=0; i<3; i++) {\n      for(uint256 j=0;j<3;j++){\n        if(board[i][j] == 0){\n          zero_count++;\n            return -1;\n        }\n        if(board[i][j] == 1) {\n          if(count == 3) {return 1;}\n          count++;\n        } else{\n          count = 0;\n          if(board[i][j] == 2) {\n            if(count == 3) {return 2;}  \n            count++;    \n          } else return 0;\n         } \n      }\n      }*\/\n    }\n  }","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338300,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n  function is_solved(int[3][] board) returns (int) {\n    int aa = board[0][0];\n    int ab = board[0][1];\n    int ac = board[0][2];\n    int ba = board[1][0];\n    int bb = board[1][1];\n    int bc = board[1][2];\n    int ca = board[2][0];\n    int cb = board[2][1];\n    int cc = board[2][2];\n    \n    if (aa != 0 && aa == ab && ab == ac) return aa;\n    if (ba != 0 && ba == bb && bb == bc) return bb;\n    if (ca != 0 && ca == cb && cb == cc) return cc;\n    \n    if (aa != 0 && aa == ba && ba == ca) return aa;\n    if (ab != 0 && ab == bb && bb == cb) return bb;\n    if (ac != 0 && ac == bc && bc == cc) return cc;\n    \n    if (bb != 0 && aa == bb && bb == cc) return aa;\n    if (bb != 0 && ca == bb && bb == ac) return bb;\n    \n    if (aa == 0 || ab == 0 || ac == 0 || ba == 0 || bb == 0 || bc == 0 || ca == 0 || cb == 0 || cc == 0) return -1;\n    \n    return 0;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338301,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n\n  int[3][3] private magicSquare = [\n         [2, 7, 6],\n         [9, 5, 1],\n         [4, 3, 8]];\n  \n  function is_solved(int[3][] board) public view returns (int) {\n    \n      int calc = 0;\n      int occTie = 0;\n    \n      \/\/checks row\n      for (uint i = 0; i < 3; i++) {\n        for (uint i2 = 0; i2 < 3; i2++) {\n          if (board[i][i2] != 0)\n            calc += magicSquare[i][i2] * board[i][i2];\n          else if (occTie != -1)\n            occTie = -1;\n        }\n        \n        if (calc % 15 == 0 && calc != 0)\n          return calc \/ 15;\n        calc = 0;\n      }\n    \n    \n    \/\/checks line\n    for (i = 0; i < 3; i++) {\n        for (i2 = 0; i2 < 3; i2++) {\n          if (board[i2][i] != 0)\n            calc += magicSquare[i2][i] * board[i2][i];\n        }\n        if (calc % 15 == 0 && calc != 0)\n          return calc \/ 15;\n        calc = 0;\n      }\n    \n    \/\/Diagonal\n    calc = (magicSquare[0][0] * board[0][0]) + (magicSquare[1][1] * board[1][1]) + (magicSquare[2][2] * board[2][2]);\n    if (calc % 15 == 0 && calc != 0)\n        return calc \/ 15;\n    \n    \/\/Anti-diagonal\n    calc = (magicSquare[0][2] * board[0][2]) + (magicSquare[1][1] * board[1][1]) + (magicSquare[2][0] * board[2][0]);\n    if (calc % 15 == 0 && calc != 0)\n        return calc \/ 15;\n\n    return occTie;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338302,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n  \n  function is_solved(int[3][] board) returns (int8) {\n    return checkWin(board, 1) ? int8(1) : checkWin(board, 2) ? int8(2) : checkCatGame(board) ? int8(0) : int8(-1); \n  }\n  \n  function checkWin(int[3][] board, uint8 player) pure internal returns(bool) {\n    if (board[0][0] == player) {\n      if (board[0][1] == player && board[0][2] == player) {\n        return true;\n      }\n      if (board[1][0] == player && board[2][0] == player) {\n        return true;\n      }\n      if (board[1][1] == player && board[2][2] == player) {\n        return true;\n      }\n    }\n    if (board[2][2] == player) {\n      if (board[0][2] == player && board[1][2] == player) {\n        return true;\n      }\n      if (board[2][0] == player && board[2][1] == player) {\n        return true;\n      }\n    }\n    if (board[1][1] == player) {\n      if (board[0][1] == player && board[2][1] == player) {\n        return true;\n      }\n      if (board[1][0] == player && board[1][2] == player) {\n        return true;\n      }\n      if (board[0][2] == player && board[2][0] == player) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  function checkCatGame(int[3][] board) pure internal returns(bool){\n    for (uint i = 0; i < board.length; i++) {\n      for (uint j = 0; j < board[i].length; j++) {\n        if(board[i][j] == 0) return false;\n      }\n    } \n    return true;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338303,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n  \n  function is_solved(int[3][] board) returns (int8) {\n    bool player1 = checkWin(board, 1);\n    bool player2 = checkWin(board, 2);\n    bool isCat = checkCatGame(board);\n    return player1 ? int8(1) : player2 ? int8(2) : isCat ? int8(0) : int8(-1); \n  }\n  \n  function checkWin(int[3][] board, uint8 player) pure internal returns(bool) {\n    if (board[0][0] == player) {\n      if (board[0][1] == player && board[0][2] == player) {\n        return true;\n      }\n      if (board[1][0] == player && board[2][0] == player) {\n        return true;\n      }\n      if (board[1][1] == player && board[2][2] == player) {\n        return true;\n      }\n    }\n    if (board[2][2] == player) {\n      if (board[0][2] == player && board[1][2] == player) {\n        return true;\n      }\n      if (board[2][0] == player && board[2][1] == player) {\n        return true;\n      }\n    }\n    if (board[1][1] == player) {\n      if (board[0][1] == player && board[2][1] == player) {\n        return true;\n      }\n      if (board[1][0] == player && board[1][2] == player) {\n        return true;\n      }\n      if (board[0][2] == player && board[2][0] == player) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  function checkCatGame(int[3][] board) pure internal returns(bool){\n    for (uint i = 0; i < board.length; i++) {\n\t    for (uint j = 0; j < board[i].length; j++) {\n\t\t    if(board[i][j] == 0) return false;\n\t    }\n    } \n    return true;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338304,"user_id":null,"body":"pragma solidity ^0.4.19;\n\/\/import \"truffle\/Console.sol\";\ncontract TicTacToe {\n\n  function is_solved(int[3][] board) external pure returns (int) {\n    \n    int result = 0;\n\n    for(uint i = 0 ; i < 3 ; i++)\n    {\n        if(board[i][0] == board[i][2] && board[i][2] == board[i][1])\n        {\n          if( board[i][0] !=0)\n            return board[i][0];\n        }\n        else if(board[0][i] == board[1][i] && board[1][i] == board[2][i])\n        {\n          if( board[0][i] !=0)\n            return board[0][i];\n        }\n      for(uint j = 0 ; j < 3 ; j++)\n      {\n          if(board[i][j] == 0)\n          {\n              result = -1;\n          }\n      }\n    }\n    if((board[1][1] == board[2][2] && board[0][0] == board[1][1]) || (board[0][2] == board[1][1] && board[1][1] == board[2][0]))\n    {\n      if( board[1][1] !=0)\n        return board[1][1];\n    }\n    \n    \n    \n    return result;\n  }\n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338305,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n function is_solved(uint[3][] board) public returns (int) {\n    \/\/ TODO: Check if the board is solved\n    uint n = board.length;\n    bool emptySlot = false;\n    bool emptySlotInDia1 = false;\n    bool emptySlotInDia2 = false;\n    uint sumDia1 = 0;\n    uint sumDia2 = 0;\n   \n    for (uint i = 0; i < n; i++) {\n      uint sumRow = 0;\n      bool emptySlotInRow = false;\n      for (uint j = 0; j < n; j++) {\n        sumRow = sumRow + board[i][j];\n        if (board[i][j] == 0) {\n          emptySlotInRow = true;\n          emptySlot = true;\n        }\n      }\n      if (sumRow == 3 && emptySlotInRow == false) {\n        return 1;\n      }\n        \n      if (sumRow == 6) {\n        return 2;\n      }\n      \n      uint sumCol = 0;\n      bool emptySlotInCol = false;\n      for (uint l = 0; l < n; l++) {\n        sumCol = sumCol + board[l][i];\n        if (board[l][i] == 0) {\n          emptySlotInCol = true;\n        }\n      }\n      if (sumCol == 3 && emptySlotInCol == false) {\n        return 1;\n      }\n        \n      if (sumCol == 6) {\n        return 2;\n      }\n      \n      sumDia1 += board[i][i];\n      if (board[i][i] == 0 ) {\n        emptySlotInDia1 = true;        \n      }\n      \n      sumDia2 += board[i][n-1-i];\n      if (board[i][2-i] == 0) {\n        emptySlotInDia2 = true;        \n      }\n    }\n   \n    if (sumDia1 == 3 &&  emptySlotInDia1 == false) {\n        return (1);\n    } \n    if (sumDia1 == 6 &&  emptySlotInDia1 == false) {\n        return (2);\n    }  \n    if (sumDia2 == 3 &&  emptySlotInDia2 == false) {\n        return (1);\n    } \n    if (sumDia2 == 6 &&  emptySlotInDia2 == false) {\n        return (2);\n    }  \n    \n    if (emptySlot == true) {\n      return -1;\n    } else {\n      return 0;\n    }\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338306,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract TicTacToe {\n  function winner(int[3][] memory board,\n                  uint8 x1, uint8 y1,\n                  uint8 x2, uint8 y2,\n                  uint8 x3, uint8 y3) internal pure returns (int) {\n    if (board[x1][y1] != 0 && board[x1][y1] == board[x2][y2] && board[x1][y1] == board[x3][y3])\n      return board[x1][y1];\n    return 0;\n  }\n  function is_solved(int[3][] board) external pure returns (int) {\n    int w = 0;\n    if ((w = winner(board, 0, 0, 0, 1, 0, 2)) != 0) return w;\n    if ((w = winner(board, 1, 0, 1, 1, 1, 2)) != 0) return w;\n    if ((w = winner(board, 2, 0, 2, 1, 2, 2)) != 0) return w;\n    if ((w = winner(board, 0, 0, 1, 0, 2, 0)) != 0) return w;\n    if ((w = winner(board, 0, 1, 1, 1, 2, 1)) != 0) return w;\n    if ((w = winner(board, 0, 2, 1, 2, 2, 2)) != 0) return w;\n    if ((w = winner(board, 0, 0, 1, 1, 2, 2)) != 0) return w;\n    if ((w = winner(board, 0, 2, 1, 1, 2, 0)) != 0) return w;\n    for (uint8 i = 0; i < 3; i++)\n      for (uint8 j = 0; j < 3; j++)\n        if (board[i][j] == 0)\n          return -1;\n    return 0;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338307,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract TicTacToe {\n  event Test(int[3][] board, bool result);\n  function is_solved(int[3][] board) returns (int) {\n    for (uint256 i = 0; i < 3; i += 1) {\n      if (rowCompleted(board[i])) {\n        Test(board, rowCompleted(board[i]));\n        return board[i][0];\n      }\n      \n      if (columnCompleted(board, i)) {\n        Test(board, columnCompleted(board, i));\n        return board[0][i];\n      }\n      \n      if (diagCompleted(board)) {\n        Test(board, diagCompleted(board));\n        return board[1][1];\n      } \n      \n      if (catGame(board)) {\n        return 0;\n      }\n    } \n    return -1;\n  }\n  \n  function catGame(int[3][] board) returns (bool) {\n    return noZero(board[0]) && noZero(board[1]) && noZero(board[2]);\n  }\n  \n  function noZero(int[3] row) returns (bool) {\n    return row[0] != 0 && row[1] != 0 && row[2] != 0;\n  }\n\n  function rowCompleted(int[3] row) returns (bool) {\n    return row[0] == row[1] && row[0] == row[2] && row[0] != 0;\n  }\n  \n  function columnCompleted(int[3][] board, uint256 j) returns (bool) {\n    return board[0][j] == board[1][j] && board[0][j] == board[2][j] && board[0][j] != 0;\n  }\n  \n  function diagCompleted(int[3][] board) returns (bool) {\n    bool diag = board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[1][1] != 0;\n    bool tDiag = board[0][2] == board[1][1] && board[0][2] == board[2][0] && board[1][1] != 0;\n    return diag || tDiag;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5513795bd3fafb56c200049e":[{"id":338308,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) view returns (int[]) {\n    int[] z;\n    \/\/ TODO: Your code here \n    for (int i=1; i <= n; i ++) {\n      z.push(i*x);\n    }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338309,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) pure public returns (int[] memory) {\n    int[] memory z = new int[](uint(n));\n    for(int i=1; i<n+1; i++) {\n      z[uint(i)-1] = x * i;\n    }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338310,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) view returns (int[]) {\n    int[] z;\n    for (int i = 1; i <= n; i++) {\n      z.push(x * i);\n    }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338311,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n  function count_by(int x, int n) returns (int[]) {\n    int[] z;\n    for (int i = 1; i <= n; i ++) z.push(i * x);\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338312,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) public view returns (int[]) {\n    int[] z;\n    int y;\n    while (n-- > 0)\n      z.push(y += x);\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338313,"user_id":76,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) public returns (int[]) {\n    int[] z;\n    for (int i = x; i <= n * x; i += x) {\n      z.push(i);\n    }   \n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338314,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) view returns (int[]) {\n    int[] z;\n    \n    for (int i = x; i \/ x <= n; i = i + x) z.push(i);\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338315,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) public view returns (int[]) {\n    int[] z;\n    if(x!=0 && n!=0){\n      for(int256 i=x;i<=(x*n);i=i+x){\n        z.push(i);\n      }\n    }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338316,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) view returns (int[]) {\n    int[] z;\n    \/\/ TODO: Your code here      \n    \n    \n    for (int cnt=1; cnt < n+1; cnt++){\n        z.push(x*cnt);\n    }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338317,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract CountByX {\n\n  function count_by(int x, int n) view returns (int[]) {\n    int[] z;\n    \/\/ TODO: Your code here      i \n    for(int i=1; i <= n; i++ ) {\n      z.push(i * x);\n    }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5545f109004975ea66000086":[{"id":338318,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    return(n % x + n % y == 0);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338319,"user_id":645,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    return n % x == 0 && n % y == 0;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338320,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    \/\/\/  All inputs should be a positive, non-zero digits.\n    \/\/\/  require( (n > 0 && x > 0 && y > 0, \"All inputs are positive, non-zero digits.\");\n\n    if ( n % x == 0 && n % y == 0 )\n      return true;\n    \n    return false;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338321,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    \/\/ your code here\n      if ((n % x) == 0 && (n % y) == 0){\n        return true;\n      }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338322,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    if (n % x != 0 || n % y !=0) {\n      return false;\n    }\n    return true;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338323,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    \/\/ your code here\n    if (n % x == 0 && n % y == 0){\n      bool isit = true;\n    }\n    return isit;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338324,"user_id":50,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    return n%y + n%x == 0 ;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338325,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    \/\/ your code here\n    var val = true;\n    n%x == 0 && n%y == 0 ? val = true : val = false;\n    return val;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338326,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    bool wasDivisible = true;\n    if ((n % x == 0) && (n % y == 0)) {\n      return wasDivisible;\n    }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338327,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function is_divisible(int n, int x, int y) public pure returns (bool) {\n    int resx = n \/ x;\n    int resy = n \/ y;\n    if ((resx * x) == n && (resy * y) == n){\n      return true;\n    }\n    else{\n      return false;\n    }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"55cbc3586671f6aa070000fb":[{"id":338328,"user_id":76,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    return base % factor == 0;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338329,"user_id":null,"body":"pragma solidity >=0.4.19 <0.7.0;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    return factor != 0 && base % factor == 0;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338330,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    if (base%factor == 0){\n    return true;\n    }else{\n    return false;}\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338331,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    if (base%factor == 0){\n    return true;\n      }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338332,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    if(base % factor == 0)\n      return true;\n    return false;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338333,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    return base % factor == 0 ? true : false;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338334,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) \n  {\n    return !(base % factor > 0);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338335,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    if  (base % factor < 1) {\n    return true;  \n    }   \n    return false;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338336,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(int base, int factor) public pure returns (bool) {\n    int result = base % factor;\n    if (result == 0) {\n    return true;\n    }\n    return false;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338337,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function checkForFactor(uint base, uint factor) public pure returns (bool) {\n    return base % factor == 0;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"55d24f55d7dd296eb9000030":[{"id":338338,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    \/\/ your code here\n    int sum = 0;\n    for (int i = 1; i<=n; i++){\n      sum += i; \n    }\n    return sum;\n  }  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338339,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    return (n + n * n) \/ 2;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338340,"user_id":645,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    return n * (n + 1) \/ 2;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338341,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    int res = 0; \/\/result integer\n    \n    for (int i=1; i<=n; i++) res += i; \n      \n    return res;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338342,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(uint n) public pure returns (uint) {\n    return n * (n + 1) \/ 2;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338343,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    if(n == 0){\n      return 0;\n    }\n    return n + summation(n - 1);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338344,"user_id":564,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    return (n * n + n) \/ 2;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338345,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    if(n > 0) {\n      int len = 0;\n      int j = 0;\n      \n      for(len; len <= n; len++) {\n        j += len;\n      }\n      \n      return j;\n    }\n    return n;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338346,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    \/\/ your code here\n    \/\/ create a start point\n    int sum = 0;\n    \/\/ after make a for to run the beging point at the end of the challege\n    for (int i = 1; i <= n; i++) {\n      \/\/ add a int sum, that us declare in the begin\n      sum += i;\n    }\n    \/\/ return value\n    return sum;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338347,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function summation(int n) public pure returns (int) {\n    \/\/ your code here\n    int sum = 0;\n    for(int i =0; i<n+1; i++){\n      sum +=i;\n    }\n    return sum;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"55f9bca8ecaa9eac7100004a":[{"id":338348,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    \/\/ your code here\n    int ss = h*60*60 + m*60 + s;\n    return ss * 1000;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338349,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(uint h, uint m, uint s) public pure returns (uint) {\n    return 1000*(h*3600+m*60+s);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338350,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n      \/*\n    h = 0\n    m = 1\n    s = 1\n    result = 61000\n    *\/\n    \n    require(h>=0 && h<=23);\n    require(m>=0 && m<=59);\n    require(s>=0 && s<=59);\n    \n    int secondsConstant = 1000;\n    int minutesConstant = secondsConstant * 60;\n    int hoursConstant = minutesConstant * 60;\n    return h * hoursConstant + m*minutesConstant + s * secondsConstant;\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338351,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    return (h*3600000)+(m*60000)+(s*1000);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338352,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    require(h<24 && m<61 && s<61);\n    return h*60*60*1000 + m*60*1000 + s * 1000;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338353,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    return (s + (m + h * 60) * 60) * 1000;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338354,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    \/\/ 1 sec = 1000 ms, 1 minute = 60000 ms, 1 hr = 3600000 ms      \n    \/\/res = h*3600000+m*60000+s*1000; \n\n    return h*3600000+m*60000+s*1000;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338355,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    \/\/ your code here\n\n    int ss = s + m*60 + h*60*60; \/\/ss means how many seconds\n\n    return ss*1000; \/\/return milliseconds\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338356,"user_id":527,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    return ((h * 60 + m) * 60 + s) * 1000;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338357,"user_id":645,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function past(int h, int m, int s) public pure returns (int) {\n    return (h * 3600 + m * 60 + s) * 1000;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"55fd2d567d94ac3bc9000064":[{"id":338358,"user_id":344,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(uint n) public returns (uint) {\n    return n ** 3;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338359,"user_id":645,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n    return n * n * n;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338360,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n    \n    int sum = 0;\n    int first = n * (n - 1) + 1;\n    \n    for(int i=0; i<n; i++) {\n      sum += first + i*2;\n    }\n    \n    return sum;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338361,"user_id":null,"body":"pragma solidity ^0.4.19; \/\/first figure out the first num of each row in the pyramid\ncontract Kata {\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n        \/\/ your code here\n        \n        int nRow = n * n * n;\n        return nRow;\n      }\n      }","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338362,"user_id":null,"body":"pragma solidity ^0.4.19;\n\n\ncontract Kata {\n  \n  \n  function row_sum_odd_numbers(uint n) public pure returns (uint) {\n    \/\/ your code here\n    return n**3;\n    }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338363,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n        int z = 0;\n        int i = n - 1;\n        while (i != 0) {\n            z += i;\n            i -= 1;\n        }\n        if (z == 0) {\n            return 1;\n        } else if (z == 1) {\n            return 8;\n        } else {\n            return ((z + n)*(z+n))-((z*z));\n        }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338364,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(uint n) public pure returns (uint) {\n        return (n** 2) * n;\n    }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338365,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n    \/\/ your code here\n    int start = n * (n-1) + 1;\n    int result = 0;\n    for (int i = 0; i<n; i++)\n      result = result + start + i*2;\n    return result;\n    \n      \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338366,"user_id":null,"body":"\/\/ SPDX-Lincense-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Kata {\n\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n    return (n * n) * n;\n  }\n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338367,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function row_sum_odd_numbers(int n) public pure returns (int) {\n    return (((n*(n-1)\/2)+1)*2-1)*n+2*(n*(n-1)\/2);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"563a631f7cbbc236cf0000c2":[{"id":338368,"user_id":53,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    return p + 2 * r;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338369,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    return r * 2 + p;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338370,"user_id":645,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    return p + r * 2;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338371,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    \/\/ your code here\n    int rolls = r + r;\n    int result = rolls + p;\n    \n    return result;\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338372,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    \/\/ your code here\n   int sum = p + r * 2;\n    return sum;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338373,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    int newPosition = p + (2*r);\n    return newPosition;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338374,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    \/\/ your code here\n    return p + r + r ;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338375,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int position, int roll) public pure returns (int) {\n    \/\/ your code here\n    return position + roll * 2;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338376,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    \/\/ your code here\n    int sum = r + r;\n    int finalSum = sum + p;\n    return finalSum;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338377,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function move(int p, int r) public pure returns (int) {\n    \/\/ your code here\n    return 2*r + p;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"57a0e5c372292dd76d000d7e":[{"id":338378,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) returns (string) {\n    bytes memory bpattern = bytes(pattern);\n    uint resultLength = repeat * bpattern.length;\n    string memory result = new string(resultLength);\n    bytes memory bresult = bytes(result);\n    for (uint i = 0; i < resultLength; i++) {\n        bresult[i] = bpattern[i % bpattern.length];\n    }\n    return string(bresult);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338379,"user_id":null,"body":"pragma solidity ^0.4.13;\ncontract Repeater {\n  string s;\n  bytes b;\n  function multiply(uint8 repeat, string pattern) returns (string) {\n    b=bytes(pattern);\n    for (uint i=0; i<repeat; i++) \n      for (uint j=0; j<b.length; j++) bytes(s).push(b[j]);\n    return s;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338380,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) returns (string) {\n    uint patternLen = bytes(pattern).length;\n    uint resultLen = patternLen * repeat;\n    bytes memory result = new bytes(resultLen);\n    for(uint i = 0; i < resultLen; i++) {\n        result[i] = bytes(pattern)[i % patternLen];\n    }\n    return string(result);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338381,"user_id":null,"body":"\npragma solidity ^0.4.19;\n\ncontract Repeater {\n\nfunction strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n    bytes memory _ba = bytes(_a);\n    bytes memory _bb = bytes(_b);\n    bytes memory _bc = bytes(_c);\n    bytes memory _bd = bytes(_d);\n    bytes memory _be = bytes(_e);\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n    bytes memory babcde = bytes(abcde);\n    uint k = 0;\n    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n    for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n    for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n    for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n    for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n    return string(babcde);\n}\n\nfunction strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n    return strConcat(_a, _b, _c, _d, \"\");\n}\n\nfunction strConcat(string _a, string _b, string _c) internal returns (string) {\n    return strConcat(_a, _b, _c, \"\", \"\");\n}\n\nfunction strConcat(string _a, string _b) internal returns (string) {\n    return strConcat(_a, _b, \"\", \"\", \"\");\n}\n\n  function multiply(uint8 repeat, string pattern) returns (string) {\nstring memory s='';\n\nfor (uint8 i=1; i<=repeat;i++)\n{\nif (i==repeat)\n{\n}\ns=strConcat(s,pattern);\n}\nreturn s;\n}\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338382,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) public pure returns (string) {\n      bytes memory _p = bytes(pattern);\n      string memory ret = new string(repeat * _p.length);\n      bytes memory bret = bytes(ret);\n      for (uint i = 0; i < repeat; i++) {\n          for (uint j = 0; j < _p.length; j++) {\n              bret[i*_p.length + j] = _p[j];\n          }\n      }\n    return string(bret);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338383,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  \n  function multiply(uint8 repeat, string pattern) returns (string) {\n    \n    bytes storage ret;\n    bytes memory pat = bytes(pattern);\n    \n    for (int i=0 ; i<repeat ; i++){\n      for (uint j=0 ; j <pat.length ; j++){\n        ret.push(pat[j]);\n      }\n    }\n    return string(ret);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338384,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) returns (string) {\n    bytes memory pattern_bytes = bytes(pattern);\n    bytes memory result = new bytes(pattern_bytes.length * repeat);\n    for (uint8 index = 0 ; index< result.length; index++){\n        result[index] = pattern_bytes[index%pattern_bytes.length];\n    }\n    return string(result);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338385,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) returns (string) {\n    string memory baseString = \"\";\n    for(uint i =0; i < repeat; i++){\n      baseString = concat(baseString, pattern);\n    }\n    return baseString;\n  }\n  \n    function concat(string _base, string _value) returns (string) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\n        bytes memory _newValue = bytes(_tmpValue);\n\n        uint i;\n        uint j;\n\n        for(i=0; i<_baseBytes.length; i++) {\n            _newValue[j++] = _baseBytes[i];\n        }\n\n        for(i=0; i<_valueBytes.length; i++) {\n            _newValue[j++] = _valueBytes[i];\n        }\n\n        return string(_newValue);\n    }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338386,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) public pure returns (string) {\n    string memory result = new string(repeat * bytes(pattern).length);\n    bytes memory byteString = bytes(result);\n    bytes memory bytePattern = bytes(pattern);\n    uint k = 0;\n    for (uint i = 0; i < repeat; i++) {\n      for (uint j = 0; j < bytes(pattern).length; j++){\n        byteString[k] = bytePattern[j];\n        k++;\n      }       \n    }\n    return string(byteString);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338387,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Repeater {\n  function multiply(uint8 repeat, string pattern) public view returns (string) {\n  string r_string;\n  bytes memory bytesPattern = bytes(pattern);\n    for (uint8 i = 0; i < repeat; i++){\n      for(uint8 j = 0; j < bytes(pattern).length; j++){\n        byte c = byte(bytesPattern[j]);\n        bytes(r_string).push(c);\n      }\n    }\n    return (r_string);\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"59c13f288bcb77dbfe00091f":[{"id":338388,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n  enum moveTypes {\n    none,\n    rock,\n    paper,\n    scissors\n  }\n  \n  struct Game {\n    address payable creator;\n    address payable participant;\n    uint bet;\n    mapping(address => moveTypes) playerMove;\n  }\n  \n  mapping(uint => Game) gamesHistory;\n  mapping(uint => bool) gameStarted;\n  uint gamePlayed = 0;\n  \n  \/**\n  * Use this endpoint to create a game. \n  * It is a payable endpoint meaning the creator of the game will send ether directly to it.\n  * The ether sent to the contract should be used as the bet for the game.\n  * @param participant - The address of the participant allowed to join the game.\n  *\/\n  function createGame(address payable participant) public payable {\n    require(msg.value > 0);\n    gamesHistory[++gamePlayed] = Game(msg.sender, participant, msg.value);\n    gameStarted[gamePlayed] = false;\n    emit GameCreated(msg.sender, gamePlayed, msg.value);\n  }\n  \n  \/**\n  * Use this endpoint to join a game.\n  * It is a payable endpoint meaning the joining participant will send ether directly to it.\n  * The ether sent to the contract should be used as the bet for the game. \n  * Any additional ether that exceeds the original bet of the creator should be refunded.\n  * @param gameNumber - Corresponds to the gameNumber provided by the GameCreated event\n  *\/\n  function joinGame(uint gameNumber) public payable {\n    require(gameNumber <= gamePlayed);\n    require(!gameStarted[gameNumber]);\n    Game storage game = gamesHistory[gameNumber];\n    require(game.participant == msg.sender);\n    require(game.bet <= msg.value);\n    if (game.bet < msg.value)\n      msg.sender.transfer(msg.value - game.bet);\n    address[] memory players = new address[](2);\n    players[0] = game.creator;\n    players[1] = game.participant;\n    gameStarted[gameNumber] = true;\n    emit GameStarted(players, gameNumber);\n  }\n  \n  \/**\n  * Use this endpoint to make a move during a game \n  * @param gameNumber - Corresponds to the gameNumber provided by the GameCreated event\n  * @param moveNumber - The move for this player (1, 2, or 3 for rock, paper, scissors respectively)\n  *\/\n  function makeMove(uint gameNumber, uint moveNumber) public { \n    require(gameNumber <= gamePlayed);\n    require(gameStarted[gameNumber]);\n    Game storage game = gamesHistory[gameNumber];\n    require(game.creator == msg.sender || game.participant == msg.sender);\n    require(1 <= moveNumber && moveNumber <= 3);\n    require(game.playerMove[msg.sender] == moveTypes.none);\n    \n    game.playerMove[msg.sender] = moveTypes(moveNumber);\n    moveTypes moveCreator = game.playerMove[game.creator];\n    moveTypes moveParticipant = game.playerMove[game.participant];\n    address payable gameWinner = address(0);\n    if (moveCreator != moveTypes.none && moveParticipant != moveTypes.none) {\n      if (uint(moveCreator) % 3 + 1 == uint(moveParticipant))\n        gameWinner = game.participant;\n      else if (uint(moveParticipant) % 3 + 1 == uint(moveCreator))\n        gameWinner = game.creator;\n      \n      if (gameWinner == address(0)) {\n        game.creator.transfer(game.bet \/ 2);\n        game.participant.transfer(game.bet \/ 2);\n      }\n      else\n        gameWinner.transfer(game.bet);\n      \n      emit GameComplete(gameWinner, gameNumber);\n    }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338389,"user_id":null,"body":"\/\/ SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[2] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n\n  \n  uint TotalGames;\n  struct game {\n    uint gamenumber;\n    uint bet;\n    address player1;\n    address player2;\n    uint chooseOfp1;\n    uint chooseOfp2;\n    bool gamestarted;\n    bool gameended;\n\n  }\n  game[] games;\n  function createGame(address participant) public payable {\n    require(msg.value > 0, \"you need to make a bet\");\n    games.push(game(TotalGames, msg.value, msg.sender, participant, 0, 0, false, false));\n    emit GameCreated(msg.sender, TotalGames, msg.value);\n    TotalGames++;\n\n\n\n  }\n  \n\n  function joinGame(uint gameNumber) public payable {\n    require(games[gameNumber].gameended == false, \"the game already ended\");\n    require(games[gameNumber].gamestarted == false, \"the game already started\");\n    require(games[gameNumber].player2 == msg.sender, \"you are not a player\");\n    if (msg.value == games[gameNumber].bet) {\n      games[gameNumber].gamestarted = true;\n      address pl1 = games[gameNumber].player1;\n      address pl2 = games[gameNumber].player2;\n      emit GameStarted([pl1, pl2], gameNumber);\n\n    }\n    else if(msg.value > games[gameNumber].bet) {\n      msg.sender.transfer(msg.value - games[gameNumber].bet);\n      games[gameNumber].gamestarted = true;\n       emit GameStarted([games[gameNumber].player2,games[gameNumber].player2], gameNumber);\n\n    }\n    else {\n      require(msg.value >= games[gameNumber].bet, \"you need to make the same bet\");\n    } \n  }\n  \n  function makeMove(uint gameNumber, uint moveNumber) public { \n    require(games[gameNumber].gamestarted == true, \"the game hasn't started yet\");\n    require(games[gameNumber].gameended == false, \"the game already ended\");\n    if (games[gameNumber].player1 == msg.sender) {\n      require(games[gameNumber].chooseOfp1 == 0, \"you already moved\");\n      require(1 <= moveNumber, \"choose number from 1 to 3\");\n      require(3 >= moveNumber, \"choose number from 1 to 3\");\n      games[gameNumber].chooseOfp1 = moveNumber;\n    }\n    else if (games[gameNumber].player2 == msg.sender) {\n      require(games[gameNumber].chooseOfp1 > 0, \"player 1 move first\");\n      require(1 <= moveNumber, \"choose number from 1 to 3\");\n      require(3 >= moveNumber, \"choose number from 1 to 3\");\n      if (games[gameNumber].chooseOfp1 == moveNumber) {\n        payable(games[gameNumber].player1).transfer(games[gameNumber].bet);\n        payable(games[gameNumber].player2).transfer(games[gameNumber].bet);\n        games[gameNumber].gameended = true;\n        emit GameComplete(address(0), gameNumber);\n      }\n      \n      else if (games[gameNumber].chooseOfp1 == 1 && moveNumber == 3){\n        payable(games[gameNumber].player1).transfer(games[gameNumber].bet*2);\n        games[gameNumber].gameended = true;\n        emit GameComplete(games[gameNumber].player1, gameNumber);\n      }\n      else if (games[gameNumber].chooseOfp1 == 2 && moveNumber == 1){\n        payable(games[gameNumber].player1).transfer(games[gameNumber].bet*2);\n        games[gameNumber].gameended = true;\n        emit GameComplete(games[gameNumber].player1, gameNumber);\n      }\n      else if (games[gameNumber].chooseOfp1 == 3 && moveNumber == 2){\n        payable(games[gameNumber].player1).transfer(games[gameNumber].bet*2);\n        games[gameNumber].gameended = true;\n        emit GameComplete(games[gameNumber].player1, gameNumber);\n      }\n      else if (games[gameNumber].chooseOfp1 == 2 && moveNumber == 3){\n        payable(games[gameNumber].player2).transfer(games[gameNumber].bet*2);\n        games[gameNumber].gameended = true;\n        emit GameComplete(games[gameNumber].player2, gameNumber);\n      }\n      else if (games[gameNumber].chooseOfp1 == 3 && moveNumber == 1){\n        payable(games[gameNumber].player2).transfer(games[gameNumber].bet*2);\n        games[gameNumber].gameended = true;\n        emit GameComplete(games[gameNumber].player2, gameNumber);\n      }\n      else if (games[gameNumber].chooseOfp1 == 1 && moveNumber == 2){\n        payable(games[gameNumber].player2).transfer(games[gameNumber].bet*2);\n        games[gameNumber].gameended = true;\n        emit GameComplete(games[gameNumber].player2, gameNumber);\n      }    \n    }\n    else {\n      revert(\"you are not a pleyer\");\n    }\n\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338390,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n  uint gameNumber;\n  \n  struct User {\n    uint choice;\n  }\n  \n  struct GameInfo {\n    uint gameNumber;\n    address[] players;\n    uint bet;\n    bool hasStarted;\n    uint choiceCreator;\n    uint choicePartic;\n  }\n  \n  mapping (uint => GameInfo) gameInfo;\n  \n  \n  function createGame(address payable participant) public payable {\n    require(msg.value > 0);\n    \n    gameNumber++;\n    uint bet = msg.value;\n    \n    address[] memory players = new address[](2);\n    players[0] = msg.sender;\n    players[1] = participant;\n    gameInfo[gameNumber] = GameInfo(gameNumber, players, bet, false, 0, 0);\n    \n    emit GameCreated(msg.sender, gameNumber, bet);\n  }\n\n  function joinGame(uint _gameNumber) payable public {\n    require(gameInfo[_gameNumber].hasStarted == false);\n    require(msg.sender == gameInfo[_gameNumber].players[1]);\n    require(msg.value >= gameInfo[_gameNumber].bet);\n    \n    if (msg.value >= gameInfo[_gameNumber].bet) {\n      uint refund = msg.value - gameInfo[_gameNumber].bet;\n      msg.sender.transfer(refund);\n      }\n    \n    gameInfo[_gameNumber].hasStarted = true;\n    emit GameStarted(gameInfo[_gameNumber].players, _gameNumber);\n  }\n  \n\n  function makeMove(uint _gameNumber, uint moveNumber) public { \n    require(gameInfo[_gameNumber].hasStarted == true);\n    require(\n      msg.sender == gameInfo[_gameNumber].players[0] ||\n      msg.sender == gameInfo[_gameNumber].players[1]\n    );\n    require(moveNumber > 0 && moveNumber <=3);\n    \n    uint playerIndex;\n    if (msg.sender == gameInfo[_gameNumber].players[0]) {\n      require(gameInfo[_gameNumber].choiceCreator == 0);\n      gameInfo[_gameNumber].choiceCreator = moveNumber;\n    } else {\n      require(gameInfo[_gameNumber].choicePartic == 0);\n      gameInfo[_gameNumber].choicePartic = moveNumber;\n    }\n \n    \/\/ rock = 1, paper = 2, sisscors = 3\n    \n    if  (gameInfo[_gameNumber].choiceCreator > 0 && \n        gameInfo[_gameNumber].choicePartic > 0 ) {\n      \n      uint outcome = decideOutcome(gameInfo[_gameNumber].choiceCreator, gameInfo[_gameNumber].choicePartic);\n      uint amount = gameInfo[_gameNumber].bet;\n      uint winnings = amount * 2;\n      address winner;\n      if (outcome == 0) {\n        winner = gameInfo[_gameNumber].players[0];\n        payable(winner).transfer(winnings);\n        \n      } else if (outcome == 1) {\n        winner = gameInfo[_gameNumber].players[1];\n        payable(winner).transfer(winnings);\n        \n      } else {\n        winner = address(0);\n        payable(gameInfo[_gameNumber].players[0]).transfer(amount);\n        payable(gameInfo[_gameNumber].players[1]).transfer(amount);\n      }\n      emit GameComplete(winner, _gameNumber);\n    }\n  }\n  \n  function decideOutcome(uint plr0, uint plr1) private returns(uint) {\n    \/\/ creator win = 0, participant win = 1, tie = 3\n    \/\/ tie\n    if (plr0 == plr1) {\n      return 3;\n    }\n    if (plr0 > plr1) {\n      if (plr1 == 1 && plr0 == 3) {\n        return 1;\n      }\n      return 0;\n    }\n    if (plr1 > plr0) {\n      if (plr0 == 1 && plr1 == 3) {\n        return 0;\n      }\n      return 1;\n    }\n  } \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338391,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n  enum Action {\n      None,\n      Rock,\n      Paper,\n      Scissors\n  }\n  \n  struct Game {\n      address[2] players;\n      bool started;\n      uint bet;\n      mapping(address => Action) playerAction;\n  }\n  \n  Game[] games;\n  \n  function createGame(address payable participant) external payable {\n    require(msg.value>0,\"bet must be >0\");\n    Game storage game = games.push();\n    game.players[0] = msg.sender;\n    game.players[1] = participant;\n    game.bet = msg.value;\n    emit GameCreated(msg.sender,games.length-1,game.bet);\n  }\n  \n  function joinGame(uint gameNumber) external payable {\n    Game storage game = games[gameNumber];\n    require(msg.sender==game.players[1],\"not invited to this game\");\n    require(msg.value>=game.bet,\"bet too low\");\n    require(!game.started,\"game already started\");\n    if (msg.value>game.bet) payable(msg.sender).transfer(msg.value-game.bet);\n    \n    address[] memory players = new address[](game.players.length);\n    players[0] = game.players[0];\n    players[1] = game.players[1];\n    game.started = true;\n    emit GameStarted(players,gameNumber);\n  }\n\n  function makeMove(uint gameNumber, uint moveNumber) external {\n    Game storage game = games[gameNumber];\n    require((msg.sender==game.players[0]) || (msg.sender==game.players[1]),\"not invited to this game\");\n    require(game.playerAction[msg.sender]==Action.None,\"already took action\");\n    require((moveNumber>0),\"invalid action\");\n    require(game.started,\"game not started\");\n    \n    Action action = Action(moveNumber);\n    game.playerAction[msg.sender] = action;\n    if((uint(game.playerAction[game.players[0]])>0) && (uint(game.playerAction[game.players[1]])>0)) GameComplete(_getWinner(game),gameNumber);\n  }\n  \n  function _getWinner(Game storage game) private view returns(address winner) {\n      uint res = (uint(game.playerAction[game.players[0]])-uint(game.playerAction[game.players[1]]));\n      if(res==1) {\n          winner = game.players[0];\n      } else if(res!=0) {\n          winner = game.players[1];\n      }\n  }\n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338392,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address payable[2] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n  struct Game {\n    uint gameId;\n    address payable[2]  players;\n    uint bet;\n    bool ready;\n    uint8[2] moves;\n  }\n  mapping(uint => Game) games;\n  uint counter = 0;\n  \n\n  function createGame(address payable participant) payable public {\n    require(msg.value > 0, \"Amount of the bet must be greater than zero\");\n    counter +=1;\n    games[counter] = Game(counter, [msg.sender, participant], msg.value, false, [0,0]);\n    emit GameCreated(msg.sender, counter, msg.value);\n  }\n  \n\n  function joinGame(uint gameNumber) payable public {\n    Game memory game = games[gameNumber];\n    require(!game.ready, \"Game is started\");\n    require(msg.sender == game.players[1], \"You are not alow\");\n    require(msg.value >= game.bet, \"Amount must be equal or greater than bet\");\n    if(game.bet < msg.value) sendEth( msg.sender, msg.value - game.bet);\n    games[gameNumber].ready = true;\n    emit GameStarted(game.players, game.gameId);\n  }\n  \n\n  function makeMove(uint gameNumber, uint8 moveNumber) public { \n    require(moveNumber > 0 && moveNumber <= 3, \"Wrong move\");\n    Game storage game = games[gameNumber];\n    require(game.ready, \"Game not ready\");\n    require(msg.sender == game.players[0] || msg.sender == game.players[1], \"You are not alow\");\n    if(msg.sender == game.players[0]) {\n      require(game.moves[0] == 0);\n      game.moves[0] = moveNumber;\n    } else {\n        require(game.moves[1] == 0);\n        game.moves[1] = moveNumber;\n    }\n    uint8 winnerId;\n    if (game.moves[0] != 0 && game.moves[1] != 0) { \n      winnerId = calculateGame(game.moves[0], game.moves[1]);\n     if(winnerId == 3) {\n        sendEth( game.players[0], game.bet);\n        sendEth( game.players[1], game.bet);\n        emit GameComplete(address(0), gameNumber);\n      } else {\n        address payable winner = game.players[winnerId];\n        sendEth(winner, game.bet);\n        emit GameComplete(winner, gameNumber);\n      }\n    }\n  }\n  \n  function calculateGame(uint move1, uint move2) pure internal returns(uint8 winnerId) { \n    if(move1 == move2) return 3;\n    if(move1 == 1) move2==3? winnerId = 0: winnerId = 1;\n      else if(move1 == 2) move2==1? winnerId = 0: winnerId = 1;\n        else if(move1 == 3) move2==2? winnerId = 0: winnerId = 1;\n  }\n  \n  function sendEth(address payable _to, uint _value) internal {\n    (bool sent,)=_to.call{value: _value}(\"\");\n    require(sent,\"failed to send\");\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338393,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[2] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n\/\/   address _creator;\n\/\/   address _participant;\n\/\/   uint _bet;\n  uint gn = 0; \/\/ gamenumber\n  \n  struct Game {\n    address creator;\n    address participant;\n    uint bet;\n    uint[2] moves;\n    bool started;\n    bool completed;\n  }\n  \n  mapping(uint => Game) public games;\n  \n  \n \n  function createGame(address participant) public payable {\n    require(msg.value > 0);\n\n    gn++;\n    games[gn] = Game(msg.sender, participant, msg.value, [uint(0),uint(0)], false, false);\n    \n    emit GameCreated(msg.sender, gn, msg.value);\n    \n  }\n  \n\n  function joinGame(uint gameNumber) public payable {\n    require(msg.sender == games[gameNumber].participant);\n    require(msg.value >= games[gameNumber].bet);\n    require(games[gameNumber].started == false);\n    \n    if(msg.value > games[gameNumber].bet) {\n        payable(msg.sender).transfer(msg.value - games[gameNumber].bet);\n    }\n    \n    games[gameNumber].participant = msg.sender;\n    \n    \/\/ address[] memory players;\n    \/\/ players[0] = games[gameNumber].creator;\n    \/\/ players[1] = msg.sender;\n    \n    emit GameStarted([games[gameNumber].creator, msg.sender], gameNumber);\n    games[gameNumber].started = true;\n    \n  }\n  \n\n  function makeMove(uint gameNumber, uint moveNumber) public { \n      require(msg.sender == games[gameNumber].creator || msg.sender == games[gameNumber].participant);\n      require(moveNumber == 1 || moveNumber == 2 || moveNumber == 3);\n      require(games[gameNumber].started == true);\n      require(games[gameNumber].completed == false);\n      \n      if(msg.sender == games[gameNumber].creator) { \/\/ creator makes a move\n          \n          games[gameNumber].moves[0] = moveNumber; \n          \n          if(games[gameNumber].moves[1] != 0) { \/\/ check opponet makes his move or not\n             \n             \/\/ select winner and end the game;\n             selectWinner(gameNumber);\n              \n          }\n          \n      } else { \/\/ participant makes a move\n         \n          games[gameNumber].moves[1] = moveNumber;\n          \n          if(games[gameNumber].moves[0] != 0) { \/\/ check opponet makes his move or not\n             \n             \/\/ select winner and end the game;\n             selectWinner(gameNumber);\n              \n          }\n          \n      }\n      \n  }\n  \n  \n  function selectWinner(uint gameNumber) private {\n      \/*\n      1,'rock'\n      2 'paper'\n      3 'scissors\n      \n      *\/\n      \n      uint move1 = games[gameNumber].moves[0];\n      uint move2 = games[gameNumber].moves[1];\n      uint winner;\n      address winnerAddress;\n        \n      if(move1 == 1 && move2 == 1) winner = 0;\n      if(move1 == 1 && move2 == 2) winner = 2;\n      if(move1 == 1 && move2 == 3) winner = 1;\n\n      if(move1 == 2 && move2 == 1) winner = 1;\n      if(move1 == 2 && move2 == 2) winner = 0;\n      if(move1 == 2 && move2 == 3) winner = 2;\n\n      if(move1 == 3 && move2 == 1) winner = 2;\n      if(move1 == 3 && move2 == 2) winner = 1;\n      if(move1 == 3 && move2 == 3) winner = 0;\n\n        if(winner == 1) winnerAddress = games[gameNumber].creator;\n        if(winner == 2) winnerAddress = games[gameNumber].participant;\n        if(winner == 0) winnerAddress = address(0);\n        \n        emit GameComplete(winnerAddress, gameNumber);\n        \n        \n        if(winnerAddress == address(0) ) {\n            payable(games[gameNumber].creator).transfer(games[gameNumber].bet);\n            payable(games[gameNumber].participant).transfer(games[gameNumber].bet);\n        } else {\n            payable(winnerAddress).transfer(games[gameNumber].bet*2);\n        }\n        \n        games[gameNumber].completed = true;\n      \n  }\n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338394,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  uint256 gamesCounter = 1;\n  \n  mapping(uint => Game) public games; \n  \n  struct Game {\n    address creator;\n    address participant;\n    uint bet;\n    bool hasParticipantJoined;\n    uint moveCreator;\n    uint moveParticipant;\n  }\n  \n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[2] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n  \/**\n * Use this endpoint to create a game. \n * It is a payable endpoint meaning the creator of the game will send ether directly to it.\n * The ether sent to the contract should be used as the bet for the game.\n * @param participant - The address of the participant allowed to join the game.\n *\/\n  function createGame(address payable participant) external payable {\n    require(msg.value > 0, \"RockPaperScissors: Amount of bet must be greater than zero\");\n    games[gamesCounter] = Game({\n      creator: msg.sender,\n      participant: participant,\n      bet: msg.value,\n      hasParticipantJoined: false,\n      moveCreator: 0,\n      moveParticipant: 0\n    });\n    emit GameCreated(msg.sender, gamesCounter, msg.value);\n    gamesCounter++;\n  }\n  \n  \/**\n * Use this endpoint to join a game.\n * It is a payable endpoint meaning the joining participant will send ether directly to it.\n * The ether sent to the contract should be used as the bet for the game. \n * Any additional ether that exceeds the original bet of the creator should be refunded.\n * @param gameNumber - Corresponds to the gameNumber provided by the GameCreated event\n *\/\n  function joinGame(uint gameNumber) external payable {\n    require (gameNumber < gamesCounter, \"RockPaperScissors: gameNumber does not exist\");\n    Game storage game = games[gameNumber];\n    require (!game.hasParticipantJoined, \"RockPaperScissors: game has already started\");\n    require(game.participant == msg.sender, \"RockPaperScissors: Participant must be whitelisted\");\n    require(game.bet <= msg.value, \"RockPaperScissors: Not enough ether\");\n    if (msg.value > game.bet) {\n      (bool success, ) = msg.sender.call{value: (msg.value - game.bet)}(\"\");\n      require(success, \"RockPaperScissors: Ether transfer failed\");\n    }\n    game.hasParticipantJoined = true;\n    emit GameStarted([game.creator, game.participant], gameNumber);\n  }\n  \n  \/**\n * Use this endpoint to make a move during a game \n * @param gameNumber - Corresponds to the gameNumber provided by the GameCreated event\n * @param moveNumber - The move for this player (1, 2, or 3 for rock, paper, scissors respectively)\n *\/\n  function makeMove(uint gameNumber, uint moveNumber) external {\n    require (gameNumber < gamesCounter, \"RockPaperScissors: gameNumber does not exist\");\n    require (moveNumber > 0 && moveNumber < 4, \"RockPaperScissors: Move not allowed\");\n    Game storage game = games[gameNumber];\n    require(game.moveParticipant == 0 || game.moveCreator == 0 , \"RockPaperScissors: msg.sender must be a player\");\n    require(msg.sender == game.participant || msg.sender == game.creator, \"RockPaperScissors: msg.sender must be a player\");\n    require(game.hasParticipantJoined, \"RockPaperScissors: participant must pay before making a move\");\n    if (msg.sender == game.participant) {\n      game.moveParticipant = moveNumber;\n    } else {\n      game.moveCreator = moveNumber;\n    }\n    if (game.moveParticipant > 0 && game.moveCreator > 0) {\n      address winner = _endGame(gameNumber);\n      emit GameComplete(winner, gameNumber);\n    }\n  }\n  \n   \/**\n * Use this endpoint to make a move during a game \n * @param gameNumber - Corresponds to the game\n *\/\n  function _endGame(uint gameNumber) internal returns (address) {\n    Game memory game = games[gameNumber];\n    bool success;\n    address winner;\n    if ((game.moveCreator - game.moveParticipant) % 3 == 1) {\n      (success, ) = game.creator.call{value: 2 * (game.bet) }(\"\");\n      winner = game.creator;\n    } else if ((game.moveParticipant - game.moveCreator) % 3 == 1) {\n      (success, ) = game.participant.call{value: 2 * (game.bet) }(\"\");\n      winner = game.participant;\n    } else {\n     (success, ) = game.participant.call{value: game.bet}(\"\");\n      require(success, \"RockPaperScissors: Ether transfer failed\");\n     (success, ) = game.creator.call{value: game.bet}(\"\");\n      winner = address(0);\n    }\n    require(success, \"RockPaperScissors: Ether transfer failed\");\n    return winner;\n  }\n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338395,"user_id":null,"body":"pragma solidity >=0.4.19;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n struct Games{\n      uint numbers;\n      address[] players;\n      uint bet;\n      uint prize;\n      address winner;\n      uint gameMove;\n      mapping (address => uint) playersAddress;\n\n  }\n  \n  mapping (uint => Games ) public games; \n  \n \n  function createGame(address payable participant) public payable {\n         require(msg.value >0, 'Not enougth bet');\n        Games storage game = games[block.number];\n        game.bet = msg.value;\n        game.prize = msg.value;\n        game.players.push(msg.sender);\n        game.players.push(participant);\n        game.numbers=block.number;\n\n        emit GameCreated(msg.sender,block.number,msg.value);  \n  }\n  \n \n  function joinGame(uint gameNumber) public payable {\n    Games storage game = games[gameNumber];\n      require(game.numbers !=0, 'Games does not exist');\n      require(game.players[1] == msg.sender, 'You are not allowed to enter the game');\n      require(game.prize == game.bet, 'This game has already started');\n      require(msg.value >= game.bet, 'Value should be higher then the bet');\n\n      if (msg.value > game.bet){\n        game.prize += msg.value - game.bet;\n        payable(msg.sender).transfer(msg.value - game.bet);\n\n      }else{\n        game.prize += msg.value;\n      }\n      emit GameStarted(game.players, gameNumber);\n  }\n  \n \n  function makeMove(uint gameNumber, uint moveNumber) public { \n    Games storage game = games[gameNumber];\n        require(game.winner == address(0), 'Game has got a winner');\n        require(game.prize > game.bet, 'Game not started');\n        require(moveNumber > 0 && moveNumber <=3, 'Move between 1 and 3');\n\n        game.playersAddress[msg.sender] = moveNumber;\n        game.gameMove++;\n\n        if(game.gameMove <=1) {return ;}\n        uint firstPlayer = game.playersAddress[game.players[0]];\n        uint secondPlayer = game.playersAddress[game.players[1]];\n\n        if((firstPlayer +1) %3 == secondPlayer){\n          game.winner = game.players[1];\n        }\n        else if(firstPlayer == secondPlayer){\n          game.winner = address(0);\n        }\n        else {\n          game.winner = game.players[0];\n        }\n\n        payable(game.winner).transfer(game.bet);\n        emit GameComplete(game.winner, gameNumber);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338396,"user_id":null,"body":"pragma solidity >= 0.6.2;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n\n  struct Game {\n    uint gameNumber;\n    address[] players;\n    uint bet;\n    mapping (address => uint) moveByAddress;\n    uint makeMoveInteractions;\n    uint prize;\n    address winner;\n  }\n\n  mapping(uint => Game) public games;\n  \n  function createGame(address payable participant) public payable {\n    require(msg.value > 0, \"Bet must be higher than 0\");\n    Game storage game = games[block.number];\n    game.bet = msg.value;\n    game.prize = msg.value;\n    game.players.push(msg.sender);\n    game.players.push(participant);\n    game.gameNumber = block.number;\n    \n    emit GameCreated(msg.sender, block.number, msg.value);\n  }\n  \n\n  function joinGame(uint gameNumber) public payable { \n    Game storage game = games[gameNumber];\n    require(game.gameNumber != 0, \"Game doesn't exsits\");\n    require(game.players[1] == msg.sender, \"You aren't allowed to enter in this game\");\n    require(game.prize == game.bet, \"This game alredy started\");\n    require(msg.value >= game.bet, \"Bet must be equal or higher than game bet\");\n\n    if(msg.value > game.bet) {\n      game.prize += msg.value - game.bet;\n      payable(msg.sender).transfer(msg.value - game.bet);\n    } else {\n      game.prize += msg.value;\n    }\n\n    emit GameStarted(game.players, gameNumber);\n  }\n  \n\n  function makeMove(uint gameNumber, uint moveNumber) public {\n    Game storage game = games[gameNumber];\n    require(game.winner == address(0), \"Game alredy has a winner\");\n    require(game.prize > game.bet, \"Game not start yet\");\n    require(moveNumber > 0 && moveNumber <= 3, \"Move can't be negative or more than 3\");\n\n    game.moveByAddress[msg.sender] = moveNumber;\n    game.makeMoveInteractions++;\n\n    if(game.makeMoveInteractions <= 1) {\n      return;\n    }\n\n    uint firstPlayerMove = game.moveByAddress[game.players[0]];\n    uint secondPlayerMove = game.moveByAddress[game.players[1]];\n\n    if((firstPlayerMove + 1) % 3 == secondPlayerMove) {\n       game.winner = game.players[1];\n      \n    } else if(firstPlayerMove == secondPlayerMove) {\n       game.winner = address(0);\n    }\n    else {\n       game.winner = game.players[0];\n    }\n\n\n    payable(game.winner).transfer(game.bet);\n    emit GameComplete( game.winner, gameNumber);\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338397,"user_id":null,"body":"pragma solidity >=0.6.2;\n\ncontract RockPaperScissors {\n  event GameCreated(address creator, uint gameNumber, uint bet);\n  event GameStarted(address[] players, uint gameNumber);\n  event GameComplete(address winner, uint gameNumber);\n  \n  \n  struct Game\n  {\n    address [] players;\n    uint[] PlayerMove;\n    uint bet;\n    bool started;\n    bool completed;\n  }\n  \n  mapping(uint => Game) Games;\n  uint gameNumber;\n\n  \n  function createGame(address payable participant)external payable {\n    require(msg.value>0);\n    \/\/require(msg.value>0);\n    address [] memory _players = new address[](2);\/\/ = [msg.sender,participant];\n    _players[0] = msg.sender;\n    _players[1] = participant;\n    uint[] memory moves = new uint[](2);\n    moves[0]=0;\n    moves[1]=0;\n    Game memory game = Game({players: _players,PlayerMove:moves,bet: msg.value,started: false, completed:false});\n    \n    Games[gameNumber] = game;\n    \n    emit GameCreated(msg.sender, gameNumber++, msg.value);\n  }\n\n  function joinGame(uint _gameNumber)external payable {\n    Game storage game = Games[_gameNumber];\n  require(msg.value >= game.bet && game.players[1] == msg.sender && !game.started);\n    if (msg.value > game.bet)\n      {\n        payable(msg.sender).transfer((msg.value - game.bet));\n      }\n    game.started=true;\n    emit GameStarted( game.players, _gameNumber);\n  }\n  \n  function makeMove(uint _gameNumber, uint moveNumber)external { \n    require(moveNumber > 0 && moveNumber < 4);\n    Game storage game = Games[_gameNumber];\n    require(game.started && !game.completed);\n    \n    address player1 = game.players[0];\n    address player2 = game.players[1];\n    \n    uint player1_move=0;\n    uint player2_move=0;\n    \n    if(player1 == msg.sender)\n      {\n        game.PlayerMove[0] = moveNumber;\n        player1_move = moveNumber;\n        player2_move = game.PlayerMove[1];\n      }\n    \n    else if(game.players[1] == msg.sender){\n      game.PlayerMove[1] = moveNumber;\n      player2_move = moveNumber;\n      player1_move = game.PlayerMove[0];\n      \n    }\n    else return;\n    \n    if(player1_move == 0 || player2_move == 0)\n      {\n        return;\n      }\n    if(player1_move == player2_move)\n      {\n        game.completed=true;\n        emit GameComplete(address(0), _gameNumber);\n        payable(player1).transfer(game.bet);\n        payable(player2).transfer(game.bet);\n        return;\n      }\n    else if ((player1_move == 1 && player2_move ==3) || player1_move > player2_move)\n      {\n        game.completed=true;\n        emit GameComplete(player1, _gameNumber);\n        payable(player1).transfer(game.bet*2);\n        return;\n      }\n    \n    game.completed=true;\n    emit GameComplete(player2, _gameNumber);\n    payable(player2).transfer(game.bet*2);\n  }\n  \n  \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5a023c426975981341000014":[{"id":338398,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) returns (int) {\n    return 180-(angle1+angle2);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338399,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  function otherAngle(uint angle1, uint angle2) public returns (uint) {\n    uint a1 = angle1;\n    uint a2 = angle2;\n    \n    assert(0 < (a1 + a2));\n    assert((a1 + a2) < 180);\n    \n    return 180 - (a1 + a2);\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338400,"user_id":527,"body":"pragma solidity ^0.4.13;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) returns (int) {\n    return 180 - angle1 - angle2;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338401,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) returns (int) {\n    \/\/ TODO your code here\n    int a1 = angle1;\n    int a2 = angle2;\n    return 180-(a1+a2);\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338402,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) returns (int) {\n    return 180 - angle1 - angle2;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338403,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  function otherAngle(uint8 angle1, uint8 angle2) public pure returns (uint8) {\n    assert(angle1 + angle2 < 180);\n    uint8 res = 180 - angle1 - angle2;\n    assert(res + angle1 + angle2 == 180);\n    return res;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338404,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) constant returns (int) {\n    return 180 - angle1 - angle2;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338405,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  int constant sumOfAngles = 180;\n  function otherAngle(int angle1, int angle2) returns (int) {\n    int a1 = angle1;\n    int a2 = angle2;\n    return 180 - a1 - a2;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338406,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) external returns (int) {\n\/\/     require(angle1 + angle2 < 180);\n    return 180 - angle1 - angle2;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338407,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract ThirdAngle {\n  function otherAngle(int angle1, int angle2) returns (int) {\n    \/\/ TODO your code here\n    int a1 = angle1;\n    int a2 = angle2;\n    int a3 = a1 + a2;\n    return 180 - a3;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5a03b3f6a1c9040084001765":[{"id":338408,"user_id":527,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    return 180 * (n - 2);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338409,"user_id":645,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    return (n - 2) * 180;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338410,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    if (n < 3)\n        return 0;\n    return (n - 2) * 180;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338411,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    require(n>2);\n    return (n-2) * 180;\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338412,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    int a = n - 2;\n    return a*180;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338413,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    return ((2*n)-4)*90;\n    \/\/ your code here\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338414,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    return (n - 2) * 180; \/\/ your code here\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338415,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    int sum = n - 2;\n    int total = sum * 180;\n    return total;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338416,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    uint z = 3;\n    n = 180 * (n - 2);\n    return n; \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338417,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function angle(int n) public pure returns (int) {\n    return 180 + (n - 3) * 180;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5a3fe3dde1ce0e8ed6000097":[{"id":338418,"user_id":645,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    return (year + 99) \/ 100;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338419,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    return year\/100 + ((year%100 == 0)?0:1);\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338420,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    int value = year \/ 100;\n    if (year % 100 == 0) {\n      return value;      \n    }\n    return value + 1;      \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338421,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    int century_from_yearIs;\n    if (year <= 100) {\n      return century_from_yearIs = 1;\n    } else if (year % 100 == 0) {\n      return century_from_yearIs = (year \/ 100);\n    } else {\n      return century_from_yearIs = (year \/ 100) + 1;\n    }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338422,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    return int( (year -1) \/ 100 + 1);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338423,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    int ret = year \/ 100;\n    int min = (year -1)\/100;\n    \n    if (ret == min) {\n      ret +=1;  \n    }\n    \n    \n    \n    return ret;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338424,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    \n  \n    int z = (year \/ 100) + 1;\n    if (year % 100 == 0){\n    z = (year \/ 100);\n  }\n    return z;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338425,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    while (year>0)\n    {if(year%100==0)\n      return year\/100;\n    else return ((year\/100)+1);\n     }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338426,"user_id":null,"body":"\/\/ SPDX-Lincense-Identifier: MIT\npragma solidity ^0.4.19;\ncontract Kata {\n\n  function century_from_year(int year) public pure returns (int) {\n    if (year % 100 == 0) {\n      return year \/ 100;\n    }\n    return (year \/ 100) + 1;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338427,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function century_from_year(int year) public pure returns (int) {\n    \/\/ your code here\n    return year\/100 + (year % 100 > 0 ? 1 : 0);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5a62e568e626c512fd000007":[{"id":338428,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract HelloWorld {\n  \/\/ State Variables for the initial greeting\n  string private greeting = \"Hello World!\";\n  \n  \/\/ Endpoints to get and set the greeting\n  function greet() constant returns (string){\n    return greeting;\n  }\n  \n  function setGreeting(string _greeting) {\n    greeting = _greeting;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338429,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n  string public greet = \"Hello World!\";\n  function setGreeting(string s) { greet = s; }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338430,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract HelloWorld {\n  \/\/ State Variables\n  string greeting = \"\"; \/\/ Change this\n  \n  \/\/ Endpoints\n  \/\/ ...\n  \n  function greet() constant returns (string) {\n     if(bytes(greeting).length == 0) return \"Hello World!\";\n     return greeting;\n   }\n   \n   function setGreeting(string g) {\n     greeting = g;\n   }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338431,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n  string greeting = \"Hello World!\";\n  \n function setGreeting(string _greeting) public {\n   greeting = _greeting;\n }\n  \n function greet() public view returns (string) {\n   return greeting;\n } \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338432,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n  \/\/ State Variables\n  string greeting = \"Hello World!\"; \/\/ Change this\n  \n  \/\/ Endpoints\n  function greet() constant returns (string) {\n    return greeting;\n  }\n  \n  function setGreeting(string newGreeting) public {\n    greeting = newGreeting;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338433,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n\n  string greeting = \"Hello World!\";\n  \n  function greet() constant returns (string) {\n        return greeting;\n    }\n\n  function setGreeting(string x) {\n        greeting = x;\n    } \n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338434,"user_id":null,"body":"pragma solidity ^0.4.13;\n\ncontract HelloWorld {\n  \/\/ State Variables\n  string public greet = \"Hello World!\";\n  \n  function setGreeting(string new_greeting) public {\n    greet = new_greeting;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338435,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n  string public greet = \"Hello World!\";\n  function setGreeting(string _newGreet) {\n  greet = _newGreet;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338436,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n  string public greet = 'Hello World!';\n  function setGreeting(string x) public { greet = x; }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338437,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract HelloWorld {\n  string greeting = \"Hello World!\";\n  function setGreeting(string G) public {\n    greeting = G;\n  }\n  function greet() public view returns(string) {\n    return greeting;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5aba780a6a176b029800041c":[{"id":338438,"user_id":645,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    return b - b % d;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338439,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    int result = b \/ d;\n    return result * d;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338440,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    \/\/ your code here\\\n    int result = b \/ d;\n    \n    return result * d;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338441,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    return d* (b\/d);\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338442,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) { \n    int n = b\/d * d;\n    return n;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338443,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    \n    for (int i = b; i >0; i--){\n      if (i%d ==0) return i;\n    }\n    \n    \/\/for i in range (bound, 1, -1):\n    \/\/    if i%divisor ==0: return i\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338444,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    for( int k = b; k>0; k--)\n      {\n        if( k%d == 0) return k;\n      }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338445,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    \/\/ your code here\n    int nr = b;\n    while (nr % d !=0)\n      {nr--;}\n    return nr;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338446,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    \n    for (int devisor = b ; devisor > 0 ;devisor--){\n          if (devisor%d==0) return devisor;\n    }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338447,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function maxMultiple(int d, int b) public pure returns (int) {\n    \/\/ your code here\n    int n;\n    for(n=b; n>0;n--)\n      {\n        if(n % d == 0)\n          {return n;}\n      }\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}],"5ae62fcf252e66d44d00008e":[{"id":338448,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    \/\/ your code here\n    int[] memory answers = new int[](6);\n    answers[0] = a * b * c;\n    answers[1] = a + b + c;\n    answers[2] = (a + b) * c;\n    answers[3] = a + (b * c);\n    answers[4] = (a * b) + c;\n    answers[5] = a * (b + c);\n    int max = 0;\n    for(uint i=0; i<6; i++) {\n      if(answers[i] > max) { max = answers[i]; }\n    }\n    return max;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338449,"user_id":645,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    int r = a + b + c;\n    if ((a + b) * c > r) r = (a + b) * c;\n    if (a * (b + c) > r) r = a * (b + c);\n    if (a * b * c > r) r = a * b * c;\n    return r;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338450,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {  \n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    int[] memory answers = new int[](4);\n    answers[0] = a * b * c;\n    answers[1] = a + b + c;\n    answers[2] = (a + b) * c;\n    answers[3] = a * (b + c);\n    \n    int max = 0;\n    for(uint i=0; i<4; i++) {\n      if(answers[i] > max) {max = answers[i];}\n    }\n    return max;\n  }\n}\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338451,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    int max = 0;\n    int d;\n    \n    d = a + b + c;\n    if( d > max ) max = d;\n    \n    d = a * b * c;\n    if( d > max ) max = d;\n\n    d = a * b + c;\n    if( d > max ) max = d;\n\n    d = a + b * c;\n    if( d > max ) max = d;\n\n    d = (a + b) * c;\n    if( d > max ) max = d;\n\n    d = a * (b + c);\n    if( d > max ) max = d;\n\n    return max;\n    \n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338452,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  \n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    int z0 = a + b + c;\n    int z1 = a * b * c;\n    int z2 = a + b * c;\n    int z3 = a * b + c;\n    int z4 = (a + b) * c;\n    int largest = a * (b + c);\n    \n    int[5] memory values = [z0, z1, z2, z3, z4];\n    \n    for(uint i = 0; i < 5; i++) {\n      if(values[i] > largest) { \n        largest = values[i];\n      } \n    }\n    return largest;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338453,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    int x1 = a * (b + c);\n    int x2 = a * b * c;\n    int x3 = a + b + c;\n    int x4 = (a + b) * c;\n    int res;\n    if (x1 > x2) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n    \n    if (res < x3) {\n      res = x3;\n    }\n    \n    if (res < x4) {\n      res = x4;\n    }\n    \n    return res;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338454,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    \/\/ your code here\n    int highest = 0;\n    \n    int try1 = a * (b + c);\n    int try2 = a * b * c;\n    int try3 = (a + b) * c;\n    int try4 = a + b + c;\n    int try5 = a + b * c;\n    int try6 = a * b + c;\n    \n    if(try1 >= try2 && try1 >= try3 && try1 >= try4 && try1 >= try5 && try1 >= try6){\n      highest = try1; \n    }else if(try2 >= try1 && try2 >= try3 && try2 >= try4 && try2 >= try5 && try2 >= try6){\n      highest = try2; \n    }else if(try3 >= try1 && try3 >= try2 && try3 >= try4 && try3 >= try5 && try3 >= try6){\n      highest = try3; \n    }else if(try4 >= try1 && try4 >= try2 && try4 >= try3 && try4 >= try5 && try4 >= try6){\n      highest = try4; \n    }else if(try5 >= try1 && try5 >= try2 && try5 >= try3 && try5 >= try4 && try5 >= try6){\n      highest = try5; \n    }else{\n      highest = try6;\n    }    \n    return highest;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338455,"user_id":null,"body":"pragma solidity ^0.4.19;\n\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    int[] memory answers = new int[](12);\n    answers[0] = a + b + c;\n    answers[1] = (a + b) + c;\n    answers[2] = a + (b + c);\n    answers[3] = a * b * c;\n    answers[4] = (a * b) * c;\n    answers[5] = a * (b * c);\n    answers[6] = a + b * c;\n    answers[7] = (a + b) * c;\n    answers[8] = a + (b * c);\n    answers[9] = a * b + c;\n    answers[10] = (a * b) + c;\n    answers[11] = a * (b + c); \n    int max_obtained = 0;\n    for (uint i = 0; i < 12; i++) {\n      if (answers[i] > max_obtained) {\n        max_obtained = answers[i];\n      }\n    }\n    return max_obtained;\n  }\n}\n\n","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338456,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    \n    int high = 0;\n    \n    if (a*(b+c)  >high) high = a*(b+c);\n    if (a*b*c    >high) high = a*b*c;\n    if (a+b*c    >high) high = a+b*c;\n    if (a+b+c    >high) high = a+b+c;\n    if ((a+b)*c  >high) high = (a+b)*c;\n    \n    return high;\n  }\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"},{"id":338457,"user_id":null,"body":"pragma solidity ^0.4.19;\ncontract Kata {\n  function expression_matter(int a, int b, int c) public pure returns (int) {\n    if (a != 1 && b != 1 && c != 1) {return a * b * c;}\n    if (a == 1 && c == 1) {return a + b + c;}\n    if (a == 1 || (b == 1 && a <= c)) {return (a + b) * c;}\n    return a * (b + c);    \n  }\n\n}","lang_id":51,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:47","updated_at":"2022-12-23 16:36:47"}]}