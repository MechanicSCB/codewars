{"50654ddff44f800200000004":[{"id":208837,"user_id":null,"body":"def multiply := nat.mul","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208838,"user_id":null,"body":"def multiply : \u2115 \u2192 \u2115 \u2192 \u2115\n|a b := a * b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208839,"user_id":645,"body":"def multiply (a b : \u2115) : \u2115 := a * b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208840,"user_id":null,"body":"def multiply (a b : nat) : nat := a*b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208841,"user_id":null,"body":"def multiply (x y : \u2115) :=\n  x*y","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208842,"user_id":null,"body":"def multiply : \u2115 -> \u2115 -> \u2115\n|a b := a * b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208843,"user_id":null,"body":"--def multiply (a b : \u2115) : \u2115 := a * b\ndef multiply (a b : nat) : nat := a * b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208844,"user_id":null,"body":"--def multiply (a, b \u2208 \u2115) \u2208 \u2115 := a \u00d7 b\ndef multiply (a b : \u2115) : \u2115 := a * b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208845,"user_id":null,"body":"import tactic\n\ndef multiply (a b : nat) : nat := a*b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208846,"user_id":null,"body":"--def multiply (a, b \u2208 \u2115) \u2208 \u2115 := a * b\ndef multiply (a b : \u2115) : \u2115 := a * b","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c85201e20f73f08df4216b1":[{"id":208847,"user_id":196,"body":"import Preloaded\n\nuniverse u\n\ntheorem flip_flip {A : Type u} : \u2200 {t : mytree A}, flip_mytree (flip_mytree t) = t\n| (mytree.leaf _)       := rfl\n| (mytree.branch a l r) := by unfold flip_mytree; rw [flip_flip, flip_flip]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208848,"user_id":644,"body":"import Preloaded\n\n\/-\nuniverses u\n\ninductive mytree (A : Type u) : Type u\n| leaf : A \u2192 mytree\n| branch : A \u2192 mytree \u2192 mytree \u2192 mytree\n\ndef flip_mytree {A : Type u} : mytree A \u2192 mytree A\n| t@(mytree.leaf _)     := t\n| (mytree.branch a l r) := mytree.branch a (flip_mytree r) (flip_mytree l)\n-\/\n\nuniverse u\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nby induction t; simp [*, flip_mytree]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208849,"user_id":null,"body":"import Preloaded\n\n\/-\nuniverses u\n\ninductive mytree (A : Type u) : Type u\n| leaf : A \u2192 mytree\n| branch : A \u2192 mytree \u2192 mytree \u2192 mytree\n\ndef flip_mytree {A : Type u} : mytree A \u2192 mytree A\n| t@(mytree.leaf _)     := t\n| (mytree.branch a l r) := mytree.branch a (flip_mytree r) (flip_mytree l)\n-\/\n\nuniverse u\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nbegin\n  induction t with t a l r h1 h2, \n    refl,\n    rw [flip_mytree, flip_mytree,  h1, h2],\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208850,"user_id":null,"body":"import Preloaded\n\ntheorem flip_flip {A : Type*} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nby induction t; simp [flip_mytree, *]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208851,"user_id":null,"body":"import Preloaded\n\n\/-\nuniverses u\n\ninductive mytree (A : Type u) : Type u\n| leaf : A \u2192 mytree\n| branch : A \u2192 mytree \u2192 mytree \u2192 mytree\n\ndef flip_mytree {A : Type u} : mytree A \u2192 mytree A\n| t@(mytree.leaf _)     := t\n| (mytree.branch a l r) := mytree.branch a (flip_mytree r) (flip_mytree l)\n-\/\n\nuniverse u\n\nlemma flip_mytree_branch_push {A : Type u} {l r : mytree A} {a : A} : \n  flip_mytree (mytree.branch a l r) = mytree.branch a (flip_mytree r) (flip_mytree l) :=\nby refl\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nbegin\n  induction t with leaf a r l hr hl,\n    refl,\n  rw [flip_mytree_branch_push, flip_mytree_branch_push, hr, hl],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208852,"user_id":null,"body":"import Preloaded\nimport tactic\n\n\/-\nuniverses u\n\ninductive mytree (A : Type u) : Type u\n| leaf : A \u2192 mytree\n| branch : A \u2192 mytree \u2192 mytree \u2192 mytree\n\ndef flip_mytree {A : Type u} : mytree A \u2192 mytree A\n| t@(mytree.leaf _)     := t\n| (mytree.branch a l r) := mytree.branch a (flip_mytree r) (flip_mytree l)\n-\/\n\nuniverse u\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nbegin\n  induction t with node node b\u2081 b\u2082 h\u2081 h\u2082,\n  { simp_rw [flip_mytree],},\n  { rw [flip_mytree, flip_mytree,h\u2081,h\u2082]},\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208853,"user_id":null,"body":"import Preloaded\n\nuniverse u\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nbegin\n  induction t with _ _ _ _ hl hr;\n  repeat { rw flip_mytree },\n  rw [hl, hr],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208854,"user_id":null,"body":"import Preloaded\n\nuniverse u\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nbegin\n  induction t with h1 h2 h3 h4 h5 h6,\n  { refl },\n  rw [flip_mytree, flip_mytree, h5, h6],\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208855,"user_id":168,"body":"import Preloaded\n\nuniverse u\n\ntheorem flip_flip {A : Type u} {t : mytree A} : flip_mytree (flip_mytree t) = t :=\nby induction t with x x t1 t2 ih1 ih2; simp [flip_mytree]; simp [ih1, ih2]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208856,"user_id":null,"body":"import Preloaded\nuniverse u\nattribute [simp] flip_mytree\ntheorem flip_flip {A: Type u} {t: mytree A}: flip_mytree (flip_mytree t) = t := by induction t; simp *","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c879811bc562909bf65c8e6":[{"id":208857,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!\n  apply myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intro n,\n  apply myrefl,\nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply myrefl,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    assumption,\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208858,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  apply myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  apply myrefl,\nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply myrefl,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    apply ihn',\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208859,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  exact myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intro n,\n  simp [add, myrefl],\nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply myrefl,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    exact ihn',\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208860,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  apply myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intros n,\n  \n  apply myrefl,\n  \nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply myrefl,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    exact ihn',\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208861,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  exact myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intro n,\n  simp [add],\n  exact myrefl,\nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    exact add_n_zero zero,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    assumption,\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208862,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  exact myrefl\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intro n,\n  exact myrefl\nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    exact myrefl\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    exact ihn'\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208863,"user_id":713,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  apply myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  intro n,\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  apply myrefl,\nend\n\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intro n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply myrefl,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    apply ihn',\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208864,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  apply myrefl,\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intros h, \n  cases h, \n  apply myrefl, \n  apply myrefl, \nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply add_n_zero, \n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    apply ihn',\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208865,"user_id":null,"body":"\n\n-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  apply myrefl, \nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  intro n,\n  apply myrefl, \nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    apply myrefl,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    apply ihn', \n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208866,"user_id":null,"body":"-- Define a datatype to represent natural numbers\n-- based on Peano axioms.\ninductive mynat : Type\n  -- A natural number can be zero,\n| zero : mynat\n  -- or the successor of another natural number.\n| succ : mynat \u2192 mynat\n\n-- This allows us to write zero \/ succ in place of\n-- mynat.zero \/ mynat.succ\nopen mynat\n\n-- Two is the successor of successor of zero.\ndef two : mynat := succ (succ zero)\n\n-- We can find the predecessor.\ndef pred : mynat \u2192 mynat :=\n  -- Let's investigate the given number n\n  \u03bb n, mynat.cases_on n\n    -- If n is zero, its predecessor is also zero\n    zero\n    -- Otherwise, the predecessor of \"the successor\n    -- of n'\" is just n'\n    (\u03bb n', n')\n\n-- We define addition of two natural numbers\n-- inductively, using the recursor \"mynat.rec_on\"\ndef add : mynat \u2192 mynat \u2192 mynat :=\n  -- Let's analyze the right operand m\n  \u03bb n m, mynat.rec_on m\n    -- If m = 0, we have n + m = n + 0 = n\n    n\n    -- Otherwise, m = succ m' for some m'\n    -- We have n + succ m' = succ (n + m'), so to\n    -- calculate n + succ m', we first calculate\n    -- n + m', then add a \"succ\" to the result\n    (\u03bb m' add_n_m', succ (add_n_m'))\n\n-- Equality is defined as the smallest reflexive\n-- binary relation.\n-- You don't need to understand the curly braces\n-- for now, just type \"a = b\" as \"myeq a b\" and\n-- use \"myrefl\" to prove any equality of the form\n-- \"a = a\"\ninductive myeq : \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 \u2192 Prop\n| myrefl : \u2200 {\u03b1 : Type} {a : \u03b1}, myeq a a\n\n-- Again, this allows us to write \"myeq.myrefl\" as\n-- simply \"myrefl\"\nopen myeq\n\n-- Reflexivity holds by definition, so we can\n-- immediately prove 1 = 1 by refl.\ndef this_is_free : myeq (succ zero) (succ zero) :=\n  myrefl\n\n-- For non-trivial statements, we can state\n-- them as \"theorem\"s and \"begin\" \/ \"end\" a\n-- tactic-mode proof\ntheorem this_is_almost_free :\n  myeq (add two zero) (add zero two) :=\n-- Let us \"begin\" our proof:\nbegin\n  -- If you're using VSCode for Lean, you can\n  -- see the \"tactic state\" at this point.\n  -- Since both sides of the equality reduce\n  -- to 2, it holds by reflexivity\n  -- So we use the \"apply\" tactic to apply our\n  -- proof \"myrefl\" to the goal\n  apply myrefl,\n  -- Now that our goal (of proving 2 + 0 =\n  -- 0 + 2) has been accomplished,\n  -- we can \"end\" our proof.\nend\n\n-- Equality is a congruence. That is, if two\n-- mathematical objects are equal then they\n-- remain so after the same function is applied\n-- to both.\ntheorem cong : \u2200 (f : mynat \u2192 mynat) (n m : mynat),\n  myeq n m \u2192 myeq (f n) (f m) :=\nbegin\n  -- To prove a statement involving universal\n  -- quantification, we start with, \"Suppose we\n  -- have ...\"\n  -- The \"intros\" tactic does this in Lean\n  intros f n m hnm,\n  -- Now we know the existence of f, n, m and that\n  -- n = m, and our goal is to prove f n = f m\n  -- Since equality is the smallest reflexive binary\n  -- relation, n = m if and only if they are one and\n  -- the same\n  -- We can make Lean discover this by all possible\n  -- \"cases\" of n and m under our hypothesis \"hnm\"\n  -- that n = m. Here, \"cases\" is another tactic.\n  cases hnm,\n  -- Since n and m are one and the same, Lean has\n  -- replaced all occurrences of m with n. So now\n  -- it suffices to prove that f n = f n instead.\n  -- How do we prove it? ;-) Replace the \"sorry\"\n  -- tactic (a cheat to \"prove\" anything) with a\n  -- proper tactic to complete the proof.\n  -- (If you don't, Lean knows this!)\n  exact myrefl\nend\n\n-- Now for the main theorems:\n-- 1) n + 0 = n for any n\ntheorem add_n_zero : \u2200 n : mynat, myeq (add n zero) n :=\nbegin\n  -- Suppose we have ...\n  -- (look above for hints if you don't know how to\n  -- do this in Lean)\n  intro n,\n  -- TODO: insert tactic\n  -- (Couldn't put \"sorry\" here since it can only be used\n  -- once per goal)\n\n  -- n + 0 reduces to n so proving n + 0 = n is same\n  -- as proving n = n. How to prove this? ;-)\n  exact myrefl,\nend\n-- 2) 0 + n = n for any n\ntheorem add_zero_n : \u2200 n : mynat, myeq (add zero n) n :=\nbegin\n  -- Suppose we have a natural number n ...\n  intros n,\n  -- Now, you might be tempted to say it's trivial, but\n  -- remember we only have n + 0 = n by definition, not\n  -- 0 + n = n\n  -- So we need to prove 0 + n = n by induction on n\n  induction n,\n  case zero : {\n    -- Basis step (n = 0): we need to prove that 0 + 0 = 0\n    -- But 0 + 0 reduces to 0 so ... how to prove this? ;-)\n    exact add_n_zero zero,\n  },\n  case succ : n' ihn' {\n    -- Inductive step (n = succ n' for some n'): Given that\n    -- our theorem holds for n' (inductive hypothesis), our\n    -- goal is to show that it holds for succ n' as well\n    -- In Lean our inductive hypothesis is named \"ihn'\"\n    -- Now, since 0 + succ n' = succ (0 + n') by definition,\n    -- it suffices to \"show\" that succ (0 + n') = succ n'\n    -- instead:\n    show myeq (succ (add zero n')) (succ n'),\n    -- Now notice that our goal has the form f n = f m. We\n    -- proved above that in order to prove an equality of the\n    -- form f n = f m, it suffices to prove n = m instead,\n    -- and we do this in Lean by \"apply\"ing that theorem.\n    -- Who said that \"apply\" can only be used on \"myrefl\"?\n    apply cong,\n    -- But now what we want to prove is just our induction\n    -- hypothesis so we are done here (almost - how to do\n    -- this in Lean?)\n    exact ihn',\n  },\nend\n\n-- Congratulations on solving your first Kata in Lean!\n-- For a more interesting introduction to theorem proving\n-- in Lean, check out the following (listed in increasing\n-- order of difficulty):\n-- 1) Kevin Buzzard's natural number game (NNG):\n--    https:\/\/wwwf.imperial.ac.uk\/~buzzard\/xena\/natural_number_game\/\n-- 2) Logic and Proof:\n--    https:\/\/leanprover.github.io\/logic_and_proof\/\n--    OR\n--    Theorem Proving in Lean:\n--    https:\/\/leanprover.github.io\/theorem_proving_in_lean\/\n--    (or both, if you wish :-)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c8b332197eb04000887fd63":[{"id":208867,"user_id":644,"body":"import Preloaded tactic\n\ntheorem arith_eq_aux (n : \u2115) : arith_sum n * 2 = n * (n + 1) :=\nbegin\n  induction n with n ih,\n  { refl },\n  { rw [arith_sum, add_mul, ih, nat.succ_eq_add_one],\n    ring }\nend\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nnat.div_eq_of_eq_mul_left (by norm_num) (arith_eq_aux n).symm","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208868,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\ntheorem div_add : \u2200 a b : \u2115, a + b \/ 2 = (a * 2 + b) \/ 2 := begin\n  intros a b,\n  induction a with a ih, { simp },\n  rw succ_add, rw succ_mul, rw add_comm (a * 2), rw add_assoc,\n  rw add_div_left, { congr, assumption }, simp\nend\n\ntheorem arith_eq : \u2200 n : \u2115, arith_formula n = arith_sum n\n| 0 := rfl\n| (n + 1) := by {\n    dsimp [arith_sum, arith_formula], rw \u2190arith_eq n, dsimp [arith_formula],\n    rw div_add, congr, rw succ_mul n 2, ring\n  }\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208869,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nbegin \n  induction n with n ihop, refl,\n  rw arith_sum, rw \u2190 ihop, \n  simp only [arith_formula, nat.succ_eq_add_one],\n  apply eq.symm,\n  suffices two_ge_zero : 2 > 0,\n  calc (n + 1) + n*(n+1)\/2  = (n*(n+1))\/2 + (n+1) : by rw add_comm\n      ...                   = (n*(n+1) + 2*(n+1))\/2 : by rw \u2190 add_mul_div_left _ _ two_ge_zero\n      ...                   = ((n+2)*(n+1))\/2 : by rw  \u2190 add_mul\n      ...                   = (n+1)*(n+2)\/2 : by rw mul_comm,\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208870,"user_id":null,"body":"import Preloaded tactic\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nbegin\nrw arith_formula,\napply nat.div_eq_of_eq_mul_right (by norm_num:0<2),\ninduction n with n ih,\nrefl,\nrw [arith_sum,mul_add 2,\u2190ih,\u2190 nat.succ_eq_add_one n],\nring\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208871,"user_id":null,"body":"import Preloaded tactic\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n :=\nbegin\n  induction n with m hm,\n  { refl },\n  rw [arith_sum, \u2190 hm, arith_formula, arith_formula, nat.succ_eq_add_one,\n        (show (m + 1) * (m + 1 + 1) = m * (m + 1) +  2 * (m + 1), by ring),\n          nat.add_mul_div_left _ _ two_pos, add_comm],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208872,"user_id":null,"body":"import Preloaded tactic\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nbegin\n  induction n with n hn,\n  {refl,},\n  rw [arith_formula, arith_sum, \u2190 hn, arith_formula, nat.succ_mul, nat.add_one, nat.mul_succ, nat.add_assoc, nat.add_succ, nat.add_succ n, nat.succ_eq_add_one (n+n), nat.succ_eq_add_one (n+n+1)],\n  have h2: 2 = nat.succ 1,\n  refl,\n  have h3: n+ n + 1 + 1 = 2 * (n + 1):=\n  begin \n    rw [\u2190 nat.one_mul n, h2, nat.succ_mul 1, nat.one_mul, nat.one_mul, nat.add_assoc n 1, nat.add_comm 1, nat.add_assoc n n (1+1)],   \n  end,\n  rw [h3, nat.add_mul_div_left],\n  { rw [nat.add_comm]},\n  apply nat.lt.step,\n  apply nat.lt.base,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208873,"user_id":null,"body":"import Preloaded tactic\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nbegin\n  suffices : 2*arith_sum n = n*(n+1),\n  {\n    unfold arith_formula,\n    rw \u2190 this,\n    apply nat.div_eq_of_eq_mul_right,\n    linarith,\n    refl,\n  },\n  induction n with n hn,\n  refl,\n  unfold arith_sum,\n  simp only [mul_add, hn, nat.succ_eq_add_one, mul_one],\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208874,"user_id":null,"body":"import Preloaded tactic\nimport data.nat.parity\n\nlemma eq_iff_mul_two_eq (a b:\u2115): a=b\u2194a*2=b*2:=by{\n  refine (nat.mul_left_inj _).symm,\n  linarith,\n}\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := by{\n  induction n;simp[arith_sum,arith_formula],\n  simp[arith_sum,arith_formula] at n_ih,\n  rw[\u2190n_ih],\n  have h\u2082 : \u2200n:\u2115, 2\u2223n*(n+1),{\n    intro n,\n    refine even_iff_two_dvd.mp _,\n    by_cases even n,{\n      exact nat.even.mul_left h (n + 1),\n    },{\n      have h\u2082: even (n+1),{\n        exact nat.even_succ.mpr h,\n      },\n      exact nat.even.mul_right n h\u2082,\n    }\n  },\n  have h\u2081:n_n.succ * (n_n.succ + 1) \/ 2 * 2=n_n^2+3*n_n+2,from\n    calc \n      n_n.succ * (n_n.succ + 1) \/ 2 * 2= n_n.succ * (n_n.succ + 1): by{\n        exact nat.div_mul_cancel (h\u2082 n_n.succ),\n      }\n      ...=n_n^2+3*n_n+2:by{\n        ring_exp!,\n      },\n  have h\u2083:(n_n.succ + n_n * (n_n + 1) \/ 2)*2=n_n^2+3*n_n+2,from\n    calc\n      (n_n.succ + n_n * (n_n + 1) \/ 2)*2=  (n_n+1)*2+n_n * (n_n + 1) \/ 2*2:by{\n        exact add_mul (nat.succ n_n) (n_n * (n_n + 1) \/ 2) 2,\n      }\n      ...=(n_n+1)*2+n_n * (n_n + 1):by{\n        have h\u2084:n_n * (n_n + 1) \/ 2*2=n_n * (n_n + 1),{\n          exact nat.div_mul_cancel (h\u2082 n_n),\n        },\n        rw[h\u2084],\n      }\n      ...=n_n^2+3*n_n+2 : by{\n        ring_exp!,\n      },\n  have h\u2084:n_n.succ * (n_n.succ + 1) \/ 2 * 2=(n_n.succ + n_n * (n_n + 1) \/ 2)*2,{\n    exact (rfl.congr (eq.symm h\u2083)).mp h\u2081,\n  },\n  exact (eq_iff_mul_two_eq (n_n.succ * (n_n.succ + 1) \/ 2) (n_n.succ + n_n * (n_n + 1) \/ 2)).mpr h\u2084,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208875,"user_id":191,"body":"import Preloaded tactic\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nbegin\n  induction n with n hn,\n  refl,\n  rw [arith_sum, \u2190 hn, arith_formula, arith_formula, nat.succ_eq_add_one,\n      add_mul,one_mul, mul_add, add_assoc n 1 1, one_add_one_eq_two, mul_add,\n      mul_one, add_assoc, \u2190 add_assoc n n 2, \u2190 two_mul n, \u2190 (2 : \u2115).mul_succ n,\n      nat.add_mul_div_left (n * n + n) n.succ two_pos, add_comm]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208876,"user_id":null,"body":"import Preloaded tactic\n\ntheorem arith_eq (n : \u2115) : arith_formula n = arith_sum n := \nbegin\n  induction n with d hd,\n  refl,\n  rw [arith_sum, \u2190hd, arith_formula, arith_formula],\n  rw [nat.succ_eq_add_one, add_assoc, one_add_one_eq_two],\n  rw [mul_add, nat.add_mul_div_right _ _ zero_lt_two], \n  rw [mul_comm d, add_comm],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c8b3e55b9d1190016bd3cca":[{"id":208877,"user_id":null,"body":"import Preloaded tactic\n\nlemma fib_aux_add (n : \u2115) : \u2200 a b, fib_aux a b (n + 2) = fib_aux a b (n + 1) + fib_aux a b n := \nbegin\n  induction n with d hd, \n  intros a b, repeat {rw fib_aux}, rw add_comm,\n  intros a b,\n    have t\u2081 : fib_aux a b (d.succ + 2) = fib_aux b (a + b) (d.succ + 1), from rfl, \n    have t\u2082 : fib_aux a b (d.succ + 1) = fib_aux b (a + b) (d.succ), from rfl,\n    have t\u2083 : fib_aux a b d.succ = fib_aux b (a + b) d, from rfl,\n  rw [t\u2081, t\u2082, t\u2083],\n  exact hd b (a + b)\nend\n\ntheorem fib_eq : \u2200 n : \u2115, fib2 n = fib n\n| 0 := rfl\n| 1 := rfl\n| (n + 2) := by rw [fib, \u2190 fib_eq (n + 1), \u2190 fib_eq n]; exact fib_aux_add n 0 1\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208878,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n := \nbegin \n  suffices h: \u2200 a b : \u2115, fib_aux a (a+b) n = a*(fib (n+1)) + b*(fib n), { rw fib2, rw h 0 1, ring },\n  induction n with n ihop, \n  { intros a b, rw fib_aux, rw [fib,fib], ring },\n  { intros a b, rw fib_aux, \n    specialize ihop (a+b) a, \n    have h : a + (a + b) = a + b + a, by ring,\n    rw [h, ihop, fib], ring }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208879,"user_id":null,"body":"import Preloaded tactic\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n :=\nbegin\n  suffices :fib2 n = fib n \u2227 fib2 n.succ = fib n.succ,\n  {\n    exact this.1,\n  },\n  induction n with n hn,\n  {\n    split;\n    refl,\n  },\n  {\n    split,\n    exact hn.2,\n    simp [fib2,fib_aux,fib,\u2190 hn.1,\u2190 hn.2],\n    clear hn,\n    suffices : \u2200 a b c d, fib_aux (a+b) (c+d) n = fib_aux a c n + fib_aux b d n,\n    {\n      exact this 1 0 1 1,\n    },\n    induction n with n hn,\n    {\n      simp [fib_aux],\n    },\n    {\n      intros a b c d,\n      simp [fib_aux],\n      have : (a + b + (c + d)) = a+c+(b+d) := by ring,\n      rw this,\n      apply hn c d (a+c) (b+d),\n    }\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208880,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem two_induction : \u2200 {p : \u2115 \u2192 Prop} (n : \u2115), p 0 \u2192 p 1 \u2192 (\u2200 (n : \u2115), ((p n \u2227 p n.succ) \u2192 p n.succ.succ)) \u2192 p n :=\nbegin\n  intros p n p\u2080 p\u2081 ind,\n  have : \u2200 (n : \u2115), p n \u2227 p n.succ:=\n  begin\n    intro m,\n    induction m with m pm,\n    split,\n    any_goals {assumption},\n    split,\n    exact pm.right,\n    apply ind m,\n    exact pm,\n  end,\n  exact (this n).left,\nend\n\nlemma fib_aux_ind (n m l: \u2115): fib_aux n m l.succ.succ = fib_aux n m l.succ + fib_aux n m l :=\nbegin\n  revert n m,\n  induction l with l hl,\n  { repeat {rw fib_aux},\n  exact add_comm,},\n  intros n m,\n  rw fib_aux,\n  conv\n  begin\n    to_rhs,\n    rw fib_aux,\n  end,\n  conv in (fib_aux n m l.succ)\n  begin\n    rw fib_aux,\n  end,\n  exact hl m (n+m),\nend\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n :=\nbegin\n  apply two_induction n,\n  { rw [fib, fib2, fib_aux],},\n  { rw [fib, fib2, fib_aux, fib_aux],},\n  intros m h,\n  cases h with h\u2081 h\u2082,\n  rw [fib, fib2, \u2190 h\u2081,\u2190 h\u2082, fib_aux, fib2, fib2, fib_aux, fib_aux],\n  simp,\n  clear h\u2081 h\u2082,\n  cases m with m,\n  { repeat {rw fib_aux},},\n  cases m with m,\n  { repeat {rw fib_aux},},\n  { \n    conv in (fib_aux 1 1 m.succ.succ) {rw fib_aux},\n    conv in (fib_aux 0 1 m.succ.succ) {rw fib_aux, rw fib_aux},\n    simp,\n    exact fib_aux_ind 1 2 m,\n    },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208881,"user_id":null,"body":"import Preloaded\nimport data.real.basic\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n := \nbegin\n\nhave h : \u2200 k : \u2115 , \u2200 m: \u2115 ,    fib_aux (fib k) (fib (k+1)) (m+1)  = fib_aux (fib (k+1))  (fib (k+2)) m ,\nintros k m,\nhave h_equals : (fib k) + fib (k+1) = (fib (k+1)) + fib k,\nexact add_comm _ _,\nexact calc\n      fib_aux (fib k) (fib (k+1)) (m+1) = fib_aux (fib (k+1)) (fib k + fib (k+1)) m : by exact rfl\n      ... = fib_aux (fib (k+1)) (fib (k+1) + fib k) m : by rw h_equals\n                      ...       = fib_aux (fib (k+1)) (fib (k+2)) m : by exact rfl,\n\nhave h' : \u2200 k : \u2115 , \u2200 m: \u2115 ,  k+m = n \u2192   fib_aux (fib k) (fib (k+1)) m  = fib n,\nintros k m,\nintro h'',\nrevert k,\n\ninduction m ,\n\nintro k,\nrw add_zero,\nintro h_foo,\nrw h_foo,\nrefl,\n\nintro k,\nintro h'',\nrw nat.add_succ at h'',\nrw add_comm at h'',\nrw \u2190 nat.add_succ at h'',\nrw add_comm at h'',\nhave h_bar := m_ih k.succ,\nhave h2 := h_bar h'',\n\nrw h k m_n,\n\nexact h2,\n\nhave h'' : 0+n = n,\nsimp,\n\nhave h3 := h' 0 n h'',\nrw \u2190 h3,\nrefl,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208882,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlemma fib_aux_eq : \u2200(n i : \u2115),fib_aux (fib n) (fib (n+1)) i= fib (n+i):= by{\n  intros n i,\n  revert n,\n  induction i with i ih,{\n    intro n,\n    induction n,\n    refl,\n    refl,\n  },{\n    intro n,\n    simp [fib_aux],\n    let h\u2081 :=ih (n+1),\n    simp[fib] at h\u2081,\n    have h\u2082:(fib n.succ + fib n)=(fib n + fib (n + 1)),{\n      exact add_comm (fib (nat.succ n)) (fib n),\n    },\n    rw[\u2190h\u2082],\n    simp[h\u2081],\n    have h\u2083:n + 1 + i=n+i.succ,{\n      ring,\n    },\n    exact congr_arg fib h\u2083,\n  }\n}\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n :=\nmatch n with \n| 0 := by {refl}\n| 1 := by {refl}\n| (n+2) := by{\n  simp[fib2],\n  \/-\n  n : \u2115,\n  _match : \u2200 (_a : \u2115), fib2 _a = fib _a,\n  n : \u2115\n  \u22a2 fib_aux 0 1 (n + 2) = fib (n + 2)\n  -\/\n  have h\u2081:fib_aux (fib 0) (fib (0+1)) (n+2) = fib(0+n+2),{\n    exact fib_aux_eq 0 (n+2)\n  },\n  have h\u2082: fib 0 = 0,refl,\n  have h\u2083: fib 1 = 1,refl,\n  simp at h\u2081,\n  simp [h\u2082,h\u2083] at h\u2081,\n  exact h\u2081,\n}\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208883,"user_id":null,"body":"import Preloaded\n\nlemma fib_aux_eq (n m : \u2115) : fib_aux (fib n) (fib (n + 1)) m = fib (m + n) := begin\n  induction m generalizing n, { rw nat.zero_add, refl },\n  specialize m_ih (n + 1), simp [fib, fib_aux] at *, rw nat.add_comm (fib n), rw m_ih,\n  rw [nat.add_comm n, \u2190nat.add_assoc]\nend\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n := fib_aux_eq 0 n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208884,"user_id":null,"body":"import Preloaded tactic\n\ntheorem fib_aux_eq (k n : \u2115) : fib_aux (fib k) (fib (k + 1)) n = fib (k + n) := by {\n  induction n with n ih generalizing k, { refl },\n  cases n,\n  { dsimp [fib_aux], refl },\n  rw [fib_aux, nat.add_comm (fib k)],\n  rw (show fib (k + 1) + fib k = fib (k + 2), by refl),\n  rw ih k.succ,\n  rw nat.succ_add,\n  refl\n}\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n := by {\n  rw [fib2, \u2190(show fib 0 = 0, by refl), \u2190(show fib 1 = 1, by refl), fib_aux_eq],\n  simp\n}\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208885,"user_id":null,"body":"import Preloaded tactic\n\nlemma aux : \u2200(n k : \u2115), fib2 (n + k) = fib_aux (fib n) (fib (n + 1)) k :=\nbegin\n  intros n,\n  induction n with d hd,\n  { intros k, simp [fib, fib2], },\n  intros k,    \n  rw [nat.succ_eq_add_one, add_assoc, add_comm 1, hd (k+1)],\n  rw [fib_aux, fib, nat.succ_eq_add_one, add_comm (fib d)],   \nend\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n := aux n 0","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208886,"user_id":168,"body":"import Preloaded data.nat.basic\n\nlemma fib_aux_eq (m n : \u2115) : fib_aux (fib m) (fib (m + 1)) n = fib (m + n) :=\nbegin\n  induction n with n ih generalizing m, refl,\n  rw [fib_aux, add_comm (fib m), \u2190fib, ih, add_assoc, add_comm 1]\nend\n\ntheorem fib_eq (n : \u2115) : fib2 n = fib n :=\nby rw [fib2, \u2190zero_add n, \u2190fib_aux_eq, zero_add, zero_add]; refl","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c8b4215a99b9c000d07d7b2":[{"id":208887,"user_id":null,"body":"import Preloaded\n\ntheorem sum_eq_aux (f k n) : sum_aux k f n = k + sum_simple f n :=\nby induction n generalizing k; simp [sum_aux,sum_simple,*]; ac_refl\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nby rw [sum_tail,sum_eq_aux,zero_add]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208888,"user_id":null,"body":"import Preloaded\n\ntheorem sum_aux_eq (f) : \u2200 a n, sum_aux a f n = sum_simple f n + a\n| a 0 := rfl\n| a (n+1) := by rw [sum_aux, sum_simple, sum_aux_eq, add_left_comm, add_assoc]\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nby rw [sum_tail, sum_aux_eq, add_zero]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208889,"user_id":null,"body":"import Preloaded\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin\n  unfold sum_tail, rw \u2190 add_zero (sum_simple f n),\n  generalize : 0 = a, revert a,\n  induction n with n h, intro a, rw [sum_aux, sum_simple],\n  intro a, rw [sum_aux, sum_simple, h, \u2190add_assoc, add_comm _ (f(n+1))],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208890,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin\n  suffices h: \u2200 a, sum_aux a f n = a + sum_simple f n, { rw [sum_tail, h 0, nat.zero_add] },\n  induction n with n ihop; \n    intro a; \n    rw [sum_aux, sum_simple],\n    { ring },\n    { rw [ihop (f(n+1)+a)], ring }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208891,"user_id":null,"body":"import Preloaded tactic\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin\n  suffices : \u2200 a, sum_aux a f n = sum_simple f n + a,\n  {\n    exact this 0,\n  },\n  induction n with n ih,\n  intro a,\n  refl,\n  intro a,\n  simp [sum_tail,sum_aux] at *,\n  specialize ih (f(n+1)+a),\n  rw ih,\n  simp [sum_simple],\n  ring,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208892,"user_id":null,"body":"import Preloaded\nimport tactic\nlemma tailrec  (f : \u2115 \u2192 \u2115) (n : \u2115) : \u2200 a:\u2115,  sum_aux a f n = sum_aux 0 f n + a :=\nbegin\n  induction n with n ihn,\n  intro a,\n    refl, \n    intro b,\n    rw [sum_aux,sum_aux,add_zero],\n    have A: sum_aux (f (n + 1) + b) f n = (sum_aux 0 f n) +(f(n+1)+b),\n      exact ihn (f(n+1)+b),\n    have B: sum_aux (f (n + 1)) f n = (sum_aux 0 f n) +f(n+1),\n      apply ihn (f(n+1)),\n      rw [A,B,add_assoc]\nend\n\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin\ninduction n with n ih,\nrefl,\nrw [sum_simple,sum_tail,sum_aux,add_zero, tailrec f n (f(n+1)),\u2190 sum_tail,ih,add_comm]\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208893,"user_id":null,"body":"import Preloaded tactic.ring\n\nlemma aux_lem (a b f n) : sum_aux (a + b) f n = a + sum_aux b f n :=\nbegin\n  induction n with k hk generalizing a b,\n  { unfold sum_aux, ring, },\n  { unfold sum_aux, rw [\u2190 nat.add_assoc, hk, hk], ring, },\nend\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin\n  induction n with m IH, { refl, },\n  rw [sum_tail, sum_aux, sum_simple, nat.add_zero, \u2190 IH, sum_tail],\n  apply aux_lem (f (m+1)) 0,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208894,"user_id":null,"body":"import Preloaded tactic\n\nlemma aux_add {n: \u2115} {f : \u2115 \u2192 \u2115} : \u2200 a b : \u2115, sum_aux (a + b) f n = a + sum_aux b f n :=\nbegin\n  induction n with d hd,\n  { intros a b, simp [sum_aux], ring },\n  intros a b,\n  simp [sum_aux],\n  rw \u2190(hd a (f (d + 1) + b)), \n  cc,\nend\n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin\n  induction n with d hd,\n  { refl },\n  unfold sum_tail sum_simple sum_aux at *,  \n  rw [\u2190hd, add_zero],\n  apply aux_add (f (d + 1)) 0,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208895,"user_id":null,"body":"import Preloaded\nimport tactic \nimport data.nat.basic \n\nlemma sum_aux_eq : \u2200 a f n, sum_aux a f n = a + sum_aux 0 f n \n| a f 0 := by { repeat { rw [sum_aux] }, ring } \n| a f (n+1) := \n  begin \n    rw [sum_aux, sum_aux,\n        sum_aux_eq (f (n + 1) + a) _ n, \n        sum_aux_eq (f (n + 1) + 0) _ n],\n    ring,\n  end \n\ntheorem sum_eq (f n) : sum_tail f n = sum_simple f n :=\nbegin \n  rw sum_tail,\n  induction n,\n  case zero { refl, },\n  case succ : n ih { \n    rw [sum_aux, sum_aux_eq, ih, sum_simple], \n    ring },\nend \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208896,"user_id":null,"body":"import Preloaded\n\nimport tactic.ring\n\ntheorem sum_aux_eq : \u2200 a f n, sum_aux a f n = sum_simple f n + a\n| a f 0       := by   rw [sum_aux, sum_simple]\n| a f n@(m+1) := by { rw [sum_aux, sum_simple, sum_aux_eq], ring }\n\ntheorem sum_eq : \u2200 f n, sum_tail f n = sum_simple f n := sum_aux_eq _\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c8b4799133e6c0009c7b096":[{"id":208897,"user_id":null,"body":"import Preloaded tactic.linarith\n\nlemma cases_e (g b e : \u2115) : (e.bodd = ff \u2192 pow_sqr_aux g.succ b e =   pow_sqr_aux g (b*b) (e\/2)) \u2227\n                            (e.bodd = tt \u2192 pow_sqr_aux g.succ b e = b*pow_sqr_aux g (b*b) (e\/2)) :=\nby split; { intro h, rw pow_sqr_aux, simp only, rw [nat.bodd_div2_eq, h, nat.div2_val e, pow_sqr_aux], }\n\ntheorem pow_eq (b e : \u2115) : pow_sqr b e = b ^ e :=\nbegin\n  suffices : \u2200 (g : \u2115), g \u2265 e \u2192 pow_sqr_aux g b e = b ^ e, by exact this e rfl.ge,\n  revert b,\n  apply nat.strong_induction_on e, clear e,\n  intros e IH b g g_ge_e,\n  cases e, \n  { induction g with _ IH' generalizing b, { simp [pow_sqr_aux], }, \n    rw (cases_e _ b 0).1 nat.bodd_zero, \n    exact IH' (zero_le _) (b * b), },\n  cases g, { exfalso, simpa using g_ge_e, },\n  have : e.succ > e.succ \/ 2, by exact nat.div_lt_of_lt_mul (by linarith [nat.succ_pos e]),\n  specialize IH (e.succ \/ 2) this (b * b) g (nat.lt_succ_iff.1 (gt_of_ge_of_gt g_ge_e this)),\n  obtain \u27e8h1, h2\u27e9 := \u27e8(cases_e g b e.succ), nat.mod_add_div e.succ 2\u27e9,\n  simp only [nat.mod_two_of_bodd, nat.bodd_succ, bnot_eq_ff_eq_eq_tt, bnot_eq_true_eq_eq_ff] at h1 h2,\n  cases e.bodd; { simp only at h1,\n                  simp only [h1, IH, mul_pow, \u2190 pow_add, \u2190 two_mul, \u2190 pow_succ],\n                  apply congr_arg (\u03bb x : \u2115, b ^ x),\n                  simpa [add_comm] using h2, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208898,"user_id":null,"body":"import Preloaded tactic data.nat.parity data.nat.pow\n\nopen nat\n\nlemma strong_induction : \u2200(C:\u2115\u2192Prop), C 0 \u2192 \n(\u2200(n:\u2115),(\u2200(x:\u2115)(h:x\u2264n),C x) \u2192 C (n+1)) \u2192\n\u2200(n x:\u2115)(h:x\u2264n),C x := by{\n  intros C h\u2081 h\u2082 n,\n  induction n,{\n    finish,\n  },{\n    have cnsucc:=h\u2082 n_n n_ih,\n    intros x hx,\n    cases hx with _ hxl,{\n      tauto,\n    },{\n      tauto,\n    }\n  }\n}\n\n\nlemma bodd_div2_nat_eq (n:\u2115) : ((even n) \u2192 (nat.bodd_div2 n)=(prod.mk ff (n\/2)))\n\u2227 ((odd n) \u2192 (bodd_div2 n)=(prod.mk tt (n\/2))):=by{\n  induction n with n hn,{\n    split;{\n      intro,\n      refl <|> finish,\n    },\n  },{\n    split,{\n      intro h0,\n      cases hn with hn1 hn2,\n      have h1: odd n,{\n        have h2:odd 1,norm_num,\n        have h3:1\u2264n+1,norm_num,\n        have h4:odd 1 \u2194 even (n+1),tauto,\n        exact (odd_sub' h3).mpr h4,\n      },\n      specialize hn2 h1,\n      dsimp [bodd_div2],\n      rw [hn2],\n      unfold bodd_div2,\n      congr,\n      replace h1:=(odd_iff).mp h1,\n      have h2:n.succ=n+1,refl,\n      rw h2,\n      have h3:=mod_add_div n 2,\n      rw h1 at h3,\n      conv{\n        to_rhs,\n        rw [\u2190h3],\n        ring_nf,\n      },\n      norm_num,    \n    },{\n      intro h0,\n      cases hn with hn1 hn2,\n      have h1:even n,{\n        have h2:odd 1,norm_num,\n        have h3:1\u2264n+1,norm_num,\n        have h4:odd (n+1)\u2194odd 1,tauto,\n        exact (even_sub' h3).mpr h4,\n      },\n      specialize hn1 h1,\n      dsimp [bodd_div2],\n      rw [hn1],\n      unfold bodd_div2,\n      have h2:n\/2=n.succ\/2,{\n        have h3:n.succ % 2=1,exact odd_iff.mp h0,\n        have h4:=mod_add_div n.succ 2,\n        rw h3 at h4,\n        have h5:n.succ=n+1,refl,\n        rw h5 at h4,\n        ring_nf at h4,\n        norm_num at h4,\n        conv{\n          to_lhs,\n          rw \u2190h4,\n        },\n        norm_num,\n      },\n      rwa [h2],\n    }\n  }\n}\n\nlemma bodd_div2_even_eq (n:\u2115)(h:even n): (bodd_div2 n)=(prod.mk ff (n\/2)):=by{\n  exact (and.left (bodd_div2_nat_eq n)) h,\n}\nlemma bodd_div2_odd_eq (n:\u2115)(h:odd n): (bodd_div2 n)=(prod.mk tt (n\/2)):=by{\n  exact (and.right (bodd_div2_nat_eq n)) h,\n}\n\n\nlemma pow_aux_eq_aux (z b e:\u2115) : pow_sqr_aux z b e= \nif z=0 then 1 else (if (even e) then pow_sqr_aux (z-1) (b*b) (e\/2) else \nb*pow_sqr_aux (z-1) (b*b) (e\/2)):=by{\n  split_ifs,{\n    rw [h],\n    refl,\n  },{\n    rename h_1 h1,\n    have h2:z\u22651,omega,\n    have h3:z-1+1=z,omega,\n    conv{\n      to_lhs,\n      conv{\n        congr,\n        rw[\u2190h3],\n      },\n      dsimp [pow_sqr_aux],\n    },\n    have h4:=(bodd_div2_even_eq e h1),\n    rw [h4],\n    dsimp,\n    refl,\n  },{\n    rename h_1 h1,\n    have h2: odd e,exact odd_iff_not_even.mpr h1,\n    have h3:z-1+1=z,omega,\n    conv{\n      to_lhs,\n      conv{\n        congr,\n        rw[\u2190h3],\n      },\n      dsimp [pow_sqr_aux],\n    },\n    rw [bodd_div2_odd_eq e h2],\n    refl,\n  }\n}\n\nlemma pow_eq_aux  :\u2200(z b e:\u2115)(h:e\u2264z),pow_sqr_aux z b e = b^e := by{\n  intro z,\n  have h0:\u2200(b e:\u2115)(h:e\u22640),pow_sqr_aux 0 b e=b^e,{\n    intros b e he,\n    have h0:e=0,omega,\n    rw [h0],\n    dsimp [pow_sqr_aux],\n    refl,\n  },\n  have h1:(\u2200(n:\u2115),(\u2200(x:\u2115)(h:x\u2264n),\u2200(b e:\u2115)(h:e\u2264x),pow_sqr_aux x b e=b^e) \n  \u2192 \u2200(b e:\u2115)(h:e\u2264n+1),pow_sqr_aux (n+1) b e=b^e),{\n    intros n hn b e he,\n    rw [pow_aux_eq_aux],\n    have h1:(e\/2)\u2264n,{\n      by_cases (n=0),{\n        simp [h] at he,\n        rw [h],\n        interval_cases e;norm_num,\n      },{\n        clear_except h he,\n        have h1: n>0,exact ne.bot_lt h,\n        have h2:n\u22651,exact h1,\n        have h3:n+1\u22642*n,omega,\n        clear h1 h2,\n        have h1:e\u22642*n,omega,\n        exact nat.div_le_of_le_mul h1,\n      }\n    },\n    split_ifs,{\n      finish,\n    },{\n      simp,\n      rename h_1 h2,\n      have h3:=hn n (le_of_eq (eq.refl n)) (b*b) (e\/2) h1,\n      rw h3,\n      clear_except h2,\n      rw mul_pow b b (e\/2),\n      rw \u2190pow_add,\n      congr,\n      ring_nf,\n      rw mul_comm 2 _,\n      have h1:2\u2223e,exact h2,\n      exact nat.div_mul_cancel h1,\n    },{\n      simp,\n      rename h_1 h2,\n      have h3:=hn n (le_of_eq (eq.refl n)) (b*b) (e\/2) h1,\n      rw h3,\n      replace h2:=odd_iff_not_even.mpr h2,\n      clear_except h2,\n      rw mul_pow b b (e\/2),\n      rw \u2190pow_add,\n      have h1:b=b^1,finish,\n      conv{\n        to_lhs,\n        congr,\n        rw h1,\n      },\n      rw \u2190(pow_add b 1 (e\/2+e\/2)),\n      congr,\n      ring_nf,\n      have h3:=mod_add_div e 2,\n      have h4:e%2=1,exact odd_iff.mp h2,\n      rw h4 at h3,\n      finish,\n    },\n  },\n  exact strong_induction (\u03bb z:\u2115,\u2200(b e:\u2115)(h:e\u2264z),pow_sqr_aux z b e=b^e) h0 h1 \n  z z (le_of_eq (eq.refl z)),\n}\n\n\n\ntheorem pow_eq (b e : \u2115) : pow_sqr b e = b ^ e := by{\n  exact pow_eq_aux e b e (le_of_eq (eq.refl e)),\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208899,"user_id":null,"body":"import Preloaded\nimport tactic tactic.induction\nopen nat\n\nlemma wf {e g m d : \u2115} (h1 : e \u2264 g + 1) (h2 : d + 2 * m = e) : m \u2264 g := \nbegin\n  cases' hm : m,\n  { linarith },\n  { apply le_of_mul_le_mul_left _ (show 0 < 2, by linarith),\n    have hg : 1 \u2264 g,\n    { simp [succ_eq_add_one, mul_add] at h2,\n      linarith },\n    linarith }\nend\n\nlemma ans_aux : \u2200 g b e : \u2115, e \u2264 g \u2192 pow_sqr_aux g b e = b ^ e :=\nbegin\n  intros g b e,\n  have hg0 : \u2200(m : \u2115), pow_sqr_aux 0 b m = 1 := \u03bbm, rfl,\n  have hg : \u2200(g b e : \u2115), pow_sqr_aux g.succ b e = prod.cases_on\n    (bodd_div2 e)\n    (\u03bb r e', bool.cases_on r\n      (pow_sqr_aux g (b * b) e')\n      (b * pow_sqr_aux g (b * b) e')) := by simp [pow_sqr_aux],\n  induction' g,\n  { intros he,\n    have he' : e = 0 := by linarith,\n    simp [he', pow_sqr_aux] },\n  { intros he,\n    rw hg g b e,    \n    cases' hd : e.bodd_div2 with u m,\n    cases' u; simp [bodd_div2] at hd; \n    have ht := bodd_add_div2 e;\n    simp [hd] at ht; simp,\n    { have hgm : m \u2264 g := wf he (show 0 + 2 * m = e, by simp [ht]),\n      have hh := ih (b * b) m hg0 hgm,\n      simp [hh, \u2190ht],\n      ring_exp },      \n    { have hgm : m \u2264 g := wf he (show 1 + 2 * m = e, by simp [ht]),\n      have hh := ih (b * b) m hg0 hgm,\n      simp [hh, \u2190ht],\n      ring_exp } }      \nend\n\ntheorem pow_eq (b e : \u2115) : pow_sqr b e = b ^ e := \n  ans_aux e b e (le_refl e)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208900,"user_id":17,"body":"import Preloaded tactic\n\nopen nat\n\n-- Lemmas to avoid deterministic timeout\nlemma lt1 {n : \u2115} (hn : n < 1) : n = 0 := by omega\nlemma lt_of_mul2 {n m : \u2115} (hm : m > 0) (hnm : 2 * n < 2 * m) :\n  n < m := by omega\nlemma zero_lt_2 : 0 < 2 := by omega\nlemma lt_succ {n m : \u2115} (hnm : n + 1 < m) : n < m := by omega\n\nlemma bodd_div2_bodd_div2 (n : \u2115) : bodd_div2 n = (bodd n, div2 n) := by simp\n\nlemma pow_sqr_aux_correct : \u2200 gas base exponent,\n  2 ^ gas > exponent \u2192\n  pow_sqr_aux gas base exponent = base ^ exponent :=\nbegin\n  introv; induction gas generalizing base exponent; simp;\n    introv hgt,\n  case zero : { subst hgt; refl },\n  case succ : gas' ihgas' {\n    simp [pow_sqr_aux],\n    generalize hdme : bodd_div2 exponent = dme,\n    cases dme with b exponent',\n    simp,\n    rw bodd_div2_bodd_div2 at *,\n    injection hdme with hdme1 hdme2,\n    clear hdme,\n    cases b; simp,\n    { show pow_sqr_aux gas' (base * base) exponent' = base ^ exponent,\n      have h := bodd_add_div2 exponent,\n      rw [hdme1, hdme2] at h,\n      simp at h,\n      subst h,\n      have hgt' : 2 * exponent' < 2 * 2 ^ gas' := hgt,\n      clear hgt,\n      rename hgt' hgt,\n      have hgas' := pow_pos zero_lt_2 gas',\n      have hgt' := lt_of_mul2 hgas' hgt,\n      clear hgt,\n      rename hgt' hgt,\n      have h := ihgas' (base * base) _ hgt,\n      rw h,\n      rw pow_mul,\n      show (base * base) ^ exponent' = (base * (base * 1)) ^ exponent',\n      rw mul_one },\n    { show base * pow_sqr_aux gas' (base * base) exponent' = base ^ exponent,\n      have h := bodd_add_div2 exponent,\n      rw [hdme1, hdme2] at h,\n      simp at h,\n      subst h,\n      have hgt' : 1 + 2 * exponent' < 2 * 2 ^ gas' := hgt,\n      clear hgt,\n      rename hgt' hgt,\n      have hgas' := pow_pos zero_lt_2 gas',\n      rw add_comm at *,\n      have hgt' := lt_succ hgt,\n      clear hgt,\n      rename hgt' hgt,\n      have hgt' := lt_of_mul2 hgas' hgt,\n      clear hgt,\n      rename hgt' hgt,\n      have h := ihgas' (base * base) _ hgt,\n      rw h,\n      show base * (base * base) ^ exponent' =\n        base * base ^ (2 * exponent'),\n      rw pow_mul,\n      rw mul_comm,\n      show (base * base) ^ exponent' * base =\n        base * (base * (base * 1)) ^ exponent',\n      rw [mul_one, mul_comm] }\n  }\nend\n\nlemma pow2_e_gt_e (e : \u2115) : 2 ^ e > e :=\nbegin\n  induction e,\n  case zero : { omega },\n  case succ : e' ihe' {\n    show 2 * 2 ^ e' > succ e',\n    generalize h : 2 ^ e' = f,\n    rw h at ihe',\n    clear h,\n    omega\n  }\nend\n\ntheorem pow_eq (b e : \u2115) : pow_sqr b e = b ^ e :=\nbegin\n  apply pow_sqr_aux_correct,\n  apply pow2_e_gt_e\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208901,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlemma proof_aux  (g : \u2115) : \u2200 b e : \u2115, 2^g > e \u2192 pow_sqr_aux g b e = pow b e :=\nbegin\n  induction g with k hk,\n  { intros b e h, rw (show e = 0, by linarith), refl, },\n  { intros b f h,\n    specialize hk (b * b) (f\/2) (nat.div_lt_of_lt_mul (pow_succ 2 k \u25b8 h)),\n    dsimp [pow_sqr_aux] at *, rw [nat.bodd_div2_eq, nat.div2_val f] at *,\n    cases (nat.bodd f).dichotomy with fparity fparity;\n    { rw fparity, dsimp, rw [hk, \u2190pow_two, \u2190pow_mul],\n      try {rw [\u2190pow_succ, add_comm]}, congr, symmetry,\n      transitivity,\n      { rw \u2190(nat.mod_add_div f 2), },\n      { rw [nat.mod_two_of_bodd, fparity], simp, }, }, },\nend\n\ntheorem pow_eq (b e : \u2115) :pow_sqr b e = b ^ e :=\nbegin\n  apply proof_aux,\n  exact nat.lt_two_pow e,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208902,"user_id":null,"body":"import Preloaded\nimport data.nat.basic tactic\n\nopen nat\n\nlemma mul_div_cancel_of_even {f : \u2115} (h : bodd f = ff) : 2 * (f\/2) = f :=\nbegin\n  apply nat.mul_div_cancel',\n  apply dvd_of_mod_eq_zero,\n  rw [mod_two_of_bodd, h],\n  refl,\nend\n\nlemma mul_div_cancel_of_odd {f : \u2115} (h : bodd f = tt) : 1 + 2 * (f\/2) = f :=\n  have h\u2082 : f % 2 = 1, { rw [mod_two_of_bodd, h], refl, },\n  eq.trans (show 1 + 2 * (f\/2) = f % 2 + 2 * (f\/2), by rw h\u2082) (mod_add_div f 2)\n\nlemma proof_aux  (g : \u2115) : \u2200 b e : \u2115, 2^g > e \u2192 pow_sqr_aux g b e = pow b e :=\nbegin\n  induction g with k hk,\n  { intros b e h, rw (show e = 0, by linarith), refl, },\n  { intros b f h,\n    specialize hk (b * b) (f\/2) (nat.div_lt_of_lt_mul (pow_succ 2 k \u25b8 h)),\n    dsimp [pow_sqr_aux] at *, rw [bodd_div2_eq, div2_val f] at *,\n    obtain feven | fodd : (bodd f) = ff \u2228 (bodd f) = tt := (bodd f).dichotomy,\n    { rw feven, dsimp,\n      rw [hk, \u2190pow_two, \u2190pow_mul, mul_div_cancel_of_even feven], },\n    { rw fodd, dsimp,\n      rw [hk, \u2190pow_two, \u2190pow_mul, \u2190pow_succ, add_comm, mul_div_cancel_of_odd fodd], }, },\nend\n\ntheorem pow_eq (b e : \u2115) :pow_sqr b e = b ^ e :=\nbegin\n  apply proof_aux,\n  exact lt_two_pow e,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208903,"user_id":null,"body":"import Preloaded\nimport data.nat.basic tactic\n\nopen nat\n\nlemma pow_sqr_aux_zero (b e : \u2115) : pow_sqr_aux 0 b e = 1 := rfl\n\nlemma odd_case {g b e : \u2115} (h : bodd e = tt) : pow_sqr_aux (nat.succ g) b e = b * pow_sqr_aux g (b * b) (e\/2) :=\nby {dsimp [pow_sqr_aux], rw [bodd_div2_eq, h, (div2_val e)]}\n\nlemma even_case {g b e : \u2115} (h : bodd e = ff) : pow_sqr_aux (nat.succ g) b e = pow_sqr_aux g (b * b) (e\/2) :=\nby {dsimp [pow_sqr_aux], rw [bodd_div2_eq, h, (div2_val e)]}\n\nlemma mul_div_cancel_of_even {f : \u2115} (h : bodd f = ff) : 2 * (f\/2) = f :=\nbegin\n  apply nat.mul_div_cancel',\n  apply dvd_of_mod_eq_zero,\n  rw [mod_two_of_bodd, h],\n  refl,\nend\n\nlemma mul_div_cancel_of_odd {f : \u2115} (h : bodd f = tt) : 1 + 2 * (f\/2) = f :=\nbegin\n  have h\u2082 : f % 2 = 1,\n  { rw [mod_two_of_bodd, h], refl, },\n  exact eq.trans (show 1 + 2 * (f\/2) = f % 2 + 2 * (f\/2), by rw h\u2082) (mod_add_div f 2),\nend\n\nlemma proof_aux (g : \u2115) : \u2200 b e : \u2115, 2^g > e \u2192 pow_sqr_aux g b e = pow b e :=\nbegin\n  induction g with k hk,\n  { intros b e h,\n    have h\u2082 : e = 0, linarith,\n    rw [h\u2082, pow_sqr_aux_zero, pow_zero], },\n  { intros b f h,\n    have h\u2082 : 2 ^ k > (f\/2) := nat.div_lt_of_lt_mul (pow_succ 2 k \u25b8 h),\n    specialize hk (b * b) (f\/2) h\u2082,\n    obtain feven | fodd : (bodd f) = ff \u2228 (bodd f) = tt := (bodd f).dichotomy,\n    { rw [even_case feven, hk, \u2190pow_two, \u2190pow_mul, mul_div_cancel_of_even feven], },\n    { rw [odd_case fodd, hk, \u2190pow_two, \u2190pow_mul, \u2190pow_succ, add_comm, mul_div_cancel_of_odd fodd], }, },\nend\n\ntheorem pow_eq (b e : \u2115) :pow_sqr b e = b ^ e :=\nbegin\n  apply proof_aux,\n  exact lt_two_pow e,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208904,"user_id":null,"body":"import Preloaded\nimport tactic tactic.nth_rewrite\n\nopen nat\n\ntheorem strong_pow_eq (d : \u2115) : \u2200 (b e : \u2115), \n            e \u2264 d \u2192 pow_sqr_aux d b e = b ^ e :=\nbegin\n  induction d with d ih, intros b e h, cases h, unfold pow_sqr_aux, trivial,\n  intros b e h, unfold pow_sqr_aux, have : bodd_div2 e = (bodd e, div2 e),\n  {ext, rw bodd, rw div2}, rw this, simp, replace ih := ih (b*b) (div2 e),\n  unfold pow_sqr_aux at ih, rw ih, have bad := bodd_add_div2 e, cases bodd e;\n  { simp at bad \u22a2, nth_rewrite 1 \u2190 bad, try {rw nat.pow_add},\n    rw [nat.pow_mul, nat.pow_two], try {rw nat.pow_one} },\n  rw [\u2190lt_succ_iff, div2_val], refine lt_of_le_of_lt _ (div_lt_self _ \n    (by norm_num: 2>1)), exacts [nat.div_le_div_right h, succ_pos'],\nend\n\ntheorem pow_eq (b e : \u2115) : pow_sqr b e = b ^ e := strong_pow_eq e b e (by trivial)\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208905,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\nlemma eq_div2 (e : \u2115) : e = if (bodd e) then 2*(div2 e) + 1 else 2*div2 e :=\nbegin\n  induction e with e he, refl,\n  by_cases e_odd : bodd e = tt,\n  { conv_lhs {rw he},\n    rw [div2_succ, bodd_succ e, e_odd],\n    change succ (2*div2 e + 1) = 2*succ (div2 e),\n    ring,\n  },\n  { conv_lhs {rw he},\n    simp only [eq_ff_eq_not_eq_tt] at e_odd,\n    rw [div2_succ, bodd_succ e, e_odd],\n    simp,\n  }\nend\n\nlemma div2_le_of_le_succ (a b : \u2115) (h : a \u2264 succ b) : div2 a \u2264 b :=\nbegin\n  rw eq_div2 a at h,\n  cases bodd a,\n  { change 2*div2 a \u2264 succ b at h,\n    omega,\n  },\n  { change 2*div2 a + 1 \u2264 succ b at h,\n    omega,\n  },\nend\n\nlemma pow_eq_aux : \u2200 (gas : \u2115), \u2200 (e \u2264 gas), \u2200 (b : \u2115), pow_sqr_aux gas b e = b^e\n| 0 :=\nbegin\n    intros e he b,\n    rw (show e = 0, from by linarith),\n    refl,\nend\n| (succ gas) :=\nbegin\n  intros e e_le_succ_gas b,\n  change (prod.cases_on (bodd_div2 e) (\u03bb r e', bool.cases_on r \n                                      (pow_sqr_aux gas (b * b) e')\n                                      (b * pow_sqr_aux gas (b * b) e')) : \u2115) = b ^ e,\n  rw (show bodd_div2 e = (bodd e, div2 e), from by ext; refl),\n  have he : e = if (bodd e) then 2*(div2 e) + 1 else 2*(div2 e) := eq_div2 e,\n  have e_div2_le_gas : div2 e \u2264 gas := div2_le_of_le_succ e gas e_le_succ_gas,\n  cases bodd e; dsimp,\n  { conv_rhs {rw (show e = 2*div2 e, from he)},\n    rw [pow_eq_aux gas (div2 e) e_div2_le_gas (b*b), \u2190 nat.pow_two, nat.pow_mul],\n  },\n  { conv_rhs {rw (show e = 2*div2 e + 1, from he)},\n    rw [pow_eq_aux gas (div2 e) e_div2_le_gas (b*b), \u2190 nat.pow_two,\n         \u2190 nat.pow_mul, mul_comm, \u2190 nat.pow_succ],\n  },\nend\n\ntheorem pow_eq (b : \u2115) : \u2200 e, pow_sqr b e = b ^ e :=\n  assume e, pow_eq_aux e e (by linarith) b\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208906,"user_id":null,"body":"import Preloaded\n\nimport tactic\n\nopen nat\n\nlemma pow_aux_eq (b e gas : \u2115) (h : e < 2^gas) : pow_sqr_aux gas b e = b ^ e := begin\n  induction gas with gas IH generalizing b e,\n  { change e < 1 at h,\n    rw (show e = 0, by linarith),\n    refl },\n  { unfold pow_sqr_aux,\n    cases r : bodd_div2 e with odd e',\n    dsimp,\n    have he : e = cond odd 1 0 + 2 * e',\n    { convert \u2190 (bodd_add_div2 e).symm,\n      exact congr_arg prod.fst r,\n      exact congr_arg prod.snd r },\n    cases odd; dsimp,\n    { change pow_sqr_aux _ _ _ = _,\n      have : e = 2 * e', { simp [he] },\n      rw IH,\n      { rw [this, nat.pow_mul, nat.pow_two] },\n      { refine lt_of_mul_lt_mul_left _ (show 0 \u2264 2, by norm_num),\n        rwa [\u2190this, mul_comm, \u2190nat.pow_succ] } },\n    { change b * pow_sqr_aux _ _ _ = _,\n      have : e = 2 * e' + 1, { rw add_comm, simp [he] },\n      rw IH,\n      { rw [mul_comm, this, nat.pow_succ, nat.pow_mul, nat.pow_two] },\n      { refine lt_of_mul_lt_mul_left _ (show 0 \u2264 2, by norm_num),\n        apply lt_trans (show _ < _ + 1, from lt_succ_self _),\n        rwa [\u2190this, mul_comm, \u2190nat.pow_succ] } } }\nend\n\ntheorem pow_eq (b e : \u2115) : pow_sqr b e = b ^ e := begin\n  apply pow_aux_eq,\n  apply lt_pow_self,\n  norm_num\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c8dda57b0a26000015f1a7a":[{"id":208907,"user_id":196,"body":"import Preloaded tactic\n\ntheorem expand (n : \u2115): (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := by ring","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208908,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := by { intro n, ring }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208909,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 :=\nbegin\n  intro n,\n  have A: (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 :=\n    calc\n      (n + 1) ^ 2 = (n + 1) * (n + 1) : by ring\n      ... = n ^ 2 + 2 * n + 1 : by ring,\n  assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208910,"user_id":null,"body":"import Preloaded tactic.ring\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := (\u03bb n, by ring)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208911,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 :=\n\nbegin\nrintro n,\nring,\n\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208912,"user_id":191,"body":"import Preloaded tactic\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 :=\nbegin\n  intro n, \n  rw pow_two,\n  rw pow_two,\n  rw add_mul,\n  rw one_mul,\n  rw mul_add,\n  rw mul_one,\n  rw two_mul,\n  rw \u2190add_assoc,\n  rw \u2190add_assoc,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208913,"user_id":null,"body":"import Preloaded tactic\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := \nbegin\n  intros n,\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208914,"user_id":null,"body":"import Preloaded tactic\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 :=\nbegin\n  intro n,\n  repeat {rw pow_two},\n  rw mul_add,\n  rw add_mul,\n  repeat {rw mul_one},\n  rw one_mul,\n  rw two_mul,\n  repeat {rw add_assoc}\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208915,"user_id":null,"body":"import Preloaded tactic\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := fun n, by ring","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208916,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\ntheorem expand : \u2200 n : \u2115, (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := \nbegin\n  intro h,\n  repeat {rw pow_succ},\n  repeat {rw pow_zero},\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c8f5d3a542ce10001c284c3":[{"id":208917,"user_id":null,"body":"import Preloaded\n\nuniverse u\n\nopen is_magical\n\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f := \n\u27e8 assume a b : \u03b1, calc\n  f a b = f (f (f b a) (f (f b a) a)) b : by rw right hf\n    ... = f (f (f b a) b) b             : by rw left hf\n    ... = f b a                         : by rw left hf \u27e9 \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208918,"user_id":null,"body":"import Preloaded tactic\n\nuniverse u\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f := \n   begin\n    fconstructor,\n    intros x y,\n    calc\n    f x y = f y (f y                         (f x y)) : by { rw (hf.2 (f x y)       y      ) }\n      ... = f y (f (f x             (f x y)) (f x y)) : by { rw (hf.2 y             x      ) }\n      ... = f y (f (f (f y (f y x)) (f x y)) (f x y)) : by { rw (hf.2 x             y      ) }\n      ... = f y       (f y (f y x))                   : by { rw (hf.1 (f y (f y x)) (f x y)) }\n      ... = f y                 x                     : by { rw (hf.2 x             y      ) }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208919,"user_id":null,"body":"import Preloaded tactic\n\nuniverse u\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f := \n  begin\n   fconstructor, intros x y,\n    have hl := hf.left,\n    have hr := hf.right,\n    finish,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208920,"user_id":null,"body":"import Preloaded tactic\n\nuniverse u\n\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f := begin\n    cases hf,\n    constructor,\n    finish,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208921,"user_id":null,"body":"import Preloaded\n\nuniverse u\n\nvariables {\u03b1 : Type u} {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} (hf : is_magical f)\n\nlemma s {x y z : \u03b1} (h : f x y = z) : f x z = y := h \u25b8 hf.right y x\nlemma t {x y z : \u03b1} (h : f x y = z) : f z y = x := h \u25b8 hf.left x y\n\ntheorem magic_is_comm : is_commutative \u03b1 f :=\n\u27e8\u03bb x y, s hf $ t hf $ s hf rfl\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208922,"user_id":null,"body":"  import Preloaded\n\n  universe u\n  theorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n    is_commutative \u03b1 f :=\n  \u27e8\u03bb a b, by { conv {\n    to_lhs, congr,\n    rw \u2190hf.right a b, skip,\n    rw \u2190hf.left b (f b a),\n  }, rw hf.right }\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208923,"user_id":null,"body":"import Preloaded\n\nuniverse u\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f :=\nbegin\n  split,\n  intros x y,\n  calc  f x y = f y (f y (f x y)) : by rw hf.right (f x y) y\n        ...   = f y (f (f x (f x y)) (f x y)) : by rw hf.right y x\n        ...   = f y x : by rw hf.left,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208924,"user_id":null,"body":"import Preloaded\nimport tactic\n\nuniverse u\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f :=\nbegin\n  cases hf with hl hr,\n  split,\n  intros x y,\n  finish\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208925,"user_id":null,"body":"import Preloaded\n\nuniverse u\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f :=\nbegin\n  apply is_commutative.mk,\n  intros x y,\n  calc f x y = f x (f (f y (f y x)) (f y x)) : by rw hf.left y (f y x)\n    ...      = f x (f x (f y x))             : by rw hf.right x y\n    ...      = f y x                         : by exact hf.right (f y x) x,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208926,"user_id":null,"body":"import Preloaded\n\nuniverse u\ntheorem magic_is_comm {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (hf : is_magical f) :\n  is_commutative \u03b1 f := is_commutative.mk (begin\n  intros x y,\n  calc f x y = f (f (f y x) (f (f y x) x)) y : by rw hf.right\n       ...   = f (f (f y x) y) y : by rw hf.left\n       ...   = f y x : by rw hf.left\nend)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5c930224c4661143a6666add":[{"id":208927,"user_id":null,"body":"import Preloaded tactic\n\nlemma row_nonzero (m : SL\u2082\u2115) : (eval m).a + (eval m).b > 0 \u2227 \n                                (eval m).c + (eval m).d > 0 :=\n  by induction m; {rw eval, split; linarith}\n\nlemma extn (n : mat) : n = \u27e8n.a,n.b,n.c,n.d\u27e9 := by {destruct n, intros, rw a_1}\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n :=\nbegin\n  revert n, induction m with m ih m ih;\n  {intros n hmn, cases n; {simp [eval] at hmn,\n    try {have := row_nonzero n}, try {{exfalso, linarith} <|>\n      {congr' 1, apply ih, rw [extn (eval m), extn (eval n)], finish}}}},\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208928,"user_id":644,"body":"import Preloaded tactic\n\nopen SL\u2082\u2115\n\ninstance : decidable_eq mat := by tactic.mk_dec_eq_instance\n\ndefinition mat_to_SL\u2082\u2115 : \u03a0 (m : mat), SL\u2082\u2115 \n| m := \nif hacbm : m.3 \u2264 m.1 \u2227 m.4 \u2264 m.2 \u2227 0 < m.3 + m.4\nthen \ntop (mat_to_SL\u2082\u2115 \u27e8m.1 - m.3, m.2 - m.4, m.3, m.4\u27e9)\nelse if hcadm : m.1 \u2264 m.3 \u2227 m.2 \u2264 m.4 \u2227 0 < m.1 + m.2\nthen\nbot (mat_to_SL\u2082\u2115 \u27e8m.1, m.2, m.3 - m.1, m.4 - m.2\u27e9)\nelse I\nusing_well_founded \n{ rel_tac := \u03bb _ _, `[exact \u27e8_, measure_wf (\u03bb m, m.1 + m.2 + m.3 + m.4)\u27e9],\n  dec_tac := `[show _ + _ < _, by omega] }\n\ntheorem eval_pos\u2081 (m : SL\u2082\u2115) : 0 < (eval m).1 + (eval m).2 :=\nby induction m; dsimp [eval]; omega\n\ntheorem eval_pos\u2082 (m : SL\u2082\u2115) : 0 < (eval m).3 + (eval m).4 :=\nby induction m; dsimp [eval]; omega\n\ntheorem eval_d_ne_zero (m : SL\u2082\u2115) : (eval m).d \u2260 0 :=\nby induction m; dsimp [eval]; omega\n\ntheorem mat_to_SL\u2082\u2115_eval (m : SL\u2082\u2115) : \n  (mat_to_SL\u2082\u2115 (eval m)) = m :=\nbegin\n  induction m with m ih m ih,\n  { refl },\n  { rw [mat_to_SL\u2082\u2115, eval],\n    simp [eval_pos\u2082],\n    convert ih,\n    cases (eval m),\n    refl },\n  { rw [mat_to_SL\u2082\u2115, eval],\n    simp [eval_pos\u2081, eval_d_ne_zero],\n    convert ih,\n    cases (eval m),\n    refl }\nend\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n := \nfunction.injective_of_has_left_inverse \u27e8_, mat_to_SL\u2082\u2115_eval\u27e9 hmn\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208929,"user_id":null,"body":"import Preloaded tactic\n\n\ndef f\u2081 : mat \u2192 \u2115 := \u03bb m, m.a+m.b \ndef f\u2082 : mat \u2192 \u2115 := \u03bb m, m.c+m.d\n\nlemma f1nonzero (m:SL\u2082\u2115) : f\u2081(eval m) >0:=\nbegin\n  induction m with m hm,\n  { simp [eval, f\u2081]},\n  {\n    simp [eval, f\u2081] at *,\n    linarith,\n  },\n  {\n    simp [eval,f\u2081] at *,\n    linarith,\n  }\nend\n\nlemma f2nonzero (m:SL\u2082\u2115) : f\u2082(eval m) >0:=\nbegin\n  induction m with m hm,\n  { simp [eval, f\u2082]},\n  {\n    simp [eval, f\u2082] at *,\n    linarith,\n  },\n  {\n    simp [eval,f\u2082] at *,\n    linarith,\n  }\nend\n\nlemma top_inj (m n:SL\u2082\u2115) (h : eval( m.top) =eval( n.top)):\n  eval m = eval n :=\nbegin\n  have : \u2203 evalm , eval m =evalm:= by use eval m,\n  have that : \u2203 evaln , eval n =evaln:= by use eval n,\n  simp only [eval] at h,\n  rcases h with \u27e8 ha,hb,hc,hd\u27e9,\n  simp only [hc, add_left_inj] at ha,\n  simp only [hd, add_left_inj] at hb,\n  cases this with evalm hh,\n  cases that with evaln hhh,\n  rw [hh,hhh] at *,\n  cases evalm with a b c d,\n  cases evaln with a' b' c' d',\n  simp only at ha hb hc hd,\n  rw [ha,hb,hc,hd],\nend\n\nlemma bot_inj (m n:SL\u2082\u2115) (h : eval( m.bot) =eval( n.bot)):\n  eval m = eval n :=\nbegin\n  have : \u2203 evalm , eval m =evalm:= by use eval m,\n  have that : \u2203 evaln , eval n =evaln:= by use eval n,\n  simp only [eval] at h,\n  rcases h with \u27e8 ha,hb,hc,hd\u27e9,\n  simp only [ha, add_right_inj] at hc,\n  simp only [hb, add_right_inj] at hd,\n  cases this with evalm hh,\n  cases that with evaln hhh,\n  rw [hh,hhh] at *,\n  cases evalm with a b c d,\n  cases evaln with a' b' c' d',\n  simp only at ha hb hc hd,\n  rw [ha,hb,hc,hd],\nend\n\nlemma A (m : SL\u2082\u2115) : f\u2081 (eval m.top) > f\u2082(eval m.top) :=\nbegin\n  simp [f\u2081,f\u2082,eval],\n  have : (eval m).a + (eval m).b >0 := f1nonzero m,\n  linarith,\nend\n\nlemma B (m : SL\u2082\u2115) : f\u2081 (eval m.bot) < f\u2082(eval m.bot) :=\nbegin\n  simp [f\u2081,f\u2082,eval],\n  have : (eval m).c + (eval m).d >0 := f2nonzero m,\n  linarith,\nend\n\nlemma C : f\u2081 (eval SL\u2082\u2115.I) = f\u2082(eval SL\u2082\u2115.I) := rfl\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n :=\nbegin\n  suffices : \u2200 n, eval m = eval n \u2192 m = n,\n  {\n    exact this _ hmn,\n  },\n  clear hmn n,\n  induction m with m hm m hm,\n  {\n    intros n hn,\n    cases n,\n    { refl},\n    {\n      have h1:f\u2081 (eval n.top) = f\u2082(eval n.top),\n      { rw \u2190 hn, refl},\n      have h2:= A n,\n      rw h1 at h2,\n      simp only [gt_iff_lt, lt_self_iff_false] at h2,\n      cases h2,\n    },\n    {\n      have h1:f\u2081 (eval n.bot) = f\u2082(eval n.bot),\n      { rw \u2190 hn, refl},\n      have h2:= B n,\n      rw h1 at h2,\n      simp only [gt_iff_lt, lt_self_iff_false] at h2,\n      cases h2,\n    }\n  },\n  {\n    intros n hn,\n    have := A m,\n    rw hn at this,\n    cases n,\n    {\n      exfalso,\n      linarith only [this,C],\n    },\n    {\n      rw hm n (top_inj _ _ hn),\n    },\n    {\n      exfalso,\n      linarith only [this,B n],\n    },    \n  },\n  {\n    intros n hn,\n    have := B m,\n    rw hn at this,\n    cases n,\n    {\n      exfalso,\n      linarith only [this,C],\n    },\n    {\n      exfalso,\n      linarith only [this,A n],\n    },\n    {\n      rw hm n (bot_inj _ _ hn),\n    }\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208930,"user_id":null,"body":"import Preloaded data.polynomial\n\nlemma d_neq_zero (m : SL\u2082\u2115) : (eval m).d \u2260 0 :=\nbegin\n  induction m,\n  { simp [eval], },\n  { simpa, },\n  { simp only [eval, ne.def, add_eq_zero_iff, not_and'], \n    intro h, \n    contradiction, },\nend\n\nlemma mat_def (M : mat) : M = { a := M.a, b := M.b, c := M.c, d := M.d } :=\nbegin\n  apply mat.cases_on M,\n  simp,\nend\n\nlemma top_of_eq_top {m n : SL\u2082\u2115} (hmn : eval m = eval n.top) : \u2203 (x : SL\u2082\u2115), m = x.top := \nbegin\n  cases m with y z,\n  { have : (eval SL\u2082\u2115.I).b \u2265 (eval SL\u2082\u2115.I).d, by { rw hmn, unfold eval, simp, },\n    simpa [eval, ge_iff_le, le_zero_iff, nat.one_ne_zero], },\n  { use y, },\n  { have : (eval z.bot).b \u2265 (eval z.bot).d, by { rw hmn, unfold eval, simp, }, \n    simpa [eval, d_neq_zero z], },\nend\n\nlemma bot_of_eq_bot {m n : SL\u2082\u2115} (hmn : eval m = eval n.bot) : \u2203 (x : SL\u2082\u2115), m = x.bot := \nbegin\n  cases m with z y,\n  { have : (eval SL\u2082\u2115.I).c \u2265 (eval SL\u2082\u2115.I).a, by { rw hmn, unfold eval, simp, },\n    simpa [eval, ge_iff_le, le_zero_iff, nat.one_ne_zero], },\n  { cases top_of_eq_top hmn.symm, contradiction, },\n  { use y, },\nend\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n := \nbegin\n  induction n with x hx x hx generalizing m;\n  cases m with y y,\n  { refl, }, \n  repeat { injection hmn,\n           suffices : eval y = eval x, by { exact congr_arg _ ((hx y) this), },\n           rw [mat_def (eval x), mat_def (eval y), mat.mk.inj_eq],\n           repeat { try {split}, linarith, }, },\n  { cases top_of_eq_top   hmn.symm, contradiction, },\n  { cases bot_of_eq_bot   hmn.symm, contradiction, },\n  repeat { cases top_of_eq_top hmn, contradiction, },\n  repeat { cases bot_of_eq_bot hmn, contradiction, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208931,"user_id":null,"body":"import Preloaded tactic\n\ndef depth : SL\u2082\u2115 \u2192 \u2115\n| SL\u2082\u2115.I := 0\n| (SL\u2082\u2115.top m) := (depth m) + 1\n| (SL\u2082\u2115.bot m) := (depth m) + 1\n\nlemma tree_induction : \u2200(C :SL\u2082\u2115 \u2192 SL\u2082\u2115 \u2192 Prop), (C SL\u2082\u2115.I SL\u2082\u2115.I) \n\u2192 (\u2200n:\u2115,((\u2200(a b:SL\u2082\u2115),depth a \u2264 n \u2192depth b \u2264 n\u2192 C a b)\n  \u2192(\u2200(a b:SL\u2082\u2115),depth a \u2264n+1\u2192depth b \u2264n+1 \u2192 C a b)))\n\u2192\u2200(n:\u2115)(a b :SL\u2082\u2115),depth a\u2264n \u2192 depth b \u2264 n \u2192 C a b:=by{\n  intros C C0 h0 n,\n  have h1:\u2200 (a b : SL\u2082\u2115), depth a \u2264 0 \u2192 depth b \u2264 0 \u2192 C a b,{\n    intros a b h0 h1,\n    cases a,{\n      cases b,{\n        assumption,\n      },\n      all_goals{\n        unfold depth at h1,\n        finish,\n      },\n    },\n    all_goals{\n      unfold depth at h0,\n      finish,\n    },\n  },\n  exact nat.rec_on n h1 h0,\n}\nlemma eval_not_eq_I_top (a:SL\u2082\u2115): eval SL\u2082\u2115.I \u2260 eval a.top:=by{\n  by_contra,\n  injections_and_clear,\n  rw \u2190h_4 at h_2,\n  tauto,\n} \nlemma eval_not_eq_I_bot (a:SL\u2082\u2115): eval SL\u2082\u2115.I \u2260 eval a.bot:=by{\n  by_contra,\n  injections_and_clear,\n  rw \u2190h_1 at h_3,\n  linarith,\n} \nlemma eval_top_not_eq_if_eval_not_eq (a b:SL\u2082\u2115): eval a \u2260eval b\u2192 eval a.top\u2260 eval b.top:=by{\n  intro h0,\n  by_contra,\n  unfold eval at h,\n  injections_and_clear,\n  rw h_3 at h_1,\n  rw h_4 at h_2,\n  simp at *,\n  have h1:(eval a)=(eval b),{\n    generalize'  h1:(eval a)=x,\n    rw h1 at h_1 h_2 h_3 h_4,\n    generalize' h2:(eval b)=y,\n    rw h2 at h_1 h_2 h_3 h_4,\n    clear_except h_1 h_2 h_3 h_4,\n    cases x,\n    cases y,\n    congr',\n  },\n  finish,\n}\nlemma eval_bot_not_eq_if_eval_not_eq (a b:SL\u2082\u2115): eval a \u2260eval b\u2192 eval a.bot\u2260 eval b.bot:=by{\n  intro h0,\n  by_contra,\n  unfold eval at h,\n  injections_and_clear,\n  rw h_1 at h_3,\n  rw h_2 at h_4,\n  simp at *,\n  have h1:(eval a)=(eval b),{\n    cases (eval a),\n    cases (eval b),\n    congr',\n  },\n  finish,\n}\nlemma eval_a_ne_zero:\u2200(m:SL\u2082\u2115),(eval m).a\u22600:=by{\n  intro m,\n  induction m with m hm,{\n    finish,\n  },{\n    unfold eval,\n    dsimp,\n    by_contra,\n    finish,\n  },{\n    unfold eval,\n    dsimp,\n    by_contra,\n    finish,\n  }\n}\nlemma eval_bot_top_not_eq_if_eval_not_eq (a b:SL\u2082\u2115): eval a \u2260eval b\u2192 eval a.top\u2260 eval b.bot:=by{\n  intro h0,\n  by_contra,\n  unfold eval at h,\n  injections_and_clear,\n  rw \u2190h_1 at h_3,\n  rw \u2190h_2 at h_4,\n  rw [add_assoc] at h_3,\n  rw [add_comm (eval a).c _] at h_3,\n  rw [\u2190add_assoc] at h_3,\n  have h1:(eval a).a + (eval b).c =0,omega,\n  have h2:(eval a).a =0,omega,\n  have h3:(eval b).c =0,omega,\n  clear h_3 h1,\n  have h6:=eval_a_ne_zero a,\n  finish,\n}\nlemma eval_top_bot_not_eq (a:SL\u2082\u2115):eval a.top \u2260 eval a.bot:=by{\n  by_contra,\n  unfold eval at h,\n  injections_and_clear,\n  simp at *,\n  have h1:=eval_a_ne_zero a,\n  finish,\n}\nlemma eval_top_bot_not_eq_of_eval_not_eq (a b:SL\u2082\u2115):eval a \u2260 eval b\u2192eval a.top\u2260eval b.bot:=by{\n  intro h,\n  have h1:eval b \u2260 eval a,finish,\n  exact eval_bot_top_not_eq_if_eval_not_eq a b h,\n}\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n := by{\n  revert hmn,\n  have h0:\u2200n:\u2115,((\u2200(a b:SL\u2082\u2115),depth a \u2264 n \u2192depth b \u2264 n\u2192 (eval a=eval b)\u2192a=b)\n  \u2192(\u2200(a b:SL\u2082\u2115),depth a \u2264n+1\u2192depth b \u2264n+1 \u2192 (eval a=eval b)\u2192a=b)),{\n    intros n h0 a b h1 h2 h3,\n    cases a;cases b,{\n      refl,\n    },{\n      have h4:=eval_not_eq_I_top b,\n      finish,\n    },{\n      have h4:=eval_not_eq_I_bot b,\n      finish,\n    },{\n      have h4:=eval_not_eq_I_top a,\n      finish,\n    },{\n      by_cases h4:(eval a=eval b),{\n        unfold depth at h1 h2,\n        have h5:depth a\u2264n,omega,\n        have h6:depth b\u2264n,omega,\n        have h7:=h0 a b h5 h6 h4,\n        finish,\n      },{\n        have h5:=eval_top_not_eq_if_eval_not_eq a b h4,\n        finish,\n      },\n    },{\n      by_cases h4:(eval a =eval b),{\n        unfold depth at h1 h2,\n        have h5:depth a\u2264n,omega,\n        have h6:depth b\u2264n,omega,\n        have h7:=h0 a b h5 h6 h4,\n        rw h7  at h3,\n        have h8:=eval_top_bot_not_eq b,\n        finish,\n      },{\n        have h5:=eval_top_bot_not_eq_of_eval_not_eq a b h4,\n        finish,\n      },\n    },{\n      have h4:=eval_not_eq_I_bot a,\n      finish,\n    },{\n      by_cases h4:(eval a =eval b),{\n        unfold depth at h1 h2,\n        have h5:depth a\u2264n,omega,\n        have h6:depth b\u2264n,omega,\n        have h7:=h0 a b h5 h6 h4,\n        rw h7  at h3,\n        have h8:=eval_top_bot_not_eq b,\n        finish,\n      },{\n        have h6:eval b\u2260eval a,exact ne.symm h4,\n        have h5:=eval_top_bot_not_eq_of_eval_not_eq b a h6,\n        finish,\n      },\n    },{\n      by_cases h4:(eval a=eval b),{\n        unfold depth at h1 h2,\n        have h5:depth a\u2264n,omega,\n        have h6:depth b\u2264n,omega,\n        have h7:=h0 a b h5 h6 h4,\n        finish,\n      },{\n        have h5:=eval_bot_not_eq_if_eval_not_eq a b h4,\n        finish,\n      },\n    }\n  },\n  have h1:(eval SL\u2082\u2115.I=eval SL\u2082\u2115.I)\u2192SL\u2082\u2115.I=SL\u2082\u2115.I,{\n    intro sdf,\n    refl,\n  },\n  intro h2,\n  have h3:depth n\u2264depth m + depth n,omega,\n  have h4:depth m\u2264depth m +depth n ,omega,\n  exact tree_induction (\u03bba b,(eval a=eval b)\u2192a=b) h1 h0 (depth m+depth n) m n\n  h4 h3 h2,\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208932,"user_id":null,"body":"import Preloaded \nimport tactic tactic.induction\n\nlemma mpos (m : SL\u2082\u2115) : (eval m).a + (eval m).b > 0 :=\nbegin\n  induction' m;\n  simp [eval] at *;\n  linarith,\nend\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n := \nbegin\n  induction' m;\n  cases' n;\n  simp [eval] at *;\n  have h1:=hmn.1;\n  have h2:=hmn.2.1;\n  have h3:=hmn.2.2.1;\n  have h4:=hmn.2.2.2;\n  try { linarith },\n  any_goals {\n    apply ih,\n    cases (eval m),\n    cases (eval n),\n    simp at *,\n    try { use [(by linarith), (by linarith), h3, h4] },\n    try { use [h1, h2, (by linarith), (by linarith)] } },\n  { have hx : (eval m).a + (eval m).b = 0 := by linarith,\n    exact ne_of_gt (mpos m) hx },\n  { have hx : (eval n).a + (eval n).b = 0 := by linarith,\n    exact ne_of_gt (mpos n) hx },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208933,"user_id":168,"body":"import Preloaded tactic\n\nlemma a_eval_ne_0 (m : SL\u2082\u2115) : (eval m).a \u2260 0 :=\nby induction m with m ih; simp only [eval]; omega\n\nlemma eval_top_ne_eval_bot (m n : SL\u2082\u2115) : eval m.top \u2260 eval n.bot :=\nbegin\n  have := a_eval_ne_0 m, \n  simp only [eval], cases eval m, cases eval n, simp at *, omega\nend\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n :=\nbegin\n  induction m with m ih m ih generalizing n; cases n with n n;\n  try { simp only [eval] at hmn, omega };\n  try { congr, apply ih, simp only [eval] at hmn,\n        cases eval m, cases eval n,\n        simp at *, omega },\n  { refl },\n  { have := eval_top_ne_eval_bot m n, contradiction },\n  { have := eval_top_ne_eval_bot n m, \n    symmetry' at this, contradiction }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208934,"user_id":null,"body":"import Preloaded tactic\n\nopen SL\u2082\u2115\n\nlemma not_eval_top_eq_bot {m n : SL\u2082\u2115} (h : eval m.top = eval n.bot) : false :=\nby { simp [eval] at h, have h\u2082 : (eval m).a= 0, omega, clear h n, revert h\u2082, change ( (eval m).a \u2260 0),\nrw \u2190(nat.pos_iff_ne_zero), induction m, omega , all_goals { rw eval, linarith, } }\n\ntheorem eval_injective : \u2200 (m n : SL\u2082\u2115) (hmn : eval m = eval n), m = n\n| I n := \u03bb h, by { cases n, refl, any_goals { exfalso, simp [eval] at h, linarith } }\n| n I := \u03bb h, by { cases n, refl, any_goals { exfalso, simp [eval] at h, linarith } }\n| (top m) (top n) := \u03bb h, by { have k := eval_injective m n, rw k, simp [eval] at *, cases (eval m), cases (eval n), omega }\n| (top m) (bot n) := \u03bb h, false.elim $ not_eval_top_eq_bot h\n| (bot m) (top n) := \u03bb h, false.elim $ not_eval_top_eq_bot h.symm\n| (bot m) (bot n) := \u03bb h, by { have k := eval_injective m n, rw k, simp [eval] at *, cases (eval m), cases (eval n), omega }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208935,"user_id":null,"body":"import Preloaded\n\nopen nat\n\nlemma eval_top_neq_eval_id (m : SL\u2082\u2115) : eval m.top \u2260 eval SL\u2082\u2115.I :=\n\u03bb h, nat.zero_ne_one (eq.trans (eq.symm (nat.eq_zero_of_add_eq_zero (congr_arg mat.b h)).right) (congr_arg mat.d h))\n\nlemma eval_bot_neq_eval_id (m : SL\u2082\u2115) : eval m.bot \u2260 eval SL\u2082\u2115.I :=\n\u03bb h, nat.zero_ne_one (eq.trans (eq.symm (nat.eq_zero_of_add_eq_zero (congr_arg mat.c h)).left) (congr_arg mat.a h))\n\nlemma mat_eq_struct (m : SL\u2082\u2115) : eval m = { mat . \n    a := (eval m).a,\n    b := (eval m).b,\n    c := (eval m).c,\n    d := (eval m).d } := by {cases (eval m), dsimp, refl}\n\nlemma mat_eq {m n : SL\u2082\u2115} : (eval m).a = (eval n).a \u2227 (eval m).b = (eval n).b \u2227 (eval m).c = (eval n).c \u2227 (eval m).d = (eval n).d \u2192 eval m = eval n :=\n\u03bb \u27e8h_a, h_b, h_c, h_d\u27e9,\nbegin\n  have h := mat_eq_struct m,\n  exact eq.trans (by rwa [h_a, h_b, h_c, h_d] at h) (eq.symm (mat_eq_struct n)),\nend\n\nlemma eval_top {m n : SL\u2082\u2115} (h : eval m.top = eval n.top) : eval m = eval n :=\nbegin\n  have h_c : (eval m).c = (eval n).c,\n    calc\n      (eval m).c = (eval m.top).c : rfl\n      ... = (eval n.top).c        : congr_arg mat.c h,\n  have h_d : (eval m).d = (eval n).d,\n    calc\n      (eval m).d = (eval m.top).d : rfl\n      ... = (eval n.top).d        : congr_arg mat.d h,\n  have hm\u2081 : (eval m).a + (eval m).c = (eval m.top).a := rfl,\n  have hn\u2081 : (eval n.top).a = (eval n).a + (eval n).c := rfl,\n  have h_a : (eval m).a = (eval n).a, \n    calc\n      (eval m).a = (eval m).a + (eval m).c - (eval m).c : (eq.symm (nat.add_sub_cancel _ _))\n      ... = (eval n).a                                  : by rw [hm\u2081, congr_arg mat.a h, h_c, hn\u2081, nat.add_sub_cancel],\n  have hm\u2082 : (eval m).b + (eval m).d = (eval m.top).b := rfl,\n  have hn\u2082 : (eval n.top).b = (eval n).b + (eval n).d := rfl,\n  have h_b : (eval m).b = (eval n).b, \n    calc\n        (eval m).b = (eval m).b + (eval m).d - (eval m).d : (eq.symm (nat.add_sub_cancel _ _))\n        ... = (eval n).b                                  : by rw [hm\u2082, congr_arg mat.b h, h_d, hn\u2082, nat.add_sub_cancel],\n  exact mat_eq \u27e8h_a, h_b, h_c, h_d\u27e9,\nend\n\nlemma eval_bot {m n : SL\u2082\u2115} (h : eval m.bot = eval n.bot) : eval m = eval n :=\nbegin\n  have h_a : (eval m).a = (eval n).a, \n    calc \n      (eval m).a = (eval m.bot).a : rfl\n      ... = (eval n.bot).a        : congr_arg mat.a h,\n  have h_b : (eval m).b = (eval n).b,\n    calc \n        (eval m).b = (eval m.bot).b : rfl\n        ... = (eval n.bot).b        : congr_arg mat.b h,\n  have hm\u2081 : (eval m).a + (eval m).c = (eval m.bot).c := rfl,\n  have hn\u2081 : (eval n.bot).c = (eval n).a + (eval n).c := rfl,\n  have h_c : (eval m).c = (eval n).c, \n    calc\n      (eval m).c = (eval m).a + (eval m).c - (eval m).a : by rw [nat.add_comm, nat.add_sub_cancel]\n      ... = (eval n).c                                  : by rw [hm\u2081, congr_arg mat.c h, h_a, hn\u2081,nat.add_comm, nat.add_sub_cancel],\n  have hm\u2082 : (eval m).b + (eval m).d = (eval m.bot).d := rfl,\n  have hn\u2082 : (eval n.bot).d = (eval n).b + (eval n).d := rfl,\n  have h_d : (eval m).d = (eval n).d,\n    calc\n      (eval m).d = (eval m).b + (eval m).d - (eval m).b : by rw [nat.add_comm, nat.add_sub_cancel]\n      ... = (eval n).d                                  : by rw [hm\u2082, congr_arg mat.d h, h_b, hn\u2082, nat.add_comm, nat.add_sub_cancel],\n  exact mat_eq \u27e8h_a, h_b, h_c, h_d\u27e9,\nend\n\ndef det : SL\u2082\u2115 \u2192 \u2115 := \u03bb m, (eval m).a * (eval m).d - (eval m).b * (eval m).c\n\nlemma special_means_det_one (m : SL\u2082\u2115) : det m = 1 :=\nbegin\n  induction m with n htop n hbot,\n  refl,\n  calc\n    det n.top = ((eval n).a + (eval n).c) * (eval n).d - ((eval n).b + (eval n).d) * (eval n).c : rfl\n    ... = det n : by rw [nat.mul_comm _ (eval n).c, nat.mul_comm, nat.left_distrib, nat.left_distrib, nat.add_comm ((eval n).c * (eval n).b) _, \u2190nat.sub_sub _ _ _, nat.mul_comm, nat.mul_comm (eval n).d (eval n).c, nat.add_sub_cancel, nat.mul_comm (eval n).c _] ; refl\n    ... = 1     : htop,\n  calc\n    det n.bot = (eval n).a * ((eval n).b + (eval n).d) - (eval n).b * ((eval n).a + (eval n).c) : rfl\n    ... = det n : by rw [nat.left_distrib, nat.add_comm, nat.mul_comm _ (eval n).b, nat.left_distrib, \u2190nat.sub_sub _ _ _, nat.add_sub_cancel] ; refl\n    ... = 1     : hbot,\nend\n\nlemma add_right_eq_cancel {a b : \u2115} (h : a + b = b) : a = 0 :=\nbegin\n  rwa [\u2190nat.zero_add b, \u2190nat.add_assoc, nat.add_zero a] at h,\n  exact nat.add_right_cancel h,\nend\n\nlemma det_zero_of_top_eq_bot {m n : SL\u2082\u2115} (h : eval m.top = eval n.bot) : det m = 0 \u2227 det n = 0 :=\nbegin\n  have h\u2080 : (eval m).a + (eval m).c = (eval n).a,\n    calc\n      (eval m).a + (eval m).c = (eval m.top).a : rfl\n      ... = (eval n.bot).a                     : congr_arg mat.a h\n      ... = (eval n).a                         : rfl,\n  have h\u2081 : (eval m).c = (eval n).a + (eval n).c,\n    calc\n      (eval m).c = (eval m.top).c   : rfl\n      ... = (eval n.bot).c          : congr_arg mat.c h\n      ... = (eval n).a + (eval n).c : rfl,\n  rw [\u2190h\u2080, nat.add_right_comm] at h\u2081,\n  have h\u2082 : (eval m).a + (eval n).c = 0 := add_right_eq_cancel (eq.symm h\u2081),\n  have h\u2083 : (eval m).b + (eval m).d = (eval n).b,\n  calc\n    (eval m).b + (eval m).d = (eval m.top).b : rfl\n    ... = (eval n.bot).b                     : congr_arg mat.b h \n    ... = (eval n).b                         : rfl,\n  have h\u2084 : (eval m).d = (eval n).b + (eval n).d,\n  calc\n    (eval m).d = (eval m.top).d              : rfl\n    ... = (eval n.bot).d                     : congr_arg mat.d h\n    ... = (eval n).b + (eval n).d            : rfl,\n  rw [\u2190h\u2083,nat.add_right_comm] at h\u2084,\n  have h\u2085 : (eval m).b + (eval n).d = 0 := add_right_eq_cancel h\u2084.symm,\n  unfold det,\n  simp [nat.eq_zero_of_add_eq_zero h\u2082, nat.eq_zero_of_add_eq_zero h\u2085, nat.zero_mul, nat.mul_zero],\nend\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n := \nbegin\n  induction m with p\u2081 hp\u2081 p\u2082 hp\u2082 generalizing n,\n  {\n    induction n with q\u2081 hq\u2081 q\u2082 hq\u2082,\n    { refl },\n    { exfalso, exact eval_top_neq_eval_id q\u2081 (eq.symm hmn) },\n    { exfalso, exact eval_bot_neq_eval_id q\u2082 (eq.symm hmn) },\n  },\n  {\n    induction n with q\u2081 hq\u2081 q\u2082 hq\u2082,\n    { exfalso, exact eval_top_neq_eval_id p\u2081 hmn },\n    { congr, exact hp\u2081 q\u2081 (eval_top hmn) },\n    {\n      have h\u2080 : det p\u2081 = 0 := (det_zero_of_top_eq_bot hmn).left,\n      have h\u2081 : det p\u2081 = 1 := special_means_det_one p\u2081,\n      rw h\u2080 at h\u2081, exfalso, exact nat.zero_ne_one h\u2081, \n    },\n  },\n  {\n    induction n with q\u2081 hq\u2081 q\u2082 hq\u2082,\n    { exfalso, exact eval_bot_neq_eval_id p\u2082 hmn },\n    {\n      have h\u2080 : det p\u2082 = 0 := (det_zero_of_top_eq_bot (eq.symm hmn)).right,\n      have h\u2081 : det p\u2082 = 1 := special_means_det_one p\u2082,\n      rw h\u2080 at h\u2081, exfalso, exact nat.zero_ne_one h\u2081, \n    },\n    { congr, exact hp\u2082 q\u2082 (eval_bot hmn) }\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208936,"user_id":null,"body":"import Preloaded tactic\n\nopen SL\u2082\u2115\n\n@[ext] lemma mat_ext {m n : mat} (ha : m.a = n.a) (hb : m.b = n.b) (hc : m.c = n.c)\n    (hd : m.d = n.d) : m = n := by cases m; cases n; omega\n\ndef top_sum (m : mat) : \u2115 := m.a + m.b\ndef bot_sum (m : mat) : \u2115 := m.c + m.d\n\nlemma top_sum_pos (m : SL\u2082\u2115) : top_sum (eval m) > 0 :=\nbegin\n    induction m;\n    dsimp [top_sum, bot_sum, eval] at *;\n    linarith,\nend\n\nlemma bot_sum_pos (m : SL\u2082\u2115) : bot_sum (eval m) > 0 :=\nbegin\n    induction m;\n    dsimp [top_sum, bot_sum, eval] at *;\n    linarith,\nend\n\nlemma top_sum_gt_bot_sum_of_top (m : SL\u2082\u2115) : top_sum (eval (top m)) > bot_sum (eval (top m)) :=\nbegin\n    have := top_sum_pos m,\n    dsimp [top_sum, bot_sum, eval] at *,\n    linarith,\nend\n\nlemma bot_sum_gt_top_sum_of_bot (m : SL\u2082\u2115) : bot_sum (eval (bot m)) > top_sum (eval (bot m)) :=\nbegin\n    have := bot_sum_pos m,\n    dsimp [top_sum, bot_sum, eval] at *,\n    linarith,\nend\n\nlemma bot_sum_eq_top_sum_of_I : bot_sum (eval I) = top_sum (eval I) :=\n    by simp [top_sum, bot_sum, eval]\n\nlemma top_of_top_sum_gt_bot_sum {m : SL\u2082\u2115} (h : top_sum (eval m) > bot_sum (eval m)) :\n    \u2203 m', m = top m' :=\nbegin\n    cases m with m,\n        linarith [bot_sum_eq_top_sum_of_I],\n        tauto,\n        linarith [bot_sum_gt_top_sum_of_bot m],\nend\n\nlemma bot_of_bot_sum_gt_top_sum {m : SL\u2082\u2115} (h : bot_sum (eval m) > top_sum (eval m)) :\n    \u2203 m', m = bot m' :=\nbegin\n    cases m with m,\n        linarith [bot_sum_eq_top_sum_of_I],\n        linarith [top_sum_gt_bot_sum_of_top m],\n        tauto,\nend\n\nlemma I_of_top_sum_eq_bot_sum {m : SL\u2082\u2115} (h : top_sum (eval m) = bot_sum (eval m)) :\n    I = m :=\nbegin\n    cases m with m,\n        refl,\n        exfalso, linarith [top_sum_gt_bot_sum_of_top m],\n        exfalso, linarith [bot_sum_gt_top_sum_of_bot m],\nend\n\nlemma top_eval_eq_iff_eval_eq {m n : SL\u2082\u2115} (hmn : eval (top m) = eval (top n)) : eval m = eval n :=\nbegin\n    simp only [eval] at hmn,\n    ext;\n    linarith,\nend\n\nlemma bot_eval_eq_iff_eval_eq {m n : SL\u2082\u2115} (hmn : eval (bot m) = eval (bot n)) : eval m = eval n :=\nbegin\n    simp only [eval] at hmn,\n    ext;\n    linarith,\nend\n\ntheorem eval_injective (m n : SL\u2082\u2115) (hmn : eval m = eval n) : m = n :=\nbegin\n    induction m with m hm m hm generalizing n,\n    {   apply I_of_top_sum_eq_bot_sum,\n        rw \u2190 hmn,\n        exact bot_sum_eq_top_sum_of_I,\n    },\n    {   have top_sum_m := top_sum_gt_bot_sum_of_top m,\n        rw hmn at top_sum_m,\n        rcases top_of_top_sum_gt_bot_sum top_sum_m with \u27e8n', hn'\u27e9,\n        rw hn' at hmn,\n        replace hmn := top_eval_eq_iff_eval_eq hmn,\n        rw hm n' hmn,\n        tauto,\n    },\n    {   have bot_sum_m := bot_sum_gt_top_sum_of_bot m,\n        rw hmn at bot_sum_m,\n        rcases bot_of_bot_sum_gt_top_sum bot_sum_m with \u27e8n', hn'\u27e9,\n        rw hn' at hmn,\n        replace hmn := bot_eval_eq_iff_eval_eq hmn,\n        rw hm n' hmn,\n        tauto,\n    },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ca3fcc8f7fb0800201ba88f":[{"id":208937,"user_id":null,"body":"import init.function tactic data.nat.parity\n       Preloaded\nopen function\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A :=\n{\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb _, rfl,\n  b_a_b := \u03bb _, rfl,\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A :=\n{\n  a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := \u03bb a, i.b_a_b a,\n  b_a_b := \u03bb b, i.a_b_a b,\n}\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C :=\n{\n  a_to_b := bc.a_to_b \u2218 ab.a_to_b,\n  b_to_a := ab.b_to_a \u2218 bc.b_to_a,\n  a_b_a := begin\n    intro a,\n    simp,\n    rw [bc.a_b_a, ab.a_b_a],\n  end,\n  b_a_b := begin\n    intro b,\n    simp,\n    rw [ab.b_a_b, bc.b_a_b],\n  end\n}\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B :=\n{\n  a_to_b := ab,\n  b_to_a := ba,\n  a_b_a := h,\n  b_a_b := begin\n    intro b,\n    refine hba _,\n    apply h,\n  end\n}\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\n\n-- inductive nat_plus_1 : Type\n-- | null : nat_plus_1\n-- | is_nat (n : \u2115) : nat_plus_1\n\nopen nat_plus_1\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 :=\n{\n  a_to_b := \u03bb n, match n with\n    | 0 := null\n    | (n+1) := is_nat n\n  end,\n  b_to_a := \u03bb n, match n with\n    | null := 0\n    | (is_nat n) := n+1\n  end,\n  a_b_a := by {intro n, cases n; refl},\n  b_a_b := by {intro n, cases n; refl},\n}\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\ndef a2b (n) := if even n then left (n\/2) else right (n\/2)\n\ndef b2a (t) := match t with\n  | left n := 2*n\n  | right n := 2*n+1\nend\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat := begin\n  apply bijection_alt a2b b2a,\n  {\n    intro n,\n    unfold a2b b2a,\n    split_ifs; unfold b2a._match_1,\n    exact nat.two_mul_div_two_of_even h,\n    exact nat.two_mul_div_two_add_one_of_odd (nat.odd_iff_not_even.mpr h),\n  },\n  intros tx ty,\n  cases tx; cases ty; intro h; unfold b2a at h,\n  replace h := nat.eq_of_mul_eq_mul_left (by norm_num) h,\n  rw h,\n  exfalso,\n  have H : odd (2 * ty + 1) := \u27e8ty, rfl\u27e9,\n  have K : even (2 * tx) := \u27e8tx, by linarith\u27e9,\n  apply nat.odd_iff_not_even.mp H,\n  rw \u2190 h,\n  exact K,\n  exfalso,\n  have H : odd (2 * tx + 1) := \u27e8tx, rfl\u27e9,\n  have K : even (2 * ty) := \u27e8ty, by linarith\u27e9,\n  apply nat.odd_iff_not_even.mp H,\n  rw h,\n  exact K,\n  injection h with H,\n  replace H := nat.eq_of_mul_eq_mul_left (by norm_num) H,\n  rw H,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208938,"user_id":null,"body":"import Preloaded\nimport init.function\nimport tactic\nimport data.nat.basic\nimport data.nat.parity\n\nopen function\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := \n{\n    a_to_b := \u03bb a, a,\n    b_to_a := \u03bb a, a,\n    a_b_a := \u03bb a, rfl,\n    b_a_b := \u03bb a, rfl,\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := \n{\n    a_to_b := i.b_to_a,\n    b_to_a := i.a_to_b,\n    a_b_a := i.b_a_b,\n    b_a_b := i.a_b_a,\n}\n\n\n\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C :=\n{\n    a_to_b := \u03bb a, bc.a_to_b (ab.a_to_b a),\n    b_to_a := \u03bb c, ab.b_to_a (bc.b_to_a c),\n    a_b_a :=\n    begin \n      intro a,\n      rw bc.a_b_a (ab.a_to_b a), exact ab.a_b_a a\n    end,\n    b_a_b :=\n    begin \n      intro c, \n      rw ab.b_a_b (bc.b_to_a c), exact bc.b_a_b c\n    end,\n}\n    \n\n\n\n\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B := {\n    a_to_b :=ab,\n    b_to_a :=ba,\n    a_b_a := h,\n    b_a_b :=\n    begin\n      intro b,\n      set y:= ba b with hy,\n      have : ba (ab y) = y,\n        exact h y,\n        rw hy at this,\n        apply hba this \n    end,\n}\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\n\n--inductive nat_plus_1 : Type\n--| null : nat_plus_1\n--| is_nat (n : \u2115) : nat_plus_1\n\nopen nat_plus_1\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 := \n{\n  a_to_b :=\n  begin\n    intro n,\n    cases n,\n    exact null,\n    exact is_nat (n)\n  end,\n  b_to_a :=\n  begin\n    intro n,\n    cases n,\n    exact nat.zero,\n    exact nat.succ(n)\n  end,\n  a_b_a :=\n  begin\n    intro n,  \n    cases n,refl,\n    dsimp, refl,\n  end,\n  b_a_b :=\n  begin\n    intro n,\n    cases n,\n    refl, dsimp,refl,\n  end,\n}\n\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\n\ndef  f1: \u2115 \u2192 nat_plus_nat := \u03bb n, ite (2\u2223n) (left (n\/2))(right (n\/2))\n\ndef f2: nat_plus_nat \u2192 \u2115 \n| (left (n :\u2115 )) := 2*n\n| (right (n : \u2115)):=2*n+1\n\n\nlemma d2 (n:\u2115) : (2*n+1)\/2=n:=\nbegin\n  induction n with n ih,\n  refl,\n  rw [nat.succ_eq_add_one,mul_add,add_assoc, add_comm (2*1),\u2190 add_assoc,mul_one],\n  have :(2*n+1+2)\/2=((2*n+1)\/2).succ,\n    apply nat.add_div_right (2*n+1) (by norm_num: 0<2),\n  rw ih at this, rw  this\nend\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat := \n{\n  a_to_b :=f1,\n  b_to_a :=f2,\n  a_b_a :=\n  begin\n    intro n, rw f1, dsimp, \n    by_cases H: 2\u2223 n,\n      cases H with k hk,\n      rw hk,\n      split_ifs,rw f2,norm_num,\n      by_contra h',apply h _, apply nat.dvd_mul_right 2 k,split_ifs,rw f2,\n      apply nat.two_mul_div_two_add_one_of_odd _,\n      norm_num, intro h,apply H h,\n  end,\n  b_a_b :=\n  begin\n    intro n, \n    cases n,\n      rw f2, rw f1, dsimp, split_ifs, norm_num,\n      have :2\u2223 2*n,\n        use n,\n      contradiction,\n      rw f2, rw f1, dsimp, split_ifs, \n      have od : \u00ac 2 \u2223 2*n+1,\n        exact nat.two_not_dvd_two_mul_add_one n,contradiction,\n    exact d2 n\n  end,\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208939,"user_id":null,"body":"import init.function\n       Preloaded\n       tactic\nopen function\n\n\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := {\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb _, rfl,\n  b_a_b := \u03bb _, rfl\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A :=\n  \u27e8 i.2,i.1,i.4,i.3\u27e9 \n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C :=\n  \u27e8 bc.1\u2218ab.1,ab.2\u2218bc.2,\u03bb _, (by simp [ab.3,bc.3]), \u03bb _, (by simp [ab.4,bc.4])\u27e9 \n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B :=\n  \u27e8ab,ba,h, \u03bb b, hba (h (ba b))\u27e9\n  \n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\nopen nat_plus_1\n\ndef f : \u2115 \u2192 nat_plus_1\n| 0 := null\n| (n+1) := is_nat n\n\ndef g : nat_plus_1 \u2192 \u2115\n| null := 0\n| (is_nat n) := n+1\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 :=\n\u27e8 f,g,\u03bb x,by { cases x; simp [f,g]}, \u03bb x, by {cases x;simp [f,g]}\u27e9 \n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\nopen nat_plus_nat\n\ndef F : nat_plus_nat \u2192 \u2115\n| (left n) := 2*n \n| (right n) := 2*n+1\n\ndef G : \u2115 \u2192 nat_plus_nat:=\n\u03bb n, ite (n%2 = 0) (left (n\/2)) (right(n\/2))\n\nlemma FG (n : \u2115 ) : F( G n) = n :=\nbegin\n  simp [G],\n  have h1: n = n\/2 * 2 + n%2 := (nat.div_add_mod' n 2).symm,\n  have h2: n%2 <2 := n.mod_lt (by linarith only),\n  cases n%2 with m,\n  {\n    simp [F],\n    symmetry,\n    rwa [add_zero,mul_comm] at h1,\n  },\n  cases m with m,\n  {\n    simp [F],\n    symmetry,\n    rwa mul_comm,\n  },\n  simp only [nat.succ_eq_add_one] at h2,\n  linarith only [h2],\nend\n\nlemma helper {n m : \u2115 } : 2*n \u2260 2*m+1 :=\nbegin\n  have h1 : (2*n) % 2 = 0 := nat.mul_mod_right _ _,\n  have h2 : (2*m+1) % 2 = 1 :=\n  calc\n    (2*m+1) % 2 = ((2*m) % 2 + 1%2)%2 : nat.add_mod _ _ _\n    ...         = (0 + 1 % 2) % 2     : by rw  nat.mul_mod_right _ _\n    ...         = 1                   : rfl,\n  intro h,\n  cc,\nend\n\n\nlemma inj_F : injective F :=\nbegin\n  intros n m hnm,\n  cases n with n,\n  {\n    cases m with m,\n    {\n      simp [F] at hnm,\n      rw hnm,\n    },\n    {\n      simp [F] at hnm,\n      cases helper hnm,\n    },\n  },\n  {\n    cases m with m,\n    {\n      simp [F] at hnm,\n      have : 2*m = 2*n+1,\n      symmetry,\n      assumption,\n      cases helper this,\n    },\n    {\n      simp [F] at hnm,\n      rw hnm,\n    }\n  }\nend\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat :=\n  bijection_alt G F FG inj_F\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208940,"user_id":null,"body":"import Preloaded\nimport init.function \nimport data.nat.parity\nopen function\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := \n{\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb a, rfl,\n  b_a_b := \u03bb b, rfl,\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := \n{\n  a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := i.b_a_b,\n  b_a_b := i.a_b_a,\n}\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C := \n{\n  a_to_b := bc.a_to_b \u2218 ab.a_to_b,\n  b_to_a := ab.b_to_a \u2218 bc.b_to_a,\n  a_b_a := \u03bb a, by rw [function.comp_app, function.comp_app, bc.a_b_a, ab.a_b_a],\n  b_a_b := \u03bb b, by rw [function.comp_app, function.comp_app, ab.b_a_b, bc.b_a_b],\n}\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B := \n{\n  a_to_b := ab,\n  b_to_a := ba,\n  a_b_a := h,\n  b_a_b := \u03bb b, hba (h (ba b)),\n}\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n\nopen nat_plus_1\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 := \n{\n  a_to_b := \u03bb n, nat.cases_on n null is_nat,\n  b_to_a := \u03bb x, nat_plus_1.cases_on x 0 nat.succ,\n  a_b_a := \u03bb a, by { cases a; simp, },\n  b_a_b := \u03bb b, by { cases b; simp, },\n}\n\n\nopen nat_plus_nat\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat := \n{\n  a_to_b := \u03bb n, ite (n % 2 = 0) (left (n\/2)) (right (n\/2)),\n  b_to_a := \u03bb x, nat_plus_nat.cases_on x (\u03bb n, 2 * n) (\u03bb n, 2 * n + 1),\n  a_b_a := \u03bb a, by { by_cases (a % 2 = 0), \n                      { rw if_pos h, dsimp only, \n                        apply nat.mul_div_cancel_left' (nat.dvd_of_mod_eq_zero h), },\n                      { rw if_neg h, dsimp only, rw add_comm,\n                        convert nat.mod_add_div a 2,\n                        exact (nat.mod_two_ne_zero.1 h).symm, }, },\n  b_a_b := \u03bb b, by { apply nat_plus_nat.cases_on b,\n                      { intro n, simp only, rw if_pos (nat.mul_mod_right 2 n),\n                        rw nat.mul_div_right n (show 0<2, by norm_num), },\n                      { intro n, simp only, \n                        rw [if_neg, add_comm, nat.add_mul_div_left _ _ (show 0<2, by norm_num)], \n                        { rw [nat.div_eq_zero (show 1<2, by norm_num), zero_add], },\n                        { rw [nat.mod_two_ne_zero, add_comm, nat.add_mul_mod_self_left], simp } } }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208941,"user_id":null,"body":"import init.function Preloaded tactic data.nat.parity\nopen function\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := {\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := by{intro a, simp,},\n  b_a_b := by{intro b, simp,},\n}\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := {\n  a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := by{exact i.b_a_b},\n  b_a_b := by{exact i.a_b_a},\n}\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C := {\n  a_to_b := bc.a_to_b \u2218 ab.a_to_b,\n  b_to_a := ab.b_to_a \u2218 bc.b_to_a,\n  a_b_a := by{simp [comp,bc.a_b_a,ab.a_b_a],},\n  b_a_b :=by{simp [comp,ab.b_a_b,bc.b_a_b],},\n}\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B :=\n{\n  a_to_b := ab,\n  b_to_a := ba,\n  a_b_a := h,\n  b_a_b := by{tauto,}\n}\nopen nat_plus_1\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 :={\n  a_to_b:= \u03bb n, nat.cases_on n null (\u03bb n, is_nat(n)),\n  b_to_a:= \u03bb z, nat_plus_1.cases_on z 0 (\u03bb n ,n+1),\n  a_b_a := by{\n    intro a,\n    cases a;simp,\n  },\n  b_a_b := by{\n    intro b,\n    cases b;simp,\n  }\n}\n\nopen nat_plus_nat\nlemma mod_two_of_mul_two_eq_zero (n:\u2115): (n*2)%2=0:=by{\n  have h0:even (n*2),{\n    exact nat.even_mul.mpr (or.inr $ by{exact even_bit0 1}),\n  },\n  rw [nat.mod_eq_zero_of_dvd ((@even_iff_two_dvd _ _ (n*2)).mp h0)],\n}\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat :={\n  a_to_b := by{\n    intro n,\n    by_cases h:even n,{\n      exact left (n\/2),\n    },\n    exact right (n\/2),\n  },\n  b_to_a := by{\n    intro npn,\n    cases npn,{\n      exact npn*2,\n    },\n    exact (npn*2+1),\n  },\n  a_b_a:= by{\n    intro a,\n    by_cases h0:even a,{\n      dsimp,\n      rw [if_pos h0],\n      dsimp,\n      replace h0:=even_iff_two_dvd.mp h0,\n      exact nat.div_mul_cancel h0,\n    },\n    dsimp,\n    rw [if_neg h0],\n    dsimp,\n    replace h0:=nat.odd_iff.mp (nat.odd_iff_not_even.mpr h0),\n    conv_rhs{\n      rw [\u2190nat.div_add_mod' a 2],\n    },\n    linarith,\n  },\n  b_a_b := by{\n    intro b,\n    dsimp,\n    cases b,{\n      simp,\n      intro,\n      have h0:even (b*2),{\n        exact nat.even_mul.mpr (or.inr $ by{exact even_bit0 1}),\n      },\n      exact \u1fb0 h0,\n    },\n    simp,\n    have h0:odd (b*2+1),{\n      rw [nat.odd_iff],\n      rw [\u2190(nat.mod_add_mod (b*2) 2 1)],\n      rw [mod_two_of_mul_two_eq_zero b],\n      norm_num,\n    },\n    replace h0:=nat.odd_iff_not_even.mp h0,\n    rw [if_neg h0],\n    congr,\n    rw [nat.add_div zero_lt_two],\n    have h1:\u00ac 2 \u2264 b * 2 % 2 + 1 % 2,{\n      rw [mod_two_of_mul_two_eq_zero b],\n      norm_num,\n    },\n    rw [if_neg h1],\n    rw [nat.mul_div_cancel b zero_lt_two],\n    norm_num,\n  },\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208942,"user_id":null,"body":"import init.function Preloaded tactic\nopen function\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := \n{ a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb x, rfl,\n  b_a_b := \u03bb x, rfl }\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := \n{ a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := \u03bb x, i.b_a_b x,\n  b_a_b := \u03bb x, i.a_b_a x }\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C := \n{ a_to_b := \u03bb x, bc.a_to_b (ab.a_to_b x),\n  b_to_a := \u03bb x, ab.b_to_a (bc.b_to_a x),\n  a_b_a := begin intro x, rw [ bc.a_b_a, ab.a_b_a], end,\n  b_a_b := begin intro x, rw [ ab.b_a_b, bc.b_a_b], end }\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B := \n{ a_to_b := ab,\n  b_to_a := ba,\n  a_b_a := h,\n  b_a_b := begin intro x, apply hba, rw h (ba x) end }\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\n\n-- inductive nat_plus_1 : Type\n-- | null : nat_plus_1\n-- | is_nat (n : \u2115) : nat_plus_1\n\nopen nat\n\nopen nat_plus_1\n\n--set_option trace.eqn_compiler.elim_match true\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 := \n{ a_to_b := \u03bb x, match x with\n    | zero := null \n    | succ n := is_nat n \n    end,\n  b_to_a := \u03bb x, match x with\n    | null := 0  \n    | is_nat n := succ n\n    end,\n  a_b_a := \u03bb x, nat.cases_on x rfl (\u03bb _, rfl),\n  b_a_b := \u03bb x, nat_plus_1.cases_on x rfl (\u03bb _, rfl) }\n\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat := \n{ a_to_b := \u03bb n, if n%2 = 0 then left (n\/2) else right (n\/2),\n  b_to_a := \u03bb x, nat_plus_nat.cases_on x (\u03bb n, 2*n) (\u03bb n, 2*n+1),     \n  a_b_a := begin\n    intro n,\n    cases mod_two_eq_zero_or_one n;\n    have t:=mod_add_div n 2;\n    rw h at t,\n    { rw if_pos, simp at *, rw t, rw h },\n    { rw if_neg, simp at *, rwa add_comm at t, simp [h] }, \n  end,\n  b_a_b := begin    \n    intro b,\n    cases b with n hn,\n    split_ifs,\n    exact nat.mul_div_cancel_left n (zero_lt_two),\n    simp at h, assumption,\n    cases (@nat.div_mod_unique (2*hn+1) 2 1 hn (zero_lt_two)).mpr \u27e8by rw add_comm, (one_lt_two)\u27e9,    \n    simp,\n    split_ifs,\n    linarith, assumption,\n  end }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208943,"user_id":null,"body":"import init.function\n       Preloaded\n       data.nat.basic\nopen function\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := \u27e8id, id, \u03bb _, rfl, \u03bb _, rfl\u27e9\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := \u27e8i.2, i.1, i.4, i.3\u27e9\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} : iso A B \u2192 iso B C \u2192 iso A C :=\n\u03bb \u27e8f\u2081, g\u2081, h\u2081, h\u2082\u27e9 \u27e8f\u2082, g\u2082, h\u2083, h\u2084\u27e9,\n  \u27e8 f\u2082 \u2218 f\u2081, g\u2081 \u2218 g\u2082,\n    \u03bb _, show g\u2081 (g\u2082 (f\u2082 (f\u2081 _))) = _, from by rw [h\u2083, h\u2081],\n    \u03bb _, show f\u2082 (f\u2081 (g\u2081 (g\u2082 _))) = _, from by rw [h\u2082, h\u2084] \u27e9\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B := \u27e8ab, ba, h, \u03bb b, hba (h _)\u27e9\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\n\n-- inductive nat_plus_1 : Type\n-- | null : nat_plus_1\n-- | is_nat (n : \u2115) : nat_plus_1\n\nopen nat_plus_1\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 :=\n\u27e8 \u03bb n, nat.cases_on n null is_nat,\n  \u03bb m, nat_plus_1.cases_on m 0 nat.succ,\n  \u03bb n, nat.cases_on n rfl (\u03bb _, rfl),\n  \u03bb m, nat_plus_1.cases_on m rfl (\u03bb _, rfl) \u27e9\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat :=\n\u27e8 \u03bb x, if x % 2 = 0 then left (x \/ 2) else right (x \/ 2),\n  \u03bb x, nat_plus_nat.cases_on x (\u03bb n, 2 * n) (\u03bb n, 1 + 2 * n),\n  begin\n    intro x,\n    have := nat.mod_add_div x 2,\n    cases x.mod_two_eq_zero_or_one with h;\n    rw h at this,\n    { rwa if_pos h, rwa zero_add at this },\n    { rwa if_neg, rw h, exact nat.one_ne_zero }\n  end,\n  begin\n    intro x,\n    cases x with n;\n    simp [nat.add_mul_div_left],\n    exact zero_add _\n  end \u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208944,"user_id":null,"body":"import init.function\n       Preloaded\nimport tactic\nopen function\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := \n{\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb a, rfl,\n  b_a_b := \u03bb b, rfl,\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A :=\n{\n  a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := i.b_a_b,\n  b_a_b := i.a_b_a,\n}\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C := \n{\n  a_to_b := bc.a_to_b \u2218 ab.a_to_b,\n  b_to_a := ab.b_to_a \u2218 bc.b_to_a,\n  a_b_a := \u03bb a, by {rw [comp_app, comp_app, bc.a_b_a (ab.a_to_b a), ab.a_b_a], },\n  b_a_b := \u03bb c, by {rw [comp_app, comp_app, ab.b_a_b (bc.b_to_a c), bc.b_a_b], },\n}\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B :=\n{\n  a_to_b := ab,\n  b_to_a := ba,\n  a_b_a := h,\n  b_a_b := \u03bb b, by {apply hba, rw h (ba b)}\n}\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\nopen nat_plus_1\n\ndef np1_to_nat : nat_plus_1 \u2192 \u2115\n| null       := 0\n| (is_nat n) := nat.succ n\n\n\ndef nat_to_np1 : \u2115 \u2192 nat_plus_1\n| 0             := null\n| (nat.succ n)  := is_nat n\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 :=\n{\n  a_to_b  := nat_to_np1,\n  b_to_a  := np1_to_nat,\n  a_b_a   := \u03bb n, nat.cases_on n rfl (\u03bb m, rfl),\n  b_a_b   := \u03bb n, nat_plus_1.cases_on n rfl (\u03bb m, rfl),\n}\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\n\ndef npn_to_nat : nat_plus_nat \u2192 \u2115\n| (left n)  := 2*n\n| (right n) := 2*n+1\n\ndef nat_to_npn (n : \u2115) : nat_plus_nat := prod.cases_on (nat.bodd_div2 n) \n  (\u03bb p n', bool.cases_on p (left n') (right n')) \n\nlemma foo\u2081 {m : \u2115} : nat_to_npn (2*m) = left m :=\nbegin\n  induction m with k, refl,\n  dsimp [nat_to_npn], rw [nat.bodd_div2_eq, nat.div2_val],\n  rw [show (2*k.succ).bodd = ff, by simp, show 2*k.succ \/ 2 = k.succ, by simp],\nend\n\nlemma foo\u2082 {m : \u2115} : nat_to_npn (2*m+1) = right m :=\nbegin\n  induction m with k, refl,\n  dsimp [nat_to_npn], rw [nat.bodd_div2_eq, nat.div2_val, show (2*k.succ + 1).bodd = tt, by simp],\n  rw [add_comm, nat.add_mul_div_left _ _ zero_lt_two], norm_num,\nend\n\nlemma doo\u2081 (n : \u2115) : npn_to_nat (nat_to_npn n) = n :=\nbegin\n  have h := nat.mod_add_div n 2,\n  cases nat.mod_two_eq_zero_or_one n with neven nodd,\n  { rw [neven, zero_add] at h, rw [\u2190h, foo\u2081], refl, },\n  { rw nodd at h, rw [\u2190h, add_comm, foo\u2082], refl, },\nend\n\nlemma doo\u2082 (x : nat_plus_nat) : nat_to_npn (npn_to_nat x) = x :=\nbegin\n  cases x,\n  case left : m { dsimp [npn_to_nat], rw foo\u2081, },\n  case right : m { dsimp [npn_to_nat], rw foo\u2082, },\nend\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat :=\n{\n  a_to_b  := nat_to_npn,\n  b_to_a  := npn_to_nat,\n  a_b_a   := doo\u2081,\n  b_a_b   := doo\u2082,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208945,"user_id":null,"body":"import init.function data.nat.parity\n       Preloaded\nopen function\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := {\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb a, by simp,\n  b_a_b := \u03bb b, by simp\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := {\n  a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := i.b_a_b,\n  b_a_b := i.a_b_a\n}\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C := {\n  a_to_b := bc.a_to_b \u2218 ab.a_to_b,\n  b_to_a := ab.b_to_a \u2218 bc.b_to_a,\n  a_b_a := \u03bb a, by { simp, rwa [bc.a_b_a, ab.a_b_a] },\n  b_a_b := \u03bb c, by { simp, rwa [ab.b_a_b, bc.b_a_b] }\n}\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B := {\n    a_to_b := ab,\n    b_to_a := ba,\n    a_b_a := h,\n    b_a_b := \u03bb b, hba (h (ba b))\n}\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\n\n-- inductive nat_plus_1 : Type\n-- | null : nat_plus_1\n-- | is_nat (n : \u2115) : nat_plus_1\n\nopen nat\nopen nat_plus_1\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 := {\n  a_to_b := \u03bb n, nat.cases_on n null (\u03bb m, is_nat m),\n  b_to_a := \u03bb m, nat_plus_1.cases_on m 0 (\u03bb n, n.succ),\n  a_b_a := \u03bb a, by { cases a; simp },\n  b_a_b := \u03bb b, by { cases b; simp, refl }\n}\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat := {\n  a_to_b := \u03bb n, ite (even n) (left (n\/2)) (right ((n - 1)\/2)),\n  b_to_a := \u03bb m, nat_plus_nat.cases_on m (\u03bb n, 2*n) (\u03bb n, 2*n + 1),\n  a_b_a := \u03bb a, by { by_cases (even a), {\n      rw if_pos h,\n      simp,\n      rw [mul_comm, nat.div_mul_cancel h]\n    },\n    {\n      rw if_neg h,\n      simp,\n      have h' : even (a + 1 - 2) := even.sub (even_succ.mpr h) (by norm_num),\n      simp at h',\n      rw [mul_comm, nat.div_mul_cancel h'],\n      cases a with a,\n        { exfalso, apply h, norm_num },\n        { exact nat.sub_add_cancel (succ_le_succ (by norm_num)) }\n    }\n  },\n  b_a_b := \u03bb b, by {\n    cases b,\n    {\n      simp,\n      have heven : even (2*b), by use b,\n      rw if_pos heven,\n    },\n    {\n      simp,\n      have heven : even (2*b), by use b,\n      have hodd : \u00ac even (2*b + 1), by { intro h, rw even_succ at h, apply h, exact heven },\n      rw if_neg hodd,\n    }\n  }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208946,"user_id":null,"body":"import init.function\n       Preloaded\n       tactic\nopen function\n\n\n-- Task 0\n-- Find a bijection between bool and bit. (provided for you as an example)\n\n\ninductive bit : Type\n  | b0 : bit\n  | b1 : bit\n\nopen bit\n\ndef bool_to_bit : bool \u2192 bit\n| tt := b1\n| ff := b0\n\ndef bit_to_bool : bit \u2192 bool\n| b0 := ff\n| b1 := tt\n\ndef bool_iso_bit : iso bool bit :=\n{\n  a_to_b := bool_to_bit,\n  b_to_a := bit_to_bool,\n  a_b_a := \u03bb a, bool.cases_on a rfl rfl,\n  b_a_b := \u03bb b, bit.cases_on b rfl rfl,\n}\n\n-- Task 1\n-- General properties of iso\n\n-- Task 1-1 : Prove that any set has the same cardinality as itself\ndef iso_rfl {A : Type} : iso A A := {\n  a_to_b := id,\n  b_to_a := id,\n  a_b_a := \u03bb a, rfl,\n  b_a_b := \u03bb b, rfl,\n}\n\n-- Task 1-2 : Prove that iso is symmetric\ndef iso_symm {A B : Type} (i : iso A B) : iso B A := {\n  a_to_b := i.b_to_a,\n  b_to_a := i.a_to_b,\n  a_b_a := i.b_a_b,\n  b_a_b := i.a_b_a,\n}\n\n\n-- Task 1-3 : Prove that iso is transitive\ndef iso_trans {A B C : Type} (ab : iso A B) (bc : iso B C) : iso A C := {\n  a_to_b := bc.a_to_b \u2218 ab.a_to_b,\n  b_to_a := ab.b_to_a \u2218 bc.b_to_a,\n  a_b_a := \u03bb a, begin\n    unfold comp,\n    rw bc.a_b_a (ab.a_to_b a),\n    exact ab.a_b_a a,\n  end,\n  b_a_b := \u03bb c, begin\n    unfold comp,\n    rw ab.b_a_b (bc.b_to_a c),\n    exact bc.b_a_b c,\n  end,\n}\n\n-- Task 1-4 : Prove the following statement:\n-- Given two functions A->B and B->A, if A->B->A is satisfied and B->A is injective, A <=> B\ndef bijection_alt {A B : Type} (ab : A \u2192 B) (ba : B \u2192 A) \n  (h : \u2200 a, ba (ab a) = a) (hba: injective ba) : iso A B := {\n    a_to_b := ab,\n    b_to_a := ba,\n    a_b_a := h,\n    b_a_b := begin\n      intros,\n      apply hba,\n      rw h,\n    end,\n  }\n\n-- Task 2\n-- iso relations between nat and various supersets of nat\n\n-- nat_plus_1 : a set having one more element than nat. (provided in preloaded)\n\n\n-- inductive nat_plus_1 : Type\n-- | null : nat_plus_1\n-- | is_nat (n : \u2115) : nat_plus_1\n\nopen nat_plus_1\n\ndef nat'_to_nat : nat_plus_1 -> \u2115\n| null := 0\n| (is_nat n) := n.succ\n\ndef nat_to_nat' : \u2115 -> nat_plus_1\n| 0 := null\n| n := is_nat n.pred\n\nopen tactic.interactive\n\nlemma nat_nat'_nat : \u2200 (a : \u2115), nat'_to_nat (nat_to_nat' a) = a := \nbegin\n  intros, destruct a,\n  finish, finish\nend\n\nlemma nat'_nat_nat' : \u2200 (b : nat_plus_1), nat_to_nat' (nat'_to_nat b) = b :=\nbegin\n  intros, destruct b,\n  finish, finish\nend\n\ndef nat_iso_nat_plus_1 : iso \u2115 nat_plus_1 := {\n  a_to_b := nat_to_nat',\n  b_to_a := nat'_to_nat,\n  a_b_a := nat_nat'_nat,\n  b_a_b := nat'_nat_nat',\n}\n\n-- nat_plus_nat : a set having size(nat) more elements than nat. (provided in preloaded)\n\n-- inductive nat_plus_nat : Type\n-- | left (n : \u2115) : nat_plus_nat\n-- | right (n : \u2115) : nat_plus_nat\n\nopen nat_plus_nat\n\ndef nat_to_nn : \u2115 -> nat_plus_nat\n| n := if (nat.bodd n) then (left (nat.div2 n)) else (right (nat.div2 n))\n\ndef nn_to_nat : nat_plus_nat -> \u2115\n| (left n) := 1 + 2 * n\n| (right n) := 2 * n\n\ndef nat_iso_nat_plus_nat : iso \u2115 nat_plus_nat := {\n  a_to_b := nat_to_nn,\n  b_to_a := nn_to_nat,\n  a_b_a := begin\n    intros,\n    have h\u2080 : cond a.bodd 1 0 + 2 * a.div2 = a, from nat.bodd_add_div2 a,\n    by_cases (nat.bodd a = tt),\n    simp [nat_to_nn, h, nn_to_nat], finish,\n    simp [nat_to_nn, h, nn_to_nat],\n    finish [bool_eq_false h],\n  end,\n  b_a_b := begin\n    intros, destruct b,\n    intros, rw a, simp [nat_to_nn],\n    simp [nn_to_nat],\n    ring, rw nat.div2_succ,\n    rw nat.div2_val, norm_num,\n    intros, rw a, simp [nat_to_nn],\n    simp [nn_to_nat],\n    rw nat.div2_val, norm_num,\n  end,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5cb9dc6f98b230001cbe2cea":[{"id":208947,"user_id":null,"body":"import tactic.linarith\n\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L,\n  { simp },\n  { by_cases p L_hd; by_cases q L_hd;\n    simp [list.filter,*]; linarith },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208948,"user_id":null,"body":"import tactic\nuniverse u\n\nopen list decidable\n\nlemma length_filter_le {\u03b1 : Type u} (xs : list \u03b1) (p : \u03b1 \u2192 Prop) [decidable_pred p]: length (filter p xs) \u2264 length xs :=\nbegin\n  induction xs with x xs,\n  simp,\n  by_cases h : (p x),\n  have : length (filter p (x :: xs)) \u2264 length (x :: xs) :=\n  calc\n    length (filter p (x :: xs)) \u2264 length (x :: filter p xs) :\n    begin\n      apply eq.le,\n      apply congr_arg,\n      apply filter_cons_of_pos,\n      apply h,\n    end\n    ... \u2264 length (filter p xs) + 1 :\n    begin\n      apply eq.le,\n      apply rfl,\n    end\n    ... \u2264 length xs + 1 :\n    begin\n      apply nat.succ_le_succ,\n      apply xs_ih,\n    end\n    ... \u2264 length (x :: xs) :\n    begin\n      apply eq.le,\n      apply rfl,\n    end,\n  assumption,\n  have : length (filter p (x :: xs)) \u2264 length (x :: xs) :=\n  calc\n    length (filter p (x :: xs)) \u2264 length (filter p xs) :\n    begin\n      apply eq.le,\n      apply congr_arg,\n      apply filter_cons_of_neg,\n      apply h,\n    end\n    ... \u2264 length xs :\n    begin\n      apply xs_ih,\n    end\n    ... \u2264 length xs + 1 :\n    begin\n      exact (length xs).le_succ,\n    end\n    ... \u2264 length (x :: xs) :\n    begin\n      apply eq.le,\n      apply congr_arg,\n      trivial,\n    end,\n  assumption,\nend\n\nlemma length_filter_cons_le {\u03b1 : Type u} (x : \u03b1) (xs : list \u03b1) (p : \u03b1 \u2192 Prop) [decidable_pred p]: length (filter p (x::xs)) \u2264 length (filter p xs) + 1:=\nbegin\n  by_cases h1 : (p x),\n  have : (filter p (x :: xs)).length \u2264 (filter p xs).length + 1 :=\n  calc\n    (filter p (x :: xs)).length \u2264 (x :: filter p xs).length :\n    begin\n       apply eq.le,\n       apply congr_arg,\n       apply filter_cons_of_pos,\n       apply h1,\n    end\n    ... \u2264 (filter p xs).length + 1 :\n    begin\n      apply eq.le,\n      exact rfl,\n    end,\n  assumption,\n  have : (filter p (x :: xs)).length \u2264 (filter p xs).length + 1 :=\n  calc\n    (filter p (x :: xs)).length \u2264 (filter p xs).length : \n    begin\n      apply eq.le,\n      apply congr_arg,\n      apply filter_cons_of_neg,\n      apply h1,\n    end\n    ... \u2264 (filter p xs).length + 1 : by apply nat.le_succ,\n  assumption,\nend\n\nlemma length_filter_tl_le_cons {\u03b1 : Type u} {x : \u03b1} {xs : list \u03b1} (p : \u03b1 \u2192 Prop) [decidable_pred p]: length (filter p xs) \u2264 length (filter p (x::xs)):=\nbegin\n  by_cases h1 : (p x),\n  have : (filter p xs).length \u2264 (filter p (x :: xs)).length :=\n  calc\n    (filter p xs).length \u2264 (filter p xs).length + 1 : by apply nat.le_succ\n    ... \u2264 (x::(filter p xs)).length : \n    begin\n      apply eq.le,\n      apply rfl,\n    end\n    ... \u2264 (filter p (x::xs)).length :\n    begin\n      apply eq.le,\n      apply congr_arg,\n      apply eq.symm,\n      apply filter_cons_of_pos xs h1,\n    end,\n  assumption,\n  have : (filter p xs).length \u2264 (filter p (x :: xs)).length :=\n  calc\n    (filter p xs).length \u2264 (filter p (x::xs)).length :\n    begin\n      apply eq.le,\n      apply congr_arg,\n      apply eq.symm,\n      apply filter_cons_of_neg xs h1,\n    end,\n  assumption,\nend\n\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  let f := (\u03bb (x : \u03b1), p x \u2228 q x),\n  induction L with x xs,\n  simp,\n  by_cases h1 : (p x \u2228 q x),\n  have : (filter f (x :: xs)).length \u2264 (filter p (x :: xs)).length + (filter q (x :: xs)).length :=\n  calc\n    (filter f (x :: xs)).length \u2264 (filter f xs).length + 1 : by apply length_filter_cons_le\n    ... \u2264 (filter p xs).length + (filter q xs).length + 1 :\n    begin\n      apply nat.succ_le_succ,\n      apply L_ih,\n    end\n    ... \u2264 (filter p (x :: xs)).length + (filter q (x :: xs)).length :\n    begin\n      by_cases h2 : (p x),\n      have : (filter p xs).length + (filter q xs).length + 1 \u2264 (filter p (x :: xs)).length + (filter q (x :: xs)).length :=\n      calc\n        (filter p xs).length + (filter q xs).length + 1 \u2264 ((filter p xs).length + 1) + (filter q xs).length : by omega\n        ... \u2264 (x::(filter p xs)).length + (filter q xs).length :\n        begin\n          apply (add_le_add_iff_right (filter q xs).length).mpr,\n          apply eq.le,\n          apply eq.symm,\n          apply rfl,\n        end\n        ... \u2264 (filter p (x::xs)).length + (filter q xs).length :\n        begin\n          apply (add_le_add_iff_right (filter q xs).length).mpr,\n          apply eq.le,\n          apply eq.symm,\n          apply congr_arg,\n          apply filter_cons_of_pos,\n          apply h2,\n        end\n        ... \u2264 (filter p (x::xs)).length + (filter q (x::xs)).length :\n        begin\n          apply (add_le_add_iff_left ((filter p (x::xs)).length)).mpr,\n          apply length_filter_tl_le_cons,\n        end,\n      assumption,\n      have h3 : q x, from or.resolve_left h1 h2,\n      have : (filter p xs).length + (filter q xs).length + 1 \u2264 (filter p (x :: xs)).length + (filter q (x :: xs)).length :=\n      calc\n        (filter p xs).length + (filter q xs).length + 1 \u2264 (filter p xs).length + ((filter q xs).length + 1) : by omega\n        ... \u2264 (filter p xs).length + (x::(filter q xs)).length :\n        begin\n          apply (add_le_add_iff_left (filter p xs).length).mpr,\n          apply eq.le,\n          apply eq.symm,\n          apply rfl,\n        end\n        ... \u2264 (filter p xs).length + (filter q (x::xs)).length :\n        begin\n          apply (add_le_add_iff_left (filter p xs).length).mpr,\n          apply eq.le,\n          apply eq.symm,\n          apply congr_arg,\n          apply filter_cons_of_pos,\n          apply h3,\n        end        \n        ... \u2264 (filter p (x::xs)).length + (filter q (x::xs)).length :\n        begin\n          apply (add_le_add_iff_right ((filter q (x::xs)).length)).mpr,\n          apply length_filter_tl_le_cons,\n        end,\n      assumption,\n    end,\n  assumption,\n  have : (filter f (x :: xs)).length \u2264 (filter p (x :: xs)).length + (filter q (x :: xs)).length :=\n  calc\n    (filter f (x :: xs)).length \u2264 (filter f xs).length :\n    begin\n      apply eq.le,\n      apply congr_arg,\n      apply filter_cons_of_neg,\n      apply h1,\n    end\n    ... \u2264 (filter p xs).length + (filter q xs).length : by apply L_ih\n    ... \u2264 (filter p (x::xs)).length + (filter q (x::xs)).length :\n    begin\n      apply nat.add_le_add,\n      apply length_filter_tl_le_cons,\n      apply length_filter_tl_le_cons,\n    end,\n  assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208949,"user_id":null,"body":"import tactic\nuniverse u\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=by{\n  induction L,\n  simp,\n  simp[list.filter],\n  split_ifs, repeat {\n    simp[list.length_cons],\n    linarith,\n  },{\n    cases h; contradiction,\n  },{\n    assumption,\n  }\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208950,"user_id":null,"body":"import Preloaded tactic\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L with x xs ih,\n  { refl },\n  by_cases hp : p x; \n  by_cases hq : q x;\n  simp [hp, hq];\n  linarith,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208951,"user_id":null,"body":"import tactic\n\nuniverse u\n\nopen list\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L with l L ih,\n  case nil {\n    repeat {rw filter_nil},\n    rw length,\n  },\n  case cons {\n    cases decidable.em (p l) with hp hp,\n    { have h : (filter q L).length \u2264 (filter q (l :: L)).length :=\n      begin\n        apply length_le_of_sublist,\n        rw \u2190 (filter_map_eq_filter q),\n        apply sublist.filter_map,\n        apply sublist_cons,\n      end,\n      simp [hp],\n      linarith only [ih, h],\n    },\n    { cases decidable.em (q l) with hq hq;\n      simp [hp, hq],\n      { linarith only [ih] },\n      { exact ih }\n    }\n  } \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208952,"user_id":191,"body":"import tactic\n\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L,\n  { repeat { rw list.filter_nil },\n    repeat { rw list.length, },\n  }, {\n    by_cases P : p L_hd;\n    by_cases Q : q L_hd,\n    { rw list.filter_cons_of_pos,\n      rw list.filter_cons_of_pos,\n      rw list.filter_cons_of_pos,\n      rw list.length_cons,\n      rw list.length_cons,\n      rw list.length_cons,\n      ring,\n      rw \u2190 add_assoc,\n      exact add_le_add L_ih one_le_two,\n      exact Q,\n      exact P,\n      left,\n      exact P\n    }, {\n      rw list.filter_cons_of_pos,\n      rw list.filter_cons_of_pos,\n      rw list.filter_cons_of_neg,\n      rw list.length_cons,\n      rw list.length_cons,\n      ring,\n      rw \u2190 add_assoc,\n      exact add_le_add L_ih (by refl),\n      exact Q,\n      exact P,\n      left,\n      exact P\n    }, {\n      rw list.filter_cons_of_pos,\n      rw list.filter_cons_of_neg,\n      rw list.filter_cons_of_pos,\n      rw list.length_cons,\n      rw list.length_cons,\n      rw \u2190 add_assoc,\n      exact add_le_add L_ih (by refl),\n      exact Q,\n      exact P,\n      right,\n      exact Q\n    }, {\n      rw list.filter_cons_of_neg,\n      rw list.filter_cons_of_neg,\n      rw list.filter_cons_of_neg,\n      exact L_ih,\n      exact Q,\n      exact P,\n      push_neg,\n      exact \u27e8P, Q\u27e9\n    }\n  }  \nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208953,"user_id":null,"body":"import tactic.linarith\n\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L with x L,\n  case list.nil : {\n    constructor,\n  },\n  case list.cons : {\n    unfold list.filter,\n    by_cases hp : p x; by_cases hq : q x;\n      simp [hp, hq, or.intro_left (q x) hp, or.intro_right (p x) hq];\n      linarith,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208954,"user_id":null,"body":"import tactic\n\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [dp: decidable_pred p] [dq: decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L,\n  simp only [list.filter_nil, list.length],\n  cases dp L_hd;\n  cases dq L_hd;\n  simp only [*, list.length, list.filter, add_assoc, if_true, or_false, false_or, if_false, or_self];\n  linarith\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208955,"user_id":null,"body":"import tactic\n\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L with y L h,\n  { simp },\n  { dsimp [list.filter], \n    by_cases hp : p y,\n    { by_cases hq : q y,\n      { simp only [if_pos (or.inl hp), if_pos hp, if_pos hq, list.length], linarith, },\n      { simp only [if_pos (or.inl hp), if_pos hp, if_neg hq, list.length], linarith, }, },\n    { by_cases hq : q y,\n      { simp only [if_pos (or.inr hq), if_neg hp, if_pos hq, list.length], linarith, },\n      { rwa [if_neg (show \u00ac(p y \u2228 q y), by finish), if_neg hp, if_neg hq], }, }, }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208956,"user_id":null,"body":"import tactic.linarith\n\nuniverse u\n\ntheorem length_filter_or_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2228 q x).length \u2264 (L.filter p).length + (L.filter q).length :=\nbegin\n  induction L with head tail ind_h,\n  { simp, },\n  { by_cases p head; by_cases q head;\n    simp [list.filter, *]; linarith, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5cc3d8c2312133001dea9b3d":[{"id":208957,"user_id":644,"body":"import Preloaded tactic.ring\n\n\/--\nimport algebra.group_power\n\ndef geom_sum : \u2115 \u2192 \u2124 \u2192 \u2124\n| 0     z := 1\n| (n+1) z := z^(n+1) + geom_sum n z\n\ndef geom_formula (n : \u2115) (z : \u2124) : \u2124 :=\nif z = 1 then n+1 else (z^(n+1) - 1) \/ (z - 1)\n\ndef SUBMISSION : Prop := \u2200 n z, geom_sum n z = geom_formula n z\nnotation `SUBMISSION` := SUBMISSION\n--\/\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\n  rw [geom_formula],\n  split_ifs,\n  { subst z,\n    induction n; simp [*, geom_sum, add_left_comm] },\n  { refine eq.symm (int.div_eq_of_eq_mul_left (sub_ne_zero_of_ne h) _),\n    induction n; simp [geom_sum, pow_succ, *, sub_eq_iff_eq_add] at *,\n    ring }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208958,"user_id":null,"body":"import Preloaded\n\n\/--\nimport algebra.group_power\nimport tactic\n\ndef geom_sum : \u2115 \u2192 \u2124 \u2192 \u2124\n| 0     z := 1\n| (n+1) z := z^(n+1) + geom_sum n z\n\ndef geom_formula (n : \u2115) (z : \u2124) : \u2124 :=\nif z = 1 then n+1 else (z^(n+1) - 1) \/ (z - 1)\n\ndef SUBMISSION : Prop := \u2200 n z, geom_sum n z = geom_formula n z\nnotation `SUBMISSION` := SUBMISSION\n--\/\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z := begin\n  by_cases h : z = 1,\n  {\n    suffices : geom_sum n 1 = \u2191n + 1,\n    {\n      rw [h, this],\n      simp [geom_sum, geom_formula],\n    },\n    induction n with n H,\n    finish,\n    unfold geom_sum,\n    rw H,\n    finish,\n  },\n  have S : z - 1 \u2260 0, from sub_ne_zero.mpr h,\n  suffices K : (geom_sum n z) * (z - 1) = z ^ (n+1) - 1,\n  {\n    rw [geom_formula, if_neg h, \u2190 K],\n    rw [int.mul_div_cancel _ S],\n  },\n  induction n with n H,\n  unfold geom_sum geom_formula,\n  simp,\n  unfold geom_sum,\n  rw [add_mul, H],\n  conv_lhs {\n    rw [mul_sub, sub_add],\n    congr,\n    rw [mul_comm, \u2190 pow_succ],\n    skip,\n    rw [\u2190 sub_add, mul_one, sub_self],\n    simp,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208959,"user_id":null,"body":"import Preloaded tactic.ring_exp\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\n  by_cases eq1 : z = 1, { induction n; simp [*, geom_sum, geom_formula, add_comm] at *, },\n  induction n with m IH, { simp [geom_sum, geom_formula, int.div_self (sub_ne_zero.2 eq1)], },\n  simp only [IH, geom_sum, geom_formula, if_neg eq1],\n  have : z ^ (m + 2) - z ^ (m + 1) = (z - 1) * z ^ (m + 1), by ring_exp,\n  nth_rewrite 0 [\u2190 int.div_eq_of_eq_mul_right (sub_ne_zero.2 eq1) this], \n  rw \u2190 int.add_div_of_dvd_left (dvd.intro _ this.symm),\n  ring_exp,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208960,"user_id":null,"body":"import Preloaded\nimport tactic\n\/--\nimport algebra.group_power\n\ndef geom_sum : \u2115 \u2192 \u2124 \u2192 \u2124\n| 0     z := 1\n| (n+1) z := z^(n+1) + geom_sum n z\n\ndef geom_formula (n : \u2115) (z : \u2124) : \u2124 :=\nif z = 1 then n+1 else (z^(n+1) - 1) \/ (z - 1)\n\ndef SUBMISSION : Prop := \u2200 n z, geom_sum n z = geom_formula n z\nnotation `SUBMISSION` := SUBMISSION\n--\/\n\nlemma n1geo (n z) :(z-1)\u2260 0 \u2192 (z-1)*geom_sum n z = z^(n+1)-1 :=\nbegin\nintro hzm1nz, \ninduction n with n ih,\n  simp [geom_sum],\n  rw [geom_sum,mul_add,ih,nat.succ_eq_add_one], \nring, \nhave : z^(n+1)*z=z^(n+2), \nring, rw this\nend\n\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\nby_cases h: z =1,\n  rw geom_formula,split_ifs,\n  induction n with n ih, \n    simp [geom_sum],\n    rw [geom_sum,ih,h,one_pow], norm_cast,ring,\n  have zm1nz: z-1 \u2260 0,\n    intro h1, have : z=1, rw int.sub_eq_zero_iff_eq at h1, exact h1, exact h this,\n  have mh: (z-1)*geom_sum n z = z^(n+1)-1, exact n1geo n z zm1nz,\n  rw geom_formula, \n  split_ifs,\n  rw \u2190 mh, rw mul_comm, symmetry,\n  apply int.mul_div_cancel (geom_sum n z) zm1nz\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208961,"user_id":null,"body":"import Preloaded tactic\n\n\/--\nimport algebra.group_power\n\ndef geom_sum : \u2115 \u2192 \u2124 \u2192 \u2124\n| 0     z := 1\n| (n+1) z := z^(n+1) + geom_sum n z\n\ndef geom_formula (n : \u2115) (z : \u2124) : \u2124 :=\nif z = 1 then n+1 else (z^(n+1) - 1) \/ (z - 1)\n\ndef SUBMISSION : Prop := \u2200 n z, geom_sum n z = geom_formula n z\nnotation `SUBMISSION` := SUBMISSION\n--\/\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\n  let z1 := (z=1),\n  by_cases z1,\n  {\n    have : z=1 := h,\n    rw this,\n    induction n with n hn,\n    {\n      simp [geom_sum,geom_formula],\n    },\n    {\n      simp [geom_sum,geom_formula] at *,\n      rw hn,\n      ring,\n    }\n  },\n  {\n    have : (z1)=false := eq_false_intro h,\n    have z1' : z-1\u2260 0,\n    {\n      intro hz,\n      rw int.sub_eq_zero_iff_eq at hz,\n      exact h hz,\n    },\n    induction n with n hn,\n    {\n      simp [geom_sum,geom_formula],\n      change 1 = ite z1 1 ((z-1)\/(z-1)),\n      simp [this],\n      symmetry,\n      apply int.div_eq_of_eq_mul_left z1',\n      rw one_mul,\n    },\n    simp [geom_sum,geom_formula,hn],\n    change z ^ (n + 1) + ite (z1) (\u2191n + 1) ((z ^ (n + 1) - 1) \/ (z - 1)) = ite (z1) (\u2191n + 1 + 1) ((z ^ (n.succ + 1) - 1) \/ (z - 1)),\n    simp only [this, if_false],\n    rw add_comm,\n    rw \u2190 int.add_mul_div_left _ _ z1',\n    have : z ^ (n + 1) - 1 + (z - 1) * z ^ (n + 1) = z ^ (n.succ + 1) - 1,\n    ring_nf,\n    rw this,\n  }\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208962,"user_id":null,"body":"import Preloaded\nimport algebra.group_power\nimport data.int.basic\nimport tactic\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z := by{\n  induction n with n,{\n    simp[geom_sum,geom_formula],\n    split_ifs,{\n      refl\n    },{\n      symmetry,\n      have h\u2081:z-1\u22600,{\n        exact sub_ne_zero.mpr h,\n      },\n      exact int.div_self h\u2081,\n    },\n  },{\n    simp[geom_sum,geom_formula],\n    split_ifs;simp[n_ih,geom_formula],{\n      simp[h],\n      exact add_comm 1 (\u2191n + 1),\n    },{\n      split_ifs,{\n        have h\u2081:z-1\u22600,{\n        exact sub_ne_zero.mpr h,\n        },\n        let a:=z^(n+1),\n        let b:=z-1,\n        from calc\n          a + (a - 1) \/ b = \n          (a*b+a-1)\/b:by {\n            have h\u2082:a*b+a-1=a*b+(a-1),{\n              ring,\n            },\n            have h\u2083:(a * b + (a - 1))=((a-1)+a*b),{\n              ring,\n            },\n            rw [h\u2082,h\u2083],\n            symmetry,\n            have h\u2085:b\u22600,{exact h\u2081},\n            have h\u2084:(a - 1 + a * b) \/ b=(a-1)\/b+a,{\n              exact int.add_mul_div_right (a-1) a h\u2085,\n            },\n            simp [h\u2084],\n            apply add_comm,\n          }\n          ...=(a*z-1)\/b:by{\n            have h\u2082:a*b+a-1=a*z-1,{\n              simp[a,b],\n              ring,\n            },\n            simp[h\u2082],\n          }\n          ...=(z ^ (n.succ + 1) - 1) \/ (z - 1) : by{\n            simp [a,b],\n            \/-\n            z : \u2124,\n            n : \u2115,\n            n_ih : geom_sum n z = geom_formula n z,\n            h : \u00acz = 1,\n            h\u2081 : z - 1 \u2260 0,\n            a : \u2124 := z ^ (n + 1),\n            b : \u2124 := z - 1\n            \u22a2 (z ^ (n + 1) * z - 1) \/ (z - 1) = (z ^ (n.succ + 1) - 1) \/ (z - 1)\n            -\/\n            have h\u2082:z ^ (n + 1) * z=z ^ (n.succ + 1),{\n              exact mul_comm (z ^ (n + 1)) z,\n            },\n            simp[h\u2082],\n          }     \n      }\n    }\n  }\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208963,"user_id":null,"body":"import Preloaded algebra.group_power \nimport tactic tactic.induction\n\nlemma zdiv : \u2200(n : \u2115) (z : \u2124), (z - 1 ) \u2223 (z^(n+1) - 1) :=\nbegin\n  intros n z,\n  induction' n,\n  { use 1, simp [mul_one] }, \n  { cases' ih z with d hd,\n    use d * z + 1,\n    rw [nat.succ_eq_add_one, mul_add, \u2190mul_assoc, \u2190hd],\n    ring_nf },\nend\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\n  by_cases hz : z = 1,\n  { induction' n;\n      simp [geom_sum, geom_formula, hz],\n      simp [geom_sum, geom_formula, hz, ih 1], ring_nf },\n  { have hz' := hz,\n    rw \u2190sub_eq_zero at hz,    \n    induction' n,\n    { simp [geom_sum, geom_formula, hz] },\n    { simp [geom_sum, geom_formula, hz, hz', ih z, nat.succ_eq_add_one], \n      rw [\u2190mul_left_inj' hz, add_mul],\n      rw [int.div_mul_cancel (zdiv n z)], \n      rw [int.div_mul_cancel (zdiv (n+1) z)], \n      ring_nf } }, \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208964,"user_id":168,"body":"import Preloaded tactic\n\nlemma mul_geom_sum (n z) : z * geom_sum n z = geom_sum n.succ z - 1 :=\nbegin\n  induction n with n ih,\n  { simp only [geom_sum], rw [zero_add, add_sub_cancel], refl },\n  rw [geom_sum, geom_sum, mul_add, ih, \u2190pow_succ, add_sub]\nend\n\nlemma geom_sum_1 (n) : geom_sum n 1 = n + 1 :=\nbegin\n  induction n with n ih, refl,\n  rw [geom_sum, ih, one_pow, add_comm, int.coe_nat_succ]\nend\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\n  by_cases z = 1, { rw [h, geom_sum_1], refl },\n  have hz : z - 1 \u2260 0, { intro h1, apply h, exact sub_eq_zero.mp h1 },\n  simp only [geom_formula, h, if_false], symmetry,\n  apply int.div_eq_of_eq_mul_left hz,\n  rw [mul_sub, mul_comm, mul_geom_sum, geom_sum], ring\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208965,"user_id":null,"body":"import Preloaded\nimport tactic \nimport data.nat.basic \nimport data.int.basic\nimport data.rat.basic\n\nlemma geom_formula_dvd (z : \u2124) (n : \u2115) : (z - 1) \u2223 (z ^ (n + 1) - 1) :=\nbegin \n  induction n with n ih,\n  { ring },\n  { cases ih with k hk,\n    have := calc \n      z ^ (n + 2) - 1 = z * z ^ (n + 1) - 1 : by rw pow_succ\n        ... = z * (z ^ (n + 1) - 1) + (z - 1) : by ring\n        ... = z * ((z - 1) * k) + (z - 1) : by rw hk\n        ... = (z - 1) * (z * k + 1) : by ring,\n    rw this,\n    use (z * k + 1), }\nend \n\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin \n  induction n with n ih,\n  { \n    cases em (z = 1), \n    { simp [geom_sum, geom_formula, h] },\n    { simp [geom_sum, geom_formula, h], \n      have : z - 1 \u2260 0  := sub_ne_zero.mpr h,\n      rwa int.div_self } },\n  { cases em (z = 1),\n    { simp [geom_sum, geom_formula, h] at ih \u22a2,\n      rw ih,\n      ring, },\n    { simp [geom_sum, geom_formula, h] at ih \u22a2,\n      rw ih,\n      clear ih, \n      have : z - 1 \u2260 0 := sub_ne_zero.mpr h,\n      have hz : (\u2191z - 1 : \u211a) \u2260 0  := \u03bb h, by { norm_cast at h },\n      suffices : \u2200 r : \u211a, (r-1)\u22600 \u2192 r^(n+1) + (r^(n+1)-1)\/(r-1) = (r^(n.succ+1)-1)\/(r-1),\n        { have := this z hz , \n          norm_cast at this, \n          rw [rat.mk_eq_div, rat.mk_eq_div,\n              \u2190 rat.coe_int_div _ _ (geom_formula_dvd z n), \n              \u2190 rat.coe_int_div _ _ (geom_formula_dvd z n.succ)] at this, \n          norm_cast at this,\n          exact this  },\n      intros r hr,\n      calc r^(n+1)+(r^(n+1)-1) \/ (r-1) \n             = (r^(n+1) * (r-1) + (r^(n+1)-1)) \/ (r-1) : add_div' _ _ _ hr\n         ... =(r^(n.succ+1) - 1) \/ (r-1) : by { rw pow_succ r n.succ, ring }\n    } }\nend \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208966,"user_id":null,"body":"import Preloaded tactic\n\n\/--\nimport algebra.group_power\n\ndef geom_sum : \u2115 \u2192 \u2124 \u2192 \u2124\n| 0     z := 1\n| (n+1) z := z^(n+1) + geom_sum n z\n\ndef geom_formula (n : \u2115) (z : \u2124) : \u2124 :=\nif z = 1 then n+1 else (z^(n+1) - 1) \/ (z - 1)\n\ndef SUBMISSION : Prop := \u2200 n z, geom_sum n z = geom_formula n z\nnotation `SUBMISSION` := SUBMISSION\n--\/\n\ntheorem geom_eq (n z) : geom_sum n z = geom_formula n z :=\nbegin\n  unfold geom_formula,\n  split_ifs;\n  induction n with n ih,\n  refl,\n  subst h,\n  unfold geom_sum,\n  rw ih,\n  simp,\n  apply add_comm,\n  simp [geom_sum],\n  rw int.div_self,\n  change \u00ac (z - 1 = 0),\n  rwa sub_eq_zero,\n  unfold geom_sum,\n  rw ih,\n  rw [add_comm, \u2190 int.add_mul_div_left, \u2190 nat.add_one],\n  ring,\n  change \u00ac (z - 1 = 0),\n  rwa sub_eq_zero,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5cc47f8c4b8fea001de6d226":[{"id":208967,"user_id":659,"body":"import Preloaded data.set.basic tactic\n\n\/-! ### Lemmas about mult_3' -\/\n\nopen mult_3'\n\nattribute [simp] mult_3'_21 -- so the below proof works\n\n\/-- 0 \u2208 mult_3' -\/\n@[simp] lemma zero_mem' : mult_3' 0 :=\nbegin\n  apply mult_3'_difference 0 21 21;\n  simp\nend\n\nattribute [simp] mult_3'_30\n\n\/-- 9 \u2208 mult_3' -\/\n@[simp] lemma nine_mem' : mult_3' 9 :=\nbegin\n  apply mult_3'_difference 9 21 30;\n  simp\nend\n\n\/-- 12 \u2208 mult_3' -\/\n@[simp] lemma twelve_mem' : mult_3' 12 :=\nbegin\n  apply mult_3'_difference 12 9 21;\n  simp\nend\n\n\/-- 3 \u2208 mult_3' -\/\n@[simp] lemma three_mem' : mult_3' 3 :=\nbegin\n  apply mult_3'_difference 3 9 12;\n  simp\nend\n\n\/-- mult_3' closed under +3 -\/\nlemma add_three_mem'_of_mem' (n : \u2115) (hn : n \u2208 mult_3') : n + 3 \u2208 mult_3' :=\nmult_3'_sum _ _ hn three_mem'\n\n\/-- Every element of mult_3' is a multiple of 3 -\/\nlemma three_dvd_of_mem' {n : \u2115} (hn : n \u2208 mult_3') : 3 \u2223 n :=\nbegin\n  -- check all the cases\n  induction hn with x y _ _ hx hy a b c _ _ ha hb hc,\n  { -- 30 is a multiple of 3\n    use 10, norm_num,\n  },\n  { -- 21 is a multiple of 3\n    use 7, norm_num\n  },\n  { -- if three divides two things it divides their sum\n    exact dvd_add hx hy,\n  },\n  { -- if three divides two things it divides their difference\n    convert nat.dvd_sub _ hc hb,\n    -- pick up the pieces\n    { rw \u2190ha, simp},\n    { rw \u2190ha, simp}\n  }\nend\n\n\n\/-- main theorem -\/\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  -- It suffices to prove inclusions in both directions\n  apply set.subset.antisymm,\n  { -- \u2286\n    -- say x : \u2115\n    intro x,\n    -- let's do strong induction on x to prove x \u2208 mult_3 \u2192 x \u2208 mult_3'\n    apply nat.strong_induction_on x, clear x, intro x,\n    -- So let's assume that for all m < x, m \u2208 mult_3 \u2192 m \u2208 mult_3'\n    intro hm,\n    -- and let's assume x \u2208 mult_3\n    intro hx,\n    -- Let's consider the cases for x \u2208 mult_3\n    cases hx with a ha,\n    -- if x = 0 then we already dealt with this.\n      exact zero_mem',\n    -- if x = a + 3 and a \u2208 mult_3 then because mult_3' is closed under +3\n    -- it suffices to prove that a \u2208 mult_3'\n    apply add_three_mem'_of_mem',\n    -- and by the strong induction procedure\n    apply hm a,\n    -- and the observation that a < a + 3\n      show a < a + 3, by linarith,\n    -- it suffices to prove a \u2208 mult_3' which is an assumption\n    assumption,\n  },\n  { -- \u2287\n    -- say x : \u2115\n    intros x hx,\n    -- By a previous lemma, if x \u2208 mult_3' then 3 \u2223 x\n    replace hx := three_dvd_of_mem' hx,\n    -- so say x = 3k and now we induct on k\n    cases hx with k hk, rw hk, clear hk x,\n    induction k with d hd,\n    -- base case : 0 \u2208 mult_3\n      exact mult_3.mult_3_O,\n    -- induction step\n    exact mult_3.mult_3_SSS _ hd,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208968,"user_id":null,"body":"import tactic\nimport Preloaded\n\nopen mult_3\nopen mult_3'\n\nlemma mult_3_3 : \u2200 {n}, n \u2208 mult_3 \u2194 3 \u2223 n := begin\n  intro n,\n  split; intro H,\n  {\n    induction H with k H K; finish,\n  },\n  rcases H with \u27e8k, rfl\u27e9,\n  induction k with k K,\n  exact mult_3_O,\n  apply mult_3_SSS (3*k) K,\nend\n\nlemma mult_3'0 : mult_3' 0 := begin\n  apply mult_3'_difference 0 30 30; fconstructor,\nend\n\nlemma mult_3'3 : mult_3' 3 := begin\n  have h : mult_3' 9 := by\n    apply mult_3'_difference 9 21 30; fconstructor,\n  have h' : mult_3' 18 := by\n    apply mult_3'_sum 9 9; assumption,\n  apply mult_3'_difference 3 18 21, swap,\n  exact mult_3'_21,\n  assumption,\n  norm_num,\nend\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' := begin\n  ext,\n  split; intro H,\n  {\n    induction H with n H K,\n    exact mult_3'0,\n    apply mult_3'_sum,\n    assumption,\n    exact mult_3'3,\n  },\n  {\n    induction H with n m H K h k l n m H K Q h k,\n    repeat {fconstructor},\n    rw [mult_3_3] at *,\n    apply dvd_add; assumption,\n    rw [mult_3_3] at *,\n    have : l = m - n := eq_tsub_of_add_eq Q,\n    rw this,\n    exact nat.dvd_sub' k h,\n  },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208969,"user_id":null,"body":"import Preloaded tactic.norm_num\n\nopen mult_3 mult_3'\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  have m3_def : \u2200 (n : \u2115), mult_3 n \u2194 3 \u2223 n ,\n  { intro n, \n    split,\n    { intro hn,\n      induction hn with _ _ three_dvd,\n      { norm_num, },\n      { exact nat.dvd_add three_dvd (by norm_num), }, }, \n    { rintros \u27e8k, rfl\u27e9,\n      induction k with k IH, \n      { exact mult_3_O, },\n      { exact mult_3_SSS (3 * k) IH, }, }, },\n  suffices : \u2200 (n : \u2115), mult_3' n \u2194 3 \u2223 n, by {ext, rw [set.mem_def, set.mem_def, this, m3_def]},\n  intro n,\n  split,\n  { intro hn,\n    apply mult_3'.rec_on hn,\n    repeat { norm_num, },\n    { intros _ _ _ _ hn hm,\n      exact dvd_add hn hm, },\n    { rintros _ _ _ _ _ rfl hn hm, \n      exact (nat.dvd_add_left hn).1 hm, }, },\n  { rintro \u27e8k, rfl\u27e9,\n    induction k with j hj',\n    { exact mult_3'_difference 0 30 30 mult_3'_30 mult_3'_30 (by tauto), },\n    { apply mult_3'_sum (3 * j) 3 hj',\n      have mult3'_9 := mult_3'_difference 9 21 30 mult_3'_21 mult_3'_30 (by tauto),\n      apply mult_3'_difference 3 9 12 mult3'_9 (mult_3'_difference 12 9 21 mult3'_9 mult_3'_21 _),\n      repeat {tauto}, }, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208970,"user_id":null,"body":"import Preloaded\nimport data.set.basic\nimport tactic.ring\n\ntheorem zero : mult_3' 0:=\nbegin\n  apply mult_3'.mult_3'_difference 0 21 21,\n  any_goals {exact mult_3'.mult_3'_21},\n  simp,\nend\n\ntheorem three : mult_3' 3 :=\nbegin\n  have : mult_3' 9,\n  { apply mult_3'.mult_3'_difference 9 21 30,\n    exact mult_3'.mult_3'_21,\n    exact mult_3'.mult_3'_30,\n    simp,},\n  have : mult_3' 12,\n  { apply mult_3'.mult_3'_difference 12 9 21,\n    assumption,\n    exact mult_3'.mult_3'_21,\n    simp,},\n  apply mult_3'.mult_3'_difference 3 9 12,\n  assumption,\n  assumption,\n  simp,\nend\n\ntheorem mult_3_mul (n : \u2115) : mult_3 (3 * n) :=\nbegin\n  induction n with n hn,\n  { rw nat.mul_zero,\n    exact mult_3.mult_3_O,},\n    rw nat.mul_succ,\n    apply mult_3.mult_3_SSS,\n    exact hn,\nend\n\ntheorem mult_3_sum (l m n : \u2115) : mult_3 n \u2192\n    mult_3 m \u2192\n    l + n = m \u2192\n    mult_3 l :=\nbegin\n    intros hn hm sum,\n    revert l n,\n    induction hm with d hd hd',\n    { intros a b hb sum,\n      have : a = 0,\n      simp at sum,\n      exact sum.left,\n      rw this,\n      exact mult_3.mult_3_O,},\n    { intros a b hb sum,\n      induction hb with e he sum_e,\n      { rw nat.add_zero at sum,\n        rw sum,\n        apply mult_3.mult_3_SSS,\n        assumption,},\n      have hyp:= hd' a e,\n      apply hyp,\n      assumption,\n      rw [\u2190 nat.add_assoc] at sum,\n      apply nat.add_right_cancel sum,},\nend\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  apply set.eq_of_subset_of_subset,\n  any_goals {rw set.subset_def,\n    intro x},\n  { intro h,\n    induction h with n m m',\n    { exact zero},\n    { apply mult_3'.mult_3'_sum,\n      exact m',\n      exact three,},},\n  { intro h',\n    induction h' with n m hn' hm' hn hm a b c hb' hc' sum hb hc,\n    { have m30: mult_3 (3 * 10) := by exact mult_3_mul 10,\n    have m30': 3 * 10 =30 := by ring, \n    rw m30' at m30,\n    exact m30},\n    { have m21: mult_3 (3 * 7) := by exact mult_3_mul 7,\n    have m21': 3 * 7 =21 := by ring, \n    rw m21' at m21,\n    exact m21},\n    { induction hm with p hp hp',\n      { rw nat.add_zero,\n        exact hn,},\n      { rw \u2190 nat.add_assoc,\n        apply mult_3.mult_3_SSS,\n        apply hp',\n        apply mult_3'.mult_3'_difference p 3 (p + 3),exact three,\n        assumption,\n        refl,},},\n    { apply mult_3_sum a c b,\n      all_goals{assumption},}},\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208971,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlemma first (n : \u2115) : n \u2208 mult_3 \u2194 \u2203 m , n = 3*m :=\nbegin\n  split,\n  intro hn,\n  induction hn with n hn ih,\n  use 0,\n  refl,\n  cases ih with m hm,\n  use m+1,\n  rw [hm,mul_add],\n  refl,\n  rintro \u27e8 m, hm\u27e9 ,\n  rw hm,\n  clear hm,\n  induction m with m ih,\n  rw mul_zero,\n  exact mult_3.mult_3_O,\n  have : 3*m.succ = 3*m + 3,\n  rw [nat.succ_eq_add_one,mul_add],\n  refl,\n  rw this,\n  exact mult_3.mult_3_SSS _ ih,\nend \n\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  ext,\n  split,\n  {\n    intro hx,\n    induction hx with x hx ih,\n    {\n      apply mult_3'.mult_3'_difference 0 21 21,\n      exact mult_3'.mult_3'_21,\n      exact mult_3'.mult_3'_21,\n      refl,\n    },\n    {\n      have h21 : mult_3' 21 := mult_3'.mult_3'_21,\n      have h30 : mult_3' 30 := mult_3'.mult_3'_30,\n      have h42 : mult_3' 42 := mult_3'.mult_3'_sum 21 21 h21 h21,\n      have h63 : mult_3' 63 := by apply mult_3'.mult_3'_sum 42 21 h42 h21,\n      have h60 : mult_3' 60 := mult_3'.mult_3'_sum 30 30 h30 h30,\n      have h3 : mult_3' 3 := mult_3'.mult_3'_difference 3 60 63 h60 h63 rfl,\n      exact mult_3'.mult_3'_sum x 3 ih h3,\n    }\n  },\n  {\n    intro hx,\n    induction hx with x y _ _ hx hy w y z _ _ hw hy hz,\n    {\n      repeat {apply mult_3.mult_3_SSS _},\n      exact mult_3.mult_3_O,\n    },\n    {\n      repeat {apply mult_3.mult_3_SSS _},\n      exact mult_3.mult_3_O,\n    },\n    {\n      clear hx_\u1fb0 hx_\u1fb0_1,\n      rw first _ at \u22a2 hx hy,\n      cases hx with n hn,\n      cases hy with m hm,\n      use n+m,\n      rw [hn, hm,mul_add],\n    },\n    {\n      clear x hx_\u1fb0 hx_\u1fb0_1,\n      rw first _ at \u22a2 hy hz,\n      cases hz with n hn,\n      cases hy with m hm,\n      use n-m,\n      rw [nat.mul_sub_left_distrib,\u2190 hn,\u2190 hm],\n      exact eq_tsub_of_add_eq hw,\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208972,"user_id":null,"body":"import Preloaded tactic\n\ndef m3 : set \u2115 := { n | \u2203 k, n = 3 * k }\n\nlemma lemma1 : mult_3 = m3 :=\nbegin\n  ext,\n  split,\n  { intros h,\n    induction h with d h1 h2,\n    { use 0, norm_num },\n    { cases h2 with k hk,\n      use k + 1, rw hk, ring } },  \n  intros h,\n  cases h with k hk, \n  revert x,\n  induction k with d hd,    \n  { intros x hx, \n    rw hx, norm_num, exact mult_3.mult_3_O },\n  intros k hk,\n  rw [hk, nat.mul_succ],\n  apply mult_3.mult_3_SSS,\n  apply hd (3 * d) rfl,\nend\n\nlemma lemma2 : m3 = mult_3' :=\nbegin\n  ext,\n  split,\n  { intros h,\n    have c9 := mult_3'.mult_3'_difference 9 21 30 mult_3'.mult_3'_21 mult_3'.mult_3'_30 (by norm_num),\n    have c18 := (mult_3'.mult_3'_sum 9 9 c9 c9), norm_num at c18,\n    have c3 := mult_3'.mult_3'_difference 3 18 21 c18 mult_3'.mult_3'_21 (by norm_num),\n    have c0 := mult_3'.mult_3'_difference 0 3 3 c3 c3 (by norm_num),\n    cases h with d hd,    \n    revert x,\n    induction d,\n    { intros x hx, norm_num at hx, rwa hx },\n    intros x hx,\n    rw [hx, nat.mul_succ],\n    apply mult_3'.mult_3'_sum, \n    apply d_ih (3 * d_n) rfl, \n    assumption },\n  intros h,\n  induction h with h1 h2 h3 h4 h5 h6 h1 h2 h3 h4 h5 h6 h7 h8,\n  { use 10, norm_num },\n  { use 7, norm_num },\n  { cases h5 with m1 hm1,\n    cases h6 with m2 hm2,\n    use m1 + m2,\n    rw [hm1, hm2, mul_add] },\n  cases h7 with m2 hm2,\n  cases h8 with m3 hm3,  \n  use m3 - m2,  \n  rw [nat.mul_sub_left_distrib, \u2190hm2, \u2190hm3, \u2190h6],  \n  rw nat.add_sub_cancel,\nend\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' := \n  eq.trans lemma1 lemma2","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208973,"user_id":null,"body":"import Preloaded tactic\n\nopen mult_3 mult_3'\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  ext n,\n  split,\n  intro p,\n  induction p with n p ih,\n  apply mult_3'_difference 0 21 21; constructor,\n  apply mult_3'_sum n 3 ih,\n  apply mult_3'_difference 3 18 21,\n  apply mult_3'_sum 9 9;\n  apply mult_3'_difference 9 21 30,\n  any_goals {constructor},\n  intro p,\n  have q : \u2203 k, 3*k = n,\n  induction p with n m p_n p_m n_ih m_ih l n m p_n p_m sum n_ih m_ih,\n  use 10, refl,\n  use 7, refl,\n  cases n_ih with k_n n_ih,\n  cases m_ih with k_m m_ih,\n  use k_n + k_m,\n  linarith,\n  cases n_ih with k_n n_ih,\n  cases m_ih with k_m m_ih,\n  use k_m - k_n,\n  rw [nat.mul_sub_left_distrib, n_ih, m_ih, nat.sub_eq_iff_eq_add, sum],\n  rw \u2190 sum,\n  apply nat.le_add_left,\n  cases q with k q,\n  rw \u2190 q,\n  clear q p n,\n  induction k with k ih;\n  constructor,\n  exact ih,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208974,"user_id":null,"body":"import Preloaded data.set.basic tactic\n\nopen mult_3 mult_3'\n\nlemma three' : mult_3' 3 :=\nbegin\n  apply mult_3'_difference 3 9 12, swap,\n  apply mult_3'_difference 12 9 21,\n  any_goals { apply mult_3'_difference 9 21 30 },\n  any_goals { simp [mult_3'_21, mult_3'_30] },\nend\n\nlemma zero' : mult_3' 0 := mult_3'_difference 0 3 3 three' three' dec_trivial\n\nlemma mult_3_sum {y z : \u2115} (h\u2081 : mult_3 y) (h\u2082 : mult_3 z) : mult_3 (y+z) :=\nbegin\n  induction h\u2082,\n  case mult_3_O { apply h\u2081 },\n  case mult_3_SSS : _ _ h { apply mult_3_SSS, exact h, }\nend\n\nlemma mult_3_difference {a b c : \u2115} (hb : mult_3 b) (hc : mult_3 c) (h : a + b  = c) : mult_3 a :=\nbegin\n  induction hb generalizing c,\n  case mult_3_O { rw \u2190h at hc, apply hc, },\n  case mult_3.mult_3_SSS : y hy ih { \n    cases hc with p hp,\n    { linarith, },\n    { apply ih hp, simp only [nat.succ_eq_add_one, add_zero, nat.add_def] at hc h, linarith, }, }\nend\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  ext x, split,\n  { intro h, induction h, \n    case mult_3_O { exact zero' },\n    case mult_3.mult_3_SSS : _ _ h { exact mult_3'_sum _ _ h three', } },\n  { intro h, induction h with _ _ _ _ hy hz _ _ _ _ _ h hb hc,\n    any_goals { repeat { apply mult_3_SSS }, exact mult_3_O, },\n    { exact mult_3_sum hy hz, },\n    { exact mult_3_difference hb hc h }, }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208975,"user_id":null,"body":"import Preloaded tactic\n\n\nlemma mult_3'_multiple : \u2200 n m : \u2115, mult_3' n \u2192 mult_3' (n*m.succ) :=\nbegin\n  intros n m, induction m with m hm,\n  rw mul_one, intro h, exact h,\n  rw nat.mul_succ, intro h, exact mult_3'.mult_3'_sum _ _ (hm h) h,\nend\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nbegin\n  ext, split,\n  have d := mult_3'.mult_3'_difference,\n  have m30 := mult_3'.mult_3'_30,\n  have m21 := mult_3'.mult_3'_21,\n  intro h, apply mult_3.rec_on h,\n  apply d 0 _ _ m30 m30 (zero_add 30),\n  intros n _ hn, apply d _ 60 (n+63) _ _ _,\n  exact mult_3'_multiple 30 1 m30,\n  apply mult_3'.mult_3'_sum, exact hn,\n  exact mult_3'_multiple 21 2 m21, simp,\n\n  have SSS := mult_3.mult_3_SSS,\n  intro h, apply mult_3'.rec_on h,\n  repeat {apply SSS},\n  exact mult_3.mult_3_O, exact mult_3.mult_3_O,\n  intros n m _ _ hn hm, clear a a_1,\n  induction hm with n' hn' hnn', exact hn, exact SSS _ hnn',\n  intros l n m _ _ hsum hn hm, clear h x a a_1,\n  revert n, induction hm with m hm hnm, intros n hsum,\n  rw add_eq_zero_iff at hsum, rw hsum.1, intro, exact mult_3.mult_3_O,\n  intros n hsum hn, induction hn with n hn,\n  rw add_zero at hsum, rw hsum, exact SSS m hm,\n  rw [\u2190add_assoc] at hsum, exact hnm n (add_right_cancel hsum) hn,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208976,"user_id":null,"body":"import Preloaded\n\nimport tactic\n\nopen mult_3 mult_3'\n\nlemma mult_3'_of_mult_3 (n : \u2115) (h : mult_3 n) : mult_3' n :=\nhave h0 : mult_3' 0 := mult_3'_difference _ _ _ mult_3'_30 mult_3'_30 (by norm_num),\nhave h9 : mult_3' 9 := mult_3'_difference _ _ _ mult_3'_21 mult_3'_30 (by norm_num),\nhave h12 : mult_3' 12 := mult_3'_difference _ _ _ h9 mult_3'_21 (by norm_num),\nhave h3 : mult_3' 3 := mult_3'_difference _ _ _ h9 h12 (by norm_num),\nbegin\n  induction h with n h IH,\n  { exact h0 },\n  { exact mult_3'_sum _ _ IH h3 }\nend\n\nlemma mult_3_3k (k : \u2115) : mult_3 (3 * k) :=\nbegin\n  induction k with k IH,\n  { exact mult_3_O },\n  { exact mult_3_SSS _ IH },\nend\n\nlemma mult_3_iff (n : \u2115) : mult_3 n \u2194 3 \u2223 n :=\nbegin\n  split,\n  { intro h,\n    induction h with n h IH,\n    { use 0, norm_num },\n    { obtain \u27e8k, hk\u27e9 := IH,\n      use k+1, rw hk, ring } },\n  { rintros \u27e8k, rfl\u27e9, apply mult_3_3k }\nend\n\nlemma mult_3_of_mult_3' (n : \u2115) (h : mult_3' n) : mult_3 n :=\nbegin\n  induction h with n m hn hm IH\u2081 IH\u2082 l n m hn hm h IH\u2081 IH\u2082,\n  { exact mult_3_3k 10 },\n  { exact mult_3_3k 7 },\n  { rw mult_3_iff at \u22a2 IH\u2081 IH\u2082,\n    exact dvd_add IH\u2081 IH\u2082 },\n  { rw mult_3_iff at \u22a2 IH\u2081 IH\u2082,\n    rwa [nat.dvd_add_iff_right IH\u2081, add_comm, h] }\nend\n\ntheorem mult_3_eq_mult_3' : mult_3 = mult_3' :=\nset.ext $ \u03bb x, \u27e8mult_3'_of_mult_3 _, mult_3_of_mult_3' _\u27e9\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5cfd36be4c60c3001b8fb38a":[{"id":208977,"user_id":null,"body":"import Preloaded tactic\nopen tm ty has_type\ninfix ` \u27f6 `:100 := step \n\nlemma nvalue_lem {t : tm} (h : nvalue t) (s : tm) : \u00ac (t \u27f6 s) :=\n\u03bb hts, by induction hts; cases h; cc\n\nlemma lvalue_lem {t : tm} (h : lvalue t) (s : tm) : \u00ac (t \u27f6 s) :=\n\u03bb hts, by induction hts; cases h; simp [*, nvalue_lem] at *\n\nlemma nat_of_nval {t : tm} (h : nvalue t) : \u22a2 t :\u2208 Nat := \nby { induction h, {exact T_Zro}, {exact T_Scc _ h_ih} }\n\nlemma list_of_lval {t : tm} (h : lvalue t) : \u22a2 t :\u2208 List := \nby { induction h, {exact T_Nul}, {exact T_Cns _ _ (nat_of_nval h_\u1fb0) h_ih}, }\n\ntheorem step_deterministic : deterministic step :=\n\u03bb x y1 y2 h1 h2, by induction x generalizing y1 y2; cases h1; cases h2; try { cases h1_\u1fb0, };\n  try { simp only [eq_self_iff_true, true_and, and_true], };\n  exact x_ih_\u1fb0_1 _ _ h1_\u1fb0_1 h2_\u1fb0_1                        <|>\n  exact x_ih_\u1fb0   _ _ h1_\u1fb0   h2_\u1fb0                          <|>\n  exact x_ih     _ _ h1_\u1fb0   h2_\u1fb0                          <|>\n  { cases h2_\u1fb0;   simp [*, nvalue_lem, lvalue_lem] at * } <|> \n  { cases h2_\u1fb0_1; simp [*, nvalue_lem, lvalue_lem] at * } <|>\n  { cases h1_\u1fb0_1; simp [*, nvalue_lem, lvalue_lem] at * }\n\ntheorem progress_dec : \u00ac progress :=\nby { unfold progress, push_neg,\n     use [zro.idx nul, Nat, T_Idx _ _ T_Zro T_Nul,                 \n          by { intro h, cases h; cases h }, by { intros _ h, cases h; cases h_\u1fb0; cases h_\u1fb0_1 }] }\n\ntheorem preservation_dec : preservation :=\n\u03bb t t' T ht htt', by induction ht generalizing t'; cases htt'; cases ht_\u1fb0;\n  simp [*, T_Scc, T_Pls, T_Cns, T_Zro, T_Len, T_Idx, T_Stn, T_Zro, T_Nul, nat_of_nval, list_of_lval]\n\nlemma soundness_dec : \u00ac soundness :=\nby { unfold soundness, push_neg,\n  use [zro.idx nul, zro.idx nul, Nat, T_Idx _ _ T_Zro T_Nul, multi.multi_refl _,\n    by {rintro \u27e8_, ht\u27e9, cases ht, {cases ht_\u1fb0_1}, {cases ht_\u1fb0}}, by {intro h, cases h; cases h}] }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208978,"user_id":null,"body":"import control.monad.cont\nimport tactic\nimport Preloaded\n\nopen tm ty\n\nlemma nvalue_not_step (t\u2081 t\u2082 : tm)\n      (h\u2081 : t\u2081 \u27f6 t\u2082) (h\u2082 : nvalue t\u2081) :\n  false :=\nbegin\n  induction h\u2082 generalizing t\u2082; cases h\u2081,\n  solve_by_elim\nend\n\nlemma lvalue_not_step (t\u2081 t\u2082 : tm)\n      (h\u2081 : t\u2081 \u27f6 t\u2082) (h\u2082 : lvalue t\u2081) :\n  false :=\nbegin\n  induction h\u2082 generalizing t\u2082; cases h\u2081,\n  { solve_by_elim },\n  { apply nvalue_not_step; assumption }\nend\nopen nat\n\nopen tactic\n\n-- this should probably be PR-ed\nmeta def bt_tac (\u03b1 : Type) :=\n\u2200 r, cont_t r tactic \u03b1\n\nmeta instance : monad bt_tac :=\n{ pure := \u03bb \u03b1 x r, pure x,\n  bind := \u03bb \u03b1 \u03b2 x f r, x r >>= \u03bb a, f a r }\n\nmeta instance : alternative bt_tac :=\n{ failure := \u03bb \u03b1 r _, failure,\n  orelse  := \u03bb \u03b1 x y r f, x _ f <|> y _ f }\n\nmeta def run_bt {\u03b1} (x : bt_tac \u03b1) : tactic \u03b1 :=\nx _ pure\n\nmeta def bt_lift {\u03b1} (x : tactic \u03b1) : bt_tac \u03b1 :=\n\u03bb r f, x >>= f\n\nmeta def var : bt_tac expr :=\nbt_lift mk_mvar\n\nmeta def hyp (p : pexpr) : bt_tac expr := do\np \u2190 bt_lift $ to_expr p,\nls \u2190 bt_lift local_context,\nls.mfirst $ \u03bb h, bt_lift $ do\n  t \u2190 infer_type h,\n  h <$ unify t p\n\n@[interactive]\nmeta def try_apply' : tactic unit :=\nrun_bt $\ndo { x \u2190 var,\n     h \u2190 hyp ``(%%x \u2192 %%x),\n     h' \u2190 hyp ``(%%x),\n     bt_lift $ () <$ apply (h h') } <|>\ndo { x \u2190 var,\n     h \u2190 hyp ``(%%x \u2192 _),\n     h' \u2190 hyp ``(%%x),\n     bt_lift $ () <$ apply (h h') }\n\nexample (i : \u2115) (j : \u2124) (r : \u211a) (g : list nat \u2192 true) (f : \u2124 \u2192 false) : false :=\nby try_apply'\n\n@[interactive]\nmeta def finish_det : tactic unit :=\nrun_bt $ do\n  t \u2190 var,\n  v' \u2190 var,\n  h \u2190 hyp ``(\u2200 v : tm, %%t \u27f6 v \u2192 _ = _),\n  h' \u2190 hyp  ``(%%t \u27f6 %%v'),\n  bt_lift $ rewrite_target (h v' h'); reflexivity\n\n@[interactive]\nmeta def no_step : tactic unit :=\nrun_bt $\ndo { v \u2190 var,\n     h' \u2190 hyp ``(nvalue %%v),\n     h \u2190 hyp ``(%%v \u27f6 _),\n     bt_lift $ () <$ (mk_mapp ``nvalue_not_step [none,none,some h,some h'] >>=\n           cases) } <|>\ndo { v \u2190 var,\n     h \u2190 hyp ``(scc %%v \u27f6 _),\n     bt_lift $ do\n         h' \u2190 get_unused_name `h',\n         h' \u2190 to_expr ``(nvalue (scc %%v)) >>= assert h',\n         solve1 (repeat (() <$ constructor); assumption),\n         () <$ (mk_mapp ``nvalue_not_step [none,none,some h,some h'] >>=\n           cases) } <|>\ndo { h \u2190 hyp ``(zro \u27f6 _),\n     bt_lift $ do\n         () <$ cases h } <|>\ndo { v \u2190 var, vs \u2190 var,\n     h \u2190 hyp ``(cns %%v %%vs \u27f6 _),\n     bt_lift $ do\n         h' \u2190 get_unused_name `h',\n         h' \u2190 to_expr ``(lvalue (cns %%v %%vs)) >>= assert h',\n         solve1 (repeat (() <$ constructor); assumption),\n         () <$ (mk_mapp ``lvalue_not_step [none,none,some h,some h'] >>=\n           cases) } <|>\ndo { h \u2190 hyp ``(nul \u27f6 _),\n     bt_lift $ do\n         () <$ cases h }\n\ntheorem step_deterministic : deterministic step :=\nbegin\n  intros x y\u2081 y\u2082 h\u2081 h\u2082,\n  induction h\u2081 generalizing y\u2082,\n  all_goals\n  { try { cases h\u2082; try { reflexivity }; try { no_step }; try { finish_det }, done, } }\nend\n\ntheorem progress_dec : \u00ac progress :=\nbegin\n  intro H,\n  have H' : \u22a2 idx zro nul :\u2208 Nat,\n  { repeat { constructor } },\n  specialize H _ _ H',\n  rcases H with \u27e8\u27e8 _ | _ \u27e9 | \u27e8 _ | _ \u27e9\u27e9 | \u27e8t', _\u27e9;\n    cases H_h; casesm [nul \u27f6 _, zro \u27f6 _],\nend\n\ntheorem nvalue_has_type (v : tm) (h : nvalue v) :\n  \u22a2 v :\u2208 Nat :=\nby induction h; repeat { constructor }; assumption\n\ntheorem lvalue_has_type (v : tm) (h : lvalue v) :\n  \u22a2 v :\u2208 List :=\nby induction h; repeat { constructor <|> apply nvalue_has_type }; assumption\n\nsection tactic\n\nopen tactic\n\nmeta def find_any_local (p : pexpr) (f : expr \u2192 tactic unit) : tactic unit := do\np \u2190 pexpr_to_pattern p,\nhs \u2190 local_context >>= mfilter (\u03bb h, succeeds $ infer_type h >>= match_pattern p),\nhs.any_of f\n\n@[interactive]\nmeta def value_type : tactic unit := do\n{ `(\u22a2 %%v :\u2208 Nat) \u2190 target,\n  find_any_local ``(nvalue %%v) $ \u03bb h, do\n    mk_app ``nvalue_has_type [h] >>= apply,\n    skip } <|>\ndo { `(\u22a2 %%v :\u2208 List) \u2190 target,\n     find_any_local ``(lvalue %%v) $ \u03bb h, do\n       mk_app ``lvalue_has_type [h] >>= apply,\n       skip }\n\n@[interactive]\nmeta def apply_ih : tactic unit := do\nfind_any_local ``(\u03bb a t, \u2200 v', a \u27f6 v' \u2192 (\u22a2 v' :\u2208 t)) $ \u03bb h, do\n  apply h,\n  assumption\n\n@[interactive]\nmeta def pres_step : tactic unit :=\nassumption <|>\n() <$ constructor <|>\nvalue_type <|>\napply_ih\n\nsetup_tactic_parser\n\n@[interactive]\nmeta def pres_step2 (id : parse ident) : tactic unit :=\n() <$ (get_local id >>= cases); repeat pres_step\n\nexample (v : tm) (h : nvalue v) : \u22a2 v :\u2208 Nat :=\nby value_type\n\nexample (v v\u2082 : tm) (h' : v \u27f6 v\u2082) (h : \u2200 v', v \u27f6 v' \u2192 (\u22a2 v' :\u2208 Nat)) : \u22a2 v\u2082 :\u2208 Nat :=\nby apply_ih\n\nend tactic\n\ntheorem preservation_dec : preservation :=\nbegin\n  introv _ Ht Ht',\n  induction Ht generalizing t',\n  repeat { {pres_step2 Ht' } },\nend\n\nlemma soundness_dec : \u00ac soundness :=\nbegin\n  intro H,\n  have H' : \u22a2 idx zro nul :\u2208 Nat,\n  { repeat { constructor } },\n  specialize H (idx zro nul) (idx zro nul) Nat H' (multi.multi_refl _),\n  apply H, clear H, dsimp [stuck,step_normal_form], split,\n  { rintro \u27e8t', H\u27e9, cases H, cases H_\u1fb0_1, cases H_\u1fb0 },\n  { rintro (\u27e8 \u27e8 \u27e9 \u27e9 | \u27e8 \u27e8 \u27e9 \u27e9), }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208979,"user_id":168,"body":"import Preloaded tactic\n\nopen tm ty\ninfix ` \u27f6 `:100 := step \n\nlemma nvalue_no_step {v} (hv : nvalue v) : \u2200 x, \u00ac v \u27f6 x :=\nby intros x h; induction hv generalizing x; cases h; exact hv_ih _ h_a\n\nlemma lvalue_no_step {v} (hv : lvalue v) : \u2200 x, \u00ac v \u27f6 x :=\nbegin\n  induction hv; intros x h; cases h,\n  { exact hv_ih _ h_a_1 },\n  { exact nvalue_no_step hv_a _ h_a }\nend \n\nlemma zro_no_step : \u2200 x, \u00ac zro \u27f6 x := by intros x h; cases h\n\nlemma scc_no_step {n} (hn : nvalue n) : \u2200 x, \u00ac scc n \u27f6 x :=\nby intros x; apply nvalue_no_step; constructor; assumption\n\nlemma nul_no_step : \u2200 x, \u00ac nul \u27f6 x := by intros x h; cases h\n\nlemma cns_no_step {n v} (hn : nvalue n) (hv : lvalue v) : \u2200 x, \u00ac cns n v \u27f6 x :=\nby apply lvalue_no_step; constructor; assumption\n\ntheorem step_deterministic : deterministic step :=\nbegin\n  intros x y1 y2 h1 h2, revert y2, induction h1; intros y2 h2; cases h2;\n  try { solve_by_elim [nvalue_no_step, zro_no_step, scc_no_step, nul_no_step ]};\n  try { congr, apply h1_ih, assumption };\n  exfalso; apply cns_no_step _ _ _ (by assumption : _); assumption\nend\n\ndef term := idx zro nul\n\nlemma not_value_term : \u00ac value term := by intro h; cases h; cases h\n\nlemma term_type : \u22a2 term :\u2208 Nat := by repeat { constructor }\n\nlemma no_step_term : \u2200 x, \u00ac term \u27f6 x :=\nby intros x h; cases h; solve_by_elim [zro_no_step, nul_no_step]\n\ntheorem progress_dec : \u00ac progress :=\nbegin\n  intro h, specialize h _ _ term_type, cases h,\n  { exact not_value_term h },\n  { cases h with x h, exact no_step_term x h }\nend\n\nlemma nvalue_in_nat {v} (hv : nvalue v) : \u22a2 v :\u2208 Nat :=\nby induction hv; constructor; assumption\n\nlemma lvalue_in_list {v} (lv : lvalue v) : \u22a2 v :\u2208 List :=\nby induction lv; constructor; try { apply nvalue_in_nat }; assumption\n\ntheorem preservation_dec : preservation :=\nbegin\n  intros t t' T hT hs, revert T, induction hs; intros T hT; cases hT; \n  repeat { constructor }; solve_by_elim [nvalue_in_nat, lvalue_in_list]\nend\n\ntheorem soundness_dec : \u00ac soundness :=\nbegin\n  intro h, specialize h _ _ _ term_type (multi.multi_refl _), apply h, split,\n  { rintro \u27e8x, hx\u27e9, exact no_step_term x hx },\n  { exact not_value_term }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208980,"user_id":17,"body":"import control.monad.cont\nimport tactic\nimport Preloaded\n\nopen tm ty\n\n-- Courtesy of @cipher1024\n\nlemma nvalue_not_step (t\u2081 t\u2082 : tm)\n      (h\u2081 : t\u2081 \u27f6 t\u2082) (h\u2082 : nvalue t\u2081) :\n  false :=\nbegin\n  induction h\u2082 generalizing t\u2082; cases h\u2081,\n  solve_by_elim\nend\n\nlemma lvalue_not_step (t\u2081 t\u2082 : tm)\n      (h\u2081 : t\u2081 \u27f6 t\u2082) (h\u2082 : lvalue t\u2081) :\n  false :=\nbegin\n  induction h\u2082 generalizing t\u2082; cases h\u2081,\n  { solve_by_elim },\n  { apply nvalue_not_step; assumption }\nend\nopen nat\n\nopen tactic\n\n-- this should probably be PR-ed\nmeta def bt_tac (\u03b1 : Type) :=\n\u2200 r, cont_t r tactic \u03b1\n\nmeta instance : monad bt_tac :=\n{ pure := \u03bb \u03b1 x r, pure x,\n  bind := \u03bb \u03b1 \u03b2 x f r, x r >>= \u03bb a, f a r }\n\nmeta instance : alternative bt_tac :=\n{ failure := \u03bb \u03b1 r _, failure,\n  orelse  := \u03bb \u03b1 x y r f, x _ f <|> y _ f }\n\nmeta def run_bt {\u03b1} (x : bt_tac \u03b1) : tactic \u03b1 :=\nx _ pure\n\nmeta def bt_lift {\u03b1} (x : tactic \u03b1) : bt_tac \u03b1 :=\n\u03bb r f, x >>= f\n\nmeta def var : bt_tac expr :=\nbt_lift mk_mvar\n\nmeta def hyp (p : pexpr) : bt_tac expr := do\np \u2190 bt_lift $ to_expr p,\nls \u2190 bt_lift local_context,\nls.mfirst $ \u03bb h, bt_lift $ do\n  t \u2190 infer_type h,\n  h <$ unify t p\n\n@[interactive]\nmeta def try_apply' : tactic unit :=\nrun_bt $\ndo { x \u2190 var,\n     h \u2190 hyp ``(%%x \u2192 %%x),\n     h' \u2190 hyp ``(%%x),\n     bt_lift $ () <$ apply (h h') } <|>\ndo { x \u2190 var,\n     h \u2190 hyp ``(%%x \u2192 _),\n     h' \u2190 hyp ``(%%x),\n     bt_lift $ () <$ apply (h h') }\n\nexample (i : \u2115) (j : \u2124) (r : \u211a) (g : list nat \u2192 true) (f : \u2124 \u2192 false) : false :=\nby try_apply'\n\n@[interactive]\nmeta def finish_det : tactic unit :=\nrun_bt $ do\n  t \u2190 var,\n  v' \u2190 var,\n  h \u2190 hyp ``(\u2200 v : tm, %%t \u27f6 v \u2192 _ = _),\n  h' \u2190 hyp  ``(%%t \u27f6 %%v'),\n  bt_lift $ rewrite_target (h v' h'); reflexivity\n\n@[interactive]\nmeta def no_step : tactic unit :=\nrun_bt $\ndo { v \u2190 var,\n     h' \u2190 hyp ``(nvalue %%v),\n     h \u2190 hyp ``(%%v \u27f6 _),\n     bt_lift $ () <$ (mk_mapp ``nvalue_not_step [none,none,some h,some h'] >>=\n           cases) } <|>\ndo { v \u2190 var,\n     h \u2190 hyp ``(scc %%v \u27f6 _),\n     bt_lift $ do\n         h' \u2190 get_unused_name `h',\n         h' \u2190 to_expr ``(nvalue (scc %%v)) >>= assert h',\n         solve1 (repeat (() <$ constructor); assumption),\n         () <$ (mk_mapp ``nvalue_not_step [none,none,some h,some h'] >>=\n           cases) } <|>\ndo { h \u2190 hyp ``(zro \u27f6 _),\n     bt_lift $ do\n         () <$ cases h } <|>\ndo { v \u2190 var, vs \u2190 var,\n     h \u2190 hyp ``(cns %%v %%vs \u27f6 _),\n     bt_lift $ do\n         h' \u2190 get_unused_name `h',\n         h' \u2190 to_expr ``(lvalue (cns %%v %%vs)) >>= assert h',\n         solve1 (repeat (() <$ constructor); assumption),\n         () <$ (mk_mapp ``lvalue_not_step [none,none,some h,some h'] >>=\n           cases) } <|>\ndo { h \u2190 hyp ``(nul \u27f6 _),\n     bt_lift $ do\n         () <$ cases h }\n\ntheorem step_deterministic : deterministic step :=\nbegin\n  intros x y\u2081 y\u2082 h\u2081 h\u2082,\n  induction h\u2081 generalizing y\u2082,\n  all_goals\n  { try { cases h\u2082; try { reflexivity }; try { no_step }; try { finish_det }, done, } }\nend\n\ntheorem progress_dec : \u00ac progress :=\nbegin\n  intro H,\n  have H' : \u22a2 idx zro nul :\u2208 Nat,\n  { repeat { constructor } },\n  specialize H _ _ H',\n  rcases H with \u27e8\u27e8 _ | _ \u27e9 | \u27e8 _ | _ \u27e9\u27e9 | \u27e8t', _\u27e9;\n    cases H_h; casesm [nul \u27f6 _, zro \u27f6 _],\nend\n\ntheorem nvalue_has_type (v : tm) (h : nvalue v) :\n  \u22a2 v :\u2208 Nat :=\nby induction h; repeat { constructor }; assumption\n\ntheorem lvalue_has_type (v : tm) (h : lvalue v) :\n  \u22a2 v :\u2208 List :=\nby induction h; repeat { constructor <|> apply nvalue_has_type }; assumption\n\nsection tactic\n\nopen tactic\n\nmeta def find_any_local (p : pexpr) (f : expr \u2192 tactic unit) : tactic unit := do\np \u2190 pexpr_to_pattern p,\nhs \u2190 local_context >>= mfilter (\u03bb h, succeeds $ infer_type h >>= match_pattern p),\nhs.any_of f\n\n@[interactive]\nmeta def value_type : tactic unit := do\n{ `(\u22a2 %%v :\u2208 Nat) \u2190 target,\n  find_any_local ``(nvalue %%v) $ \u03bb h, do\n    mk_app ``nvalue_has_type [h] >>= apply,\n    skip } <|>\ndo { `(\u22a2 %%v :\u2208 List) \u2190 target,\n     find_any_local ``(lvalue %%v) $ \u03bb h, do\n       mk_app ``lvalue_has_type [h] >>= apply,\n       skip }\n\n@[interactive]\nmeta def apply_ih : tactic unit := do\nfind_any_local ``(\u03bb a t, \u2200 v', a \u27f6 v' \u2192 (\u22a2 v' :\u2208 t)) $ \u03bb h, do\n  apply h,\n  assumption\n\n@[interactive]\nmeta def pres_step : tactic unit :=\nassumption <|>\n() <$ constructor <|>\nvalue_type <|>\napply_ih\n\nsetup_tactic_parser\n\n@[interactive]\nmeta def pres_step2 (id : parse ident) : tactic unit :=\n() <$ (get_local id >>= cases); repeat pres_step\n\nexample (v : tm) (h : nvalue v) : \u22a2 v :\u2208 Nat :=\nby value_type\n\nexample (v v\u2082 : tm) (h' : v \u27f6 v\u2082) (h : \u2200 v', v \u27f6 v' \u2192 (\u22a2 v' :\u2208 Nat)) : \u22a2 v\u2082 :\u2208 Nat :=\nby apply_ih\n\nend tactic\n\ntheorem preservation_dec : preservation :=\nbegin\n  introv _ Ht Ht',\n  induction Ht generalizing t',\n  repeat { {pres_step2 Ht' } },\nend\n\nlemma soundness_dec : \u00ac soundness :=\nbegin\n  intro H,\n  have H' : \u22a2 idx zro nul :\u2208 Nat,\n  { repeat { constructor } },\n  specialize H (idx zro nul) (idx zro nul) Nat H' (multi.multi_refl _),\n  apply H, clear H, dsimp [stuck,step_normal_form], split,\n  { rintro \u27e8t', H\u27e9, cases H, cases H_a_1, cases H_a },\n  { rintro (\u27e8 \u27e8 \u27e9 \u27e9 | \u27e8 \u27e8 \u27e9 \u27e9), }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208981,"user_id":null,"body":"import Preloaded\nimport tactic.basic\nimport tactic.interactive\nimport tactic\n\nopen tm\nopen nvalue\nopen lvalue\nopen step\nopen ty\nopen has_type\n\ninfix ` \u27f6 `:100 := step\n\nlemma zero_contra : \u2200 y, \u00ac zro \u27f6 y :=\nbegin\n  intros y h, cases h\nend\nlemma nval_contra (y z) (h : nvalue y) : \u00ac y \u27f6 z :=\nbegin\n  revert z,\n  induction h with x h ih,\n  exact zero_contra,\n  intros z hx,\n  cases hx,\n  apply ih,\n  assumption\nend\n\nlemma nul_contra : \u2200 y, \u00ac nul \u27f6 y :=\nbegin\n  intros y h, cases h\nend\nlemma lval_contra (y z) (h : lvalue y) : \u00ac y \u27f6 z :=\nbegin\n  revert z,\n  induction h with x xs hx hxs ih,\n  exact nul_contra,\n  intros z hx,\n  cases hx,\n  apply ih,\n  assumption,\n  apply nval_contra,\n  assumption'\nend\nlemma cns_contra (x xs z) (h\u2081 : nvalue x) (h\u2082 : lvalue xs) : \u00ac (x.cns xs) \u27f6 z :=\nbegin\n  apply lval_contra,\n  apply lv_cns,\n  assumption'\nend\n\nlemma nval_Nat (x : tm) (h : nvalue x) : \u22a2 x :\u2208 Nat :=\nbegin\n  induction h,\n  exact T_Zro,\n  apply T_Scc,\n  assumption\nend\nlemma lval_List (x : tm) (h : lvalue x) : \u22a2 x :\u2208 List :=\nbegin\n  induction h,\n  exact T_Nul,\n  apply T_Cns,\n  apply nval_Nat,\n  assumption,\n  assumption\nend\n\n\ntheorem step_deterministic : deterministic step := \nbegin\n  intros x,\n  induction x with n ihn n m ihn ihm x xs ihx ihxs xs ihxs i xs ihi ihxs x ihx;\n  intros y\u2081 y\u2082 hy\u2081 hy\u2082,\n  { cases hy\u2081 },\n  { cases hy\u2081 with _ n' hn',\n    cases hy\u2082 with _ m' hm',\n    have heq : n' = m' := ihn n' m' hn' hm',\n    rw heq },\n  { cases hy\u2081 with n n' hnn' n hn n m hn hm n m m' hn hmm' n n' m hnn';\n    cases hy\u2082 with n n' hnn' n hn n m hn hm n m m' hn hmm' n n' m hnn';\n    try { solve1 { refl } };\n    try { solve1 { have h := zero_contra _ _, contradiction, rotate, assumption } };\n    try { solve1 { have h := nval_contra m _ _ _, contradiction, rotate, assumption' } };\n    try { solve1 { have h := nval_contra n _ _ _, contradiction, rotate, assumption' } };\n    try { solve1 { have h := nval_contra n.scc _ _ _, contradiction, rotate, { apply nv_scc, assumption }, assumption } };\n    try { solve1 { apply congr_arg, apply ihm, assumption' } },\n    { apply congr_arg2, apply ihn, assumption, assumption, refl } },\n  { cases hy\u2081 },\n  { cases hy\u2081; cases hy\u2082;\n    try { solve1 { have h := nval_contra x _ _ _, contradiction, rotate, assumption' } },\n    { apply congr_arg, apply ihxs, assumption' },\n    { apply congr_arg2, apply ihx, assumption, assumption, refl } },\n  { cases hy\u2081 with n n' hnn' n hn n m hn hm n m m' hn hmm' n n' m hnn' x xs xs' hx hxsxs' x x' xs hxx' x xs hx hxs xs xs' hxsxs' i xs hi hxs i x xs hi hx hxs i xs xs' hi hxsxs' i i' xs hii' x hx x x' hxx';\n    cases hy\u2082 with n n' hnn' n hn n m hn hm n m m' hn hmm' n n' m hnn' x xs xs' hx hxsxs' x x' xs hxx' x xs hx hxs xs xs' hxsxs' i xs hi hxs i x xs hi hx hxs i xs xs' hi hxsxs' i i' xs hii' x hx x x' hxx';\n    try { solve1 { refl }, };\n    try { solve1 { have h := nul_contra _ _, contradiction, rotate, assumption' } };\n    try { solve1 { have h := cns_contra x xs xs' _ _ _, contradiction, assumption' } },\n    { apply congr_arg, apply ihxs, assumption' } },\n  { cases hy\u2081 with n n' hnn' n hn n m hn hm n m m' hn hmm' n n' m hnn' x xs xs' hx hxsxs' x x' xs hxx' x xs hx hxs xs xs' hxsxs' i xs hi hxs i x xs hi hx hxs i xs xs' hi hxsxs' i i' xs hii' x hx x x' hxx';\n    cases hy\u2082 with n n' hnn' n hn n m hn hm n m m' hn hmm' n n' m hnn' x xs xs' hx hxsxs' x x' xs hxx' x xs hx hxs xs xs' hxsxs' i xs hi hxs i x xs hi hx hxs i xs xs' hi hxsxs' i i' xs hii' x hx x x' hxx';\n    try { solve1 { refl }, };\n    try { solve1 { have h := nul_contra _ _, contradiction, rotate, assumption' } };\n    try { solve1 { have h := zero_contra _ _, contradiction, rotate, assumption } };\n    try { solve1 { have h := cns_contra x xs xs' _ _ _, contradiction, assumption' } };\n    try { solve1 { have h := cns_contra y\u2081 xs xs' _ _ _, contradiction, assumption' } };\n    try { solve1 { have h := cns_contra y\u2082 xs xs' _ _ _, contradiction, assumption' } };\n    try { solve1 { have h := nval_contra i _ _ _, contradiction, rotate, assumption' } };\n    try { solve1 { have h := nval_contra i.scc _ _ _, contradiction, rotate, { apply nv_scc, assumption }, assumption } };\n    try { apply congr_arg2; try { refl }; try { solve1 { apply ihi, assumption' } }; try { solve1 { apply ihxs, assumption' } } } },\n  { cases hy\u2081; cases hy\u2082;\n    try { solve1 { have h := nval_contra x _ _ _, contradiction, rotate, assumption' } },\n    { refl },\n    { apply congr_arg, apply ihx, assumption' } }\nend\n\n\/- Uncomment one of the following two: -\/\n-- theorem progress_dec : progress := sorry\ntheorem progress_dec : \u00ac progress := \nbegin\n  intro hp,\n  have herror : \u22a2 idx zro nul :\u2208 Nat := T_Idx _ _ T_Zro T_Nul,\n  specialize hp _ _ herror,\n  cases hp,\n  { cases hp;\n    cases hp },\n  cases hp with t ht,\n  cases ht,\n  cases ht_a_1,\n  cases ht_a\nend\n\n\n\/- Uncomment one of the following two: -\/\ntheorem preservation_dec : preservation := \nbegin\n  intros t t' T ht htt',\n  revert t',\n  induction ht with x hx ih x y hx hy ihx ihy x xs hx hxs ihx ihxs xs hxs ih i xs hi hxs ihi ihxs xs hxs ih;\n  intros t' htt';\n  cases htt' with s s' hss' z hz z w hz hw z w w' hz hww' z z' hzz' z zs zs' hz hzszs' z z' zs hzz' z zs hz hzs zs zs' hzszs' z zs hz hzs j z zs hj hz hzs j zs zs' hj hzszs' j j' zs hjj' z hz z z' hzz';\n  try { assumption },\n  { exact T_Scc s' (ih s' hss') },\n  { apply T_Scc,\n    convert T_Pls z y _ hy,\n    cases hx, assumption },\n  { convert T_Pls x w' hx _,\n    exact ihy w' hww' },\n  { convert T_Pls _ _ _ hy,\n    exact ihx _ z },\n  { convert T_Cns _ _ hx _,\n    exact ihxs _ z },\n  { convert T_Cns _ _ _ hxs,\n    exact ihx _ z },\n  { exact T_Zro },\n  { apply T_Scc,\n    apply T_Len,\n    apply lval_List,\n    assumption },\n  { apply T_Len,\n    apply ih,\n    assumption },\n  { apply nval_Nat,\n    assumption },\n  { apply T_Idx,\n    apply nval_Nat,\n    assumption,\n    apply lval_List,\n    assumption },\n  { apply T_Idx,\n    apply nval_Nat,\n    assumption,\n    apply ihxs,\n    assumption },\n  { apply T_Idx,\n    apply ihi,\n    assumption,\n    assumption },\n  { apply T_Cns,\n    assumption,\n    exact T_Nul },\n  { apply T_Stn,\n    apply ih,\n    assumption }\nend\n-- theorem preservation_dec : \u00ac preservation := sorry\n\n\/- Uncomment one of the following two: -\/\n-- lemma soundness_dec : soundness := sorry\nlemma soundness_dec : \u00ac soundness := \nbegin\n  intro hs,\n  have herror : \u22a2 idx zro nul :\u2208 Nat := T_Idx _ _ T_Zro T_Nul,\n  specialize hs _ _ _ herror (multi.multi_refl (idx zro nul)),\n  have : stuck (zro.idx nul),\n  { split,\n    intro h,\n    cases h with t' ht',\n    cases ht',\n    cases ht'_a_1,\n    cases ht'_a,\n    intro hv,\n    cases hv,\n    cases hv,\n    cases hv },\n  contradiction\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208982,"user_id":null,"body":"import Preloaded\n\nopen nvalue lvalue tm ty has_type\n\nlemma nval_nf {x : tm} : nvalue x \u2192 \u2200 {y}, \u00ac x \u27f6 y :=\n-- intuitionistically equivalent to x being normal form\nbegin\n  intro nx, induction nx with _ _ ih;\n  {intros _ xy, cases xy, try {exact ih xy_a}},\nend\n\nlemma lval_nf {x : tm} : lvalue x \u2192 \u2200 {y}, \u00ac x \u27f6 y :=\nbegin\n  intro vx, induction vx; {intros _ xy, cases xy, \n    try {exacts [vx_ih xy_a_1, nval_nf vx_a xy_a]}},\nend\n\ntheorem step_deterministic : deterministic step :=\nbegin\n  intro x, induction x; intros y1 y2 h1 h2,\n  { cases h1 },\n  { cases h1 with _ y1 h\u2081, cases h2 with _ y2 h\u2082, congr, exact x_ih _ _ h\u2081 h\u2082 },\n  { cases h1; cases h2, refl, \n    exact absurd h2_a_1 (nval_nf h1_a),\n    cases h2_a, refl,\n    exact absurd h2_a_1 (nval_nf h1_a_1), \n    exact absurd h2_a (nval_nf (nv_scc _ h1_a)),\n    exact absurd h1_a_1 (nval_nf h2_a),\n    exact absurd h1_a_1 (nval_nf h2_a_1),\n    rw x_ih_a_1 _ _ h1_a_1 h2_a_1,\n    exact absurd h2_a (nval_nf h1_a),\n    cases h1_a,\n    exact absurd h1_a (nval_nf (nv_scc _ h2_a)),\n    exact absurd h1_a (nval_nf h2_a),\n    rw x_ih_a _ _ h1_a h2_a },\n  { cases h1 },\n  { cases h1; cases h2,\n    rw x_ih_a_1 _ _ h1_a_1 h2_a_1,\n    exact absurd h2_a (nval_nf h1_a),\n    exact absurd h1_a (nval_nf h2_a),\n    rw x_ih_a _ _ h1_a h2_a },\n  { cases h1; cases h2, refl, cases h2_a, refl,\n    exact absurd h2_a (lval_nf (lv_cns _ _ h1_a h1_a_1)),\n    cases h1_a,\n    exact absurd h1_a (lval_nf (lv_cns _ _ h2_a h2_a_1)),\n    rw x_ih _ _ h1_a h2_a },\n  { cases h1; cases h2, refl,\n    exact absurd h2_a_1 (lval_nf (lv_cns _ _ h1_a h1_a_1)),\n    cases h2_a, refl,\n    exact absurd h2_a_1 (lval_nf (lv_cns _ _ h1_a_1 h1_a_2)),\n    exact absurd h2_a (nval_nf (nv_scc _ h1_a)),\n    exact absurd h1_a_1 (lval_nf (lv_cns _ _ h2_a h2_a_1)),\n    exact absurd h1_a_1 (lval_nf (lv_cns _ _ h2_a_1 h2_a_2)),\n    rw x_ih_a_1 _ _ h1_a_1 h2_a_1,\n    exact absurd h2_a (nval_nf h1_a),\n    cases h1_a,\n    exact absurd h1_a (nval_nf (nv_scc _ h2_a)),\n    exact absurd h1_a (nval_nf h2_a),\n    rw x_ih_a _ _ h1_a h2_a },\n  { cases h1; cases h2, refl,\n    exact absurd h2_a (nval_nf h1_a),\n    exact absurd h1_a (nval_nf h2_a),\n    rw x_ih _ _ h1_a h2_a }\nend\n\ntheorem progress_dec : \u00ac progress := begin\n  intro p, cases p (idx zro nul) Nat (T_Idx _ _ T_Zro T_Nul),\n  repeat {cases h}, cases h_h, cases h_h_a_1, cases h_h_a,\nend\n\ntheorem preservation_dec : preservation := begin\n  intro t, induction t; intros t' T tT h;\n  cases h; repeat {cases tT},\n  exact T_Scc _ (t_ih _ _ tT_a h_a),\n  exact tT_a_1,\n  cases tT_a_2, exact T_Scc _ (T_Pls _ _ tT_a_2_a tT_a_3),\n  exact T_Pls _ _ tT_a (t_ih_a_1 _ _ tT_a_1 h_a_1),\n  exact T_Pls _ _ (t_ih_a _ _ tT_a h_a) tT_a_1,\n  exact T_Cns _ _ tT_a (t_ih_a_1 _ _ tT_a_1 h_a_1),\n  exact T_Cns _ _ (t_ih_a _ _ tT_a h_a) tT_a_1,\n  exact T_Zro,\n  cases tT_a, exact T_Scc _ (T_Len _ tT_a_a_1),\n  exact T_Len _ (t_ih _ _ tT_a h_a),\n  cases tT_a_1, exact tT_a_1_a,\n  cases tT_a, cases tT_a_1, exact T_Idx _ _ tT_a_a tT_a_1_a_1,\n  exact T_Idx _ _ tT_a (t_ih_a_1 _ _ tT_a_1 h_a_1),\n  exact T_Idx _ _ (t_ih_a _ _ tT_a h_a) tT_a_1,\n  exact T_Cns _ _ tT_a T_Nul,\n  exact T_Stn _ (t_ih _ _ tT_a h_a),\nend\n\nlemma soundness_dec : \u00ac soundness := begin\n  intro s, apply s (idx zro nul) _ Nat \n    (T_Idx _ _ T_Zro T_Nul) (multi.multi_refl _),\n  split, intro p, cases p, cases p_h, cases p_h_a_1, cases p_h_a,\n  intro v, repeat {cases v},\nend\n\n-- termination at either idx [nvalue] nul or a value ?","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208983,"user_id":null,"body":"import Preloaded tactic\n\nopen tm nvalue lvalue step ty has_type multi\ninfix ` \u27f6 `:100 := step\nnotation `\u22a2 `:19 t ` :\u2208 `:20 T := has_type t T\nnotation `step_normal_form` := (normal_form step)\n\nlemma nvalue_normal (x : tm) (h : nvalue x) (y : tm) : \u00ac x \u27f6 y :=\nbegin\n    intro hxy,\n    induction h with x hx ih generalizing y,\n    cases hxy,\n    cases hxy,\n    solve_by_elim,\nend \n\nlemma lvalue_normal (x : tm) (h : lvalue x) (y : tm) : \u00ac x \u27f6 y :=\nbegin\n    intro hxy,\n    induction h with x hx ih generalizing y,\n    cases hxy,\n    cases hxy,\n    solve_by_elim,\n    simp only [*, nvalue_normal] at *,\nend \n\nlemma Nat_of_nvalue {x : tm} (h : nvalue x) : \u22a2 x :\u2208 Nat :=\nbegin\n    induction h,\n    simp only [T_Zro],\n    simp only [*, T_Scc],\nend \n\nlemma List_of_lvalue {x : tm} (h : lvalue x) : \u22a2 x :\u2208 List :=\nbegin\n    induction h,\n    simp only [T_Nul],\n    simp only [*, T_Cns, Nat_of_nvalue],\nend\n\ntheorem step_deterministic : deterministic step :=\nbegin\n    intros x y1 y2 hy1 hy2,\n    induction hy1 generalizing y2;\n    cases hy2,\n    any_goals { simp only [*, nvalue_normal, nv_zro, nv_scc] at *, },\n    any_goals { tauto, },\n    any_goals { simp only [*, lvalue_normal, lv_nul, lv_cns] at *, },\nend\n\ntheorem progress_dec : \u00ac progress :=\nbegin\n    unfold progress,\n    push_neg,\n    use [idx (scc zro) nul, Nat],\n    refine \u27e8by simp only [T_Idx, T_Scc, T_Zro, T_Nul], _, _\u27e9,\n    {   intro h,\n        repeat { cases h, },\n    },\n    {   intros t' ht',\n        cases_type* step,\n    },\nend\n\ntheorem preservation_dec : preservation :=\nbegin\n    intros t t' T _ t_step_t',\n    revert T,\n    induction t_step_t';\n    intros T t_in_T;\n    cases t_in_T;\n    simp only [*, Nat_of_nvalue, List_of_lvalue, nv_zro, T_Scc, T_Pls, T_Cns,\n                T_Nul, T_Len, T_Idx, T_Stn],\nend\n\nlemma a_fortiori : soundness \u2192 progress :=\nbegin\n    intro h,\n    intros t T t_in_T,\n    have t_not_stuck := h t t T t_in_T (multi_refl t),\n    unfold stuck at t_not_stuck,\n    change step_normal_form t with \u00ac \u2203 t', t \u27f6 t' at t_not_stuck,\n    finish,\nend\n\nlemma soundness_dec : \u00ac soundness := \u03bb h, progress_dec (a_fortiori h)\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208984,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen tm nvalue step ty has_type\ninfix ` \u27f6 `:100 := step\n\nlemma no_step_nvalue (a b : tm) (h\u2082 : a \u27f6 b) (h\u2081 : nvalue a) : false :=\nbegin\n  induction h\u2081 generalizing b h\u2082; cases h\u2082,\n  repeat { apply_assumption }\nend\n\nlemma no_step_lvalue (a b : tm) (h\u2082 : a \u27f6 b) (h\u2081 : lvalue a) : false :=\nbegin\n  induction h\u2081 generalizing b h\u2082; cases h\u2082,\n  { repeat { apply_assumption } },\n  { solve_by_elim [no_step_nvalue] }\nend\n\ntheorem step_deterministic : deterministic step :=\nbegin\n  rintros x y\u2081 y\u2082 r\u2081,\n  induction r\u2081 generalizing y\u2082; intro r\u2082; cases r\u2082,\n  all_goals { try { refl } },\n  all_goals { try { congr, apply r\u2081_ih, assumption } },\n  all_goals { try {\n    exfalso,\n    solve_by_elim [no_step_nvalue, nvalue.nv_zro, nvalue.nv_scc,\n      no_step_lvalue, lvalue.lv_nul, lvalue.lv_cns] { max_depth := 5 } } },\nend\n\ntheorem progress_dec : \u00ac progress :=\nbegin\n  dunfold progress,\n  push_neg,\n  refine \u27e8idx zro nul, Nat, _, _, _\u27e9,\n  { solve_by_elim [T_Zro, T_Nul, T_Idx] },\n  { rintro (a|a); cases a },\n  { rintro t s; cases s,\n    cases_matching nul \u27f6 _,\n    cases_matching zro \u27f6 _ }\nend\n\nlemma nvalue_typed (a : tm) (h : nvalue a) : \u22a2 a :\u2208 Nat :=\nby induction h; solve_by_elim [T_Zro, T_Scc]\n\nlemma lvalue_typed (a : tm) (h : lvalue a) : \u22a2 a :\u2208 List :=\nby induction h; solve_by_elim [T_Nul, T_Cns, nvalue_typed] { max_depth := 5 }\n\ntheorem preservation_dec : preservation :=\nbegin\n  rintros t t' T j s,\n  induction s generalizing T; cases j;\n  solve_by_elim [T_Zro, T_Scc, T_Pls, T_Nul, T_Cns, T_Len, T_Idx, T_Stn, nvalue_typed, lvalue_typed] { max_depth := 5 }\nend\n\ntheorem soundness_dec : \u00ac soundness :=\nbegin\n  have : \u00acprogress := progress_dec,\n  dunfold progress at this,\n  push_neg at this,\n  obtain \u27e8t, T, j, nv, np\u27e9 := this,\n  dunfold soundness,\n  push_neg,\n  refine \u27e8t, t, T, j, multi.multi_refl _, _, nv\u27e9,\n  dunfold normal_form,\n  push_neg,\n  apply np\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5d0e57ec1c5fdd000146b7d9":[{"id":208985,"user_id":660,"body":"import Preloaded\nimport tactic\n\n@[simp]\ntheorem horner_correct' (x cf acc) : \n  horner_loop acc x cf = eval_poly x cf + acc * x ^ cf.length :=\nbegin\n  induction cf generalizing acc,\n  { simp [horner_loop, eval_poly] },\n  { simp [horner_loop, cf_ih, eval_poly, nat.pow_succ, add_mul], ac_refl },\nend\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf := \nby simp [horner]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208986,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\nlemma horner_loop_correct (acc x cf) : eval_poly x cf + acc * x ^ cf.length = horner_loop acc x cf :=\nbegin\n  revert acc,\n  induction cf; intro acc; simp [eval_poly, horner_loop],\n  rw [\u2190cf_ih, pow_add, pow_one],\n  ring\nend\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nbegin\n  have h := horner_loop_correct 0 x cf,\n  simp [horner] at *,\n  assumption\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208987,"user_id":null,"body":"import Preloaded\nimport tactic\nlemma horner_correct_aux : \u2200(cfh:\u2115)(x:\u2115)(cft:list \u2115),\nhorner_loop cfh x cft = eval_poly x (cfh::cft) := by{\n  intros cfh x cft,\n  revert cfh x,\n  induction cft,{\n    simp[eval_poly],\n    intros,\n    refl,\n  },{\n    intros,\n    simp [horner_loop,eval_poly],\n    exact calc\n    horner_loop (nat.add (cfh*x) cft_hd) x cft_tl = eval_poly x ((nat.add (cfh*x) cft_hd)::cft_tl) : by{\n      exact cft_ih (cfh*x + cft_hd) x,\n    }\n    ... = eval_poly x cft_tl + (cfh*x + cft_hd)*x^cft_tl.length : by{\n      simp [eval_poly],\n    }\n    ... = eval_poly x cft_tl + cft_hd * x ^ cft_tl.length + cfh * x ^ (cft_tl.length + 1):by{\n      ring_exp!,\n    }\n  }\n}\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf := by{\n  simp[horner],\n  symmetry,\n  exact calc\n  horner_loop 0 x cf = eval_poly x (0::cf) : by{\n    exact horner_correct_aux 0 x cf,\n  }\n  ...=eval_poly x cf : by{\n    simp [eval_poly],\n  }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208988,"user_id":null,"body":"import Preloaded\n\nlemma horner_acc_gets_added {a b x cf} : horner_loop (a + b) x cf = horner_loop a x (list.repeat 0 cf.length) + horner_loop b x cf := begin\n  induction cf generalizing a b, { refl, },\n  simp [horner_loop] at *,\n  rw add_mul, rw add_assoc,\n  exact @cf_ih (a * x) (b * x + cf_hd),\nend\n\nlemma horner_zero_mul {a x n} : horner_loop a x (list.repeat 0 n) = a * x ^ n := begin\n  induction n generalizing a, { simp [horner_loop], },\n  simp [horner_loop], rw pow_succ, rw \u2190mul_assoc, exact n_ih,\nend\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf := begin\n  induction cf, refl,\n  simp [horner, horner_loop, eval_poly],\n  rw [cf_ih, \u2190add_zero cf_hd, horner_acc_gets_added],\n  simp,\n  rw [horner_zero_mul, horner],\n  exact add_comm _ _,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208989,"user_id":null,"body":"import Preloaded tactic\nimport data.nat.basic\n\nlemma aux (x cf) : \u2200a, horner_loop a x cf = a * x ^ cf.length + horner x cf :=\nmatch x, cf with \n| x, [] := by simp [horner, horner_loop, pow_zero]\n| x, (c::cs) := begin\n    intros a,\n    simp [horner, horner_loop],\n    simp [_match x cs],\n    ring_exp,\n  end\nend\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nmatch x, cf with \n| x, [] := by refl\n| x, (c::cs) := begin  \n  simp [eval_poly, horner, horner_loop],\n  rw [_match, aux, add_comm]\n  end\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208990,"user_id":null,"body":"import Preloaded\n\nlemma horner_loop_correct : \u2200 acc x cf, eval_poly x cf +  acc * x ^ cf.length = horner_loop acc x cf :=\nbegin\nintros,\ninduction cf with h t generalizing acc x,\nsimp [horner_loop, eval_poly, list.length],\nsimp [horner_loop, eval_poly],\nrw \u2190 (cf_ih (acc * x + h) _),\nrw [add_mul, add_assoc],\ncongr' 1,\nrw [add_comm],\ncongr' 1,\nrw [mul_assoc],\ncongr' 1,\nend\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nby simpa [horner] using horner_loop_correct 0 x cf","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208991,"user_id":null,"body":"import Preloaded\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nbegin\n    induction cf with hd cf ih; unfold eval_poly horner horner_loop,\n    simp,\n    rw ih,\n    have aux : \u2200 (coeff : list nat) (a b y : nat),\n    horner_loop a y coeff + b * y ^ coeff.length = horner_loop (a + b) y coeff,\n    {\n        intro coeff,\n        induction coeff;\n        unfold horner_loop;\n        intros;\n        simp,\n        rw add_mul,\n        repeat {rw \u2190coeff_ih},\n        rw [add_right_comm, pow_succ, mul_assoc b],\n        },\n    specialize aux cf 0 hd x,\n    simp at aux,\n    unfold horner,\n    assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208992,"user_id":17,"body":"import Preloaded algebra\n\n-- Courtesy of @kckennylau\n\nlemma horner_aux (x : nat) : \u2200 (cf : list nat) (acc : nat), horner_loop acc x cf = acc * x ^ cf.length + eval_poly x cf\n| []       acc := show acc = acc * 1 + 0, by rw [add_zero, mul_one]\n| (an::cf) acc := show horner_loop (acc*x+an) x cf = acc * (x * x^cf.length) + (eval_poly x cf + an*x^cf.length),\n    by rw [horner_aux, add_comm, add_left_comm, add_mul, mul_assoc]\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nby unfold horner; rw [horner_aux, zero_mul, zero_add]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208993,"user_id":196,"body":"import Preloaded algebra\n\nlemma horner_aux (x : nat) : \u2200 (cf : list nat) (acc : nat), horner_loop acc x cf = acc * x ^ cf.length + eval_poly x cf\n| []       acc := show acc = acc * 1 + 0, by rw [add_zero, mul_one]\n| (an::cf) acc := show horner_loop (acc*x+an) x cf = acc * (x * x^cf.length) + (eval_poly x cf + an*x^cf.length),\n    by rw [horner_aux, add_comm, add_left_comm, add_mul, mul_assoc]\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nby unfold horner; rw [horner_aux, zero_mul, zero_add]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208994,"user_id":null,"body":"import Preloaded tactic tactic.nth_rewrite\n\ntheorem horner_correct (x cf) : eval_poly x cf = horner x cf :=\nbegin\n  induction cf with an cf h,\n  repeat {unfold horner horner_loop eval_poly},\n  rw [h, horner, zero_mul], clear h,\n  generalize : 0 = acc, revert acc an,\n  induction cf with an1 cf h, unfold horner_loop,\n  intros acc an, simp,\n  intros acc an, unfold horner_loop,\n  rw [list.length, nat.pow_succ, add_mul, add_right_comm],\n  nth_rewrite 1 \u2190 h, ring,\nend\n-- no lemma, just generalize","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5d1eae23c193ae0025b5d50b":[{"id":208995,"user_id":null,"body":"import Preloaded tactic.linarith\n\nopen nat\n\n---------------------------------------------------------------------------------------\n-- From mathlib\nlemma fib_two_mul (n : \u2115) : fib (2 * n) = fib n * (2 * fib (n + 1) - fib n) :=\nbegin\n  cases n,\n  { simp },\n  { rw [nat.succ_eq_add_one, two_mul, \u2190add_assoc, \u2190 fib_add, fib_add_two, two_mul],\n    simp only [\u2190 add_assoc, add_tsub_cancel_right],\n    ring, },\nend\n\nlemma fib_two_mul_add_one (n : \u2115) : fib (2 * n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=\nby { rw [two_mul, \u2190 fib_add], ring }\n----------------------------------------------------------------------------------------\n\nlemma bodd_of_odd (n : \u2115) (h : odd n) : n.bodd = tt := \nby { rcases h with \u27e8k, rfl\u27e9, simp [nat.bodd_add, nat.bodd_mul, nat.bodd_two] }\n\nlemma not_bodd_of_even (n : \u2115) (h : even n) : n.bodd = ff := \nby { rcases h with \u27e8k, rfl\u27e9, simp [nat.bodd_add, nat.bodd_mul, nat.bodd_two] }\n\ntheorem fib_fast_correct_aux (n : \u2115) : fib2 n = (fib n, fib n.succ) :=\nbegin\n  apply nat.strong_induction_on n,\n  intros k IH,\n  cases k, { rw [fib2, fib_zero, fib_one], },\n  cases even_or_odd k,\n  { simp_rw [fib2, not_bodd_of_even k h, bool.cond_ff],\n    rw [IH (k.succ \/ 2) (succ_div2_lt_succ k), prod.mk.inj_iff],\n    rcases h with \u27e8b, rfl\u27e9,\n    have : (2*b + 1) \/ 2 = b, by rw [add_comm, add_mul_div_left, nat.div_eq_of_lt]; norm_num,\n    rw [this, nat.fib_add_two, fib_two_mul_add_one b, fib_two_mul],\n    split; ring, },\n  { simp_rw [fib2, bodd_of_odd k h, bool.cond_tt],\n    rw [IH (k.succ \/ 2) (succ_div2_lt_succ k), prod.mk.inj_iff],\n    rcases h with \u27e8b, rfl\u27e9, \n    rw show (2 * b + 1).succ \/ 2 = b + 1, by { apply nat.div_eq_of_eq_mul_left, norm_num, ring, }, \n    rw [fib_add_two, fib_add_two, fib_add_two, fib_add_two, fib_two_mul_add_one b],\n    split,\n    { rw [fib_two_mul, nat.mul_sub_left_distrib (fib b), \u2190 nat.sub_add_comm, two_mul, \n          nat.add_sub_assoc, nat.add_sub_cancel, nat.add_sub_assoc, \u2190 pow_two, nat.add_sub_cancel],\n      { ring, },\n      { rw \u2190 pow_two, apply nat.le_add_left, },\n      { apply nat.le_add_left, },\n      { apply nat.mul_le_mul_of_nonneg_left, linarith [@fib_le_fib_succ b], }, },\n    { rw [fib_two_mul, nat.mul_sub_left_distrib, \u2190 nat.sub_add_comm, \u2190 add_assoc _ _ (fib b ^ 2), \n          pow_two (fib b), nat.add_sub_cancel],\n      { ring, },\n      { apply nat.mul_le_mul_of_nonneg_left, linarith [@fib_le_fib_succ b], }, }, },\nend\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n := by rw [fib_fast, fib_fast_correct_aux]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208996,"user_id":null,"body":"import Preloaded\n\nopen nat\n\nlemma fib2_correct : \u2200 n, fib2 n = (fib n, fib (succ n))\n| 0 := by simp [fib2]\n| (succ n) :=\n  have succ n \/ 2 < succ n, from succ_div2_lt_succ n,\n  begin\n    have ih : fib2 (succ n \/ 2) = (fib (succ n \/ 2), fib (succ (succ n \/ 2))), \n      from fib2_correct (succ n \/ 2),\n    simp [fib2], rw ih, simp,\n    have h\u2081 : bodd n = !bodd n.succ,\n      rw [nat.bodd_succ, bnot_bnot],\n    rw h\u2081, generalize : (n.succ = m),\n    conv\n    begin\n      to_rhs,\n      rw [\u2190(nat.bodd_add_div2 m)]\n    end,\n    rw [\u2190nat.div2_val], generalize : (div2 m = x),\n    cases (bodd m); simp; split; rw (two_mul x),\n    {\n      cases x, simp,\n      conv { to_rhs, rw [add_succ, \u2190nat.fib_add], },\n      rw [fib_add_two, add_one],\n      conv {\n        to_lhs, congr, skip, rw mul_add,\n        rw (nat.add_sub_assoc (nat.le_mul_of_pos_left zero_lt_two)),\n        congr, skip,\n        conv { congr, skip, rw \u2190(one_mul (fib x.succ)) },\n        rw \u2190nat.mul_sub_right_distrib, simp,\n      },\n      ring\n    },\n    { rw \u2190nat.fib_add },\n    { conv { to_rhs, rw [nat.add_comm, \u2190nat.fib_add] } },\n    {\n      conv {\n        to_rhs, rw [\u2190nat.add_assoc, \u2190nat.fib_add],\n        congr, skip, congr, rw [nat.add_comm 1 x, nat.add_assoc, fib_add_two],\n      },\n      conv {\n        to_lhs, rw [\u2190nat.add_assoc, \u2190mul_add],\n        congr, congr, skip,\n      },\n      rw [nat.sub_add_cancel, add_comm 1 x, add_one],\n        ring,\n      apply le_trans,\n        apply fib_le_fib_succ,\n      rw add_one, apply nat.le_mul_of_pos_left, exact zero_lt_two\n    }\n  end\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n :=\nbegin\n  unfold fib_fast,\n  rw fib2_correct\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208997,"user_id":null,"body":"import Preloaded \nimport data.nat.basic data.nat.parity data.nat.fib\nimport tactic tactic.induction\n\nopen nat\n\nlemma fle (n : \u2115) : fib n \u2264 2 * fib (n + 1) :=\nbegin\n  cases' n; simp [fib_add_two],\n  linarith,\nend\n\nlemma frec (n : \u2115) : \n  fib(2 * n) = fib n * (2 * fib (n + 1) - fib n) \n  \u2227 fib (2 * n + 1) = fib n * fib n + fib (n + 1) * fib (n + 1) :=\nbegin\n  induction' n,\n  { simp },\n  simp [nat.succ_eq_add_one, mul_add, fib_add_two, ih.1, ih.2],   \n  split,\n  { rw [\u2190add_assoc, \u2190mul_add, nat.sub_add_cancel (fle n)],\n    simp [nat.add_sub_assoc, \u2190one_add_one_eq_two, add_mul, mul_add], \n    ac_refl },\n  { rw [add_comm, \u2190add_assoc, \u2190add_assoc, \u2190mul_add, nat.sub_add_cancel (fle n)],\n    simp [add_mul, mul_add, \u2190one_add_one_eq_two],\n    ac_refl }\nend\n\nlemma aux : \u2200(n k : \u2115), k \u2264 n \u2192 fib2 k = (fib k, fib (k + 1)) :=\nbegin  \n  intros n,\n  induction' n,\n  { intros k hk,\n    simp [fib2, fib, (show k = 0, by linarith)] },\n  simp [nat.succ_eq_add_one],\n  intros k hk,\n  by_cases he : k \u2264 n,\n  { exact ih k he },\n  simp [show k = n + 1, by linarith] at *,\n  cases even_or_odd n with hp hp,\n  { cases hp with m hm,\n    simp [hm, fib2], rw nat.succ_eq_add_one,\n    specialize ih m (by linarith),\n    have ht : (2 * m + 1) \/ 2 = m,\n      simp [nat.add_div_of_dvd_right], norm_num,\n    rw [ht, ih],    \n    simp [\u2190(frec m).2, \u2190(frec m).1, fib_add_two] },\n  { cases hp with m hm,\n    simp [hm, fib2], rw nat.succ_eq_add_one,\n    specialize ih (m+1) (by linarith),\n    have ht : (2 * m + 1 + 1) \/ 2 = m + 1,\n      simp [add_assoc, one_add_one_eq_two],\n    rw [ht, ih],\n    simp [\u2190(frec (m + 1)).1, \u2190(frec (m + 1)).2, mul_add] }\nend\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n := \nby simp [fib_fast, aux n n (le_refl n)]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208998,"user_id":17,"body":"import Preloaded tactic\n\nopen nat\n\nlemma lt_1 {n : \u2115} (hlt : n < 1) : n = 0 := by omega\n\nlemma two_gt_0 : 2 > 0 := by omega\n\nlemma twomul_gt {n m : \u2115} (hgt : 2 * n > 2 * m) : n > m := by omega\n\nlemma le_lemma1 {n m : \u2115} (hle : n \u2264 m) : n \u2264 2 * m := by omega\n\nlemma le_lemma2 {n : \u2115} : n \u2264 2 * n := by omega\n\nlemma sub_lemma1 {n : \u2115} : n = 2 * n - n := by omega\n\nlemma fib_2k_succ_2k_equations (k : \u2115) :\n  fib (2 * k) = fib k * (2 * fib (succ k) - fib k) \u2227\n  fib (succ (2 * k)) = fib k * fib k + fib (succ k) * fib (succ k) :=\nbegin\n  induction k,\n  case zero : { split; refl },\n  case succ : k' ihk' {\n    cases ihk' with ihk'\u2081 ihk'\u2082,\n    change fib (2 * k' + 2) = _ \u2227 fib (succ (2 * k' + 2)) = _,\n    repeat { rw fib_add_two },\n    repeat { rw ihk'\u2081 },\n    repeat { rw ihk'\u2082 },\n    clear ihk'\u2081 ihk'\u2082,\n    have hle := @fib_le_fib_succ k',\n    repeat { rw nat.mul_sub_left_distrib },\n    split,\n    { rw \u2190 nat.sub_add_comm,\n      { rw [add_left_comm, add_comm],\n        rw nat.add_sub_assoc (le_refl _),\n        simp,\n        repeat { rw left_distrib },\n        rw nat.add_sub_assoc,\n        { congr' 1,\n          { ring },\n          { have h : fib (succ k') * (2 * fib (k' + 1)) =\n              2 * (fib (succ k') * fib (succ k')), by ring,\n            rw h,\n            clear h,\n            apply sub_lemma1 } },\n        { have h : fib (succ k') * (2 * fib (k' + 1)) =\n            2 * (fib (succ k') * fib (succ k')), by ring,\n          rw h,\n          clear h,\n          apply le_lemma2 } },\n      { apply nat.mul_le_mul_left,\n        apply le_lemma1 hle } },\n    { rw [left_distrib, right_distrib, right_distrib],\n      generalize h\u2081 : fib k' = n,\n      generalize h\u2082 : fib (k' + 1) = m,\n      rw [h\u2081, h\u2082] at hle,\n      clear h\u2081 h\u2082,\n      have heq : n * (2 * m) = 2 * (n * m), by ring,\n      rw heq,\n      clear heq,\n      rw mul_comm m n,\n      have h\u2081 : n * n \u2264 n * m :=\n        mul_le_mul (le_refl n) hle (nat.zero_le _) (nat.zero_le _),\n      have h\u2082 : n * m \u2264 m * m :=\n        mul_le_mul hle (le_refl m) (nat.zero_le _) (nat.zero_le _),\n      generalize h\u2083 : n * n = a,\n      generalize h\u2084 : n * m = b,\n      generalize h\u2085 : m * m = c,\n      rw [h\u2083, h\u2084] at h\u2081,\n      rw [h\u2084, h\u2085] at h\u2082,\n      clear hle h\u2083 h\u2084 h\u2085 k' n m,\n      omega }\n  }\nend\n\nlemma fib2_correct : \u2200 n, fib2 n = (fib n, fib (succ n))\n| 0 := by rw [fib2]; refl\n| (succ n) :=\nhave succ n \/ 2 < succ n, from succ_div2_lt_succ n,\nbegin \n  rw [fib2, fib2_correct], simp only [],\n  obtain \u27e8eq1, eq2\u27e9 := fib_2k_succ_2k_equations (succ n \/ 2),\n  rw [\u2190eq1, \u2190eq2],\n  cases hodd : bodd n; rw cond,\n  { suffices : 2 * (succ n \/ 2) = n, rw [this, fib_add_two],\n    rw [nat.two_mul_odd_div_two, succ_sub_one],\n    rw [nat.mod_two_of_bodd, nat.bodd_succ, hodd, bool.bnot_false, cond], },\n  { suffices : 2 * (succ n \/ 2) = succ n, rw this,\n    rw [\u2190nat.bit_decomp (succ n), nat.bodd_succ, hodd, bool.bnot_true],\n    rw [nat.bit, cond, \u2190div2_val, div2_bit0, \u2190bit0_val], },\nend\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n :=\nbegin\n  unfold fib_fast,\n  rw fib2_correct,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":208999,"user_id":168,"body":"import Preloaded tactic\n\nopen nat\n\nlemma fib_prop (k) : fib (2 * k) + fib k * fib k = 2 * fib k * fib k.succ \u2227\n                     fib (2 * k).succ = fib k * fib k + fib k.succ * fib k.succ :=\nbegin\n  induction k using nat.strong_induction_on with k ih,\n  cases k, exact \u27e8rfl, rfl\u27e9, \n  rw [(show 2 * k.succ = 2 * k + 2, by omega)],\n  simp only [fib_succ_succ, ih k (lt_add_one _), \u2190add_assoc],\n  split; ring\nend\n\nlemma fib_zify_lemma (k : \u2115) : (((2 * k.succ.fib - k.fib) : \u2115) : \u2124) = 2 * k.succ.fib - k.fib :=\nbegin\n  rw int.coe_nat_sub, { refl },\n  linarith [@fib_le_fib_succ k]\nend\n\nlemma fib2_spec (n) : fib2 n = (fib n, fib n.succ) :=\nbegin\n  induction n using nat.strong_induction_on with n ih,\n  cases n, { refl },\n  rw [fib2, ih _ (succ_div2_lt_succ n)], simp only,\n  have h := nat.bit_decomp n,\n  have h1 := nat.div2_succ n,\n  cases n.bodd; simp only [bit, bit0, bit1, cond] at h h1; rw cond,\n  { set k := n.div2, rw \u2190two_mul at h,\n    rw [\u2190nat.div2_val, h1, \u2190h], \n    congr' 1, { rw (fib_prop k).2 },\n    simp only [fib_succ_succ, fib_prop k, \u2190add_assoc],\n    zify, rw fib_zify_lemma, ring },\n  { set k := n.div2, rw \u2190two_mul at h,\n    rw [\u2190nat.div2_val, h1, \u2190h],\n    congr' 1, swap,\n    { rw [show (2 * k + 1).succ.succ = (2 * (k + 1)).succ, from rfl, (fib_prop (k + 1)).2] },\n    rw [show (2 * k + 1).succ = 2 * (k + 1), from rfl],\n    have := (fib_prop (k + 1)).1,\n    zify at this \u22a2, rw fib_zify_lemma, linarith }\nend\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n :=\nby rw [fib_fast, fib2_spec]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209000,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\nvariable (n : \u2115)\n\nlemma aux_fib :\n  n.fib * n.fib + (n + 1).fib * (n + 1).fib = (2 * n + 1).fib \u2227\n  n.fib * (2 * n.succ.fib - n.fib) = (2 * n).fib :=\nbegin\n  zify [show n.fib \u2264 2 * n.succ.fib, from\n    le_trans fib_le_fib_succ (le_mul_of_pos_left succ_pos')],\n  induction n with n h,\n  { split; refl },\n  rw mul_succ,\n  repeat { rw [fib_succ_succ, int.coe_nat_add] },\n  rw [\u2190 h.1, \u2190 h.2],\n  split; ring\nend\n\nlemma aux_nat : \u2203 m, 2 * m = n \u2228 2 * m + 1 = n :=\nbegin\n  induction n with n hn,\n  exact \u27e80, or.inl rfl\u27e9,\n  rcases hn with \u27e8m, rfl | rfl\u27e9,\n  { exact \u27e8m, or.inr rfl\u27e9 },\n  { exact \u27e8m.succ, or.inl rfl\u27e9 }\nend\n\nlemma aux_even : (2 * n).bodd = ff :=\n(two_mul n).symm \u25b8 bodd_bit0 n\n\nlemma aux_odd : (2 * n + 1).bodd = tt :=\n(two_mul n).symm \u25b8 bodd_bit1 n\n\nlemma aux_even_succ_div : (2 * n).succ \/ 2 = n :=\nbegin\n  rw [\u2190 add_one, add_comm, add_mul_div_left],\n  exact zero_add _,\n  exact succ_pos'\nend\n\nlemma aux_odd_succ_div : (2 * n + 1).succ \/ 2 = n.succ :=\nshow (2 * n + 2 * 1) \/ 2 = _,\nbegin\n  rw [\u2190 mul_add, nat.mul_div_cancel_left],\n  exact succ_pos'\nend\n\ntheorem fib2_correct : fib2 n = (fib n, fib n.succ) :=\nbegin\n  apply nat.case_strong_induction_on n, refl,\n  clear n, intros n h,\n  rw [fib2, h],\n  show cond _ _ _ = _,\n  rcases aux_nat n with \u27e8k, rfl | rfl\u27e9,\n  { rw [aux_even, cond, prod.mk.inj_iff, aux_even_succ_div,\n      (aux_fib k).1, (aux_fib k).2, fib_succ_succ], split; refl },\n  { rw [aux_odd, cond, prod.mk.inj_iff, aux_odd_succ_div,\n      (aux_fib k.succ).1, (aux_fib k.succ).2], split; refl },\n  { cases n,\n    { exact rfl.le },\n    apply nat.div_le_of_le_mul,\n    rw mul_succ,\n    exact add_le_add_right (le_mul_of_pos_left succ_pos') 2 }\nend\n\ntheorem fib_fast_correct : fib_fast n = fib n :=\ncongr_arg prod.fst (fib2_correct n)\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209001,"user_id":null,"body":"import Preloaded\n\nimport data.nat.fib data.nat.basic\nimport data.matrix.basic data.matrix.notation\nimport tactic.linarith\n\nopen nat\n\nlemma div2_val' (n : \u2115) : n \/ 2 = n.div2 := (div2_val n).symm\nlemma add_add_sub (a b c: \u2115) : a + (b + c) - c = a + b := by induction c; simp[*, add_succ]\n\nattribute [simp] fib_succ_succ div2_succ div2_val' add_add_sub\n\ndef fib_mat : matrix (fin 2) (fin 2) \u2115 := ![![1, 1], ![1, 0]]\n\nlemma leq_2 (n : fin 2) : n = 0 \u2228 n = 1 := by {\n  by_cases h : n.val < 1; cases n,\n  left, congr, linarith,\n  right, congr, simp, linarith\n}\n\ntheorem fib_pow (n : \u2115) : fib_mat ^ n.succ = ![![fib n.succ.succ, fib n.succ], ![fib n.succ, fib n]] :=\nbegin\n  induction n with n hn,\n  ext i j,\n  cases leq_2 i; cases leq_2 j; unfold fib_mat fib; simp *; refl,\n  ext i j,\n  cases leq_2 i; cases leq_2 j; rw pow_succ; simp *; unfold fib_mat; simp; ring,\nend\n\n\nlemma sub_add_self {a b : \u2115} (H : a \u2264 b) : b - a + a = b := by {\n  induction a with a h generalizing b, simp, \n  cases b,\n    exfalso, exact not_succ_le_zero a H, \n    simp [h (succ_le_succ_iff.mp H), add_succ],\n}\n\nlemma fib_le_fib_succ (n : \u2115) : fib n \u2264 fib n.succ := by cases n; simp\n\nlemma fib_fast_thm' (n m : \u2115) (_ : m \u2264 n) : fib2 m = ((fib_mat ^ m.succ) 1 1, (fib_mat ^ m.succ) 0 1) :=\nbegin\n  revert m,\n  induction n with n hn,\n  intros m H,\n  rwa le_zero_iff.mp H,\n  unfold fib_mat fib2, simp, \n  intros m H,\n  by_cases h: m = n.succ,\n    rw h,\n    unfold fib2,\n    rw [hn _ (lt_succ_iff.mp (succ_div2_lt_succ n)), \u2190 bodd_add_div2 (n.succ.succ)],\n    simp only [two_mul, pow_add],\n    by_cases odd_n : bodd n = tt, {\n      simp [odd_n, fib_pow],\n      split; ring\n    }, {\n      simp at odd_n,\n      simp [odd_n, fib_pow],\n      split,\n        ring,\n        rw [\u2190 add_assoc, \u2190 mul_add, sub_add_self (le_add_left (fib_le_fib_succ n.div2))], ring\n    },\n      exact hn _ (lt_succ_iff.mp (lt_of_le_of_ne H h))\nend\n\ntheorem fib_fast_thm (n : \u2115) : fib2 n = ((fib_mat ^ n.succ) 1 1, (fib_mat ^ n.succ) 0 1)\n  := fib_fast_thm' n n rfl.ge\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n\n := by unfold fib_fast; simp [fib_fast_thm, fib_pow]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209002,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\n\nlemma le_two_self {n : \u2115} : n \u2264 2*n := by { rw [\u2190one_add_one_eq_two, add_mul, one_mul], exact le.intro rfl, }\n\nlemma two_mul_sub_self {b : \u2115} : 2 * b - b = b := by {rw [\u2190one_mul b, \u2190mul_assoc, \u2190nat.mul_sub_right_distrib], norm_num}\n\nlemma add_sub_eq_add_sub {s t u : \u2115} (h\u2081 : u \u2264 t) (h\u2082 : u \u2264 s) : s + (t - u) = t + (s - u) :=\neq.trans ((nat.add_sub_assoc h\u2081 _).symm) (by {rw add_comm, exact nat.add_sub_assoc h\u2082 _, })\n\nlemma boopy {a b : \u2115} (h : a \u2264 b) : a + (2 * b - a) = 2 * b := add_sub_of_le (le_trans h le_two_self)\n\nlemma hoopy {a b : \u2115} (h : a \u2264 b) : 2 * a + (2 * b - a) = a + 2*b :=\nby rw [add_sub_eq_add_sub (le_trans h le_two_self) le_two_self, two_mul_sub_self, add_comm]\n\nlemma roopy {a b : \u2115} (h : a \u2264 b) : 2 * (a + b) - b = 2 * a + b :=\nby rw [mul_add, (nat.add_sub_assoc le_two_self _), two_mul_sub_self]\n\nlemma mul_div_cancel_of_even {f : \u2115} (h : bodd f = ff) : 2 * (f\/2) = f :=\nby { apply nat.mul_div_cancel', apply dvd_of_mod_eq_zero, rw [mod_two_of_bodd, h], refl }\n\nlemma mul_div_cancel_of_odd {f : \u2115} (h : bodd f = tt) : 1 + 2 * (f\/2) = f :=\neq.symm $ eq.trans (mod_add_div f 2).symm (by {rw [mod_two_of_bodd, h], refl})\n\nlemma fib_even_odd (m : \u2115) : fib (2 * m) = fib m * (2 * fib m.succ - fib m) \u2227 fib (2 * m + 1) = (fib m) * (fib m) + (fib m.succ) * (fib m.succ) :=\nbegin\n  rw succ_eq_add_one,\n  induction m with m ih,\n  { split; refl, },\n  { rw succ_eq_add_one,\n    split,\n    { rw [(show 2*(m+1) = 2*m + 2, by linarith), add_assoc],\n      rw [fib_succ_succ, fib_succ_succ, ih.left, ih.right], \n      ring, rw [(boopy fib_le_fib_succ), (roopy fib_le_fib_succ)], ring, },\n    { rw [(show 2*(m+1) + 1= (2 * m + 1) + 2, by linarith), add_assoc],\n      rw [fib_succ_succ, fib_succ_succ, fib_succ_succ, ih.left, ih.right],\n      ring, rw (hoopy fib_le_fib_succ), ring, }, }\nend\n\nlemma fib2_eq {x : \u2115} : fib2 x = (fib x, fib $ succ x) :=\nbegin\n  apply nat.strong_induction_on x,\n  intros n h,\n  induction n with n ih,\n  { refl, },\n  { unfold fib2,\n    cases (bodd n).dichotomy with feven fodd,\n    { dsimp, rw [feven, h (n.succ \/ 2) (succ_div2_lt_succ n), \u2190(mul_div_cancel_of_even feven)],\n      generalize k : n \/ 2 = m, dsimp,\n      have p : (2*m).succ \/ 2 = m,\n      { rw [succ_eq_add_one, add_comm, add_mul_div_left _ _ zero_lt_two], norm_num, },\n      rw [p, \u2190(fib_even_odd _).left, \u2190(fib_even_odd _).right], ring, },\n    { dsimp, rw [fodd, h (n.succ \/ 2) (succ_div2_lt_succ n), \u2190(mul_div_cancel_of_odd fodd)],\n      generalize k : n \/ 2 = m, dsimp,\n      have p : (1 + 2*m).succ \/ 2 = m + 1,\n      { convert mul_div_right _ zero_lt_two, rw succ_eq_add_one, linarith, },\n      rw [p, \u2190(fib_even_odd _).left, \u2190(fib_even_odd _).right], ring, }, },\nend\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n := by {unfold fib_fast, rw fib2_eq}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209003,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\nlemma helper : \u2200 (n : \u2115), n.fib + (n.succ.fib + n.succ.fib - n.fib) = n.succ.fib + n.succ.fib :=\nbegin\n  intros n,\n  have h : n.succ.fib >= n.fib := by cases n; simp [fib_succ_succ],\n  rw nat.add_sub_assoc h,\n  rw \u2190 add_assoc,\n  rw add_comm n.fib n.succ.fib,\n  rw \u2190 nat.add_sub_assoc h,\n  omega,\nend\n\nlemma fib_bin : \u2200 n,\n  fib n = cond (bodd n)\n               (fib (div2 n) ^ 2 + fib (div2 n + 1) ^ 2)\n               (fib (div2 n) * (2 * fib (div2 n + 1) - fib (div2 n))) :=\ntwo_step_induction \n(by simp) (by simp; ring)\n(by\n  intros n hn hsn;\n  cases hn_odd : bodd n;\n    have hsn_odd := bodd_succ n;\n    have hssn_odd := bodd_succ n.succ;\n    rw fib_succ_succ;\n    rw hn;\n    rw hsn;\n    rw div2_succ;\n    rw div2_succ;\n    rw hssn_odd;\n    rw hsn_odd;\n    rw hn_odd;\n    simp *;\n    ring;\n    repeat {rw add_one};\n    rw fib_succ_succ;\n    repeat {rw add_one};\n    repeat {rw two_mul};\n    try {rw helper n.div2};\n    rw add_sub_cancel_right (n.div2.fib + n.div2.succ.fib) n.div2.fib n.div2.succ.fib;\n    ring\n)\n\nlemma fib2_is_fib_fib (n : \u2115) : fib2 n = (fib n, fib n.succ) :=\nnat.strong_induction_on n\n(\nbegin\n  intros n ih,\n  cases n with n,\n    simp [fib2],\n  cases hn_odd : bodd n,\n    have hn : fib2 n = (fib n, fib n.succ) := by apply ih; apply lt_succ_self,\n    cases n with n,\n      unfold fib2,\n      split,\n    unfold fib2 at *,\n    rw \u2190 div2_val at *,\n    rw div2_succ,\n    rw hn_odd at *,\n    simp * at *,\n    rw bool.cond_ff at *,\n    destruct (fib2 n.succ.div2),\n    intros c d hcd,\n    rw hcd at *,\n    simp * at *,\n    rwa \u2190 fib_succ_succ,\n\n    unfold fib2,\n    rw ih _ (succ_div2_lt_succ _),\n    repeat {rw \u2190 div2_val},\n    rw fib_bin n.succ,\n    rw fib_bin n.succ.succ,\n    simp * at *,\n    ring, \nend\n)\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n := \nbegin\n  unfold fib_fast,\n  rw fib2_is_fib_fib,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209004,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\nlemma sub_mul_add {a b : \u2115} (c : \u2115) : b \u2264 a \u2192 (a - b)*c + b*c = a*c :=\nbegin\n    intro h,\n    induction c with c hc,\n    { ring, },\n    { repeat {rw mul_succ},\n      rw [\u2190 hc, add_assoc, add_assoc, add_left_cancel_iff,\n          add_comm (b*c) b, add_comm (b*c) a, \u2190 add_assoc,\n          add_right_cancel_iff],\n      exact nat.sub_add_cancel h,\n    },\nend\n\nlemma sub_mul' {a b : \u2115} (c : \u2115) (h : b \u2264 a) : (a - b)*c = a*c - b*c :=\nbegin\n    rw \u2190 sub_mul_add c h,\n    simp only [nat.add_sub_cancel],\nend\n\nlemma mul_sub' {a b : \u2115} (c : \u2115) (h : b \u2264 a) : c*(a - b) = c*a - c*b :=\nby rw [mul_comm, sub_mul' c h, mul_comm a, mul_comm b]\n\nlemma fib_def (n : \u2115) : fib (n + 2) = fib n + fib (n + 1) := rfl\n\nlemma fib_increasing (n : \u2115) : fib n \u2264 fib (n + 1) :=\nbegin\n  cases n,\n  { exact dec_trivial, },\n  { rw [succ_eq_add_one, fib_def],\n    exact le_add_left _ _,\n  },\nend\n\nlemma fib_identity : \u2200 (n : \u2115), fib (2*n) = fib n *(2*fib (n + 1) - fib n) \u2227\n  fib (2*n + 1) = (fib n)*(fib n) + (fib (n + 1))*(fib (n + 1))\n| 0 := \u27e8rfl, rfl\u27e9\n| (n + 1) :=\nbegin\n  have hn : fib n \u2264 2*fib (n + 1) := by linarith [fib_increasing n],\n  split,\n  { rw [mul_add, mul_one, fib_def, (fib_identity n).1, (fib_identity n).2,\n        mul_sub' (fib n) hn, \u2190 add_assoc, nat.sub_add_cancel (mul_le_mul_left (fib n) hn),\n        fib_def, mul_add, two_mul (fib (n + 1)), \u2190 add_assoc (2*fib n), nat.add_sub_cancel],\n    ring,\n  },\n  { rw [(show 2*(n + 1) + 1 = 2*n + 1 + 2, by ring), fib_def,\n        (show 2*n + 1 + 1 = 2*n + 2, by ring), (show 2*n + 1 + 1 = 2*n + 2, by ring),\n        fib_def, fib_def, (fib_identity n).1, (fib_identity n).2, \u2190 add_assoc,\n        mul_sub' (fib n) hn, add_comm (fib n * fib n), add_assoc (fib (n + 1)*fib (n + 1)),\n          add_comm (fib n * fib n), nat.sub_add_cancel (mul_le_mul_left (fib n) hn)],\n    ring,\n  },\nend\n\nlemma fib2_correct : \u2200 (n : \u2115), fib2 n = (fib n, fib (n + 1))\n| 0 := rfl\n| (n + 1) :=\nbegin\n    rw fib2,\n    rw (have succ n \/ 2 < n + 1, from succ_div2_lt_succ n, fib2_correct (succ n\/ 2)),\n    by_cases n_parity : (bodd n = tt),\n    {   have : succ n \/ 2 = div2 n + 1 := by rw \u2190 div2_val; simp [*, div2_succ],\n        have : n + 1 = 2*(div2 n + 1),\n        { conv_lhs { rw \u2190 nat.bodd_add_div2 n, },\n          simp only [*, add_assoc, cond],\n          ring,\n        },\n        simp [*, fib_identity],\n    },\n    {   have := bool_eq_false n_parity,\n        have : succ n \/ 2 = div2 n := by rw \u2190 div2_val; simp [*, div2_succ],\n        have : n + 1 = 2*(div2 n) + 1,\n        { conv_lhs { rw \u2190 nat.bodd_add_div2 n, },\n          simp only [*, add_assoc, cond],\n          ring,\n        },\n        simp [*, fib_identity, fib_def],\n    },\nend\n\ntheorem fib_fast_correct (n : \u2115) : fib_fast n = fib n := by simp only [fib_fast, fib2_correct]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5d2b89d4b90c0a001f4a6456":[{"id":209005,"user_id":null,"body":"import Preloaded data.nat.fib\n\nopen real\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n  have phi_id : phi^2 = phi + 1, \n  calc phi^2 = (1 + 2 * sqrt 5 + 5)\/4 : by {rw [phi, div_pow, add_sq, one_pow, mul_one, sq_sqrt]; norm_num}\n    ...      = (2 + 2 * sqrt 5) \/ 4 +  4\/4 : by { rw [\u2190 add_div, div_left_inj'], ring, norm_num, }\n    ...      = phi + 1 : by {norm_num, rw [phi, div_eq_iff, div_mul_comm'], ring, norm_num}, \n  have phi_rec : \u2200 (k : \u2115), phi ^ k.succ.succ = phi ^ k.succ + phi ^ k,\n  { intro k, \n    have : phi ^ k * phi ^ 2 = phi ^ k * (phi + 1), by rw phi_id,\n    rw [left_distrib, mul_one] at this,\n    rwa [pow_add _ k 2, pow_add _ k 1, pow_one], }, \n  have psi_id : psi^2 = psi + 1, \n  calc psi^2 = (1 - 2 * sqrt 5 + 5)\/4 : by {rw [psi, div_pow, sub_sq, one_pow, mul_one, sq_sqrt]; norm_num}\n    ...      = (2 - 2 * sqrt 5) \/ 4 +  4\/4 : by { rw [\u2190 add_div, div_left_inj'], ring, norm_num, }\n    ...      = psi + 1 : by {norm_num, rw [psi, div_eq_iff, div_mul_comm'], ring, norm_num}, \n  have psi_rec : \u2200 (k : \u2115), psi ^ k.succ.succ = psi ^ k.succ + psi ^ k,\n  { intro k, \n    have : psi ^ k * psi ^ 2 = psi ^ k * (psi + 1), by rw psi_id,\n    rw [left_distrib, mul_one] at this,\n    rwa [pow_add _ k 2, pow_add _ k 1, pow_one], }, \n\n  apply nat.strong_induction_on n,\n  intro k,\n  cases k, { simp, },\n  cases k, { rw [phi, psi, pow_one, pow_one, \u2190 sub_div, nat.fib_one, eq_div_iff]; norm_num, },\n  intro IH,\n  rw [nat.succ_eq_add_one, nat.succ_eq_add_one, phi_rec, psi_rec, \u2190 sub_sub],\n  suffices : \u2191(nat.fib (k+1+1)) = (phi^k.succ - psi^k.succ) \/ (sqrt 5) + (phi^k - psi^k) \/ sqrt 5,\n  { convert this, \n    rw [\u2190 add_div, div_left_inj' (show sqrt 5 \u2260 0, by norm_num)],\n    linarith, },\n  rw [\u2190 IH k (lt_trans (lt_add_one k) (lt_add_one k.succ)), \u2190 IH k.succ (lt_add_one k.succ), \n      (show k+1+1 = k+2, by linarith), nat.fib_add_two, add_comm],\n  norm_cast,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209006,"user_id":null,"body":"import Preloaded data.nat.fib\nlemma phi_fib : 1 + phi = phi^2 := begin\n  rw phi, ring_nf, rw add_mul, assoc_rw @real.mul_self_sqrt 5, ring!, recover, linarith,\nend\n\nlemma psi_fib : 1 + psi = psi^2 := begin\n  rw psi, ring_nf, rw sub_mul, assoc_rw @real.mul_self_sqrt 5, ring!, recover, linarith,\nend\n\ndef p := \u03bb (n : \u2115), (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n\nlemma p_eq {n : \u2115} : p n \u2194 (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 := by refl\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n  change p n, apply nat.strong_induction_on,\n  intros n ih,\n  cases n with n, { rw p_eq, norm_num },\n  cases n with n, { rw [p_eq, phi, psi], simp, ring_nf, rw mul_comm, rw mul_inv_cancel, norm_num },\n\n  have h1 := ih n (@nat.lt_add_of_pos_right _ 2 (by linarith)),\n  have h2 := ih n.succ (nat.lt.base _),\n  rw p_eq at *,\n  rw [pow_add phi _ 2, \u2190phi_fib, pow_add psi _ 2, \u2190psi_fib, nat.fib_add_two],\n  norm_num,\n  rw [h1, h2, pow_add phi _ 1, pow_add psi _ 1], ring\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209007,"user_id":null,"body":"import Preloaded data.nat.fib\nimport tactic tactic.induction\n\nlemma hphi : \u2200(n : \u2115), phi^(n+2) = phi^(n+1) + phi^n :=\nbegin\n  intros n,\n  rw [pow_add, pow_add], \n  simp [phi, \u2190sub_eq_zero], \n  ring_nf,\n  rw @real.sq_sqrt 5 (by linarith),\n  norm_num,\nend \n\nlemma hpsi : \u2200(n : \u2115), psi^(n+2) = psi^(n+1) + psi^n :=\nbegin\n  intros n,\n  rw [pow_add, pow_add], \n  simp [psi, \u2190sub_eq_zero], \n  ring_nf,\n  rw @real.sq_sqrt 5 (by linarith),\n  norm_num,\nend \n\nlemma binet_aux (n : \u2115) : \u2200m \u2264 n, (nat.fib m : \u211d) = (phi^m - psi^m) \/ real.sqrt 5 := \nbegin\n  induction' n,\n  { intros m hm, \n    rw nat.eq_zero_of_le_zero hm, \n    norm_num },    \n  intros m hm,\n  rcases lt_or_eq_of_le hm with (h | rfl),\n  { rw nat.succ_eq_add_one at *, exact ih m (by linarith) },\n  have nz : real.sqrt 5 \u2260 0 := by norm_num,\n  cases n,  \n  { simp [phi, psi], ring_nf, simp [nz] },\n  repeat { rw [nat.succ_eq_add_one] at *},\n  rw nat.fib_add_two, push_cast,\n  rw [ih n (by linarith), ih (n+1) (by linarith)], \n  field_simp, \n  rw [hphi n, hpsi n],\n  ring, \nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbinet_aux n n (le_refl n)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209008,"user_id":196,"body":"import Preloaded data.nat.fib tactic\n\nlemma phi_sub_psi : phi - psi = real.sqrt 5 :=\nby rw [phi, psi, \u2190 sub_div, add_sub_sub_cancel, add_self_div_two]\n\nlemma phi_mul_self : phi * phi = phi + 1 :=\nby rw [phi, div_mul_div, add_mul_self_eq, mul_one, \u2190 pow_two, mul_one, real.sq_sqrt (by norm_num : (0:\u211d) \u2264 5),\n      add_right_comm, (by norm_num : (1 + 5:\u211d) = 2 * 3), \u2190 mul_add, mul_div_mul_left _ _ (by norm_num : (2:\u211d) \u2260 0),\n      div_add', add_right_comm]; norm_num\n\nlemma psi_mul_self : psi * psi = psi + 1 :=\nby rw [psi, div_mul_div, sub_eq_add_neg, add_mul_self_eq, neg_mul_neg, mul_one, \u2190 pow_two, mul_one, real.sq_sqrt (by norm_num : (0:\u211d) \u2264 5),\n      add_right_comm, (by norm_num : (1 + 5:\u211d) = 2 * 3), \u2190 mul_add, mul_div_mul_left _ _ (by norm_num : (2:\u211d) \u2260 0),\n      div_add', add_right_comm]; norm_num\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n  suffices : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n    \u2227 (nat.fib (n+1) : \u211d) = (phi^(n+1) - psi^(n+1)) \/ real.sqrt 5, { tauto },\n  have hr5 : real.sqrt 5 \u2260 0,\n  { intro H, rw real.sqrt_eq_zero' at H, revert H, norm_num },\n  induction n with n ih,\n  { split,\n    { rw [nat.fib_zero, nat.cast_zero, pow_zero, pow_zero, sub_self, zero_div] },\n    { rw [nat.fib_one, nat.cast_one, pow_one, pow_one, phi_sub_psi, div_self hr5] } },\n  cases ih with ih0 ih1, split, { exact ih1 },\n  rw [nat.fib_add_two, nat.cast_add, ih0, ih1, \u2190 add_div], congr' 1,\n  simp only [pow_succ], rw [\u2190 mul_assoc, phi_mul_self, \u2190 mul_assoc, psi_mul_self],\n  ring\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209009,"user_id":null,"body":"import Preloaded data.nat.fib\n\nopen real\n\nlemma sqrt_five_mul_sqr : (sqrt 5) * (sqrt 5) = 5 := mul_self_sqrt (show 0 \u2264 (5 : \u211d), by norm_num)\n\n-- Refactored using the awsome power of `field_simp`.\nlemma one_add_phi : 1 + phi = phi^2 := by { field_simp [phi], linarith [sqrt_five_mul_sqr], }\n\nlemma one_add_psi : 1 + psi = psi^2 := by { field_simp [psi], linarith [sqrt_five_mul_sqr], }\n         \ntheorem binet : \u2200 n : \u2115, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n| 0   := by simp\n| 1   := by { simp [pow_one, phi, psi], ring, rw inv_mul_cancel, intro h, linarith [show (0 : \u211d) * 0 = 5, from h \u25b8 sqrt_five_mul_sqr], }\n| (n+2) :=\nbegin\n  rw [nat.fib_succ_succ], push_cast, rw [binet n, binet (n+1)],\n  calc (phi ^ n - psi ^ n) \/ sqrt 5 + (phi ^ (n + 1) - psi ^ (n + 1)) \/ sqrt 5\n        = ( phi ^ n * (1 + phi)  - psi ^ n * (1 + psi) ) \/ sqrt 5 : by { simp only [pow_succ], ring, }\n    ... = (phi ^ (n + 2) - psi ^ (n + 2)) \/ sqrt 5 : by { simp only [one_add_phi, one_add_psi, pow_add], }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209010,"user_id":null,"body":"import Preloaded data.nat.fib\n\nopen real\n\nlemma sqrt_five_mul_sqr : (sqrt 5) * (sqrt 5) = 5 := mul_self_sqrt (show 0 \u2264 (5 : \u211d), by norm_num)\n\nlemma one_add_phi : 1 + phi = phi^2 :=\ncalc 1 + phi = (1 + 2*sqrt 5 + 5)\/4 : by { dsimp [phi], ring }\n         ... = (1+ sqrt 5)^2 \/ 2^2 : by {congr' 1; rw pow_two, simp only [mul_add, add_mul, sqrt_five_mul_sqr], ring, ring }\n         ... = phi ^2 : by { rw \u2190div_pow _ _ 2, congr' 1}\n\nlemma one_add_psi : 1 + psi = psi^2 :=\ncalc 1 + psi = (1 - 2*sqrt 5 + 5)\/4 : by { dsimp [psi], ring }\n         ... = (1 - sqrt 5)^2 \/ 2^2 : by {congr' 1; rw pow_two, simp only [mul_sub, sub_mul, sqrt_five_mul_sqr], ring, ring, }\n         ... = psi ^2 : by { rw \u2190div_pow _ _ 2, congr' 1,}\n\ntheorem binet : \u2200 n : \u2115, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n| 0   := by simp\n| 1   := by { simp [pow_one, phi, psi], ring, rw inv_mul_cancel, intro h, have h\u2082 := sqrt_five_mul_sqr, rw [h, mul_zero] at h\u2082, linarith }\n| (n+2) :=\nbegin\n  rw [nat.fib_succ_succ], push_cast,\n  rw [binet n, binet (n+1)],\n  calc (phi ^ n - psi ^ n) \/ sqrt 5 + (phi ^ (n + 1) - psi ^ (n + 1)) \/ sqrt 5\n        = ( phi ^ n * (1 + phi)  - psi ^ n * (1 + psi) ) \/ sqrt 5 : by { simp only [pow_succ], ring, }\n    ... = (phi ^ (n + 2) - psi ^ (n + 2)) \/ sqrt 5 : by { simp only [one_add_phi, one_add_psi, pow_add], }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209011,"user_id":null,"body":"import Preloaded data.nat.fib\nimport tactic\n\nlemma lt_wrap {n m: nat} {h: n < m}: n.lt m\n:= by assumption\n\nlemma ind2 {C: \u2115 \u2192 Prop} {n: \u2115}:\n  C 0 \u2192 C 1 \u2192 (\u2200 k: \u2115, C k \u2192 C (k + 1) \u2192 C (k + 2)) \u2192 C n\n:=\nbegin\n  intros h0 h1 hstep,\n  apply nat.lt_wf.induction,\n  intros n ih,\n  rcases n with _ | _ | n,\n    assumption',\n  apply hstep,\n  apply ih n (by apply lt_wrap; omega),\n  apply ih (n + 1) (by apply lt_wrap; omega),\nend\n\nlemma lem_phi2: phi^2 = phi + 1\n:=\nbegin\n  unfold phi,\n  unfold pow monoid.pow,\n  field_simp,\n  ring_exp,\n  rw [real.sqr_sqrt _],\n  ring,\n  linarith,\nend\n\n#check pow\n\nlemma lem_psi2: psi^2 = psi + 1\n:=\nbegin\n  unfold psi,\n  unfold pow monoid.pow,\n  field_simp,\n  ring_exp,\n  rw [real.sqr_sqrt _],\n  ring,\n  linarith,\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n  induction n using ind2 with n ihn1 ihn2,\n  {\n    simp,\n  }, {\n    simp,\n    unfold phi psi,\n    ring,\n    symmetry,\n    apply @inv_mul_cancel _ _ (real.sqrt 5) _,\n    intro h,\n    let h2 := (real.sqrt_eq_zero _).1 h,\n    linarith,\n    linarith,\n  }, {\n    rw nat.fib_succ_succ,\n    simp,\n    rw [ihn1, ihn2], clear ihn1 ihn2,\n    conv {\n      to_rhs,\n      congr,\n      rw [pow_add phi n 2, lem_phi2],\n      rw [pow_add psi n 2, lem_psi2],\n    },\n    ring_exp,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209012,"user_id":null,"body":"import Preloaded data.nat.fib\n\nlemma din (P : \u2115 \u2192 Prop) (h\u2080 : P 0) (h\u2081 : P 1) (hss : \u2200 n, P n \u2192 P (n+1) \u2192 P (n+2)) :\n  \u2200 n, P n :=\nbegin\n  intro n,\n  suffices : P n \u2227 P (n+1), cc,\n  induction n with d hd,\n    exact \u27e8h\u2080, h\u2081\u27e9,\n  use hd.2,\n  apply hss d,\n  repeat {cc},\nend\n\nlemma phi_pow_two : phi ^ 2 = phi + 1 :=\nbegin\n  rw phi,\n  field_simp,\n  rw pow_two,\n  repeat { rw add_mul, rw mul_add },\n  rw \u2190 pow_two (real.sqrt 5),\n  rw real.sqr_sqrt (by norm_num : (0:\u211d) \u2264 5),\n  ring,\nend\n\nlemma psi_pow_two : psi ^ 2 = psi + 1 :=\nbegin\n  rw psi,\n  field_simp,\n  rw pow_two,\n  repeat { rw sub_mul, rw mul_sub },\n  rw \u2190 pow_two (real.sqrt 5),\n  rw real.sqr_sqrt (by norm_num : (0:\u211d) \u2264 5),\n  ring,\nend\n\ntheorem binet' : \u2200 n, (nat.fib n : \u211d) * real.sqrt 5 = phi^n - psi^n :=\nbegin\n  apply din,\n  { norm_num },\n  { dsimp [phi, psi], ring },\n\n  { intros n hn hnn,\n    repeat { rw pow_add at * },\n    rw nat.fib_succ_succ, push_cast, rw add_mul,\n    rw [hn, hnn, phi_pow_two, psi_pow_two],\n    ring },\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi ^ n - psi ^ n) \/ real.sqrt 5 :=\nby { rw [\u2190binet' n, mul_div_assoc, div_self, mul_one], norm_num, }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209013,"user_id":null,"body":"import Preloaded data.nat.fib tactic.ring_exp\n\nnotation `\u03c6` := phi\nnotation `\u03c8` := psi\n\nlemma phi_sq_eq_phi_add_one : \u03c6^2 = \u03c6+1 := \nbegin\n  rw phi,\n  ring_exp,\n  rw [@real.sqr_sqrt 5 (by norm_num)],\n  ring\nend\n\nlemma psi_sq_eq_psi_add_one : \u03c8^2 = \u03c8 + 1 :=\nbegin\n  rw psi,\n  ring_exp,\n  rw [@real.sqr_sqrt 5 (by norm_num)],\n  ring\nend\n\nsection fibrec\n\nvariables {\u03b1 : Type*} [semiring \u03b1]\n\ndef satisfy_fib_rec (u : \u2115 \u2192 \u03b1) :=\n  \u2200 n, u (n+2) = u n + u (n+1)\n\nlemma satisfy_fib_rec_linear {u v : \u2115 \u2192 \u03b1} {a b : \u03b1}\n  (hu : satisfy_fib_rec u) (hv : satisfy_fib_rec v) : satisfy_fib_rec (\u03bb n, a * u n + b * v n) :=\nbegin\n  intros n,\n  simp only,\n  rw [hu n, hv n, mul_add, mul_add],\n  ac_refl,\nend\n\nend fibrec\n\nlemma phi_pow_satisfy_fib_rec : satisfy_fib_rec (\u03bb n, (\u03c6^n)) :=\nbegin\n  intros n,\n  simp only,\n  rw pow_add,\n  rw phi_sq_eq_phi_add_one,\n  ring_exp\nend\n\nlemma psi_pow_satisfy_fib_rec : satisfy_fib_rec (\u03bb n, (\u03c8^n)) :=\nbegin\n  intros n,\n  simp only,\n  rw pow_add,\n  rw psi_sq_eq_psi_add_one,\n  ring_exp\nend\n\nlemma eq_fib_of_satisfy_fib_rec (u : \u2115 \u2192 \u211d) (h\u2080 : u 0 = 0) (h\u2081 : u 1 = 1)\n  (h\u2099 : satisfy_fib_rec u) :\n  \u2200 n : \u2115, (n.fib : \u211d) = u n\n| 0 := by rw [nat.fib_zero, nat.cast_zero, h\u2080]\n| 1 := by rw [nat.fib_one, nat.cast_one, h\u2081]\n| (n+2) :=\n  by rw [h\u2099, nat.fib_succ_succ, nat.cast_add, eq_fib_of_satisfy_fib_rec, eq_fib_of_satisfy_fib_rec]\n\nlemma binet : \u2200 (n : \u2115), (nat.fib n : \u211d) = (\u03c6^n - \u03c8^n)\/(real.sqrt 5) :=\nbegin\n  apply eq_fib_of_satisfy_fib_rec,\n  { ring_exp },\n  { rw [psi, phi], \n    ring_exp,\n    refine mul_inv_cancel _,\n    norm_num },\n  { ring,\n    simp_rw [sub_eq_add_neg, neg_mul_eq_neg_mul],\n    apply satisfy_fib_rec_linear, \n    { exact phi_pow_satisfy_fib_rec },\n    { exact psi_pow_satisfy_fib_rec } }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209014,"user_id":null,"body":"import Preloaded data.nat.fib\n\nlemma phi_mul_psi : phi * psi = -1 :=\nby unfold phi psi; field_simp; rw \u2190 mul_self_sub_mul_self_eq; norm_num\n\nlemma phi_add_psi : phi + psi = 1 := by unfold phi psi; field_simp\nlemma one_sub_psi : 1 - phi = psi := by linarith [phi_add_psi]\nlemma one_sub_phi : 1 - psi = phi := by linarith [phi_add_psi]\nlemma phi_square : phi * phi = phi + 1 := \nby have pmp := phi_mul_psi; rw [\u2190one_sub_psi, mul_sub] at pmp; linarith\nlemma psi_square : psi * psi = psi + 1 :=\nby have pmp := phi_mul_psi; rw [\u2190one_sub_phi, sub_mul] at pmp; linarith\n\nlemma phi_sub_psi : phi - psi = real.sqrt 5 := by unfold phi psi; ring\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n  revert n, apply nat.strong_rec', intros n h,\n  cases n, norm_num, cases n, simp, rw phi_sub_psi,\n  have p: real.sqrt 5 \u2260 0, norm_num, simp [p],  \n  rw nat.fib_succ_succ, push_cast, rw [h n, h n.succ],\n  repeat {rw pow_succ}, field_simp, congr' 1, \n  repeat {rw \u2190 mul_assoc}, rw [phi_square, psi_square], ring,\n  apply nat.lt_succ_self, apply lt_trans (nat.lt_succ_self n),\n  apply nat.lt_succ_self,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209015,"user_id":null,"body":"import Preloaded data.nat.fib algebra.field tactic\n\ntheorem binet : \u2200 (n : \u2115), (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n| 0 := by norm_num\n| 1 := by { dsimp [phi, psi], norm_num, ring, rw inv_mul_cancel, norm_num }\n| (nat.succ (nat.succ n)) :=\n   let h\u2080 := binet n, h\u2081 := binet n.succ in begin\n     rw nat.fib_succ_succ, push_cast, rw [h\u2081, h\u2080], rw div_add_div_same, congr' 1,\n     obtain \u27e8h\u03d5, h\u03c8\u27e9 : 1 + phi = phi * phi \u2227 1 + psi = psi * psi,\n     by split; { dsimp [phi, psi], ring SOP, rw @real.sqr_sqrt 5 (by norm_num), ring SOP },\n     simp only [pow_succ],\n     rw (calc phi ^ n - psi ^ n + (phi * phi ^ n - psi * psi ^ n)\n               = (phi ^ n + phi * phi ^ n) - (psi ^ n + psi * psi ^ n) : by { rw [add_sub,\n                                                                                  sub_add_eq_add_sub,\n                                                                                  sub_sub] }\n           ... = (1 + phi) * phi ^ n - (1 + psi) * psi ^ n : by simp [add_mul]),\n     congr' 1; rw \u2190mul_assoc; congr, exact h\u03d5, exact h\u03c8,\n   end\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209016,"user_id":null,"body":"import Preloaded data.nat.fib\n\n\nlemma phi_plus_1 : phi + 1 = phi^2 :=\ncalc phi + 1 = ((1 + real.sqrt 5)\/ 2) + 1 : by rw phi\n    ... = (1 + 5 + 2*real.sqrt 5)\/4 : by ring\n    ... = (1 + (real.sqrt 5)^2 + 2*real.sqrt 5)\/4 : by rw real.sqr_sqrt; linarith\n    ... = ((1 + real.sqrt 5)\/2)^2 : by ring\n    ... = phi^2 : by rw \u2190 phi\n\nlemma psi_plus_1 : psi + 1 = psi^2 :=\ncalc psi + 1 = ((1 - real.sqrt 5)\/ 2) + 1 : by rw psi\n    ... = (1 + 5 - 2*real.sqrt 5)\/4 : by ring\n    ... = (1 + (real.sqrt 5)^2 - 2*real.sqrt 5)\/4 : by rw real.sqr_sqrt; linarith\n    ... = ((1 - real.sqrt 5)\/2)^2 : by ring\n    ... = psi^2 : by rw \u2190 psi\n\ntheorem binet : \u2200 n : \u2115, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n| 0 := by norm_num\n| 1 :=\nbegin\n    rw [phi, psi, pow_one, pow_one, \u2190 sub_div],\n    simp only [nat.fib_one, nat.cast_one],\n    ring,\n    rw inv_mul_cancel (show real.sqrt 5 \u2260 0, from by norm_num),\nend\n| (n + 2) :=\ncalc (nat.fib (n + 2) : \u211d) = \u2191(nat.fib n + nat.fib (n + 1)) : by rw nat.fib_succ_succ\n    ... = \u2191(nat.fib n) + \u2191(nat.fib (n + 1)) : by rw nat.cast_add\n    ... = (phi^n - psi^n)\/real.sqrt 5 + (phi^(n + 1) - psi^(n + 1))\/real.sqrt 5 : by rw [binet n, binet (n + 1)]\n    ... = (phi^n - psi^n + (phi^(n + 1) - psi^(n+1)))\/real.sqrt 5 : by rw \u2190 add_div\n    ... = ((phi^n + phi^(n + 1)) - (psi^n + psi^(n + 1)))\/real.sqrt 5 : by ring\n    ... = ((phi^n + phi^n * phi) - (psi^n + psi^n * psi))\/real.sqrt 5 : by simp [pow_succ, mul_comm]\n    ... = (phi^n * (phi + 1) - psi^n * (psi + 1))\/real.sqrt 5 : by ring\n    ... = (phi^n * phi^2 - psi^n * psi^2)\/real.sqrt 5 : by rw [phi_plus_1, psi_plus_1]\n    ... = (phi^(n + 2) - psi^(n + 2))\/real.sqrt 5 : by simp [pow_add]\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209017,"user_id":null,"body":"import Preloaded data.nat.fib\n\n\ntheorem rt5_ne_zero : real.sqrt 5 \u2260 0 := by norm_num\n\ntheorem binet : \u2200 (n : \u2115), (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n| 0 := by simp\n| 1 := by {\n    rw [psi, phi],\n    simp,\n    ring,\n    rw [mul_comm, mul_inv_cancel],\n    exact rt5_ne_zero,\n}\n| (n + 2) := by {\n    have h0 := binet n,\n    have h1 := binet (n + 1),\n    clear binet,\n    rw nat.fib_succ_succ,\n    rw nat.cast_add,\n    rw h0,\n    rw h1,\n    clear h0 h1,\n    rw \u2190 sub_eq_zero,\n    rw div_add_div_same,\n    rw div_sub_div_same,\n    rw div_eq_zero_iff rt5_ne_zero,\n\n    repeat {rw [pow_add]},\n    repeat {rw [pow_one]},\n\n    have hph : phi^2 = phi + 1, by {\n        rw phi, rw pow_two,\n        field_simp,\n        repeat { rw mul_add },\n        repeat { rw add_mul },\n        have duh : (0 : \u211d) \u2264 5, by { norm_num },\n        rw \u2190 real.sqrt_mul',\n        swap, exact duh,\n        rw real.sqrt_mul_self duh,\n        ring,\n    },\n    have hps : psi^2 = psi + 1, by {\n        rw psi, rw pow_two,\n        field_simp,\n        repeat { rw mul_add },\n        repeat { rw add_mul },\n        repeat { rw mul_sub },\n        repeat { rw sub_mul },\n        have duh : (0 : \u211d) \u2264 5, by { norm_num },\n        rw \u2190 real.sqrt_mul',\n        swap, exact duh,\n        rw real.sqrt_mul_self duh,\n        ring,\n    },\n    rw hph,\n    rw hps,\n    ring,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209018,"user_id":null,"body":"import Preloaded data.nat.fib\n\nlemma lem0 (a b c : \u211d) : (a\/c) - (b\/c) = (a-b)\/c :=\nbegin\n    by {exact div_sub_div_same a b c},\nend \n\nlemma lem1 : phi - psi = real.sqrt 5 :=\nbegin\n    unfold phi,\n    unfold psi,\n    rw lem0,\n    ring,\nend\n\nlemma lem2a (n : \u2115) : phi^2 = 1 + phi :=\nbegin\n    unfold phi,\n    ring,\n    rw add_mul,\n    rw mul_assoc,\n    rw real.mul_self_sqrt,\n    ring,\n    linarith,\nend\n\nlemma lem2 (n : \u2115) : phi^(n+2) = phi^n + phi^(n+1) :=\nbegin\n    rw pow_add,\n    rw pow_add,\n    rw lem2a n,\n    ring,\nend\n\nlemma lem3a (n : \u2115) : psi^2 = 1 + psi :=\nbegin\n    unfold psi,\n    ring,\n    rw sub_mul,\n    rw mul_assoc,\n    rw real.mul_self_sqrt,\n    ring,\n    linarith,\nend\n\nlemma lem3 (n : \u2115) : psi^(n+2) = psi^n + psi^(n+1) :=\nbegin\n    rw pow_add,\n    rw pow_add,\n    rw lem3a n,\n    ring,\nend\n\ndefinition bin (n : \u2115) : Prop := (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n\nlemma bin0 : bin 0 :=\nbegin\n    unfold bin,\n    ring,\nend\n\nlemma bin1 : bin 1 :=\nbegin\n    unfold bin,\n    rw [nat.fib_one,pow_one,pow_one,nat.cast_one,lem1],\n    symmetry,\n    apply div_self,\n    by_contradiction,\n    push_neg at a,\n    have h : real.sqrt 5 * real.sqrt 5 = 5,\n    apply real.mul_self_sqrt,\n    linarith,\n    rw a at h,\n    linarith,\nend\n\nlemma induct (n : \u2115) : ((bin n) \u2227 bin (n+1)) \u2192 bin (n+2) :=\nbegin\n    intro h,\n    cases h with h0 h1,\n    unfold bin at *,\n    rw nat.fib_succ_succ,\n    simp only [nat.cast_add],\n    rw h0,\n    rw h1,\n    clear h0 h1,\n    rw div_add_div_same,\n    rw lem2,\n    rw lem3,\n    ring,\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n    have h : \u2200 m, \u2200 k \u2264 m, bin k,\n    intro m,\n    induction m with m ih,\n    intros k h,\n    have h1 := eq_bot_iff.mpr h,\n    rw h1,\n    exact bin0,\n    intros k h,\n    cases h with h h,\n    cases m,\n    exact bin1,\n    apply induct,\n    split,\n    apply ih m,\n    rw nat.succ_eq_add_one,\n    linarith,\n    apply ih,\n    rw nat.succ_eq_add_one,\n    apply ih,\n    exact h,\n    apply (h n n),\n    refl,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209019,"user_id":null,"body":"import Preloaded data.nat.fib\nimport init.wf\nimport tactic\n\nopen well_founded\n\nlemma phi_sol : phi^2 = phi + 1 :=\nbegin\nunfold phi,\napply eq_of_sub_eq_zero, ring, rw real.sqr_sqrt; norm_num,\nend\n\nlemma psi_sol : psi^2 = psi + 1 :=\nbegin\nunfold psi,\napply eq_of_sub_eq_zero, simp, ring, rw real.sqr_sqrt; norm_num,\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\napply @well_founded.fix \u2115 (\u03bb n, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5) nat.lt nat.lt_wf,\nintros,\ncases x, simp,\ncases x, simp, unfold phi, unfold psi, ring, rw inv_mul_cancel, norm_num,\nrw nat.fib_succ_succ,\nsimp only [nat.cast_add],\nrw [pow_add _ x 2, pow_add _ x 2, psi_sol, phi_sol, a x, a (x+1), \u2190add_div, div_left_inj'],\nring_exp, norm_num,\napply lt_add_one (x+1),\napply nat.lt_succ_iff.mp, apply nat.le_succ,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209020,"user_id":null,"body":"import Preloaded data.nat.fib\n\nimport tactic\n\nlemma fivepos : (0 \u2264 (5 : \u211d) ) :=\nbegin\nnorm_num,\nend\n\n\nlemma quad : phi ^ 2 = 1 + phi :=\ncalc \nphi ^ 2 \n     = phi * phi :\n        by { apply pow_two }\n ... = (1 + real.sqrt 5) \/ 2 * ((1 + real.sqrt 5) \/ 2) : \n        by { unfold phi }\n ... = (1 * 1 + 1 * real.sqrt 5 + real.sqrt 5 * 1 + (real.sqrt 5) ^ 2 ) \/ 4 : \n        by { ring, }\n ... = (1 * 1 + 1 * real.sqrt 5 + real.sqrt 5 * 1 + 5 ) \/ 4 :\n        by { rw real.sqr_sqrt fivepos, }\n ... = (6 + 2 * real.sqrt 5) \/ 4 :\n        by { ring, }                    \n ... = 1 + phi :\n        by { rw phi, ring }\n\n\nlemma quad\u2082 : psi ^ 2 = 1 + psi :=\ncalc \npsi ^ 2\n     = psi * psi :\n        by { apply pow_two }\n ... = (1 - real.sqrt 5) \/ 2 * ((1 - real.sqrt 5) \/ 2) : \n        by { unfold psi }\n ... = (1 * 1 - 1 * real.sqrt 5 - real.sqrt 5 * 1 + (real.sqrt 5) ^ 2 ) \/ 4 : \n        by { ring, }\n ... = (1 * 1 - 1 * real.sqrt 5 - real.sqrt 5 * 1 + 5 ) \/ 4 :\n        by { rw real.sqr_sqrt fivepos, }\n ... = (6 - 2 * real.sqrt 5) \/ 4 :\n        by { ring, }                    \n ... = 1 + psi :\n        by { rw psi, ring }\n\n\nlemma main : \u2200 (n : \u2115), phi ^ (n + 2) = phi ^ n + phi ^ (n + 1) :=\nbegin\nintros, \ncalc\nphi ^ (n + 2) = (phi ^ n) * (phi ^ 2) : by { apply pow_add }\n          ... = (phi ^ n) * (1 + phi) : by { rw quad, }\n          ... = phi ^ n + (phi ^ n) * phi : by { ring } \n          ... = phi ^ n + phi ^ (n + 1) : by { rw pow_succ' }\nend\n\n\nlemma main\u2082 : \u2200 (n : \u2115), psi ^ (n + 2) = psi ^ n + psi ^ (n + 1) :=\nbegin\nintros, \ncalc\npsi ^ (n + 2) = (psi ^ n) * (psi ^ 2) : by { apply pow_add }\n          ... = (psi ^ n) * (1 + psi) : by { rw quad\u2082, }\n          ... = psi ^ n + (psi ^ n) * psi : by { ring } \n          ... = psi ^ n + psi ^ (n + 1) : by { rw pow_succ' }\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n\n induction n with m ih,\n simp at *,\n suffices P : \u2200 (p : \u2115 ), \u2191(nat.fib p) = (phi ^ p - psi ^ p) \/ real.sqrt 5 \u2227 \u2191(nat.fib (nat.succ p)) = (phi ^ nat.succ p - psi ^ nat.succ p) \/ real.sqrt 5,\n  from (P m).2,\n intro,\n induction p with q h,\n split, ring,\n norm_num,\n unfold phi, unfold psi,\n ring,\n have silly : real.sqrt 5 \u2260 0, norm_num,\n have := inv_mul_cancel silly,\n ring, symmetry, simp at *,\n exact this,\n rw nat.succ_eq_add_one at *,\n rw nat.succ_eq_add_one,\n split;\n cases h with h\u2081 h\u2082,\n from h\u2082,\n rw nat.fib_succ_succ,\n simp at *,\n rw h\u2081,\n rw h\u2082,\n rw main,\n rw main\u2082,\n ring, \nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209021,"user_id":722,"body":"import Preloaded data.nat.fib\n\nlemma phi_fib' : phi^2 = phi + 1 :=\nbegin\n  unfold phi,\n  ring,\n  rw [add_mul, mul_assoc, \u2190real.sqrt_mul, real.sqrt_mul_self],\n  ring,\n  norm_num,\n  norm_num,\nend\n\nlemma psi_fib' : psi^2 = psi + 1 :=\nbegin\n  unfold psi,\n  ring,\n  rw [sub_mul, mul_assoc, \u2190real.sqrt_mul, real.sqrt_mul_self],\n  ring,\n  norm_num,\n  norm_num,\nend\n\nlemma phi_fib (n : \u2115) : phi^(n + 2) = phi^(n + 1) + phi^n :=\nbegin\n  rw [pow_add, pow_add, pow_one],\n  conv { to_rhs, congr, skip, rw \u2190mul_one (phi^n) },\n  rw [\u2190mul_add, phi_fib'],\nend\n\nlemma psi_fib (n : \u2115) : psi^(n + 2) = psi^(n + 1) + psi^n :=\nbegin\n  rw [pow_add, pow_add, pow_one],\n  conv { to_rhs, congr, skip, rw \u2190mul_one (psi^n) },\n  rw [\u2190mul_add, psi_fib'],\nend\n\nlemma binet' (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n  \u2227 (nat.fib (n + 1) : \u211d) = (phi^(n + 1) - psi^(n + 1)) \/ real.sqrt 5 :=\nbegin\n  induction n with k hk,\n  { split,\n    { norm_num },\n    { unfold phi psi,\n      norm_num,\n      ring,\n      rw inv_mul_cancel,\n      -- sqrt 5 is not zero\n      norm_num } },\n  cases hk with hk hkp1,\n  split,\n  { exact hkp1 },\n  rw nat.fib_succ_succ,\n  norm_num,\n  rw [hk, hkp1, \u2190add_div, psi_fib, phi_fib],\n  ring,\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\n  and.left (binet' n)\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209022,"user_id":657,"body":"import Preloaded data.nat.fib\nimport data.real.basic \nimport data.nat.fib\nimport tactic\n\nnoncomputable theory\n\ndef char_polynomial (x:\u211d) := x^2 -x - 1\n\nlemma characteristic_polynomial_phi : char_polynomial phi = 0 := begin\nrw phi, rw char_polynomial,\nring_exp, \nhave key : (real.sqrt 5) ^2 = 5 := by norm_num, \nrw key, \nnorm_num,\nend\n\nlemma characteristic_polynomial_psi : char_polynomial psi = 0 := begin\nrw psi, rw char_polynomial,\nring_exp, \nhave key : (real.sqrt 5) ^2 = 5 := by norm_num, \nrw key, \nnorm_num,\nend\n\ntheorem root_ne_zero (x : \u211d ) (hx : char_polynomial x = 0) : x\u2260 0 := begin\nhave key : char_polynomial 0 \u2260 0,\nrw char_polynomial, norm_num, \nintro h, apply_fun char_polynomial at h, \nrw hx at h, finish,\nend\nlemma phi_ne_zero : phi \u2260 0 := root_ne_zero phi characteristic_polynomial_phi\n\nlemma psi_ne_zero : psi \u2260 0 := root_ne_zero psi characteristic_polynomial_psi\n\nlemma char_polynomial_recurrence (n : \u2115) (x : \u211d ) (h: x^2 -x - 1 = 0) (h0 : x \u2260 0): x ^ (n + 2) = x^(n+1) + x^n := begin\nring_exp, \nsuffices key : x^2 = x + 1, rw key, ring, linarith,\nend\n\n\nlemma case_bash  (n : \u2115 ): n = 0 \u2228 n = 1 \u2228 \u2203(k:\u2115) , n = k+2 := begin\ninduction n with d hd, simp,\ncases hd, rw hd, simp,\ncases hd, rw hd, right, right, use 0,\ncases hd with kd hkd, right, right, use kd + 1, rw hkd,\nend\n\ntheorem binet : \u2200 n : \u2115, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 := begin\nintro n, \n\napply @nat.strong_induction_on (\u03bb n, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5) n,\nintros, \ncases case_bash n_1,\nrw h, simp,\ncases h, rw h, rw phi, rw psi, rw nat.fib_one, ring_exp, simp, rw mul_comm, rw inv_mul_cancel, norm_num,\ncases h with k h, rw h,\n\nrw char_polynomial_recurrence k phi,\nrw char_polynomial_recurrence k psi,\nrw nat.fib_succ_succ,\npush_cast, rw a k, rw a (k+1), ring_exp,\n\nlinarith,\nlinarith,\n\nrw \u2190 char_polynomial, exact characteristic_polynomial_psi,\nexact psi_ne_zero,\nrw \u2190 char_polynomial, exact characteristic_polynomial_phi,\nexact root_ne_zero _ characteristic_polynomial_phi,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209023,"user_id":659,"body":"import Preloaded data.nat.fib tactic\n\nlemma sqrt5_ne_zero : real.sqrt 5 \u2260 0 :=\nbegin\n  symmetry,\n  apply ne_of_lt,\n  rw real.sqrt_pos,\n  norm_num    \nend\n\n\ntheorem binet_aux (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 \u2227 \n  (nat.fib (n + 1) : \u211d) = (phi^(n+1) - psi^(n+1)) \/ real.sqrt 5 :=\nbegin\n  induction n with d hd,\n  { split, field_simp, field_simp [phi, psi, sqrt5_ne_zero],\n    ring,\n  },\n  cases hd with hd1 hd2,\n  split, exact hd2,\n  rw nat.fib_succ_succ,\n  push_cast,\n  rw [hd1, hd2],\n  field_simp [sqrt5_ne_zero],\n  congr' 1,\n  apply eq_of_sub_eq_zero,\n  suffices : phi^d*(1+phi-phi^2)-psi^d*(1+psi-psi^2)=0,\n    rw [\u2190this], simp [pow_succ], ring_exp,\n  suffices : 1+phi-phi^2=0 \u2227 1+psi-psi^2=0,\n    cases this with t1 t2, simp [t1,t2],\n  split,\n  { rw phi, field_simp, ring, rw [pow_two,(real.sqrt_prop 5).2], norm_num},\n  { rw psi, field_simp, ring, rw [pow_two,(real.sqrt_prop 5).2], norm_num},\nend\n\ntheorem binet (n : \u2115) : (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\n(binet_aux n).1\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209024,"user_id":644,"body":"import Preloaded data.nat.fib tactic.ring_exp\n\n\n@[simp] theorem fib_one : nat.fib 1 = 1 := rfl\n\ntheorem sqrt_five_ne_zero : real.sqrt 5 \u2260 0 :=\nby rw [ne.def, real.sqrt_eq_zero]; norm_num\n\nlemma real.sqrt_mul_sqrt {x : \u211d} (hx : 0 \u2264 x) : \n  real.sqrt x * real.sqrt x = x :=\nby rw [\u2190 real.sqrt_mul hx, real.sqrt_mul_self hx]\n\nlemma phi_pow_two : phi ^ 2 = phi + 1 :=\nbegin\n  rw [phi, pow_two, div_mul_div, mul_add, add_mul, add_mul,\n    one_mul, mul_one, one_mul, real.sqrt_mul_sqrt],\n  ring, norm_num\nend\n\nlemma psi_pow_two : psi ^ 2 = psi + 1 :=\nbegin\n  rw [psi, pow_two, div_mul_div, mul_sub, sub_mul, sub_mul,\n    one_mul, mul_one, one_mul, real.sqrt_mul_sqrt],\n  ring, norm_num\nend\n\nlemma phi_pow_sub_psi_pow (n : \u2115) : \n  phi ^ n - psi ^ n + (phi ^ (n + 1) - psi ^ (n + 1)) =\n  phi ^ (n + 2) - psi ^ (n + 2) :=\ncalc phi ^ n - psi ^ n + (phi ^ (n + 1) - psi ^ (n + 1))\n    = phi ^ n * (phi + 1) - psi ^ n * (psi + 1) : by ring_exp\n... = _ : by rw [\u2190 phi_pow_two, \u2190 psi_pow_two]; ring_exp\n  \ntheorem binet : \u2200 n, (nat.fib n : \u211d) = (phi^n - psi^n) \/ real.sqrt 5\n| 0     := by simp\n| 1     := by rw [nat.fib_one, pow_one, pow_one, phi, psi, \n  div_sub_div_same, add_sub_sub_cancel, \u2190 two_mul, \n  mul_div_cancel_left _ (show (2 : \u211d) \u2260 0, by norm_num),\n  div_self sqrt_five_ne_zero, nat.cast_one]\n| (n+2) := by rw [nat.fib_succ_succ, nat.cast_add, binet, binet, div_add_div_same,\n    phi_pow_sub_psi_pow]\n    \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209025,"user_id":null,"body":"import Preloaded data.nat.fib algebra.quadratic_discriminant\n\nlemma roots_phi_psi {x : \u211d} : x * x - x - 1 = 0 \u2194 x = phi \u2228 x = psi :=\nbegin\n  convert @quadratic_eq_zero_iff \u211d _ 1 (-1) (-1) one_ne_zero (real.sqrt 5) _ x;\n    simp [phi, psi, sub_eq_add_neg, discrim],\n  rw [real.mul_self_sqrt]; norm_num\nend\n\nlemma phi_sqr : phi ^ 2 = phi + 1 :=\nby rw [\u2190 sub_eq_iff_eq_add', pow_two, \u2190 sub_eq_zero, roots_phi_psi.2 (or.inl rfl)]\n\nlemma psi_sqr : psi ^ 2 = psi + 1 :=\nby rw [\u2190 sub_eq_iff_eq_add', pow_two, \u2190 sub_eq_zero, roots_phi_psi.2 (or.inr rfl)]\n\ntheorem fib_induction (p : \u2115 \u2192 \u2115 \u2192 Prop) (h0 : p 0 0) (h1 : p 1 1)\n  (H : \u2200 {n a b}, p n a \u2192 p (n + 1) b \u2192 p (n + 2) (a + b)) :\n  \u2200 n, p n n.fib\n| 0 := h0\n| 1 := h1\n| (n+2) := by { rw [nat.fib_succ_succ], exact H (fib_induction n) (fib_induction (n+1)) }\n\ntheorem binet (n : \u2115) : (n.fib : \u211d) = (phi^n - psi^n) \/ real.sqrt 5 :=\nbegin\n  apply fib_induction (\u03bb n a, (a : \u211d) = (phi^n - psi^n) \/ real.sqrt 5),\n  { simp },\n  { rw [nat.cast_one, pow_one, pow_one, phi, psi, div_sub_div_same, \u2190 sub_add,\n      add_sub_cancel', \u2190 mul_two, mul_div_cancel _ (@two_ne_zero \u211d _), div_self],\n    norm_num },\n  { clear n,\n    intros n a b ha hb,\n    rw [nat.cast_add, ha, hb],\n    simp only [div_add_div_same, pow_add, phi_sqr, psi_sqr, pow_one, mul_one, mul_add],\n    congr' 1,\n    abel }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5d2bd8e414a6ef001a0421d2":[{"id":209026,"user_id":null,"body":"import Preloaded tactic.ring_exp analysis.special_functions.trigonometric.inverse\n\nopen polynomial real\n\ntheorem cheb_cos (n : \u2115) (x : \u211d) : \n  polynomial.eval (cos x) (cheb n) = cos (n * x) :=\nbegin\n  apply nat.strong_induction_on n,\n  intros n IH,\n  cases n with j hj, { simp [cheb], },\n  cases j with m hm, { simp [cheb], },\n  have angle_add : \u2200 n : \u2115, cos(\u2191(m + n) * x) = cos (m*x) * cos (\u2191n*x) - sin (m*x) * sin (\u2191n*x),\n  { intro n, rw [nat.cast_add, field.right_distrib, cos_add], refl, },\n  rw [nat.succ_eq_add_one, nat.succ_eq_add_one, cheb, eval_sub, eval_mul, eval_mul, IH m, eval_X, \n      IH m.succ, eval_bit0, eval_one, nat.succ_eq_add_one, angle_add 1, angle_add 2, nat.cast_bit0, \n      nat.cast_one, one_mul, sin_two_mul, cos_two_mul],\n  ring_exp,\n  repeat { repeat {rw nat.succ_eq_add_one}, linarith, },\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  polynomial.eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  rw set.mem_Icc at hx,\n  rw [(show x = cos (arccos x), by {rw cos_arccos; linarith}), cheb_cos],\n  apply cos_mem_Icc,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209027,"user_id":null,"body":"import Preloaded analysis.special_functions.trigonometric.basic\n\nopen real\n\ntheorem cheb_cos (n : \u2115) (x : \u211d) : \n  polynomial.eval (real.cos x) (cheb n) = real.cos (n * x) :=\nbegin\n  suffices strong_ind :\n    polynomial.eval (real.cos x) (cheb n) = real.cos (n * x)\n     \u2227 polynomial.eval (real.cos x) (cheb n.succ) = real.cos (n.succ * x),\n  { exact strong_ind.1 },\n  induction n with n ih,\n  {\n    split;\n    simp [cheb],\n  },\n  {\n    split,\n    exact ih.2,\n    simp [cheb,ih,add_mul,one_mul,cos_add,sin_add],\n    have : cos(n*x)* (sin x) * (sin x)= cos(n*x)*( 1- (cos x)^2):=\n      by rw [mul_assoc,\u2190 sq,sin_sq x],\n    rw this,\n    ring,\n  }\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  polynomial.eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  suffices : \u2203 t : \u211d , x = cos t,\n  cases this with t ht,\n  {\n    rw [ht,cheb_cos _ _],\n    split,\n    exact (\u2191n * t).neg_one_le_cos,\n    exact (\u2191n * t).cos_le_one,\n  },\n  have := real.surj_on_cos,\n  have := this hx,\n  tidy,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209028,"user_id":null,"body":"import Preloaded analysis.special_functions.trigonometric.basic\nimport analysis.special_functions.trigonometric.inverse\nimport tactic tactic.induction \n\ntheorem cheb_cos : \u2200(n : \u2115) (x : \u211d),\n  polynomial.eval (real.cos x) (cheb n) = real.cos (n * x) \n| 0 x     := by simp [cheb]\n| 1 x     := by simp [cheb]\n| (n+2) x := \n  begin\n    simp [cheb, (cheb_cos n x), (cheb_cos (n+1) x)],\n    have hs : (\u2191n + 2) * x = (\u2191n + 1) * x + 1 * x := by ring,\n    rw [hs, real.cos_add, \u2190one_add_one_eq_two, add_mul, add_mul], \n    have h := real.cos_add ((\u2191n + 1)*x) (-1 * x),\n    rw \u2190add_mul at h, \n    simp at *,\n    linarith,\n  end\n\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  polynomial.eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  cases hx with hL hR,\n  rw \u2190@real.cos_arccos x (by linarith) (by linarith),\n  rw cheb_cos,\n  apply real.cos_mem_Icc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209029,"user_id":168,"body":"import Preloaded analysis.special_functions.trigonometric.basic\n\nopen polynomial\n\ntheorem cheb_cos : \u2200 n x, eval (real.cos x) (cheb n) = real.cos (n * x)\n| 0 x := by simp only [cheb, eval_one, nat.cast_zero, zero_mul, real.cos_zero]\n| 1 x := by simp only [cheb, eval_X, one_mul, nat.cast_one]\n| (n + 2) x := \nbegin\n  rw [cheb, eval_sub, eval_mul, eval_mul, eval_X, bit0, eval_add, eval_one],\n  rw [cheb_cos, cheb_cos],\n  simp only [nat.cast_add, \u2190nat.add_one, add_mul, nat.cast_one, one_mul, real.cos_add, nat.cast_two, real.cos_two_mul, real.sin_two_mul],\n  ring,\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  suffices : \u2203 y, real.sin y = x,\n    obtain \u27e8y, eq\u27e9 := this,\n    rw [\u2190eq, \u2190real.cos_pi_div_two_sub, cheb_cos, set.mem_Icc],\n    simp only [real.neg_one_le_cos, real.cos_le_one, and_self],\n  have := set.mem_of_mem_of_subset hx real.surj_on_sin,\n  simp_rw [set.mem_image, set.mem_Icc] at this,\n  obtain \u27e8y, _, hy\u27e9 := this,\n  exact \u27e8y, hy\u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209030,"user_id":168,"body":"import Preloaded analysis.special_functions.trigonometric.basic\n\nopen polynomial\n\ntheorem cheb_cos : \u2200 n x, eval (real.cos x) (cheb n) = real.cos (n * x)\n| 0 x := by simp only [cheb, eval_one, nat.cast_zero, zero_mul, real.cos_zero]\n| 1 x := by simp only [cheb, eval_X, one_mul, nat.cast_one]\n| (n + 2) x := \nbegin\n  rw [cheb, eval_sub, eval_mul, eval_mul, eval_X, bit0, eval_add, eval_one],\n  rw [cheb_cos, cheb_cos],\n  simp only [nat.cast_add, \u2190nat.add_one, add_mul, nat.cast_one, one_mul, real.cos_add, nat.cast_two, real.cos_two_mul, real.sin_two_mul],\n  ring,\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  suffices : \u2203 y, real.sin y = x,\n    obtain \u27e8y, eq\u27e9 := this,\n    rw [\u2190eq, \u2190real.cos_pi_div_two_sub, cheb_cos, set.mem_Icc],\n    simp only [real.neg_one_le_cos, real.cos_le_one, and_self],\n  have := set.mem_of_mem_of_subset hx real.surj_on_sin,\n  simp_rw [set.mem_image, set.mem_Icc] at this,\n  obtain \u27e8y, _, hy\u27e9 := this,\n  exact \u27e8y, hy\u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209031,"user_id":null,"body":"import Preloaded analysis.special_functions.trigonometric\n\nopen polynomial real\n\nlemma cos_add_cos' (x : \u211d) (k : \u2115): cos ((k+1+1)*x) + cos (k*x) = 2 * cos ((k+1)*x) * cos (1*x):=\nbegin\n  have h\u2081 := cos_add ((k+1)*x) (1*x), have h\u2082 := cos_sub ((k+1)*x) (1*x),\n  rw [mul_assoc (2 : \u211d) _ _, two_mul], rw eq_sub_iff_add_eq' at h\u2081, rw \u2190sub_eq_iff_eq_add at h\u2082,\n  nth_rewrite_rhs 0 [\u2190h\u2081], rw [\u2190h\u2082],  nth_rewrite_rhs 1 add_comm, rw add_add_sub_cancel, congr' 2; ring,\nend\n\ntheorem cheb_cos (n : \u2115) (x : \u211d) : \n  polynomial.eval (real.cos x) (cheb n) = real.cos (n * x) :=\nbegin\n  induction n using nat.case_strong_induction_on with k ih,\n  { convert eval_one, simp, },\n  { induction k with k im,\n    { convert eval_X, simp, },\n    { have hksucc := ih k.succ (le_refl k.succ),\n      have hk := ih k (nat.le_succ k),\n      conv_lhs { rw cheb, }, simp[hk, hksucc],\n      suffices : 2 * (cos x) * cos ((k+1)*x) - cos (k*x) = cos ((k+1+1)*x), { simpa [hk, hksucc], },\n      rw [sub_eq_iff_eq_add, mul_assoc, mul_comm (real.cos x) _, \u2190mul_assoc, cos_add_cos'],\n      congr' 3; ring, }, },\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  polynomial.eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nby { rw [\u2190cos_arccos hx.1 hx.2, cheb_cos], exact \u27e8neg_one_le_cos _, cos_le_one _\u27e9 }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209032,"user_id":null,"body":"import Preloaded data.polynomial data.complex.exponential analysis.complex.exponential\n\nnamespace polynomial\n\nvariables {R : Type*} [comm_semiring R] {a : R}\n\n@[simp] lemma C_bit0 : C (bit0 a) = bit0 (C a) := C_add\n@[simp] lemma C_bit1 : C (bit1 a) = bit1 (C a) := by simp only [bit1, C_bit0, C_1, C_add]\n\nend polynomial\n\nopen polynomial\n\ntheorem cheb_cos : \u2200 n, \u2200 x,\n  polynomial.eval (real.cos x) (cheb n) = real.cos (n * x)\n| 0 := by simp only [cheb, eval, eval\u2082_one, forall_const, nat.cast_zero, zero_mul, real.cos_zero]\n| 1 := by simp only [cheb, eval, forall_const, one_mul, eq_self_iff_true, nat.cast_one, eval\u2082_X]\n| (n + 2) :=\nbegin\n    intro x,\n    rw [cheb, eval_sub, eval_mul, eval_mul, eval_X, \u2190 show C (2 : \u211d) = 2, by simp, eval_C, \n        cheb_cos, cheb_cos, nat.succ_eq_add_one, show ((n + 1 : \u2115) : \u211d) = (n : \u211d) + (1 : \u211d), by simp only [nat.cast_add, nat.cast_one],\n        show ((n + 2 : \u2115) : \u211d) = (n : \u211d) + (2 : \u211d), by simp only [nat.cast_bit0, nat.cast_add, nat.cast_one], add_mul, add_mul, one_mul,\n        two_mul, two_mul, \u2190 sub_eq_zero],\n    simp only [real.cos_add, real.sin_add],\n    ring,\n    rw [sub_mul, add_sub, mul_comm, \u2190 add_mul, add_comm, real.sin_sq_add_cos_sq],\n    ring,\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  polynomial.eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  let y := real.arccos x,\n  rw [\u2190 show real.cos y = x, from real.cos_arccos hx.1 hx.2, cheb_cos],\n  exact \u27e8real.neg_one_le_cos _, real.cos_le_one _ \u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209033,"user_id":196,"body":"import Preloaded analysis.complex.exponential\n\nopen polynomial\n\n@[elab_as_eliminator]\nlemma nat.fib_rec_on {P : \u2115 \u2192 Prop} (n : \u2115) (h0 : P 0) (h1 : P 1)\n  (hss : \u2200 n, P n \u2192 P (n+1) \u2192 P (n+2)) : P n :=\nsuffices P n \u2227 P (n+1), from this.1,\nnat.rec_on n \u27e8h0, h1\u27e9 $ \u03bb n ih, \u27e8ih.2, hss n ih.1 ih.2\u27e9\n\n\/- 2 cos(x) cos((n+1)x) - cos(nx)\n=  2 cos(x) cos((n+1)x) - cos(x) cos((n+1)x) - sin(x) sin((n+1)x)\n=  cos(x) cos((n+1)x) - sin(x) sin((n+1)x)\n=  cos((n+2)x)\n-\/\ntheorem cheb_cos (n : \u2115) (x : \u211d) : \n  polynomial.eval (real.cos x) (cheb n) = real.cos (n * x) :=\nbegin\n  apply nat.fib_rec_on n,\n  { rw [cheb, \u2190 C_1, eval_C, nat.cast_zero, zero_mul, real.cos_zero] },\n  { rw [cheb, eval_X, nat.cast_one, one_mul] },\n  intros n ih0 ih1,\n  simp_rw [cheb, eval_sub, two_mul, add_mul, eval_add, eval_mul, eval_X],\n  rw [ih0, ih1, \u2190 add_sub_cancel (n * x : \u211d) x], push_cast, simp_rw [add_mul, one_mul],\n  rw [real.cos_sub, mul_comm (real.cos x), add_sub_add_left_eq_sub, \u2190 real.cos_add]\nend\n\ntheorem cheb_bounded (n : \u2115) (x : \u211d) (hx : x \u2208 set.Icc (-1 : \u211d) 1) :\n  polynomial.eval x (cheb n) \u2208 set.Icc (-1 : \u211d) 1 :=\nbegin\n  rw [\u2190 real.cos_arccos hx.1 hx.2, cheb_cos],\n  exact \u27e8real.neg_one_le_cos _, real.cos_le_one _\u27e9\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5d64d9c0a5aad20001b2d9f8":[{"id":209034,"user_id":null,"body":"import Preloaded\nimport data.nat.modeq\nimport tactic\n\nlemma sum1: \u2200 n, fsum id n = n*(n+1)\/2 :=\nbegin\n  intro n,symmetry,\n  apply nat.div_eq_of_eq_mul_right (lt_trans nat.zero_lt_one (by norm_num: 1<2)),\n  induction n with n ih, \n    simpa, \n    rw fsum at *, dsimp at *,\n    rw mul_add 2 at *,\n    rw \u2190ih,  \n    repeat {rw nat.succ_eq_add_one}, \n    ring\nend \n\n\n---START waste of time fixing parity conditions...how should I be doing this?\nlemma parn : \u2200  n, (n*(n+1)\/2)^2=(n*(n+1))^2\/4 :=\nbegin\n  intro n,\n  have parity: n*(n+1)%2 =0 ,\n    rw [nat.mul_mod],\n    have : n % 2 < 2 := nat.mod_lt n (by norm_num),\n    interval_cases n % 2 with hn,\n      swap,rw hn, simp,\n      swap,\n      rw nat.add_mod n 1 2, rw hn, norm_num,\n  have : 2\u2223 n*(n+1),\n    apply nat.modeq_zero_iff_dvd.mp parity,\n  cases this with k hk, rw hk, norm_num,rw pow_two, rw pow_two,\n  have :2*k*(2*k)= 4*k^2,\n    ring,\n  rw this, norm_num,rwa pow_two\nend\n---END\n\n\nlemma nicomachus_easy : \u2200 n, fsum cb n = (n*(n+1)\/2)^2:=\nbegin\n  intro n,\n  symmetry,\n  rw parn n,\n  apply nat.div_eq_of_eq_mul_right (by norm_num: 0<4),\n  induction n with n ih, \n    simpa, \n    rw fsum at *, dsimp at *,\n    rw mul_add 4 at *, rw \u2190ih,\n    rw cb, dsimp,repeat {rw nat.succ_eq_add_one},ring\nend\n\n\ntheorem nicomachus : \u2200 n, sq_nat (fsum id n) = fsum cb n :=\nbegin\n  intro n,\n  rw [sum1 n, nicomachus_easy n, sq_nat], \nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209035,"user_id":null,"body":"import Preloaded\nimport data.nat.basic tactic.ring tactic.ring_exp\n\nlemma fsum_lemma (f : \u2115 \u2192 \u2115) (n : \u2115) : fsum f n.succ = f (n.succ) + fsum f n := by refl\n\nlemma fsum_id (n : \u2115) : fsum id n * 2 = n * (n + 1) :=\nbegin\n  induction n with m hm,\n  { refl, },\n  rw [fsum_lemma, right_distrib, hm, id, nat.succ_eq_add_one],\n  ring,\nend\n\ntheorem nicomachus : \u2200 n, sq_nat (fsum id n) = fsum cb n :=\nbegin\n  intro n,\n  induction n with m hm,\n  { ring, },\n  simp_rw [fsum_lemma, sq_nat, \u2190 hm, id, cb], \n  ring_exp,\n  rw fsum_id,\n  ring_nf,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209036,"user_id":null,"body":"import Preloaded\nimport tactic\n\n\nlemma sum_def (f : \u2115 \u2192 \u2115) (n : \u2115) :\n  fsum f n.succ =  f(n.succ)+ fsum f n:=\nbegin\n  refl,\nend\n\ntheorem nicomachus : \u2200 n, sq_nat (fsum id n) = fsum cb n :=\nbegin\n  intro n,\n  induction n with n h,\n  {\n    refl,\n  },\n  {\n    rw sum_def _ _,\n    rw sum_def _ _,\n    have : 2*fsum id n = n*(n+1),\n    {\n      clear h,\n      induction n with n ih,\n      refl,\n      rw [sum_def _ _, mul_add,ih],\n      simp [nat.succ_eq_add_one],\n      ring,\n    },\n    rw \u2190 h,\n    simp [sq_nat,cb,pow_two,mul_add,add_mul],\n    have simplify :n.succ * n.succ + n.succ * fsum id n\n      + (fsum id n * n.succ + fsum id n * fsum id n)\n      = n.succ^2 + n.succ * (2 * fsum id n) + (fsum id n)^2:=\n      by ring,\n    rw [simplify,this],\n    simp [nat.succ_eq_add_one],\n    ring,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209037,"user_id":null,"body":"import Preloaded tactic data.nat.parity\n\nlemma sumn (n:\u2115): fsum id n = n*(n+1)\/2:=by{\n  induction n with n hn,{\n    refl,\n  },{\n    dsimp [fsum],\n    dsimp [fsum] at hn,\n    have h0:n.succ=n+1,refl,\n    rw h0,\n    rw hn,\n    rw mul_add,\n    rw mul_add (n+1) (n+1) 1,\n    simp[mul_add,add_mul],\n    conv{\n      to_rhs,\n      rw [add_assoc],\n      rw [\u2190mul_two (n+1)],\n      rw [nat.add_mul_div_right _ _ zero_lt_two],\n      rw [add_comm],\n    },\n  }\n}\ntheorem nicomachus : \u2200 n, sq_nat (fsum id n) = fsum cb n := by{\n  intro n,\n  have h10:\u2200(n:\u2115),2\u2223n*(n+1),{\n    intro n,\n    by_cases (even n),{\n      exact dvd_mul_of_dvd_left h (n+1),\n    },{\n      replace h:=nat.odd_iff_not_even.mpr h,\n      have h0:odd 1:=nat.odd_iff.mpr rfl,\n      replace h:=nat.odd.add_odd h h0,\n      exact dvd_mul_of_dvd_right h n,\n    },\n  },\n  induction n with n hn,{\n    refl,\n  },{\n    have h0:=sumn n,\n    simp [fsum] at h0 hn,\n    simp [fsum],\n    rw \u2190hn,\n    rw h0,\n    simp [sq_nat,cb],\n\n    conv{\n      to_lhs,\n      rw [add_sq],\n      congr,\n      congr,\n      skip,\n      rw [mul_comm 2 _],\n      rw [mul_assoc],\n      rw [nat.mul_div_cancel' (h10 n)],\n      rw [mul_comm n],\n      rw [\u2190mul_assoc],\n      rw [(sq n.succ).symm],\n    },\n    conv{\n      to_lhs,\n      congr,\n      conv{\n        congr,\n        rw [\u2190mul_one (n.succ^2)],\n      },\n      rw [\u2190mul_add],\n      rw [add_comm 1 n],\n      rw [\u2190pow_succ'],\n    },  \n  }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209038,"user_id":660,"body":"import Preloaded\nimport data.nat.pow\n\nlemma fsum_succ {n : \u2115} {f : \u2115 \u2192 \u2115} : fsum f n.succ = f n.succ + fsum f n := rfl\n\nlemma triangle {n : \u2115} : 2 * fsum id n = n * (n + 1) :=\nbegin\n  induction n with n ih,\n  { simp [fsum] },\n  rw [fsum_succ, mul_add, ih],\n  simp only [nat.succ_eq_add_one, id.def, \u2190add_mul, add_comm 2, mul_comm (n + 2)],\nend\n\ntheorem nicomachus : \u2200 n, sq_nat (fsum id n) = fsum cb n :=\nbegin\n  intro n,\n  rw sq_nat,\n  induction n with n ih,\n  { simp [fsum, cb, zero_pow] },\n  dsimp at ih,\n  simp only [fsum_succ, add_sq, ih, add_left_inj, id.def],\n  rw [mul_comm 2, mul_assoc, triangle, sq, \u2190nat.succ_eq_add_one, \u2190mul_add, \u2190one_mul n.succ,\n    \u2190mul_assoc, mul_one, \u2190add_mul, \u2190nat.succ_eq_one_add, one_mul, cb],\n  dsimp,\n  rw [pow_succ, sq],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209039,"user_id":17,"body":"import Preloaded tactic.ring_exp\n\n@[simp] lemma fsum_rec (f : \u2115 \u2192 \u2115) (n : \u2115) :\n  fsum f n.succ = f n.succ + fsum f n := rfl\n\ntheorem aux (n : \u2115) :\n  (fsum id n : \u211a) = n * (n+1)\/2 :=\nbegin\n  induction n with n IH, { simp [fsum] },\n  simp [IH],\n  ring_exp\nend\n\ntheorem nicomachus (n : \u2115) : sq_nat (fsum id n) = fsum cb n :=\nbegin\n  suffices H : (sq_nat (fsum id n) : \u211a) = fsum cb n, by exact_mod_cast H,\n  induction n with n IH, { refl },\n  simp [sq_nat, cb] at *,\n  rw [\u2190 IH, aux n],\n  ring_exp\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209040,"user_id":null,"body":"import Preloaded tactic\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nbegin\n  have h1 : \u2200 n,  2 * fsum id n = n*(n+1),\n  { intros n,\n    induction n with d hd,\n    { unfold fsum, norm_num, },  \n    unfold fsum at hd \u22a2,\n    rw [mul_add, hd, nat.succ_eq_add_one],\n    unfold id,\n    ring, },\n  have h2 : \u2200 n,  4 * fsum cb n =  n^2 * (n + 1)^2,\n  { intros n,\n    induction n with d hd,\n    {unfold fsum, unfold cb, norm_num, },\n    unfold fsum at hd \u22a2,\n    rw [mul_add, hd, nat.succ_eq_add_one],\n    unfold cb, \n    ring, },\n  intros n,\n  unfold sq,\n  apply @nat.eq_of_mul_eq_mul_left _ _ 4,\n  { norm_num, },\n  have : 4=2^2 := by norm_num,\n  rw [this, \u2190mul_pow, \u2190this, h1 n, h2 n],\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209041,"user_id":null,"body":"import Preloaded tactic\n\n\nlemma gauss {n : \u2115} : (fsum id n) * 2 = (n + 1) * n :=\nnat.rec_on n rfl (\u03bb n hn, by { dsimp [fsum] at hn \u22a2, rw [add_mul, hn, nat.succ_eq_add_one], linarith })\n\ntheorem nicomachus_aux : \u2200 n, sq (fsum id n) * 4 = (fsum cb n) * 4 :=\nbegin\n  intro n, rw (show sq (fsum id n) * 4 = sq ((fsum id n) * 2) , by { dsimp [sq, pow_two], linarith,}),\n  rw gauss,\n  induction n with n hn, { refl },\n  { have k : fsum cb n.succ * 4 = (cb n.succ + (fsum cb n)) * 4, { congr' 1, },\n    rw k, conv_rhs { rw [add_mul, \u2190hn] }, rw nat.succ_eq_add_one, dsimp [sq, cb], simp, ring, },\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := \u03bb n, mul_right_cancel' (dec_trivial) (nicomachus_aux n)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209042,"user_id":null,"body":"import Preloaded\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := \nbegin\n    intro n,\n    induction n with n ih,\n    refl,\n    have : \u2200 (f: \u2115 \u2192 \u2115) (m : \u2115), fsum f (nat.succ m) = f (nat.succ m) + fsum f m,\n    {\n        intros f m,\n        refl,\n    },\n    rw this,\n    rw this,\n    rw \u2190ih,\n    unfold sq,\n    rw pow_two,\n    unfold id,\n    rw left_distrib,\n    rw right_distrib,\n    rw right_distrib,\n    rw \u2190pow_two,\n    rw \u2190pow_two,\n    rw \u2190add_assoc,\n    rw add_assoc (n.succ ^ 2),\n    rw mul_comm,\n    rw \u2190two_mul,\n    rw \u2190mul_assoc,\n    have pascal : \u2200 (m : \u2115), 2 * fsum id m = m * (m + 1),\n    {\n        intro m,\n        induction m with m ihm,\n        unfold fsum,\n        unfold id,\n        simp,\n        rw this,\n        rw left_distrib,\n        rw ihm,\n        unfold id,\n        rw \u2190right_distrib,\n        rw add_comm,\n        rw mul_comm,\n    },\n    have : n.succ ^ 2 + 2 * n.succ * fsum id n = cb n.succ,\n    {\n        rw mul_comm 2 n.succ,\n        rw mul_assoc,\n        rw pascal,\n        rw mul_comm n n.succ,\n        rw \u2190mul_assoc,\n        rw \u2190pow_two,\n        rw add_comm,\n        rw \u2190nat.mul_succ,\n        unfold cb,\n        rw pow_succ n.succ 2,\n        rw mul_comm,\n    },\n    rw this,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209043,"user_id":null,"body":"import Preloaded tactic\n\nlemma nat_sum {n : \u2115} : 2 * fsum id n = n * (n + 1) :=\nbegin\n  unfold fsum,\n  simp,\n  induction n with n hn,\n  { refl, },\n  simp,\n  rw [mul_add, hn, nat.succ_eq_add_one],\n  ring,\nend\n\nlemma succ_cube {n : \u2115} : fsum cb n.succ = sq n.succ + 2 * n.succ * fsum id n + fsum cb n :=\nbegin\n  unfold fsum,\n  unfold cb,\n  rw nat.succ_eq_add_one,\n  simp,\n  induction n with n hn,\n  { refl, },\n  symmetry,\n  let x := fsum id n,\n  calc\n    sq (n.succ + 1) + 2 * (n.succ + 1) * nat.rec 0 (\u03bb (n' : \u2115), has_add.add n'.succ) n.succ\n        = (n + 2) ^ 2 + 2 * (n + 2) * (n + 1 + x) : by refl\n    ... = (n + 1) ^ 2 + 2 * (n + 1) * x + 2 * (n + 3) * (n + 1) + 2 * x + 1 : by ring\n    ... = (n + 1) ^ 2 + 2 * (n + 1) * x + 2 * (n + 3) * (n + 1) + n * (n + 1) + 1 : by rw nat_sum\n    ... = (n + 1) ^ 3                   + 2 * (n + 3) * (n + 1) + n * (n + 1) + 1 : by { rw hn, refl, }\n    ... = (n + 2) ^ 3 : by ring\n    ... = cb n.succ.succ : by refl,\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := \nbegin\n  intro n,\n  induction n with n ih,\n  { refl, },\n  \n  calc\n    sq (n.succ + nat.rec 0 (\u03bb (n' : \u2115), has_add.add n'.succ) n)\n        = sq n.succ + 2 * n.succ * fsum id n + sq (fsum id n) : by { unfold sq, ring, }\n    ... = sq n.succ + 2 * n.succ * fsum id n + fsum cb n : by rw \u2190ih\n    ... = fsum cb n.succ : by rw \u2190succ_cube,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209044,"user_id":null,"body":"import Preloaded data.nat.basic data.nat.parity tactic\n\nopen nat\n\nlemma fsum_succ {f : \u2115 \u2192 \u2115} (n : \u2115): fsum f n.succ = fsum f n + f n.succ :=\nbegin\n  rw fsum,\n  nlinarith,\nend\n\nlemma gauss_eq (n : \u2115) : 2 * fsum id n = n * (n+1) := begin\n  induction n,\n  refl,\n  rw fsum_succ,\n  rw [mul_add, n_ih, succ_eq_add_one, id],\n  ring,\nend\n\nlemma square_of_sum (n : \u2115): sq (2 * fsum id n) = sq (n * (n+1)) := by rw [gauss_eq]\n\nlemma sum_of_cubes (n : \u2115) : 4 * fsum cb n = (n * (n+1)) ^2 := begin\n  induction n with n ih,\n  refl,\n  rw [fsum_succ, mul_add, ih, cb, succ_eq_add_one],\n  nlinarith,\nend\n\nlemma sq_eq_pow_two (n : \u2115) : sq n = n ^ 2 := rfl\n\nlemma even_of_n_mul_n_succ (n : \u2115) : even (n * n.succ) := begin\n  induction n with n ih,\n  exact even_zero,\n  apply even_mul.mpr,\n  rw even_mul at ih,\n  cases ih,\n  right,\n  apply even_succ.mpr,\n  by_contra h,\n  have : \u00ac even n := even_succ.mp h,\n  contradiction,\n  left,\n  exact ih,\nend\n\nlemma sq_over_div_of_dvd {a b : \u2115} : b \u2223 a \u2192 sq (a \/ b) = sq a \/ sq b := begin\n  intro h,\n  cases h with k hk,\n  rw sq,\n  simp,\n  rw hk,\n  ring,\n  cases b,\n  rw [mul_zero, nat.div_zero, zero_pow, mul_zero, nat.div_zero],\n  exact zero_lt_two,\n\n  rw nat.mul_div_cancel k (zero_lt_succ b),\n  have zero_lt_succ_sq : 0 < b.succ ^2 := zero_lt_iff_ne_zero.mpr (pow_ne_zero 2 (succ_ne_zero b)),\n  rw nat.mul_div_cancel (k^2) zero_lt_succ_sq,\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nassume n,\ncalc sq (fsum id n)\n    = sq (2 * fsum id n \/ 2): by norm_num\n... = sq (2 * fsum id n) \/ sq 2: sq_over_div_of_dvd (dvd.intro (fsum id n) rfl)\n... = sq (n * (n+1)) \/ sq 2 : by rw square_of_sum\n... = sq (n * (n+1)) \/ 4 : rfl\n... = (n * (n+1))^2 \/ 4 : by rw \u2190 sq_eq_pow_two\n... =  4 * fsum cb n \/ 4 : by rw \u2190 sum_of_cubes\n... = fsum cb n : by rw nat.mul_div_cancel_left (fsum cb n) zero_lt_four","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209045,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\ntheorem fsum_succ (f : \u2115 \u2192 \u2115) (n : \u2115) : fsum f (succ n) = f (succ n) + fsum f n := rfl\n\n@[simp]\ntheorem arith_sum (n : \u2115) : 2 * fsum id n = n * (n.succ) :=\nbegin\n  induction n with n ih,\n  refl,\n  rw fsum_succ,\n  unfold id,\n  rw [nat.left_distrib, ih],\n  ring,\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nbegin\nintro n,\ninduction n with n ih,\nrefl,\nrepeat {rw fsum_succ},\nunfold sq at ih |-,\nring,\nrw \u2190ih,\nsimp,\nunfold cb,\nring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209046,"user_id":null,"body":"import Preloaded tactic\n\nlemma add_sq_self (a b : \u2115) : (a+b)^2 = (2*b+a)*a + b^2 := by ring\n-- in Lean 3.11.0, add_mul_self_eq only works for commutative rings\n-- works for semirings after https:\/\/github.com\/leanprover-community\/mathlib\/commit\/a478f91b2afdde01b98dc9be042938b8368dafaf\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nbegin\n  unfold sq cb fsum, intro n, induction n with n h,\n  norm_num, dsimp at h \u22a2, rw [add_sq_self, h], congr' 1,\n  rw nat.pow_succ, congr' 1, clear h, induction n with n h,\n  norm_num, dsimp, rw [mul_add, nat.add_succ, add_assoc, h],\n  repeat {rw nat.succ_eq_add_one}, ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209047,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\n\nlemma sum_eq (n : \u2115) : fsum id n = (finset.range (n + 1)).sum (\u03bb (i : \u2115), i) :=\nbegin\n  induction n with n hn, refl,\n  change fsum id (nat.succ n) with (n + 1) + fsum id n,\n  rw [hn, finset.sum_range_succ _ (n + 1)],\nend\n\nlemma mul_succ_even (n : \u2115) : 2 \u2223 (n + 1)*n :=\nbegin\n  induction n with n ih, exact \u27e80, rfl\u27e9,\n  cases ih with k hk,\n  rw [nat.succ_eq_add_one, (by ring: n + 1 + 1 = n + 2), add_mul,\n      mul_comm, hk, \u2190 mul_add],\n  use (k + (n + 1)),\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nbegin\n  intro n,\n  induction n with n ih, refl,\n  change fsum cb (nat.succ n) with (cb (n + 1)) + fsum cb n,\n  rw [\u2190 ih, sum_eq, sum_eq, finset.sum_range_id, finset.sum_range_id],\n  change ((n + 2)*(n + 1)\/2)^2 = (n + 1)^3 + ((n + 1)*n\/2)^2,\n  calc (((n + 2)*(n + 1))\/2)^2 = ((2*(n + 1) + (n + 1)*n)\/2)^2 :\n            by rw (show (n + 2)*(n + 1) = 2*(n + 1) + (n + 1)*n, from by ring)\n  ... = ((n + 1) + (n+ 1)*n\/2)^2 : by rw [add_comm (2*(n + 1)),\n            nat.add_mul_div_left _ _ (by linarith : 0 < 2), add_comm]\n  ... = (n + 1)^2 + 2*((n + 1)*n\/2)*(n + 1) + ((n + 1)*n\/2)^2 : by ring\n  ... = (n + 1)^2 + ((n + 1))*n*(n + 1) + ((n + 1)*n\/2)^2 :\n            by rw nat.mul_div_cancel' (show 2 \u2223 (n + 1)*n, from mul_succ_even n)\n  ... = (n + 1)^3 + ((n + 1)*n\/2)^2 : by ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209048,"user_id":null,"body":"import Preloaded tactic\n\nlemma fsum_succ (f : \u2115 \u2192 \u2115) (x : \u2115) : fsum f x.succ = fsum f x + f x.succ\n:= by { simp only [fsum], rw nat.add_comm }\n\nlemma fsum_id (n : \u2115) : 2 * fsum id n = n * n.succ\n:= by {\n  induction n with n' ih, { refl },\n  rw [fsum_succ, id, mul_add, ih, nat.mul_succ n'.succ, nat.succ_mul n', add_assoc, two_mul],\n}\n\nlemma sq_add (a b : \u2115) : sq (a + b) = sq a + 2 * a * b + sq b\n:= by { dsimp [sq], ring }\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := by {\n  intro n, induction n with n' ih, { refl }, \n  rw [fsum_succ, fsum_succ, sq_add, id, fsum_id, ih, add_assoc], congr' 1,\n  dsimp [sq, cb],\n  rw [nat.pow_succ n'.succ 2, nat.mul_succ (n'.succ ^ 2)], ring\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209049,"user_id":null,"body":"import Preloaded tactic\n\nlemma lem1 (n : \u2115) (f: \u2115 \u2192 \u2115): fsum f (n.succ) = (fsum f n) + (f (n.succ)) :=\nbegin \n  simp [fsum], \n  ring,\nend \n\nlemma lem2 (a b : \u2115 ) : sq (a + b) = (sq a) + 2 * a * b + (sq b) := \nbegin \n  unfold sq at *, \n  ring,\nend \n\nlemma lem3 (n : \u2115 ) : cb n.succ = (sq n.succ) * n + sq n.succ:= \nbegin \n  unfold cb, unfold sq,\n  ring,\nend\n\nlemma lem4 (n: \u2115) : 2 * fsum id n = n * n.succ:= \nbegin \n  induction n with n hyp,\n  refl,\n  rw lem1,\n  rw mul_add,\n  rw hyp,\n  unfold id,\n  have : n.succ = n + 1, by exact rfl,\n  rw this, \n  have : (n + 1).succ = n + 2, by exact rfl,\n  rw this,\n  ring,\nend \n\nlemma lem5 (a b c: nat) : b = c \u2192 a + b = a + c := \nbegin \n  simp only [imp_self, add_right_inj],\nend \n\nlemma lem6 (a b c: nat) : a + b = c \u2192 a = c - b := \nbegin \n  intros,\n  rw \u2190a_1, \n  simp,\nend \n\nlemma lem7 (a b c: nat) : b = c \u2192 b + a = c + a:= \nbegin \n  simp only [imp_self, add_left_inj],\nend \n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := \nbegin \n  intro n,\n  induction n with n hyp,\n  refl,\n  rw [lem1, lem1 _ cb, lem2, hyp, id],\n  rw add_assoc,\n  apply lem5 (fsum cb n) (2 * fsum id n * n.succ + sq n.succ) (cb n.succ),\n  rw lem3,\n  apply lem7,\n  rw lem4,\n  unfold sq,\n  ring,\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209050,"user_id":null,"body":"import Preloaded\nimport tactic\n\n\ntheorem fsum_succ (f : \u2115 \u2192 \u2115) (n : \u2115) : fsum f n.succ = f (nat.succ n) + fsum f n := rfl\n\ntheorem sum_tri : \u2200 n, fsum id n * 2 = n * (n + 1) := begin\n    intro n,\n    induction n with n' hn,\n    {\n        unfold fsum, rw id, ring\n    },\n    {\n        simp only [fsum_succ, id],\n        rw add_mul,\n        rw hn, clear hn,\n        rw mul_add,\n        rw mul_add,\n        simp [nat.succ_mul, nat.mul_succ],\n        ring,\n    }\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := begin\n    intro n,\n    induction n with n' hn,\n    {\n        unfold fsum, unfold sq, unfold cb, ring,\n    },\n    {\n        simp [fsum_succ, id, sq],\n        rw [nat.pow_two, add_mul, mul_add, mul_add],\n        simp [sq, nat.pow_two] at hn,\n        rw [\u2190 add_assoc, hn],\n        clear hn,\n        rw add_right_cancel_iff,\n        ring,\n        rw mul_comm (fsum id n') (n'.succ),\n        rw add_assoc,\n        rw \u2190 mul_two,\n        rw mul_assoc,\n        rw \u2190 mul_add,\n        rw sum_tri,\n        unfold cb,\n        rw \u2190 nat.succ_eq_add_one,\n        rw mul_comm n',\n        have h : n'.succ + n'.succ * n' = n'.succ * n'.succ := by {\n            ring,\n            rw \u2190 nat.succ_eq_add_one,\n            rw pow_two,\n        },\n        rw h,\n        rw \u2190pow_two,\n        rw \u2190pow_succ,\n        simp,\n    }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209051,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlemma sum_nat : \u2200 n, fsum id n = n * (n+1)\/2 := by {\n    intro n,\n    induction n with n hi,\n        unfold fsum,\n        unfold id,\n        norm_num,\n    unfold fsum at *,\n    unfold id at *,\n    rw [hi,nat.succ_eq_add_one,add_comm],\n    rw [\u2190nat.add_mul_div_left _],\n        ring,\n    linarith\n}\n\nlemma even_cons_sum : \u2200 n, 2 \u2223 n * (n+1) := by {\n    intro n,\n    cases (nat.mod_two_eq_zero_or_one n) with h h,\n        apply dvd_mul_of_dvd_left,\n        exact nat.dvd_of_mod_eq_zero h,\n    apply dvd_mul_of_dvd_right,\n    have h1 : \u00ac 2 \u2223 n,\n        intro h1,\n        rw nat.dvd_iff_mod_eq_zero at h1,\n        rw h at h1,\n        norm_num at h1,\n    suffices hf : \u2203 k, 1 + 2 * k = n,\n        cases hf with w hw,\n        use w+1,\n        linarith,\n    have h2 : 0 < 2 := by linarith,\n    use n\/2,\n    exact ((@nat.div_mod_unique n _ 1 (n\/2) h2).1 \u27e8rfl,h\u27e9).1,\n}\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := by {\n    intro n,\n    rw sum_nat,\n    induction n with n hi,\n        unfold fsum,\n        unfold sq,\n        unfold cb,\n        norm_num,\n    unfold fsum at *,\n    rw \u2190 hi,\n    unfold sq,\n    unfold cb,\n    rw nat.pow_succ _ 2,\n    repeat {rw nat.pow_two},\n    rw nat.div_mul_div,\n    apply nat.div_eq_of_eq_mul_right,\n        norm_num,\n    rw [mul_add (2*2), add_comm $ 2 * 2 * (nat.succ n * nat.succ n * nat.succ n)],\n    rw [mul_assoc 2, \u2190mul_assoc 2 $ n * (n + 1) \/ 2, nat.mul_div_cancel'],\n    rw [\u2190mul_assoc 2, mul_comm 2, mul_assoc _ 2, nat.mul_div_cancel'],\n    rw [nat.succ_eq_add_one],\n    ring,\n    repeat {apply even_cons_sum}\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209052,"user_id":null,"body":"import tactic.ring\n\nimport Preloaded\n\nlemma fsum_id : \u2200 n, 2 * fsum id n = n * (n + 1):=\nbegin\n  intro,\n  induction n with n ih, {\n    unfold fsum, refl,\n  }, {\n    unfold fsum at *,\n    simp at *,\n    rw mul_add,\n    rw ih,\n    simp,\n    rw nat.succ_eq_add_one,\n    ring,\n  },\nend\n\ndef fsum' (f : \u2115 \u2192 \u2115) : \u2115 \u2192 \u2115\n| 0 := f 0\n| (n + 1) := f (n + 1) + fsum' n\n\nlemma fsum_fsum' : fsum = fsum' :=\nbegin\n  rw function.funext_iff,\n  intro f,\n  rw function.funext_iff,\n  intro n,\n  induction n with n ih, {\n    unfold fsum fsum',\n  }, {\n    unfold fsum fsum' at *,\n    simp,\n    rw \u2190 ih,\n    -- simp,\n  },\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := \nbegin\n  intro,\n  rw fsum_fsum',\n  induction n with n ihn, {\n    unfold sq cb fsum',\n    simp,\n    refl,\n  }, {\n    unfold fsum',\n    rw \u2190 ihn, clear ihn,\n    unfold sq, simp,\n    rw \u2190 nat.add_assoc,\n    let sn := n + 1,\n    change (n + 1) with sn,\n    ring,\n    rw add_right_cancel_iff,\n    rw mul_comm,\n    rw \u2190 fsum_fsum', rw fsum_id,\n    change sn with (n + 1),\n    unfold cb,\n    ring,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209053,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\nlemma decompose_sum (f : \u2115 \u2192 \u2115) (n : \u2115) : fsum f (n + 1) = fsum f n + f (n + 1) :=\n  by {simp [fsum, nat.add_one], ring}\n\n\nlemma sq_sum (a b : \u2115) : (a + b)^2 = a^2 + b^2 + 2*a*b := by ring\nlemma succ_cb (a : \u2115) : (a + 1)^3 = a^3 + 3*a^2 + 3*a + 1 := by ring\nlemma fsum_id (n : \u2115) : 2 * fsum id n = n * (n + 1) :=\nbegin\n  induction n with n' ihn',\n    { simp, right, ring},\n    { rw [\u2190 nat.add_one, decompose_sum, left_distrib, ihn', id],\n      ring}\nend\n\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nbegin\n  intros n,\n  induction n with n' ihn',\n    { simpa [fsum, sq, cb]},\n    { simp [decompose_sum, sq, sq_sum, cb, succ_cb],\n      simp [sq] at ihn',\n      rw [ihn', \u2190 cb, add_left_inj, fsum_id],\n      ring}\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209054,"user_id":null,"body":"import Preloaded\nimport tactic.ring_exp\n\n@[simp] lemma fsum_rec (f : \u2115 \u2192 \u2115) (n : \u2115) :\n  fsum f n.succ = f n.succ + fsum f n := rfl\n\ntheorem aux (n : \u2115) :\n  (fsum id n : \u211a) = n * (n+1)\/2 :=\nbegin\n  induction n with n IH, { refl },\n  simp [IH],\n  ring_exp\nend\n\ntheorem nicomachus (n : \u2115) : sq (fsum id n) = fsum cb n :=\nbegin\n  suffices H : (sq (fsum id n) : \u211a) = fsum cb n, by exact_mod_cast H,\n  induction n with n IH, { refl },\n  simp [sq, cb] at *,\n  rw [\u2190 IH, aux n],\n  ring_exp\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209055,"user_id":null,"body":"import Preloaded\nimport tactic.ring_exp\n\ntheorem fsum_succ: \u2200f n, fsum f (n + 1) = f (n + 1) + fsum f n := by simp[fsum, \u2190nat.succ_eq_add_one]\n\ntheorem double_sum: \u2200n, 2 * fsum id n = n * (n + 1) :=\n    begin\n        intro n,\n        induction n with n ih,\n        refl,\n        simp[fsum_succ],\n        ring_exp,\n        simp[nat.mul_comm (fsum id n), ih, nat.succ_eq_add_one],\n        ring_exp,\n    end\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := begin\nintro n,\ninduction n with n ih,\nrefl,\nsimp[sq] at ih,\nshow _, from calc \n    sq (fsum id (n + 1)) = (n + 1 + fsum id n) ^ 2 : by refl\n    ... = (n + 1) ^ 2 + 2 * (fsum id n) * (n + 1) + (fsum id n) ^ 2 : by ring_exp\n    ... = (n + 1) ^ 2 + n * (n + 1) * (n + 1) + (fsum cb n): by simp[double_sum, ih]\n    ... = (n + 1) ^ 3 + (fsum cb n): by ring_exp\n    ... = fsum cb (nat.succ n) : by refl\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209056,"user_id":657,"body":"import Preloaded\n\nimport tactic\n\nlemma fsum_rec (f : \u2115 \u2192 \u2115) (d : \u2115) : fsum f d + f (nat.succ d) = fsum f (nat.succ d) := begin\nexact add_comm (fsum f d) (f (nat.succ d)),\nend\n\nlemma arithmetic1 (d : \u2115) : d * (d + 1) = 2 * fsum id d := begin\ninduction d with k hk, unfold fsum, norm_num,\nrw\u2190 nat.one_add,\nsuffices key : 2 * fsum id (1 + k) = 2 * (k + 1) + 2 * fsum id k,\nrw key, rw\u2190 hk, ring_exp,\nhave key2 : fsum id (nat.succ k) = nat.succ k + fsum id k := by refl,\n rw \u2190 nat.one_add at key2, rw key2, ring_exp,\nend\n\nlemma arithmetic2 (a b : \u2115) : (a + b)^2 = a^2 + b^2 + 2 * a * b := begin ring, end\n\nlemma key1 (d : \u2115 ): sq (fsum id (nat.succ d)) = sq (fsum id d) + (nat.succ d) ^3  := begin\ninduction d with k hk, unfold fsum, unfold sq, norm_num,\nlet d := nat.succ k,\nhave calc1 : fsum id (nat.succ d) = nat.succ d + fsum id d,\nunfold fsum, simp only [id.def], rw calc1,\nsuffices calc2 : nat.succ (d)^3 = (nat.succ d)^2 +2 * (fsum id d) * (nat.succ d),\nrw calc2, simp only [sq], ring,\nhave calc3 : nat.succ d ^ 3 = d^3 + 2 *d^2 + d + (d + 1) ^2,\ncalc nat.succ d ^ 3 = (d+1)^3  : by simp only [eq_self_iff_true]\n... = d^3 + (3 * d^2) + (3 * d) + 1 : by ring_exp\n... = d^3 + 2 *d^2 + d + (d + 1) ^2 : by ring\n,\nrw calc3, \nsuffices calc4 : d ^ 3 + 2 * d ^ 2 + d = 2 * fsum id d * nat.succ d, rw calc4, rw nat.add_one, ring,\nsuffices calc5 : d * (d + 1) =  2 * fsum id d, rw \u2190 calc5, rw \u2190 nat.one_add, ring_exp, apply arithmetic1,\nend\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n := begin\nintro n, induction n with d hd,\nclarify,\nrw key1, rw hd, \nhave q : (nat.succ d)^3 = cb (nat.succ d):= by unfold cb,\napply fsum_rec,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209057,"user_id":196,"body":"import Preloaded tactic.ring\n\nlemma nicomachus_aux_aux (n) : 2 * fsum id n = n * (n+1) :=\nbegin\n  induction n with n ih, { refl },\n  change 2 * ((n+1) + fsum id n) = (n+1)*(n+2),\n  rw [mul_add, ih], ring\nend\n\nlemma nicomachus_aux (n) : (n+1)^3 = (n+1)^2 + 2 * fsum id n * (n+1) :=\nby rw nicomachus_aux_aux; ring\n\ntheorem nicomachus (n) : sq (fsum id n) = fsum cb n :=\nbegin\n  unfold sq, induction n with n ih, { refl },\n  change ((n+1) + fsum id n)^2 = (n+1)^3 + fsum cb n,\n  rw [\u2190 ih, nicomachus_aux], ring\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209058,"user_id":659,"body":"import Preloaded tactic\n\n-- don't want to deal with nat.rec_on so pull this inductive fact out\nlemma fsum_aux (f : \u2115 \u2192 \u2115) (n : \u2115) : fsum f (nat.succ n) = f (n + 1) + fsum f n := rfl\n\n-- More convenient to work with rationals here\nlemma fsum_id (n : \u2115) : (fsum id n : \u211a) = n * (n + 1) \/ 2 :=\nbegin\n  -- induction on n\n  induction n with d hd, refl, -- base case done\n  -- inductive step uses auxiliary function\n  rw fsum_aux,\n  -- To use inductive hypothesis need to push coercions as far in as possible\n  push_cast,\n  -- now we can use it\n  rw [hd, id],\n  -- and pushing in again turns the question into one about the variable `\u2191d`\n  push_cast,\n  -- which `ring` can solve\n  ring,\nend\n\ntheorem nicomachus (n : \u2115) : sq (fsum id n) = fsum cb n :=\nbegin\n  induction n with d hd, refl, -- base case trivial\n  -- for inductive step use the inductive fact, and also get rid of this silly `sq` and `cb` nonsense\n  rw [fsum_aux, fsum_aux, \u2190hd, id, sq, cb], dsimp only [], clear hd,\n  -- this is now a statement only about fsum id\n  -- We know what this is in the rationals though\n  rw \u2190@nat.cast_inj \u211a,\n  -- so again push the coercions in as far as they'll go\n  push_cast,\n  -- use the fact that we know the sum\n  rw fsum_id,\n  -- and now this is an identity in ring theory\n  ring,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209059,"user_id":168,"body":"import Preloaded tactic\n\nopen nat\n\ntheorem nicomachus : \u2200 n, sq (fsum id n) = fsum cb n :=\nhave sum : \u2200 n, 2 * fsum id n = (n + 1) * n :=\nbegin\n  intro n, induction n with n ih, refl, \n  change fsum id (succ n) with succ n + fsum id n,\n  rw [mul_add, ih, \u2190add_one], ring,\nend,\nbegin\n  intro n, induction n with n ih, refl,\n  change fsum cb (succ n) with cb (succ n) + fsum cb n,\n  rw [\u2190ih, sq, cb, \u2190add_one], simp,\n  apply eq_of_mul_eq_mul_left (@nat.pow_pos 2 (by norm_num) 2),\n  simp [mul_add, \u2190nat.mul_pow, sum], ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209060,"user_id":644,"body":"import Preloaded tactic.ring\n\nopen nat\n\ntheorem fsum_zero (f) : fsum f 0 = f 0 := rfl\ntheorem fsum_succ (n f) : fsum f (succ n) = f (succ n) + fsum f n := rfl\n\nlemma fsum_id_eq (n) : 2 * fsum id n = n * (n + 1) :=\nbegin\n  induction n with n ih,\n  { refl },\n  { rw [fsum_succ, mul_add, ih, succ_eq_add_one, id.def], \n    ring }\nend\n\nlemma fsum_cb_eq (n) : 4 * fsum cb n = (n * (n + 1)) * (n * (n + 1)) :=\nbegin\n  induction n with n ih,\n  { refl },\n  { rw [fsum_succ, mul_add, ih, succ_eq_add_one, cb], \n    simp [mul_add, add_mul, nat.pow_succ, bit0, bit1, mul_assoc,\n      mul_comm, mul_left_comm, add_comm, add_assoc, add_left_comm] }\nend\n\ntheorem nicomachus (n) : sq (fsum id n) = fsum cb n :=\n(nat.mul_left_inj (show 0 < 4, from dec_trivial)).1 \n  (calc 4 * sq (fsum id n) = (2 * fsum id n) * (2 * fsum id n) : \n    by simp only [sq, \u2190 nat.pow_eq_pow]; ring\n  ... = (n * (n + 1)) * (n * (n + 1)) : by rw [fsum_id_eq]\n  ... = _ : by rw [fsum_cb_eq])","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e030784d7721600190aa84b":[{"id":209061,"user_id":168,"body":"import Preloaded\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\n  by rw \u2190H; clear H; induction t; simp only [node, empty_place]; cc\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209062,"user_id":196,"body":"import Preloaded tactic.omega\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nby subst H; induction t; unfold node empty_place; omega\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209063,"user_id":null,"body":"import Preloaded\nimport tactic.ring\n\n\/-\ninductive BTree : Type\n| Leaf        : BTree\n| Single_Son  : BTree -> BTree\n| Binary_Sons : BTree -> BTree -> BTree\n\nopen BTree\n\ndef node : BTree \u2192 \u2115\n| Leaf                := 1\n| (Single_Son t')     := 1 + node t'\n| (Binary_Sons t1 t2) := 1 + node t1 + node t2\n\ndef empty_place : BTree \u2192 \u2115\n| Leaf                := 2\n| (Single_Son t')     := 1 + empty_place t'\n| (Binary_Sons t1 t2) := empty_place t1 + empty_place t2\n-\/\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  revert n,\n  induction t with t ihop left right ih_left ih_right; intros n H; rw node at H; rw [empty_place];  \n    rw \u2190 H,\n    { specialize ihop (node t), have h := ihop (eq.refl (node t)), rw h, ring },\n    { specialize ih_left (node left), have h := ih_left (eq.refl (node left)), rw h,\n      specialize ih_right (node right), have h := ih_right (eq.refl (node right)), rw h, ring },  \nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209064,"user_id":null,"body":"import Preloaded tactic.ring\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  induction t with T hT T\u2081 T\u2082 hT\u2081 hT\u2082 generalizing n,\n  repeat { rw [\u2190 H, empty_place, node], },\n  { rw [hT  (node T ) (by refl)],                          ring, },\n  { rw [hT\u2081 (node T\u2081) (by refl), hT\u2082 (node T\u2082) (by refl)], ring, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209065,"user_id":null,"body":"import Preloaded\n\n\/-\ninductive BTree : Type\n| Leaf        : BTree\n| Single_Son  : BTree -> BTree\n| Binary_Sons : BTree -> BTree -> BTree\n\nopen BTree\n\ndef node : BTree \u2192 \u2115\n| Leaf                := 1\n| (Single_Son t')     := 1 + node t'\n| (Binary_Sons t1 t2) := 1 + node t1 + node t2\n\ndef empty_place : BTree \u2192 \u2115\n| Leaf                := 2\n| (Single_Son t')     := 1 + empty_place t'\n| (Binary_Sons t1 t2) := empty_place t1 + empty_place t2\n-\/\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 := begin\n  suffices : \u2200 t, empty_place t = node t + 1,\n  { rw [this, H] },\n  intro T,\n  induction T with t1 h t1 t2 h1 h2,\n  { refl },\n  { unfold empty_place node, rw h, refl },\n  { unfold empty_place node, rw [h1, h2, nat.add_assoc],\n    calc node t1 + (1 + (node t2 + 1)) = (node t1 + 1) + (node t2 + 1) : by rw nat.add_assoc\n      ... = 1 + node t1 + (node t2 + 1) : by rw nat.add_comm 1,\n  },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209066,"user_id":191,"body":"import Preloaded tactic\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  revert n,\n  induction t with t ih l r hl hr,\n  { intros n hn,\n    rw [\u2190 hn, node, empty_place]\n  },\n  { rw [node, empty_place],\n    intros n hn,\n    cases n,\n    { exfalso,\n      rw add_comm at hn,\n      exact nat.add_one_ne_zero _ hn\n    },\n    { rw [nat.succ_eq_one_add, add_left_cancel_iff] at hn,\n      rw [add_comm, add_right_cancel_iff],\n      exact ih n hn\n    }\n  },\n  { rw [node, empty_place],\n    intros n hn,\n    cases n,\n    { exfalso,\n      rw [add_assoc, add_comm] at hn,\n      exact nat.add_one_ne_zero _ hn\n    },\n    { rw [nat.succ_eq_one_add, add_assoc, add_left_cancel_iff] at hn,\n      rw nat.succ_eq_add_one,\n      rw \u2190 hn,\n      rw hl (node l) rfl,\n      rw hr (node r) rfl,\n      rw add_assoc,\n      rw add_comm 1,\n      refl\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209067,"user_id":null,"body":"import Preloaded tactic\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  revert n,\n  induction t with t ih t1 t2 ih1 ih2,\n  { simp [empty_place, node] },\n  all_goals \n  { intros n h, \n    simp [empty_place, node] at *, \n    cc, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209068,"user_id":null,"body":"import Preloaded\n\n\/-\ninductive BTree : Type\n| Leaf        : BTree\n| Single_Son  : BTree -> BTree\n| Binary_Sons : BTree -> BTree -> BTree\n\nopen BTree\n\ndef node : BTree \u2192 \u2115\n| Leaf                := 1\n| (Single_Son t')     := 1 + node t'\n| (Binary_Sons t1 t2) := 1 + node t1 + node t2\n\ndef empty_place : BTree \u2192 \u2115\n| Leaf                := 2\n| (Single_Son t')     := 1 + empty_place t'\n| (Binary_Sons t1 t2) := empty_place t1 + empty_place t2\n-\/\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  induction t with t h t1 t2 h1 h2 generalizing n,\n      rw \u2190H, refl,\n    unfold empty_place, unfold node at H,\n    rw \u2190H, rw nat.add_assoc, congr, apply h, refl,\n  unfold empty_place, unfold node at H,\n  rw \u2190H, rw h1 (node t1), rw h2 (node t2),\n  rw nat.add_comm (node t1), rw \u2190nat.add_assoc, refl, refl\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209069,"user_id":null,"body":"import Preloaded tactic\n\n\/-\ninductive BTree : Type\n| Leaf        : BTree\n| Single_Son  : BTree -> BTree\n| Binary_Sons : BTree -> BTree -> BTree\n\nopen BTree\n\ndef node : BTree \u2192 \u2115\n| Leaf                := 1\n| (Single_Son t')     := 1 + node t'\n| (Binary_Sons t1 t2) := 1 + node t1 + node t2\n\ndef empty_place : BTree \u2192 \u2115\n| Leaf                := 2\n| (Single_Son t')     := 1 + empty_place t'\n| (Binary_Sons t1 t2) := empty_place t1 + empty_place t2\n-\/\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  induction t with t ih t t2 ih i2 generalizing n,\n  all_goals { simp only [node, empty_place] at H \u22a2, rw \u2190H, try { rw (ih (node t) rfl)} , try { rw (i2 (node t2) rfl)}, try { ac_refl } },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209070,"user_id":null,"body":"import Preloaded tactic\n\ntheorem l (t n) (H : node t = n) : empty_place t = n + 1 :=\nbegin\n  induction t with t ih t1 t2 tih1 tih2 generalizing n; rw node at H; rw empty_place,\n  { linarith [H], },\n  {\n    cases n,\n    { linarith only [H], },\n    {\n      rw nat.succ_eq_add_one,\n      rw nat.succ_eq_add_one at H,\n      rw ih (node t) (by refl),\n      linarith [H],\n    },\n  },\n  {\n    cases n,\n    { linarith only [H], },\n    {\n      rw nat.succ_eq_add_one at H,\n      rw nat.succ_eq_add_one,\n      rw tih1 (node t1) (refl (node t1)),\n      rw tih2 (node t2) (refl (node t2)),\n      linarith [H],\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e10444e4225f3000123b9db":[{"id":209071,"user_id":null,"body":"import Preloaded tactic\n\nattribute [simp] dual\nattribute [simp] eval\n\n@[simp] def flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\nlemma flip_dual (f : formula) (m : \u2115 \u2192 bool) : bnot (eval (flip' m) f) = eval m (dual f) :=\nbegin\n    induction f;\n    simp * at *,\nend\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\nbegin\n    specialize h (flip' n),\n    rw \u2190 flip_dual f n,\n    simpa,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209072,"user_id":null,"body":"import Preloaded tactic.tauto\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\nlemma flip_flip (m : \u2115 \u2192 bool) : flip' (flip' m) = m := by { unfold flip', simp, }\n\nlemma flip_lem (f : formula) (m : \u2115 \u2192 bool) : eval m f = bnot (eval (flip' m) (dual f)) :=\nbegin\n  induction f with _ _ _ IH1 IH2 _ _ IH1 IH2; rw [dual, eval, eval],\n  { rw [flip', bnot_bnot], },\n  repeat { tauto, },\n  { rw [IH1, IH2, bool.bnot_band], },\n  { rw [IH1, IH2, bool.bnot_bor ], },\nend\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\nbegin\n  specialize h (flip' n),\n  cases f; rw [dual, eval],\n  { rwa [eval, flip', bnot_eq_true_eq_eq_ff] at h, },\n  { tauto, },\n  { rw [band_eq_false_eq_eq_ff_or_eq_ff, \u2190 bnot_eq_true_eq_eq_ff, \u2190 bnot_eq_true_eq_eq_ff],\n    rwa [eval, flip_lem, flip_lem _ (flip' n), flip_flip, bor_eq_true_eq_eq_tt_or_eq_tt] at h, },\n  { rw [bor_eq_false_eq_eq_ff_and_eq_ff, \u2190 bnot_eq_true_eq_eq_ff, \u2190 bnot_eq_true_eq_eq_ff],\n    rwa [eval, flip_lem, flip_lem _ (flip' n), flip_flip, band_eq_true_eq_eq_tt_and_eq_tt] at h, },\n  { rwa [bnot_eq_ff_eq_eq_tt, \u2190 bnot_bnot (eval n _), \u2190 flip_flip n, \u2190 flip_lem, \u2190 eval], },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209073,"user_id":null,"body":"import Preloaded tactic\n\nlemma ndual : \u2200 (f : formula), \u2200 n, eval n (dual f) = bnot (eval (bnot \u2218 n) f) :=\nbegin\n  intros f n,\n  induction f; simp [dual, eval],\n    simp [f_ih_\u03b1, f_ih_\u03b2],\n    simp [f_ih_\u03b1, f_ih_\u03b2],\n    rw [f_ih], simp,\nend\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\nbegin\n  rw [ndual f n, h (bnot \u2218 n)],\n  refl\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209074,"user_id":null,"body":"import Preloaded tactic\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\nopen formula\n\nlemma tautology_flip_of_tautology {f : formula} (h : \u2200 m, eval m f = tt) (n) : eval (flip' n) f = tt :=\nby { induction f; all_goals { specialize h (flip' n), simp [eval, flip'] at h \u22a2, try {assumption}}, }\n\nlemma flip_eq_not_dual {f : formula} {m} : eval (flip' m) f = eval m (not_f (dual f)) :=\nby { induction f with _ _ _ ha hb _ _ ha hb _ hb, all_goals { simp [flip', dual, eval] at *, try { rw ha }, try {rw hb} }, simp, }\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) : eval n (dual f) = ff := \nby {have h\u2082 := tautology_flip_of_tautology h n, simp [flip_eq_not_dual, dual, eval] at h\u2082, assumption }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209075,"user_id":null,"body":"import Preloaded data.bool\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\ntheorem full_duality (m f) : eval m (dual f) = bnot (eval (flip' m) f) :=\nbegin\n  induction f with f \u03b1 \u03b2 h\u03b1 h\u03b2 \u03b1 \u03b2 h\u03b1 h\u03b2 \u03b1 h,\n  repeat {simp [eval, dual, flip']},\n  repeat {simp [h\u03b1, h\u03b2, eval, dual, flip']},\n  simp [h, eval, dual, flip'],\nend\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff := by simp [full_duality, h]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209076,"user_id":null,"body":"import Preloaded data.bool\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\nlemma duality (f : formula) (m : \u2115 \u2192 bool) : bnot (eval (flip' m) f) = (eval m (dual f)) := by {\n  induction f with a f\u2081 f\u2082 ih\u2081 ih\u2082 f\u2081 f\u2082 ih\u2081 ih\u2082 f\u2081 ih\u2081; dsimp [dual, eval, flip'],\n  { rw bnot_bnot },\n  { refl },\n  { refl },\n  { rw [bool.bnot_bor], rw flip' at ih\u2081 ih\u2082, rw [ih\u2081, ih\u2082] },\n  { rw [bool.bnot_band], rw flip' at ih\u2081 ih\u2082, rw [ih\u2081, ih\u2082] },\n  { rw flip' at ih\u2081, rw [ih\u2081] }\n}\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) : eval n (dual f) = ff\n:= by { rw \u2190duality, rw h (flip' n), refl }\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209077,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen formula\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\n\nlemma duality (f : formula) (n : \u2115 \u2192 bool) : \n    eval n (dual f) = bnot (eval (flip' n) f) :=\nbegin\ninduction f,\n{\n    unfold dual eval flip',\n    simp,\n},\n{\n    unfold dual flip' eval,\n    refl,\n},\n{\n    unfold dual flip' eval,\n    refl,\n},\n{\n    unfold dual eval,\n    rw [f_ih_\u03b1, f_ih_\u03b2],\n    apply eq.symm,\n    apply bool.bnot_bor,\n},\n{\n    unfold dual eval,\n    rw [f_ih_\u03b1, f_ih_\u03b2],\n    apply eq.symm,\n    apply bool.bnot_band,    \n},\n{\n    unfold dual eval,\n    rw f_ih,\n}\nend\n\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\nbegin\nrw duality,\nspecialize h (flip' n),\nrw h,\nrefl,\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209078,"user_id":null,"body":"import Preloaded\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\n-- lemma 1: flip' is an involution\ntheorem flip_invol (m) : (flip' (flip' m)) = m :=\nbegin\nrepeat { rw flip'},\nsimp,\nend\n\n-- lemma 2: we can apply bnot to (or remove bnot from) both sides of a boolean identity\ntheorem bnot_eq (P : bool) (Q : bool) : (P = Q) \u2194 bnot P = bnot Q :=\nbegin\n-- no idea if the following is considered OK style\nsplit; cases Q with qt qf; intro h,\nrepeat { rw h },\nrepeat { \nhave g := bnot_bnot P,\nrw h at g,\nrw bnot_bnot at g,\nrw eq.symm(g),\n},\nend\n\n-- lemmas 3 and 4 : distributing - through || and &&\ntheorem neg_or (P : bool) (Q : bool) : bnot (P || Q) = (bnot P) && (bnot Q) :=\nbegin\ncases P with pt pf,\ncases Q with qt qt,\n\nrw ff_bor,\nrw bnot,\nrw band_tt,\n\nrw ff_bor,\nrw bnot,\nrw band_ff,\n\nrw tt_bor,\nrw bnot,\nrw ff_band,\nend\n\n\ntheorem neg_and (P : bool) (Q : bool) : bnot (P && Q) = (bnot P) || (bnot Q) :=\nbegin\nhave h := bnot_bnot ((bnot P) || (bnot Q)),\nrw neg_or at h,\nrepeat { rw bnot_bnot at h },\nexact h,\nend\n\n-- main duality lemma: -fhat(nhat) = f(n)\ntheorem duality_lemma (f : formula)(n) : \n  bnot(eval (flip' n) (dual f)) = (eval n f) :=\nbegin\ninduction f with p; rw eval,  \n  -- atoms are self-dual, so this base case is just boolean double-negation\n  rw flip', rw dual, rw eval,\n  rw bnot_bnot (n p),\n  -- constant formulae are a trivial case, but maybe there is a better\n  -- way to write the following\n  repeat {\n    rw flip', rw dual, rw eval,\n    rw bnot,\n  },\n  -- the content-ful cases are handled by lemmas 3 and 4 (+ induction)\n  rw dual,\n  rw eval,\n  rw neg_and,\n  rw f_ih_\u03b1,\n  rw f_ih_\u03b2,\n\n  rw dual,\n  rw eval,\n  rw neg_or,\n  rw f_ih_\u03b1,\n  rw f_ih_\u03b2,\n\n  -- negated formulae is just definitions + inductive hypothesis\n  rw dual,\n  rw eval,\n  rw f_ih, \nend\n\n\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\n\nbegin\n -- the main proof is now quite short!\n have d:= duality_lemma f (flip' n),\n have x:= h (flip' n),\n rw bnot_eq at d,\n rw bnot_bnot at d,\n rw flip_invol at d,\n rw x at d,\n rw bnot at d,\n exact d,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209079,"user_id":168,"body":"import Preloaded\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\n@[simp] lemma bnot_band : \u2200 (a b : bool), bnot (a && b) = bnot a || bnot b\n| ff _ := rfl\n| tt ff := rfl\n| tt tt := rfl\n\n@[simp] lemma bnot_bor : \u2200 (a b : bool), bnot (a || b) = bnot a && bnot b\n| tt _ := rfl\n| ff ff := rfl\n| ff tt := rfl\n\nlemma eval_dual (f : formula) (m) : \n  eval m (dual f) = bnot (eval (flip' m) f) :=\nby induction f; simp [dual, flip', eval, *] at *\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\nby rw [eval_dual, h]; refl","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209080,"user_id":null,"body":"import Preloaded\n\nopen formula\n\ndef flip' (m : \u2115 \u2192 bool) : \u2115 \u2192 bool :=\n\u03bb v, bnot $ m v\n\n@[simp] lemma bnot_or (x y : bool) : bnot (x || y) = bnot x && bnot y :=\nby { cases x; cases y; refl }\n\n@[simp] lemma bnot_and (x y : bool) : bnot (x && y) = bnot x || bnot y :=\nby { cases x; cases y; refl }\n\nlemma eval_dual : \u2200 (m : \u2115 \u2192 bool) (f : formula), eval (flip' m) (dual f) = bnot (eval m f)\n| m (atom v) := rfl\n| m true_f := rfl\n| m false_f := rfl\n| m (or_f \u03b1 \u03b2) := begin\n  show _ && _ = _,\n  rw [eval_dual, eval_dual],\n  simp [eval],\nend\n| m (and_f \u03b1 \u03b2) := begin\n  show _ || _ = _,\n  rw [eval_dual, eval_dual],\n  simp [eval],\nend\n| m (not_f \u03b1) := begin\n  show bnot _ = _,\n  rw eval_dual,\n  simp [eval],\nend\n\ntheorem tautology_duality (f : formula) (h : \u2200 m, eval m f = tt) (n) :\n  eval n (dual f) = ff :=\nbegin\n  let m := flip' n,\n  have : flip' m = n, by { funext, simp [flip', m] },\n  rw [\u2190this, eval_dual, h],\n  refl\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e3c1eb312676f001eb41f1c":[{"id":209081,"user_id":null,"body":"import Preloaded tactic\n\nopen formula MID\n\nlemma val_of_subst (f : formula) (s : \u2115 \u2192 formula) (m : \u2115 \u2192 MID) : \n  valuation f (\u03bb (n : \u2115), valuation (s n) m) = valuation (subst f s) m := \nby induction f; simp [valuation, subst, *]\n\nlemma hilbert_MID_sound {c : formula} (hc : hilbert c) : MID_valid c :=\nbegin\n  induction hc with _ X _ _ MVf MVf1 f s hf MVf; intro m; try { simp only [valuation] },\n  { specialize MVf m, rw [valuation, MVf1 m] at MVf, cases (valuation X m); tauto, },\n  { specialize MVf (\u03bb n, valuation (s n) m), \n    rwa val_of_subst f s m at MVf, },\n  repeat { cases (valuation X m); cases (valuation Y m); try {cases (valuation Z m)}; tauto, },\nend\n\nlemma LEM_not_MID_valid : \u00acMID_valid LEM := \u03bb h, by { specialize h (\u03bb _, mid), simpa, }\n\ntheorem hilbert_LEM_not_provable : \u00achilbert LEM :=\n-- This should not need modifying\nmt hilbert_MID_sound LEM_not_MID_valid","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209082,"user_id":null,"body":"import Preloaded\nimport tactic tactic.induction\n\nopen formula MID\n\nlemma subst_val (c : formula) (m : \u2115 \u2192 MID) (s : \u2115 \u2192 formula) : \n  valuation (subst c s) m = valuation c (\u03bbi, valuation (s i) m) :=\nbegin\n  induction' c;\n  all_goals {\n    simp [subst, valuation],\n    try { simp [ih_c m, ih_c_1 m] } },\nend\n\nlemma hilbert_MID_sound {c : formula} (hc : hilbert c) : MID_valid c := \nbegin\n  induction' hc;\n  simp [MID_valid] at *,\n  { intros m,\n    specialize ih_hc m,\n    specialize ih_hc_1 m,\n    simp [valuation, impl, ih_hc_1] at *,\n    cases (valuation c m);\n    simp [sel] at *;\n    assumption },\n  { intros m,\n    simp [subst_val],\n    apply ih },  \n  all_goals { intros m,\n    simp [valuation, impl] at *,\n    cases (valuation X m);\n    cases (valuation Y m);\n    cases (valuation Z m);\n    simp [sel, join, meet, impl] }  \nend\n\nlemma LEM_not_MID_valid : \u00acMID_valid LEM := \nbegin\n  simp [LEM, MID_valid],\n  use [\u03bbi, mid],\nend\n\ntheorem hilbert_LEM_not_provable : \u00achilbert LEM :=\n  mt hilbert_MID_sound LEM_not_MID_valid","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209083,"user_id":null,"body":"import Preloaded tactic\n\nopen formula MID\n\nattribute [simp] MID_valid sel valuation meet join impl subst\n\n@[simp]\nlemma sel_all_self {x : MID} : sel x bot mid top = x := begin\n  cases x; rw sel,\nend\n\nlemma hilbert_subst_same {c : formula} (s : \u2115 \u2192 formula) : \u2200 m, valuation (subst c s) m = valuation c (\u03bb n, valuation (s n) m) := begin\n  intro m,\n  induction c,\n  any_goals { refl, },\n  any_goals { simp *, },\nend\n\nlemma hilbert_MID_sound {c : formula} (hc: hilbert c) : MID_valid c := begin\n  induction hc with _ _ _ _ hc_ih hc_ih_a hc_a hc_s _ hc_ih,\n  any_goals {\n    intro m, simp,\n    cases valuation X m; simp;\n    cases valuation Y m; simp;\n    cases valuation Z m; simp;\n    done,\n  },\n  case app_h {\n    intro m, specialize hc_ih m, specialize hc_ih_a m,\n    simp [hc_ih_a] at hc_ih,\n    -- rw [valuation, hc_ih_a, impl, sel, sel_all_self] at hc_ih,\n    assumption,\n  },\n  case subst_h {\n    intro m, specialize hc_ih (\u03bb n, valuation (hc_s n) m),\n    rwa hilbert_subst_same hc_s m,\n  },\n\nend\n\nlemma LEM_not_MID_valid : \u00acMID_valid LEM := begin\n  unfold MID_valid, push_neg,\n  use \u03bb x, mid,\nend\n\ntheorem hilbert_LEM_not_provable : \u00achilbert LEM :=\nmt hilbert_MID_sound LEM_not_MID_valid\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209084,"user_id":168,"body":"import Preloaded\n\nopen formula MID\n\nlemma valid_subst (a) (s) (ha : MID_valid a) : MID_valid (subst a s) :=\n\u03bb m, begin\n  suffices : valuation (subst a s) m = valuation a (\u03bb v, valuation (s v) m), rw [this, ha],\n  clear ha, induction a; simp only [valuation, subst, *]\nend\n\nlemma hilbert_MID_sound {c : formula} (hc : hilbert c) : MID_valid c :=\nbegin\n  induction hc,\n  { intro m, specialize hc_ih_a m, specialize hc_ih_a_1 m,\n    rw [valuation, impl] at hc_ih_a,\n    cases valuation hc_\u03b2 m; simp only [sel] at hc_ih_a; cases valuation hc_\u03b1 m; simp only [sel] at hc_ih_a; cc, },\n  { exact valid_subst hc_\u03b1 hc_s hc_ih },\n  all_goals { intro m; simp only [X, Y, Z, valuation];\n              cases m 0; cases m 1; cases m 2; refl, }\nend\n\nlemma LEM_not_MID_valid : \u00acMID_valid LEM :=\nby intro h; specialize h (\u03bb _, mid); cases h\n\ntheorem hilbert_LEM_not_provable : \u00achilbert LEM :=\nmt hilbert_MID_sound LEM_not_MID_valid","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209085,"user_id":196,"body":"import Preloaded\n\nopen formula MID\n\nlemma valuation_subst {c : formula} {s : \u2115 \u2192 formula} {m : \u2115 \u2192 MID} :\n  valuation (subst c s) m = valuation c (\u03bb n, valuation (s n) m) :=\nby induction c; simp! only *\n\nlemma hilbert_MID_sound {c : formula} (hc : hilbert c) : MID_valid c :=\nbegin\n  induction hc,\n  case hilbert.app_h : \u03b1 \u03b2 _ _ ih1 ih2\n  { intro m, specialize ih1 m, specialize ih2 m, unfold valuation at ih1, rw ih2 at ih1,\n    cases valuation \u03b2 m; exact ih1 },\n  case hilbert.subst_h : \u03b1 s _ ih\n  { intro m, rw valuation_subst, exact ih _ },\n  all_goals { intro m, unfold valuation X Y Z,\n    cases m 0; try {refl}; cases m 1; try {refl}; cases m 2; try {refl} }\nend\n\nlemma LEM_not_MID_valid : \u00acMID_valid LEM :=\n\u03bb h, match h (\u03bb _, mid) with end\n\ntheorem hilbert_LEM_not_provable : \u00achilbert LEM :=\n-- This should not need modifying\nmt hilbert_MID_sound LEM_not_MID_valid\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e3cd88fa5b6a8001fa84ed5":[{"id":209086,"user_id":null,"body":"import Preloaded\nimport tactic.push_neg\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) :=\nbegin\n  have all_drunk := classical.em (\u2200 x : \u03b1, r x), \n  cases all_drunk with all_drunk not_all_drunk,\n  { have dan := (_inst_1).intro ,cases dan, cases dan, existsi dan, intro, exact all_drunk },\n  { push_neg at not_all_drunk,\n    cases not_all_drunk with sam sam_is_sober,\n    existsi sam, intro sam_is_drunk, exfalso, exact sam_is_sober sam_is_drunk }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209087,"user_id":null,"body":"import Preloaded tactic\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) :=\nby { by_cases \u2200 y, r y, { simp [h], },\n                        { push_neg at h, cases h with x, use x, }, }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209088,"user_id":null,"body":"universe u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] : \u2203 x, (r x \u2192 \u2200 y, r y) :=\nbegin\n  cases (classical.em (\u2203 x, \u00acr x)),\n  {\n    cases (classical.indefinite_description _ h),\n    existsi val, intro, contradiction\n  },\n  {\n    existsi (classical.choice (by assumption)),\n    intros, by_contra h1, apply h, existsi y, assumption\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209089,"user_id":null,"body":"import Preloaded\nimport tactic\n\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) := \n  begin\nby_cases \u2200 z, r z,\ntactic.unfreeze_local_instances,\ncases _inst_1 with w,\nuse w,\nintro h3,\nexact h,\nrw push_neg.not_forall_eq at h,\ncases h with w,\nuse w,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209090,"user_id":191,"body":"import Preloaded tactic\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) :=\nbegin\n  by_cases h : \u2200 y, r y,\n  use classical.arbitrary \u03b1,\n  intro,\n  exact h,\n  push_neg at h,\n  rcases h with \u27e8x, hx\u27e9,\n  use x\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209091,"user_id":null,"body":"import tactic\nimport Preloaded\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) := \nbegin\n  by_cases h : \u2200(y : \u03b1), r y,\n\n  {have a : \u03b1 := nonempty.some _inst_1,\n  use a, finish, },\n\n  {push_neg at h, rcases h with \u27e8a, h\u27e9, use a, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209092,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) := \nbegin\n  by_contradiction h,\n  push_neg at h,\n  rcases h (nonempty.some _) with \u27e8hr, a, ha\u27e9,\n  exact ha (h a).left,\n  assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209093,"user_id":null,"body":"import Preloaded\nimport tactic\nopen_locale classical\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) := \n  begin\n    by_contra h,\n    push_neg at h,\n    have y : \u03b1 := classical.choice _inst_1, \n    cases (h y).2 with y\u2081 h\u2081, exact h\u2081 (h y\u2081).1,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209094,"user_id":null,"body":"import Preloaded\nimport tactic\n\nuniverse u\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) :=\nbegin\n  by_cases h : \u2200 p, r p,\n  { -- if everybody is drinking\n    use nonempty.some _inst_1,\n    intros _ y, exact h y,\n  },\n  { -- if somebody isn't drinking\n    push_neg at h,\n    obtain \u27e8x, nrx\u27e9 := h,\n    use x,\n  },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209095,"user_id":null,"body":"import Preloaded tactic\n\nuniverse u\n\nopen_locale classical\n\ntheorem drinker {\u03b1 : Type u} (r : \u03b1 \u2192 Prop) [i : nonempty \u03b1] :\n  \u2203 x, (r x \u2192 \u2200 y, r y) :=\nbegin\n  by_contra h,\n  push_neg at h,\n  obtain \u27e8h\u2082, x, _\u27e9 := h (nonempty.some i),\n  obtain \u27e8_, y, _\u27e9 := h x,\n  contradiction,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e59626530e9d00028bbe569":[{"id":209096,"user_id":null,"body":"import Preloaded tactic\n\nopen nat times_3_plus_5\n\nlemma upward_closed {k n : \u2115} : k \u2264 n \u2192 n%5 = k%5\n  \u2192 times_3_plus_5 k \u2192 times_3_plus_5 n :=\nbegin\n  intros hle hmod hk, replace hmod := sub_mod_eq_zero_of_mod_eq hmod,\n  rw \u2190 dvd_iff_mod_eq_zero at hmod, cases hmod with m hm,\n  rw nat.sub_eq_iff_eq_add hle at hm, subst hm,\n  clear hle, induction m with m hm, simpa,\n  rw [mul_succ, add_right_comm], exact plus_5 _ hm,\nend\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt := \nbegin\n  unfold decide, split,\n  { intro h, induction h with n _ ih n _ ih, solve_by_elim,\n    { rw mul_mod, have hu := @mod_lt n 5 (by norm_num),\n      interval_cases n%5,\n      iterate 5 {rw h at ih \u22a2, solve_by_elim <|>\n        {norm_num, unfold decide at ih \u22a2,\n          simp at ih \u22a2, linarith [mod_le n 5]}}, },\n    rw add_mod_right, delta decide at ih,\n    split_ifs at ih with h0 h2 h4,\n    cases ih, repeat {rw h2 <|> rw h4, \n      unfold decide, simp at ih \u22a2, linarith},\n    rw decide, exact h4, exact h2, exact h0, },\n  { intro h, have h9 := times_3 3 (times_3 1 start),\n    have hu := @mod_lt n 5 (by norm_num), interval_cases n%5;\n    rw h_1 at h, cases h, any_goals {unfold decide at h, simp at h},\n    all_goals {apply upward_closed, exact h <|> exact mod_le n 5,\n      any_goals {rw h_1}, norm_num},\n    exacts [start, times_3 9 h9, times_3 1 start, h9], },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209097,"user_id":null,"body":"import Preloaded\nimport tactic data.nat.prime\nopen nat\n\nlemma lem1 {a : \u2115} (h : \u00ac 3 \u2223 a) (j : \u2115): \u00ac j * 2 + j = a :=\nbegin\n  ring_nf,\n  intro three_dvd,\n  exact h (dvd.intro j three_dvd), \nend\n\nlemma not_2_4 {a : \u2115} (h : times_3_plus_5 a) : a \u2260 2 \u2227 a \u2260 4 :=\nbegin\n  split;\n  { cases h with j _ _ _, \n    { norm_num, }, \n    { simp only [mul_def, add_zero, add_def, ne.def],\n      exact lem1 (by norm_num) j},\n    { simp only [mul_def, add_zero, add_def, ne.def, succ_eq_add_one],\n      linarith, }, },\nend\n\nlemma not_7 {a : \u2115} (h : times_3_plus_5 a) : a \u2260 7 :=\nbegin\n  cases h with j _ k hk, \n  { norm_num, }, \n  { simp only [mul_def, add_zero, add_def, ne.def],\n    exact lem1 (by norm_num) j, },\n  { simp only [add_zero, add_def, ne.def, succ_eq_add_one], \n    intro k_eq, \n    replace k_eq : k = 2, by linarith,\n    rw k_eq at hk,\n    exact (not_2_4 hk).1 (refl 2), },\nend\n\nlemma not_12 {a : \u2115} (h : times_3_plus_5 a) : a \u2260 12 :=\nbegin\n  cases h with j hj k hk, \n  { norm_num, }, \n  { simp only [mul_def, add_zero, add_def, ne.def],\n    ring_nf,\n    intro j_eq_4,\n    replace j_eq_4 : j = 4, by linarith,\n    rw j_eq_4 at hj,\n    exact (not_2_4 hj).2 (refl 4), }, \n  { simp only [add_zero, add_def, ne.def, succ_eq_add_one], \n    intro k_eq, \n    replace k_eq : k = 7, by linarith,\n    rw k_eq at hk,\n    exact (not_7 hk) (refl 7), },\nend\n\nlemma not_17 {a : \u2115} (h : times_3_plus_5 a) : a \u2260 17 :=\nbegin\n  cases h with j _ k hk, \n  { norm_num, }, \n  { simp only [mul_def, add_zero, add_def, ne.def],\n    exact lem1 (by norm_num) j },\n  { simp only [add_zero, add_def, ne.def, succ_eq_add_one], \n    intro k_eq, \n    replace k_eq : k = 12, by linarith,\n    rw k_eq at hk,\n    exact (not_12 hk) (refl 12), },\nend\n\nlemma not_22 {a : \u2115} (h : times_3_plus_5 a) : a \u2260 22 :=\nbegin\n  cases h with j _ k hk, \n  { norm_num, }, \n  { simp only [mul_def, add_zero, add_def, ne.def],\n    exact lem1 (by norm_num) j },\n  { simp only [add_zero, add_def, ne.def, succ_eq_add_one], \n    intro k_eq, \n    replace k_eq : k = 17, by linarith,\n    rw k_eq at hk,\n    exact (not_17 hk) (refl 17), },\nend\n\nlemma not_7_12_17_22 {a : \u2115} (h : times_3_plus_5 a) : a \u2260 7 \u2227 a \u2260 12 \u2227 a \u2260 17 \u2227 a \u2260 22 := \n\u27e8not_7 h, not_12 h, not_17 h, not_22 h\u27e9\n\nopen times_3_plus_5\n\ntheorem decide_works (n : \u2115) : times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  have := nat.mod_lt n (show 0<5, by norm_num),\n  interval_cases n % 5; clear this,\n  \n  -- n % 5 = 0\n  { simp only [(show decide n = ff, by {unfold decide, rw h, refl}), iff_false],\n    intro t3p5,\n    induction t3p5 with _ _ IH _ _ IH,\n    { simpa, },\n    repeat { apply IH, rw \u2190 nat.dvd_iff_mod_eq_zero at *, },\n    { apply or.resolve_right (prime.dvd_or_dvd (prime_iff.1 (by norm_num)) h) (by norm_num), }, \n    { exact nat.dvd_add_self_right.1 h, }, },\n\n  -- n % 5 = 1\n  { simp only [(show decide n = tt, by {unfold decide, rw h, refl}), eq_self_iff_true, iff_true],\n    replace h : \u2203 (k : \u2115), 5 * k + 1 = n, by { use n \/ 5, convert nat.div_add_mod n 5, rw h, },\n    rcases h with \u27e8k, rfl\u27e9, \n    induction k with j hj,\n    { exact start,         },\n    { exact (plus_5 _) hj, }, },\n\n  -- n % 5 = 2\n  { simp only [(show decide n = (27 \u2264 n), by {unfold decide, rw h, refl}), to_bool_iff], \n    replace h : \u2203 (k : \u2115), 5 * k + 2 = n, by { use n \/ 5, convert nat.div_add_mod n 5, rw h, },\n    rcases h with \u27e8k, rfl\u27e9,\n    cases k, \n    { simp only [lt_one_iff, zero_add, nat.bit1_ne_zero, bit1_le_bit0_iff, mul_zero, iff_false],\n      intro t3p5,\n      exact (not_2_4 t3p5).1 (refl 2), },\n    cases k, swap, cases k, swap, cases k, swap, cases k,\n    repeat { norm_num, intro t3p5, have := not_7_12_17_22 t3p5, tauto, },\n    suffices : times_3_plus_5 (5 * k.succ.succ.succ.succ.succ + 2),\n    { convert iff_true_intro this,\n      simp only [eq_true, succ_eq_add_one],\n      linarith, },\n    induction k with j hj,\n    { exact (times_3 9) ((times_3 3) (times_3 1 start)), },\n    { exact (plus_5  _) hj, }, },\n  \n  -- n % 5 = 3\n  { simp only [(show decide n = tt, by {unfold decide, rw h, refl}), eq_self_iff_true, iff_true],\n    replace h : \u2203 (k : \u2115), 5 * k + 3 = n, by { use n \/ 5, convert nat.div_add_mod n 5, rw h, },\n    rcases h with \u27e8k, rfl\u27e9,\n    induction k with j hj,\n    { exact (times_3 1) start, },\n    { exact (plus_5  _) hj,    }, },\n\n  -- n % 5 = 4\n  { simp only [(show decide n = (9 \u2264 n), by {unfold decide, rw h, refl}), to_bool_iff], \n    replace h : \u2203 (k : \u2115), 5 * k + 4 = n, by { use n \/ 5, convert nat.div_add_mod n 5, rw h, },\n    rcases h with \u27e8k, rfl\u27e9, \n    cases k,\n    { simp only [mul_zero, zero_add, (show \u00ac 9 \u2264 4, by norm_num), iff_false],\n      intro t3p5,\n      exact (not_2_4 t3p5).2 (refl 4), }, \n    { suffices : times_3_plus_5 (5 * k.succ + 4),\n      { convert iff_true_intro this,\n        rw [eq_true, succ_eq_add_one],\n        linarith, },\n      induction k with j hj,\n      { exact (times_3 3) (times_3 1 start), },\n      { exact (plus_5  _) hj, }, }, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209098,"user_id":null,"body":"import Preloaded tactic\n\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  split,\n  {\n    intro hn,\n    induction hn with a _ha ha b _hb hb,\n    { refl },\n    {\n      clear n _ha,\n      have : a = (a \/5) * 5 + (a%5) := (nat.div_add_mod' a 5).symm,\n      have bound : a%5 < 5 := nat.mod_lt a (by linarith),\n      simp [decide] at *,\n      cases a % 5 with m,\n      { cases ha, },\n      {\n        cases m with m,\n        {\n          have h3a : (a*3) % 5 = 3,\n          {\n            rw [this,add_mul,add_comm,mul_assoc,mul_comm 5 3,\u2190 mul_assoc,nat.add_mul_mod_self_right],\n            refl,\n          },\n          rw h3a,\n          refl,\n        },\n        cases m with m,\n        {\n          have h3a : (a*3) % 5 = 1,\n          {\n            rw [this,add_mul,add_comm,mul_assoc,mul_comm 5 3,\u2190 mul_assoc,nat.add_mul_mod_self_right],\n            refl,\n          },\n          rw h3a,\n          refl,\n        },\n        cases m with m,\n        {\n          have h3a : (a*3) % 5 = 4,\n          {\n            rw [this,add_mul,add_comm,mul_assoc,mul_comm 5 3,\u2190 mul_assoc,nat.add_mul_mod_self_right],\n            refl,\n          },\n          rw h3a,\n          simp [decide],\n          rw [this,add_mul],\n          norm_num,\n        },\n        cases m with m,\n        {\n          have h3a : (a*3)%5 = 2,\n          {\n            rw [this,add_mul,add_comm,mul_assoc,mul_comm 5 3,\u2190 mul_assoc,nat.add_mul_mod_self_right],\n            refl,\n          },\n          rw h3a,\n          simp [decide] at ha \u22a2,\n          linarith,\n        },\n        simp [nat.succ_eq_add_one] at bound,\n        linarith,\n      },\n    },\n    {\n      clear n _hb,\n      have : b = (b \/5) * 5 + (b%5) := (nat.div_add_mod' b 5).symm,\n      have bound : b%5 < 5 := nat.mod_lt b (by linarith),\n      have b5mod: (b+5)%5 = b%5 ,\n      {\n        rw nat.add_mod,\n        have : (5%5=0):=(by refl),\n        rw this,\n        simp,\n      },\n      simp [decide] at *,\n      cases b%5 with m,\n      {\n        cases hb,\n      },\n      cases m with m,\n      {\n        simp [decide],\n      },\n      cases m with m,\n      {\n        simp [decide] at hb \u22a2,\n        linarith,\n      },\n      cases m with m,\n      {\n        refl,\n      },\n      cases m with m,\n      {\n        simp [decide] at hb \u22a2,\n        linarith,\n      },\n      simp [nat.succ_eq_add_one] at bound,\n      linarith,\n    }\n  },\n  {\n    intro hdec,\n    have bound : n%5 < 5 := nat.mod_lt _ (by linarith),\n    have : n = n \/ 5 * 5 + n%5 := (nat.div_add_mod' n 5).symm,\n    simp [decide] at hdec,\n    cases n % 5 with m,\n    {\n      cases hdec,\n    },\n    cases m with m,\n    {\n      clear hdec,\n      have : \u2203 d : \u2115 , n = d*5 + 1,\n      {\n        use n\/5,\n        exact this,\n      },\n      cases this with d hd,\n      clear this,\n      rw hd,\n      clear hd,\n      induction d with d ihd,\n      {\n        exact times_3_plus_5.start,\n      },\n      {\n        rw nat.succ_eq_add_one,\n        have : (d+1)*5 + 1 = d*5+1+5 := by ring,\n        rw this,\n        exact times_3_plus_5.plus_5 _ ihd,\n      }\n    },\n    cases m with m,\n    {\n      simp [decide] at hdec,\n      have : \u2203 d , n = d*5+27,\n      {\n        have hs : \u2203 s , s=n\/5 := by use n\/5 ,\n        cases hs with s hs,\n        rw \u2190 hs at this,\n        rw this at hdec,\n        change 5*5+2 \u2264 s*5 +2 at hdec,\n        have h1 : 5 \u2264 s := by linarith only [hdec],\n        have h2 : \u2203 d , s=5+d := nat.exists_eq_add_of_le h1,\n        cases h2 with d hd,\n        use d,\n        rw hd at this,\n        rw this,\n        ring_nf,\n      },\n      cases this with d hd,\n      rw hd,\n      clear hdec hd this n,\n      induction d with d ihd,\n      {\n        exact times_3_plus_5.times_3 _ (times_3_plus_5.times_3 _ (times_3_plus_5.times_3 _ times_3_plus_5.start)),\n      },\n      {\n        have : d.succ * 5 + 27 = d*5 + 27+ 5,\n        {\n          simp [nat.succ_eq_add_one],\n          ring,\n        },\n        rw this,\n        exact times_3_plus_5.plus_5 _ ihd,\n      },\n    },\n    cases m with m,\n    {\n      clear hdec,\n      have : \u2203 d , n\/5 = d := by use n\/5,\n      cases this with d hd,\n      rw hd at this,\n      rw this,\n      clear this hd n,\n      induction d with d ihd,\n      {\n        exact times_3_plus_5.times_3 _ times_3_plus_5.start \n      },\n      have : d.succ * 5 + 3 = d*5 + 3 + 5,\n      {\n        rw nat.succ_eq_add_one,\n        ring,\n      },\n      rw this,\n      exact times_3_plus_5.plus_5 _ ihd,\n    },\n    cases m with m,\n    {\n      simp [decide] at hdec,\n      have hd : \u2203 d , n\/5 = d := by use n\/5,\n      cases hd with d hd,\n      rw hd at this,\n      cases d,\n      {\n        rw [this] at hdec,\n        change 9 \u2264 4 at hdec,\n        linarith only [hdec],\n      },\n      rw this,\n      clear this hd hdec n,\n      induction d with d hd,\n      {\n        exact times_3_plus_5.times_3 _ (times_3_plus_5.times_3 _ (times_3_plus_5.start)),\n      },\n      {\n        have : d.succ.succ * 5+4 = d.succ * 5 + 4 + 5,\n        {\n          rw nat.succ_eq_add_one,\n          ring,\n        },\n        rw this,\n        exact times_3_plus_5.plus_5 _ hd,\n      }\n    },\n    simp only [nat.succ_eq_add_one] at bound,\n    linarith only [bound],\n  }\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209099,"user_id":660,"body":"import Preloaded\nimport tactic\nimport data.nat.prime\n\nlemma nat.prime_five : nat.prime 5 := by norm_num\n\nlemma mem_of_big_and_not_mod_three {n : \u2115} (hn : (n + 5) % 3 \u2260 0) :\n  times_3_plus_5 (n + 5) \u2192 times_3_plus_5 n :=\nbegin\n  have : \u2200 m n, n + 5 = m \u2192 m % 3 \u2260 0 \u2192 times_3_plus_5 m \u2192 times_3_plus_5 n,\n  { intros m k h\u2081 h\u2082 h\u2083,\n    induction h\u2083 with h\u2084 h\u2085 h\u2086 h\u2087 h\u2088 h\u2089 generalizing k,\n    { simpa using h\u2081 },\n    { simpa using h\u2082 },\n    simp only [add_left_inj] at h\u2081,\n    rwa h\u2081 },\n  apply this _ _ rfl hn,\nend\n\nlemma mem_of_small {n : \u2115} (hn : n < 5) (hn' : n % 3 \u2260 0) (hn'' : n \u2260 1) :\n  \u00actimes_3_plus_5 n :=\nbegin\n  intro h,\n  induction h,\n  { simpa },\n  { simpa using hn' },\n  { simpa using hn },\nend\n\nlemma not_times_3_plus_5_2 : \u00actimes_3_plus_5 2 :=\nmem_of_small (by norm_num) (by norm_num) (by norm_num)\nlemma not_times_3_plus_5_4 : \u00actimes_3_plus_5 4 :=\nmem_of_small (by norm_num) (by norm_num) (by norm_num)\n\n\nlemma mod_zero_aux {n : \u2115} (hn : times_3_plus_5 n) : n % 5 \u2260 0 :=\nbegin\n  induction hn with m hm hm' _ _ hm,\n  { simp },\n  { rw [ne.def, \u2190nat.dvd_iff_mod_eq_zero, nat.prime_five.dvd_mul, not_or_distrib,\n      nat.dvd_iff_mod_eq_zero, and_iff_right hm'],\n    norm_num },\n  simp [hm],\nend\n\nlemma mod_zero (n : \u2115) (hn : n % 5 = 0) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  simp only [decide, hn, iff_false],\n  exact \u03bb h, mod_zero_aux h hn,\nend\n\nlemma mod_one_aux (n : \u2115) : times_3_plus_5 (5 * n + 1) :=\nbegin\n  induction n with n ih,\n  { simp [times_3_plus_5.start] },\n  rw [nat.mul_succ, add_right_comm],\n  exact times_3_plus_5.plus_5 _ ih,\nend\n\nlemma mod_one (n : \u2115) (hn : n % 5 = 1) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  simp only [hn, decide, nat.one_ne_bit0, not_false_iff, nat.one_ne_zero, eq_self_iff_true,\n    iff_true],\n  rw [\u2190nat.div_add_mod n 5, hn],\n  apply mod_one_aux\nend\n\nlemma not_times_3_plus_5_7 : \u00actimes_3_plus_5 7 :=\nmt (mem_of_big_and_not_mod_three (by norm_num)) not_times_3_plus_5_2\nlemma not_times_3_plus_5_12 : \u00actimes_3_plus_5 12 :=\nbegin\n  suffices : \u2200 n, times_3_plus_5 n \u2192 n \u2260 12,\n  { exact \u03bb h, this 12 h rfl },\n  intros n hn,\n  induction hn with m k,\n  { simp },\n  { refine mt _ not_times_3_plus_5_4,\n    simp only [\u2190(show 4 * 3 = 12, by norm_num1), mul_eq_mul_right_iff, nat.bit1_ne_zero,\n      or_false],\n    rintro rfl,\n    assumption },\n  { refine mt _ not_times_3_plus_5_7,\n    simp only [\u2190(show 7 + 5 = 12, by norm_num1), add_left_inj],\n    rintro rfl,\n    assumption },\nend\nlemma not_times_3_plus_5_17 : \u00actimes_3_plus_5 17 :=\nmt (mem_of_big_and_not_mod_three (by norm_num)) not_times_3_plus_5_12\nlemma not_times_3_plus_5_22 : \u00actimes_3_plus_5 22 :=\nmt (mem_of_big_and_not_mod_three (by norm_num)) not_times_3_plus_5_17\nlemma times_3_plus_5_9 : times_3_plus_5 9 :=\ntimes_3_plus_5.times_3 3 (times_3_plus_5.times_3 1 times_3_plus_5.start)\nlemma times_3_plus_5_27 : times_3_plus_5 27 :=\ntimes_3_plus_5.times_3 _ times_3_plus_5_9\n\nlemma mod_two_aux {n : \u2115} : 5 \u2264 n \u2192 times_3_plus_5 (5 * n + 2) :=\nbegin\n  intro hn,\n  obtain \u27e8w, rfl\u27e9 := nat.exists_eq_add_of_le hn,\n  clear hn,\n  induction w with w ih,\n  { norm_num [times_3_plus_5_27] },\n  rw [nat.add_succ 5, nat.mul_succ, add_right_comm],\n  exact times_3_plus_5.plus_5 _ ih,\nend\n\nlemma mod_two_aux' : \u2200 {n}, times_3_plus_5 (5 * n + 2) \u2192 5 \u2264 n\n| 0 := by norm_num [not_times_3_plus_5_2]\n| 1 := by norm_num [not_times_3_plus_5_7]\n| 2 := by norm_num [not_times_3_plus_5_12]\n| 3 := by norm_num [not_times_3_plus_5_17]\n| 4 := by norm_num [not_times_3_plus_5_22]\n| (n+5) := by simp\n\nlemma mod_two_aux'' {n : \u2115} : times_3_plus_5 (5 * n + 2) \u2194 5 \u2264 n :=\n\u27e8mod_two_aux', mod_two_aux\u27e9\n\nlemma mod_two {n : \u2115} (hn : n % 5 = 2) : times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  simp only [hn, decide, to_bool_iff],\n  rw [\u2190nat.div_add_mod n 5, hn, mod_two_aux'', \u2190(show 5 * 5 + 2 = 27, by norm_num),\n    add_le_add_iff_right],\n  split,\n  { intro h,\n    exact nat.mul_le_mul_left _ h },\n  { intro h,\n    exact nat.le_of_mul_le_mul_left h (by norm_num1) }\nend\n\nlemma mod_three_aux (n : \u2115) : times_3_plus_5 (5 * n + 3) :=\nbegin\n  induction n with n ih,\n  { rw [mul_zero, zero_add, \u2190one_mul 3],\n    exact times_3_plus_5.times_3 1 times_3_plus_5.start },\n  rw [nat.mul_succ, add_right_comm],\n  exact times_3_plus_5.plus_5 _ ih,\nend\n\nlemma mod_three (n : \u2115) (hn : n % 5 = 3) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  simp only [hn, decide, nat.bit1_ne_bit0, not_false_iff, nat.bit1_ne_zero, eq_self_iff_true,\n    iff_true],\n  rw [\u2190nat.div_add_mod n 5, hn],\n  apply mod_three_aux\nend\n\nlemma mod_four_aux {n : \u2115} : 1 \u2264 n \u2192 times_3_plus_5 (5 * n + 4) :=\nbegin\n  intro hn,\n  obtain \u27e8w, rfl\u27e9 := nat.exists_eq_add_of_le hn,\n  clear hn,\n  induction w with w ih,\n  { norm_num [times_3_plus_5_9] },\n  rw [nat.add_succ 1, nat.mul_succ, add_right_comm],\n  exact times_3_plus_5.plus_5 _ ih,\nend\n\nlemma mod_four_aux' : \u2200 {n}, times_3_plus_5 (5 * n + 4) \u2192 1 \u2264 n\n| 0 := by norm_num [not_times_3_plus_5_4]\n| (n+1) := by simp\n\nlemma mod_four_aux'' {n : \u2115} : times_3_plus_5 (5 * n + 4) \u2194 1 \u2264 n :=\n\u27e8mod_four_aux', mod_four_aux\u27e9\n\nlemma mod_four {n : \u2115} (hn : n % 5 = 4) : times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  simp only [hn, decide, to_bool_iff],\n  rw [\u2190nat.div_add_mod n 5, hn, mod_four_aux'', \u2190(show 5 * 1 + 4 = 9, by norm_num),\n    add_le_add_iff_right],\n  split,\n  { intro h,\n    exact nat.mul_le_mul_left _ h },\n  { intro h,\n    exact nat.le_of_mul_le_mul_left h (by norm_num1) }\nend\n\nlemma lt_five : \u2200 n, n < 5 \u2192 n = 0 \u2228 n = 1 \u2228 n = 2 \u2228 n = 3 \u2228 n = 4\n| 0 := by simp\n| 1 := by simp\n| 2 := by simp\n| 3 := by simp\n| 4 := by simp\n| (n+5) := by simp\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  rcases lt_five _ (nat.mod_lt n (by norm_num1)) with (h | h | h | h | h),\n  { rw [mod_zero _ h] },\n  { rw [mod_one _ h] },\n  { rw [mod_two h] },\n  { rw [mod_three _ h] },\n  { rw [mod_four h] },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209100,"user_id":17,"body":"import Preloaded tactic data.nat.modeq\n\nopen times_3_plus_5 nat nat.modeq\n\n-- Trivial lemmas just to avoid deterministic timeout\nlemma mul_3_not_1 : \u2200 m, m * 3 \u2260 1 := by omega\nlemma mul_3_not_2 : \u2200 m, m * 3 \u2260 2 := by omega\nlemma mul_1_3_3 : \u2200 m, m * 3 = 3 \u2192 m = 1 := by omega\nlemma mul_3_not_4 : \u2200 m, m * 3 \u2260 4 := by omega\nlemma mul_3_not_5 : \u2200 m, m * 3 \u2260 5 := by omega\nlemma mul_2_3_6 : \u2200 m, m * 3 = 6 \u2192 m = 2 := by omega\nlemma mul_3_not_7 : \u2200 m, m * 3 \u2260 7 := by omega\nlemma mul_3_not_8 : \u2200 m, m * 3 \u2260 8 := by omega\nlemma nine_le : \u2200 m, 9 \u2264 succ (succ (succ (succ (succ (succ (succ (succ (succ m)))))))) := by omega\nlemma twenty_seven_le_mult_3_of_9_le_m : \u2200 m, 9 \u2264 m \u2192 27 \u2264 m * 3 := by omega\nlemma twenty_seven_le_plus_5_of_27_le_m : \u2200 m, 27 \u2264 m \u2192 27 \u2264 m + 5 := by omega\nlemma nine_le_plus_5_of_9_le_m : \u2200 m, 9 \u2264 m \u2192 9 \u2264 m + 5 := by omega\nlemma twenty_seven_nle_2 : 27 \u2264 2 \u2192 false := by omega\nlemma twenty_seven_nle_5 : 27 \u2264 5 \u2192 false := by omega\nlemma twenty_seven_nle_6 : 27 \u2264 6 \u2192 false := by omega\nlemma twenty_seven_nle_7 : 27 \u2264 7 \u2192 false := by omega\nlemma twenty_seven_nle_8 : 27 \u2264 8 \u2192 false := by omega\nlemma twenty_seven_nle_9 : 27 \u2264 9 \u2192 false := by omega\nlemma twenty_seven_nle_10 : 27 \u2264 10 \u2192 false := by omega\nlemma twenty_seven_nle_11 : 27 \u2264 11 \u2192 false := by omega\nlemma twenty_seven_nle_12 : 27 \u2264 12 \u2192 false := by omega\nlemma twenty_seven_nle_13 : 27 \u2264 13 \u2192 false := by omega\nlemma twenty_seven_nle_14 : 27 \u2264 14 \u2192 false := by omega\nlemma twenty_seven_nle_15 : 27 \u2264 15 \u2192 false := by omega\nlemma twenty_seven_nle_16 : 27 \u2264 16 \u2192 false := by omega\nlemma twenty_seven_nle_17 : 27 \u2264 17 \u2192 false := by omega\nlemma twenty_seven_nle_18 : 27 \u2264 18 \u2192 false := by omega\nlemma twenty_seven_nle_19 : 27 \u2264 19 \u2192 false := by omega\nlemma twenty_seven_nle_20 : 27 \u2264 20 \u2192 false := by omega\nlemma twenty_seven_nle_21 : 27 \u2264 21 \u2192 false := by omega\nlemma twenty_seven_nle_22 : 27 \u2264 22 \u2192 false := by omega\nlemma twenty_seven_nle_23 : 27 \u2264 23 \u2192 false := by omega\nlemma twenty_seven_nle_24 : 27 \u2264 24 \u2192 false := by omega\nlemma twenty_seven_nle_25 : 27 \u2264 25 \u2192 false := by omega\nlemma twenty_seven_nle_26 : 27 \u2264 26 \u2192 false := by omega\nlemma nine_nle_4 : 9 \u2264 4 \u2192 false := by omega\nlemma nine_nle_5 : 9 \u2264 5 \u2192 false := by omega\nlemma nine_nle_6 : 9 \u2264 6 \u2192 false := by omega\nlemma nine_nle_7 : 9 \u2264 7 \u2192 false := by omega\nlemma nine_nle_8 : 9 \u2264 8 \u2192 false := by omega\n\nlemma decide_complete (n : \u2115) :\n  times_3_plus_5 n \u2192 decide n = tt :=\nbegin\n  simp [decide]; intros h; induction h,\n  case start : { refl },\n  case times_3 : m hm ihm {\n    have hm5 : m % 5 < 5 := mod_lt m dec_trivial,\n    interval_cases (m % 5),\n    { rw h at ihm, contradiction },\n    { have hm1 : m % 5 = 1 % 5, by assumption,\n      have hm3 : m * 3 % 5 = 1 * 3 % 5 := modeq.mul_right _ hm1,\n      rw hm3,\n      refl },\n    { rw h at ihm,\n      simp [decide] at *,\n      have hm2 : m % 5 = 2 % 5, by assumption,\n      have hm3 : m * 3 % 5 = 2 * 3 % 5 := modeq.mul_right _ hm2,\n      rw hm3,\n      refl },\n    { have hm3 : m % 5 = 3 % 5, by assumption,\n      have hm4 : m * 3 % 5 = 4 := modeq.mul_right _ hm3,\n      rw hm4,\n      simp [decide],\n      generalize h : m * 3 = m',\n      iterate 9 { all_goals { try { cases m' } } },\n      { rw h at hm4; contradiction },\n      { exfalso; apply mul_3_not_1 m h },\n      { exfalso; apply mul_3_not_2 m h },\n      { have hm1 : m = 1 := mul_1_3_3 _ h, subst hm1, clear h, cases h },\n      { exfalso; apply mul_3_not_4 m h },\n      { exfalso; apply mul_3_not_5 m h },\n      { have hm2 : m = 2 := mul_2_3_6 _ h, subst hm2, clear h, cases h },\n      { exfalso; apply mul_3_not_7 m h },\n      { exfalso; apply mul_3_not_8 m h },\n      { apply nine_le } },\n    { rw h at ihm,\n      simp [decide] at ihm,\n      have hm4 : m % 5 = 4 % 5, by assumption,\n      have hm4 : m * 3 % 5 = 2 := modeq.mul_right _ hm4,\n      rw hm4,\n      simp [decide],\n      apply twenty_seven_le_mult_3_of_9_le_m _ ihm }\n  },\n  case plus_5 : m hm ihm {\n    have hm5 : m % 5 = m % 5, by refl,\n    have h50 : 5 % 5 = 0 % 5, by refl,\n    have hyp := modeq.add hm5 h50,\n    unfold modeq at hyp,\n    rw hyp,\n    simp,\n    clear hm5 h50 hyp,\n    have hm5 : m % 5 < 5 := mod_lt m dec_trivial,\n    interval_cases (m % 5); rw h at *; try { simp [decide] at * },\n    { assumption },\n    { linarith },\n    { linarith }\n  }\nend\n\nlemma times_3_plus_5_n_of_mod5_1 : \u2200 n,\n  n % 5 = 1 \u2192\n  times_3_plus_5 n\n| 0 := by intro h; cases h\n| 1 := by intro; constructor\n| 2 := by intro h; cases h\n| 3 := by intro h; cases h\n| 4 := by intro h; cases h\n| (n' + 5) :=\n    begin\n      intro h,\n      have hn'5 : n' % 5 = n' % 5, by refl,\n      have h50 : 5 % 5 = 0 % 5, by refl,\n      have hyp := modeq.add hn'5 h50,\n      unfold modeq at hyp,\n      rw hyp at h,\n      simp at h,\n      clear hn'5 h50 hyp,\n      constructor,\n      apply times_3_plus_5_n_of_mod5_1 _ h\n    end\n\nlemma nat_ind5 : \u2200 P : \u2115 \u2192 Prop,\n  P 0 \u2192\n  P 1 \u2192\n  P 2 \u2192\n  P 3 \u2192\n  P 4 \u2192\n  (\u2200 n, P n \u2192 P (n + 5)) \u2192\n  \u2200 n, P n :=\nbegin\n  introv hP0 hP1 hP2 hP3 hP4 ihP,\n  have h : \u2200 n, P n \u2227 P (n + 1) \u2227 P (n + 2) \u2227 P (n + 3) \u2227 P (n + 4),\n  { clear n,\n    intros n,\n    induction n,\n    case zero : { repeat { split }; assumption },\n    case succ : n' ihn' {\n      rcases ihn' with \u27e8ihn'1, ihn'2, ihn'3, ihn'4, ihn'5\u27e9,\n      repeat { split }; try { apply ihP }; assumption\n    } },\n  have h' := h n,\n  rcases h' with \u27e8hPn, hrest\u27e9,\n  assumption\nend\n\nlemma times_3_plus_5_n_of_mod5_2 : \u2200 n,\n  n % 5 = 2 \u2192\n  27 \u2264 n \u2192\n  times_3_plus_5 n := nat_ind5 (\u03bb n, n % 5 = 2 \u2192 27 \u2264 n \u2192 times_3_plus_5 n)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intros h1 h2; exfalso; apply twenty_seven_nle_2 h2)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    begin\n      intros n ihn hmod hle,\n      iterate 27 { all_goals { try { cases n } } },\n      { exfalso; apply twenty_seven_nle_5 hle },\n      { exfalso; apply twenty_seven_nle_6 hle },\n      { exfalso; apply twenty_seven_nle_7 hle },\n      { exfalso; apply twenty_seven_nle_8 hle },\n      { exfalso; apply twenty_seven_nle_9 hle },\n      { exfalso; apply twenty_seven_nle_10 hle },\n      { exfalso; apply twenty_seven_nle_11 hle },\n      { exfalso; apply twenty_seven_nle_12 hle },\n      { exfalso; apply twenty_seven_nle_13 hle },\n      { exfalso; apply twenty_seven_nle_14 hle },\n      { exfalso; apply twenty_seven_nle_15 hle },\n      { exfalso; apply twenty_seven_nle_16 hle },\n      { exfalso; apply twenty_seven_nle_17 hle },\n      { exfalso; apply twenty_seven_nle_18 hle },\n      { exfalso; apply twenty_seven_nle_19 hle },\n      { exfalso; apply twenty_seven_nle_20 hle },\n      { exfalso; apply twenty_seven_nle_21 hle },\n      { exfalso; apply twenty_seven_nle_22 hle },\n      { exfalso; apply twenty_seven_nle_23 hle },\n      { exfalso; apply twenty_seven_nle_24 hle },\n      { exfalso; apply twenty_seven_nle_25 hle },\n      { exfalso; apply twenty_seven_nle_26 hle },\n      { show times_3_plus_5 (1 * 3 * 3 * 3); repeat { constructor } },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { constructor,\n        rw nat.add_mod_right at hmod, \n        apply ihn hmod,\n        repeat { rw succ_le_succ_iff },\n        apply nat.zero_le }\n    end\n\nlemma times_3_plus_5_n_of_mod5_3 : \u2200 n,\n  n % 5 = 3 \u2192\n  times_3_plus_5 n\n| 0 := by intro h; cases h\n| 1 := by intro h; cases h\n| 2 := by intro h; cases h\n| 3 := by intros; show times_3_plus_5 (1 * 3); repeat { constructor }\n| 4 := by intro h; cases h\n| (n' + 5) :=\n    begin\n      intro h,\n      have hn'5 : n' % 5 = n' % 5, by refl,\n      have h50 : 5 % 5 = 0 % 5, by refl,\n      have hyp := modeq.add hn'5 h50,\n      unfold modeq at hyp,\n      rw hyp at h,\n      simp at h,\n      clear hn'5 h50 hyp,\n      constructor,\n      apply times_3_plus_5_n_of_mod5_3 _ h\n    end\n\nlemma times_3_plus_5_n_of_mod5_4 : \u2200 n,\n  n % 5 = 4 \u2192\n  9 \u2264 n \u2192\n  times_3_plus_5 n := nat_ind5 (\u03bb n, n % 5 = 4 \u2192 9 \u2264 n \u2192 times_3_plus_5 n)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intros h1 h2; exfalso; apply nine_nle_4 h2)\n    begin\n      intros n ihn hmod hle,\n      iterate 9 { all_goals { try { cases n } } },\n      { exfalso; apply nine_nle_5 hle },\n      { exfalso; apply nine_nle_6 hle },\n      { exfalso; apply nine_nle_7 hle },\n      { exfalso; apply nine_nle_8 hle },\n      { show times_3_plus_5 (1 * 3 * 3); repeat { constructor } },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { constructor, rw nat.add_mod_right at hmod, apply ihn hmod (nine_le _) }\n    end\n\nlemma decide_sound (n : \u2115) :\n  decide n = tt \u2192 times_3_plus_5 n :=\nbegin\n  simp [decide],\n  intro hdec,\n  have hm5 : n % 5 < 5 := mod_lt n dec_trivial,\n  interval_cases (n % 5); rw h at *; try { simp [decide] at * },\n  { contradiction },\n  { apply times_3_plus_5_n_of_mod5_1 _ h },\n  { apply times_3_plus_5_n_of_mod5_2 _ h hdec },\n  { apply times_3_plus_5_n_of_mod5_3 _ h },\n  { apply times_3_plus_5_n_of_mod5_4 _ h hdec }\nend\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  split,\n  { apply decide_complete },\n  { apply decide_sound }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209101,"user_id":17,"body":"import Preloaded tactic data.nat.modeq\n\nopen times_3_plus_5 nat nat.modeq\n\n-- Trivial lemmas just to avoid deterministic timeout\nlemma mul_3_not_1 : \u2200 m, m * 3 \u2260 1 := by omega\nlemma mul_3_not_2 : \u2200 m, m * 3 \u2260 2 := by omega\nlemma mul_1_3_3 : \u2200 m, m * 3 = 3 \u2192 m = 1 := by omega\nlemma mul_3_not_4 : \u2200 m, m * 3 \u2260 4 := by omega\nlemma mul_3_not_5 : \u2200 m, m * 3 \u2260 5 := by omega\nlemma mul_2_3_6 : \u2200 m, m * 3 = 6 \u2192 m = 2 := by omega\nlemma mul_3_not_7 : \u2200 m, m * 3 \u2260 7 := by omega\nlemma mul_3_not_8 : \u2200 m, m * 3 \u2260 8 := by omega\nlemma nine_le : \u2200 m, 9 \u2264 succ (succ (succ (succ (succ (succ (succ (succ (succ m)))))))) := by omega\nlemma twenty_seven_le_mult_3_of_9_le_m : \u2200 m, 9 \u2264 m \u2192 27 \u2264 m * 3 := by omega\nlemma twenty_seven_le_plus_5_of_27_le_m : \u2200 m, 27 \u2264 m \u2192 27 \u2264 m + 5 := by omega\nlemma nine_le_plus_5_of_9_le_m : \u2200 m, 9 \u2264 m \u2192 9 \u2264 m + 5 := by omega\nlemma twenty_seven_nle_2 : 27 \u2264 2 \u2192 false := by omega\nlemma twenty_seven_nle_5 : 27 \u2264 5 \u2192 false := by omega\nlemma twenty_seven_nle_6 : 27 \u2264 6 \u2192 false := by omega\nlemma twenty_seven_nle_7 : 27 \u2264 7 \u2192 false := by omega\nlemma twenty_seven_nle_8 : 27 \u2264 8 \u2192 false := by omega\nlemma twenty_seven_nle_9 : 27 \u2264 9 \u2192 false := by omega\nlemma twenty_seven_nle_10 : 27 \u2264 10 \u2192 false := by omega\nlemma twenty_seven_nle_11 : 27 \u2264 11 \u2192 false := by omega\nlemma twenty_seven_nle_12 : 27 \u2264 12 \u2192 false := by omega\nlemma twenty_seven_nle_13 : 27 \u2264 13 \u2192 false := by omega\nlemma twenty_seven_nle_14 : 27 \u2264 14 \u2192 false := by omega\nlemma twenty_seven_nle_15 : 27 \u2264 15 \u2192 false := by omega\nlemma twenty_seven_nle_16 : 27 \u2264 16 \u2192 false := by omega\nlemma twenty_seven_nle_17 : 27 \u2264 17 \u2192 false := by omega\nlemma twenty_seven_nle_18 : 27 \u2264 18 \u2192 false := by omega\nlemma twenty_seven_nle_19 : 27 \u2264 19 \u2192 false := by omega\nlemma twenty_seven_nle_20 : 27 \u2264 20 \u2192 false := by omega\nlemma twenty_seven_nle_21 : 27 \u2264 21 \u2192 false := by omega\nlemma twenty_seven_nle_22 : 27 \u2264 22 \u2192 false := by omega\nlemma twenty_seven_nle_23 : 27 \u2264 23 \u2192 false := by omega\nlemma twenty_seven_nle_24 : 27 \u2264 24 \u2192 false := by omega\nlemma twenty_seven_nle_25 : 27 \u2264 25 \u2192 false := by omega\nlemma twenty_seven_nle_26 : 27 \u2264 26 \u2192 false := by omega\nlemma nine_nle_4 : 9 \u2264 4 \u2192 false := by omega\nlemma nine_nle_5 : 9 \u2264 5 \u2192 false := by omega\nlemma nine_nle_6 : 9 \u2264 6 \u2192 false := by omega\nlemma nine_nle_7 : 9 \u2264 7 \u2192 false := by omega\nlemma nine_nle_8 : 9 \u2264 8 \u2192 false := by omega\n\nlemma decide_complete (n : \u2115) :\n  times_3_plus_5 n \u2192 decide n = tt :=\nbegin\n  simp [decide]; intros h; induction h,\n  case start : { refl },\n  case times_3 : m hm ihm {\n    have hm5 : m % 5 < 5 := mod_lt m dec_trivial,\n    interval_cases (m % 5),\n    { rw h at ihm, contradiction },\n    { have hm1 : m % 5 = 1 % 5, by assumption,\n      have hm3 : m * 3 % 5 = 1 * 3 % 5 := modeq.mul_right _ hm1,\n      rw hm3,\n      refl },\n    { rw h at ihm,\n      simp [decide] at *,\n      have hm2 : m % 5 = 2 % 5, by assumption,\n      have hm3 : m * 3 % 5 = 2 * 3 % 5 := modeq.mul_right _ hm2,\n      rw hm3,\n      refl },\n    { have hm3 : m % 5 = 3 % 5, by assumption,\n      have hm4 : m * 3 % 5 = 4 := modeq.mul_right _ hm3,\n      rw hm4,\n      simp [decide],\n      generalize h : m * 3 = m',\n      iterate 9 { all_goals { try { cases m' } } },\n      { rw h at hm4; contradiction },\n      { exfalso; apply mul_3_not_1 m h },\n      { exfalso; apply mul_3_not_2 m h },\n      { have hm1 : m = 1 := mul_1_3_3 _ h, subst hm1, clear h, cases h },\n      { exfalso; apply mul_3_not_4 m h },\n      { exfalso; apply mul_3_not_5 m h },\n      { have hm2 : m = 2 := mul_2_3_6 _ h, subst hm2, clear h, cases h },\n      { exfalso; apply mul_3_not_7 m h },\n      { exfalso; apply mul_3_not_8 m h },\n      { apply nine_le } },\n    { rw h at ihm,\n      simp [decide] at ihm,\n      have hm4 : m % 5 = 4 % 5, by assumption,\n      have hm4 : m * 3 % 5 = 2 := modeq.mul_right _ hm4,\n      rw hm4,\n      simp [decide],\n      apply twenty_seven_le_mult_3_of_9_le_m _ ihm }\n  },\n  case plus_5 : m hm ihm {\n    have hm5 : m % 5 = m % 5, by refl,\n    have h50 : 5 % 5 = 0 % 5, by refl,\n    have hyp := modeq.add hm5 h50,\n    unfold modeq at hyp,\n    rw hyp,\n    simp,\n    clear hm5 h50 hyp,\n    have hm5 : m % 5 < 5 := mod_lt m dec_trivial,\n    interval_cases (m % 5); rw h at *; try { simp [decide] at * },\n    { assumption },\n    { linarith },\n    { linarith }\n  }\nend\n\nlemma times_3_plus_5_n_of_mod5_1 : \u2200 n,\n  n % 5 = 1 \u2192\n  times_3_plus_5 n\n| 0 := by intro h; cases h\n| 1 := by intro; constructor\n| 2 := by intro h; cases h\n| 3 := by intro h; cases h\n| 4 := by intro h; cases h\n| (n' + 5) :=\n    begin\n      intro h,\n      have hn'5 : n' % 5 = n' % 5, by refl,\n      have h50 : 5 % 5 = 0 % 5, by refl,\n      have hyp := modeq.add hn'5 h50,\n      unfold modeq at hyp,\n      rw hyp at h,\n      simp at h,\n      clear hn'5 h50 hyp,\n      constructor,\n      apply times_3_plus_5_n_of_mod5_1 _ h\n    end\n\nlemma nat_ind5 : \u2200 P : \u2115 \u2192 Prop,\n  P 0 \u2192\n  P 1 \u2192\n  P 2 \u2192\n  P 3 \u2192\n  P 4 \u2192\n  (\u2200 n, P n \u2192 P (n + 5)) \u2192\n  \u2200 n, P n :=\nbegin\n  introv hP0 hP1 hP2 hP3 hP4 ihP,\n  have h : \u2200 n, P n \u2227 P (n + 1) \u2227 P (n + 2) \u2227 P (n + 3) \u2227 P (n + 4),\n  { clear n,\n    intros n,\n    induction n,\n    case zero : { repeat { split }; assumption },\n    case succ : n' ihn' {\n      rcases ihn' with \u27e8ihn'1, ihn'2, ihn'3, ihn'4, ihn'5\u27e9,\n      repeat { split }; try { apply ihP }; assumption\n    } },\n  have h' := h n,\n  rcases h' with \u27e8hPn, hrest\u27e9,\n  assumption\nend\n\nlemma times_3_plus_5_n_of_mod5_2 : \u2200 n,\n  n % 5 = 2 \u2192\n  27 \u2264 n \u2192\n  times_3_plus_5 n := nat_ind5 (\u03bb n, n % 5 = 2 \u2192 27 \u2264 n \u2192 times_3_plus_5 n)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intros h1 h2; exfalso; apply twenty_seven_nle_2 h2)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    begin\n      intros n ihn hmod hle,\n      iterate 27 { all_goals { try { cases n } } },\n      { exfalso; apply twenty_seven_nle_5 hle },\n      { exfalso; apply twenty_seven_nle_6 hle },\n      { exfalso; apply twenty_seven_nle_7 hle },\n      { exfalso; apply twenty_seven_nle_8 hle },\n      { exfalso; apply twenty_seven_nle_9 hle },\n      { exfalso; apply twenty_seven_nle_10 hle },\n      { exfalso; apply twenty_seven_nle_11 hle },\n      { exfalso; apply twenty_seven_nle_12 hle },\n      { exfalso; apply twenty_seven_nle_13 hle },\n      { exfalso; apply twenty_seven_nle_14 hle },\n      { exfalso; apply twenty_seven_nle_15 hle },\n      { exfalso; apply twenty_seven_nle_16 hle },\n      { exfalso; apply twenty_seven_nle_17 hle },\n      { exfalso; apply twenty_seven_nle_18 hle },\n      { exfalso; apply twenty_seven_nle_19 hle },\n      { exfalso; apply twenty_seven_nle_20 hle },\n      { exfalso; apply twenty_seven_nle_21 hle },\n      { exfalso; apply twenty_seven_nle_22 hle },\n      { exfalso; apply twenty_seven_nle_23 hle },\n      { exfalso; apply twenty_seven_nle_24 hle },\n      { exfalso; apply twenty_seven_nle_25 hle },\n      { exfalso; apply twenty_seven_nle_26 hle },\n      { show times_3_plus_5 (1 * 3 * 3 * 3); repeat { constructor } },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { constructor,\n        rw nat.add_mod_right at hmod, \n        apply ihn hmod,\n        repeat { rw succ_le_succ_iff },\n        apply nat.zero_le }\n    end\n\nlemma times_3_plus_5_n_of_mod5_3 : \u2200 n,\n  n % 5 = 3 \u2192\n  times_3_plus_5 n\n| 0 := by intro h; cases h\n| 1 := by intro h; cases h\n| 2 := by intro h; cases h\n| 3 := by intros; show times_3_plus_5 (1 * 3); repeat { constructor }\n| 4 := by intro h; cases h\n| (n' + 5) :=\n    begin\n      intro h,\n      have hn'5 : n' % 5 = n' % 5, by refl,\n      have h50 : 5 % 5 = 0 % 5, by refl,\n      have hyp := modeq.add hn'5 h50,\n      unfold modeq at hyp,\n      rw hyp at h,\n      simp at h,\n      clear hn'5 h50 hyp,\n      constructor,\n      apply times_3_plus_5_n_of_mod5_3 _ h\n    end\n\nlemma times_3_plus_5_n_of_mod5_4 : \u2200 n,\n  n % 5 = 4 \u2192\n  9 \u2264 n \u2192\n  times_3_plus_5 n := nat_ind5 (\u03bb n, n % 5 = 4 \u2192 9 \u2264 n \u2192 times_3_plus_5 n)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intro h; cases h)\n    (by intros h1 h2; exfalso; apply nine_nle_4 h2)\n    begin\n      intros n ihn hmod hle,\n      iterate 9 { all_goals { try { cases n } } },\n      { exfalso; apply nine_nle_5 hle },\n      { exfalso; apply nine_nle_6 hle },\n      { exfalso; apply nine_nle_7 hle },\n      { exfalso; apply nine_nle_8 hle },\n      { show times_3_plus_5 (1 * 3 * 3); repeat { constructor } },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { cases hmod },\n      { constructor, rw nat.add_mod_right at hmod, apply ihn hmod (nine_le _) }\n    end\n\nlemma decide_sound (n : \u2115) :\n  decide n = tt \u2192 times_3_plus_5 n :=\nbegin\n  simp [decide],\n  intro hdec,\n  have hm5 : n % 5 < 5 := mod_lt n dec_trivial,\n  interval_cases (n % 5); rw h at *; try { simp [decide] at * },\n  { contradiction },\n  { apply times_3_plus_5_n_of_mod5_1 _ h },\n  { apply times_3_plus_5_n_of_mod5_2 _ h hdec },\n  { apply times_3_plus_5_n_of_mod5_3 _ h },\n  { apply times_3_plus_5_n_of_mod5_4 _ h hdec }\nend\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt :=\nbegin\n  split,\n  { apply decide_complete },\n  { apply decide_sound }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209102,"user_id":168,"body":"import Preloaded tactic\n\nlemma decide_spec (n : \u2115) :\n  decide n = tt \u2194 n % 5 = 1 \u2228 n % 5 = 3 \u2228 n % 5 = 2 \u2227 27 \u2264 n \u2228 n % 5 = 4 \u2227 9 \u2264 n :=\nbegin\n  have : n % 5 = 0 \u2228 n % 5 = 1 \u2228 n % 5 = 2 \u2228 n % 5 = 3 \u2228 n % 5 = 4,\n  { have := nat.mod_lt n (show 0 < 5, by norm_num),\n    interval_cases (n % 5); tauto },\n  repeat { cases this }; simp [decide, this] at *; try { dec_trivial };\n  { split, tauto, norm_num }\nend\n\nlemma imp_decide {n : \u2115} (h : times_3_plus_5 n) : decide n = tt :=\nbegin\n  induction h with k hk ih k hk ih, { refl },\n  { rw decide_spec at *, repeat { cases ih },\n    { right, left, rw [nat.mul_mod, ih], refl },\n    { right, right, right, rw [nat.mul_mod, ih], \n      exact \u27e8rfl, by linarith [nat.mod_le k 5]\u27e9 },\n    { left, rw [nat.mul_mod, ih_left], refl },\n    { right, right, left, rw [nat.mul_mod, ih_left],\n      exact \u27e8rfl, by linarith\u27e9 } },\n  rw decide_spec at *, rw nat.add_mod_right, repeat { cases ih }; try { tauto },\n  { right, right, left, exact \u27e8ih_left, by linarith\u27e9 },\n  { right, right, right, exact \u27e8ih_left, by linarith\u27e9 }\nend\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt :=\n\u27e8imp_decide, begin\n  induction n using nat.strong_induction_on with n ih,\n  obtain \u27e8k, hk\u27e9 : \u2203 k, n = (n % 5) + 5 * k,\n  { existsi n \/ 5, rw nat.mod_add_div },\n  rw decide_spec, intro h,\n  cases k,\n  { repeat { cases h }; rw hk; try { rw [h] <|> rw [hk, h_left] at h_right },\n    { constructor }, \n    { change 3 with 1 * 3, repeat { constructor } },\n    { norm_num at h_right },\n    { norm_num at h_right } },\n  have h5 : n - 5 < n, omega,\n  have hn : n = (n - 5) + 5, omega,\n  have hn1 : n - 5 = n % 5 + 5 * k, omega,\n  repeat { cases h },\n  { rw hn, constructor, apply ih _ h5, rw decide_spec, left,\n    rw [hn1, h, nat.add_mul_mod_self_left], refl },\n  { rw hn, constructor, apply ih _ h5, rw decide_spec, right, left,\n    rw [hn1, h, nat.add_mul_mod_self_left], refl },\n  { rw [hk, h_left] at h_right,\n    repeat { cases k, { norm_num at h_right } },\n    cases k,\n    { rw [hk, h_left, show 2 + 5 * 5 = 1 * 3 * 3 * 3, from rfl], \n      repeat { constructor } },\n    rw hn, constructor, apply ih _ h5, rw decide_spec, right, right, left,\n    rw [hn1, h_left, nat.add_mul_mod_self_left], exact \u27e8rfl, by omega\u27e9 },\n  { rw [hk, h_left] at h_right,\n    cases k,\n    { rw [hk, h_left, show 4 + 5 * 1 = 1 * 3 * 3, from rfl],\n      repeat { constructor } },\n    rw hn, constructor, apply ih _ h5, rw decide_spec, right, right, right,\n    rw [hn1, h_left, nat.add_mul_mod_self_left], exact \u27e8rfl, by omega\u27e9 }\nend\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209103,"user_id":null,"body":"import Preloaded tactic\nopen nat times_3_plus_5\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt := \nbegin\n  have mb : \u2200n, n%5<5 := by intro n; apply mod_lt; norm_num,\n  split, intro h, apply times_3_plus_5.rec_on h, solve_by_elim,\n  intros m _ hm, unfold decide at hm \u22a2, rw mul_mod,\n  replace mb := mb m, interval_cases m%5,\n  intros m _ hm, unfold decide, rw add_mod_right,\n  delta decide at hm, split_ifs at hm, cases hm,\n  rw h_2, unfold decide, simp at hm \u22a2, linarith,\n  rw h_3, unfold decide, simp at hm \u22a2, linarith,\n  rw decide, exact h_3, exact h_2, exact h_1,\n  intro h, delta decide at h, split_ifs at h, cases h,\n  { simp at h, have hd : 5\u2223n-27, rw [dvd_iff_mod_eq_zero,\n    sub_mod_eq_zero_of_mod_eq], exact h_2,\n  cases hd with m hm, rw nat.sub_eq_iff_eq_add h at hm,\n  clear_except hm, subst hm, induction m with m hm,\n  rw (by norm_num: 5*0+27=((1*3)*3)*3), repeat {apply times_3}, exact start,\n  rw [mul_succ, add_right_comm], exact plus_5 _ hm },\n  { simp at h, have hd : 5\u2223n-9, rw [dvd_iff_mod_eq_zero,\n    sub_mod_eq_zero_of_mod_eq], exact h_3,\n  cases hd with m hm, rw nat.sub_eq_iff_eq_add h at hm,\n  clear_except hm, subst hm, induction m with m hm,\n  rw (by norm_num: 5*0+9=(1*3)*3), exact times_3 3 (times_3 1 start),\n  rw [mul_succ, add_right_comm], exact plus_5 _ hm },\n  replace mb := mb n, rw \u2190 mod_add_div n 5, interval_cases n%5,\n  iterate 3 {rw h_1 at hm \u22a2, solve_by_elim},\n  rw h_1 at hm \u22a2, norm_num, unfold decide, simp,\n  rw (by norm_num : 9=3*3), apply mul_le_mul_of_nonneg_right,\n  rw \u2190 h_1, apply mod_le, norm_num,\n  rw h_1 at hm \u22a2, norm_num, unfold decide at hm \u22a2, simp at hm \u22a2,\n  rw (by norm_num : 27=9*3), apply mul_le_mul_of_nonneg_right hm, norm_num,\n  repeat {induction n\/5 with m hm, rw h_4, exact start <|> {exact times_3 1 start},\n  rw [mul_succ, \u2190add_assoc], exact plus_5 _ hm},\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209104,"user_id":null,"body":"import Preloaded tactic data.nat.basic\n\nopen times_3_plus_5\n\nlemma gt_3 {n : \u2115} (h : n % 5 = 3) : n \u2265 3 :=\nbegin\n    by_contradiction h',\n    push_neg at h',\n    interval_cases n;\n    norm_num at h,\nend\n\nlemma eq_9 {n : \u2115} (h1 : n < 9) (h2 : n % 5 = 4) : n + 5 = 9 :=\nbegin\n    interval_cases n;\n    norm_num at h2,\nend\n\nlemma eq_27 {n : \u2115} (h1 : n < 27) (h2 : 27 \u2264 n + 5) (h3 : n % 5 = 2) : n + 5 = 27 :=\nbegin\n    have : 22 \u2264 n := by linarith,\n    interval_cases n;\n    norm_num at h3,\nend\n\nlemma decide_of_times_3_plus_5 : \u2200 (n : \u2115), times_3_plus_5 n \u2192 decide n :=\nbegin\n    intros n h,\n    induction h with n hn ih n hn ih,\n    {   exact dec_trivial,  },\n    {   have n_mod_5_lt_5 : n % 5 < 5 := nat.mod_lt n (show 5 > 0, from dec_trivial),\n        have : n * 3 % 5 = (n % 5) * 3 % 5 := by rw nat.mul_mod; ring,\n        interval_cases n % 5;\n        simp only [*, decide, bool.coe_sort_ff, nat.zero_mod, zero_mul, one_mul];\n        simp only [*, decide, bool.of_to_bool_iff] at ih,\n        {   tauto,  },\n        {   exact dec_trivial,  },\n        {   exact dec_trivial,  },\n        {   have : n \u2265 3 := gt_3 h,\n            simp [*, show 3*3 % 5 = 4, from dec_trivial,\n                    show 9 \u2264 n * 3, from by linarith, decide._match_1],\n        },\n        {   simp [*, show 27 \u2264 n * 3, from by linarith, show 4*3 % 5 = 2, from dec_trivial,\n                    decide._match_1],\n        },\n    },\n    {   have n_mod_5_lt_5 : n % 5 < 5 := nat.mod_lt n (show 5 > 0, from dec_trivial),\n        have : (n + 5) % 5 = n % 5 := by rw nat.add_mod; norm_num,\n        interval_cases n % 5;\n        simp only [*, decide, bool.coe_sort_ff, bool.of_to_bool_iff];\n        simp only [*, decide, bool.of_to_bool_iff] at ih,\n        {   tauto,  },\n        {   exact dec_trivial,  },\n        {   linarith,   },\n        {   exact dec_trivial,  },\n        {   linarith,   },\n    },\nend\n\nlemma times_3_plus_5_of_decide : \u2200 (n : \u2115), decide n \u2192 times_3_plus_5 n\n| 0 := by simp [decide]\n| 1 := \u03bb _, start\n| 2 := by simp [decide, show 2 % 5 = 2, from dec_trivial, show 2 < 27, from dec_trivial]\n| 3 := \u03bb _, times_3 1 start\n| 4 := by simp [decide, show 4 % 5 = 4, from dec_trivial, show 4 < 9, from dec_trivial]\n| (n + 5) :=\nbegin\n    intro h,\n    have : n % 5 < 5 := nat.mod_lt n (show 5 > 0, from dec_trivial),\n    have : (n + 5) % 5 = n % 5 := by rw nat.add_mod; norm_num,\n    interval_cases n % 5;\n    simp only [*, decide, bool.coe_sort_ff, bool.of_to_bool_iff] at h,\n    {   tauto,  },\n    {   have hn : (decide n : Prop) := by simp only [*, decide]; exact dec_trivial,\n        exact plus_5 n (times_3_plus_5_of_decide n hn),\n    },\n    {   by_cases n_lt_27 : n < 27,\n        {   rw (eq_27 n_lt_27 h h_1),\n            exact times_3 9 (times_3 3 (times_3 1 start)),\n        },\n        {   have hn : (decide n : Prop) := by simp [*, decide, not_lt.mp n_lt_27],\n            exact plus_5 n (times_3_plus_5_of_decide n hn),\n        },\n    },\n    {   have : (decide n : Prop) := by simp only [*, decide]; exact dec_trivial,\n        exact plus_5 n (times_3_plus_5_of_decide n this),\n    },\n    {   by_cases n_lt_9 : n < 9,\n        {   rw (eq_9 n_lt_9 h_1),\n            exact times_3 3 (times_3 1 start),\n        },\n        {   have : (decide n : Prop) := by simp [*, decide, not_lt.mp n_lt_9],\n            exact plus_5 n (times_3_plus_5_of_decide n this),\n        },\n    },\nend\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt := \u27e8decide_of_times_3_plus_5 n, times_3_plus_5_of_decide n\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209105,"user_id":657,"body":"import Preloaded\nimport data.nat.basic\nimport tactic\n\n\nlemma nat.mul_mod (a b n : \u2115) : (a * b) % n = ((a % n) * (b % n)) % n :=\nbegin\n  conv_lhs {\n    rw [\u2190nat.mod_add_div a n, \u2190nat.mod_add_div b n, right_distrib, left_distrib, left_distrib,\n        mul_assoc, mul_assoc, \u2190left_distrib n _ _, nat.add_mul_mod_self_left,\n        mul_comm _ (n * (b \/ n)), mul_assoc, nat.add_mul_mod_self_left] }\nend\n\n\nlemma arithmetic1_aux (n : \u2115) : (n  + 5) % 5 = n % 5 := by ring\nlemma arithmetic1 (n k : \u2115) : (n  + 5*k) % 5 = n % 5 := begin\ninduction k with d hd, simp only [add_zero, mul_zero], rw nat.mul_succ, rw \u2190 add_assoc,\nrwa arithmetic1_aux (n + 5*d),\nend\n\nlemma arithmetic2_aux (n : \u2115) : \u2203 k, n = n % 5 + 5 * k := begin\napply nat.strong_induction_on n, clear n,\nintros n hn,\nby_cases 5 \u2264 n,\nswap,\n    use 0, simp only [add_zero, mul_zero],\n    have key : n < 5:= by omega,\n    symmetry,\n    apply nat.mod_eq_of_lt, assumption,\nhave key : \u2203 k : \u2115, n = 5 + k := le_iff_exists_add.mp h,\ncases key with m hm,\nhave key2 := hn m (by omega),\ncases key2 with k hk, use k+1,\nhave q := arithmetic1_aux m,\nrw add_comm at q, rw\u2190 hm at q,\nrwa [q, hm, mul_add, mul_one, \u2190 add_assoc, \u2190 hk, add_comm],\nend\nlemma arithmetic2 (n m: \u2115) (m_le_n : m \u2264 n) : n % 5 = m % 5 \u2192 \u2203 k, n = m + 5 * k := begin\nintro h,\nhave hm := arithmetic2_aux m,\ncases hm with km hkm,\nhave hn := arithmetic2_aux n,\ncases hn with kn hkn,\nrw [hkm, hkn, h],\nhave km_le_kn : km \u2264 kn, rw h at hkn, linarith,\nrw le_iff_exists_add at km_le_kn,\ncases km_le_kn with c hc,\nuse c, rw hc, ring,\nend\n\nlemma induction1 (n m : \u2115) (hm: times_3_plus_5 m) (m_le_n : m \u2264 n) (m_modeq_n : n %5 = m % 5) : times_3_plus_5 n := begin\nhave key := arithmetic2 n m m_le_n m_modeq_n,\ncases key with k hk, rw hk, rw hk at m_modeq_n, rw hk at m_le_n, clear hk n,  induction k with d hd,\nsimpa only [],\nrw nat.mul_succ,\napply times_3_plus_5.plus_5,\nsimp only [add_zero, nat.add_def], apply hd, apply arithmetic1, linarith,\nend\n\nlemma q0_aux {n : \u2115} (hn : times_3_plus_5 n) : 1 \u2264 n := begin\ninduction hn with d hd hd'; linarith,\nend\nlemma q0 : \u00actimes_3_plus_5 0 := begin\nintro h, have key := q0_aux h, linarith,\nend\n\nlemma q3 : times_3_plus_5 3 := begin\nrw \u2190 one_mul 3,\napply times_3_plus_5.times_3,\napply times_3_plus_5.start,\nend\nlemma q9 : times_3_plus_5 9 := begin\nhave key : 9 = 3 * 3 := by ring, rw key, clear key,\napply times_3_plus_5.times_3,\nexact q3,\nend\nlemma q27 : times_3_plus_5 27 := begin\nhave key : 27 = 9 * 3 := by ring, rw key, clear key,\napply times_3_plus_5.times_3,\nexact q9,\nend\n\nlemma arithmetic3 (n : \u2115) : n % 5 < 5 := begin\nrefine nat.mod_lt n _, norm_num,\nend\n\n\nlemma decide_imp_times_3_plus_5 (n : \u2115) : decide n = tt \u2192 times_3_plus_5 n := begin\n\nunfold decide, \n\nhave case_bash1 : 0 \u2264 n % 5, simp only [zero_le],\nhave case_bash2 := arithmetic3 n, \ninterval_cases n%5,\n\n-- n%5 = 0\nrename lh h0,\n    rw h0, unfold decide, tauto,\n\n-- n%5 = 1\nrename lh h1,\n    rw h1, intro h, \n    apply induction1 n 1,\n    apply times_3_plus_5.start,\n    suffices key : n \u2260 0, omega,intro hn, rw hn at h1,revert h1, norm_num, assumption,\n\n-- n%5 = 2\nrename lh h2, \n    rw h2, unfold decide, intro hn, simp only [to_bool_iff] at hn,\n    apply induction1 n 27 q27 hn, rw h2, norm_num,\n\n-- n%5 = 3\nrename lh h3, \n    rw h3, intro k, clear k, apply induction1 n 3 q3, rw \u2190 h3, exact nat.mod_le n 5, exact h3,\n\n-- n%5 = 4\nrename lh h4, \n    rw h4, unfold decide, intro hn, simp only [to_bool_iff] at hn,\n    apply induction1 n 9 q9 hn, rw h4, norm_num,\nend\n\nlemma induction2_aux (n : \u2115) (hn : decide n = tt) : (decide (n + 5) = tt) := begin\nunfold decide, rw arithmetic1_aux, unfold decide at hn,\nhave key : n \u2264 n+5 := by simp only [zero_le, le_add_iff_nonneg_right],\n\nhave case_bash1 : 0 \u2264 n % 5, simp only [zero_le],\nhave case_bash2 := arithmetic3 n, \ninterval_cases n%5; rename lh h,\n--n%5 = 0\nrename h h0, rw h0 at hn, unfold decide at hn, contradiction,\n--n%5 = 1\nrw h, refl,\n--n%5 = 2\nrename h h2, \nrw h2 at hn, unfold decide at hn,\nrw h2, unfold decide,\n simp only [to_bool_iff] at hn,\n  simp only [to_bool_iff], linarith,\n--n%5 = 3\nrw h, refl,\n--n%5 = 4\nrename h h4, rw h4, rw h4 at hn, unfold decide, unfold decide at hn,\n simp only [to_bool_iff] at hn,\n  simp only [to_bool_iff], linarith,\nend\n\nlemma times_3_plus_5_imp_decide (n : \u2115) : times_3_plus_5 n \u2192 decide n = tt := begin\napply nat.strong_induction_on n, clear n, \nintros n hm hn,\ncases hn with nn hnn nn hnn, \n-- start\nrefl,\n\nswap,-- plus_5\nunfold decide, \nhave key := hm nn (by {rw \u2190 nat.add_one, simp,}) hnn,\napply induction2_aux, simpa only [],\n\n-- times_3\nhave key := hm nn _ hnn, swap,\nsimp, suffices calc1: nn \u2260 0, omega, intro h, rw h at hnn, exact q0 hnn,\nhave calc1 : nat.add (nat.mul nn (nat.add 2 0)) nn = 3 * nn := by {simp only [nat.mul_def, add_zero, nat.add_def], ring}, rw calc1, clear calc1,\n\nhave case_bash1 : 0 \u2264 nn % 5, simp only [zero_le],\nhave case_bash2 := arithmetic3 nn, \ninterval_cases nn%5; rename lh h,\n\n-- nn %5 = 0\nexfalso,\nrevert key, unfold decide, rw h,\nunfold decide, simp only [forall_prop_of_false, not_false_iff],\n\n-- nn %5 = 1\nhave calc1 : (3 * nn) % 5 = 3:= by { rw nat.mul_mod 3, rw h, norm_num,},\nunfold decide, rw calc1, \nrefl,\n\n-- nn %5 = 2\nhave calc1 : (3 * nn) % 5 = 1:= by {rw nat.mul_mod 3, rw h, norm_num},\nunfold decide, rw calc1, \nrefl,\n\n-- nn %5 = 3\nhave calc1 : (3 * nn) % 5 = 4:= by {rw nat.mul_mod 3, rw h, norm_num},\nunfold decide, rw calc1, \nunfold decide, simp only [to_bool_iff],\nsuffices key : 3 \u2264 nn, omega,\nrw \u2190 h, exact nat.mod_le nn 5,\n\n-- nn %5 = 4\nhave calc1 : (3 * nn) % 5 = 2:= by {rw nat.mul_mod 3, rw h, norm_num},\nunfold decide, rw calc1, \nunfold decide, simp only [to_bool_iff],\nsuffices key : 9 \u2264 nn, omega,\nunfold decide at key, rw h at key,\nunfold decide at key, revert key, simp only [to_bool_iff], tauto,\nend\n\nexample (a b : \u2115): (a * b) % 5 = (a%5) * (b%5) % 5 := begin\nexact nat.mul_mod a b 5,\nend\n\n\ntheorem decide_works (n : \u2115) :\n  times_3_plus_5 n \u2194 decide n = tt := begin\nsplit, \n    apply times_3_plus_5_imp_decide,\napply decide_imp_times_3_plus_5,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e8897a818f8ed002eedd1bd":[{"id":209106,"user_id":null,"body":"import Preloaded tactic.omega\n\ntheorem thm_3p6p1 (point line : Type) (inc : point \u2192 line \u2192 Prop)\n  [axms : incidence point line inc] (l m : line) (neqlm : l \u2260 m)\n  (exs : \u2203 P, inc P l \u2227 inc P m) :\n  \u2203! P, inc P l \u2227 inc P m :=\n  begin\n  rcases exs with \u27e8P, \u27e8Pl, Pm\u27e9\u27e9,\n  use P,\n  split,\n  tauto,\n  rintros Q \u27e8Ql, Qm\u27e9,\n  apply of_not_not,\n  intro neq,\n  rcases @incidence.I\u2081 point line inc axms P Q (ne.symm neq) with \u27e8s, \u27e8\u27e8Ps, Qs\u27e9, eq\u27e9\u27e9,\n  have H2 := eq l \u27e8Pl, Ql\u27e9,\n  have H3 := eq m \u27e8Pm, Qm\u27e9,\n  exact neqlm (H2.trans H3.symm),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209107,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\nbegin\n  obtain \u27e8P, hP\u27e9 := hnpar,\n  use [P, hP],\n  intros y hy,\n  by_contra,\n  have hl : incident_with y l \u2227 incident_with P l, by cc,\n  have hm : incident_with y m \u2227 incident_with P m, by cc,\n  rcases incidence.I\u2081 y P h with \u27e8L, \u27e8hL, uniqL\u27e9\u27e9,\n  exact hlm (eq.trans (uniqL l hl) (uniqL m hm).symm),\n  assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209108,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\n\nbegin\n  cases hnpar with P hP,\n  use P,\n  split,\n  exact hP,\n  intros Q hQ,\n  by_contra,\n  have := incidence.I\u2081 Q P h,\n  {\n    rcases this with \u27e8 L, \u27e8 hL1, hL2\u27e9\u27e9,\n    simp at hL2,\n    have hl := hL2 l hQ.1 hP.1,\n    have hm := hL2 m hQ.2 hP.2,\n    rw [hl,hm] at hlm,\n    exact hlm rfl,\n  },\n  {\n    exact _inst_1,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209109,"user_id":null,"body":"import Preloaded\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := \n  begin\n    cases hnpar with p hp,\n    split,\n    {\n      split,\n      {\n        exact hp,\n      },\n      {\n        intro q,\n        intro hq,\n        by_contradiction hqnp,\n\n        have h\u2081 := _inst_1.I\u2081,\n        specialize h\u2081 q p,\n        have h\u2082 := h\u2081 hqnp, \n        cases h\u2082 with n hn,\n        have hlen : l = n := by {\n          have hnr := hn.right,\n          specialize hnr l,\n          apply hnr,\n          exact and.intro hq.left hp.left,\n        },\n        have hmen : m = n := by {\n          have hnr := hn.right,\n          specialize hnr m,\n          apply hnr,\n          exact and.intro hq.right hp.right,\n        },\n        rw <- hmen at hlen,\n        apply hlm,\n        exact hlen,\n\n      },\n    },\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209110,"user_id":null,"body":"import Preloaded\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := begin\n    intros,\n    apply exists.elim hnpar, intros p p_inc, existsi p,\n    simp, split, assumption,\n    intros y y_inc, by_contradiction,\n    apply exists.elim (incidence.I\u2081 y p h),\n    intros L, simp, intros h1,\n    have l_eq_L : l = L := (and.elim_right h1) l (and.intro (and.elim_left y_inc) (and.elim_left p_inc)),\n    have m_eq_L : m = L := (and.elim_right h1) m (and.intro (and.elim_right y_inc) (and.elim_right p_inc)),\n    rw \u2190 m_eq_L at l_eq_L, contradiction, simp, assumption,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209111,"user_id":191,"body":"import Preloaded tactic\n\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\nbegin\n  rcases hnpar with \u27e8P, hPl, hPm\u27e9,\n  use P,\n  split,\n  exact \u27e8hPl, hPm\u27e9,\n  intro Q,\n  dsimp,\n  rintro \u27e8hQl, hQm\u27e9,\n  classical,\n  by_contra Q_ne_P,\n  apply hlm,\n  rcases I\u2081 incident_with Q P Q_ne_P with \u27e8n, _, n_unique\u27e9,\n  rw n_unique m \u27e8hQm, hPm\u27e9,\n  rw n_unique l \u27e8hQl, hPl\u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209112,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\n  begin\n    have A\u2081:= _inst_1.I\u2081, \n    cases hnpar with P hP,\n    use [P, hP],\n    intros Q hQ,\n    by_contradiction h,\n    rcases A\u2081 P Q (ne.symm h) with \u27e8t, ht1, ht2\u27e9,\n    have e1 := ht2 l \u27e8hP.1, hQ.1\u27e9,\n    have e2 := ht2 m \u27e8hP.2, hQ.2\u27e9,\n    exact hlm (by simp[e1, e2])\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209113,"user_id":null,"body":"import Preloaded\nimport tactic \n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8P, hl, hm\u27e9 := hnpar,\n  use [P, hl, hm],\n  rintros P' \u27e8hl', hm'\u27e9,\n  classical,\n  by_contradiction hneq,\n  obtain \u27e8n, _, hn\u27e9 : \u2203! (l : line), incident_with P l \u2227 incident_with P' l \n    := incidence.I\u2081 P P' (by cc),\n  have := hn l \u27e8hl, hl'\u27e9,\n  have := hn m \u27e8hm, hm'\u27e9,\n  cc,\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209114,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := \nbegin \n  rcases hnpar with \u27e8P, hl, hm\u27e9,\n  use P,\n  split,\n  { exact \u27e8hl, hm\u27e9 },\n  { rintros P' \u27e8hl', hm'\u27e9,\n    by_contradiction hneq,\n    obtain \u27e8n, _, hn\u27e9 : \u2203! (l : line), incident_with P l \u2227 incident_with P' l \n      := incidence.I\u2081 P P' (\u03bb h, hneq (h.symm)),\n    rw [hn l \u27e8hl, hl'\u27e9, hn m \u27e8hm, hm'\u27e9] at hlm,\n    apply hlm, refl,\n    }\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209115,"user_id":null,"body":"import Preloaded tactic\n\nopen incidence\n\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\nbegin\n  rcases hnpar with \u27e8P, Pl, Pm\u27e9,\n  use [P, Pl, Pm],\n  rintro Q \u27e8Ql, Qm\u27e9,\n  by_cases Q = P,\n  { assumption, },\n  { rcases I\u2081 Q P h with \u27e8n, -, hn\u27e9,  -- `_inst_1.I\u2081` errors :-(\n    have : l = n, from hn l \u27e8Ql, Pl\u27e9,\n    have : m = n, from hn m \u27e8Qm, Pm\u27e9,\n    finish,\n    assumption, -- required due to the above mentioned bug\n  },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e889a3c0f55ed0032f1879f":[{"id":209116,"user_id":659,"body":"import Preloaded tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  (s : incidence point line incident_with) : \u2200 l,\n  \u2203 P, \u00acincident_with P l := \nbegin\n  -- let l be a line\n  intro l,\n  -- By assumption there are three points P Q and R which aren't collinear.\n  rcases s.I\u2083 with \u27e8P, Q, R, hPQ, hQR, hPR, h\u27e9,\n  -- So they can't all lie on l.\n  replace h := h l,\n  -- which means one of P or Q or R doesn't lie on l.\n  push_neg at h,\n  -- If P doesn't lie on l, use P.\n  cases h, use P,\n  -- If Q doesn't lie on l, use Q.\n  cases h, use Q,\n  -- Otherwise, use R\n  use R,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209117,"user_id":196,"body":"import Preloaded logic.basic\n\nlocal attribute [instance] classical.prop_decidable\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  (s : incidence point line incident_with) (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nlet \u27e8P, Q, R, hpq, hqr, hpr, h\u27e9 := s.I\u2083 in\nor.cases_on (not_and_distrib.1 $ h l) (exists.intro P) $ \u03bb h,\nor.cases_on (not_and_distrib.1 h) (exists.intro Q) (exists.intro R)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209118,"user_id":null,"body":"import Preloaded tactic\nopen_locale classical\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  by_contra h,\n  push_neg at h,\n  rcases _inst_1.I\u2083 with \u27e8a, b, c, _, _, _, h'\u27e9,\n  exact h' l \u27e8h a, h b, h c\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209119,"user_id":null,"body":"import Preloaded tactic.omega\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [axms : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  rcases @incidence.I\u2083 point line incident_with axms with \u27e8P,Q,R,pnq,qnr,pnr,noni\u27e9,\n  rcases @incidence.I\u2081 point line incident_with axms P Q pnq with \u27e8l2, pl2, ql2\u27e9,\n  simp at ql2,\n  by_cases (l = l2),\n  {\n    rw\u2190 h at pl2,\n    use R, \n    exact (\u03bb a, noni l \u27e8pl2.left, pl2.right, a\u27e9), \n  },\n  {\n    by_cases h2: (incident_with P l),\n    {\n      use Q,\n      intro h3,\n      specialize ql2 l h2 h3,\n      exact (h ql2),\n    },\n    exact \u27e8P, h2\u27e9,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209120,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nlet \u27e8_, _, _, _, _, _, hl\u27e9 := _inst_1.I\u2083 in by {by_contra, push_neg at h, exact hl l (by simp [h])}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209121,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\n\nbegin\n  have := _inst_1.I\u2083,\n  rcases this with \u27e8P, Q, R, \u27e8_,_,_,hpqr\u27e9\u27e9,\n  specialize hpqr l,\n  push_neg at hpqr,\n  by_cases hP: incident_with P l,\n  {\n    by_cases hQ: incident_with Q l,\n    {\n      exact \u27e8 R, hpqr hP hQ \u27e9,\n    },\n    exact \u27e8 Q, hQ\u27e9,\n  },\n  exact \u27e8 P,hP\u27e9,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209122,"user_id":null,"body":"import Preloaded tactic\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\nlemma I\u2082 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 l, \u2203 P Q, P \u2260 Q \u2227 incident_with P l \u2227 incident_with Q l := incidence.I\u2082\n\nlemma I\u2083 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n   \u2203 P Q R, P \u2260 Q \u2227 Q \u2260 R \u2227 P \u2260 R \u2227\n    \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := incidence.I\u2083\n\n\n\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \n  begin\n    rcases (I\u2083 incident_with) with \u27e8P, Q, R, P_ne_Q, Q_ne_R, P_ne_R, h\u27e9,\n    specialize h l,\n    rw not_and_distrib at h,\n    rw not_and_distrib at h,\n    classical,\n    cases h,\n    {\n      use P,\n    },\n    {\n      cases h,\n      use Q,\n      use R,\n    },\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209123,"user_id":null,"body":"import Preloaded\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \n  begin\n  have props := _inst_1,\n  cases props.I\u2083 with p\u2081 tp\u2081,\n  cases tp\u2081 with p\u2082 tp\u2082,\n  cases tp\u2082 with p\u2083 three_pts,\n  by_cases h\u2081: (incident_with p\u2081 l),\n  { by_cases h\u2082: (incident_with p\u2082 l),\n    { by_cases h\u2083: (incident_with p\u2083 l),\n      { have not_aligned: \u00ac(incident_with p\u2081 l \u2227 incident_with p\u2082 l \u2227 incident_with p\u2083 l) :=\n        begin\n          have x:= three_pts.elim_right.elim_right.elim_right,\n          exact x l,\n        end,\n        have h\u2082\u2083 := and.intro h\u2082 h\u2083,\n        have h\u2081\u2082\u2083:= and.intro h\u2081 h\u2082\u2083,\n        exfalso,\n        exact not_aligned(h\u2081\u2082\u2083),\n        },\n      exact \u27e8p\u2083, h\u2083\u27e9,},\n    exact \u27e8p\u2082, h\u2082\u27e9,},\n  exact \u27e8p\u2081, h\u2081\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209124,"user_id":null,"body":"import Preloaded\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := begin\n    intros, \n    cases incidence.I\u2083, cases h, cases h_h,\n    rename w p, rename h_w q, rename h_h_w r, rename h_h_h h,\n    by_cases p_inc : incident_with p l,\n    by_cases q_inc : incident_with q l,\n    by_cases r_inc : incident_with r l,\n    let all_inc : incident_with p l \u2227 incident_with q l \u2227 incident_with r l \n      := and.intro p_inc (and.intro q_inc r_inc),\n    let n_all_inc : \u00ac(incident_with p l \u2227 incident_with q l \u2227 incident_with r l) \n      := (and.elim_right (and.elim_right (and.elim_right h))) l,\n    contradiction,\n    existsi r, assumption,\n    existsi q, assumption,\n    existsi p, assumption,\n    assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209125,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin\n  have A\u2083 := _inst_1.I\u2083,\n  rcases A\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, h\u27e9,\n  by_cases hQ : \u00ac incident_with Q l,\n  { use [Q, hQ] },\n  by_cases hR : \u00ac incident_with R l,\n  { use [R, hR] },\n  by_cases hS : \u00ac incident_with S l,\n  { use [S, hS] },\n  exfalso,  \n  simp [neg_neg] at *,\n  exact (h l) hQ hR hS\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e889bcd0f55ed0023f11b2e":[{"id":209126,"user_id":null,"body":"import Preloaded tactic\n\nlemma exists_line (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) : \u2203 l, incident_with P l \u2227 incident_with Q l :=\nbegin\n  have A\u2081:= _inst_1.I\u2081,\n  by_cases hPQ : P = Q,\n  { obtain \u27e8R, S, _, hRS, _, _, _\u27e9 := _inst_1.I\u2083, \n    by_cases hPR : P = R,\n    { obtain \u27e8l, _\u27e9   := A\u2081 P S (ne_of_eq_of_ne hPR hRS), use [l, by cc], },\n    { obtain \u27e8l, _\u27e9   := A\u2081 P R hPR,                      use [l, by cc], }, },\n  { obtain \u27e8l, hl, _\u27e9 := A\u2081 P Q hPQ,                      use [l, hl],    },\nend\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  obtain \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9 := _inst_1.I\u2083,\n  obtain \u27e8lPQ, hlPQ\u27e9 := exists_line point line incident_with P Q,\n  obtain \u27e8lPR, hlPR\u27e9 := exists_line point line incident_with P R,\n  obtain \u27e8lPS, hlPS\u27e9 := exists_line point line incident_with P S,\n  by_cases PQ_eq_PR : lPQ = lPR,\n  { have PQ_ne_PS : lPQ \u2260 lPS, by { intro, exact hQRS lPQ (by cc) },\n    use [lPQ, lPS, PQ_ne_PS, hlPQ.1, hlPS.1], },\n  { use [lPQ, lPR, PQ_eq_PR, hlPQ.1, hlPR.1], },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209127,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [s:incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  let I1 := s.I\u2081,\n  let I2 := s.I\u2082,\n  rcases s.I\u2083 with \u27e8A, B, C, \u27e8hab,hbc,hac,habc\u27e9\u27e9,\n  rcases I1 A B hab with \u27e8 AB ,\u27e8 hAB,hAB' \u27e9\u27e9,\n  simp only [and_imp] at hAB',\n  by_cases hP : incident_with P AB,\n  {\n    have : P \u2260 C,\n    {\n      by_contra,\n      apply habc AB,\n      tidy,\n    },\n    rcases I1 P C this with \u27e8 PC ,\u27e8 hPC,hPC' \u27e9\u27e9,\n    use [AB, PC],\n    split,\n    {\n      by_contra,\n      apply habc AB,\n      tidy,\n    },\n    tidy,\n  },\n  have anp : A \u2260 P := by tidy,\n  have bnp : B \u2260 P := by tidy,\n  rcases I1 A P anp with \u27e8 AP ,\u27e8 hAP,hAP' \u27e9\u27e9,\n  rcases I1 B P bnp with \u27e8 BP ,\u27e8 hBP,hBP' \u27e9\u27e9,\n  use [AP,BP],\n  split,\n  {\n    by_contra,\n    have := hAB' AP hAP.1,\n    rw h at this,\n    have := this hBP.1,\n    tidy,\n  },\n  tidy,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209128,"user_id":null,"body":"import Preloaded tactic\n\nlemma exists_two_lines (point line incident_with)\n  [geo : incidence point line incident_with] (P Q R : point)\n  (nPQ : P \u2260 Q) (nQR : Q \u2260 R) (nPR : P \u2260 R)\n  (hLine : \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l)) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  obtain \u27e8l, \u27e8lP, lQ\u27e9, hl\u27e9 := @incidence.I\u2081 _ _ _ geo _ _ nPQ,\n  obtain \u27e8m, \u27e8mP, mR\u27e9, hm\u27e9 := @incidence.I\u2081 _ _ _ geo _ _ nPR,\n  simp at hl hm,\n  use [l, m],\n  fconstructor,\n  { intro h, apply hLine l, rw \u2190h at mR, cc },\n  finish,\nend\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (X : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with X l \u2227 incident_with X m :=\nbegin\n  obtain \u27e8P, Q, R, nPQ, nQR, nPR, nLine\u27e9 := geo.I\u2083,\n  by_cases nXP : X = P, { rw nXP at *, exact exists_two_lines _ _ _ _ _ _ nPQ nQR nPR nLine },\n  by_cases nXQ : X = Q, { rw nXQ at *, exact exists_two_lines _ _ _ _ _ _ nQR nPR.symm nPQ.symm (by finish) },\n  by_cases nXR : X = R, { rw nXR at *, exact exists_two_lines _ _ _ _ _ _ nPR.symm nPQ nQR.symm (by finish) },\n  obtain \u27e8l, hl, hl2\u27e9 := @incidence.I\u2081 _ _ _ geo X P nXP, simp at hl2,\n  obtain \u27e8m, hm, hm2\u27e9 := @incidence.I\u2081 _ _ _ geo X Q nXQ, simp at hm2,\n  obtain \u27e8s, hs, hs2\u27e9 := @incidence.I\u2081 _ _ _ geo X R nXR, simp at hs2,\n  by_cases l = m, swap, { use [l, m], cc },\n  by_cases m = s, swap, { use [m, s], cc },\n  by_cases l = s, swap, { use [l, s], cc },\n  specialize nLine m, cc,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209129,"user_id":191,"body":"import Preloaded tactic\n\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, Q_ne_R, R_ne_S, Q_ne_S, hQRS\u27e9,\n  by_cases hPQ : P = Q,\n  { rw hPQ,\n    rcases I\u2081 incident_with Q R Q_ne_R with \u27e8l, \u27e8hQl, hRl\u27e9, -\u27e9,\n    rcases I\u2081 incident_with Q S Q_ne_S with \u27e8m, \u27e8hQm, hSm\u27e9, -\u27e9,\n    use [l, m],\n    split,\n    { intro hlm,\n      apply hQRS l,\n      rw \u2190 hlm at hSm,\n      exact \u27e8hQl, hRl, hSm\u27e9\n    },\n    exact \u27e8hQl, hQm\u27e9,\n  },\n  { rcases I\u2081 incident_with P Q hPQ with \u27e8l, \u27e8hPl, hQl\u27e9, -\u27e9,\n    by_cases hPR : P = R,\n    { rw hPR at |- hPl,\n      rcases I\u2081 incident_with R S R_ne_S with \u27e8m, \u27e8hRm, hSm\u27e9, -\u27e9,\n      use [l, m],\n      split,\n      { intro hlm,\n        apply hQRS l,\n        rw \u2190 hlm at hSm,\n        exact \u27e8hQl, hPl, hSm\u27e9\n      },\n      exact \u27e8hPl, hRm\u27e9,\n    },\n    { rcases I\u2081 incident_with P R hPR with \u27e8m, \u27e8hPm, hRm\u27e9, -\u27e9,\n      by_cases hPS : P = S,\n      { rw hPS at |- hPl hPm,\n        use [l, m],\n        split,\n        { intro hlm,\n          apply hQRS l,\n          rw \u2190 hlm at hRm,\n          exact \u27e8hQl, hRm, hPl\u27e9,\n        },\n        exact \u27e8hPl, hPm\u27e9\n      },\n      { by_cases hlm : l = m,\n        { rcases I\u2081 incident_with P S hPS with \u27e8n, \u27e8hPn, hSn\u27e9, -\u27e9,\n          use [l, n],\n          split,\n          { intro hln,\n            apply hQRS l,\n            rw \u2190 hlm at hRm,\n            rw \u2190 hln at hSn,\n            exact \u27e8hQl, hRm, hSn\u27e9\n          },\n          exact \u27e8hPl, hPn\u27e9\n        },\n        { use [l, m],\n          exact \u27e8hlm, hPl, hPm\u27e9\n        }\n      }\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209130,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m := \nbegin\n  have A\u2081 := _inst_1.I\u2081, \n  have A\u2082 := _inst_1.I\u2082, \n  have A\u2083 := _inst_1.I\u2083, \n  rcases A\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9,\n  rcases A\u2081 Q R hQR with \u27e8l, \u27e8hlQ, hlR\u27e9, hl\u27e9,\n  dsimp at *,\n  by_cases hlP : incident_with P l,\n  { have hPS : P \u2260 S,\n    { intros hPS,\n      rw hPS at hlP,\n      exact (hQRS l) \u27e8hlQ, hlR, hlP\u27e9 }, \n    rcases A\u2081 P S hPS with \u27e8m, \u27e8hmP, hmS\u27e9, hm\u27e9,\n    have hlm : l \u2260 m,\n    { intros hlm,\n      rw \u2190hlm at hmS,\n      exact (hQRS l) \u27e8hlQ, hlR, hmS\u27e9 },\n    use [l, m, hlm, hlP, hmP] },\n  have hPQ : P \u2260 Q,\n  { intros hPQ,\n    cc },\n  have hPR : P \u2260 R,\n  { intros hPR,\n    cc },\n  rcases A\u2081 P Q hPQ with \u27e8m, \u27e8hmP, hmQ\u27e9, hm\u27e9,\n  rcases A\u2081 P R hPR with \u27e8n, \u27e8hnP, hnR\u27e9, hn\u27e9,\n  have hmn : m \u2260 n,\n  { intros hmn,\n    rw \u2190hmn at hnR,\n    rw [hl m \u27e8hmQ, hnR\u27e9] at hmP,\n    exact hlP hmP },\n  use [m, n, hmn, hmP, hnP]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209131,"user_id":null,"body":"import Preloaded\nimport tactic\n\n\nopen_locale classical\n\n\/--\nintersection of two line is unique.\n-\/\ntheorem thm_3p6p1 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [inst : incidence point line incident_with] (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8P, hl, hm\u27e9 := hnpar,\n  use [P, hl, hm],\n  rintros P' \u27e8hl', hm'\u27e9,\n  classical,\n  by_contradiction hneq,\n  obtain \u27e8n, _, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P P' (by cc),\n  have := hn_unique l \u27e8hl, hl'\u27e9,\n  have := hn_unique m \u27e8hm, hm'\u27e9,\n  cc,\nend \n\n\/--\n-\/\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [inst : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin \n  obtain \u27e8P, Q, R, _, _, _, h\u27e9 := inst.I\u2083,\n  by_contradiction hi,\n  push_neg at hi,\n  exact h l \u27e8hi P, hi Q, hi R\u27e9,\nend \n\nlemma exists_distinct_point (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [inst : incidence point line incident_with] (P : point) :\n  \u2203 Q, P \u2260 Q :=\nbegin \n  obtain \u27e8Q, R, S, hQR, hRS, hQS, _\u27e9 := inst.I\u2083,\n  have ht : P \u2260 Q \u2228 P \u2260 R \u2228 P \u2260 S := by finish,\n  cases ht, { use Q },\n  cases ht, { use R }, { use S }\nend \n\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [inst : incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  finish,\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209132,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, h3\u27e9,\n  by_cases hPQ : P = Q, {\n    subst_vars,\n    have hl := _inst_1.I\u2081, specialize hl Q R hQR, rcases hl with \u27e8l, hl0, hl1\u27e9, simp at hl1,\n    have hS : \u00acincident_with S l, { have := h3 l, cc },\n    have hm := _inst_1.I\u2081, specialize hm Q S hQS, rcases hm with \u27e8m, hm0, hm1\u27e9, simp at hm1,\n    have hS : \u00acincident_with R m, { have := h3 m, cc },\n    existsi [l, m], by_cases l = m; cc\n  },\n  by_cases hPR : P = R, {\n    subst_vars,\n    have hl := _inst_1.I\u2081, specialize hl Q R hQR, rcases hl with \u27e8l, hl0, hl1\u27e9, simp at hl1,\n    have hS : \u00acincident_with S l, { have := h3 l, cc },\n    have hm := _inst_1.I\u2081, specialize hm R S hRS, rcases hm with \u27e8m, hm0, hm1\u27e9, simp at hm1,\n    have hS : \u00acincident_with Q m, { have := h3 m, cc },\n    existsi [l, m], by_cases l = m; cc\n  },\n  by_cases hPS : P = S, {\n    subst_vars,\n    have hl := _inst_1.I\u2081, specialize hl Q S hQS, rcases hl with \u27e8l, hl0, hl1\u27e9, simp at hl1,\n    have hS : \u00acincident_with R l, { have := h3 l, cc },\n    have hm := _inst_1.I\u2081, specialize hm R S hRS, rcases hm with \u27e8m, hm0, hm1\u27e9, simp at hm1,\n    have hS : \u00acincident_with Q m, { have := h3 m, cc },\n    existsi [l, m], by_cases l = m; cc\n  },\n  have hl := _inst_1.I\u2081, specialize hl P Q hPQ, rcases hl with \u27e8l, hl0, hl1\u27e9, simp at hl1,\n  have hm := _inst_1.I\u2081, specialize hm P R hPR, rcases hm with \u27e8m, hm0, hm1\u27e9, simp at hm1,\n  have hn := _inst_1.I\u2081, specialize hn P S hPS, rcases hn with \u27e8n, hn0, hn1\u27e9, simp at hn1,\n  by_cases l = m, swap, { existsi [l, m], cc },\n  by_cases l = n, swap, { existsi [l, n], cc },\n  by_cases m = n, swap, { existsi [m, n], cc },\n  have := h3 m, cc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209133,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (S : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with S l \u2227 incident_with S m :=\nbegin\n  rcases geo.I\u2083 with \u27e8P, Q, R, pneq, qner, pner , h\u2081\u27e9,\n  have k\u2081, from geo.I\u2081,\n  rcases k\u2081 P Q pneq with \u27e8l, \u27e8inc_pl, inc_ql\u27e9, h\u2082\u27e9,\n  rcases k\u2081 P R pner with \u27e8m, \u27e8inc_pm, inc_rm\u27e9, h\u2083\u27e9,\n  have k\u2083 : l \u2260 m, from \u03bb lm, h\u2081 l \u27e8inc_pl, inc_ql, lm.symm \u25b8 inc_rm\u27e9,\n  by_cases h : P = S,\n  { exact h \u25b8 \u27e8l, m, k\u2083, inc_pl, inc_pm\u27e9, },\n  { rcases k\u2081 P S h with \u27e8c, \u27e8inc_pc, inc_sc\u27e9, h\u2084\u27e9,\n    have h\u2085 : \u00ac(incident_with S l \u2227 incident_with S m), from\n      \u03bb k\u2082, k\u2083 (eq.trans (h\u2084 l \u27e8inc_pl, k\u2082.left\u27e9) (h\u2084 m \u27e8inc_pm, k\u2082.right\u27e9).symm),\n    cases (not_and_distrib.mp h\u2085) with ninc_sl ninc_sm,\n    { rcases k\u2081 S Q (\u03bb k, ninc_sl $ k.symm \u25b8 inc_ql) with \u27e8d, \u27e8inc_sd, inc_qd\u27e9, h\u2086\u27e9,\n      exact \u27e8c, d, \u03bb cd, ninc_sl $ (h\u2082 d \u27e8cd \u25b8 inc_pc, inc_qd\u27e9) \u25b8 inc_sd, inc_sc, inc_sd\u27e9, },\n    { rcases k\u2081 S R (\u03bb k, ninc_sm $ k.symm \u25b8 inc_rm) with \u27e8d, \u27e8inc_sd, inc_rd\u27e9, h\u2086\u27e9,\n      exact \u27e8c, d, \u03bb cd, ninc_sm $ (h\u2083 d \u27e8cd \u25b8 inc_pc, inc_rd\u27e9) \u25b8 inc_sd, inc_sc, inc_sd\u27e9, }, },\nend  ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209134,"user_id":17,"body":"import Preloaded\nimport tactic.tidy\n\n-- Original author of solution: @monadius\n-- Copied for the v3.18.4 migration only\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  obtain \u27e8p, q, r, pq, qr, pr, h\u27e9 := _inst_1.I\u2083,\n  have hl := h l,\n  repeat {rw not_and_distrib at hl},\n  tidy,\nend\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  obtain \u27e8Q, nPQ\u27e9 : \u2203 Q, P \u2260 Q,\n  { rcases s.I\u2083 with \u27e8A, B, C, ab, bc, ac, h\u27e9,\n    cases em (P = A), tidy, },\n  rcases @incidence.I\u2081 _ _ _ s P Q nPQ with \u27e8l, \u27e8Pl, Ql\u27e9, _\u27e9,\n  rcases @thm_3p6p2 _ _ _ s l with \u27e8R, nRl\u27e9,\n  have nRP : R \u2260 P, intro rp, rw rp at *, contradiction,\n  rcases @incidence.I\u2081 _ _ _ s R P nRP with \u27e8m, \u27e8Rm, Pm\u27e9, _\u27e9,\n  existsi l, existsi m, tidy,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209135,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  -- let Q, R and S be 3 non-collinear points\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, nqr, nsr, nqs, h3\u27e9,\n  have h1 := _inst_1.I\u2081,\n  -- let QR be the line through Q and R\n  rcases h1 Q R nqr with \u27e8QR, hqr, uqr\u27e9,\n  by_cases hpqr : incident_with P QR,\n  { -- if P \u2208 QR, then P must not equal S\n    have nps : P \u2260 S := by { intro e, apply h3 QR, tidy },\n    -- let PS be the line through P and S\n    rcases h1 P S nps with \u27e8PS, hps, ups\u27e9,\n    -- as P is in both lines, we only need to show that they are not the same\n    refine \u27e8QR, PS, _, hpqr, hps.1\u27e9,\n    -- which would be a contradiction, for Q, R and S are not collinear\n    intro e,\n    apply h3 QR,\n    tidy\n  },\n  -- if P \u2209 QR, than its not Q nor R\n  have npq : P \u2260 Q := by { intro e, apply hpqr, tidy },\n  have npr : P \u2260 R := by { intro e, apply hpqr, tidy },\n  -- let PQ and PR be the lines through P by Q and R, respectively\n  rcases h1 P Q npq with \u27e8PQ, hpq, upq\u27e9,\n  rcases h1 P R npr with \u27e8PR, hpr, upr\u27e9,\n  -- we only need to show that they are distict\n  refine \u27e8PQ, PR, _, hpq.1, hpr.1\u27e9,\n  -- assuming they were equal\n  intro e1,\n  -- Q and R would both lie on PQ, which would then equal QR\n  have e2 : PQ = QR := by { apply uqr, tidy},\n  -- a contradiction, for P does not lie on it\n  tidy\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e889e710f55ed0015f17e84":[{"id":209136,"user_id":null,"body":"import Preloaded tactic\n\nlemma exists_line_through_points (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) : \u2203 l, incident_with P l \u2227 incident_with Q l :=\nbegin\n  have A\u2081:= _inst_1.I\u2081,\n  by_cases hPQ : P = Q,\n  { obtain \u27e8R, S, _, hRS, _, _, _\u27e9 := _inst_1.I\u2083, \n    by_cases hPR : P = R,\n    { obtain \u27e8l, _\u27e9   := A\u2081 P S (ne_of_eq_of_ne hPR hRS), use [l, by cc], },\n    { obtain \u27e8l, _\u27e9   := A\u2081 P R hPR,                      use [l, by cc], }, },\n  { obtain \u27e8l, hl, _\u27e9 := A\u2081 P Q hPQ,                      use [l, hl],    },\nend\n\nlemma exists_point_off_line (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) : \u2203 P, \u00ac incident_with P l :=\nbegin\n  obtain \u27e8P, Q, R, hPQ, hQR, hPR, hPQR\u27e9 := _inst_1.I\u2083,\n  by_cases hP : incident_with P l, swap, use [P, hP],\n  by_cases hQ : incident_with Q l, swap, use [Q, hQ],\n  by_cases hR : incident_with R l, swap, use [R, hR],\n  exfalso,\n  exact hPQR l (by cc),\nend\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  have A\u2081 := _inst_1.I\u2081,\n  have A\u2082 := _inst_1.I\u2082,\n  obtain \u27e8P, Q, hPQ, hPl, hQl\u27e9 := A\u2082 l,\n  obtain \u27e8_, _, u\u27e9 := A\u2081 P Q hPQ,\n  obtain \u27e8R, _\u27e9             := exists_point_off_line       point line incident_with l,\n  obtain \u27e8lPR, P_on_lPR, _\u27e9 := exists_line_through_points  point line incident_with P R,\n  obtain \u27e8lQR, Q_on_lQR, _\u27e9 := exists_line_through_points  point line incident_with Q R,\n  use [lPR, lQR, by {intro, cc}],\n  repeat { use [by {intro, have := u lPR (by cc), have := u l (by cc), cc}], },\n  use [P, P_on_lPR, hPl, Q, Q_on_lQR, hQl],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209137,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p1\n  (point line : Type) (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with]\n  (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\nbegin\n  cases hnpar with P hP,\n  use P,\n  split,\n  exact hP,\n  intros Q hQ,\n  by_contra,\n  have := incidence.I\u2081 Q P h,\n  {\n    rcases this with \u27e8 L, \u27e8 hL1, hL2\u27e9\u27e9,\n    simp at hL2,\n    have hl := hL2 l hQ.1 hP.1,\n    have hm := hL2 m hQ.2 hP.2,\n    rw [hl,hm] at hlm,\n    exact hlm rfl,\n  },\n  {\n    exact _inst_1,\n  },\nend\n\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  have := _inst_1.I\u2083,\n  rcases this with \u27e8P, Q, R, \u27e8_,_,_,hpqr\u27e9\u27e9,\n  specialize hpqr l,\n  push_neg at hpqr,\n  by_cases hP: incident_with P l,\n  {\n    by_cases hQ: incident_with Q l,\n    {\n      exact \u27e8 R, hpqr hP hQ \u27e9,\n    },\n    exact \u27e8 Q, hQ\u27e9,\n  },\n  exact \u27e8 P,hP\u27e9,\nend\n\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  let I2 := _inst_1.I\u2082,\n  let I1 := _inst_1.I\u2081,\n  rcases I2 l with \u27e8 P,Q, \u27e8hPQ, hPl,hQl\u27e9\u27e9,\n  cases thm_3p6p2 point line incident_with l with R hR,\n  have hRP : R \u2260 P := by tidy,\n  have hRQ : R \u2260 Q := by tidy,\n  rcases I1 R P hRP with \u27e8RP,\u27e8hRP1,hRP2\u27e9\u27e9,\n  rcases I1 R Q hRQ with \u27e8RQ,\u27e8hRQ1,hRQ2\u27e9\u27e9,\n  use [RP,RQ],\n  split,\n  {\n    tidy,\n  },\n  split,\n  {\n    by_contra,\n    rcases thm_3p6p1 _ _ incident_with l RP\n     (by tidy) \u27e8 P,by tidy\u27e9 with \u27e8p, \u27e8 hp1,hp2\u27e9\u27e9,\n    have := hp2 P (by tidy),\n    have := hp2 Q (by tidy),\n    tidy,\n  },\n  split,\n  {\n    tidy,\n  },\n  split,\n  {\n    use P,\n    tidy,\n  },\n  {\n    use Q,\n    tidy,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209138,"user_id":191,"body":"import Preloaded tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8P, Q, R, -, -, -, hPQR\u27e9,\n  by_cases hPl : incident_with P l,\n  by_cases hQl : incident_with Q l,\n  push_neg at hPQR,\n  exact \u27e8R, hPQR l hPl hQl\u27e9,\n  use Q,\n  use P\nend\n\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\nlemma I\u2082 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 l, \u2203 P Q, P \u2260 Q \u2227 incident_with P l \u2227 incident_with Q l := incidence.I\u2082\n\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  rcases thm_3p6p2 _ _ incident_with l with \u27e8P, hP\u27e9,\n  rcases I\u2082 incident_with l with \u27e8Q, R, Q_ne_R, hQl, hRl\u27e9,\n  have P_ne_Q : P \u2260 Q, intro h, rw h at hP, exact hP hQl,\n  have P_ne_R : P \u2260 R, intro h, rw h at hP, exact hP hRl,\n  rcases I\u2081 incident_with P Q P_ne_Q with \u27e8m, \u27e8hPm, hQm\u27e9, -\u27e9,\n  rcases I\u2081 incident_with P R P_ne_R with \u27e8n, \u27e8hPn, hRn\u27e9, -\u27e9,\n  use [m, n],\n  split, intro h, rw h at hP, exact hP hPm,\n  split, {\n     intro h,\n     rcases I\u2081 incident_with Q R Q_ne_R with \u27e8o, \u27e8hQo, hRo\u27e9, o_unique\u27e9,\n     rw h at hQm,\n     rw [o_unique n \u27e8hQm, hRn\u27e9, \u2190 o_unique l \u27e8hQl, hRl\u27e9] at hPn,\n     exact hP hPn,\n  },\n  split, intro h, rw h at hP, exact hP hPn,\n  exact \u27e8\u27e8Q, hQm, hQl\u27e9, \u27e8R, hRn, hRl\u27e9\u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209139,"user_id":191,"body":"import Preloaded tactic\n\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\nlemma I\u2082 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 l, \u2203 P Q, P \u2260 Q \u2227 incident_with P l \u2227 incident_with Q l := incidence.I\u2082\n\n\/- Theorem 3.6.2 and 3.6.3 shamelessly stolen from monadius -\/\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := by { obtain \u27e8p, q, r, pq, qr, pr, h\u27e9 := _inst_1.I\u2083, have hl := h l, repeat {rw not_and_distrib at hl}, tidy }\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] (P : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m :=\nbegin\n  obtain \u27e8Q, nPQ\u27e9 : \u2203 Q, P \u2260 Q, { rcases s.I\u2083 with \u27e8A, B, C, ab, bc, ac, h\u27e9, cases em (P = A), tidy, },\n  rcases @incidence.I\u2081 _ _ _ s P Q nPQ with \u27e8l, \u27e8Pl, Ql\u27e9, _\u27e9, rcases @thm_3p6p2 _ _ _ s l with \u27e8R, nRl\u27e9,\n  have nRP : R \u2260 P, intro rp, rw rp at *, contradiction, rcases @incidence.I\u2081 _ _ _ s R P nRP with \u27e8m, \u27e8Rm, Pm\u27e9, _\u27e9,\n  existsi l, existsi m, tidy,\nend\n\/- end monadius -\/\n\nlemma unique_from_points {point line : Type} (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] {P Q : point} {l m : line} (P_ne_Q : P \u2260 Q) (hPl : incident_with P l)\n  (hPm : incident_with P m) (hQl : incident_with Q l) (hQm : incident_with Q m) : l = m :=\nbegin\n  rcases I\u2081 incident_with P Q P_ne_Q with \u27e8l', -, l'_unique\u27e9,\n  have hll' := l'_unique l \u27e8hPl, hQl\u27e9,\n  have hml' := l'_unique m \u27e8hPm, hQm\u27e9,\n  cc,\nend\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  rcases I\u2082 incident_with l with \u27e8P, Q, P_ne_Q, hPl, hQl\u27e9,\n  rcases thm_3p6p3 _ _ incident_with P with \u27e8m, n, hmn, hPm, hPn\u27e9,\n  by_cases hlm : l = m,\n  { rcases thm_3p6p3 _ _ incident_with Q with \u27e8o, p, hop, hQo, hQp\u27e9,\n    by_cases hlo : l = o,\n    { use [n, p],\n      split, rw hlm, exact hmn,\n      split, {\n        intro h,\n        rw \u2190 h at hQp,\n        rw hlm at hQl,\n        exact hmn (unique_from_points _ P_ne_Q hPm hPn hQl hQp)\n      },\n      split, rw hlo, exact hop,\n      exact \u27e8\u27e8P, hPn, hPl\u27e9, \u27e8Q, hQp, hQl\u27e9\u27e9\n    },\n    { use [n, o],\n      split, rw hlm, exact hmn,\n      split, {\n        intro h,\n        rw hlm at hQl,\n        rw \u2190 h at hQo,\n        exact hmn (unique_from_points _ P_ne_Q hPm hPn hQl hQo)\n      },\n      split, exact hlo,\n      exact \u27e8\u27e8P, hPn, hPl\u27e9, \u27e8Q, hQo, hQl\u27e9\u27e9\n    }\n  },\n  { rcases thm_3p6p3 _ _ incident_with Q with \u27e8o, p, hop, hQo, hQp\u27e9,\n    by_cases hlo : l = o,\n    { use [m, p],\n      split, exact hlm,\n      split, {\n        intro h,\n        rw \u2190 h at hQp,\n        exact hlm (unique_from_points _ P_ne_Q hPl hPm hQl hQp)\n      },\n      split, rw hlo, exact hop,\n      exact \u27e8\u27e8P, hPm, hPl\u27e9, \u27e8Q, hQp, hQl\u27e9\u27e9\n    },\n    { use [m, o],\n      split, exact hlm,\n      split, {\n        intro h,\n        rw \u2190 h at hQo,\n        exact hlm (unique_from_points _ P_ne_Q hPl hPm hQl hQo)\n      },\n      split, exact hlo,\n      exact \u27e8\u27e8P, hPm, hPl\u27e9, \u27e8Q, hQo, hQl\u27e9\u27e9\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209140,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l := \nbegin\n  have A\u2081:=_inst_1.I\u2081,\n  have A\u2082:=_inst_1.I\u2082,\n  have A\u2083:=_inst_1.I\u2083,  \n  rcases A\u2082 l with \u27e8P, Q, hPQ, hPl, hQl\u27e9,\n  have hR : \u2203 R, \u00ac (incident_with R l),\n  { by_contradiction hc,\n    push_neg at hc,\n    rcases A\u2083 with \u27e8A, B, C, _, _, _, h\u27e9,\n    exact (h l) \u27e8hc A, hc B, hc C\u27e9 },\n  rcases hR with \u27e8R, hRl\u27e9,\n  have hPR : P \u2260 R,\n  { intros hPR, rw hPR at hPl, exact hRl hPl }, \n  have hQR : Q \u2260 R,\n  { intros hQR, rw hQR at hQl, exact hRl hQl }, \n  rcases A\u2081 P R hPR with \u27e8m, \u27e8hPm, hRm\u27e9, hmPR\u27e9,\n  rcases A\u2081 Q R hQR with \u27e8n, \u27e8hQn, hRn\u27e9, hnQR\u27e9,\n  have hlm : l \u2260 m,\n  { intros hlm, rw hlm at hRl, exact hRl hRm },\n  have hmn : m \u2260 n,\n  { intros hmn, \n    rw \u2190hmn at hQn,\n    rcases A\u2081 P Q hPQ with \u27e8w, \u27e8_, _\u27e9, hw\u27e9, \n    have t1 := hw m \u27e8hPm, hQn\u27e9, \n    have t2 := hw l \u27e8hPl, hQl\u27e9,\n    exact hlm (by simp [t1, t2])},\n  have hln : l \u2260 n,\n  { intros hln, rw hln at hRl, exact hRl hRn },  \n  use [m, n, hlm, hmn, hln, \u27e8P, hPm, hPl\u27e9, \u27e8Q, hQn, hQl\u27e9]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209141,"user_id":null,"body":"import Preloaded\nimport tactic \nopen_locale classical\n\nsection \nvariables (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n\n\/-- intersection of two line is unique. -\/\ntheorem thm_3p6p1 [inst : incidence point line incident_with] \n  (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8P, hl, hm\u27e9 := hnpar,\n  use [P, hl, hm],\n  rintros P' \u27e8hl', hm'\u27e9,\n  classical,\n  by_contradiction hneq,\n  obtain \u27e8n, _, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P P' (by cc),\n  have := hn_unique l \u27e8hl, hl'\u27e9,\n  have := hn_unique m \u27e8hm, hm'\u27e9,\n  cc,\nend \n\n\/-- every line has non-incident point. -\/\ntheorem thm_3p6p2 [inst : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin \n  obtain \u27e8P, Q, R, _, _, _, h\u27e9 := inst.I\u2083,\n  by_contradiction hi,\n  push_neg at hi,\n  exact h l \u27e8hi P, hi Q, hi R\u27e9,\nend \n\n\nlemma exists_distinct_point [inst : incidence point line incident_with] (P : point) : \n  \u2203 Q, P \u2260 Q :=\nbegin \n  obtain \u27e8Q, R, S, hQR, hRS, hQS, _\u27e9 := inst.I\u2083,\n  have ht : P \u2260 Q \u2228 P \u2260 R \u2228 P \u2260 S := by finish,\n  finish,\nend \n\n\/-- every point has two distinct incident line. -\/\ntheorem thm_3p6p3 [inst : incidence point line incident_with] (P : point) : \n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  finish,\nend \n\n\/-- for any line, there exists two more lines, with pairwise intersection -\/\ntheorem thm_3p6p4 \n  [inst : incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l := \nbegin \n  obtain \u27e8P, hP\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8Q, R, hQR, hl\u27e9 := let I\u2082 := inst.I\u2082 in I\u2082 l,\n  obtain \u27e8l', hl', hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q R (by finish),\n  rcases (hl_unique l hl : l = l') with rfl, clear hl',\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q (by finish),\n  obtain \u27e8n, hn, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  exact \u27e8m, n, \n    (by finish : l \u2260 m), (by finish : m \u2260 n), (by finish : l \u2260 n), \n    \u27e8Q, (by cc)\u27e9, \u27e8R, (by cc)\u27e9\u27e9,\nend \n\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209142,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  have hl := _inst_1.I\u2082, specialize hl l, rcases hl with \u27e8 P, Q, hPQ, hP, hQ \u27e9,\n  have h : \u2203 P, \u00acincident_with P l, {\n    rcases _inst_1.I\u2083 with \u27e8P, Q, R, hPQ, hQR, hPR, h\u27e9,\n    have := h l,\n    by_cases incident_with P l, swap, { use P },\n    by_cases incident_with Q l, swap, { use Q },\n    by_cases incident_with R l, swap, { use R },\n    cc\n  }, rcases h with \u27e8 R, hR \u27e9,\n  by_cases hPR : P = R, { cc },\n  by_cases hQR : Q = R, { cc },\n  have hl := _inst_1.I\u2081, specialize hl P R hPR, rcases hl with \u27e8 m, hm0, hm1 \u27e9, simp at hm1,\n  have hl := _inst_1.I\u2081, specialize hl Q R hQR, rcases hl with \u27e8 n, hn0, hn1 \u27e9, simp at hn1,\n  by_cases hlm : l = m, { cc },\n  by_cases hln : l = n, { cc },\n  by_cases hmn : m = n, {\n    have hl := _inst_1.I\u2081, specialize hl P Q hPQ, rcases hl with \u27e8 t, ht0, ht1 \u27e9, simp at ht1,\n    have := ht1 n, have := ht1 l, cc\n  },\n  existsi [m, n],\n  split; try { assumption },\n  split; try { assumption },\n  split; try { assumption },\n  split; [existsi P, existsi Q]; cc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209143,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  rcases geo.I\u2083 with \u27e8_, _, _, _, _, _, h\u2081\u27e9,\n  specialize h\u2081 l,\n  rw [not_and_distrib, not_and_distrib] at h\u2081,\n  rcases h\u2081;\n  finish,\nend\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  cases (thm_3p6p2 point line incident_with l) with R ninc_rl,\n  obtain \u27e8P, Q, pneq, inc_pl, inc_ql\u27e9 := @incidence.I\u2082 _ _ _ geo l,\n  have pner : P \u2260 R, from \u03bb pr, ninc_rl $ pr \u25b8 inc_pl,\n  have qner : Q \u2260 R, from \u03bb qr, ninc_rl $ qr \u25b8 inc_ql,\n  have k\u2081 := geo.I\u2081,\n  rcases k\u2081 P Q pneq with \u27e8w, _, h\u2081\u27e9,\n  have lw : l = w, from h\u2081 l \u27e8inc_pl, inc_ql\u27e9,\n  rcases k\u2081 P R pner with \u27e8m, \u27e8inc_pm, inc_rm\u27e9, h\u2082\u27e9,\n  rcases k\u2081 Q R qner with \u27e8n, \u27e8inc_qn, inc_rn\u27e9, h\u2083\u27e9,\n  use [m, n],\n  have lnem : l \u2260 m, from \u03bb lm, ninc_rl $ lm.symm \u25b8 inc_rm,\n  have mnen : m \u2260 n,\n  { intro mn,\n    have inc_qm : incident_with Q m, from mn.symm \u25b8 inc_qn,\n    have mw : m = w, from h\u2081 m \u27e8inc_pm, inc_qm\u27e9,\n    exact lnem (eq.trans lw mw.symm), },\n  have lnen : l \u2260 n, from \u03bb ln, ninc_rl $ ln.symm \u25b8 inc_rn,\n  exact \u27e8lnem, mnen, lnen, \u27e8P, inc_pm, inc_pl\u27e9, \u27e8Q, inc_qn, inc_ql\u27e9\u27e9,\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209144,"user_id":null,"body":"import Preloaded tactic\n\nlemma two_on_one_off (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) (P Q R : point)\n    (hPQ : P \u2260 Q) (hQR : Q \u2260 R) (hPR : P \u2260 R) ( hlP : incident_with P l )\n    (hlQ : incident_with Q l) (hlR : \u00ac incident_with R l) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l := \nbegin\n  have i1 := @incidence.I\u2081 point line incident_with _,\n    rcases i1 P R hPR with \u27e8m, \u27e8hmP, hmR\u27e9, hmuPR\u27e9,\n    rcases i1 Q R hQR with \u27e8n, \u27e8hnQ, hnR\u27e9, hnuQR\u27e9,\n    refine \u27e8m, n, _, _, _, \u27e8P, hmP, hlP\u27e9, \u27e8Q, hnQ, hlQ\u27e9\u27e9,\n    any_goals { finish },\n    {\n      rcases i1 P Q hPQ with \u27e8_, _, hluPQ\u27e9,\n      intro hmn,\n      rw hmn at hmP,\n      rw hluPQ n \u27e8hmP, hnQ\u27e9 at hnR,\n      rw hluPQ l \u27e8hlP, hlQ\u27e9 at hlR,\n      exact hlR hnR,\n    },\nend\n\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l := \nbegin\n  have i2 := @incidence.I\u2082 point line incident_with _,\n  have i3 := @incidence.I\u2083 point line incident_with _,\n  rcases i3 with \n    \u27e8P, Q, R, hPQ, hQR, hPR, hPQR\u27e9,\n  by_cases hlPQ : incident_with P l \u2227 incident_with Q l,\n  {\n    rcases hlPQ with \u27e8hlP, hlQ\u27e9,\n    refine two_on_one_off _ _ _ _ _ _ _ hPQ hQR hPR hlP hlQ _,\n    finish,\n  },\n  {\n    rcases i2 l with \u27e8S, T, hST, hlS, hlT\u27e9,\n    rw not_and_distrib at hlPQ,\n    rcases hlPQ with h | h;\n    refine two_on_one_off _ _ _ _ _ _ _ hST _ _ hlS hlT h;\n    finish,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209145,"user_id":null,"body":"import Preloaded tactic\n\n-- Using 3.6.2\nlemma thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8P, Q, R, _, _, _, h\u27e9,\n  by_cases p : incident_with P l,\n  by_cases q : incident_with Q l,\n  by_cases r : incident_with R l,\n  exfalso,\n  apply h l,\n  tidy\nend\n\ntheorem thm_3p6p4 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l :=\nbegin\n  -- let P be a point not in l (by 3.6.2)\n  cases thm_3p6p2 point _ incident_with l with P h,\n  -- let Q and R be 2 (distinct) points in l\n  rcases @incidence.I\u2082 point _ incident_with _ l with \u27e8 Q, R, nqr, hql, hrl \u27e9,\n  -- P, Q and R are all distinct\n  have npq : P \u2260 Q := by {tidy},\n  have npr : P \u2260 R := by {tidy},\n  have h1 := _inst_1.I\u2081,\n  -- let PQ and PR be lines through P by Q and R, respectively\n  rcases h1 P Q npq with \u27e8 PQ, hpq, upq \u27e9,\n  rcases h1 P R npr with \u27e8 PR, hpr, upr \u27e9,\n  -- we need to show that these 3 lines are distinct\n  refine \u27e8 PQ, PR, _, _, _, \u27e8 Q, hpq.2, hql \u27e9, \u27e8 R, hpr.2, hrl \u27e9 \u27e9,\n  swap,\n  -- let QR be the unique line through Q and R\n  rcases h1 Q R nqr with \u27e8QR, hqr, uqr\u27e9,\n  -- that is, l\n  have lqr : l = QR := by {tidy},\n  -- if PQ = PR, then they must both be QR (or l)\n  intro e,\n  have pqr : PQ = QR := by {tidy},\n  -- but it is clear that neither PQ nor PR can be l, for P lie in both of them\n  tidy\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e88a132a220140028506a43":[{"id":209146,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l := by {\n  -- By I\u2083 there are three noncollinear points, call them A, B, C.\n  rcases @incidence.I\u2083 _ _ incident_with _ with \u27e8A, B, C, hAB, hBC, hAC, h3\u27e9,\n  -- By I\u2081 we can construct the lines AB, BC, and AC.\n  rcases @incidence.I\u2081 _ _ incident_with _ A B hAB with \u27e8AB, \u27e8hA_AB, hB_AB\u27e9, hAB_uniq\u27e9,\n  rcases @incidence.I\u2081 _ _ incident_with _ B C hBC with \u27e8BC, \u27e8hB_BC, hC_BC\u27e9, hBC_uniq\u27e9,\n  rcases @incidence.I\u2081 _ _ incident_with _ A C hAC with \u27e8AC, \u27e8hA_AC, hC_AC\u27e9, hAC_uniq\u27e9,\n  -- If P does not lie on one of these three, clearly we are done:\n  classical,\n  by_cases incident_with P AB, swap, { use AB },\n  by_cases incident_with P BC, swap, { use BC },\n  by_cases incident_with P AC, swap, { use AC },\n  -- but is it possible that P lies on all three? No, we reach a contradiction:\n  exfalso, suffices : AB = BC, by finish,\n  rcases @incidence.I\u2081 _ _ incident_with _ P B (by finish) with \u27e8PB, \u27e8hP_PB, hB_PB\u27e9, _\u27e9,\n  finish  -- PB = AB via hAB_uniq; PB = BC via hBC_uniq.\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209147,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  have A\u2081 := _inst_1.I\u2081,\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9,\n  rcases A\u2081 Q R hQR with \u27e8lQR, \u27e8Q_on_lQR, R_on_lQR\u27e9, _\u27e9,\n  rcases A\u2081 R S hRS with \u27e8lRS, \u27e8       _, S_on_lRS\u27e9, _\u27e9,\n  rcases A\u2081 Q S hQS with \u27e8lQS, _\u27e9,\n  by_cases P_lQR : incident_with P lQR, swap, use [lQR, P_lQR],\n  by_cases P_lQS : incident_with P lQS, swap, use [lQS, P_lQS],\n  by_cases hPQ   :               P = Q, { use lRS, specialize hQRS lRS, cc, },\n  exfalso,\n  apply hQRS lQR,\n  use [Q_on_lQR, R_on_lQR],\n  rcases A\u2081 P Q hPQ with \u27e8_, _, u\u27e9,\n  have := u lQR (by cc),\n  have := u lQS (by cc),\n  cc,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209148,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p1\n  (point line : Type) (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with]\n  (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\nbegin\n  cases hnpar with P hP,\n  use P,\n  split,\n  exact hP,\n  intros Q hQ,\n  by_contra,\n  have := incidence.I\u2081 Q P h,\n  {\n    rcases this with \u27e8 L, \u27e8 hL1, hL2\u27e9\u27e9,\n    simp at hL2,\n    have hl := hL2 l hQ.1 hP.1,\n    have hm := hL2 m hQ.2 hP.2,\n    rw [hl,hm] at hlm,\n    exact hlm rfl,\n  },\n  {\n    exact _inst_1,\n  },\nend\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  let I1:= _inst_1.I\u2081,\n  rcases _inst_1.I\u2083 with \u27e8A,B,C,\u27e8hAB,hBC,hAC,hABC\u27e9\u27e9,\n  by_cases P=A,\n  {\n    rcases I1 B C hBC with \u27e8lBC,\u27e8hlBC,hlBC'\u27e9\u27e9,\n    use lBC,\n    specialize hABC lBC,\n    cc,\n  },\n  {\n    rcases I1 A B hAB with \u27e8lAB,\u27e8hlAB,hlAB'\u27e9\u27e9,\n    by_cases incident_with P lAB,\n    {\n      rcases I1 A C hAC with \u27e8lAC,\u27e8hlAC,hlAC'\u27e9\u27e9,\n      use lAC,\n      have : lAB \u2260 lAC,\n      {\n        by_contra,\n        have := hABC lAB,\n        cc,\n      },\n      by_contra,\n      rcases thm_3p6p1 _ _ incident_with lAB lAC\n        this \u27e8 P,by tidy\u27e9 with \u27e8p, \u27e8 hp1,hp2\u27e9\u27e9,\n      have := hp2 P (by cc),\n      have := hp2 A (by cc),\n      cc,\n    },\n    {\n      exact \u27e8 lAB, h\u27e9,\n    }\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209149,"user_id":191,"body":"import Preloaded tactic\n\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\nlemma unique_from_points {point line : Type} (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] {P Q : point} {l m : line} (P_ne_Q : P \u2260 Q) (hPl : incident_with P l)\n  (hPm : incident_with P m) (hQl : incident_with Q l) (hQm : incident_with Q m) : l = m :=\nbegin\n  rcases I\u2081 incident_with P Q P_ne_Q with \u27e8l', -, l'_unique\u27e9,\n  have hll' := l'_unique l \u27e8hPl, hQl\u27e9,\n  have hml' := l'_unique m \u27e8hPm, hQm\u27e9,\n  cc\nend\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, Q_ne_R, R_ne_S, Q_ne_S, hQRS\u27e9,\n  rcases I\u2081 incident_with Q R Q_ne_R with \u27e8l, \u27e8hQl, hRl\u27e9, -\u27e9,\n  rcases I\u2081 incident_with R S R_ne_S with \u27e8m, \u27e8hRm, hSm\u27e9, -\u27e9,\n  rcases I\u2081 incident_with Q S Q_ne_S with \u27e8n, \u27e8hQn, hSn\u27e9, -\u27e9,\n  by_cases hPl : incident_with P l,\n  by_cases hPm : incident_with P m,\n  by_cases hPn : incident_with P n,\n  by_cases hPQ : P = Q, rw hPQ at *, exact \u27e8m, \u03bb h, hQRS m \u27e8h, hRm, hSm\u27e9\u27e9,\n  have hln := unique_from_points incident_with hPQ hPl hPn hQl hQn,\n  exfalso,\n  rw \u2190 hln at hSn,\n  exact hQRS l \u27e8hQl, hRl, hSn\u27e9,\n  use n,\n  use m,\n  use l\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209150,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l := \nbegin\n  have A\u2081:=_inst_1.I\u2081,\n  have A\u2082:=_inst_1.I\u2082,\n  have A\u2083:=_inst_1.I\u2083,  \n  rcases A\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9,\n  rcases A\u2081 Q R hQR with \u27e8l, \u27e8hQl, hRl\u27e9, hlQR\u27e9,\n  rcases A\u2081 R S hRS with \u27e8m, \u27e8hRm, hSm\u27e9, hmRS\u27e9,\n  rcases A\u2081 Q S hQS with \u27e8n, \u27e8hQn, hSn\u27e9, hnQS\u27e9,  \n  by_contradiction hc,\n  push_neg at hc,\n  by_cases hPQ : P=Q,\n  { rw hPQ at hc, exact (hQRS m) \u27e8hc m, hRm, hSm\u27e9 },\n  rcases A\u2081 P Q hPQ with \u27e8k, \u27e8hPk, hQk\u27e9, hkPQ\u27e9,\n  dsimp at *,\n  have t1 := hkPQ l \u27e8hc l, hQl\u27e9,\n  have t2 := hkPQ n \u27e8hc n, hQn\u27e9,\n  rw \u2190t2 at t1,\n  rw t1 at hRl,\n  exact (hQRS n) \u27e8hQn, hRl, hSn\u27e9,  \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209151,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen_locale classical\n\nsection \nvariables (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n\n\/-- every line has non-incident point. -\/\ntheorem thm_3p6p2 [inst : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin \n  obtain \u27e8P, Q, R, _, _, _, h\u27e9 := inst.I\u2083,\n  by_contradiction hi,\n  push_neg at hi,\n  exact h l \u27e8hi P, hi Q, hi R\u27e9,\nend \n\nlemma exists_distinct_point [inst : incidence point line incident_with] (P : point) : \n  \u2203 Q, P \u2260 Q :=\nbegin \n  obtain \u27e8Q, R, S, hQR, hRS, hQS, _\u27e9 := inst.I\u2083,\n  have ht : P \u2260 Q \u2228 P \u2260 R \u2228 P \u2260 S := by finish,\n  finish,\nend \n\n\/-- for any point, there exists non-incident line. -\/\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [inst : incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q R (by finish),\n  finish,\nend \n\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209152,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  classical,\n  by_contra a,\n  push_neg at a,\n  obtain \u27e8Q, R, S, b\u27e9 := @incidence.I\u2083 _ _ _ _inst_1,\n  by_cases c : P = Q,\n  obtain \u27e8l, d\u27e9 := @incidence.I\u2081 _ _ _ _inst_1 R S b.2.1,\n  apply b.2.2.2 l,\n  rw c at a,\n  exact \u27e8a l, d.1.1, d.1.2\u27e9,\n  obtain \u27e8l, d\u27e9 := @incidence.I\u2081 _ _ _ _inst_1 Q R b.1,\n  obtain \u27e8m, e\u27e9 := @incidence.I\u2081 _ _ _ _inst_1 Q S b.2.2.1,\n  obtain \u27e8n, f\u27e9 := @incidence.I\u2081 _ _ _ _inst_1 P Q c,\n  have g : l = m,\n  transitivity n,\n  apply f.2,\n  exact \u27e8a l, d.1.1\u27e9,\n  symmetry,\n  apply f.2,\n  exact \u27e8a m, e.1.1\u27e9,\n  rw g at d,\n  apply b.2.2.2 m,\n  exact \u27e8d.1.1, d.1.2, e.1.2\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209153,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, h3\u27e9,\n  have h := _inst_1.I\u2081, specialize h R S hRS, rcases h with \u27e8 l, hl0, hl1 \u27e9, simp at hl1,\n  have h := _inst_1.I\u2081, specialize h Q S hQS, rcases h with \u27e8 m, hm0, hm1 \u27e9, simp at hm1,\n  have h := _inst_1.I\u2081, specialize h Q R hQR, rcases h with \u27e8 n, hn0, hn1 \u27e9, simp at hn1,\n  by_cases hPQ : P = Q, { existsi l, have hl := h3 l, cc },\n  by_cases hPR : P = R, { existsi m, have hl := h3 m, cc },\n  by_cases hPS : P = S, { existsi n, have hl := h3 n, cc },\n  have h := _inst_1.I\u2081, specialize h P Q hPQ, rcases h with \u27e8i, hi0, hi1\u27e9, simp at hi1,\n  have h := _inst_1.I\u2081, specialize h P R hPR, rcases h with \u27e8j, hj0, hj1\u27e9, simp at hj1,\n  have h := _inst_1.I\u2081, specialize h P S hPS, rcases h with \u27e8k, hk0, hk1\u27e9, simp at hk1,\n  by_cases incident_with P l, swap, { existsi l, assumption },\n  by_cases incident_with P m, swap, { existsi m, assumption },\n  by_cases incident_with P n, swap, { existsi n, assumption },\n  have := h3 l, have := hn1 l, have := hj1 l, have := hj1 n, cc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209154,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, h3\u27e9,\n  have h := _inst_1.I\u2081, specialize h R S hRS, rcases h with \u27e8 l, hl0, hl1 \u27e9, simp at hl1,\n  have h := _inst_1.I\u2081, specialize h Q S hQS, rcases h with \u27e8 m, hm0, hm1 \u27e9, simp at hm1,\n  have h := _inst_1.I\u2081, specialize h Q R hQR, rcases h with \u27e8 n, hn0, hn1 \u27e9, simp at hn1,\n  by_cases hPQ : P = Q, { existsi l, have hl := h3 l, cc },\n  by_cases hPR : P = R, { existsi m, have hl := h3 m, cc },\n  by_cases hPS : P = S, { existsi n, have hl := h3 n, cc },\n  have h := _inst_1.I\u2081, specialize h P Q hPQ, rcases h with \u27e8i, hi0, hi1\u27e9, simp at hi1,\n  have h := _inst_1.I\u2081, specialize h P R hPR, rcases h with \u27e8j, hj0, hj1\u27e9, simp at hj1,\n  have h := _inst_1.I\u2081, specialize h P S hPS, rcases h with \u27e8k, hk0, hk1\u27e9, simp at hk1,\n  by_cases hlm : l = m, { have := hn1 l, have := h3 l, cc },\n  by_cases hln : l = n, { have := hm1 l, have := h3 l, cc },\n  by_cases hmn : m = n, { have := hl1 m, have := h3 l, cc },\n  by_cases incident_with P l, swap, { existsi l, assumption },\n  by_cases incident_with P m, swap, { existsi m, assumption },\n  by_cases incident_with P n, swap, { existsi n, assumption },\n  by_cases him : i = m, { have := hj1 l, have := hj1 n, cc },\n  by_cases hin : i = n, { have := hj1 l, have := hj1 n, cc },\n  by_cases hjl : j = l, { have := hj1 l, have := hj1 n, cc },\n  by_cases hjn : j = n, { have := hj1 l, have := hj1 n, cc },\n  by_cases hkl : k = l, { have := hj1 l, have := hj1 n, cc },\n  by_cases hkm : k = m, { have := hj1 l, have := hj1 n, cc },\n  have := hj1 l, cc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209155,"user_id":null,"body":"import Preloaded\n\ntheorem thm_3p6p5 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l :=\nbegin\n  -- introductory statements\n  cases _inst_1.I\u2083 with Q h, -- grr no rcases tactic\n  cases h with R h,\n  cases h with S h,\n  cases h with h1 h2,\n  cases h2 with h2 h3,\n  cases h3 with h3 h4,\n  -- Get the lines forming the triangle\n  have lem : \u2203! (lqr : line), incident_with Q lqr \u2227 incident_with R lqr,\n    apply _inst_1.I\u2081,\n    exact h1,\n  cases lem with lqr hl,\n  cases hl with hlqr hlqru,\n  have gen_s : \u00ac incident_with S lqr,\n    by_contradiction slqr,\n    specialize h4 lqr,\n    apply h4,\n    split, exact hlqr.left,\n    split, exact hlqr.right,\n    exact slqr,\n  have lem : \u2203! (lrs : line), incident_with R lrs \u2227 incident_with S lrs,\n    apply _inst_1.I\u2081,\n    exact h2,\n  cases lem with lrs hl,\n  cases hl with hlrs hlrsu,\n  have gen_q : \u00ac incident_with Q lrs,\n    by_contradiction qlrs,\n    specialize h4 lrs,\n    apply h4,\n    split, exact qlrs,\n    split, exact hlrs.left,\n    exact hlrs.right,\n  have lem : \u2203! (lqs : line), incident_with Q lqs \u2227 incident_with S lqs,\n    apply _inst_1.I\u2081,\n    exact h3,\n  cases lem with lqs hl,\n  cases hl with hlqs hlqsu,\n  have gen_r : \u00ac incident_with R lqs,\n    by_contradiction rlqs,\n    specialize h4 lqs,\n    apply h4,\n    split, exact hlqs.left,\n    split, exact rlqs,\n    exact hlqs.right,\n  -- Plan\n  -- if P=Q, then use RS\n  by_cases hpq: P=Q,\n    rw hpq,\n    existsi lrs,\n    exact gen_q,\n  -- else, P =\/= Q, so by I\u2081 there is a unique line joining them\n  have lem : \u2203! (lpq : line), incident_with P lpq \u2227 incident_with Q lpq,\n    apply _inst_1.I\u2081,\n    exact hpq,\n  cases lem with lpq hl,\n  cases hl with hlpq hlpqu,\n  -- if P \u2208 lqr, then use QS line\n  by_cases (incident_with P lqr),\n    existsi lqs,\n    by_contradiction pqs,\n    have same1 : lqr = lpq,\n      specialize hlpqu lqr,\n      apply hlpqu,\n      split, exact h,\n      exact hlqr.left,\n    have same2: lqs = lpq,\n      specialize hlpqu lqs,\n      apply hlpqu,\n      split, exact pqs,\n      exact hlqs.left,\n    -- but this is a contradiction because lpq = lqr contains p, q, r which violates h4\n    specialize h4 lpq,\n    apply h4,\n    split,\n      exact hlpq.right,\n      split,\n        rw \u2190 same1,\n        exact hlqr.right,\n        --\n        rw \u2190 same2,\n        exact hlqs.right,\n  -- else use lqr\n  specialize h4 lqr,\n  existsi lqr,\n  exact h,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e88a329c398e20033afc236":[{"id":209156,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) := \nbegin\n  rcases s.I\u2083 with \u27e8A,B,C,AnB,BnC,AnC,ncolin\u27e9,\n  have i := s.I\u2081,\n  rcases i A B AnB with \u27e8AB,\u27e8AB1,AB2\u27e9,uAB\u27e9,\n  rcases i B C BnC with \u27e8BC,\u27e8BC1,BC2\u27e9,uBC\u27e9,\n  rcases i A C AnC with \u27e8AC,\u27e8AC1,AC2\u27e9,uAC\u27e9,\n  use AB, use BC, use AC,\n  split, intro e, rw e at AB1, apply ncolin BC,\n  split, exact AB1, split, exact BC1, exact BC2,\n  split, intro e, rw e at BC1, apply ncolin AC,\n  split, exact AC1, split, exact BC1, exact AC2,\n  split, intro e, rw e at AB2, apply ncolin AC,\n  split, exact AC1, split, exact AB2, exact AC2,\n  intros P concur, have PnA : P\u2260A,\n  intro PeA, rw PeA at concur, apply ncolin BC,\n  split, exact concur.2.1, split, exact BC1, exact BC2,\n  rcases i P A PnA with \u27e8PA,\u27e8PA1,PA2\u27e9,uPA\u27e9,\n  have PAB := uPA AB (and.intro concur.1 AB1),\n  have PAC := uPA AC (and.intro concur.2.2 AC1),\n  rw PAB at AB2, rw PAC at AC2, apply ncolin PA, \n  split, exact PA2, split, exact AB2, exact AC2,\nend -- no need of excluded middle!","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209157,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\nbegin\n  have A\u2081 := _inst_1.I\u2081,\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9,\n  rcases A\u2081 Q R hQR with \u27e8lQR, \u27e8Q_on_lQR, R_on_lQR\u27e9, _\u27e9,\n  rcases A\u2081 R S hRS with \u27e8lRS, _\u27e9,\n  rcases A\u2081 Q S hQS with \u27e8lQS, _\u27e9,\n  use [lQR, lRS, lQS],\n  repeat { use by {intro, apply hQRS lRS, cc}, },\n  use by {intro, apply hQRS lQR, cc},\n  intros P _,\n  by_cases hPR : P = R, { apply hQRS lQS, cc, },\n  apply hQRS lQR,\n  use [Q_on_lQR, R_on_lQR],\n  rcases A\u2081 P R hPR with \u27e8_, _, u\u27e9,\n  have := u lQR (by cc),\n  have := u lRS (by cc),\n  cc,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209158,"user_id":null,"body":"import Preloaded tactic.basic\n\ntheorem thm_3p6p1\n  (point line : Type) (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with]\n  (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m :=\nbegin\n  cases hnpar with P hP,\n  use P,\n  split,\n  exact hP,\n  intros Q hQ,\n  by_contra,\n  have := incidence.I\u2081 Q P h,\n  {\n    rcases this with \u27e8 L, \u27e8 hL1, hL2\u27e9\u27e9,\n    simp only [and_imp] at hL2,\n    have hl := hL2 l hQ.1 hP.1,\n    have hm := hL2 m hQ.2 hP.2,\n    rw [hl,hm] at hlm,\n    exact hlm rfl,\n  },\n  {\n    exact _inst_1,\n  },\nend\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8P,Q,R,\u27e8hpq,hqr,hpr,hpqr\u27e9\u27e9,\n  let I1:=_inst_1.I\u2081,\n  rcases I1 P Q hpq with \u27e8lpq,\u27e8hlpq,hlpq'\u27e9\u27e9,\n  rcases I1 Q R hqr with \u27e8lqr,\u27e8hlqr,hlqr'\u27e9\u27e9,\n  rcases I1 P R hpr with \u27e8lpr,\u27e8hlpr,hlpr'\u27e9\u27e9,\n  use [lpq,lqr,lpr],\n  split,\n  {\n    by_contra,\n    have := hpqr lpq,\n    cc,\n  },\n  split,\n  {\n    by_contra,\n    have := hpqr lqr,\n    cc,\n  },\n  split,\n  {\n    by_contra,\n    have := hpqr lpq,\n    cc,\n  },\n  intro S,\n  by_cases hsp:S=P,\n  {\n    suffices : \u00ac incident_with S lqr,\n    cc,\n    have := hpqr lqr,\n    cc,\n  },\n  have :lpr\u2260 lpq,\n  {\n    by_contra,\n    have := hpqr lpr,\n    cc,\n  },\n  rcases thm_3p6p1 _ _ incident_with lpr lpq this \u27e8 P,by cc\u27e9\n   with \u27e8p, hp1,hp2\u27e9,\n  have hPp := hp2 P (by cc),\n  have := hp2 S,\n  finish,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209159,"user_id":191,"body":"import Preloaded tactic\n\nlemma I\u2081 {point line : Type} (incident_with : point \u2192 line \u2192 Prop) [incidence point line incident_with] :\n  \u2200 P Q, P \u2260 Q \u2192 \u2203! l, incident_with P l \u2227 incident_with Q l := incidence.I\u2081\n\nlemma unique_from_points {point line : Type} (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] {P Q : point} {l m : line} (P_ne_Q : P \u2260 Q) (hPl : incident_with P l)\n  (hPm : incident_with P m) (hQl : incident_with Q l) (hQm : incident_with Q m) : l = m :=\nbegin\n  rcases I\u2081 incident_with P Q P_ne_Q with \u27e8l', -, l'_unique\u27e9,\n  have hll' := l'_unique l \u27e8hPl, hQl\u27e9,\n  have hml' := l'_unique m \u27e8hPm, hQm\u27e9,\n  cc\nend\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8P, Q, R, P_ne_Q, Q_ne_R, P_ne_R, hPQR\u27e9,\n  rcases I\u2081 incident_with P Q P_ne_Q with \u27e8l, \u27e8hPl, hQl\u27e9, -\u27e9,\n  rcases I\u2081 incident_with Q R Q_ne_R with \u27e8m, \u27e8hQm, hRm\u27e9, -\u27e9,\n  rcases I\u2081 incident_with P R P_ne_R with \u27e8n, \u27e8hPn, hRn\u27e9, -\u27e9,\n  have hlm : l \u2260 m, intro h, rw h at *,\n    have hmn := unique_from_points incident_with P_ne_R hPl hPn hRm hRn,\n    rw hmn at *, exact hPQR n \u27e8hPn, hQm, hRm\u27e9,\n  have hln : l \u2260 n, intro h, rw h at *,\n    have hnm := unique_from_points incident_with Q_ne_R hQl hQm hRn hRm,\n    exact hlm hnm,\n  have hmn : m \u2260 n, intro h, rw h at *,\n    have ln := unique_from_points incident_with P_ne_Q hPl hPn hQl hQm,\n    exact hln ln,\n  classical,\n  by_contradiction h,\n  push_neg at h,\n  specialize h l m n hlm hmn hln,\n  rcases h with \u27e8S, hSl, hSm, hSn\u27e9,\n  by_cases hPS : P = S,\n  rw hPS at *,\n  have lm := unique_from_points incident_with P_ne_Q hSl hSm hQl hQm,\n  exact hlm lm,\n  have ln := unique_from_points incident_with hPS hPl hPn hSl hSn,\n  exact hln ln\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209160,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) := \nbegin\n  have A\u2081:=_inst_1.I\u2081,\n  have A\u2082:=_inst_1.I\u2082,\n  have A\u2083:=_inst_1.I\u2083,  \n  rcases A\u2083 with \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9,\n  rcases A\u2081 Q R hQR with \u27e8l, \u27e8hQl, hRl\u27e9, hlQR\u27e9,\n  rcases A\u2081 R S hRS with \u27e8m, \u27e8hRm, hSm\u27e9, hmRS\u27e9,\n  rcases A\u2081 Q S hQS with \u27e8n, \u27e8hQn, hSn\u27e9, hnQS\u27e9,  \n  have hlm : l \u2260 m,\n  { intros hlm, rw hlm at hQl, exact hQRS m \u27e8hQl, hRm, hSm\u27e9 },\n  have hmn : m \u2260 n,\n  { intros hmn, rw hmn at hRm, exact hQRS n \u27e8hQn, hRm, hSn\u27e9 },\n  have hln : l \u2260 n,\n  { intros hln, rw hln at hRl, exact hQRS n \u27e8hQn, hRl, hSn\u27e9 },\n  use [l, m, n, hlm, hmn, hln],\n  rintros P \u27e8hPl, hPm, hPn\u27e9,\n  have hPQ : P \u2260 Q,\n  { intros hPQ, rw hPQ at hPm, exact hQRS m \u27e8hPm, hRm, hSm\u27e9 },\n  rcases A\u2081 P Q hPQ with \u27e8k, \u27e8hPk, hQk\u27e9, hkPQ\u27e9,\n  have t1 := hkPQ l \u27e8hPl, hQl\u27e9,\n  have t2 := hkPQ n \u27e8hPn, hQn\u27e9,\n  rw \u2190t2 at t1,\n  rw t1 at hRl,\n  exact (hQRS n) \u27e8hQn, hRl, hSn\u27e9,  \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209161,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen_locale classical\n\nsection \nvariables (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n\ntheorem thm_3p6p6 [inst : incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) := \nbegin \n  obtain \u27e8Q, R, S, _, _, _, h\u27e9 := inst.I\u2083,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q R (by finish),\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 R S (by finish),\n  obtain \u27e8n, hn, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q S (by finish),\n  use [l, m, n],\n  use [(by finish : l \u2260 m), (by finish : m \u2260 n), (by finish : l \u2260 n)],\n  intros P h, \n  obtain \u27e8l', hl', hl_unique'\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q (by finish),\n  obtain \u27e8m', hm', hm_unique'\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  obtain \u27e8n', hn', hn_unique'\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P S (by finish),\n  finish,\nend \n\nend \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209162,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [i : incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\nbegin\n  -- First, summon three lines from the void\n  obtain \u27e8P, Q, R, pq, qr, pr, h\u27e9 := i.I\u2083,\n  have I\u2081 := i.I\u2081,\n  obtain \u27e8l\u2081, \u27e8P\u2081, Q\u2081\u27e9, -\u27e9 := I\u2081 P Q pq,\n  obtain \u27e8l\u2082, \u27e8Q\u2082, R\u2082\u27e9, -\u27e9 := I\u2081 Q R qr,\n  obtain \u27e8l\u2083, \u27e8P\u2083, R\u2083\u27e9, -\u27e9 := I\u2081 P R pr,\n  obtain \u27e8e\u2081\u2082, e\u2082\u2083, e\u2081\u2083\u27e9 : l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083,\n  { simp only [\u2190 not_or_distrib],\n    push_neg at h,\n    rintro (rfl | rfl | rfl); finish, },\n  use [l\u2081, l\u2082, l\u2083, e\u2081\u2082, e\u2082\u2083, e\u2081\u2083],\n  -- Next, show that these lines have no common point\n  rintro X \u27e8X\u2081, X\u2082, X\u2083\u27e9,\n  by_cases e : X = P \u2228 X = Q \u2228 X = R,\n  { rcases e with rfl | rfl | rfl; finish, },\n  { push_neg at e,\n    rcases e with \u27e8XP, XQ, XR\u27e9,\n    obtain \u27e8k, \u27e8-, -\u27e9, hk\u27e9 := I\u2081 X P XP,\n    finish [hk l\u2081 \u27e8X\u2081, P\u2081\u27e9, hk l\u2083 \u27e8X\u2083, P\u2083\u27e9], },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209163,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\nbegin\n  rcases incidence.I\u2083 with \u27e8A : point, B, C, hAB, hBC, hAC, h : \u2200 (l : line), \u00ac(incident_with A l \u2227 _)\u27e9,\n  obtain \u27e8l\u2081 : line, \u27e8hl\u2081A, hl\u2081B\u27e9, hl\u2081\u27e9 := incidence.I\u2081 A B hAB,\n  obtain \u27e8l\u2082 : line, \u27e8hl\u2082B, hl\u2082C\u27e9, hl\u2082\u27e9 := incidence.I\u2081 B C hBC,\n  obtain \u27e8l\u2083 : line, \u27e8hl\u2083A, hl\u2083C\u27e9, hl\u2083\u27e9 := incidence.I\u2081 A C hAC,\n  simp at hl\u2081 hl\u2082 hl\u2083,\n  use [l\u2081, l\u2082, l\u2083],\n  repeat { assumption }, -- clear metavariables\n  split,\n  { intro x,\n    rw x at *,\n    exact h l\u2082 (by tauto),\n  },\n  split,\n  { intro x,\n    rw x at *,\n    exact h l\u2083 (by tauto),\n  },\n  obtain hl\u2081l\u2083 : l\u2081 \u2260 l\u2083 :=\n    by { intro x,\n      rw x at *,\n      exact h l\u2083 (by tauto),\n    },\n  split,\n  exact hl\u2081l\u2083,\n\n  intros P hP,\n  have : P \u2260 A := by {\n    intro x,\n    rw x at hP,\n    exact h l\u2082 \u27e8hP.2.1, hl\u2082B, hl\u2082C\u27e9,\n  },\n  obtain \u27e8l : line, \u27e8hlP, hlA\u27e9, hl\u27e9 := incidence.I\u2081 P A this,\n  repeat { assumption, }, -- again, remove metavariables\n  simp at hl,\n  have l\u2081l := hl l\u2081 (by tauto) (by tauto),\n  have l\u2083l := hl l\u2083 (by tauto) (by tauto),\n  rw [l\u2081l, l\u2083l] at hl\u2081l\u2083,\n  exact hl\u2081l\u2083 rfl,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209164,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8A, B, C, hAB, hBC, hAC, h\u27e9,\n  have h := _inst_1.I\u2081, specialize h A B hAB, rcases h with \u27e8 AB, AB0, AB1 \u27e9, simp at AB1,\n  have h := _inst_1.I\u2081, specialize h A C hAC, rcases h with \u27e8 AC, AC0, AC1 \u27e9, simp at AC1,\n  have h := _inst_1.I\u2081, specialize h B C hBC, rcases h with \u27e8 BC, BC0, BC1 \u27e9, simp at BC1,\n  use [AB, AC, BC], split; [finish, split]; [finish, split], finish, intro P,\n  by_cases incident_with P AB, swap, { finish },\n  by_cases incident_with P BC, swap, { finish },\n  by_cases incident_with P AC, swap, { finish },\n  have h := _inst_1.I\u2081, specialize h P A (by finish), rcases h with \u27e8 PA, PA0, PA1 \u27e9, simp at PA1,\n  have h := _inst_1.I\u2081, specialize h P B (by finish), rcases h with \u27e8 PB, PB0, PB1 \u27e9, simp at PB1,\n  have h := _inst_1.I\u2081, specialize h P C (by finish), rcases h with \u27e8 PC, PC0, PC1 \u27e9, simp at PC1,\n  finish\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209165,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p6 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [ax : incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) :=\n    begin\n  rcases ax.I\u2083 with \u27e8P, Q, R, hPQ, hQR, hPR, h\u27e9,\n  have := ax.1, rcases this P Q hPQ with \u27e8l\u2081, \u27e8\u27e8hPl\u2081, hQl\u2081\u27e9, hPQ'\u27e9\u27e9,\n  have := ax.1, rcases this Q R hQR with \u27e8l\u2082, \u27e8\u27e8hQl\u2082, hRl\u2082\u27e9, hQR'\u27e9\u27e9,\n  have := ax.1, rcases this P R hPR with \u27e8l\u2083, \u27e8\u27e8hPl\u2083, hRl\u2083\u27e9, hPR'\u27e9\u27e9,\n  use [l\u2081, l\u2082, l\u2083],\n  split, intro h12, apply h l\u2082, rw h12 at hPl\u2081, use [hPl\u2081, hQl\u2082, hRl\u2082],\n  split, intro h23, apply h l\u2083, rw h23 at hQl\u2082, use [hPl\u2083, hQl\u2082, hRl\u2083],\n  split, intro h13, apply h l\u2081, rw \u2190h13 at hRl\u2083, use [hPl\u2081, hQl\u2081, hRl\u2083],\n  intros S hS,\n  by_cases HPS : P = S,\n    rw \u2190HPS at hS,\n    have h23 := hPR' l\u2082 \u27e8hS.2.1, hRl\u2082\u27e9,\n    have h21 := hPQ' l\u2082 \u27e8hS.2.1, hQl\u2082\u27e9,\n    apply h l\u2081,\n    split, assumption,\n    split, assumption,\n    rw \u2190h21, rw h23, assumption,\n  have := ax.1, rcases this P S HPS with \u27e8l\u2084, \u27e8\u27e8hPl, hSl\u27e9,hPS'\u27e9\u27e9,\n  have h34 := hPS' l\u2083 \u27e8hPl\u2083, hS.2.2\u27e9, rw \u2190h34 at hPS',\n  have h13 := hPS' l\u2081 \u27e8hPl\u2081, hS.1\u27e9, rw h13 at hQl\u2081,\n  exact h l\u2083 \u27e8hPl\u2083, hQl\u2081, hRl\u2083\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e88a4ee3820e90017210927":[{"id":209166,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  have A\u2081 := _inst_1.I\u2081,\n  rcases _inst_1.I\u2083 with \u27e8Q, R, S, hQR, _, _, hQRS\u27e9,\n  cases A\u2081 Q R hQR with lQR,\n  by_cases hPQ : P = Q, { use [R, S], rw hPQ, exact hQRS, },\n  by_cases P_on_lQR : incident_with P lQR,\n  use [Q, S], intros l _, apply hQRS l,   rcases A\u2081 P Q hPQ with \u27e8_, _, u\u27e9,\n  swap,\n  use [Q, R], intros l _, apply P_on_lQR, rcases A\u2081 Q R hQR with \u27e8_, _, u\u27e9,\n  repeat { have := u lQR (by cc), have := u l (by cc), cc, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209167,"user_id":null,"body":"import Preloaded tactic.basic\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin\n  rcases _inst_1.I\u2083 with \u27e8A,B,C,\u27e8hab,hbc,hac,habc\u27e9\u27e9,\n  let I1 := _inst_1.I\u2081,\n  rcases I1 A B hab with \u27e8lab,hlab1,hlab2\u27e9,\n  rcases I1 A C hac with \u27e8lac,hlac1,hlac2\u27e9,\n  rcases I1 B C hbc with \u27e8lbc,hlbc1,hlbc2\u27e9,\n  by_cases hpa : P=A,\n  {\n    use [B,C], rwa hpa,\n  },\n  by_cases hplab : incident_with P lab,\n  {\n    use [A,C],\n    intro l,\n    by_contra,\n    have : l=lac := hlac2 l (by cc),\n    rcases I1 P A hpa with \u27e8 lpa , hlpa1,hlpa2\u27e9,\n    have : l = lpa := hlpa2 l (by cc),\n    have : lab = lpa := hlpa2 lab (by cc),\n    have := habc l,\n    cc,\n  },\n  {\n    use [A,B],\n    intro l,\n    by_contra,\n    have : l = lab := hlab2 l (by cc),\n    cc,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209168,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin\n  have A\u2081:=_inst_1.I\u2081,\n  have A\u2082:=_inst_1.I\u2082,\n  have A\u2083:=_inst_1.I\u2083,  \n  rcases A\u2083 with \u27e8S, T, U, hST, hTU, hSU, hSTU\u27e9,\n  by_contradiction hc,\n  push_neg at hc,\n  have hPS : P \u2260 S,\n  { intros hPS, \n    rw hPS at hc, \n    cases hc T U with k hk, \n    exact hSTU k hk },     \n  rcases A\u2081 P S hPS with \u27e8a, \u27e8hPa, hSa\u27e9, haPS\u27e9,\n  rcases hc S T with \u27e8l, hPl, hSl, hTl\u27e9,\n  have hal : l = a := haPS l \u27e8hPl, hSl\u27e9,\n  rcases hc S U with \u27e8n, hPn, hSn, hTn\u27e9,\n  have han : n = a := haPS n \u27e8hPn, hSn\u27e9,\n  have hnl : n = l := by simp [hal, han],\n  rw hnl at hTn,\n  exact hSTU l \u27e8hSl, hTl, hTn\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209169,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen_locale classical\n\nsection \nvariables (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n\n\/-- every line has non-incident point. -\/\ntheorem thm_3p6p2 [inst : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin \n  obtain \u27e8P, Q, R, _, _, _, h\u27e9 := inst.I\u2083,\n  by_contradiction hi,\n  push_neg at hi,\n  exact h l \u27e8hi P, hi Q, hi R\u27e9,\nend \n\n\nlemma exists_distinct_point [inst : incidence point line incident_with] (P : point) : \n  \u2203 Q, P \u2260 Q :=\nbegin \n  obtain \u27e8Q, R, S, hQR, hRS, hQS, _\u27e9 := inst.I\u2083,\n  have ht : P \u2260 Q \u2228 P \u2260 R \u2228 P \u2260 S := by finish,\n  finish,\nend \n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [inst : incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  use [Q, R],\n  finish,\nend \n\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209170,"user_id":null,"body":"import Preloaded\n\nopen classical\nlocal attribute [instance] prop_decidable\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  cases incidence.I\u2083 with P' h,\n  cases h with Q h,\n  cases h with R h,\n  cases h with P'_ne_Q h,\n  cases h with Q_ne_R h,\n  cases h with P'_ne_R h,\n  cases decidable.em (P = P'),\n  case or.inl : P_eq_P' {\n    rw P_eq_P',\n    existsi Q,\n    existsi R,\n    intro l,\n    apply h,\n  },\n  case or.inr : P_ne_P' {\n    cases incidence.I\u2081 P P' P_ne_P' with L a,\n    have, from h L,\n    cases a with P_on_L_and_P'_on_L L_unique,\n    cases P_on_L_and_P'_on_L with P_on_L P'_on_L,\n    cases decidable.em (incident_with Q L \u2227 incident_with R L),\n    case or.inl : Q_on_L_and_R_on_L {\n      exfalso,\n      apply this,\n      split,\n      exact P'_on_L,\n      assumption,\n    },\n    case or.inr : not_Q_on_L_and_R_on_L {\n      cases (decidable.not_and_iff_or_not _ _).1 not_Q_on_L_and_R_on_L,\n      case or.inl : not_Q_on_L {\n        existsi P',\n        existsi Q,\n        intros L' on_all,\n        cases on_all with P_on_L' on_all,\n        cases on_all with P'_on_L' Q_on_L',\n        have L'_eq_L, from L_unique L' \u27e8P_on_L', P'_on_L'\u27e9,\n        apply not_Q_on_L,\n        rw L'_eq_L at Q_on_L',\n        assumption,\n      },\n      case or.inr : not_R_on_L {\n        existsi P',\n        existsi R,\n        intros L' on_all,\n        cases on_all with P_on_L' on_all,\n        cases on_all with P'_on_L' R_on_L',\n        have L'_eq_L, from L_unique L' \u27e8P_on_L', P'_on_L'\u27e9,\n        apply not_R_on_L,\n        rw L'_eq_L at R_on_L',\n        assumption,\n      }\n    },\n    apply_instance,\n  },\n  apply_instance,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209171,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin\n  rcases _inst_1.I\u2083 with \u27e8A, B, C, hAB, hBC, hAC, h\u27e9,\n  have h := _inst_1.I\u2081, specialize h A B hAB, rcases h with \u27e8AB, AB0, AB1\u27e9, simp at AB1,\n  have h := _inst_1.I\u2081, specialize h A C hAC, rcases h with \u27e8AC, AC0, AC1\u27e9, simp at AC1,\n  have h := _inst_1.I\u2081, specialize h B C hBC, rcases h with \u27e8BC, BC0, BC1\u27e9, simp at BC1,\n  by_cases hPA : P = A, { existsi [B, C], intro l, have := h l, cc },\n  by_cases hPB : P = B, { existsi [A, C], intro l, have := h l, cc },\n  by_cases hPC : P = C, { existsi [A, B], intro l, have := h l, cc },\n  have h := _inst_1.I\u2081, specialize h P A hPA, rcases h with \u27e8PA, PA0, PA1\u27e9, simp at PA1,\n  have h := _inst_1.I\u2081, specialize h P B hPB, rcases h with \u27e8PB, PB0, PB1\u27e9, simp at PB1,\n  have h := _inst_1.I\u2081, specialize h P C hPC, rcases h with \u27e8PC, PC0, PC1\u27e9, simp at PC1,\n  by_cases hPAB : incident_with P AB, swap, {\n    existsi [A, B], intros l _, have := PA1 l, have := PB1 l, have := AB1 l, cc\n  },\n  by_cases hPAC : incident_with P AC, swap, {\n    existsi [A, C], intros l _, have := PA1 l, have := PC1 l, have := AC1 l, cc\n  },\n  by_cases hPBC : incident_with P BC, swap, {\n    existsi [B, C], intros l _, have := PB1 l, have := PC1 l, have := BC1 l, cc\n  },\n have := PA1 AB, have := PA1 AC, have := h PA, cc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209172,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p3 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (S : point) :\n  \u2203 l m, l \u2260 m \u2227 incident_with S l \u2227 incident_with S m :=\nbegin\n  rcases geo.I\u2083 with \u27e8P, Q, R, pneq, qner, pner , h\u2081\u27e9,\n  have k\u2081, from geo.I\u2081,\n  rcases k\u2081 P Q pneq with \u27e8l, \u27e8inc_pl, inc_ql\u27e9, h\u2082\u27e9,\n  rcases k\u2081 P R pner with \u27e8m, \u27e8inc_pm, inc_rm\u27e9, h\u2083\u27e9,\n  have k\u2083 : l \u2260 m, from \u03bb lm, h\u2081 l \u27e8inc_pl, inc_ql, lm.symm \u25b8 inc_rm\u27e9,\n  by_cases h : P = S,\n  { exact h \u25b8 \u27e8l, m, k\u2083, inc_pl, inc_pm\u27e9, },\n  { rcases k\u2081 P S h with \u27e8c, \u27e8inc_pc, inc_sc\u27e9, h\u2084\u27e9,\n    have h\u2085 : \u00ac(incident_with S l \u2227 incident_with S m), from\n      \u03bb k\u2082, k\u2083 (eq.trans (h\u2084 l \u27e8inc_pl, k\u2082.left\u27e9) (h\u2084 m \u27e8inc_pm, k\u2082.right\u27e9).symm),\n    cases (not_and_distrib.mp h\u2085) with ninc_sl ninc_sm,\n    { rcases k\u2081 S Q (\u03bb k, ninc_sl $ k.symm \u25b8 inc_ql) with \u27e8d, \u27e8inc_sd, inc_qd\u27e9, h\u2086\u27e9,\n      exact \u27e8c, d, \u03bb cd, ninc_sl $ (h\u2082 d \u27e8cd \u25b8 inc_pc, inc_qd\u27e9) \u25b8 inc_sd, inc_sc, inc_sd\u27e9, },\n    { rcases k\u2081 S R (\u03bb k, ninc_sm $ k.symm \u25b8 inc_rm) with \u27e8d, \u27e8inc_sd, inc_rd\u27e9, h\u2086\u27e9,\n      exact \u27e8c, d, \u03bb cd, ninc_sm $ (h\u2083 d \u27e8cd \u25b8 inc_pc, inc_rd\u27e9) \u25b8 inc_sd, inc_sc, inc_sd\u27e9, }, },\nend  \n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  rcases thm_3p6p3 _ _ incident_with P with \u27e8m, n, mnen, inc_pm, inc_pn\u27e9,\n  have k\u2082 := geo.I\u2082,\n  obtain \u27e8Q, pneq, inc_qm\u27e9 : \u2203 Q, (P \u2260 Q) \u2227 incident_with Q m,\n  { rcases k\u2082 m with \u27e8Q\u2081, Q\u2082, q1neq2, inc_q1m, incq2m\u27e9,\n    by_cases h : P = Q\u2081,\n    { use Q\u2082, finish, },\n    { use Q\u2081, finish }, },\n  obtain \u27e8R, pner, inc_rn\u27e9 : \u2203 R, (P \u2260 R) \u2227 incident_with R n,\n  { rcases k\u2082 n with \u27e8R\u2081, R\u2082, _, _, _\u27e9,\n    by_cases h : P = R\u2081,\n    { use R\u2082, finish },\n    { use R\u2081, finish }, },\n  clear k\u2082, use [Q, R], intros l h\u2081, have k\u2081 := geo.I\u2081,\n  by_cases h\u2082 : l = m,\n  { rcases k\u2081 P R pner with \u27e8w, \u27e8inc_pw, inc_rw\u27e9, uni_w\u27e9, finish, },\n  { rcases k\u2081 P Q pneq with \u27e8w, \u27e8inc_pw, inc_qw\u27e9, uni_w\u27e9, finish, }, \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209173,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin\n  have i1 := @incidence.I\u2081 point line incident_with _,\n  have i3 := @incidence.I\u2083 point line incident_with _,\n  rcases i3 with \n    \u27e8Q, R, S, hQR, hRS, hQS, hQRS\u27e9,\n  rcases i1 Q R hQR with \n    \u27e8l, \u27e8hlQ, hlR\u27e9, uQR\u27e9,\n  rcases i1 R S hRS with \n    \u27e8m, \u27e8hmR, hmS\u27e9, uRS\u27e9,\n  rcases i1 Q S hQS with \n    \u27e8n, \u27e8hnQ, hnS\u27e9, uQS\u27e9,\n  by_cases hPQ : P = Q,\n  {\n    rw \u2190 hPQ at hQRS,\n    exact \u27e8R, S, hQRS\u27e9,\n  },\n  {\n    rcases i1 P Q hPQ with \n      \u27e8r, \u27e8hrP, hrQ\u27e9, uPQ\u27e9,\n    by_cases hlP : incident_with P l,\n    {\n      use [Q, S],\n      rintros s \u27e8hsP, hsQ, hsS\u27e9,\n      rw uPQ s \u27e8hsP, hsQ\u27e9 at hsS,\n      rw \u2190 uPQ l \u27e8hlP, hlQ\u27e9 at hsS,\n      exact hQRS l \u27e8hlQ, hlR, hsS\u27e9,\n    },\n    {\n      use [Q, R],\n      rintros s \u27e8hsP, hsQ, hsR\u27e9,\n      rw \u2190 uQR s \u27e8hsQ, hsR\u27e9 at hlP,\n      rw uPQ s \u27e8hsP, hsQ\u27e9 at hlP,\n      exact hlP hrP,\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209174,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  -- let A, B and C be noncollinear\n  rcases _inst_1.I\u2083 with \u27e8A, B, C, nab, nbc, nac, h\u27e9,\n  -- if P equals A or B, were are done\n  by_cases pa : P = A,\n  { exact \u27e8B, C, by {rwa pa}\u27e9 },\n  by_cases bp : B = P,\n  { refine \u27e8A, C, _\u27e9, intros l a, apply h l, tidy },\n  -- let AB be the line through A and B\n  have h1 := _inst_1.I\u2081,\n  rcases h1 A B nab with \u27e8AB, hab, uab\u27e9,\n  by_cases pAB : incident_with P AB,\n  swap 2,\n  -- if P \u2209 AB, then P, A, B can't be collinear\n  { refine \u27e8A, B, _\u27e9, intros l a, apply pAB,\n    -- for there is exactly one line through AB and P is not in it\n    have : l = AB := uab l a.2,\n    rw this at a, exact a.1\n  },\n  -- else, suppose P, B and C are collinear (at l)\n  refine \u27e8B, C, _\u27e9, intros l a,\n  -- then A, B, C are also collinear\n  apply h l, refine \u27e8_, a.2\u27e9,\n  -- for l must equal BP\n  rcases h1 B P bp with \u27e8BP, hbp, ubp\u27e9,\n  have : l = BP := ubp l \u27e8a.2.1, a.1\u27e9,\n  rw this,\n  -- and so does AB\n  have : AB = BP := ubp AB \u27e8hab.2, pAB\u27e9,\n  rw \u2190this, exact hab.1\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209175,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p7 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  rcases _inst_1.I\u2083 with \u27e8S,Q,R,_,_,_,h\u27e9,\n  cases classical.em (P=S) with PS PnS,\n  use Q, use R, rw \u2190 PS at h, exact h,\n  cases classical.em (\u2203l: line, incident_with P l \u2227 incident_with Q l \u2227 incident_with S l) with colin_PQS ncolin_PQS,\n  use R, use S, intros l lPRS,\n  cases colin_PQS with m mPQS,\n  have i := _inst_1.I\u2081, replace i := i P S PnS,\n  cases i with n i, replace i := i.2,\n  have ln := i l (and.intro lPRS.1 lPRS.2.2),\n  have mn := i m (and.intro mPQS.1 mPQS.2.2),\n  rw ln at lPRS, rw mn at mPQS,\n  exact h n (and.intro lPRS.2.2 (and.intro mPQS.2.1 lPRS.2.1)),\n  use Q, use S, intros l lPQS, exact ncolin_PQS (exists.intro l lPQS),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e88a6657912b20021d49d18":[{"id":209176,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  have A\u2081 := _inst_1.I\u2081,\n  rcases _inst_1.I\u2083 with \u27e8T, R, S, hTR, _, _, hTRS\u27e9,\n  rcases A\u2081 T R hTR with \u27e8lTR, _\u27e9,\n  rcases A\u2081 P Q hPQ with \u27e8lPQ, _, u\u27e9,\n  have := hTRS lPQ,\n  by_cases incident_with T lPQ,\n  by_cases incident_with R lPQ,\n  use S, rotate, use R, rotate, use T, \n  repeat { intros l _, have := u lPQ (by cc), have := u l (by cc), cc, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209177,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  have := @incidence.I\u2081 point line incident_with _inst_1 P Q hPQ,\n  cases this with l hl,\n  by_contra,\n  push_neg at h,\n  have : \u2200 R : point, incident_with R l,\n  intro R,\n  cases h R with l' hl',\n  have : l'=l,\n  apply hl.2,\n  exact \u27e8 hl'.1,hl'.2.1\u27e9 ,\n  rw \u2190 this,\n  exact hl'.right.right,\n  cases @incidence.I\u2083 point line incident_with _inst_1 with A ha,\n  cases ha with B hb,\n  cases hb with C hc,\n  apply hc.right.right.right l,\n  exact \u27e8 this A, this B, this C \u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209178,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin\n  have A\u2081:=_inst_1.I\u2081,\n  have A\u2082:=_inst_1.I\u2082,\n  have A\u2083:=_inst_1.I\u2083,  \n  by_contradiction hc,\n  push_neg at hc,\n  rcases A\u2081 P Q hPQ with \u27e8k, \u27e8hPk, hQk\u27e9, hPQk\u27e9,\n  rcases A\u2083 with \u27e8S, T, U, hST, hTU, hSU, hSTU\u27e9,\n  rcases hc S with \u27e8l, hPl, hQl, hSl\u27e9,\n  rw hPQk l \u27e8hPl, hQl\u27e9 at hSl,\n  rcases hc T with \u27e8m, hPm, hQm, hTm\u27e9,\n  rw hPQk m \u27e8hPm, hQm\u27e9 at hTm,  \n  rcases hc U with \u27e8n, hPn, hQn, hUn\u27e9,\n  rw hPQk n \u27e8hPn, hQn\u27e9 at hUn,  \n  exact hSTU k \u27e8hSl, hTm, hUn\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209179,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen_locale classical\n\nsection \nvariables (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n\ntheorem thm_3p6p1 [inst : incidence point line incident_with] \n  (l m : line) (hlm : l \u2260 m)\n  (hnpar : \u2203 P, incident_with P l \u2227 incident_with P m) :\n  \u2203! P, incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8P, hl, hm\u27e9 := hnpar,\n  use [P, hl, hm],\n  rintros P' \u27e8hl', hm'\u27e9,\n  classical,\n  by_contradiction hneq,\n  obtain \u27e8n, _, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P P' (by cc),\n  have := hn_unique l \u27e8hl, hl'\u27e9,\n  have := hn_unique m \u27e8hm, hm'\u27e9,\n  cc,\nend \n\ntheorem thm_3p6p2 [inst : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin \n  obtain \u27e8P, Q, R, _, _, _, h\u27e9 := inst.I\u2083,\n  by_contradiction hi,\n  push_neg at hi,\n  exact h l \u27e8hi P, hi Q, hi R\u27e9,\nend \n\n\nlemma exists_distinct_point [inst : incidence point line incident_with] (P : point) : \n  \u2203 Q, P \u2260 Q :=\nbegin \n  obtain \u27e8Q, R, S, hQR, hRS, hQS, _\u27e9 := inst.I\u2083,\n  have ht : P \u2260 Q \u2228 P \u2260 R \u2228 P \u2260 S := by finish,\n  finish,\nend \n\ntheorem thm_3p6p3 [inst : incidence point line incident_with] (P : point) : \n  \u2203 l m, l \u2260 m \u2227 incident_with P l \u2227 incident_with P m := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  finish,\nend \n\ntheorem thm_3p6p4 \n  [inst : incidence point line incident_with] (l : line) :\n  \u2203 m n, l \u2260 m \u2227 m \u2260 n \u2227 l \u2260 n \u2227 (\u2203 P, incident_with P m \u2227 incident_with P l) \u2227\n    \u2203 P, incident_with P n \u2227 incident_with P l := \nbegin \n  obtain \u27e8P, hP\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8Q, R, hQR, hl\u27e9 := let I\u2082 := inst.I\u2082 in I\u2082 l,\n  obtain \u27e8l', hl', hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q R (by finish),\n  rcases (hl_unique l hl : l = l') with rfl, clear hl',\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q (by finish),\n  obtain \u27e8n, hn, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  use [m, n],\n  use [(by finish : l \u2260 m), (by finish : m \u2260 n), (by finish : l \u2260 n)], \n  exact \u27e8\u27e8Q, (by cc)\u27e9, \u27e8R, (by cc)\u27e9\u27e9,\nend \n\ntheorem thm_3p6p5 [inst : incidence point line incident_with] (P : point) :\n  \u2203 l, \u00acincident_with P l := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q R (by finish),\n  finish,\nend \n\ntheorem thm_3p6p6 [inst : incidence point line incident_with] :\n  \u2203 l\u2081 l\u2082 l\u2083, l\u2081 \u2260 l\u2082 \u2227 l\u2082 \u2260 l\u2083 \u2227 l\u2081 \u2260 l\u2083 \u2227 \u2200 P, \u00ac(incident_with P l\u2081 \u2227\n    incident_with P l\u2082 \u2227 incident_with P l\u2083) := \nbegin \n  obtain \u27e8Q, R, S, _, _, _, h\u27e9 := inst.I\u2083,\n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q R (by finish),\n  obtain \u27e8m, hm, hm_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 R S (by finish),\n  obtain \u27e8n, hn, hn_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 Q S (by finish),\n  use [l, m, n],\n  use [(by finish : l \u2260 m), (by finish : m \u2260 n), (by finish : l \u2260 n)],\n  intros P h, \n  obtain \u27e8l', hl', hl_unique'\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q (by finish),\n  obtain \u27e8m', hm', hm_unique'\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P R (by finish),\n  obtain \u27e8n', hn', hn_unique'\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P S (by finish),\n  finish,\nend \n\ntheorem thm_3p6p8 [inst : incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin \n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  use R,\n  finish,\nend\n\ntheorem thm_3p6p7 [inst : incidence point line incident_with] (P : point) :\n  \u2203 Q R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin \n  obtain \u27e8Q, hPQ\u27e9 := exists_distinct_point point line incident_with P,\n  exact \u27e8Q, thm_3p6p8 _ _ _ P Q hPQ\u27e9,\nend \n\nend \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209180,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen_locale classical\n\nsection \nvariables (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n\n\/-- every line has non-incident point. -\/\ntheorem thm_3p6p2 [inst : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l := \nbegin \n  obtain \u27e8P, Q, R, _, _, _, h\u27e9 := inst.I\u2083,\n  by_contradiction hi,\n  push_neg at hi,\n  exact h l \u27e8hi P, hi Q, hi R\u27e9,\nend \n\ntheorem thm_3p6p8 [inst : incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin \n  obtain \u27e8l, hl, hl_unique\u27e9 := let I\u2081 := inst.I\u2081 in I\u2081 P Q hPQ,\n  obtain \u27e8R, hR\u27e9 := thm_3p6p2 point line incident_with l,\n  use R,\n  finish,\nend\n\nend \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209181,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [i : incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  obtain \u27e8x, y, z, -, -, -, hxyz\u27e9 := i.I\u2083,\n  obtain \u27e8l\u2080, -, h\u2080\u27e9 := let I\u2081 := i.I\u2081 in I\u2081 P Q hPQ,  -- let\/in required due to a bug\n  by_cases H : incident_with x l\u2080 \u2227 incident_with y l\u2080 \u2227 incident_with z l\u2080,\n  { finish, },\n  { simp only [not_and_distrib] at H,\n    rcases H with _ | _ | _;\n    [use x, use y, use z];\n    push_neg;\n    intros l hP hQ;\n    rwa h\u2080 l \u27e8hP, hQ\u27e9, },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209182,"user_id":106,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  have h := _inst_1.I\u2081, specialize h P Q hPQ, rcases h with \u27e8PQ, PQ0, PQ1\u27e9, simp at PQ1,\n  have h : \u2203 R, \u00acincident_with R PQ, {\n    rcases _inst_1.I\u2083 with \u27e8A, B, C, _, _, _, h\u27e9,\n    have := h PQ,\n    by_cases incident_with A PQ, swap, { use A },\n    by_cases incident_with B PQ, swap, { use B },\n    by_cases incident_with C PQ, swap, { use C },\n    cc\n  }, rcases h with \u27e8 R, hR \u27e9,\n  existsi R, intros l _,\n  have := PQ1 l, cc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209183,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem thm_3p6p2 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (l : line) :\n  \u2203 P, \u00acincident_with P l :=\nbegin\n  rcases geo.I\u2083 with \u27e8_, _, _, _, _, _, h\u2081\u27e9,\n  specialize h\u2081 l,\n  rw [not_and_distrib, not_and_distrib] at h\u2081,\n  rcases h\u2081;\n  finish,\nend\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [geo : incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  have k\u2081 := geo.I\u2081,\n  rcases k\u2081 P Q hPQ with \u27e8l, \u27e8inc_pl, inc_ql\u27e9, h\u27e9,\n  rcases thm_3p6p2 point line incident_with l with \u27e8R, ninc_rl\u27e9,\n  use R,\n  intro m,\n  finish,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209184,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) :=\nbegin\n  have i1 := @incidence.I\u2081 point line incident_with _,\n  have i3 := @incidence.I\u2083 point line incident_with _,\n  rcases i3 with \n    \u27e8R, S, T, hRS, hST, hRT, hRST\u27e9,\n  rcases i1 P Q hPQ with \n    \u27e8l, \u27e8hlP, hlQ\u27e9, uPQ\u27e9,\n  specialize hRST l,\n  repeat {rw not_and_distrib at hRST},\n  rcases hRST with hlX | hlX | hlX,\n  use R, rotate 1, use S, rotate 1, use T,\n  all_goals {\n    rintros k \u27e8hkP, hkQ, hkX\u27e9,\n    rw uPQ k \u27e8hkP, hkQ\u27e9 at hkX,\n    exact hlX hkX,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209185,"user_id":null,"body":"import Preloaded tactic\n\ntheorem thm_3p6p8 (point line : Type) (incident_with : point \u2192 line \u2192 Prop)\n  [s : incidence point line incident_with] (P Q : point) (hPQ : P \u2260 Q) :\n  \u2203 R, \u2200 l, \u00ac(incident_with P l \u2227 incident_with Q l \u2227 incident_with R l) := \nbegin\n  have i := s.I\u2081, cases i P Q hPQ with l h,\n  rcases s.I\u2083 with \u27e8R,S,T,_,_,_,ncolin\u27e9,\n  cases classical.em (incident_with R l) with Rl nRl,\n  cases classical.em (incident_with S l) with Sl nSl,\n  use T, intros m mPQT,\n  have ml := h.2 m (and.intro mPQT.1 mPQT.2.1),\n  rw ml at mPQT, apply ncolin l, split, exact Rl,\n  split, exact Sl, exact mPQT.2.2,\n  use S, intros m mPQS,\n  have ml := h.2 m (and.intro mPQS.1 mPQS.2.1),\n  rw ml at mPQS, exact nSl mPQS.2.2,\n  use R, intros m mPQR,\n  have ml := h.2 m (and.intro mPQR.1 mPQR.2.1),\n  rw ml at mPQR, exact nRl mPQR.2.2,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e8a8f8a18f8ed0010f55280":[{"id":209186,"user_id":null,"body":"import data.nat.prime tactic.norm_num\n\nopen nat\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) :=\nmt (\u03bb h, h 5) (by norm_num)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209187,"user_id":null,"body":"import data.nat.prime\nimport tactic.norm_num\n\nopen nat\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) :=\nbegin\n  push_neg,\n  use 5,\n  norm_num,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209188,"user_id":null,"body":"import data.nat.prime tactic\n\nopen nat\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) := \nbegin\nintro ha,\nhave := ha 5,\nnorm_num at this,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209189,"user_id":null,"body":"import data.nat.prime\nimport tactic.norm_num\n\nopen nat\n\nnamespace tactic\nnamespace interactive\n\nmeta def find_counter_aux : \u2115 \u2192 tactic (\u2115 \u00d7 \u2115)\n| n :=\ndo let m := 2^2^n + 1,\n   let k := min_fac m,\n   if m = k\n     then find_counter_aux $ n+1\n     else pure (k,n)\n\nmeta def find_counter : tactic unit :=\ndo (k,n) \u2190 find_counter_aux 3,\n   tactic.existsi (reflect n),\n   let m := (2^2^n + 1) \/ k,\n   p \u2190 to_expr ``(2^2^%%(reflect n) + 1 = %%(reflect k) * %%(reflect m)),\n   h \u2190 assert `h p,\n   solve1 $ tactic.interactive.norm_num [] (interactive.loc.ns [none]),\n   rewrite_target h,\n   applyc ``not_prime_mul; tactic.interactive.norm_num [] (interactive.loc.ns [none]),\n   pure ()\n\nend interactive\nend tactic\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) := \nbegin\n  apply not_forall_of_exists_not,\n  find_counter,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209190,"user_id":null,"body":"import data.nat.prime\nimport tactic.norm_num\n\nopen nat\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) := \nbegin\n  intro ferma,\n  have contra := ferma 5,\n  revert contra,\n  norm_num,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209191,"user_id":106,"body":"import data.real.basic\nimport data.nat.prime\n\nopen nat\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) :=\nbegin\n  intro h,\n  specialize h 5,\n  have h' : (2 ^ 5) = 32, { ring },\n  rw h' at h, clear h',\n  have h' : (2 ^ 32 + 1) = 4294967297, { ring },\n  rw h' at h, clear h',\n  unfold prime at h,\n  cases h with e h, clear e,\n  specialize h 641,\n  have h' : \u00ac(641 = 1 \u2228 641 = 4294967297), { cc },\n  apply h', apply h,\n  unfold has_dvd.dvd, existsi 6700417, ring\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209192,"user_id":196,"body":"import data.nat.prime tactic.norm_num\n\nopen nat\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, prime (2^2^n + 1)) :=\n\u03bb h, absurd ((h 5).2 641 \u27e86700417, by norm_num\u27e9) (by norm_num)\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209193,"user_id":null,"body":"import data.nat.prime\n\n\n\nlemma five_does_not_work : \u00ac(nat.prime (2 ^ 2 ^ 5 + 1)) :=\nbegin\n  apply nat.not_prime_mul',\n  show 6700417 * 641 = (2 ^ (2 ^ 5) + 1), by {norm_num},\n  show 1 < 6700417, by norm_num,\n  show 1 < 641, by norm_num,\nend\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong: \u00ac(\u2200n : \u2115, nat.prime (2 ^ 2 ^ n + 1)) :=\nbegin\n  refine not_forall.mpr _,\n  existsi 5,\n  apply five_does_not_work,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209194,"user_id":null,"body":"import data.nat.prime\nimport tactic.norm_num\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, nat.prime (2^2^n + 1)) := \nbegin\n  intro h, \n  specialize h 5, \n  cases h with h1 h2,\n  specialize h2 641 6700417, norm_num at h2,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209195,"user_id":null,"body":"import data.nat.prime\n\n\/-- Fermat conjectured that 2^2^n+1 was always prime-\/\ntheorem fermat_was_wrong : \u00ac (\u2200 n : \u2115, nat.prime (2^2^n + 1)) := \nbegin\n  rw not_forall,\n  split,\n  refine imp_false.mp _,\n  exact 5,\n\n  intro hf,\n  have h\u2081 : \u00ac nat.prime (2 ^ 2 ^ 5 +1) := by\n  {\n    have h\u2083 : nat.min_fac ((2 ^ 2^ 5) + 1) = 641 := by norm_num,\n    have h\u2084 := @nat.not_prime_iff_min_fac_lt (2 ^ 2 ^ 5 +1),\n    have h\u2086 : 2 \u2264 2 ^ 2 ^ 5 + 1 := by norm_num,\n    have h\u2085 := (h\u2084 h\u2086),\n    rw h\u2085,\n    rw h\u2083,\n    norm_num,\n  },\n\n  apply h\u2081,\n  apply hf,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e8aa432792ce30025db012e":[{"id":209196,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\n\n\nlemma helper (n : \u2115) (h :\u00ac 3 \u2223 n) : n^3 % 9\u2208 [1,8] :=\nbegin\n  let q := n \/ 3,\n  let r := n % 3,\n  have : n = 3*q+r := (div_add_mod n 3).symm,\n  have : r =1 \u2228 r = 2,\n  {\n    have m_bound : r < 3 := mod_lt _ (by linarith),\n    interval_cases r with hr,\n    exfalso,\n    simp only [hr, add_zero] at this,\n    exact h \u27e8 q,this\u27e9,\n    all_goals { cc }\n  },\n  clear h,\n  cases this with hr hr,\n  all_goals {\n    rw hr at this,\n    rw this,\n  },\n  {\n    left,\n    have :(3*q+1)^3 = 1+ 9 *( 3*q^3 + 3*q^2 + q) := by ring,\n    rw this,\n    simp only [add_mul_mod_self_left, one_mod],\n  },\n  {\n    right,left,\n    have : (3*q+2)^3 = 8 + 9* ( 3*q^3 + 6*q^2 + 4*q) := by ring,\n    rw this,\n    simp only [add_mul_mod_self_left],\n    refl,\n  }\nend\n\n\n\ntheorem easy_fermat (a b c:\u2115 ) (h:a^3+b^3=c^3) : 3 \u2223 a*b*c :=\nbegin\n  suffices : 3\u2223a \u2228 3\u2223b \u2228 3\u2223c,\n  {\n    cases this,\n    apply dvd_mul_of_dvd_left,\n    apply (dvd_mul_of_dvd_left this),\n    cases this,\n    apply dvd_mul_of_dvd_left,\n    apply dvd_mul_of_dvd_right this,\n    apply dvd_mul_of_dvd_right this,\n  },\n  by_contra hh,\n  push_neg at hh,\n  suffices : (a^3 % 9 + b^3 %9) % 9 \u2260 c^3 % 9,\n  {\n    rw [\u2190 add_mod,h] at this,\n    exact this rfl,\n  },\n  have ha := helper\n _ hh.1,\n  have hb := helper\n _ hh.2.1,\n  have hc := helper\n _ hh.2.2,\n  fin_cases ha,\n  all_goals {\n    rw ha,\n    fin_cases hb,\n    all_goals {\n      rw hb,\n      fin_cases hc,\n      all_goals {\n        rw hc,\n        obviously,\n      }\n    }\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209197,"user_id":null,"body":"import data.nat.basic\nimport data.nat.modeq\nimport tactic.ring_exp\nimport tactic.linarith\n\nlemma mod_three_eq_zero_or_one_or_two (n : \u2115) : n % 3 = 0 \u2228 n % 3 = 1 \u2228 n % 3 = 2 :=\nmatch n % 3, @nat.mod_lt n 3 dec_trivial with\n| 0,   _ := or.inl rfl\n| 1,   _ := or.inr (or.inl rfl)\n| 2,   _ := or.inr (or.inr rfl)\n| k+3, h := absurd h dec_trivial\nend\n\nlemma mod_of_add_mod (a b m : \u2115) : ((a % m) + (b % m)) % m = (a + b) % m :=\nbegin\n  suffices : \u2203 (k : \u2115), (a % m) + (b % m) + m * k = a + b, \n  { cases this with k hk, rw [\u2190 hk, \u2190 nat.add_mul_mod_self_left], },\n  use a\/m + b\/m,\n  have : (a%m + m*(a\/m)) + (b%m + m*(b\/m)) = a+b, by rw [nat.mod_add_div a m, nat.mod_add_div b m],\n  rw \u2190 this,\n  ring,\nend\n\nlemma cube_mod_nine (n : \u2115) : n^3 % 9 = (n % 3)^3 :=\nbegin\n  cases mod_three_eq_zero_or_one_or_two n,\n  { rw [h, zero_pow], swap, linarith,\n    cases (nat.dvd_iff_mod_eq_zero 3 n).2 h with k hk,\n    rw [\u2190 nat.dvd_iff_mod_eq_zero, hk],\n    use 3 * k^3, ring,},\n    cases h with hn hn,\n  { rw [hn, \u2190 nat.mod_add_div n 3, hn, one_pow], \n    set m := n\/3,\n    rw [(show (1+3*m)^3=1+9*(m + 3*m^2 + 3*m^3), by ring), nat.add_mul_mod_self_left, nat.one_mod]},\n  { rw [hn, \u2190 nat.mod_add_div n 3, hn],\n    set m := n\/3,\n    rw [(show (2+3*m)^3=2^3+9*(4*m + 6*m^2 + 3*m^3), by ring), nat.add_mul_mod_self_left], \n    rw nat.mod_def, \n    norm_num, },\nend\n\ntheorem easy_fermat : \u2200 a b c : \u2115, a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intros a b c habc,\n  by_cases ha0 : a % 3 = 0,\n  { exact dvd_trans (nat.dvd_of_mod_eq_zero ha0) (show a \u2223 a*b*c, by {use b*c, ring,}), },\n  by_cases hb0 : b % 3 = 0,\n  { exact dvd_trans (nat.dvd_of_mod_eq_zero hb0) (show b \u2223 a*b*c, by {use a*c, ring, }), },\n  by_cases hc0 : c % 3 = 0,\n  { exact dvd_trans (nat.dvd_of_mod_eq_zero hc0) (show c \u2223 a*b*c, by {use a*b, ring, }), },\n  cases or.resolve_left (mod_three_eq_zero_or_one_or_two a) ha0 with ha ha;\n  cases or.resolve_left (mod_three_eq_zero_or_one_or_two b) hb0 with hb hb;\n  cases or.resolve_left (mod_three_eq_zero_or_one_or_two c) hc0 with hc hc;\n  exfalso; clear ha0; clear hb0; clear hc0;\n  have habc' := congr_arg (\u03bb x, x % 9) habc; simp only at habc';\n  rw [\u2190 mod_of_add_mod, cube_mod_nine, cube_mod_nine, cube_mod_nine, ha, hb, hc] at habc';\n  norm_num at habc',\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209198,"user_id":17,"body":"import data.nat.prime data.nat.modeq tactic.norm_num\n\nopen nat nat.prime nat.modeq\n\ntheorem modeq_pow : \u2200 {k m n e : \u2115}, k \u2261 m [MOD n] \u2192 k^e \u2261 m^e [MOD n]\n| _ _ _ 0 h := by rw [pow_zero, pow_zero]\n| a b c (e+1) h := by rw [pow_succ, pow_succ]; exact nat.modeq.mul h (modeq_pow h)\n\ntheorem of_not_3_dvd {n : \u2115} (hn : \u00ac3 \u2223 n) :\n  n^3 \u2261 1 [MOD 9] \u2228 n^3 \u2261 8 [MOD 9] :=\nbegin\n  generalize hm : n % 9 = m,\n  cases m, { exfalso, apply hn, rw [\u2190 mod_add_div n 9, hm], apply dvd_add, { use 0, norm_num }, apply dvd_mul_of_dvd_left, { use 3, norm_num } },\n  cases m, { left, apply (@modeq_pow n 1 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { right, apply (@modeq_pow n 2 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { exfalso, apply hn, rw [\u2190 mod_add_div n 9, hm], apply dvd_add, { use 1, norm_num }, apply dvd_mul_of_dvd_left, { use 3, norm_num } },\n  cases m, { left, apply (@modeq_pow n 4 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { right, apply (@modeq_pow n 5 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { exfalso, apply hn, rw [\u2190 mod_add_div n 9, hm], apply dvd_add, { use 2, norm_num }, apply dvd_mul_of_dvd_left, { use 3, norm_num } },\n  cases m, { left, apply (@modeq_pow n 7 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { right, apply (@modeq_pow n 8 9 3 hm).trans, unfold modeq, norm_num },\n  exfalso, have := mod_lt n (by norm_num : 9 > 0), rw hm at this, exact absurd this dec_trivial\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro habc,\n  have h3 : nat.prime 3, norm_num,\n  rw [dvd_mul h3, dvd_mul h3],\n  by_contra hdvd,\n  rw [not_or_distrib, not_or_distrib] at hdvd,\n  rcases hdvd with \u27e8\u27e8ha, hb\u27e9, hc\u27e9,\n  rcases of_not_3_dvd ha with ha | ha;\n  rcases of_not_3_dvd hb with hb | hb;\n  rcases of_not_3_dvd hc with hc | hc;\n  rw [\u2190 habc] at hc;\n  replace hc := hc.symm.trans (modeq.add ha hb);\n  cases hc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209199,"user_id":null,"body":"import Preloaded tactic\n\nlemma r9 {a : \u2115} (ha : \u00ac 3 \u2223 a) : (a^3 % 9 = 1) \u2228 (a^3 % 9 = 8) :=\nbegin\n  by_cases h0 : a%3 \u2264 0,\n  { exfalso, \n    have a0 := nat.le_zero_iff.mp h0, \n    exact ha (nat.dvd_of_mod_eq_zero a0) },\n  by_cases h1 : a%3 \u2264 1,\n  { have h : a%3=1 := by linarith,  \n    left,\n    have t:= nat.mod_add_div a 3,\n    rw h at t,\n    let b := a\/3,\n    have hd : a^3 = 1 + 9 * b * (3 * b^2 + a),\n    rw [\u2190t], simp[b], ring,\n    rw [hd, mul_assoc, nat.add_mul_mod_self_left],\n    norm_num },\n  by_cases h2 : a%3 \u2264 2,\n  { have h : a%3=2 := by linarith,\n    right, \n    have t:= nat.mod_add_div a 3,\n    rw h at t,\n    let b := a\/3,\n    have hd : a^3 = 8 + 9 * b * (3 * b^2 + 6 * b + 4),\n    rw [\u2190t], simp[b], ring,\n    rw [hd, mul_assoc, nat.add_mul_mod_self_left],\n    norm_num },\n  have t := nat.mod_lt a (show 0<3, by linarith),\n  exfalso,\n  linarith,\nend\n\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c := \nbegin\n  intros h,\n  replace h := congr_arg (\u03bb x, x%9) h,  \n  simp at h,\n  rw nat.add_mod at h,\n  by_contradiction hco,\n  have ha : \u00ac 3 \u2223 a,\n  { intro hx, apply hco, apply dvd_mul_of_dvd_left, exact dvd_mul_of_dvd_left hx b },\n  have hb : \u00ac 3 \u2223 b,\n  { intro hx, apply hco, apply dvd_mul_of_dvd_left, exact dvd_mul_of_dvd_right hx a },\n  have hc : \u00ac 3 \u2223 c,\n  { intro hx, apply hco, apply dvd_mul_of_dvd_right hx },\n  cases r9 ha; cases r9 hb; cases r9 hc;\n  rw [h_1, h_2, h_3] at h;\n  norm_num at h,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209200,"user_id":null,"body":"import Preloaded data.nat.basic data.zmod.basic tactic\n\nlemma mod_eq_of_mod_eq {n m a : \u2115} (h : n % a = m % a) : (n : zmod a) = (m : zmod a) :=\nbegin\n  have : ((n % a : \u2115) : zmod a) = ((m % a : \u2115) : zmod a) := by rw h,\n  simp [zmod.cast_mod_nat] at this,\n  exact this,\nend\n\n@[simp] lemma mod_3_eq_mod_9_mod_3 (n : \u2115) : (n : zmod 3) = ((n : zmod 9) : zmod 3) :=\nbegin\n  apply mod_eq_of_mod_eq,\n  rw zmod.val_cast_nat,\n  exact eq.symm (nat.mod_mod_of_dvd n (by norm_num)),\nend\n\nlemma cubes_mod_9 (n : \u2115) : (n : zmod 3) = 0 \u2228 (n : zmod 9)^3 = 1 \u2228 (n : zmod 9)^3 = -1 :=\nbegin\n  set n' := (n : zmod 9) with hn,\n  fin_cases n',\n  any_goals {rw h, right, exact dec_trivial},\n  any_goals {\n    simp only [mod_3_eq_mod_9_mod_3],\n    rw [\u2190 hn, h],\n    exact dec_trivial,\n  },\nend\n\nlemma mul_3_of_0_mod_3 {n : \u2115} (h : (n : zmod 3) = 0) : 3 \u2223 n :=\nbegin\n  replace h : n % 3 = 0,\n    rw \u2190 zmod.val_cast_nat,\n    exact eq.trans (congr_arg zmod.val h) rfl,\n  exact nat.dvd_of_mod_eq_zero h,\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n    intro h,\n    have h' : (a : zmod 9)^3 + (b : zmod 9)^3 = (c : zmod 9)^3 := \n      by norm_cast at *; rw h,\n    have h'' : (a*b*c : zmod 3) = 0,\n      have := cubes_mod_9 a,\n      have := cubes_mod_9 b,\n      have := cubes_mod_9 c,\n      cases_matching* _ \u2228 _,\n      any_goals { simp only [*, mul_zero, zero_mul], },\n      any_goals {\n        have : (a : zmod 9)^3 + (b : zmod 9)^3 \u2260 (c : zmod 9)^3,\n        simp only [*],\n        exact dec_trivial,\n        tauto,\n      },\n    norm_cast at h'',\n    exact mul_3_of_0_mod_3 h'',\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209201,"user_id":659,"body":"import data.nat.prime data.nat.modeq tactic\n\nopen nat nat.prime nat.modeq\n\n-- surprised this isn't in mathlib\nlemma add_mod (a b c : \u2115) : (a + b) % c = ((a % c) + (b % c)) % c :=\nbegin\n  -- suffices to show a+b and (a%c)+(b%c) are congruent mod c\n  show a + b \u2261 (a % c) + (b % c) [MOD c],\n  -- but this follows from standard results\n  apply modeq_add,\n  symmetry, apply mod_modeq,\n  symmetry, apply mod_modeq,\nend\n\n\/-- If a isn't a multiple of 3 then a^3 is 1 or 8 mod 9 -\/\nlemma coprime_three_cube {a : \u2115} (ha : \u00ac 3 \u2223 a) : a ^ 3 % 9 = 1 \u2228 a ^ 3 % 9 = 8 :=\nbegin\n  have ha1 := mod_add_div a 3,\n  -- a mod 3 is less than 3\n  have ha3 : a % 3 < 3 := mod_lt a dec_trivial,\n  interval_cases a % 3,\n  -- so it's 0, 1 or 2. Cases.\n  { -- a=0 mod 3\n    -- In this case a is a multiple of 3\n    exact false.elim (ha (dvd_of_mod_eq_zero h)),\n  },\n  { -- a=1 mod 3\n    -- In this case just expand out the algebra to see a^3=1 mod 9\n    left,\n    rw h at ha1,\n    rw \u2190ha1,\n    rw (show (1 + 3 * (a \/ 3)) ^ 3 = 1 + 9 * ((a\/3) + 3 * (a\/3)^2 + 3 * (a\/3)^3), by ring),\n    rw add_mul_mod_self_left, refl,\n  },\n  { -- a=2 mod 3\n    -- again just expand out to deduce a^3=8 mod 9\n    right,\n    rw h at ha1,\n    rw \u2190ha1,\n    rw (show (2 + 3 * (a \/ 3)) ^ 3 = 8 + 9 * (4*(a\/3) + 6 * (a\/3)^2 + 3 * (a\/3)^3), by ring),\n    rw add_mul_mod_self_left, refl,\n  }\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) : a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h,\n  rw [dvd_mul prime_three, dvd_mul prime_three],\n  -- Proof by contradiction\n  apply classical.by_contradiction,\n  intro h2,\n  push_neg at h2,\n  -- Assume 3 doesn't divide any of a, b, c\n  rcases h2 with \u27e8\u27e8ha, hb\u27e9, hc\u27e9,\n  have hp : (a ^ 3 + b ^ 3) % 9 = (c ^ 3) % 9,\n    rw h,\n  replace ha := coprime_three_cube ha,\n  replace hb := coprime_three_cube hb,\n  replace hc := coprime_three_cube hc,\n  rw nat.add_mod at hp,\n  -- then a^3 + b^3 mod 9 = c^3 mod 9\n  -- and checking all the cases...\n  cases ha; cases hb; cases hc;\n  rw [ha, hb, hc] at hp;\n  -- ...we see that none of them work. This is the contradiction we seek.\n  cases hp\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209202,"user_id":null,"body":"import Preloaded\n\nimport data.nat.modeq tactic.interval_cases tactic.ring_exp\nopen nat nat.modeq\n\nlemma quot_rem (n : \u2115) {m : \u2115} (h : m > 0) : \u2203d r : \u2115, r < m \u2227 n = d * m + r :=\nbegin\n  use [n \/ m, n % m], split, exact mod_lt _ h, convert (mod_add_div n m).symm using 1,\n  simp [mul_comm, add_comm],\nend\n\nlemma add_pow_three {n m : \u2115} : (n * 3 + m) ^ 3 = 9 * (3 * n ^ 3 + 3 * n ^ 2 * m + n * m ^ 2) + m ^ 3 :=\nby ring_exp\n\nlemma lemma1 {n : \u2115} (h : \u00ac3 \u2223 n) : 1 \u2261 n ^ 3 [MOD 9] \u2228 8 \u2261 n ^ 3 [MOD 9] :=\nbegin\n  have : 3 > 0 := dec_trivial,\n  rcases quot_rem n this with \u27e8n1, k1, hk1, rfl\u27e9,\n  interval_cases k1; [simpa using h, left, right]; rw add_pow_three;\n    refine modeq.trans _ (modeq_add (modeq_zero_iff.mpr _).symm (by refl)); \n    simp [nat.pow_succ, mul_succ]\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) : a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h,\n  by_contra h2,\n  have h3 : a ^ 3 + b ^ 3 \u2261 c ^ 3 [MOD 9], { rw h },\n  simp [prime.dvd_mul prime_three, not_or_distrib] at h2,\n  rcases lemma1 h2.1.1 with ha|ha; rcases lemma1 h2.1.2 with hb|hb; rcases lemma1 h2.2 with hc|hc;\n  have := (ha.modeq_add hb).trans (h3.trans hc.symm);\n  apply not.elim dec_trivial this\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209203,"user_id":196,"body":"import data.nat.prime data.nat.modeq tactic.norm_num\n\nopen nat nat.prime nat.modeq\n\ntheorem modeq_pow : \u2200 {k m n e : \u2115}, k \u2261 m [MOD n] \u2192 k^e \u2261 m^e [MOD n]\n| _ _ _ 0 h := by rw [nat.pow_zero, nat.pow_zero]\n| _ _ _ (e+1) h := by rw [nat.pow_succ, nat.pow_succ]; exact modeq_mul (modeq_pow h) h\n\ntheorem of_not_3_dvd {n : \u2115} (hn : \u00ac3 \u2223 n) :\n  n^3 \u2261 1 [MOD 9] \u2228 n^3 \u2261 8 [MOD 9] :=\nbegin\n  generalize hm : n % 9 = m,\n  cases m, { exfalso, apply hn, rw [\u2190 mod_add_div n 9, hm], apply dvd_add, { use 0, norm_num }, apply dvd_mul_of_dvd_left, { use 3, norm_num } },\n  cases m, { left, apply (@modeq_pow n 1 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { right, apply (@modeq_pow n 2 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { exfalso, apply hn, rw [\u2190 mod_add_div n 9, hm], apply dvd_add, { use 1, norm_num }, apply dvd_mul_of_dvd_left, { use 3, norm_num } },\n  cases m, { left, apply (@modeq_pow n 4 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { right, apply (@modeq_pow n 5 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { exfalso, apply hn, rw [\u2190 mod_add_div n 9, hm], apply dvd_add, { use 2, norm_num }, apply dvd_mul_of_dvd_left, { use 3, norm_num } },\n  cases m, { left, apply (@modeq_pow n 7 9 3 hm).trans, unfold modeq, norm_num },\n  cases m, { right, apply (@modeq_pow n 8 9 3 hm).trans, unfold modeq, norm_num },\n  exfalso, have := mod_lt n (by norm_num : 9 > 0), rw hm at this, exact absurd this dec_trivial\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro habc,\n  have h3 : prime 3, norm_num,\n  rw [dvd_mul h3, dvd_mul h3],\n  by_contra hdvd,\n  rw [not_or_distrib, not_or_distrib] at hdvd,\n  rcases hdvd with \u27e8\u27e8ha, hb\u27e9, hc\u27e9,\n  rcases of_not_3_dvd ha with ha | ha;\n  rcases of_not_3_dvd hb with hb | hb;\n  rcases of_not_3_dvd hc with hc | hc;\n  rw [\u2190 habc] at hc;\n  replace hc := hc.symm.trans (modeq_add ha hb);\n  cases hc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209204,"user_id":null,"body":"import Preloaded data.int.basic tactic tactic.nth_rewrite\n\nopen int \n\nlemma cube_mod9 (a : \u2124) : a^3 % 9 = (a%3)^3 % 9 :=\nbegin\n  have h : 3\u2223(a - a%3), apply dvd_sub_of_mod_eq, refl,\n  cases h with n h, rw sub_eq_iff_eq_add at h, nth_rewrite 0 h,\n  set A := a % 3, rw mod_eq_mod_iff_mod_sub_eq_zero,\n  rw \u2190dvd_iff_mod_eq_zero, use 3*n^2*(n+A)+n*A^2, ring,\nend\n\nlemma cases_mod9 (a : \u2124) : 3\u2223a \u2228 a^3 % 9 = 1 \u2228 a^3 % 9 = 8 :=\nbegin\n  have hl : 0 \u2264 a%3, apply mod_nonneg, norm_num,\n  have hu : a%3 < 3, apply mod_lt_of_pos, norm_num,\n  interval_cases using hl hu,\n  left, exact h, right,\n  left, rw [cube_mod9, h], norm_num,\n  right, rw [cube_mod9, h], norm_num,\nend\n\ntheorem eazy_fermat (a b c : \u2124) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro eqn, have H : (a^3%9+b^3%9)%9 = c^3%9, rw [\u2190add_mod, \u2190eqn],\n  cases cases_mod9 a with h ha, cases h with n h, use n*b*c, rw h, ring,\n  cases cases_mod9 b with h hb, cases h with n h, use n*a*c, rw h, ring,\n  cases cases_mod9 c with h hc, cases h with n h, use n*a*b, rw h, ring,\n  exfalso, cases ha, iterate 2 { cases hb, iterate 2 { cases hc, iterate 2 {\n      rw [ha,hb,hc] at H, norm_num at H }}},\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h, rw \u2190 coe_nat_dvd, push_cast,\n  apply eazy_fermat, norm_cast, exact h,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209205,"user_id":null,"body":"import Preloaded\n\nimport data.zmod.basic\n\nlemma l1 {x y z : zmod 9}\n  (hx : x = 1 \u2228 x = 8) (hy : y = 1 \u2228 y = 8) (hz : z = 1 \u2228 z = 8) :\n  \u00ac (x + y = z) :=\nbegin\n  rcases hx with rfl|rfl;\n  rcases hy with rfl|rfl;\n  rcases hz with rfl|rfl;\n  exact dec_trivial\nend\n\nlemma l2 {a : zmod 9} (ha : \u00ac (3 \u2223 a)) : a^3 = 1 \u2228 a^3 = 8 :=\nbegin\n  fin_cases a,\n  iterate 3 {\n    { exact false.elim (ha dec_trivial) },\n    { exact or.inl dec_trivial },\n    { exact or.inr dec_trivial },\n  }\nend\n\nlemma l3 {n : \u2115} (hn : \u00ac (3 \u2223 n)) {a : zmod 9} (ha : a = n) : a^3 = 1 \u2228 a^3 = 8 :=\nbegin\n  suffices : \u00ac (3 \u2223 a), by exact l2 this,\n  subst a,\n  rintro \u27e8b, h\u27e9,\n  apply hn,\n  -- lift b to nat,\n  let b' := b.val,\n  rw [show 3 * b = ((3 * b' : \u2115) : zmod 9), by simp,\n    zmod.eq_iff_modeq_nat] at h,\n  replace h := nat.modeq.modeq_of_dvd_of_modeq (show 3 \u2223 9, from dec_trivial) h,\n  dunfold nat.modeq at h,\n  rw nat.mul_mod_right at h,\n  rwa nat.dvd_iff_mod_eq_zero\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h,\n  by_contradiction habc,\n  have hab : \u00ac (3 \u2223 a * b) := mt (\u03bb H, dvd_mul_of_dvd_left H _) habc,\n  have ha : \u00ac (3 \u2223 a) := mt (\u03bb H, dvd_mul_of_dvd_left H _) hab,\n  have hb : \u00ac (3 \u2223 b) := mt (\u03bb H, dvd_mul_of_dvd_right H _) hab,\n  have hc : \u00ac (3 \u2223 c) := mt (\u03bb H, dvd_mul_of_dvd_right H _) habc,\n  replace h := congr_arg (\u03bb (n : \u2115), (n : zmod 9)) h,\n  push_cast at h,\n  have := l1 (l3 ha rfl) (l3 hb rfl) (l3 hc rfl),\n  contradiction\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209206,"user_id":644,"body":"import Preloaded data.zmod.basic\ninstance : fintype (set.range ((^3) : zmod 9 \u2192 zmod 9)) :=\n\u27e8\u27e8\u27e80, 0, rfl\u27e9::\u27e81, 1, rfl\u27e9::\u27e88, 2, rfl\u27e9::0, dec_trivial\u27e9, dec_trivial\u27e9\n\nlocal attribute [priority 0] set_fintype\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) (h : a ^ 3 + b ^ 3 = c ^ 3) :\n  3 \u2223 a * b * c :=\nhave hcube : \u2200 a : zmod 9, 3 \u2223 a^3 \u2194 3 \u2223 a := dec_trivial,\nhave \u2200 a b c : (set.range ((^3) : zmod 9 \u2192 zmod 9)), a.1 + b.1 = c.1 \u2192 \n    3 \u2223 a.1 \u2228 3 \u2223 b.1 \u2228 3 \u2223 c.1 :=\n  dec_trivial,\nhave \u2200 a b c : zmod 9, a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c := \n  \u03bb a b c h, \n    begin\n      have : 3 \u2223 a^3 \u2228 3 \u2223 b^3 \u2228 3 \u2223 c^3 := \n        this \u27e8a^3, _, rfl\u27e9 \u27e8b^3, _, rfl\u27e9 \u27e8c^3, _, rfl\u27e9 h,\n      simp only [hcube] at this,\n      rcases this with \u27e8x, rfl\u27e9 | \u27e8x, rfl\u27e9 | \u27e8x, rfl\u27e9; \n      simp [mul_comm _ (3 : zmod 9), mul_assoc, mul_left_comm _ (3 : zmod 9)]\n    end,\nbegin\n  cases this a b c (by norm_cast; rw h) with x hx,\n  rw [\u2190 zmod.cast_val x, show (3 : zmod 9) = (3 : \u2115), from rfl] at hx,\n  norm_cast at hx,\n  rw [zmod.eq_iff_modeq_nat] at hx,\n  change ((9 : \u2115+) : \u2115) with (3 * (3 : \u2115+)) at hx,\n  have := nat.modeq.modeq_of_modeq_mul_left 3 hx,\n  rwa [\u2190 zmod.eq_iff_modeq_nat, nat.cast_mul 3, show ((3 : \u2115) : zmod 3) = 0, from rfl,\n    zero_mul, zmod.eq_zero_iff_dvd_nat] at this\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209207,"user_id":168,"body":"import Preloaded tactic data.zmod.basic data.nat.prime\n\nopen nat\n\nlemma mod9 (n : zmod 9) : n ^ 3 = 0 \u2228 n ^ 3 = 1 \u2228 n ^ 3 = 8 :=\nbegin\n  fin_cases n; exact dec_trivial,\nend\n\nlemma mod9_n3 (n : \u2115) (h : \u00ac(3 \u2223 n)) : (n : zmod 9) ^ 3 = 1 \u2228 (n : zmod 9) ^ 3 = 8 :=\nbegin\n  have n9 : \u00ac9 \u2223 n ^ 3,\n    by_contra h9, apply h,\n    apply @prime.dvd_of_dvd_pow 3 _ 3, norm_num,\n    exact @dvd_of_mul_left_dvd _ _ 3 3 _ h9,\n  rw [\u2190modeq.modeq_zero_iff, \u2190@zmod.eq_iff_modeq_nat' 9 dec_trivial] at n9,\n  push_cast at n9,\n  cases mod9 n with h0 h2, rw h0 at n9, contradiction,\n  cases h2 with h1 h8, left, simpa,\n  right, simpa,\nend\n\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h,\n  have p3 : prime 3, norm_num,\n  simp only [prime.dvd_mul p3],\n  by_contra n3, push_neg at n3,\n  obtain \u27e8\u27e8a3, b3\u27e9, c3\u27e9 := n3,\n  have : (a ^ 3 + b ^ 3 : zmod 9) = c ^ 3,\n    norm_cast, rw h,\n  revert this,\n  cases mod9_n3 _ a3 with ha1 ha8; \n    cases mod9_n3 _ b3 with hb1 hb8; \n    cases mod9_n3 _ c3 with hc1 hc8;\n      simp only [*]; exact dec_trivial,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209208,"user_id":null,"body":"import tactic data.nat.modeq Preloaded\n\nopen nat\n\nlemma mod_pow (a m n : \u2115) : (a^n)%m = (a%m)^n % m :=\nbegin\n  induction n with n ih,\n    refl,\n  repeat {rw nat.pow_succ},\n  apply modeq.modeq_mul,\n  exact ih,\n  symmetry,\n  exact modeq.mod_modeq a m,\nend\n\nlemma mylemma {a : \u2115} (ha : \u00ac 3 \u2223 a) : (a^3 % 9 = 1 \u2228 a^3 % 9 = 8) :=\nbegin\n  rw mod_pow,\n  have : a%9 < 9,\n    apply mod_lt,\n    norm_num,\n  set i : fin 9 := \u27e8a%9, this\u27e9 with hi,\n  fin_cases i;\n  try {\n    exfalso,\n    apply ha,\n    rw dvd_iff_mod_eq_zero,\n    rw \u2190mod_mod_of_dvd a (by norm_num : 3 \u2223 9),\n    rw h,\n    norm_num,\n    done };\n  rw h;\n  norm_num\nend\n\ntheorem easy_fermat (a b c : \u2115) :\n  a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h,\n  repeat {rw prime.dvd_mul prime_three},\n  suffices : \u00ac (\u00ac3\u2223a \u2227 \u00ac3\u2223b \u2227 \u00ac3\u2223c),\n    tauto,\n  rintro \u27e8ha, hb, hc\u27e9,\n  suffices : (a^3%9 + b^3%9)%9 \u2260 c^3%9,\n    apply this,\n    rw \u2190h,\n    apply modeq.modeq_add,\n    apply modeq.mod_modeq,\n    apply modeq.mod_modeq,\n  cases mylemma ha with A A; rw A;\n  cases mylemma hb with B B; rw B;\n  cases mylemma hc with C C; rw C;\n  norm_num\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209209,"user_id":659,"body":"import data.nat.prime data.nat.modeq tactic\n\nopen nat nat.prime nat.modeq\n\n-- surprised this isn't in mathlib\nlemma add_mod (a b c : \u2115) : (a + b) % c = ((a % c) + (b % c)) % c :=\nbegin\n  -- suffices to show a+b and (a%c)+(b%c) are congruent mod c\n  show a + b \u2261 (a % c) + (b % c) [MOD c],\n  -- but this follows from standard results\n  apply modeq_add,\n  symmetry, apply mod_modeq,\n  symmetry, apply mod_modeq,\nend\n\n\/-- If a isn't a multiple of 3 then a^3 is 1 or 8 mod 9 -\/\nlemma coprime_three_cube {a : \u2115} (ha : \u00ac 3 \u2223 a) : a ^ 3 % 9 = 1 \u2228 a ^ 3 % 9 = 8 :=\nbegin\n  have ha1 := mod_add_div a 3,\n  -- a mod 3 is less than 3\n  have ha3 : a % 3 < 3 := mod_lt a dec_trivial,\n  interval_cases a % 3,\n  -- so it's 0, 1 or 2. Cases.\n  { -- a=0 mod 3\n    -- In this case a is a multiple of 3\n    exact false.elim (ha (dvd_of_mod_eq_zero lh)),\n  },\n  { -- a=1 mod 3\n    -- In this case just expand out the algebra to see a^3=1 mod 9\n    left,\n    rw lh at ha1,\n    rw \u2190ha1,\n    rw (show (1 + 3 * (a \/ 3)) ^ 3 = 1 + 9 * ((a\/3) + 3 * (a\/3)^2 + 3 * (a\/3)^3), by ring),\n    rw add_mul_mod_self_left, refl,\n  },\n  { -- a=2 mod 3\n    -- again just expand out to deduce a^3=8 mod 9\n    right,\n    rw lh at ha1,\n    rw \u2190ha1,\n    rw (show (2 + 3 * (a \/ 3)) ^ 3 = 8 + 9 * (4*(a\/3) + 6 * (a\/3)^2 + 3 * (a\/3)^3), by ring),\n    rw add_mul_mod_self_left, refl,\n  }\nend\n\n-- A weak corollary of Fermat's Last Theorem: no type 1 solutions if p=3\ntheorem easy_fermat (a b c : \u2115) : a ^ 3 + b ^ 3 = c ^ 3 \u2192 3 \u2223 a * b * c :=\nbegin\n  intro h,\n  rw [dvd_mul prime_three, dvd_mul prime_three],\n  -- Proof by contradiction\n  apply classical.by_contradiction,\n  intro h2,\n  push_neg at h2,\n  -- Assume 3 doesn't divide any of a, b, c\n  rcases h2 with \u27e8\u27e8ha, hb\u27e9, hc\u27e9,\n  have hp : (a ^ 3 + b ^ 3) % 9 = (c ^ 3) % 9,\n    rw h,\n  replace ha := coprime_three_cube ha,\n  replace hb := coprime_three_cube hb,\n  replace hc := coprime_three_cube hc,\n  rw add_mod at hp,\n  -- then a^3 + b^3 mod 9 = c^3 mod 9\n  -- and checking all the cases...\n  cases ha; cases hb; cases hc;\n  rw [ha, hb, hc] at hp;\n  -- ...we see that none of them work. This is the contradiction we seek.\n  cases hp\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e8eb40a802e03001ba0733a":[{"id":209210,"user_id":null,"body":"import data.fintype.basic group_theory.order_of_element tactic\n\nuniverses u\n\nlemma order_cases (n : \u2115) : \u00acn\u22232 \u2192 n\u22234 \u2192 n \u2264 4 \u2192 n = 4 :=\nbegin\n  intros nd2 d4 l4, interval_cases n, norm_num at d4,\n  repeat {norm_num at nd2, cases nd2}, norm_num at d4,\nend\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\nbegin\n  classical, by_cases exp: \u2200g:G, g*g=1, intros g h,\n  exact calc g*h = g*h*1           : by rw mul_one\n             ... = g*h*(h*g*(h*g)) : by rw \u2190 exp\n             ... = g*(h*h)*g*h*g   : by repeat {rw mul_assoc}\n             ... = g*1*g*h*g       : by rw exp\n             ... = g*g*h*g         : by rw mul_one\n             ... = 1*h*g           : by rw exp\n             ... = h*g             : by rw one_mul,\n  push_neg at exp, cases exp with g H,\n  rw [\u2190pow_two, \u2190order_of_dvd_iff_pow_eq_one] at H,\n  have o4 := order_cases _ H _ _, rw \u2190 hG4 at o4,\n  cases (is_cyclic_of_order_of_eq_card g o4).exists_generator\n    with g' gen, intros x y,\n  cases gen x with m gmx, cases gen y with n gny,\n  rw [\u2190gmx, \u2190gny, \u2190gpow_add, \u2190gpow_add, add_comm],\n  rw \u2190 hG4, exact order_of_dvd_card_univ,\n  rw \u2190 hG4, exact order_of_le_card_univ,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209211,"user_id":null,"body":"import data.fintype.basic tactic algebra.group.basic\nopen_locale classical\nuniverses u\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\nbegin\n    intros g h,\n    by_cases g_neq_1 : g = 1, \n        simp only [*, mul_one, one_mul],\n    by_cases h_neq_1 : h = 1,\n        simp only [*, mul_one, one_mul],\n    by_cases g_neq_h : g = h,\n        simp only [*],\n    by_cases gh_neq_g : g*h = g, finish,\n    by_cases gh_neq_h : g*h = h, finish,\n    by_cases hg_neq_g : h*g = g, finish,\n    by_cases hg_neq_h : h*g = h, finish,\n    by_cases hg_neq_1 : h*g = 1,\n        simp only [eq_inv_of_mul_eq_one hg_neq_1, mul_right_inv, mul_left_inv],\n    by_cases gh_neq_1 : g*h = 1,\n        simp only [eq_inv_of_mul_eq_one gh_neq_1, mul_right_inv, mul_left_inv],\n    by_cases gh_eq_hg : g*h = h*g, cc,\n    let S : finset G := \u27e8[1, g, h, g*h, h*g], by simp *; cc\u27e9,\n    have : 5 \u2264 _ := finset.card_le_of_subset (finset.subset_univ S),\n    rw [finset.card_univ, hG4] at this,\n    exact absurd this dec_trivial,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209212,"user_id":null,"body":"import data.fintype.basic tactic.linarith\n\nuniverses u\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\nbegin\n  by_contra',\n  obtain \u27e8g, h, gh_ne_hg\u27e9 := this,\n  have g_ne_1 : 1 \u2260 g, by { intro x, apply gh_ne_hg, rw \u2190 x, simp, },\n  have h_ne_1 : 1 \u2260 h, by { intro x, apply gh_ne_hg, rw \u2190 x, simp, },\n  suffices : 5 \u2264 fintype.card G, by linarith,\n  suffices : ([1, g, h, g * h, h * g] : multiset G).nodup, \n  { rw \u2190 (show (\u27e8[1, g, h, g * h, h * g], this\u27e9 : finset G).card = 5, by simp), \n    apply finset.card_le_of_subset, \n    simp, },\n  rw multiset.nodup_iff_pairwise,\n  use [[1, g, h, g * h, h * g], by tauto],\n  rw list.pairwise_iff,\n  right,\n  use [1, [g, h, g * h, h * g]],\n  split,\n  { intros a ha,\n    cases ha, { convert g_ne_1, },\n    cases ha, { convert h_ne_1, },\n    cases ha, \n    { rw ha, intro hgh, apply gh_ne_hg, rw [\u2190 hgh, \u2190 mul_right_inj, \u2190 mul_assoc, \u2190 hgh], simp, },\n    { rw list.eq_of_mem_singleton ha, \n      intro hhg, apply gh_ne_hg, rw [\u2190 hhg, \u2190 mul_left_inj, mul_assoc, \u2190 hhg], simp, }, },\n  split,\n  { rw list.pairwise_iff,\n    right,\n    use [g, [h, g * h, h * g]],\n    split,\n    { intros a ha,\n      cases ha, { rw ha, intro hgh, apply gh_ne_hg, rw hgh, }, \n      cases ha, { rw [\u2190 mul_one g, ha, mul_ne_mul_right g], exact h_ne_1,  },\n      rw [\u2190 one_mul g, list.eq_of_mem_singleton ha, mul_ne_mul_left g],\n      exact h_ne_1, },\n    split,\n    { rw list.pairwise_iff,\n      right,\n      use [h, [g * h, h * g]],\n      split,\n      { intros a ha,\n        cases ha, { rw [\u2190 one_mul h, ha, mul_ne_mul_left h], exact g_ne_1, }, \n        rw [\u2190 mul_one h, list.eq_of_mem_singleton ha, mul_ne_mul_right],\n        exact g_ne_1, },\n      split,\n      { rw list.pairwise_pair, \n        exact gh_ne_hg, },\n      tauto, },\n    tauto, },\n  tauto,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209213,"user_id":null,"body":"import tactic tactic.induction\nimport data.fintype.basic\nlocal attribute [instance] classical.prop_decidable\n\nuniverses u\n\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] \n  (hG4 : fintype.card G = 4) : \u2200 g h : G, g * h = h * g :=\nbegin\n  let e := _inst_2.one,\n  intros g h,\n  by_contradiction hc,\n  let gs : multiset G := [e, g, h, g*h, h*g],\n  by_cases hnodup : multiset.nodup gs,\n  { let H : finset G := { val := gs, nodup := hnodup },    \n    have hh : H \u2286 _inst_1.elems,          \n    { intros x hx,\n      apply finset.mem_univ x },\n    have he := finset.card_le_of_subset hh,    \n    have ht : (fintype.elems G).card = fintype.card G := rfl,    \n    simp [ht, hG4] at he,\n    assumption },\n  by_cases h1 : g = e; \n  by_cases h2 : h = e;\n  try { \n    simp [h1, h2, e, _inst_2.one_mul, _inst_2.mul_one] at hc, \n    contradiction },\n  by_cases h3 : g = h,\n    rw h3 at hc, simp at hc, contradiction,\n  by_cases h4 : g * h = g,\n    simp at h4, exact h2 h4,\n  by_cases h5 : g * h = h,\n    simp at h5, exact h1 h5,\n  by_cases h6 : g * h = e,\n    rw (mul_eq_one_iff_eq_inv.mp h6) at hc, \n    simp at hc, contradiction,  \n  by_cases h7 : h * g = e,\n    rw (mul_eq_one_iff_eq_inv.mp h7) at hc, \n    simp at hc, contradiction,  \n  simp at hnodup,\n  push_neg at hnodup,\n  apply hc (hnodup _ _ _);\n  repeat { split }; try { cc },\n  { exact h2 },\n  { exact h1 }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209214,"user_id":null,"body":"import data.fintype.basic tactic\n\nuniverses u\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\nbegin\n  intros g h,\n\n  by_cases one : g * h = 1, { rw eq_inv_of_mul_eq_one one, group },\n  by_cases two : g * h = g, { rw mul_right_eq_self.mp two, group },\n  by_cases thr : g * h = h, { rw mul_left_eq_self.mp thr, group },\n  by_cases fou : g = h, { rw fou },\n\n  let elems : finset G := \u27e8[1, g, h, g * h], _\u27e9, swap,\n  { simp at *, repeat { split, }, repeat { tidy, },\n    { apply two, have b := a.symm, rw [mul_right_eq_self] at b, exact b },\n    { apply thr, have b := a.symm, rw [mul_left_eq_self] at b, exact b },\n  },\n  have elemsCard : elems.card = fintype.card G := by { rw hG4, refl },\n  have x := finset.eq_univ_of_card _ elemsCard,\n  have hg := finset.mem_univ_val (h * g),\n  rw \u2190x at hg,\n  simp at *,\n  rcases hg with hg | hg | hg | hg,\n  { exfalso, rw mul_eq_one_iff_eq_inv at hg, simp [hg] at one, exact one, },\n  { exfalso, simp [hg] at two, exact two, },\n  { exfalso, simp [hg] at thr, exact thr, },\n  exact hg.symm\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209215,"user_id":106,"body":"import data.fintype.basic\n\nuniverses u\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\nbegin\n  apply iff.elim_left not_not, intro Hc',\n  cases iff.elim_left not_forall Hc' with g Hc',\n  cases iff.elim_left not_forall Hc' with h Hc',\n  have Hc : g * h \u2260 h * g := Hc', clear Hc', clear Hc',\n  have Hgh : g \u2260 h, {\n    intro, subst_vars, contradiction\n  },\n  have Hg1 : g \u2260 1, {\n    intro, apply Hc, subst_vars, rw [one_mul, mul_one],\n  },\n  have Hh1 : h \u2260 1, {\n    intro, apply Hc, subst_vars, rw [one_mul, mul_one],\n  },\n  have Hgh1 : g * h \u2260 1, {\n    intro H,\n    have H := iff.elim_right (mul_left_inj h\u207b\u00b9) H,\n    rw [mul_inv_cancel_right, one_mul] at H,\n    apply Hc, subst_vars, rw [mul_left_inv, mul_right_inv],\n  },\n  have Hhg1 : h * g \u2260 1, {\n    intro H,\n    have H := iff.elim_right (mul_left_inj g\u207b\u00b9) H,\n    rw [mul_inv_cancel_right, one_mul] at H,\n    apply Hc, subst_vars, rw [mul_left_inv, mul_right_inv],\n  },\n  have Hghg : g * h \u2260 g, {\n    intro H,\n    have H := iff.elim_right (mul_right_inj g\u207b\u00b9) H,\n    rw [\u2190mul_assoc, mul_left_inv, one_mul] at H, contradiction,\n  },\n  have Hhgh : h * g \u2260 h, {\n    intro H,\n    have H := iff.elim_right (mul_right_inj h\u207b\u00b9) H,\n    rw [\u2190mul_assoc, mul_left_inv, one_mul] at H, contradiction,\n  },\n  have Hhgg : h * g \u2260 g, {\n    intro H,\n    have H := iff.elim_right (mul_left_inj g\u207b\u00b9) H,\n    rw [mul_inv_cancel_right, mul_right_inv] at H, contradiction,\n  },\n  have Hghh : g * h \u2260 h, {\n    intro H,\n    have H := iff.elim_right (mul_left_inj h\u207b\u00b9) H,\n    rw [mul_inv_cancel_right, mul_right_inv] at H, contradiction,\n  },\n  let l : multiset G := (h * g) :: (g * h) :: h :: g :: 1 :: 0,\n  have lu : l.nodup, {\n    repeat { \n      apply multiset.nodup_cons_of_nodup,\n      simp, intro H, repeat { cases H; try { rw H at *, contradiction } },\n    },\n    apply multiset.nodup_singleton\n  },\n  have lc : finset.card { finset . val := l, nodup := lu } = 5, by apply finset.card_mk,\n  have q := finset.card_le_univ { finset . val := l, nodup := lu },\n  rw [hG4, lc] at q, simp at q, exact (lt_irrefl _ q),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209216,"user_id":null,"body":"import data.fintype.basic group_theory.order_of_element data.nat.prime tactic\n\nuniverses u\n\nvariables (G : Type u) [fintype G] [group G]\n\nlemma foo (k : \u2200 a : G, a * a = 1) (g h : G) : g * h = h * g :=\nbegin\n  have k\u2082 := k (g * h),\n  rw [\u2190mul_left_inj (h * g), one_mul, mul_assoc] at k\u2082,\n  have k\u2083 : g * h * (h * g) = 1, { rw [mul_assoc, \u2190mul_assoc h, k h, one_mul, k g ],},\n  rwa [k\u2083, mul_one] at k\u2082,\nend\n\nlemma bam {a : \u2115} (h\u2081 : a \u2223 4) (h\u2082 : a \u2260 4) : a \u2223 2 :=\nbegin\n  rw (show 4 = 2^2, from dec_trivial) at h\u2081 h\u2082,\n  have pp : nat.prime 2 := dec_trivial,\n  rw nat.dvd_prime_pow pp at h\u2081,\n  rcases h\u2081 with \u27e8 _ | _ | _ | m, hm, rfl\u27e9, -- pattern matching on `m`.\n  { simp }, { simp }, { exfalso, apply h\u2082, refl, },\n  { exfalso, simp only [nat.succ_eq_add_one] at hm, linarith, },\nend\n\n-- Copied the following result from `is_cyclic.comm_group`!\nlemma bar (H : Type u) [group H] [is_cyclic H]: \u2200 (a b : H), a * b = b * a :=\n\u03bb x y, show x * y = y * x, from\nlet \u27e8g, hg\u27e9 := is_cyclic.exists_generator H in let \u27e8n, hn\u27e9 := hg x in let \u27e8m, hm\u27e9 := hg y in  hm \u25b8 hn \u25b8 gpow_mul_comm _ _ _\n\nlemma mul_comm_of_card_eq_four (hG4 : fintype.card G = 4) : \u2200 g h : G, g * h = h * g :=\nbegin\n  haveI : decidable_eq G := classical.dec_eq G,\n  by_cases k\u2082 : \u2203 g : G, order_of g = 4,\n  { rcases k\u2082 with \u27e8g, hg\u27e9,\n    haveI : is_cyclic G := is_cyclic_of_order_of_eq_card g (hG4.symm \u25b8 hg), exact bar G, },\n  have k\u2083 : \u2200 a : G, order_of a \u2223 2 := \u03bb g, bam (hG4 \u25b8 ( (\u03bb a, order_of_dvd_card_univ) g)) (\u03bb h, k\u2082 \u27e8g, h\u27e9), \n  have k\u2084 : \u2200 a : G, a * a = 1,\n  { intro a, specialize k\u2083 a, rwa [order_of_dvd_iff_pow_eq_one, pow_two] at k\u2083, },\n  exact foo _ k\u2084,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209217,"user_id":null,"body":"import data.fintype.basic\nimport algebra.group\nimport data.multiset\nimport tactic\n\nnoncomputable theory\nopen_locale classical\n\nuniverses u\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four (G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\nbegin\n      intros,\n      by_contradiction ncomm,\n      have lt : \u2200 (L : list G), L.nodup \u2192 L.length \u2264 fintype.card G,\n      {\n          intros L L_nodup,\n          rw \u2190multiset.coe_card L,\n          rw \u2190multiset.coe_nodup at L_nodup,\n          let fs : finset G := {val := \u2191L, nodup := L_nodup},\n          exact finset.card_le_univ fs,       \n      },\n      have hg : g \u2260 1,\n      {\n          intro eqn,\n          repeat {rw eqn at ncomm},\n          simp at ncomm,\n          assumption,\n      },\n      have hh: h \u2260 1,\n      {\n          intro eqn,\n          repeat {rw eqn at ncomm},\n          simp at ncomm,\n          assumption,\n      },\n      let five := [1, g, h, g * h, h * g],\n      have : five.nodup, \n      {\n          simp,\n          push_neg,\n          repeat {split}; intro he,\n          exact hg he.symm,\n          exact hh he.symm,\n          rw \u2190inv_eq_of_mul_eq_one he.symm at ncomm,\n          simp at ncomm,\n          assumption,\n          rw \u2190inv_eq_of_mul_eq_one he.symm at ncomm,\n          simp at ncomm,\n          assumption,\n          rw he at ncomm,\n          simp at ncomm,\n          assumption,\n          let he := (inv_mul_eq_of_eq_mul he).symm,\n          simp at he,\n          exact hh he,\n          let he := (mul_inv_eq_of_eq_mul he).symm,\n          simp at he,\n          exact hh he,\n          let he := (mul_inv_eq_of_eq_mul he).symm,\n          simp at he,\n          exact hg he,\n          let he := (inv_mul_eq_of_eq_mul he).symm,\n          simp at he,\n          exact hg he,\n          exact ncomm he,                   \n      },      \n      suffices : five.length \u2264 4, {simp at this, assumption},\n      rw \u2190hG4,\n      exact lt five this,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209218,"user_id":null,"body":"import data.fintype.basic\n\nuniverses u\n \nlemma I{G: Type u}[group G]{x: G}: x*x = x \u2192 1 = x \n:= \u03bb h, calc\n    1 = x * x\u207b\u00b9   : by simp\n  ... = (x*x)*x\u207b\u00b9 : by rw h\n  ... = x*(x*x\u207b\u00b9) : by repeat {rw mul_assoc}\n  ... = x         : by simp\n\nlemma J{G: Type u}[group G]{x y: G}: x = x*y \u2192 y = 1 := \n\u03bb e, calc y = x\u207b\u00b9*x*y   : by simp\n        ... = x\u207b\u00b9*(x*y) : by rw mul_assoc\n        ... = 1         : by {rw [\u2190 e]; simp}\nlemma K{G: Type u}[group G]{x y: G}: y = x*y \u2192 x = 1 :=\n\u03bb e, calc x = x*(y*y\u207b\u00b9) : by simp\n        ... = (x*y)*y\u207b\u00b9 : by rw mul_assoc\n        ... = 1         : by {rw [\u2190 e]; simp}\n\nlemma L{G: Type u}[group G]{x y: G}: 1 = x*y \u2192 1 = y*x\n:= \u03bb h, I $ calc \n  y * x * (y * x) = y * (x*y) * x : by repeat {rw mul_assoc}\n              ... = y * 1 * x     : by rw h\n              ... = y * x         : by simp\n\nopen_locale classical\n\nlemma C{T: Type u}[fintype T](h4 : fintype.card T = 4)(a b c d e: T): \n  a = b \u2228 a = c \u2228 a = d \u2228 a = e \n        \u2228 b = c \u2228 b = d \u2228 b = e\n                \u2228 c = d \u2228 c = e\n                        \u2228 d = e := \nbegin \n    cases em (a = b), left, assumption, right,\n    cases em (a = c), left, assumption, right,\n    cases em (a = d), left, assumption, right,\n    cases em (a = e), left, assumption, right,\n    cases em (b = c), left, assumption, right,\n    cases em (b = d), left, assumption, right,\n    cases em (b = e), left, assumption, right,\n    cases em (c = d), left, assumption, right,\n    cases em (c = e), left, assumption, right,\n    cases em (d = e), assumption,\n\n    have fact0: 5 \u2264 ({a,b,c,d,e}: finset T).card,\n        repeat {rw finset.card_insert_of_not_mem}; simp; \n        try {assumption}; intro H; repeat {cases H with e H }; \n        contradiction,\n    have c: 5 \u2264 4,\n        calc 5 \u2264 ({a,b,c,d,e}: finset T).card : by assumption\n           ... \u2264 (finset.univ: finset T).card : finset.card_le_univ _\n           ... = 4 : h4,\n    repeat {cases c with e c}\nend\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four(G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\n\u03bb g h, begin\n  have H := C hG4 1 g h (g*h) (h*g),\n  repeat { cases H with e H },\n  \n  simp [\u2190 e],\n  simp [\u2190 e],\n  rw [\u2190 L e, \u2190 e],\n  rw [\u2190 L e, \u2190 e],\n  simp [e],\n  simp [J e],\n  simp [K e],\n  simp [K e],\n  simp [J e],\n  assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209219,"user_id":null,"body":"import data.fintype.basic\n\nuniverses u\n \nlemma I{G: Type u}[group G]{x: G}: x*x = x \u2192 1 = x \n:= \u03bb h, calc\n    1 = x * x\u207b\u00b9   : by simp\n  ... = (x*x)*x\u207b\u00b9 : by rw h\n  ... = x*(x*x\u207b\u00b9) : by repeat {rw mul_assoc}\n  ... = x         : by simp\n\nlemma J{G: Type u}[group G]{x y: G}: x = x*y \u2192 y = 1 := \n\u03bb e, calc y = x\u207b\u00b9*x*y   : by simp\n        ... = x\u207b\u00b9*(x*y) : by rw mul_assoc\n        ... = 1         : by {rw [\u2190 e]; simp}\nlemma K{G: Type u}[group G]{x y: G}: y = x*y \u2192 x = 1 :=\n\u03bb e, calc x = x*(y*y\u207b\u00b9) : by simp\n        ... = (x*y)*y\u207b\u00b9 : by rw mul_assoc\n        ... = 1         : by {rw [\u2190 e]; simp}\n\nlemma L{G: Type u}[group G]{x y: G}: 1 = x*y \u2192 1 = y*x\n:= \u03bb h, I $ calc \n  y * x * (y * x) = y * (x*y) * x : by repeat {rw mul_assoc}\n              ... = y * 1 * x     : by rw h\n              ... = y * x         : by simp\n\nlemma C{T: Type u}[fintype T][decidable_eq T](h4 : fintype.card T = 4)(a b c d e: T): \n  a = b \u2228 a = c \u2228 a = d \u2228 a = e \n        \u2228 b = c \u2228 b = d \u2228 b = e\n                \u2228 c = d \u2228 c = e\n                        \u2228 d = e := \nbegin \n    cases classical.em (a = b), left, assumption, right,\n    cases classical.em (a = c), left, assumption, right,\n    cases classical.em (a = d), left, assumption, right,\n    cases classical.em (a = e), left, assumption, right,\n    cases classical.em (b = c), left, assumption, right,\n    cases classical.em (b = d), left, assumption, right,\n    cases classical.em (b = e), left, assumption, right,\n    cases classical.em (c = d), left, assumption, right,\n    cases classical.em (c = e), left, assumption, right,\n    cases classical.em (d = e), assumption,\n\n    have fact0: 5 \u2264 ({a,b,c,d,e}: finset T).card,\n        repeat {rw finset.card_insert_of_not_mem}; simp; \n        try {assumption}; intro H; repeat {cases H with e H }; \n        contradiction,\n    have c: 5 \u2264 4,\n        calc 5 \u2264 ({a,b,c,d,e}: finset T).card : by assumption\n           ... \u2264 (finset.univ: finset T).card : finset.card_le_univ _\n           ... = 4 : h4,\n    repeat {cases c with e c}\nend\n\nnoncomputable instance dec_eq(T: Type u): decidable_eq T := \u03bb x y, \n    classical.prop_decidable (x = y)\n\n\/-- Every group of order 4 is commutative -\/\nlemma mul_comm_of_card_eq_four(G : Type u) [fintype G] [group G] (hG4 : fintype.card G = 4) :\n  \u2200 g h : G, g * h = h * g :=\n\u03bb g h, begin\n  have H := C hG4 1 g h (g*h) (h*g),\n  repeat { cases H with e H },\n  \n  simp [\u2190 e],\n  simp [\u2190 e],\n  rw [\u2190 L e, \u2190 e],\n  rw [\u2190 L e, \u2190 e],\n  simp [e],\n  simp [J e],\n  simp [K e],\n  simp [K e],\n  simp [J e],\n  assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e90c3814af7f4002e2535af":[{"id":209220,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 := \u27e8unit, empty, \u03bb h, by cases h.mp \u27e8\u27e9\u27e9\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209221,"user_id":659,"body":"import tactic\n\ntheorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 :=\nbegin\n  -- let \u03b1 be the empty type\n  use empty,\n  -- let \u03b2 be the type `unit` with one term\n  use unit,\n  -- assume they're equal\n  intro h,\n  -- I can prove that `unit` has a term\n  have h2 : \u2203 b : unit, true,\n    use (),\n  -- and now I can deduce that `empty` has a term.\n  rw \u2190h at h2,\n  -- so let's look at all the cases\n  rcases h2 with \u27e8\u27e8\u27e9, _\u27e9,\n  -- there aren't any cases\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209222,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 :=\n\u27e8unit, empty, \u03bb h, match eq.mp h () with end\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209223,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 := \u27e8unit, empty, by intro h; cases h.mp ()\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209224,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 :=\nbegin\n  existsi unit, existsi empty, \n  intro h,\n  have u : unit, exact(unit.star),\n  rw h at u, cases u,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209225,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 := by\nbegin\n  existsi empty,\n  existsi unit,\n  intro p,\n  have q : unit := unit.star,\n  rw\u2190 p at q,\n  cases q,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209226,"user_id":null,"body":"import tactic\ntheorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 :=\nbegin\n  use [\u2115, bool],\n  intro h,\n  have := char_zero.infinite \u2115,\n  rw h at this,\n  apply this.1,\n  exact bool.fintype,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209227,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 :=\nbegin\n  have h : empty \u2260 unit,\n  by_contra,\n  have f : unit \u2192 empty := id _,\n  cases f unit.star,\n  rw h,\n  exact id,\n  exact \u27e8  empty,unit, h \u27e9 ,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209228,"user_id":null,"body":"import tactic\n\ntheorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 := \nbegin\n  use [empty, \u2115],\n  intros h,\n  have z := 0,\n  rw \u2190 h at z,\n  cases z,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209229,"user_id":null,"body":"theorem exists_Type_ne : \u2203 \u03b1 \u03b2 : Type, \u03b1 \u2260 \u03b2 := \u27e8_, empty, \u03bb h, match h.mp () with end\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e90debc151f6b002b405672":[{"id":209230,"user_id":null,"body":"import Preloaded tactic.ring\n\n-- Prove that all of the x_i are integers\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := begin\n  suffices : \u2200 (n : \u2115), \u2203 a b : \u2124, x n = a \u2227 x (n+1) = b \u2227 b^2 + 2 = 4*a*b - a^2,\n  { obtain \u27e8z, _, h, _\u27e9 := this n, exact \u27e8z, h\u27e9 },\n  intro n, induction n with n IH,\n  { exact \u27e81, 1, rfl, rfl, rfl\u27e9 },\n  rcases IH with \u27e8a, b, ha, hb, h\u27e9,\n  refine \u27e8b, 4*b-a, hb, _, _\u27e9,\n  { rw [x, hb, ha, div_eq_iff]; norm_cast,\n    { rw h, ring },\n    { rintro rfl,\n      have := add_le_add_right (pow_two_nonneg b) 2,\n      rw h at this, norm_num at this } },\n  { convert congr_arg (\u03bb x, 15*b^2 - 8*a*b + a^2 + x) h using 1; ring }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209231,"user_id":null,"body":"import Preloaded data.int.parity tactic \n\n-- in fact we'll show that the following integers work.\ndef a : \u2115 \u2192 \u2124\n| 0 := 1\n| 1 := 1\n| (n+2) := 4*(a (n+1)) - a n \n\n--the equality of the two sequences\n--can be deduced from the following lemma.\nlemma helper (n : \u2115 ) : (a n)^2 - 4*(a n)*(a (n+1)) + a(n+1)^2 = -2 :=\nbegin\n  induction n with n hn,\n  refl,\n  simp only [a, \u2190hn],\n  ring_nf,\nend\n\n-- we'll also need the fact that a n \u2260 0,\nlemma helper2 (n : \u2115 ): a n \u2260 0 :=\nbegin\n  suffices : odd (a n) \u2227 odd (a(n+1)),\n  {\n    intro hn,\n    simp [hn] at *,\n    assumption,\n  },\n  induction n with n hn,\n  exact \u27e8 \u27e8 0,rfl\u27e9,\u27e8 0,rfl\u27e9\u27e9,\n  split,\n  exact hn.2,\n  simp only [a],\n  cases hn.1 with k hn,\n  use 2* a(n+1) -k-1,\n  simp only [hn, nat.succ_eq_add_one],\n  ring,\nend\n\n\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := \nbegin\n  suffices : ((a n):\u211a) = x n \u2227 ((a (n+1):\u211a)) = x (n+1),\n  { exact \u27e8 a n, by rw this.1\u27e9 },\n  induction n with n hn,\n  simp [a,x],\n  split,\n  { exact hn.2 },\n  simp [nat.succ_eq_add_one] at *,\n  simp [a,x],\n  rw [\u2190 hn.1,\u2190 hn.2],\n  refine (eq_div_iff _).mpr _,\n  { norm_cast, exact helper2 n,},\n  clear hn,\n  have := helper n,\n  norm_cast,\n  simp [nat.succ_eq_add_one],\n  symmetry,\n  apply int.sub_eq_zero_iff_eq.1,\n  rw \u2190 int.sub_eq_zero_iff_eq at this,\n  ring_nf at *,\n  assumption,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209232,"user_id":null,"body":"import Preloaded\nimport data.rat.basic\nimport data.int.gcd\nimport algebra.order.field\nimport data.real.sqrt\nimport tactic.ring_exp\n\n-- Prove that all of the x_i are integers\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := \nbegin \n  set a := (3 - real.sqrt 3)\/6,\n  set b := (3 + real.sqrt 3)\/6,\n  set r := 2 + real.sqrt 3,\n  set s := 2 - real.sqrt 3,\n\n  set y : \u2115 \u2192 \u211d := \u03bb n, a * r^n + b * s^n,\n\n  have hrs : r^2 + s^2 = 14 \u2227 r * s = 1,\n  split;\n  { simp_rw [r, s],\n    ring_nf,\n    rw real.sq_sqrt; norm_num, },\n\n  have hab : a * b = 1\/6,\n  { simp_rw [a, b],\n    ring_nf,\n    rw real.sq_sqrt; norm_num, },\n\n  have sqrt_3_lt_2 : real.sqrt 3 < 2,\n  { suffices : real.sqrt 4 = 2, by { rw \u2190 this, apply real.sqrt_lt_sqrt; norm_num, }, \n    rw real.sqrt_eq_iff_sq_eq; norm_num, },\n\n  have y_ne0 : \u2200 (n : \u2115), y n \u2260 0, \n  { intro n, \n    suffices : y n > 0, by exact ne_of_gt this,\n    simp_rw [y], \n    apply add_pos, \n    { induction n with m hm,\n      rw [pow_zero, mul_one],\n      apply div_pos,\n      { apply sub_pos.2 (lt_trans sqrt_3_lt_2 (show (2:\u211d)<(3:\u211d), by norm_num)), },\n      { norm_num },\n      rw [pow_succ, mul_comm r, \u2190 mul_assoc], \n      apply mul_pos hm,\n      apply add_pos; norm_num, },\n    { induction n with m hm,\n      rw [pow_zero, mul_one],\n      apply div_pos,\n      { apply add_pos; norm_num, },\n      { norm_num },\n      rw [pow_succ, mul_comm s, \u2190 mul_assoc], \n      apply mul_pos hm,\n      { apply sub_pos.2 sqrt_3_lt_2, }, }, },\n \n  have hr : r^2 - 4*r + 1 = 0,\n  { simp_rw [r], ring_exp, rw real.sq_sqrt; norm_num, },\n  have hs : s^2 - 4*s + 1 = 0,\n  { simp_rw [s], ring_exp, rw real.sq_sqrt; norm_num, },\n\n  have y_rec1 : \u2200 (n : \u2115), (y (n+2)) * (y n) = (y (n+1))^2 + 2, \n  { intro n,\n    simp_rw [y],\n    calc (a * r^(n+2) + b * s^(n+2)) * (a * r^n + b * s^n)                \n        = a^2 * r^(2*n+2) + b^2 * s^(2*n+2) + (a*b) * (r*s)^n * (r^2 + s^2) : by ring_exp\n    ... = a^2 * r^(2*n+2) + b^2 * s^(2*n+2) + (1\/6) * 1^n * 14      : by rw [hab, hrs.1, hrs.2]\n    ... = a^2 * r^(2*n+2) + b^2 * s^(2*n+2) + ((1\/6) * 1 * 2 + 2)   : by norm_num\n    ... = a^2 * r^(2*n+2) + b^2 * s^(2*n+2) + (a*b*(r*s)^(n+1)*2+2) : by rw [hab, hrs.2, one_pow]\n    ...                  = (a * r^(n+1) + b * s^(n+1))^2 + 2        : by ring_exp, },\n\n  clear hab hrs,\n\n  have y_rec2 : \u2200 (n : \u2115), y (n+2) = 4 * (y (n+1)) - y(n),\n  { intro n,\n    suffices : 0 = y(n+2) - 4 * (y (n+1)) + y(n), by linarith,\n    simp_rw [y],\n    calc 0 = a * r^n * 0 + b * s^n * 0                             : by ring\n      ...  = a * r^n * (r^2 - 4*r + 1) + b * s^n * 0               : by rw \u2190 hr\n      ...  = a * r^n * (r^2 - 4*r + 1) + b * s^n * (s^2 - 4*s + 1) : by rw \u2190 hs\n      ...  = a*r^(n+2) + b*s^(n+2) - 4*(a*r^(n+1) + b*s^(n+1)) + (a*r^n + b*s^n) : by ring_exp }, \n\n  clear hr hs,\n\n  have formula : \u2200 (n : \u2115), y n = ((x n) : \u211d),\n  { intro n,\n    apply nat.strong_induction_on n, \n    intros c IH,\n    cases c with d, \n    { simp only [y, x, a, b], norm_num, linarith, },    \n    cases d with e, \n    { simp only [y, x, a, b, r, s], norm_num, ring_nf, norm_num, },\n    rw ((div_eq_iff (y_ne0 e)).2 (y_rec1 e).symm).symm, \n    rw [(IH e (show e<e+2, by linarith)), (IH (e+1) (show e+1<e+2, by linarith))],\n    simp [x], },\n  \n  have is_int : \u2200 (n : \u2115), \u2203 z : \u2124, (y n) = (z : \u211d),\n  { intro n,\n    apply nat.strong_induction_on n, \n    intros n IH,\n    cases n with j hj,\n    { use 1, simp_rw [y], norm_num, simp_rw [a, b], linarith, },\n    cases j with k hk,\n    { use 1, simp_rw [y], norm_num, simp_rw [a, b, r, s], ring_exp, rw real.sq_sqrt; norm_num, }, \n    cases IH k     (show k   < k+2, by linarith) with y_k hy_k,\n    cases IH (k+1) (show k+1 < k+2, by linarith) with y_k_plus_1 hy_k_plus_1,\n    use 4 * y_k_plus_1 - y_k,\n    simp [y_rec2 k, hy_k_plus_1, hy_k], },\n  \n  cases is_int n with z hz,\n  use z,\n  suffices : ((x n) : \u211d) = ((z : \u211a) : \u211d), by { rwa rat.cast_inj at this, },\n  rwa [rat.cast_coe_int, \u2190 formula n],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209233,"user_id":null,"body":"import Preloaded\nimport tactic\n\ndef x':\u2115\u2192\u211a\n| 0:=1\n| 1:=1\n|(n+2):=4*(x' (n+1)) - (x' n)\n\nlemma strong_induction : \u2200(C:\u2115\u2192Prop), C 0 \u2192 \n(\u2200(n:\u2115),(\u2200(x:\u2115)(h:x\u2264n),C x) \u2192 C (n+1)) \u2192\n\u2200(n x:\u2115)(h:x\u2264n),C x := by{\n  intros C h\u2081 h\u2082 n,\n  induction n,{\n    finish,\n  },{\n    have cnsucc:=h\u2082 n_n n_ih,\n    intros x hx,\n    cases hx with _ hxl,{\n      tauto,\n    },{\n      tauto,\n    }\n  }\n}\n\nlemma x_x'_eq :\u2200(n:\u2115),(x n)=(x' n):=by{\n  have h\u2080 : x 0 = x' 0, refl,\n  have h\u2081 : (\u2200(n:\u2115),(\u2200(z:\u2115)(h:z\u2264n),x z = x' z) \u2192 x (n+1) = x' (n+1)),{\n    intros n h,\n    induction n with n nh,{\n      tauto,\n    },{\n      induction n with n nh1,{\n        unfold x x',\n        norm_num,\n      },{\n        have h\u2081:=h n (self_le_add_right n 2),\n        have h\u2082:=h (n+1) (self_le_add_right (n+1) 1),\n        have h\u2083:=h (n+2) (le_of_eq (eq.refl (n+2))),\n        unfold1 x x',\n        rw [h\u2083,h\u2082],\n        clear nh nh1,\n        unfold x',\n        unfold x x' at h\u2083,\n        rw [h\u2081,h\u2082] at h\u2083,\n        have h\u2084:\u2200n,x n\u22600,{\n          have h\u2084:x (0)\u22600,{\n            unfold x,\n            norm_num,\n          },\n          have h\u2085:(\u2200(n:\u2115),(\u2200(z:\u2115)(h:z\u2264n),x (z)\u22600) \u2192 x (n+1)\u22600),{\n            clear_except,\n            intros n h,\n            induction n with n nh,{\n              unfold x,\n              norm_num,\n            },{\n              unfold x,\n              have h\u2081:=h (n+1) (le_of_eq (eq.refl (n+1))),\n              have h\u2082:=h n (self_le_add_right (n) 1),\n              have h\u2083:(x (n+1))^2 >0,{\n                exact pow_bit0_pos h\u2081 1,\n              },\n              have h\u2085:(x (n+1))^2+2>0,{\n                linarith,\n              },\n              have h\u2086:(x (n+1))^2+2\u22600,{\n                linarith,\n              },\n              exact div_ne_zero h\u2086 h\u2082,\n            }\n          },\n          have h\u2086:=strong_induction (\u03bbn,x n\u22600) h\u2084 h\u2085,\n          intro n,\n          exact h\u2086 (n) (n) (le_of_eq (eq.refl(n))),\n        },\n        have h\u2085:=h\u2084(n+1),\n        rw h\u2082 at h\u2085,\n        have h\u2086:=h\u2084(n),\n        rw h\u2081 at h\u2086,\n        apply (div_eq_iff h\u2085).mpr,\n        ring_nf,\n        simp [sub_mul],\n        apply eq_of_sub_eq_zero,\n        ring_nf,\n        have h7:=(div_eq_iff h\u2086).mp h\u2083,\n        ring_exp! at h\u2083,\n        have h8:=sub_eq_zero_of_eq h7,\n        ring_nf at h8,\n        exact h8,\n      }\n    }\n  },\n  intro n,\n  exact strong_induction (\u03bbn,x n=x' n) h\u2080 h\u2081 n n (le_of_eq (eq.refl n)),\n}\n\nlemma all_integers_x' (n:\u2115):\u2203z:\u2124,(x' n:\u211a)=z:=by{\n  have h0:\u2203z:\u2124,x' 0=z,{\n    use 1,\n    norm_cast at *,\n  },\n  have h1:(\u2200(n:\u2115),(\u2200(y:\u2115)(h:y\u2264n),\u2203z:\u2124,x' y=z) \u2192 \u2203z:\u2124,x' (n+1)=z),{\n    intros n h,\n    induction n with n nh,{\n      use 1,\n      norm_cast at *,\n    },{\n      have h1:=h (n+1) (le_of_eq (eq.refl(n+1))),\n      have h2:=h n (self_le_add_right n 1),\n      cases h1 with z1 hz1,\n      cases h2 with z2 hz2,\n      use 4*z1-z2,\n      unfold x',\n      rw [hz1,hz2],\n      norm_cast at *,\n    }\n  },\n  exact strong_induction (\u03bbn,\u2203z:\u2124,x' n=z) h0 h1 n n (le_of_eq (eq.refl n)),\n}\n\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := by{\n  have h0:=all_integers_x' n,\n  cases h0 with z hz,\n  use z,\n  have h1:=x_x'_eq n,\n  finish,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209234,"user_id":null,"body":"import Preloaded\nimport data.int.gcd data.nat.parity tactic \n\/-\ndef x : \u2115 \u2192 \u211a\n| 0 := 1\n| 1 := 1\n|(n + 2) := ((x (n + 1))^2 + 2) \/ x n\n-\/\n\ntheorem all_nats : \u2200(n : \u2115), \u2203(z : \u2115), (x n : \u211a) = z \u2227 odd z\n| 0 := by {use 1, simp [x]}\n| 1 := by {use 1, simp [x]}\n| 2 := by {use 3, simp [x], norm_num }\n| 3 := by {use 11, simp [x], norm_num }\n| (n+4) := \n  begin    \n    rcases (all_nats n) with \u27e8z, hz, hoz\u27e9,\n    rcases (all_nats (n+1)) with \u27e8a, ha, hoa\u27e9,\n    rcases (all_nats (n+2)) with \u27e8b, hb, hob\u27e9,\n    rcases (all_nats (n+3)) with \u27e8c, hc, ck, hck\u27e9,\n    have auxz : (z : \u211a) \u2260 0 := by simp [nat.odd_gt_zero hoz, ne_of_gt],\n    have auxa : (a : \u211a) \u2260 0 := by simp [nat.odd_gt_zero hoa, ne_of_gt],\n    have auxb : (b : \u211a) \u2260 0 := by simp [nat.odd_gt_zero hob, ne_of_gt],    \n    cases hob with B hB,\n    have hgcd : nat.gcd a b = 1,\n      have hx : x (n+2) = ((x (n+1))^2 + 2) \/ x n := by simp [x],\n      simp [ha, hb, hz] at hx,\n      field_simp at hx,\n      norm_cast at hx,\n      have h1 : a.gcd b \u2223 b * z := \n        nat.dvd_trans (nat.gcd_dvd_right a b) (nat.dvd_mul_right b z),\n      rw hx at h1,\n      have h2 : a.gcd b \u2223 a^2,\n        rw pow_two, \n        exact nat.dvd_trans (nat.gcd_dvd_left _ _) (nat.dvd_mul_right a a),\n      have h3 : a.gcd b \u2223 2,\n        have t:=nat.dvd_sub' h1 h2,\n        simp [add_sub_cancel'] at t,\n        assumption,\n      have h4 :=nat.le_of_dvd (by linarith) h3,\n      cases a.gcd b,\n        exfalso, norm_num at h3,\n      cases n_1,\n        refl,\n      cases n_1,\n        exfalso, \n        have h5 : 2 \u2223 a, \n          exact nat.prime.dvd_of_dvd_pow (show nat.prime 2, by norm_num) h2,\n        exact (nat.two_dvd_ne_zero.mpr (nat.odd_iff.mp hoa)) h5,\n      exfalso, \n      simp [nat.succ_eq_add_one] at h4,\n      linarith,    \n    have h1 : nat.gcd (a^2) b = 1,\n      have t:=nat.coprime.pow 2 1 hgcd,\n      rwa [nat.coprime, pow_one] at t,\n    have h2 : a^2 \u2223 (b^2 + 2)^2 + 2 * a^2,\n      have hd : ((x (n+2))^2 + 2) \/ (x (n+1)) = \u2191c,\n        simp [x] at *, assumption,\n      use c^2 + 2,\n      rw [ha, hb] at hd,\n      field_simp at hd,\n      norm_cast at hd,\n      rw hd,\n      ring_nf,\n    have h3 : b \u2223 (b^2 + 2)^2 + 2 * a^2,\n      simp [x] at *,\n      use [b^3 + 4 * b + 2 * z],\n      rw [ha, hz] at hb,\n      have : (z : \u211a) \u2260 0,\n        intros hz,\n        simp [hz] at hb, norm_cast at hb, exact auxb (eq.symm hb),\n      field_simp at hb,\n      norm_cast at hb,\n      ring_nf,\n      rw [show 4 = 2 * 2, by norm_num, \u2190mul_add, hb],\n      ring_nf,\n    have h4 : a^2 * b \u2223 (b^2 + 2)^2 + 2 * a^2,\n      exact nat.coprime.mul_dvd_of_dvd_of_dvd h1 h2 h3,      \n    cases h4 with d hd,\n    use d,\n    have he : ((((x (n+2))^2 + 2)\/ (x (n+1)))^2 + 2) \/ (x (n+2)) = \u2191d,\n      rw [ha, hb],\n      field_simp,\n      rw_mod_cast [hd],\n      ac_refl,\n    simp [x] at *,\n    split,\n    { assumption },\n    intros hed,\n    cases hed with D hD,\n    rw [hB, hD] at hd,\n    have g1 : (((2 * B + 1) ^ 2 + 2) ^ 2 + 2 * a ^ 2) % 2 = 1,\n    { have hmod : (2*B+1) % 2 = 1 := by simp [add_comm, \u2190nat.add_mod_mod],\n      simp,\n      rw [add_comm, pow_two, pow_two], \n      simp [nat.mul_mod, hmod] }, \n    have g2 : (a ^ 2 * (2 * B + 1) * (2 * D)) % 2 = 0,\n    { rw [nat.mul_mod, nat.mul_mod, nat.mul_mod], \n      norm_num }, \n    rw [hd, g2] at g1,\n    exact zero_ne_one g1,\n  end\n\n  theorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := \n  begin\n    rcases all_nats n with \u27e8z, hoz, hz\u27e9,\n    use z,\n    simp [hoz],\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209235,"user_id":196,"body":"-- written with the help of @kbuzzard\n\nimport Preloaded tactic.ring\n\ndef y : \u2115 \u2192 \u2124\n| 0 := 1\n| 1 := 1\n| (n+2) := 4 * y(n+1) - y(n)\n\ntheorem useful (n : \u2115) : y n * y (n+2) = (y (n+1))^2 + 2 :=\nbegin\n  change y n * (4 * y (n+1) - y n) = y (n+1) ^ 2 + 2,\n  induction n with n ih,\n  { unfold y, norm_num },\n  change y (n+1) * (4 * (4 * y (n+1) - y n) - y (n+1)) = (4 * y (n+1) - y n) ^ 2 + 2,\n  rw \u2190 sub_eq_zero at ih \u22a2, rw \u2190 ih, ring\nend\n\ntheorem x_pos : \u2200 n, x n > 0\n| 0     := zero_lt_one\n| 1     := zero_lt_one\n| (n+2) := div_pos (add_pos_of_nonneg_of_pos (pow_two_nonneg _) zero_lt_two) (x_pos n)\n\ntheorem x_eq_y : \u2200 n, x n = y n\n| 0     := by rw [y, int.cast_one]; refl\n| 1     := by rw [y, int.cast_one]; refl\n| (n+2) := (div_eq_iff_mul_eq $ ne_of_gt $ x_pos n).2 $\n    by rw [x_eq_y, x_eq_y, \u2190 int.cast_mul, mul_comm, useful]; norm_cast\n\n-- Prove that all of the x_i are integers\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z :=\n\u27e8y n, x_eq_y n\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209236,"user_id":196,"body":"-- written with the help of @kbuzzard\n\nimport Preloaded tactic.ring\n\ndef y : \u2115 \u2192 \u2124\n| 0 := 1\n| 1 := 1\n| (n+2) := 4 * y(n+1) - y(n)\n\ntheorem useful (n : \u2115) : y n * y (n+2) = (y (n+1))^2 + 2 :=\nbegin\n  change y n * (4 * y (n+1) - y n) = y (n+1) ^ 2 + 2,\n  induction n with n ih,\n  { unfold y, norm_num },\n  change y (n+1) * (4 * (4 * y (n+1) - y n) - y (n+1)) = (4 * y (n+1) - y n) ^ 2 + 2,\n  rw \u2190 sub_eq_zero at ih \u22a2, rw \u2190 ih, ring\nend\n\ntheorem x_pos : \u2200 n, x n > 0\n| 0     := zero_lt_one\n| 1     := zero_lt_one\n| (n+2) := div_pos (add_pos_of_nonneg_of_pos (pow_two_nonneg _) zero_lt_two) (x_pos n)\n\ntheorem x_eq_y : \u2200 n, x n = y n\n| 0     := by rw [y, int.cast_one]; refl\n| 1     := by rw [y, int.cast_one]; refl\n| (n+2) := (div_eq_iff_mul_eq $ ne_of_gt $ x_pos n).2 $\n    by rw [x_eq_y, x_eq_y, \u2190 int.cast_mul, mul_comm, useful]; norm_cast\n\n-- Prove that all of the x_i are integers\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z :=\n\u27e8y n, x_eq_y n\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209237,"user_id":106,"body":"import Preloaded\nimport data.rat.basic\nimport tactic\n\ndef y : \u2115 \u2192 \u211a\n| 0 := 1\n| 1 := 1\n|(n + 2) := 4 * y (n + 1) - y n\n\nlemma ind_2 { P : (\u2115 \u2192 Prop) } :\n  P 0 \u2192 P 1 \u2192 \n  (\u2200 (n : \u2115), P n \u2192 P (n + 1) \u2192 P (n + 2)) \u2192\n  (\u2200 (n : \u2115), P n) :=\nbegin\n  intros p0 p1 ph n,\n  apply and.elim_left (_ : _ \u2227 P (n + 1)),\n  induction n with n ih, simp, finish,\n  rw [nat.succ_eq_add_one, add_assoc, one_add_one_eq_two],\n  finish\nend\n\nlemma x_pos (n : \u2115) : x n > 0 :=\nbegin\n  revert n, apply ind_2,\n  { unfold x, apply zero_lt_one, },\n  { unfold x, apply zero_lt_one, },\n  intros n h0 h1, unfold x, rw nat.succ_eq_add_one,\n  have h := pow_two_nonneg (x (n + 1)),\n  have h : x (n + 1) ^ 2 + 2 > 0, by linarith,\n  apply div_pos h h0,\nend\n\nlemma y_diff (n : \u2115) : y (n + 1) ^ 2 + 2 = y (n + 2) * y n :=\nbegin\n  induction n with n ih,\n  { unfold y, ring },\n  unfold y at *, rw nat.succ_eq_add_one at *,\n  rw ((by ring) : 4 * (4 * y (n + 1) - y n) = 16 * y (n + 1) - 4 * y n),\n  rw ((by ring) : (16 * y (n + 1) - 4 * y n - y (n + 1)) * y (n + 1) = 15 * (y (n + 1) ^ 2) - 4 * y n * y (n + 1)),\n  rw ((by ring) : (4 * y (n + 1) - y n) ^ 2 = 16 * (y (n + 1) ^ 2) - 8 * y n * y (n + 1) + y n ^ 2),\n  rw eq_sub_iff_add_eq,\n  rw ((by ring) : 16 * y (n + 1) ^ 2 - 8 * y n * y (n + 1) + y n ^ 2 + 2 + 4 * y n * y (n + 1) = \n    (16 * y (n + 1) ^ 2 + y n ^ 2 + 2) - 4 * y n * y (n + 1)),\n  symmetry, rw [eq_sub_iff_add_eq, \u2190eq_sub_iff_add_eq'],\n  rw ((by ring) : 16 * y (n + 1) ^ 2 + y n ^ 2 + 2 - 15 * y (n + 1) ^ 2 = y (n + 1) ^ 2 + y n ^ 2 + 2),\n  rw ((by ring) : (4 * y (n + 1) - y n) * y n = (4 * y (n + 1) * y n - y n ^ 2)) at ih,\n  rw eq_sub_iff_add_eq at ih, linarith\nend\n\ntheorem impl_eq (n : \u2115) : x n = y n :=\nbegin\n  revert n, apply ind_2,\n  { unfold x y },\n  { unfold x y },\n  intros n h0 h1, unfold x at *, rw nat.succ_eq_add_one,\n  rw [h1, \u2190mul_left_inj' (ne_of_gt (x_pos n)), div_mul_cancel _ (ne_of_gt (x_pos n)), h0],\n  rw y_diff n\nend\n\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := \nbegin\n  rw impl_eq,\n  revert n, apply ind_2,\n  { unfold y, existsi (1 : \u2124), simp },\n  { unfold y, existsi (1 : \u2124), simp },\n  intros n ha hb, cases ha with a ha, cases hb with b hb,\n  unfold y, rw nat.succ_eq_add_one,\n  existsi (4 * b - a),\n  rw [int.cast_sub, int.cast_mul, ha, hb], refl\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209238,"user_id":null,"body":"import Preloaded data.rat.order tactic\n\ndef y : \u2115 \u2192 \u2124\n| 0 := 1\n| 1 := 1\n| (n + 2) := 4*(y (n + 1)) - (y n)\n\nlemma x_pos : \u2200 n, 0 < x n\n| 0 := dec_trivial\n| 1 := dec_trivial\n| (n + 2) := div_pos\n    (add_pos\n        (pow_pos (x_pos (n + 1)) 2)\n        dec_trivial\n    )\n    (x_pos n)\n\nlemma x_eq_y : \u2200 n, x n = y n\n| 0 := rfl\n| 1 := rfl\n| 2 := rfl\n| (n + 3) :=\ncalc x (n + 3) = ((x (n + 2))^2 + 2)\/(x (n + 1)) : rfl\n... = ((x (n + 2))*(x (n + 2)) + 2)\/(x (n + 1)) : by ring\n... = ((x (n + 2))*(y (n + 2)) + 2)\/(x (n + 1)) : by rw x_eq_y\n... = ((x (n + 2))*(4*(y (n + 1)) - (y n) : \u2124) + 2)\/(x (n + 1)) : by rw y\n... = ((x (n + 2))*(4*(x (n + 1)) - (x n)) + 2)\/(x (n + 1)) : by push_cast; rw [\u2190 x_eq_y, \u2190 x_eq_y]\n... = (4*(x (n + 2))*(x (n + 1)) - (x (n + 2))*(x n) + 2)\/(x (n + 1)) : by ring\n... = (4*(x (n + 2))*(x (n + 1)) - (((x (n + 1))^2 + 2) \/ x n)*(x n) + 2)\/(x (n + 1)) : by rw x\n... = (4*(x (n + 2))*(x (n + 1)) - ((x (n + 1))^2 + 2) + 2)\/(x (n + 1)) : by simp [x_pos n, ne_of_gt]\n... = (4*(x (n + 2))*(x (n + 1)) - (x (n + 1))*(x (n + 1)))\/(x (n + 1)) : by ring\n... = 4*(x (n + 2)) - (x (n + 1)) : by simp [x_pos (n + 1), ne_of_gt, sub_div]\n... = 4*(y (n + 2)) - (y (n + 1)) : by rw [x_eq_y, x_eq_y]\n... = (4*(y (n + 2)) - (y (n + 1)) : \u2124) : by push_cast\n... = y (n + 3) : rfl\n\n-- Prove that all of the x_i are integers\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z := \u27e8y n, x_eq_y n\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209239,"user_id":644,"body":"import Preloaded tactic\n\ndef y : \u2115 \u2192 \u2124\n| 0     := 1\n| 1     := 1\n| (n+2) := 4 * y (n + 1) - y n\n\nlemma y_lemma : \u2200 n, \n  y (n+1)^2 = 4 * y (n+1) * y n - y n ^2 - 2\n| 0 := rfl\n| (n+1) := by rw [y, y_lemma]; ring\n\nlemma y_mono : \u2200 n, 0 < y (n+1) \u2227 y n \u2264 y (n + 1)\n| 0     := dec_trivial\n| 1     := dec_trivial\n| (n+1) :=\nbegin\n  rw y, \n  rcases y_mono n with \u27e8_, _\u27e9,\n  split;\n  linarith\nend\n\nlemma y_pos : \u2200 n, 0 < y n\n| 0     := dec_trivial\n| (n+1) := (y_mono n).1\n\nlemma x_eq_y : \u2200 n : \u2115, x n = y n \n| 0     := rfl\n| 1     := rfl\n| (n+2) := \nhave (y n : \u211a) \u2260 0, by norm_cast; exact ne_of_gt (y_pos n),\nbegin\n  rw [x, y, x_eq_y, x_eq_y, \u2190 int.cast_pow, y_lemma,\n    div_eq_iff this, nat.succ_eq_add_one], \n  push_cast,\n  ring\nend\n\n-- Prove that all of the x_i are integers\ntheorem all_integers (n : \u2115) : \u2203 z : \u2124, (x n : \u211a) = z :=\n\u27e8y n, x_eq_y n\u27e9\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e9900b311efe00001996e26":[{"id":209240,"user_id":657,"body":"import Preloaded\nimport tactic\n\ntheorem correct_version : \u00ac bad_theorem :=\nbegin\n-- we'll construct a counterexample\nrw bad_theorem, \nrefine classical.not_forall.mpr _, use unit,\n-- we're using unit but any inhabited type would work\nrefine classical.not_forall.mpr _, use (\u03bb x,\u03bb y, false),\n-- we use the relation is never satisfied\npush_neg, split,\nrw symmetric, intros, exact a,\n-- the definition of symmetry only fires once you've got some related pair, so there's nothing to check\nsplit,\nrw transitive, intros, exact a,\n-- for transitivity you need two related pairs! so the same tactic script works\nrw reflexive, simp,\n-- but it's not reflexive. since \\alpha is inhabited there is an x : \\alpha and reflexivity demands r x x.\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209241,"user_id":196,"body":"import Preloaded\n\ntheorem correct_version : \u00ac bad_theorem :=\n\u03bb H, H unit (\u03bb _ _, false) (\u03bb _ _, id) (\u03bb _ _ _ _ , id) ()\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209242,"user_id":168,"body":"import Preloaded\n\ntheorem correct_version : \u00ac bad_theorem :=\n  \u03bb h, h bool empty_relation (\u03bb _ _, id) (\u03bb _ _ _ _, id) tt","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209243,"user_id":660,"body":"import tactic\nimport Preloaded\n\ntheorem correct_version : \u00ac bad_theorem :=\n\u03bb a, a \u2115 (\u03bb _ _, false) (by tauto) (by tauto) 0","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209244,"user_id":null,"body":"import Preloaded\n\nimport tactic.basic\n\n\ndef myrel : \u2115 \u2192 \u2115 \u2192 Prop := \u03bbx, \u03bby, false\n\nlemma L1: symmetric myrel :=\nbegin\n  intros a b H,\n  assumption,\nend\n\nlemma L2: transitive myrel :=\nbegin\n  intros a b c H1 H2,\n  assumption,\nend\n\nlemma L3: \u00acreflexive myrel :=\nbegin\n  intro H,\n  have Wid := H 17,\n  assumption,\nend\n\ntheorem correct_version : \u00ac bad_theorem :=\nbegin\n  intro Hyp,\n  have A := Hyp \u2115 myrel L1 L2,\n  exact L3 A,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209245,"user_id":null,"body":"import Preloaded\n\ndef empty_rel := (\u03bb x y: unit, false)\n\ntheorem correct_version : \u00ac bad_theorem :=\nbegin \n  intro h,\n  have str := h unit empty_rel,\n  have s :  symmetric empty_rel, { intros x y hs, cases hs },\n  have t : transitive empty_rel, { intros x y z ht, cases ht },\n  have r := str s t (), cases r,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209246,"user_id":null,"body":"import Preloaded\n\n@[simp] def r : (unit \u2192 unit \u2192 Prop) := (\u03bb x y, false)\n\ntheorem correct_version : \u00ac bad_theorem :=\nbegin\n  intro bad_theorem,\n  have symr : symmetric r := by {intros x y p, simp at *, exact p},\n  have transr : transitive r := by {intros x y z, simp},\n  have reflr : reflexive r := bad_theorem _ r symr transr,\n  exact (reflr unit.star),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209247,"user_id":null,"body":"import Preloaded\n\ndefinition r (a b : unit) : Prop := false\n\ntheorem correct_version : \u00ac bad_theorem :=\n\u03bb h, h unit r (by {intros _ _ _, cc}) (by {intros _ _ _, cc}) unit.star","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209248,"user_id":null,"body":"import Preloaded\n\n\ndef r : unit \u2192 unit \u2192 Prop := \u03bb _ _,false\n\ntheorem correct_version : \u00ac bad_theorem :=\nbegin\n  have h1 : symmetric r,\n  { intros x y hxy, cases hxy},\n  have h2 : transitive r,\n  { intros x y z hxy hyz, cases hxy},\n  intro h,\n  exact h _ r h1 h2 unit.star,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209249,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem correct_version : \u00ac bad_theorem :=\nbegin\n  simp [bad_theorem],\n  refine \u27e8_,_,_,_,_\u27e9,\n  { exact Prop },\n  { exact empty_relation },\n  all_goals { simp [symmetric,transitive,reflexive,empty_relation] }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e997f77ea84170016600045":[{"id":209250,"user_id":168,"body":"import Preloaded tactic data.real.basic\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin\n  have hxy : \u2200 n, abs (x n - y n) = y n - x n,\n    intro n, rw [abs_sub, abs_of_nonneg],\n    obtain \u27e8h1, h2\u27e9 := h\u2081 n, linarith,\n  split; intros e he; obtain \u27e8N, hN\u27e9 := h\u2082 e he; \n    existsi N; intros n hn;\n    obtain \u27e8ineq1, ineq2\u27e9 := h\u2081 n;\n    have := hN n hn; simp only [hxy, sub_zero] at this,\n  { rw abs_of_nonpos; linarith, },\n  { rw abs_of_nonneg; linarith, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209251,"user_id":null,"body":"import Preloaded\nimport tactic \n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin \n  split,\n  {\n    intros \u03b5 h\u03b5,\n    rcases h\u2082 \u03b5 h\u03b5 with \u27e8N, hN\u27e9,\n    use N,\n    intros n hn,\n    specialize h\u2081 n,\n    rcases h\u2081 with \u27e8hx, hy\u27e9,\n    specialize hN n hn,\n    simp at hN,\n    rw abs_lt at hN \u22a2,\n    rcases hN with \u27e8hN1, hN2\u27e9,\n    split,\n    linarith,\n    linarith,\n  },\n  {\n    intros \u03b5 h\u03b5,\n    rcases h\u2082 \u03b5 h\u03b5 with \u27e8N, hN\u27e9,\n    use N,\n    intros n hn,\n    specialize h\u2081 n,\n    rcases h\u2081 with \u27e8hx, hy\u27e9,\n    specialize hN n hn,\n    simp at hN,\n    rw abs_lt at hN \u22a2,\n    rcases hN with \u27e8hN1, hN2\u27e9,\n    split,\n    linarith,\n    linarith,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209252,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin\n  split;\n  { intros \u03b5 h\u03b5,\n    cases h\u2082 \u03b5 h\u03b5 with N hN,\n    use N,\n    intros n hnN,\n    cases h\u2081 n with hx hy,\n    specialize hN n hnN,\n    simp [abs_lt] at *,\n    split;\n    linarith, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209253,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin\n  split,\n  {\n    intros \u03b5 hep,\n    have := h\u2082 \u03b5 hep,\n    cases this with N hN,\n    use N,\n    intros n hn,\n    have := hN n hn,\n    simp at this,\n    specialize h\u2081 n,\n    rw abs_sub_lt_iff at this \u22a2,\n    cases this with _ this,\n    clear this_left,\n    split,\n    linarith,\n    linarith,\n  },\n  {\n    intros \u03b5 hep,\n    have := h\u2082 \u03b5 hep,\n    cases this with N hN,\n    use N,\n    intros n hn,\n    have := hN n hn,\n    simp at this,\n    specialize h\u2081 n,\n    rw abs_sub_lt_iff at this \u22a2,\n    cases this with _ this,\n    clear this_left,\n    split,\n    linarith,\n    linarith,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209254,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin\n  split;\n  { intros \u03b5 h\u03b5,\n    obtain \u27e8N, hN\u27e9 := h\u2082 \u03b5 h\u03b5,\n    use N,\n    intros n hn,\n    specialize hN n hn,\n    simp only [abs_lt] at hN \u22a2,\n    split; linarith [h\u2081 n], },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209255,"user_id":null,"body":"import Preloaded\n\n\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l := \n  \n   begin\n    split,\n    {\n\n      have h_xl\u2081 : \u2200 n, (l - x n) \u2264 (y n - x n) := by\n      {\n        intros,\n        have h\u2083 := (h\u2081 n).right,\n        linarith,\n      },\n      intro \u03b5,\n      intro h\u03b5,\n      specialize h\u2082 \u03b5,\n      have h\u2083 := h\u2082 h\u03b5,\n      cases h\u2083 with outer_N outer_h,\n      use outer_N,\n      intro n,\n      intro hn,\n      specialize outer_h n,\n      have h\u2084 := outer_h hn,\n      simp at h\u2084,\n      have h\u2085 : |l - x n| \u2264 |x n - y n| := by {\n        simp at *,\n        specialize h\u2081 n,\n        rcases h\u2081 with \u27e8h_xl, h_yl\u27e9,\n        have h\u2086 : | x n - y n | = |y n - x n| := abs_sub_comm (x n) (y n),\n        rw h\u2086,\n        have h\u2085 : y n - x n = y n - l + l - x n := by ring,\n        rw h\u2085,\n        have h\u2087 : |y n - l + l - x n| = |y n - l | + |l - x n| := by \n        {\n          have s\u2081  := abs_of_nonneg (sub_nonneg.mpr h_yl),\n          have s\u2082  := abs_of_nonneg (sub_nonneg.mpr h_xl),\n          rw <- s\u2081,\n          have t : |y n - l| + l - x n = |y n - l| + (l - x n) := by ring,\n          rw t,\n          rw <- s\u2082,\n          rw <- s\u2081,\n          simp,\n          linarith,\n        },\n        rw h\u2087,\n        simp,\n        exact abs_nonneg (y n - l),\n      },\n      specialize h_xl\u2081 n,\n      have h\u2086 : |y n - x n| = |x n - y n| := abs_sub_comm (y n) (x n),\n      rw <- h\u2086 at h\u2084,\n      have : |l - x n| = |x n - l| := abs_sub_comm l (x n),\n      rw <- this,\n      linarith,\n    },\n    {\n      have h_yl\u2081 : \u2200 n, (y n - l) \u2264 (y n - x n) := by\n      {\n        intros,\n        have h\u2083 := (h\u2081 n).left,\n        linarith,\n      },\n      intro \u03b5,\n      intro h\u03b5,\n      specialize h\u2082 \u03b5,\n      have h\u2083 := h\u2082 h\u03b5,\n      cases h\u2083 with outer_N outer_h,\n      use outer_N,\n      intro n,\n      intro hn,\n      specialize outer_h n,\n      have h\u2084 := outer_h hn,\n      simp at h\u2084,\n      have h\u2085 : |y n - l| \u2264 |x n - y n| := by {\n        simp at *,\n        specialize h\u2081 n,\n        rcases h\u2081 with \u27e8h_xl, h_yl\u27e9,\n        have h\u2086 : | x n - y n | = |y n - x n| := abs_sub_comm (x n) (y n),\n        rw h\u2086,\n        have h\u2085 : y n - x n = y n - l + l - x n := by ring,\n        rw h\u2085,\n        have h\u2087 : |y n - l + l - x n| = |y n - l | + |l - x n| := by \n        {\n          have s\u2081  := abs_of_nonneg (sub_nonneg.mpr h_yl),\n          have s\u2082  := abs_of_nonneg (sub_nonneg.mpr h_xl),\n          rw <- s\u2081,\n          have t : |y n - l| + l - x n = |y n - l| + (l - x n) := by ring,\n          rw t,\n          rw <- s\u2082,\n          rw <- s\u2081,\n          simp,\n          linarith,\n        },\n        rw h\u2087,\n        simp,\n        exact abs_nonneg (l - x n),\n      },\n      specialize h_yl\u2081 n,\n      linarith,\n    },\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209256,"user_id":null,"body":"import Preloaded\n\nlemma two_into_one (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 (\u2203 (N : \u2115), \u2200 (n : \u2115), N \u2264 n \u2192 (|x n - l| < \u03b5 \u2227 |y n - l| < \u03b5 ))):\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin\n  repeat {rw lim_to_inf},\n  split,\n  { intros \u03b5 \u03b5_pos,\n    have h\u2081 := h \u03b5 \u03b5_pos,\n    cases h\u2081 with N hN,\n    use N,\n    intro n,\n    intro hn,\n    have h\u2082 := hN n hn,\n    exact h\u2082.left,\n    },\n  { intros \u03b5 \u03b5_pos,\n    have h\u2081 := h \u03b5 \u03b5_pos,\n    cases h\u2081 with N hN,\n    use N,\n    intro n,\n    intro hn,\n    have h\u2082 := hN n hn,\n    exact h\u2082.right,\n    }\nend\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\n  begin\n    apply two_into_one,\n    rw lim_to_inf at h\u2082,\n    simp at h\u2082,\n    intro \u03b5,\n    intro \u03b5_pos,\n    have h\u2083 := h\u2082 \u03b5 \u03b5_pos,\n    cases h\u2083 with N hN,\n    use N,\n    intros n hn,\n    have bounds:= h\u2081 n,\n    have other_bound:= hN n hn,\n    split,\n    { rw abs_lt,\n      split,\n      { rw abs_lt at other_bound,\n        linarith},\n      { linarith [\u03b5_pos, bounds.left]},},\n    { rw abs_lt,\n      split,\n      { linarith},\n      { rw abs_lt at other_bound,\n        linarith},},\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209257,"user_id":null,"body":"import Preloaded tactic\n\nlemma sfe (a b:\u211d ) : | |a|+|b| |=|a| +|b|:= by{\n  norm_num,\n  have h0:0\u2264|a|,exact abs_nonneg a,\n  have h1:0\u2264|b|,exact abs_nonneg b,\n  exact add_nonneg h0 h1,\n}\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l := by {\n  have h0:\u2200n, abs(l-x n)=l-x n,{\n    intro n,\n    replace h\u2081:=(h\u2081 n).left,\n    have h0:l-x n\u22650,exact sub_nonneg.mpr h\u2081,\n    exact abs_eq_self.mpr h0,\n  },\n  have h1:\u2200n, abs(y n -l)=y n -l,{\n    intro n,\n    replace h\u2081:=(h\u2081 n).right,\n    have h1:y n -l\u22650,exact sub_nonneg.mpr h\u2081,\n    exact abs_eq_self.mpr h1,\n  },\n  have h5:\u2200n,x n - y n=-((l-x n) + (y n - l)),{\n    intro n,\n    specialize h\u2081 n,\n    linarith,\n  },\n  split,\n  all_goals{\n    intros \u03b5 h2,\n    specialize h\u2082 \u03b5 h2,\n    cases h\u2082 with N h3,\n    use N,\n    intros n h4,\n    specialize h3 n,\n    replace h3:= h3 h4,\n    simp at h3,\n    specialize h5 n,\n    rw h5 at h3,\n    rw [abs_neg] at h3,\n    specialize h0 n,\n    specialize h1 n,\n    rw [\u2190h0,\u2190h1] at h3,\n    rw [sfe] at h3,\n  },{\n    have h6:|x n -l|=|l - x n|,exact abs_sub_comm (x n) l,\n    rw h6,\n    have h7:0\u2264|y n -l|,exact abs_eq_self.mp (congr_arg abs h1),\n    clear_except h3 h7,\n    linarith,\n  },{\n    have h7:0\u2264|l - x n|,exact abs_nonneg (l - x n),\n    clear_except h3 h7,\n    linarith,\n  }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209258,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l :=\nbegin\n split;\n try { \n    intros \u03b5 h,\n    rcases h\u2082 \u03b5 h with \u27e8N,hN\u27e9,\n    use N,\n    intros n hn,\n    specialize hN n hn,\n    specialize h\u2081 n,\n    have := sub_le_sub h\u2081.1 h\u2081.2,\n    have H : x n - l \u2264 y n - x n := by linarith,\n    have H' : y n - l \u2264 y n - x n := by linarith,\n    have hH' : abs (y n - l) \u2264 abs (x n - y n),\n     simp [\u2190abs_neg (x n - y n)],\n     apply abs_le_abs H' _,\n     linarith,\n    have hH : abs (x n - l) \u2264 abs (x n - y n),\n     simp [\u2190abs_neg (x n - y n)],\n     apply abs_le_abs H _,\n     linarith,\n    simp at hN,\n    linarith\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209259,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p2 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, x n \u2264 l \u2227 l \u2264 y n)\n  (h\u2082 : lim_to_inf (\u03bb n, x n - y n) 0) :\n  lim_to_inf x l \u2227 lim_to_inf y l := \nbegin\n  split; intros \u03b5 h,\n\n  any_goals{rcases h\u2082 \u03b5 h with \u27e8N, h\u2083\u27e9,\n  use N, intros n h\u2084,\n  specialize h\u2083 n h\u2084, simp at h\u2083,\n  specialize h\u2081 n,\n  \n  have pos_1: y n - x n \u2265 0 := by linarith,\n  have pos_2: l - x n \u2265 0 := by linarith,\n  have pos_3: y n - l \u2265 0 := by linarith,\n  rw [abs_sub_comm, abs_of_nonneg pos_1] at h\u2083,\n  },\n  \n  {rw [abs_sub_comm, abs_of_nonneg pos_2],\n  linarith, },\n\n  {rw abs_of_nonneg pos_3,\n  linarith, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e9981da9dd96e001f3b7c0c":[{"id":209260,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l :=\n\u03bb \u03b5 h,\nmatch h\u2082 \u03b5 h with \u27e8N, h\u2082\u27e9 :=\n  \u27e8N, \u03bb n h\u2080, lt_of_le_of_lt (h\u2081 n) (lt_of_le_of_lt (le_abs_self _) (eq.subst (sub_zero (y n)) (h\u2082 n h\u2080)))\u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209261,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l :=\nbegin \n  intros \u03b5 h\u03b5,\n  rcases h\u2082 \u03b5 h\u03b5 with \u27e8N,hN\u27e9,\n  use N,\n  intros n hn,\n  specialize h\u2081 n,\n  specialize hN n hn,\n  simp at hN,\n  rw abs_lt at hN,\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209262,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l := \nbegin\n  intros \u03b5 epos,\n  cases h\u2082 \u03b5 epos with N hN,\n  use N,\n  intros n hn,\n  specialize hN n,\n  specialize h\u2081 n,\n  apply lt_of_le_of_lt h\u2081 _ ,\n  rw sub_zero at hN,\n  have :|y n|=y n,\n    apply abs_of_nonneg,\n    apply le_trans (abs_nonneg (x n - l)) h\u2081, \n  rw \u2190 this,\n  apply hN hn\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209263,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8N, hN\u27e9 := h\u2082 \u03b5 h\u03b5,\n  use N,\n  intros n hn,\n  have := (abs_lt.1 $ hN n hn).2,\n  rw sub_zero at this,\n  apply lt_of_le_of_lt (h\u2081 n) this,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209264,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l := begin\n  intros \u03b5 \u03b5_pos,\n  cases h\u2082 \u03b5 \u03b5_pos with N hN,\n  use N, intros n hn,\n  calc |x n - l| \u2264 y n : h\u2081 n\n       ... \u2264 |y n| : le_abs_self (y n)\n       ... = |y n - 0| : by simp\n       ... < \u03b5 : hN n hn\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209265,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l :=\nbegin\n intros \u03b5 h,\n rcases h\u2082 \u03b5 h with \u27e8N,hN\u27e9,\n use N,\n intros n hn,\n specialize hN n hn,\n specialize h\u2081 n,\n simp at hN,\n calc abs (x n - l) \u2264 y n       : by assumption\n                ... \u2264 abs (y n) : le_max_left (y n) (-y n)\n                ... < \u03b5         : by assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209266,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l := \nbegin\n  rw lim_to_inf at *,\n  intros \u03b5 h\u03b5,\n  specialize h\u2082 \u03b5 h\u03b5,\n  rcases h\u2082 with \u27e8N, h\u2082\u27e9,\n  use N,\n  intros n hn,\n  specialize h\u2081 n,\n  specialize h\u2082 n hn,\n  norm_num at h\u2082,\n  refine lt_of_le_of_lt h\u2081 (lt_of_abs_lt h\u2082),\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209267,"user_id":null,"body":"import Preloaded\ntheorem exercise_1p3 (x y: \u2115 \u2192 \u211d) (l: \u211d) \n  (h\u2081: \u2200 n, abs (x n - l) \u2264 y n) (h\u2082: lim_to_inf y 0): lim_to_inf x l :=\nbegin\n  intros \u03b5 p\u03b5, specialize h\u2082 \u03b5 p\u03b5, cases h\u2082 with N h\u2082, use N,\n  intros n pn, specialize h\u2081 n, specialize h\u2082 n pn, simp at h\u2082,\n  linarith [le_abs_self (y n)]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209268,"user_id":null,"body":"import Preloaded\ntheorem exercise_1p3 (x y: \u2115 \u2192 \u211d) (l: \u211d) \n  (h\u2081: \u2200 n, abs (x n - l) \u2264 y n) (h\u2082: lim_to_inf y 0): lim_to_inf x l :=\nbegin\n  intros \u03b5 p\u03b5, specialize h\u2082 \u03b5 p\u03b5, cases h\u2082 with N h\u2082, use N,\n  intros n pn, specialize h\u2081 n, specialize h\u2082 n pn, simp at h\u2082,\n  have h\u2083: y n \u2264 abs (y n), apply le_abs_self, linarith\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209269,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p3 (x y: \u2115 \u2192 \u211d) (l: \u211d) \n  (h\u2081: \u2200 n, abs (x n - l) \u2264 y n) (h\u2082: lim_to_inf y 0): lim_to_inf x l :=\nbegin\n  intros \u03b5 p\u03b5,\n  specialize h\u2082 \u03b5 p\u03b5,\n  cases h\u2082 with N h\u2082,\n  use N, intros n pn,\n  specialize h\u2081 n, specialize h\u2082 n pn, simp at h\u2082,\n  rw abs_le at h\u2081, cases h\u2081 with h\u2081n h\u2081p, rw neg_le at h\u2081n,\n  have h\u2081: abs (x n - l) \u2264 abs (y n), apply abs_le_abs h\u2081p h\u2081n, clear h\u2081p h\u2081n, linarith\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e9983456a4f5d001ad74a63":[{"id":209270,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin \n  intros \u03b5 h\u03b5,\n  rcases h\u2081 \u03b5 h\u03b5 with \u27e8N, hN\u27e9,\n  use N,\n  intros n hn,\n  simp,\n  specialize hN n hn,\n  have hs := abs_abs_sub_abs_le_abs_sub (x n) l,\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209271,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  rw [lim_to_inf] at *,\n  intros \u03b5 h\u03b5,\n  obtain \u27e8N, hN\u27e9 := h\u2081 \u03b5 h\u03b5,\n  use N,\n  intros n hn,\n  specialize hN n hn,\n  linarith [abs_abs_sub_abs_le_abs_sub (x n) l],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209272,"user_id":null,"body":"import Preloaded\n\nlemma lim_abs_eq_zero (x : \u2115 \u2192 \u211d) : lim_to_inf x 0 \u2194 lim_to_inf (\u03bb n, |x n|) 0 :=\nby { unfold lim_to_inf, simp_rw [sub_zero, abs_abs], }\n\nlemma lim_neg {x : \u2115 \u2192 \u211d} {l : \u211d} (h : lim_to_inf x l) : lim_to_inf (-x) (-l) :=\n\u03bb \u03b5 h\u03b5, by { convert h \u03b5 h\u03b5, simp [abs_sub_comm], }\n\nlemma exercise_1p4_l_pos {x : \u2115 \u2192 \u211d} {l : \u211d} (h\u2081 : lim_to_inf x l) (h\u2082 : l > 0) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\n\u03bb \u03b5 h\u03b5, by  { obtain \u27e8N, hN\u27e9 := h\u2081 (|l| \/ 2) (half_pos (abs_pos_of_pos h\u2082)),\n              obtain \u27e8M, hM\u27e9 := h\u2081 \u03b5 h\u03b5,\n              use max N M,\n              intros n hn,\n              specialize hN n (le_of_max_le_left hn),\n              specialize hM n (le_of_max_le_right hn),\n              rw [abs_lt, abs_of_pos h\u2082] at hN,\n              simpa [abs_of_pos h\u2082, abs_of_pos (show x n > 0, by linarith)], }\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  cases le_or_gt 0 l,\n  cases lt_or_eq_of_le h with hpos h0, \n  { exact exercise_1p4_l_pos h\u2081 hpos, },\n  { intros \u03b5 h\u03b5, convert h\u2081 \u03b5 h\u03b5, simp [\u2190 h0], }, \n  { rw \u2190 abs_neg l, convert exercise_1p4_l_pos (lim_neg h\u2081) (show -l > 0, by linarith), simp, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209273,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  intros \u03b5 h,\n  rcases h\u2081 \u03b5 h with \u27e8N,hN\u27e9,\n  use N,\n  intros n hn,\n  specialize hN n hn,\n  dsimp,\n  linarith [abs_abs_sub_abs_le_abs_sub (x n) l],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209274,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) := \nbegin\n  rw lim_to_inf at *,\n  intros \u03b5 h\u03b5,\n  specialize h\u2081 \u03b5 h\u03b5,\n  cases h\u2081 with N h\u2081,\n  use N,\n  intros n hn,\n  specialize h\u2081 n hn,\n  exact gt_of_gt_of_ge h\u2081 (abs_abs_sub_abs_le_abs_sub (x n) l),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209275,"user_id":191,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  rintro \u03b5 h\u03b5,\n  cases h\u2081 \u03b5 h\u03b5 with N hN,\n  use N,\n  rintro n hn,\n  specialize hN n hn,\n  apply lt_of_le_of_lt _ hN,\n  exact abs_abs_sub_abs_le_abs_sub _ _\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209276,"user_id":null,"body":"import Preloaded\ntheorem exercise_1p4 (x: \u2115 \u2192 \u211d) (l: \u211d) \n  (h\u2081: lim_to_inf x l) : lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  intros \u03b5 p\u03b5, simp, specialize h\u2081 \u03b5 p\u03b5, cases h\u2081 with N h\u2081, use N, \n  intros n pn, specialize h\u2081 n pn, linarith [abs_abs_sub_abs_le_abs_sub (x n) l]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209277,"user_id":null,"body":"import Preloaded tactic \nimport data.real.basic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) := \nbegin\n  intros \u03b5 h\u03b5,\n  rcases h\u2081 \u03b5 h\u03b5 with \u27e8N, hN\u27e9,\n  use N,\n  intros n hn,\n  have t := abs_abs_sub_abs_le_abs_sub (x n) l,\n  exact lt_of_le_of_lt t (hN n hn),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209278,"user_id":191,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  rintro \u03b5 h\u03b5,\n  cases h\u2081 \u03b5 h\u03b5 with N hN,\n  use N,\n  rintro n hn,\n  specialize hN n hn,\n  apply lt_of_le_of_lt _ hN,\n  exact abs_abs_sub_le_abs_sub _ _\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209279,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8N\u2080, h\u2082\u27e9 := h\u2081 \u03b5 h\u03b5,\n  use N\u2080,\n  intros n hn,\n  have h\u2083 := h\u2082 n hn,\n  simp,\n  have h\u2084 := abs_sub_abs_le_abs_sub (x n) l,\n  have h\u2085 := abs_sub_abs_le_abs_sub l (x n),\n  rw abs_lt,\n  rw [\u2190abs_neg (l - x n), neg_sub] at h\u2085,\n  split, repeat { linarith }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e9985252d3a920029a7b020":[{"id":209280,"user_id":null,"body":"import Preloaded tactic\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 := \nbegin\n  intros \u03b5 \u03b5pos, cases h\u2082 with B0 h2, let B := max B0 1,\n  have h1 := h\u2081 (\u03b5\/B),\n  have Bpos := lt_of_lt_of_le (_:0<1) (le_max_right B0 1),\n  cases h1 (div_pos \u03b5pos Bpos) with N h, use N,\n  intros n hn, replace h := h n hn, simp at h \u22a2,\n  rw abs_mul, replace h2 := le_trans (h2 n) (le_max_left B0 1),\n  replace h := mul_lt_mul' h2 h (abs_nonneg _) Bpos,\n  rw mul_div_cancel' at h, rwa mul_comm,\n  intro h, rw h at Bpos, linarith, norm_num,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209281,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 :=\nbegin \n  intros \u03b5 h\u03b5,\n  simp,\n  rcases h\u2082 with \u27e8C, hC\u27e9,\n  have haC : abs(C) + 1 > 0,\n  {\n    have hC' := abs_nonneg C,\n    linarith,\n  },\n  have haC' := ne_of_gt haC,\n  rcases h\u2081 (\u03b5 \/ (abs(C) + 1)) _ with \u27e8N, hN\u27e9,\n  use N,\n  intros n hn,\n  specialize hC n,\n  specialize hN n hn,\n  simp at hN,\n  rw abs_mul,\n  have heq : \u03b5 = (\u03b5 \/ (abs(C) + 1)) * (abs(C) + 1),\n  field_simp,\n  rw heq,\n  apply mul_lt_mul'',\n  assumption,\n  have hCl := le_abs_self C,\n  linarith,\n  exact abs_nonneg (x n),\n  exact abs_nonneg (y n),\n  exact div_pos h\u03b5 haC,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209282,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8B, hB\u27e9 := h\u2082,  -- C = B + 1\n  have : B + 1 > 0, by linarith [hB 0, abs_nonneg (y 0)],\n  have \u03b5_over_C_pos := div_pos h\u03b5 this,\n  have := le_of_lt \u03b5_over_C_pos,\n  obtain \u27e8N, hN\u27e9 := h\u2081 (\u03b5 \/ (B + 1)) \u03b5_over_C_pos,\n  use N,\n  intros n hn,\n  by_cases |y n| = 0, { simpa [h, mul_zero, abs_mul], },\n  have : |y n| > 0, by  { apply or.resolve_left (has_le.le.eq_or_lt (abs_nonneg (y n))), \n                          intro t, exact h t.symm, },\n  rw  [sub_zero, abs_mul, \u2190 (show (\u03b5\/(B + 1)) * (B + 1) = \u03b5, by {apply div_mul_cancel, linarith})],\n  have := le_trans (hB n) (show B \u2264 B + 1, by linarith),\n  apply mul_lt_mul, {convert hN n hn, rw sub_zero}, repeat {assumption},\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209283,"user_id":null,"body":"import Preloaded tactic \nimport data.real.basic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 := \nbegin\n  intros \u03b5 h\u03b5,\n  rcases h\u2082 with \u27e8B, hB\u27e9,\n  dsimp,\n  have h : B \u2265 0 := by linarith [hB 0, abs_nonneg (y 0)],\n  by_cases h0 : B > 0,\n  { rcases h\u2081 (\u03b5\/B) (div_pos h\u03b5 h0) with \u27e8N, hN\u27e9,\n    use N,\n    intros n hn,\n    norm_num at *,\n    rw [abs_mul, mul_comm],\n    rw \u2190mul_div_cancel' \u03b5 (ne_of_gt h0),\n    exact mul_lt_mul' (hB n) (hN n hn) (abs_nonneg _) h0 },\n  { use 0, \n    intros n hn, \n    simp at *,\n    rw \u2190 le_antisymm h h0 at hB,\n    rw abs_nonpos_iff.mp (hB n),\n    norm_num,\n    assumption },     \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209284,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 :=\nbegin\n  intros \u03b5 h\u03b5,\n  cases h\u2082 with B hB,\n  simp,\n  cases lt_or_ge 0 B,\n  { have h\u2083 : 0 < \u03b5 \/ B := by linarith [div_pos h\u03b5 h],\n    cases h\u2081 (\u03b5 \/ B) h\u2083 with N hN,\n    use N,\n    intros n hn,\n    rw abs_mul,\n    have hB := hB n,\n    have h\u2084 := hN n hn,\n    rw sub_zero at h\u2084,\n    have h\u2085 := mul_lt_mul' hB h\u2084 (abs_nonneg _) h,\n    rw [mul_div_comm, div_self (ne_of_lt h).symm, mul_one] at h\u2085,\n    linarith },\n  { cases eq_or_lt_of_le h,\n    { use 0, intros n hn, have h\u2083 := hB n, simp * at h\u2083, rw [h\u2083, mul_zero, abs_zero], exact h\u03b5 },\n    { apply false.elim, have h\u2083 := hB 0, linarith [abs_nonneg (y 0)] } }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209285,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 :=\nbegin\n  cases h\u2082 with B hB,\n  let B' := 1 + abs B,\n  have hB' : B' > 0,\n  { simp [B'], linarith [abs_nonneg B] },\n  intros \u03b5 h\u03b5,\n  cases h\u2081 (\u03b5\/B') (div_pos h\u03b5 hB') with N hN,\n  use N,\n  intros n hn,\n  simp,\n  norm_num at *,\n  have hy : abs (y n) < B',\n  {\n    simp [B'],\n    calc abs (y n) \u2264 B         : hB n\n    ...            \u2264 abs B     : le_abs_self B\n    ...            < 1 + abs B : by linarith,\n  },\n  specialize hN n hn,\n  calc abs (x n * y n) = abs (x n) * abs (y n) : abs_mul (x n) (y n)\n  ...                  < \u03b5 \/ B' * B'           : mul_lt_mul'' hN hy (abs_nonneg _) (abs_nonneg _)\n  ...                  = \u03b5                     : div_mul_cancel _ (ne_of_gt hB'),\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209286,"user_id":null,"body":"import Preloaded\n\nlemma abs_pos {a : \u211d} : 0 < abs a \u2194 a \u2260 0 :=\nbegin\n  rcases lt_trichotomy a 0 with (ha|rfl|ha),\n  { simp [abs_of_neg ha, neg_pos, ha.ne, ha] },\n  { simp },\n  { simp [abs_of_pos ha, ha, ha.ne.symm] }\nend\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 := \nbegin\n  simp [lim_to_inf],\n  intros \u03b5 b,\n  simp [bounded'] at h\u2082,\n  cases h\u2082 with B h2,\n  have h3 : \u2200 x : \u2115, 0 \u2264 abs (y x),\n    intro x,\n    apply or.elim (classical.em (y x = 0)),\n      intro h3,\n      rw h3,\n      simp [abs_zero],\n      intro h3,\n      exact (le_of_lt (abs_pos.mpr h3)),\n  have h4 : 0 \u2264 B,\n    transitivity,\n    exact h3 0,\n    exact h2 0,\n  have h5 : 0 < B \u2228 0 = B,\n    apply or.elim (classical.em (B = 0)),\n      intro,right,symmetry,assumption,\n      intro c, left, apply lt_iff_le_and_ne.mpr,\n      apply and.intro,\n        exact h4,\n        symmetry, exact c,\n  cases h5,\n    have h6: 0 < \u03b5 \/ (2*B),\n      have h7 : 0 < 2*B,\n        simp only [two_mul], \n        exact (add_pos h5 h5),\n      exact (div_pos b h7),\n    simp [lim_to_inf] at h\u2081,\n    specialize h\u2081 (\u03b5\/(2*B)) h6,\n    cases h\u2081 with w hw,\n    apply exists.intro,\n    intros n , \n    specialize hw n,\n    have h11 : w \u2264 n \u2192 abs(x n * y n) < \u03b5,\n    exact (\n        show w \u2264 n \u2192 abs (x n * y n) < \u03b5, from\n        begin\n          intro h7,\n          --have h8: abs (x n) < a\/(2*B),\n            specialize (hw) h7,\n          --have h9 : abs (y n) \u2264 B,\n            specialize h2 n,\n          simp [abs_mul],\n          exact calc \n            abs (x n) * abs (y n) \u2264 \u03b5\/(2 * B) * B : \n              mul_le_mul (le_of_lt hw) h2 (h3 n) (le_of_lt h6)\n            ... = (\u03b5 * B) \/ (2 * B) : div_mul_eq_mul_div B \u03b5 (2*B)\n            ... = \u03b5\/2 :  mul_div_mul_right \u03b5 2 (ne_of_gt h5)\n            ... < \u03b5 : div_two_lt_of_pos b\n        end\n    ),\n    show \u2115, exact w,exact h11,\n    have h12 : \u2200 (x : \u2115), abs (y x) = 0, from \n    begin\n      rw [\u2190h5] at h2,\n      intro x,\n      exact (le_antisymm (h2 x) (h3 x) ),\n    end,\n    fapply exists.intro, exact 1,\n    intros n h6,\n    simp [abs_mul],\n    exact calc \n      abs (x n) * abs (y n) = 0 : by simp [h12,mul_zero]\n      ... < \u03b5 : b\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209287,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 := \n\nbegin\n  intro \u03b5,\n  assume : \u03b5 > 0,\n  cases h\u2082 with B boundB,\n  have h\u2084: B+1 > 0,\n    {\n      have : 0 \u2264 B,\n      apply le_trans (abs_nonneg (y 1)) (boundB 1), \n      rw add_comm,\n      apply lt_of_le_of_lt (this) (lt_one_add B),\n    },\n  have h\u2085 : \u03b5 \/ (B+1) > 0,\n    {\n      exact div_pos this h\u2084,\n    },\n\n  have h\u2083 := h\u2081 (\u03b5 \/ (B+1)) h\u2085,\n  cases h\u2083 with N Nprop,\n  use N,\n  intro n,\n  assume h\u2086: n \u2265 N,\n  dsimp,\n  rw sub_zero,\n  rw abs_mul,\n  have bound := Nprop n h\u2086,\n  rw sub_zero at bound,\n  have boundB' := boundB n,\n  have h\u2087 := lt_of_le_of_lt boundB' (lt_one_add B),\n  rw add_comm at h\u2087,\n  calc abs(x n)*abs(y n) \u2264 abs(x n) * (B+1) : by apply mul_le_mul (le_refl(abs(x n))) (le_of_lt h\u2087) (abs_nonneg(y n)) (abs_nonneg(x n))\n                    ...  < \u03b5 \/ (B+1) * (B+1) : by apply mul_lt_mul bound (le_refl (B+1)) h\u2084 (le_of_lt h\u2085)\n                    ...  = \u03b5 : by rw div_mul_cancel \u03b5 (ne_of_gt h\u2084),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209288,"user_id":106,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 :=\nbegin\n  intros \u03b5 h\u03b5, cases h\u2082 with m hy,\n  unfold lim_to_inf at h\u2081, simp at *,\n  have hm : 0 \u2264 m, by exact le_trans (abs_nonneg _) (hy 0),\n  cases lt_or_eq_of_le hm with hm' hm',\n  {\n    specialize h\u2081 (\u03b5 \/ m) (div_pos h\u03b5 hm'),\n    cases h\u2081 with N h\u2081, existsi N, intros n hn,\n    rw abs_mul,\n    cases lt_or_eq_of_le (abs_nonneg (y n)) with hy' hy',\n    {\n      rw \u2190 div_mul_cancel \u03b5 (ne_of_gt hm'),\n      specialize h\u2081 n hn,\n      have hyn := hy n,\n      apply mul_lt_mul h\u2081 hyn hy' (le_of_lt (div_pos h\u03b5 hm')),\n    },\n    {\n      rw \u2190hy', simp, exact h\u03b5\n    }\n  },\n  {\n    subst hm',\n    existsi 0, intros n _,\n    rw abs_mul, specialize hy n,\n    have hy' := abs_nonneg (y n),\n    rw (le_antisymm hy hy'), simp, exact h\u03b5\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209289,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 :=\nbegin\n  intros \u03b5 \u03b5p,\n  cases h\u2082 with B hB,\n  have Bp1p : B + 1 > 0,\n  {\n    exact calc B + 1 > B : by linarith\n    ...              \u2265 abs (y 0) : hB 0\n    ...              \u2265 0 : by linarith [abs_nonneg (y 0)],\n  },\n  cases h\u2081 (\u03b5 \/ (B + 1)) (div_pos \u03b5p Bp1p) with N,\n  existsi N,\n  intros n ngeN,\n  simp,\n  simp at h,\n  rw abs_mul,\n  have ynlt : abs (y n) < B + 1,\n  {\n    exact calc abs (y n) \u2264 B : hB n\n    ...                  < B + 1 : by linarith,\n  },\n  exact calc abs (x n) * abs (y n) < \u03b5 \/ (B + 1) * (B + 1) : mul_lt_mul'' (h n ngeN) ynlt (abs_nonneg (x n)) (abs_nonneg (y n))\n  ...                              = \u03b5 : div_mul_cancel \u03b5 (by linarith),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e998b42dcf07b0001581def":[{"id":209290,"user_id":null,"body":"import Preloaded\nimport data.nat.basic\nimport tactic\n\nopen even odd\n\n-- lemma even_exists {n : \u2115} (hn : even n) : \u2203 k : \u2115, n = 2 * k :=\n-- begin\n--   induction even with n hn,\n--     use 0,\n--     rw mul_zero,\n  \n--   sorry,\n-- end\n\n-- Getting Started\n\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) :=\nbegin\n  induction hn with n h hn,\n    simp [odd_one],\n  exact odd_ss hn,\nend\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) :=\nbegin\n  induction hn with n h hn,\n    exact even_ss even_zero,\n  exact even_ss hn,\nend\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n :=\nbegin\n  induction n with n hn,\n    exact or.inr even_zero,\n  cases hn,\n    exact or.inr (odd_add_one hn),\n  exact or.inl (even_add_one hn),\nend\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) :=\nbegin\n  induction hm with m hm hnm,\n    exact odd_add_one hn,\n  rw \u2190add_assoc,\n  exact even_ss hnm,\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) :=\nbegin\n  induction hm with m hm hnm,\n    exact hn,\n  rw \u2190add_assoc,\n  exact odd_ss hnm,\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) :=\nbegin\n  rw add_comm,\n  exact odd_add_even hm hn,\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) :=\nbegin\n  induction hm with m hm hnm,\n    rwa add_zero,\n  rw \u2190 add_assoc,\n  exact even_ss hnm,\nend\n\n-- Multiplication\n\nlemma mul_two_even {n : \u2115} : (even (n * 2)) :=\nbegin\n  induction n with n hn,\n    rw zero_mul,\n    exact even_zero,\n  change even ((n + 1) * 2),\n  rw add_mul,\n  apply even_add_even,\n    assumption,\n  rw one_mul,\n  exact even_ss (even_zero),\nend\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) :=\nbegin\n  induction hm with m hm hnm,\n    rw mul_zero,\n    exact even_zero,\n  rw mul_add,\n  apply even_add_even,\n    exact hnm,\n  exact mul_two_even,\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) :=\nbegin\n  induction hm with m hm hnm,\n    rwa mul_one,\n  rw mul_add,\n  apply even_add_even,\n    exact hnm,\n  exact mul_two_even,\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) :=\nbegin\n  rw mul_comm,\n  exact even_mul_odd hm hn,\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  odd (n * m) :=\nbegin\n  induction hm with m hm hnm,\n    rwa mul_one,\n  rw mul_add,\n  apply odd_add_even,\n    assumption,\n  exact mul_two_even,\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) :=\nbegin\n  induction m with m hm,\n    rw mul_zero,\n    exact even_zero,\n  change even (n * (m + 1)),\n  rw mul_add,\n  apply even_add_even,\n    assumption,\n  rwa mul_one,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209291,"user_id":null,"body":"import Preloaded\nopen odd even\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) := \nby { induction hn, exact odd_one, exact odd_ss hn_ih }\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) := \nby { induction hn, exact even_ss even_zero, exact even_ss hn_ih }\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n := \nbegin\n  induction n,\n  right, exact even_zero,\n  cases n_ih, \n  right, apply odd_add_one n_ih,\n  left, apply even_add_one n_ih\nend\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) : even (n + m) := \nbegin\n  induction hn, induction hm,\n  exact even_ss even_zero, exact even_ss hm_ih,\n  rw nat.add_comm at *, exact even_ss hn_ih\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) : odd (n + m) := \nbegin\n  induction hn, induction hm,\n  exact odd_one, exact odd_ss hm_ih,\n  rw nat.add_comm at *, exact odd_ss hn_ih\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) : odd (n + m) := \nbegin\n  induction hn, induction hm,\n  exact odd_one, exact odd_ss hm_ih,\n  rw nat.add_comm at *, exact odd_ss hn_ih\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) : even (n + m) := \nbegin\n  induction hn, induction hm,\n  exact even_zero, exact even_ss hm_ih,\n  rw nat.add_comm at *, exact even_ss hn_ih \nend\n\nlemma two_mul_even (n : \u2115) : even (2 * n) :=\nby { induction n, exact even_zero, exact even_ss n_ih }\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) : even (n * m) := \nbegin\n  induction hn, induction hm,\n  exact even_zero, rw nat.zero_mul, exact even_zero,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) : even (n * m) :=\nbegin\n  induction hn, induction hm,\n  exact even_zero, rw nat.zero_mul, exact even_zero,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) : even (n * m) := \nbegin\n  induction hn, induction hm with _ h,\n  exact even_zero, rw nat.one_mul, exact even_ss h,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) : odd (n * m) := \nbegin\n  induction hn, induction hm with _ h,\n  exact odd_one, rw nat.one_mul, exact odd_ss h,\n  rw nat.right_distrib hn_n 2 m, apply odd_add_even hn_ih (two_mul_even m)\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) : even (n * m) := \nby { cases odd_or_even m with h, exact even_mul_odd hn h, exact even_mul_even hn h }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209292,"user_id":null,"body":"import Preloaded\n\nopen odd even\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) := \nby { induction hn, exact odd_one, exact odd_ss hn_ih }\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) := \nby { induction hn, exact even_ss even_zero, exact even_ss hn_ih }\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n := \nbegin\n  induction n,\n  right, exact even_zero,\n  cases n_ih,\n  right, apply odd_add_one n_ih,\n  left, apply even_add_one n_ih\nend\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) : even (n + m) := \nbegin\n  induction hn, induction hm,\n  exact even_ss even_zero, exact even_ss hm_ih,\n  rw nat.add_comm at *, exact even_ss hn_ih\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) : odd (n + m) := \nbegin\n  induction hn, induction hm,\n  exact odd_one, exact odd_ss hm_ih,\n  rw nat.add_comm at *, exact odd_ss hn_ih\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) : odd (n + m) := \nbegin\n  induction hn, induction hm,\n  exact odd_one, exact odd_ss hm_ih,\n  rw nat.add_comm at *, exact odd_ss hn_ih\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) : even (n + m) := \nbegin\n  induction hn, induction hm,\n  exact even_zero, exact even_ss hm_ih,\n  rw nat.add_comm at *, exact even_ss hn_ih \nend\n\nlemma two_mul_even (n : \u2115) : even (2 * n) :=\nby { induction n, exact even_zero, exact even_ss n_ih }\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) : even (n * m) := \nbegin\n  induction hn, induction hm,\n  exact even_zero, rw nat.zero_mul, exact even_zero,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) : even (n * m) :=\nbegin\n  induction hn, induction hm,\n  exact even_zero, rw nat.zero_mul, exact even_zero,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) : even (n * m) := \nbegin\n  induction hn, induction hm with _ h,\n  exact even_zero, rw nat.one_mul, exact even_ss h,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) : odd (n * m) := \nbegin\n  induction hn, induction hm with _ h,\n  exact odd_one, rw nat.one_mul, exact odd_ss h,\n  rw nat.right_distrib hn_n 2 m,  \n  apply odd_add_even hn_ih (two_mul_even m)\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) : even (n * m) := \nbegin\n  induction hn, induction m,\n  exact even_zero, rw nat.zero_mul, exact even_zero,\n  rw nat.right_distrib hn_n 2 m, apply even_add_even hn_ih (two_mul_even m)\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209293,"user_id":null,"body":"import Preloaded\n\nopen odd even\n\n-- Getting Started\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) :=\nbegin\n  induction hn with x hx ih,\n  exact odd_one,\n  exact odd_ss ih,\nend\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) :=\nbegin\n  induction hn with _ _ ih,\n  exact even_ss even_zero,\n  exact even_ss ih,\nend\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n :=\nbegin\n  induction n with n hn,\n  right,\n  exact even_zero,\n  cases hn with hn,\n  right,\n  exact odd_add_one hn,\n  left,\n  exact even_add_one hn,\nend\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) :=\nbegin\n  induction hm with x hx ih,\n  exact odd_add_one hn,\n  exact even_ss ih,\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) :=\nbegin\n  induction hm with x hx ih,\n  exact hn,\n  exact odd_ss ih,\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) :=\nbegin\n  rw nat.add_comm,\n  exact odd_add_even hm hn,\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) :=\nbegin\n  induction hm with x hx ih,\n  exact hn,\n  exact even_ss ih,\nend\n\n-- Multiplication\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) :=\nbegin\n  induction hn with x hx ih,\n  rw nat.zero_mul,\n  exact even_zero,\n  rw nat.right_distrib x 2 m,\n  apply even_add_even ih,\n  have : 2*m = m+m :=\n  calc\n    2*m = (1+1)*m : by simp\n    ... = 1*m + 1*m : nat.right_distrib 1 1 m\n    ... = m + 1*m   : by rw nat.one_mul m\n    ... = m + m   : by rw nat.one_mul m,\n  rw this,\n  apply even_add_even hm hm,\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) :=\nbegin\n  induction hn with x hx ih,\n  rw nat.zero_mul,\n  exact even_zero,\n  rw nat.right_distrib x 2 m,\n  apply even_add_even ih,\n  have : 2*m = m+m :=\n  calc\n    2*m = (1+1)*m : by simp\n    ... = 1*m + 1*m : nat.right_distrib 1 1 m\n    ... = m + 1*m   : by rw nat.one_mul m\n    ... = m + m   : by rw nat.one_mul m,\n  rw this,\n  apply odd_add_odd hm hm,\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) :=\nbegin\n  rw nat.mul_comm,\n  exact even_mul_odd hm hn,\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  odd (n * m) :=\nbegin\n  induction hn with x hx ih,\n  rwa nat.one_mul,\n  rw nat.right_distrib _ _ _,\n  exact odd_add_even ih (even_mul_odd (even_ss even_zero) hm),\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) :=\nbegin\n  cases odd_or_even m with hm hm,\n  exact even_mul_odd hn hm,\n  exact even_mul_even hn hm,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209294,"user_id":null,"body":"\nimport tactic\nimport Preloaded\nopen odd even\n\n-- Getting Started\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) := by{\n  have h\u2081:odd(0+1),{\n    exact odd_one,\n  },\n  have h\u2082:\u2200(n:\u2115),even n \u2192 odd (n+1) \u2192 odd (n+2+1),{\n    intros a _ h,\n    exact odd_ss h,\n  },\n  exact even.rec_on hn h\u2081 h\u2082,\n}\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) := by{\n  have h\u2081:even(1+1),{\n    exact even_ss (even_zero),\n  },\n  have h\u2082:\u2200(n:\u2115),odd n \u2192 even (n+1) \u2192 even (n+2+1),{\n    intros a _ h,\n    exact even_ss h,\n  },\n  exact odd.rec_on hn h\u2081 h\u2082,\n}\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n := by{\n  induction n with n nh,{\n    right,\n    exact even_zero,\n  },{\n    cases nh with h h,{\n      right,\n      exact odd_add_one h,\n    },{\n      left,\n      exact even_add_one h,\n    }\n  }\n}\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) := by{\n  have h\u2081:\u2200(a:\u2115),odd a \u2192 even (n+a) \u2192 even (n+a+2),{\n    intros _ _ h,\n    exact even_ss h,\n  },\n  exact odd.rec_on hm (odd_add_one hn) h\u2081,\n}\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) := by{\n  have h\u2081:\u2200(a:\u2115),even a \u2192 odd (n+a) \u2192 odd (n+a+2),{\n    intros _ _ h,\n    exact odd_ss h,\n  },\n  exact even.rec_on hm hn h\u2081,\n}\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) := by{\n  have h\u2081:\u2200(a:\u2115),odd a \u2192 odd (n+a) \u2192 odd (n+a+2),{\n    intros _ _ h,\n    exact odd_ss h,\n  },\n  exact odd.rec_on hm (even_add_one hn) h\u2081, \n}\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) := by{\n  have h\u2081:\u2200(a:\u2115),even a \u2192 even (n+a) \u2192 even (n+a+2),{\n    intros _ _ h,\n    exact even_ss h,\n  },\n  exact even.rec_on hm hn h\u2081,\n}\n\n-- Multiplication\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) := by{\n  have h\u2081:\u2200(a:\u2115),even a \u2192 even(n*a) \u2192 even(n*(a+2)),{\n    intros a ea ena,\n    simp [mul_add,mul_two],\n    exact even_add_even ena (even_add_even hn hn)\n  },\n  have h\u2082:even (n*0),{\n    exact even_zero,\n  },\n  exact even.rec_on hm h\u2082 h\u2081,\n}\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) := by{\n  have h\u2081:\u2200(a:\u2115),odd a \u2192 even(n*a) \u2192 even(n*(a+2)),{\n    intros a ea ena,\n    simp [mul_add,mul_two],\n    exact even_add_even ena (even_add_even hn hn)\n  },\n  have h\u2082:even(n*1),{\n    simp [mul_one],\n    assumption,\n  },\n  exact odd.rec_on hm h\u2082 h\u2081,\n}\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) := by{\n  have h\u2081:\u2200(a:\u2115),even a \u2192 even(n*a) \u2192 even(n*(a+2)),{\n    intros a ea ena,\n    simp [mul_add,mul_two],\n    exact even_add_even ena (odd_add_odd hn hn)\n  },\n  have h\u2082:even (n*0),{\n    exact even_zero,\n  },\n  exact even.rec_on hm h\u2082 h\u2081,\n}\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  odd (n * m) := by{\n  have h\u2081:\u2200(a:\u2115),odd a \u2192 odd(n*a) \u2192 odd(n*(a+2)),{\n    intros a ea ena,\n    simp [mul_add,mul_two],\n    exact odd_add_even ena (odd_add_odd hn hn)\n  },\n  have h\u2082:odd(n*1),{\n    simp [mul_one],\n    assumption,\n  },\n  exact odd.rec_on hm h\u2082 h\u2081,\n}\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) := by{\n  cases (odd_or_even m),\n  exact even_mul_odd hn h,\n  exact even_mul_even hn h,\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209295,"user_id":722,"body":"import Preloaded\n\nopen odd even\n\n-- Getting Started\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) :=\nbegin\n  induction hn with n hn IHn,\n  { exact odd_one },\n  { rw \u2190nat.add_right_comm, exact odd_ss IHn }\nend\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) :=\nbegin\n  induction hn with n hn IHn,\n  { exact even_ss even_zero },\n  { rw \u2190nat.add_right_comm, exact even_ss IHn }\nend\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n :=\nbegin\n  induction n with n IH,\n  { right, exact even_zero },\n  { cases IH,\n    { right, rw \u2190nat.add_one, exact odd_add_one IH },\n    { left, rw \u2190nat.add_one, exact even_add_one IH } }\nend\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) :=\nbegin\n  induction hn with n hn IHn,\n  { induction hm with m hm IHm,\n    { exact even_ss even_zero },\n    { rw \u2190nat.add_assoc, exact even_ss IHm } },\n  { rw \u2190nat.add_right_comm, exact even_ss IHn }\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) :=\nbegin\n  induction hn with n hn IHn,\n  { induction hm with m hm IHm,\n    { exact odd_one },\n    { rw \u2190nat.add_assoc, exact odd_ss IHm } },\n  { rw \u2190nat.add_right_comm, exact odd_ss IHn }\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) :=\nbegin\n  rw nat.add_comm, exact odd_add_even hm hn,\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) :=\nbegin\n  induction hn with n hn IHn,\n  { rw nat.zero_add, exact hm },\n  { rw \u2190nat.add_right_comm, exact even_ss IHn }\nend\n\n-- Multiplication\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) :=\nbegin\n  revert m,\n  induction hn with n hn IHn,\n  { intros m hm, rw nat.zero_mul, exact even_zero },\n  { intros m hm,\n    rw nat.right_distrib, apply even_add_even,\n    { exact IHn hm },\n    { induction hm with m hm IHm,\n      { exact even_zero },\n      { rw nat.left_distrib, rw (show 2*m + 2*2 = 2*m + 2 + 2, by refl),\n        exact even_ss (even_ss IHm) } } }\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) :=\nbegin\n  revert m,\n  induction hn with n hn IHn,\n  { intros m hm, rw nat.zero_mul, exact even_zero },\n  { intros m hm,\n    rw nat.right_distrib, apply even_add_even,\n    { exact IHn hm },\n    { induction hm with m hm IHm,\n      { exact even_ss even_zero, },\n      { rw nat.left_distrib, rw (show 2*m + 2*2 = 2*m + 2 + 2, by refl),\n        exact even_ss (even_ss IHm) } } }\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) :=\nbegin\n  rw nat.mul_comm, exact even_mul_odd hm hn,\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (h : odd m) :\n  odd (n * m) :=\nbegin\n  induction hn with n hn IHn,\n  { rw nat.one_mul, exact h },\n  { rw nat.right_distrib, apply odd_add_even,\n    { exact IHn },\n    { apply even_mul_odd,\n      { exact even_ss even_zero },\n      { exact h } } }\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) :=\nbegin\n  cases (odd_or_even m) with hm hm,\n  { exact even_mul_odd hn hm },\n  { exact even_mul_even hn hm },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209296,"user_id":null,"body":"import Preloaded tactic\n\nopen odd even\n\n\n-- Getting Started\n\n@[simp]\nlemma even_iff {n : \u2115} : even n \u2194 \u2203k : \u2115, n = 2 * k :=\nbegin\n  split, \n  { intros h,\n    induction h with d hd ih,\n    { use 0, refl },\n    { cases ih with k hk, use (k + 1), simp [hk, mul_add] } },\n  { intros h,    \n    rcases h with \u27e8k, rfl\u27e9,\n    induction k with d hd,\n    { simp [even_zero] }, \n    { exact even_ss hd} }\nend\n\n@[simp]\nlemma odd_iff {n : \u2115} : odd n \u2194 \u2203k : \u2115, n = 2 * k + 1 := \nbegin\n  split, \n  { intros h,\n    induction h with d hd ih,\n    { use 0, refl },\n    { cases ih with k hk, use (k + 1), simp [hk, mul_add] } },\n  { intros h,    \n    rcases h with \u27e8k, rfl\u27e9,\n    induction k with d hd,\n    { simp [odd_one] }, \n    { exact odd_ss hd} }\nend\n\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) := \nbegin\n  simp at *, \n  rcases hn with \u27e8k, rfl\u27e9, \n  use k, \nend\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) := \nbegin\n  simp at *, \n  rcases hn with \u27e8k, rfl\u27e9, \n  use k + 1, \n  ring,\nend\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n := \nbegin\n  induction n with d hd,\n  { right, exact even_zero },\n  { cases hd with h1 h2,\n    { simp at *, right, rcases h1 with \u27e8t, rfl\u27e9, use (t+1), ring }, \n    { simp at *, left,  rcases h2 with \u27e8t, rfl\u27e9, use t, } } \nend\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (kn + km + 1),\n  ring,\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (kn + km),\n  ring,\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (kn + km),\n  ring,\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (kn + km),\n  ring,\nend\n\n-- Multiplication\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (2 * kn * km),\n  ring,\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (2 * kn * km + kn),\n  ring,\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (2 * kn *  km + km),\n  ring,\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  odd (n * m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,\n  rcases hm with \u27e8km, rfl\u27e9,\n  use (2 * kn * km + kn + km),\n  ring,\nend\n\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) := \nbegin\n  simp at *,\n  rcases hn with \u27e8kn, rfl\u27e9,  \n  use (kn * m),\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209297,"user_id":null,"body":"import Preloaded\nimport data.nat.basic\n\nopen odd even\n\n-- Getting Started\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) :=\nbegin\n  induction hn,\n  exact odd_one,\n  exact odd_ss (by assumption),\nend\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) :=\nbegin\n  induction hn,\n  exact even_ss even_zero,\n  exact even_ss (by assumption),\nend\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n :=\nbegin\n  induction n,\n  case zero { right, exact even_zero, },\n  case succ : n {\n    cases n_ih,\n    right, exact odd_add_one n_ih,\n    left, exact even_add_one n_ih,\n  },\nend\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) :=\nbegin\n  induction hm,\n  exact odd_add_one hn,\n  exact even_ss hm_ih,\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) :=\nbegin\n  induction hm,\n  exact hn,\n  exact odd_ss hm_ih,\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) :=\nbegin\n  induction hm,\n  exact even_add_one hn,\n  exact odd_ss hm_ih,\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) :=\nbegin\n  induction hm,\n  exact hn,\n  exact even_ss hm_ih,\nend\n\n-- Multiplication\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) :=\nbegin\n  induction hm,\n  case even_zero { exact even_zero, },\n  case even_ss {\n    rw [mul_add, mul_two],\n    apply even_add_even hm_ih,\n    exact even_add_even hn hn,\n  },\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) :=\nbegin\n  induction hm,\n  case odd_one { rw mul_one, exact hn },\n  case odd_ss {\n    rw [mul_add, mul_two],\n    apply even_add_even hm_ih,\n    exact even_add_even hn hn,\n  },\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) :=\nbegin\n  induction hm,\n  case even_zero { exact even_zero, },\n  case even_ss {\n    rw [mul_add, mul_two],\n    apply even_add_even hm_ih,\n    exact odd_add_odd hn hn,\n  },\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  odd (n * m) :=\nbegin\n  induction hm,\n  case odd_one { rw mul_one, exact hn, },\n  case odd_ss {\n    rw [mul_add, mul_two],\n    apply odd_add_even hm_ih,\n    exact odd_add_odd hn hn,\n  },\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) :=\nbegin\n  cases odd_or_even m,\n  { exact even_mul_odd hn (by assumption) },\n  { exact even_mul_even hn (by assumption) },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209298,"user_id":null,"body":"import Preloaded tactic\n \nopen odd even nat\n\n-- Getting Started\n\n@[simp] lemma even_zero' : even 0 := even.even_zero\n@[simp] lemma even_ss' : \u2200 {n}, even n \u2192 even (n + 2) := \u03bb n h, even_ss h\n@[simp] lemma odd_one' : odd 1 := odd.odd_one\n@[simp] lemma odd_ss' : \u2200 {n}, odd n \u2192 odd (n + 2) := \u03bb n h, odd_ss h\n\nlemma even_add_one : \u2200 {n : nat}, even n \u2192 odd (n + 1)\n| 0 := \u03bb h, by simp\n| 1 := \u03bb h, by cases h -- assume `h : even 1` and then use induction to get a contradiction\n| (m + 2) := \u03bb h, by { cases h with _ hm, constructor, exact even_add_one hm}\n\nlemma odd_add_one : \u2200 {n : \u2115}, odd n \u2192 even (n + 1)\n| 0 := \u03bb h, by cases h\n| 1 := \u03bb h, by { simp }\n| (m + 2) := \u03bb h, by { cases h with _ hm, constructor, exact odd_add_one hm, }\n\nlemma odd_or_even : \u2200 n, odd n \u2228 even n\n| 0 := or.inr even_zero\n| 1 := or.inl odd_one\n| (m + 2) := or.elim (odd_or_even m) (\u03bb h, or.inl $ odd_ss h) (\u03bb h, or.inr $ even_ss h)\n\n-- Addition\n\n@[simp] lemma aux {n m : \u2115} : n + 2 + (m + 2) = n + m + 2 + 2 := by linarith\n\n@[simp] theorem odd_add_odd : \u2200 {n m : \u2115}, odd n \u2192 odd m \u2192 even (n + m)\n| _         0     := \u03bb _ h0, by { exfalso, cases h0 }\n| 0         _     := \u03bb h0, by { exfalso, cases h0 }\n| 1         1     := \u03bb _ _, by simp\n| (n+2)     1     := \u03bb hn _, odd_add_one hn\n| 1         (m+2) := \u03bb _ hm, by { rw add_comm, exact odd_add_one hm }\n| (n+2)     (m+2) := \u03bb hn hm, by { cases hn with _ hn, cases hm with _ hm, simp [odd_add_odd hn hm] }          \n                                  \n@[simp] theorem odd_add_even : \u2200 {n m : \u2115}, odd n \u2192 even m \u2192 odd (n + m)\n| 0         _     := \u03bb h0, by { exfalso, cases h0 }\n| _         1     := \u03bb _ h0, by { exfalso, cases h0 }\n| 1         0     := \u03bb _ _, by simp\n| 1         (m+2) := \u03bb h1 hm, by { rw add_comm, exact even_add_one hm, }\n| (n+2)     0     := \u03bb _ _, by simpa\n| (n+2)     (m+2) := \u03bb hn hm, by { cases hn with _ hn, cases hm with _ hm, simp [odd_add_even hn hm] }\n\n@[simp] theorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\nodd (n + m) := by { rw add_comm, exact odd_add_even hm hn }\n\n@[simp] theorem even_add_even : \u2200 {n m : \u2115}, even n \u2192 even m \u2192 even (n + m)\n| 1         _     := \u03bb h1, by { exfalso, cases h1 }\n| _         1     := \u03bb _ h1, by { exfalso, cases h1 }\n| 0         0     := \u03bb _ _, by simp \n| 0         (m+2) := \u03bb _ _, by simpa\n| (n+2)     0     := \u03bb _ _, by simpa\n| (n+2)     (m+2) := \u03bb hn hm, by { cases hn with _ hn, cases hm with _ hm, simp [even_add_even hn hm] }\n\n-- Multiplication\n  \ntheorem even_mul_even : \u2200 {n m : \u2115},  even n \u2192 even m \u2192 even (n * m)\n| 0        := by simp\n| 1        := \u03bb _ _ _, by simpa\n| (n+2)    := \u03bb m hn hm, by { cases hn with _ hn, rw add_mul, apply even_add_even (even_mul_even hn hm),\n   rw two_mul, simp [hm] }\n\ntheorem even_mul_odd : \u2200 {n m : \u2115}, even n \u2192 odd m \u2192 even (n * m)\n| 0     := by simp\n| 1     := \u03bb _ h1 , by { exfalso, cases h1 }\n| (n+2) := \u03bb m hn hm, by { cases hn with _ hn, rw add_mul, apply even_add_even (even_mul_odd hn hm),\n   rw two_mul, simp [hm] }\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) : even (n * m) := by { rw mul_comm, exact even_mul_odd hm hn }\n\ntheorem odd_mul_odd : \u2200 {n m : \u2115}, odd n \u2192 odd m \u2192 odd (n * m)\n| 0     := \u03bb _ h0, by { exfalso, cases h0 }\n| 1     := by simp\n| (n+2) := \u03bb m hn hm, by { cases hn with _ hn, rw add_mul, apply odd_add_even (odd_mul_odd hn hm),\n  rw two_mul, simp [hm] }\n\ntheorem even_mul : \u2200 (n m : \u2115), even n \u2192 even (n * m)\n| 0       := by simp\n| 1       := \u03bb _ h1, by { exfalso, cases h1 }\n| (n+2)   := \u03bb m hn, by { cases hn with _ hn, rw add_mul, apply even_add_even (even_mul _ _ hn),\n  rw two_mul, cases (odd_or_even m) with h h; { simp [h] } }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209299,"user_id":null,"body":"import Preloaded tactic\n\nopen odd even\n\n-- Getting Started\n\nlemma even_add_one {n : \u2115} (hn : even n) : odd (n + 1) := \nbegin\n  induction hn with n hn ih,\n  { exact odd_one, },\n  exact odd_ss ih,\nend\n\nlemma odd_add_one {n : \u2115} (hn : odd n) : even (n + 1) := \nbegin\n  induction hn with n hn ih,\n  { exact even_ss even_zero, },\n  exact even_ss ih,\nend\n\nlemma odd_or_even (n : \u2115) : odd n \u2228 even n := \nbegin\n  induction n with n ih,\n  { exact or.inr even_zero, },\n  exact ih.cases_on (or.inr \u2218 odd_add_one) (or.inl \u2218 even_add_one),\nend\n\n-- Addition\n\ntheorem odd_add_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  even (n + m) := \nbegin\n  induction hm with _ _ ih,\n  { exact odd_add_one hn, },\n  exact even_ss ih,\nend\n\ntheorem odd_add_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  odd (n + m) := \nbegin\n  induction hm with _ _ ih,\n  { exact hn, },\n  exact odd_ss ih,\nend\n\ntheorem even_add_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  odd (n + m) := \nbegin\n  induction hm with _ _ ih,\n  { exact even_add_one hn, },\n  exact odd_ss ih,\nend\n\ntheorem even_add_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n + m) := \nbegin\n  induction hm with _ _ ih,\n  { exact hn, },\n  exact even_ss ih,\nend\n\n-- Multiplication\n\ntheorem even_mul_even {n m : \u2115} (hn : even n) (hm : even m) :\n  even (n * m) := \nbegin\n  induction hm with _ _ ih,\n  { exact even_zero, },\n  apply even_add_even _ hn,\n  apply even_add_even _ hn,\n  exact ih,\nend\n\ntheorem even_mul_odd {n m : \u2115} (hn : even n) (hm : odd m) :\n  even (n * m) := \nbegin\n  induction hm with _ _ ih,\n  { exact even_add_even even_zero hn, },\n  apply even_add_even _ hn,\n  apply even_add_even _ hn,\n  exact ih,\nend\n\ntheorem odd_mul_even {n m : \u2115} (hn : odd n) (hm : even m) :\n  even (n * m) := \nbegin\n  induction hm with _ _ ih,\n  { exact even_zero, },\n  apply odd_add_odd _ hn,\n  apply even_add_odd _ hn,\n  exact ih,\nend\n\ntheorem odd_mul_odd {n m : \u2115} (hn : odd n) (hm : odd m) :\n  odd (n * m) := \nbegin\n  induction hm with _ _ ih,\n  { exact even_add_odd even_zero hn, },\n  apply even_add_odd _ hn,\n  apply odd_add_odd _ hn,\n  exact ih,\nend\n\ntheorem even_mul (n m : \u2115) (hn : even n) :\n  even (n * m) := \nbegin\n  exact (odd_or_even m).cases_on (even_mul_odd hn) (even_mul_even hn),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5e9e9f39c58d260016b53116":[{"id":209300,"user_id":196,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 :=\nlet \u27e8\u03b4, h\u03b4, H\u27e9 := hcont (f a \/ 2) (half_pos hgt) in\n\u27e8a-\u03b4, a+\u03b4, \u27e8sub_lt_self a h\u03b4, lt_add_of_pos_right a h\u03b4\u27e9, \u03bb x hx,\nhave h : abs (x - a) < \u03b4, from abs_sub_lt_iff.2 \u27e8sub_left_lt_of_lt_add hx.2, sub_lt_of_sub_lt hx.1\u27e9,\ncalc  f x\n    = f a - (f a - f x) : (sub_sub_cancel (f a) (f x)).symm\n... > f a - (f a \/ 2) : sub_lt_sub_left (abs_sub_lt_iff.1 $ H x h).2 (f a)\n... = f a \/ 2 : sub_half (f a)\n... > 0 : half_pos hgt\u27e9\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209301,"user_id":656,"body":"import Preloaded\n\nopen set\n\nlemma in_Ioo_abs {a x \u03b4 : \u211d} (h : x \u2208 Ioo (a - \u03b4) (a + \u03b4)) : abs (x - a) < \u03b4 :=\nabs_lt.2 (by split; linarith [h.left, h.right])\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 := \nlet \u27e8\u03b4, h\u03b4\u2081, h\u03b4\u2082\u27e9 := hcont (f a \/ 2) (half_pos hgt) in\n\u27e8a - \u03b4, a + \u03b4, by split; try {linarith}, \u03bb x hx, by linarith [(abs_lt.1 $ h\u03b4\u2082 x (in_Ioo_abs hx)).left]\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209302,"user_id":null,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 :=\nbegin\n  obtain \u27e8\u03b4, \u03b4pos, h\u03b4\u27e9 := hcont (f a \/ 2) (half_pos hgt),\n  use [a-\u03b4, a+\u03b4],\n  split, \n    split; by {norm_num, assumption},\n\n  intros x hx1,\n  have hx2 : |x - a| < \u03b4 := by {\n    rw abs_sub_lt_iff,\n    dsimp [Ioo] at hx1,\n    split; linarith,\n  },\n  have hfx := h\u03b4 x hx2,\n  cases abs_sub_lt_iff.mp hfx with hfx1 hfx2,\n  linarith [hfx2],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209303,"user_id":null,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 :=\nbegin\n  have hgt2 : (f a) \/ 2 > 0 := (div_pos_iff.mpr $ or.inl \u27e8hgt, by norm_num\u27e9),\n  obtain \u27e8\u03b4, \u03b4pos, h\u03b4\u27e9 := hcont (f a \/ 2) hgt2,\n\n  use [a-\u03b4, a+\u03b4],\n  split, \n    split; by {norm_num, assumption},\n\n  intros x hx1,\n  have hx2 : |x - a| < \u03b4 := abs_sub_lt_iff.mpr \u27e8sub_right_lt_of_lt_add $ by {rw add_comm, exact hx1.right},\n    sub_lt.mp hx1.left\u27e9,\n\n  have hfx := h\u03b4 x hx2,\n  cases abs_sub_lt_iff.mp hfx with hfx1 hfx2,\n  rw sub_lt at hfx2,\n  exact lt_trans (sub_pos_of_lt $ div_lt_self hgt $ by norm_num) hfx2,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209304,"user_id":null,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 := \n  begin\n  specialize hcont (f a) hgt,\n  cases hcont with d hd, \n  cases hd with Hd hd,\n  use [a-d,a+d],\n  split, norm_num, exact Hd,\n  intro x,\n  specialize hd x,\n  intro hx,\n  have h1: |f x - f a| < (f a),\n    apply hd _,\n    have h2: a-d < x \u2227 x< a+d,\n    apply set.mem_Ioo.mp hx,\n    rw abs_sub_lt_iff,\n    split,\n      rw sub_lt_iff_lt_add, rw add_comm, exact h2.2,\n      cases h2,\n      rw [sub_lt_iff_lt_add, add_comm],\n      rw sub_lt_iff_lt_add at h2_left,assumption,\n    rw abs_sub_lt_iff at h1,\n    cases h1,\n      rw [sub_lt_iff_lt_add , add_comm, \u2190 add_zero (f a), \u2190  add_assoc] at h1_right,\n      rw [add_zero (f x + f a), add_comm (f x)] at h1_right,\n      apply lt_of_add_lt_add_left  h1_right\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209305,"user_id":null,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 :=\nbegin\n  let \u03b5 := f a,\n  specialize hcont \u03b5 hgt,\n  cases hcont with \u03b4 hde,\n  cases hde with hde1 hde2,\n  use a-\u03b4, use a+\u03b4,\n  split,\n  simp [Ioo],\n  linarith only [hde1],\n  intros x hx,\n  simp [Ioo] at hx,\n  have : | x - a | < \u03b4,\n  {\n    rw abs_sub_lt_iff,\n    split;\n    linarith,\n  },\n  specialize hde2 x this,\n  rw abs_sub_lt_iff at hde2,\n  linarith only [hde2.2],\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209306,"user_id":null,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 :=\nbegin\n  rcases hcont ((f a) \/ 2) (half_pos hgt) with \u27e8\u03b4, \u27e8h\u03b4, h\u27e9\u27e9,\n  use [(a-\u03b4), (a+\u03b4), by linarith, by linarith],\n  intros x hx,\n  rw mem_Ioo at hx,\n  linarith [abs_lt.1 (h x (by {rw abs_lt, split, linarith, linarith}))],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209307,"user_id":null,"body":"import Preloaded\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 := by{\n  obtain \u27e8\u03b4,\u27e8h0,h1\u27e9\u27e9:=hcont (f a) hgt,\n  use (a-\u03b4), use (a+\u03b4),\n  split,{\n    split;finish,\n  },\n  intros x h2,\n  have h3:|x-a|<\u03b4,{\n    apply abs_sub_lt_iff.mpr,\n    rcases h2 with \u27e8h3,h4\u27e9,\n    clear_except h3 h4,\n    split;linarith,\n  },\n  replace h1:=h1 x h3,\n  clear_except h1,\n  replace h1:=(abs_sub_lt_iff.mp h1).right,\n  linarith,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209308,"user_id":17,"body":"import Preloaded\n\nopen set\n\n-- Original author: @monadius\n-- Copied for the purposes of v3.39.1 migration only\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 :=\nbegin\n  obtain \u27e8d, hd, h\u27e9 := hcont (f a \/ 2) (half_pos hgt),\n  existsi a - d, existsi a + d,\n  split; simp only [mem_Ioo, lt_add_iff_pos_right], \n    split, linarith, assumption,\n  rintro x \u27e8h1, h2\u27e9,\n  have : abs (x - a) < d,\n    rw abs_sub_lt_iff, split; linarith,\n  have := h _ this, rw abs_sub_lt_iff at this,\n  obtain \u27e8h2, h3\u27e9 := this, linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209309,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\nopen set\n\ntheorem continuous_function_about_an_open_interval {f a}\n  (hcont : continuous_at f a) (hgt : f a > 0) :\n  \u2203 b c : \u211d, a \u2208 Ioo b c \u2227 \u2200 x \u2208 Ioo b c, f x > 0 := \nbegin\n  rcases (hcont (f a) (by linarith)) with \u27e8\u03b4, h\u03b4, hf\u27e9,\n  use [a-\u03b4, a+\u03b4],\n  split,\n  { unfold Ioo, split; linarith },\n  rintros x \u27e8hx1, hx2\u27e9,  \n  have h : abs (x - a) < \u03b4,\n  { exact abs_lt.mpr \u27e8(by linarith), (by linarith)\u27e9 },\n  specialize hf x h,\n  linarith [(abs_lt.mp hf).left],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ea1f341014f0c0001ec7c5e":[{"id":209310,"user_id":null,"body":"import Preloaded\nopen_locale classical\n\nlocal attribute [instance, priority 1001] classical.prop_decidable\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) :\nx\u2080 = x\u2081 :=\nbegin\n    by_contradiction h,\n    have x01_pos : (dist x\u2080 x\u2081) \/ 2 > 0 := half_pos (dist_pos.mpr h),\n    cases h\u2080 ((dist x\u2080 x\u2081)\/2) x01_pos with N1 hx0,\n    cases h\u2081 ((dist x\u2080 x\u2081)\/2) x01_pos with N2 hx1,\n    set N := max N1 N2 with hN,\n    specialize hx0 N (le_max_left N1 N2),\n    specialize hx1 N (le_max_right N1 N2),\n    have : dist x\u2080 x\u2081 \u2264 (dist x\u2080 (s N)) + (dist x\u2081 (s N)) := dist_triangle_right x\u2080 x\u2081 (s N),\n    linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209311,"user_id":null,"body":"import Preloaded\n\ntheorem funnylemma (a : \u211d) (h1 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 a < \u03b5) (h2 : 0 \u2264 a) : a = 0 :=\nbegin\n  norm_cast at *,\n  have h:= lt_trichotomy 0 a,\n  cases h,\n  exfalso,\n  have h3 := h1 _ h,\n  simp at h3,\n  assumption,\n  cases h,\n  symmetry,\n  exact h,\n  linarith,\nend\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) :\nx\u2080 = x\u2081 :=\nbegin\n  unfold converges_to at h\u2080 h\u2081,\n  have converges : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 dist x\u2080 x\u2081 < \u03b5 := by\n  begin\n    intros eps pos,\n    have H := h\u2081 (eps \/ 2) (by {apply div_pos, assumption, simp,}),\n    have H2 := h\u2080 (eps \/ 2) (by {apply div_pos, assumption, simp,}),\n    rcases H with \u27e8n1, p1\u27e9,\n    rcases H2 with \u27e8n2, p2\u27e9,\n    specialize p1 (max n1 n2) (by simp),\n    specialize p2 (max n1 n2) (by simp),\n    have h3 := dist_triangle_right x\u2080 x\u2081 (s (max n1 n2)),\n    have h4 := add_lt_add p2 p1,\n    norm_num at h4,\n    linarith,\n  end,\n  have pos: 0 \u2264 dist x\u2080 x\u2081 := dist_nonneg,\n  have iszero := funnylemma _ converges pos,\n  apply eq_of_dist_eq_zero iszero,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209312,"user_id":null,"body":"import Preloaded\n\ntheorem limit_unique {X : Type*} [met:metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) :\nx\u2080 = x\u2081 :=\nbegin\n  by_cases x\u2080=x\u2081,\n  assumption,\n  exfalso,\n  let d := dist x\u2080 x\u2081,\n  have : d>0 := dist_pos.mpr h,\n  have : d\/2>0 := by linarith,\n  specialize h\u2080 (d\/2) this,\n  specialize h\u2081 (d\/2) this,\n  cases h\u2080 with N\u2080 hN\u2080,\n  cases h\u2081 with N\u2081 hN\u2081,\n  let m := max N\u2080 N\u2081,\n  specialize hN\u2080 m (le_max_left N\u2080 N\u2081),\n  specialize hN\u2081 m (le_max_right N\u2080 N\u2081),\n  have tri := met.dist_triangle,\n  have sym := met.dist_comm,\n  have : d<d :=\n  calc\n    d = dist x\u2080 x\u2081                      : rfl\n    ... \u2264 dist x\u2080 (s m) + dist (s m) x\u2081 : tri _ _ _\n    ... = dist x\u2080 (s m) + dist x\u2081 (s m) : by rw [sym (s m) _] \n    ... < d\/2 + d\/2                     : by linarith \n    ... = d                             : by ring,\n  linarith only [this],\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209313,"user_id":null,"body":"import Preloaded\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) :\nx\u2080 = x\u2081 :=\nbegin\n  apply eq_of_forall_dist_le,\n  intros \u03b5 eps_gt_zero,\n  have eps_third_gt_zero : \u03b5\/3 > 0 :=\n  begin\n    have h\u2080 : (0:\u211d) < (3:\u211d) :=\n    begin\n      exact three_pos,\n    end,\n    have ha : (0:\u211d) * (3:\u211d) = (0:\u211d) :=\n    begin\n      exact zero_mul 3,\n    end,\n    have hb : (\u03b5\/3) * 3 = \u03b5 := by ring,\n    apply norm_num.clear_denom_lt (0:\u211d) (0:\u211d) (\u03b5\/3) \u03b5 (3:\u211d) h\u2080 ha hb eps_gt_zero,\n  end,\n  have foo0 := h\u2080 (\u03b5\/3) eps_third_gt_zero,\n  have foo1 := h\u2081 (\u03b5\/3) eps_third_gt_zero,\n  have step : \u2200N0, \u2200N1, (\u2200 (n : \u2115) (hn : N0 \u2264 n), dist x\u2080 (s n) < \u03b5\/3) \u2192 (\u2200 (n : \u2115) (hn : N1 \u2264 n), dist x\u2081 (s n) < \u03b5\/3) \u2192 dist x\u2080 x\u2081 \u2264 \u03b5 :=\n  begin\n    intros N0 N1 N0_prop N1_prop,\n    let N2 := max N0 N1,\n    have A1: dist x\u2080 (s N2) < \u03b5\/3 :=\n    begin\n      apply N0_prop,\n      exact le_max_left N0 N1,\n    end,\n    have A2: dist x\u2081 (s N2) < \u03b5\/3 :=\n    begin\n      apply N1_prop,\n      exact le_max_right N0 N1,\n    end,\n    show dist x\u2080 x\u2081 \u2264 \u03b5, from\n    calc\n      dist x\u2080 x\u2081 \u2264 dist x\u2080 (s N2) + dist (s N2) x\u2081 : by apply dist_triangle\n      ... \u2264 dist x\u2080 (s N2) + dist x\u2081 (s N2) :\n      begin\n        rw dist_comm (s N2) x\u2081,\n      end\n      ... \u2264 \u03b5\/3 + \u03b5\/3 :\n      begin\n        apply le_of_lt,\n        linarith,\n      end\n      ... \u2264 \u03b5 : by linarith,\n  end,\n  show _, from exists.elim foo1 (\u03bbN1, exists.elim foo0 (\u03bbN0, step N0 N1)),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209314,"user_id":null,"body":"import Preloaded\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) :\nx\u2080 = x\u2081 :=\nbegin\n  refine classical.by_contradiction _,\n  intro h,\n  have new_h := dist_pos.mpr h,\n  rcases h\u2080 ((dist x\u2080 x\u2081)\/2) (by linarith) with \u27e8N,hN\u27e9,\n  rcases h\u2081 ((dist x\u2080 x\u2081)\/2) (by linarith) with \u27e8N',hN'\u27e9,\n  have nesda := dist_triangle_right x\u2080 x\u2081 (s (max N N')),\n  have ans := add_lt_add (hN (max N N') (le_max_left _ _)) (hN' (max N N') (le_max_right _ _)),\n  linarith\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209315,"user_id":null,"body":"import Preloaded\ntheorem limit_unique {X: Type*} [h: metric_space X] \n  {s: \u2115 \u2192 X} (x\u2080 x\u2081: X) (h\u2080: s \u27f6 x\u2080) (h\u2081: s \u27f6 x\u2081): x\u2080 = x\u2081 := \nbegin\n  apply eq_of_forall_dist_le, rw converges_to at h\u2080 h\u2081, intros \u03b5 h\u03b5,\n  cases h\u2080 (\u03b5\/2) (by linarith) with N\u2080 h\u2080, cases h\u2081 (\u03b5\/2) (by linarith) with N\u2081 h\u2081,\n  let n := max N\u2080 N\u2081, specialize h\u2080 n (le_max_left N\u2080 N\u2081), specialize h\u2081 n (le_max_right N\u2080 N\u2081),\n  linarith [dist_comm x\u2081 (s n), dist_triangle x\u2080 (s n) x\u2081]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209316,"user_id":null,"body":"import Preloaded\ntheorem limit_unique {X: Type*} [h: metric_space X] {s: \u2115 \u2192 X} \n  (x\u2080 x\u2081: X) (h\u2080: s \u27f6 x\u2080) (h\u2081: s \u27f6 x\u2081): x\u2080 = x\u2081 := \nbegin\n  apply eq_of_forall_dist_le, rw converges_to at h\u2080 h\u2081, intros \u03b5 h\u03b5, \n  cases h\u2080 (\u03b5\/2) (by linarith) with N\u2080 h\u2080, cases h\u2081 (\u03b5\/2) (by linarith) with N\u2081 h\u2081,\n  let N := max N\u2080 N\u2081, \n  specialize h\u2080 N (le_max_left N\u2080 N\u2081), specialize h\u2081 N (le_max_right N\u2080 N\u2081),\n  linarith [dist_comm x\u2081 (s N), dist_triangle x\u2080 (s N) x\u2081]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209317,"user_id":null,"body":"import Preloaded\nlocal attribute [instance] classical.prop_decidable\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) : x\u2080 = x\u2081 :=\nbegin\n  by_contradiction hc,\n  have hp : 0 < dist x\u2080 x\u2081 := dist_pos.mpr hc,\n  specialize h\u2080 ((dist x\u2080 x\u2081)\/3) (by linarith),\n  rcases h\u2080 with \u27e8N, hN\u27e9,\n  specialize h\u2081 ((dist x\u2080 x\u2081)\/3) (by linarith),\n  rcases h\u2081 with \u27e8M, hM\u27e9,\n  specialize hN (max N M) (le_max_left N M),\n  specialize hM (max N M) (le_max_right N M),\n  have := dist_triangle_right x\u2080 x\u2081 (s (max N M)),\n  linarith,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209318,"user_id":null,"body":"import Preloaded\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) : x\u2080 = x\u2081 := begin\n  apply eq_of_forall_dist_le,\n  intros \u03b5 h\u03b5,\n  obtain \u27e8N\u2080, h\u2080\u27e9 := h\u2080 (\u03b5\/2) (by linarith),\n  obtain \u27e8N\u2081, h\u2081\u27e9 := h\u2081 (\u03b5\/2) (by linarith),\n  let N := max N\u2080 N\u2081,\n  specialize h\u2080 N (le_max_left _ _),\n  specialize h\u2081 N (le_max_right _ _),\n  rw dist_comm at h\u2081,\n  apply le_of_lt,\n  apply lt_of_le_of_lt (dist_triangle _ _ _),\n  rw \u2190add_halves \u03b5,\n  exact add_lt_add h\u2080 h\u2081,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209319,"user_id":191,"body":"import Preloaded\n\ntheorem limit_unique {X : Type*} [metric_space X] {s : \u2115 \u2192 X}\n  (x\u2080 x\u2081 : X) (h\u2080 : s \u27f6 x\u2080) (h\u2081 : s \u27f6 x\u2081) : x\u2080 = x\u2081 :=\nbegin\n  classical,\n  by_contradiction h,\n  rw push_neg.not_eq at h,\n  rw \u2190 dist_pos at h,\n  specialize h\u2080 ((dist x\u2080 x\u2081)\/2) (by linarith),\n  specialize h\u2081 ((dist x\u2080 x\u2081)\/2) (by linarith),\n  cases h\u2080 with N hN,\n  cases h\u2081 with M hM,\n  let K := max N M,\n  specialize hN K (le_max_left _ _),\n  specialize hM K (le_max_right _ _),\n  have wrong : dist x\u2080 x\u2081 < dist x\u2080 x\u2081,\n  calc dist x\u2080 x\u2081 \u2264 dist x\u2080 (s K) + dist (s K) x\u2081 : dist_triangle _ _ _\n              ... < (dist x\u2080 x\u2081) \/ 2 + dist (s K) x\u2081 : (add_lt_add_iff_right _).2 hN\n              ... = (dist x\u2080 x\u2081) \/ 2 + dist x\u2081 (s K) : by rw dist_comm x\u2081\n              ... < (dist x\u2080 x\u2081) \/ 2 + (dist x\u2080 x\u2081) \/2 : (add_lt_add_iff_left _).2 hM\n              ... = dist x\u2080 x\u2081 : add_halves' _,\n  exact has_lt.lt.false wrong\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ea24f59c3928c002e0be59c":[{"id":209320,"user_id":null,"body":"import Preloaded\n\nlemma if_abs_lt {x y : \u211d} : abs x < y \u2192 x < y \u2227 -x < y :=\nbegin\n  intro, split, repeat {refine lt_of_le_of_lt _ a},\n  apply le_abs_self, apply neg_le_abs_self,\nend\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=\nbegin\n  split; {intros \u03b5 \u03b5pos,\n  cases h\u2081 \u03b5 \u03b5pos with N1 h1,\n  cases h\u2082 \u03b5 \u03b5pos with N2 h2,\n  use max N1 N2, intros n hn, dsimp,\n  replace h1 := if_abs_lt (h1 n (ge_trans hn _)),\n  replace h2 := if_abs_lt (h2 n (ge_trans hn _)),\n  apply abs_lt_of_lt_of_neg_lt;\n  {unfold max min, split_ifs; linarith},\n  apply le_max_right, apply le_max_left},\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209321,"user_id":null,"body":"import Preloaded\n\ntheorem lim_add (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k) : lim_to_inf (x + y) (l + k) := begin\n  intros \u03b5 h\u03b5,\n  cases h\u2081 (\u03b5 \/ 2) (by linarith) with N hN,\n  cases h\u2082 (\u03b5 \/ 2) (by linarith) with M hM,\n  use max N M,\n  intros n hn,\n  simp,\n  specialize hN n (le_of_max_le_left hn),\n  specialize hM n (le_of_max_le_right hn),\n  rw abs_lt at *,\n  split; linarith,\nend\n\ntheorem lim_sub (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k) : lim_to_inf (x - y) (l - k) := begin\n  intros \u03b5 h\u03b5,\n  cases h\u2081 (\u03b5 \/ 2) (by linarith) with N hN,\n  cases h\u2082 (\u03b5 \/ 2) (by linarith) with M hM,\n  use max N M,\n  intros n hn,\n  simp,\n  specialize hN n (le_of_max_le_left hn),\n  specialize hM n (le_of_max_le_right hn),\n  rw abs_lt at *,\n  split; linarith,\nend\n\ntheorem lim_q2 (x : \u2115 \u2192 \u211d) (l : \u211d) (h : lim_to_inf x l) : lim_to_inf (x \/ 2) (l \/ 2) := begin\n  intros \u03b5 h\u03b5,\n  cases h (\u03b5 \/ 2) (by linarith) with N hN,\n  use N,\n  intros n hn,\n  simp,\n  specialize hN n hn,\n  rw abs_lt at *,\n  split; linarith,\nend\n\ntheorem lim_abs (x : \u2115 \u2192 \u211d) (l : \u211d) (h : lim_to_inf x l) : lim_to_inf (|x|) (|l|) := begin\n  intros \u03b5 h\u03b5,\n  cases h \u03b5 h\u03b5 with N hN,\n  use N,\n  intros n hn,\n  specialize hN n hn,\n  change |x| n with |x n|,\n  have := abs_abs_sub_abs_le_abs_sub (x n) l,\n  linarith,\nend\n\ntheorem max_add (a : \u211d) (b : \u211d) : max a b = (a + b + |b - a|) \/ 2 := begin\n  rw [abs_eq_max_neg, max_def, max_def],\n  split_ifs; linarith,\nend\n\ntheorem min_sub (a : \u211d) (b : \u211d) : min a b = (a + b - |b - a|) \/ 2 := begin\n  rw [abs_eq_max_neg, min_def, max_def],\n  split_ifs; linarith,\nend\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) := begin\n  split,\n  {\n    have : (\u03bb n, max (x n) (y n)) = (x + y + |y - x|) \/ 2,\n    {\n      ext n,\n      rw [max_add],\n      refl,\n    },\n    rw [this, max_add],\n    apply lim_q2,\n    apply lim_add,\n    apply lim_add; assumption,\n    apply lim_abs,\n    apply lim_sub; assumption,\n  },\n  {\n    have : (\u03bb n, min (x n) (y n)) = (x + y - |y - x|) \/ 2,\n    {\n      ext n,\n      rw [min_sub],\n      refl,\n    },\n    rw [this, min_sub],\n    apply lim_q2,\n    apply lim_sub,\n    apply lim_add; assumption,\n    apply lim_abs,\n    apply lim_sub; assumption,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209322,"user_id":null,"body":"import Preloaded topology.continuous_function.algebra\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=\nbegin\n  split;\n  { intros \u03b5 h\u03b5,\n    obtain \u27e8N\u2081, hN\u2081\u27e9 := h\u2081 (\u03b5 \/ 4) (by exact div_pos h\u03b5 (by norm_num)), \n    obtain \u27e8N\u2082, hN\u2082\u27e9 := h\u2082 (\u03b5 \/ 4) (by exact div_pos h\u03b5 (by norm_num)),\n    use (max N\u2081 N\u2082),\n    intros n hn,\n    dsimp only,\n    try { rw [max_eq_half_add_add_abs_sub, max_eq_half_add_add_abs_sub], },\n    try { rw [min_eq_half_add_sub_abs_sub, min_eq_half_add_sub_abs_sub], },\n    specialize hN\u2081 n (le_of_max_le_left hn), \n    specialize hN\u2082 n (le_of_max_le_right hn), \n    rw abs_lt at hN\u2081 hN\u2082 \u22a2,\n    have hN\u2083 : |(|x n - y n| - |l - k|)| < \u03b5 \/ 2,\n    { apply lt_of_le_of_lt (abs_abs_sub_abs_le_abs_sub (x n - y n) (l - k)),\n      rw abs_lt, \n      split; linarith, },\n    rw abs_lt at hN\u2083,\n    split; { rw [\u2190 mul_sub_left_distrib, \u2190 div_eq_inv_mul], linarith, }, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209323,"user_id":null,"body":"import Preloaded tactic algebra.order.group algebra.order.field\n\ndef neg_seq (f:\u2115\u2192\u211d):=\u03bbn, -(f n)\n\ndef add_seq (f g:\u2115\u2192\u211d):=\u03bbn,(f n)+(g n)\n\ndef sub_seq (f g:\u2115\u2192\u211d):=\u03bbn,(f n)-(g n)\n\nlemma lim_neg (f:\u2115\u2192\u211d)(l:\u211d):lim_to_inf f l \u2192 lim_to_inf (neg_seq f) (-l):=by{\n  intros lmf \u03b5 \u03b5pos,\n  cases (lmf \u03b5 \u03b5pos) with N lmf,\n  use N,\n  intros n ngN,\n  specialize lmf n ngN,\n  simp [neg_seq],\n  have h: l - f n =-(f n -l),{\n    ring,\n  },\n  rw [h],\n  have h1 : | -((f n) - l)|=|(f n) - l| ,{\n    exact abs_neg (f n - l),\n  },\n  rwa [h1],\n}\n\nlemma lim_add (f g:\u2115\u2192\u211d)(lf lg:\u211d):lim_to_inf f lf \u2192 lim_to_inf g lg \u2192\nlim_to_inf (add_seq f g) (lf+lg):=by{\n  intros lmf lmg \u03b5 \u03b5pos,\n  have h1:\u03b5\/2>0,linarith,\n  specialize lmf (\u03b5\/2) h1,\n  specialize lmg (\u03b5\/2) h1,\n  cases lmf with n1,\n  cases lmg with n2,\n  use (n1+n2),\n  intros N hN,\n  unfold add_seq,\n  have h2:N\u2265 n1,omega,\n  have h3:N\u2265n2,omega,\n  specialize lmf_h N h2,\n  specialize lmg_h N h3,\n  clear_except lmf_h lmg_h,\n  have h1:f N + g N -(lf+lg)=(f N -lf)+(g N -lg),ring,\n  rw [h1],\n  have h2:|f N - lf + (g N - lg)|\u2264|f N -lf|+|g N-lg|,exact abs_add (f N - lf) (g N - lg),\n  linarith,\n}\n\nlemma lim_sub (f g:\u2115\u2192\u211d)(lf lg:\u211d):lim_to_inf f lf \u2192 lim_to_inf g lg \u2192\nlim_to_inf (sub_seq f g) (lf-lg):=by{\n  intros lmf lmg,\n  have h1:=lim_neg g lg lmg,\n  have h2:=lim_add f (neg_seq g) lf (-lg) lmf h1,\n  exact h2,\n}\n\nlemma max_eq (a b:\u211d):(max a b) = (a+b+abs(a-b))\/2:=by{\n  by_cases (a>b),{\n    have h1:max a b =a,{\n      refine max_eq_iff.mpr _,\n      left,\n      split,\n      refl,\n      exact le_of_lt h,\n    },\n    have h2:|a-b|=a-b,{\n      finish,\n    },\n    rw [h1,h2],\n    ring,\n  },{\n     have h1:max a b =b,{\n      refine max_eq_iff.mpr _,\n      right,\n      split,\n      refl,\n      exact not_lt.mp h,\n    },\n    have h2:|a-b|=b-a,{\n      push_neg at h,\n      refine (abs_eq _).mpr _,\n      exact sub_nonneg.mpr h,\n      right,\n      ring,\n    },\n    rw [h1,h2],\n    ring,\n  }\n}\n\nlemma min_eq (a b:\u211d):(min a b)=(a+b-abs(a-b))\/2:=by{\n  by_cases (a>b),{\n    have h1:min a b =b,{\n      refine min_eq_iff.mpr _,\n      right,\n      split,\n      refl,\n      exact le_of_lt h,\n    },\n    have h2:|a-b|=a-b,{\n      finish,\n    },\n    rw [h1,h2],\n    ring,\n  },{\n     have h1:min a b =a,{\n      refine min_eq_iff.mpr _,\n      left,\n      split,\n      refl,\n      exact not_lt.mp h,\n    },\n    have h2:|a-b|=b-a,{\n      push_neg at h,\n      refine (abs_eq _).mpr _,\n      exact sub_nonneg.mpr h,\n      right,\n      ring,\n    },\n    rw [h1,h2],\n    ring,\n  }\n}\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) := by{\n  split,{\n    intros \u03b5 \u03b5pos,\n    have h:\u03b5\/4>0,nlinarith,\n    have h2:\u03b5\/2>0,linarith,\n    have h1:=h\u2081 (\u03b5\/4) h,\n    have h2:=h\u2082 (\u03b5\/4) h,\n    cases h1 with n1 hn1,\n    cases h2 with n2 hn2,\n    have h1:= lim_sub x y l k h\u2081 h\u2082,\n    cases (h1 (\u03b5\/2) h2) with n3 hn3,\n    use n1+n2+n3,\n    clear h\u2081 h\u2082 h2 h h1,\n    intros n h1,\n    dsimp,\n    rw [max_eq (x n) (y n), max_eq l k],\n    have h2:n\u2265n1,omega,\n    have h3:n\u2265n2,omega,\n    have h4:n\u2265n3,omega,\n    have h5:=hn1 n h2,\n    have h6:=hn2 n h3,\n    have h7:=hn3 n h4,\n    clear_except h5 h6 h7 \u03b5pos,\n    exact calc\n    |(x n + y n + |x n - y n|) \/ 2 - (l + k + |l - k|) \/ 2|\n    =|((x n + y n + |x n - y n|)-(l + k + |l - k|))\/2| : by{\n      ring_nf,\n    }\n    ...=|((x n -l)+ (y n - k) + (|x n - y n| - |l - k|))\/2| : by{\n      ring_nf,\n    }\n    ...=|(x n -l)+ (y n - k) + (|x n - y n| - |l - k|)|\/|2| : by{\n      exact abs_div (x n - l + (y n - k) + (|x n - y n| - |l - k|)) 2,\n    }\n    ...=|(x n -l)+ (y n - k) + (|x n - y n| - |l - k|)|\/2:by{\n      norm_num,\n    }\n    ...\u2264(|(x n) -l+(y n - k)| +| (|x n - y n| - |l - k|)|)\/2:by{\n      have h:0\u2264(2:\u211d),norm_num,\n      apply (div_le_div_of_le h),\n      exact abs_add (x n - l + (y n - k)) (|x n - y n| - |l - k|),\n    }\n    ...\u2264(|(x n) -l|+|(y n) -k|+|(|x n -y n|)-(|l-k|)|)\/2 : by{\n      have h:0\u2264(2:\u211d),norm_num,\n      apply (div_le_div_of_le h),\n      apply (add_le_add),\n      exact abs_add (x n - l) (y n - k),\n      exact rfl.ge,\n    }\n    ...\u2264|(x n) -l| \/2+|(y n) -k|\/2 +|(|x n - (y n)|)-(|l-k|)|\/2: by{\n      ring_nf,\n    }\n    ...\u2264|(x n) -l|\/2+|(y n) -k|\/2 +|((x n - y n)-(l-k))|\/2:by{\n      simp,\n      have h:0\u2264(2:\u211d),norm_num,\n      apply (div_le_div_of_le h),\n      exact abs_abs_sub_abs_le_abs_sub (x n - y n) (l-k),\n    }\n    ...<\u03b5\/4\/2+\u03b5\/4\/2+\u03b5\/2\/2:by{\n      dsimp [sub_seq] at h7,\n      have h:0\u2264(2:\u211d),norm_num,\n      have h1:0<(2:\u211d),norm_num,\n      mono left,mono left,\n      repeat{\n        apply (div_le_div_of_le h),\n        nlinarith,\n      },{\n        set a:=|x n - (y n) -(l-k)|,\n        apply (div_lt_div_of_lt h1),\n        exact h7,\n      }\n    }\n    ...=\u03b5\/4+\u03b5\/2\/2:by{\n      ring,\n    }\n    ...<\u03b5 : by{\n      linarith,\n    }\n  },{\n    intros \u03b5 \u03b5pos,\n    have h:\u03b5\/4>0,nlinarith,\n    have h2:\u03b5\/2>0,linarith,\n    have h1:=h\u2081 (\u03b5\/4) h,\n    have h2:=h\u2082 (\u03b5\/4) h,\n    cases h1 with n1 hn1,\n    cases h2 with n2 hn2,\n    have h1:= lim_sub x y l k h\u2081 h\u2082,\n    cases (h1 (\u03b5\/2) h2) with n3 hn3,\n    use n1+n2+n3,\n    clear h\u2081 h\u2082 h2 h h1,\n    intros n h1,\n    dsimp,\n    rw [min_eq (x n) (y n), min_eq l k],\n    have h2:n\u2265n1,omega,\n    have h3:n\u2265n2,omega,\n    have h4:n\u2265n3,omega,\n    have h5:=hn1 n h2,\n    have h6:=hn2 n h3,\n    have h7:=hn3 n h4,\n    clear_except h5 h6 h7 \u03b5pos,\n    exact calc\n    |(x n + y n - |x n - y n|) \/ 2 - (l + k - |l - k|) \/ 2|\n    =|((x n + y n - |x n - y n|)-(l + k - |l - k|))\/2| : by{\n      ring_nf,\n    }\n    ...=|((x n -l)+ (y n - k) - (|x n - y n| - |l - k|))\/2| : by{\n      ring_nf,\n    }\n    ...=|(x n -l)+ (y n - k) - (|x n - y n| - |l - k|)|\/|2| : by{\n      exact abs_div (x n - l + (y n - k) - (|x n - y n| - |l - k|)) 2,\n    }\n    ...=|(x n -l)+ (y n - k) - (|x n - y n| - |l - k|)|\/2:by{\n      norm_num,\n    }\n    ...\u2264(|(x n) -l+(y n - k)| +| (|x n - y n| - |l - k|)|)\/2:by{\n      have h:0\u2264(2:\u211d),norm_num,\n      apply (div_le_div_of_le h),\n      exact abs_sub (x n - l + (y n - k)) (|x n - y n| - |l - k|),\n    }\n    ...\u2264(|(x n) -l|+|(y n) -k|+|(|x n -y n|)-(|l-k|)|)\/2 : by{\n      have h:0\u2264(2:\u211d),norm_num,\n      apply (div_le_div_of_le h),\n      apply (add_le_add),\n      exact abs_add (x n - l) (y n - k),\n      exact rfl.ge,\n    }\n    ...\u2264|(x n) -l| \/2+|(y n) -k|\/2 +|(|x n - (y n)|)-(|l-k|)|\/2: by{\n      ring_nf,\n    }\n    ...\u2264|(x n) -l|\/2+|(y n) -k|\/2 +|((x n - y n)-(l-k))|\/2:by{\n      simp,\n      have h:0\u2264(2:\u211d),norm_num,\n      apply (div_le_div_of_le h),\n      exact abs_abs_sub_abs_le_abs_sub (x n - y n) (l-k),\n    }\n    ...<\u03b5\/4\/2+\u03b5\/4\/2+\u03b5\/2\/2:by{\n      dsimp [sub_seq] at h7,\n      have h:0\u2264(2:\u211d),norm_num,\n      have h1:0<(2:\u211d),norm_num,\n      mono left,mono left,\n      repeat{\n        apply (div_le_div_of_le h),\n        nlinarith,\n      },{\n        set a:=|x n - (y n) -(l-k)|,\n        apply (div_lt_div_of_lt h1),\n        exact h7,\n      }\n    }\n    ...=\u03b5\/4+\u03b5\/2\/2:by{\n      ring,\n    }\n    ...<\u03b5 : by{\n      linarith,\n    }\n  }\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209324,"user_id":17,"body":"import Preloaded\n\n-- Original author: @alreadydone\n-- Copying for the purposes of v3.18.4 migration only\n\nlemma if_abs_lt {x y : \u211d} : abs x < y \u2192 x < y \u2227 -x < y :=\nbegin\n  intro a, split, repeat {refine lt_of_le_of_lt _ a},\n  apply le_abs_self, apply neg_le_abs_self,\nend\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=\nbegin\n  split; {intros \u03b5 \u03b5pos,\n  cases h\u2081 \u03b5 \u03b5pos with N1 h1,\n  cases h\u2082 \u03b5 \u03b5pos with N2 h2,\n  use max N1 N2, intros n hn, dsimp,\n  replace h1 := if_abs_lt (h1 n (ge_trans hn _)),\n  replace h2 := if_abs_lt (h2 n (ge_trans hn _)),\n  rw [abs_lt, neg_lt], split;\n  {simp only [max_def, min_def], split_ifs; linarith},\n  apply le_max_right, apply le_max_left},\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209325,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=  \nbegin\n  have Tmax : \u2200 x : \u211d, max (l + x) (k + x) = max l k + x,\n  { intro x,\n    by_cases h : l \u2264 k,\n    { have hx : l + x \u2264 k + x := by linarith,\n      rw [max_eq_right h, max_eq_right hx] },\n    { have h' : k \u2264 l := by linarith,\n      have hx' : k + x \u2264 l + x := by linarith,\n      rw [ max_eq_left h', max_eq_left hx' ] } },\n  have Tmin : \u2200 x : \u211d, min (l + x) (k + x) = min l k + x,\n  { intro x,\n    by_cases h : l \u2264 k,\n    { have hx : l + x \u2264 k + x := by linarith,\n      rw [ min_eq_left h, min_eq_left hx] },\n    { have h' : k \u2264 l := by linarith,\n      have hx' : k + x \u2264 l + x := by linarith,\n      rw [ min_eq_right h', min_eq_right hx' ] } },\n  split;\n  intros \u03b5 h\u03b5;    \n  rcases h\u2081 \u03b5 h\u03b5 with \u27e8N, hN\u27e9;\n  rcases h\u2082 \u03b5 h\u03b5 with \u27e8M, hM\u27e9;\n  use max N M;\n  intros n hn;\n  specialize hN n (by linarith [le_max_left N M]);\n  specialize hM n (by linarith [le_max_right N M]);\n  simp at *;\n  have t1 := max_lt_iff.mpr \u27e8hN, hM\u27e9;\n  cases max_lt_iff.mp t1 with t11 t12;\n  cases abs_lt.mp t11 with t111 t112;\n  cases abs_lt.mp t12 with t121 t122,\n  { have e1 := by calc max (x n) (y n) > max (l - \u03b5) (k - \u03b5) : max_lt_max (by linarith) (by linarith)\n    ... = (max l k) - \u03b5 : by rw [sub_eq_add_neg, sub_eq_add_neg, Tmax (-\u03b5), sub_eq_add_neg ],\n    have e2 := by calc max (x n) (y n) < max (l + \u03b5) (k + \u03b5) : max_lt_max (by linarith) (by linarith)\n                                ...    = (max l k) + \u03b5 : by rw Tmax (\u03b5),  \n    apply abs_sub_lt_iff.mpr,\n    split;\n    linarith },\n  { have e1 := by calc min (x n) (y n) > min (l - \u03b5) (k - \u03b5) : min_lt_min (by linarith) (by linarith)\n    ...    = (min l k) - \u03b5 : by rw [sub_eq_add_neg, sub_eq_add_neg, Tmin (-\u03b5), sub_eq_add_neg ],\n    have e2 := by calc min (x n) (y n) < min (l + \u03b5) (k + \u03b5) : min_lt_min (by linarith) (by linarith)\n                                ...    = (min l k) + \u03b5 : by rw Tmin (\u03b5),  \n    apply abs_sub_lt_iff.mpr,\n    split;\n    linarith },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209326,"user_id":106,"body":"import Preloaded\n\nlemma max_abs (a b : \u211d) : max a b = (a + b + abs (a - b)) \/ 2 :=\nbegin\n  have ht := min_add_max a b,\n  have h := iff.elim_right (add_right_inj (max a b - min a b)) ht,\n  rw [\u2190add_assoc, sub_add_eq_add_sub, add_sub_assoc] at h,\n  simp at h, rw [max_sub_min_eq_abs' a b, add_comm (abs _)] at h, linarith\nend\n\nlemma min_abs (a b : \u211d) : min a b = (a + b - abs (a - b)) \/ 2 :=\nbegin\n  have ht := min_add_max a b,\n  have h := iff.elim_right (add_right_inj (max a b - min a b)) ht,\n  rw [\u2190add_assoc, sub_add_eq_add_sub, add_sub_assoc] at h,\n  simp at h, rw [max_sub_min_eq_abs' a b, add_comm (abs _)] at h, linarith\nend\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=\nbegin\n  split; intros \u03b5 h\u03b5,\n  {\n    have h\u03b52 : \u03b5 \/ 2 > 0, by linarith,\n    cases (h\u2081 (\u03b5 \/ 2) h\u03b52) with N\u2081 h\u2081,\n    cases (h\u2082 (\u03b5 \/ 2) h\u03b52) with N\u2082 h\u2082,\n    existsi max N\u2081 N\u2082, intros n hn, simp,\n    specialize h\u2081 n (le_trans (le_max_left _ _) hn),\n    specialize h\u2082 n (le_trans (le_max_right _ _) hn),\n    rw [max_abs, max_abs, \u2190sub_div, abs_div], simp,\n    apply iff.elim_left (mul_lt_mul_right zero_lt_two),\n    rw (div_mul_cancel _ (two_ne_zero : (2 : \u211d) \u2260 0)),\n    have h' : x n + y n + abs (x n - y n) - (l + k + abs (l - k)) = (x n - l) + (y n - k) + abs (x n - y n) - abs (l - k), by ring,\n    rw h', clear h',\n\n    have h := abs_add (x n - l) (y n - k),\n    have h := lt_of_le_of_lt h (add_lt_add_right h\u2081 (abs (y n - k))),\n    have h := lt_trans h (add_lt_add_left h\u2082 _),\n    have h := add_lt_add_right h (abs (abs (x n - y n) - abs (l - k))),\n    have h := lt_of_le_of_lt (abs_add _ _) h,\n    have h' := abs_abs_sub_le_abs_sub (x n - y n) (l - k),\n    have h := lt_of_lt_of_le h (add_le_add_left h' _), clear h',\n    have h' : x n - y n - (l - k) = x n - l + (k - y n), by ring,\n    rw [add_sub, h'] at h, clear h',\n\n    have hk := abs_add (x n - l) (k - y n),\n    have hk := lt_of_le_of_lt hk (add_lt_add_right h\u2081 (abs (k - y n))),\n    rw abs_sub k (y n) at hk,\n    have hk := lt_trans hk (add_lt_add_left h\u2082 _),\n    have hk := lt_trans h (add_lt_add_left hk _),\n    rwa [add_halves, \u2190mul_two] at hk,\n  },\n  {\n    have h\u03b52 : \u03b5 \/ 2 > 0, by linarith,\n    cases (h\u2081 (\u03b5 \/ 2) h\u03b52) with N\u2081 h\u2081,\n    cases (h\u2082 (\u03b5 \/ 2) h\u03b52) with N\u2082 h\u2082,\n    existsi max N\u2081 N\u2082, intros n hn, simp,\n    specialize h\u2081 n (le_trans (le_max_left _ _) hn),\n    specialize h\u2082 n (le_trans (le_max_right _ _) hn),\n    rw [min_abs, min_abs, \u2190sub_div, abs_div], simp,\n    apply iff.elim_left (mul_lt_mul_right zero_lt_two),\n    rw (div_mul_cancel _ (two_ne_zero : (2 : \u211d) \u2260 0)),\n    have h' : x n + y n - abs (x n - y n) - (l + k - abs (l - k)) = (x n - l) + (y n - k) + abs (l - k) - abs (x n - y n), by ring,\n    rw h', clear h',\n\n    have h := abs_add (x n - l) (y n - k),\n    have h := lt_of_le_of_lt h (add_lt_add_left h\u2082 (abs (x n - l))),\n    have h := lt_trans h (add_lt_add_right h\u2081 _),\n    have h := add_lt_add_right h (abs (abs (l - k) - abs (x n - y n))),\n    have h := lt_of_le_of_lt (abs_add _ _) h,\n    have h' := abs_abs_sub_le_abs_sub (l - k) (x n - y n),\n    have h := lt_of_lt_of_le h (add_le_add_left h' _), clear h',\n    have h' : l - k - (x n - y n) = l - x n + (y n - k), by ring,\n    rw [add_sub, h'] at h, clear h',\n\n    have hk := abs_add (l - x n) (y n - k),\n    have hk := lt_of_le_of_lt hk (add_lt_add_left h\u2082 (abs (l - x n))),\n    rw abs_sub l (x n) at hk,\n    have hk := lt_trans hk (add_lt_add_right h\u2081 _),\n    have hk := lt_trans h (add_lt_add_left hk _),\n    rwa [add_halves, \u2190mul_two] at hk,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209327,"user_id":null,"body":"import Preloaded\n\nlemma real_max_explicit (a b : \u211d) : max a b = (1\/2)*(a + b + abs(a - b)) :=\nbegin\n  by_cases a_lt_b : (a \u2264 b),\n  {\n    rw max_eq_right a_lt_b,\n    rw abs_of_nonpos;\n    linarith,\n  },\n  {\n    rw not_le at a_lt_b,\n    rw max_eq_left_of_lt a_lt_b,\n    rw abs_of_pos;\n    linarith,\n  },\nend\n\nlemma abs_neg_sub_neg_eq_sub (a b : \u211d) : abs (-a - -b) = abs (a - b) := \nbegin\n  rw [neg_sub_neg, abs_sub],\nend\n\nlemma min_eq_neg_max (a b : \u211d) : min a b = - max (-a) (-b) :=\nbegin\n  let h := max_sub_min_eq_abs' a b,\n  rw real_max_explicit at *,\n  rw abs_neg_sub_neg_eq_sub _ _,\n  linarith,\nend\n\nlemma abs_abs_sub_sub_abs_sub_lt (a b c d e f : \u211d ) ( h\u2081 : abs (a - c) < e ) ( h\u2082 : abs (b - d) < f )\n: abs(abs (a - b) - abs (c - d)) < e + f :=\nbegin\n  calc abs(abs (a - b) - abs (c - d)) \u2264 abs ( (a - b) - (c - d)) : by apply abs_abs_sub_abs_le_abs_sub\n                                  ... = abs ( (a - c) + (d - b) ) : by {congr, ring}\n                                  ... \u2264 abs (a - c) + abs (d - b) : by apply abs_add\n                                  ... = abs (a - c) + abs (b - d) : by rw (abs_sub d _)\n                                  ... < e + f : by linarith,\nend\n\nlemma abs_max_sub_max_lt (a b c d e f : \u211d ) ( h\u2081 : abs (a - c) < e ) ( h\u2082 : abs (b - d) < f )\n: abs (max a b - max c d) < e + f :=\nbegin\n  repeat {rw real_max_explicit},\n  rw \u2190 mul_sub,\n  rw abs_mul,\n  rw abs_of_pos,\n  calc 1 \/ 2 * abs (a + b + abs (a - b) - (c + d + abs (c - d))) = (1\/2)*abs( (a - c) + (b - d) + (abs (a - b) - abs (c - d))) : by {congr, ring, }\n                                                                ... < e + f : by linarith [abs_add_three (a - c) (b - d) (abs (a - b) - abs (c - d)), abs_abs_sub_sub_abs_sub_lt a b c d e f h\u2081 h\u2082],\n  exact one_half_pos,\nend\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) := \nbegin\n  split;\n  intros \u03b5 \u03b5_pos;\n  dsimp only;\n  specialize h\u2081 (\u03b5\/2) (by linarith);\n  cases h\u2081 with N\u2081 hN\u2081;\n  specialize h\u2082 (\u03b5\/2) (by linarith);\n  cases h\u2082 with N\u2082 hN\u2082;\n  let N := max N\u2081 N\u2082;\n  use N;\n  intros n hn;\n  specialize hN\u2081 n (by linarith [le_max_left N\u2081 N\u2082]);\n  specialize hN\u2082 n (by linarith [le_max_right N\u2081 N\u2082]),\n  { linarith [abs_max_sub_max_lt (x n) (y n) l k (\u03b5\/2) (\u03b5\/2) hN\u2081 hN\u2082], },\n  {\n    repeat {rw min_eq_neg_max},\n    rw abs_neg_sub_neg_eq_sub,\n    rw \u2190 abs_neg_sub_neg_eq_sub at hN\u2081 hN\u2082,\n    linarith [abs_max_sub_max_lt (-x n) (-y n) (-l) (-k) (\u03b5\/2) (\u03b5\/2) hN\u2081 hN\u2082],\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209328,"user_id":null,"body":"import Preloaded\n\nopen classical\n\nlemma max_min_rw {x y : \u211d} : max x y = 1 \/ 2 * (x + y + abs(x - y)) \u2227 min x y = 1 \/ 2 * (x + y - abs(x - y)) :=\n  begin\n    have h := classical.em (x \u2264 y);\n    rw not_le at h;\n    cases h with h_le h_lt,\n    {\n      rw [max_eq_right h_le, min_eq_left h_le],\n      rw \u2190 sub_nonneg at h_le,\n      repeat {rw abs_sub x y},\n      rw [abs_of_nonneg h_le, add_assoc x, add_sub, \u2190 two_mul y, \u2190 sub_add],\n      simp,\n      rw \u2190 two_mul x,\n      repeat {rw \u2190 mul_assoc},\n      norm_num,\n    },\n    {\n      rw [min_eq_right (le_of_lt h_lt), max_eq_left (le_of_lt h_lt)],\n      rw \u2190 sub_pos at h_lt,\n      rw [abs_of_pos h_lt, add_sub, add_assoc, add_comm y x, \u2190 add_assoc, \u2190 two_mul x, \u2190 add_sub, sub_self, \u2190 sub_add, add_comm x y, \u2190 add_sub, sub_self, add_zero, add_zero, \u2190 two_mul],\n      norm_num,\n    }\n  end\n\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=\n  \n  begin\n    have two_pos : 0 < (2 : \u211d), by norm_num,\n    split;\n    intros \u03b5 \u03b5_pos;\n    specialize h\u2081 (\u03b5 \/ 2);\n    specialize h\u2082 (\u03b5 \/ 2);\n    specialize h\u2081 (div_pos \u03b5_pos two_pos);\n    specialize h\u2082 (div_pos \u03b5_pos two_pos);\n    cases h\u2081 with N\u2081 h_N\u2081;\n    cases h\u2082 with N\u2082 h_N\u2082;\n    use max N\u2081 N\u2082;\n    intro n;\n    contrapose!;\n    intro h;\n    specialize h_N\u2081 n;\n    specialize h_N\u2082 n;\n    rw lt_iff_not_ge;\n    intro h\u2099;\n    rw [ge, max_le_iff, \u2190 ge, \u2190 ge] at h\u2099;\n    specialize h_N\u2081 h\u2099.left;\n    specialize h_N\u2082 h\u2099.right,\n    {\n      repeat {rw max_min_rw.left at h},\n      rw [\u2190 mul_sub, abs_mul] at h,\n      simp at h,\n      rw [abs_inv, abs_of_pos two_pos, sub_add_eq_sub_sub, sub_add_eq_sub_sub, \u2190 div_eq_inv_mul, le_div_iff two_pos, add_comm (x n), add_assoc (y n), add_comm (x n), \u2190 add_assoc (y n)] at h,\n      rw [\u2190 add_sub (y n + abs (x n - y n)) (x n) l, add_assoc, add_comm (abs (x n - y n)), \u2190 add_assoc, add_comm (y n), add_assoc, add_comm (y n), \u2190 add_assoc, \u2190 add_sub (x n - l + abs (x n - y n)) (y n) k] at h,\n      rw [add_assoc, add_comm (abs (x n - y n)), \u2190 add_assoc, \u2190 add_sub] at h,\n      have h_3 := abs_add_le_abs_add_abs (x n - l + (y n - k)) (abs (x n - y n) - abs (l - k)),\n      have h_4 := abs_add_le_abs_add_abs (x n - l) (y n - k),\n      have h_5 := abs_abs_sub_le_abs_sub (x n - y n) (l - k),\n      rw [sub_sub, add_sub, add_comm (y n) l, \u2190 add_sub, \u2190 sub_sub, sub_eq_add_neg (x n - l)] at h_5,\n      have h_6 := abs_add_le_abs_add_abs (x n - l) (-(y n - k)),\n      rw abs_neg at h_6,\n      linarith,\n    },\n    {\n      repeat {rw max_min_rw.right at h},\n      rw [\u2190 mul_sub, abs_mul] at h,\n      simp at h,\n      rw [abs_inv, abs_of_pos two_pos, \u2190 div_eq_inv_mul, le_div_iff two_pos, \u2190 sub_add, sub_right_comm, \u2190 sub_sub, sub_right_comm (x n + y n) l k, \u2190 add_sub, add_comm (x n), \u2190 add_sub, sub_add, sub_eq_add_neg] at h,\n      have h_3 := abs_add_le_abs_add_abs (y n - k + (x n - l)) (-(abs (x n - y n) - abs (l - k))),\n      rw abs_neg at h_3,\n      have h_4 := abs_add_le_abs_add_abs (y n - k) (x n - l),\n      have h_5 := abs_abs_sub_le_abs_sub (x n - y n) (l - k),\n      rw [sub_sub, add_sub, add_comm (y n) l, \u2190 add_sub, \u2190 sub_sub, sub_eq_add_neg (x n - l)] at h_5,\n      have h_6 := abs_add_le_abs_add_abs (x n - l) (-(y n - k)),\n      rw abs_neg at h_6,\n      linarith,\n    },\n    \n  end\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209329,"user_id":null,"body":"import Preloaded\n\ntheorem exercise_1p18 (x y : \u2115 \u2192 \u211d) (l k : \u211d) (h\u2081 : lim_to_inf x l)\n  (h\u2082 : lim_to_inf y k)  : lim_to_inf (\u03bb n, max (x n) (y n)) (max l k) \u2227\n  lim_to_inf (\u03bb n, min (x n) (y n)) (min l k) :=\nbegin\n  split,\n  { intros \u03b5 \u03b5_pos,\n    rcases lt_trichotomy l k with hlk | hlk | hlk,\n    { let \u03b5' := min \u03b5 ((k - l) \/ 2),\n      have \u03b5'_pos := lt_min \u03b5_pos (half_pos (sub_pos.mpr hlk)),\n      specialize h\u2081 \u03b5' \u03b5'_pos,\n      specialize h\u2082 \u03b5' \u03b5'_pos,\n      cases h\u2081 with N\u2081 hN\u2081,\n      cases h\u2082 with N\u2082 hN\u2082,\n      use max N\u2081 N\u2082,\n      intros n hn,\n      specialize hN\u2081 n (le_of_max_le_left hn),\n      specialize hN\u2082 n (le_of_max_le_right hn),\n      have q\u2081 : y n > k - \u03b5' := sub_lt_of_abs_sub_lt_left hN\u2082,\n      have q\u2082 : x n < l + \u03b5' := sub_lt_iff_lt_add'.mp (lt_of_le_of_lt (le_abs_self (x n - l)) hN\u2081),\n      have q\u2083 : \u03b5' \u2264 (k - l) \/ 2 := min_le_right \u03b5 ((k - l) \/ 2),\n      have hxy := calc\n        y n - x n > (k - \u03b5') - (l + \u03b5')       : by linarith\n        ...       = k - l - 2 * \u03b5'            : by ring\n        ...       \u2265 k - l - 2 * ((k - l) \/ 2) : by linarith\n        ...       = 0                         : by ring,\n      simp [max, le_of_lt hlk, le_of_lt (sub_pos.mp hxy)],\n      exact lt_of_lt_of_le hN\u2082 (min_le_left \u03b5 ((k - l) \/ 2))\n    },\n    { specialize h\u2081 \u03b5 \u03b5_pos,\n      specialize h\u2082 \u03b5 \u03b5_pos,\n      cases h\u2081 with N\u2081 hN\u2081,\n      cases h\u2082 with N\u2082 hN\u2082,\n      use max N\u2081 N\u2082,\n      intros n hn,\n      specialize hN\u2081 n (le_of_max_le_left hn),\n      specialize hN\u2082 n (le_of_max_le_right hn),\n      simp [max, le_of_eq hlk],\n      by_cases hxy : x n \u2264 y n,\n      { simp [hxy], exact hN\u2082 },\n      { simp [hxy], rw \u2190 hlk, exact hN\u2081 }\n    },\n    { let \u03b5' := min \u03b5 ((l - k) \/ 2),\n      have \u03b5'_pos := lt_min \u03b5_pos (half_pos (sub_pos.mpr hlk)),\n      specialize h\u2081 \u03b5' \u03b5'_pos,\n      specialize h\u2082 \u03b5' \u03b5'_pos,\n      cases h\u2081 with N\u2081 hN\u2081,\n      cases h\u2082 with N\u2082 hN\u2082,\n      use max N\u2081 N\u2082,\n      intros n hn,\n      specialize hN\u2081 n (le_of_max_le_left hn),\n      specialize hN\u2082 n (le_of_max_le_right hn),\n      have q\u2081 : x n > l - \u03b5' := sub_lt_of_abs_sub_lt_left hN\u2081,\n      have q\u2082 : y n < k + \u03b5' := sub_lt_iff_lt_add'.mp (lt_of_le_of_lt (le_abs_self (y n - k)) hN\u2082),\n      have q\u2083 : \u03b5' \u2264 (l - k) \/ 2 := min_le_right \u03b5 ((l - k) \/ 2),\n      have hxy := calc\n        x n - y n > (l - \u03b5') - (k + \u03b5')       : by linarith\n        ...       = l - k - 2 * \u03b5'            : by ring\n        ...       \u2265 l - k - 2 * ((l - k) \/ 2) : by linarith\n        ...       = 0                         : by ring,\n      simp [max, not_le.mpr hlk, not_le.mpr (sub_pos.mp hxy)],\n      exact lt_of_lt_of_le hN\u2081 (min_le_left \u03b5 ((l - k) \/ 2))\n    }\n  },\n  { intros \u03b5 \u03b5_pos,\n    rcases lt_trichotomy l k with hlk | hlk | hlk,\n    { let \u03b5' := min \u03b5 ((k - l) \/ 2),\n      have \u03b5'_pos := lt_min \u03b5_pos (half_pos (sub_pos.mpr hlk)),\n      specialize h\u2081 \u03b5' \u03b5'_pos,\n      specialize h\u2082 \u03b5' \u03b5'_pos,\n      cases h\u2081 with N\u2081 hN\u2081,\n      cases h\u2082 with N\u2082 hN\u2082,\n      use max N\u2081 N\u2082,\n      intros n hn,\n      specialize hN\u2081 n (le_of_max_le_left hn),\n      specialize hN\u2082 n (le_of_max_le_right hn),\n      have q\u2081 : y n > k - \u03b5' := sub_lt_of_abs_sub_lt_left hN\u2082,\n      have q\u2082 : x n < l + \u03b5' := sub_lt_iff_lt_add'.mp (lt_of_le_of_lt (le_abs_self (x n - l)) hN\u2081),\n      have q\u2083 : \u03b5' \u2264 (k - l) \/ 2 := min_le_right \u03b5 ((k - l) \/ 2),\n      have hxy := calc\n        y n - x n > (k - \u03b5') - (l + \u03b5')       : by linarith\n        ...       = k - l - 2 * \u03b5'            : by ring\n        ...       \u2265 k - l - 2 * ((k - l) \/ 2) : by linarith\n        ...       = 0                         : by ring,\n      simp [min, le_of_lt hlk, le_of_lt (sub_pos.mp hxy)],\n      exact lt_of_lt_of_le hN\u2081 (min_le_left \u03b5 ((k - l) \/ 2))\n    },\n    { specialize h\u2081 \u03b5 \u03b5_pos,\n      specialize h\u2082 \u03b5 \u03b5_pos,\n      cases h\u2081 with N\u2081 hN\u2081,\n      cases h\u2082 with N\u2082 hN\u2082,\n      use max N\u2081 N\u2082,\n      intros n hn,\n      specialize hN\u2081 n (le_of_max_le_left hn),\n      specialize hN\u2082 n (le_of_max_le_right hn),\n      simp [min, le_of_eq hlk],\n      by_cases hxy : x n \u2264 y n,\n      { simp [hxy], exact hN\u2081 },\n      { simp [hxy], rw hlk, exact hN\u2082 },\n    },\n    { let \u03b5' := min \u03b5 ((l - k) \/ 2),\n      have \u03b5'_pos := lt_min \u03b5_pos (half_pos (sub_pos.mpr hlk)),\n      specialize h\u2081 \u03b5' \u03b5'_pos,\n      specialize h\u2082 \u03b5' \u03b5'_pos,\n      cases h\u2081 with N\u2081 hN\u2081,\n      cases h\u2082 with N\u2082 hN\u2082,\n      use max N\u2081 N\u2082,\n      intros n hn,\n      specialize hN\u2081 n (le_of_max_le_left hn),\n      specialize hN\u2082 n (le_of_max_le_right hn),\n      have q\u2081 : x n > l - \u03b5' := sub_lt_of_abs_sub_lt_left hN\u2081,\n      have q\u2082 : y n < k + \u03b5' := sub_lt_iff_lt_add'.mp (lt_of_le_of_lt (le_abs_self (y n - k)) hN\u2082),\n      have q\u2083 : \u03b5' \u2264 (l - k) \/ 2 := min_le_right \u03b5 ((l - k) \/ 2),\n      have hxy := calc\n        x n - y n > (l - \u03b5') - (k + \u03b5')       : by linarith\n        ...       = l - k - 2 * \u03b5'            : by ring\n        ...       \u2265 l - k - 2 * ((l - k) \/ 2) : by linarith\n        ...       = 0                         : by ring,\n      simp [min, not_le.mpr hlk, not_le.mpr (sub_pos.mp hxy)],\n      exact lt_of_lt_of_le hN\u2082 (min_le_left \u03b5 ((l - k) \/ 2))\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ea281b8888eba001fd3d77c":[{"id":209330,"user_id":null,"body":"import Preloaded\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f :=\nbegin\n    intros e hep,\n    cases hf with l hl,\n\n    have hlp : 0 < l+1,\n        suffices : 0 \u2264 l, linarith,\n        have := le_trans (abs_nonneg _) (hl 1 0),\n        rwa [sub_zero, abs_one, mul_one] at this,\n\n    use [e\/(l+1), div_pos hep hlp],\n    intros x y h,\n    specialize hl x y,\n    rw lt_div_iff' hlp at h,\n    calc\n      abs (f x - f y)\n          \u2264 l * abs (x - y) + 0            : by simp only [hl, add_zero]\n      ... \u2264 l * abs (x - y) + abs (x - y)  : add_le_add (le_refl _) (abs_nonneg _)\n      ... = (l + 1) * abs (x - y)          : by rw [add_mul, one_mul]\n      ... < e                              : h\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209331,"user_id":656,"body":"import Preloaded\n\nlemma lipschitz_nonneg {f : \u211d \u2192 \u211d} (h : lipschitz f) :\n  \u2203 L \u2265 0, \u2200 x y, abs (f x - f y) \u2264 L * abs (x - y) :=\nlet \u27e8L, hL\u27e9 := h in\n\u27e8L, le_trans (abs_nonneg (f 2 - f 1)) (le_trans (hL 2 1) (le_of_eq (by norm_num))), hL\u27e9\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f := \u03bb \u03b5 h\u03b5,\n  let \u27e8L, hL\u2081, hL\u2082\u27e9 := lipschitz_nonneg hf in\nbegin\n  cases eq_or_lt_of_le hL\u2081,\n    { simp [\u2190h] at hL\u2082,\n      refine \u27e8\u03b5, h\u03b5, \u03bb x y _, _\u27e9,\n      rw hL\u2082 x y, norm_num, exact h\u03b5 },\n    exact \u27e8\u03b5 \/ L, div_pos h\u03b5 h, \u03bb x y hxy, lt_of_le_of_lt (hL\u2082 x y) ((lt_div_iff' h).mp hxy) \u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209332,"user_id":null,"body":"import Preloaded\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8L, hL\u27e9 := hf,\n  have L_nonneg : L \u2265 0, by \n  { specialize hL 0 1,\n    norm_num at hL,\n    linarith [abs_nonneg (f 0 - f 1)], },\n  by_cases 0 < L,\n  { use [\u03b5 \/ L, div_pos h\u03b5 h],\n    intros _ _ hxy,\n    apply lt_of_le_of_lt (hL _ _) ((lt_div_iff' h).1 hxy), },\n  { use [1, by norm_num], \n    intros, \n    apply lt_of_le_of_lt _ h\u03b5,\n    convert hL _ _,\n    rw [(show L=0, by linarith), zero_mul], },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209333,"user_id":null,"body":"import tactic\nimport Preloaded\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f := \nbegin\n  intros \u03b5 h, rcases hf with \u27e8L, hf\u27e9,\n  by_cases p : L = 0,\n  \n  {use 1, split, simp,\n  intros x y h\u2081, specialize hf x y,\n  rw p at hf, simp at hf, rw hf, finish, },\n\n  have L_pos : L > 0 := by{have temp := hf 1 0, simp at temp,\n  exact (ne.symm p).le_iff_lt.mp (le_trans (abs_nonneg (f 1 - f 0)) temp), },\n\n  use \u03b5\/L, split,\n  \n  {exact div_pos h L_pos, },\n\n  {intros x y h,\n  specialize hf x y,\n  have : L * |x - y| < \u03b5 := (lt_div_iff' L_pos).mp h,\n  linarith, }, \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209334,"user_id":null,"body":"import Preloaded tactic\nlocal attribute [instance] classical.prop_decidable\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f := \nbegin\n  intros \u03b5 h\u03b5,  \n  have h\u03b5' : \u03b5\/2 > 0 := div_pos h\u03b5 (by norm_num),\n  cases hf with L hL,\n  by_cases L > 0,\n  { use [(\u03b5\/2)\/L, div_pos h\u03b5' h],\n    intros x y hxy,\n    calc abs (f x - f y) \u2264 L * abs(x - y) : hL x y\n                     ... \u2264 L * ((\u03b5\/2)\/L) : (mul_le_mul_left h).mpr (by linarith)\n                     ... = \u03b5\/2 : mul_div_cancel' (\u03b5\/2) (ne_of_gt h)\n                     ... < \u03b5 : by linarith },\n  use [1, zero_lt_one],\n  intros x y hxy,\n  have t := abs_nonneg (x-y),\n  calc abs (f x - f y) \u2264 L * abs (x - y) : hL x y\n                   ... \u2264 0 : mul_nonpos_of_nonpos_of_nonneg (by linarith) t \n                   ... < \u03b5 : by linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209335,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f :=\nbegin\n  rcases hf with \u27e8L, hf\u27e9,\n  intros \u03b5 \u03b5_pos,\n  by_cases hL : L = 0,\n  { use [1, (by linarith)],\n    intros x y _,\n    calc abs (f x - f y)  \u2264 0 * abs (x - y) : by { specialize hf x y, rwa hL at hf }\n                      ... < \u03b5 : by linarith },\n  { have hL' :=\n      calc  0 \u2264 abs (f 1 - f 0) : by apply abs_nonneg\n          ... \u2264 L * abs (1 - 0) : hf 1 0\n          ... = L : by norm_num,\n    have hL_pos : 0 < L := lt_of_le_of_ne hL' (ne_comm.mp hL),\n    use [\u03b5\/L, (div_pos \u03b5_pos hL_pos)],\n    intros x y h,\n    calc  abs (f x - f y) \u2264 L * abs (x - y) : hf x y\n                  ... < L * (\u03b5 \/ L) : mul_lt_mul_of_pos_left h hL_pos\n                  ... = \u03b5 : by { rw [mul_div_assoc', div_eq_iff hL, mul_comm] }\n   }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209336,"user_id":null,"body":"import Preloaded\n\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f :=\nbegin\n  cases hf with L hf,\n  intros \u03b5 h\u03b5,\n  cases classical.em (0 < L) with hL hL,\n  { use \u03b5 \/ L,\n    split,\n    { apply div_pos,\n      { apply h\u03b5 },\n      { apply hL }\n    },\n    intros x y hxy,\n    calc abs (f x - f y) \u2264 L * abs (x - y)\n      : hf x y\n    ... < L * (\u03b5 \/ L)\n      : (mul_lt_mul_left hL).mpr hxy\n    ... = \u03b5\n      : begin\n        rw [mul_div_comm, div_self, mul_one],\n        exact ne_of_gt hL\n      end },\n  { simp at hL,\n    cases classical.em (L = 0) with hL' hL',\n    { rw hL' at hf, simp at hf,\n      use 1,\n      split,\n      { linarith },\n      { intros x y hxy,\n        simp [hf x y],\n        apply h\u03b5 }},\n    { have hL := lt_of_le_of_ne hL hL',\n      apply false.elim,\n      have hf := hf 1 0,\n      simp at hf,\n      have hf : abs (f 1 - f 0) < 0 := by linarith,\n      have hf\u2082 := abs_nonneg (f 1 - f 0),\n      linarith } }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209337,"user_id":106,"body":"import Preloaded\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f :=\nbegin\n  cases hf with L hf, intros \u03b5 h\u03b5,\n  have hL : 0 \u2264 L, {\n    specialize hf 0 1, simp at hf,\n    apply le_trans (abs_nonneg _) hf,\n  },\n  cases eq_or_lt_of_le hL with hL hL, {\n    subst_vars,\n    have heq : \u2200 (x y : \u211d), f x = f y, {\n      intros x y, specialize hf x y,\n      rw zero_mul at hf,\n      have hf' := abs_nonneg (f x - f y),\n      have h := iff.elim_left abs_eq_zero (le_antisymm hf hf'), linarith\n    },\n    existsi [\u03b5, h\u03b5], intros x y _, rw (heq x y), simp, assumption\n  }, {\n    have hL\u03b5 := div_pos h\u03b5 hL,\n    existsi [\u03b5 \/ L, hL\u03b5],\n    intros x y h,\n    specialize hf x y,\n    have h := mul_lt_mul_of_pos_left h hL,\n    have hf := lt_of_le_of_lt hf h,\n    rw [mul_comm, div_mul_cancel _ (ne_of_gt hL)] at hf,\n    assumption\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209338,"user_id":null,"body":"import Preloaded\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\nuniform_continuous f :=\nbegin\n  intros \u03b5 \u03b5pos,\n  cases hf with L h,\n  by_cases hl : L \u2264 0,\n  { use 1, rw and_iff_right zero_lt_one,\n    intros x y h\u2082, specialize h x y, \n    calc abs (f x - f y) \u2264 L * abs (x - y) : h\n      ... \u2264 0 : by { apply mul_nonpos_of_nonpos_of_nonneg hl, exact abs_nonneg _ }\n      ... < \u03b5 : \u03b5pos, },\n  use \u03b5 \/ L, rw not_le at hl,\n  split,\n  { apply mul_pos \u03b5pos, simp only [inv_pos, hl]  },\n  { intros x y h\u2082, \n    calc abs (f x - f y) \u2264 L * abs (x - y) : h x y\n      ... < L * (\u03b5 \/ L) : mul_lt_mul_of_pos_left h\u2082 hl\n      ... = \u03b5 : by { rw mul_div_cancel', linarith, }, }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209339,"user_id":null,"body":"import Preloaded\n\nopen real\n\nlemma neq {x : \u211d} : \u00ac x = 0 \u2194 x \u2260 0 :=\nbegin\n    exact iff.rfl,\nend\n\ntheorem uniform_continuous_of_lipschitz {f} (hf : lipschitz f) :\n  uniform_continuous f := \n  begin\n    intros \u03b5 \u03b5_pos,\n    cases hf with L hL,\n    use (\u03b5 \/ (abs L + 1)),\n    have h\u2081 : 0 < abs L + 1 ,\n      {\n        apply lt_add_of_sub_right_lt,\n        simp,\n        refine lt_of_lt_of_le _ _,\n        exact 0 ,\n        norm_num,\n        exact abs_nonneg L,\n      },\n    split,\n      {\n        exact div_pos \u03b5_pos h\u2081,\n      },\n      {\n        intros x y,\n        specialize hL x y,\n        intro h\u2082,\n        rw lt_div_iff h\u2081 at h\u2082,\n        rw mul_comm at hL,\n        have h\u2083 : abs(x - y) * L \u2264 abs(x - y) * (abs L + 1),\n        {\n          have h\u2084 := classical.em (x = y),\n          cases h\u2084 with heq hneq,\n          {\n            repeat {rw heq},\n            repeat {rw sub_self},\n            simp,\n          },\n          {\n            rw [\u2190 sub_eq_zero, neq, \u2190 abs_pos_iff] at hneq,\n            rw mul_le_mul_left hneq,\n            refine le_trans _ _,\n            exact (abs L),\n            exact le_abs_self L,\n            rw add_comm,\n            apply le_add_of_sub_right_le,\n            rw sub_self,\n            norm_num,\n          },\n        },\n        linarith,\n      },\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ea4167a676dc90033f0b5f3":[{"id":209340,"user_id":null,"body":"import Preloaded\nimport data.nat.log \n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_sum (1 \/ 10) n) 1 :=\nbegin\n  intros \u03b5 h\u03b5,\n  use (1 + nat.clog 10 (nat.ceil \u03b5\u207b\u00b9)),\n  intros n hn,\n  simp only [one_div, geom_sum_eq (show (10 : \u211d)\u207b\u00b9 \u2260 1, by norm_num)],\n  ring_nf,\n  rw [abs_neg, abs_of_pos (pow_pos (show 0 < (10 : \u211d)\u207b\u00b9, by norm_num) n), inv_pow\u2080],\n  suffices : \u03b5\u207b\u00b9 < 10 ^ n, by exact inv_lt_of_inv_lt h\u03b5 this,\n  calc \u03b5\u207b\u00b9 \u2264 nat.ceil \u03b5\u207b\u00b9                    : nat.le_ceil \u03b5\u207b\u00b9\n      ...  \u2264 10 ^ nat.clog 10 (nat.ceil \u03b5\u207b\u00b9) : by {norm_cast, apply nat.le_pow_clog, norm_num }\n      ...  < 10 ^ n                          : pow_lt_pow (by norm_num) (by linarith)\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209341,"user_id":null,"body":"import Preloaded tactic\nimport data.nat.log \n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_sum (1 \/ 10) n) 1 := \nbegin\n  intros \u03b5 h\u03b5,\n  let N  := nat.clog 10 (nat.ceil (2 * \u03b5\u207b\u00b9)),\n  use N,\n  intros n hn,\n  have hs := geom_sum_mul_neg (1\/10 : \u211d) n,\n  norm_num at hs,\n  rw mul_comm at hs,\n  simp at *,  \n  simp [hs],\n  have hpos : (10 ^ n : \u211d)\u207b\u00b9 > 0 := by norm_num, \n  rw [abs_of_pos hpos], rw inv_lt, \n  have h10 : 1 < 10 := by norm_num,\n  have h1 : 10^N \u2264 10^n := nat.pow_le_pow_of_le_right (by linarith) hn,\n  have h2 : nat.ceil (2 * \u03b5\u207b\u00b9) \u2264 10^N := nat.le_pow_clog h10 _,\n  have h3 : 2 * \u03b5\u207b\u00b9 \u2264 nat.ceil (2 * \u03b5\u207b\u00b9) := nat.le_ceil _,\n  calc \u03b5\u207b\u00b9< 2* \u03b5\u207b\u00b9 : by linarith [inv_pos.mpr h\u03b5]\n    ... \u2264 nat.ceil (2 * \u03b5\u207b\u00b9) : by simp [h3]\n    ... \u2264 10^N : by { norm_cast, simp [h2]}\n    ... \u2264 10^n : by { norm_cast, simp [h1]},   \n  norm_num,\n  assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209342,"user_id":17,"body":"import Preloaded\n\n-- Courtesy of @alreadydone\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_sum (1 \/ 10) n) 1 :=\nbegin\n  intros \u03b5 \u03b5pos, cases exists_nat_gt \u03b5\u207b\u00b9 with N hN,\n  use N, intros n h, simp,\n  have lp : n < 10 ^ n, apply nat.lt_pow_self, norm_num,\n  have p : (9\/10:real) = 1 - 10\u207b\u00b9, norm_num,\n  rw [p, mul_comm, geom_sum_mul_neg, sub_right_comm], simp,\n  rw [abs_inv, abs_of_pos, inv_lt],\n  replace lp := lt_of_le_of_lt h lp,\n  have rlp : \u2191N < (10:\u211d)^n, exact_mod_cast lp,\n  exact lt_trans hN rlp, apply pow_pos, norm_num,\n  exact \u03b5pos, apply pow_pos, norm_num,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209343,"user_id":null,"body":"import Preloaded\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\nbegin\n  intros \u03b5 \u03b5pos, cases exists_nat_gt \u03b5\u207b\u00b9 with N hN,\n  use N, intros n h, simp,\n  have lp : n < 10 ^ n, apply nat.lt_pow_self, norm_num,\n  have p : (9\/10:real) = 1 - 10\u207b\u00b9, norm_num,\n  rw [p, mul_comm, geom_sum_mul_neg, sub_right_comm], simp,\n  rw [abs_inv, abs_of_pos, inv_lt],\n  replace lp := lt_of_le_of_lt h lp,\n  have rlp : \u2191N < (10:\u211d)^n, exact_mod_cast lp,\n  exact lt_trans hN rlp, apply pow_pos, norm_num,\n  exact \u03b5pos, apply pow_pos, norm_num,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209344,"user_id":null,"body":"import Preloaded\n\nimport data.rat.floor\nimport analysis.special_functions.exp_log\nimport analysis.special_functions.pow\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\nbegin\n  let p : \u211d := 10\u207b\u00b9,\n  have hp : p = 10\u207b\u00b9 := by refl,\n  simp,\n  have h\u2081 := \u03bb(n : \u2115), calc abs (9 \/ 10 * geom_series 10\u207b\u00b9 n - 1) = abs ((1 - p) * geom_series p n - 1)\n      : begin\n        have h' : 1 - p = 9 \/ 10 := by rw hp; norm_num,\n        rw [hp, h']\n      end\n    ... = abs (1 - p ^ n - 1)\n      : by rw mul_neg_geom_sum\n    ... = p ^ n\n      : begin\n        ring,\n        rw abs_neg,\n        rw abs_of_pos,\n        apply pow_pos,\n        norm_num\n      end,\n\n  intros \u03b5 h\u03b5,\n  cases classical.em (1 \u2264 \u03b5) with h\u03b5\u2082 h\u03b5\u2082,\n  { use 1,\n    intros n hn,\n    simp,\n    rw h\u2081,\n    calc p ^ n < 1\n        : begin\n          rw \u2190real.rpow_nat_cast,\n          apply real.rpow_lt_one,\n          { norm_num },\n          { rw hp, norm_num },\n          { norm_cast,\n            calc 0 < 1\n                : by simp\n              ... \u2264 n\n                : by rw \u2190ge_iff_le; apply hn }\n        end\n      ... \u2264 \u03b5\n        : h\u03b5\u2082 },\n  simp at h\u03b5\u2082,\n  -- let t := - real.log \u03b5 \/ real.log 10,\n  let t := - real.log \u03b5 \/ real.log 10,\n  let N := int.to_nat (floor t) + 1,\n  use N,\n  intros n hn,\n  calc abs (9 \/ 10 * geom_series 10\u207b\u00b9 n - 1) = abs ((1 - p) * geom_series p n - 1)\n      : begin\n        have h' : 1 - p = 9 \/ 10 := by rw hp; norm_num,\n        rw [hp, h']\n      end\n    ... = abs (1 - p ^ n - 1)\n      : by rw mul_neg_geom_sum\n    ... = p ^ n\n      : begin\n        ring,\n        rw abs_neg,\n        rw abs_of_pos,\n        apply pow_pos,\n        norm_num\n      end\n    ... \u2264 p ^ N\n      : begin\n        apply pow_le_pow_of_le_one,\n        { norm_num },\n        { rw hp, norm_num },\n        { rw \u2190ge_iff_le, assumption }\n      end\n    ... < p ^ t\n      : begin\n        rw \u2190real.rpow_nat_cast,\n        apply real.rpow_lt_rpow_of_exponent_gt,\n        { norm_num },\n        { rw hp, norm_num },\n        { simp [N],\n          have h : t < \u230at\u230b + 1 := lt_floor_add_one t,\n          have h\u2081 : 0 < t :=\n          begin\n            simp [t],\n            apply div_pos,\n            { rw [lt_neg, neg_zero],\n              apply real.log_neg h\u03b5 h\u03b5\u2082 },\n            { apply real.log_pos, norm_num },\n          end,\n          have h\u2082 : 0 \u2264 \u230at\u230b :=\n          begin\n            apply iff.elim_right le_floor,\n            simp,\n            apply le_of_lt h\u2081\n          end,\n          have h\u2083 : \u2191(\u230at\u230b.to_nat) = (\u230at\u230b : \u211d) :=\n          begin\n            rw \u2190int.to_nat_of_nonneg h\u2082,\n            norm_cast\n          end,\n          rw h\u2083,\n          exact h }\n      end\n    ... = \u03b5\n      : begin\n        simp [p, t],\n        calc 10\u207b\u00b9 ^ (-real.log \u03b5 \/ real.log 10) = ((10 : \u211d) ^ (-1 : \u211d)) ^ (-real.log \u03b5 \/ real.log 10)\n            : by rw \u2190real.rpow_neg_one 10\n          ... = 10 ^ (real.log \u03b5 \/ real.log 10)\n            : begin\n              rw \u2190real.rpow_mul,\n              { rw neg_div, simp },\n              { norm_num }\n            end\n          ... = \u03b5\n            : begin\n              have h : 0 < (10 : \u211d) := by norm_num,\n              rw real.rpow_def_of_pos h,\n              rw mul_div_comm,\n              have h\u2081 : real.log 10 \u2260 0 :=\n              begin\n                apply ne_of_gt,\n                apply real.log_pos,\n                norm_num\n              end,\n              rw div_self h\u2081,\n              rw mul_one,\n              apply real.exp_log,\n              apply gt_iff_lt.1 h\u03b5\n            end,\n      end\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209345,"user_id":106,"body":"import data.real.basic algebra.geom_sum\nimport Preloaded\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\nbegin\n  intros \u03b5 h\u03b5,\n  have h' : ((9 \/ 10) : \u211d) = 1 - 1 \/ 10, by linarith,\n  simp at *, rw h', clear h',\n  have h\u03b5N: \u2203 N : nat, \u03b5 > (10\u207b\u00b9 : \u211d) ^ N, {\n    have h10' : 1 < (10 : \u211d), by linarith,\n    cases (pow_unbounded_of_one_lt (1 \/ \u03b5) h10') with n hn,\n    existsi n,\n    have h' : (10 : \u211d) ^ n > 0, {\n      apply pow_pos, all_goals { linarith }\n    },\n    rw inv_pow', simp at *,\n    exact iff.elim_left (inv_lt h\u03b5 h') hn,\n  },\n  cases h\u03b5N with N h\u03b5N, existsi N, intros,\n  rw [mul_neg_geom_sum (10\u207b\u00b9 : \u211d) n, sub_sub, add_comm, \u2190sub_sub, sub_self, zero_sub, abs_neg],\n  have h' : (10\u207b\u00b9 : \u211d) ^ n > 0, {\n    field_simp, apply pos_div_pow_pos, all_goals { linarith }\n  },\n  have hr0: 10\u207b\u00b9 > (0 : \u211d), { apply iff.elim_right inv_pos, linarith },\n  have hr1: 10\u207b\u00b9 < (1 : \u211d), { rw inv_eq_one_div, apply iff.elim_right (div_lt_one _), all_goals { linarith } },\n  have h := pow_le_pow_of_le_one (le_of_lt hr0) (le_of_lt hr1) H,\n  rw abs_of_pos h', exact lt_of_le_of_lt h h\u03b5N,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209346,"user_id":null,"body":"import Preloaded\n\nlemma one_add_mul_le_one_add_pow (a n : nat) : n*a + 1 \u2264 (a + 1)^n :=\nbegin\n  induction n with n hn,\n  { simp, },\n  { rw [pow_succ, nat.succ_eq_add_one],\n    calc (n+1) * a + 1  \u2264 (a + 1) * (n * a + 1) : _\n                    ... \u2264 (a + 1) * (a + 1)^n : _,\n    { simp only [add_mul, one_mul, add_assoc, mul_add, mul_one], conv_rhs { rw add_comm },\n      simp only [add_le_add_iff_left, add_assoc], exact nat.le.intro rfl, },\n    { exact nat.mul_le_mul_left _ hn, }, },\nend\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 := \nbegin\n  intros \u03b5 \u03b5_pos,\n  use nat_ceil ((\u03b5\u207b\u00b9 - 1)\/9) + 1, dsimp,\n  intros n hn,\n  have hpos : 0 < (1 : \u211d) - 1\/10, by norm_num,\n  rw \u2190mul_lt_mul_left hpos, conv_lhs { rw [\u2190abs_of_pos hpos, \u2190abs_neg, \u2190abs_mul], },\n  rw show -(1-(1:\u211d)\/10) = (1:\u211d)\/10 -1, by norm_num,\n  rw [mul_sub, mul_left_comm, mul_comm ((1:\u211d)\/10 - 1), geom_sum_mul, mul_one],\n  rw [show (1:\u211d)\/10 -1 = -(9\/10), by norm_num, sub_neg_eq_add],\n  rw show 1 - (1:\u211d)\/10 = 9\/10, by norm_num,\n  rw (show \u2200 a b : \u211d, a * b + a = a * (b+1), from \u03bb a b, by { rw [mul_add, mul_one] }), clear hpos,\n  have hpos : 0 < (9:\u211d)\/10, by norm_num,\n  rw [sub_add_cancel, abs_mul, abs_of_pos hpos, mul_lt_mul_left hpos, abs_of_pos, one_div, inv_pow', inv_lt],\n  calc \u03b5\u207b\u00b9  = ((\u03b5\u207b\u00b9 -1)\/9)*9 + 1 : by ring\n        ... \u2264 (nat_ceil ((\u03b5\u207b\u00b9 - 1)\/9))*9 + 1 : _\n        ... < n*9 + 1 : _\n        ... \u2264 10 ^ n : _,\n  { rw [add_le_add_iff_right, mul_le_mul_right], apply le_nat_ceil _, norm_num },\n  { norm_cast, linarith, },\n  { exact_mod_cast one_add_mul_le_one_add_pow _ _, }, \n  { apply pow_pos, norm_num, },\n  { exact \u03b5_pos, },\n  { apply pow_pos, norm_num, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209347,"user_id":null,"body":"import Preloaded\n\ntheorem zero_point_nine_recurring_is_one :\nlim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 \n:=\n  assume \u03b5 \u03b5_pos,\n  let \u27e8N, hN\u27e9 := exists_nat_one_div_lt \u03b5_pos in \n  exists.intro (N + 1) ( \n    assume n hn,\n    have (n: \u211d) < 10^n, by apply_mod_cast (nat.lt_pow_self (show 1 < 10, from nat.lt_of_sub_eq_succ rfl) n),\n    calc abs ((9:\u211d)\/10 *  geom_series (1 \/ 10) n- 1) \n          = abs ((1:\u211d) - 9\/10 * geom_series (1 \/ 10) n)       : by rw abs_sub\n      ... = abs ((1:\u211d) - geom_series (1 \/ 10) n * (1 - 1\/10)) : by rw [(show (9:\u211d)\/10 = 1 - 1\/10, by ring), mul_comm]\n      ... = abs ((1:\u211d) - (1 - (1\/10)^n))                      : by rw geom_sum_mul_neg\n      ... = abs ((1\/10)^n)                                    : by ring \n      ... = (1\/10)^n                                          : by rw (abs_of_nonneg (show 0 \u2264 ((1:\u211d)\/10)^n, from pow_nonneg (by linarith) n))\n      ... = 1\/(10^n)                                          : by simp [div_pow]\n      ... < 1\/n                                               : (one_div_lt_one_div (pow_pos (show 0 < (10:\u211d), by linarith) n) (by apply_mod_cast (show 0 < n, by linarith))).mpr this         \n      ... \u2264 1\/(N+1)                                           : (one_div_le_one_div (show 0 < (n:\u211d), by apply_mod_cast (show 0 < n, by linarith)) (show 0 < (N:\u211d) + 1, by apply_mod_cast (show 0 < N + 1, by linarith))).mpr (by apply_mod_cast hn)\n      ... < \u03b5                                                 : by apply_mod_cast hN)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209348,"user_id":null,"body":"import Preloaded\n\nopen finset\nopen_locale big_operators\n\n\ntheorem zero_point_nine_recurring_is_one :\nlim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 \n:=\n  assume \u03b5 \u03b5_pos,\n  have H : \u2200 n, (1:\u211d) - 9\/10 * \u2211 i in range n, (1\/10)^i = (1\/10)^n, from \n    assume n,\n    nat.rec_on n \n    (by {rw [finset.sum_range_zero], simp})\n    (assume n hn, \n      calc (1:\u211d) - 9\/10 * \u2211 i in range (n+1), (1\/10)^i        \n            = 1 - 9\/10 * ((1\/10)^n + \u2211 i in range n, (1\/10)^i)    : by rw sum_range_succ \n        ... = 1 - 9\/10 *\u2211 i in range n, (1\/10)^i - 9\/10*(1\/10)^n  : by ring\n        ... = (1\/10)^n - 9\/10*(1\/10)^n                            : by rw hn\n        ... = (1\/10)^n*(1 - 9\/10)                                 : by ring \n        ... = (1\/10)^n*(1\/10)                                     : by ring\n        ... = (1\/10)^(n+1)                                        : by rw pow_succ'),\n\n  let \u27e8N, hN\u27e9 := exists_nat_one_div_lt \u03b5_pos in \n  exists.intro (N + 1) ( \n    assume n hn,\n    have (n: \u211d) < 10^n, by apply_mod_cast (nat.lt_pow_self (show 1 < 10, from nat.lt_of_sub_eq_succ rfl) n),\n    calc abs ((9:\u211d)\/10 * \u2211 i in range n, (1\/10)^i - 1) = \n          abs ((1:\u211d) - 9\/10 * \u2211 i in range n, (1\/10)^i) : by rw abs_sub\n      ... = abs ((1\/10)^n)                              : by rw H n \n      ... = (1\/10)^n                                    : by rw (abs_of_nonneg (show 0 \u2264 ((1:\u211d)\/10)^n, from pow_nonneg (by linarith) n))\n      ... = 1\/(10^n)                                    : by simp [div_pow]\n      ... < 1\/n                                         : (one_div_lt_one_div (show 0 < (10:\u211d)^n, from pow_pos (show 0 < (10:\u211d), by linarith) n) (show 0 < (n:\u211d), by apply_mod_cast (show 0 < n, by linarith))).mpr this         \n      ... \u2264 1\/(N+1)                                     : (one_div_le_one_div (show 0 < (n:\u211d), by apply_mod_cast (show 0 < n, by linarith)) (show 0 < (N:\u211d) + 1, by apply_mod_cast (show 0 < N + 1, by linarith))).mpr (by apply_mod_cast hn)\n      ... < \u03b5                                           : by apply_mod_cast hN)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209349,"user_id":191,"body":"import Preloaded\n\nlemma pos_ten_pow {n : \u2115} : 0 < (10 : \u211d) ^ n :=\nbegin\n  induction n with n hn,\n  rw pow_zero,\n  exact zero_lt_one,\n  rw pow_succ,\n  rw zero_lt_mul_left,\n  exact hn,\n  norm_num\nend\n\nlemma one_le_ten_pow {n : \u2115} : 1 \u2264 10 ^ n :=\nbegin\n  induction n with n hn,\n  rw pow_zero,\n  rw pow_succ,\n  rw \u2190 mul_one 1,\n  apply mul_le_mul,\n  norm_num,\n  rw mul_one,\n  exact hn,\n  exact zero_le_one,\n  norm_num,\nend\n\nlemma le_ten_pow {n : \u2115} : n < 10 ^ n :=\nbegin\n  induction n with n hn,\n  rw pow_zero,\n  exact zero_lt_one,\n  rw pow_succ,\n  rw nat.succ_eq_add_one,\n  have h1 : n + 1 < 10 ^ n + 1 := (add_lt_add_iff_right 1).mpr hn,\n  have h2 : 10 ^ n + 1 \u2264 10 ^ n + 10 ^ n,\n    apply add_le_add _,\n    exact one_le_ten_pow,\n    refl,\n  have h3 : 10 ^ n + 10 ^ n = 2 * 10 ^ n,\n    exact (two_mul (10 ^ n)).symm,\n  have h4 : 2 * 10 ^ n < 10 * 10 ^ n,\n    apply mul_lt_mul,\n    norm_num,\n    refl,\n    apply pow_pos,\n    norm_num,\n    norm_num,\n  calc n + 1 < 10 ^ n + 1 : h1\n         ... \u2264 10 ^ n + 10 ^ n : h2\n         ... = 2 * 10 ^ n : h3\n         ... < 10 * 10 ^ n : h4\nend\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\nbegin\n  rintro \u03b5 h\u03b5,\n  cases exists_nat_gt (\u03b5\u207b\u00b9) with N hN,\n  use N,\n  intros n hn,\n  dsimp,\n  rw geom_sum,\n  { field_simp,\n    ring,\n    simp,\n    rw abs_inv,\n    rw inv_lt,\n    { rw abs_of_pos,\n      { have h\u03b5n : \u03b5\u207b\u00b9 < n := lt_of_lt_of_le hN (nat.cast_le.mpr hn),\n        apply lt_trans h\u03b5n,\n        exact_mod_cast le_ten_pow },\n      { exact pos_ten_pow }},\n    { apply abs_pos_of_pos,\n      exact pos_ten_pow },\n    { exact h\u03b5 }},\n  { norm_num }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209350,"user_id":null,"body":"import Preloaded\n\nopen real nat\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\n  begin\n    \n    intros \u03b5 \u03b5_pos,\n    have h\u2081 : (\u2203 (n : \u2115), \u03b5\u207b\u00b9 < 10 ^ n), apply pow_unbounded_of_one_lt (\u03b5\u207b\u00b9), norm_num,\n    cases h\u2081 with N h_N,\n    use N,\n    intros n h\u2099,\n    simp,\n    rw geom_sum,\n    norm_num,\n    rw div_neg,\n    simp,\n    rw [div_div_eq_mul_div, mul_comm, mul_div_assoc, mul_assoc],\n    norm_num,\n    rw [\u2190 sub_add_eq_sub_sub_swap,sub_eq_add_neg, neg_add],\n    simp,\n    have h_pos : (10 : \u211d) ^ n \u2265 0, apply pow_nonneg, norm_num,\n    rw [abs_inv, inv_lt _ _, abs_of_nonneg h_pos],\n    have h\u2082 : (10 : \u211d)^N \u2264 (10 : \u211d)^n, apply pow_le_pow, norm_num, assumption,\n    apply lt_of_lt_of_le h_N h\u2082,\n    rw abs_of_nonneg h_pos,\n    apply pow_pos,\n    norm_num,\n    assumption,\n    norm_num,\n    \n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209351,"user_id":null,"body":"import Preloaded\n\nlemma pow_n_ge_n (n m : \u2115) : 2 \u2264 m \u2192 n \u2264 m^n :=\nbegin\n  intro h,\n  induction n with n hn,\n  { exact bot_le, },\n  { rw nat.succ_eq_add_one,\n    have : 1 \u2264 m^n,\n    { cases n,\n      { ring, },\n      { calc 1 \u2264 nat.succ n : inf_eq_left.mp rfl\n        ... \u2264 m^nat.succ n : hn,\n      },\n    },\n    calc n + 1 \u2264 m^n + 1 : by linarith\n    ... \u2264 m^n + m^n : by linarith\n    ... = 2*(m^n) : by ring\n    ... \u2264 m*(m^n) : nat.mul_le_mul_right (m ^ n) h\n    ... = m^(n + 1) : by ring,\n  },\nend\n\nlemma pow_n_le_one_div_n (n m : \u2115) : 0 < n \u2192 2 \u2264 m \u2192 ((1\/m)^n : \u211d) \u2264 (1\/n : \u211d) :=\nbegin\n  intros hn hm,\n  suffices key : (n : \u211d) \u2264 (m : \u211d)^n,\n  { suffices : ((m : \u211d) ^ n)\u207b\u00b9 \u2264 (n : \u211d)\u207b\u00b9,\n    { simp [this], },\n    { have hn' : (n : \u211d) > 0,\n      { norm_cast,\n        exact hn,\n      },\n      have hm' : (m^n : \u211d) > 0,\n      { exact lt_of_lt_of_le hn' key, },\n      exact inv_le_inv_of_le hn' key,\n    },\n  },\n  { norm_cast,\n    exact pow_n_ge_n n m hm,\n  }\nend\n\ntheorem zero_point_nine_recurring_is_one :\nlim_to_inf (\u03bb n, (9 \/ 10) * geom_series (1 \/ 10) n) 1 :=\n  begin\n    intros \u03b5 h\u03b5,\n    have one_div_eps_pos : 1\/\u03b5 > 0 := by exact one_div_pos_of_pos h\u03b5,\n    cases exists_nat_gt (1\/\u03b5) with N hN,\n    have N_pos : 0 < (\u2191N : \u211d) := lt.trans one_div_eps_pos hN,\n    use N,\n    intros n hn,\n    have n_pos : 0 < (\u2191n : \u211d),\n    { calc 0 < \u2191N : N_pos\n      ... \u2264 (\u2191n : \u211d) : nat.cast_le.mpr hn,\n    },\n    dsimp,\n    rw abs_sub_lt_iff,\n    rw geom_sum,\n    split,\n    { have : -((1\/10)^n : \u211d) < 0,\n      { norm_num,\n        exact pow_pos (by linarith) n,\n      },\n      calc 9 \/ 10 * (((1 \/ 10) ^ n - 1) \/ (1 \/ 10 - 1)) - 1 = -((1\/10)^n : \u211d) : by ring; norm_num\n      ... < \u03b5 : by linarith,\n    },\n    { calc 1 - (9 \/ 10) * (((1 \/ 10) ^ n - 1) \/ ((1 \/ 10) - 1)) = ((1\/\u219110)^n : \u211d) : by ring; norm_num\n        ... \u2264 (1\/n : \u211d) : pow_n_le_one_div_n n 10 (by finish) (by linarith)\n        ... \u2264  1\/(N : \u211d) : one_div_le_one_div_of_le N_pos (nat.cast_le.mpr hn)\n        ... < \u03b5 : (one_div_lt h\u03b5 N_pos).mp hN,\n    },\n    { intro h, \n      linarith, \n    },\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209352,"user_id":644,"body":"import Preloaded\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\n\u03bb \u03b5 \u03b50, let \u27e8N, hN\u27e9 := pow_unbounded_of_one_lt (\u03b5\u207b\u00b9) (show (1 : \u211d) < 10, by norm_num) in \n\u27e8N, \u03bb n hn, \nhave h10 : (1 : \u211d) \/ 10 \u2260 1, by norm_num,\nhave h\u03b5 : (1 \/ 10)^n < \u03b5, \n  from lt_of_le_of_lt (pow_le_pow_of_le_one (by norm_num) (by norm_num) hn) \n    (lt_of_one_div_lt_one_div \u03b50 $\n      by rwa [one_div_eq_inv, div_pow, one_pow, \n        one_div_eq_inv, one_div_eq_inv, inv_inv']; norm_num),\nhave hnn : 0 \u2264 (1 \/ 10 : \u211d)^n, from pow_nonneg (by norm_num) _,\nhave (1 \/ 10 - 1 : \u211d) = -(9 \/ 10), by norm_num,\nbegin\n  dsimp only,\n  rw [geom_sum h10, this, div_neg, mul_neg_eq_neg_mul_symm, \n    mul_div_cancel', abs_of_nonpos];\n  linarith,\nend\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209353,"user_id":659,"body":"import Preloaded\n\nlemma nat.one_le_iff_succ (a : \u2115) : 1 \u2264 a \u2194 \u2203 t, a = nat.succ t :=\nbegin\n  split,\n  { intro h, cases a with a, cases h, use a},\n  { rintro \u27e8t, rfl\u27e9, apply nat.succ_le_succ, exact zero_le t}\nend\n\nlemma nat.one_le_mul {a b : \u2115} (ha : 1 \u2264 a) (hb : 1 \u2264 b) : 1 \u2264 a * b :=\nbegin\n  rw nat.one_le_iff_succ at ha hb \u22a2,\n  rcases hb with \u27e8c, rfl\u27e9,\n  rcases ha with \u27e8d, rfl\u27e9,\n  use d*c+d+c,\n  ring\nend\n\nlemma nat.one_le_pow {a b : \u2115} (ha : 1 \u2264 a) : 1 \u2264 a ^ b :=\nbegin\n  induction b with c hc,\n    refl,\n  rw nat.pow_succ,\n  apply nat.one_le_mul hc ha,\nend\n\nlemma dumblemma (n : \u2115) : n \u2264 10^n :=\nbegin\n  induction n with m hm,\n    exact dec_trivial,\n  rw nat.pow_succ,\n  conv begin\n    to_rhs,\n    congr, skip,\n    rw (show 10 = 1 + 9, by norm_num),\n  end,\n  rw [mul_add, mul_one, nat.succ_eq_add_one],\n  apply add_le_add hm,\n  refine nat.one_le_mul _ (by norm_num),\n  exact nat.one_le_pow (by norm_num),\nend\n\n-- not proud of this one :-\/\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\nbegin\n  intros \u03b5 h\u03b5,\n  cases exists_nat_one_div_lt h\u03b5 with m hm,\n  use (m + 1),\n  intros n hn,\n  dsimp,\n  rw [geom_sum (show (1 : \u211d) \/ 10 \u2260 1, by norm_num), abs_lt],\n  split,\n  { field_simp,\n    rw [sub_mul, div_mul_cancel, one_mul, show (1 : \u211d) - 10 = -9, by norm_num,\n        div_neg, mul_div_cancel_left],\n    suffices : 1 \/ 10 ^ n < \u03b5, linarith,\n    apply lt_of_le_of_lt _ hm,\n    apply one_div_le_one_div_of_le,\n    norm_cast, apply nat.zero_lt_succ,\n    norm_cast, apply le_trans hn (dumblemma n),\n    norm_num, norm_num\n  },\n    { field_simp,\n    rw [sub_mul, div_mul_cancel, one_mul, show (1 : \u211d) - 10 = -9, by norm_num,\n        div_neg, mul_div_cancel_left],\n    suffices : -(1 \/ 10 ^ n) < \u03b5, linarith,\n    apply lt_trans _ h\u03b5,\n    rw neg_neg_iff_pos,\n    apply div_pos, exact zero_lt_one,\n    apply pow_pos,\n    all_goals {linarith},\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209354,"user_id":196,"body":"import Preloaded\n\nlemma lt_ten_pow (n : \u2115) : (n : \u211d) < 10 ^ n :=\nby exact_mod_cast (@nat.cast_lt \u211d _ _ _).2 (nat.lt_pow_self (show 1 < 10, by norm_num) n)\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\n\u03bb \u03b5 h\u03b5, \u27e8nat_ceil (1\/\u03b5) + 1, \u03bb n hn,\nhave h1 : (9 \/ 10 : \u211d) = 1 - 1 \/ 10, by rw sub_div' (1:\u211d) _ _ (ne_of_gt _); norm_num,\nhave h2 : 0 < ((1 \/ 10) ^ n : \u211d), from pow_pos (one_div_pos_of_pos $ by norm_num) _,\ncalc  abs (9 \/ 10 * geom_series (1 \/ 10) n - 1)\n    = 1 \/ 10 ^ n : by rw [mul_comm, h1, geom_sum_mul_neg, sub_right_comm, sub_self, zero_sub, abs_neg, abs_of_pos h2, one_div_pow]\n... < (1 \/ n : \u211d) : one_div_lt_one_div_of_lt (nat.cast_pos.2 $ le_trans (nat.le_add_left _ _) hn) (lt_ten_pow n)\n... \u2264 \u03b5 : one_div_le_of_one_div_le_of_pos h\u03b5 $ nat_ceil_le.1 $ nat.le_of_succ_le hn\u27e9\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209355,"user_id":168,"body":"import Preloaded\n\ntheorem zero_point_nine_recurring_is_one :\n  lim_to_inf (\u03bb n, 9 \/ 10 * geom_series (1 \/ 10) n) 1 :=\nbegin\n  intros e he,\n  have h1 : (1 : \u211d) < 10 := by norm_num,\n  obtain \u27e8N, hN\u27e9 := pow_unbounded_of_one_lt (1 \/ e) h1,\n  existsi N, intros n hn, simp only [],\n  rw [abs_sub, (by norm_num : (9 : \u211d) \/ 10 = 1 - 1 \/ 10), mul_comm, geom_sum_mul_neg],\n  rw [sub_sub_self, div_pow, one_pow, abs_div, abs_one],\n  have h2 : (0 : \u211d) < 10^n := pow_pos (by norm_num) n,\n  rw [abs_of_pos h2, one_div_lt h2 he],\n  apply lt_of_lt_of_le hN, \n  rw [\u2190fpow_of_nat, \u2190fpow_of_nat],\n  apply fpow_le_of_le (le_of_lt h1),\n  norm_cast, exact hn,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ea8056e449f540001a2dab2":[{"id":209356,"user_id":null,"body":"import group_theory.subgroup.basic\n\nuniverse u\n\ntheorem ne_union_of_proper {G : Type u} [group G] (S K : subgroup G) (hS : S < \u22a4) (hK : K < \u22a4) :\n  (S : set G) \u222a K \u2260 \u22a4 :=\nbegin\n  replace hS : \u2203 (g : G), g \u2209 S := by simpa [set.subset_def] using hS.right,\n  replace hK : \u2203 (g : G), g \u2209 K := by simpa [set.subset_def] using hK.right,\n\n  assume hunion,\n  replace hunion : \u2200 (g : G), g \u2208 S \u2228 g \u2208 K := by simpa [set.ext_iff] using hunion,\n\n  have h1 : \u2203 (g : G), g \u2208 S \u2227 g \u2209 K := by {\n    apply not_not.mp,\n    simp only [not_exists, not_and_distrib, not_not],\n    by_contra h,\n    have : \u2200 (g : G), g \u2208 K := \u03bb g,\n      or.elim (h g) (\u03bb h, or_iff_not_imp_left.mp (hunion g) h) id,\n    exact not_forall.mpr hK this,\n  },\n  have h2 : \u2203 (g : G), g \u2208 K \u2227 g \u2209 S := by {\n    apply not_not.mp,\n    simp only [not_exists, not_and_distrib, not_not],\n    by_contra h,\n    have : \u2200 (g : G), g \u2208 S := \u03bb g,\n      or.elim (h g) (\u03bb h, or_iff_not_imp_right.mp (hunion g) h) id,\n    exact not_forall.mpr hS this\n  },\n\n  suffices h3 : \u2203 (g : G), g \u2209 S \u2227 g \u2209 K,\n  simp_rw [\u2190not_or_distrib, \u2190not_forall] at h3,\n  exact absurd hunion h3,\n\n  use h1.some * h2.some,\n  split,\n  exact \u03bb h, absurd\n    ((subgroup.mul_mem_cancel_left _ h1.some_spec.left).mp h)\n    h2.some_spec.right,\n  exact \u03bb h, absurd\n    ((subgroup.mul_mem_cancel_right _ h2.some_spec.left).mp h)\n    h1.some_spec.right,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209357,"user_id":null,"body":"import group_theory.subgroup.basic tactic\n\nuniverse u\n\ntheorem ne_union_of_proper {G : Type u} [group G] (S K : subgroup G) (hS : S < \u22a4) (hK : K < \u22a4) :\n  (S : set G) \u222a K \u2260 \u22a4 :=\n\nbegin\n  by_contra,\n  cases hS with hs1 hs2,\n  cases hK with hk1 hk2,\n  have h1 : \u2203 x, x \u2209 S,\n  {\n    by_contra,\n    push_neg at h,\n    apply hs2,\n    intros x hx,\n    apply h x,\n  },\n  cases h1 with x hx1,\n  have hx2 : x \u2208 (K:set G),\n  {\n    by_contra hh,\n    have : x \u2209 (S:set G) \u222a K := by tidy,\n    rw h at this,\n    apply this,\n    triv,\n  },\n  have h2 : \u2203 x : G, \u00ac x \u2208 K,\n  {\n    by_contra,\n    push_neg at h,\n    apply hk2,\n    intros x _,\n    exact h x,\n  },\n  cases h2 with y hy1,\n  have hy2 : y \u2208 (S: set G),\n  {\n    by_contra hh,\n    have : y \u2209 (S:set G) \u222a K := by tidy,\n    rw h at this,\n    apply this,\n    triv,\n  },\n  have : x*y \u2208 (S: set G) \u222a K,\n  {\n    rw h, exact trivial,\n  },\n  cases this,\n  {\n    have : x*y*y\u207b\u00b9 \u2208 (S:set G),\n    {\n      exact S.mul_mem this (S.inv_mem' hy2),\n    },\n    simp only [mul_inv_cancel_right, set_like.mem_coe] at this,\n    exact hx1 this,\n  },\n  {\n    have : x\u207b\u00b9*(x*y) \u2208 (K:set G),\n    {\n      exact K.mul_mem (K.inv_mem' hx2) this,\n    },\n    simp only [inv_mul_cancel_left, set_like.mem_coe] at this,\n    exact hy1 this,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209358,"user_id":null,"body":"import group_theory.subgroup.basic\n\nuniverse u\n\ntheorem ne_union_of_proper {G : Type u} [group G] (S K : subgroup G) (hS : S < \u22a4) (hK : K < \u22a4) :\n  (S : set G) \u222a K \u2260 \u22a4 :=\nbegin\n  cases hS with ST nTS,\n  cases hK with KT nTK,\n  simp only [subgroup.coe_top, set.le_eq_subset, set.not_subset_iff_exists_mem_not_mem] at nTS nTK,\n  rcases nTS with \u27e8x, \u27e8hx, x_not_in_S\u27e9\u27e9,\n  rcases nTK with \u27e8y, \u27e8hy, y_not_in_K\u27e9\u27e9,\n  intro SUK_eq_T,\n  cases (set.ext_iff.1 SUK_eq_T (x * y)).2 (subgroup.mem_top (x * y)),\n  { have xy_in_subgp := subgroup.mem_carrier.1 h,\n    rw subgroup.mul_mem_cancel_right at xy_in_subgp,\n    swap,\n    cases (set.ext_iff.1 SUK_eq_T y).2 (subgroup.mem_top y),\n    repeat {tauto}, },\n  { have xy_in_subgp := subgroup.mem_carrier.1 h,\n    rw subgroup.mul_mem_cancel_left at xy_in_subgp,\n    swap,\n    cases (set.ext_iff.1 SUK_eq_T x).2 (subgroup.mem_top x),\n    repeat {tauto}, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209359,"user_id":null,"body":"import group_theory.subgroup.basic\n\nuniverse u\n\ntheorem ne_union_of_proper {G : Type u} [group G] (S K : subgroup G) (hS : S < \u22a4) (hK : K < \u22a4) :\n  (S : set G) \u222a K \u2260 \u22a4 :=\nbegin\n  intros hKS,\n  have hm : \u2200x, x \u2208 \u2191S \u2228 x \u2208 \u2191K,\n    intros x,    \n    rw [\u2190set.mem_union, hKS, set.top_eq_univ], \n    exact set.mem_univ x, \n\n  have hnK : \u2203k, \u00ac k \u2208 (K : set G),\n    by_contradiction hc,\n    push_neg at hc,\n    apply hK.2,\n    intros x hx,\n    exact hc x,\n  cases hnK with s hsK,\n  cases hm s with hsS; try {contradiction},\n\n  have hnS : \u2203s, \u00ac s \u2208 (S : set G),\n    by_contradiction hc,\n    push_neg at hc,\n    apply hS.2,\n    intros x hx,\n    exact hc x,\n  cases hnS with k hkS,\n  cases hm k with _ hkK; try {contradiction},\n\n  cases hm (k * s) with h5 h6,\n  { apply hkS,\n    exact (subgroup.mul_mem_cancel_right S hsS).mp h5 },\n  { apply hsK,\n    exact (subgroup.mul_mem_cancel_left K hkK).mp h6 },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209360,"user_id":196,"body":"import tactic group_theory.subgroup.basic\n\nuniverse u\n\ntheorem ne_union_of_proper {G : Type u} [group G] (S K : subgroup G) (hS : S < \u22a4) (hK : K < \u22a4) :\n  (S : set G) \u222a K \u2260 \u22a4 :=\nbegin\n  intro h, simp [set.ext_iff] at h,\n  obtain \u27e8x, _, hxs\u27e9 := set_like.exists_of_lt hS,\n  obtain \u27e8y, _, hyk\u27e9 := set_like.exists_of_lt hK,\n  cases h (x * y) with hs hk,\n  { exact hxs ((subgroup.mul_mem_cancel_right S $ (h y).resolve_right hyk).1 hs) },\n  { exact hyk ((subgroup.mul_mem_cancel_left K $ (h x).resolve_left hxs).1 hk) }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209361,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup deprecated.subgroup\nnoncomputable theory\nopen_locale classical\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\n  begin\n      by_contradiction h,\n      rw not_or_distrib at h,\n      cases h with hS hT,\n      rw not_forall at *,\n      cases hS with s hsG hnsS,\n      cases hT with t htG hntT,\n      have hst := HST (t * s),\n      cases hst with inS inT,\n      apply hsG,\n      have : t \u2208 S, finish,\n      rw is_subgroup.mul_mem_cancel_left S this at inS,\n      assumption,\n      apply htG,\n      have : s \u2208 T, finish,\n      rw is_subgroup.mul_mem_cancel_right T this at inT,\n      assumption,\n  end\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209362,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup deprecated.subgroup\n\nnoncomputable theory\nopen_locale classical\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  by_contradiction this,\n  push_neg at this,\n  obtain \u27e8\u27e8s, hsnS\u27e9, \u27e8t, htnT\u27e9\u27e9 := this,\n  have hsT := or.resolve_left (HST s) hsnS,\n  have htS := or.resolve_right (HST t) htnT,\n  specialize HST (s * t), cases HST,\n  exact hsnS ((is_subgroup.mul_mem_cancel_right S htS).mp HST),\n  exact htnT ((is_subgroup.mul_mem_cancel_left T hsT).mp HST)\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209363,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup deprecated.subgroup\nlocal attribute [instance] classical.prop_decidable\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  by_contradiction h,\n  push_neg at h,\n  rcases h with \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9,\n  cases HST (x * y) with h,\n  {\n    have := HST y,\n    have y_in : y \u2208 S, by cc,\n    apply hx,\n    exact (is_subgroup.mul_mem_cancel_right S y_in).mp h,\n  },\n  {\n    have := HST x,\n    have x_in : x \u2208 T, by cc,\n    apply hy,\n    exact (is_subgroup.mul_mem_cancel_left T x_in).mp h,\n  },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209364,"user_id":106,"body":"import Preloaded tactic group_theory.subgroup deprecated.subgroup\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  apply of_not_not, intro Ha,\n  have Ha := (iff.elim_left not_or_distrib) Ha,\n  cases Ha with Hs Ht, clear Ha,\n  cases iff.elim_left not_forall Hs with a HaS, clear Hs,\n  cases iff.elim_left not_forall Ht with b HbT, clear Ht,\n  have HaT : a \u2208 T, by exact (iff.elim_left or_iff_not_imp_left) (HST a) HaS,\n  have HbS : b \u2208 S, by exact (iff.elim_left or_iff_not_imp_right) (HST b) HbT,\n  have HabS : a * b \u2209 S, {\n    intro HabS,\n    have HabS := is_submonoid.mul_mem HabS (is_subgroup.inv_mem HbS),\n    rw mul_inv_cancel_right at HabS, contradiction\n  },\n  have HabT : a * b \u2209 T, {\n    intro HabT,\n    have HabT := is_submonoid.mul_mem (is_subgroup.inv_mem HaT) HabT,\n    rw inv_mul_cancel_left at HabT, contradiction\n  },\n  apply (iff.elim_right not_not) HST,\n  apply iff.elim_right not_forall,\n  existsi a * b,\n  apply iff.elim_right not_or_distrib,\n  split; assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209365,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\n\nopen is_subgroup is_submonoid\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [sgS: is_subgroup S] [sgT: is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  cases classical.em (\u2203x:G, x\u2209S),\n  cases h with t tnS, right,\n  intro x, cases HST x,\n  have tT := or.resolve_left (HST t) tnS,\n  have xtiT := or.resolve_left (HST (x*t\u207b\u00b9)) _,\n  rw \u2190 inv_mul_cancel_right x t,\n  exact mul_mem xtiT tT,\n  intro xtiS, apply tnS,\n  rw [\u2190inv_mem_iff S, \u2190mul_mem_cancel_right S],\n  exact xtiS, exact h, exact h,\n  left, push_neg at h, exact h,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209366,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  -- Suppose S and T were proper subgroups: then there is some t \u2209 S and some s \u2209 T.\n  classical, by_contradiction h, push_neg at h,\n  rcases h with \u27e8\u27e8t, htns\u27e9, \u27e8s, hsnt\u27e9\u27e9,\n  -- By the premise HST, s \u2208 S and t \u2208 T.\n  have hss : s \u2208 S := (HST s).resolve_right hsnt,\n  have htt : t \u2208 T := (HST t).resolve_left htns,\n  -- Now consider st. Either it's in S or it's in T.\n  cases HST (s * t) with hstS hstT,\n  { -- If it's in S, then we can show s\u207b\u00b9st = t \u2208 S, a contradiction:\n    have hc: s\u207b\u00b9 * (s * t) \u2208 S := is_submonoid.mul_mem (is_subgroup.inv_mem hss) hstS,\n    rw [\u2190mul_assoc, mul_left_inv s, one_mul] at hc,\n    contradiction },\n  { -- Otherwise we can show stt\u207b\u00b9 = s \u2208 T, a contradiction.\n    have hc : (s * t) * t\u207b\u00b9 \u2208 T := is_submonoid.mul_mem hstT (is_subgroup.inv_mem htt),\n    rw [mul_assoc, mul_right_inv t, mul_one] at hc,\n    contradiction },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209367,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) := by\n{\n    classical, unfreezeI,\n    \n    by_contra h,\n    push_neg at h,\n    rcases h with \u27e8\u27e8ns, hns\u27e9, \u27e8nt, hnt\u27e9\u27e9,\n    -- where ns is an element of G not in S and nt is an element of G not in T\n    \n    cases HST (ns*nt) with hs ht,\n    \n        -- Proving that (ns*nt) being in S leads to a contradiction\n        \n        cases _inst_2, cases _to_is_submonoid,\n        replace hnt := or_iff_not_imp_right.1 (HST nt) hnt,\n        have hnti := inv_mem hnt,\n        have hw := mul_mem hs hnti,\n        rw [mul_assoc, mul_inv_self, mul_one] at hw,\n        contradiction,\n    \n    -- Proving that (ns*nt) being in T leads to a contradiction\n    \n    cases _inst_3, cases _to_is_submonoid,\n    replace hns := or_iff_not_imp_left.1 (HST ns) hns,\n    have hnsi := inv_mem hns,\n    have hw := mul_mem hnsi ht,\n    rw [\u2190mul_assoc, inv_mul_self, one_mul] at hw,\n    contradiction,\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209368,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\nnoncomputable theory\nopen_locale classical\n\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n    revert HST,\n    contrapose!,\n    rintros \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9,\n    by_cases hx' : x \u2208 T,\n    by_cases hy' : y \u2208 S,\n    { use x*y,\n      split,\n      { intro hxy,\n        have : x \u2208 S := (is_subgroup.mul_mem_cancel_left S hy').mp hxy,\n        exact hx this,\n      },\n      { intro hxy,\n        have : y \u2208 T := (is_subgroup.mul_mem_cancel_right T hx').mp hxy,\n        exact hy this,\n      },\n    },\n    { exact \u27e8y, hy', hy\u27e9, },\n    { exact \u27e8x, hx, hx'\u27e9, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209369,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\nimport tactic\n\nopen_locale classical\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\nby_contradiction,\npush_neg at a,\nrcases a with \u27e8\u27e8x, xh\u27e9, \u27e8y, yh\u27e9\u27e9,\nby_cases (x * y \u2208 S),\nhave w := or.resolve_right (HST y) yh,\nexact xh ((is_subgroup.mul_mem_cancel_left S w).mp h),\nhave z := or.resolve_left (HST (x*y)) h,\nhave w := or.resolve_left (HST x) xh,\nexact yh ((is_subgroup.mul_mem_cancel_right T w).mp z),\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209370,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  classical,\n  by_contradiction h,\n  push_neg at h,\n  obtain \u27e8\u27e8s, hs\u27e9, \u27e8t, ht\u27e9\u27e9 := h,\n  have st : s \u2208 T := (HST s).resolve_left hs,\n  have ts : t \u2208 S := (HST t).resolve_right ht,\n  have : s * t \u2209 S := \u03bb H, hs ((is_subgroup.mul_mem_cancel_left S ts).mp H),\n  have : s * t \u2209 T := \u03bb H, ht ((is_subgroup.mul_mem_cancel_right T st).mp H),\n  cases HST (s * t); contradiction\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209371,"user_id":644,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\nopen_locale classical\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nor_iff_not_imp_left.2 $ \u03bb h, let \u27e8x, hxS\u27e9 := classical.not_forall.1 h in\n\u03bb y, (HST (x * y)).elim\n  (\u03bb hxyS, (HST y).resolve_left \n    (\u03bb hyS, hxS ((is_subgroup.mul_mem_cancel_left _ hyS).1 hxyS)))\n  (is_subgroup.mul_mem_cancel_right _ ((HST x).resolve_left hxS)).1\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209372,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\nopen_locale classical\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  rw classical.or_iff_not_imp_left,\n  intro,\n  push_neg at a,\n  obtain \u27e8s,hs\u27e9 := a,\n  intro t,\n  by_contra ht,\n  have hsT := classical.or_iff_not_imp_left.mp (HST s) hs,\n  have htS := classical.or_iff_not_imp_right.mp (HST t) ht,\n  cases HST (s*t),\n  {\n    apply hs,\n    exact (is_subgroup.mul_mem_cancel_left S htS).mp h,\n  },\n  {\n    apply ht,\n    exact (is_subgroup.mul_mem_cancel_right T hsT).mp h,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209373,"user_id":660,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\nopen_locale classical\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  by_contra a,\n  push_neg at a,\n  rcases a with \u27e8\u27e8s, hs\u27e9, \u27e8t, ht\u27e9\u27e9,\n  cases HST (s * t),\n  { rw is_subgroup.mul_mem_cancel_left _ ((HST t).resolve_right ht) at h,\n    apply hs h },\n  { rw is_subgroup.mul_mem_cancel_right _ ((HST s).resolve_left hs) at h,\n    apply ht h },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209374,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\nopen_locale classical\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\nby_cases (\u2200 x, x \u2208 S),\nsimp *,\nsimp *,\nby_contradiction g,\nhave sproper := not_forall.mp h,\nhave tproper := not_forall.mp g,\ncases sproper with t tnS;\ncases tproper with s snT;\ncases (HST t) with tS tT;\ncases (HST s) with sS sT;\ntry { contradiction },\ncases (HST (s * t : G)) with stS stT,\nhave := (is_subgroup.mul_mem_cancel_right S sS).mp stS, contradiction,\nhave := (is_subgroup.mul_mem_cancel_left  T tT).mp stT, contradiction \nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209375,"user_id":657,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\nopen_locale classical\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n-- by_contradiction, push_neg at a, cases a with hS hT,\n-- by_cases S \u2286 T, right,\n-- intro x, have calc1 := (HST x), cases calc1 with hs ht, apply h, assumption, assumption,\n\n-- by_cases T \u2286 S, left,\n-- intro x, have calc1 := (HST x), cases calc1 with hs ht, assumption, apply h, assumption,\nhave S_inv := _inst_2.inv_mem,\nhave T_inv := _inst_3.inv_mem,\nhave S_mul_aux : is_submonoid S,\napply is_subgroup.to_is_submonoid,\nhave S_mul := S_mul_aux.mul_mem,\nhave T_mul_aux : is_submonoid T,\napply is_subgroup.to_is_submonoid,\nhave T_mul := T_mul_aux.mul_mem,\n\nby_cases \u2203 s, s \u2208 S \u2227 s \u2209 T, rename h hs,\nby_cases \u2203 t, t \u2209 S \u2227 t \u2208 T,\nexfalso,\nrename h ht,\ncases hs with s hs,\ncases hs with hs hst,\ncases ht with t ht,\ncases ht with hts ht,\nhave key := HST (s * t),\ncases key with key_s key_t, revert ht, \nsuffices calc1 : t\u2208 S, tauto,\nrw \u2190 inv_mul_cancel_left s t,\napply S_mul (S_inv hs), assumption,\n\nsuffices calc1 : s \u2208 T, tauto,\nhave calc2 : s = s * t * t\u207b\u00b9:= by simp only [mul_inv_cancel_right], rw calc2,\napply T_mul _ (T_inv ht), assumption,\n\nleft, \nintro x,\npush_neg at h,\nhave calc1 := h x,\nhave calc2 := HST x, tauto,\n\nright,\nintro x,\npush_neg at h,\nhave calc1 := h x,\nhave calc2 := HST x, tauto,\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209376,"user_id":null,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  classical,\n  by_contradiction h,\n  push_neg at h,\n  rcases h with \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9,\n  cases HST (x * y),\n  { have : y \u2208 S, by simpa [hy] using HST y,\n    have : x \u2208 S := (is_subgroup.mul_mem_cancel_left S this).mp h,\n    exact hx this },\n  { have : x \u2208 T, by simpa [hx] using HST x,\n    have : y \u2208 T := (is_subgroup.mul_mem_cancel_right T this).mp h,\n    exact hy this },\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209377,"user_id":17,"body":"import Preloaded tactic group_theory.subgroup\n\nopen classical\nattribute [instance] prop_decidable\n\nuniverse u\n\n-- Proof adapted from\n-- https:\/\/math.stackexchange.com\/questions\/334405\/if-a-group-is-the-union-of-two-subgroups-is-one-subgroup-the-group-itself\n\nlemma second_paragraph {G : Type u} {S T : set G} (hsub : S \u2286 T \u2228 T \u2286 S)\n  (hG : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) := or.elim hsub\n  (\u03bb hsub, or.inr (\u03bb x, or.elim (hG x) (@hsub _) (\u03bb hx, hx)))\n  (\u03bb hsub, or.inl (\u03bb x, or.elim (hG x) (\u03bb hx, hx) (@hsub _)))\n\nlemma comment {G : Type u} [group G] {S T : set G} [is_subgroup S]\n  [is_subgroup T] {s t : G} (hs : s \u2208 S \\ T) (ht : t \u2208 T \\ S)\n  (hst : s * t \u2208 S \u222a T) : false :=\nbegin\n  cases hst with hst hst,\n  { have ht' := is_submonoid.mul_mem (is_subgroup.inv_mem\n      (set.diff_subset S T hs)) hst,\n    simp at ht',\n    rw set.diff_eq at ht,\n    cases ht with ht\u2081 ht\u2082,\n    exact ht\u2082 ht' },\n  { have hs' := is_submonoid.mul_mem hst (is_subgroup.inv_mem\n      (set.diff_subset T S ht)),\n    simp at hs',\n    rw set.diff_eq at hs,\n    cases hs with hs\u2081 hs\u2082,\n    exact hs\u2082 hs' }\nend\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  by_contra hc,\n  push_neg at hc,\n  rcases hc with \u27e8\u27e8x\u2080, hx\u2080\u27e9, \u27e8x\u2081, hx\u2081\u27e9\u27e9,\n  have hx\u2080' : x\u2080 \u2208 T \\ S := and.intro (or.elim (HST x\u2080)\n    (\u03bb hx\u2080', false.elim (hx\u2080 hx\u2080')) (\u03bb hx\u2080', hx\u2080')) hx\u2080,\n  have hx\u2081' : x\u2081 \u2208 S \\ T := and.intro (or.elim (HST x\u2081) (\u03bb hx\u2081', hx\u2081')\n    (\u03bb hx\u2081', false.elim (hx\u2081 hx\u2081'))) hx\u2081,\n  exact comment hx\u2081' hx\u2080' (HST _)\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209378,"user_id":168,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  classical, by_contra h, push_neg at h,\n  obtain \u27e8\u27e8x, hxS\u27e9, \u27e8y, hyT\u27e9\u27e9 := h,\n  cases HST (x * y),\n  { rw is_subgroup.mul_mem_cancel_left at h, contradiction,\n    cases HST y, assumption, contradiction, },\n  { rw is_subgroup.mul_mem_cancel_right at h, contradiction,\n    cases HST x, contradiction, assumption, }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209379,"user_id":656,"body":"import Preloaded tactic group_theory.subgroup\n\nuniverse u\n\n\/- Sorry for crappy proof :P -\/\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\n  apply classical.by_contradiction, push_neg,\n  rintro \u27e8\u27e8a, ha\u27e9, b, hb\u27e9, \n  cases HST (a * b),\n    { suffices : a \u2208 S, contradiction,\n      have : b \u2208 S, cases HST b, assumption, contradiction,\n      replace this : b\u207b\u00b9 \u2208 S, apply _inst_2.2, exact this,\n      replace this : a * b * b\u207b\u00b9 \u2208 S, apply _inst_2.1.2; assumption,\n      convert this, rwa mul_inv_cancel_right a b },\n    { suffices : b \u2208 T, contradiction,\n      have : a \u2208 T, cases HST a, contradiction, assumption,\n      replace this : a\u207b\u00b9 \u2208 T, apply _inst_3.2, exact this,\n      replace this : a\u207b\u00b9 * a * b \u2208 T, rw mul_assoc, apply _inst_3.1.2; assumption,\n      convert this, rwa [mul_left_inv, one_mul] }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209380,"user_id":null,"body":"import tactic group_theory.subgroup\n\nuniverse u\n\nopen_locale classical\n\ntheorem of_forall_mem_or_mem {G : Type u} [group G] (S T : set G) [is_subgroup S] [is_subgroup T]\n  (HST : \u2200 x, x \u2208 S \u2228 x \u2208 T) : (\u2200 x, x \u2208 S) \u2228 (\u2200 x, x \u2208 T) :=\nbegin\ncases classical.em (\u2200 (x : G), x \u2208 S) with SG SnG,\n    left, exact SG,\nright,\nrw not_forall at SnG, cases SnG with t,\nhave tt : t \u2208 T, \n  {cases HST t, \n    {exfalso, apply SnG_h, exact h},\n  exact h\n  },\nintro g,\nhave tg : g*t \u2208 T,\n  { cases HST (g*t),\n    { cases HST g,\n      have ggt : g\u207b\u00b9*g*t \u2208 S, rw mul_assoc, exact is_submonoid.mul_mem (is_subgroup.inv_mem h_1) h,\n      rw [mul_assoc, inv_mul_cancel_left] at ggt,\n      exfalso, apply SnG_h, exact ggt,\n    exact is_submonoid.mul_mem h_1 tt,\n    },\n  exact h\n  },\nhave gtt : g*t*t\u207b\u00b9 \u2208 T, exact is_submonoid.mul_mem tg (is_subgroup.inv_mem tt),\nsimp at gtt, exact gtt,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ea9b14c9b7bf50001b88e55":[{"id":209381,"user_id":null,"body":"import Preloaded\nimport tactic\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := by tidy\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := by tidy\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) := by tidy\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp := by tidy\n\nlocal attribute [simp] le' comp transitive\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := by tidy\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209382,"user_id":null,"body":"import Preloaded tactic\n\n\nvariables {\u03b1 : Type*}\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \nbegin\n  intros x,\n  simp [le'],\nend\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\nbegin\n  intros x y z p q,\n  simp [le'] at *,\n  finish,\nend\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) :=\n  begin\n    intros x,\n    simp [comp] at *,\n    use x,\n    split,\n    apply h\u2080,\n    apply h\u2081,\n  end\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp := \nbegin\n  intros x y z,\n  simp [comp],\n  funext,\n  simp,\n  tauto,\nend\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := \nbegin\n  simp [comp, le', transitive],\n  tauto,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209383,"user_id":null,"body":"import Preloaded\nimport tactic.ext\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\n  \u03bb _ _ _, id\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\n  \u03bb r r' r'' h1 h2 x y rxy, (h2 x y) (h1 x y rxy)\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) :=\n  \u03bb x, \u27e8x, h\u2080 x, h\u2081 x\u27e9\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp :=\nbegin\n  intros r1 r2 r3,\n  ext,\n  unfold comp,\n  split,\n  intro h,\n  cases h with a h,\n  cases h with h h2,\n  cases h with b h1,\n  exact \u27e8b, h1.1, \u27e8 a, h1.2,h2 \u27e9 \u27e9 ,\n  intro h,\n  cases h with a h,\n  cases h with h1 h2,\n  cases h2 with b h2,\n  exact \u27e8 b, \u27e8 a, h1 , h2.1\u27e9 , h2.2\u27e9 ,\nend\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 :=\nbegin\n  unfold transitive,\n  split,\n  intro h,\n  intros x z hxz,\n  cases hxz with y hy,\n  exact h hy.1 hy.2,\n  intros h x y z hxy hyz,\n  apply h x z,\n  exact \u27e8y, hxy, hyz \u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209384,"user_id":null,"body":"import Preloaded\n\nimport tactic\nvariables {\u03b1 : Type*}\n\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=by {\n  simp[reflexive],\n  intro,\n  simp[le'],\n}\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := by{\n  simp[transitive,le'],\n  intros x y z h\u2081 h\u2082 a b h\u2083,\n  exact h\u2082 a b (h\u2081 a b h\u2083),\n}\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) := by{\n    simp[reflexive,comp],\n    intro x,\n    simp[reflexive] at h\u2080 h\u2081,\n    use x,\n    exact \u27e8h\u2080 x, h\u2081 x\u27e9\n  }\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp := by{\n  simp [associative,comp],\n  intros a b c,\n  funext,\n  simp,\n  split,{\n    intro h\u2081,\n    rcases h\u2081 with \u27e8c_1,\u27e8\u27e8c_2,\u27e8h\u2083,h\u2084\u27e9\u27e9,h\u2082\u27e9\u27e9,\n    use c_2,\n    split,{\n      assumption\n    },{\n      use c_1,\n      exact \u27e8h\u2084, h\u2082\u27e9,\n    }\n  },{\n    intro h\u2081,\n    rcases h\u2081 with \u27e8c_1,\u27e8h\u2082,\u27e8c_2,\u27e8h\u2083,h\u2084\u27e9\u27e9\u27e9\u27e9,\n    use c_2,\n    split,{\n      split,{\n        exact \u27e8h\u2082, h\u2083\u27e9\n      },\n    },{\n      exact h\u2084\n    }\n  }, \n}\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := by{\n  split,{\n    simp[transitive,comp,le'],\n    intros h\u2081 z b x h\u2082 h\u2083,\n    exact h\u2081 h\u2082 h\u2083,\n  },{\n    simp[transitive,comp,le'],\n    intros h\u2081 x y z h\u2082 h\u2083,\n    exact h\u2081 x z y h\u2082 h\u2083,\n  }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209385,"user_id":null,"body":"import Preloaded tactic\n\nvariables {\u03b1 : Type*}\n\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \nbegin\n  intros R x y hxy,\n  exact hxy,\nend\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \nbegin\n  intros R S T hRS hST x y hRxy,\n  exact hST x y (hRS x y hRxy), \nend\n\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) := \nbegin\n  intros x,\n  use [x, h\u2080 x, h\u2081 x],\nend\n\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp := \nbegin\n  intros R S T,\n  ext x y,\n  split,\n  { rintros \u27e8z, \u27e8t, hRxt, hStz\u27e9, hTzy\u27e9, \n    use [t, hRxt, z, hStz, hTzy] },\n  { rintros \u27e8z, hRxz, \u27e8t, hSzt, hTty\u27e9\u27e9, \n    use [t, z, hRxz, hSzt, hTty] },\nend\n\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := \nbegin\n  split,\n  { rintros h x y \u27e8z, hxz, hzy\u27e9,\n    exact h hxz hzy },\n  { intros h x y z hxy hyz,    \n    exact h x z \u27e8y, hxy, hyz\u27e9 },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209386,"user_id":null,"body":"import Preloaded\nimport tactic\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \nbegin\n  intro,\n  intros a b,\n  intro h,\n  exact h,\nend\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \nbegin\n  intros x y z,\n  intros h1 h2,\n  intros xa xb,\n  intro hx,\n  have t := h1 xa xb hx,\n  have p := h2 xa xb t,\n  exact p,\nend\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) := \nbegin\n  intro,\n  existsi x,\n  split,\n  exact h\u2080 x,\n  exact h\u2081 x,\nend\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp := \nbegin\n  intros a b c,\n  funext x y,\n  rw eq_iff_iff,\n  split,\n  {\n    intro h,\n    cases h with j hj,\n    cases hj,\n    cases hj_left with k hk,\n    use k,\n    split,\n    exact hk.1,\n    use j,\n    split,\n    exact hk.2,\n    exact hj_right,\n  }, \n  {\n    intro h,\n    cases h with j hj,\n    cases hj,\n    cases hj_right with k hk,\n    use k,\n    split,\n    use j,\n    split,\n    exact hj_left,\n    exact hk.1,\n    exact hk.2,\n  },\nend\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := \nbegin\n  split,\n  intro h,\n  intros a b,\n  intro comp_h,\n  cases comp_h with c hc,\n  cases hc,\n  exact h hc_left hc_right,\n  intro h,\n  intros x y z,\n  intros h1 h2,\n  have hs : \u2203 y : \u03b1, \u03c4 x y \u2227 \u03c4 y z := \u27e8y , h1, h2 \u27e9, \n  exact h x z hs,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209387,"user_id":null,"body":"import Preloaded tactic\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\n\u03bb _ _ _ h, h\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\n\u03bb _ _ _ h\u2081 h\u2082 _ _ h, h\u2082 _ _ (h\u2081 _ _ h)\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) :=\n\u03bb a, \u27e8a, h\u2080 a, h\u2081 a\u27e9\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp :=\n\u03bb r s t, by ext a b; unfold comp; tauto\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 :=\n\u27e8\u03bb h _ _ \u27e8_, h\u2081, h\u2082\u27e9, h h\u2081 h\u2082, \u03bb h _ _ _ h\u2081 h\u2082, h _ _ \u27e8_, h\u2081, h\u2082\u27e9\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209388,"user_id":null,"body":"import Preloaded\nimport tactic\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \u03bb \u03c4 a b, id\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := \u03bb \u03c4 \u03c3 \u03bc h\u03c4\u03c3 h\u03c3\u03bc a b h\u03c4ab, h\u03c3\u03bc a b (h\u03c4\u03c3 a b h\u03c4ab)\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) := \u03bb a, exists.intro a \u27e8h\u2080 a, h\u2081 a\u27e9\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp :=\nbegin\n  intros \u03c4 \u03c3 \u03bc,\n  ext a b,\n  exact \u27e8\u03bb \u27e8c\u2081, \u27e8c\u2082, h\u03c4, h\u03c3\u27e9, h\u03bc\u27e9, \u27e8c\u2082, \u27e8h\u03c4, \u27e8c\u2081, \u27e8h\u03c3,h\u03bc\u27e9\u27e9\u27e9\u27e9,\n         \u03bb \u27e8c\u2081, h\u03c4, c\u2082, h\u03c3, h\u03bc\u27e9, \u27e8c\u2082, \u27e8\u27e8c\u2081, \u27e8h\u03c4, h\u03c3\u27e9\u27e9, h\u03bc\u27e9\u27e9\u27e9,\nend\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := \u27e8\u03bb htran a b \u27e8c, hac, hcb\u27e9, htran hac hcb, \n  \u03bb hle a b c hab hbc, hle _ _ \u27e8b, \u27e8hab, hbc\u27e9\u27e9\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209389,"user_id":null,"body":"import Preloaded tactic\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\nbegin\n    intros _ _ _,\n    exact id,\nend\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' :=\nbegin\n    unfold transitive,\n    intros p q r h1 h2 a b,\n    intro x,\n    apply h2 _ _,\n    apply h1 _ _,\n    exact x,\nend\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) :=\nbegin\n    intro x,\n    use x,\n    exact \u27e8h\u2080 x, h\u2081 x\u27e9,\nend\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp :=\nbegin\n    intros p q r,\n    apply funext,\n    intro a,\n    apply funext,\n    intro b,\n    rw eq_iff_iff,\n    split,\n    { \n        rintro \u27e8c, \u27e8d, hp, hq\u27e9, hr\u27e9,\n        use d, split, swap,\n        use c, split,\n        repeat { by assumption, },\n    }, {\n        rintro \u27e8c, hp, \u27e8d, hq, hr\u27e9\u27e9,\n        use d, use c, split,\n        repeat { by assumption, },\n    },\n\nend\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u00b0 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 :=\nbegin\n    split,\n    {\n        rintros h a b \u27e8c, \u03c4ac, \u03c4cb\u27e9,\n        exact h \u03c4ac \u03c4cb,\n    }, {\n        intros h x y z \u03c4xy \u03c4yz,\n        exact h x z \u27e8y, \u03c4xy, \u03c4yz\u27e9,\n    },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209390,"user_id":null,"body":"import Preloaded tactic\n\nvariables {\u03b1 : Type*}\n\n\/- Prove that \u2286 is both reflexive and transitive -\/\ntheorem le'_refl : @reflexive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := begin\n  intros _ _ _ hab,\n  assumption,\nend\n\ntheorem le'_trans : @transitive (\u03b1 \u2192 \u03b1 \u2192 Prop) le' := begin\n  intros x y z hxy hyz a b hab,\n  exact hyz _ _ (hxy _ _ hab),\nend\n\n\/- Prove that if two binary relations are reflexive, then so are their\ncompositions-\/\ntheorem comp_refl {\u03c4 \u03c3 : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (h\u2080 : reflexive \u03c4) (h\u2081 : reflexive \u03c3) :\n  reflexive (\u03c4 \u2218 \u03c3) := begin\n  unfold reflexive comp at *,\n  intro a,\n  existsi a,\n  split,\n  apply h\u2080,\n  apply h\u2081,\nend\n\n\/- Prove that composition is associative -\/\ntheorem comp_assoc : @associative (\u03b1 \u2192 \u03b1 \u2192 Prop) comp := begin\n  intros x y z,\n  ext a b,\n  split,\n  intro h,\n  unfold comp at h,\n  cases h with e he,\n  cases he,\n  cases he_left with w hw,\n  cases hw,\n  unfold comp,\n  use w,\n  split,\n  exact hw_left,\n  use e,\n  cc,\n  intro h,\n  cases h with e he,\n  cases he with hxae yoz,\n  cases yoz with f hf,\n  cases hf,\n  unfold comp,\n  use f,\n  split,\n  use e,\n  cc,\n  cc,\nend\n\n\/- Prove that a binary relation \u03c4 is transitive if and only if\n(\u03c4 \u2218 \u03c4) \u2286 \u03c4 -\/\ntheorem trans_iff_comp_le' {\u03c4 : \u03b1 \u2192 \u03b1 \u2192 Prop} :\ntransitive \u03c4 \u2194 (\u03c4 \u2218 \u03c4) \u2286 \u03c4 := begin\n  split,\n  intro h\u03c4,\n  unfold comp transitive le' at *,\n  intros a b hc,\n  cases hc with c hc,\n  exact h\u03c4 hc.left hc.right,\n  intros h\u03c4,\n  unfold comp le' transitive at *,\n  intros x y z hxy hyz,\n  apply h\u03c4 x z,\n  use y,\n  cc,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eaa05ce96ed2500292a6d29":[{"id":209391,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\nopen_locale big_operators\n\ntheorem sum_xx14n1 : \u2200 (n : \u2115), 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) \n| 0 := by refl \n| 1 := by refl \n| (n+2) :=\n    let f := \u03bb n, n * (2 * n - 1) in\n    calc 6 * \u2211 i in range (n+3), i * (2 * i - 1)    \n        = 6 * ((n+2) * (2 * (n+2) - 1)) + 6 * \u2211 i in range (n+2), f i       : by rw [sum_range_succ, mul_add]\n    ... = 6 * ((n+2) * (2 * (n+2) - 1)) + (n+1) * (n+2) * (4 * (n+1) - 1)   : by rw sum_xx14n1 -- induction step\n    ... = 6 * ((n+2) * (2 * (n+2) - 1)) + (n+1) * (n+2) * (4*n + 3)         : by rw (show 4*(n+1)-1 = 4*n+3, from by ring) -- remove negative\n    ... = 6 * ((n+2) * (2*n + 3)) + (n+1) * (n+2) * (4*n + 3)               : by rw (show (2*(n+2)-1) = 2*n+3, from by ring) -- remove negative\n    ... = (n + 2) * (n + 3) * (4*n + 7)                                     : by ring \n    ... = (n + 2) * (n + 3) * (4 * (n + 2) - 1)                             : by rw (show 4*n+7 = 4*(n+2)-1, from by ring) ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209392,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\nopen_locale big_operators\n\ntheorem sum_xx14n1 : \u2200 (n : \u2115), 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) \n| 0 := by refl \n| 1 := by refl \n| (n+2) :=\n    let f := \u03bb n, n * (2 * n - 1) in\n    calc 6 * \u2211 i in range (n+3), i * (2 * i - 1)    \n        = 6 * ((n+2) * (2 * (n+2) - 1)) + 6 * \u2211 i in range (n+2), f i       : by rw [sum_range_succ, mul_add]\n    ... = 6 * ((n+2) * (2 * (n+2) - 1)) + (n+1) * (n+2) * (4 * (n+1) - 1)   : by rw sum_xx14n1 -- induction step\n    ... = 6 * ((n+2) * (2 * (n+2) - 1)) + (n+1) * (n+2) * (4*n + 3)         : by rw [show 4 *(n+1)-1 = 4*n + 3, from by ring] -- remove negative\n    ... = 6 * ((n+2) * (2*n + 3)) + (n+1) * (n+2) * (4*n + 3)               : by rw [show (2*(n+2)-1) = 2*n+3, from by ring] -- remove negative\n    ... = (n + 2) * (n + 3) * (4*n + 7)                                     : by ring \n    ... = (n + 2) * (n + 3) * (4 * (n + 2) - 1)                             : by rw [show 4*n+7 = 4*(n+2)-1, from by ring] \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209393,"user_id":659,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) :=\nbegin\n  intro n,\n  cases n, refl,\n  induction n with d hd, refl,\n  rw [sum_range_succ, mul_add, hd, succ_eq_add_one, succ_eq_add_one],\n  rw (show (4 * (d + 1) - 1) = 4 * d + 3, by ring),\n  rw (show (4 * (d + 1 + 1) - 1) = 4 * d + 7, by ring),\n  rw (show (2 * (d + 1 + 1) - 1) = 2 * d + 3, by ring),\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209394,"user_id":168,"body":"import Preloaded tactic algebra.big_operators\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (finset.range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1)\n| 0 := rfl\n| (nat.succ n) := begin\n  rw [finset.sum_range_succ, mul_add, sum_xx14n1],\n  cases n with n, refl,\n  simp_rw [nat.succ_eq_add_one],\n  rw [show 4 * (n + 1 + 1) - 1 = 4 * (n + 1) + 3, by ring,\n      show 4 * (n + 1) - 1 = 4 * n + 3, by ring,\n      show 2 * (n + 1 + 1) - 1 = 2 * (n + 1) + 1, by ring],\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209395,"user_id":645,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) := begin\n  intro n,\n  induction n with d hd,\n  refl,\n  rw [sum_range_succ, mul_add, hd, succ_eq_add_one],\n  induction d with d hd,\n  refl,\n  rw succ_eq_add_one,\n  repeat { rw mul_add },\n  simp,\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209396,"user_id":null,"body":"import Preloaded algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) :=\nbegin\n  intro n,\n  cases n,               { simp, },\n  induction n with m IH, { simp [finset.sum_range, fin.sum_univ_two, add_mul], },\n  rw [finset.sum_range_add, range_one, sum_singleton],\n  simp only [mul_add, succ_eq_add_one, IH, mul_one, mul_zero, nat.succ_sub_one],\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209397,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) :=\nbegin\nintro n,\ninduction n with k hk,\n{simp},\nrw [finset.sum_range_succ,succ_eq_add_one,mul_add],\nrw hk,\nrw [mul_comm k (k+1),\u2190 mul_assoc 6, mul_comm 6 (k+1)],\nhave knz: k+1\u2260 0,\n{rw \u2190 succ_eq_add_one,\napply succ_ne_zero},\nrw [mul_assoc,mul_assoc,\u2190 mul_add (k+1),mul_assoc (k+1)],\nnorm_num,\nrw [mul_add,mul_add,add_mul,add_mul,one_mul],\n-- surely I should have k\u22600 as a hypothesis at this point, but I don't..\ncases k with j,\nnorm_num,\nrepeat {rw succ_eq_add_one},\nnorm_num,ring_nf,\nhave hyp: 12 = 1+11,\n{norm_num},\nrw [hyp, mul_add,add_mul],\nnorm_num,\nring,\nend ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209398,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) :=\nbegin\n  intro n,\n  induction n with n hn,\n  refl,\n  rw [sum_range_succ,succ_eq_add_one,mul_add,hn],\n  cases n,\n  refl,\n  rw succ_eq_add_one,\n  simp [mul_add],\n  ring,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209399,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, \n  6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) :=\nbegin\n  intros n,\n  induction n with d hd,\n  { simp, },\n  rw range_add_one,\n  rw succ_eq_add_one at *,\n  simp at *,\n  rw [mul_add, hd],\n  cases d,\n  { norm_num, },\n  rw succ_eq_add_one, \n  repeat { rw mul_add },\n  norm_num,\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209400,"user_id":null,"body":"import Preloaded tactic algebra.big_operators\n\nopen nat finset\n\ntheorem sum_xx14n1 : \u2200 n : \u2115, 6 * (range (n + 1)).sum (\u03bb n : \u2115, n * (2 * n - 1)) = n * (n + 1) * (4 * n - 1) :=\nbegin\n  intro n,\n  induction n with d hd,\n    refl,\n  rw range_add_one,\n  simp at *,\n  rw succ_eq_add_one,\n  rw mul_add,\n  rw hd,\n  simp [mul_add, add_mul, one_add_one_eq_two],\n  ring,\n  cases d,\n  refl,\n  simp [add_mul, mul_add, succ_eq_add_one],\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eaad37e96b2c400205f9905":[{"id":209401,"user_id":null,"body":"import Preloaded\n\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n    induction n with n hn, refl,\n    calc fword (nat.succ n + 2) = fword_aux (fword (nat.succ n + 1)) : rfl\n    ... = fword_aux (fword (n + 1) ++ fword n) : by rw hn\n    ... = (fword_aux (fword (n + 1))) ++ (fword_aux (fword n)) : list.bind_append _ _ _\n    ... = (fword (n + 2)) ++ (fword (n + 1)) : rfl,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209402,"user_id":168,"body":"import Preloaded\n\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n  induction n with n ih, { refl },\n  change fword (nat.succ n + 2) with fword_aux (fword (n + 2)),\n  conv_lhs { rw [ih, fword_aux, list.bind_append] },\n  refl,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209403,"user_id":714,"body":"import Preloaded\n\nlemma fword_aux_append {x y : list bool} : fword_aux (x ++ y) = fword_aux x ++ fword_aux y :=\nby { unfold fword_aux, rw list.bind_append }\n\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n  induction n with d hd,\n  { refl },\n  change fword_aux (fword (d + 2)) = fword_aux (fword (d + 1)) ++ fword_aux (fword d),\n  rw [\u2190fword_aux_append, hd]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209404,"user_id":null,"body":"import Preloaded\n\nlemma fword_step (n : \u2115) : fword (n + 1) = fword_aux (fword n) := rfl\n\nlemma fword_aux_append (s t : list bool) :\n  fword_aux (s ++ t) = (fword_aux s) ++ (fword_aux t) := \nby {rw [fword_aux, list.bind_append], refl}\n\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n  induction n with d hd,\n  refl,\n  rw [nat.succ_eq_add_one, fword_step, hd, fword_aux_append, \u2190hd, \u2190fword_step, \u2190fword_step],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209405,"user_id":null,"body":"import Preloaded\n\n\nlemma recurrence {n:\u2115} : fword (n+1) = fword_aux(fword n):=\nbegin\n  refl,\nend\n\ntheorem fword_succ_succ (n : \u2115) :\n  fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n  induction n with n hn,\n  refl,\n  rw [recurrence,nat.succ_eq_add_one,hn],\n  calc\n    fword_aux (fword (n + 1) ++ fword n)\n        = fword_aux (fword (n+1)) ++ fword_aux (fword n)\n          : by simp [fword_aux]\n    ... = fword (n+2) ++ fword_aux (fword n)\n          : by rw \u2190 recurrence\n    ... = fword (n+2) ++ fword(n+1)\n          : by rw \u2190 recurrence\n    ... = fword (n+1) ++ fword n ++ fword(n+1)\n          : by rw hn,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209406,"user_id":null,"body":"import Preloaded\n\nlemma fword_aux_append (s t:list bool) : \nfword_aux s ++ (fword_aux t) = fword_aux (s++t):=by{\n  induction s with s hs,\n    refl,\n  dsimp [fword_aux] at *,\n  dsimp [list.bind] at *,\n  rw [list.append_assoc],\n  rw s_ih,\n}\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n :=\nby{\n  induction n with n hn1,{\n    refl,\n  },\n  dsimp [fword,stream.iterate] at *,\n  rw [fword_aux_append,hn1],\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209407,"user_id":null,"body":"import Preloaded tactic\n\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n  induction n with d hd,  \n  { refl }, \n  simp [nat.succ_eq_add_one],\n  have h : \u2200n, fword (n + 1) = list.bind (fword n) phi := \u03bbn, rfl,\n  rw [h (d + 2), hd, list.append_bind],\n  rw [\u2190(h (d + 1)), \u2190h d, hd],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209408,"user_id":191,"body":"import Preloaded tactic.nth_rewrite\n\nlemma iterate_succ {\u03b1 : Type} {a : \u03b1} {f : \u03b1 \u2192 \u03b1} (n : \u2115) : stream.iterate f a n.succ = f(stream.iterate f a n) := rfl\n\nlemma fword_succ_succ : \u2200 n, fword (n + 2) = fword (n + 1) ++ fword n :=\nbegin\n  intro n,\n  induction n with n hn,\n  tauto,\n  unfold fword at *,\n  rw iterate_succ,\n  nth_rewrite 0 hn,\n  rw fword_aux,\n  rw list.append_bind,\n  refl\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209409,"user_id":null,"body":"import Preloaded\ntheorem fword_succ (n:\u2115) : fword (nat.succ n) = fword_aux ( fword n):=\nbegin\n    refl,\nend\n\ntheorem fword_aux_concat (a:list bool) (b:list bool) \n    : fword_aux (a ++ b) = (fword_aux a) ++ (fword_aux b) :=\nbegin\ninduction a,\nrw list.nil_append,\nhave H: fword_aux list.nil = list.nil,\nhave L: fword_aux list.nil = list.bind list.nil phi,\nrefl,\nrw L,\nrw list.nil_bind,\nrw H,\nrw list.nil_append,\nhave L2: \u2200 s:(list bool), fword_aux s = list.bind s phi,\nintro s,\nrefl,\nrw L2 (a_hd :: a_tl ++ b),\nrw list.append_bind,\nrefl,\n\nend\n\ntheorem fword_succ_succ (n : \u2115) : fword (n + 2) = fword (n + 1) ++ fword n := \nbegin\n    induction n,\n    refl,\n    rw nat.succ_add,\n    rw nat.succ_add,\n    rw fword_succ,\n    rw n_ih,\n    rw fword_aux_concat,\n    rw fword_succ,\n    have H: \u2200(m:nat),fword_aux (fword_aux (fword m)) = fword_aux (fword m) ++ fword m,\n    intro m,\n    induction m,\n    refl,\n    rw fword_succ,\n    rw m_ih,\n    rw fword_aux_concat,\n    rw m_ih,\n\n    rw H n_n,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209410,"user_id":null,"body":"import Preloaded tactic\n\ntheorem fword_succ_succ : \u2200 n, fword (n + 2) = fword (n + 1) ++ fword n\n| 0 := rfl\n| (n+1) := \nbegin\n  simp only [add_assoc], norm_num, rw [show fword (n+3) = fword_aux (fword (n+2)), from rfl],\n  conv_lhs { rw fword_succ_succ n}, simp only [fword_aux, list.bind_append], congr' 1,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eac8d8845655d003300f5b5":[{"id":209411,"user_id":644,"body":"import Preloaded tactic\n\nopen nat\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nif h : b \u2264 a \nthen \n  have b ^ 4 \u2264 a ^ 4, from nat.pow_le_pow_of_le_left h _,\n  int.coe_nat_inj $ by simp [int.coe_nat_sub h, int.coe_nat_sub this]; ring\nelse \n  have a ^ 4 \u2264 b ^ 4, from nat.pow_le_pow_of_le_left (le_of_not_ge h) _,\n  by rw [nat.sub_eq_zero_of_le (le_of_not_ge h), nat.sub_eq_zero_of_le this]; simp","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209412,"user_id":null,"body":"import Preloaded tactic\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  have pos : a^4 + b * (a+b) * (a^2 + b^2) = b^4 + a * (a+b) * (a^2 + b^2), { by ring },\n  calc a^4 - b^4  \n      = (a^4 + b * (a+b) * (a^2 + b^2)) - (b^4 + b * (a+b) * (a^2 + b^2)) : by rw \u2190 nat.add_sub_add_right\n  ... = (b ^4 + a * (a+b) * (a^2 + b^2) ) - (b^4 + b * (a+b) * (a^2 + b^2)) : by rw pos\n  ... = a * (a+b) * (a^2 + b^2) - b * (a+b) * (a^2 + b^2) : by rw nat.add_sub_add_left\n  ... = a * ((a+b) * (a^2 + b^2)) - b * ((a+b) * (a^2 + b^2)) : by rw [mul_assoc, mul_assoc]\n  ... = (a - b) * (a + b) * (a ^ 2 + b ^ 2): by rw [\u2190 nat.mul_sub_right_distrib, \u2190 mul_assoc]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209413,"user_id":null,"body":"import Preloaded tactic\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  rw [mul_assoc, add_mul],\n  simp only [nat.mul_sub_right_distrib, mul_comm b],\n  simp only [mul_add, add_mul, \u2190 mul_assoc a, mul_assoc _ _ b, \u2190 pow_two, \u2190 pow_succ, \u2190 pow_succ'],\n  simp only [\u2190 nat.sub_sub, nat.add_sub_cancel],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209414,"user_id":null,"body":"import Preloaded tactic\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  cases le_total a b with h h,\n  { rw [nat.sub_eq_zero_of_le h, zero_mul, zero_mul],\n    exact nat.sub_eq_zero_of_le (pow_le_pow_of_le_left (nat.zero_le a) h 4) },\n  { zify [h, pow_le_pow_of_le_left (nat.zero_le b) h 4],\n    ring }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209415,"user_id":null,"body":"import Preloaded tactic\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  by_cases h : b \u2264 a,\n  { zify, rw [int.coe_nat_sub h, int.coe_nat_sub (nat.pow_le_pow_of_le_left h 4)], ring, },\n  { have aleb : a \u2264 b, by linarith,\n    simp only [nat.sub_eq_zero_of_le aleb, zero_mul],\n    rw nat.sub_eq_zero_of_le (nat.pow_le_pow_of_le_left aleb 4), }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209416,"user_id":null,"body":"import Preloaded tactic\ntheorem p4(a: \u2115): a^4 = (a^2)^2 := begin \n  simp [pow, monoid.pow, nat.mul_one, nat.mul_assoc],\nend\n\ntheorem U{a b: \u2115}: a \u2264 b \u2192 a - b = 0 := nat.sub_eq_zero_of_le\ntheorem V{a b: \u2115}: a \u2264 b \u2192 a^2 \u2264 b^2 := \u03bb h, begin \n  simp [pow, monoid.pow],\n  apply nat.mul_le_mul h h\nend\n\ntheorem sqr_diff(a b: \u2115): a^2 - b^2 = (a-b)*(a+b) := begin   \n  cases @nat.le_total b a,\n  {\n    simp [nat.mul_sub_right_distrib, nat.left_distrib],\n    have f: b*b \u2264 a*b := nat.mul_le_mul_right _ h,\n    have g: b*a \u2264 a*a := nat.mul_le_mul_right _ h,\n    rw \u2190 nat.add_sub_assoc f,\n    rw nat.mul_comm a b,\n    rw nat.sub_add_cancel g,\n    simp [pow, monoid.pow, nat.mul_one]\n  },\n  rw [U h, U (V h), nat.zero_mul]\nend\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115): a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\n  calc a ^ 4 - b ^ 4 \n     = ((a^2)^2 - (b^2)^2)             : by simp [p4]\n ... = (a^2 - b^2) * (a^2 + b^2)       : by rw sqr_diff\n ... = ((a-b)*(a+b)) * (a^2 + b^2)     : by rw sqr_diff\n ... = (a - b) * (a + b) * (a^2 + b^2) : by rw nat.mul_assoc\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209417,"user_id":null,"body":"import Preloaded tactic\n\ntheorem help (a b : \u2115) : (a - b) * (a + b) = a^2 - b^2 :=\nbegin\n  rw nat.mul_sub_right_distrib,\n  rw mul_add,\n  rw mul_add,\n  rw add_comm (b * a) (b * b),\n  rw mul_comm b a,\n  rw nat.add_sub_add_right,\n  rw pow_two,\n  rw pow_two,\nend \n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  symmetry,\n  rw help,\n  rw help,\n  rw <-pow_mul',\n  rw <-pow_mul',\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209418,"user_id":645,"body":"import Preloaded tactic\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  rw (show 4 = 2 * 2, by ring),\n  simp [pow_mul, pow_two],\n  repeat { rw nat.mul_self_sub_mul_self_eq },\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209419,"user_id":null,"body":"import tactic\n\nopen nat\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n  have p4 : 4 = 2 * 2, norm_num,\n  rw p4, simp only [nat.pow_mul, nat.pow_two],\n  repeat {rw nat.mul_self_sub_mul_self_eq}, ring, \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209420,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\nlemma sub_eq_zero_of_lt {a b : \u2115} : a < b \u2192 a - b = 0 :=\nbegin\n    intro h,\n    omega,\nend\n\nlemma sub_mul_add {a b : \u2115} (c : \u2115) : b \u2264 a \u2192 (a - b)*c + b*c = a*c :=\nbegin\n    intro h,\n    induction c with c hc,\n    { ring, },\n    { repeat {rw mul_succ},\n      rw [\u2190 hc, add_assoc, add_assoc, add_left_cancel_iff,\n          add_comm (b*c) b, add_comm (b*c) a, \u2190 add_assoc,\n          add_right_cancel_iff],\n      exact nat.sub_add_cancel h,\n    },\nend\n\nlemma sub_mul' {a b : \u2115} (c : \u2115) : b \u2264 a \u2192 (a - b)*c = a*c - b*c :=\nbegin\n    intro h,\n    rw \u2190 sub_mul_add c h,\n    simp only [nat.add_sub_cancel],\nend\n\nlemma sub_cancel (a b c : \u2115) : (a + c) - (b + c) = a - b :=\nbegin\n    omega,\nend\n\nlemma sub_pow_2_of_sub_add {a b : \u2115} : (a - b)*(a + b) = a^2 - b^2 :=\nbegin\n    by_cases h : a < b,\n    {   have a2_lt_b2 : a^2 < b^2,\n            simp only [nat.pow_two, mul_self_lt_mul_self h],\n        simp only [show a - b = 0, from sub_eq_zero_of_lt h,\n                    show a ^ 2 - b ^ 2 = 0, from sub_eq_zero_of_lt a2_lt_b2,\n                    zero_mul],\n    },\n    {   push_neg at h,\n        rwa [sub_mul' (a + b) h, mul_add, mul_add, mul_comm b a,\n                add_comm (a*b), sub_cancel (a*a), nat.pow_two, nat.pow_two],\n    },\nend\n\ntheorem a_pow_4_sub_b_pow_4 (a b : \u2115) : a ^ 4 - b ^ 4 = (a - b) * (a + b) * (a ^ 2 + b ^ 2) :=\nbegin\n    repeat {rw sub_pow_2_of_sub_add},\n    ring,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb07c4c77763300145aed45":[{"id":209421,"user_id":null,"body":"import Preloaded\n\nlemma eq_limit (f : \u211d \u2192 \u211d) (a l : \u211d) : fun_limit f a l \u2192 f a = l :=\nbegin\n    intro f_lim,\n    by_contradiction H,\n    have : 0 < abs(f a - l) := abs_pos_iff.mpr (sub_ne_zero_of_ne H),\n    rcases f_lim (abs(f a - l)) this with \u27e8\u03b4, \u03b4_pos, hf\u27e9,\n    specialize hf a,\n    rw [sub_self, abs_zero] at hf,\n    specialize hf \u03b4_pos,\n    linarith,\nend\n\n\/- We seek to prove that if f\u2099 : \u211d \u2192 \u211d uniformly converges to f : \u211d \u2192 \u211d \nthen \u2200 a \u2208 \u211d, lim_{n \u2192 \u221e} lim_{x \u2192 a} f\u2099(x) = lim_{x \u2192 a} lim_{n \u2192 \u221e} f\u2099(x) -\/\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l :=\nbegin\n    intros \u03b5 \u03b5_pos,\n    cases h\u2080 \u03b5 \u03b5_pos with N hfg,\n    use N,\n    intros n n_ge_N,\n    specialize hfg n n_ge_N a,\n    have := eq_limit g a l,\n    finish,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209422,"user_id":null,"body":"import Preloaded\n\n\/- We seek to prove that if f\u2099 : \u211d \u2192 \u211d uniformly converges to f : \u211d \u2192 \u211d \nthen \u2200 a \u2208 \u211d, lim_{n \u2192 \u221e} lim_{x \u2192 a} f\u2099(x) = lim_{x \u2192 a} lim_{n \u2192 \u221e} f\u2099(x) -\/\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l :=\nbegin\n  intros \u03b5 \u03b5pos,\n  cases h\u2080 (\u03b5\/2) (half_pos \u03b5pos) with N hN,\n  rcases h\u2081 (\u03b5\/2) (half_pos \u03b5pos) with \u27e8\u03b4, \u03b4pos, h\u03b4\u27e9,\n  use N, intros n ngeN,\n  specialize h\u03b4 a, \n  rw [sub_self, abs_zero] at h\u03b4, \n  rw \u2190 add_halves \u03b5,\n  exact lt_of_le_of_lt (abs_sub_le (f n a) (g a) l) (add_lt_add (hN n ngeN a) (h\u03b4 \u03b4pos)) \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209423,"user_id":null,"body":"import Preloaded\n\n\/- We seek to prove that if f\u2099 : \u211d \u2192 \u211d uniformly converges to f : \u211d \u2192 \u211d \nthen \u2200 a \u2208 \u211d, lim_{n \u2192 \u221e} lim_{x \u2192 a} f\u2099(x) = lim_{x \u2192 a} lim_{n \u2192 \u221e} f\u2099(x) -\/\n\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l :=\nbegin\n  intros \u03b5 hep,\n  specialize h\u2080 (\u03b5\/2) (by linarith),\n  cases h\u2080 with N hN,\n  use N,\n  intros n hn,\n  specialize hN n hn a,\n  simp [function.swap],\n  specialize h\u2081 (\u03b5\/2) (by linarith),\n  rcases h\u2081 with \u27e8 \u03b4 ,\u27e8 h1 , h2 \u27e9 \u27e9,\n  specialize h2 a _,\n  simp only [sub_self, abs_zero],\n  linarith,\n  rw abs_sub_lt_iff at *,\n  split;\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209424,"user_id":null,"body":"import Preloaded tactic\n\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l := \nbegin  \n  by_cases g a = l,\n  { intros \u03b5 h\u03b5,\n    cases (h\u2080 \u03b5 h\u03b5) with N hN,   \n    use N,\n    intros n hn,\n    have hf := hN n hn a,\n    rwa h at hf, },\n  replace h := sub_ne_zero_of_ne h,\n  exfalso,  \n  by_cases hd : g a - l > 0,\n  { rcases h\u2081 (g a - l) hd with \u27e8\u03b4, h\u03b4, hh\u27e9,\n    specialize hh a (by {norm_num, linarith}),\n    rw abs_of_pos hd at hh,\n    linarith, },\n  { replace hd := lt_of_le_of_ne (by linarith [hd]) (sub_ne_zero.mp h),\n    replace hd : g a - l < 0 := by linarith,\n    rcases h\u2081 (l - g a) (by linarith) with \u27e8\u03b4, h\u03b4, hh\u27e9,\n    specialize hh a (by {norm_num, linarith}),\n    rw abs_of_neg hd at hh,\n    linarith, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209425,"user_id":null,"body":"import Preloaded\ntheorem limit_swap (f g a l) (h\u2080: unif_convergence f g) (h\u2081: fun_limit g a l): \n  seq_limit (function.swap f a) l :=\nbegin\n  intros \u03b5 p\u03b5, simp_rw function.swap,\n  rcases h\u2080 (\u03b5\/2) (by linarith) with \u27e8N, uc\u27e9,\n  use N, intros n ng, specialize uc n ng a,\n  rcases h\u2081 (\u03b5\/2) (by linarith) with \u27e8\u03b4, p\u03b4, fl\u27e9,\n  specialize fl a (by simpa), \n  linarith [abs_sub_le (f n a) (g a) l]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209426,"user_id":null,"body":"import Preloaded\ntheorem limit_swap (f g a l) (h\u2080: unif_convergence f g) (h\u2081: fun_limit g a l): \n  seq_limit (function.swap f a) l :=\nbegin\n  intros \u03b5 p\u03b5, simp_rw function.swap,\n  cases h\u2080 (\u03b5\/2) (by linarith) with N uc, \n  use N, intros n pn, specialize uc n pn a,\n  rcases h\u2081 (\u03b5\/2) (by linarith) with \u27e8\u03b4, p\u03b4, fl\u27e9, \n  specialize fl a (by simpa),\n  linarith [abs_sub_le (f n a) (g a) l]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209427,"user_id":null,"body":"import Preloaded\ntheorem limit_swap (f g a l) (h\u2080: unif_convergence f g) (h\u2081: fun_limit g a l): seq_limit (function.swap f a) l :=\nbegin\n  intros \u03b5 p\u03b5, \n  cases h\u2080 (\u03b5\/2) (by linarith) with N uc, \n  use N, intros n pn, specialize uc n pn a,\n  rcases h\u2081 (\u03b5\/2) (by linarith) with \u27e8\u03b4, p\u03b4, fl\u27e9, \n  specialize fl a (by simpa),\n  simp_rw function.swap, linarith [abs_sub_le (f n a) (g a) l]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209428,"user_id":191,"body":"import Preloaded\n\n\/- We seek to prove that if f\u2099 : \u211d \u2192 \u211d uniformly converges to f : \u211d \u2192 \u211d \nthen \u2200 a \u2208 \u211d, lim_{n \u2192 \u221e} lim_{x \u2192 a} f\u2099(x) = lim_{x \u2192 a} lim_{n \u2192 \u221e} f\u2099(x) -\/\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l :=\nbegin\n  rintro \u03b5 h\u03b5,\n  specialize h\u2080 (\u03b5\/2) (by linarith),\n  cases h\u2080 with N hN,\n  use N,\n  rintro n hn,\n  specialize hN n hn a,\n  specialize h\u2081 (\u03b5\/2) (by linarith),\n  rcases h\u2081 with \u27e8\u03b4, h\u03b4, h\u2081\u27e9,\n  specialize h\u2081 a,\n  rw [sub_self, abs_zero] at h\u2081,\n  specialize h\u2081 h\u03b4,\n  let h := add_lt_add hN h\u2081,\n  rw add_halves' at h,\n  apply lt_of_le_of_lt _ h,\n  apply le_trans _ (abs_add _ _),\n  rw sub_add_sub_cancel\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209429,"user_id":null,"body":"import Preloaded\n\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l :=\nbegin\n  intros \u03b5 h\u03b5,\n  cases h\u2080 (\u03b5 \/ 2) (by linarith) with N hN,\n  rcases h\u2081 (\u03b5 \/ 2) (by linarith) with \u27e8\u03b4, h\u03b4, h\u27e9,\n  use N,\n  intros n hn,\n  specialize hN n hn a,\n  specialize h a (by simpa),\n  linarith [abs_sub_le (f n a) (g a) l],\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209430,"user_id":106,"body":"import Preloaded\n\n\/- We seek to prove that if f\u2099 : \u211d \u2192 \u211d uniformly converges to f : \u211d \u2192 \u211d \nthen \u2200 a \u2208 \u211d, lim_{n \u2192 \u221e} lim_{x \u2192 a} f\u2099(x) = lim_{x \u2192 a} lim_{n \u2192 \u221e} f\u2099(x) -\/\ntheorem limit_swap (f g a l) (h\u2080 : unif_convergence f g) \n(h\u2081 : fun_limit g a l) : seq_limit (function.swap f a) l := begin\n  intros \u03b5 h\u03b5,\n  have h\u03b52 := div_pos h\u03b5 zero_lt_two,\n  specialize h\u2080 (\u03b5 \/ 2) h\u03b52,\n  specialize h\u2081 (\u03b5 \/ 2) h\u03b52,\n  cases h\u2080 with N\u2080 h\u2080, cases h\u2081 with \u03b4 h\u2081, cases h\u2081 with h\u03b4 h\u2081, unfold function.swap,\n  existsi N\u2080, intros n h, specialize h\u2080 n h,\n  have h := abs_sub_le (f n a) (g a) l,\n  specialize h\u2080 a, specialize h\u2081 a, simp at h\u2081, specialize h\u2081 h\u03b4,\n  have h := lt_of_le_of_lt h (add_lt_add h\u2080 h\u2081), simp at h, assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb0c7163c435d002f65666e":[{"id":209431,"user_id":null,"body":"import tactic\nimport data.nat.parity\n\nopen_locale classical\nopen nat\n\ntheorem solution \n  {p q : \u2115} \n  (hp : prime p) \n  (hq : prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  have : 2 \u2223 p + q,\n  { have : \u00ac even p := not_even_iff.mpr (hp.eq_two_or_odd.resolve_left p_ne_two),\n    have : \u00ac even q := not_even_iff.mpr (hq.eq_two_or_odd.resolve_left q_ne_two),\n    change even (p + q),\n    simp * with parity_simps },\n  obtain \u27e8k, hk\u27e9 := this,\n  have : p < k, { linarith },\n  have : k < q, { linarith },\n  have : p \u2265 2 := hp.two_le,\n  have : q \u2265 2 := hq.two_le,\n  have : k \u2265 2, { linarith },\n  obtain \u27e8b, \u27e8c, h\u2081\u27e9, h\u2082, h\u2083\u27e9 :=\n    exists_dvd_of_not_prime2 \u2039k \u2265 2\u203a (consecutive k \u2039p < k\u203a \u2039k < q\u203a),\n  refine \u27e82, b, c, by cc, by norm_num, h\u2082, _\u27e9,\n  -- This is dumb\n  subst h\u2081,\n  refine lt_of_mul_lt_mul_left _ (show b \u2265 0, from nat.zero_le _),\n  simpa using h\u2083\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209432,"user_id":null,"body":"import tactic\nimport data.nat.prime\nimport data.nat.parity\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  cases nat.odd_iff.2 (or.resolve_left (nat.prime.eq_two_or_odd hp) p_ne_two) with m hm,\n  cases nat.odd_iff.2 (or.resolve_left (nat.prime.eq_two_or_odd hq) q_ne_two) with n hn,\n  have := consecutive (m+n+1) (by linarith) (by linarith),\n  rcases nat.exists_dvd_of_not_prime (by linarith) this with \u27e8b, \u27e8c, hc\u27e9, b_ne_one, c_ne_one\u27e9,\n  use [2, b, c, by linarith, by norm_num],\n  have nonzero : b \u2260 0 \u2227 c \u2260 0, by split; { rintro rfl, linarith, },\n  split; rw [gt_iff_lt, nat.one_lt_iff_ne_zero_and_ne_one],\n  exact \u27e8nonzero.1, b_ne_one\u27e9,\n  exact \u27e8nonzero.2, by {rintro rfl, exact c_ne_one (eq.trans hc (mul_one b)).symm} \u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209433,"user_id":null,"body":"import tactic\nimport data.nat.prime  data.nat.parity\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  cases nat.prime.eq_two_or_odd hp with _ h1,\n    contradiction,\n  cases nat.prime.eq_two_or_odd hq with _ h2,\n    contradiction,    \n  cases nat.odd.add_odd (nat.odd_iff.mpr h1) (nat.odd_iff.mpr h2),\n  have hwp : p < w := by linarith,\n  have hwq : w < q := by linarith,\n  have hw2 : 2 \u2264 w := by linarith [nat.prime.one_lt hp],\n  have hnp := consecutive w hwp hwq,\n  rcases nat.exists_dvd_of_not_prime hw2 hnp with \u27e8b, h1, h2, h3\u27e9,\n  cases h1 with c hc,\n  use [2, b, c],\n  split,\n    rwa [hc, \u2190mul_assoc] at h,\n  split,\n    exact one_lt_two,\n  split,\n    have hb0 : b \u2260 0, intros hb0, rw hb0 at hc, linarith,\n    exact nat.one_lt_iff_ne_zero_and_ne_one.mpr \u27e8hb0, h2\u27e9,\n    have hc0 : c \u2260 0, intros hc0, rw hc0 at hc, linarith,\n    have hc1 : c \u2260 1, intros hc1, rw [hc1, mul_one] at hc, cc,\n    exact nat.one_lt_iff_ne_zero_and_ne_one.mpr \u27e8hc0, hc1\u27e9\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209434,"user_id":657,"body":"import tactic\nimport data.nat.prime\n\nuniverse u\nopen_locale classical\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  have h1 := hp.eq_two_or_odd.resolve_left p_ne_two,\n  have h2 := hq.eq_two_or_odd.resolve_left q_ne_two,\n  have h3 : p + 2 \u2264 q,\n  { unfreezingI {\n    rcases nat.eq_or_lt_of_le p_lt_q with \u27e8rfl, _\u27e9,\n    { rw [nat.succ_eq_add_one, nat.add_mod, h1] at h2, cases h2 },\n    exact h } },\n  have h4 : p < (p + q) \/ 2,\n  { rw [nat.lt_iff_add_one_le, nat.le_div_iff_mul_le' (dec_trivial : 0 < 2)],\n    rw [add_mul, one_mul, mul_two, add_assoc],\n    exact nat.add_le_add_left h3 _ },\n  have h5 : (p + q) \/ 2 < q,\n  { rw [nat.lt_iff_add_one_le, \u2190 nat.succ_eq_add_one, \u2190 nat.add_div_right _ (dec_trivial : 0 < 2)],\n    apply nat.div_le_of_le_mul,\n    rw [two_mul, add_right_comm],\n    exact nat.add_le_add_right h3 _ },\n  have h6 := consecutive _ h4 h5,\n  rw nat.prime_def_lt'' at h6, push_neg at h6, \n  rcases h6 _ with \u27e8b, \u27e8c, h6\u27e9, hb, hc\u27e9, \n  refine \u27e82, b, c, _, dec_trivial, _, _\u27e9,\n  { rw [mul_assoc, \u2190 h6, nat.mul_div_cancel'],\n    rw [nat.dvd_iff_mod_eq_zero, nat.add_mod],\n    simp [h1, h2] },\n  { contrapose! hc, interval_cases b, { simp [h6] }, { tauto } },\n  { contrapose! h6, interval_cases c, { omega }, symmetry, simpa },\n  have := nat.prime.two_le hp, omega,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209435,"user_id":644,"body":"import tactic\nimport data.nat.basic data.nat.parity tactic\n\nuniverse u\nopen_locale classical\nopen nat\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nhave op : \u00ac even p, from not_even_iff.2 (hp.eq_two_or_odd.resolve_left p_ne_two),\nhave oq : \u00ac even q, from not_even_iff.2 (hq.eq_two_or_odd.resolve_left q_ne_two),\nhave heven : even (p + q), from even_add.2 (iff_of_false op oq),\nlet \u27e8k, hk\u27e9 := heven in \nhave hpk : \u00ac nat.prime k, from consecutive k (by linarith) (by linarith),\nhave hp2 : 2 < p, from lt_of_le_of_ne hp.two_le p_ne_two.symm,\nhave hp2 : 2 < q, from lt_of_le_of_ne hq.two_le q_ne_two.symm,\nlet \u27e8b, \u27e8c, hc\u27e9, hb1, hbm\u27e9 := exists_dvd_of_not_prime2 (by linarith) hpk in\n\u27e82, b, c, by rw [mul_assoc, \u2190 hc, hk], by norm_num, hb1, \n  lt_of_not_ge (not_le_of_gt hbm \u2218 (hc.symm \u25b8 mul_le_of_le_one_right (nat.zero_le _)))\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209436,"user_id":106,"body":"import tactic\nimport data.nat.basic\n\nuniverse u\nopen_locale classical\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  have pqe: 2 \u2223 p + q, {\n    cases nat.prime.eq_two_or_odd hp with po po, contradiction,\n    cases nat.prime.eq_two_or_odd hq with pq pq, contradiction,\n    have h := nat.add_mod p q 2, rw [po, pq] at h, simp at h,\n    have h' := @nat.dvd_sub_mod 2 (p + q), rw [h, nat.sub_zero] at h',\n    exact h'\n  },\n  cases pqe with a pq,\n  have h2 : a >= 2, {\n    have h' := add_le_add (nat.prime.two_le hp) (nat.prime.two_le hq),\n    linarith\n  },\n  cases em (nat.prime a) with ha, {\n    have aq := add_lt_add_right p_lt_q q,\n    rw [pq, \u2190two_mul] at aq,\n    have ap := add_lt_add_right p_lt_q p,\n    rw [add_comm q p, pq, \u2190two_mul] at ap,\n    have a2 : 0 < 2, by linarith,\n    specialize consecutive a (iff.elim_left (mul_lt_mul_left a2) ap) (iff.elim_left (mul_lt_mul_left a2) aq),\n    contradiction\n  },\n  {\n    have h := nat.exists_dvd_of_not_prime2 h2 h,\n    cases h with m h, cases h with h r, cases h with n hn, cases r with l r,\n    existsi [2, m, n], split,\n    {\n      rw [hn, \u2190mul_assoc] at pq, exact pq\n    },\n    {\n      split, norm_num, split, linarith,\n      cases n, linarith, cases n, linarith,\n      repeat { rw nat.succ_eq_add_one }, norm_num\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209437,"user_id":null,"body":"import tactic data.nat.basic data.nat.prime\n\nopen nat\n\nlemma aux {n : \u2115} (h\u2081 : 2 \u2264 n) (h\u2082 : \u00acprime n) : \u2203 c d : \u2115, n = c * d \u2227 c > 1 \u2227 d > 1 :=\nbegin\n  rcases exists_dvd_of_not_prime2 h\u2081 h\u2082 with \u27e8c, cdvdn, cge2, cltn\u27e9,\n  use [c, n\/c],\n  split,\n  { exact symm (nat.mul_div_cancel' cdvdn), },\n  { split,\n    { linarith, },\n    { rcases cdvdn with \u27e8m, hm\u27e9,\n      have cpos : 0 < c, linarith,\n      rw hm at cltn \u22a2,\n      rwa [(mul_div_right m cpos), gt_iff_lt, \u2190(mul_lt_mul_left cpos), mul_one], }, },\nend\n\nlemma odd_prime {p : \u2115} : prime p \u2192 p \u2260 2 \u2192 p % 2 = 1 := \u03bb h k, or.elim (prime.eq_two_or_odd h) (\u03bb m, absurd m k) id\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  use 2,\n  obtain \u27e8k, hk\u27e9 : 2 \u2223 (p + q),\n  { apply dvd_of_mod_eq_zero, rw [add_mod, (odd_prime hp p_ne_two), (odd_prime hq q_ne_two)], norm_num, },\n  have h : \u00acprime k := consecutive k (by linarith) (by linarith),\n  rcases aux (by linarith [prime.two_le hp]) h with \u27e8b, c, keqbc, bcgt1\u27e9,\n  exact \u27e8b, c, by rw [hk, keqbc, mul_assoc], \u27e8by linarith, bcgt1\u27e9\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209438,"user_id":null,"body":"import tactic\nimport data.nat.basic\nimport data.nat.prime\nimport data.nat.modeq\n\nimport data.int.basic\nimport data.int.parity\n\nuniverse u\nopen_locale classical\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n    have op : \u00ac nat.even p := nat.not_even_iff.mpr (hp.eq_two_or_odd.resolve_left p_ne_two),\n    have oq : \u00ac nat.even q := nat.not_even_iff.mpr (hq.eq_two_or_odd.resolve_left q_ne_two),\n    have epq : nat.even (p + q) := nat.even_add.2 (by simpa [op]),\n    cases (exists_eq_mul_right_of_dvd epq) with d hd,\n    have compd : \u00ac nat.prime d := consecutive d (by linarith) (by linarith),\n    have d2 : 2 \u2264 d, by linarith [hp.two_le],\n    have d0 : d > 0, by linarith [d2],\n    rcases (nat.exists_dvd_of_not_prime d2 compd) with \u27e8n, hn1, hn2, hn3\u27e9,\n    have npos := nat.pos_of_dvd_of_pos hn1 d0,\n    have nltd := nat.le_of_dvd d0 hn1,\n    refine \u27e82, n, d\/n, _, _, _, _\u27e9,\n    { rwa [mul_assoc, nat.mul_div_cancel' hn1] },\n    norm_num,\n    { exact lt_of_le_of_ne npos hn2.symm },\n    {\n        apply (mul_lt_mul_left npos).mp,\n        rw nat.mul_div_cancel' hn1,\n        simp [lt_of_le_of_ne nltd hn3],\n    },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209439,"user_id":null,"body":"import tactic\nimport data.nat.basic\n\nuniverse u\nopen_locale classical\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  cases nat.prime.eq_two_or_odd hp with h op, exfalso, exact p_ne_two h,\n  cases nat.prime.eq_two_or_odd hq with h oq, exfalso, exact q_ne_two h,\n  have epq : (p + q) % 2 = 0, rw [nat.add_mod, op, oq], norm_num,\n  have d2 : 2 \u2223 (p + q),\n  rw [\u2190nat.sub_zero (p+q), \u2190epq], apply nat.dvd_sub_mod, \n  cases d2 with t pq2t,\n  have plt : p < t, linarith, have tlq : t < q, linarith,\n  have compos := nat.exists_dvd_of_not_prime2 _ (consecutive t plt tlq),\n  cases compos with b h, cases h.1 with c hbc, use 2, use b, use c,\n  split, rwa [hbc, \u2190mul_assoc] at pq2t, split, norm_num,\n  split, linarith, rw gt_iff_lt, apply lt_of_mul_lt_mul_left,\n  rw mul_one, rw \u2190 hbc, exact h.2.2, linarith,\n  linarith only [nat.prime.two_le hp, nat.prime.two_le hq, pq2t],\n  \/- have pla : p < a, rw lt_iff_not_ge', intro alep,\n  have alq := lt_of_le_of_lt alep p_lt_q,\n  have pqlaa := add_lt_add_of_le_of_lt alep alq,\n  rw pq2a at pqlaa, linarith,\n  have alq : a < q, rw lt_iff_not_ge', intro qlea,\n  have aalpq := add_lt_add_of_lt_of_le pla qlea, -\/\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209440,"user_id":null,"body":"import Preloaded\n\nopen nat\n\ntheorem solution \n  {p q : \u2115} \n  (hp : p.prime) \n  (hq : q.prime) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \u2227 a > 1 \u2227 b > 1 \u2227 c > 1\n:= by {\n  -- p and q are both odd, so p + q is even.\n  have p_odd : p % 2 = 1, from hp.eq_two_or_odd.resolve_left p_ne_two,\n  have q_odd : q % 2 = 1, from hq.eq_two_or_odd.resolve_left q_ne_two,\n  have pq_mod2 : (p + q) % 2 = 0, by\n    { rw [\u2190mod_add_mod, p_odd, add_comm, \u2190mod_add_mod, q_odd], norm_num },\n  have pq_even : 2 \u2223 (p + q), by\n    { rw \u2190nat.sub_zero (p + q), rw \u2190pq_mod2, apply dvd_sub_mod, },\n  -- Therefore the average a = (p + q) \/ 2 is a whole number between p and q.\n  obtain \u27e8a, ha\u27e9 := pq_even,\n  have a_lbound : p < a, by { apply (mul_lt_mul_left zero_lt_two).mp, rw \u2190ha, linarith },\n  have a_ubound : a < q, by { apply (mul_lt_mul_left zero_lt_two).mp, rw \u2190ha, linarith },\n  -- Since p and q are successive primes, a must be a composite.\n  have a_nonprime : \u00acprime a := consecutive a a_lbound a_ubound,\n  have two_le_a: 2 \u2264 a, from le_trans hp.two_le (le_of_lt a_lbound),\n  -- Therefore it has two divisors m and n, each > 1:\n  obtain \u27e8m, \u27e8\u27e8n, hmn\u27e9, two_le_m, m_lt_a\u27e9\u27e9 := nat.exists_dvd_of_not_prime2 two_le_a a_nonprime,\n  have m_gt_one : m > 1, by linarith,\n  have n_gt_one : n > 1, by\n    { apply (mul_lt_mul_left (show 0 < m, by linarith)).mp, rw [mul_one, \u2190hmn], exact m_lt_a },\n  -- and this means 2 * m * n = 2 * a = p + q, which completes our proof.\n  have result : p + q = 2 * m * n, by rwa [mul_assoc, \u2190 hmn, ha],\n  use 2, use m, use n, exact \u27e8result, one_lt_two, m_gt_one, n_gt_one\u27e9\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209441,"user_id":null,"body":"import tactic\nimport data.nat.basic\n\nuniverse u\nopen_locale classical\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n    have pq_even : 2 \u2223 (p + q),\n    {   have p_odd : p % 2 = 1 := by cases nat.prime.eq_two_or_odd hp; cc,\n        have q_odd : q % 2 = 1 := by cases nat.prime.eq_two_or_odd hq; cc,\n        have pq_even : (p + q) % 2 = 0,\n            calc (p + q) % 2 = ((p % 2) + (q % 2)) % 2 : nat.add_mod p q 2\n            ... = (1 + 1) % 2 : by rw [p_odd, q_odd]\n            ... = 0 : by ring,\n        exact nat.dvd_of_mod_eq_zero pq_even, \n    },\n    cases pq_even with k hk,\n    have k_nprime : \u00acnat.prime k := consecutive k (by linarith) (by linarith),\n    have k_ge_2 : k \u2265 2 := by linarith [nat.prime.two_le hp],\n    rcases nat.exists_dvd_of_not_prime2 k_ge_2 k_nprime\n        with \u27e8m, \u27e8n, hnm\u27e9, m_ge_two, m_lt_k\u27e9,\n    have n_gt_one : n > 1,\n    {   by_contradiction hn,\n        rw not_lt at hn,\n        have : m*n \u2264 m,\n            rw mul_comm,\n            exact mul_le_of_le_one_left bot_le hn,\n        linarith,\n    },\n    exact \u27e82, n, m, by rw [hk, hnm, mul_comm m n, mul_assoc],\n            by linarith, n_gt_one, by linarith\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209442,"user_id":null,"body":"import tactic\nimport data.nat.basic\n\nuniverse u\nopen_locale classical\n\nlemma add_odds_even {a b : \u2115} : a % 2 = 1 \u2192 b % 2 = 1 \u2192 2 \u2223 a + b := by {\n    intros ha hb,\n    have ha1 := ((@nat.div_mod_unique a 2 1 (a\/2) (by norm_num)).1 \u27e8rfl,ha\u27e9).1,\n    have hb1 := ((@nat.div_mod_unique b 2 1 (b\/2) (by norm_num)).1 \u27e8rfl,hb\u27e9).1,\n    use (a\/2 + b\/2 + 1),\n    rw [mul_add, mul_add],\n    show _ = _ + _ + 1 + 1,\n    rw [add_comm _ 1, add_assoc, add_comm _ 1, \u2190add_assoc, ha1, hb1]\n}\n\nlemma eq_zero_of_zero_dv {a : \u2115} (h : 0 \u2223 a) : a = 0 :=\nexists.elim h (assume c, assume H' : a = 0 * c, eq.trans H' (nat.zero_mul c))\n\nlemma prime_odd {p} : nat.prime p \u2192 p \u2260 2 \u2192 p % 2 = 1 := by {\n    intros hp hnt,\n    cases (nat.mod_two_eq_zero_or_one p) with h h,\n        rw \u2190nat.dvd_iff_mod_eq_zero at h,\n        cases hp with hpt hp,\n        cases hp _ h with h1 h2,\n            injections,\n        rw h2 at hnt,\n        contradiction,\n    assumption\n}\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n    have hae : 2 \u2223 p + q :=\n        add_odds_even (prime_odd hp p_ne_two) (prime_odd hq q_ne_two),\n    have hab : p < (p+q)\/2 \u2227 (p+q)\/2 < q,\n        split,\n            apply @lt_of_le_of_lt _ _ _ (2*p\/2),\n                rw [@nat.mul_div_cancel_left p 2 (by norm_num)],\n            apply nat.div_lt_of_lt_mul,\n            rw [nat.mul_div_cancel' hae, two_mul],\n            exact nat.add_lt_add_left p_lt_q p,\n        rw [@nat.div_lt_iff_lt_mul' _ _ 2 (by norm_num), mul_two],\n        exact nat.add_lt_add_right p_lt_q q,\n    have hac := consecutive _ hab.1 hab.2,\n    unfold nat.prime at hac,\n    push_neg at hac,\n    have hl : 2 \u2264 (p + q) \/ 2,\n        rw @nat.le_div_iff_mul_le' _ _ 2 (by norm_num),\n        show 2 + 2 \u2264 _,\n        apply add_le_add;\n            apply nat.prime.two_le;\n            assumption,\n    cases hac,\n        rw lt_iff_not_ge at hac,\n        contradiction,\n    rcases hac with \u27e8w, hw1, hw2, hw3\u27e9,\n    use [2, w, (p+q)\/(2*w)],\n    split,\n        have hf : (2*w) \u2223 p + q := nat.mul_dvd_of_dvd_div hae hw1,\n        symmetry,\n        exact nat.mul_div_cancel' hf,\n    use two_gt_one,\n    have hh : \u2200 n, n \u2260 0 \u2192 n \u2260 1 \u2192 n > 1,\n        intros,\n        cases n,\n            contradiction,\n        cases n,\n            contradiction,\n        show 0 + 1 < n.succ + 1,\n        apply nat.add_lt_add_right,\n        rw lt_iff_not_ge,\n        exact nat.not_succ_le_zero n,\n    have hwgo : w > 1,\n        apply hh,\n            intro hn,\n            rw hn at *,\n            have hn := eq_zero_of_zero_dv hw1,\n            apply hw3,\n            rw hn,\n        contradiction,\n    use hwgo,\n    apply hh;\n        intro hn;\n        rw [\u2190nat.div_div_eq_div_mul,\n            nat.div_eq_iff_eq_mul_right (lt_trans zero_lt_one hwgo) hw1] at hn,\n        rw [@nat.div_eq_iff_eq_mul_right _ 2 _ (by norm_num) hae] at hn,\n        rw [mul_zero, mul_zero, add_eq_zero_iff] at hn,\n        rw [hn.1,hn.2] at p_lt_q,\n        exact lt_irrefl _ p_lt_q,\n    rw mul_one at hn,\n    apply hw3,\n    rw hn,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209443,"user_id":null,"body":"import tactic\nimport data.nat.basic\nimport data.nat.parity\n\nuniverse u\nopen_locale classical\n\nlemma prime_is_odd {p : \u2115} (pp : nat.prime p) (qq : 2 < p) : \u00acnat.even p :=\nbegin\nintro,\ntidy,\nspecialize pp_right 2 (by tidy),\ncases pp_right; linarith,\nend\n\nlemma odd_add (n m : \u2115) (pp : \u00acnat.even n) (qq : \u00acnat.even m) : nat.even (n + m) :=\nbegin\napply nat.even_add.2,\nsplit;\nintro;\ncontradiction,\nend\n\nlemma two_lt (p : \u2115) (h : nat.prime p) (hh : p \u2260 2) : 2 < p :=\nbegin\napply lt_of_le_of_ne,\napply nat.prime.two_le,\nassumption,\nexact ne.symm hh,\nend\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\nobtain : 2 < p \u2227 2 < q,\n{\n  split;\n  apply two_lt;\n  assumption;\n  assumption,\n},\nuse 2,\nobtain k : \u2203 k, p + q = 2*k,\n{\n  apply odd_add,\n  apply prime_is_odd,\n  exact hp,\n  exact left,\n  apply prime_is_odd,\n  exact hq,\n  exact right,\n},\nhave B : p < k \u2227 k < q, by { split; linarith },\nhave C : \u00ack.prime, by {apply consecutive; linarith},\nobtain \u27e8m, div_h, h2, h3\u27e9 := nat.exists_dvd_of_not_prime2 (by linarith) C,\nobtain \u27e8u, u_prod\u27e9 := div_h,\nuse [m, u],\nsplit,\nrw [h, u_prod],\nring,\nsplit,\nlinarith,\nsplit,\nlinarith,\napply nat.one_lt_iff_ne_zero_and_ne_one.2,\nsplit,\nintro,\nfinish,\nintro,\nrw a at u_prod,\nrw u_prod at h3,\nsimp at h3,\nhave : \u00acm < m, by {exact irrefl m},\nexact this h3,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209444,"user_id":196,"body":"import tactic\nimport data.nat.basic\n\nuniverse u\nopen_locale classical\n\n-- https:\/\/github.com\/leanprover-community\/mathlib\/blob\/34a0c8c5e57b3504d157a7b93069a189054e8b17\/src\/data\/nat\/basic.lean#L612\n@[simp] theorem nat.mod_add_mod (m n k : \u2115) : (m % n + k) % n = (m + k) % n :=\nby have := (nat.add_mul_mod_self_left (m % n + k) n (m \/ n)).symm;\n   rwa [add_right_comm, nat.mod_add_div] at this\n\n-- https:\/\/github.com\/leanprover-community\/mathlib\/blob\/34a0c8c5e57b3504d157a7b93069a189054e8b17\/src\/data\/nat\/basic.lean#L616\n@[simp] theorem nat.add_mod_mod (m n k : \u2115) : (m + n % k) % k = (m + n) % k :=\nby rw [add_comm, nat.mod_add_mod, add_comm]\n\n-- https:\/\/github.com\/leanprover-community\/mathlib\/blob\/34a0c8c5e57b3504d157a7b93069a189054e8b17\/src\/data\/nat\/basic.lean#L619\nlemma nat.add_mod (a b n : \u2115) : (a + b) % n = ((a % n) + (b % n)) % n :=\nby rw [nat.add_mod_mod, nat.mod_add_mod]\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  have h1 := hp.eq_two_or_odd.resolve_left p_ne_two,\n  have h2 := hq.eq_two_or_odd.resolve_left q_ne_two,\n  have h3 : p + 2 \u2264 q,\n  { rcases nat.eq_or_lt_of_le p_lt_q with \u27e8rfl, _\u27e9,\n    { rw [nat.succ_eq_add_one, nat.add_mod, h1] at h2, cases h2 },\n    exact h },\n  have h4 : p < (p + q) \/ 2,\n  { rw [nat.lt_iff_add_one_le, nat.le_div_iff_mul_le' (dec_trivial : 0 < 2)],\n    rw [add_mul, one_mul, mul_two, add_assoc],\n    exact nat.add_le_add_left h3 _ },\n  have h5 : (p + q) \/ 2 < q,\n  { rw [nat.lt_iff_add_one_le, \u2190 nat.succ_eq_add_one, \u2190 nat.add_div_right _ (dec_trivial : 0 < 2)],\n    apply nat.div_le_of_le_mul,\n    rw [two_mul, add_right_comm],\n    exact nat.add_le_add_right h3 _ },\n  have h6 := consecutive _ h4 h5,\n  unfold nat.prime at h6, push_neg at h6, rcases h6 with H|\u27e8b, \u27e8c, h6\u27e9, hb, hc\u27e9,\n  { exact absurd (lt_trans (lt_of_le_of_lt hp.two_le h4) H) (lt_irrefl 2) },\n  refine \u27e82, b, c, _, dec_trivial, _, _\u27e9,\n  { rw [mul_assoc, \u2190 h6, nat.mul_div_cancel'],\n    rw [nat.dvd_iff_mod_eq_zero, nat.add_mod, h1, h2], refl },\n  { cases b, { rw zero_mul at h6, rw h6 at h4, cases h4 },\n    cases b, { exact absurd rfl hb },\n    exact nat.le_add_left _ _ },\n  { cases c, { rw mul_zero at h6, rw h6 at h4, cases h4 },\n    cases c, { rw mul_one at h6, exact absurd h6.symm hc },\n    exact nat.le_add_left _ _ }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209445,"user_id":null,"body":"import tactic\nimport data.nat.basic\n\n\ntheorem mod_add_mod (m n k : \u2115) : (m % n + k) % n = (m + k) % n :=\nby have := (nat.add_mul_mod_self_left (m % n + k) n (m \/ n)).symm;\n   rwa [nat.add_right_comm, nat.mod_add_div] at this\n\n@[simp] theorem add_mod_mod (m n k : \u2115) : (m + n % k) % k = (m + n) % k :=\nby rw [add_comm, mod_add_mod, add_comm]\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  obtain \u27e8B, h\u27e9 : 2 \u2223 (p + q) :=\n  begin\n    rw [nat.dvd_iff_mod_eq_zero, \u2190 mod_add_mod,\n      hp.eq_two_or_odd.resolve_left p_ne_two,\n      \u2190 add_mod_mod, hq.eq_two_or_odd.resolve_left q_ne_two, nat.mod_self],\n  end,\n  have pB : p < B := by linarith,\n  have Bq: B < q := by linarith,\n  use [2],\n  simp,\n  obtain \u27e8b , \u27e8c, hbc\u27e9, \u27e8hb1, hbB\u27e9\u27e9 := nat.exists_dvd_of_not_prime2 (by linarith [hp.1]) (consecutive _ pB Bq),\n  use [b, c],\n  rw [h, hbc, mul_assoc, eq_self_iff_true, true_and],\n  split, exact lt_add_one 1,\n  split,\n  linarith,\n  rw hbc at hbB,\n  convert lt_of_mul_lt_mul_left _ (show 0 \u2264 b, by linarith) ,\n  rw mul_one,\n  exact hbB,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209446,"user_id":17,"body":"import tactic data.nat.basic data.nat.parity\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \n\u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  have hp\u2081 : p % 2 + 2 * (p \/ 2) = 1 + 2 * (p \/ 2) :=\n    congr_arg (\u03bb x, x + 2 * (p \/ 2)) (or.elim (nat.prime.eq_two_or_odd hp)\n    (\u03bb hp\u2081, false.elim (p_ne_two hp\u2081)) (\u03bb hp\u2081, hp\u2081)),\n  have hq\u2081 : q % 2 + 2 * (q \/ 2) = 1 + 2 * (q \/ 2) :=\n    congr_arg (\u03bb x, x + 2 * (q \/ 2)) (or.elim (nat.prime.eq_two_or_odd hq)\n    (\u03bb hq\u2081, false.elim (q_ne_two hq\u2081)) (\u03bb hq\u2081, hq\u2081)),\n  rw nat.mod_add_div at hp\u2081 hq\u2081,\n  have hpq : nat.even (p + q),\n  { existsi p \/ 2 + q \/ 2 + 1,\n    repeat { rw left_distrib },\n    rw [show p + q = (1 + 2 * (p \/ 2)) + (1 + 2 * (q \/ 2)), by cc],\n    ring },\n  cases hpq with a ha,\n  by_cases (nat.prime a),\n  { exfalso,\n    rw [show 2 * a = a + a, by ring] at ha,\n    apply consecutive a,\n    { by_contra hc,\n      rw not_lt at hc,\n      have haq := lt_of_le_of_lt hc p_lt_q,\n      cases (eq_or_lt_of_le hc),\n      { subst h_1,\n        have hc' := add_lt_add_left haq a,\n        rw ha at hc',\n        exact lt_irrefl _ hc' },\n      { have hc' := add_lt_add h_1 haq,\n        rw ha at hc',\n        exact lt_irrefl _ hc' } },\n    { by_contra hc,\n      rw not_lt at hc,\n      have hpa := lt_of_lt_of_le p_lt_q hc,\n      cases (eq_or_lt_of_le hc),\n      { subst h_1,\n        have hc' := add_lt_add_right hpa q,\n        rw ha at hc',\n        exact lt_irrefl _ hc' },\n      { have hc' := add_lt_add hpa h_1,\n        rw ha at hc',\n        exact lt_irrefl _ hc' } },\n    { assumption } },\n  { existsi 2,\n    by_cases ha' : 2 \u2264 a,\n    { have ha' := nat.exists_dvd_of_not_prime2 ha' h,\n      rcases ha' with \u27e8m, \u27e8n, hn\u27e9, h2m, hma\u27e9,\n      existsi m,\n      existsi n,\n      repeat { split },\n      { rw mul_assoc; cc },\n      { exact lt_add_one 1 },\n      { exact h2m },\n      { cases n,\n        { subst hn; assumption },\n        { cases n,\n          { subst hn; rw mul_one at hma; exact false.elim (lt_irrefl _ hma) },\n          { exact (nat.succ_lt_succ (nat.zero_lt_succ _)) } } } },\n    { rw not_lt at ha',\n      cases a,\n      { cases p; cases q; contradiction },\n      { cases a,\n        { cases p; cases q; try { contradiction },\n          cases p; cases q; try { contradiction },\n          injection ha,\n          injection h_1,\n          repeat { rw nat.succ_add at h_2 },\n          contradiction },\n        { exact false.elim (nat.not_succ_le_zero _\n            (nat.le_of_succ_le_succ ha')) } } } }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209447,"user_id":168,"body":"import tactic\nimport data.nat.prime data.nat.modeq\n\ntheorem solution \n  {p q : \u2115} \n  (hp : nat.prime p) \n  (hq : nat.prime q) \n  (p_lt_q : p < q) \n  (p_ne_two : p \u2260 2) \n  (q_ne_two : q \u2260 2) \n  (consecutive : \u2200 k, p < k \u2192 k < q \u2192 \u00ac nat.prime k) : \n\u2203 a b c, p + q = a * b * c \u2227 a > 1 \u2227 b > 1 \u2227 c > 1 := \nbegin\n  cases nat.prime.eq_two_or_odd hp with _ hp1, contradiction,\n  cases nat.prime.eq_two_or_odd hq with _ hq1, contradiction,\n  obtain \u27e8r, req\u27e9 : 2 \u2223 p + q,\n    apply nat.dvd_of_mod_eq_zero,\n    exact @nat.modeq.modeq_add 2 p 1 q 1 hp1 hq1,\n  have hr : 2 \u2264 r, linarith [nat.prime.two_le hp, nat.prime.two_le hq],\n  have : \u00ac nat.prime r, apply consecutive; linarith,\n  obtain \u27e8b, \u27e8c, req\u2082\u27e9, hb2, hbr\u27e9 := nat.exists_dvd_of_not_prime2 hr this,\n  refine \u27e82, b, c, by cc, dec_trivial, hb2, _\u27e9,\n  cases c, rw [req\u2082, nat.mul_zero] at hbr, exact absurd hbr not_lt_bot,\n  cases c, rw [req\u2082, nat.mul_one] at hbr, exact absurd hbr (irrefl b),\n  exact dec_trivial,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb0ce255179590016d613ce":[{"id":209448,"user_id":168,"body":"theorem not_not_not (P : Prop) : \u00ac \u00ac \u00ac P \u2192 \u00ac P := \u03bb h p, h (\u03bb np, np p)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209449,"user_id":645,"body":"import tactic\n\ntheorem not_not_not (P : Prop) : \u00ac \u00ac \u00ac P \u2192 \u00ac P := by cc","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209450,"user_id":null,"body":"theorem not_not_not \n  (P : Prop) :\n  \u00ac \u00ac \u00ac P \u2192 \u00ac P := \nbegin\nintros h hp,\napply h,\nintro h1,\nexact h1 hp,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209451,"user_id":17,"body":"theorem not_not_not (P : Prop) : \u00ac\u00ac\u00acP \u2192 \u00acP := \u03bb hnnnp hp, hnnnp (\u03bb hnp, hnp hp)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209452,"user_id":null,"body":"theorem not_not_not (p) : \u00ac\u00ac\u00acp \u2192 \u00acp := flip (\u2218) $ flip id ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209453,"user_id":null,"body":"theorem not_not_not \n  (P : Prop) : \u00ac \u00ac \u00ac P \u2192 \u00ac P := \u03bbx, \u03bby, (x (\u03bbz, z y))","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209454,"user_id":null,"body":"theorem not_not_not (P : Prop) : \u00ac \u00ac \u00ac P \u2192 \u00ac P := \u03bb nnnp p, nnnp (not_not_intro p)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209455,"user_id":null,"body":"theorem not_not_not \n  (P : Prop) :\n  \u00ac \u00ac \u00ac P \u2192 \u00ac P := \nbegin\n  intros h1 h2,\n  apply h1,\n  intro h3,\n  apply h3 h2,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209456,"user_id":null,"body":"theorem not_not_not \n  (P : Prop) :\n  \u00ac \u00ac \u00ac P \u2192 \u00ac P := \nbegin\n  intros h hy,\n  apply h,\n  intros ye,\n  apply ye,\n  assumption\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209457,"user_id":null,"body":"theorem not_not_not (P : Prop) : \u00ac \u00ac \u00ac P \u2192 \u00ac P := \u03bb h h\u2081, h $ \u03bb h\u2082, h\u2082 h\u2081","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb2c73ff08e28002471b09e":[{"id":209458,"user_id":168,"body":"import tactic\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  cases le_total n m, exact H1 n h,\n  obtain \u27e8k, rfl\u27e9 := int.le.dest h, clear h,\n  induction k with k ih, apply H1, erw add_zero,\n  push_cast, rw [\u2190add_assoc],\n  exact H2 _ (int.le.intro rfl) ih,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209459,"user_id":659,"body":"import data.int.basic tactic\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  apply int.induction_on' n m,\n  { refine H1 _ (le_refl _)},\n  { exact H2},\n  { intros k hk hP,\n    apply H1,\n    linarith\n  }\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209460,"user_id":null,"body":"import tactic.linarith\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  by_cases h: n \u2264 m,\n  { exact H1 n h },\n  {\n    have : \u2203 x:\u2115 , n-m = x:= int.eq_coe_of_zero_le (by linarith),\n    cases this with x hx,\n    have : n = m+x := by linarith,\n    rw this at *,\n    clear h hx this n,\n    specialize H1 m (by refl),\n    induction x with x hx,\n    { simpa using H1 },\n    { simpa [add_assoc] using H2 (m+x) (by linarith) hx }\n  }\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209461,"user_id":null,"body":"import data.nat.basic\nimport tactic\nimport data.int.least_greatest\nimport data.set.basic\n\n\n\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\nby_contra,\n  have lb:\u2203 k:\u2124, \u2200 x:\u2124,  \u00ac P x \u2192 k\u2264 x,\n    use m,\n    intros x hx,\n    by_contra,\n      have px: P x,\n        have xlm :x\u2264 m, linarith, \n        exact H1 x xlm,\n        apply hx px,\n      have ex: \u2203 z, \u00ac P z, \n        use n,\n      have llb: \u2203 (s:\u2124), \u00acP s \u2227 \u2200 (z : \u2124), \u00acP z \u2192 s \u2264 z,\n        exact int.exists_least_of_bdd lb ex,\n      rcases llb with \u27e8s,hns,as\u27e9,\n      have sm1: P (s-1),\n      by_contra,\n       have ms: s\u2264 s-1,\n        exact as (s-1) h, linarith,    \n      have ps: P s,\n        have pm: P m, exact H1 m (le_refl m),\n        have mles: m\u2264 s-1,\n          by_contra,\n          have : s\u2264 m, linarith, \n          have :P s, exact H1 s this,\n           exact hns this,\n           have: P(s-1+1),\n           apply H2 (s-1) mles sm1,\n           norm_num at this,\n           exact hns ps,\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209462,"user_id":null,"body":"import tactic\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  by_cases h : n < m,\n  { exact H1 n (le_of_lt h), },\n  push_neg at h,\n  obtain \u27e8k, hk\u27e9 := show \u2203 (k : \u2115), n = m + k, by\n  { obtain \u27e8c, \u27e8hc, _\u27e9\u27e9 := (le_iff_exists_nonneg_add m n).1 h,\n    use [int.to_nat c, by rwa int.to_nat_of_nonneg hc], },\n  induction k with j IH generalizing n,\n  { exact H1 n (by simp [hk]), },\n  convert H2 (j + m) (by linarith) (IH (j + m) (by linarith) (by rw add_comm)), \n  rwa [add_comm \u2191j, add_assoc, \u2190 int.coe_nat_succ],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209463,"user_id":null,"body":"import tactic\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  have hd : \u2200(d : \u2115), P (m + d),\n  { intros d,\n    induction d with k hk,\n    { simp, exact H1 m (le_refl m) }, \n    push_cast,  \n    rw \u2190add_assoc,\n    exact H2 (m+k) (by linarith) hk },\n  cases le_or_gt n m,\n  { exact H1 n h },\n  convert hd (int.nat_abs (n-m)),\n  have hp : 0 \u2264 n - m := by linarith,\n  simp [int.nat_abs_of_nonneg hp],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209464,"user_id":null,"body":"import tactic\nimport init\n\n\nopen int \nopen nat \n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\nhave h : n \u2264 m \u2228 n > m := le_or_lt _ _,\ncases h,\n{ exact H1 n h },\n{ have h : n \u2265 m := int.le_of_lt h,\n  have : P m := H1 m (le_refl m),\n  have l : \u2200 k : \u2115, P (m + \u2191k) :=\n    \u03bb k, by \n    { induction k with k hk, \n      { simpa, },\n      { have := H2 (m + \u2191k) (by linarith) hk, \n        have : \u2191k + 1 = \u2191(k.succ) := (cast_succ k).symm,\n        have : m + \u2191k + 1 = m + \u2191(k.succ) := by { rw add_assoc, simp },\n        rwa \u2190 this, } },\n  have : n - m \u2265 0 := by linarith,\n  have : m + \u2191(nat_abs (n - m)) = n := by {rw nat_abs_of_nonneg this, linarith },\n  rw \u2190 this, \n  exact l _ }, \nend\n\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209465,"user_id":null,"body":"import data.int.basic\nimport tactic.linarith\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  have key : \u2200 k : \u2115, P (m + k), {\n    intros k,\n    induction k,\n    case nat.zero : {\n      apply H1,\n      norm_num,\n    },\n    case nat.succ : {\n      norm_num,\n      rw \u2190 add_assoc,\n      apply H2,\n      { linarith },\n      { assumption },\n    }\n  },\n  cases le_total n m with h h,\n  case or.inl : {\n    apply H1,\n    exact h,\n  },\n  case or.inr : {\n    have hnm : n = m + (n - m), by ring,\n    rw hnm,\n    rw \u2190 int.to_nat_of_nonneg (sub_nonneg.mpr h),\n    apply key,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209466,"user_id":null,"body":"import tactic\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  by_cases h : n \u2264 m,\n  { exact H1 _ h, },\n  { have ind : \u2200 (k : \u2115), P(m+k),\n    { intro k,\n      induction k with k ih,\n      { specialize H1 m (le_refl _), simpa, },\n      { specialize H2 (m+k) (by linarith) ih,  \n        convert H2 using 1, rw add_assoc, simp, } },\n    cases (int.eq_coe_of_zero_le (show 0 \u2264 n -m, by linarith)) with k hk,\n    specialize ind k, convert ind, linarith, },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209467,"user_id":null,"body":"import tactic\n\nopen tactic\n\ntheorem int_induction (P : \u2124 \u2192 Prop) (m : \u2124) (H1 : \u2200 n \u2264 m, P n)\n  (H2 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (n+1)) (n : \u2124) : P n :=\nbegin\n  by_cases m \u2264 n,\n  {\n    specialize H1 m,\n    simp at H1,\n    have h\u2082 : \u2200(k : \u2115), P (m + k),\n    {\n      intro k,\n      induction k with k kh,\n      {\n        simp,\n        exact H1,\n      },\n      {\n        specialize H2 (m + k),\n        simp,\n        rw <-add_assoc,\n        apply H2,\n        exact int.le.intro rfl,\n        exact kh,\n      }\n    },\n    have h\u2083 := int.le.dest h,\n    cases h\u2083 with k h\u2083,\n    specialize h\u2082 k,\n    rw h\u2083 at h\u2082,\n    exact h\u2082,\n  },\n  {\n    specialize H1 n,\n    rw not_le at h,\n    apply H1,\n    apply le_of_lt,\n    exact h,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb52b7336f17a00010a3d2a":[{"id":209468,"user_id":196,"body":"import algebra.associated algebra.geom_sum\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) :=\nbegin\n  rw is_unit_iff_exists_inv at hu \u22a2, cases hu with b hb,\n  use b * geom_series (-(r*b)) n,\n  rw [\u2190 mul_assoc, add_mul, hb, \u2190 sub_neg_eq_add, mul_comm, geom_sum_mul_neg,\n      neg_mul_eq_mul_neg, mul_pow, hr, zero_mul, sub_zero]\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209469,"user_id":168,"body":"import algebra.associated algebra.geom_sum\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) :=\nbegin\n  rw is_unit_iff_exists_inv at *,\n  obtain \u27e8v, huv\u27e9 := hu,\n  existsi v * geom_series (-(r * v)) n,\n  rw [\u2190mul_assoc, add_mul, huv, \u2190sub_neg_eq_add, mul_comm, geom_sum_mul_neg],\n  rw [neg_mul_eq_mul_neg, mul_pow, hr, zero_mul, sub_zero],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209470,"user_id":null,"body":"import algebra.associated\nimport tactic\n\nlemma formula {R : Type*} [comm_ring R] {x : R} {n : \u2115} : \n  (1 - x) * (finset.sum (finset.range n) (fun i : \u2115, x ^ i)) = 1 - x^n :=\nbegin \n  induction n with m hm,\n  {\n    simp,\n  },\n  {\n    rw [finset.range_add_one,finset.sum_insert,mul_add,hm,pow_succ],\n    ring,\n    exact finset.not_mem_range_self,\n  }\nend\n\nlemma one_sub_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) :\n  is_unit (1 - r) :=\nbegin \n  rw is_unit_iff_exists_inv,\n  use (finset.sum (finset.range n) (fun i : \u2115, r ^ i)),\n  rw [formula, hr],\n  simp,\nend\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) :=\nbegin \n  rw \u2190 (units.is_unit_mul_units (u+r) (hu.unit)\u207b\u00b9),\n  rw [right_distrib,is_unit.mul_coe_inv],\n  rw \u2190 sub_neg_eq_add ,\n  apply one_sub_nilpotent,\n  swap 3,\n  exact n,\n  exact 1,\n  rw [neg_eq_neg_one_mul,mul_pow,mul_pow,hr],\n  simp,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209471,"user_id":null,"body":"import algebra.associated\n\n\ndef geo_seq {R : Type*} [comm_ring R] (r:R): (\u2115 \u2192 R) \n  | 0   := 1\n  | (n+1) :=  geo_seq n + r^(n+1)\n\nlemma sum_geo_seq {R:Type*} [comm_ring R] (r:R) (n:\u2115) :\n  (1-r)* geo_seq r n = 1-r^(n+1) :=\nbegin\n  induction n with n hn,\n  simp [geo_seq],\n  rw [geo_seq,mul_add,hn,nat.succ_eq_add_one,sub_mul,\n      one_mul,pow_succ,pow_succ,pow_succ,sub_add_sub_cancel],\nend \n\nlemma helper {R:Type*} [comm_ring R] {r:R} {n:\u2115} (h:r^n=0) :\n  is_unit (1-r):=\nbegin\n  have inv := sum_geo_seq r n,\n  rw [pow_succ,h,mul_zero,sub_zero] at inv,\n  exact is_unit_of_mul_eq_one (1 - r) (geo_seq r n) inv,\nend\n\n\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) :=\nbegin\n  cases hu with x hx,\n  have h1: (x:R)+r = u*(1-(-x.inv*r)):= by simp [\u2190 hx,mul_add],\n  have h2: (-x.inv*r)^n=0 := by rw [mul_pow,hr,mul_zero],\n  have h3:= helper h2,\n  rw [\u2190 hx,h1,mul_comm,\u2190 hx],\n  exact (units.is_unit_mul_units (1- -x.inv*r) x).2 h3,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209472,"user_id":null,"body":"import algebra.associated\n\nlemma one_plus_nilp  {R : Type*} [comm_ring R] {r : R} {n : \u2115} (hr : r ^ n = 0) : is_unit (1 + r) := begin\n  revert r,\n  induction n with n hn,\n  { intros r nilp,\n    have :  r = 0,\n    rw [\u2190 mul_one r, \u2190 pow_zero r, nilp, mul_zero],\n    rw [this, add_zero],\n    exact is_unit_one},\n  intros r hr,\n  cases n,\n  { rw [\u2190 pow_one r, hr, add_zero],\n    exact is_unit_one},\n  have product: (1+r) * (1+(-r))= (1-r * r),\n  { rw [add_mul, mul_add, mul_add, add_assoc],\n    simp,\n    exact (sub_eq_add_neg 1 (r * r)).symm,},\n  have : is_unit (1-r * r),\n  { rw sub_eq_add_neg,\n    have : (-(r * r))^(nat.succ n)= 0,\n    rw [neg_pow, mul_pow, \u2190 pow_add],\n    have : n.succ + n.succ = n.succ.succ + n,\n    { repeat {rw nat.succ_eq_add_one},\n      simp [add_assoc, add_comm],},\n    rw [this, pow_add, hr],\n    simp [mul_zero, zero_mul],\n    exact hn this,},\n    rw [\u2190 product, is_unit.mul_iff] at this,\n    exact this.left,\nend\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0)\n  (hu : is_unit u) : is_unit (u + r) :=\n  begin\n    cases u_unit:hu with ux hu\u2080,\n    cases ux with u u' mul_r mul_l,\n    cases hu\u2080,\n    revert r,\n    intros r nilp,\n    have : (u + r) = u* (1 + u'* r),\n    { rw [mul_add, \u2190 mul_assoc, mul_r],\n      simp},\n    rw [this, is_unit.mul_iff],\n    split, exact hu,\n    have other_nilp: (u' * r)^n = 0,\n    rw mul_pow,\n    simp [nilp],\n    exact one_plus_nilp other_nilp,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209473,"user_id":null,"body":"import algebra.associated\nimport algebra.geom_sum\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) :=\nbegin\n  have geo_sum := commute.mul_geom_sum\u2082 (commute.all u (-r)) n,\n  rw [sub_neg_eq_add, neg_pow, hr, mul_zero, sub_zero] at geo_sum,\n  rw is_unit_iff_exists_inv,\n  cases is_unit.exists_right_inv hu with a ha,\n  use (geom_sum\u2082 u (-r) n) * a^n,\n  rw [\u2190 mul_assoc, geo_sum, \u2190 mul_pow, ha, one_pow],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209474,"user_id":null,"body":"import tactic\nimport algebra.associated \n\ndef inv {R : Type*} [comm_ring R] : \u2115 \u2192 R \u2192 R \u2192 R\n| 0     v _ := 0\n| (m+1) v r := (inv m v r) + (-v * r)^m\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) := \nbegin\n  rw is_unit_iff_exists_inv at *,\n  cases hu with v hv,\n  have h : \u2200m, (u + r) * v * (inv m v r) = 1 + (-1)^(m+1) * v^m * r^m,\n  { intros m,\n    induction m with d hd,\n    { simp [inv] },\n    rw [nat.succ_eq_add_one, inv, mul_add, hd, add_mul, hv],    \n    ring_exp,\n    simp [mul_one] },\n  use [v * inv n v r],\n  simp [\u2190mul_assoc, h n, hr]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209475,"user_id":644,"body":"import data.polynomial\n\nopen polynomial\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) := \nhave hr' : (-r)^n = 0, by rw [neg_eq_neg_one_mul, mul_pow, hr, mul_zero],\nis_unit_of_dvd_unit\n  (show u + r \u2223 u ^ n, from\n    suffices (X - C (-r)).eval u \u2223 (X ^ n).eval u, by simpa [hr] using this,\n    have X - C (- r) \u2223 X ^ n, from dvd_iff_is_root.2 (by simp [is_root, hr']),\n    let \u27e8f, hf\u27e9 := this in \u27e8f.eval u, by rw [\u2190 eval_mul, hf]\u27e9)\n  (is_unit.pow n hu)","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209476,"user_id":106,"body":"import algebra.associated\n\ndef pow_sum {R : Type*} [comm_ring R] : \u2115 \u2192 R \u2192 R\n| 0 r := 1\n| (n+1) r := r ^ n.succ + pow_sum n r\n\ntheorem unit_add_nilpotent {R : Type*} [comm_ring R] {u r : R} {n : \u2115} (hr : r ^ n = 0) \n  (hu : is_unit u) : is_unit (u + r) :=\nbegin\n  cases n, {\n    simp at *,\n    have hr : r = 0, {\n      have h' : - (0 * r) + 0 * r + 0 * r = - (0 * r) + 0 * r, by rw [add_assoc, \u2190right_distrib 0 0 r, zero_add],\n      have h' : 1 * r = 0, by { rw hr, rw [add_left_neg, zero_add] at h', exact h' },\n      rw one_mul at h', assumption\n    },\n    rw hr, simp,\n    cases hu with hu heq, existsi hu, assumption\n  },\n  {\n    cases hu with hu equ, cases hu with _ v huv hvu, cases equ, clear equ,\n    have hu : v * (u + r) = 1 + (v * r), by rw [left_distrib, hvu],\n    have huv' : (1 + v * r) * pow_sum n (- v * r) = 1 - (-v * r) ^ n.succ, {\n      clear hr,\n      induction n with n ih; intros,\n      {\n        unfold pow_sum, simp at *\n      },\n      {\n        unfold pow_sum,\n        rw [left_distrib, right_distrib, ih],\n        rw [one_mul, pow_succ _ n.succ], simp,\n        rw [add_comm, \u2190add_assoc, sub_add], simp\n      }\n    },\n    rw [mul_pow, hr, mul_zero, sub_zero, \u2190hu, mul_comm, \u2190mul_assoc, mul_comm] at huv',\n    have hvu' : (pow_sum n (-v * r) * v) * (u + r) = 1, by rw [mul_comm, huv'],\n    existsi { units . val := u + r, inv := pow_sum n (-v * r) * v, val_inv := huv', inv_val := hvu' },\n    simp,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209477,"user_id":null,"body":"import algebra.associated tactic algebra.geom_sum\n\nvariables {R : Type*} [comm_ring R]\n\n-- Unnecessarily used induction in my previous submission!\nlemma is_unit_one_sub_of_is_nilpotent {r : R} {a : \u2115} (h : r ^ a = 0) : is_unit (1-r) :=\nbegin\n  have h\u2082 := geom_sum_mul r a,\n  rw [h, mul_comm, \u2190neg_sub, neg_eq_neg_one_mul, mul_assoc, \u2190neg_eq_neg_one_mul, zero_sub, neg_inj] at h\u2082,\n  exact is_unit_of_mul_eq_one _ _ h\u2082,\nend\n\ntheorem unit_add_nilpotent {u r : R} {n : \u2115} (hr : r ^ n = 0) (hu : is_unit u) : is_unit (u + r) :=\nbegin\n  rcases is_unit_iff_dvd_one.mp hu with \u27e8v, hv\u27e9,\n  have h\u2082 : u + r = u * ( 1 - (-v*r)), \n  { simp only [neg_mul_eq_neg_mul_symm, sub_neg_eq_add, mul_add, mul_one, add_right_inj, \u2190mul_assoc, \u2190hv, one_mul], },\n  rw h\u2082, refine is_unit.mul hu _, apply is_unit_one_sub_of_is_nilpotent, rw [mul_pow, hr, mul_zero]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb718d0e7c54e001a6e03b8":[{"id":209478,"user_id":null,"body":"import Preloaded\nimport tactic.linarith\n\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\n  intro g, specialize g 0, have ez : even 0, existsi 0, refl, \n  have h := g ez, rcases h with \u27e8p, q, h\u27e9, rcases h with \u27e8hp, hq, s\u27e9,\n  have pz : p = 0, linarith, cases hp, exact (hp_left pz),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209479,"user_id":null,"body":"import Preloaded tactic.linarith\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  by_contradiction,\n  obtain \u27e8p, \u27e8q, \u27e8hp, \u27e8hq, sum\u27e9\u27e9\u27e9\u27e9 := h 0 (by norm_num),\n  linarith [nat.prime.pos (nat.prime_iff.2 hp)],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209480,"user_id":null,"body":"import Preloaded\n\n\n\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\n  intro gb,\n  specialize gb 0,\n  have h\u2081 : even 0 := by norm_num,\n  have h\u2082 := gb h\u2081,\n  have h\u2083 : \u00acprime 0 := by norm_num,\n  cases h\u2082 with p hp,\n  cases hp with q hq,\n  rcases hq with \u27e8pr_p, pr_q, p_pl_q\u27e9,\n  simp at p_pl_q,\n  rcases p_pl_q with \u27e8p0, q0\u27e9,\n  rw p0 at pr_p,\n  apply h\u2083,\n  exact pr_p,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209481,"user_id":null,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\n  change \u00ac \u2200 n, even n \u2192 \u2203 p q, prime p \u2227 prime q \u2227 p+q = 2*n,\n  push_neg,\n  use 0,\n  split,\n  {\n    simp,\n  },\n  {\n    intros p q hp hq h,\n    rw mul_zero at h,\n    have : p=0 \u2227 q=0 := add_eq_zero_iff.mp h,\n    rw this.1 at hp,\n    have :\u00ac prime 0 := by simp,\n    exact this hp,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209482,"user_id":null,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\nhave h: even 0,\nnorm_num,\nintro h',\nhave h'' := h' 0 h,\ncases h'' with p,\ncases h''_h with q,\ncases h''_h_h with ha haa,\ncases haa with hb hc,\nlet hp : p>0,\nexact pos_iff_ne_zero.mpr (prime.ne_zero ha),\nlet hq : q>0,\nexact pos_iff_ne_zero.mpr (prime.ne_zero hb),\nhave h2 : p+q >0,\nexact add_pos hp hq,\nrw hc at h2,\nlinarith,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209483,"user_id":null,"body":"import Preloaded\nimport data.nat.basic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  by_contradiction h,\n  obtain \u27e8p, q, hp, hq, hz\u27e9 := h 0 nat.even_zero,\n  rw mul_zero at hz,\n  obtain \u27e8rfl, rfl\u27e9 := add_eq_zero_iff.mp hz,\n  exact hp.ne_zero rfl,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209484,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro h,\n  rcases h 0 (by simp) with \u27e8p, q, pprime, qprime, huh\u27e9,\n  dsimp only [nat.prime] at pprime qprime,\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209485,"user_id":null,"body":"import Preloaded\n\nopen nat\n\ntheorem goldbach_disproof : \u00ac goldbach := \nassume h,\nlet \u27e8p, q, hp, hq, hpq\u27e9 := h 0 even_zero in\nhave r : p = 0 \u2227 q = 0, from eq_zero_of_add_eq_zero (mul_zero 2 \u25b8 hpq),\nshow false, from hp.ne_zero r.left","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209486,"user_id":644,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  assume h,\n  rcases h 0 (by norm_num) with \u27e8p, q, hp, hq, h\u27e9,\n  simp at h,\n  exact absurd hp (h.1.symm \u25b8 by norm_num)\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209487,"user_id":196,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach :=\n\u03bb H, absurd (H 0 dec_trivial) $ \u03bb \u27e8p, q, hp, hq, h\u27e9, hp.ne_zero $ (add_eq_zero_iff.1 h).1\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209488,"user_id":null,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin  \n  intros h,\n  specialize h 0 (by norm_num),\n  rcases h with \u27e8p, q, hp, hq, hs\u27e9,\n  have t:=nat.eq_zero_of_add_eq_zero hs,\n  exact (nat.prime.ne_zero hp) t.left,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209489,"user_id":191,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro h,\n  specialize h 0 nat.even_zero,\n  rw mul_zero at h,\n  rcases h with \u27e8p, q, h\u27e9,\n  rw add_eq_zero_iff at h,\n  rcases h with \u27e8hp, hq, p0, q0\u27e9,\n  rw p0 at hp,\n  cases hp with wrong h,\n  linarith\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209490,"user_id":null,"body":"import Preloaded\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\n  intro h, specialize h 0 nat.even_zero,\n  rcases h with \u27e8p, q, pp, pq, ez\u27e9,\n  apply ne_of_gt (add_pos pp.pos pq.pos) ez\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209491,"user_id":null,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro h,\n  obtain \u27e8p, q, prime_p, prime_q, sum_p_q\u27e9 := h 0 \u27e80, rfl\u27e9,\n  have p_pos := prime_p.1,\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209492,"user_id":106,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro h,\n  specialize h 0, simp at h,\n  cases h with p h, cases h with hp h,\n  cases h with q h, cases h with hq h,\n  cases h with ep eq, rw ep at hp,\n  have hp := nat.prime.ne_zero hp, simp at hp, exact hp\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209493,"user_id":null,"body":"import Preloaded\n\nopen nat\n\ntheorem goldbach_disproof : \u00acgoldbach :=\nbegin\n  intro h,\n  specialize h 0 \u27e80, rfl\u27e9,\n  rcases h with \u27e8p, q, hp, hq, bad\u27e9,\n  have h : 1 + 1 < p + q, { simp only [add_lt_add, prime.one_lt hp, prime.one_lt hq]},\n  rw [bad, \u2190not_le] at h, exact h (nat.zero_le 2),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209494,"user_id":null,"body":"import Preloaded\nimport data.nat.parity\nimport data.nat.prime\n\nopen nat\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  refine not_ball.mpr _,\n  use 0,\n  refine and.intro even_zero _,\n\n  refine not_exists.mpr _,\n\n  intro x,\n\n  refine not_exists.mpr _,\n\n  intro y,\n\n  refine not_and.mpr _,\n\n  intro px,\n\n  refine not_and.mpr _,\n\n  intro py,\n\n  norm_num,\n\n  intro x_pos,\n\n  have zero_not_prime : \u00ac prime 0 := of_to_bool_ff rfl,\n\n  intro abs,\n\n  rw \u2190 abs at zero_not_prime,\n\n  exact zero_not_prime py,\n\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209495,"user_id":null,"body":"import Preloaded tactic\n\nimport data.nat.prime\nimport data.nat.parity\n\nopen nat\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  change \u00ac(\u2200 n, even n \u2192 \u2203 p q, prime p \u2227 prime q \u2227 p + q = 2 * n),\n  rw not_forall,\n  use 0,\n  push_neg,\n  split,\n  exact even_zero,\n  intros p q hp hq,\n  rw mul_zero,\n  have hppos : 0 < p, exact prime.pos hp,\n  have hqpos : 0 < q, exact prime.pos hq,\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209496,"user_id":null,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n    intro g,\n    specialize g 0,\n    norm_num at g,\n    cases g with p h,\n    cases h with p_prime h,\n    cases h with q h,\n    cases h with q_prime h,\n    cases h with p_zero q_zero,\n    cases p_prime,\n    finish,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209497,"user_id":null,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro h,\n  rcases h 0 nat.even_zero with \u27e8p, q ,hp, hq, hpq\u27e9,\n  linarith [hp.1],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209498,"user_id":null,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro h,\n  rcases h 0 (by simp)  with \u27e8p, q ,hp, hq, hpq\u27e9,\n  have := nat.le_add_left p q,\n  rw [add_comm, hpq] at this,\n  linarith [nat.prime.two_le hp],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209499,"user_id":null,"body":"import Preloaded\nopen nat\n\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\n    by_contra hf,\n    rcases hf 0 \u27e80, rfl\u27e9 with \u27e8p, q, p_prime, q_prime, hpq\u27e9,\n    simp at hpq,\n    cases hpq with hpf hqf,\n    have zero_not_prime : \u00ac prime 0,\n        exact of_to_bool_ff rfl,\n    rw hpf at p_prime,\n    exact zero_not_prime p_prime,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209500,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intros h,\n  specialize h 0 nat.even_zero,\n  rcases h with \u27e8p, q, hp, hq, h\u27e9,\n  have h' : p + q \u2265 4 := by linarith [hp.1, hq.1],\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209501,"user_id":null,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro g, have g0 := g 0 _, swap, finish,\n  rcases g0 with \u27e8p,q,Pp,Pq,pq0\u27e9,\n  rw mul_zero at pq0,\n  have p2 := nat.prime.two_le Pp, finish,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209502,"user_id":null,"body":"import Preloaded tactic\nopen nat\ntheorem goldbach_disproof : \u00ac goldbach := \nbegin\nintro h,\nspecialize h 0 even_zero,\nrcases h with \u27e8 p,q,hp,hq,hpq\u27e9,\nreplace hp:=hp.1,\nreplace hq:=hq.1,\nlinarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209503,"user_id":null,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n    intro h,\n    rcases h 0 (nat.even_iff.mpr rfl) with \u27e8p, q, hp, hq, hpq\u27e9,\n    replace hp := hp.1,\n    replace hq := hq.1,\n    linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209504,"user_id":null,"body":"import Preloaded\nimport tactic\n\nopen nat\n\nlemma exists_not {\u03b1} {p : \u03b1 \u2192 Prop} : (\u2203 x, \u00ac p x) \u2192 (\u00ac \u2200 x, p x) := by tautology\n\ntheorem goldbach_disproof : \u00ac goldbach := begin\n  rw goldbach.equations._eqn_1,\n  apply exists_not,\n  use 0,\n  apply not_imp.mpr,\n  split,\n  exact even_zero,\n  rw mul_zero,\n  apply not_exists_of_forall_not,\n  intro p,\n  apply not_exists_of_forall_not,\n  intro q,\n  dsimp [prime],\n  apply not_and.mpr,\n  intro hp,\n  apply not_and.mpr,\n  intro hq,\n  intro hz,\n  have : p = 0, from (eq_zero_of_add_eq_zero hz).left,\n  have : 2 \u2264 0, from this \u25b8 hp.left,\n  finish,\n  exact decidable.is_true even_zero,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209505,"user_id":null,"body":"import Preloaded tactic\nopen nat\n\ntheorem goldbach_disproof : \u00ac goldbach := by\n{\n  intro hw,\n  rcases hw 0 even_zero with \u27e8p, q, hpp, hqp, hs\u27e9,\n  have hf := add_lt_add (prime.pos hpp) (prime.pos hqp),\n  linarith,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209506,"user_id":null,"body":"import Preloaded\n\nopen nat \n\ntheorem goldbach_disproof : \u00ac goldbach := \nassume h,\nlet \u27e8p, q, hp, hq, hpq\u27e9 := h 0 even_zero in\nhave r : p = 0 \u2227 q = 0, from eq_zero_of_add_eq_zero (mul_zero 2 \u25b8 hpq),\nhave p \u2260 0, from assume p_zero,\n    have \u00ac p < 2, from not_lt.mpr hp.left,\n    have p < 2, from symm p_zero \u25b8 (zero_lt_succ 1),\n    absurd \u2039p < 2\u203a \u2039\u00ac p < 2\u203a,\nabsurd r.left \u2039p \u2260 0\u203a\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209507,"user_id":null,"body":"import Preloaded\n\nopen nat \n\ntheorem goldbach_disproof : \u00ac goldbach := \nassume h,\nlet \u27e8p, q, hp, hq, hpq\u27e9 := h 0 even_zero in\nhave r : p = 0 \u2227 q = 0, from eq_zero_of_add_eq_zero (mul_zero 2 \u25b8 hpq),\nhave p \u2260 0, from assume p_zero,\n    have \u00ac prime 0, from of_as_true trivial,\n    \u2039\u00ac prime 0\u203a (p_zero \u25b8 hp),\nshow false, from \u2039p \u2260 0\u203a r.left","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209508,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro H,\n  obtain \u27e8p, q, hp, hq, hpq\u27e9 := H 0 (by norm_num),\n  have : p \u2265 2 := hp.two_le,\n  have : q \u2265 2 := hq.two_le,\n  linarith,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209509,"user_id":17,"body":"import Preloaded tactic\n\ntheorem goldbach_disproof : \u00ac goldbach :=\nbegin\n  intro hc,\n  rcases (hc _ (exists.intro 0 rfl)) with \u27e8p, q, hp, hq, hpq\u27e9,\n  clear hc,\n  cases p; cases q; try { contradiction },\n  clear hq hpq,\n  cases hp with hc _,\n  have hc' : 2 \u2264 0 \u2192 false, by omega,\n  exact hc' hc\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209510,"user_id":657,"body":"import Preloaded\n\nopen nat\n\ntheorem goldbach_disproof : \u00ac goldbach := begin\nunfold goldbach, push_neg, existsi 0, split, simp only [even_zero],\nintros,\nby_cases prime p,\n  swap, left, assumption,\nby_cases prime q,\n  swap, right, left, assumption,\nright, right,\nintro h, simp only [add_eq_zero_iff, mul_zero] at h,\nrw h.left at *, \nunfold prime at *, norm_num at *, \nassumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209511,"user_id":168,"body":"import Preloaded\n\ntheorem goldbach_disproof : \u00ac goldbach :=\n\u03bb h, let \u27e8p, q, hp, hq, eq\u27e9 := h 0 dec_trivial in\n  absurd (nat.eq_zero_of_add_eq_zero_right eq) (nat.prime.ne_zero hp)\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb801967cd701001e52d668":[{"id":209512,"user_id":null,"body":"import data.int.basic\n\nimport data.int.basic\nimport tactic\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n    split; intro h; cases h with q mul,\n    use 4 * q,\n    rw mul,\n    apply mul_left_comm,\n    use (5 * q - a),\n    rw [mul_sub, mul_left_comm, \u2190mul],\n    ring,\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b :=\nbegin\n    split; intro h; cases h with q mul,\n    use (4 * q - 21 * a),\n    rw [mul_sub, mul_left_comm, \u2190mul],\n    ring,\n    use (100 * q - 21 * b),\n    rw [mul_sub, mul_left_comm, \u2190mul],\n    ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209513,"user_id":null,"body":"import data.int.basic\nimport tactic\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a := begin\n  split; intro H; cases H with k K,\n  use (4 * k),\n  rw [K], ring,\n  use (5 * k - a),\n  symmetry,\n  calc 19 * (5 * k - a) = 5 * (19 * k) - 19 * a : by ring\n    ... = 5 * (4 * a) - 19 * a : by rw [K]\n    ... = a : by ring,\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b := begin\n  rw [nineteen_dvd (100 * a + b)],\n  apply dvd_iff_dvd_of_dvd_sub,\n  use (21 * a),\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209514,"user_id":null,"body":"import data.int.gcd tactic.ring\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a := \nbegin\n  split,\n  { rintro \u27e8k, rfl\u27e9, use 4*k, ring, },\n  { intro h, rw mul_comm at h, apply int.dvd_of_dvd_mul_left_of_gcd_one h, norm_num, },\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b := \nbegin\n  rw [nineteen_dvd (100*a+b), \u2190 @dvd_add_left _ _ _ (a+4*b) _ (show 19\u2223399*a, by {use 21*a, ring})],\n  ring_nf,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209515,"user_id":null,"body":"import data.int.basic tactic\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n  split,\n  { intros h, \n    apply dvd_mul_of_dvd_right, \n    apply h, },\n  { intros h,     \n    cases dvd_mul_of_dvd_right h 5 with b hb,\n    use (b - a),\n    linarith, }, \nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b :=\nbegin\n  split,\n  { intros h, \n    cases dvd_mul_of_dvd_right h 4 with c hc,\n    use (c - 21 * a),\n    linarith, },\n  { intros h,\n    cases dvd_mul_of_dvd_right h 100 with c hc,\n    use (c - 21 * b),\n    linarith, }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209516,"user_id":null,"body":"import data.int.basic\nimport tactic\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n  split,\n  intro h, cases h with k h,\n  rw[h, mul_comm 19 k, \u2190 mul_assoc], simp,\n  \n  intro h, cases h with k h, \n  use (3 * a - 14 * k),\n  rw [mul_sub, mul_comm 14 k, \u2190 mul_assoc 19 k 14, \u2190 h], ring,\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b :=\nbegin\n  split, intro h,\n  have puppy := (nineteen_dvd (100 * a + b)).1 h,\n  have bunny := dvd_mul_of_dvd_left (dvd_refl 19) (21 * a),\n  cases puppy with k\u2081 puppy, cases bunny with k\u2082 bunny,\n  use k\u2081 - k\u2082, rw[mul_sub, \u2190 puppy, \u2190 bunny], ring,\n\n  intro h, apply (nineteen_dvd (100 * a + b)).2,\n  have bunny := dvd_mul_of_dvd_left (dvd_refl 19) (21 * a),\n  cases h with k\u2081 h, cases bunny with k\u2082 bunny,\n  use k\u2081 + k\u2082, rw[mul_add 19 k\u2081 k\u2082, \u2190 h, \u2190 bunny], ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209517,"user_id":null,"body":"import data.int.basic tactic\nopen nat int \n\nlemma not_dvd_of_pos_of_lt {a b : \u2115} (h1 : 0 < b) (h2 : b < a) : \u00ac a \u2223 b :=\nbegin\n  rintros \u27e8c, rfl\u27e9,\n  rcases eq_zero_or_pos c with (rfl | hc),\n  { exact lt_irrefl 0 h1 },\n  { exact not_lt.2 (le_mul_of_pos_right hc) h2 },\nend\n\ntheorem nineteen_dvd_nat (a : \u2115) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n  split; intros H,\n  {\n    rcases H with \u27e8c, Hc\u27e9,\n    existsi (4*c), rw Hc,\n    ring,\n  },\n  {\n    have H19 : nat.prime (19), by norm_num,\n    rw prime.dvd_mul H19 at H, \n    rcases H; try {assumption},\n    {\n      exfalso,\n      have := @not_dvd_of_pos_of_lt 19 4 (by norm_num) (by norm_num), \n      solve_by_elim,\n    }\n  }\nend\n\ntheorem nineteen_dvd : \u2200 a:\u2124, 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\nintros a, \ninduction a with k\u2081 k\u2082,\n{\n  simp only [of_nat_eq_coe],\n  convert nineteen_dvd_nat k\u2081 using 1,\n  all_goals{simp only [eq_iff_iff], apply int.coe_nat_dvd},\n},\n{\n  rw [neg_succ_of_nat_eq,dvd_neg, \u2190neg_mul_eq_mul_neg,dvd_neg], \n  convert nineteen_dvd_nat (k\u2082 + 1) using 1,\n  all_goals{simp only [eq_iff_iff], apply int.coe_nat_dvd},\n}\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b\n :=\nbegin \n  repeat {rw int.dvd_iff_mod_eq_zero},\n  rw int.add_mod, rw (int.add_mod a),\n  have h\u2081 : (100:\u2124) = 5 + 19*5, by norm_num,\n  rw h\u2081, rw add_mul, rw mul_assoc,\n  rw (int.add_mul_mod_self_left (5*a)),\n  simp, rw nineteen_dvd, rw mul_add,\n  rw \u2190mul_assoc,\n  have h\u2082 : 4*5 = 19+(1:\u2124), by norm_num,\n  rw h\u2082, rw add_mul, rw int.dvd_iff_mod_eq_zero,\n  rw add_assoc, rw add_comm,\n  rw (int.add_mul_mod_self_left), simp,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209518,"user_id":106,"body":"import data.int.basic\nimport ring_theory.coprime\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n  split; intro h,\n  {\n    apply dvd_mul_of_dvd_right h _,\n  },\n  {\n    have g : is_coprime (19 : \u2124) (4 : \u2124), {\n      existsi [(-1 : \u2124), (5 : \u2124)], norm_num\n    },\n    apply is_coprime.dvd_of_dvd_mul_left g h\n  }\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b :=\nbegin\n  split; intro h,\n  {\n    have h := dvd_mul_of_dvd_right h 4,\n    have ha : 19 \u2223 399 * a, by { existsi (21 * a), rw \u2190 mul_assoc, norm_num },\n    rw [left_distrib, \u2190mul_assoc] at h,\n    have h := dvd_sub h ha,\n    rw [add_comm, add_sub_assoc, \u2190mul_sub_right_distrib, add_comm] at h,\n    have ha : (4 * 100 - 399 : \u2124) = 1, by norm_num, rw [ha, one_mul] at h,\n    exact h\n  },\n  {\n    have ha : 19 \u2223 399 * a, by { existsi (21 * a), rw \u2190 mul_assoc, norm_num },\n    have h := dvd_add ha h,\n    rw \u2190add_assoc at h,\n    have h' : 399 * a + a = 399 * a + 1 * a, by norm_num, rw h' at h, clear h',\n    rw \u2190right_distrib at h, simp at h,\n    have h' : (399 + 1 : \u2124) = 4 * 100, by norm_num, rw h' at h, clear h',\n    rw [mul_assoc, \u2190left_distrib] at h,\n    exact iff.elim_right (nineteen_dvd _) h,\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209519,"user_id":null,"body":"import data.int.basic\nimport tactic\nopen int\n\n\nlemma foo {b m : \u2124} (h : 2 * b = 19 * m) : \u2203 c, m = 2 * c :=\nbegin\n  apply exists_eq_mul_right_of_dvd,\n  cases mod_two_eq_zero_or_one m with meven modd,\n  { exact dvd_of_mod_eq_zero meven, },\n  { have h\u2082 : 19 * m % 2 = 0, { rw [\u2190h, mul_mod], norm_num, },\n    revert h\u2082, rw mul_mod, norm_num, },\nend\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n  split,\n  { intro h, exact dvd_mul_of_dvd_right h 4, },\n  { rintro \u27e8m, hm\u27e9,\n    rw [(show (4 : \u2124) * a = 2 * (2 * a), by ring)] at hm,\n    rcases foo hm with \u27e8c, rfl\u27e9,\n    have hm\u2082 : 2 * a = 19 * c := mul_left_cancel' two_ne_zero (mul_left_comm 19 2 c \u25b8 hm),\n    rcases foo hm\u2082 with \u27e8p, rfl\u27e9,\n    exact \u27e8p, mul_left_cancel' two_ne_zero (mul_left_comm 19 2 p \u25b8 hm\u2082)\u27e9 }, \nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b :=\nbegin\n  repeat { rw dvd_iff_mod_eq_zero, },\n  split,\n  { intro h, \n    have k : (1 * a + 4 * b) % 19 = 4 * (100 * a + b) % 19,\n    { rw [mul_add, \u2190mul_assoc, mod_add_cancel_right, mul_mod, mul_mod (4*100) _ _], norm_num, },\n    rw one_mul at k, rw [k, mul_mod, h], norm_num, },\n  { intro h,\n    have k : (100 * a + 1 * b) % 19 = 100 * (a + 4 * b) % 19,\n    { rw [mul_add, \u2190mul_assoc, mod_add_cancel_left, mul_mod, mul_mod (100*4) _ _], norm_num, },\n    rw one_mul at k, rw [k, mul_mod, h], norm_num, },\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209520,"user_id":null,"body":"import tactic\n\nimport data.nat.basic\nimport data.nat.prime\nimport ring_theory.coprime\nimport data.int.modeq\n\n-- #check dvd_mul_left\n\n\ntheorem nineteen_dvd (a : \u2124) : \n  19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin \n  split,\n  {\n    intro h,\n    exact dvd_mul_of_dvd_right h 4,\n  },\n  {\n    intro h\u2081,\n    have h\u2082 : nat.coprime 19 4 := by tauto, \n    rw \u2190nat.is_coprime_iff_coprime at h\u2082,\n    exact is_coprime.dvd_of_dvd_mul_left h\u2082 h\u2081,\n  }\nend\n\nopen int.modeq\n\nexample (a b c d n : \u2124 ) : a \u2261 b [ZMOD n] \u2192 b*c \u2261 d [ZMOD n] \u2192 a*c \u2261 d [ZMOD n] := \nbegin\n  intros h hh,\n  have h\u2083 := modeq_mul_right c h,\n  exact int.modeq.trans h\u2083 hh,\nend \n\nlemma nineteen_dvd_mod (a b : \u2124) : \n  100 * a + b \u2261 0 [ZMOD 19] \u2194 a + 4*b \u2261 0 [ZMOD 19] :=\nbegin\n  have fourhundred_is_one : 400 \u2261 1 [ZMOD 19] := by dec_trivial,\n  have hundred_is_one : 100 \u2261 5 [ZMOD 19] := by dec_trivial,\n  have k\u2083 : 1 \u2261 20 [ZMOD 19] := by dec_trivial,\n  have k\u2080 : 100* a + 1*b \u2261 5*a + 20*b [ZMOD 19] := modeq_add (modeq_mul_right a (hundred_is_one)) (modeq_mul k\u2083 (show b \u2261 b [ZMOD 19], by refl)),\n  have k\u2081 : 400 * a + 4*b\u2261 1*a + 4*b [ZMOD 19] := modeq_add (modeq_mul_right a fourhundred_is_one) (show 4*b\u22614*b [ZMOD 19], by refl),\n  ring at k\u2081 k\u2080,\n  \n  split,\n  {\n    intro h,\n    have j := modeq_mul_left 4 h,\n    ring at j,\n    -- trans j k\u2081 \n    exact int.modeq.trans k\u2081.symm j,\n  },\n  {\n    intro h,\n    have j := modeq_mul_left 5 h,\n    ring at j,\n    -- k\u2080 j\n    exact int.modeq.trans k\u2080 j,\n  },\nend \n\ntheorem nineteen_dvd' (a b : \u2124) : \n  19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b \n:=\nbegin\n  have k := nineteen_dvd_mod a b,\n  simp [modeq_zero_iff] at k,\n  exact k,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209521,"user_id":null,"body":"import data.int.basic data.zmod.basic tactic\n\nlemma lem1 (a : \u2124) : 19 \u2223 a \u2194 (a : zmod 19) = 0 :=\nbegin\n    exact iff.symm (char_p.int_cast_eq_zero_iff (zmod 19) 19 a),\nend\n\nlemma lem2 (a : \u2124) : 19 \u2223 4*a \u2194 (4*a : zmod 19) = 0 :=\nbegin\n    norm_cast,\n    exact iff.symm (char_p.int_cast_eq_zero_iff (zmod 19) 19 (4*a)),\nend\n\ntheorem nineteen_dvd (a : \u2124) : 19 \u2223 a \u2194 19 \u2223 4 * a :=\nbegin\n    rw [lem1, lem2],\n    split,\n    {   intro h,\n        rw [h, mul_zero],\n    },\n    {   intro h,\n        have := congr_arg (has_mul.mul (5 : zmod 19)) h,\n        ring at this,\n        rw [show (20 : zmod 19) = 1, from rfl] at this,\n        rwa one_mul at this,\n    },\nend\n\nlemma lem3 (a b : \u2124) : 19 \u2223 100*a + b \u2194 ((100*a + b) : zmod 19) = 0 :=\nbegin\n    norm_cast,\n    exact iff.symm (char_p.int_cast_eq_zero_iff (zmod 19) 19 (100*a + b)),\nend\n\nlemma lem4 (a b : \u2124) : 19 \u2223 a + 4*b \u2194 ((a + 4*b) : zmod 19) = 0 :=\nbegin\n    norm_cast,\n    exact iff.symm (char_p.int_cast_eq_zero_iff (zmod 19) 19 (a + 4*b)),\nend\n\ntheorem nineteen_dvd' (a b : \u2124) : 19 \u2223 100 * a + b \u2194 19 \u2223 a + 4 * b :=\nbegin\n    rw [lem3, lem4],\n    split,\n    {   intro h,\n        have := congr_arg (has_mul.mul (4 : zmod 19)) h,\n        ring at this,\n        rw [show (400 : zmod 19) = (1 : zmod 19), from rfl] at this,\n        rwa one_mul at this,\n    },\n    {   intro h,\n        have := congr_arg (has_mul.mul (100 : zmod 19)) h,\n        norm_cast at this,\n        ring at this,\n        push_cast at this,\n        rw [show (400 : zmod 19) = (1 : zmod 19), from rfl] at this,\n        rwa one_mul at this,\n    },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb806b4e7c54e00246f70e1":[{"id":209522,"user_id":null,"body":"import Preloaded group_theory.subgroup.basic\n\n-- This definition is imported from Preloaded\n-- def \u0394 (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\ndef subgroup_\u0394 (G : Type*) [group G] : subgroup (G \u00d7 G) := \n{ carrier := \u0394 G,\n  one_mem' := by tauto,\n  mul_mem' := begin intros, rw \u0394 at *, finish, end,\n  inv_mem' := begin intros, rw \u0394 at *, finish, end }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : (subgroup_\u0394 G).normal \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  { intros DeltaG_normal g h,\n    apply eq_mul_of_mul_inv_eq,\n    have := DeltaG_normal.conj_mem (h, h) (by tauto) (g, 1),\n    simpa [\u2190 subgroup.mem_carrier, subgroup_\u0394, \u0394], },\n  { intro comm_G,\n    have comm_GxG : \u2200 x y : G \u00d7 G, x * y = y * x, by { rintros \u27e8_, _\u27e9 \u27e8_, _\u27e9, simp [comm_G], },    \n    rw [\u2190 subgroup.normalizer_eq_top, eq_top_iff],\n    intros x _ y,\n    simp_rw [comm_GxG x y, mul_assoc, mul_inv_self, mul_one], }, \nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209523,"user_id":null,"body":"import Preloaded group_theory.subgroup.basic\n\n-- This definition is imported from Preloaded\n-- def \u0394 (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\n\nlemma one_is_one_prod_one (G : Type*) [group G] : (1:G \u00d7 G) = (1,1):=\nbegin\n  let y:G \u00d7 G := (1,1) ,\n  let z: G\u00d7G  := 1,\n  have z\u2081:z=1 := by refl,\n  have h\u2081: y = z := by refl,\n  have : y \u2208 \u0394 G,\n  { rw \u0394,\n    have : y.fst = y.snd := by refl,\n    assumption,},\n  rw [\u2190 z\u2081,\u2190 h\u2081],\nend\n\n\ndef subgroup_\u0394 (G : Type*) [group G] : subgroup (G \u00d7 G) :=\n{ carrier := \u0394 G,\n  one_mem' :=\n  begin\n    rw [one_is_one_prod_one G ,\u0394],\n    rw set.mem_set_of_eq,\n  end,\n  mul_mem' :=\n  begin\n    intros a b \u0394a \u0394b,\n    have ha: a.fst = a.snd:= by {rw \u0394 at \u0394a, assumption},\n    have hb: b.fst = b.snd:= by {rw \u0394 at \u0394b, assumption},\n    have fst: (a * b).fst = a.fst * b.fst:= by refl,\n    have snd: (a * b).snd = a.snd * b.snd:= by refl,\n    have h: (a * b).fst = (a * b).snd := by {rw [fst, snd, ha, hb]},\n    rw \u0394,\n    assumption,\n  end,\n  inv_mem' :=\n  begin\n    intro x,\n    intro hx,\n    rw \u0394 at hx,\n    rw \u0394,\n    have inv: x\u207b\u00b9 * x = 1 := by exact mul_left_inv x,\n    have hfst: x\u207b\u00b9.fst = x.fst\u207b\u00b9,\n    {\n      have : x\u207b\u00b9.fst * x.fst = 1:= by\n      calc\n        x\u207b\u00b9.fst * x.fst = (x\u207b\u00b9* x).fst : by refl\n        ... = (1:G\u00d7G ).fst : by rw inv\n        ... = 1 : by rw one_is_one_prod_one,\n      have inv\u2081: (x\u207b\u00b9 * x).fst = (1:G\u00d7G) .fst := by rw inv,\n      simp,\n    },\n    have hfst: x\u207b\u00b9.snd = x.snd\u207b\u00b9,\n    {\n      have : x\u207b\u00b9.snd * x.snd = 1:= by\n      calc\n        x\u207b\u00b9.snd * x.snd = (x\u207b\u00b9* x).snd : by refl\n        ... = (1:G\u00d7G ).snd : by rw inv\n        ... = 1 : by rw one_is_one_prod_one,\n      have inv\u2081: (x\u207b\u00b9 * x).snd = (1:G\u00d7G) .snd := by rw inv,\n      simp,\n    },\n    rw set.mem_set_of_eq at hx,\n    rw set.mem_set_of_eq,\n    simp,\n    assumption,\n  end }\n\n\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : (subgroup_\u0394 G).normal \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  { intro normal, intros,\n    have gin : (g, g) \u2208 \u0394 G := by {rw [\u0394, set.mem_set_of_eq]},\n    let h\u2082 : G \u00d7 G := (1,h),\n    have conj: h\u2082 *  (g, g) * h\u2082\u207b\u00b9 \u2208 \u0394 G := by {exact normal.conj_mem (g,g) gin h\u2082},\n    have h\u2083 :h\u2082 *  (g, g) * h\u2082\u207b\u00b9 = (g, h * g * h\u207b\u00b9) := by simp,\n    rw [h\u2083, \u0394, set.mem_set_of_eq] at conj,\n    have eq : g = h * g * h\u207b\u00b9 := by {\n      have x\u2081: (g, h * g * h\u207b\u00b9).fst = g := by refl,\n      have x\u2082: (g, h * g * h\u207b\u00b9).snd = h * g * h\u207b\u00b9 := by refl,\n      rw [x\u2081 ,x\u2082] at conj,\n      assumption,\n    },\n    conv {\n      to_lhs,\n      rw eq,\n    },\n    simp,},\n  { intro comm,\n    intros,\n    have : (subgroup_\u0394 G).normal := {\n      conj_mem:= begin\n        intros n hn g\u2082,\n        rw [subgroup_\u0394],\n        have : g\u2082 * n * g\u2082\u207b\u00b9 \u2208 \u0394 G:= by\n          begin\n            rw [ \u0394, set.mem_set_of_eq],\n            have fst : (g\u2082 * n * g\u2082\u207b\u00b9).fst = n.fst := by\n            calc\n              (g\u2082 * n * g\u2082\u207b\u00b9).fst  = g\u2082.fst * n.fst * g\u2082\u207b\u00b9.fst  : by refl\n              ... = g\u2082.fst * g\u2082\u207b\u00b9.fst * n.fst : by rw [mul_assoc, comm n.fst _,\u2190 mul_assoc]\n              ... = n.fst : by simp,\n            have snd : (g\u2082 * n * g\u2082\u207b\u00b9).snd = n.snd := by\n            calc\n              (g\u2082 * n * g\u2082\u207b\u00b9).snd  = g\u2082.snd * n.snd * g\u2082\u207b\u00b9.snd  : by refl\n              ... = g\u2082.snd * g\u2082\u207b\u00b9.snd * n.snd : by rw [mul_assoc, comm n.snd _,\u2190 mul_assoc]\n              ... = n.snd : by simp,\n            rw [fst, snd],\n            have h\u0394 : n \u2208 \u0394 G := by {rw subgroup_\u0394 at hn, assumption,},\n            rw \u0394 at h\u0394,\n            assumption,\n          end,\n        assumption,\n      end\n    },\n    assumption,}\nend\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209524,"user_id":null,"body":"import Preloaded group_theory.subgroup.basic tactic\n\n-- This definition is imported from Preloaded\n-- def \u0394 (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\ndef subgroup_\u0394 (G : Type*) [group G] : subgroup (G \u00d7 G) := \n{ carrier := \u0394 G,\n  one_mem' := by{\n    solve_by_elim,\n  },\n  mul_mem' := by{\n    intros a b h0 h1,\n    cases b, cases a,\n    dsimp,\n    dsimp [set.has_mem, set.mem,\u0394,set_of] at h0 h1 |-,\n    finish,\n  },\n  inv_mem' := by{\n    intros x h0,\n    dsimp [set.has_mem, set.mem,\u0394,set_of] at h0 |-,\n    finish,\n  } }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : (subgroup_\u0394 G).normal \u2194 \u2200 g h : G, g * h = h * g :=\nby{\n  split,{\n    intros h1 g h,\n    cases h1,\n    have h2:(h,h)\u2208subgroup_\u0394 G,{\n      solve_by_elim,\n    },\n    specialize h1 (h,h) h2 (g,1),\n    have h3:g*h*g\u207b\u00b9=h,{\n      finish,\n    },\n    clear_except h3,\n    apply_fun (right_mul g) at h3,\n    simp [right_mul] at h3,\n    assumption,\n  },\n  intros h0,\n  fconstructor,\n  intros h h1 g,\n  have h2:=h0 g.1 h.1,\n  have h3:=h0 g.2 h.1,\n  change (h.1=h.2) at h1,\n  change (g.1*h.1*(g.1)\u207b\u00b9)=(g.2*h.2*(g.2)\u207b\u00b9),\n  rw [\u2190h1,h2,h3],\n  norm_num,\n}\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209525,"user_id":null,"body":"import Preloaded group_theory.subgroup.basic\nimport tactic.group\n\n-- This definition is imported from Preloaded\n-- def \u0394 (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\ndef subgroup_\u0394 (G : Type*) [group G] : subgroup (G \u00d7 G) := \n{\n  carrier := \u0394 G,\n  one_mem' := begin\n    unfold \u0394,\n    rw set.mem_set_of_eq,\n    refl,\n  end,\n  mul_mem' := begin\n    rintros \u27e8 a,a'\u27e9 \u27e8b,b' \u27e9 ha hb,\n    unfold \u0394 at *,\n    tidy,\n  end,\n  inv_mem' := begin\n    rintros \u27e8 x , y \u27e9 hx,\n    unfold \u0394 at *,\n    tidy,\n  end \n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : (subgroup_\u0394 G).normal \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  {\n    intros h x y,\n    have := h.conj_mem \u27e8 x,x \u27e9 rfl  \u27e8 1,y \u27e9,\n    simp at this,\n    unfold subgroup_\u0394 at this,\n    simp at this,\n    unfold \u0394 at this,\n    simp at this,\n    calc\n      x * y = (y * x * y\u207b\u00b9) * y : by rw \u2190 this ... \n            = y * x             : by group ,\n  },\n  {\n    intros h,\n    exact {\n      conj_mem := begin\n        rintros \u27e8 x,y\u27e9 hxy \u27e8 a,b \u27e9 ,\n        dsimp,\n        unfold subgroup_\u0394 at *,\n        unfold \u0394 at *,\n        simp at *,\n        rw [h a x,h b y,hxy],\n        group,\n      end,\n    }\n  }\nend\n\n\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209526,"user_id":197,"body":"import Preloaded group_theory.subgroup.basic\n\ndef subgroup_\u0394 (G : Type*) [group G] : subgroup (G \u00d7 G) := \n{ carrier := \u0394 G,\n  one_mem' := rfl,\n  mul_mem' := by rintros \u27e8a, _\u27e9 \u27e8b, _\u27e9 (_|_) (_|_); exact eq.refl _,\n  inv_mem' := by rintros \u27e8a, _\u27e9 (_|_); exact eq.refl _ }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : (subgroup_\u0394 G).normal \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  { intros h\u0394 g h,\n    symmetry,\n    apply mul_eq_of_eq_mul_inv,\n    conv_lhs { rw [\u2190mul_one h, \u2190mul_right_inv h, \u2190mul_assoc] },\n    change (h, g) * (h, h) * (h, g)\u207b\u00b9 \u2208 subgroup_\u0394 G,\n    apply subgroup.normal.conj_mem h\u0394,\n    exact eq.refl h },\n  { intro h\u0394,\n    constructor,\n    rintros \u27e8h, h\u2082\u27e9 (_|_) \u27e8g\u2081, g\u2082\u27e9,\n    change g\u2081 * h * g\u2081\u207b\u00b9 = g\u2082 * h * g\u2082\u207b\u00b9,\n    rw [h\u0394, \u2190mul_assoc, mul_left_inv, one_mul, h\u0394, \u2190mul_assoc, mul_left_inv, one_mul] }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209527,"user_id":null,"body":"import Preloaded deprecated.subgroup\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{ one_mem := rfl,\n  mul_mem := begin\n    intros a b ha hb, \n    simp [\u0394] at *,\n    rw [ha, hb],\n  end,\n  inv_mem := begin\n    intros a,\n    simp [\u0394] at *,    \n  end }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] \n: normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  { rintros \u27e8hs, hn\u27e9 g h,\n    have hc:=hn (g, g) rfl (1, h),\n    simp [\u0394] at hc,    \n    rw hc,\n    simpa },\n  intros h,  \n  constructor,\n  intros n hn g,\n  simp [\u0394] at *,\n  have h1 := h g.fst n.fst,\n  have h2 := h g.snd n.snd,\n  have h3 := h g.fst n.snd,\n  simp [hn, h1, h2, h3],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209528,"user_id":106,"body":"import Preloaded deprecated.subgroup\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\nbegin\n  tactic.unfreeze_local_instances,\n  have hsm : is_submonoid (\u0394 G), {\n    apply is_submonoid.mk, {\n      unfold \u0394, simp\n    }, {\n      intros a b am bm,\n      cases a, cases b,\n      unfold \u0394 at *, simp at *,\n      subst am, subst bm,\n    }\n  },\n  apply is_subgroup.mk,\n  intros a am,\n  cases a, unfold \u0394 at *, simp at *,\n  assumption\nend\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split; intros, {\n    cases a with ag an, cases ag with asm agi, cases asm with asm1 asmm,\n    have hgg : ((g, g) : (G \u00d7 G)) \u2208 \u0394 G, by { unfold \u0394, simp },\n    have he := an (g, g) hgg (g, h),\n    rw prod.inv_mk _ _ at he,\n    repeat { rw prod.mk_mul_mk _ _ _ _ at he },\n    rw [mul_assoc, mul_right_inv _, mul_one] at he,\n    unfold \u0394 at he, simp at he,\n    have he := iff.elim_right (mul_left_inj h) he,\n    rw [mul_assoc, mul_left_inv _, mul_one] at he,\n    assumption\n  }, {\n    apply normal_subgroup.mk, intros,\n    cases g, cases n,\n    rw prod.inv_mk _ _,\n    repeat { rw prod.mk_mul_mk _ _ _ _ },\n    rw a g_fst _, rw a g_snd _, repeat { rw mul_assoc }, rw a g_fst _, rw a g_snd _,\n    repeat { rw mul_left_inv }, repeat { rw mul_one },\n    assumption\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209529,"user_id":null,"body":"import deprecated.subgroup Preloaded\n\ninstance subgroup_\u0394 (G : Type*) [i : group G] : is_subgroup (\u0394 G) :=\n{ one_mem := show ((1 : G), (1:G)) \u2208 (\u0394 G), by { simp [\u0394] },\n  mul_mem := \u03bb a b ha hb, by { unfold \u0394 at ha hb \u22a2, finish },\n  inv_mem := \u03bb a ha, by { unfold \u0394 at ha \u22a2, finish } }\n\nexample (G : Type*) [group G] (g : G) : g * g\u207b\u00b9 = 1 := by refine mul_inv_self g\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  { intros hN g h,\n    have h\u2082 : (g,h) * (h, h) * (g\u207b\u00b9, h\u207b\u00b9) \u2208 \u0394 G,\n    { apply hN.normal, simp [\u0394], },\n    simp only [prod.mk_mul_mk, mul_assoc h, mul_inv_self, mul_one] at h\u2082,\n    have h\u2083 : g * h * g\u207b\u00b9 = h,\n    { simp only [\u0394, set.mem_set_of_eq] at h\u2082, exact h\u2082,  },\n    refine mul_right_cancel _, exact g\u207b\u00b9,\n    rw [mul_assoc h, mul_inv_self, mul_one, h\u2083], },\n  { exact \u03bb hc, { normal := \u03bb \u27e8g, g'\u27e9 hn \u27e8a, b\u27e9, by\n    { simpa [prod.mk_mul_mk, hc _ a\u207b\u00b9, hc _ b\u207b\u00b9, \u2190mul_assoc, inv_mul_self, one_mul], } } },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209530,"user_id":null,"body":"import deprecated.subgroup\nimport Preloaded\nattribute [simp] \u0394\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) := {\n\n    mul_mem := \u03bb p q h i, by {simp at *, simp [h,i]},\n    one_mem := by simp [\u0394],\n    inv_mem := \u03bb \u27e8x,y\u27e9 h, by {simp [h] at *, assumption}\n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\n\u27e8\n    \u03bb \u27e8hn\u27e9 g h, \n        have U: (g,g) \u2208 \u0394 G, by simp, \n        have T: _ := hn (g,g) U (g,h), \n        begin \n            simp at *,\n            calc g * h = h * g * h\u207b\u00b9 * h : by rw [\u2190T] \n                   ... = h * g           : by simp            \n        end,\n    \u03bb hc, {\n        normal := \u03bb s he g, begin \n            simp at *, rw he,\n            rw [hc g.fst s.snd, hc g.snd s.snd], simp,\n        end\n    }\n\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209531,"user_id":null,"body":"import Preloaded tactic\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{ one_mem := by tidy,\n  mul_mem :=\n  begin\n    intros a b ha hb,\n    have ha' : a.fst = a.snd, by tidy,\n    have hb' : b.fst = b.snd, by tidy,\n    tidy,\n  end,\n  inv_mem :=\n  begin\n    intros a ha,\n    have ha' : a.fst = a.snd, by tidy,\n    tidy,\n  end }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split,\n  { intros hnormal g' h',\n    let g : (G \u00d7 G) := \u27e8g', 1\u27e9,\n    let h : (G \u00d7 G) := \u27e8h', h'\u27e9,\n    have hh : h.fst = h.snd, by tidy,\n    let f : (G \u00d7 G) := g * h * g\u207b\u00b9,\n    have hf : f \u2208 \u0394 G,\n    { apply hnormal.normal, tidy },\n    have hs : f.snd = h', by simp,\n    have Hf : g' * h' * g'\u207b\u00b9 = h',\n    { calc f.fst = f.snd : by tidy\n             ... = h' : by simp,},\n    exact eq_mul_of_mul_inv_eq Hf,\n  },\n  { intro hcom,\n    tidy,\n    have h : g_fst * n_fst * g_fst\u207b\u00b9 = g_snd * n_snd * g_snd\u207b\u00b9,\n    { rw hcom g_fst n_fst,\n      rw hcom g_snd n_snd,\n      group,\n      have H' : n_fst = n_snd, tidy,},\n    tidy, },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209532,"user_id":659,"body":"import group_theory.subgroup algebra.pi_instances\nimport tactic\nimport Preloaded\n-- This is in Preloaded.lean, so delete before submitting and `import Preloaded` instead\n--def \u0394 (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{ one_mem := rfl,\n  mul_mem := by {rintro \u27e8a,b\u27e9 \u27e8c,d\u27e9 \u27e8rfl\u27e9 \u27e8rfl\u27e9, show _ = _, refl},\n  inv_mem := by {rintro \u27e8a, b\u27e9 \u27e8rfl\u27e9, show _ = _, refl} } \n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split; intro h1,\n  { intros a b,\n    have h2 : (b,b*a) * (a,1) \u2208 \u0394 G,\n    exact (mul_one _).symm,\n    rw \u2190one_mul (b * a),\n    resetI,\n    rwa is_subgroup.mem_norm_comm_iff at h2 }, \n  { letI : comm_group G := { mul_comm := h1, .._inst_1 },\n    exact normal_subgroup_of_comm_group (\u0394 G)\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209533,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\nbegin\n  refine {..}, unfold \u0394 monoid.one group.one set.mem,\n  rw [set.set_of_app_iff, prod.fst_one, prod.snd_one],\n  intros a b ha hb,\n  unfold \u0394 set.mem group.mul monoid.mul semigroup.mul at ha hb \u22a2,\n  rw set.set_of_app_iff at ha hb \u22a2,\n  rw [prod.fst_mul, prod.snd_mul, ha, hb],\n  intro a, unfold \u0394 set.mem, repeat {rw set.set_of_app_iff},\n  rw [prod.fst_inv, prod.snd_inv], intro h, rw h,\nend\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split, intros H g h, cases H with _ Hn,\n  apply eq_mul_of_mul_inv_eq,\n  replace Hn := Hn (h,h) _ (g,1),\n  rw [prod.inv_mk, prod.mk_mul_mk, prod.mk_mul_mk] at Hn,\n  unfold \u0394 at Hn, rw set.mem_set_of_eq at Hn,\n  unfold prod.fst prod.snd at Hn, simpa using Hn,\n  unfold \u0394, rw set.mem_set_of_eq,\n  intro H, constructor,\n  intros n Hn g, unfold \u0394, rw set.mem_set_of_eq,\n  repeat {rw [prod.fst_mul, prod.snd_mul]}, \n  rw [prod.fst_inv, prod.snd_inv, H g.fst n.fst, H g.snd n.snd],\n  repeat {rw inv_mul_cancel_right}, simp, exact Hn,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209534,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\nbegin\n  refine {..}, tauto, intros a b ha hb,\n  unfold \u0394 set.mem group.mul monoid.mul semigroup.mul at ha hb \u22a2,\n  rw set.set_of_app_iff at ha hb \u22a2,\n  rw [prod.fst_mul, prod.snd_mul, ha, hb],\n  intro a, unfold \u0394 set.mem, repeat {rw set.set_of_app_iff},\n  rw [prod.fst_inv, prod.snd_inv], intro h, rw h,\nend\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split, intros H g h, cases H with _ Hn,\n  apply eq_mul_of_mul_inv_eq,\n  replace Hn := Hn (h,h) _ (g,1),\n  rw [prod.inv_mk, prod.mk_mul_mk, prod.mk_mul_mk] at Hn,\n  unfold \u0394 at Hn, rw set.mem_set_of_eq at Hn,\n  unfold prod.fst prod.snd at Hn, simpa using Hn,\n  unfold \u0394, rw set.mem_set_of_eq,\n  intro H, constructor,\n  intros n Hn g, unfold \u0394, rw set.mem_set_of_eq,\n  repeat {rw [prod.fst_mul, prod.snd_mul]}, \n  rw [prod.fst_inv, prod.snd_inv, H g.fst n.fst, H g.snd n.snd],\n  repeat {rw inv_mul_cancel_right}, simp, exact Hn,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209535,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{\n  one_mem := by tauto,\n  mul_mem := begin\n    intros a b ha hb,\n    unfold \u0394 set.mem group.mul monoid.mul semigroup.mul at ha hb \u22a2,\n    rw set.set_of_app_iff at ha hb \u22a2,\n    rw [prod.fst_mul, prod.snd_mul, ha, hb],\n  end,\n  inv_mem := begin\n    intro a, unfold \u0394 set.mem, repeat {rw set.set_of_app_iff},\n    rw [prod.fst_inv, prod.snd_inv], intro h, rw h,\n  end \n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split, intros H g h, cases H with _ Hn,\n  apply eq_mul_of_mul_inv_eq,\n  replace Hn := Hn (h,h) _ (g,1),\n  rw [prod.inv_mk, prod.mk_mul_mk, prod.mk_mul_mk] at Hn,\n  unfold \u0394 at Hn, rw set.mem_set_of_eq at Hn,\n  unfold prod.fst prod.snd at Hn, simpa using Hn,\n  unfold \u0394, rw set.mem_set_of_eq,\n  intro H, constructor,\n  intros n Hn g, unfold \u0394, rw set.mem_set_of_eq,\n  repeat {rw [prod.fst_mul, prod.snd_mul]}, \n  rw [prod.fst_inv, prod.snd_inv, H g.fst n.fst, H g.snd n.snd],\n  repeat {rw inv_mul_cancel_right}, simp, exact Hn,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209536,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances tactic\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\nbegin\n  refine {..}, unfold \u0394 monoid.one group.one set.mem,\n  rw [prod.one_eq_mk, set.set_of_app_iff],\n  intros a b ha hb,\n  unfold \u0394 set.mem group.mul monoid.mul semigroup.mul at ha hb \u22a2,\n  rw set.set_of_app_iff at ha hb \u22a2,\n  rw [prod.fst_mul, prod.snd_mul, ha, hb],\n  intro a, unfold \u0394 set.mem, repeat {rw set.set_of_app_iff},\n  rw [prod.fst_inv, prod.snd_inv], intro h, rw h,\nend\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split, intros H g h, cases H with _ Hn,\n  apply eq_mul_of_mul_inv_eq,\n  replace Hn := Hn (h,h) _ (g,1),\n  rw [prod.inv_mk, prod.mk_mul_mk, prod.mk_mul_mk] at Hn,\n  unfold \u0394 at Hn, rw set.mem_set_of_eq at Hn,\n  unfold prod.fst prod.snd at Hn, simpa using Hn,\n  unfold \u0394, rw set.mem_set_of_eq,\n  intro H, refine {..},\n  -- refine {_to_is_subgroup := subgroup_\u0394 G, ..},unfold \u0394 monoid.one group.one set.mem,\n  unfold \u0394 monoid.one group.one set.mem,\n  rw [prod.one_eq_mk, set.mem_set_of_eq],\n  intros a b ha hb,\n  unfold \u0394 set.mem group.mul monoid.mul semigroup.mul at ha hb \u22a2,\n  rw set.mem_set_of_eq at ha hb \u22a2,\n  rw [prod.fst_mul, prod.snd_mul, ha, hb],\n  intro a, unfold \u0394 set.mem, repeat {rw set.mem_set_of_eq},\n  rw [prod.fst_inv, prod.snd_inv], intro h, rw h,\n  -- have to repeat last proof\n  intros n Hn g, unfold \u0394, rw set.mem_set_of_eq,\n  repeat {rw [prod.fst_mul, prod.snd_mul]}, \n  rw [prod.fst_inv, prod.snd_inv, H g.fst n.fst, H g.snd n.snd],\n  repeat {rw inv_mul_cancel_right}, simp, exact Hn,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209537,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{\n    one_mem := by tauto,\n    mul_mem :=\n    begin\n        intros a b ha hb,\n        have ha' : a.fst = a.snd := ha,\n        have hb' : b.fst = b.snd := hb,\n        unfold group.mul,\n        unfold monoid.mul,\n        unfold semigroup.mul,\n        dsimp [(*)],\n        rw [ha', hb'],\n        exact rfl,\n    end,\n    inv_mem :=\n    begin\n        intros a ha,\n        have ha' : a\u207b\u00b9 = \u27e8a.fst\u207b\u00b9, a.snd\u207b\u00b9\u27e9 := rfl,\n        have ha'' : a.fst = a.snd := ha,\n        rw [ha', ha''],\n        exact rfl,\n    end\n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194\n    \u2200 g h : G, g * h = h * g :=\nbegin\n    split,\n    {   intros hG g h,\n        let g' : G \u00d7 G := \u27e8g, g\u27e9,\n        let h' : G \u00d7 G := \u27e81, h\u27e9,\n        have g'_in_\u0394G : (\u0394 G) g' := rfl,\n        have key : (\u0394 G) (h' * g' * h'\u207b\u00b9) :=\n            @normal_subgroup.normal (G\u00d7G) prod.group (\u0394 G) hG g' g'_in_\u0394G h',\n        replace key : g = h*g*h\u207b\u00b9,\n            change 1*g*1\u207b\u00b9 = h*g*h\u207b\u00b9 at key,\n            rw [one_inv, one_mul, mul_one] at key,\n            exact key,\n        conv_lhs {rw key},\n        simp only [inv_mul_cancel_right],\n    },\n    {   intro hG,\n        constructor,\n        rintros \u27e8g1, g2\u27e9 hg \u27e8h1, h2\u27e9,\n        change g1 = g2 at hg,\n        change h1*g1*h1\u207b\u00b9 = h2*g2*h2\u207b\u00b9,\n        rw hg,\n        rw hG h1 g2,\n        rw hG h2 g2,\n        simp only [mul_inv_cancel_right],\n    },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209538,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances tactic\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{\n    one_mem := rfl,\n\n    mul_mem := by\n      {rintros \u27e8a1, a2\u27e9 \u27e8b1, b2\u27e9 ha hb,\n      change a1 = a2 at ha, change b1 = b2 at hb,\n      show a1 * b1 = a2 * b2,\n      rw [ha,hb]},\n\n    inv_mem := by\n      {rintros \u27e8a1, a2\u27e9 ha,\n      change a1 = a2 at ha,\n      show a1\u207b\u00b9 = a2\u207b\u00b9,\n      rw ha}\n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] :\n  normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\n\u27e8by\n  {intros hn g h,\n  cases hn,\n  have h1 : g * h * g\u207b\u00b9 = h * h * h\u207b\u00b9 := hn_normal (h,h) rfl (g,h),\n  have h2 : g * (g * h) * g\u207b\u00b9 = h * (g * h) * h\u207b\u00b9 := hn_normal (g*h, g*h) rfl (g,h),\n  rw [mul_assoc, h1, mul_assoc, mul_right_inv, mul_one] at h2,\n  rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at h2,},\n\nassume h,\n{ normal := by\n  {rintros \u27e8n1, n2\u27e9 hn \u27e8g1, g2\u27e9,\n  show g1 * n1 * g1\u207b\u00b9 = g2 * n2 * g2\u207b\u00b9,\n  change n1 = n2 at hn,\n  rw [hn, h g1 n2, h g2 n2],\n  repeat {rw [mul_assoc, mul_right_inv]}},\n  ..subgroup_\u0394 G}\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209539,"user_id":null,"body":"import group_theory.subgroup algebra.pi_instances\nimport Preloaded\n\ninstance is_submonoid_\u0394 (G : Type*) [group G] : is_submonoid (\u0394 G) := {\n  one_mem := rfl,\n  mul_mem := by { change \u2200 {a b : G \u00d7 G }, a.fst = a.snd \u2192 b.fst = b.snd \u2192 a.fst * b.fst = a.snd * b.snd,\n                  intros a b ha hb, rw [ha, hb] },\n}\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) := {\n  inv_mem := by { change \u2200 {a : G \u00d7 G}, a.fst = a.snd \u2192 (a.fst)\u207b\u00b9 = (a.snd)\u207b\u00b9,\n                  intros a ha, rw ha, },\n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G]\n  : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g\n:= by {\n  split,\n  \/- \u27f9 -\/\n  { intros hnormal g h,\n    replace hnormal := hnormal.normal,\n    have eqn: (\u27e8g, h\u27e9 : G \u00d7 G) * \u27e8h, h\u27e9 * \u27e8g\u207b\u00b9, h\u207b\u00b9\u27e9 \u2208 \u0394 G,\n    from hnormal \u27e8h, h\u27e9 (by { dsimp [\u0394], refl }) \u27e8g, h\u27e9,\n    dsimp [prod.has_mul, \u0394] at eqn,\n    rw [\u2190mul_one (g * h), \u2190mul_left_inv g, \u2190mul_assoc], congr,\n    rwa [mul_assoc h h, mul_right_inv, mul_one] at eqn,\n    },\n  \/- \u27f8 -\/\n  intro comm,\n  have prod_comm : \u2200 (g h : G \u00d7 G), g * h = h * g,\n  by { dsimp [prod.has_mul], intros, congr' 1; apply comm },\n  split, intros x hx y, rw prod_comm y x, rw mul_assoc, simpa,\n}\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209540,"user_id":null,"body":"import group_theory.subgroup algebra.pi_instances tactic\n\ndef D (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (D G) :=\n{\n    one_mem := rfl,\n\n    mul_mem := by\n      {rintros \u27e8a1, a2\u27e9 \u27e8b1, b2\u27e9 ha hb,\n      change a1 = a2 at ha, change b1 = b2 at hb,\n      show a1 * b1 = a2 * b2,\n      rw [ha,hb]},\n\n    inv_mem := by\n      {rintros \u27e8a1, a2\u27e9 ha,\n      change a1 = a2 at ha,\n      show a1\u207b\u00b9 = a2\u207b\u00b9,\n      rw ha}\n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] :\n  normal_subgroup (D G) \u2194 \u2200 g h : G, g * h = h * g :=\n\u27e8by\n  {intros hn g h,\n  cases hn,\n  have h1 : g * h * g\u207b\u00b9 = h * h * h\u207b\u00b9 := hn_normal (h,h) rfl (g,h),\n  have h2 : g * (g * h) * g\u207b\u00b9 = h * (g * h) * h\u207b\u00b9 := hn_normal (g*h, g*h) rfl (g,h),\n  rw [mul_assoc, h1, mul_assoc, mul_right_inv, mul_one] at h2,\n  rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at h2,},\n\nassume h,\n{ normal := by\n  {rintros \u27e8n1, n2\u27e9 hn \u27e8g1, g2\u27e9,\n  show g1 * n1 * g1\u207b\u00b9 = g2 * n2 * g2\u207b\u00b9,\n  change n1 = n2 at hn,\n  rw [hn, h g1 n2, h g2 n2],\n  repeat {rw [mul_assoc, mul_right_inv]}},\n  ..subgroup_\u0394 G}\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209541,"user_id":null,"body":"import group_theory.subgroup algebra.pi_instances\nimport Preloaded\nimport tactic\n\n-- With thanks to Kenny Lau on zulip who gave me a tidier solution which works on this old lean version\n-- https:\/\/leanprover.zulipchat.com\/#narrow\/stream\/113489-new-members\/topic\/Failed.20to.20synthesize.20type.20class.20instance\/near\/201145132\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) := \n{ one_mem := rfl,\n  mul_mem := \u03bb p q hp hq, show p.1 * q.1 = p.2 * q.2, by congr',\n  inv_mem := \u03bb p hp, show p.1\u207b\u00b9 = p.2\u207b\u00b9, by congr' }\n\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n    split,\n    {\n        intro h,\n        have j := h.normal,\n        clear h,\n        simp_rw prod.forall at j,\n        simp_rw \u0394 at j,\n        simp at j,\n        intros a b,\n        have ja := j a a (eq.refl a) 1 b,\n        simp at ja,\n        have ha : a * b = b * a * b\u207b\u00b9 * b := by rw \u2190 ja,\n        rw ha,\n        field_simp,\n    },\n    {\n        intro h_comm,\n        have j : \u2200 (n : G \u00d7 G), n \u2208 \u0394 G \u2192 \u2200 (g : G \u00d7 G), g * n * g\u207b\u00b9 \u2208 \u0394 G := by {\n            simp_rw prod.forall,\n            intros a b,\n            intro hin,\n            intros c d,\n            rw prod.inv_mk,\n            rw prod.mk_mul_mk,\n            rw prod.mk_mul_mk,\n            rw h_comm c a,\n            rw h_comm d b,\n            field_simp,\n            exact hin,\n        },\n        have h : is_subgroup (\u0394 G) := subgroup_\u0394 G,\n        exact { one_mem := h.one_mem,\n                mul_mem := h.mul_mem,\n                inv_mem := h.inv_mem,\n                normal := j },\n    }\n\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209542,"user_id":null,"body":"import group_theory.subgroup algebra.pi_instances\nimport tactic\nimport Preloaded\n\n@[simp] lemma \u0394_def {G : Type*} {x : G \u00d7 G} : x \u2208 \u0394 G \u2194 x.fst = x.snd := iff.rfl\n@[simp] lemma \u0394_def' {G : Type*} {x : G \u00d7 G} : set.mem x (\u0394 G) \u2194 x.fst = x.snd := iff.rfl --why?\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{ one_mem := rfl,\n  mul_mem := by { rintros \u27e8_, _\u27e9 \u27e8_, _\u27e9 h\u2081 h\u2082, rw \u0394_def' at \u22a2 h\u2081 h\u2082, cases h\u2081, cases h\u2082, refl } ,\n  inv_mem := by { rintros \u27e8_, _\u27e9 h\u2081, rw \u0394_def' at \u22a2 h\u2081, cases h\u2081, refl } }\n-- by { refine_struct {..}; tidy } -- this is really slow for some reason\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  simp only [\u2190 mul_inv_eq_iff_eq_mul],\n  split; intro H; resetI,\n  { intros g h,\n    change (g * h * g\u207b\u00b9, h) \u2208 \u0394 G,\n    convert normal_subgroup.normal (h, h) (show (h, h) \u2208 \u0394 G, from rfl) (g, 1),\n    simp },\n  { refine \u27e8\u03bb n hn g, _\u27e9,\n    simpa [H] using hn }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209543,"user_id":null,"body":"import Preloaded group_theory.subgroup algebra.pi_instances tactic\n\n-- This is in Preloaded.lean, so delete before submitting and `import Preloaded` instead\n-- def \u0394 (G : Type*) : set (G \u00d7 G) := { g : G \u00d7 G | g.fst = g.snd }\n\nlemma \u0394.one_mem (G : Type*) [group G] : ((1:G), (1:G)) \u2208 \u0394 G :=\nbegin\ntauto,\nend\n\nlemma \u0394.mul_mem (G : Type*) [group G] : \u2200 (g  h : G \u00d7 G), g \u2208 \u0394 G \u2192 h \u2208 \u0394 G \u2192 g * h \u2208 \u0394 G :=\nbegin\nintros g h,\nintros Hg Hh,\nunfold \u0394 at *,\nsuffices : (g*h).fst = (g*h).snd, tauto,\nsimp only [prod.snd_mul, prod.fst_mul] at *,\nreplace Hg : g.fst = g.snd := by solve_by_elim,\nreplace Hh : h.fst = h.snd := by solve_by_elim,\nrw [Hg, Hh],\nend\n\nlemma \u0394.inv_mem (G : Type*) [group G] : \u2200 (g : G \u00d7 G), g \u2208 \u0394 G \u2192 g\u207b\u00b9 \u2208 \u0394 G :=\nbegin\nintros g Hg,\nunfold \u0394 at *,\nsuffices : g\u207b\u00b9.fst = g\u207b\u00b9.snd, tauto,\nreplace Hg : g.fst = g.snd := by solve_by_elim,\nsimp only [prod.fst_inv, prod.snd_inv],\nrw Hg,\nend\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{\none_mem := \u0394.one_mem G,\nmul_mem := \u0394.mul_mem G,\ninv_mem := \u0394.inv_mem G,\n}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\nsplit,\nintro H,\nunfreezeI,\nintros g h,\nhave hh : (h, h) \u2208 \u0394 G := by tauto,\nhave : (g, 1) * (h, h) * (g, 1)\u207b\u00b9 \u2208 \u0394 G := normal_subgroup.normal (h, h) hh (g, 1),\nsimp only [prod.inv_mk, inv_inv, prod.mk_mul_mk] at this,\nunfold \u0394 at this,\nsimp only [one_inv, mul_one, one_mul, set.mem_set_of_eq] at *,\nfrom eq_mul_of_mul_inv_eq this,\nintro H,\nfconstructor,\nintros n Hn g,\nsuffices : (g * n * g\u207b\u00b9).fst = (g * n * g\u207b\u00b9).snd, tauto,\nunfold \u0394 at *,\nsimp only [prod.snd_mul, prod.fst_mul, prod.snd_inv, set.mem_set_of_eq, prod.fst_inv] at *,\nrw [Hn,(H g.fst n.snd), (H g.snd n.snd), mul_inv_cancel_right, mul_inv_cancel_right],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209544,"user_id":657,"body":"import Preloaded\nimport group_theory.subgroup algebra.pi_instances\nimport tactic\n\nnoncomputable theory\nopen_locale classical\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\nbegin\nrefine is_subgroup.of_div (\u0394 G) _ _,\nrefine rfl,\nintros a b ha hb,\n-- obviously?,\ncases b, cases a, simp only [prod.inv_mk, prod.mk_mul_mk],\nhave calc1 : a_fst = a_snd := by exact ha,\nhave calc2 : b_fst = b_snd := by exact hb,\nrw [calc1, calc2], \nrefine rfl,\nend\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\nsplit; intro hG, \n{by_contra, \npush_neg at a, cases a with g hg, cases hg with h not_comm,\nhave hgg : prod.mk g g \u2208 \u0394 G:= by refine rfl,\nlet gg := prod.mk g g,\nlet h1 := prod.mk h (1: G),\nhave calc2 : gg * h1 \u2260 h1 * gg,\nsimpa only [one_inv, mul_one, one_mul, and_true, prod.inv_mk, prod.mk.inj_iff, eq_self_iff_true, ne.def, prod.mk_mul_mk],\nrevert calc2, rw [imp_false, not_not],\nhave calc3 := hG.normal,\nhave calc4 := calc3 gg hgg h1,\nhave key : h * g * h\u207b\u00b9 = 1 * g * 1\u207b\u00b9 := by exact calc4,\nsimp only [one_inv, mul_one, one_mul] at key,\nsimp only [mul_one, one_mul, and_true, prod.mk.inj_iff, eq_self_iff_true, prod.mk_mul_mk], rw \u2190 key, simp only [mul_right_inj, inv_mul_cancel_right],\nrw key},\nrefine {to_is_subgroup := by apply_instance, normal := _}, \nintros nn hnn gg, \nsuffices key : gg * nn * gg\u207b\u00b9 = nn, rwa key,\ncases gg, cases nn, simp only [prod.inv_mk, prod.mk.inj_iff, prod.mk_mul_mk],\nsplit; {rw hG, simp only [inv_mul_cancel_left]},\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209545,"user_id":660,"body":"import group_theory.subgroup algebra.pi_instances\nimport tactic Preloaded\n\ninstance submonoid_\u0394 (G : Type*) [group G] : is_submonoid (\u0394 G) :=\n{ one_mem := rfl,\n  mul_mem :=\n  begin\n    rintro \u27e8a\u2081, a\u2082\u27e9 \u27e8b\u2081, b\u2082\u27e9 ha hb,\n    cases ha,\n    cases hb,\n    exact rfl,\n  end }\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{ inv_mem :=\n  begin\n    rintro \u27e8a\u2081, a\u2082\u27e9 h,\n    cases h,\n    exact rfl\n  end }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  refine \u27e8\u03bb k g h, eq_mul_of_mul_inv_eq _, \u03bb k, \u27e8_\u27e9\u27e9,\n  have : g * h * g\u207b\u00b9 = h * h * h\u207b\u00b9 := @normal_subgroup.normal _ _ _ k (h, h) rfl (g, h),\n  simpa using this,\n  rintro \u27e8n\u2081, n\u2082\u27e9 hn \u27e8g\u2081, g\u2082\u27e9,\n  cases hn,\n  change _ = _,\n  dsimp,\n  rw [k, \u2190 mul_assoc, mul_left_inv, one_mul, k, \u2190 mul_assoc, mul_left_inv, one_mul],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209546,"user_id":17,"body":"import Preloaded group_theory.subgroup algebra.pi_instances\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n  @is_subgroup.mk _ _ _ (@is_submonoid.mk _ _ (\u0394 G)\n  (by constructor)\n  begin\n    intros a b ha hb,\n    cases a with a\u2081 a\u2082,\n    cases b with b\u2081 b\u2082,\n    have ha\u2081a\u2082 : a\u2081 = a\u2082 := ha; subst ha\u2081a\u2082; clear ha,\n    have hb\u2081b\u2082 : b\u2081 = b\u2082 := hb; subst hb\u2081b\u2082; clear hb,\n    constructor\n  end)\n  begin\n    intros a ha,\n    cases a with a\u2081 a\u2082,\n    have ha\u2081a\u2082 : a\u2081 = a\u2082 := ha; subst ha\u2081a\u2082; clear ha,\n    constructor\n  end\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] :\n  normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g := iff.intro\n  begin\n    -- Proof adapted from https:\/\/math.stackexchange.com\/a\/2050609\n    intros h\u0394G g h,\n    have h\u2081 := @normal_subgroup.normal _ _ _ h\u0394G (h, h) (by constructor) (g, 1),\n    have h\u2082 : g * h * g\u207b\u00b9 = 1 * h * 1\u207b\u00b9 := h\u2081,\n    rw one_mul at h\u2082,\n    have h\u2083 : g * h * g\u207b\u00b9 * 1 = h * 1\u207b\u00b9 * 1, by repeat { rw mul_one }; assumption,\n    rw [show h * 1\u207b\u00b9 * 1 = h * (1\u207b\u00b9 * 1), by rw mul_assoc, inv_mul_self, mul_one,\n      mul_one] at h\u2083,\n    have h\u2084 : g * h * g\u207b\u00b9 * g = h * g, by cc,\n    rw [\u2190 h\u2084, show g * h * g\u207b\u00b9 * g = g * h * (g\u207b\u00b9 * g), by rw mul_assoc,\n      inv_mul_self, mul_one]\n  end\n  begin\n    intro hG,\n    constructor,\n    intros b hb a,\n    cases b with b\u2081 b\u2082,\n    have hb' : b\u2081 = b\u2082 := hb; subst hb'; clear hb,\n    cases a with a\u2081 a\u2082,\n    show a\u2081 * b\u2081 * a\u2081\u207b\u00b9 = a\u2082 * b\u2081 * a\u2082\u207b\u00b9,\n    rw [hG a\u2081 b\u2081, hG a\u2082 b\u2081, mul_assoc, mul_assoc, mul_right_inv, mul_right_inv]\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209547,"user_id":644,"body":"import group_theory.subgroup algebra.pi_instances Preloaded\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\nby refine_struct {..}; simp [\u0394] {contextual := tt}\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\n\u27e8\u03bb \u27e8n\u27e9, \u03bb g h, by simpa [\u0394, mul_inv_eq_iff_eq_mul] using n (h, h) rfl (g, h),  \n  \u03bb n, \u27e8by simp [n, \u0394] {contextual := tt}\u27e9\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209548,"user_id":168,"body":"import Preloaded group_theory.subgroup algebra.pi_instances\n\ninstance subgroup_\u0394 (G : Type*) [group G] : is_subgroup (\u0394 G) :=\n{ one_mem := by change ((1 : G), (1 : G)) \u2208 \u0394 G; rw [\u0394, set.mem_set_of_eq],\n  mul_mem := begin\n    change \u2200 a b, a \u2208 \u0394 G \u2192 b \u2208 \u0394 G \u2192 a * b \u2208 \u0394 G,\n    intros a b ha hb,\n    simp only [\u0394, set.mem_set_of_eq, prod.snd_mul, prod.fst_mul] at *,\n    rw [ha, hb],\n  end,\n  inv_mem := begin\n    change \u2200 a, a \u2208 \u0394 G \u2192 a\u207b\u00b9 \u2208 \u0394 G, intros a ha,\n    simp only [\u0394, inv_inj', prod.snd_inv, set.mem_set_of_eq, prod.fst_inv] at *,\n    exact ha,\n  end }\n\ntheorem normal_\u0394_iff_comm (G : Type*) [group G] : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\nbegin\n  split, \n  { rintro \u27e8h_sub, hn\u27e9 g h, \n    simp_rw [\u0394, set.mem_set_of_eq, prod.fst_mul, prod.snd_mul, prod.fst_inv, prod.snd_inv] at hn,\n    specialize hn (h, h) rfl (g, h),\n    apply eq_mul_of_mul_inv_eq, rw [hn, mul_inv_cancel_right], },\n  { intro h, constructor, \n    simp_rw [\u0394, set.mem_set_of_eq, prod.fst_mul, prod.snd_mul, prod.fst_inv, prod.snd_inv],\n    intros n heq g,\n    rw [h g.fst n.fst, h g.snd n.snd, mul_assoc, mul_assoc, mul_right_inv, mul_right_inv, heq], }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209549,"user_id":196,"body":"import Preloaded\n\nuniverse u\n\nvariables (G : Type u) [group G]\n\ninstance subgroup_\u0394 : is_subgroup (\u0394 G) :=\n{ mul_mem := \u03bb x y hx hy, congr_arg2 (*) hx hy,\n  one_mem := rfl,\n  inv_mem := \u03bb x hx, congr_arg (\u03bb g, g\u207b\u00b9) hx }\n\ntheorem normal_\u0394_iff_comm : normal_subgroup (\u0394 G) \u2194 \u2200 g h : G, g * h = h * g :=\n\u27e8\u03bb \u27e8h\u27e9 x y, eq_mul_of_mul_inv_eq $ (h (y, y) rfl (x, 1)).trans $\n  show 1 * y * 1\u207b\u00b9 = y, by rw [one_inv, mul_one, one_mul],\n\u03bb h, by letI : comm_group G := { mul_comm := h, .. _inst_1 };\n  exact normal_subgroup_of_comm_group _\u27e9\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb80c83eccaf80032feae69":[{"id":209550,"user_id":644,"body":"import tactic Preloaded\n\nopen nat\n\n\/-- Fibonacci! -\/\ndef euclid_not_constant_aux : \u03a0 n : \u2115, \u03a3' a b : \u2115, gcd_steps a b = n \u2227 a < b\n| 0     := \u27e80, 1, rfl, dec_trivial\u27e9\n| (n+1) := \nbegin\n  rcases euclid_not_constant_aux n with \u27e8a, b, h\u27e9,\n  cases a with a,\n  { rw [gcd_steps] at h,\n    rw \u2190 h.1,\n    exact \u27e81, 2, rfl, dec_trivial\u27e9 },\n  { cases b with b,\n    { rw [gcd_steps, zero_mod, gcd_steps, add_zero] at h,\n      exact \u27e82, 3, h.1 \u25b8 rfl, dec_trivial\u27e9 },\n    { refine \u27e8b.succ, a.succ + b.succ, _\u27e9,\n      rw [gcd_steps, add_mod_right, mod_eq_of_lt h.2, h.1, add_comm],\n      omega } }\nend\n\ntheorem euclid_not_constant (n : \u2115) : \u2203 a b, gcd_steps a b = n :=\nlet \u27e8a, b, h, _\u27e9 := euclid_not_constant_aux n in \u27e8a, b, h\u27e9","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209551,"user_id":168,"body":"import Preloaded tactic\n\nopen nat\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n :=\nbegin\n  intro n,\n  suffices : \u2203 a b, a \u2264 b \u2227 gcd_steps a b = n,\n    obtain \u27e8a, b, hab, h\u27e9 := this, exact \u27e8a, b, h\u27e9,\n  induction n with n ih, { exact \u27e80, 0, le_refl _, rfl\u27e9 },\n  obtain \u27e8a, b, hab, hg\u27e9 := ih,\n  rcases eq_or_lt_of_le hab with rfl | h,\n    cases a, refine \u27e81, 1, _\u27e9, rw \u2190hg, exact \u27e8le_refl _, rfl\u27e9,\n    refine \u27e82, 3, dec_trivial, _\u27e9,\n    rw [\u2190hg, gcd_steps, gcd_steps, mod_self], refl,\n  cases b, cases h,\n  refine \u27e8succ b, a + succ b, le_add_left _ _, _\u27e9,\n  rw [gcd_steps, add_mod_right, mod_eq_of_lt h, hg, add_comm],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209552,"user_id":null,"body":"import Preloaded\nimport data.nat.fib\nimport data.nat.basic\nimport tactic \n\nopen nat\n\nlemma mul_add_mod_own (a b c : \u2115) : (a * b + c) % b = c % b :=\nbegin \n  rw nat.add_mod,\n  rw nat.mul_mod,\n  simp,\nend\n\nlemma gcd_gt_1 : \u2200 m n, m > 0 \u2192 gcd_steps m n = 1 + gcd_steps (n % m) m :=\nbegin \n  intros m n,\n  cases m with k hk,\n  {\n    intro h0,\n    exfalso,\n    exact nat.lt_asymm h0 h0,\n  },\n  {\n    intros h, clear h,\n    simp [gcd_steps],\n  }\nend\n\nlemma fib_mod : \u2200 n > 2, fib (succ (succ n)) % fib (succ n) = fib n :=\nbegin \n  intros n hn,\n  rw fib_add_two,\n  suffices hn : (fib n + fib (n + 1)) =  (1 * fib (n + 1) + fib n),\n  {\n    rw [hn, mul_add_mod_own],\n    have hn2 : n = (n-2)+2,\n    rw tsub_add_cancel_of_le,\n    linarith,\n    rw hn2,\n    rw nat.mod_eq_of_lt,\n    apply fib_add_two_strict_mono,\n    linarith,\n  },\n  {\n    ring,\n  }\nend\ntheorem fibo_steps : \u2200 n, gcd_steps (fib (n+3)) (fib (n+4)) = n+2 :=\nbegin \n  intro n,\n  induction n with m hm,\n  {\n    simp [fib,gcd_steps],\n  },\n  {\n    rw [gcd_gt_1, fib_mod, hm],\n    ring,\n    rw succ_eq_one_add, linarith,\n    apply fib_pos,\n    linarith,\n  }\nend\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n :=\nbegin \n  intros n,\n  cases n with m hm,\n  {\n    use [0,0],\n    simp [gcd_steps],\n  },\n  cases m with k hk,\n  {\n    use [1,1],\n    simp [gcd_steps],\n  },\n  {\n    use [fib (k+3), fib (k+4)],\n    rw fibo_steps,\n\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209553,"user_id":null,"body":"import Preloaded\nimport tactic\n\ntheorem euclid_not_constant_le : \u2200 n, \u2203 a b, (a \u2264 b) \u2227 gcd_steps a b = n := \nbegin\n  intro n,\n  induction n with n ih,\n    use [0,0],rw gcd_steps, tauto,\n    cases ih with a hb, cases hb with b hab,\n    by_cases aeqb: a=b,\n      have neq1: (n=1 \u2227 a \u2260 0 \u2227 b \u2260 0) \u2228 (n=0 \u2227 a=0 \u2227 b=0),\n        cases b,\n          right,\n          rw [aeqb,gcd_steps] at hab, \n          tauto,\n          left,\n          rw [aeqb,gcd_steps] at hab,\n          rw [nat.mod_self,gcd_steps,add_zero] at hab,\n          simp [hab,aeqb], symmetry, exact hab.2,\n      cases neq1,\n      use [2,3], simp [gcd_steps, neq1],\n      use [1,1], simp [gcd_steps, neq1],\n      use [b,a+b],\n      have altb: a<b, \n        exact nat.lt_of_le_and_ne hab.1 aeqb,\n      have md: (a+b)%b = a,\n        simp, exact nat.mod_eq_of_lt altb,\n      split, \n      exact nat.le_add_left _ _,\n      have bne0: b\u2260 0, linarith,\n      cases b,\n        tauto,\n        rw [gcd_steps,md,hab.2,add_comm]       \nend\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n := \nbegin\n  intro n,\n  rcases euclid_not_constant_le n with \u27e8a,b,h\u27e9,\n  use [a,b], exact h.2\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209554,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\nlemma jvok {a b:\u2115} (h:a>b): gcd_steps a b = 1+gcd_steps b a:=by{\n  cases a,{\n    finish,\n  },{\n    simp [gcd_steps],\n    rw [mod_eq_of_lt],\n    exact gt_iff_lt.mp h,\n  },\n}\n\nlemma ifjdj {a b:\u2115} (h0:a<b) : (b*a+a)%b=a:=by{\n  rw [add_comm],\n  rw [add_mul_mod_self_left],\n  exact mod_eq_of_lt h0,\n}\n\nlemma gcd_steps_aux (a b n:\u2115)(h0:a<b)(h1:gcd_steps a b = n) : \u2203(x y:\u2115),(x<y)\u2227(gcd_steps x y) = n+1:=by{\n  cases a,{\n    simp [gcd_steps] at h1,\n    use 1,use 2,\n    split,norm_num,\n    simp [gcd_steps],\n    finish,\n  },\n  use b,\n  use (b*a.succ+a.succ),\n  split,{\n    have h2:a.succ=a+1,refl,\n    rw h2,\n    have h3:b\u2264b*(a+1),{\n      rw [mul_add],\n      norm_num,\n    },\n    have h4:0<a+1,norm_num,\n    have h5:b*(a+1) < b*(a+1) + (a+1),{\n      exact lt_add_of_pos_right (b*(a+1)) h4,\n    },\n    clear_except h3 h5,\n    exact gt_of_gt_of_ge h5 h3,\n  },\n  cases b,{\n    finish,\n  },{\n    simp [gcd_steps],\n    rw [ifjdj h0],\n    simp [h1],\n    rw [add_comm],\n  }\n}\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n := by{\n  intro n,\n  induction n with n hn,{\n    use 0,\n    use 1,\n    simp [gcd_steps],\n  },{\n    rcases hn with \u27e8a,\u27e8b,h0\u27e9\u27e9,\n    by_cases h1:(a>b),{\n      rw jvok h1 at h0,\n      replace h1:=gt_iff_lt.mp h1,\n      have h8:1\u2264n,exact le.intro h0,\n      have h3:gcd_steps b a =n-1,{\n        linarith,\n      },\n      have h2:=gcd_steps_aux b a (n-1) h1 h3,\n      rcases h2 with \u27e8x,\u27e8y,\u27e8h4,h5\u27e9\u27e9\u27e9,\n      have h7:n-1+1=n,linarith,\n      rw h7 at h5,\n      have h6:=gcd_steps_aux x y n h4 h5,\n      rcases h6 with \u27e8u,\u27e8z,\u27e8_,_\u27e9\u27e9\u27e9,\n      use u,use z,\n      rw [h6_h_h_right],\n    },{\n      by_cases h2:(a=b),{\n        rw h2 at h0,\n        cases b,\n        all_goals{\n          simp [gcd_steps] at h0,\n          rw [\u2190h0],\n          clear_except,\n        },{\n          use 1,use 1,\n          simp [gcd_steps],\n        },{\n          use 2,use 3,\n          simp [gcd_steps],\n        }\n      },{\n        push_neg at h1,\n        replace h1:=lt_of_le_of_ne h1 h2,\n        clear h2,\n        have h2:= gcd_steps_aux a b n h1 h0,\n        rcases h2 with \u27e8_,\u27e8_,\u27e8_,h3\u27e9\u27e9\u27e9,\n        use h2_w,use h2_h_w,\n        rw h3,\n      },\n    },\n  }\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209555,"user_id":null,"body":"import Preloaded tactic\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n := \nbegin\n  have h : \u2200 n, \u2203 a b, (gcd_steps a b = n) \u2227 (a < b),   \n  { intros n,\n    induction n with d hd,\n    { use [0, 1], \n      split, simp [gcd_steps], linarith },\n    rcases hd with \u27e8a, b, hs, hab\u27e9,\n    use [b, a+b+b], \n    split,\n    cases b, linarith,\n    simp [gcd_steps],\n    rw [nat.mod_eq_of_lt hab, hs, nat.succ_eq_add_one, add_comm],\n    linarith },\n  intros n,\n  rcases h n with \u27e8a, b, hab\u27e9,\n  use [a, b, hab.left],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209556,"user_id":197,"body":"import data.nat.fib tactic Preloaded\n\nopen nat\n\nlemma fib_mod (n : \u2115) : fib (n + 4) % fib (n + 3) = fib (n + 2) :=\nbegin\n  rw [fib_add_two, add_mod_right],\n  apply mod_eq_of_lt,\n  conv_rhs { rw fib_add_two },\n  apply nat.lt_add_of_pos_left,\n  apply fib_pos,\n  omega\nend\n\nlemma euclid_fib (n : \u2115) : gcd_steps (fib (n + 2)) (fib (n + 3)) = n + 1 :=\nbegin\n  induction n with d hd,\n  { norm_num [gcd_steps] },\n  { have := ne_of_lt (fib_pos (show 0 < succ d + 2, from succ_pos _)),\n    obtain \u27e8x, hx\u27e9 := exists_eq_succ_of_ne_zero this.symm,\n    rw [hx, gcd_steps, \u2190hx, fib_mod, hd],\n    omega }\nend\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n :=\nbegin\n  intro n,\n  cases n,\n  { exact \u27e80, 0, by rw gcd_steps\u27e9 },\n  { exact \u27e8fib (n + 2), fib (n + 3), euclid_fib n\u27e9 }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209557,"user_id":106,"body":"import Preloaded data.nat.basic\n\ndef fib : \u2115 \u2192 \u2115\n| 0 := 1\n| 1 := 2\n| (nat.succ (nat.succ x)) := fib x + fib x.succ\n\nlemma succ_destruct : \u2200 n : \u2115, n > 0 \u2192 (\u2203 x : \u2115, x.succ = n) :=\nbegin\n  intros n h, cases n,\n  { have := lt_irrefl _ h, contradiction },\n  { existsi n, refl }\nend\n\nlemma fib_pos : \u2200 n : \u2115, fib n > 0 :=\nbegin\n  intros n,\n  induction n with n ih,\n  { exact nat.zero_lt_one },\n  {\n    cases n with n n, all_goals { unfold fib, simp },\n    induction (fib n) with x ih, {\n      simp, assumption\n    }, {\n      have ih := lt_trans ih (lt_one_add (x + fib n.succ)),\n      rw [\u2190add_assoc, add_comm 1 x, \u2190nat.succ_eq_add_one] at ih, assumption\n    }\n  }\nend\n\nlemma fib_increasing: \u2200 n : \u2115, fib n < fib n.succ :=\nbegin\n  intros, induction n with n ih,\n  all_goals { unfold fib, simp },\n  apply fib_pos\nend\n\nlemma gt_mod_eq: \u2200 a b : \u2115, a < b \u2192 a % b = a :=\nbegin\n  intros a b h,\n  have h' := nat.mod_add_div a b,\n  rw [nat.div_eq_of_lt h, nat.mul_zero, nat.add_zero] at h', assumption\nend\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n :=\nbegin\n  intro n,\n  cases n, { existsi [0, 0], unfold gcd_steps },\n  existsi [fib n, fib n.succ],\n  induction n with n ih, {\n    unfold fib, repeat { simp, unfold gcd_steps }\n  }, {\n    unfold fib,\n    cases (succ_destruct (fib n.succ) (fib_pos _)) with x hx,\n    rw \u2190hx at *, unfold gcd_steps,\n    rw hx at *, rw [nat.add_mod_right, gt_mod_eq _ _ (fib_increasing n), ih, nat.add_comm],\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209558,"user_id":null,"body":"import Preloaded tactic\n\nopen nat\n\ndef fib' : \u2115 \u2192 \u2115\n| 0       := 0\n| 1       := 1\n| 2       := 2\n| (n + 3) := fib' (n+2) + fib' (n+1)\n\nlemma fib_pos_of_ne_zero : \u2200 n, n \u2260 0 \u2192 fib' n > 0 \n| 0       := \u03bb h, false.elim (h rfl)\n| 1       := \u03bb _, zero_lt_one\n| 2       := \u03bb _, zero_lt_two\n| (n+3)   := \u03bb h, by { dsimp [fib'], linarith [fib_pos_of_ne_zero n.succ (succ_ne_zero n)] }\n\nlemma strict_inc_fib : \u2200 n, fib' n < fib' (n+1)\n| 0     := zero_lt_one\n| 1     := one_lt_two\n| (n+2) := by { conv_rhs { rw fib'}, linarith [fib_pos_of_ne_zero n.succ (succ_ne_zero _)] }\n\ntheorem fib'_aux : \u2200 n, gcd_steps (fib' n) (fib' n.succ) = n\n| 0     := rfl\n| 1     := rfl\n| (n + 2) :=\nbegin\n  specialize fib'_aux (n.succ),\n  have h\u2081 : n + 2 = (n+1).succ, by {rw succ_eq_add_one}, rw h\u2081,\n  have h\u2082 : (fib' (n+1).succ).pred.succ = fib' (n+1).succ,\n  { rw succ_pred_eq_of_pos (fib_pos_of_ne_zero _ (succ_ne_zero _)), },\n  rw [\u2190h\u2082, gcd_steps], clear h\u2081, \n  conv_rhs {rw [succ_eq_add_one, add_comm]}, congr' 1, conv_rhs { rw \u2190succ_eq_add_one}, rw h\u2082,\n  convert fib'_aux, rw [fib', nat.add_mod],\n  simp only [succ_eq_add_one, show n + 1 + 1 = n + 2, by simp, mod_self, mod_mod, zero_add],\n  exact mod_eq_of_lt (strict_inc_fib _),\nend\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n := \u03bb n, \u27e8fib' n, fib' n.succ, fib'_aux n\u27e9 \n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209559,"user_id":null,"body":"import Preloaded tactic\nopen nat\n\nlemma euclid_not_constant_aux : \u2200 n, \u2203 a b, gcd_steps a b = (n + 1) \u2227 a < b \u2227 a > 0\n| 0 := \u27e81, 2, rfl, dec_trivial\u27e9\n| (n + 1) :=\nbegin\n    obtain \u27e8a, b, hab, a_lt_b, a_pos\u27e9 := euclid_not_constant_aux n,\n    refine \u27e8b, b + a, _, by linarith, by linarith\u27e9,\n    cases b, omega,\n    rw [gcd_steps, show (succ b + a) % succ b = a, by simp [*, mod_eq_of_lt], hab],\n    omega,\nend\n\ntheorem euclid_not_constant : \u2200 n, \u2203 a b, gcd_steps a b = n\n| 0 := \u27e80, 0, rfl\u27e9\n| (n + 1) :=\nbegin\n    obtain \u27e8a, b, hab, _, _\u27e9 := euclid_not_constant_aux n,\n    exact \u27e8a, b, hab\u27e9,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209560,"user_id":196,"body":"import Preloaded\n\nopen nat\n\ntheorem euclid_not_constant (n) : \u2203 a b, gcd_steps a b = n :=\nsuffices \u2203 a b, a < succ b \u2227 gcd_steps a (succ b) = n,\nfrom let \u27e8a, b, h1, h2\u27e9 := this in \u27e8a, succ b, h2\u27e9,\nnat.rec_on n \u27e80, 0, dec_trivial, rfl\u27e9 $ \u03bb n \u27e8a, b, h1, h2\u27e9,\nnat.cases_on a (\u03bb h1 h2, \u27e81, 1, dec_trivial, h2 \u25b8 rfl\u27e9) (\u03bb a h1 h2, \u27e8succ b, succ a + b,\nsucc_lt_succ $ nat.lt_add_of_pos_left $ succ_pos a,\nshow 1 + gcd_steps _ _ = _, by rw [\u2190 add_succ, add_mod_right, mod_eq_of_lt h1, h2, one_add]\u27e9) h1 h2\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eb8aefefaa14a0001c915e8":[{"id":209561,"user_id":null,"body":"import logic.function\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g := by\n{\n  funext x,\n  specialize hf x,\n  specialize hfg (f x),\n  rw hf at hfg,\n  rw hfg\n}\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g := by\n{\n  funext x,\n  specialize hf (g x),\n  specialize hfg x,\n  rwa hfg at hf\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209562,"user_id":null,"body":"import logic.function.basic \n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g :=\nbegin\n  funext,\n  rw [\u2190 hfg (f x), hf],\nend\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g :=\nbegin\n  funext,\n  rw [\u2190 hf (g x), hfg],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209563,"user_id":null,"body":"import logic.function.basic tactic\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g :=\nbegin\n  simp [involutive,left_inverse] at *,\n  ext,\n  rw [\u2190 hf x,hfg _,hf _],\nend\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g :=\nbegin\n  simp [involutive] at hf,\n  change left_inverse f g at hfg,\n  simp [left_inverse] at hfg,\n  ext,\n  rw [\u2190 hf (g x), hfg x],\nend\n  ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209564,"user_id":null,"body":"import logic.function.basic\nimport tactic\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g :=\nby { ext,exact (eq.symm (hfg (f x))).trans (congr_arg g (hf x)) }\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g :=\nby { ext,exact (congr_arg f (eq.symm (hfg x))).trans (hf (g x)) }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209565,"user_id":null,"body":"import logic.function.basic tactic\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g := \nbegin  \n  ext, \n  calc f x = g (f (f x)) : by rw hfg (f x)\n       ... = g x : by rw hf x,\n end\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g := \nbegin\n  ext,\n  calc f x = f (f (g x)) : by rw hfg x\n       ... = g x : by rw hf (g x),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209566,"user_id":null,"body":"import logic.function.basic\nopen function\nvariables {\u03b1: Type} (f g: \u03b1 \u2192 \u03b1)\nlemma left (hf: involutive f) (hfg: left_inverse g f): f = g := by { funext, rw [\u2190 hf x, hfg, hf] }\nlemma right (hf: involutive f) (hfg: right_inverse g f): f = g := by { funext, rw [\u2190 hf (g x), hfg] }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209567,"user_id":null,"body":"import logic.function.basic\nopen function\n\nlemma left {\u03b1: Type} (f g: \u03b1 \u2192 \u03b1) (hf: involutive f) (hfg: left_inverse g f): \nf = g := by { funext, rw [\u2190 hf x, hfg, hf] }\n\nlemma right {\u03b1: Type} (f g: \u03b1 \u2192 \u03b1) (hf: involutive f) (hfg: right_inverse g f): \nf = g := by { funext, rw [\u2190 hf (g x), hfg] }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209568,"user_id":null,"body":"import logic.function.basic\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g := \n  begin\n    apply funext,\n    intro x,\n    rw involutive at hf,\n    rw left_inverse at hfg,\n    have hfx, from hf x,\n    have hfgx, from hfg (f x),\n    have h1, from congr_arg g hfx,\n    rw hfgx at h1,\n    assumption,\n  end\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g :=\n  begin\n    apply funext,\n    intro x,\n    rw involutive at hf,\n    rw function.right_inverse at hfg,\n    rw left_inverse at hfg,\n    have hfgx, from hfg x,\n    have h1, from congr_arg f hfgx,\n    have h2, from hf (g x),\n    rw h1 at h2,\n    assumption,\n  end\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209569,"user_id":76,"body":"import logic.function.basic\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g :=\nbegin\n  refine funext _,\n  intro h,\n  exact (eq.symm (hfg (f h))).trans (congr_arg g (hf h))\nend\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g :=\nbegin\n  refine funext _,\n  intro h,\n  exact (congr_arg f (eq.symm (hfg h))).trans (hf (g h))\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209570,"user_id":null,"body":"import logic.function.basic\n\nopen function\n\nlemma left {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : left_inverse g f) : f = g := by \n  {\n      funext,\n      have h : g x = g (f (f x)), rw hf,\n      rw h, rw hfg,\n  }\n\nlemma right {\u03b1: Type} (f g : \u03b1 \u2192 \u03b1)\n  (hf : involutive f) (hfg : right_inverse g f) : f = g := by\n  {\n    funext,\n    have h : g x = f (f (g x)), rw hf,\n    rw h, rw hfg,\n  }","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ebba64d6d3d0c003305db14":[{"id":209571,"user_id":null,"body":"import data.nat.prime\nimport tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n  have ab: 1 < a^b,\n   apply nat.one_lt_pow  b a (by linarith [hb]) ha,\n   have to2: (a^b+1)=2 \u2228 (a^b+1)%2=1,\n      apply nat.prime.eq_two_or_odd hp,\n      have tne2: a^b+1\u2260 2, linarith,\n      have todd: (a^b+1)%2=1,\n        cases to2 with even odd,\n          contradiction, exact odd,\n          have td: 2\u2223((a^b+1)-(a^b+1)%2),\n            apply nat.dvd_sub_mod (a^b+1),\n  rw todd at td,\n  have tdab: 2\u2223 a^b,\n    rw nat.add_sub_cancel (a^b) 1 at td, exact td,\n    apply nat.prime.dvd_of_dvd_pow (nat.prime_two) td\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209572,"user_id":null,"body":"import data.nat.prime tactic data.nat.parity\n\nlemma jsdf {n:\u2115}: odd (n+1)\u2192even n:=by{\n  intro h,\n  by_contra h0,\n  replace h0:=nat.odd_iff_not_even.mpr h0,\n  have h1:odd 1,norm_num,\n  have h2:even (n+1),exact nat.odd.add_odd h0 h1,\n  finish,\n}\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nby{\n  replace hp:= nat.prime.eq_two_or_odd hp,\n  cases hp with h0,{\n    have h1:a^b>1,{\n      refine one_lt_pow ha _,\n      omega,\n    },\n    linarith,\n  },\n  rw [\u2190even_iff_two_dvd],\n  rw [\u2190nat.odd_iff] at hp,\n  replace hp:=jsdf hp,\n  refine (nat.even_pow' _).mp _,\n  exact b,\n  linarith,\n  assumption,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209573,"user_id":197,"body":"import data.nat.prime data.nat.modeq data.nat.parity tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n  cases nat.prime.eq_two_or_odd hp,\n  { suffices : a \u2264 1, linarith,\n    have : a < a^b,\n    { conv_lhs { rw \u2190pow_one a },\n      exact nat.pow_lt_pow_of_lt_right ha hb },\n    omega },\n  suffices : even (a^b),\n  { exact (nat.even_pow.1 this).1 },\n  rw (show a^b = (a^b + 1) - 1, by simp),\n  apply (nat.even_sub (nat.zero_lt_succ _)).2,\n  simp only [nat.not_even_one, iff_false],\n  exact nat.not_even_iff.2 h\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209574,"user_id":null,"body":"import data.nat.prime tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) \n  : 2 \u2223 a :=\nbegin  \n  cases nat.prime.eq_two_or_odd hp with h1 h2,\n  { exfalso, \n    have hab := nat.one_lt_pow b a (by linarith [hb]) ha,\n    linarith [hab], },\n  { have h3 := nat.two_mul_odd_div_two h2,\n    have h4 : 2 \u2223 a^b := \u27e8((a ^ b + 1) \/ 2), by simp [h3]\u27e9,\n    apply nat.prime.dvd_of_dvd_pow nat.prime_two h4, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209575,"user_id":106,"body":"import data.nat.prime\nimport data.nat.parity\nimport tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n  cases nat.prime.eq_two_or_odd hp with h h, {\n    have hz := pow_lt_pow_of_lt_left ha zero_le_one (by linarith : b > 0),\n    rw one_pow at hz, linarith\n  }, {\n    have h : (a ^ b + 1) % 2 = 1 % 2, by rwa nat.one_mod,\n    have h := nat.sub_mod_eq_zero_of_mod_eq h,\n    rw [nat.add_sub_cancel, \u2190nat.even_iff, nat.even_pow, nat.even_iff, \u2190nat.dvd_iff_mod_eq_zero] at h,\n    cc\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209576,"user_id":644,"body":"import data.nat.prime tactic data.nat.parity\n\nopen nat\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1)\n  (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nhave \u00ac even (a ^ b + 1), \n  from hp.eq_two_or_odd.elim \n    (\u03bb h, begin\n      have : 1 < a ^ b, from nat.one_lt_pow _ _ (by linarith) ha,\n      linarith\n    end)\n    (by simp [nat.not_even_iff]),\nbegin\n  simp with parity_simps at this,\n  exact this.1\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209577,"user_id":null,"body":"import data.nat.prime tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n    cases nat.prime.eq_two_or_odd hp with hab hab,\n    {   exfalso,\n        linarith [nat.lt_pow_self ha b],\n    },\n    {   have ab_mod_2 : a^b % 2 = 0,\n        {   have : (a^b) % 2 < 2 := nat.mod_lt (a^b) two_pos,\n            interval_cases (a^b % 2),\n            { tauto, },\n            { rw nat.add_mod at hab,\n              rw h at hab,\n              rw (show (1 + 1 % 2) % 2 = 0, from by ring) at hab,\n              exfalso,\n              tauto,\n            },\n        },\n        have two_dvd_ab : 2 \u2223 a^b := nat.dvd_of_mod_eq_zero ab_mod_2,\n        exact nat.prime.dvd_of_dvd_pow nat.prime_two two_dvd_ab,\n    },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209578,"user_id":722,"body":"import data.nat.prime\n       tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n  refine nat.prime.dvd_of_dvd_pow nat.prime_two (show 2 \u2223 a^b, from _),\n  by_contra h,\n  rw nat.dvd_iff_mod_eq_zero at h,\n  have hrem : (a^b) % 2 = 1, from or.resolve_left (nat.mod_two_eq_zero_or_one _) h,\n  set k := (a^b)\/2 with hk,\n  have hab : (a^b) = 1 + 2*k,\n  suffices : (a^b) = (a^b)%2 + 2*k, { rwa hrem at this },\n  { rw nat.mod_add_div },\n  rw [hab, (show 1 + 2 * k + 1 = 2*(k+1), by ring)] at hp,\n  refine nat.not_prime_mul dec_trivial _ hp,\n  suffices : k \u2260 0, by omega,\n  rw [hk, ne.def, nat.div_eq_zero_iff (show 0 < 2, from dec_trivial)],\n  have h1 : a \u2265 2, from ha,\n  have h2 : a^b \u2265 2^b, from nat.pow_le_pow_of_le_left h1 b,\n  have h3 : 2^b \u2265 2^1, from nat.pow_le_pow_of_le_right dec_trivial (le_of_lt hb),\n  have h4 : a^b \u2265 2, from le_trans h3 h2,\n  intro h5,\n  exact not_le_of_lt h5 h4,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209579,"user_id":168,"body":"import data.nat.prime data.nat.parity tactic\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n  by_cases he : nat.even a, exact he,\n  have hp2 : nat.even (a ^ b + 1), finish [nat.even_add, nat.even_pow],\n  linarith [lt_trans hb (nat.lt_pow_self ha _), (@nat.dvd_prime_two_le _ 2 hp dec_trivial).1 hp2]\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209580,"user_id":196,"body":"import data.nat.prime data.nat.modeq\n\n-- Lemma copied from my solution in https:\/\/www.codewars.com\/kata\/reviews\/5eb8141afaa14a0001af33e8\/groups\/5ebaa6e94187b80001baacf6\ntheorem nat.pow_eq_one : \u2200 (x y : \u2115), x ^ y = 1 \u2194 x = 1 \u2228 y = 0\n| 0     0     := dec_trivial\n| 0     (y+1) := dec_trivial\n| 1     y     := iff_of_true y.one_pow $ or.inl rfl\n| (x+2) 0     := iff_of_true rfl $ or.inr rfl\n| (x+2) (y+1) := iff_of_false (ne_of_gt $ nat.pow_lt_pow_of_lt_right (nat.le_add_left 2 x) y.succ_pos)\n    (by rintros (H|H); cases H)\n\ntheorem even_of_prime_succ_pow (a b : \u2115) (ha : a > 1) (hb : b > 1) (hp : nat.prime (a^b + 1)) : 2 \u2223 a :=\nbegin\n  cases hp.eq_two_or_odd with hab hab,\n  { replace hab := nat.add_right_cancel hab,\n    rw nat.pow_eq_one at hab,\n    rcases hab with rfl|rfl,\n    { exact absurd ha (lt_irrefl 1) },\n    { cases hb } },\n  { replace hab : a^b%2=0%2 := nat.modeq.modeq_add_cancel_right rfl hab,\n    replace hab := nat.modeq.modeq_zero_iff.1 hab,\n    exact nat.prime_two.dvd_of_dvd_pow hab }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5ebc0adb01409100192bdc71":[{"id":209581,"user_id":null,"body":"import data.equiv.mul_add data.rat.basic\nimport tactic\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin\n  have ha : \u2203 a : \u2124, a + a = 1,\n  {\n    use f.symm (f 1 \/2),\n    unfold_coes,\n    rw \u2190 f.symm.map_add',\n    apply f.injective,\n    simp,\n  },\n  clear f,\n  rcases ha with \u27e8a, ha\u27e9,\n  omega,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209582,"user_id":null,"body":"import data.equiv.mul_add data.rat.basic data.int.parity\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin\n  obtain \u27e8x, hx\u27e9 := add_equiv.surjective f ((f 1) \/ 2),\n  have odd_one : odd (1 : \u2124), by { use 0, simp, },\n  suffices : 1 = x + x, by { apply int.even_iff_not_odd.1 _ odd_one, use x, convert this, apply two_mul },\n  apply add_equiv.injective f,\n  rw [map_add f x x, hx, add_halves (f 1)],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209583,"user_id":null,"body":"import tactic\nimport data.equiv.mul_add data.rat.basic\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin    \n  let x := f.to_fun 1,\n  let y := f.inv_fun (x\/2),\n  have h : f.to_fun (y + y) = x,\n  { simp [y] },   \n  change f.to_fun (y + y) = f.to_fun 1 at h,\n  have c := congr_arg f.inv_fun h,\n  repeat { rw add_equiv.left_inv f at c },\n  have d : 2 \u2223 (1 : \u2124) := \u27e8y, by linarith\u27e9,\n  cases (int.eq_one_of_dvd_one (by linarith) d),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209584,"user_id":null,"body":"import data.equiv.mul_add\nimport data.rat.basic data.rat.order\nimport algebra.associated\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin\n  have \u03c6 := add_equiv.symm f,\n  have g : function.surjective \u03c6 := \u03c6.to_equiv.surjective,\n  have h := g 1,\n  cases h with r h,\n  rw <- add_halves r at h,\n  rw add_equiv.map_add at h,\n  rw <- mul_two at h,\n  have i := dvd.intro_left (\u03c6 (r\/2)) h,\n  rw <- is_unit_iff_dvd_one at i,\n  rw is_unit_int at i,\n  cases i\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209585,"user_id":null,"body":"import data.equiv.mul_add data.rat.basic\nimport tactic\n\nlemma not_two_mul_eq_one {x : \u2124} (h : 2 * x = 1) : false := \nbegin\n  by_cases k : x = 0,\n  { linarith, },\n  { apply k, linarith, }\nend\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin\n  cases f with \u03b8 \u03b8\u2082 hlinv hrinv hom,\n  cases (function.right_inverse.surjective hrinv ((\u03b8 1)\/2)) with x hx,\n  have h\u2082 : \u03b8 (x + x) = \u03b8 1, from\n    (hom x x).symm \u25b8 (two_mul (\u03b8 x)) \u25b8 ((mul_div_cancel' (\u03b8 1) two_ne_zero) \u25b8 (congr_arg _ hx)),\n  have h\u2083 : x + x = 1, from (function.left_inverse.injective hlinv) h\u2082,\n  exact not_two_mul_eq_one (show 2 * x = 1, from (two_mul x).symm \u25b8 h\u2083),\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209586,"user_id":null,"body":"import data.equiv.mul_add data.rat.basic tactic\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin\n    let q := f 1,\n    have : q \u2260 0,\n    {   rw [\u2190 add_equiv.map_zero f, show q = f.to_fun 1, from rfl,\n            show f 0 = f.to_fun 0, from rfl],\n        intro h,\n        have := equiv.injective (add_equiv.to_equiv f) h,\n        omega,\n    },\n    let n := f.inv_fun (q\/2),\n    have hq : (q\/2) + (q\/2) = q := by linarith,\n    have hn : f n = q\/2 := f.right_inv (q\/2),\n    have hn' : n + n = 1,\n    {   apply (equiv.injective (add_equiv.to_equiv f)),\n        change f.to_fun (n + n) = q,\n        rw [f.map_add', \u2190 hq, \u2190 hn],\n        refl,\n    },\n    omega,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209587,"user_id":644,"body":"import data.equiv.mul_add data.rat.basic tactic\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\n(show \u00ac ((2 : \u2124) \u2223 1), by norm_num) \n  \u27e8f.symm (f 1 \/ 2), \n    by rw [two_mul, \u2190 add_equiv.map_add, div_add_div_same, \u2190 two_mul, mul_div_cancel_left]; \n    simp; norm_num\u27e9 ","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209588,"user_id":106,"body":"import data.equiv.mul_add data.rat.basic data.int.basic data.int.parity\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false := begin\n  cases (add_equiv.symm f),\n  let Z1Q := inv_fun 1,\n  have HZ1Q : to_fun Z1Q = 1, by apply right_inv 1,\n  specialize map_add' (Z1Q \/ 2) (Z1Q \/ 2),\n  have H2F : (Z1Q \/ 2 + Z1Q \/ 2 = Z1Q), by ring,\n  have HF2 : to_fun (Z1Q \/ 2) + to_fun (Z1Q \/ 2) = 2 * to_fun (Z1Q \/ 2), by ring,\n  rw H2F at map_add', rw HF2 at map_add', rw HZ1Q at map_add',\n  have H := congr_arg (\u03bb (x : \u2124), x % 2) map_add', simp at H,\n  exact int.not_even_one H\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209589,"user_id":657,"body":"import tactic\nimport data.equiv.mul_add data.rat.basic\n\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\nbegin \nhave key : \u2200 x : \u211a, \u2203half, x = half + half,\n{intro x, use (x\/2), ring},\nhave key2 : \u00ac \u2200 x : \u2124 , \u2203half, x = half + half,\n{push_neg, existsi (1 : \u2124), intro,omega},\n\nrevert key2, rw imp_false, rw classical.not_not,\nintro x, cases key (f x) with q hq,\nlet g := add_equiv.symm f,\nuse g q,\nrw [\u2190g.map_add, \u2190 hq],\nrw add_equiv.symm_apply_apply f,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209590,"user_id":196,"body":"import data.equiv.mul_add data.rat.order\n\ntheorem int_not_iso_rat (f : \u2124 \u2243+ \u211a) : false :=\none_ne_zero $ calc (1 % 2 : \u2124)\n    = f.symm (f 1) % 2 : by rw add_equiv.symm_apply_apply\n... = f.symm ((f 1 \/ 2) + (f 1 \/ 2)) % 2 : by rw add_halves\n... = (f.symm (f 1 \/ 2) + f.symm (f 1 \/ 2)) % 2 : by rw f.symm.map_add\n... = (f.symm (f 1 \/ 2) * 2) % 2 : by rw mul_two\n... = 0 : by rw int.mul_mod_left\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eec40dfe5d13e0001234d01":[{"id":209591,"user_id":null,"body":"import Preloaded data.list.basic \nopen list\n\nvariables (c : char) (n : \u2115) (s : list char)\n\ntheorem leftpad_length : (leftpad c n s).length = max n s.length :=\nby { by_cases n \u2265 s.length,\n     { simp [leftpad, max_eq_left h, nat.sub_add_cancel h], },\n     { simp [leftpad, nat.sub_eq_zero_of_le (le_of_not_ge h), max_eq_right (le_of_not_ge h)], }, }\n\n\ntheorem leftpad_prefix : \u2200 p \u2208 list.take (n - s.length) (leftpad c n s), p = c :=\n\u03bb _ _, by { apply eq_of_mem_repeat, \n            rwa [\u2190 append_nil (repeat _ _), \u2190 take_zero, \u2190 take_append, length_repeat] }\n\ntheorem leftpad_suffix : list.drop (n - s.length) (leftpad c n s) = s :=\nby rw [\u2190 length_repeat c (n - length s), leftpad, \u2190 add_zero (repeat c _).length, drop_append, drop]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209592,"user_id":null,"body":"import Preloaded tactic\n\nvariables (c : char) (n : \u2115) (s : list char)\n\ntheorem leftpad_length :\n  (leftpad c n s).length = max n s.length :=\nby{\n  simp [leftpad,max,max_default],\n  by_cases h0:s.length\u2264n,{\n    rw [if_pos h0],\n    linarith,\n  },\n  rw [if_neg h0],\n  omega,\n}\n\ntheorem leftpad_prefix :\n  \u2200 p \u2208 list.take (n - s.length) (leftpad c n s), p = c :=\nby{\n  intros p,\n  simp [list.take,leftpad],\n  generalize : (n-s.length)=x,\n  intro h0,\n  induction x with x hx,{\n    dsimp at h0,\n    tauto,\n  },\n  dsimp at h0,\n  cases h0,{\n    assumption,\n  },\n  exact hx h0,\n}\n\ntheorem leftpad_suffix :\n  list.drop (n - s.length) (leftpad c n s) = s :=\nby{\n  simp [list.drop,leftpad],\n  generalize : (n-s.length)=x,\n  induction x with x hx,{\n    simp,\n  },\n  simpa,\n}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209593,"user_id":null,"body":"import Preloaded tactic\n\nvariables (c : char) (n : \u2115) (s : list char)\n\ntheorem leftpad_length :\n  (leftpad c n s).length = max n s.length :=\nbegin\n  simp [leftpad],\n  by_cases n \u2264 s.length,\n    { simp [h, nat.sub_eq_zero_of_le h] },\n    { push_neg at h, \n      replace h := le_of_lt h, \n      simp [h, nat.sub_add_cancel] } \nend\n\ntheorem leftpad_prefix :\n  \u2200 p \u2208 list.take (n - s.length) (leftpad c n s), p = c :=\nbegin\n  intros p hp,\n  simp [leftpad] at hp,\n  rw list.take_append_of_le_length at hp,\n  simp [list.take_repeat] at hp,  \n  apply list.mem_singleton.mp,\n  exact list.repeat_subset_singleton c (n-s.length) hp,  \n  by_cases n \u2264 s.length; simp [h],\n  push_neg at h, \n  replace h := le_of_lt h, \n  simp [h, nat.sub_add_cancel]    \nend\n\ntheorem leftpad_suffix :\n  list.drop (n - s.length) (leftpad c n s) = s :=\nbegin\n  convert list.drop_append 0,\n  simp,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209594,"user_id":191,"body":"import Preloaded tactic\n\nvariables (c : char) (n : \u2115) (s : list char)\n\ntheorem leftpad_length :\n  (leftpad c n s).length = max n s.length :=\nbegin\n  unfold leftpad,\n  rw list.length_append,\n  rw list.length_repeat,\n  exact tsub_add_eq_max\nend\n\ntheorem leftpad_prefix :\n  \u2200 p \u2208 list.take (n - s.length) (leftpad c n s), p = c :=\nbegin\n  unfold leftpad,\n  rw list.take_append_of_le_length,\n  rw list.take_repeat,\n  apply list.eq_repeat'.1,\n  rw min_eq_right,\n  rw list.length_repeat,\n  refl,\n  rw list.length_repeat,\nend\n\ntheorem leftpad_suffix :\n  list.drop (n - s.length) (leftpad c n s) = s :=\nbegin\n  unfold leftpad,\n  convert list.drop_left _ _,\n  rw list.length_repeat,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209595,"user_id":null,"body":"import Preloaded\nimport tactic\n\nvariables (c : char) (n : \u2115) (s : list char)\n\ntheorem leftpad_length :\n  (leftpad c n s).length = max n s.length :=\nbegin\n  rw leftpad,\n  by_cases h : n <= s.length,\n  { rw max_eq_right h,\n    have hsub : n - s.length = 0 := nat.sub_eq_zero_of_le h,\n    simp [hsub],\n  },\n  { simp at h,\n    rw max_eq_left_of_lt h,\n    simp,\n    rw nat.sub_add_cancel (le_of_lt h),\n  },\nend\n\ntheorem leftpad_prefix :\n  \u2200 p \u2208 list.take (n - s.length) (leftpad c n s), p = c :=\nbegin\n  intros p hp,\n  rw leftpad at hp,\n  conv at hp begin\n    congr, skip, congr,\n    rw [\u2190list.length_repeat c (n - s.length), \u2190add_zero (list.length _)],\n  end,\n  rw [list.take_append 0, list.take_zero, list.append_nil] at hp,\n  exact list.eq_of_mem_repeat hp,\nend\n\ntheorem leftpad_suffix :\n  list.drop (n - s.length) (leftpad c n s) = s :=\nbegin\n  rw leftpad,\n  conv begin\n    to_lhs, congr,\n    rw [\u2190list.length_repeat c (n - s.length), \u2190add_zero (list.length _)],\n  end,\n  rw [list.drop_append 0, list.drop],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209596,"user_id":168,"body":"import Preloaded\nimport data.list\n\nvariables (c : char) (n : \u2115) (s : list char)\n\ntheorem leftpad_length :\n  (leftpad c n s).length = max n s.length :=\nbegin\n  rw [leftpad, list.length_append, list.length_repeat],\n  exact nat.sub_add_eq_max n _,\nend\n\ntheorem leftpad_prefix :\n  \u2200 p \u2208 list.take (n - s.length) (leftpad c n s), p = c :=\nbegin\n  rw [leftpad, list.take_append_of_le_length],\n  { rw list.take_repeat, intros x h,\n    exact list.eq_of_mem_repeat h, },\n  { rw list.length_repeat, },\nend\n\ntheorem leftpad_suffix :\n  list.drop (n - s.length) (leftpad c n s) = s :=\nbegin\n  rw [leftpad, list.drop_left'], rw list.length_repeat,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5eee3937ffe966002d3c1f6c":[{"id":209597,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := \nbegin\n  intro h, -- 2 \u2223 n\n\n  rw sub_mul, -- (a - b) * c = a*c - b*c\n  rw one_mul, -- 1*a = a\n  rw int.div_mul_cancel h, -- 2 \u2223 a \u2192 2 \/ 2 * 2 = a\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209598,"user_id":722,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := begin\n  intro hn,\n  rw [sub_mul, one_mul, mul_comm, int.mul_div_cancel' hn]\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209599,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := begin\n  intro h,\n  rcases h with \u27e8k, rfl\u27e9,\n  rw int.mul_div_cancel_left k two_ne_zero,\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209600,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := begin\n  rintro \u27e8k, rfl\u27e9,\n  norm_num,\n  ring,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209601,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 :=\nbegin\n  intro h,\n  cases h with x hx,\n  rw hx,\n  simp,\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209602,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := \n\u03bb h, by rw [mul_sub_right_distrib, int.div_mul_cancel h, one_mul]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209603,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := begin\n  intro h,\n  have h\u2081:(n \/ 2 - 1) * 2=n\/2*2-1*2,{\n    simp[sub_mul],\n  },\n  have h\u2082:n\/2*2=n,{\n    simp[int.div_mul_cancel h],\n  },\n  rw [h\u2081,h\u2082],\n  ring,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209604,"user_id":null,"body":"import Preloaded tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := begin\n  intros h,\n  rw [ sub_mul, int.div_mul_cancel h],\n  simp,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209605,"user_id":null,"body":"import tactic\ntheorem div2predmul2 (n: \u2124): 2 \u2223 n \u2192 (n\/2-1)*2 = n-2 := \nby {intro h, rw [sub_mul, int.div_mul_cancel h, one_mul]}","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209606,"user_id":null,"body":"import tactic\n\ntheorem div2predmul2 (n : \u2124) : 2 \u2223 n \u2192 (n \/ 2 - 1) * 2 = n - 2 := begin\n  intro h,\n  rw [sub_mul, one_mul, int.div_mul_cancel h],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"5f22c23ba72c3b000162a352":[{"id":209607,"user_id":null,"body":"import data.nat.basic tactic\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n := by\nbegin\n  existsi 0,\n  split,\n  simp,\n  intros  y p,\n  cases p,\n  cases p_h,\n  have h:= (p_h_right y (by simp)),\n  rw h,\n  have h1:= (p_h_right 0 (by simp)),\n  exact (h1.symm),\n  end\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209608,"user_id":null,"body":"import tactic.basic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  use [0,0];\n  simp,\n  split,\n  refl,\n  exact \u03bb y hy, nat.eq_zero_of_le_zero hy,\n  intros y hy,\n  cases y,\n  refl,\n  cases hy with z hyz,\n  simp only at hyz,\n  have :=hyz.2 y (nat.le_succ y),\n  have :=hyz.2 y.succ (by refl),\n  have := nat.succ_ne_self z,\n  cc,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209609,"user_id":null,"body":"import tactic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  existsi 0, simp,\n  intros y, cases y, simp,\n  intro h,\n  apply unique_of_exists_unique h,\n    exact le_rfl,\n    exact (zero_le _)\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209610,"user_id":191,"body":"import tactic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  use 0,\n  split,\n    use 0,\n    split,\n      dsimp,\n      refl,\n    dsimp only,\n    rintro _ h,\n    exact le_bot_iff.mp h,\n  rintro n h,\n  rcases h with \u27e8m, _, h\u27e9,\n  rw h n (rfl.le),\n  rw h 0 (zero_le n)\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209611,"user_id":null,"body":"import tactic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin    \n  unfold exists_unique,\n  use 0,\n  split,\n  { use [0, refl 0],\n    intros y hy,\n    exact nat.le_zero_iff.mp hy },\n  intros y h,\n  rcases h with \u27e8x, h1, h2\u27e9,\n  have t1 := h2 0 (nat.zero_le y),\n  have t2 := h2 y (refl y),\n  simp [t1, t2],\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209612,"user_id":null,"body":"import tactic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  use 0, use 0, split, simp,\n  intros y h, exact le_antisymm h (zero_le y),\n  intros n h\u2081, by_contra,\n  cases h\u2081 with h\u2081 p, cases p with p q,\n  have puppy := q 0 (zero_le n),\n  \n  have zzz : 0 < n := \n  begin\n    by_contra H, push_neg at H, have : n \u2265 0 := zero_le n,\n    have z : n = 0 := le_antisymm H this, exact a z,\n  end,\n  \n  have kitten := q 1 (nat.succ_le_iff.mpr (zzz)), linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209613,"user_id":null,"body":"import tactic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  unfold exists_unique,\n  use [0, by simp],\n  { rintro x \u27e8y, -, h\u27e9,\n    rw [h 0 (zero_le _), h x (by refl)], },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209614,"user_id":null,"body":"theorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  unfold exists_unique,\n  existsi 0,\n  split,\n  {\n    existsi 0,\n    split,\n    { constructor },\n    { apply nat.eq_zero_of_le_zero },\n  },\n  {\n    intros y h,\n    cases h with x h,\n    cases h with hxy h,\n    cases y with y y,\n    { refl },\n    {\n      exfalso,\n      have : 0 = x,\n      { apply h, apply nat.zero_le },\n      apply nat.zero_ne_one,\n      rw this,\n      symmetry,\n      apply h,\n      apply nat.succ_le_succ,\n      apply nat.zero_le,\n    },\n  },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209615,"user_id":null,"body":"import tactic\n\ntheorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  use 0,\n  split, {tidy,},\n  rintros y \u27e8x, hy, hz\u27e9,\n  simp at hz,\n  cases x with d hd,\n  {\n    exact hz y (by linarith),\n  },\n  {\n    have := hz d (by linarith [nat.le_succ d]),\n    change d = d + 1 at this,\n    linarith,\n  },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209616,"user_id":106,"body":"theorem exists_unique_le : \u2203! n m : \u2115, m \u2264 n :=\nbegin\n  existsi 0, simp, split,\n  {\n    existsi 0, simp, split,\n    exact le_refl 0,\n    apply nat.eq_zero_of_le_zero\n  },\n  {\n    intros n H, cases H with m H, simp at H, cases H with Ha Hb,\n    have H0 := Hb 0 (nat.zero_le n),\n    have Hn := Hb n (nat.le_refl n),\n    rw H0, rw Hn\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"60b49f44080926003a20bbed":[{"id":209617,"user_id":null,"body":"import Preloaded tactic\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\nbegin\n  split,\n  { intros _ h;\n    induction l with a L IH; cases h,\n    { simp [list_max_Z, h, le_max_left a],      }, \n    { exact le_trans (IH h) (le_max_right a (list_max_Z L)), }, },\n  { induction l with _ _ IH; simp only [list_max_Z, list.foldr],\n    { tauto, },\n    { cases IH;\n      { rw [list.mem_cons_iff, max_eq_left_iff, \u2190 list_max_Z, or_iff_not_imp_left, not_or_distrib],\n        rintro \u27e8h1, h2\u27e9,\n        rw max_eq_right_of_lt (not_le.1 h1) at h2 \u22a2,\n        tauto, }, }, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209618,"user_id":null,"body":"import Preloaded\n\nimport tactic\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\n  begin\n    split,\n    { intros x hx,\n      induction l with head tail ind_hyp,\n      { cases hx},\n      cases hx,\n      { rw [list_max_Z, list.foldr, hx],\n        apply le_max_left,},\n      { rw [list_max_Z, list.foldr],\n        have h := ind_hyp(hx), \n        rw \u2190 list_max_Z,\n        by_cases side : head <= list_max_Z tail,\n        { rw max_eq_right,\n          repeat {assumption},},\n        { rw not_le at side,\n          rw max_eq_left_of_lt,\n          linarith,\n          assumption,}},\n    },\n    induction l with head tail ind_hyp,\n    { right,\n      rw [list_max_Z],\n      simp,},\n    rw [list_max_Z, list.foldr],\n    by_cases side : head <= list.foldr max 0 tail,\n    { rw max_eq_right,\n      cases ind_hyp,\n      { left,\n        right,\n        rw \u2190 list_max_Z,\n        assumption,},\n      { rw list_max_Z at ind_hyp,\n        right,\n        assumption},\n        assumption},\n      have : list.foldr max 0 tail <= head,\n      { exact le_of_not_le(side)},\n      rw max_eq_left(this),\n      left,\n      left,\n      refl,\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209619,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\n  begin\n    simp,\n    unfold list_max_Z,\n    induction l with y l hl,\n    {\n      split,\n      intros x hx,\n      finish,\n      simp,\n    },\n    {\n      cases hl with hl1 hl2,\n      split,\n      intros x hx,\n      cases hx,\n      rw hx,\n      simp,\n      calc\n        x \u2264 list_max_Z l :hl1 x hx ... \n          \u2264 list_max_Z (y :: l) : _,\n      unfold list_max_Z,\n      simp,\n      cases hl2,\n      left,\n      simp [hl2],\n      by_cases h : (list.foldr max 0 l \u2264 y),\n      left,\n      exact h,\n      right,\n      push_neg at h,\n      have : max y (list.foldr max 0 l) = list.foldr max 0 l := max_eq_right_of_lt h,\n      rw this,\n      exact hl2,\n      by_cases h : y \u2265 0,\n      left,\n      dsimp,\n      rw hl2,\n      have : max y 0 = y := max_eq_left h,\n      rw this,\n      simp,\n      right,\n      dsimp,\n      rw hl2,\n      push_neg at h,\n      simp only [max_eq_right_iff],\n      linarith,\n    }\n  end","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209620,"user_id":null,"body":"import Preloaded tactic\n \nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\nbegin\n  split,abstract h{\n    intros x h0,\n    induction l with l hl,{\n      cases h0,\n    },{\n      cases h0,{\n        unfold list_max_Z,\n        unfold list.foldr,\n        rw h0,\n        exact le_max_left l (list.foldr max 0 hl),\n      },{\n        have h1:=l_ih h0,\n        unfold list_max_Z,\n        unfold list.foldr,\n        unfold list_max_Z at h1,\n        have h2:(list.foldr max 0 hl) \u2264 max l (list.foldr max 0 hl),{\n          exact le_sup_right,\n        },\n        exact le_trans (l_ih h0) h2,\n      },\n    },\n  },{\n    by_contra' h0,\n    have h1:=h0.left,\n    replace h0:=h0.right,\n    induction l,{\n      tauto,\n    },{\n      unfold list_max_Z at h1,\n      unfold list.foldr at h1,\n      unfold list_max_Z at h0,\n      unfold list.foldr at h0,\n      by_cases  (list.foldr max 0 l_tl) \u2264 l_hd,{\n        unfold max at h1,\n        unfold max_default at h1,\n        unfold max at h,\n        rw [if_pos h] at h1,\n        finish,\n      },{\n        unfold max at h1,\n        unfold max_default at h1,\n        unfold max at h,\n        rw [if_neg h] at h1,\n        unfold list_max_Z at l_ih,\n        unfold max at l_ih,\n        unfold max at h0,\n        set a:=list.foldr max_default 0 l_tl,\n        have h2:a \u2209 l_tl,{\n          by_contra,\n          have h3:a\u2208l_hd::l_tl,\n          right,\n          assumption,\n          finish,\n        },\n        unfold max_default at h0,\n        rw [if_neg h] at h0,\n        have h3:=l_ih h2 h0,\n        assumption,\n      }\n    }\n\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209621,"user_id":null,"body":"import Preloaded tactic\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\nbegin\n  split,\n  { intros m h,\n    induction l,\n    { cases h },\n    rcases h with (rfl | ht); simp [list_max_Z],\n    exact or.inr (l_ih ht) },\n  { induction l,\n    { apply or.inr rfl }, \n    { simp [list_max_Z] at *,\n      rcases l_ih with (h1 | h2);\n      by_cases list.foldr max 0 l_tl \u2264 l_hd,\n        left, left, assumption,\n        left, right, rwa [max_eq_right], linarith,\n        left, left, assumption,\n        right, rwa [max_eq_right], linarith } },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209622,"user_id":null,"body":"import Preloaded\nimport tactic\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\nbegin\n  simp [list_max_Z],\n  induction l with h l' ih,\n  case list.nil {\n    split,\n    intros x hx,\n    exfalso,\n    exact list.not_mem_nil _ hx,\n    right, rw list.foldr,\n  },\n  case list.cons {\n    rcases ih with \u27e8ih\u2081, ih\u2082\u27e9,\n    rw list.foldr, split,\n    {\n      intros x hx,\n      rw list.mem_cons_eq at hx,\n      cases hx,\n      {\n        rw hx,\n        exact le_max_left _ _,\n      },\n      {\n        specialize ih\u2081 x hx,\n        apply le_max_iff.mpr,\n        exact or.inr ih\u2081,\n      },\n    },\n    cases ih\u2082,\n    {\n      left,\n      have hmax := max_choice h (list.foldr max 0 l'),\n      cases hmax,\n      { simp [hmax] },\n      { simp [hmax, ih\u2082] },\n    },\n    {\n      rw ih\u2082,\n      have hmax := max_choice h 0,\n      cases hmax,\n      simp [or.inl hmax],\n      exact or.inr hmax,\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209623,"user_id":168,"body":"import data.list\nimport Preloaded\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\nbegin\n  simp [list_max_Z], split; induction l with h t ih; simp,\n  { split, { left, apply le_refl, },\n    intros x hx, right, exact ih _ hx, },\n  cases ih, \n  { cases le_total h (list.foldr max 0 t),\n    { rw max_eq_right h_1, left, right, exact ih, },\n    { rw max_eq_left h_1, left, left, exact rfl, }, },\n  { rw ih, cases le_total h 0,\n    { rw max_eq_right h_1, right, exact rfl, },\n    { rw max_eq_left h_1, left, left, exact rfl, }, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209624,"user_id":191,"body":"import Preloaded tactic\n\nlemma list_max_Z_spec {l : list \u2124} :\n  let max_val := list_max_Z l in \n  (\u2200 x \u2208 l, x \u2264 max_val) \u2227 (max_val \u2208 l \u2228 max_val = 0) :=\nbegin\n  rintro,\n  have h : max_val = list_max_Z l, simp,\n  split,\n  { rintro,\n    rw h,\n    unfold list_max_Z,\n    induction l,\n    { exfalso,\n      exact H\n    },\n    { rw [list.foldr_cons, le_max_iff],\n      cases H,\n      { left,\n        exact (eq.symm H).ge\n      },\n      { right,\n        exact l_ih rfl H\n      }\n    }\n  },\n  { unfold list_max_Z at h,\n    induction l,\n    { simp * at *},\n    { simp only [*, list.mem_cons_iff, list.foldr] at *,\n      cases lt_or_ge (list.foldr max 0 l_tl) l_hd,\n      { left,\n        left,\n        rw max_eq_left_of_lt h_1\n      },\n      { rw max_eq_right h_1,\n        cases l_ih rfl,\n        { left,\n          right,\n          exact h_2\n        },\n        { right,\n          exact h_2\n        }\n      }\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"60c034c1b3a07c0006e72b24":[{"id":209625,"user_id":191,"body":"import tactic\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false := by omega\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209626,"user_id":null,"body":"import data.nat.parity\n\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  intros n hn,  \n  exact nat.not_even_one (exists.intro n hn),\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209627,"user_id":null,"body":"import tactic.linarith\n\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  intros n h,\n  cases n, contradiction, rw nat.mul_succ at h, linarith,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209628,"user_id":null,"body":"lemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\n  begin\n    intro n,\n    assume h : 1 = 2 * n,\n    have h\u2081 : 1 = 1 % 2 := (nat.mod_eq_of_lt (nat.succ_lt_succ nat.zero_lt_one)).symm,\n    have h\u2082 : 1 % 2 = 2 * n % 2 := congr_arg (% 2) h,\n    have h\u2083 : 2 * n % 2 = 0 := nat.mul_mod_right 2 n,\n    have h\u2084 : 0 = 1 := ((h\u2081.trans h\u2082).trans h\u2083).symm,\n    from nat.zero_ne_one h\u2084\n  end\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209629,"user_id":null,"body":"import data.nat.basic tactic.omega\n\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  intros n,\n  omega,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209630,"user_id":null,"body":"import data.nat.parity\n\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\n\u03bb n hn, nat.not_even_one (by use [n, hn])\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209631,"user_id":null,"body":"lemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  intro n,\n  induction n with d hd,\n  {  \n    rw nat.mul_zero 2,\n    intro x,\n    have h\u2082 := nat.add_self_ne_one 0,\n    rw nat.add_zero at h\u2082,\n    apply h\u2082,\n    rw eq_comm,\n    exact x,\n  },\n  {\n    rw nat.mul_succ,\n    have h\u2081 :  0 \u2264 2 * d := nat.zero_le (2 * d),\n    have h\u2082 :  2 + 0 \u2264 2 + 2 * d := nat.add_le_add_left h\u2081 2,\n    rw nat.add_zero at h\u2082,\n    rw nat.add_comm at h\u2082,\n    by_contradiction,\n    rw <- h at h\u2082,\n    exact nat.lt_asymm h\u2082 h\u2082,\n  }\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209632,"user_id":null,"body":"import tactic\n\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  intros n hn,\n  cases n,\n  simpa using hn,\n  have : 2*(n.succ) = (2*n).succ.succ,\n  simp [nat.succ_eq_add_one, mul_add],\n  rw this at hn,\n  have := nat.succ.inj hn,\n  apply nat.succ_ne_zero (2*n),\n  symmetry,\n  assumption,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209633,"user_id":null,"body":"lemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  refine forall_not_of_not_exists _,\n  exact of_to_bool_ff rfl,\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209634,"user_id":null,"body":"import tactic\n\nlemma kata : \u2200 (n : \u2115), 1 = 2 * n -> false :=\nbegin\n  by omega\nend\n\n-- https:\/\/leanprover-community.github.io\/mathlib_docs\/tactics.html#omega\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"61860eed193401003c624be0":[{"id":209635,"user_id":null,"body":"import data.list\n\nuniverse u\n\ntheorem length_filter_and_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter p).length \u2227 (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter q).length :=\nbegin\n  split;\n  apply list.length_le_of_sublist;\n  rw \u2190 list.filter_filter,\n  { apply list.filter_sublist_filter,\n    apply list.filter_sublist, },\n  { apply list.filter_sublist, },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209636,"user_id":null,"body":"import tactic\n\nuniverse u\n\ntheorem length_filter_and_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} \n  [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n    (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter p).length \n  \u2227 (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter q).length :=\nbegin\n  split;\n  { induction L with a as ih,\n    { refl },\n    cases classical.em (p a) with hp hp;\n    cases classical.em (q a) with hq hq;\n    simp [list.filter, hp, hq]; linarith },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209637,"user_id":168,"body":"import tactic.linarith\n\nuniverse u\n\ntheorem length_filter_and_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [hp : decidable_pred p] [hq : decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter p).length \u2227 (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter q).length :=\nbegin\n  induction L with h t, simp,\n  cases hp h, all_goals { cases hq h }, \n  all_goals { simp * },\n  all_goals { linarith },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209638,"user_id":null,"body":"import tactic\nuniverse u\nopen list\ntheorem length_filter_and_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter p).length \u2227 (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter q).length :=\nbegin\n  refine \u27e8_, _\u27e9;\n  { induction L with l L ih,\n    case nil {simp},\n    case cons {\n      by_cases hp : p l;\n      by_cases hq : q l;\n      simp [hp, hq, ih, le_trans ih],\n    }\n  }\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209639,"user_id":191,"body":"import tactic.linarith\n\nuniverse u\n\ntheorem length_filter_and_le {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} [decidable_pred p] [decidable_pred q] {L : list \u03b1} :\n  (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter p).length \u2227 (L.filter $ \u03bb x, p x \u2227 q x).length \u2264 (L.filter q).length :=\nbegin\n  split; \n  induction L,\n  simp,\n  by_cases P : p L_hd;\n  by_cases Q : q L_hd;\n  simp [list.filter,P,Q];\n  linarith,\n  simp,\n  by_cases P : p L_hd;\n  by_cases Q : q L_hd;\n  simp [list.filter,P,Q];\n  linarith,\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}],"61861ec3193401003c64ec32":[{"id":209640,"user_id":null,"body":"import tactic\nuniverse u\n\ntheorem yet_another_one {\u03b1 : Type u} {f g : \u03b1 \u2192 Prop} [decidable_pred f] [decidable_pred g] {L : list \u03b1} : \n  (\u2200 a, a \u2208 L \u2192 (f a \u2192 g a)) \u2194 \u2200 a, a \u2208 (L.filter f) \u2192 a \u2208 (L.filter g) :=\nbegin\n  split; intros h\u2081 h\u2082 h\u2083,\n\n  {specialize h\u2081 h\u2082,\n  obtain \u27e8p, q\u27e9 := list.mem_filter.1 h\u2083,\n  have r : h\u2082 \u2208 L \u2227 g h\u2082 := \u27e8p, h\u2081 p q\u27e9,\n  exact list.mem_filter.2 r, },\n\n  {intro h\u2084,\n  have r : h\u2082 \u2208 L \u2227 f h\u2082 := \u27e8h\u2083, h\u2084\u27e9,\n  exact (list.mem_filter.1 (h\u2081 h\u2082 (list.mem_filter.2 r))).2, },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209641,"user_id":null,"body":"import tactic\n\nuniverse u\n\ntheorem yet_another_one {\u03b1 : Type u} {f g : \u03b1 \u2192 Prop} [decidable_pred f] [decidable_pred g] {L : list \u03b1} : \n  (\u2200 a, a \u2208 L \u2192 (f a \u2192 g a)) \u2194 \u2200 a, a \u2208 (L.filter f) \u2192 a \u2208 (L.filter g) :=\nbegin\n  split,\n  { intros h1 a ha,\n    induction L; simp at ha,\n    { contradiction },\n    { rcases ha with \u27e8(rfl | hL), hf\u27e9,\n      { simp [h1 a (by simp) hf] },\n      { simp [hL, h1 a (by simp [hL]) hf] } } },\n  { intros h1 a ha hfa, \n    specialize h1 a (by simpa [ha]),\n    induction L; simp at h1,\n    { contradiction },\n    { rcases h1 with \u27e8(rfl | hL), hg\u27e9; assumption } },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209642,"user_id":168,"body":"import tactic\nuniverse u\n\ntheorem yet_another_one {\u03b1 : Type u} {f g : \u03b1 \u2192 Prop} [decidable_pred f] [decidable_pred g] {L : list \u03b1} : \n  (\u2200 a, a \u2208 L \u2192 (f a \u2192 g a)) \u2194 \u2200 a, a \u2208 (L.filter f) \u2192 a \u2208 (L.filter g) :=\nbegin\n  simp, split; intros h a ha hfa, \n  { exact \u27e8ha, h a ha hfa\u27e9 },\n  { obtain \u27e8_, hg\u27e9 := h _ ha hfa, exact hg },\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209643,"user_id":null,"body":"import data.list\n\nuniverse u\n\ntheorem yet_another_one {\u03b1 : Type u} {f g : \u03b1 \u2192 Prop} [decidable_pred f] [decidable_pred g] {L : list \u03b1} :\n  (\u2200 a, a \u2208 L \u2192 (f a \u2192 g a)) \u2194 \u2200 a, a \u2208 (L.filter f) \u2192 a \u2208 (L.filter g) :=\nbegin\n  split,\n  { intros h a ha,\n    rw list.mem_filter at ha,\n    exact list.mem_filter_of_mem ha.1 (h _ ha.1 ha.2), },\n  { intros h a aL fa,\n    exact list.of_mem_filter (h a (list.mem_filter_of_mem aL fa)), },\nend\n","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209644,"user_id":null,"body":"import tactic\nuniverse u\n\ntheorem yet_another_one {\u03b1 : Type u} {f g : \u03b1 \u2192 Prop} [decidable_pred f] [decidable_pred g] {L : list \u03b1} : \n  (\u2200 a, a \u2208 L \u2192 (f a \u2192 g a)) \u2194 \u2200 a, a \u2208 (L.filter f) \u2192 a \u2208 (L.filter g) :=\n  have gsimp : (\u2200 (a : \u03b1), a \u2208 L \u2192 f a \u2192 g a) \n    \u2194 \u2200 (a : \u03b1), a \u2208 L \u2192 f a \u2192 a \u2208 L \u2227 g a :=\n    \u27e8 \u03bb H _ hL hf, \u27e8hL, H _ hL hf\u27e9, \n      \u03bb H _ hL hf, and.elim_right (H _ hL hf)\u27e9,\n  by simp [gsimp]","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"},{"id":209645,"user_id":191,"body":"import tactic\n\nuniverse u\n\ntheorem yet_another_one {\u03b1 : Type u} {f g : \u03b1 \u2192 Prop} [decidable_pred f] [decidable_pred g] {L : list \u03b1} : \n  (\u2200 a, a \u2208 L \u2192 (f a \u2192 g a)) \u2194 \u2200 a, a \u2208 (L.filter f) \u2192 a \u2208 (L.filter g) :=\nbegin\n  split,\n  rintro h a ha,\n  simp at *,\n  exact \u27e8ha.1, h a ha.1 ha.2\u27e9,\n  rintro h a ha hf,\n  simp at *,\n  exact (h a ha hf).2\nend","lang_id":30,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-23 16:36:33","updated_at":"2022-12-23 16:36:33"}]}