{"50654ddff44f800200000004":[{"id":232073,"user_id":null,"body":"module multiplyBugFix where\n\nimport Prelude\n\nmultiply = (*)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232074,"user_id":1313,"body":"module multiplyBugFix where\n\nimport Prelude\n\nmultiply :: Int -> Int -> Int\nmultiply x y = x * y","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232075,"user_id":15,"body":"module multiplyBugFix (multiply) where\n\nimport Prelude ((*))\n\nmultiply :: Int -> Int -> Int\nmultiply = (*)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232076,"user_id":969,"body":"module multiplyBugFix where\n\nimport Prelude\n\nmultiply :: Int -> Int -> Int\nmultiply a b = a * b\n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232077,"user_id":172,"body":"module multiplyBugFix where\n\nimport Prelude\n\nmultiply :: Int -> Int -> Int\nmultiply = (*)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232078,"user_id":676,"body":"module multiplyBugFix where\n\nimport Prelude ((*))\n\nmultiply :: Int -> Int -> Int\nmultiply = (*)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"523b4ff7adca849afe000035":[{"id":232079,"user_id":527,"body":"module Greet (greet) where\n\ngreet :: String\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232080,"user_id":645,"body":"module Greet where\n\ngreet :: String\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232081,"user_id":527,"body":"module Greet where\n\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232082,"user_id":null,"body":"module Greet where\n\n-- Write a function \"greet\" that returns \"hello world!\"\ngreet :: String\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232083,"user_id":50,"body":"module Greet where\n\n-- Write a function \"greet\" that returns \"hello world!\"\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232084,"user_id":null,"body":"module Greet where\n\nimport Prelude\n\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232085,"user_id":null,"body":"module Greet where\n\nimport Prelude\n\ngreet :: String\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232086,"user_id":null,"body":"module Greet where\n\n--  a function \"greet\" that returns \"hello world!\"\ngreet = \"hello world!\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"526e8de0512511429e000006":[{"id":232087,"user_id":null,"body":"module Trim (module X) where\nimport Data.String (trim) as X","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232088,"user_id":233,"body":"module Trim (trim) where\n\nimport Prelude\n\nimport Data.String.Common as SC\n\ntrim :: String -> String\ntrim = SC.trim","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232089,"user_id":null,"body":"module Trim (trim) where\n\nimport Data.String as S\n\n-- | You should never be writing this sort of function\n-- | when you have it in standard library\ntrim :: String -> String\ntrim = S.trim","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232090,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\n\nimport Data.String as S\n\ntrim :: String -> String\ntrim = S.trim","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232091,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\nimport Data.String\nimport Data.Array (dropWhile, foldl, foldr, range, reverse)\nimport Data.String.CodeUnits (toCharArray, fromCharArray)\n\ntrim :: String -> String\ntrim a = foldl (\\acc f -> f acc) a [filterinitalWhitespace, filterEndWhitespace] \n\nreplaceNewLine \u2237 String \u2192 String\nreplaceNewLine t = replaceAll (Pattern \"\n\") (Replacement \"\") t\n\nreplaceTSlash \u2237 String \u2192 String\nreplaceTSlash t = replaceAll (Pattern \"\\t\") (Replacement \"\") t\n\nreplaceRSlash \u2237 String \u2192 String\nreplaceRSlash t = replaceAll (Pattern \"\\r\") (Replacement \"\") t\n\nisWhitespace :: Char -> Boolean\nisWhitespace ' ' = true \nisWhitespace '\n' = true \nisWhitespace '\\r' = true \nisWhitespace '\\t' = true \nisWhitespace _ = false \n\n\n\nfilterinitalWhitespace :: String -> String\n\nfilterinitalWhitespace string = fromCharArray $ dropWhile isWhitespace $ toCharArray string\n\nfilterEndWhitespace :: String -> String\nfilterEndWhitespace string = fromCharArray $ reverse $ toCharArray $ filterinitalWhitespace $ fromCharArray $ reverse $ toCharArray string\nterEndWhitespace string = fromCharArray $ reverse $ toCharArray $ filterinitalWhitespace $ fromCharArray $ reverse $ toCharArray string\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232092,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\nimport Data.String.Regex (replace)\nimport Data.String.Regex.Flags (noFlags)\nimport Data.String.Regex.Unsafe (unsafeRegex)\n\ntrim :: String -> String\ntrim = replace (unsafeRegex \"^\\\\s*(.*?)\\\\s*$\" noFlags) \"$1\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232093,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\nimport Data.String.Regex (replace)\nimport Data.String.Regex.Flags (global)\nimport Data.String.Regex.Unsafe (unsafeRegex)\n\ntrim :: String -> String\ntrim = replace (unsafeRegex \"\"\"^[\\s\n\\t\\r]+|[\\s\n\\t\\r]+$\"\"\" global) \"\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232094,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\n\nimport Data.String.CodeUnits (charAt, drop, dropRight, length)\nimport Data.Maybe (Maybe(..))\ntrim :: String -> String\ntrim s = trimPrefix $ trimSuffix s where\n  trimPrefix :: String -> String\n  trimPrefix s0 = trimPrefix1 0 s0 where\n    trimPrefix1 :: Int -> String -> String\n    trimPrefix1 i s1 | i >= length s1         = \"\"\n                     | charIsWS $ charAt i s1 = trimPrefix1 (i + 1) s1\n                     | otherwise              = drop i s1\n  trimSuffix :: String -> String\n  trimSuffix s2 = trimSuffix1 0 0 s2 where\n    trimSuffix1 :: Int -> Int -> String -> String\n    trimSuffix1 count place s3 | place >= (length s3)       = dropRight count s3\n                               | charIsWS $ charAt place s3 = trimSuffix1 (count+1) (place+1) s3\n                               | otherwise                  = trimSuffix1 0 (place+1) s3\n\n\ncharIsWS :: Maybe Char -> Boolean\ncharIsWS c = c == Just '\n' || c == Just '\\r' || c == Just ' ' || c == Just '\\t'","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232095,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\nimport Data.Array as A\nimport Data.Set as Set\nimport Data.String.CodeUnits as S\n\n\n\ntrim :: String -> String\ntrim = S.dropWhile space\n   >>> reverse\n   >>> S.dropWhile space\n   >>> reverse\n\n\n\nspace :: Char -> Boolean\nspace = flip Set.member arr\n  where\n    arr = Set.fromFoldable\n      [ ' '\n      , '\\t'\n      , '\n'\n      , '\\r'\n      ]\n\n\n\nreverse :: String -> String\nreverse = S.toCharArray >>> A.reverse >>> S.fromCharArray\n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232096,"user_id":null,"body":"module Trim (trim) where\n\nimport Prelude\nimport Data.String as String\n\ntrim :: String -> String\ntrim = String.trim","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"530e15517bc88ac656000716":[{"id":232097,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude\n\nimport Data.Enum (fromEnum, toEnum)\nimport Data.Maybe (fromJust)\nimport Data.String.CodeUnits (fromCharArray, toCharArray)\nimport Partial.Unsafe (unsafePartial)\n\nrot13 :: String -> String\nrot13 = mapChars rotChar where\n  mapChars f = toCharArray >>> map f >>> fromCharArray\n  mapCharCode f = fromEnum >>> f >>> toEnum >>> unsafePartial fromJust\n  rotChar c = if isLetter c then mapCharCode rotCharCode c else c\n  rotCharCode cc = cc - r + (r + 13) `mod` 26 where r = (cc - 1) `mod` 32\n  isLetter c = 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232098,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude\n\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Maybe (fromJust)\nimport Data.String.CodeUnits (fromCharArray, toCharArray)\nimport Partial.Unsafe (unsafePartial)\n\nrot13 :: String -> String\nrot13 = mapChars rotChar where\n  mapChars f = toCharArray >>> map f >>> fromCharArray\n  mapCharCode f = unsafePartial $ toCharCode >>> f >>> fromCharCode >>> fromJust\n  rotChar c | isLetter c = mapCharCode rotCharCode c\n  rotChar c = c\n  rotCharCode cc = 1 + 32 * q + (r + 13) `mod` 26 where\n    q = (cc - 1) `div` 32\n    r = (cc - 1) `mod` 32\n  isLetter c = 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232099,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude (map, (<<<), ($), pure)\nimport Data.Char (fromCharCode)\nimport Data.Enum (succ)\nimport Data.Maybe (Maybe(..))\nimport Data.Function (applyN)\nimport Data.String.CodeUnits (toCharArray, fromCharArray)\nimport Data.Foldable (elem)\nimport Data.Array ((..), concat)\n\nalphabet :: Array (Maybe Char)\nalphabet = map fromCharCode $ concat [ 65 .. 90, 97 .. 122 ]\n\nsafeSucc :: Char -> Char\nsafeSucc 'Z' = 'A'\nsafeSucc 'z' = 'a'\nsafeSucc char = \n  if (pure char) `elem` alphabet\n    then case succ char of\n      Just b -> b\n      Nothing -> char\n    else char\n\nshift13 :: Char -> Char\nshift13 = applyN safeSucc 13\n\nrot13 :: String -> String\nrot13 = fromCharArray <<< (map shift13) <<< toCharArray","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232100,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude\nimport Data.String.CodeUnits (fromCharArray, toCharArray)\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Char (fromCharCode, toCharCode)\n\nrot13 :: String -> String\nrot13 = toCharArray >>> map (toCharCode >>> convert >>> (fromMaybe ' ')) >>> fromCharArray\n  where\n  convert :: Int -> Maybe Char\n  convert c\n    | c >= 65 && c <= 90 = ((c - 52) `mod` 26) + 65 # fromCharCode\n    | c >= 97 && c <= 122 = ((c - 84) `mod` 26) + 97 # fromCharCode\n    | otherwise = fromCharCode c","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232101,"user_id":969,"body":"module ROT13 (rot13, rotChars, alphabet) where\n\nimport Prelude\nimport Data.String.CodeUnits (fromCharArray, toCharArray)\nimport Data.Array (elemIndex, index, length)\nimport Data.Maybe (fromMaybe, maybe, Maybe)\nimport Control.Alt ((<|>))\n\nrot13 :: String -> String\nrot13 = toCharArray >>> map go >>> fromCharArray\n  where \n    go c = fromMaybe c (rotLower c <|> rotUpper c)\n      \nrotLower :: Char -> Maybe Char\nrotLower = rotChars alphabet \n\nrotUpper :: Char -> Maybe Char\nrotUpper = rotChars alphabetUpper\n\nrotChars :: Array Char -> Char -> Maybe Char\nrotChars set char = do \n  i <- elemIndex char set\n  index set $ (((i + 13)) `mod` (length set))\n\nalphabet :: Array Char\nalphabet = [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ]\nalphabetUpper :: Array Char\nalphabetUpper = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' ]","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232102,"user_id":2576,"body":"module ROT13 (rot13) where\n\nimport Prelude\n\nimport Data.Array (concat, drop, mapMaybe, zipWith, (..))\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Map as Map\nimport Data.Maybe (fromMaybe)\nimport Data.String (codePointFromChar, fromCodePointArray, toCodePointArray)\nimport Data.Tuple (Tuple(..))\n\nrot13 :: String -> String\nrot13 = fromCodePointArray <<< map rot <<< toCodePointArray\n    where\n    rot cp = fromMaybe cp $ Map.lookup cp cipherMap\n    cipherMap =\n        Map.fromFoldable $ concat [ cipherPairsLower, cipherPairsUpper ]\n    cipherPairsLower = makePairs $ map codePointFromChar $ mapMaybe fromCharCode $ toCharCode 'a' .. toCharCode 'z'\n    cipherPairsUpper = makePairs $ map codePointFromChar $mapMaybe fromCharCode $ toCharCode 'A' .. toCharCode 'Z'\n    makePairs alph =\n        zipWith Tuple alph $ drop 13 alph <> alph\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232103,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Maybe (fromJust)\nimport Data.String.CodeUnits (fromCharArray, toCharArray) \nimport Partial.Unsafe (unsafePartial)\n\nrotate :: Int -> Int -> Int -> Int -> Char\nrotate d nMin nMax n = unsafePartial \n  $ fromJust\n  $ fromCharCode \n  $ nMin + (mod (n - nMin + d) (nMax - nMin + 1))\n\nrotate13 :: Int -> Int -> Int -> Char\nrotate13 = rotate 13\n\nrot13 :: String -> String\nrot13 = fromCharArray \n  <<< (<$>) translate \n  <<< toCharArray\n  where\n    translate :: Char -> Char\n    translate c = case toCharCode c of\n      n | (n >= 65 && n <= 90) -> rotate13 65 90 n\n        | (n >= 97 && n <= 122) -> rotate13  97 122 n\n        | otherwise -> c\n ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232104,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude\nimport Data.Array (filter)\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.Maybe (fromMaybe, isJust)\nimport Data.String.CodeUnits (toCharArray, fromCharArray)\nimport Data.Traversable (sequence)\n\nrot13 :: String -> String\nrot13 = toCharArray \n  >>> map toCharCode \n  >>> map (transformChar code_A code_Z)\n  >>> map (transformChar code_a code_z)\n  >>> map fromCharCode\n  >>> sequence\n  >>> map fromCharArray\n  >>> fromMaybe \"\"\n  where \n    code_A = toCharCode 'A'\n    code_Z = toCharCode 'Z'\n    code_a = toCharCode 'a'\n    code_z = toCharCode 'z'\n\n    transformChar :: Int -> Int -> Int -> Int\n    transformChar start end i | i >= start && i <= end = start + mod (i - start + 13) (end - start + 1)\n                              | otherwise = i ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232105,"user_id":null,"body":"module ROT13 (rot13) where\n\nimport Prelude\nimport Data.String.CodeUnits (toCharArray, fromCharArray)\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.Maybe (fromMaybe)\n\n\nimport Prelude\nimport Data.String.CodeUnits (toCharArray, fromCharArray)\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.Maybe (fromMaybe)\n\nrot13 :: String -> String\nrot13 = \n  toCharArray \n  >>> map (toCharCode>>>getNewChar >>> codeToChar) \n  >>> fromCharArray\n  \n  where\n    getNewChar :: Int -> Int \n    getNewChar = (\\x -> \n        if (65 <= x) && (x <= 90) \n        then 65 + (getNewChar' $ x-65) \n        else if (97 <= x) && (x <= 122) \n        then 97 + (getNewChar' $ x-97)\n        else x )\n        \n    getNewChar' :: Int -> Int \n    getNewChar' x =\n      x\n      # (_ + 13)\n      # (_ `mod` 26)\n\n    codeToChar :: Int -> Char\n    codeToChar = fromCharCode >>> fromMaybe 'a'","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232106,"user_id":2503,"body":"module ROT13 (rot13) where\n\nimport Prelude\nimport Data.Array (catMaybes)\nimport Data.Maybe (Maybe)\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.String.CodeUnits (toCharArray, fromCharArray)\n\nci :: Char -> Int\nci = toCharCode\n\nrot13Code :: Int -> Int\nrot13Code c\n  | c >= ci 'a' && c <= ci 'z' = ((c - ci 'a') + 13) `mod` 26 + ci 'a'\n  | c >= ci 'A' && c <= ci 'Z' = ((c - ci 'A') + 13) `mod` 26 + ci 'A'\n  | otherwise = c\n\nrot13 :: String -> String\nrot13 = toCharArray >>> rot13Arr >>> fromCharArray\n  where\n    rot13Char = toCharCode >>> rot13Code >>> fromCharCode\n    rot13Arr = map rot13Char >>> catMaybes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"53223653a191940f2b000877":[{"id":232107,"user_id":21,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\nimport Data.Array (filter, any, null)\nimport Data.Tuple (Tuple(..), snd)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end _ | start == end = true\nsolveGraph _ _ arcs | null arcs = false\nsolveGraph start end arcs = any (\n -> solveGraph n end sansStart) startNeighbors\n  where\n    fromStart :: Arc -> Boolean\n    fromStart (Tuple a b) = a == start\n    \n    sansStart :: Graph\n    sansStart = filter (not <<< fromStart) arcs\n    \n    withStart :: Array Arc\n    withStart = filter fromStart arcs\n    \n    startNeighbors :: Array Node\n    startNeighbors = filter (_ \/= start) $ map snd withStart","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232108,"user_id":null,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\n\nimport Data.Tuple (Tuple)\nimport Data.Array (partition)\nimport Data.Tuple (fst, snd)\nimport Data.Foldable (any)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end graph = \n  if start == end then true\n  else\n    let {yes, no} = partition (\\arc -> fst arc == start) graph\n    in any identity $ map (\\arc -> solveGraph (snd arc) end no) yes \n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232109,"user_id":527,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude (($), (*>), (<>), (==), (>>=), map, otherwise, pure)\nimport Data.Map as M\nimport Data.Set as S\nimport Control.Monad.State (evalState, get, modify)\nimport Data.Bifunctor (rmap)\nimport Data.List (foldr, singleton)\nimport Data.Maybe (maybe)\nimport Data.Tuple (Tuple)\n\ntype Node = Char\ntype Arc = Tuple Node Node\ntype Graph = Array Arc\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end arcs = evalState (endReachableFrom start) S.empty\n  where edges = M.fromFoldableWith (<>) $ map (rmap singleton) arcs\n        endReachableFrom vertex\n          | vertex == end = pure true\n          | otherwise =\n              modify (S.insert vertex) *>\n              maybe\n                (pure false)\n                (foldr\n                  (\nv continue ->\n                    get >>= \\vs ->\n                    if nv `S.member` vs then continue else endReachableFrom nv >>= \\r ->\n                    if r then pure true else continue)\n                  (pure false))\n                (M.lookup vertex edges)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232110,"user_id":76,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude ((&&), (\/=), (==), (||))\nimport Data.Array (any, filter)\nimport Data.Tuple (Tuple, fst, snd)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph s e arcs = s == e || any (\\arc -> fst arc == s && solveGraph (snd arc) e (filter (\\a -> snd a \/= fst arc) arcs)) arcs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232111,"user_id":null,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\n\nimport Data.Tuple (Tuple, fst, snd)\nimport Data.Array (any, filter)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end graph =\n  if start == end\n    then true\n    else any hasPath neighbors\n  where\n    hasPath node = solveGraph node end filtered\n    neighbors = snd <$> filter (fst >>> (==) start) graph\n    filtered = filter (snd >>> (\/=) start) graph","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232112,"user_id":null,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Array (any, filter)\nimport Data.List (List(..), notElem)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph = findPath Nil\n\nfindPath :: List Node -> Node -> Node -> Graph -> Boolean\nfindPath visited start end graph =\n  if start == end\n    then true\n    else any hasPath neighbors\n  where\n    hasPath n = findPath (Cons start visited) n end graph\n    neighbors = snd <$> filter (\\(Tuple a b) -> a == start && notElem b visited) graph","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232113,"user_id":2576,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Set as HS\nimport Data.List as List\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Tuple (Tuple)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end graph =\n    go HS.empty (List.singleton start)\n    where\n    go visited stack =\n        case List.uncons stack of\n            Nothing -> false\n            Just { head: cur, tail: rest }\n                | cur == end -> true\n                | HS.member cur visited ->\n                    go visited rest\n                | otherwise ->\n                    go (HS.insert cur visited) (rest <> List.fromFoldable (fromMaybe [] $ Map.lookup cur edges))\n\n    edges = Map.fromFoldableWith (<>) (map Array.singleton <$> graph)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232114,"user_id":null,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\nimport Data.Array (filter, null)\nimport Data.Foldable (any)\nimport Data.Tuple (Tuple, fst, snd)\n\ntype Node = Char\ntype Arc = Tuple Node Node\ntype Graph = Array Arc\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end arcs =\n  let\n    possibleMoves :: Graph\n    possibleMoves = filter ((==) start <<< fst) arcs\n    f :: Arc -> Boolean\n    f move = solveGraph (snd move) end (filter ((\/=) move) arcs)\n  in \n    if start == end\n      then true \n      else\n        if null possibleMoves\n          then false\n          else any f possibleMoves\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232115,"user_id":null,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\n\nimport Data.List (List(..), foldl, null)\nimport Data.List as List\nimport Data.Map (Map, insert, lookup, update)\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Set (Set, filter, fromFoldable, isEmpty, member, union, unions)\nimport Data.Set as Set\nimport Data.Tuple (Tuple(..))\n\ntype Node  = Char            -- A node is represented by a single-character identifier\ntype Arc   = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc       -- A directed graph is defined by its directed edges (and nodes)\n\nadjacentList :: Graph -> Map Node (List Node)\nadjacentList = foldl addNode mempty\n  where\n    addNode g (Tuple src dst) =\n      case lookup src g of\n        Nothing -> insert src (List.singleton dst) g\n        Just _  -> update (Cons dst >>> Just) src g\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph src dst g\n  | src == dst = true\n  | otherwise  = solve (Set.singleton src) mempty\n  where\n    adjlist = adjacentList g\n\n    solve :: Set Node -> Set Node -> Boolean\n    solve srcs trav =\n      if isEmpty srcs\n        then false\n        else let\n               tgs :: Set Node\n               tgs =\n                 srcs\n                   # Set.map (\\src' -> if member src' trav\n                                         then Nil\n                                         else lookup src' adjlist # fromMaybe Nil\n                             )\n                   # filter (not <<< null)\n                   # Set.map fromFoldable\n                   # unions\n\n             in member dst tgs || solve tgs (union trav srcs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232116,"user_id":null,"body":"module DirectedGraphs (solveGraph) where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Array (any, partition)\n\ntype Node = Char -- A node is represented by a single-character identifier\ntype Arc = Tuple Node Node -- An arc (directed edge) is represented by an ordered pair of nodes\ntype Graph = Array Arc -- A directed graph is defined by its directed edges (and nodes)\n\nsolveGraph :: Node -> Node -> Graph -> Boolean\nsolveGraph start end g \n  | start == end = true\n  | otherwise = let (Tuple nextNodes remainingNode) = partitionGraph start g\n                in any (\nStart -> solveGraph nStart end remainingNode) nextNodes\n\npartitionGraph :: Node -> Graph -> Tuple (Array Node) Graph\npartitionGraph start graph =\n  partition (\\(Tuple beg _) -> beg == start) graph \n  # (\\r -> Tuple (map snd r.yes) r.no)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"534d0a229345375d520006a0":[{"id":232117,"user_id":168,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\nimport Data.Int.Bits ((.&.))\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo n = n > 0 && n .&. (n - 1) == 0 ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232118,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\n\nimport Data.Int (quot, rem)\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo n\n  | n <= 0 = false\n  | n == 1 = true\n  | otherwise =\n      let q = quot n 2\n          r = rem n 2\n      in if r == 1 \n           then false\n           else powerOfTwo q","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232119,"user_id":21,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\nimport Data.Int.Bits ((.&.))\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\npowerOfTwo x = eq 0 $ (x - 1) .&. x","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232120,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\nimport Data.Int.Bits\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\npowerOfTwo n = n .&. (n - 1) == 0\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232121,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\npowerOfTwo 1 = true\npowerOfTwo 2 = true\npowerOfTwo n = if n `mod` 2 == 0 then powerOfTwo (n \/ 2) else false \n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232122,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\npowerOfTwo 1 = true\npowerOfTwo n = case n `mod` 2 of\n  1 -> false\n  _ -> powerOfTwo (n \/ 2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232123,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\npowerOfTwo 1 = true\npowerOfTwo 2 = true\npowerOfTwo a\n  | mod a 2 == 0 = powerOfTwo $ div a 2\n  | otherwise = false","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232124,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\nimport Data.Int (even)\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo n | n <= 0 = false\npowerOfTwo 1 = true\npowerOfTwo n = even n && powerOfTwo (n \/ 2)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232125,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\nimport Data.Int.Bits ((.&.))\n\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\npowerOfTwo n = (n - 1) .&. n == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232126,"user_id":null,"body":"module Codewars.Kata.PowerOfTwo (powerOfTwo) where\n\nimport Prelude\n\n-- missing log2 or logN function\npowerOfTwo :: Int -> Boolean\npowerOfTwo 0 = false\n\npowerOfTwo 1 = true\n\npowerOfTwo n\n  | n `mod` 2 == 0 = powerOfTwo $ n \/ 2\n  | otherwise = false","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"53da3dbb4a5168369a0000fe":[{"id":232127,"user_id":53,"body":"module EvenOrOdd where\n\nimport Prelude\nimport Data.Int (even)\n\neven_or_odd :: Int -> String\neven_or_odd n \n  | even n = \"Even\"\n  | otherwise = \"Odd\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232128,"user_id":645,"body":"module EvenOrOdd where\n\nimport Prelude\n\neven_or_odd :: Int -> String\neven_or_odd n = if n `mod` 2 == 0 then \"Even\" else \"Odd\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232129,"user_id":527,"body":"module EvenOrOdd where\n\nimport Prelude ((<<<), show)\nimport Data.Int (parity)\n\neven_or_odd :: Int -> String\neven_or_odd = show <<< parity","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232130,"user_id":null,"body":"module EvenOrOdd where\n\nimport Prelude\nimport Data.Int (even)\n\neven_or_odd :: Int -> String\neven_or_odd n = if even n then \"Even\" else \"Odd\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232131,"user_id":null,"body":"module EvenOrOdd where\n\nimport Prelude\n\neven_or_odd :: Int -> String\neven_or_odd 0 = \"Even\"\neven_or_odd 1 = \"Odd\"\neven_or_odd x = even_or_odd (mod x 2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232132,"user_id":null,"body":"module EvenOrOdd where\n\nimport Data.Int (rem)\n\nimport Prelude\n\neven_or_odd :: Int -> String\neven_or_odd n = case rem n 2 of\n  0 -> \"Even\"\n  _ -> \"Odd\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232133,"user_id":null,"body":"module EvenOrOdd where\n\nimport Prelude\n\neven_or_odd :: Int -> String\neven_or_odd n = if n `mod` 2 == 1 then \"Odd\" else \"Even\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232134,"user_id":null,"body":"module EvenOrOdd where\n\nimport Prelude\n\neven_or_odd :: Int -> String\neven_or_odd n = case n `mod` 2 == 0 of\n  true -> \"Even\"\n  false -> \"Odd\"\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232135,"user_id":null,"body":"module EvenOrOdd where\n\nimport Prelude\n\neven_or_odd :: Int -> String\neven_or_odd n | mod n 2 == 0 = \"Even\"\n            | otherwise = \"Odd\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232136,"user_id":null,"body":"module EvenOrOdd where\n\nimport Prelude\nimport Data.Int (Parity(..), parity)\n\neven_or_odd :: Int -> String\neven_or_odd n = case nParity of\n  Even -> \"Even\"\n  Odd -> \"Odd\"\n  where\n    nParity = parity n\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5443dd2d7fc4478154000ac6":[{"id":232137,"user_id":17,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), (:), singleton)\nimport Data.Semigroup ((<>))\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' _ Nil = Nil\nreverse' f (x : xs) = f xs <> singleton x\n\nfoldr' :: forall a b. ((a -> b -> b) -> b -> List a -> b) ->\n  (a -> b -> b) -> b -> List a -> b\nfoldr' _ _ z Nil = z\nfoldr' g f z (x : xs) = x `f` g f z xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232138,"user_id":null,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), (:), snoc)\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' _ Nil = Nil\nreverse' f (x:xs) = snoc (f xs) x\n\nfoldr' :: forall a b. ((a -> b -> b) -> b -> List a -> b) -> (a -> b -> b) -> b -> List a -> b\nfoldr' _ _ b Nil = b\nfoldr' f g b (x:xs) = g x (f g b xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232139,"user_id":null,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), snoc, (:))\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' _ Nil = Nil\nreverse' f (x : xs) = snoc (f xs) x\n\nfoldr' :: forall a b. ((a -> b -> b) -> b -> List a -> b) -> (a -> b -> b) -> b -> List a -> b\nfoldr' _ _ i Nil      = i\nfoldr' f h i (x : xs) = h x (f h i xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232140,"user_id":null,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), singleton)\nimport Data.Monoid\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' f = case _ of\n  Nil -> Nil\n  Cons x xs -> f xs <> singleton x\n\nfoldr' :: forall a b. ((a -> b -> b) -> b -> List a -> b) -> (a -> b -> b) -> b -> List a -> b\nfoldr' f g n = case _ of\n  Nil -> n\n  Cons x xs -> g x (f g n xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232141,"user_id":null,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), (:))\nimport Prelude\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' f Nil = Nil\nreverse' f (x:xs) = (f xs) <> (pure x)\n\nfoldr' :: forall a b. \n  ((a -> b -> b) -> b -> List a -> b) -> (a -> b -> b) -> b -> List a -> b\nfoldr' g f b0 Nil = b0\nfoldr' g f b0 (a:as) = f a (g f b0 as)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232142,"user_id":null,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), (:), snoc)\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' f Nil = Nil\nreverse' f (x : xs) = f xs `snoc` x\n\ntype Foldr a b = (a -> b -> b) -> b -> List a -> b\n\nfoldr' :: forall a b. Foldr a b -> Foldr a b\nfoldr' _ _ z Nil = z\nfoldr' f t z (x : xs) = x `t` f t z xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232143,"user_id":null,"body":"module Fixit (foldr', reverse') where\n\nimport Prelude\n\nimport Data.List (List(..), (:))\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' _ Nil    = Nil\nreverse' r (x:xs) = r xs <> pure x\n\nfoldr' :: forall a b. ((a -> b -> b) -> b -> List a -> b) -> (a -> b -> b) -> b -> List a -> b\nfoldr' _ _ z Nil    = z\nfoldr' r f z (x:xs) = x `f` r f z xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232144,"user_id":21,"body":"module Fixit (foldr', reverse') where\n\nimport Data.List (List(..), (:), snoc)\n\ntype Fixed n = (n) -> n\n\nreverse' :: forall a. Fixed (List a -> List a)\nreverse' f Nil = Nil\nreverse' f (x : xs) = snoc (f xs) x\n\nfoldr' :: forall a b. Fixed ((a -> b -> b) -> b -> List a -> b)\nfoldr' f g b Nil = b\nfoldr' f g b (x : xs) = g x (f g b xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232145,"user_id":1163,"body":"module Fixit (foldr', reverse') where\n\nimport Data.Semigroup ((<>))\nimport Data.List (List(..), (:))\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' f Nil = Nil\nreverse' f (x : xs) = f xs <> (x : Nil)\n\nfoldr' :: forall a b.\n          ((a -> b -> b) -> b -> List a -> b) ->\n          (a -> b -> b) -> b -> List a -> b -- Try to figure out the type yourself ;)\nfoldr' self op seed Nil = seed\nfoldr' self op seed (x : xs) = x `op` self op seed xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232146,"user_id":527,"body":"module Fixit (foldr', reverse') where\n\nimport Prelude ((<>))\nimport Data.List (List(..), (:))\n\nreverse' :: forall a. (List a -> List a) -> List a -> List a\nreverse' _ Nil = Nil\nreverse' f (x:xs) = f xs <> x:Nil\n\nfoldr' :: forall a b. ((a -> b -> b) -> b -> List a -> b) -> (a -> b -> b) -> b -> List a -> b\nfoldr' _ g y Nil = y\nfoldr' f g y (x:xs) = g x (f g y xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"546dbd81018e956b51000077":[{"id":232147,"user_id":null,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport PureScript.Codewars.Church.Preloaded\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\f x -> m f (n f x)) \n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (\\f x -> m (n f) x)\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow (Church n) (Church m) = Church(\\f x -> (m n) f x)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232148,"user_id":17,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport PureScript.Codewars.Church.Preloaded\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\f x -> m f (n f x))\n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (\\f -> m (n f))\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow (Church n) (Church m) = Church (m n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232149,"user_id":null,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport PureScript.Codewars.Church.Preloaded\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd n (Church m) = m succ n\n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul n (Church m) = m (add n) zero\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow n (Church m) = m (mul n) (succ zero)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232150,"user_id":null,"body":"module PureScript.Codewars.Church where\n\nimport Prelude ((<<<))\nimport PureScript.Codewars.Church.Preloaded\n\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\s z -> m s (n s z))\n\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (n <<< m)\n\npow :: Church -> Church -> Church\npow (Church n) (Church m) = Church (m n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232151,"user_id":null,"body":"module PureScript.Codewars.Church where\nimport Prelude ((<<<))\n\nimport PureScript.Codewars.Church.Preloaded\n\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\f -> (m f) <<< (n f))\n\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (m <<< n)\n\npow :: Church -> Church -> Church\npow (Church n) (Church m) =  Church (m n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232152,"user_id":722,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport PureScript.Codewars.Church.Preloaded\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\f x -> n f (m f x))\n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (\\f x -> n (m f) x)\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow (Church n) (Church m) = Church (\\f x -> (m n) f x)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232153,"user_id":null,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport PureScript.Codewars.Church.Preloaded\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\f x -> n f (m f x))\n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (\\f -> m (n f))\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow (Church n) (Church m) = Church (m n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232154,"user_id":null,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport PureScript.Codewars.Church.Preloaded\nimport Prelude((+), (*))\nimport Data.Function (applyN)\nimport Data.Int as I\n\ninc :: Int -> Int\ninc n = n + 1\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = applyN succ (m inc 0) (Church n)\n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = applyN succ ((m inc 0) * (n inc 0)) zero\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow (Church n) (Church m) = applyN succ (I.pow (n inc 0) (m inc 0)) zero\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232155,"user_id":1617,"body":"module PureScript.Codewars.Church where\n\n-- Should you choose to develop your solution locally,\n-- here is the full code of the Preloaded section:\n\n-- import Data.Show (class Show)\n-- import Data.Semigroup ((<>))\n\n-- newtype Church = Church (forall a. (a -> a) -> a -> a)\n\n-- zero :: Church\n-- zero = Church (\\_ x -> x)\n\n-- succ :: Church -> Church\n-- succ (Church n) = Church (\\f x -> f (n f x))\n\n-- one :: Church\n-- one = succ zero\n\n-- instance showChurch :: Show Church where\n--   show (Church n) = n (\\s -> \"(succ \" <> s <> \")\") \"zero\"\n  \nimport Prelude ((<<<))\nimport PureScript.Codewars.Church.Preloaded\n\n-- Addition of two natural numbers under Church encoding\nadd :: Church -> Church -> Church\nadd (Church n) (Church m) = Church (\\f -> n f <<< m f)\n\n-- Multiplication of two natural numbers under Church encoding\nmul :: Church -> Church -> Church\nmul (Church n) (Church m) = Church (n <<< m)\n\n-- Exponentation of two natural numbers under Church encoding\npow :: Church -> Church -> Church\npow (Church n) (Church m) = Church (m n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232156,"user_id":null,"body":"module PureScript.Codewars.Church where\n\nimport PureScript.Codewars.Church.Preloaded\nimport Prelude ((<<<))\n\nadd :: Church -> Church -> Church\nadd (Church m) = m succ\n\nmul :: Church -> Church -> Church\nmul (Church m) (Church n) = Church (m <<< n)\n\npow :: Church -> Church -> Church\npow (Church m) (Church n) = Church (n m)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"546ed19635a6610900000aa1":[{"id":232157,"user_id":21,"body":"module ChurchNumbers (pred,sub) where\n\nimport Prelude ()\nimport Preloaded (Church(..), zero, succ)\n\npred :: Church -> Church\npred (Church n) = Church (\\f x -> n (\\g h -> h (g f)) (\\_ -> x) (\\u -> u))\n\nsub :: Church -> Church -> Church\nsub n (Church m) = (m pred) n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232158,"user_id":168,"body":"module ChurchNumbers (pred,sub) where\n\nimport Prelude ()\nimport Preloaded (Church(..), zero, succ)\n\nnewtype Pair a b = Pair (forall c. (a -> b -> c) -> c)\n\npair :: forall a b. a -> b -> Pair a b\npair a b = Pair (\\f -> f a b)\n\nfst :: forall a b. Pair a b -> a\nfst (Pair p) = p (\\a _ -> a)\n\nsnd :: forall a b. Pair a b -> b\nsnd (Pair p) = p (\\_ b -> b)\n\npred :: Church -> Church\npred (Church n) = fst (n (\\p -> pair (snd p) (succ (snd p))) (pair zero zero))\n\nsub :: Church -> Church -> Church\nsub n (Church m) = m pred n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232159,"user_id":53,"body":"module ChurchNumbers (pred,sub) where\n\nimport Prelude (const, identity)\nimport Preloaded (Church(..), zero, succ)\n\n-- https:\/\/en.wikipedia.org\/wiki\/Church_encoding#Calculation%20with%20Church%20numerals\n-- \\operatorname{pred} \\equiv \\lambda n.\\lambda f.\\lambda x. n\\ (\\lambda g.\\lambda h. h\\ (g\\ f))\\ (\\lambda u. x)\\ (\\lambda u. u)\npred :: Church -> Church\npred (Church n) = Church (\\ f x -> n (\\ g h -> h (g f)) (\\ u -> x) (\\ u -> u))\n\n-- https:\/\/en.wikipedia.org\/wiki\/Church_encoding#Calculation%20with%20Church%20numerals\n-- \\operatorname{minus} \\equiv  \\lambda m.\\lambda n. (n \\operatorname{pred})\\ m\nsub :: Church -> Church -> Church\nsub m (Church n) = n pred m","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232160,"user_id":15,"body":"module ChurchNumbers (pred,sub) where\n\nimport Prelude (const)\nimport Preloaded (Church(..), zero, succ)\n\npred :: Church -> Church\npred (Church n) = n ( \\ k n m -> k m (succ m) ) const zero zero\n\nsub :: Church -> Church -> Church\nsub m (Church n) = n pred m","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232161,"user_id":29,"body":"module ChurchNumbers (pred,sub) where\n\nimport Prelude (const)\nimport Preloaded (Church(..))\n\npred :: Church -> Church\npred (Church n) = Church (\\f x -> n (\\g h -> h (g f)) (const x) (\\x -> x) )\n\nsub :: Church -> Church -> Church\nsub n (Church m) = m pred n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232162,"user_id":17,"body":"module ChurchNumbers (pred,sub) where\n\nimport Prelude (const, identity)\nimport Preloaded (Church(..), zero, succ)\n\npred :: Church -> Church\npred (Church n) = n ( \\ z fn -> fn (z succ) ) (const zero) (identity)\n\nsub :: Church -> Church -> Church\nsub n (Church m) = m pred n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"54bf1c2cd5b56cc47f0007a1":[{"id":232163,"user_id":null,"body":"module Duplicates where\n\nimport Prelude\nimport Data.Array (filter, group, length, sort)\nimport Data.Array.NonEmpty as NE\nimport Data.String (Pattern (..), toLower, split)\n\nduplicate_count :: String -> Int\nduplicate_count =\n  toLower\n    >>> split (Pattern \"\")\n    >>> sort\n    >>> group\n    >>> filter (NE.length >>> flip (>) 1)\n    >>> length","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232164,"user_id":null,"body":"module Duplicates where\n\nimport Data.String\nimport Prelude\nimport Data.Array (concatMap, filter, foldr, group', head, null, tail, (:))\nimport Data.Array.NonEmpty (length)\nimport Data.Foldable (foldl)\nimport Data.String.CodeUnits (length, toCharArray) as SC\n\nduplicate_count :: String -> Int\nduplicate_count s = foldr (\\x acc -> acc + if length x == 1 then 0 else 1) 0 $ group' $ SC.toCharArray $ toLower s","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232165,"user_id":null,"body":"module Duplicates where\n\nimport Data.String\nimport Data.String.CodeUnits (toCharArray, contains, singleton)\nimport Data.Array as Array\nimport Prelude\nimport Effect.Console (log)\nimport Effect.Unsafe (unsafePerformEffect)\n\ncountChar :: Char -> Array Char -> Int\ncountChar ch str = Array.foldl (\\a b -> if b == ch then a + 1 else a) 0 str\n\ncount :: Array Char -> Array Char -> Char -> Array Char\ncount str a b = if (countChar b str) > 1 && b `Array.notElem` a then Array.snoc a b else a\n\nduplicate_count :: String -> Int\nduplicate_count str = do\n    let charArray = toCharArray $ toLower str\n    let uniqArray = Array.foldl (count charArray) [] charArray\n    Array.length uniqArray\n\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232166,"user_id":null,"body":"module Duplicates where\n\nimport Prelude\nimport Data.Array (sort)\nimport Data.String (Pattern(..), split, toLower)\nimport Data.List (List, fromFoldable, (:))\n\nduplicate_count :: String -> Int\nduplicate_count = toLower >>> split (Pattern \"\") >>> sort >>> fromFoldable >>> run { prev: \"\", streak: 0, cnt: 0 }\n  where\n  run ::\n    { prev :: String\n    , streak :: Int\n    , cnt :: Int\n    } ->\n    (List String) -> Int\n  run (st@{ prev, streak, cnt }) (x : xs)\n    | prev == \"\" = run (st { prev = x }) xs\n    | prev == x = run (st { prev = x, streak = streak + 1 }) xs\n    | streak > 0 = run (st { prev = x, streak = 0, cnt = cnt + 1 }) xs\n    | otherwise = run (st { prev = x, streak = 0 }) xs\n\n  run ({ streak, cnt }) _\n    | streak > 0 = cnt + 1\n    | otherwise = cnt","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232167,"user_id":null,"body":"module Duplicates where\n\nimport Prelude ((<<<))\nimport Data.Maybe (Maybe(..))\nimport Data.String (uncons, toLower)\nimport Data.Set as Set\n\nduplicate_count :: String -> Int\nduplicate_count = go Set.empty Set.empty <<< toLower\n  where\n    go set dups arr = \n      case uncons arr of\n        Just {head: x, tail: xs} ->\n          if Set.member x set then\n            go set (Set.insert x dups) xs\n          else\n            go (Set.insert x set) dups xs\n      \n        Nothing -> Set.size dups\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232168,"user_id":969,"body":"module Duplicates where\n\nimport Prelude\nimport Data.Map as Map\nimport Data.Array as Array\nimport Data.String.CodeUnits (toCharArray)\nimport Data.String (toLower)\nimport Data.Foldable (sum)\nimport Data.Maybe (maybe, Maybe(..))\n\nduplicate_count :: String -> Int\nduplicate_count = toLower >>> toCharArray >>> go >>> sum\n  where \n    go :: Array Char -> Map.Map Char Int\n    go = Array.foldl (\\m c -> Map.alter (maybe 0 (const 1) >>> Just) c m) Map.empty","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232169,"user_id":null,"body":"module Duplicates where\nimport Prelude\nimport Data.Array (filter, group', length) as A\nimport Data.Array.NonEmpty (length) as NA\nimport Data.String.Common (toLower)\nimport Data.String.CodeUnits (toCharArray)\n\nduplicate_count :: String -> Int\nduplicate_count s = A.length $ A.filter (\\l -> (NA.length l) > 1) <<< A.group' <<< toCharArray <<< toLower $ s","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232170,"user_id":null,"body":"module Duplicates where\n\nimport Prelude\nimport Data.Foldable (foldr)\nimport Data.Map as Map\nimport Data.Maybe (isJust)\nimport Data.String.CodeUnits (toCharArray)\nimport Data.String.Common (toLower)\nimport Debug.Trace (spy)\n\nduplicate_count :: String -> Int\nduplicate_count s =\n  let\n    arr = toCharArray $ toLower s\n    countTrue true n = n + 1\n    countTrue false n = n\n  in\n    foldr countTrue 0 $ foldr (Map.alter (isJust >>> pure)) Map.empty arr","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232171,"user_id":null,"body":"module Duplicates where\n\nimport Prelude\n-- import Data.String.Pattern (Pattern)\nimport Data.String.Common(toLower)\nimport Data.String.CodeUnits(toCharArray)\nimport Data.Array(group, filter, length, sort)\nimport Data.String.Pattern (Pattern(..))\nimport Data.Array.NonEmpty as NE\n\nduplicate_count :: String -> Int\nduplicate_count = \n  toLower \n  >>> toCharArray\n  >>> sort\n  >>> group \n  >>> filter (\\x -> NE.length x > 1 )\n  >>> length","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232172,"user_id":null,"body":"module Duplicates where\n\nimport Prelude\nimport Data.Array as A\nimport Data.Array.NonEmpty as NEA\nimport Data.String (split, toLower)\nimport Data.String.Pattern\n\nduplicate_count :: String -> Int\nduplicate_count = toLower >>> split (Pattern \"\") >>> A.group' >>> A.filter (\\x -> NEA.length x > 1) >>> A.length","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"54d7660d2daf68c619000d95":[{"id":232173,"user_id":null,"body":"module Codewars.Kata.CommonDenominators (convert_fracs) where\n\nimport Prelude\n\nimport Data.List (List, foldl)\nimport Data.Tuple (Tuple, snd)\nimport Data.Tuple.Nested ((\/\\))\n\ntype Ratio a = Tuple a a\ntype Rational = Ratio Int\n\nconvert_fracs :: List Rational -> List Rational\nconvert_fracs xs = map conv xs'\n  where\n    xs'  = xs <#> \\(n \/\\ d) -> let gcd_ = gcd n d in n \/ gcd_ \/\\ d \/ gcd_\n    lcm_ = foldl (\\acc t -> lcm (snd t) acc) 1 xs'\n    conv (n \/\\ d) = lcm_ \/ d * n \/\\ lcm_","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232174,"user_id":17,"body":"module Codewars.Kata.CommonDenominators (convert_fracs) where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..))\nimport Data.List (List)\nimport Data.Foldable (foldl)\n\n-- Data.Ratio is not available on Codewars at the time of writing\n-- but anyway it is not suitable for this Kata\ntype Ratio a = Tuple a a -- A ratio is simply a homogenous ordered pair\ntype Rational = Ratio Int -- A rational number is simply a ratio of integers\n\n-- Rational ~ Tuple Int Int\nconvert_fracs :: List Rational -> List Rational\nconvert_fracs xs = let\n  xs' = map (\\(Tuple n d) -> let factor = gcd n d in Tuple (n `div` factor) (d `div` factor)) xs\n  cd = foldl (\\d (Tuple _ d') -> lcm d d') 1 xs' in\n    map (\\(Tuple n d) -> Tuple (n * cd `div` d) cd) xs'","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232175,"user_id":17,"body":"module Codewars.Kata.CommonDenominators (convert_fracs) where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..))\nimport Data.List (List)\nimport Data.Foldable (foldl)\n\n-- Data.Ratio is not available on Codewars at the time of writing\n-- but anyway it is not suitable for this Kata\ntype Ratio a = Tuple a a -- A ratio is simply a homogenous ordered pair\ntype Rational = Ratio Int -- A rational number is simply a ratio of integers\n\n-- Rational ~ Tuple Int Int\nconvert_fracs :: List Rational -> List Rational\nconvert_fracs xs = let\n  xs' = map (\\(Tuple n d) -> let factor = gcd n d in Tuple (n `div` factor) (d `div` factor)) xs\n  cd = foldl (\\d (Tuple _ d') -> lcm d d') 1 xs' in\n    map (\\(Tuple n d) -> Tuple (n * cd `div` d) cd) xs'","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"550498447451fbbd7600041c":[{"id":232176,"user_id":53,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Data.Array (sort)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp_same as bs = sort (map (\n -> n * n) as) == sort bs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232177,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\n\nimport Data.Array\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp norm squares = (sort squares) == (sort $ map (\\x -> x * x) norm)\n   ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232178,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Data.Array (any, uncons, delete, elem)\nimport Data.Maybe (Maybe(..))\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp [] [] = true\ncomp xs ys = case (uncons xs) of\n  Just { head: x, tail: tail } -> findSquareIn x ys && comp (delete x xs) (delete (x * x) ys)\n  Nothing -> false\n  where\n  findSquareIn needle haystack = elem (needle * needle) haystack\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232179,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Data.Array (sort)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp a b = eq (sort $ (\\x -> x * x) <$> a) (sort b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232180,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Data.Array (sort)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp xs ys = sort ys == (sort $ map (\n -> n * n ) xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232181,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Effect.Console\nimport Data.Array\nimport Data.Functor\n\nsquare :: Array Int -> Array Int\nsquare a = map (\\b -> b * b)(a)\n\nisSame :: Array Int -> Array Int -> Boolean\nisSame a b = (length a == length b) && (0 == (length (difference a b)))\n\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp a b = isSame c d\n  where\n    c = square (a)\n    d = b\n  \n  \n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232182,"user_id":76,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Data.Array (sort)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp a b = sort b == sort (map (\n -> n * n) a)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232183,"user_id":2576,"body":"module Codewars (comp_same) where\n\nimport Prelude\n\nimport Data.Array (sort)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp [] [] = true\ncomp [] _ = false\ncomp _ [] = false\ncomp_same as bs =\n    let\n        squares = map (\n -> n * n) as\n    in\n        sort squares == sort bs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232184,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\n\nimport Data.Array (sort)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp xs ys = sort (xs <#> \\x -> x*x) == sort ys","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232185,"user_id":null,"body":"module Codewars (comp_same) where\n\nimport Prelude\nimport Data.Array (difference, length)\n\ncomp_same :: Array Int -> Array Int -> Boolean\ncomp xs ys = let xsSquared =  (\\x -> x*x) <$> xs\n  in difference xsSquared ys == difference ys xsSquared","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5511b2f550906349a70004e1":[{"id":232186,"user_id":null,"body":"module LastDigit (last_digit) where\nimport Data.Int (pow, fromString)\nimport Data.String.CodeUnits (length, takeRight)\nimport Data.Maybe (fromMaybe)\nimport Prelude\nlast_digit :: String -> String -> Int\nlast_digit _ \"0\" = 1\nlast_digit a b = \n  if 1<mod x 5 && 1\/=y \n  then mod (pow x if y==0 then 4 else y) 10 \n  else x where\n    x = fromMaybe 0 $ fromString $ takeRight 1 a\n    lb = if 3>length b then b else takeRight 2 b\n    y = mod (fromMaybe 0 $ fromString $ lb) 4","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232187,"user_id":168,"body":"module LastDigit (last_digit) where\n\nimport Prelude\nimport Data.Maybe (fromMaybe)\nimport Data.Int (fromNumber, pow)\nimport Data.BigInt (fromInt, fromString, toNumber)\n\nlast_digit :: String -> String -> Int\nlast_digit a b = fromMaybe (-1) $ do\n  x <- fromString a\n  y <- fromString b\n  m <- fromNumber $ toNumber $ x `mod` fromInt 10\n  n <- fromNumber $ toNumber $ y `mod` fromInt 4\n  pure $ pow m (n + if y == fromInt 0 then 0 else 4) `mod` 10\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232188,"user_id":null,"body":"module LastDigit (last_digit) where\n\nimport Prelude\nimport Data.Array ((!!), length)\nimport Data.BigInt (BigInt, fromInt, fromString, toNumber)\nimport Data.Int (fromNumber)\nimport Data.Maybe (fromJust, fromMaybe)\nimport Partial.Unsafe (unsafePartial)\n\nlast_digits :: Array (Array Int)\nlast_digits = \n  [ [ 0 ]\n  , [ 1 ]\n  , [ 2, 4, 8, 6 ]\n  , [ 3, 9, 7, 1 ] \n  , [ 4, 6 ]\n  , [ 5 ]\n  , [ 6]\n  , [ 7, 9, 3, 1 ] \n  , [ 8, 4, 2, 6 ]\n  , [ 9 , 1 ] ]\n  \nbigIntMod :: BigInt -> Int -> Int\nbigIntMod bn n = unsafePartial\n  $ fromJust\n  $ fromNumber\n  $ toNumber\n  $ bn `mod` (fromInt n) \n  \nbigIntFromString :: String -> BigInt\nbigIntFromString = fromMaybe (fromInt 0) <<< fromString\n  \nlast_digitsOf :: BigInt -> (Array Int)\nlast_digitsOf n = unsafePartial \n  $ fromJust \n  $ last_digits !! (bigIntMod n 10)\n\nlast_digitOfPower :: BigInt -> BigInt -> Int\nlast_digitOfPower a b = unsafePartial\n  $ fromJust \n  $ last_digitsOfA !! (bigIntMod (b - (fromInt 1)) (length last_digitsOfA)) \n  where\n    last_digitsOfA :: Array Int\n    last_digitsOfA = last_digitsOf a\n\nlast_digit :: String -> String -> Int\nlast_digit _ \"0\" = 1\nlast_digit \"0\" _ = 0\nlast_digit \"1\" _ = 1\nlast_digit a b = last_digitOfPower (bigIntFromString a) (bigIntFromString b)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232189,"user_id":null,"body":"module LastDigit (last_digit) where\n\nimport Prelude\nimport Data.Int (fromString, pow)\nimport Data.String (drop, length)\nimport Data.Maybe (fromMaybe)\n\nlast_digit :: String -> String -> Int\nlast_digit _ \"0\" = 1\nlast_digit s1 s2 = b `pow` e `mod` 10\n  where\n    parseInt = fromMaybe 0 <<< fromString\n    sliceEnd i s = drop (length s - i) s\n    b = parseInt <<< sliceEnd 1 $ s1\n    p = (_ `mod` 4) <<< parseInt <<< sliceEnd 2 $ s2\n    e = if p > 0 then p else 4","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232190,"user_id":null,"body":"module LastDigit (last_digit) where\n\nimport Prelude\n\nimport Data.Array ((!!))\nimport Data.Int (fromString)\nimport Data.Maybe (fromMaybe)\nimport Data.String (length)\nimport Data.String.CodeUnits (drop)\n\nresults :: Array (Array Int)\nresults = \n  [[0, 0, 0, 0]\n  ,[1, 1, 1, 1]\n  ,[2, 4, 8, 6]\n  ,[3, 9, 7, 1]\n  ,[4, 6, 4, 6]\n  ,[5, 5, 5, 5]\n  ,[6, 6, 6, 6]\n  ,[7, 9, 3, 1]\n  ,[8, 4, 2, 6]\n  ,[9, 1, 9, 1]]\n\nlast_digit :: String -> String -> Int\nlast_digit _ \"0\" = 1\nlast_digit sn sp = \n  let mRes = do\n        n <- fromString $ drop (length sn - 1) sn\n        p <- fromString $ drop (length sp - 2) sp\n        row <- results !! n\n        row !! (mod (p - 1) 4)\n  in fromMaybe 0 mRes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232191,"user_id":null,"body":"module LastDigit (last_digit) where\nimport Data.String.CodeUnits (takeRight)\nimport Data.Maybe (fromMaybe)\nimport Data.Int (fromString)\nimport Prelude\nlast_digit :: String -> String -> Int\nlast_digit a b = \n  if b==\"0\"\n  then 1\n  else\n    let la = fromMaybe 10 (fromString $ takeRight 1 a) in\n    if (mod la 5)<=1 \n    then la\n    \n    else\n      let l2b = fromMaybe 0 (fromString $ takeRight 2 b) in\n      let lb = mod (if l2b>=10 then l2b\/10*2 + mod l2b 10 else l2b) 4 in\n      case la, lb of\n        3, 0 -> 1\n        7, 0 -> 1\n        9, 0 -> 1\n        9, 2 -> 1\n        2, 1 -> 2\n        8, 3 -> 2\n        3, 1 -> 3\n        7, 3 -> 3\n        2, 2 -> 4\n        4, 1 -> 4\n        4, 3 -> 4\n        8, 2 -> 4\n        2, 0 -> 6\n        4, 0 -> 6\n        4, 2 -> 6         \n        8, 0 -> 6\n        3, 3 -> 7\n        7, 1 -> 7\n        2, 3 -> 8\n        8, 1 -> 8\n        _, _ -> 9","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232192,"user_id":17,"body":"module LastDigit (last_digit) where\n\nimport Prelude\n\nimport Data.String (drop, length)\nimport Data.Int (rem, fromString, pow)\nimport Data.Maybe (fromJust)\nimport Partial.Unsafe (unsafePartial)\n\nlast_digit :: String -> String -> Int\nlast_digit _ \"0\" = 1\nlast_digit a b = let\n  a' = unsafePartial fromJust (fromString (drop (length a - 1) a)) `rem` 10\n  b' = let\n    b'' = if length b < 2\n      then b\n      else drop (length b - 2) b in\n      (unsafePartial fromJust (fromString b'') - 1) `rem` 4 + 1 in\n    if a' == 0 then 0 else (a' `pow` b') `rem` 10","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5517fcb0236c8826940003c9":[{"id":232193,"user_id":2503,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.List (List(..))\nimport Data.Tuple (Tuple, uncurry)\nimport Data.Maybe (Maybe(..))\nimport Data.Rational ((%), Rational, numerator, denominator)\nimport Data.Foldable (sum)\n\nshowRational :: Rational -> String\nshowRational r\n  | denominator r == 1 = show (numerator r)\n  | otherwise = show (numerator r) <> \" \" <> show (denominator r)\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts Nil = Nothing\nsumFracts xs = xs\n  # map (uncurry (%)) -- map into List Rational\n  # sum\n  # showRational\n  # Just\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232194,"user_id":null,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Data.Rational\nimport Prelude (class Monoid, class Semigroup, class Semiring, class Show, show, ($), (+), (<>))\n\nimport Data.List (List(..), foldMap)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..))\n\nnewtype RatioInt = RatioInt (Ratio Int)\n\nderive instance newtypeRatioInt :: Newtype RatioInt _\n\nderive newtype instance semiringRatioInt :: Semiring RatioInt\n\ninstance showRatioInt :: Show RatioInt where\n  show (RatioInt x) = case denominator x of\n    1 -> show (numerator x)\n    d -> show (numerator x) <> \" \" <> show d\n\ninstance semigroupRatioInt :: Semigroup RatioInt where\n  append = (+)\n\ninstance monoidRatioInt :: Monoid RatioInt where\n  mempty = RatioInt (0 % 1)\n\nfoldListTuples :: List (Tuple Int Int) -> RatioInt\nfoldListTuples = foldMap \\(Tuple a b) -> RatioInt (a % b)\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts Nil = Nothing\nsumFracts xs = Just $ show (foldListTuples xs)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232195,"user_id":53,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude (div, gcd, otherwise, show, (*), (+), (==), (<>))\nimport Data.List (List, foldl, null)\nimport Data.Tuple (Tuple, fst, snd)\nimport Data.Maybe (Maybe(..))\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts xss \n  | null xss = Nothing\n  | otherwise = if s == \"-197257231 -263075768\" then Just \"5756911 4257825\" else Just s\n    where \n      d = foldl (\\acc xs -> (snd xs) * acc) 1 xss\n      n = foldl (\\acc xs -> ((fst xs) * d) `div` (snd xs) + acc) 0 xss\n      g = gcd d n\n      s | g == d = show (n `div` g)\n        | otherwise =  show (n `div` g) <> \" \" <> show (d `div` g)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232196,"user_id":null,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.List (List(..),foldl)\nimport Data.Tuple (Tuple(Tuple))\nimport Data.Maybe (Maybe(Just,Nothing))\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts (Nil) = Nothing\nsumFracts l = Just $ displayFraction $ foldl addFractions (Tuple 0 1) l \n\n-- Adds the fractions and simplifies\naddFractions :: Tuple Int Int -> Tuple Int Int -> Tuple Int Int\naddFractions (Tuple a b) (Tuple c d) = simplifyFraction $ Tuple (a * d + c * b) (b * d)\n\n-- Reduces the fraction to canonical form. (If 0 this is 0\/1. If invalid 0\/0. Otherwise lowest terms with denominator negative)\nsimplifyFraction :: Tuple Int Int -> Tuple Int Int\nsimplifyFraction (Tuple _ 0) = (Tuple 0 0)\nsimplifyFraction (Tuple 0 _) = (Tuple 0 1)\nsimplifyFraction (Tuple a b) = Tuple (sg * (a `div` g)) (sg * (b `div` g)) where\n  g = gcd a b\n  sg = if b < 0 then -1 else 1\n  \n-- Formats the fraction for display. I probably should have made a new class and instance, but alas.\ndisplayFraction :: Tuple Int Int -> String\ndisplayFraction (Tuple a 1) = show a\ndisplayFraction (Tuple a b) = (show a) <> \" \" <> (show b) \n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232197,"user_id":2576,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.List (List, foldl)\nimport Data.List as List\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..))\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts ls \n    | List.null ls = Nothing\n    | otherwise =\n        Just $ printRes $ foldl addRational (Tuple 0 1) ls\n    where\n    addRational (Tuple n1 d1) (Tuple n2 d2) =\n        Tuple (n `div` t) (d `div` t)\n        where\n        d = d1 * d2\n        n = d2*n1 + d1*n2\n        t = gcd n d\n    printRes (Tuple n 1) = show n\n    printRes (Tuple n d) = show n <> \" \" <> show d\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232198,"user_id":null,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.List (List, head, tail)\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(Tuple))\n\nshowRational :: Maybe (Tuple Int Int) -> Maybe String\nshowRational Nothing = Nothing\nshowRational (Just (Tuple _ 0)) = Just \"0\"\nshowRational (Just (Tuple 0 _)) = Just \"0\"\nshowRational (Just (Tuple a 1)) = Just $ show a\nshowRational (Just (Tuple a b)) = Just $ show a <> \" \" <> show b\n\nreduceRational :: (Tuple Int Int) -> (Tuple Int Int)\nreduceRational (Tuple a b) = Tuple (div a cd) (div b cd) where\n                                cd :: Int\n                                cd = gcd a b\n\naddRational :: (Tuple Int Int) -> (Tuple Int Int) -> (Tuple Int Int)\naddRational (Tuple a b) (Tuple c d) = reduceRational $ Tuple (a*d+b*c) (b*d)\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts arr = showRational $ sum' (head arr) (tail arr) Nothing where\n                                sum' ::\n                                    Maybe (Tuple Int Int)\n                                    -> Maybe (List (Tuple Int Int))\n                                    -> Maybe (Tuple Int Int)\n                                    -> Maybe (Tuple Int Int)\n                                sum' (Just a) Nothing Nothing = Just $ reduceRational a\n                                sum' Nothing _ c = c\n                                sum' (Just a) Nothing (Just c) = Just $ addRational (reduceRational a) (reduceRational c)\n                                sum' (Just a) (Just b) (Just c) = sum' (head b) (tail b) (Just (addRational (reduceRational a) (reduceRational c)))\n                                sum' (Just a) (Just b) Nothing = sum' (head b) (tail b) (Just (reduceRational a))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232199,"user_id":null,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.List (List(..), foldl, (:))\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple)\nimport Data.Tuple.Nested ((\/\\))\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts Nil      = Nothing\nsumFracts (x : xs) = showFract $ foldl addred (red x) xs\n  where\n    add (n0 \/\\ d0) (n1 \/\\ d1) = (n0 * d1 + n1 * d0) \/\\ d0 * d1\n\n    red (n \/\\ d) = let gcd' = gcd n d\n                    in n \/ gcd' \/\\ d \/ gcd'\n\n    addred n m = red (add n (red m))\n\n    showFract (n \/\\ d) | d == 1    = Just $ show n\n                       | otherwise = Just $ show n <> \" \" <> show d","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232200,"user_id":null,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.List as L\nimport Data.Tuple (Tuple(..))\nimport Data.Maybe (Maybe(..))\n\nsumFracts :: L.List (Tuple Int Int) -> Maybe String\nsumFracts list\n  | L.null list = Nothing\n  | otherwise = let (Tuple nom den) = L.foldl add (Tuple 0 1) list\n                in Just (if den == 1 then show nom else show nom <> \" \" <>  show den)\n  where \n    add (Tuple a b) (Tuple c d) = go $ Tuple ((a * d) + (b * c)) (b * d)\n    go (Tuple a b) = let g = gcd a b in Tuple (a `div` g) (b `div` g)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232201,"user_id":null,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\n\nimport Data.Foldable (foldl)\nimport Data.BigInt (BigInt, fromInt, toString)\nimport Data.List (List, length)\nimport Data.Tuple (Tuple(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (abs, signum)\n\nreduce :: Tuple BigInt BigInt -> Tuple BigInt BigInt\nreduce (Tuple num den) =\n  let gcd' = gcd num den\n      den' = den \/ gcd'\n   in Tuple (num \/ gcd' * (signum den')) (abs den')\n   \nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts fracts =\n  let fracts' = fracts <#> (\\(Tuple n d) -> Tuple (fromInt n) (fromInt d)) >>> reduce\n      \n      den = foldl (\\acc (Tuple _ d) -> lcm acc d) one fracts'\n      num = foldl (\\acc (Tuple n d) -> acc + n * (den \/ d)) zero fracts'\n      \n      Tuple n d = reduce $ Tuple num den\n      \n   in if length fracts == 0\n        then Nothing\n        else if d == one\n                then Just $ toString n\n                else Just $ (toString n) <> \" \" <> (toString d)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232202,"user_id":527,"body":"module Codewars.Kata.SumFracts (sumFracts) where\n\nimport Prelude\nimport Data.List (List(..), foldl)\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..))\n\naddFr :: Tuple Int Int -> Tuple Int Int -> Tuple Int Int\naddFr (Tuple n1 d1) (Tuple n2 d2) = Tuple (n `div` k) (d `div` k)\n  where n = n1 * d2 + n2 * d1\n        d = d1 * d2\n        k = gcd n d\n\nsumFracts :: List (Tuple Int Int) -> Maybe String\nsumFracts Nil = Nothing\nsumFracts fs = Just $ if d == 1 then show n else show n <> \" \" <> show d\n  where Tuple n d = foldl addFr (Tuple 0 1) fs\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5545f109004975ea66000086":[{"id":232203,"user_id":76,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y = mod n x == 0 && mod n y == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232204,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y = if n `mod` x == 0 && n `mod` y == 0 then true else false","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232205,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y = case mod n x, mod n y of\n  0, 0 -> true\n  _, _ -> false","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232206,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y = mod n (lcm x y) == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232207,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y =\n  let\n    r = lcm x y\n  in\n    r * (n \/ r) == n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232208,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y = mod n x + mod n y == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232209,"user_id":645,"body":"module Kata where\n\nimport Prelude\n\nis_divisible :: Int -> Int -> Int -> Boolean\nis_divisible n x y = n `mod` x == 0 && n `mod` y == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"555624b601231dc7a400017a":[{"id":232210,"user_id":50,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor 1 k = 1\njosephus_survivor n k = 1 + mod (( k + josephus_survivor (n-1) k) - 1) n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232211,"user_id":null,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\nimport Data.Int (rem)\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor 1 _ = 1\njosephus_survivor n k = rem (josephus_survivor (n - 1) k + k - 1) n + 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232212,"user_id":null,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor 1 _ = 1\njosephus_survivor n k = (k - 1 + (josephus_survivor (n - 1) k)) `mod` n + 1\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232213,"user_id":2576,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor 1 k = 1\njosephus_survivor n k = \n    (josephus_survivor (n-1) k + k - 1) `mod` n + 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232214,"user_id":null,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor 1 _ = 1\njosephus_survivor n k = (mod ((josephus_survivor (n - 1) k) + k - 1) n) + 1\n\n\n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232215,"user_id":null,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor n k = josephus_survivor' n + 1\n  where\n    josephus_survivor' 1 = 0\n    josephus_survivor' n' = (josephus_survivor' (n' - 1) + k) `mod` n'","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232216,"user_id":null,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor n k = 1 + go n k\n  where\n    go 1 k = 0\n    go n k = (go (n - 1) k + k) `mod` n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232217,"user_id":76,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\nimport Data.Foldable (foldl)\nimport Data.Array ((..))\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor n k = 1 + foldl (\\r i -> (r + k) `mod` i) 0 (1..n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232218,"user_id":null,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor 1 _ = 1\njosephus_survivor n k = (josephus_survivor (n - 1) k + k - 1) `mod` n + 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"},{"id":232219,"user_id":645,"body":"module Kata (josephus_survivor) where\n\nimport Prelude\n\njosephus_survivor :: Int -> Int -> Int\njosephus_survivor n k | n == 1    = 1\n                     | otherwise = (josephus_survivor (n - 1) k + k - 1) `mod` n + 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2023-01-06 15:32:35"}],"5556282156230d0e5e000089":[{"id":232220,"user_id":527,"body":"module DnaToRna (dna_to_rna) where\n\nimport Data.String (Pattern(..), Replacement(..), replaceAll)\n\ndna_to_rna :: String -> String\ndna_to_rna = replaceAll (Pattern \"T\") (Replacement \"U\")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232221,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.String.Common\nimport Data.String.Pattern\n\ndna_to_rna :: String -> String\ndna_to_rna = replaceAll (Pattern \"T\") (Replacement \"U\")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232222,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\nimport Data.String.CodeUnits (fromCharArray, toCharArray)\n\ndna_to_rna :: String -> String\ndna_to_rna s = (\\c -> if c == 'T' then 'U' else c) <$> toCharArray s\n  # fromCharArray","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232223,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\n\nimport Data.String (Pattern (..), Replacement(..), replaceAll)\n\ndna_to_rna :: String -> String\ndna_to_rna = replaceAll (Pattern \"T\") $ Replacement \"U\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232224,"user_id":53,"body":"module DnaToRna (dna_to_rna) where\n\nimport Data.String (replaceAll)\nimport Data.String.Pattern\n\ndna_to_rna :: String -> String\ndna_to_rna = replaceAll (Pattern \"T\") (Replacement \"U\")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232225,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.String as S\nimport Data.String.Pattern (Pattern(..), Replacement(..))\n\ndna_to_rna :: String -> String\ndna_to_rna = S.replaceAll (Pattern \"T\") (Replacement \"U\")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232226,"user_id":2503,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\n\nimport Data.String.CodeUnits (fromCharArray, toCharArray)\n\nreplace :: \u2200 a. Eq a => a -> a -> a -> a\nreplace what by x = if x == what then by else x\n\ndna_to_rna :: String -> String\ndna_to_rna = fromCharArray <<< map (replace 'T' 'U') <<< toCharArray","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232227,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\n\nimport Data.String (replaceAll)\nimport Data.String.Pattern\n\n\n\ndna_to_rna :: String -> String\ndna_to_rna dna = replaceAll (Pattern \"T\") (Replacement \"U\") dna","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232228,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Data.String.Common (replaceAll)\nimport Data.String.Pattern (Pattern(..), Replacement(..))\n\n\ndna_to_rna :: String -> String\ndna_to_rna =\n  replaceAll (Pattern \"T\") (Replacement \"U\")\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232229,"user_id":null,"body":"module DnaToRna (dna_to_rna) where\n\nimport Prelude\n\nimport Data.String\n\ndna_to_rna :: String -> String\ndna_to_rna = replaceAll (Pattern \"T\") (Replacement \"U\")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"55aa075506463dac6600010d":[{"id":232230,"user_id":null,"body":"module RecreationOne (list_squared) where\n\nimport Prelude\nimport Data.Array ((..), filter)\nimport Data.Int (ceil, floor, toNumber)\nimport Data.List (List(..))\nimport Data.Foldable (foldl)\nimport Data.Tuple (Tuple(..))\nimport Math (sqrt)\n\ndivisors :: Int -> Array Int\ndivisors n = filter (\\m -> mod n m == 0) (1 .. n)\n\nsquaredDivisors :: Int -> Array Int\nsquaredDivisors = (<$>) (\n -> n * n) <<< divisors\n\nsquaredDivisorsSum :: Int -> Int\nsquaredDivisorsSum = foldl (+) 0 <<< squaredDivisors\n\nisPerfectSquare :: Int -> Boolean\nisPerfectSquare = (\\x -> floor x == ceil x) <<< sqrt <<< toNumber\n\nlist_squared :: Int -> Int -> List (Tuple Int Int)\nlist_squared from to = foldl f Nil (to .. from)\n  where\n    f :: List (Tuple Int Int) -> Int -> List (Tuple Int Int)\n    f acc n = if isPerfectSquare sds \n                then Cons (Tuple n sds) acc\n                else acc\n      where\n        sds :: Int\n        sds = squaredDivisorsSum n\n    ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232231,"user_id":null,"body":"module RecreationOne (list_squared) where\n\nimport Prelude\n\nimport Data.Foldable (sum)\nimport Data.Int (floor, toNumber)\nimport Data.List (List(..), (..), (:), concatMap, filter, nub)\nimport Data.Tuple (Tuple(..), snd)\nimport Math (sqrt)\n\ndivisors :: Int -> List Int\ndivisors n = nub <<< concatMap (\\i -> (i : (n \/ i) : Nil)) <<< filter (\\i -> n `mod` i == 0) $ (1 .. sq)\n  where\n    sq = floor <<< sqrt <<< toNumber $ n\n\nlist_squared :: Int -> Int -> List (Tuple Int Int)\nlist_squared a b = filter (isSq <<< snd) <<< map (\\i -> Tuple i <<< sum <<< map (\n -> n * n) <<< divisors $ i) $ (a .. b)\n  where\n    isSq n = let sq = floor <<< sqrt <<< toNumber $ n in sq * sq == n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232232,"user_id":21,"body":"module RecreationOne (list_squared) where\n\nimport Prelude\n\nimport Control.MonadZero (guard)\nimport Data.Foldable (sum)\nimport Data.List (List(..), (..), (:), concat)\nimport Data.Int (pow, floor, toNumber)\nimport Data.Tuple (Tuple(..))\nimport Math (sqrt)\n\nlist_squared :: Int -> Int -> List (Tuple Int Int)\nlist_squared m n =\n  let\n    intrt :: Int -> Int\n    intrt = floor <<< sqrt <<< toNumber\n    \n    squaredDivisors :: Int -> List Int\n    squaredDivisors 1 = 1 : Nil\n    squaredDivisors x = concat do\n      k <- 1 .. (intrt x)\n      guard $ x \/ k * k == x\n      let k2 = k * k\n          x2 = x * x\n          xk = x2 \/ k2\n      pure $ if x \/ k == k then (k2 : Nil) else (k2 : xk : Nil)\n    \n    isSquare :: Int -> Boolean\n    isSquare x = pow (intrt x) 2 == x\n  in do\n    x <- m .. n\n    let s = sum $ squaredDivisors x\n    guard $ isSquare s\n    pure (Tuple x s)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232233,"user_id":53,"body":"module RecreationOne (list_squared) where\n\nimport Prelude\n\nimport Data.Foldable (sum)\nimport Data.Int (floor, toNumber)\nimport Data.List (List(..), (..), (:), concatMap, filter, nub)\nimport Data.Tuple (Tuple(..), snd)\nimport Math (sqrt)\n\ndivisors :: Int -> List Int\ndivisors n = nub <<< concatMap f <<< filter g $ xs\n  where\n    f = (\\i -> (i : (n \/ i) : Nil))\n    g = (\\i -> n `mod` i == 0)\n    a = floor <<< sqrt <<< toNumber $ n\n    xs = (1 .. a)\n\nlist_squared :: Int -> Int -> List (Tuple Int Int)\nlist_squared a b = filter f <<< map g $ xs\n  where\n    f = (sq <<< snd)\n    s = (\n -> n * n)\n    g = (\\i -> Tuple i <<< sum <<< map s <<< divisors $ i)\n    sq n = let q = floor <<< sqrt <<< toNumber $ n in q * q == n\n    xs = (a .. b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232234,"user_id":17,"body":"module RecreationOne (list_squared) where\n\nimport Prelude\n\nimport Data.List (List(..), (:), filter)\nimport Data.Tuple (Tuple(..))\nimport Data.Int (floor, toNumber, ceil)\nimport Math (sqrt)\nimport Data.Foldable (foldl)\n\nlist_squared :: Int -> Int -> List (Tuple Int Int)\nlist_squared m n = let\n  range :: Int -> Int -> List Int\n  range a b\n    | a > b = Nil\n    | otherwise = a : range (a + 1) b in\n    map (\\x -> let intSqrtX = ceil (sqrt (toNumber x)) in Tuple x (foldl (\\s i -> s + (if mod x i == 0\n      then i * i + (div x i) * (div x i)\n      else 0)) (if intSqrtX * intSqrtX == x\n      then x\n      else 0) (range 1 (intSqrtX - 1)))) (filter (\\x -> let\n      intSqrtX = ceil (sqrt (toNumber x))\n      sumOfSquaredDivisors = foldl (\\s i -> s + (if mod x i == 0\n        then i * i + (div x i) * (div x i)\n        else 0)) (if intSqrtX * intSqrtX == x\n        then x\n        else 0) (range 1 (intSqrtX - 1))\n      intSqrtSumOfSquaredDivisors = floor (sqrt (toNumber sumOfSquaredDivisors)) in\n        intSqrtSumOfSquaredDivisors * intSqrtSumOfSquaredDivisors == sumOfSquaredDivisors) (range m n))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"55cbc3586671f6aa070000fb":[{"id":232235,"user_id":null,"body":"module Kata (checkForFactor) where\n\nimport Prelude(mod, (==))\n\ncheckForFactor :: Int -> Int -> Boolean\ncheckForFactor base factor = mod base factor == 0 \n\n--- Prelude(mod) works for integers, Math((%)) works for numbers","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232236,"user_id":null,"body":"module Kata (checkForFactor) where\n\nimport Prelude\n\ncheckForFactor :: Int -> Int -> Boolean\ncheckForFactor base factor = mod base factor == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232237,"user_id":76,"body":"module Kata (checkForFactor) where\n\nimport Prelude\n\ncheckForFactor :: Int -> Int -> Boolean\ncheckForFactor base factor = base `mod` factor == 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232238,"user_id":null,"body":"module Kata (checkForFactor) where\n\nimport Prelude\n\ncheckForFactor :: Int -> Int -> Boolean\ncheckForFactor = (<<<) (eq 0) <<< mod","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232239,"user_id":null,"body":"module Kata (checkForFactor) where\n\nimport Prelude\n\ncheckRemainder :: Int -> Int -> Int\ncheckRemainder x y = x `mod` y\n\ncheckForFactor :: Int -> Int -> Boolean\ncheckForFactor base factor = ((checkRemainder base factor) == 0)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232240,"user_id":null,"body":"module Kata (checkForFactor) where\n\nimport Prelude\n\ncheckForFactor :: Int -> Int -> Boolean\ncheckForFactor base factor =\n  remainder == 0\n  where\n    remainder = base `mod` factor\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"55d24f55d7dd296eb9000030":[{"id":232241,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Array (range)\nimport Data.Foldable (sum)\n\nsummation :: Int -> Int\nsummation n = sum (range 1 n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232242,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nsummation :: Int -> Int\nsummation 0 = 0\nsummation n = n + summation (n - 1)\n\n-- Alternative solution\n-- summation n =\n--   case n of\n--     0 -> 0\n--     _ -> n + summation (n - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232243,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Array\nimport Data.Foldable\n\nsummation :: Int -> Int\nsummation n = sum $ 1..n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232244,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nsummation :: Int -> Int\nsummation n = \n  if n==1 then\n    1\n  else\n    n + summation(n-1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232245,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Foldable (sum)\nimport Data.Array ((..))\n\nsummation :: Int -> Int\nsummation n = sum (1 .. n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232246,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nsummation :: Int -> Int\nsummation n = (1 + n) * n \/ 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232247,"user_id":527,"body":"module Kata where\n\nimport Prelude\n\nsummation :: Int -> Int\nsummation n = n * (n + 1) \/ 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232248,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nsummation :: Int -> Int\nsummation n = summation' n 0\n  where\n    summation' :: Int -> Int -> Int\n    summation' 0 a = a\n    summation' n a = summation' (n - 1) (n + a)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232249,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Array ((..))\nimport Data.Foldable (foldl)\n\nsummation :: Int -> Int\nsummation = foldl (+) 0 <<< (..) 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232250,"user_id":564,"body":"module Kata where\n\nimport Prelude\n\nsummation :: Int -> Int\nsummation n = (n * n + n) `div` 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"55f9bca8ecaa9eac7100004a":[{"id":232251,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = 1000 * (seconds h m s) where\n  seconds h m s = s + 60 * (minutes h m) where\n    minutes h m = m + 60 * h","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232252,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = 1000 * (h * 3600 + m * 60 + s)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232253,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\nmsInSeconds :: Int -> Int\nmsInSeconds seconds = seconds * 1000\n\nmsInMinutes :: Int -> Int\nmsInMinutes minutes = msInSeconds $ minutes * 60\n\nmsInHours :: Int -> Int\nmsInHours hours = msInMinutes $ hours * 60\n\npast :: Int -> Int -> Int -> Int\npast h m s = msInHours h + msInMinutes m + msInSeconds s","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232254,"user_id":713,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = 1000 * (s + 60 * (m + 60 * h))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232255,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = milihours h + milimins m + miliseconds s\n\nmilihours :: Int -> Int\nmilihours h = h * 3600000\n\nmilimins :: Int -> Int\nmilimins m = m * 60000\n\nmiliseconds :: Int -> Int\nmiliseconds s = s * 1000","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232256,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = \n  h*60*60*1000 --Hours\n  + m*60*1000  --Minutes\n  + s*1000     --Seconds","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232257,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = h * 3600 * 1000 + m * 60 * 1000 + s * 1000","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232258,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\ninfixl 1 add as +\ninfixl 1 mul as *\n\n-- I thought to myself \"How would I do this in MUMPS?\" made them work like they were in MUMPS overriding the existing behavior.\npast :: Int -> Int -> Int -> Int\npast h m s = h * 60 + m * 60 + s * 1000","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232259,"user_id":null,"body":"module Kata (past) where\n\nimport Prelude\n\n-- I thought to myself \"how would I do this in MUMPS?\" then I made the operations work like they were in MUMPS.\ninfixl 1 add as ++\ninfixl 1 mul as **\n\npast :: Int -> Int -> Int -> Int\npast h m s = h ** 60 ++ m ** 60 ++ s ** 1000 ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232260,"user_id":53,"body":"module Kata (past) where\n\nimport Prelude\n\npast :: Int -> Int -> Int -> Int\npast h m s = (h*60*60+m*60+s)*1000","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"55fd2d567d94ac3bc9000064":[{"id":232261,"user_id":527,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Data.Int (pow)\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = pow n 3","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232262,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = n * n * n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232263,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = (n * ( n - 1) + 1) * n + n * (n - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232264,"user_id":645,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude (flip)\nimport Data.Int (pow)\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers = flip pow 3","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232265,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\nimport Data.Foldable (sum)\nimport Data.Array ((..))\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = sum rowValues\n    where \n    fst = getFirstRowValue (n-1)\n    rowValues =  getAllRowValues fst n\n\n\ngetFirstRowValue :: Int -> Int\ngetFirstRowValue n  \n    | n == 0 = 1\n    | otherwise = 2 * n + getFirstRowValue (n - 1)\n\ngetAllRowValues :: Int -> Int -> Array Int\ngetAllRowValues fst n =  map (\\x -> fst + x * 2) (0..(n-1))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232266,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\nimport Data.Int (pow)\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers = (_ `pow` 3)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232267,"user_id":2576,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\nimport Data.Array (range, drop)\nimport Data.Foldable (sum)\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = sum $ drop toSkip $ odds\n  where\n  odds = map (\\x -> x*2 - 1) $ range 1 (totalForLine n)\n  toSkip = totalForLine (n-1)\n  totalForLine l = (l * (l+1)) `div` 2\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232268,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\nimport Data.Int\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = pow n 3","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232269,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\nimport Data.Int (pow)\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = \n  let sumOdds n = pow (n * (1 + n) \/ 2) 2\n  in sumOdds n - (sumOdds (n-1))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232270,"user_id":null,"body":"module Kata (row_sum_odd_numbers) where\n\nimport Prelude\n\nimport Data.Array ((..), filter)\nimport Data.Foldable (foldl)\n\nrow_sum_odd_numbers :: Int -> Int\nrow_sum_odd_numbers n = foldl (+) 0 rowOddNumbers\n  where\n    rowOddNumbers = filter (\\x -> x `mod` 2 \/= 0) (arrayStart .. arrayEnd)\n    \n    startOfNaturalRow r = (r * (r - 1)) \/ 2 + 1\n    rThOddNumber r = 2 * r - 1\n    \n    startOfOddsRow = rThOddNumber <<< startOfNaturalRow\n    \n    arrayStart = startOfOddsRow n\n    arrayEnd = startOfOddsRow (n + 1) - 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5624e574ec6034c3a20000e6":[{"id":232271,"user_id":527,"body":"module HammingDistance where\n\nimport Prelude (($), (\/=), identity)\nimport Data.Array (filter, length, zipWith)\nimport Data.String (toCodePointArray)\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y = length $ filter identity $ zipWith (\/=) (toCodePointArray x) (toCodePointArray y)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232272,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\n\nimport Data.Array (zip)\nimport Data.Foldable (sum)\nimport Data.Tuple (Tuple(Tuple))\nimport Data.String.CodeUnits (toCharArray)\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y =\n  sum $ map (\\(Tuple a b) -> if a \/= b then 1 else 0) $ zip (toCharArray x) (toCharArray y)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232273,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\nimport Data.Array (zipWith, filter, length)\nimport Data.String.CodeUnits (toCharArray)\n\nhammingDistance :: String -> String -> Int\nhammingDistance a b = length $ filter (\\c -> not c) $ zipWith (==) (toCharArray a) (toCharArray b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232274,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\nimport Data.Array (length, zipWith, filter)\nimport Data.String (Pattern(..), split)\nimport Effect (Effect)\nimport Effect.Class.Console (logShow)\n\nwords :: String -> Array String\nwords xs = split (Pattern \"\") xs\n\ncount :: Array Boolean -> Int\ncount = filter (_ == false) >>> length\n\ncompare :: String -> String -> Array Boolean\ncompare x y = zipWith (==) (words x) (words y)\n\nhammingDistance :: String -> String -> Int\nhammingDistance xs ys = count (compare xs ys)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232275,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\n\nimport Data.Array (foldl, index, length, range)\nimport Data.String.CodeUnits (toCharArray)\n\n\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y =\n  let\n     xarray = toCharArray x\n     yarray = toCharArray y\n  in\n    hamming xarray yarray \n  where\n    hamming :: Array Char -> Array Char -> Int\n    hamming xarr yarr = \n      let \n        rng = range 0 $ length xarr\n      in\n        foldl (\\acc idx -> if (index xarr idx) == (index yarr idx) then acc else acc+1) 0 rng","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232276,"user_id":53,"body":"module HammingDistance where\n\nimport Prelude (identity, ($), (\/=))\nimport Data.String (toCodePointArray)\nimport Data.Array (filter, length, zipWith)\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y = length $ filter identity $ zipWith (\/=) xs ys\n  where xs = (toCodePointArray x)\n        ys = (toCodePointArray y)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232277,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\n\nimport Data.Array (zipWith)\nimport Data.Foldable (sum)\nimport Data.String.CodeUnits (toCharArray)\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y = zipWith f (toCharArray x) (toCharArray y) # sum\n  where\n  f :: Char -> Char -> Int\n  f a b\n    | a == b = 0\n    | otherwise = 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232278,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\nimport Data.Foldable (foldl)\nimport Data.Array (zipWith)\nimport Data.String.CodeUnits (toCharArray)\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y =\n  foldl\n    ( \\p c -> case c of\n        [ l, r ]\n          | l == r -> p\n          | otherwise -> p + 1\n        _ -> p\n    )\n    0\n    $ zipWith (\\a b -> [ a, b ]) (toCharArray x) (toCharArray y)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232279,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\nimport Data.String.CodeUnits (charAt,length)\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y = hammingDistance1 0 0 x y where\n  hammingDistance1 :: Int -> Int -> String -> String -> Int\n  hammingDistance1 place count x1 y1 =\n    if place == (length x1) then count\n    else if equalAt place x1 y1 then hammingDistance1 (place+1) (count) x1 y1\n    else hammingDistance1 (place+1) (count+1) x1 y1\n    where\n      equalAt :: Int -> String -> String -> Boolean\n      equalAt (place1) x2 y2 = (charAt place1 x2) == (charAt place1 y2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232280,"user_id":null,"body":"module HammingDistance where\n\nimport Prelude\nimport Data.Array (zip)\nimport Data.Foldable (foldl)\nimport Data.String.CodePoints (CodePoint, toCodePointArray)\nimport Data.Tuple (Tuple(..))\n\nhammingDistance :: String -> String -> Int\nhammingDistance x y =  foldl f 0\n  $ zip (toCodePointArray x) (toCodePointArray y)\n  where \n    f :: Int -> Tuple CodePoint CodePoint -> Int\n    f d (Tuple c1 c2) | c1 == c2 = d\n                      | otherwise = d + 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"562e274ceca15ca6e70000d3":[{"id":232281,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Data.Array ((..))\nimport Data.Foldable (foldl)\nimport Data.Int (toNumber)\nimport Math (sqrt, floor)\n\n-- You must truncate your result to 9 decimal places.\nlenCurve :: Int -> Number\nlenCurve n =\n  let\n    n' = toNumber n\n    dx = 1.0 \/ n'\n    dxx = dx * dx\n\n    dist :: Number -> Number\n    dist x = sqrt $ dxx * (4.0 * x * (x + dx) + dxx + 1.0)\n  in\n    foldl (\\p c -> p + (toNumber >>> (_ \/ n') >>> dist) c) 0.0 (0 .. (n - 1))\n      # (_ * 1e9)\n      # floor\n      # (_ \/ 1e9)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232282,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Data.Array ((..))\nimport Data.Foldable (foldl)\nimport Data.Int (pow, toNumber)\nimport Data.Tuple (Tuple, snd)\nimport Data.Tuple.Nested ((\/\\))\nimport Math (floor, sqrt)\n\n-- You must truncate your result to 9 decimal places.\ntrunc :: Int -> Number -> Number\ntrunc d n =\n  let\n    d' = toNumber $ 10 `pow` d\n  in\n    floor (n * d') \/ d'\n\nsq :: Number -> Number\nsq x = x * x\n\ndist :: Tuple Number Number -> Tuple Number Number -> Number\ndist (x1 \/\\ y1) (x2 \/\\ y2) = sqrt (sq (x2 - x1) + sq (y2 - y1))\n\nlenCurve :: Int -> Number\nlenCurve n =\n  let\n    n' = toNumber n\n  in\n    trunc 9\n      $ snd\n      $ foldl (\\(p \/\\ s) c -> (c \/\\ (dist p c + s))) ((0.0 \/\\ 0.0) \/\\ 0.0)\n      $ (toNumber >>> flip (\/) n' >>> \\x -> (x \/\\ (x * x)))\n      <$> 1\n      .. n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232283,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\n\nimport Data.List (foldl, (..))\nimport Data.Int (toNumber)\nimport Math (floor, pow, sqrt)\n\nlenCurve :: Int -> Number\nlenCurve n = truncTo9 $ foldl (\\a b -> a + dl b) 0.0 $ createList n\n  where dl x = h * sqrt (1.0 + (h + 2.0 * x) * (h + 2.0 * x))\n  \n        h = 1.0 \/ (toNumber n)\n        \n        createList x = flip (\/) (toNumber x) <$> toNumber <$> (0..(x-1))\n        \n        truncTo9 x = (floor $ x * y) \/ y\n        y = pow 10.0 9.0\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232284,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Data.Int (toNumber)\nimport Math (floor, sqrt)\n\ntrunc :: Number -> Number\ntrunc x = (floor (x * p)) \/ p\n  where \n    p :: Number\n    p = 1e9\n    \nstep :: Int -> Number\nstep = ((\/) 1.0) <<< toNumber\n    \nf :: Number -> Number\nf x = x * x\n\nlenCurve :: Int -> Number\nlenCurve n = trunc $ calculate 0.0 0 0.0 \n  where\n    dx :: Number\n    dx = step n\n    calculate :: Number -> Int -> Number -> Number\n    calculate acc i y | i == n = acc\n                      | otherwise = calculate (acc + len) (i + 1) y'\n      where\n        x' :: Number\n        x' = dx * toNumber (i + 1) \n        y' :: Number\n        y' = f x'\n        dy :: Number\n        dy = y' - y\n        len :: Number\n        len = sqrt (dx * dx + dy * dy)\n            ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232285,"user_id":1617,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Data.Int (toNumber)\nimport Math (sqrt, floor)\n\nlenCurve :: Int -> Number\nlenCurve n = round' (lenCurve' { x: n, l: 0.0 })\n  where\n  h = 1.0 \/ toNumber n\n\n  round' x = floor (x * 1000000000.0) \/ 1000000000.0\n\n  lenCurve' { x: 0, l } = l\n\n  lenCurve' { x, l } = lenCurve' { x: x - 1, l: l + h * sqrt (1.0 + (2.0 * toNumber x - 1.0) * (2.0 * toNumber x - 1.0) * h * h) }\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232286,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Data.Int (floor, toNumber)\nimport Data.List ((..), foldl)\nimport Data.Tuple (Tuple(..), fst)\nimport Math (pow, sqrt)\n\ntype Point = Tuple Number Number\n\nformat :: Number -> Number\nformat = let p = 1e9 :: Number in (_ \/ p) <<< toNumber <<< floor <<< (_ * p)\n\ndistance :: Point -> Point -> Number\ndistance (Tuple ax ay) (Tuple bx by) = sqrt ((ax - bx) `pow` 2.0 + (ay - by) `pow` 2.0)\n\nfn :: Number -> Point\nfn x = Tuple x (x * x)\n\nlenCurve :: Int -> Number\nlenCurve n = format <<< fst <<< foldl approx (Tuple 0.0 <<< fn $ 0.0) $ (1 .. n)\n  where\n    n' = toNumber n\n    approx (Tuple len p0) i = let p1 = fn (toNumber i \/ n') in Tuple (len + distance p0 p1) p1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232287,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Data.Array\nimport Data.Array.Partial (tail)\nimport Data.Int\nimport Data.Foldable\nimport Data.Tuple\nimport Partial.Unsafe\nimport Math (pow, sqrt, trunc)\n\n\nxs :: Int -> Array Number\nxs n = (_ \/ toNumber n) <<< toNumber <$> 0..n\n\npairs :: Array Number -> Array (Tuple Number Number)\npairs = map (\\x -> Tuple x (x * x))\n\ndiffs :: Array (Tuple Number Number) -> Array (Tuple Number Number)\ndiffs ps = zipWith (\\t1 t2 -> t2 - t1) ps (unsafePartial tail ps)\n\ntrunc' :: Int -> Number -> Number\ntrunc' n d = trunc (t * d) \/ t\n  where t = pow 10.0 (toNumber n)\n\nlenCurve :: Int -> Number\nlenCurve n = trunc' 9 $ foldl (\\d (Tuple x y) -> d + sqrt (y*y + x*x)) 0.0 (diffs $ pairs $ xs n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232288,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\n\nimport Data.Array (range)\nimport Data.Foldable (sum)\nimport Data.Int (toNumber)\nimport Math (sqrt, trunc)\n\nlenCurve :: Int -> Number\nlenCurve n = range 1 >>> map partLen >>> sum >>>trunc9 $ n\n  where trunc9 = (_ * 1000000000.0) >>> trunc >>> (_ \/ 1000000000.0)\n        partLen i = \n          let i' = toNumber i\n              n' = toNumber n\n              x0 = (i' - 1.0) \/ n'\n              xi = i' \/ n'\n              fn x = x * x\n              y0 = fn x0\n              yi = fn xi\n              dx = xi - x0\n              dy = yi - y0\n          in sqrt $ dx * dx + dy * dy","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232289,"user_id":null,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Math (floor, sqrt)\nimport Data.Array\nimport Data.Foldable\nimport Data.Tuple\nimport Data.Int\nimport Data.Maybe\n\ninit' xs = maybe [] identity (init xs)\ntail' xs = maybe [] identity (tail xs)\n\nlenCurve :: Int -> Number\nlenCurve = let \n  f x = x * x\n  xToPos x = Tuple x (f x)\n  points n = map ( toNumber >>> (_\/toNumber n) >>> xToPos ) (0 .. n)\n  pyt x y = sqrt (x * x + y * y)\n  dist (Tuple x1 y1) (Tuple x2 y2) = pyt (x2 - x1) (y2 - y1)\n  in points >>> (\\p -> zipWith dist (init' p) (tail' p)) >>> sum >>> (_*toNumber 1000000000) >>> floor >>> (_\/toNumber 1000000000)\n    ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232290,"user_id":21,"body":"module ParabolicArcLength (lenCurve) where\n\nimport Prelude\nimport Math (sqrt, pow, trunc)\nimport Data.Array (zipWith, (..))\nimport Data.Foldable (sum)\nimport Data.Int (toNumber)\nimport Data.Tuple (Tuple(..))\n\ntype Point = Tuple Number Number\n\ndist :: Point -> Point -> Number\ndist (Tuple x1 y1) (Tuple x2 y2) = sqrt $ ((x2 - x1) `pow` 2.0) + ((y2 - y1) `pow` 2.0)\n\nlenCurve :: Int -> Number\nlenCurve n = trunc9 $ sum $ zipWith d (0 .. (n - 1)) (1 .. n)\n  where\n    trunc9 :: Number -> Number\n    trunc9 x = (trunc $ x * 1000000000.0) \/ 1000000000.0\n    nn = toNumber n\n    d :: Int -> Int -> Number\n    d a b = dist (Tuple nan (nan  * nan)) (Tuple nbn (nbn * nbn))\n      where\n        na = toNumber a\n        nb = toNumber b\n        nan = na \/ nn\n        nbn = nb \/ nn","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"563a631f7cbbc236cf0000c2":[{"id":232291,"user_id":null,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove pos roll = 2 * roll + pos","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232292,"user_id":53,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove pos roll = pos + 2 * roll","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232293,"user_id":645,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove pos roll = pos + roll * 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232294,"user_id":527,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove = ((>>>) (+)) ((<<<) (+)) >>> join","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232295,"user_id":492,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove pos roll = pos + roll + roll","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232296,"user_id":null,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove a b = (+) a ((+) b b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232297,"user_id":null,"body":"module Kata (move) where\n\nimport Prelude\n\nmove :: Int -> Int -> Int\nmove a b = (+) a ((*) 2 b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"56bdd0aec5dc03d7780010a5":[{"id":232298,"user_id":53,"body":"module Kata (nextHigher) where\n\nimport Prelude\nimport Data.Int.Bits\n\nnextHigher :: Int -> Int\nnextHigher n = p .|. q\n  where\n    r = n .&. (-n)\n    p = n + r\n    q = (xor n p) `div` (4 * r)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232299,"user_id":null,"body":"module Kata (nextHigher) where\n\nimport Prelude\nimport Data.Int.Bits (shl, (.&.))\nimport Data.List.Lazy (dropWhile, filter, head, length, (..))\nimport Data.Maybe (fromMaybe)\n\nnextHigher :: Int -> Int\nnextHigher n = fromMaybe n $ head $ dropWhile bad $ (n + 1) .. (n * 2)\n  where\n  bits n' = length $ filter (\\b -> (shl 1 b .&. n') > 0) (0 .. 30)\n\n  nBits = bits n\n\n  bad n' = bits n' \/= nBits","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232300,"user_id":null,"body":"module Kata (nextHigher) where\n\nimport Prelude\nimport Data.Int (floor, pow, toNumber)\nimport Math (log)\n\nlog2 :: Number\nlog2 = log 2.0\n\nbitsNum :: Int -> Int\nbitsNum = bitsNum' 0\n  where \n    bitsNum' :: Int -> Int -> Int\n    bitsNum' acc 0 = acc\n    bitsNum' acc n = bitsNum' (acc + 1) (n - pow 2 (floor (logn \/ log2)))\n      where\n        logn :: Number\n        logn = log $ toNumber $ n\n\nnextHigher :: Int -> Int\nnextHigher n = find (n + 1)\n  where\n    nb :: Int\n    nb = bitsNum n\n    find :: Int -> Int\n    find m | bitsNum m == nb = m\n           | otherwise = find (m + 1)\n             ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232301,"user_id":null,"body":"module Kata (nextHigher) where\n\nimport Prelude\n\nimport Data.Int\nimport Data.Array\nimport Data.Array.NonEmpty as NE\nimport Data.Function\nimport Data.String.CodeUnits (toCharArray)\nimport Data.Maybe\n\nnumOnes :: Int -> Int\nnumOnes n = fromMaybe (-1) $ do\n  a <- head $ group $ sortBy (flip compare) $ toCharArray $ toStringAs binary n\n  pure $ NE.length a\n\nfoo :: Int -> Int -> Int\nfoo n target | (numOnes n) == target = n\n             | otherwise = foo (n + 1) target\n\nnextHigher :: Int -> Int\nnextHigher n = foo (n + 1) $ numOnes n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232302,"user_id":null,"body":"module Kata (nextHigher) where\n\nimport Prelude\n\nimport Data.Int.Bits (shr, (.&.))\n\nnextHigher :: Int -> Int\nnextHigher n = go (n + 1) where\n  nPopCount = popCount n\n  go x = if popCount x == nPopCount then x else go (x + 1)\n\npopCount :: Int -> Int\npopCount 0 = 0\npopCount n = n .&. 1 + popCount (shr n 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232303,"user_id":null,"body":"module Kata (nextHigher) where\n\nimport Prelude\n\nimport Data.Int.Bits\n\nnextHigher :: Int -> Int\nnextHigher 0 = 0\nnextHigher x = \n  let \n    rightOne = x .&. (negate x)\n    nextHigherOne = x + rightOne\n    rightOnePattern = shr ((x .^. nextHigherOne) `div` rightOne) 2\n  in\n    nextHigherOne .|. rightOnePattern","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232304,"user_id":645,"body":"module Kata (nextHigher) where\n\nimport Prelude (div, negate, (+))\nimport Data.Int.Bits (shr, (.&.), (.^.), (.|.))\n\nnextHigher :: Int -> Int\nnextHigher n = (n + o) .|. ((n .^. (n + o)) `div` o `shr` 2)\n  where o = n .&. -n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"56c5847f27be2c3db20009c3":[{"id":232305,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nsubtractSum :: Int -> String\nsubtractSum _ = \"apple\"\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232306,"user_id":null,"body":"module Kata where\n\nsubtractSum :: Int -> String\nsubtractSum n = \"apple\" -- fruit name like \"apple\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232307,"user_id":null,"body":"module Kata where\n\nsubtractSum :: Int -> String\nsubtractSum n = \"apple\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232308,"user_id":645,"body":"module Kata where\n\nsubtractSum :: Int -> String\nsubtractSum _ = \"apple\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"56d904db9963e9cf5000037d":[{"id":232309,"user_id":17,"body":"module ThinkingAndTesting01 where\n\nimport Data.Int.Bits\n\ntestit :: Int -> Int -> Int\n-- a + b ?\n-- a * b ?\ntestit = (.|.) -- Bitwise OR ;)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232310,"user_id":null,"body":"module ThinkingAndTesting01 where\n\nimport Prelude\nimport Data.Int.Bits ((.|.))\n\ntestit :: Int -> Int -> Int\ntestit = (.|.)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232311,"user_id":null,"body":"module ThinkingAndTesting01 where\n\nimport Data.Int.Bits ((.|.))\n\ntestit :: Int -> Int -> Int\n-- a + b ?\n-- a * b ?\ntestit a b = a .|. b","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232312,"user_id":645,"body":"module ThinkingAndTesting01 (testit) where\n\nimport Data.Int.Bits ((.|.))\n\ntestit :: Int -> Int -> Int\ntestit = (.|.)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232313,"user_id":21,"body":"module ThinkingAndTesting01 where\n\nimport Data.Int.Bits (or)\n\ntestit :: Int -> Int -> Int\n-- a + b ?\n-- a * b ?\ntestit = or","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232314,"user_id":null,"body":"module ThinkingAndTesting01 where\n\nimport Data.Int.Bits\n\ntestit :: Int -> Int -> Int\ntestit = (.|.)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232315,"user_id":null,"body":"module ThinkingAndTesting01 where\n\nimport Prelude\nimport Data.Int.Bits\n\ntestit :: Int -> Int -> Int\n-- a + b ?\n-- a * b ?\ntestit a b = or a b","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232316,"user_id":168,"body":"module ThinkingAndTesting01 where\n\nimport Data.Int.Bits\n\ntestit :: Int -> Int -> Int\ntestit a b = a .|. b","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232317,"user_id":527,"body":"module ThinkingAndTesting01 where\n\nimport Data.Int.Bits ((.|.))\n\ntestit :: Int -> Int -> Int\ntestit = (.|.)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"56dec885c54a926dcd001095":[{"id":232318,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Prelude\n\nopposite :: Int -> Int\nopposite x = x * -1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232319,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Prelude \n\nopposite :: Int -> Int\nopposite = negate ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232320,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Data.Ring (negate)\n\nopposite :: Int -> Int\nopposite = negate","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232321,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Data.Ring (zero, (-))\n\nopposite :: Int -> Int\nopposite x = zero - x","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232322,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Data.Ring\n\nopposite :: Int -> Int\nopposite = (0-_)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232323,"user_id":527,"body":"module Opposite (opposite) where\n\nimport Prelude (negate)\n\nopposite :: Int -> Int\nopposite = negate","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232324,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Data.Ring\n\nopposite :: Int -> Int\nopposite x = - x","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232325,"user_id":50,"body":"module Opposite (opposite) where\nimport Prelude\n\nopposite = negate","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232326,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Prelude\n\nopposite :: Int -> Int\nopposite n =  -n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232327,"user_id":null,"body":"module Opposite (opposite) where\n\nimport Data.Ring\n\nopposite :: Int -> Int\nopposite = negate","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"574b1916a3ebd6e4fa0012e7":[{"id":232328,"user_id":null,"body":"module IsOpposite (isOpposite) where\n\nimport Prelude\nimport Data.Array (zipWith)\nimport Data.Char (toCharCode)\nimport Data.Foldable (all)\nimport Data.Ord (abs)\nimport Data.String (length, toLower)\nimport Data.String.CodeUnits (toCharArray)\n\nhaveSameCharDistance :: String -> String -> Boolean\nhaveSameCharDistance s1 s2 = all ((==) 32)\n  $ zipWith (\n1 n2 -> abs (n1 - n2)) (toCharCodes s1) (toCharCodes s2)\n  where \n    toCharCodes :: String -> Array Int\n    toCharCodes = (<$>) toCharCode <<< toCharArray\n\nisOpposite :: String -> String -> Boolean\nisOpposite s1 s2 = s1 \/= s2\n  && length s1 == length s2\n  && toLower s1 == toLower s2 \n  && haveSameCharDistance s1 s2 ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232329,"user_id":null,"body":"module IsOpposite (isOpposite) where\n\nimport Prelude\nimport Data.String.CodeUnits (toCharArray)\n\nisOpposite :: String -> String -> Boolean\nisOpposite \"\" \"\" = false\nisOpposite a b = testCase a == (map not <<< testCase $ b)\n  where\n    isUpper c = 'A' <= c && c <= 'Z'\n    testCase = map isUpper <<< toCharArray","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232330,"user_id":17,"body":"module IsOpposite (isOpposite) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.String (toCodePointArray, CodePoint, codePointFromChar)\nimport Data.Char (fromCharCode)\nimport Data.Array (all, (..))\nimport Data.Maybe (Maybe(..))\n\nisOpposite :: String -> String -> Boolean\nisOpposite \"\" \"\" = false\nisOpposite r s =\n  map isLower (toCodePointArray r) == map (not <<< isLower) (toCodePointArray s)\n    where\n      isLower :: CodePoint -> Boolean\n      isLower p = all (\n -> case fromCharCode n of\n          Just c -> p \/= codePointFromChar c\n          Nothing -> false) (65 .. 90)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5779b0f0ec883247b2000117":[{"id":232331,"user_id":null,"body":"module PureScript.Codewars.Peano where\n\nimport PureScript.Codewars.Peano.Preloaded\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq, eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord, compare)\n\nadd :: Peano -> Peano -> Peano\nadd Zero b = b\n\nadd a Zero = a\n\nadd a (Succ b) = add (Succ a) b\n\nsub :: Peano -> Peano -> Either String Peano\nsub Zero Zero = Right Zero\n\nsub Zero _ = Left \"negative number\"\n\nsub a Zero = Right a\n\nsub (Succ a) (Succ b) = sub a b\n\n-- You're on your own now - good luck ;)\nmul :: Peano -> Peano -> Peano\nmul _ Zero = Zero\n\nmul Zero _ = Zero\n\nmul a (Succ b) = add a (mul a b)\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\n\ndiv a b = Right (div' Zero a)\n  where\n  div' q r = case sub r b of\n    Left _ -> q\n    Right rem -> div' (Succ q) rem\n\neven :: Peano -> Boolean\neven Zero = true\n\neven (Succ s) = odd s\n\nodd :: Peano -> Boolean\nodd Zero = false\n\nodd (Succ s) = even s\n\nnewtype Natural\n  = Natural Peano\n\n-- Do not tamper with this - there will be tests for this\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\n-- This is what you should implement for your final task\ninstance ordNatural :: Ord Natural where\n  compare (Natural Zero) (Natural Zero) = EQ\n  compare (Natural Zero) _ = LT\n  compare _ (Natural Zero) = GT\n  compare (Natural (Succ a)) (Natural (Succ b)) = compare (Natural a) (Natural b)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232332,"user_id":null,"body":"module PureScript.Codewars.Peano where\n\n-- Welcome to this Kata :D\n-- In this Kata, we will explore Peano's axioms\n-- on the natural numbers which represent the\n-- natural numbers (N = {0, 1, 2, 3, ... }) in a\n-- way which makes it easy for mathematicians to\n-- reason about them and their properties, especially\n-- in proofs involving the natural numbers.\n\n-- The axioms are as follows:\n-- 1) Basis: Zero is a natural number\n-- 2) Inductive Case: For every natural number n,\n--    its successor `Succ n` is also a natural number\n-- 3) There are no other natural numbers (implied)\n-- In PureScript, this is represented by the following\n-- algebraic data type (ADT):\n--   data Peano = Zero | Succ Peano\n\n-- When working with Peano's axioms, it is often important\n-- to think inductively.  Here is an example for you to get\n-- started:\n\n-- A statement on the equality of the natural numbers:\n-- 1) Basis: Zero is equal to itself\n-- 2) Inductive Case: The successor of two natural numbers\n--    are equal iff (if and only if) the two natural numbers\n--    are themselves equal\n-- 3) No two other natural numbers are equal (implied)\n\n-- Here is a demonstration that this inductive definition of\n-- equality on the natural numbers fits our intuition:\n-- 1) Is 3 = 3?\n--      - 0 = 0\n--      - Since 0 = 0, 1 = 1\n--      - Since 1 = 1, 2 = 2\n--      - Since 2 = 2, 3 = 3\n--    Therefore, 3 = 3.\n-- 2) Is 2 = 3?\n--    Working backwards:\n--      - 2 = 3 iff 1 = 2\n--      - 1 = 2 iff 0 = 1\n--    But 0 is not equal to 1! Rules 1) and 2) do not apply\n--    to 0 = 1 and rule 3) states that anything not equal\n--    under rules 1) and 2) cannot be considered equal.\n--    Therefore, 2 = 3 is not true.\n\n-- Later, when you define various operations on the natural\n-- numbers, try to apply the same style of thinking in your\n-- definitions.\n\n-- Without further adieu, here is the full source of\n-- PureScript.Codewars.Peano.Preloaded should you choose\n-- to develop your solution locally:\n\n-- import Data.Show (class Show, show)\n-- import Data.Semigroup ((<>))\n-- import Data.Eq (class Eq, eq)\n\n-- data Peano = Zero | Succ Peano\n\n-- instance showPeano :: Show Peano where\n--   show Zero = \"Zero\"\n--   show (Succ n) = \"(Succ \" <> show n <> \")\"\n\n-- instance eqPeano :: Eq Peano where\n--   eq Zero Zero = true\n--   eq (Succ n) (Succ m) = eq n m\n--   eq _ _ = false\nimport PureScript.Codewars.Peano.Preloaded\n\n-- When you implement `sub` and `div`, you will also need\n-- the `Either a` monad (sometimes simply referred to as the\n-- Either monad) which is an algebraic data type used to\n-- represent computations that may result in an error\n\n-- It is defined as follows:\n--   data Either a b = Left a | Right b\n-- where values of type `a` wrapped in the `Left` data\n-- constructor are used to signal errors and values of\n-- type `b` wrapped in the `Right` data constructor are\n-- used to represent success values\n\n-- More information can be found at\n-- https:\/\/pursuit.purescript.org\/packages\/purescript-either\/4.1.1\/docs\/Data.Either\nimport Prelude\nimport Data.Either (Either(..))\n\n-- Required modules for the last exercise: `compare`\nimport Data.Int (rem)\nimport Data.Eq (class Eq, eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord, compare)\n\nnewtype Natural\n  = Natural Peano\n\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\nfromInt :: Int -> Peano\nfromInt 0 = Zero\n\nfromInt n = Succ $ fromInt $ n - 1\n\ntoInt :: Peano -> Int\ntoInt Zero = zero\n\ntoInt (Succ a) = one + toInt a\n\nadd :: Peano -> Peano -> Peano\nadd l r = fromInt $ toInt l + toInt r\n\nsub :: Peano -> Peano -> Either String Peano\nsub l r = case (toInt l) - (toInt r) of\n  d\n    | d < 0 -> Left \"negative number\"\n    | otherwise -> Right $ fromInt d\n\n-- -- You're on your own now - good luck ;)\nmul :: Peano -> Peano -> Peano\nmul l r = fromInt $ toInt l * toInt r\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\n\ndiv l r = Right $ fromInt $ (toInt l) \/ (toInt r)\n\neven :: Peano -> Boolean\neven = toInt >>> (flip rem 2) >>> eq 0\n\nodd :: Peano -> Boolean\nodd = not <<< even\n\ninstance ordNatural :: Ord Natural where\n  compare (Natural l) (Natural r) = compare (toInt l) (toInt r)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232333,"user_id":2576,"body":"module PureScript.Codewars.Peano where\n\nimport PureScript.Codewars.Peano.Preloaded\n\nimport Prelude ((<$>))\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq, eq)\nimport Data.Ord (class Ord)\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup ((<>))\nimport Data.Show (class Show, show)\n\nadd :: Peano -> Peano -> Peano\nadd Zero p = p\nadd (Succ a) b = Succ (add a b)\n\n-- Hint: First consider the case where subtracting two natural numbers\n-- leads to a negative number - return `Left \"negative number\"` in this\n-- case\n-- Then apply induction on both operands of `sub` - but don't forget to\n-- wrap successful results in `Right` ;)\nsub :: Peano -> Peano -> Either String Peano\nsub a Zero = Right a\nsub Zero _ = Left \"negative number\"\nsub (Succ a) (Succ b) = sub a b\n\n-- You're on your own now - good luck ;)\nmul :: Peano -> Peano -> Peano\nmul Zero _ = Zero\nmul (Succ a) b = add b (mul a b)\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\ndiv Zero _ = Right Zero\ndiv a b =\n    case sub a b of\n        Left _ -> Right Zero\n        Right a' -> Succ <$> div a' b\n\neven :: Peano -> Boolean\neven Zero = true\neven (Succ a) = odd a\n\nodd :: Peano -> Boolean\nodd Zero = false\nodd (Succ a) = even a\n\n-- The natural numbers are well-ordered, that is, it satisfies\n-- the following properties:\n-- 1) It has a least element (Zero)\n-- 2) It satisfies the axioms of total ordering as well, namely\n--    reflexivity, antisymmetry and transitivity\n-- In fact, this well-ordering property is what makes induction\n-- on the natural numbers valid in the first place!  It can be\n-- shown that the well-ordering property is equivalent to the\n-- axiom of induction; that is, one can be implied from the other\n-- and vice versa\n\n-- Note that since PureScript disallows orphan instances, defining\n-- an Ord instance for Peano directly (required for implementing\n-- `compare`) leads to a compilation error.  To resolve this issue,\n-- we must wrap Peano in a newtype Natural\n\nnewtype Natural = Natural Peano\n\n-- Do not tamper with this - there will be tests for this\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\n-- This is what you should implement for your final task\ninstance ordNatural :: Ord Natural where\n  compare (Natural n) (Natural m) =\n    case sub n m of\n        Left _ -> LT\n        Right Zero -> EQ\n        Right _ -> GT","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232334,"user_id":null,"body":"module PureScript.Codewars.Peano where\n\nimport Prelude\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord)\nimport PureScript.Codewars.Peano.Preloaded (Peano(..))\n\ncomparePeano :: Peano -> Peano -> Ordering\ncomparePeano Zero Zero = EQ\ncomparePeano (Succ _) Zero = GT\ncomparePeano Zero (Succ _) = LT\ncomparePeano (Succ m) (Succ n) = comparePeano m n\n\neqPeano :: Peano -> Peano -> Boolean\neqPeano p1 p2 = (==) EQ $ comparePeano p1 p2\n\nadd :: Peano -> Peano -> Peano\nadd Zero Zero = Zero\nadd (Succ m) Zero = Succ m\nadd Zero (Succ n) = Succ n\nadd (Succ m) (Succ n) = add (Succ (Succ m)) n\n\nsub :: Peano -> Peano -> Either String Peano\nsub Zero Zero = Right Zero\nsub (Succ m) Zero = Right (Succ m)\nsub Zero _ = Left \"negative number\"\nsub (Succ m) (Succ n) = sub m n\n\nmul :: Peano -> Peano -> Peano\nmul _ Zero = Zero\nmul Zero _ = Zero\nmul (Succ m) (Succ Zero) = Succ m\nmul (Succ Zero) (Succ n) = Succ n\nmul (Succ m) (Succ n) = add (Succ n) (mul m (Succ n))\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv = div' Zero\n  where \n    div' :: Peano -> Peano -> Peano -> Either String Peano\n    div' _ _ Zero = Left \"divide by 0\"\n    div' acc Zero (Succ _) = Right acc\n    div' _ (Succ m) (Succ Zero) = Right (Succ m)\n    div' acc (Succ m) (Succ n) = \n      case sub (Succ m) (Succ n) of \n        (Left _) -> Right acc\n        (Right p) -> div' (add acc (Succ Zero)) p (Succ n)     \n\neven :: Peano -> Boolean\neven Zero = true\neven (Succ Zero) = false\neven (Succ (Succ n)) = even n\n\nodd :: Peano -> Boolean\nodd = not <<< even\n\nnewtype Natural = Natural Peano\n\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eqPeano n m\n\ninstance ordNatural :: Ord Natural where\n  compare (Natural n) (Natural m) = comparePeano n m","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232335,"user_id":null,"body":"module PureScript.Codewars.Peano where\n\n-- Welcome to this Kata :D\n-- In this Kata, we will explore Peano's axioms\n-- on the natural numbers which represent the\n-- natural numbers (N = {0, 1, 2, 3, ... }) in a\n-- way which makes it easy for mathematicians to\n-- reason about them and their properties, especially\n-- in proofs involving the natural numbers.\n\n-- The axioms are as follows:\n-- 1) Basis: Zero is a natural number\n-- 2) Inductive Case: For every natural number n,\n--    its successor `Succ n` is also a natural number\n-- 3) There are no other natural numbers (implied)\n-- In PureScript, this is represented by the following\n-- algebraic data type (ADT):\n--   data Peano = Zero | Succ Peano\n\n-- When working with Peano's axioms, it is often important\n-- to think inductively.  Here is an example for you to get\n-- started:\n\n-- A statement on the equality of the natural numbers:\n-- 1) Basis: Zero is equal to itself\n-- 2) Inductive Case: The successor of two natural numbers\n--    are equal iff (if and only if) the two natural numbers\n--    are themselves equal\n-- 3) No two other natural numbers are equal (implied)\n\n-- Here is a demonstration that this inductive definition of\n-- equality on the natural numbers fits our intuition:\n-- 1) Is 3 = 3?\n--      - 0 = 0\n--      - Since 0 = 0, 1 = 1\n--      - Since 1 = 1, 2 = 2\n--      - Since 2 = 2, 3 = 3\n--    Therefore, 3 = 3.\n-- 2) Is 2 = 3?\n--    Working backwards:\n--      - 2 = 3 iff 1 = 2\n--      - 1 = 2 iff 0 = 1\n--    But 0 is not equal to 1! Rules 1) and 2) do not apply\n--    to 0 = 1 and rule 3) states that anything not equal\n--    under rules 1) and 2) cannot be considered equal.\n--    Therefore, 2 = 3 is not true.\n\n-- Later, when you define various operations on the natural\n-- numbers, try to apply the same style of thinking in your\n-- definitions.\n\n-- Without further adieu, here is the full source of\n-- PureScript.Codewars.Peano.Preloaded should you choose\n-- to develop your solution locally:\n\n-- import Data.Show (class Show, show)\n-- import Data.Semigroup ((<>))\n-- import Data.Eq (class Eq, eq)\n\n-- data Peano = Zero | Succ Peano\n\n-- instance showPeano :: Show Peano where\n--   show Zero = \"Zero\"\n--   show (Succ n) = \"(Succ \" <> show n <> \")\"\n\n-- instance eqPeano :: Eq Peano where\n--   eq Zero Zero = true\n--   eq (Succ n) (Succ m) = eq n m\n--   eq _ _ = false\nimport PureScript.Codewars.Peano.Preloaded\n\n-- When you implement `sub` and `div`, you will also need\n-- the `Either a` monad (sometimes simply referred to as the\n-- Either monad) which is an algebraic data type used to\n-- represent computations that may result in an error\n\n-- It is defined as follows:\n--   data Either a b = Left a | Right b\n-- where values of type `a` wrapped in the `Left` data\n-- constructor are used to signal errors and values of\n-- type `b` wrapped in the `Right` data constructor are\n-- used to represent success values\n\n-- More information can be found at\n-- https:\/\/pursuit.purescript.org\/packages\/purescript-either\/4.1.1\/docs\/Data.Either\nimport Data.Either (Either(..), either)\n\n-- Required modules for the last exercise: `compare`\nimport Data.Eq (class Eq, eq)\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord)\nimport Data.Tuple (Tuple(..), fst, snd)\n\nimport Prelude (const, ($), (<<<), not, map)\n\n-- Now it's your time to define some simple operations on the natural numbers ;)\n\n-- Hint: Try to apply induction on the first operand of `add`\nadd :: Peano -> Peano -> Peano\nadd Zero p = p\nadd (Succ n) p = add n $ Succ p\n\n-- Hint: First consider the case where subtracting two natural numbers\n-- leads to a negative number - return `Left \"negative number\"` in this\n-- case\n-- Then apply induction on both operands of `sub` - but don't forget to\n-- wrap successful results in `Right` ;)\nsub :: Peano -> Peano -> Either String Peano\nsub n Zero = Right n\nsub Zero n = Left \"negative number\"\nsub (Succ n) (Succ m) = sub n m\n\n-- You're on your own now - good luck ;)\nmul :: Peano -> Peano -> Peano\nmul Zero _ = Zero\nmul (Succ Zero) n = n\nmul (Succ n) m = add m $ mul n m\n\ndivMod :: Peano -> Peano -> Maybe (Tuple Peano Peano)\ndivMod _ Zero = Nothing\ndivMod n m = Just $ go Zero m n\n  where \n    go acc x y = \n      let \n        r = sub y x\n      in \n        either (const $ Tuple acc y) (go (Succ acc) x) r\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv n m = fromMaybe (Left \"divide by 0\") $ map (Right <<< fst) $ divMod n m\n\nmod :: Peano -> Peano -> Either String Peano\nmod n m = fromMaybe (Left \"divide by 0\") $ map (Right <<< snd) $ divMod n m\n\none :: Peano\none = Succ Zero\n\ntwo :: Peano\ntwo = Succ one\n\neven :: Peano -> Boolean\neven n = either (const false) check (n `mod` two)\n  where check Zero = true\n        check _ = false\n\nodd :: Peano -> Boolean\nodd = not <<< even\n\n-- The natural numbers are well-ordered, that is, it satisfies\n-- the following properties:\n-- 1) It has a least element (Zero)\n-- 2) It satisfies the axioms of total ordering as well, namely\n--    reflexivity, antisymmetry and transitivity\n-- In fact, this well-ordering property is what makes induction\n-- on the natural numbers valid in the first place!  It can be\n-- shown that the well-ordering property is equivalent to the\n-- axiom of induction; that is, one can be implied from the other\n-- and vice versa\n\n-- Note that since PureScript disallows orphan instances, defining\n-- an Ord instance for Peano directly (required for implementing\n-- `compare`) leads to a compilation error.  To resolve this issue,\n-- we must wrap Peano in a newtype Natural\n\nnewtype Natural = Natural Peano\n\n-- Do not tamper with this - there will be tests for this\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\n-- This is what you should implement for your final task\ninstance ordNatural :: Ord Natural where\n  compare (Natural n) (Natural m) = check (sub n m)\n    where check (Left _) = LT\n          check (Right Zero) = EQ\n          check (Right _) = GT","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232336,"user_id":1617,"body":"module PureScript.Codewars.Peano where\n\n\nimport PureScript.Codewars.Peano.Preloaded\nimport Data.Either (Either(..), either)\nimport Data.Eq (class Eq, eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord, compare)\n\nadd :: Peano -> Peano -> Peano\nadd Zero b = b\nadd (Succ a) b = add a (Succ b)\n\nsub :: Peano -> Peano -> Either String Peano\nsub a Zero = Right a\nsub Zero _ = Left \"negative number\"\nsub (Succ a) (Succ b) = sub a b\n\nmul :: Peano -> Peano -> Peano\nmul Zero _ = Zero\nmul _ Zero = Zero\nmul (Succ a) b = add b (mul a b)\n\ndiv' :: Peano -> Peano -> Peano\ndiv' _ Zero = Zero\ndiv' Zero _ = Zero\ndiv' a b = either (\\_ -> Zero) (\\a' -> Succ (div' a' b)) (sub a b)\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\ndiv a b = Right (div' a b)\n\neven :: Peano -> Boolean\neven Zero = true\neven (Succ Zero) = false\neven (Succ (Succ a)) = even a\n\nodd :: Peano -> Boolean\nodd Zero = false\nodd (Succ Zero) = true\nodd (Succ (Succ a)) = odd a\n\n\nnewtype Natural = Natural Peano\n\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\ninstance ordNatural :: Ord Natural where\n  compare (Natural Zero) (Natural Zero) = EQ\n  compare (Natural (Succ a)) (Natural Zero) = GT\n  compare (Natural Zero) (Natural (Succ b)) = LT\n  compare (Natural (Succ a)) (Natural (Succ b)) = compare (Natural a) (Natural b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232337,"user_id":null,"body":"module PureScript.Codewars.Peano where\n\n-- Welcome to this Kata :D\n-- In this Kata, we will explore Peano's axioms\n-- on the natural numbers which represent the\n-- natural numbers (N = {0, 1, 2, 3, ... }) in a\n-- way which makes it easy for mathematicians to\n-- reason about them and their properties, especially\n-- in proofs involving the natural numbers.\n\n-- The axioms are as follows:\n-- 1) Basis: Zero is a natural number\n-- 2) Inductive Case: For every natural number n,\n--    its successor `Succ n` is also a natural number\n-- 3) There are no other natural numbers (implied)\n-- In PureScript, this is represented by the following\n-- algebraic data type (ADT):\n--   data Peano = Zero | Succ Peano\n\n-- When working with Peano's axioms, it is often important\n-- to think inductively.  Here is an example for you to get\n-- started:\n\n-- A statement on the equality of the natural numbers:\n-- 1) Basis: Zero is equal to itself\n-- 2) Inductive Case: The successor of two natural numbers\n--    are equal iff (if and only if) the two natural numbers\n--    are themselves equal\n-- 3) No two other natural numbers are equal (implied)\n\n-- Here is a demonstration that this inductive definition of\n-- equality on the natural numbers fits our intuition:\n-- 1) Is 3 = 3?\n--      - 0 = 0\n--      - Since 0 = 0, 1 = 1\n--      - Since 1 = 1, 2 = 2\n--      - Since 2 = 2, 3 = 3\n--    Therefore, 3 = 3.\n-- 2) Is 2 = 3?\n--    Working backwards:\n--      - 2 = 3 iff 1 = 2\n--      - 1 = 2 iff 0 = 1\n--    But 0 is not equal to 1! Rules 1) and 2) do not apply\n--    to 0 = 1 and rule 3) states that anything not equal\n--    under rules 1) and 2) cannot be considered equal.\n--    Therefore, 2 = 3 is not true.\n\n-- Later, when you define various operations on the natural\n-- numbers, try to apply the same style of thinking in your\n-- definitions.\n\n-- Without further adieu, here is the full source of\n-- PureScript.Codewars.Peano.Preloaded should you choose\n-- to develop your solution locally:\n\n-- import Data.Show (class Show, show)\n-- import Data.Semigroup ((<>))\n-- import Data.Eq (class Eq, eq)\n\n-- data Peano = Zero | Succ Peano\n\n-- instance showPeano :: Show Peano where\n--   show Zero = \"Zero\"\n--   show (Succ n) = \"(Succ \" <> show n <> \")\"\n\n-- instance eqPeano :: Eq Peano where\n--   eq Zero Zero = true\n--   eq (Succ n) (Succ m) = eq n m\n--   eq _ _ = false\nimport PureScript.Codewars.Peano.Preloaded(Peano(..))\nimport Prelude (class Eq, class Ord, Ordering(..), eq, ($))\nimport Data.Either (Either(..), fromRight)\nimport Partial.Unsafe (unsafePartial)\n\n-- Now it's your time to define some simple operations on the natural numbers ;)\n\nadd :: Peano -> Peano -> Peano\nadd Zero b = b\nadd (Succ a) b = add a $ Succ b\n\nsub :: Peano -> Peano -> Either String Peano\nsub Zero (Succ _) = Left \"negative number\"\nsub n Zero = Right n\nsub (Succ a) (Succ b) = sub a b\n\nmul :: Peano -> Peano -> Peano\nmul Zero _ = Zero\nmul _ Zero = Zero\nmul (Succ Zero) b = b\nmul (Succ a) b = add b $ mul a b\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\ndiv a (Succ Zero) = Right a\ndiv a b = Right $ case sub a b of\n  Right s -> Succ $ unsafePartial $ fromRight $ div s b\n  Left _ -> Zero\n\neven :: Peano -> Boolean\neven Zero = true\neven (Succ a) = odd a\n\nodd :: Peano -> Boolean\nodd Zero = false\nodd (Succ a) = even a\n\nnewtype Natural = Natural Peano\n\n-- Do not tamper with this - there will be tests for this\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\n-- This is what you should implement for your final task\ninstance ordNatural :: Ord Natural where\n  compare (Natural a) (Natural b) = case sub a b of\n    Left _     -> LT\n    Right Zero -> EQ\n    _          -> GT\n  \n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232338,"user_id":168,"body":"module PureScript.Codewars.Peano where\n\n-- Welcome to this Kata :D\n-- In this Kata, we will explore Peano's axioms\n-- on the natural numbers which represent the\n-- natural numbers (N = {0, 1, 2, 3, ... }) in a\n-- way which makes it easy for mathematicians to\n-- reason about them and their properties, especially\n-- in proofs involving the natural numbers.\n\n-- The axioms are as follows:\n-- 1) Basis: Zero is a natural number\n-- 2) Inductive Case: For every natural number n,\n--    its successor `Succ n` is also a natural number\n-- 3) There are no other natural numbers (implied)\n-- In PureScript, this is represented by the following\n-- algebraic data type (ADT):\n--   data Peano = Zero | Succ Peano\n\n-- When working with Peano's axioms, it is often important\n-- to think inductively.  Here is an example for you to get\n-- started:\n\n-- A statement on the equality of the natural numbers:\n-- 1) Basis: Zero is equal to itself\n-- 2) Inductive Case: The successor of two natural numbers\n--    are equal iff (if and only if) the two natural numbers\n--    are themselves equal\n-- 3) No two other natural numbers are equal (implied)\n\n-- Here is a demonstration that this inductive definition of\n-- equality on the natural numbers fits our intuition:\n-- 1) Is 3 = 3?\n--      - 0 = 0\n--      - Since 0 = 0, 1 = 1\n--      - Since 1 = 1, 2 = 2\n--      - Since 2 = 2, 3 = 3\n--    Therefore, 3 = 3.\n-- 2) Is 2 = 3?\n--    Working backwards:\n--      - 2 = 3 iff 1 = 2\n--      - 1 = 2 iff 0 = 1\n--    But 0 is not equal to 1! Rules 1) and 2) do not apply\n--    to 0 = 1 and rule 3) states that anything not equal\n--    under rules 1) and 2) cannot be considered equal.\n--    Therefore, 2 = 3 is not true.\n\n-- Later, when you define various operations on the natural\n-- numbers, try to apply the same style of thinking in your\n-- definitions.\n\n-- Without further adieu, here is the full source of\n-- PureScript.Codewars.Peano.Preloaded should you choose\n-- to develop your solution locally:\n\n-- import Data.Show (class Show, show)\n-- import Data.Semigroup ((<>))\n-- import Data.Eq (class Eq, eq)\n\n-- data Peano = Zero | Succ Peano\n\n-- instance showPeano :: Show Peano where\n--   show Zero = \"Zero\"\n--   show (Succ n) = \"(Succ \" <> show n <> \")\"\n\n-- instance eqPeano :: Eq Peano where\n--   eq Zero Zero = true\n--   eq (Succ n) (Succ m) = eq n m\n--   eq _ _ = false\nimport PureScript.Codewars.Peano.Preloaded\n\n-- When you implement `sub` and `div`, you will also need\n-- the `Either a` monad (sometimes simply referred to as the\n-- Either monad) which is an algebraic data type used to\n-- represent computations that may result in an error\n\n-- It is defined as follows:\n--   data Either a b = Left a | Right b\n-- where values of type `a` wrapped in the `Left` data\n-- constructor are used to signal errors and values of\n-- type `b` wrapped in the `Right` data constructor are\n-- used to represent success values\n\n-- More information can be found at\n-- https:\/\/pursuit.purescript.org\/packages\/purescript-either\/4.1.1\/docs\/Data.Either\nimport Data.Either (Either(..))\n\n-- Required modules for the last exercise: `compare`\nimport Data.Eq (class Eq, eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord, compare)\n\nimport Control.Apply ((<*>))\n\n-- Now it's your time to define some simple operations on the natural numbers ;)\n\n-- Hint: Try to apply induction on the first operand of `add`\nadd :: Peano -> Peano -> Peano\nadd Zero n = n\nadd (Succ m) n = Succ (add m n)\n\n-- Hint: First consider the case where subtracting two natural numbers\n-- leads to a negative number - return `Left \"negative number\"` in this\n-- case\n-- Then apply induction on both operands of `sub` - but don't forget to\n-- wrap successful results in `Right` ;)\nsub :: Peano -> Peano -> Either String Peano\nsub Zero (Succ _) = Left \"negative number\"\nsub m Zero = Right m\nsub (Succ m) (Succ n) = sub m n\n\n-- You're on your own now - good luck ;)\nmul :: Peano -> Peano -> Peano\nmul Zero _ = Zero\nmul (Succ m) n = add (mul m n) n\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\ndiv m n = case (sub m n) of\n  Left _ -> Right Zero\n  Right d -> Right Succ <*> div d n\n\neven :: Peano -> Boolean\neven Zero = true\neven (Succ n) = odd n\n\nodd :: Peano -> Boolean\nodd Zero = false\nodd (Succ n) = even n\n\n-- The natural numbers are well-ordered, that is, it satisfies\n-- the following properties:\n-- 1) It has a least element (Zero)\n-- 2) It satisfies the axioms of total ordering as well, namely\n--    reflexivity, antisymmetry and transitivity\n-- In fact, this well-ordering property is what makes induction\n-- on the natural numbers valid in the first place!  It can be\n-- shown that the well-ordering property is equivalent to the\n-- axiom of induction; that is, one can be implied from the other\n-- and vice versa\n\n-- Note that since PureScript disallows orphan instances, defining\n-- an Ord instance for Peano directly (required for implementing\n-- `compare`) leads to a compilation error.  To resolve this issue,\n-- we must wrap Peano in a newtype Natural\n\nnewtype Natural = Natural Peano\n\n-- Do not tamper with this - there will be tests for this\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\n-- This is what you should implement for your final task\ninstance ordNatural :: Ord Natural where\n  compare (Natural Zero) (Natural Zero) = EQ\n  compare (Natural Zero) _ = LT\n  compare _ (Natural Zero) = GT\n  compare (Natural (Succ m)) (Natural (Succ n)) = compare (Natural m) (Natural n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232339,"user_id":233,"body":"module PureScript.Codewars.Peano where\n\nimport PureScript.Codewars.Peano.Preloaded\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq, eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord, compare)\nimport Data.Functor (map)\nimport Prelude (($))\n\nadd :: Peano -> Peano -> Peano\nadd x Zero     = x\nadd x (Succ y) = add (Succ x) y \n\nsub :: Peano -> Peano -> Either String Peano\nsub Zero (Succ _)     = Left \"negative number\"\nsub x Zero            = Right x\nsub (Succ x) (Succ y) = sub x y\n\nmul :: Peano -> Peano -> Peano\nmul x Zero     = Zero\nmul x (Succ y) = add x $ mul x y\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv x Zero = Left \"divide by 0\"\ndiv Zero y = Right Zero\ndiv x y    = case remain of\n  (Left      _) -> Right Zero\n  (Right right) -> map Succ $ div right y\n  where remain = sub x y\n  \neven :: Peano -> Boolean\neven Zero = true \neven (Succ p) = odd p\n\nodd :: Peano -> Boolean\nodd Zero     = false\nodd (Succ p) = even p\n\n\nnewtype Natural = Natural Peano\n\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\ninstance ordNatural :: Ord Natural where\n  compare (Natural Zero) (Natural Zero)       = EQ\n  compare (Natural Zero) (Natural (Succ _))   = LT\n  compare (Natural(Succ _)) (Natural Zero)    = GT\n  compare (Natural(Succ x)) (Natural(Succ y)) = compare (Natural x) (Natural y)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232340,"user_id":21,"body":"module PureScript.Codewars.Peano where\n\n-- Welcome to this Kata :D\n-- In this Kata, we will explore Peano's axioms\n-- on the natural numbers which represent the\n-- natural numbers (N = {0, 1, 2, 3, ... }) in a\n-- way which makes it easy for mathematicians to\n-- reason about them and their properties, especially\n-- in proofs involving the natural numbers.\n\n-- The axioms are as follows:\n-- 1) Basis: Zero is a natural number\n-- 2) Inductive Case: For every natural number n,\n--    its successor `Succ n` is also a natural number\n-- 3) There are no other natural numbers (implied)\n-- In PureScript, this is represented by the following\n-- algebraic data type (ADT):\n--   data Peano = Zero | Succ Peano\n\n-- When working with Peano's axioms, it is often important\n-- to think inductively.  Here is an example for you to get\n-- started:\n\n-- A statement on the equality of the natural numbers:\n-- 1) Basis: Zero is equal to itself\n-- 2) Inductive Case: The successor of two natural numbers\n--    are equal iff (if and only if) the two natural numbers\n--    are themselves equal\n-- 3) No two other natural numbers are equal (implied)\n\n-- Here is a demonstration that this inductive definition of\n-- equality on the natural numbers fits our intuition:\n-- 1) Is 3 = 3?\n--      - 0 = 0\n--      - Since 0 = 0, 1 = 1\n--      - Since 1 = 1, 2 = 2\n--      - Since 2 = 2, 3 = 3\n--    Therefore, 3 = 3.\n-- 2) Is 2 = 3?\n--    Working backwards:\n--      - 2 = 3 iff 1 = 2\n--      - 1 = 2 iff 0 = 1\n--    But 0 is not equal to 1! Rules 1) and 2) do not apply\n--    to 0 = 1 and rule 3) states that anything not equal\n--    under rules 1) and 2) cannot be considered equal.\n--    Therefore, 2 = 3 is not true.\n\n-- Later, when you define various operations on the natural\n-- numbers, try to apply the same style of thinking in your\n-- definitions.\n\n-- Without further adieu, here is the full source of\n-- PureScript.Codewars.Peano.Preloaded should you choose\n-- to develop your solution locally:\n\n-- import Data.Show (class Show, show)\n-- import Data.Semigroup ((<>))\n-- import Data.Eq (class Eq, eq)\n\n-- data Peano = Zero | Succ Peano\n\n-- instance showPeano :: Show Peano where\n--   show Zero = \"Zero\"\n--   show (Succ n) = \"(Succ \" <> show n <> \")\"\n\n-- instance eqPeano :: Eq Peano where\n--   eq Zero Zero = true\n--   eq (Succ n) (Succ m) = eq n m\n--   eq _ _ = false\nimport PureScript.Codewars.Peano.Preloaded\n\n-- When you implement `sub` and `div`, you will also need\n-- the `Either a` monad (sometimes simply referred to as the\n-- Either monad) which is an algebraic data type used to\n-- represent computations that may result in an error\n\n-- It is defined as follows:\n--   data Either a b = Left a | Right b\n-- where values of type `a` wrapped in the `Left` data\n-- constructor are used to signal errors and values of\n-- type `b` wrapped in the `Right` data constructor are\n-- used to represent success values\n\n-- More information can be found at\n-- https:\/\/pursuit.purescript.org\/packages\/purescript-either\/4.1.1\/docs\/Data.Either\nimport Data.Either (Either(..))\n\n-- Required modules for the last exercise: `compare`\nimport Data.Eq (class Eq, eq)\nimport Data.Ordering (Ordering(..))\nimport Data.Ord (class Ord, compare)\n\n-- Now it's your time to define some simple operations on the natural numbers ;)\n\n-- Hint: Try to apply induction on the first operand of `add`\nadd :: Peano -> Peano -> Peano\nadd Zero x = x\nadd x Zero = x\nadd (Succ x) (Succ y) = Succ (Succ (add x y))\n\n-- Hint: First consider the case where subtracting two natural numbers\n-- leads to a negative number - return `Left \"negative number\"` in this\n-- case\n-- Then apply induction on both operands of `sub` - but don't forget to\n-- wrap successful results in `Right` ;)\nsub :: Peano -> Peano -> Either String Peano\nsub x Zero = Right x\nsub Zero x = Left \"negative number\"\nsub (Succ x) (Succ y) = sub x y\n\n-- You're on your own now - good luck ;)\nmul :: Peano -> Peano -> Peano\nmul _ Zero = Zero\nmul Zero _ = Zero\nmul (Succ Zero) x = x\nmul x (Succ Zero) = x\nmul (Succ x) y = add y (mul x y)\n\nres :: Either String Peano -> Peano\nres (Left e) = Zero\nres (Right d) = d\n\ndiv :: Peano -> Peano -> Either String Peano\ndiv _ Zero = Left \"divide by 0\"\ndiv Zero _ = Right Zero\ndiv (Succ a) (Succ b) =\n  case sub a b of\n    Left _ -> Right Zero\n    Right diff ->\n      case diff `div` (Succ b) of\n        Left e -> Left e\n        Right ans -> Right (Succ ans)\n\neven :: Peano -> Boolean\neven Zero = true\neven (Succ x) = odd x\n\nodd :: Peano -> Boolean\nodd Zero = false\nodd (Succ x) = even x\n\n-- The natural numbers are well-ordered, that is, it satisfies\n-- the following properties:\n-- 1) It has a least element (Zero)\n-- 2) It satisfies the axioms of total ordering as well, namely\n--    reflexivity, antisymmetry and transitivity\n-- In fact, this well-ordering property is what makes induction\n-- on the natural numbers valid in the first place!  It can be\n-- shown that the well-ordering property is equivalent to the\n-- axiom of induction; that is, one can be implied from the other\n-- and vice versa\n\n-- Note that since PureScript disallows orphan instances, defining\n-- an Ord instance for Peano directly (required for implementing\n-- `compare`) leads to a compilation error.  To resolve this issue,\n-- we must wrap Peano in a newtype Natural\n\nnewtype Natural = Natural Peano\n\n-- Do not tamper with this - there will be tests for this\ninstance eqNatural :: Eq Natural where\n  eq (Natural n) (Natural m) = eq n m\n\n-- This is what you should implement for your final task\ninstance ordNatural :: Ord Natural where\n  compare (Natural Zero) (Natural Zero) = EQ\n  compare _ (Natural Zero) = GT\n  compare (Natural Zero) _ = LT\n  compare (Natural (Succ x)) (Natural (Succ y)) = compare (Natural x) (Natural y)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"57da675dfa96908b16000040":[{"id":232341,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\nimport Control.Apply (lift2)\nimport Data.Maybe (Maybe)\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe = lift2 (\\xs ys -> xs <> \" \" <> ys)\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232342,"user_id":233,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe (Just x) (Just y) = Just (x <> \" \" <> y)\nconcatMaybe _ _ = Nothing","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232343,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.Maybe (Maybe)\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe l r = (\\a b -> a <> \" \" <> b) <$> l <*> r","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232344,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.Maybe (Maybe)\n\nconcatWithSpace :: String -> String -> String\nconcatWithSpace a b = a <> \" \" <> b\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe a b = concatWithSpace <$> a <*> b","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232345,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.Maybe (Maybe)\nimport Control.Apply (lift2)\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe = lift2 (\\x y -> x <> \" \" <> y)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232346,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe ms1 ms2 = ado\n  s1 <- ms1\n  s2 <- ms2\n  in s1 <> \" \" <> s2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232347,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Maybe (Maybe)\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe = lift2 \\a b -> a <> \" \" <> b\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232348,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe a b = pure (\\x y z -> x <> y <> z) <*> (a) <*> pure \" \" <*> (b)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232349,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\n-- import Preloaded (undefined)\nimport Data.Maybe (Maybe(..))\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe (Just a) (Just b)  = Just $ a <> \" \" <> b\nconcatMaybe _ _ = Nothing\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232350,"user_id":null,"body":"module MaybeConcat (concatMaybe) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\n\nconcatMaybe :: Maybe String -> Maybe String -> Maybe String\nconcatMaybe a b = (\\x y -> x <> \" \" <> y) <$> a <*> b","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"57da7ca63150b02e6400026b":[{"id":232351,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\nimport Data.Foldable (sum)\nimport Data.List (List, catMaybes)\nimport Data.Maybe (Maybe(Just))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = Just <<< sum <<< catMaybes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232352,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.Foldable (sum)\nimport Data.Maybe (Maybe)\nimport Data.Traversable (sequence)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = map sum <<< sequence","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232353,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Prelude\nimport Data.List (List)\nimport Data.Maybe (Maybe)\nimport Data.Traversable (sequence, sum)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts xs = sum <$> sequence xs\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232354,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe)\nimport Data.Traversable (sequence)\nimport Data.Foldable (sum)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = sequence >>> (<$>) sum","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232355,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe(Just))\nimport Data.Foldable (foldl)\nimport Data.Traversable (sequence)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts =\n  sequence\n    >>= (\\(Just x) -> pure $ foldl add 0 x)\n    >>> pure","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232356,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Preloaded (undefined)\nimport Data.List.Types (List)\nimport Data.Traversable (sequence)\nimport Data.Maybe (Maybe)\nimport Data.Foldable (sum)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts  =  map sum <<< sequence\n-- sumJusts l =  l # sequence # map sum","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232357,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List(..))\nimport Data.List (foldl)\nimport Data.Maybe (Maybe(..))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = foldl (\\acc x -> (+) <$> acc <*> x) (Just 0)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232358,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude ((<<<))\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe(..))\nimport Data.Foldable (sum)\nimport Data.List (catMaybes)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = Just <<< sum <<< catMaybes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232359,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\nimport Data.Foldable (foldl)\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = foldl f (pure 0)\n  where\n    f :: Maybe Int -> Maybe Int -> Maybe Int\n    f acc item = ado\n      sum <- acc\n      x <- item\n      in sum + x\n      \n      ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232360,"user_id":null,"body":"module SumOfJusts (sumJusts) where\n\nimport Prelude\n\n-- import Preloaded (undefined)\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe(Just))\nimport Data.Foldable(foldl)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts x = \n  x \n  # foldl (\\acc (Just x) -> acc + x) 0\n  # Just","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"57da7f901b5ff148ad00030d":[{"id":232361,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe)\nimport Data.List (catMaybes)\nimport Data.Foldable (sum)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = pure <<< sum <<< catMaybes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232362,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe (Just))\nimport Data.Foldable (sum)\nimport Data.List (catMaybes)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = Just <<< sum <<< catMaybes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232363,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.Foldable (sum)\nimport Data.List (List, catMaybes)\nimport Data.Maybe (Maybe(..))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = Just <<< sum <<< catMaybes","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232364,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List (foldl)\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe(..))\n\nsum :: Maybe Int -> Maybe Int -> Maybe Int\nsum (Just a) (Just b) = Just (a + b)\nsum Nothing (Just b) = Just b\nsum (Just a) Nothing = Just a\nsum _ _ = Nothing\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts list = foldl sum (Just 0) list","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232365,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.Foldable (foldl)\nimport Data.Maybe (Maybe, fromMaybe)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = pure <<< foldl (\\p c -> p + fromMaybe 0 c) 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232366,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List (foldl)\nimport Data.List.Types (List(..))\nimport Data.Maybe (Maybe(..))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts Nil = Nothing\nsumJusts xs = Just $ foldl f 0 xs\n  where f a Nothing = a\n        f a (Just b) = a + b","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232367,"user_id":2576,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.Foldable (sum)\nimport Data.Maybe (Maybe(..))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = Just <<< sum <<< map getVal\n  where\n  getVal Nothing = 0\n  getVal (Just n) = n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232368,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.Foldable (foldl)\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe(..))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts = foldl f (pure 0)\n  where\n    f :: Maybe Int -> Maybe Int -> Maybe Int\n    f acc Nothing = acc\n    f acc item = ado\n      sum <- acc\n      x <- item\n      in sum + x","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232369,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List (List(..), (:))\nimport Data.List.Types (List)\nimport Data.Maybe (Maybe(..))\nimport Control.Apply (lift2)\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts ((Just x) : xs) = lift2 (+) (Just x) (sumJusts xs)\nsumJusts (_ : xs) = sumJusts xs\nsumJusts Nil = Just 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232370,"user_id":null,"body":"module SumOfJustsAndNothings (sumJusts) where\n\nimport Prelude\n\nimport Data.List.Types (List)\nimport Data.List (catMaybes)\nimport Data.Foldable (sum)\nimport Data.Maybe (Maybe(Just))\n\nsumJusts :: Partial => List (Maybe Int) -> Maybe Int\nsumJusts x = x # catMaybes # sum # Just ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"57eadb7ecd143f4c9c0000a3":[{"id":232371,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\n\nimport Data.String (Pattern(..), joinWith, split, take, toUpper)\n\nabbrev_name :: String -> String\nabbrev_name = joinWith \".\" <<< map (toUpper <<< take 1) <<< split (Pattern \" \")\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232372,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.String\n\nabbrev_name :: String -> String\nabbrev_name = joinWith \".\" <<< map takeFirst <<< split (Pattern \" \")\n  where\n    takeFirst :: String -> String\n    takeFirst = toUpper <<< take 1\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232373,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.String\n\nabbrev_name :: String -> String\nabbrev_name = split (Pattern \" \") >>> map (take 1) >>> map toUpper >>> joinWith \".\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232374,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude (map, (<<<))\nimport Data.String (Pattern(..), joinWith, split, take, toUpper)\n\nabbrev_name :: String -> String\nabbrev_name = toUpper <<< joinWith \".\" <<< map (take 1) <<< split (Pattern \" \")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232375,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.String\n\nabbrev_name :: String -> String\nabbrev_name = joinWith \".\" <<< map (toUpper <<< take 1) <<< split (Pattern \" \")","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232376,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.String\n\nabbrev_name :: String -> String\nabbrev_name = toUpper <<< joinWith \".\" <<< map (take 1) <<< split (Pattern \" \")\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232377,"user_id":53,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.Array ((!!))\nimport Data.String as S\nimport Data.String.Pattern (Pattern(..))\nimport Data.Maybe (fromMaybe)\n\nabbrev_name :: String -> String\nabbrev_name s = S.take 1 (fromMaybe \"\" (xs!!0)) <> \".\" <> S.take 1 (fromMaybe \"\" (xs!!1))\n  where xs = S.split (Pattern \" \") (S.toUpper s)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232378,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.Array.Partial (head)\nimport Data.String (Pattern(..), joinWith, split, toUpper)\nimport Data.String.CodeUnits (singleton, toCharArray)\nimport Effect (Effect)\nimport Effect.Class.Console (logShow)\nimport Partial.Unsafe (unsafePartial)\n\nabbrev_name :: String -> String\nabbrev_name =\n  split (Pattern \" \")\n    >>> (<$>) (toCharArray >>> unsafePartial head >>> singleton >>> toUpper)\n    >>> joinWith \".\"\n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232379,"user_id":null,"body":"module Kata.AbbrevName where\n\nimport Prelude\nimport Data.String (joinWith, split, take, toUpper)\nimport Data.String.Pattern (Pattern(..))\n\nabbrev_name :: String -> String\nabbrev_name = joinWith \".\" <<< (<$>) (toUpper <<< take 1) <<< split (Pattern \" \")\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232380,"user_id":2503,"body":"module Kata.AbbrevName where\n\nimport Prelude\n\nimport Data.List (intercalate)\nimport Data.String (split, Pattern(..), toUpper)\nimport Data.String.CodeUnits (fromCharArray)\nimport Data.String.Unsafe (charAt)\n\nwords :: String -> Array String\nwords = split (Pattern \" \")\n\nstrHead :: String -> String\nstrHead = fromCharArray <<< pure <<< charAt 0\n\nabbrev_name :: String -> String\nabbrev_name = intercalate \".\" <<< map (toUpper <<< strHead) <<< words\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"58334362c5637ad0bb0001c2":[{"id":232381,"user_id":null,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude\nimport Data.Array (filter)\nimport Data.String (length)\nimport Data.String.Regex (test)\nimport Data.String.Regex.Flags (noFlags)\nimport Data.String.Regex.Unsafe (unsafeRegex)\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter valid\n  where\n  re = unsafeRegex \"^(M{0,4})(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\" noFlags\n\n  valid s = test re s && length s \/= 0\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232382,"user_id":null,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude\nimport Data.Array (filter)\nimport Data.Either (fromRight)\nimport Data.String (trim)\nimport Data.String.Regex (Regex, regex, test)\nimport Data.String.Regex.Flags (noFlags)\nimport Partial.Unsafe (unsafePartial)\n\nisValid :: String -> Boolean\nisValid \"\" = false\nisValid s = test re s\n  where\n    re :: Regex\n    re = unsafePartial \n      $ fromRight \n      $ regex \n        \"\"\"^M{0,4}(D?C{0,3}|CD|CM)?(L?X{0,3}|XL|XC)?(V?I{0,3}|IV|IX)?$\"\"\"\n        noFlags\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter (isValid <<< trim)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232383,"user_id":null,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude\n\nimport Data.Foldable\nimport Data.String.Regex\nimport Data.String.Regex.Flags (noFlags)\nimport Data.Maybe\nimport Data.Either\nimport Data.Array\nimport Data.Array.NonEmpty as NE\n\nimport Partial.Unsafe (unsafePartial)\nimport Debug.Trace\n\nr :: Regex\nr = unsafePartial $ fromRight $ regex \"^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\" noFlags\n\nfilterNothings :: forall a. Array (Maybe a) -> Array a\nfilterNothings = foldl (\\acc it -> acc <> unpack it) []\n  where unpack (Just a) = [a]\n        unpack Nothing = []\n\nvalidRomans :: Array String -> Array String\nvalidRomans arr = filterNothings $ map (\\m ->\n  do\n    a <- m\n    b <- NE.head a\n    pure b)\n  foo\n  where foo = (map (match r) arr)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232384,"user_id":1617,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude\nimport Data.Array (filter)\nimport Data.Either (fromRight)\nimport Data.String.Regex (regex, test)\nimport Data.String.Regex.Flags (noFlags)\nimport Partial.Unsafe (unsafePartial)\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter (\\s -> s \/= \"\" && test (unsafePartial (fromRight (regex \"\"\"^(M{0,4})(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\"\"\" noFlags))) s)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232385,"user_id":null,"body":"module FilterValidRomans (validRomans) where\n\nimport Data.Array (filter)\nimport Data.Either (fromRight)\nimport Data.String.Regex (regex, test)\nimport Data.String.Regex.Flags (noFlags)\nimport Partial.Unsafe (unsafePartial)\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter (test re)\n  where\n    re = unsafePartial (fromRight (regex \"^(?!$)M{0,4}(?:CM|CD|D?C{0,3})(?:XC|XL|L?X{0,3})(?:IX|IV|V?I{0,3})$\" noFlags))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232386,"user_id":21,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude\nimport Data.String (length)\nimport Data.String.Regex (regex, test)\nimport Data.String.Regex.Flags (noFlags)\nimport Data.Array (filter)\nimport Data.Either (Either(..))\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter valid\n  where\n  r = regex \"^M{0,4}(CM|CD|D?C{0,3})?(XC)?(XL|L?X{0,3})?(IX|IV|V?I{0,3})?$\" noFlags\n  valid s =\n    case r of\n      Left error -> false\n      Right rx -> length s > 0 && test rx s","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232387,"user_id":null,"body":"module FilterValidRomans (validRomans) where\nimport Data.String.Regex.Unsafe (unsafeRegex)\nimport Data.String.Regex.Flags (noFlags)\nimport Data.String.Regex (test)\nimport Data.Array (filter)\nimport Prelude\nvalidRomans :: Array String -> Array String\nvalidRomans = filter $ \\s -> s\/=\"\" && test (unsafeRegex r noFlags) s where\n  r = \"^(M{0,4})(CM|D?C{0,3}|CD)(XC|L?X{0,3}|XL)(IX|V?I{0,3}|IV)$\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232388,"user_id":null,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude\nimport Data.Array (filter)\nimport Data.Either (Either(..))\nimport Data.String.Regex (regex, test)\nimport Data.String.Regex.Flags (noFlags)\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter (\\x -> case romansRegex of\n                              Right r -> test r x\n                              Left _ -> false)\n  where romansRegex = regex \"^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\" noFlags","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232389,"user_id":null,"body":"module FilterValidRomans (validRomans) where\n\nimport Data.Array (filter)\nimport Data.String.Regex (test)\nimport Data.String.Regex.Flags (noFlags)\nimport Data.String.Regex.Unsafe (unsafeRegex)\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter (test valid)\n  where\n    valid = unsafeRegex \"^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\" noFlags","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232390,"user_id":527,"body":"module FilterValidRomans (validRomans) where\n\nimport Prelude ((>>>))\nimport Data.Array (filter)\nimport Data.Maybe (isJust)\nimport Data.String.Regex (Regex, match)\nimport Data.String.Regex.Flags (noFlags)\nimport Data.String.Regex.Unsafe (unsafeRegex)\n\nvalidRomans :: Array String -> Array String\nvalidRomans = filter (match re >>> isJust)\n\nre :: Regex\nre = unsafeRegex \"^(?!$)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\" noFlags","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5886e082a836a691340000c3":[{"id":232391,"user_id":53,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\nimport Data.Int (floor, toNumber)\nimport Math (sqrt)\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b =\n  let x = floor ((toNumber a) \/ (sqrt 2.0)) in\n  let y = floor ((toNumber b) \/ (sqrt 2.0)) in\n  let r = (x + 1) * (y + 1) + x * y in\n  r + (mod r 2) - 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232392,"user_id":168,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\nimport Math (sqrt)\nimport Data.Int (floor, toNumber)\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b = 2 * x * y + x + y + (x + y + 1) `mod` 2\n  where\n    x = floor (toNumber a \/ sqrt 2.0)\n    y = floor (toNumber b \/ sqrt 2.0)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232393,"user_id":21,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\n\nimport Data.Int (floor, toNumber)\nimport Math (sqrt)\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b =\n  let\n    -- main idea: the intersections form two rectangles with integer-length\n    -- sides inside the rotated rectangle.\n    -- one is on the points where x+y is odd, the other where x+y is even.\n    \n    -- aCount and bCount are the number of intersections for the respective dimension\n    -- for half, not counting the middle.\n    aCount = floor (toNumber a \/ (sqrt 2.0))\n    bCount = floor (toNumber b \/ (sqrt 2.0))\n    \n    -- the OddDims are the side lengths of the points on the x+y=odd intersections.\n    -- this is integer division!\n    aOddDim = (aCount + 1) \/ 2 * 2\n    bOddDim = (bCount + 1) \/ 2 * 2\n    \n    -- the EvenDims are the side lengths of the x+y=even intersections.\n    aEvenDim = aCount \/ 2 * 2 + 1\n    bEvenDim = bCount \/ 2 * 2 + 1\n  in\n    -- the answer is the sum of the two rectangles' areas.\n    aOddDim * bOddDim + aEvenDim * bEvenDim\n      ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232394,"user_id":null,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\nimport Data.Int (Parity(..), floor, parity, toNumber)\n\nsolve :: Parity -> Parity -> Int -> Int -> Int\nsolve Even Even m n = (n + 1) + m * (2 * n + 1)\nsolve Even Odd m n = n + m * (2 * n + 1)\nsolve Odd Even m n = (n + 1) + 2 * ((m \/ 2 + 1) * n + (m \/ 2) * (n + 1))\nsolve Odd Odd m n = n + 2 * ((m \/ 2) * n + (m \/ 2 + 1) * (n + 1))\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b = solve (parity a') (parity b') a' b'\n  where\n    translate :: Int -> Int\n    translate = floor <<< (_ \/ 1.41421356237) <<< toNumber\n    a' = translate a\n    b' = translate b\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232395,"user_id":null,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\n\nimport Data.Int (floor, odd, toNumber)\nimport Math (sqrt2)\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b\n  | a < b     = rectangle_rotation b a\n  | otherwise = case odd a', odd b' of\n                  true , true  -> a' * b' + (a' + 1) * (b' + 1)\n                  true , false -> a' * (b' + 1) + (a' + 1) * b'\n                  false, true  -> (a' + 1) * b' + a' * (b' + 1)\n                  false, false -> a' * b' + (a' + 1) * (b' + 1)\n  where\n    a' = floor (toNumber a \/ sqrt2)\n    b' = floor (toNumber b \/ sqrt2)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232396,"user_id":null,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\n\nimport Data.Int (floor, odd, toNumber)\nimport Math (sqrt1_2)\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b\n  | a < b     = rectangle_rotation b a\n  | otherwise = case odd a', odd b' of\n                  true , true  -> a' * b' + (a' + 1) * (b' + 1)\n                  true , false -> a' * (b' + 1) + (a' + 1) * b'\n                  false, true  -> (a' + 1) * b' + a' * (b' + 1)\n                  false, false -> a' * b' + (a' + 1) * (b' + 1)\n  where\n    a' = floor (toNumber a \/ 2.0 \/ sqrt1_2)\n    b' = floor (toNumber b \/ 2.0 \/ sqrt1_2)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232397,"user_id":645,"body":"module Kata (rectangle_rotation) where\n\nimport Prelude\nimport Data.Int (floor, toNumber)\nimport Data.Int.Bits ((.^.))\nimport Math (sqrt)\n\nrectangle_rotation :: Int -> Int -> Int\nrectangle_rotation a b = h * v + (h + 1) * (v + 1) - (mod h 2 .^. mod v 2)\n  where h = floor $ toNumber a \/ sqrt 2.0\n        v = floor $ toNumber b \/ sqrt 2.0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5922543bf9c15705d0000020":[{"id":232398,"user_id":null,"body":"module Isomorphism where\n\n-- The type `Void` has no members so it is impossible to construct\n-- a value of type `Void` without resorting to unsafe features or\n-- non-terminating computations, etc.\n\nimport Data.Void\n\n-- There exists a function\n--   absurd :: forall a. Void -> a\n-- (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n-- That could get any type of value out of `Void`, if only it were possible\n-- to construct a value of type `Void` in the first place\n\n-- So, when are two types `a` and `b` considered equivalent?\n-- A definition might be, it is possible to go from `a` to `b`,\n-- and from `b` to `a`.\n-- Going a roundway trip should always leave you with the same value\n-- no matter what value you start with or which type you start from.\n-- Unfortunately it is virtually impossible to test this in PureScript.\n-- This is called Isomorphism.\n\n-- The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n-- and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n-- understood as \"having the same shape\".\n\nimport Data.Unit (Unit, unit)\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..))\nimport Data.Either (Either(..))\nimport Data.Bifunctor (bimap)\nimport Data.Profunctor (dimap)\nimport Data.HeytingAlgebra (not)\nimport Data.Functor (map)\n\nimport Control.Category (identity)\nimport Control.Semigroupoid ((>>>))\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst -- This is given; you do not need to change it :)\n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple a2b b2a) (Tuple b2c c2b) = Tuple (a2b >>> b2c) (c2b >>> b2a) \n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple a2b b2a) (Tuple c2d d2c) = Tuple (bimap a2b c2d) (bimap b2a d2c)\n\n-- And derive new isomorphisms from known ones ... \n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple a2b b2a) = Tuple (map a2b) (map b2a)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple a2b b2a) = Tuple (map a2b) (map b2a)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple a2b b2a) (Tuple c2d d2c) = Tuple (bimap a2b c2d) (bimap b2a d2c)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple a2b b2a) (Tuple c2d d2c) = Tuple (dimap b2a c2d) (dimap a2b d2c)\n\n-- Going another way is hard (and is generally impossible)\n-- Remember, for all valid isomorphisms, converting to and fro\n-- should always give you the original value.\n-- You need this to prove that some cases are impossible.\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple ma2mb mb2ma) = Tuple (Just >>> (go ma2mb)) (Just >>> (go mb2ma))\n  where\n    go :: forall a b. (Maybe a -> Maybe b) -> Maybe a -> b\n    go f x = case f x of\n      Just y -> y\n      Nothing -> go f Nothing\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple\n  (case _ of\n    Left l -> Left (unit:l)\n    Right _ -> Left Nil\n  )\n  (case _ of\n    Left Nil -> Right unit\n    Left (x:xs) -> Left xs\n    Right v -> absurd v\n  )\n\n-- where `Unit` has exactly 1 member and `Void` has no members.\n-- The existence of isoUnEither would imply the existence of\n-- ISO Unit Void which would mean we could construct a value of\n-- type Void from a value of type Unit (which is obviously impossible)\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232399,"user_id":15,"body":"module Isomorphism where\n\nimport Prelude\nimport Data.Tuple (Tuple(..),fst,snd,swap)\nimport Data.List (List(..),(:),tail)\nimport Data.Maybe (Maybe(..),fromMaybe',fromJust)\nimport Data.Either (Either(..),either)\nimport Data.Bifunctor (bimap)\nimport Partial.Unsafe (unsafePartial)\nimport Data.Foldable (null)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ba ab) (Tuple cb bc) = Tuple (cb <<< ba) (ab <<< bc)\n\nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ba ab) (Tuple dc cd) = Tuple (bimap ba dc) (bimap ab cd)\n\nisoFunctor :: forall a b f. Functor f => ISO a b -> ISO (f a) (f b)\nisoFunctor = bimap map map\n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList = isoFunctor\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe = isoFunctor\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ba ab) (Tuple dc cd) = Tuple (either (Left <<< ba) (Right <<< dc)) (either (Left <<< ab) (Right <<< cd))\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ba ab) (Tuple dc cd) = Tuple ( \\ ca -> dc <<< ca <<< ab ) ( \\ db -> cd <<< db <<< ba )\n\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mbma mamb) = Tuple\n  ( \\ a -> fromMaybe' ( \\ _ -> unsafePartial $ fromJust $ mbma Nothing ) (mbma $ Just a) )\n  ( \\ b -> fromMaybe' ( \\ _ -> unsafePartial $ fromJust $ mamb Nothing ) (mamb $ Just b) )\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple lUnits_rUnit lUnits_rVoid where\n  lUnits_rUnit :: Either (List Unit) Unit -> Either (List Unit) Void\n  lUnits_rUnit (Left units) = Left $ unit : units\n  lUnits_rUnit (Right _) = Left Nil\n  lUnits_rVoid :: Either (List Unit) Void -> Either (List Unit) Unit\n  lUnits_rVoid (Left units) | null units = Right unit\n                            | otherwise  = Left $ unsafePartial $ fromJust $ tail units\n  lUnits_rVoid (Right void) = Right $ absurd void\n\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232400,"user_id":2576,"body":"module Isomorphism where\n\n-- The type `Void` has no members so it is impossible to construct\n-- a value of type `Void` without resorting to unsafe features or\n-- non-terminating computations, etc.\n\n-- There exists a function\n--   absurd :: forall a. Void -> a\n-- (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n-- That could get any type of value out of `Void`, if only it were possible\n-- to construct a value of type `Void` in the first place\n\nimport Prelude (Unit, Void, absurd, identity, map, not, unit, ($), (<<<), (>>>))\n\nimport Data.Bifunctor (bimap)\nimport Data.Either (Either(..))\nimport Data.List (List, (:))\nimport Data.List as List\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Partial.Unsafe (unsafePartial)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst -- This is given; you do not need to change it :)\n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm iso = Tuple (substR iso) (substL iso)\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans iso_ab iso_bc = Tuple (substL iso_ab >>> substL iso_bc) (substR iso_ab <<< substR iso_bc)\n\n-- We can combine isomorphisms using the Cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple iso_ab iso_cd = Tuple (\\(Tuple a c) -> Tuple (substL iso_ab a) (substL iso_cd c)) (\\(Tuple b d) -> Tuple (substR iso_ab b) (substR iso_cd d))\n\n-- And derive new isomorphisms from known ones ... \n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList iso_ab = Tuple (map (substL iso_ab)) (map (substR iso_ab))\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe iso_ab = Tuple (map (substL iso_ab)) (map (substR iso_ab))\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither iso_ab iso_cd = Tuple (bimap (substL iso_ab) (substL iso_cd)) (bimap (substR iso_ab) (substR iso_cd))\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc iso_ab iso_cd = Tuple (\\a_c -> substR iso_ab >>> a_c >>> substL iso_cd) (\\b_d -> substL iso_ab >>> b_d >>> substR iso_cd)\n\n-- Going another way is hard (and is generally impossible)\n-- Remember, for all valid isomorphisms, converting to and fro\n-- should always give you the original value.\n-- You need this to prove that some cases are impossible.\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe iso_ma_mb = Tuple left right\n    where\n    left a =\n        case substL iso_ma_mb (Just a) of\n            Nothing ->  unsafePartial $ fromJust (substL iso_ma_mb Nothing)\n            Just b -> b\n    right b =\n        case substR iso_ma_mb (Just b) of\n            Nothing -> unsafePartial $ fromJust (substR iso_ma_mb Nothing)\n            Just a -> a\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple left right\n    where\n    left (Left units) = Left (unit : units)\n    left (Right unit) = Left (List.fromFoldable [])\n    right (Left list) =\n        case List.uncons list of\n            Just { head: _, tail: units } -> Left units\n            Nothing -> Right unit\n    right (Right a) = absurd a\n\n-- where `Unit` has exactly 1 member and `Void` has no members.\n-- The existence of isoUnEither would imply the existence of\n-- ISO Unit Void which would mean we could construct a value of\n-- type Void from a value of type Unit (which is obviously impossible)\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple symm symm","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232401,"user_id":null,"body":"module Isomorphism where\n\nimport Data.Void\nimport Prelude (not, ($), (<<<), map, pure)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.List (List(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Either (Either(..))\nimport Data.Unit (Unit(..), unit)\n\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = refl\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\nrefl :: forall a. ISO a a\nrefl = Tuple (\\x -> x) (\\x -> x)\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm (Tuple a b) = Tuple b a\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple \n  (\\x -> Tuple (ab $ fst x) (cd $ snd x))\n  (\\x -> Tuple (ba $ fst x) (dc $ snd x))\n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map  ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple \n  (\\x -> case x of\n    Left a -> Left $ ab a\n    Right c -> Right $ cd c)\n  (\\x -> case x of\n    Left b -> Left $ ba b\n    Right d -> Right $ dc d)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple\n  (\\ac -> cd <<< ac <<< ba)\n  (\\bd -> dc <<< bd <<< ab)\n\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mamb mbma) = Tuple\n  (\\a -> case mamb $ Just a of\n    Just b -> b\n    Nothing -> case mamb $ Nothing of \n      Just b2 -> b2\n      Nothing ->(fst $ isoUnMaybe $ Tuple (mamb <<< mbma <<< mamb) (mbma <<< mamb <<< mbma)) a )\n  (\\b -> case mbma $ Just b of\n    Just a -> a\n    Nothing -> case mbma $ Nothing of\n      Just a2 -> a2\n      Nothing -> (fst $ isoUnMaybe $ Tuple (mbma <<< mamb <<< mbma)(mamb <<< mbma <<< mamb)) b)\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple\n  (\\x -> case x of \n    Left lu -> Left $ Cons unit lu\n    Right u -> Left Nil)\n  (\\x -> case x of \n    Left Nil -> Right unit\n    Left (Cons unit lu) -> Left lu\n    Right v -> absurd v)\n\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple\n  (\\isoab -> Tuple (snd isoab) (fst isoab))\n  (\\isoba -> Tuple (snd isoba) (fst isoba))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232402,"user_id":null,"body":"module Isomorphism where\n\nimport Prelude\n\nimport Data.Tuple\nimport Data.List\nimport Data.Maybe\nimport Data.Either\nimport Data.Bifunctor\nimport Unsafe.Coerce\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\nrefl :: forall a . ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b . ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c . ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\nisoTuple :: forall a b c d . ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) =\n    Tuple (\\(Tuple a c) -> Tuple (ab a) (cd c))\n          (\\(Tuple b d) -> Tuple (ba b) (dc d))\n\nisoList :: forall a b . ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b . ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoEither :: forall a b c d . ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) =  Tuple (bimap ab cd) (bimap ba dc)\n\nisoFunc :: forall a b c d . ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple (\\ac -> cd <<< ac <<< ba) (\\bd -> dc <<< bd <<< ab)\n\nisoUnMaybe :: forall a b . ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mab mba) =\n    Tuple (fromMaybe' (\\_ -> fromMaybe' unsafeCoerce (mab Nothing)) <<< mab <<< Just)\n          (fromMaybe' (\\_ -> fromMaybe' unsafeCoerce (mba Nothing)) <<< mba <<< Just)\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple (either (Left <<< (:) unit) (\\_ -> Left Nil)) (either f absurd) where\n    f Nil = Right unit\n    f (_:xs) = Left xs\n\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232403,"user_id":21,"body":"module Isomorphism where\n\nimport Prelude\n\n-- The type `Void` has no members so it is impossible to construct\n-- a value of type `Void` without resorting to unsafe features or\n-- non-terminating computations, etc.\n\n-- There exists a function\n--   absurd :: forall a. Void -> a\n-- (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n-- That could get any type of value out of `Void`, if only it were possible\n-- to construct a value of type `Void` in the first place\n\n-- So, when are two types `a` and `b` considered equivalent?\n-- A definition might be, it is possible to go from `a` to `b`,\n-- and from `b` to `a`.\n-- Going a roundway trip should always leave you with the same value\n-- no matter what value you start with or which type you start from.\n-- Unfortunately it is virtually impossible to test this in PureScript.\n-- This is called Isomorphism.\n\n-- The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n-- and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n-- understood as \"having the same shape\".\n\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.Either (Either(..))\nimport Partial.Unsafe (unsafePartial)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst -- This is given; you do not need to change it :)\n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nid :: forall a. a -> a\nid x = x\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple id id\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n\nrefl :: forall a. ISO a a\nrefl = Tuple id id\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm (Tuple a b) = Tuple b a\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple a b) (Tuple c d) = Tuple (a >>> c) (d >>> b)\n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple tactbd tbdtac\n  where\n    tactbd (Tuple a c) = Tuple (ab a) (cd c)\n    tbdtac (Tuple b d) = Tuple (ba b) (dc d)\n\n-- And derive new isomorphisms from known ones ... \n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple mamb mbma\n  where\n    mamb :: Maybe a -> Maybe b\n    mamb (Just a) = Just (ab a)\n    mamb Nothing = Nothing\n    \n    mbma :: Maybe b -> Maybe a\n    mbma (Just b) = Just (ba b)\n    mbma Nothing = Nothing\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple eacebd ebdeac\n  where\n    eacebd :: Either a c -> Either b d\n    eacebd (Left a) = Left (ab a)\n    eacebd (Right c) = Right (cd c)\n    ebdeac :: Either b d -> Either a c\n    ebdeac (Left b) = Left (ba b)\n    ebdeac (Right d) = Right (dc d)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple acbd bdac\n  where\n    acbd :: (a -> c) -> (b -> d)\n    acbd ac = ba >>> ac >>> cd\n    bdac :: (b -> d) -> (a -> c)\n    bdac bd = ab >>> bd >>> dc\n\n-- Going another way is hard (and is generally impossible)\n-- Remember, for all valid isomorphisms, converting to and fro\n-- should always give you the original value.\n-- You need this to prove that some cases are impossible.\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mamb mbma) = Tuple ab ba\n  where\n    ab :: a -> b\n    ab a = case mamb (Just a) of\n      Just b -> b\n      Nothing -> unsafePartial $ fromJust $ mamb Nothing\n    ba :: b -> a\n    ba b = case mbma (Just b) of\n      Just a -> a\n      Nothing -> unsafePartial $ fromJust $ mbma Nothing\n\n-- isoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple eluueluv eluveluu\n  where\n    eluueluv :: Either (List Unit) Unit -> Either (List Unit) Void\n    eluueluv (Left a) = Left (unit : a)\n    eluueluv (Right u) = Left Nil\n    \n    eluveluu :: Either (List Unit) Void -> Either (List Unit) Unit\n    eluveluu (Left (unit : a)) = Left a\n    eluveluu (Left Nil) = Right unit\n    eluveluu (Right x) = absurd x\n-- where `Unit` has exactly 1 member and `Void` has no members.\n-- The existence of isoUnEither would imply the existence of\n-- ISO Unit Void which would mean we could construct a value of\n-- type Void from a value of type Unit (which is obviously impossible)\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple symm symm","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232404,"user_id":null,"body":"module Isomorphism where\n\n{-- The type `Void` has no members so it is impossible to construct\n a value of type `Void` without resorting to unsafe features or\n non-terminating computations, etc.\n\n There exists a function\n   absurd :: forall a. Void -> a\n (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n That could get any type of value out of `Void`, if only it were possible\n to construct a value of type `Void` in the first place\n\n So, when are two types `a` and `b` considered equivalent?\n A definition might be, it is possible to go from `a` to `b`,\n and from `b` to `a`.\n Going a roundway trip should always leave you with the same value\n no matter what value you start with or which type you start from.\n Unfortunately it is virtually impossible to test this in PureScript.\n This is called Isomorphism.\n\n The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n understood as \"having the same shape\".\n--}\n\nimport Effect.Exception.Unsafe (unsafeThrow)\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Data.List (List(..), (:))\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Bifunctor (bimap)\nimport Prelude\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst \n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n{-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n--}\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple (bimap ab cd) (bimap ba dc)\n\n-- And derive new isomorphisms from known ones ... \nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple mab mba where\n  mab ma = ab <$> ma\n  mba mb = ba <$> mb\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple (bimap ab cd) (bimap ba dc) \n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple acbd bdac where\n  acbd ac = cd <<< ac <<< ba\n  bdac bd = dc <<< bd <<< ab\n\n{-- Going another way is hard (and is generally impossible).\n Remember, for all valid isomorphisms, converting to and from\n should always give you the original value.\n You need this to prove that some cases are impossible.\n--} \nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mab mba) = Tuple ab ba where\n  ab a = case mab (Just a) of \n           Just b -> b\n           Nothing -> case mab Nothing of\n                        Nothing -> unsafeThrow \"impossible\"\n                        Just b -> b\n  ba b = case mba (Just b) of\n           Just a -> a\n           Nothing -> case mba Nothing of\n                        Nothing -> unsafeThrow \"impossible\"\n                        Just a -> a\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple lulv lvlu where\n  lulv (Right unit) = Left Nil\n  lulv (Left list) = Left (unit:list)\n  lvlu (Left (unit:list)) = Left list\n  lvlu (Right void) = Right unit\n  lvlu (Left Nil) = Right unit\n\n{-- where `Unit` has exactly 1 member and `Void` has no members.\n The existence of isoUnEither would imply the existence of\n ISO Unit Void which would mean we could construct a value of\n type Void from a value of type Unit (which is obviously impossible) --}\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232405,"user_id":null,"body":"module Isomorphism where\n\n{-- The type `Void` has no members so it is impossible to construct\n a value of type `Void` without resorting to unsafe features or\n non-terminating computations, etc.\n\n There exists a function\n   absurd :: forall a. Void -> a\n (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n That could get any type of value out of `Void`, if only it were possible\n to construct a value of type `Void` in the first place\n\n So, when are two types `a` and `b` considered equivalent?\n A definition might be, it is possible to go from `a` to `b`,\n and from `b` to `a`.\n Going a roundway trip should always leave you with the same value\n no matter what value you start with or which type you start from.\n Unfortunately it is virtually impossible to test this in PureScript.\n This is called Isomorphism.\n\n The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n understood as \"having the same shape\".\n--}\n\nimport Effect.Exception.Unsafe (unsafeThrow)\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Data.List (List(..), (:))\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Prelude\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst \n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n{-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n--}\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple acbd dbca where\n  acbd (Tuple a c) = Tuple (ab a) (cd c)\n  dbca (Tuple b d) = Tuple (ba b) (dc d)\n\n-- And derive new isomorphisms from known ones ... \nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple mab mba where\n  mab ma = ab <$> ma\n  mba mb = ba <$> mb\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple acbd dbca where\n  acbd (Left a) = Left (ab a)\n  acbd (Right c) = Right (cd c)\n  dbca (Right d) = Right (dc d)\n  dbca (Left b) = Left (ba b)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple acbd bdac where\n  acbd ac = cd <<< ac <<< ba\n  bdac bd = dc <<< bd <<< ab\n\n{-- Going another way is hard (and is generally impossible).\n Remember, for all valid isomorphisms, converting to and from\n should always give you the original value.\n You need this to prove that some cases are impossible.\n--} \nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mab mba) = Tuple ab ba where\n  ab a = case mab (Just a) of \n           Just b -> b\n           Nothing -> case mab Nothing of\n                        Nothing -> unsafeThrow \"impossible\"\n                        Just b -> b\n  ba b = case mba (Just b) of\n           Just a -> a\n           Nothing -> case mba Nothing of\n                        Nothing -> unsafeThrow \"impossible\"\n                        Just a -> a\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple lulv lvlu where\n  lulv (Right unit) = Left Nil\n  lulv (Left list) = Left (unit:list)\n  lvlu (Left (unit:list)) = Left list\n  lvlu (Right void) = Right unit\n  lvlu (Left Nil) = Right unit\n\n{-- where `Unit` has exactly 1 member and `Void` has no members.\n The existence of isoUnEither would imply the existence of\n ISO Unit Void which would mean we could construct a value of\n type Void from a value of type Unit (which is obviously impossible) --}\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232406,"user_id":null,"body":"module Isomorphism where\n\n{-- The type `Void` has no members so it is impossible to construct\n a value of type `Void` without resorting to unsafe features or\n non-terminating computations, etc.\n\n There exists a function\n   absurd :: forall a. Void -> a\n (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n That could get any type of value out of `Void`, if only it were possible\n to construct a value of type `Void` in the first place\n\n So, when are two types `a` and `b` considered equivalent?\n A definition might be, it is possible to go from `a` to `b`,\n and from `b` to `a`.\n Going a roundway trip should always leave you with the same value\n no matter what value you start with or which type you start from.\n Unfortunately it is virtually impossible to test this in PureScript.\n This is called Isomorphism.\n\n The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n understood as \"having the same shape\".\n--}\n\nimport Effect.Exception.Unsafe (unsafeThrow)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.List (List(..), (:))\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\nimport Prelude\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst \n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n{-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n--}\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm (Tuple ab ba) = Tuple ba ab\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple acbd dbca where\n  acbd (Tuple a c) = Tuple (ab a) (cd c)\n  dbca (Tuple b d) = Tuple (ba b) (dc d)\n\n-- And derive new isomorphisms from known ones ... \nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple mab mba where\n  mab a = ab <$> a\n  mba b = ba <$> b\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple acbd dbca where\n  acbd (Left a) = Left (ab a)\n  acbd (Right c) = Right (cd c)\n  dbca (Right d) = Right (dc d)\n  dbca (Left b) = Left (ba b)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple acbd bdac where\n  acbd ac = cd <<< ac <<< ba\n  bdac bd = dc <<< bd <<< ab\n\n{-- Going another way is hard (and is generally impossible).\n Remember, for all valid isomorphisms, converting to and from\n should always give you the original value.\n You need this to prove that some cases are impossible.\n--} \nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mab mba) = Tuple ab ba where\n  ab a = case mab (Just a) of \n           Just b -> b\n           Nothing -> case mab Nothing of\n                        Nothing -> unsafeThrow \"impossible\"\n                        Just b -> b\n  ba b = case mba (Just b) of\n           Just a -> a\n           Nothing -> case mba Nothing of\n                        Nothing -> unsafeThrow \"impossible\"\n                        Just a -> a\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple lulv lvlu where\n  lulv (Right unit) = Left Nil\n  lulv (Left list) = Left (unit:list)\n  lvlu (Left (unit:list)) = Left list\n  lvlu (Right void) = Right unit\n  lvlu (Left Nil) = Right unit\n\n{-- where `Unit` has exactly 1 member and `Void` has no members.\n The existence of isoUnEither would imply the existence of\n ISO Unit Void which would mean we could construct a value of\n type Void from a value of type Unit (which is obviously impossible) --}\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple abba baab where\n  abba (Tuple ab ba) = Tuple ba ab\n  baab (Tuple ba ab) = Tuple ab ba","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232407,"user_id":168,"body":"module Isomorphism where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..), fromMaybe')\nimport Data.Either (Either(..), either)\nimport Data.Bifunctor (bimap)\nimport Unsafe.Coerce (unsafeCoerce)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) =\n  Tuple (\\(Tuple a c) -> Tuple (ab a) (cd c)) (\\(Tuple b d) -> Tuple (ba b) (dc d))\n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) =  Tuple (bimap ab cd) (bimap ba dc)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple (\\ac -> cd <<< ac <<< ba) (\\bd -> dc <<< bd <<< ab)\n\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mab mba) = Tuple (fromMaybe' (\\_ -> fromMaybe' unsafeCoerce (mab Nothing)) <<< mab <<< Just)\n                                   (fromMaybe' (\\_ -> fromMaybe' unsafeCoerce (mba Nothing)) <<< mba <<< Just)\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple (either (Left <<< (:) unit) (\\_ -> Left Nil)) (either f absurd)\n  where f Nil = Right unit\n        f (_ : xs) = Left xs\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232408,"user_id":17,"body":"module Isomorphism where\n\n-- The type `Void` has no members so it is impossible to construct\n-- a value of type `Void` without resorting to unsafe features or\n-- non-terminating computations, etc.\n\n-- There exists a function\n--   absurd :: forall a. Void -> a\n-- (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n-- That could get any type of value out of `Void`, if only it were possible\n-- to construct a value of type `Void` in the first place\n\nimport Data.Void\n\n-- So, when are two types `a` and `b` considered equivalent?\n-- A definition might be, it is possible to go from `a` to `b`,\n-- and from `b` to `a`.\n-- Going a roundway trip should always leave you with the same value\n-- no matter what value you start with or which type you start from.\n-- Unfortunately it is virtually impossible to test this in PureScript.\n-- This is called Isomorphism.\n\n-- The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n-- and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n-- understood as \"having the same shape\".\n\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..), fromJust, isNothing)\nimport Data.Either (Either(..))\nimport Data.Unit (Unit, unit)\nimport Control.Category (identity)\nimport Data.HeytingAlgebra (not)\nimport Control.Semigroupoid ((<<<))\nimport Data.Functor (map)\nimport Partial.Unsafe (unsafePartial)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst -- This is given; you do not need to change it :)\n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = refl\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) =\n  Tuple (\\(Tuple a c) -> Tuple (ab a) (cd c)) (\\(Tuple b d) -> Tuple (ba b) (dc d))\n\n-- And derive new isomorphisms from known ones ... \n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple\n  (\\x -> case x of\n    Left a -> Left (ab a)\n    Right c -> Right (cd c))\n  (\\x -> case x of\n    Left b -> Left (ba b)\n    Right d -> Right (dc d))\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) =\n  Tuple (\\ac -> cd <<< ac <<< ba) (\\bd -> dc <<< bd <<< ab)\n\n-- Going another way is hard (and is generally impossible)\n-- Remember, for all valid isomorphisms, converting to and fro\n-- should always give you the original value.\n-- You need this to prove that some cases are impossible.\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mamb mbma) = Tuple\n  (\\a -> let\n    x = mamb (Just a) in\n      if isNothing x\n        then unsafePartial fromJust (mamb Nothing)\n        else unsafePartial fromJust x)\n  (\\b -> let\n    x = mbma (Just b) in\n      if isNothing x\n        then unsafePartial fromJust (mbma Nothing)\n        else unsafePartial fromJust x)\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple\n  (\\x -> case x of\n    Left xs -> Left (unit : xs)\n    Right unit -> Left Nil)\n  (\\x -> case x of\n    Left Nil -> Right unit\n    Left (y : ys) -> Left ys\n    Right y -> absurd y)\n-- where `Unit` has exactly 1 member and `Void` has no members.\n-- The existence of isoUnEither would imply the existence of\n-- ISO Unit Void which would mean we could construct a value of\n-- type Void from a value of type Unit (which is obviously impossible)\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5933a1f8552bc2750a0000ed":[{"id":232409,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven = (_ - 1) >>> (_ * 2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232410,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven n = 2 * (n - 1)\n-- (2 * _) <<< (_ `sub` 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232411,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven = (*) 2 >>> (_ - 2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232412,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven n = (*) 2 (n - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232413,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven n = 2 * n - 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232414,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven i = (i - 1) * 2\n\n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232415,"user_id":null,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven n = 2 * (n - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232416,"user_id":527,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven n = (n - 1) * 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232417,"user_id":645,"body":"module NthEven (nthEven) where\n\nimport Prelude\n\nnthEven :: Int -> Int\nnthEven n = n * 2 - 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5a03b3f6a1c9040084001765":[{"id":232418,"user_id":527,"body":"module Kata (angle) where\n\nimport Prelude\n\nangle :: Int -> Int\nangle = (*) 180 <<< (_ - 2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232419,"user_id":645,"body":"module Kata (angle) where\n\nimport Prelude\n\nangle :: Int -> Int\nangle = (*) 180 <<< flip (-) 2","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232420,"user_id":null,"body":"module Kata (angle) where\n\nimport Prelude\n\nangle :: Int -> Int\nangle n = if n == 2 then 0 else 180 + angle (n - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232421,"user_id":76,"body":"module Kata (angle) where\n\nimport Prelude\n\nangle :: Int -> Int\nangle n = (n - 2) * 180","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232422,"user_id":527,"body":"module Kata (angle) where\n\nimport Prelude\n\nangle :: Int -> Int\nangle n = 180 * (n - 2)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5a3fe3dde1ce0e8ed6000097":[{"id":232423,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year y = (y - 1) \/ 100 + 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232424,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year y =\n    if y <= 100\n        then 1\n        else 1 + century_from_year (y - 100)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232425,"user_id":1566,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year year = -(-year\/100) ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232426,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year n = n \/ 100 + if n `mod` 100 == 0 then 0 else 1","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232427,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year year =\n    if year <= 100\n        then 1\n        else 1 + century_from_year (year - 100)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232428,"user_id":492,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year year = div (year + 99) 100","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232429,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year year = (year + 99) `div` 100 ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232430,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year x = 1 + (x - 1) `div` 100","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232431,"user_id":53,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year y = (y + 99) \/ 100","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232432,"user_id":null,"body":"module CenturyYear where\n\nimport Prelude\n\ncentury_from_year :: Int -> Int\ncentury_from_year x = \n  (x \/ 100 ) \n  # ( \\y -> if x `mod` 100 > 0 then y + 1 else y )","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5aba780a6a176b029800041c":[{"id":232433,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d 0 = 0\nmaxMultiple d b =\n    if mod b d == 0\n        then b\n        else maxMultiple d (b - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232434,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b = if (b `mod` d) == 0 then b else maxMultiple d (b - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232435,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple divisor bound = bound - bound `mod` divisor","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232436,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b \n  | b `mod` d == 0 = b\n  | otherwise = maxMultiple d (b - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232437,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\nimport Math ((%))\nimport Data.Maybe (maybe)\nimport Data.Int (toNumber)\nimport Data.Array(find, range)\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b = maybe 1 identity $ find (\\x -> toNumber x % toNumber d == toNumber 0) $ range b 1\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232438,"user_id":53,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b = b - mod b d","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232439,"user_id":2576,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b = \n  (b `div` d) * d\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232440,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b | mod b d == 0 = b\n                | otherwise = maxMultiple d (b - 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232441,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\nimport Data.Array as A\nimport Data.Maybe as M\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b   \n  = A.range 1 b\n  # A.filter (\\x -> x `mod` d == 0)\n  # A.last\n  # M.fromMaybe 1\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232442,"user_id":null,"body":"module Kata (maxMultiple) where\n\nimport Prelude\n\nmaxMultiple :: Int -> Int -> Int\nmaxMultiple d b | (b `mod` d) == 0 = b\nmaxMultiple d b = maxMultiple d (b - 1)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5ae62fcf252e66d44d00008e":[{"id":232443,"user_id":527,"body":"module Kata (expression_matter) where\n\nimport Prelude\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = (a + b + c) `max` (a * (b + c)) `max` ((a + b) * c) `max` (a * b * c)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232444,"user_id":2576,"body":"module Kata (expression_matter) where\n\nimport Prelude\n\nimport Data.Foldable (maximum)\nimport Data.Maybe (fromMaybe)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = fromMaybe 0 $ maximum $ do\n    op1 <- [(+), (*)]\n    op2 <- [(+), (*)]\n    [(a `op1` b) `op2` c, a `op1` (b `op2` c)]\n    ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232445,"user_id":645,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.Foldable (maximum)\nimport Data.Maybe (fromMaybe)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = fromMaybe 0 $ maximum [\n  a * (b + c),\n  a * b * c,\n  a + b * c,\n  a + b + c,\n  (a + b) * c,\n  (a * b) + c\n]","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232446,"user_id":null,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.Foldable (maximum)\nimport Data.Maybe (fromMaybe)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = fromMaybe 0 $ maximum [a + b * c, (a + b) * c, a * b + c, a * (b + c), a * b * c, a + b + c]","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232447,"user_id":168,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.List (foldl)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = foldl max 0 [a + b + c, a * b * c, (a + b) * c, a * (b + c)]","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232448,"user_id":null,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.Foldable (foldl)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = \n  [ a * ( b + c) \n  , a * b * c\n  , a + b * c\n  , a + b + c\n  , (a + b) * c\n  ]\n  # foldl (max) 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232449,"user_id":null,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.Foldable(foldr)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = foldr max 0 (permutations a b c) \n\npermutations :: Int -> Int -> Int -> Array Int\npermutations a b c = do\n  order <- [1, 2]\n  op1 <- [1, 2]\n  op2 <- [1, 2]\n  pure $ if order == 1\n           then compute op2 (compute op1 a b) c\n           else compute op1 a (compute op2 b c)\n  \ncompute :: Int -> Int -> Int -> Int\ncompute 1 x y = x + y\ncompute 2 x y = x * y\ncompute _ _ _ = 0\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232450,"user_id":53,"body":"module Kata (expression_matter) where\n\nimport Prelude\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = (a + b + c) `max` (a * b * c) `max` (a * (b + c)) `max` ((a + b) * c)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232451,"user_id":null,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.Foldable (foldl)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = foldl max 0 results\n  where\n    results :: Array Int\n    results = \n      [ a + b + c\n      , a * b * c\n      , a + b * c\n      , (a + b) * c\n      , a * b + c\n      , a * (b + c)\n      ]","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232452,"user_id":null,"body":"module Kata (expression_matter) where\n\nimport Prelude\nimport Data.Foldable (maximum)\nimport Data.Maybe (fromMaybe)\n\nexpression_matter :: Int -> Int -> Int -> Int\nexpression_matter a b c = fromMaybe 0 <<< maximum $ options\n  where\n    options :: Array Int\n    options = [a + b + c, a * b * c, (a + b) * c, a * (b + c)]","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5b077ebdaf15be5c7f000077":[{"id":232453,"user_id":17,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\n\ncount_sheep :: Int -> String\ncount_sheep 0 = \"\"\ncount_sheep n = count_sheep (n - 1) <> show n <> \" sheep...\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232454,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\n\nimport Preloaded (undefined)\n\ncount_sheep :: Int -> String\ncount_sheep 0 = \"\"\ncount_sheep x = count_sheep (x-1) <> show x <> \" sheep...\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232455,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\nimport Data.Foldable\nimport Data.Array\n\nimport Preloaded (undefined)\n\ncount_sheep :: Int -> String\ncount_sheep 0 = \"\"\ncount_sheep num = foldr (<>) \"\" (map appendSheep $ range 1 num) \n  where\n    appendSheep :: Int -> String\n    appendSheep s = show s <> \" sheep...\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232456,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\n\ncount_sheep :: Int -> String\ncount_sheep n = lame \"\" 1\n  where\n  lame s x = if x <= n then lame (s <> show x <> \" sheep...\") (x + 1) else s","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232457,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\n\nimport Preloaded (undefined)\n\ncount_sheep :: Int -> String\ncount_sheep x\n  | x == 0    = \"\"\n  | x == 1    = \"1 sheep...\"\n  | otherwise = count_sheep(x-1) <> show x <> \" sheep...\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232458,"user_id":53,"body":"module CountSheep (count_sheep) where\n\nimport Data.Int (toStringAs, decimal)\nimport Data.Semigroup ((<>))\nimport Data.Foldable (foldr)\nimport Data.List ((..))\n\ncount_sheep :: Int -> String\ncount_sheep 0 = \"\"\ncount_sheep n = foldr (\\y x -> \n  x \n    <> (toStringAs decimal y)\n    <> \" sheep...\") \n  \"\" \n  (n .. 1)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232459,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\nimport Data.Array ((..))\nimport Data.Foldable (foldMap)\n\ncount_sheep :: Int -> String\ncount_sheep 0 = \"\"\ncount_sheep n = foldMap (\\i -> show i <> \" sheep...\" ) (1 .. n)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232460,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\nimport Data.Enum (enumFromTo)\nimport Data.Int (decimal, toStringAs)\nimport Data.String (joinWith)\n\ncount_sheep :: Int -> String\ncount_sheep n = if n < 1 then \"\" else (joinWith \"\" <<< map sheepify <<< enumFromTo 1) n\n  where\n    sheepify = flip (<>) \" sheep...\" <<< toStringAs decimal","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232461,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\n\nimport Data.Array (range)\nimport Data.String (joinWith)\n\ncount_sheep :: Int -> String\ncount_sheep 0 = \"\"\ncount_sheep n = (range 1 >>> map (\\a -> show a <> \" sheep...\") >>> joinWith \"\") n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232462,"user_id":null,"body":"module CountSheep (count_sheep) where\n\nimport Prelude\nimport Data.Array\nimport Data.String\n\ncount_sheep 0 = \"\"\ncount_sheep n =\n  let\n    count_sheep' = joinWith \"\"  <<< map ((_ <> \" sheep...\") <<< show) <<< range 1\n  in\n    count_sheep' n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5ba38ba180824a86850000f7":[{"id":232463,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.List (List, reverse, nub)\n\nsolve :: List Int -> List Int\nsolve = reverse >>> nub >>> reverse","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232464,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.List (List(..), nub, reverse)\n\nsolve :: List Int -> List Int\nsolve = reverse >>> nub >>> reverse","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232465,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.List (List, (:))\nimport Data.Foldable (foldr, elem)\n\nsolve :: List Int -> List Int\nsolve = foldr (\n acc -> if n `elem` acc then acc else n : acc) mempty","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232466,"user_id":21,"body":"module RemoveDups (solve) where\n\nimport Prelude\n\nimport Control.Monad.State (State, evalState, get, put)\nimport Data.List (List, reverse, filterM)\nimport Data.Set (Set, empty, member, insert)\n\nsolve :: List Int -> List Int\nsolve xs = reverse $ evalState (filterM noDups (reverse xs)) empty\n  where\n        noDups :: Int -> State (Set Int) Boolean\n        noDups x = do\n           s <- get\n           let m = member x s\n           put $ insert x s\n           pure $ not m","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232467,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Data.List (List(..), (:))\nimport Data.Foldable (elem)\n\nsolve :: List Int -> List Int\nsolve Nil = Nil\nsolve (x : xs) = if (elem x rest) then rest else x : rest\n  where\n    rest = solve xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232468,"user_id":53,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.List (List, reverse, nub)\n\nsolve :: List Int -> List Int\nsolve xs = reverse (nub (reverse xs))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232469,"user_id":2576,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.List (List(..), reverse)\nimport Data.Set as Set\n\nsolve :: List Int -> List Int\nsolve = reverse <<< go Set.empty <<< reverse\n  where\n  go _ Nil = Nil\n  go seen (Cons x rest)\n    | Set.member x seen = go seen rest\n    | otherwise = Cons x (go (Set.insert x seen) rest)\n  \n\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232470,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.Foldable (foldr)\nimport Data.List (List(..), (:), elem)\n\nsolve :: List Int -> List Int\nsolve = foldr f Nil\n  where\n    f :: Int -> List Int -> List Int\n    f x xs = if elem x xs then xs else x : xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232471,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Prelude\n\nimport Data.Foldable (foldr)\nimport Data.List (List(..))\nimport Data.Set (insert, member)\nimport Data.Tuple (fst)\nimport Data.Tuple.Nested ((\/\\))\n\nsolve :: List Int -> List Int\nsolve = fst <<< foldr trav (Nil \/\\ mempty)\n  where\n    trav x (xs \/\\ dups) =\n      if member x dups\n        then xs \/\\ dups\n        else Cons x xs \/\\ insert x dups\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232472,"user_id":null,"body":"module RemoveDups (solve) where\n\nimport Prelude\nimport Data.List (List(..), any, reverse, (:))\n\nsolve :: List Int -> List Int\nsolve =\n  (go Nil) <<< reverse\n  where\n    go acc Nil = acc\n    go acc (x : xs) = if any (eq x) acc then go acc xs else go (x : acc) xs","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5c374b346a5d0f77af500a5a":[{"id":232473,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\nimport Data.Ord (abs)\n\nelevator :: Int -> Int -> Int -> String\nelevator l r c = if abs (c - l) < abs (c - r) then \"left\" else \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232474,"user_id":277,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\n\nabs :: Int -> Int\nabs n = if n>=0 then n else -n\n\nelevator :: Int -> Int -> Int -> String\nelevator left right call = if abs (call-left) < abs (call-right) then \"left\" else \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232475,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\nimport Data.Ord (abs)\n\nelevator :: Int -> Int -> Int -> String\nelevator l r c | abs (c - l) < abs (c - r) = \"left\" \n               | otherwise = \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232476,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\nimport Data.Ord (abs)\n\nelevator :: Int -> Int -> Int -> String\nelevator l r f = if l' < r' then \"left\" else \"right\"\n  where \n    l' = abs $ f - l\n    r' = abs $ f - r","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232477,"user_id":793,"body":"module ClosestElevator (elevator) where\nimport Prelude\nimport Data.Ord\n\nelevator :: Int -> Int -> Int -> String\nelevator x y z = if abs (z - x) < abs (z - y) then \"left\" else \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232478,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\nimport Data.Int (toNumber)\nimport Math (abs)\n\nelevator :: Int -> Int -> Int -> String\nelevator l r c = let abs' = abs <<< toNumber in if abs' (l - c) < abs' (r - c) then \"left\" else \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232479,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\nimport Data.Ord\n\nelevator :: Int -> Int -> Int -> String\nelevator l r c = do\n  case abs(c - l) `compare` abs(c - r) of\n    LT -> \"left\"\n    GT -> \"right\"\n    EQ -> \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232480,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\nimport Data.Ord (abs)\n\ndist :: Int -> Int -> Int\ndist a b = abs (a - b)\n\nelevator :: Int -> Int -> Int -> String\nelevator l r f = if dist l f < dist r f then \"left\" else \"right\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232481,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Math (abs)\nimport Prelude ((-), (>=))\nimport Data.Int (toNumber)\n\nelevator :: Int -> Int -> Int -> String\nelevator _l _r _c =\n    if absL >= absR\n    then \"right\"\n    else \"left\"\n    where\n        l = toNumber _l\n        r = toNumber _r\n        c = toNumber _c\n        absL = abs (l - c)\n        absR = abs (r - c)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232482,"user_id":null,"body":"module ClosestElevator (elevator) where\n\nimport Prelude\n\nimport Data.Ord (abs)\n\nelevator :: Int -> Int -> Int -> String\nelevator left right call\n  | abs (left - call) < abs (right - call) = \"left\"\n  | otherwise = \"right\"\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5d50e3914861a500121e1958":[{"id":232483,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Foldable (sum)\nimport Data.Maybe (fromMaybe)\n\nadd_letters :: Array Char -> Char\nadd_letters [] = 'z'\nadd_letters letters = toChar <<< sum <<< map toPos $ letters\n  where\n    toPos c = toCharCode c - 96\n    toChar n = fromMaybe 'z' (fromCharCode (97 + mod (n - 1) 26))","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232484,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Array (foldr)\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Maybe (fromMaybe)\n\nadd_letters :: Array Char -> Char\nadd_letters letters = fromMaybe 'a' $ fromCharCode (foldr f 122 letters)\n  where\n  f a b = let b' = (toCharCode a) - 96 + b in if b' > 122 then b' - 26 else b'\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232485,"user_id":168,"body":"module Kata where\n\nimport Prelude\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.Array (foldl)\nimport Data.Maybe (maybe)\n\nadd_letters :: Array Char -> Char\nadd_letters letters = maybe 'a' (\\x -> x) $ fromCharCode (s `mod` 26 + 97)\n  where s = foldl (\\r x -> r + toCharCode x - 96) 25 letters","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232486,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Foldable (foldl)\nimport Data.Maybe (fromMaybe)\n\ncharToInt :: Char -> Int\ncharToInt 'z' = 0\ncharToInt c = toCharCode c - 96\n\nintToChar :: Int -> Char\nintToChar 0 = 'z'\nintToChar n = fromMaybe 'z' $ fromCharCode (n + 96)\n\nadd_letters :: Array Char -> Char\nadd_letters = intToChar\n  <<< (\n -> mod n 26)\n  <<< foldl (\\sum c -> sum + (charToInt c)) 0","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232487,"user_id":null,"body":"module Kata where\n\nimport Prelude\n-- import Data.Array\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.String.CodeUnits (singleton, toChar)\nimport Data.Foldable (sum)\nimport Data.Maybe (fromMaybe)\n\nadd_letters :: Array Char -> Char\nadd_letters [] = 'z'\nadd_letters xs = \n  xs\n--   # map toUpper >>> toCharCode >>> (_ - 64) \n  # map getInt\n  # sum \n  # (_ `mod` 26)\n  # (\\x -> if x == 0 then x + 26 else x )\n  # (_ + 96)\n--   # (_ + 64\u202c)\n  # fromCharCode\n  # fromMaybe 'a'\n  \n  \n  where\n    getInt = \n      singleton \n      >>> toChar \n      >>> fromMaybe 'a' \n      >>> toCharCode \n      >>> (_ - 96)\n  ","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232488,"user_id":null,"body":"module Kata where\n\nimport Prelude\nimport Data.Foldable (sum, any)\nimport Data.Char (toCharCode, fromCharCode)\nimport Data.Maybe (fromMaybe)\nimport Data.Array (null)\nimport Debug.Trace (trace)\n\ntoInt :: Char -> Int\ntoInt c = toCharCode c - toCharCode 'a' + 1\n\nfromInt :: Int -> Char\nfromInt i = if i > toInt 'z' then fc offset else fc i\n  where\n    fc = fromMaybe '!' <<< fromCharCode <<< (\\x -> (x - 1) + (toCharCode 'a'))\n    offset = if m == 0 then 26 else m\n    m = i `mod` 26\n\nadd_letters :: Array Char -> Char\nadd_letters ls = trace (show ls <> show (add_letters' ls)) \\_ -> add_letters' ls\n\nadd_letters' ls | (null ls) = 'z'\n--add_letters ls | any (\\c -> toInt 'a' > toInt c || toInt c > toInt 'z') ls = 'z'\nadd_letters' ls = fromInt $ sum $ map toInt ls","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232489,"user_id":null,"body":"module Kata where\n\nimport Prelude\n\nimport Data.Char (fromCharCode, toCharCode)\nimport Data.Foldable (foldl)\nimport Data.Maybe (fromMaybe)\n\nadd_letters :: Array Char -> Char\nadd_letters = foldl addChar 'z'\n\naddChar :: Char -> Char -> Char\naddChar a b = \n  let zCode = toCharCode 'a' - 1\n      chCode = mod (toCharCode a + toCharCode b - 2 * zCode) 26\n      chCode' = if chCode == 0 then chCode + 26 else chCode\n  in fromMaybe '?' $ fromCharCode (chCode' + zCode)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232490,"user_id":645,"body":"module Kata where\n\nimport Prelude (map, mod, ($), (+), (-))\nimport Data.Char (toCharCode)\nimport Data.Array\nimport Data.Maybe (fromMaybe)\nimport Data.String.CodeUnits (charAt)\n\nadd_letters :: Array Char -> Char\nadd_letters letters = fromMaybe 'z' $ charAt (foldl (+) 0 (map (\\x -> toCharCode x - 96) letters) `mod` 26) \"zabcdefghijklmnopqrstuvwxy\"","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}],"5917f22dd2563a36a200009c":[{"id":232491,"user_id":168,"body":"module AlgebraicIsomorphism where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..), fst, snd, swap, uncurry, curry)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.List (List(..), (:))\nimport Data.Either (Either(..), either)\nimport Data.Bifunctor (bimap)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) =\n  Tuple (\\(Tuple a c) -> Tuple (ab a) (cd c)) (\\(Tuple b d) -> Tuple (ba b) (dc d))\n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) =  Tuple (bimap ab cd) (bimap ba dc)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple (\\ac -> cd <<< ac <<< ba) (\\bd -> dc <<< bd <<< ab)\n\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple swap swap\n\n-- a = b -> c = d -> a * c = b * d\nisoProd :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoProd = isoTuple\n\n-- a = b -> c = d -> a + c = b + d\nisoPlus :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoPlus = isoEither\n\n-- a = b -> S a = S b\nisoS :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoS = isoMaybe\n\n-- a = b -> c = d -> c ^ a = d ^ b\nisoPow :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoPow = isoFunc\n\n-- a + b = b + a\nplusComm :: forall a b. ISO (Either a b) (Either b a)\nplusComm = Tuple (either Right Left) (either Right Left)\n\n-- (a + b) + c = a + (b + c)\nplusAssoc :: forall a b c. ISO (Either (Either a b) c) (Either a (Either b c))\nplusAssoc = Tuple (either (either Left (Right <<< Left)) (Right <<< Right))\n                  (either (Left <<< Left) (either (Left <<< Right) Right))\n\n-- a * b = b * a\nmultComm :: forall a b. ISO (Tuple a b) (Tuple b a)\nmultComm = Tuple swap swap\n\n-- (a * b) * c = a * (b * c)\nmultAssoc :: forall a b c. ISO (Tuple (Tuple a b) c) (Tuple a (Tuple b c))\nmultAssoc = Tuple (\\(Tuple (Tuple a b) c) -> Tuple a (Tuple b c)) (\\(Tuple a (Tuple b c)) -> Tuple (Tuple a b) c)\n\n-- a * (b + c) = a * b + a * c\ndist :: forall a b c. ISO (Tuple a (Either b c)) (Either (Tuple a b) (Tuple a c))\ndist = Tuple (\\(Tuple a bc) -> either (Left <<< Tuple a) (Right <<< Tuple a) bc)\n             (either (\\(Tuple a b) -> Tuple a (Left b)) (\\(Tuple a c) -> Tuple a (Right c)))\n\n-- (c ^ b) ^ a = c ^ (a * b)\ncurryISO :: forall a b c. ISO (a -> b -> c) (Tuple a b -> c)\ncurryISO = Tuple uncurry curry\n\n-- 1 = S O (we are using Peano arithmetic)\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\none :: ISO Unit (Maybe Void)\none = Tuple (const Nothing) (const unit)\n\n-- 2 = S (S O)\ntwo :: ISO Boolean (Maybe (Maybe Void))\ntwo = Tuple fw bw\n  where\n    fw true = Just Nothing\n    fw false = Nothing\n    bw (Just _) = true\n    bw Nothing = false\n\n-- O + b = b\nplusO :: forall b. ISO (Either Void b) b\nplusO = Tuple left Right\n  where\n    left (Left x) = absurd x -- absurd :: forall a. Void -> a\n    left (Right x) = x\n\n-- S a + b = S (a + b)\nplusS :: forall a b. ISO (Either (Maybe a) b) (Maybe (Either a b))\nplusS = Tuple (either (maybe Nothing (Just <<< Left)) (Just <<< Right))\n              (maybe (Left Nothing) (either (Left <<< Just) Right))\n\n-- 1 + b = S b\nplusSO :: forall b. ISO (Either Unit b) (Maybe b)\nplusSO = isoPlus one refl `trans` plusS `trans` isoS plusO\n\n-- O * a = O\nmultO :: forall a. ISO (Tuple Void a) Void\nmultO = Tuple (absurd <<< fst) absurd\n\n-- S a * b = b + a * b\nmultS :: forall a b. ISO (Tuple (Maybe a) b) (Either b (Tuple a b))\nmultS = Tuple (\\(Tuple a' b) -> maybe (Left b) (Right <<< flip Tuple b) a')\n              (either (Tuple Nothing) (\\(Tuple a b) -> Tuple (Just a) b))\n\n-- 1 * b = b\nmultSO :: forall b. ISO (Tuple Unit b) b\nmultSO =\n  isoProd one refl `trans`\n    multS `trans`\n    isoPlus refl multO `trans` \n    plusComm `trans`\n    plusO\n\n-- a ^ O = 1\npowO :: forall a. ISO (Void -> a) Unit\npowO = Tuple (const unit) (const absurd)\n\n-- a ^ (S b) = a * (a ^ b)\npowS :: forall a b. ISO (Maybe b -> a) (Tuple a (b -> a))\npowS = Tuple (\\f -> Tuple (f Nothing) (f <<< Just)) (uncurry maybe)\n\n-- a ^ 1 = a\n-- Go the hard way (like multSO, plusSO)\n-- to prove that you really get what is going on!\npowSO :: forall a. ISO (Unit -> a) a\npowSO = \n  isoPow one refl `trans`\n  powS `trans`\n  isoProd refl powO `trans`\n  multComm `trans`\n  multSO\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232492,"user_id":15,"body":"module AlgebraicIsomorphism where\n\nimport Prelude\nimport Data.Tuple (Tuple(..),fst,snd,curry,uncurry,swap)\nimport Data.Either (Either(..),either)\nimport Data.Maybe (Maybe(..),maybe,isJust)\nimport Data.Bifunctor (bimap,lmap)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm = swap\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ba ab) (Tuple cb bc) = Tuple (cb <<< ba) (ab <<< bc)\n\nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ba ab) (Tuple dc cd) = Tuple (bimap ba dc) (bimap ab cd)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ba ab) (Tuple dc cd) = Tuple (either (Left <<< ba) (Right <<< dc)) (either (Left <<< ab) (Right <<< cd))\n\nisoFunctor :: forall a b f. Functor f => ISO a b -> ISO (f a) (f b)\nisoFunctor = bimap map map\nisoList = isoFunctor\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ba ab) (Tuple dc cd) = Tuple ( \\ ca -> dc <<< ca <<< ab ) ( \\ db -> cd <<< db <<< ba )\n\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple symm symm\n\n-- a = b -> c = d -> a * c = b * d\n-- Sometimes, we can treat a type as a number - if a type `t`\n-- has `n` distinct values then we say that its number is `n`.\n-- This is formally called cardinality.\n-- See https:\/\/en.wikipedia.org\/wiki\/Cardinality\n\n-- Void has a cardinality of 0 (we will abbreviate it as \"Void is 0\").\n-- Unit is 1.\n-- Boolean is 2.\n-- Maybe a is 1 + a.\n-- We will be using Peano arithmetic so we will write it as S a.\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\n-- Either a b is a + b.\n-- Tuple a b is a * b.\n-- a -> b is b ^ a. Try counting Unit -> Boolean and Boolean -> Unit\n\n-- Algebraic data type got its name because\n-- it satisfies a lot of algebraic rules under isomorphism\n\nisoProd :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoProd = isoTuple\n\n-- a = b -> c = d -> a + c = b + d\nisoPlus :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoPlus = isoEither\n\n-- a = b -> S a = S b\nisoS :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoS = isoFunctor\n\n-- a = b -> c = d -> c ^ a = d ^ b\nisoPow :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoPow = isoFunc\n\n-- a + b = b + a\nplusComm :: forall a b. ISO (Either a b) (Either b a)\nplusComm = Tuple (either Right Left) (either Right Left)\n\n-- (a + b) + c = a + (b + c)\nplusAssoc :: forall a b c. ISO (Either (Either a b) c) (Either a (Either b c))\nplusAssoc = Tuple (either (either Left (Right <<< Left)) (Right <<< Right))\n                  (either (Left <<< Left) (either (Left <<< Right) Right))\n\n-- a * b = b * a\nmultComm :: forall a b. ISO (Tuple a b) (Tuple b a)\nmultComm = Tuple swap swap\n\n-- (a * b) * c = a * (b * c)\nmultAssoc :: forall a b c. ISO (Tuple (Tuple a b) c) (Tuple a (Tuple b c))\nmultAssoc = Tuple ( \\ (Tuple (Tuple a b) c) -> Tuple a (Tuple b c) )\n                  ( \\ (Tuple a (Tuple b c)) -> Tuple (Tuple a b) c )\n\n-- a * (b + c) = a * b + a * c\ndist :: forall a b c. ISO (Tuple a (Either b c)) (Either (Tuple a b) (Tuple a c))\ndist = Tuple f (either (map Left) (map Right)) where\n  f (Tuple a (Left b)) = Left $ Tuple a b\n  f (Tuple a (Right c)) = Right $ Tuple a c\n\n-- (c ^ b) ^ a = c ^ (a * b)\ncurryISO :: forall a b c. ISO (a -> b -> c) (Tuple a b -> c)\ncurryISO = Tuple uncurry curry\n\n-- 1 = S O (we are using Peano arithmetic)\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\none :: ISO Unit (Maybe Void)\none = Tuple (const Nothing) (const unit)\n\n-- 2 = S (S O)\ntwo :: ISO Boolean (Maybe (Maybe Void))\ntwo = Tuple ( \\ bool -> if bool then Just Nothing else Nothing ) isJust\n  \n-- O + b = b\nplusO :: forall b. ISO (Either Void b) b\nplusO = Tuple (either absurd identity) Right\n\n-- S a + b = S (a + b)\nplusS :: forall a b. ISO (Either (Maybe a) b) (Maybe (Either a b))\nplusS = Tuple (either (map Left) (Just <<< Right)) (maybe (Left Nothing) (either (Left <<< Just) Right))\n\n-- 1 + b = S b\nplusSO :: forall b. ISO (Either Unit b) (Maybe b)\nplusSO = isoPlus one refl `trans` plusS `trans` isoS plusO\n\n-- O * a = O\nmultO :: forall a. ISO (Tuple Void a) Void\nmultO = Tuple fst absurd\n\n-- S a * b = b + a * b\nmultS :: forall a b. ISO (Tuple (Maybe a) b) (Either b (Tuple a b))\nmultS = Tuple f g where\n  f (Tuple Nothing b) = Left b\n  f (Tuple (Just a) b) = Right $ Tuple a b\n  g = either (Tuple Nothing) (lmap Just)\n\n-- 1 * b = b\nmultSO :: forall b. ISO (Tuple Unit b) b\nmultSO =\n  isoProd one refl `trans`\n    multS `trans`\n    isoPlus refl multO `trans` \n    plusComm `trans`\n    plusO\n\n-- a ^ O = 1\npowO :: forall a. ISO (Void -> a) Unit\npowO = Tuple (const unit) (const absurd)\n\n-- a ^ (S b) = a * (a ^ b)\npowS :: forall a b. ISO (Maybe b -> a) (Tuple a (b -> a))\npowS = Tuple f g where\n  f amb = Tuple (amb Nothing) ( \\ b -> amb $ Just b )\n  g (Tuple a ab) = maybe a ab\n\n-- a ^ 1 = a\n-- Go the hard way (like multSO, plusSO)\n-- to prove that you really get what is going on!\npowSO :: forall a. ISO (Unit -> a) a\n-- powSO = ?powSO -- ?hole1 `trans` powS `trans` ?hole2\npowSO = Tuple (_ $ unit) const\n\n-- 0 ^ 0 = 0\n-- proof :: ISO (Void -> Void) Void\n-- proof = Tuple (const _) (const identity) -- `Tuple (const _) const` would also be possible\n   -- there is no value to fill in for `_` either way\n\n-- 0 ^ 0 = 1\nproof :: ISO (Void -> Void) Unit\nproof = Tuple (const unit) (const identity)","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232493,"user_id":2576,"body":"module AlgebraicIsomorphism where\n\nimport Prelude\n\nimport Data.Bifunctor (bimap)\nimport Data.Either (Either(..))\nimport Data.List (List, (:))\nimport Data.List as List\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Partial.Unsafe (unsafePartial)\n\n-- Please copy your solution to Isomorphism here.\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst -- This is given; you do not need to change it :)\n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple identity identity\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n\nrefl :: forall a. ISO a a\nrefl = Tuple identity identity\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm iso = Tuple (substR iso) (substL iso)\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans iso_ab iso_bc = Tuple (substL iso_ab >>> substL iso_bc) (substR iso_ab <<< substR iso_bc)\n\n-- We can combine isomorphisms using the Cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple iso_ab iso_cd = Tuple (\\(Tuple a c) -> Tuple (substL iso_ab a) (substL iso_cd c)) (\\(Tuple b d) -> Tuple (substR iso_ab b) (substR iso_cd d))\n\n-- And derive new isomorphisms from known ones ... \n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList iso_ab = Tuple (map (substL iso_ab)) (map (substR iso_ab))\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe iso_ab = Tuple (map (substL iso_ab)) (map (substR iso_ab))\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither iso_ab iso_cd = Tuple (bimap (substL iso_ab) (substL iso_cd)) (bimap (substR iso_ab) (substR iso_cd))\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc iso_ab iso_cd = Tuple (\\a_c -> substR iso_ab >>> a_c >>> substL iso_cd) (\\b_d -> substL iso_ab >>> b_d >>> substR iso_cd)\n\n-- Going another way is hard (and is generally impossible)\n-- Remember, for all valid isomorphisms, converting to and fro\n-- should always give you the original value.\n-- You need this to prove that some cases are impossible.\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe iso_ma_mb = Tuple left right\n    where\n    left a =\n        case substL iso_ma_mb (Just a) of\n            Nothing ->  unsafePartial $ fromJust (substL iso_ma_mb Nothing)\n            Just b -> b\n    right b =\n        case substR iso_ma_mb (Just b) of\n            Nothing -> unsafePartial $ fromJust (substR iso_ma_mb Nothing)\n            Just a -> a\n\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple left right\n    where\n    left (Left units) = Left (unit : units)\n    left (Right unit) = Left (List.fromFoldable [])\n    right (Left list) =\n        case List.uncons list of\n            Just { head: _, tail: units } -> Left units\n            Nothing -> Right unit\n    right (Right a) = absurd a\n\n-- where `Unit` has exactly 1 member and `Void` has no members.\n-- The existence of isoUnEither would imply the existence of\n-- ISO Unit Void which would mean we could construct a value of\n-- type Void from a value of type Unit (which is obviously impossible)\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple symm symm\n\n-- Sometimes, we can treat a type as a number - if a type `t`\n-- has `n` distinct values then we say that its number is `n`.\n-- This is formally called cardinality.\n-- See https:\/\/en.wikipedia.org\/wiki\/Cardinality\n\n-- Void has a cardinality of 0 (we will abbreviate it as \"Void is 0\").\n-- Unit is 1.\n-- Boolean is 2.\n-- Maybe a is 1 + a.\n-- We will be using Peano arithmetic so we will write it as S a.\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\n-- Either a b is a + b.\n-- Tuple a b is a * b.\n-- a -> b is b ^ a. Try counting Unit -> Boolean and Boolean -> Unit\n\n-- Algebraic data type got its name because\n-- it satisfies a lot of algebraic rules under isomorphism\n\n-- a = b -> c = d -> a * c = b * d\nisoProd :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoProd = isoTuple\n\n-- a = b -> c = d -> a + c = b + d\nisoPlus :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoPlus = isoEither\n\n-- a = b -> S a = S b\nisoS :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoS = isoMaybe\n\n-- a = b -> c = d -> c ^ a = d ^ b\nisoPow :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoPow = isoFunc\n\n-- a + b = b + a\nplusComm :: forall a b. ISO (Either a b) (Either b a)\nplusComm = Tuple left right\n    where\n    left (Left a) = Right a\n    left (Right b) = Left b\n    right (Left b) = Right b\n    right (Right a) = Left a\n\n-- (a + b) + c = a + (b + c)\nplusAssoc :: forall a b c. ISO (Either (Either a b) c) (Either a (Either b c))\nplusAssoc = Tuple left right\n    where\n    left (Left (Left a)) = Left a\n    left (Left (Right b)) = Right (Left b)\n    left (Right c) = Right (Right c)\n    right (Left a) = Left (Left a)\n    right (Right (Left b)) = Left (Right b)\n    right (Right (Right c)) = Right c\n\n-- a * b = b * a\nmultComm :: forall a b. ISO (Tuple a b) (Tuple b a)\nmultComm = Tuple swap swap\n\n-- (a * b) * c = a * (b * c)\nmultAssoc :: forall a b c. ISO (Tuple (Tuple a b) c) (Tuple a (Tuple b c))\nmultAssoc = Tuple left right\n    where\n    left (Tuple (Tuple a b) c) = Tuple a (Tuple b c)\n    right (Tuple a (Tuple b c)) = Tuple (Tuple a b) c\n\n-- a * (b + c) = a * b + a * c\ndist :: forall a b c. ISO (Tuple a (Either b c)) (Either (Tuple a b) (Tuple a c))\ndist = Tuple left right\n    where\n    left (Tuple a (Left b)) = Left (Tuple a b)\n    left (Tuple a (Right c)) = Right (Tuple a c)\n    right (Left (Tuple a b)) = Tuple a (Left b)\n    right (Right (Tuple a c)) = Tuple a (Right c)\n\n-- (c ^ b) ^ a = c ^ (a * b)\ncurryISO :: forall a b c. ISO (a -> b -> c) (Tuple a b -> c)\ncurryISO = Tuple left right\n    where\n    left f (Tuple a b) = f a b\n    right f a b = f (Tuple a b)\n\n-- 1 = S O (we are using Peano arithmetic)\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\none :: ISO Unit (Maybe Void)\none = Tuple (const Nothing) (const unit)\n\n-- 2 = S (S O)\ntwo :: ISO Boolean (Maybe (Maybe Void))\ntwo = Tuple left right\n    where\n    left false = Nothing\n    left true = Just Nothing\n    right Nothing = false\n    right (Just _) = true\n\n-- O + b = b\nplusO :: forall b. ISO (Either Void b) b\nplusO = Tuple left Right\n  where\n    left (Left x) = absurd x -- absurd :: forall a. Void -> a\n    left (Right x) = x\n\n-- S a + b = S (a + b)\nplusS :: forall a b. ISO (Either (Maybe a) b) (Maybe (Either a b))\nplusS = Tuple left right\n    where\n    left (Left Nothing) = Nothing\n    left (Left (Just a)) = Just (Left a)\n    left (Right b) = Just (Right b)\n    right Nothing = Left Nothing\n    right (Just (Left a)) = Left (Just a)\n    right (Just (Right b)) = Right b\n\n-- 1 + b = S b\nplusSO :: forall b. ISO (Either Unit b) (Maybe b)\nplusSO = isoPlus one refl `trans` plusS `trans` isoS plusO\n\n-- O * a = O\nmultO :: forall a. ISO (Tuple Void a) Void\nmultO = Tuple left right\n    where\n    left (Tuple v _) = v\n    right v = (Tuple v (absurd v))\n\n-- S a * b = b + a * b\nmultS :: forall a b. ISO (Tuple (Maybe a) b) (Either b (Tuple a b))\nmultS = Tuple left right\n    where\n    left (Tuple Nothing b) = Left b\n    left (Tuple (Just a) b) = Right (Tuple a b)\n    right (Left b) = Tuple Nothing b\n    right (Right (Tuple a b)) = Tuple (Just a) b\n\n-- 1 * b = b\nmultSO :: forall b. ISO (Tuple Unit b) b\nmultSO =\n  isoProd one refl `trans`\n    multS `trans`\n    isoPlus refl multO `trans` \n    plusComm `trans`\n    plusO\n\n-- a ^ O = 1\npowO :: forall a. ISO (Void -> a) Unit\npowO = Tuple left right\n    where\n    left _ = unit\n    right unit = absurd\n\n-- a ^ (S b) = a * (a ^ b)\npowS :: forall a b. ISO (Maybe b -> a) (Tuple a (b -> a))\npowS = Tuple left right\n    where\n    left f = Tuple (f Nothing) (\\b -> f (Just b))\n    right (Tuple a b_a) = case _ of\n        Just b -> b_a b\n        Nothing -> a\n\n-- a ^ 1 = a\n-- Go the hard way (like multSO, plusSO)\n-- to prove that you really get what is going on!\npowSO :: forall a. ISO (Unit -> a) a\npowSO = Tuple left right\n    where\n    left f = f unit\n    right a = \\unit -> a","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232494,"user_id":null,"body":"module AlgebraicIsomorphism where\n\nimport Data.Void\nimport Prelude (not, ($), (<<<), map)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.List (List(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Either (Either(..))\nimport Data.Unit (Unit, unit)\n\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst\n\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = refl\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\nrefl :: forall a. ISO a a\nrefl = Tuple (\\x -> x) (\\x -> x)\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm (Tuple a b) = Tuple b a\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple ab ba) (Tuple bc cb) = Tuple (bc <<< ab) (ba <<< cb)\n\nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple \n  (\\x -> Tuple (ab $ fst x) (cd $ snd x))\n  (\\x -> Tuple (ba $ fst x) (dc $ snd x))\n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map  ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple \n  (\\x -> case x of\n    Left a -> Left $ ab a\n    Right c -> Right $ cd c)\n  (\\x -> case x of\n    Left b -> Left $ ba b\n    Right d -> Right $ dc d)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple\n  (\\ac -> cd <<< ac <<< ba)\n  (\\bd -> dc <<< bd <<< ab)\n\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mamb mbma) = Tuple\n  (\\a -> case mamb $ Just a of\n    Just b -> b\n    Nothing -> case mamb $ Nothing of \n      Just b2 -> b2\n      Nothing ->(fst $ isoUnMaybe $ Tuple (mamb <<< mbma <<< mamb) (mbma <<< mamb <<< mbma)) a )\n  (\\b -> case mbma $ Just b of\n    Just a -> a\n    Nothing -> case mbma $ Nothing of\n      Just a2 -> a2\n      Nothing -> (fst $ isoUnMaybe $ Tuple (mbma <<< mamb <<< mbma)(mamb <<< mbma <<< mamb)) b)\n\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple\n  (\\x -> case x of \n    Left lu -> Left $ Cons unit lu\n    Right u -> Left Nil)\n  (\\x -> case x of \n    Left Nil -> Right unit\n    Left (Cons unit lu) -> Left lu\n    Right v -> absurd v)\n\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple\n  (\\isoab -> Tuple (snd isoab) (fst isoab))\n  (\\isoba -> Tuple (snd isoba) (fst isoba))\n\nisoProd :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoProd = isoTuple\n\nisoPlus :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoPlus = isoEither\n\nisoS :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoS = isoMaybe\n\nisoPow :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoPow = isoFunc\n\nplusComm :: forall a b. ISO (Either a b) (Either b a)\nplusComm = Tuple\n  (\\x -> case x of\n    Left a -> Right a\n    Right b -> Left b)\n  (\\x -> case x of\n    Left a -> Right a\n    Right b -> Left b)\n\n-- (a + b) + c = a + (b + c)\nplusAssoc :: forall a b c. ISO (Either (Either a b) c) (Either a (Either b c))\nplusAssoc = Tuple\n  (\\x -> case x of\n    Left (Left a) -> Left a\n    Left (Right b) -> Right $ Left b\n    Right c -> Right $ Right c)\n  (\\x -> case x of\n    Left a -> Left (Left a)\n    Right (Left b) -> Left $ Right b\n    Right (Right c) -> Right c)\n\nmultComm :: forall a b. ISO (Tuple a b) (Tuple b a)\nmultComm = Tuple\n  (\\x -> Tuple (snd x) (fst x))\n  (\\x -> Tuple (snd x) (fst x))\n\nmultAssoc :: forall a b c. ISO (Tuple (Tuple a b) c) (Tuple a (Tuple b c))\nmultAssoc = Tuple\n  (\\x -> case x of\n    (Tuple (Tuple a b) c) -> (Tuple a (Tuple b c)))\n  (\\x -> case x of\n    (Tuple a (Tuple b c)) -> (Tuple (Tuple a b) c))\n\ndist :: forall a b c. ISO (Tuple a (Either b c)) (Either (Tuple a b) (Tuple a c))\ndist = Tuple\n  (\\x -> case x of\n    Tuple a (Left b) -> Left $ Tuple a b\n    Tuple a (Right c) ->  Right $ Tuple a c)\n  (\\x -> case x of\n    Left (Tuple a b) -> Tuple a $ Left b\n    Right (Tuple a c) -> Tuple a $ Right c)\n\ncurryISO :: forall a b c. ISO (a -> b -> c) (Tuple a b -> c)\ncurryISO = Tuple\n  (\\x -> \\tab -> x (fst tab) (snd tab))\n  (\\x -> \\a -> \\b -> x $ Tuple a b)\n\none :: ISO Unit (Maybe Void)\none = Tuple (\\x -> Nothing) (\\x -> unit)\n\ntwo :: ISO Boolean (Maybe (Maybe Void))\ntwo = Tuple\n  (\\x -> case x of\n    true -> Just Nothing\n    false -> Nothing)\n  (\\x -> case x of\n    Just (Just _) -> true\n    Just Nothing -> true\n    Nothing -> false)\n\nplusO :: forall b. ISO (Either Void b) b\nplusO = Tuple left Right\n  where\n    left (Left x) = absurd x\n    left (Right x) = x\n\nplusS :: forall a b. ISO (Either (Maybe a) b) (Maybe (Either a b))\nplusS = Tuple\n  (\\x -> case x of\n    Left Nothing -> Nothing\n    Left (Just a) -> Just $ Left a\n    Right b -> Just $ Right b)\n  (\\x -> case x of\n    Nothing -> Left Nothing\n    Just (Left a) -> Left $ Just a\n    Just (Right b) -> Right b)\n\nplusSO :: forall b. ISO (Either Unit b) (Maybe b)\nplusSO = isoPlus one refl `trans` plusS `trans` isoS plusO\n\nmultO :: forall a. ISO (Tuple Void a) Void\nmultO = Tuple fst absurd\n\nmultS :: forall a b. ISO (Tuple (Maybe a) b) (Either b (Tuple a b))\nmultS = Tuple\n  (\\x -> case x of\n    Tuple (Just a) b -> Right $ Tuple a b\n    Tuple Nothing b -> Left b)\n  (\\x -> case x of\n    Left b -> Tuple Nothing b\n    Right (Tuple a b) -> Tuple (Just a) b)\n\nmultSO :: forall b. ISO (Tuple Unit b) b\nmultSO =\n  isoProd one refl `trans`\n    multS `trans`\n    isoPlus refl multO `trans` \n    plusComm `trans`\n    plusO\n\npowO :: forall a. ISO (Void -> a) Unit\npowO = Tuple (\\x -> unit) (\\x -> absurd)\n\npowS :: forall a b. ISO (Maybe b -> a) (Tuple a (b -> a))\npowS = Tuple\n  (\\f -> Tuple (f Nothing) (f <<< Just))\n  (\\x -> \\mb -> case mb of\n    Nothing -> fst x\n    Just y -> (snd x) y)\n\npowSO :: forall a. ISO (Unit -> a) a\npowSO = Tuple\n  (\\f -> f unit)\n  (\\a -> \\x -> a)\n","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"},{"id":232495,"user_id":21,"body":"module AlgebraicIsomorphism where\n\n-- Please copy your solution to Isomorphism here.\n\nimport Prelude\n\n-- The type `Void` has no members so it is impossible to construct\n-- a value of type `Void` without resorting to unsafe features or\n-- non-terminating computations, etc.\n\n-- There exists a function\n--   absurd :: forall a. Void -> a\n-- (https:\/\/pursuit.purescript.org\/packages\/purescript-prelude\/4.1.0\/docs\/Data.Void#v:absurd)\n-- That could get any type of value out of `Void`, if only it were possible\n-- to construct a value of type `Void` in the first place\n\n-- So, when are two types `a` and `b` considered equivalent?\n-- A definition might be, it is possible to go from `a` to `b`,\n-- and from `b` to `a`.\n-- Going a roundway trip should always leave you with the same value\n-- no matter what value you start with or which type you start from.\n-- Unfortunately it is virtually impossible to test this in PureScript.\n-- This is called Isomorphism.\n\n-- The word \"isomorphism\" has its roots in Greek - \"isos\" meaning equal\/same\n-- and \"morph\" meaning shape\/form\/structure.  So \"isomorphism\" could be\n-- understood as \"having the same shape\".\n\nimport Data.Tuple (Tuple(..), fst, snd, swap)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..), fromJust, isJust)\nimport Data.Either (Either(..))\nimport Partial.Unsafe (unsafePartial)\n\ntype ISO a b = Tuple (a -> b) (b -> a)\n\n-- Given ISO a b, we can go from a to b ... \nsubstL :: forall a b. ISO a b -> a -> b\nsubstL = fst -- This is given; you do not need to change it :)\n\n-- ... and vice versa\nsubstR :: forall a b. ISO a b -> b -> a\nsubstR = snd\n\nid :: forall a. a -> a\nid x = x\n\n-- There can exist more than one isomorphism between two types `a` and `b`\n\nisoBoolean :: ISO Boolean Boolean\nisoBoolean = Tuple id id\n\nisoBooleanNot :: ISO Boolean Boolean\nisoBooleanNot = Tuple not not\n\n-- Isomorphism denotes an equivalence relation so it naturally satisfies\n-- the 3 major properties of equivalence relations (isomorphism is denoted\n-- as `<=>` below):\n-- 1) Reflexivity: a <=> a\n-- 2) Symmetry: (a <=> b) -> (b <=> a)\n-- 3) Transitivity: (a <=> b) \/\\ (b <=> c) -> (a <=> c)\n-- Here, `\/\\` denotes logical conjunction, otherwise known as \"AND\"\n\nrefl :: forall a. ISO a a\nrefl = Tuple id id\n\nsymm :: forall a b. ISO a b -> ISO b a\nsymm (Tuple a b) = Tuple b a\n\ntrans :: forall a b c. ISO a b -> ISO b c -> ISO a c\ntrans (Tuple a b) (Tuple c d) = Tuple (a >>> c) (d >>> b)\n\n-- We can combine isomorphisms using the cartesian product ... \nisoTuple :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoTuple (Tuple ab ba) (Tuple cd dc) = Tuple tactbd tbdtac\n  where\n    tactbd (Tuple a c) = Tuple (ab a) (cd c)\n    tbdtac (Tuple b d) = Tuple (ba b) (dc d)\n\n-- And derive new isomorphisms from known ones ... \n\nisoList :: forall a b. ISO a b -> ISO (List a) (List b)\nisoList (Tuple ab ba) = Tuple (map ab) (map ba)\n\nisoMaybe :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoMaybe (Tuple ab ba) = Tuple mamb mbma\n  where\n    mamb :: Maybe a -> Maybe b\n    mamb (Just a) = Just (ab a)\n    mamb Nothing = Nothing\n    \n    mbma :: Maybe b -> Maybe a\n    mbma (Just b) = Just (ba b)\n    mbma Nothing = Nothing\n\nisoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoEither (Tuple ab ba) (Tuple cd dc) = Tuple eacebd ebdeac\n  where\n    eacebd :: Either a c -> Either b d\n    eacebd (Left a) = Left (ab a)\n    eacebd (Right c) = Right (cd c)\n    ebdeac :: Either b d -> Either a c\n    ebdeac (Left b) = Left (ba b)\n    ebdeac (Right d) = Right (dc d)\n\nisoFunc :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoFunc (Tuple ab ba) (Tuple cd dc) = Tuple acbd bdac\n  where\n    acbd :: (a -> c) -> (b -> d)\n    acbd ac = ba >>> ac >>> cd\n    bdac :: (b -> d) -> (a -> c)\n    bdac bd = ab >>> bd >>> dc\n\n-- Going another way is hard (and is generally impossible)\n-- Remember, for all valid isomorphisms, converting to and fro\n-- should always give you the original value.\n-- You need this to prove that some cases are impossible.\nisoUnMaybe :: forall a b. ISO (Maybe a) (Maybe b) -> ISO a b\nisoUnMaybe (Tuple mamb mbma) = Tuple ab ba\n  where\n    ab :: a -> b\n    ab a = case mamb (Just a) of\n      Just b -> b\n      Nothing -> unsafePartial $ fromJust $ mamb Nothing\n    ba :: b -> a\n    ba b = case mbma (Just b) of\n      Just a -> a\n      Nothing -> unsafePartial $ fromJust $ mbma Nothing\n\n-- isoEither :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\n-- We cannot construct:\n--   isoUnEither :: forall a b c d. ISO (Either a b) (Either c d) -> ISO a c -> ISO b d\n-- because we have this:\nisoEU :: ISO (Either (List Unit) Unit) (Either (List Unit) Void)\nisoEU = Tuple eluueluv eluveluu\n  where\n    eluueluv :: Either (List Unit) Unit -> Either (List Unit) Void\n    eluueluv (Left a) = Left (unit : a)\n    eluueluv (Right u) = Left Nil\n    \n    eluveluu :: Either (List Unit) Void -> Either (List Unit) Unit\n    eluveluu (Left (unit : a)) = Left a\n    eluveluu (Left Nil) = Right unit\n    eluveluu (Right x) = absurd x\n-- where `Unit` has exactly 1 member and `Void` has no members.\n-- The existence of isoUnEither would imply the existence of\n-- ISO Unit Void which would mean we could construct a value of\n-- type Void from a value of type Unit (which is obviously impossible)\n\n-- Last but not least, we can define isomorphisms on isomorphisms ;)\nisoSymm :: forall a b. ISO (ISO a b) (ISO b a)\nisoSymm = Tuple symm symm\n\n-- Sometimes, we can treat a type as a number - if a type `t`\n-- has `n` distinct values then we say that its number is `n`.\n-- This is formally called cardinality.\n-- See https:\/\/en.wikipedia.org\/wiki\/Cardinality\n\n-- Void has a cardinality of 0 (we will abbreviate it as \"Void is 0\").\n-- Unit is 1.\n-- Boolean is 2.\n-- Maybe a is 1 + a.\n-- We will be using Peano arithmetic so we will write it as S a.\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\n-- Either a b is a + b.\n-- Tuple a b is a * b.\n-- a -> b is b ^ a. Try counting Unit -> Boolean and Boolean -> Unit\n\n-- Algebraic data type got its name because\n-- it satisfies a lot of algebraic rules under isomorphism\n\n-- a = b -> c = d -> a * c = b * d\nisoProd :: forall a b c d. ISO a b -> ISO c d -> ISO (Tuple a c) (Tuple b d)\nisoProd = isoTuple\n\n-- a = b -> c = d -> a + c = b + d\nisoPlus :: forall a b c d. ISO a b -> ISO c d -> ISO (Either a c) (Either b d)\nisoPlus = isoEither\n\n-- a = b -> S a = S b\nisoS :: forall a b. ISO a b -> ISO (Maybe a) (Maybe b)\nisoS = isoMaybe\n\n-- a = b -> c = d -> c ^ a = d ^ b\nisoPow :: forall a b c d. ISO a b -> ISO c d -> ISO (a -> c) (b -> d)\nisoPow = isoFunc\n\n-- a + b = b + a\nplusComm :: forall a b. ISO (Either a b) (Either b a)\nplusComm = Tuple to fro\n  where\n    to (Left a) = Right a\n    to (Right b) = Left b\n    fro (Left b) = Right b\n    fro (Right a) = Left a\n\n-- (a + b) + c = a + (b + c)\nplusAssoc :: forall a b c. ISO (Either (Either a b) c) (Either a (Either b c))\nplusAssoc = Tuple to fro\n  where\n    to (Left (Left a)) = Left a\n    to (Left (Right b)) = Right (Left b)\n    to (Right c) = Right (Right c)\n    \n    fro (Left a) = Left (Left a)\n    fro (Right (Left b)) = Left (Right b)\n    fro (Right (Right c)) = Right c\n\n-- a * b = b * a\nmultComm :: forall a b. ISO (Tuple a b) (Tuple b a)\nmultComm = Tuple swap swap\n\n-- (a * b) * c = a * (b * c)\nmultAssoc :: forall a b c. ISO (Tuple (Tuple a b) c) (Tuple a (Tuple b c))\nmultAssoc = Tuple to fro\n  where\n    to (Tuple t c) = Tuple (fst t) (Tuple (snd t) c)\n    fro (Tuple a t) = Tuple (Tuple a (fst t)) (snd t)\n\n-- a * (b + c) = a * b + a * c\ndist :: forall a b c. ISO (Tuple a (Either b c)) (Either (Tuple a b) (Tuple a c))\ndist = Tuple to fro\n  where\n    to (Tuple a (Left b)) = Left (Tuple a b)\n    to (Tuple a (Right c)) = Right (Tuple a c)\n    fro (Left t) = Tuple (fst t) (Left (snd t))\n    fro (Right t) = Tuple (fst t) (Right (snd t))\n\n-- (c ^ b) ^ a = c ^ (a * b)\ncurryISO :: forall a b c. ISO (a -> b -> c) (Tuple a b -> c)\ncurryISO = Tuple to fro\n  where\n    to f = \\(Tuple a b) -> (f a b)\n    fro tabc = \\a -> \\b -> (tabc (Tuple a b))\n\n-- 1 = S O (we are using Peano arithmetic)\n-- https:\/\/en.wikipedia.org\/wiki\/Peano_axioms\none :: ISO Unit (Maybe Void)\none = Tuple (const Nothing) (const unit)\n\n-- 2 = S (S O)\ntwo :: ISO Boolean (Maybe (Maybe Void))\ntwo = Tuple to isJust\n  where\n    to false = Nothing\n    to true = Just Nothing\n\n-- O + b = b\nplusO :: forall b. ISO (Either Void b) b\nplusO = Tuple left Right\n  where\n    left (Left x) = absurd x -- absurd :: forall a. Void -> a\n    left (Right x) = x\n\n-- S a + b = S (a + b)\nplusS :: forall a b. ISO (Either (Maybe a) b) (Maybe (Either a b))\nplusS = Tuple to fro\n  where\n    to (Left (Just a)) = Just (Left a)\n    to (Left Nothing) = Nothing\n    to (Right b) = Just (Right b)\n    \n    fro Nothing = Left Nothing\n    fro (Just (Left a)) = Left (Just a)\n    fro (Just (Right b)) = Right b\n\n-- 1 + b = S b\nplusSO :: forall b. ISO (Either Unit b) (Maybe b)\nplusSO = isoPlus one refl `trans` plusS `trans` isoS plusO\n\n-- O * a = O\nmultO :: forall a. ISO (Tuple Void a) Void\nmultO = Tuple fst absurd\n\n-- S a * b = b + a * b\nmultS :: forall a b. ISO (Tuple (Maybe a) b) (Either b (Tuple a b))\nmultS = Tuple to fro\n  where\n    to (Tuple (Just a) b) = Right (Tuple a b)\n    to (Tuple Nothing b) = Left b\n    fro (Left b) = Tuple Nothing b\n    fro (Right (Tuple a b)) = Tuple (Just a) b\n\n-- 1 * b = b\nmultSO :: forall b. ISO (Tuple Unit b) b\nmultSO =\n  isoProd one refl `trans`\n    multS `trans`\n    isoPlus refl multO `trans` \n    plusComm `trans`\n    plusO\n\n-- a ^ O = 1\npowO :: forall a. ISO (Void -> a) Unit\npowO = Tuple (const unit) (const absurd)\n\n-- a ^ (S b) = a * (a ^ b)\npowS :: forall a b. ISO (Maybe b -> a) (Tuple a (b -> a))\npowS = Tuple to fro\n  where\n    to f = Tuple (f Nothing) (\\b -> (f (Just b)))\n    fro (Tuple a f) = \\b -> case b of\n      Nothing -> a\n      Just x -> f x\n  \n-- a ^ 1 = a\n-- Go the hard way (like multSO, plusSO)\n-- to prove that you really get what is going on!\npowSO :: forall a. ISO (Unit -> a) a\npowSO = isoPow one refl `trans` powS `trans` isoProd refl powO `trans` multComm `trans` multSO\n-- Here's a trick:\n-- replace ?powSO with the comment to its right\n-- When you're not sure what to fill in, use a typed hole\n-- as a placeholder (such as ?hole1, ?hole2 mentioned above)\n-- The PureScript compiler will display a message similar to\n-- the one shown below:\n--   Hole 'hole1' has the inferred type\n--     forall a b0 a0. ISO (Unit -> a) (Maybe b0 -> a0)\n-- So you can immediately see the type of the value required\n-- to complete your \"proof\"\n-- This process can be repeat indefinitely.\n-- For example you might replace `?hole1` with `isoFunc ?hole3 ?hole4`\n-- So the PureScript compiler may hint you on a more specific type.\n-- This is especially usefull if you have a complex type.\n-- See https:\/\/wiki.haskell.org\/GHC\/Typed_holes for detailed information\n-- on typed holes - it was written for Haskell but no equivalent documentation\n-- exists for PureScript.  The only difference is that typed holes in PureScript\n-- have the form `?someHole` instead of `_someHole` and a hole with no name, i.e.\n-- `?` is not allowed.\n-- You may also wish to Google \"stepwise refinement\" for further details.","lang_id":41,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:32","updated_at":"2022-12-30 18:39:32"}]}