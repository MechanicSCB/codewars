{"5dcb1705bc7c4c00312ae9a2":[{"id":289295,"user_id":null,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (if (or (negative? wr) (not (positive? vs))) 0\n    (let\n      ([time (\/ wr vs)])\n      (sqrt (+ (expt wr 2) (expt (* time (abs vr)) 2))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289296,"user_id":null,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (if (= vs 0) 0 (\/ wr (cos (atan (\/ vr vs))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289297,"user_id":null,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance flow-rate swim-speed river-width)\n  (cond [(= swim-speed 0) 0]\n        [(= river-width 0) 0]\n        [else (sqrt (+ (expt flow-rate 2) (expt river-width 2)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289298,"user_id":913,"body":"#lang racket\n\n(provide swim-distance)\n    \n;(: pythagoras (rational rational -> rational))\n(define (pythagoras a b)\n  (sqrt (+ (* a a) (* b b)))\n  )\n    \n;(: swim-distance (rational rational rational -> number))\n(define (swim-distance vr vs wr)\n  (cond\n    ((<= vs 0) 0)\n    (else\n     (define speedRatio (\/ vr vs))\n     (define offset (* wr speedRatio))\n     (pythagoras wr offset)\n     )))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289299,"user_id":544,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (cond [(or (= vs 0) (<= wr 0)) 0]\n        [else (sqrt (+ (sqr wr) \n                       (sqr (\/ (* vr wr) \n                               vs))))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289300,"user_id":null,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (if (or (zero? vs) (negative? wr))\n      0\n      (* wr (sqrt (add1 (sqr (\/ vr vs)))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289301,"user_id":242,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (cond\n    [(= vs 0) 0]\n    [(= vr 0) wr]\n    [else \n      (let \n        (\n          (t (\/ wr vr))\n        )\n        (* 2 (sqrt (+ (* wr wr) (* t t vs vs))) )\n      )\n    ]\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289302,"user_id":null,"body":"#lang racket\n(provide swim-distance)\n\n(define swim-distance\n  (lambda (vr vs wr)\n    (if (= vs 0) 0\n    (* (\/ wr vs) (sqrt (+ (sqr vs) (sqr vr)))))\n  ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289303,"user_id":null,"body":"#lang racket\n(provide swim-distance)\n\n(define swim-distance\n  (lambda (vr vs wr)\n    (if (= vs 0) +inf.0\n    (* (\/ wr vs) (sqrt (+ (sqr vs) (sqr vr)))))\n  ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289304,"user_id":106,"body":"#lang racket\n(provide swim-distance)\n\n(define (square x)\n  (* x x))\n\n(define swim-distance\n  (lambda (vr vs wr)\n    (if (= 0 vs) +inf.0 (sqrt (+ (square (* (\/ wr vs) vr)) (square wr))))\n  ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289305,"user_id":168,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (if (<= vs 0) +inf.0\n      (magnitude (make-rectangular wr (\/ (* wr vr) vs)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289306,"user_id":503,"body":"#lang racket\n(provide swim-distance)\n(define swim-distance (lambda (Q W E) (if (= 0 W) +inf.0 (sqrt (+ (sqr E) (sqr (\/ (* Q E) W)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289307,"user_id":502,"body":"#lang racket\n(provide swim-distance)\n\n(define swim-distance\n  (lambda (a b c)\n    (cond\n      ((= b 0) +inf.0)\n      (else (let ([t (\/ c b)])\n     (sqrt (+ (expt (* a  t) 2) (* c c)))\n  )))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289308,"user_id":527,"body":"#lang racket\n(provide swim-distance)\n\n(define (swim-distance vr vs wr)\n  (* wr (sqrt (+ 1 (expt (\/ vr (exact->inexact vs)) 2)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5e23eadb0879110028b96424":[{"id":289309,"user_id":564,"body":"#lang racket\n\n(provide\n  square\n  average\n  absolute-value\n  improve\n  good-enough?\n  try\n  square-root)\n\n(define (square x)\n    (* x x))\n\n(define (average x y)\n    (\/ (+ x y) 2))\n    \n(define (absolute-value x)\n    (if (< x 0) (- x)\n        x))\n\n(define (improve guess x)\n    (average guess (\/ x guess)))\n\n(define (good-enough? guess x)\n  (< (abs (- (square guess) x))\n     .001))\n\n(define (try guess x)\n  (if (good-enough? guess x)\n      guess\n      (try (improve guess x) x)))\n\n(define (square-root x) (try 1 x))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289310,"user_id":168,"body":"#lang racket\n\n(provide\n  square\n  average\n  absolute-value\n  improve\n  good-enough?\n  try\n  square-root)\n\n; The path of wizardry is fraught with danger,\n; but holds great power for those who persevere.\n\n(define (square x)\n    (* x x))\n\n(define (average x y)\n    (\/ (+ x y) 2))\n    \n(define (absolute-value x)\n    (abs x))\n\n(define (improve guess x)\n    (average guess (\/ x guess)))\n\n(define (good-enough? guess x)\n    (<= (abs (- (square guess) x)) 0.001))\n\n(define (try guess x)\n    (sqrt x))\n\n(define (square-root x)\n    (sqrt x))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289311,"user_id":242,"body":"#lang racket\n\n(provide\n  square\n  average\n  absolute-value\n  improve\n  good-enough?\n  try\n  square-root)\n\n; The path of wizardry is fraught with danger,\n; but holds great power for those who persevere.\n\n(define (square x) (* x x))\n\n(define (average x y) (\/ (+ x y) 2))\n    \n(define (absolute-value x) (if (> x 0) x (- 0 x)))\n\n(define (improve guess x) (average guess (\/ x guess)))\n\n(define (good-enough? guess x) (> 0.001 (absolute-value (- (square guess) x))))\n\n(define (try guess x)\n  (cond\n    [(good-enough? guess x) guess]\n    [else (try (improve guess x) x)]\n  )\n)\n\n(define (square-root x) (try 1 x) )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289312,"user_id":527,"body":"#lang racket\n\n(provide\n  square\n  average\n  absolute-value\n  improve\n  good-enough?\n  try\n  square-root)\n\n(define (square x) (* x x))\n(define (average x y) (\/ (+ x y) 2))\n(define absolute-value abs)\n(define (improve guess x) (\/ (+ guess (\/ x guess)) 2))\n(define (good-enough? guess x) (<= (abs (- (sqr guess) x)) 0.001))\n(define try improve)\n(define square-root sqrt)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"51ba717bb08c1cd60f00002f":[{"id":289313,"user_id":53,"body":"#lang racket\n\n(provide solution list)\n \n(define (solution xs)\n  (let loop ([cnt 0]\n             [last 0]\n             [acc '()]\n             [i 0])\n    (let* ([x (if (>= i (length xs)) 0 (list-ref xs i))]\n           [p (or (zero? i) (= i (length acc)) (not (eq? x (+ last cnt))))])\n      (cond \n        [(> i (length xs)) (string-join (reverse acc) \",\")]\n        [(and p (not (zero? i)) (eq? 1 cnt)) (loop 1 x (cons (format \"~a\" last) acc) (add1 i))]\n        [(and p (not (zero? i)) (eq? 2 cnt)) (loop 1 x (cons (format \"~a,~a\" last (add1 last)) acc) (add1 i))]\n        [(and p (not (zero? i))) (loop 1 x (cons (format \"~a-~a\" last (sub1 (+ last cnt))) acc) (add1 i))]\n        [p (loop 1 x acc (add1 i))]\n        [else (loop (add1 cnt) last acc (add1 i))]))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289314,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide solution list)\n\n\n;; (List Integer) -> String\n;; given a list of integers in increasing order, return a correctly formatted\n;; string in the range format, i.e. a comma separated list of either:\n;; - individual integers\n;; - or a range of integers denoted by the starting int separated from the end\n;;   int by dash '-'. The range includes all integers in the interval incl.\n;;   endpoints and spans at least 3 numbers, e.g. \"15-17\"\n\n;; idea\n;; first walk through the list, putting consecutive numbers into sublists\n;; then process the resulting list, by squeezing sublists with more than\n;; two elements\n\n;; best conceivable runtime: O(n)\n;; actual runtime: ?\n\n(define (solution xs)\n  (string-join (map seq->string (chunk '() (map list xs))) \",\"))\n      \n(module+ test\n  (check-equal?\n   (solution '(-6 -3 -2 -1 0 1 3 4 5 7 8 9 10 11 14 15 17 18 19 20))\n   \"-6,-3-1,3-5,7-11,14,15,17-20\"))\n\n\n;; (List Number) -> String\n;; given a list with consecutive numbers, turn it into a string according\n;; to above rules\n(define (seq->string s)\n  (cond\n    [(= 1 (length s)) (number->string (first s))]\n    [(= 2 (length s)) (format \"~a,~a\" (first s) (second s))]\n    [else (format \"~a-~a\" (first s) (last s))]))\n\n(module+ test\n  (check-equal? (seq->string '(1)) \"1\")\n  (check-equal? (seq->string '(1 2)) \"1,2\")\n  (check-equal? (seq->string '(1 2 3)) \"1-3\"))\n\n\n;; (List (List=1 Number)) -> (List (List Number))\n;; identify consecutive numbers and merge them into a sublist\n;; in the left-to-right, longest match fashion\n(define (chunk left right)\n  (cond\n    [(empty? right) left]\n    [(empty? left) (chunk `(,(first right)) (rest right))]\n    [else\n     (if (= (caar right) (add1 (last (last left))))\n         (chunk\n          (append (drop-right left 1) `(,(append (last left) (first right))))\n          (rest right))\n         (chunk (append left `(,(first right))) (rest right)))]))\n   \n(module+ test\n  (check-equal?\n   (chunk '() (map list '(-6 -3 -2 -1 0 1 3 4 5 7 8 9 10 11 14 15 17 18 19 20)))\n   '((-6) (-3 -2 -1 0 1) (3 4 5) (7 8 9 10 11) (14 15) (17 18 19 20))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289315,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution nums)\n  (define (solution nums)\n    (cond\n      [(null? nums)\n       \"\"]\n      [(= (length nums) 1)\n       (format \"~a\" (first nums))]\n      [(find-range-in-head nums)\n       (format\n        \"~a,~a\"\n        (format-range-in-head nums)\n        (solution (ignore-range-in-head nums)))]\n      [else\n       (format \"~a,~a\" (first nums) (solution (rest nums)))]))\n  (define res (solution nums))\n  (if (string-suffix? res \",\")\n      (substring res 0 (sub1 (string-length res)))\n      res))\n\n(define (format-range-in-head nums)\n  (define rng (find-range-in-head nums))\n  (format \"~a-~a\" (first rng) (last rng)))\n\n(define (ignore-range-in-head nums)\n  (define rng (find-range-in-head nums))\n  (if rng (drop nums (length rng)) nums))\n\n(define (find-range-in-head nums)\n  (define (find-range-in-head nums)\n    (cond\n      [(null? nums)\n       '()]\n      [(= (length nums) 1)\n       (list (first nums))]\n      [(= (abs (- (first nums) (second nums))) 1)\n       (cons (first nums) (find-range-in-head (rest nums)))]\n      [else\n       (list (first nums))]))\n  (define rng (find-range-in-head nums))\n  (if (> (length rng) 2) rng #f))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289316,"user_id":null,"body":"#lang racket\n\n(provide solution list)\n\n(define (stringify l n)\n  (cond\n    ((null? l) \"\")\n    ((>= n 2)\n     (string-append (number->string (car l)) \"-\"))\n    (else\n     (string-append (number->string (car l)) \",\"))))\n \n  (define (solution l)\n  (define (range lon acc n)\n    (cond\n      ((null? (cdr lon))\n       (string-append (stringify acc n)\n                      (number->string (car lon))))\n      ((null? acc)\n       (let ((cur (car lon))\n             (nxt (car (cdr lon))))\n         (if (= cur (- nxt 1))\n             (range (cdr lon) (cons (car lon) acc) 1)\n           (string-append (string-append (number->string cur) \",\")\n                          (range (cdr lon) acc n)))))\n      (else\n       (let ((cur (car lon))\n             (nxt (car (cdr lon))))\n         (if (= cur (- nxt 1))\n             (range (cdr lon) acc (+ 1 n))\n             (string-append (string-append (stringify acc n)\n                                         (number->string cur))\n                            \",\"\n                            (range (cdr lon) '() 0)))))))\n  (range l '() 0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289317,"user_id":null,"body":"#lang racket\n\n(provide solution list)\n\n(define (solution xs)\n  (string-join (to-list xs) \",\"))\n\n(define (to-list xs)\n  (define (fmt-range a b)\n    (cond\n      [(= b a) (~a a)]\n      [(= b (+ a 1)) (format \"~a,~a\" a b)]\n      [else (format \"~a-~a\" a b)]))\n  (let loop ([beg (car xs)] [pre (car xs)] [xs (cdr xs)])\n    (if (null? xs) `(,(fmt-range beg pre))\n      (let ([first (car xs)] [rest (cdr xs)])\n        (if (= first (+ pre 1)) (loop beg first rest)\n          (cons (fmt-range beg pre) (loop first first rest)))))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289318,"user_id":null,"body":"#lang racket\n\n(provide solution list)\n \n(define (solution xs)\n  (tostr (findr xs '() '()) '()))\n\n(define (findr ls a ret)\n  (cond\n   [(and (null? ls) (<= 3 (length a))) (cons (reverse a) ret)]\n   [(and (null? ls) (< 0 (length a)) (> 3 (length a))) (append a ret)]\n   [(null? ls) ret]\n   [(null? a) (findr (cdr ls) (cons (car ls) a) ret)]\n   [(= 1 (- (car ls) (car a))) (findr (cdr ls) (cons (car ls) a) ret)]\n   [(<= 3 (length a)) (findr (cdr ls) (list (car ls)) (cons (reverse a) ret))]\n   [(and (< 0 (length a))(> 3 (length a))) (findr (cdr ls) (list (car ls)) (append  a ret))]\n   [else (findr (cdr ls) a (cons (car ls) ret))]))\n\n(define (tostr ls ret)\n  (cond\n   [(null? ls) (string-join ret \",\")]\n   [(list? (car ls)) \n    (tostr (cdr ls) \n           (cons (string-append (number->string (caar ls)) \"-\" (number->string (last (car ls)))) ret))]\n   [else (tostr (cdr ls) (cons (number->string (car ls)) ret))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289319,"user_id":null,"body":"#lang racket\n\n(provide solution list)\n \n\n(define-syntax ~>\n  (syntax-rules (>)\n    [(~> x) x]\n    [(~> x > (f ...) r ...) (~> (f ... x) r ...)]\n    [(~> x f r ...) (~> (f x) r ...)]))\n\n(define (solution lst)\n  (~> (let ([el (cdr lst)]) (if (list? el) el (list el)))\n      > (foldl (lambda (now last)\n                 (let ([head (car last)] [rest (cdr last)])\n                   (if (eq? now (+ 1 (cdr head)))\n                     (cons (cons (car head) now) rest)\n                     (cons (cons now now) last))))\n               `((,(car lst) . ,(car lst))))\n      > (map (lambda (range)\n               (let ([beg (car range)] [end (cdr range)])\n                 (cond\n                   [(eq? end beg) (number->string beg)]\n                   [(eq? end (+ 1 beg)) (format \"~a,~a\" beg end)]\n                   [else (format \"~a-~a\" beg end)]))))\n      reverse\n      (lambda (lst) (string-join lst \",\"))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289320,"user_id":null,"body":"#lang racket\n(provide solution)\n \n(define (solution xs)\n  (define (go a b l)\n    (define (s)\n      (map ~a\n        (match (- b a)\n          [0 `(,a)]\n          [1 `(,a ,b)]\n          [_ `(,(format \"~a-~a\" a b))])))\n    (match l\n      [`(,h ,@t)\n       (if (= (+ b 1) h)\n           (go a (+ b 1) t)\n           `(,@(s) ,@(go h h t)))]\n      [_ (s)]))\n  (match xs\n    [`(,h ,@t)\n     (string-join (go h h t) \",\")]\n    [_ \"\"]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289321,"user_id":null,"body":"#lang racket\n\n(provide solution list)\n \n(define (solution xs)\n  (string-trim (foldl (lambda (x y)\n           (cond [(= (length x) 1) (string-append y \",\" (~v (first x)))]\n                 [(= (length x) 2) (string-append y \",\" (~v (first x)) \",\" (~v (second x)))]\n                 [else (string-append y \",\" (~v (first x)) \"-\" (~v (last x)))]))\n         \"\"\n         (foldr (lambda (f r)\n                  (cond [(empty? r) (cons (cons f '()) r)]\n                        [(= (first (first r)) (+ f 1)) (cons (cons f (first r)) (rest r))]\n                        [else (cons (cons f '()) r)]))\n                '()\n                xs)) \",\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289322,"user_id":null,"body":"#lang racket\n\n(provide solution list)\n \n(define (solution xs)\n  (solution\/a (rest xs) (first xs) (first xs) \"\"))\n\n(define (solution\/a xs startOfSeq prev acc)\n  (cond [(empty? xs) (cond [(equal? prev startOfSeq) (string-append acc (~v prev))]\n                    [(< prev (+ 2 startOfSeq)) (string-append acc (string-append \n                                                (string-append (~v startOfSeq) \",\")\n                                                (~v prev)))]\n                    [else (string-append acc (string-append \n                                              (string-append (~v startOfSeq) \"-\")\n                                              (~v prev)))]\n        )]\n        [(equal? (+ 1 prev) (first xs)) (solution\/a (rest xs) startOfSeq (first xs) acc)]\n        [else (cond [(equal? prev startOfSeq) (solution\/a (rest xs) (first xs) (first xs)\n                                                         (string-append acc (string-append (~v prev) \",\")))]\n                    [(< prev (+ 2 startOfSeq)) (solution\/a (rest xs) (first xs) (first xs)\n                                                         (string-append acc (string-append \n                                                          (string-append (~v startOfSeq) \",\")\n                                                          (string-append (~v prev) \",\"))))]\n                    [else (solution\/a (rest xs) (first xs) (first xs)\n                                                         (string-append acc (string-append \n                                                          (string-append (~v startOfSeq) \"-\")\n                                                          (string-append (~v prev) \",\"))))]\n        )]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"52742f58faf5485cae000b9a":[{"id":289323,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration seconds)\n  (if (= seconds 0)\n      \"now\"\n      (make-format (t seconds))))\n\n(define (t n)\n\t(define ld (list 60 60 24 365))\n\t(define lw (list \"second\" \"minute\" \"hour\" \"day\" \"year\"))\n\t(define (temp n l d w)\n\t\t\t\t(cond [(< n 1) l]\n\t\t\t\t\t[(null? d) (cons (list (car w) n) l)]\n\t\t\t\t\t[(temp (quotient n (car d))\n\t\t\t\t\t\t\t(if (> (remainder n (car d)) 0)\n\t\t\t\t\t\t\t\t\t(cons (list (car w) (remainder n (car d))) l)\n\t\t\t\t\t\t\t\t\tl)\n\t\t\t\t\t\t\t(cdr d)\n\t\t\t\t\t\t\t(cdr w))]))\n\t(temp n '() ld lw))\n\n(define (make-format lst)\n\t(if (null? lst)\n\t\t\t\"\"\n\t\t\t(let ([d (cadar lst)]\n\t\t\t\t\t\t[w (caar lst)])\n\t\t\t\t(string-append\n\t\t\t\t\t(format \"~a ~a~a\" d w (if (> d 1) \"s\" \"\"))\n\t\t\t\t\t(cond\n\t\t\t\t\t\t[(and (not (null? (cdr lst))) (null? (cddr lst)))\n\t\t\t\t\t\t\t\" and \"]\n\t\t\t\t\t\t[(null? (cdr lst)) \"\"]\n\t\t\t\t\t\t[else \", \"])\n\t\t\t\t\t(make-format (cdr lst))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289324,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration sec)\n  (if (= sec 0) \"now\"\n    (let* ([times (let split-times ([sec sec]\n                               [ratio '(60 60 24 365)])\n                   (let* ([this (car ratio)]\n                          [rest (quotient sec this)]\n                          [next (cdr ratio)])\n                     (cons\n                       (remainder sec this)\n                       (if (null? next) `(,rest) (split-times rest next)))))]\n           [strs (for\/list ([time (reverse times)]\n                            [name '(\"year\" \"day\" \"hour\" \"minute\" \"second\")]\n                            #:unless (= time 0))\n                   (format \"~a ~a~a\" time name (if (= time 1) \"\" \"s\")))])\n      (string-join strs \", \" #:before-last \" and \"))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289325,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration sec)\n  (if (= sec 0) \"now\"\n    (let ([times (let fmtlist ([sec sec]\n                               [ratio '(60 60 24 365)]\n                               [names '(\"second\" \"minute\" \"hour\" \"day\")])\n                   (define (fmt-time tm name) (format \"~a ~a~a\" tm name (if (= tm 1) \"\" \"s\")))\n                   (let* ([inv (car ratio)]\n                          [this (remainder sec inv)]\n                          [more (cdr ratio)]\n                          [rest (quotient sec inv)]\n                          [next (if (null? more)\n                                  (if (= rest 0) '() `(,(fmt-time rest \"year\")))\n                                  (fmtlist rest more (cdr names)))])\n                     (if (= this 0) next\n                       (cons (fmt-time this (car names)) next))))])\n      (let ([last (car times)] [rest (cdr times)])\n        (if (null? rest) last\n          (format \"~a and ~a\" (string-join (reverse rest) \", \") last))))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289326,"user_id":544,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration seconds)\n  (if (= seconds 0)\n      \"now\"\n      (string-join\n       (for\/list ([time-part (y-d-h-m-s seconds)]\n                  [time-descriptor-singular (list \"year\" \"day\" \"hour\" \"minute\" \"second\")]                                                                  \n                  [time-descriptor-plural (list \"years\" \"days\" \"hours\" \"minutes\" \"seconds\")]\n                  #:unless (= time-part 0))\n         (if (= time-part 1)\n             (string-join (list (number->string time-part) time-descriptor-singular))\n             (string-join (list (number->string time-part) time-descriptor-plural))))\n       \", \" #:before-last \" and \")))\n\n; generate a list of time parts to parse later\n(define (y-d-h-m-s seconds)\n  (let* ([y (quotient seconds (* 365 24 60 60))]\n         [d (quotient (modulo seconds (* 365 24 60 60)) (* 24 60 60))]\n         [h (quotient (modulo seconds (* 24 60 60)) (* 60 60))]\n         [m (quotient (modulo seconds (* 60 60)) (* 60))]\n         [s (modulo seconds (* 60))])\n    (list y d h m s)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289327,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration seconds)\n  (local (;1. produce list of values (as strings)\n          ;   for all time intervals e.g.\n          ;  '(\"3\"   \"1\"    \"4\"    \"1\"      \"5\")\n          ;   years  days  hours  minutes  seconds\n          (define values\n            (local ((define (helper n acc period base)\n                      (cond\n                        [(zero? n) acc]\n                        [else\n                         (call-with-values\n                          (lambda () (quotient\/remainder n base))\n                          (lambda (quot rem)\n                            (helper quot\n                                    (cons (number->string rem) acc)\n                                    (add1 period)                     \n                                    (cond\n                                      [(< period 1) 60]\n                                      [(< period 2) 24]\n                                      [(< period 3) 365]\n                                      [else n]))))])))\n              (helper seconds '() 0 60)))\n          \n          ; 2. add names of time intervals e.g\n          ;    '(\"3 years\" \"1 day\" \"4 hours\" \"1 minute\" \"5 seconds\")\n          ;    remove all periods with \"0\" value\n          \n          ;String String -> String\n          ;given string representation of a number n\n          ;and a name of time interval t (second,minute,hour,day,year)\n          ;concatanate those 2 strings makeing plural form of\n          ;interval name where needed\n          (define (singular\/plural n t)\n            (if (string=? n \"1\")\n                (string-append n \" \" t)\n                (string-append n \" \" t \"s\")))\n\n          (define names (drop '(\"year\" \"day\" \"hour\" \"minute\" \"second\") (- 5 (length values))))          \n          (define values-with-names\n            (filter-map (lambda (n t) (and (not (string=? n \"0\")) (singular\/plural n t))) values names))\n\n          ; 3. produce final string,\n          ;    speparate values with \",\" and \"and\"\n          (define output\n            (if (zero? seconds)\n                \"now\"\n                (local ((define (concat-all in out)\n                          (cond\n                            [(empty? in) out]\n                            [(empty? (rest in)) (string-append out \" and \" (first in))]\n                            [else (concat-all (rest in) (string-append out \", \" (first in)))])))\n                  (concat-all (rest values-with-names) (first values-with-names))))))\n    output))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289328,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration seconds)\n\n  (define units\n    '((second .  60)\n      (minute .  60)\n      (hour   .  24)\n      (day    . 365)\n      (year   .   0)))\n\n  (define (n-unit-to-string n unit-cell)\n    (let* ([suffix (if (> n 1) \"s\" \"\")]\n           [unit-symbol (car unit-cell)]\n           [unit-str (symbol->string unit-symbol)]\n           [units-str (string-append unit-str suffix)])\n      (string-join (list (number->string n)\n                         units-str))))\n\n  (define (to-unit-list-aux n units acc)\n    (if (zero? n)\n        acc\n        (let*-values ([(u-head) (car units)]\n                      [(u-tail) (cdr units)]\n                      [(n-rest n-here) (if (null? u-tail)\n                                           (values 0 n)\n                                           (quotient\/remainder n (cdr u-head)))]\n                      [(new-acc) (if (zero? n-here)\n                                     acc\n                                     (cons (n-unit-to-string n-here u-head) acc))])\n          (to-unit-list-aux n-rest u-tail new-acc))))\n\n  (define (concat-result times)\n    (match times\n      [(list) \"now\"]\n      [(list a) a]\n      [(list a b) (string-append a \" and \" b)]\n      [(cons head tail) (string-append head \", \" (concat-result tail))]))\n\n  (concat-result (to-unit-list-aux seconds units '())))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289329,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration seconds)\n  (define singular identity)\n  (define (plural e) (string-append e \"s\"))\n  (define (format-time time name)\n    ((if (= time 1) singular plural)\n     (format \"~a ~a\" time name)))\n\n  (define divisors #(31536000 86400 3600 60 1))\n  (define names #(\"year\" \"day\" \"hour\" \"minute\" \"second\"))\n\n  (define time-list\n    (for\/fold ([result '()]\n               [remain seconds]\n               #:result result)\n              ([d (in-vector divisors)]\n               [n (in-vector names)]\n               #:break (zero? remain))\n      (define-values (q r) (quotient\/remainder remain d))\n      (values\n        (if (zero? q) result\n            (cons (format-time q n) result))\n        r)))\n\n  (match time-list\n    ['() \"now\"]\n    [(list x) x]\n    [(list x xs ...)\n     (string-append\n       (string-join (reverse xs) \", \")\n       \" and \"\n       x)]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289330,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n;; duration: (List years days hours minutes seconds)\n(define bases '(60 60 24 365))\n(define names '(\"year\" \"day\" \"hour\" \"minute\" \"second\"))\n\n(define (format_duration seconds)\n  (cond\n    [(zero? seconds) \"now\"] ; special case\n    [else (show-duration (seconds->duration seconds))]))\n\n(define (seconds->duration seconds)\n  (for\/fold ([time seconds] [acc '()]\n             #:result (cons time acc))\n            ([base (in-list bases)])\n    (define-values (q r) (quotient\/remainder time base))\n    (values q (cons r acc))))\n\n(define (show-duration duration)\n  (define parts\n    (for\/list ([num (in-list duration)]\n               [name (in-list names)]\n               #:unless (zero? num))\n      (if (= num 1)\n          (format \"1 ~a\" name)\n          (format \"~a ~as\" num name))))\n  (string-join parts \", \" #:before-last \" and \"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289331,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n; descomp-time :: int -> List int\n(define (descomp-time time)\n\t(let* ([sec\/year\t(* 365 24 60 60)]\n\t\t   [sec\/day\t\t(* 24 60 60)]\n\t\t   [sec\/hour\t(* 60 60)]\n\t\t   [sec\/min \t60]\n\t\t   [years\t\t(quotient time sec\/year)]\n\t\t   [rest-days\t(remainder time sec\/year)]\n\t\t   [days\t\t(quotient rest-days sec\/day)]\n\t\t   [rest-hours\t(remainder rest-days sec\/day)]\n\t\t   [hours\t\t(quotient rest-hours sec\/hour)]\n\t\t   [rest-minutes (remainder rest-hours sec\/hour)]\n\t\t   [minutes\t\t(quotient rest-minutes sec\/min)]\n\t\t   [seconds\t\t(remainder rest-minutes sec\/min)])\n\t\t(list years days hours minutes seconds)))\n\n; combine-lists :: int -> string -> string\n(define (combine-lists number category)\n    (cond [(= number 0) \"\"]\n          [(= number 1) (string-append (number->string number) \" \" category)]\n          [else         (string-append (number->string number) \" \" category \"s\")]))\n\n; combine-strings :: List string -> string\n(define (combine-strings string-list)\n\t(let loop ([str-lst string-list]\n\t\t\t   [final-str \"\"])\n\t\t(cond [(null? str-lst) \"now\"]\n          [(= (length str-lst) 1) (string-append final-str (car str-lst))]\n\t\t\t    [(= (length str-lst) 2) (loop (cdr str-lst) (string-append final-str (car str-lst) \" and \"))]\n\t\t\t    [else\t\t\t\t\t  (loop (cdr str-lst) (string-append final-str (car str-lst) \", \"))])))\n\n; not-empty-string? :: string -> bool\n(define (not-empty-string? str)\n\t(not (eq? str \"\")))\n\n; format_duration :: int -> string\n(define (format_duration seconds)\n    (let* ([time-list       (descomp-time seconds)]\n           [categories-list (list \"year\" \"day\" \"hour\" \"minute\" \"second\")]\n           [string-list     (filter not-empty-string? (map combine-lists time-list categories-list))])\n        (combine-strings string-list)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289332,"user_id":null,"body":"#lang racket\n(provide format_duration)\n\n(define (format_duration seconds)\n  (if\n   (= seconds 0)\n   \"now\"\n   (build-string (filter non-empty-string? (get-all seconds)))))\n\n(define (get-duration div qty str)\n  (\u03bb (tot)\n    (let\n        ([val (modulo (floor (\/ tot div)) qty)])\n      (case val\n        ([0] \"\")\n        ([1] (~a val \" \" str))\n        (else (~a val \" \" str \"s\"))))))\n\n(define get-seconds\n  (get-duration 1 60 \"second\"))\n\n(define get-minutes\n  (get-duration 60 60 \"minute\"))\n\n(define get-hours\n  (get-duration 3600 24 \"hour\"))\n\n(define get-days\n  (get-duration 86400 365 \"day\"))\n\n(define get-years\n  (get-duration 31536000 1000 \"year\"))\n\n(define (get-all time)\n  (filter\n   non-empty-string?\n   (list\n    (get-years time)\n    (get-days time)\n    (get-hours time)\n    (get-minutes time)\n    (get-seconds time))))\n\n(define (build-string strs)\n  (case (length strs)\n    ([0] \"\")\n    ([1] (~a (first strs)))\n    ([2] (~a (first strs) \" and \" (second strs)))\n    (else (~a (first strs) \", \" (build-string (cdr strs))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"52b7ed099cdc285c300001cd":[{"id":289333,"user_id":527,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (sum_of_intervals intervals)\n  (define sorted-intervals (sort intervals < #:key first))\n  (for*\/fold ([sum 0]\n              [max-e (caar sorted-intervals)]\n              #:result sum)\n             ([i sorted-intervals]\n              [b (in-value (first i))]\n              [e (in-value (second i))]\n              [b1 (in-value (max b max-e))]\n              [e1 (in-value (max e max-e))])\n    (values (+ sum (- e1 b1)) e1)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289334,"user_id":null,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (sum_of_intervals lst)\n  (set-count\n    (for*\/set ([p (in-list lst)]\n               [i (in-range (car p) (cadr p))])\n      i)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289335,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide sum_of_intervals)\n\n\n;; (List (List Number Number)) -> Integer\n;; given a list of intervals, return the sum of all the interval lengths.\n;; - overlapping intervals are counted only once\n;; ASSUME:\n;; - intervals are represented by a pair of numbers\n;; - the first number is always less than the second\n\n;; Best conceivable runtime: O(n)\n;; Actual runtime: ?\n\n;; idea: first compare the pairs of intervals merging the overlapping ones, then\n;; sum up lengths of intervals in the resulting list.\n(define (sum_of_intervals lst)\n (apply + (map int-length (merge-overlapping lst))))\n\n(module+ test\n  (check-equal? (sum_of_intervals (list (list -22 -9) (list -52 -8) (list -5 24) (list -12 84))) 136)\n  (check-equal? (sum_of_intervals (list (list -19 7) (list -14 8) (list -2 46) (list -10 -1))) 65)\n  (check-equal? (sum_of_intervals (list (list -56 11) (list -37 23) (list -42 50) (list -40 -20))) 106)\n  (check-equal? (sum_of_intervals (list (list -54 -25) (list -54 35) (list -10 46) (list -50 -18))) 100))\n\n\n;; (List (List Number Number)) -> (List (List Number Number))\n;; merge overlapping intervals, if any\n;; idea: sort first\n(define (merge-overlapping lst)\n  (define (loop accum lst)\n    (cond\n      [(empty? lst) accum]\n      [(= (length lst) 1) (append accum lst)]\n      [(if (overlap? (first lst) (second lst))\n           (loop accum (cons (merge-two (first lst) (second lst)) (rest (rest lst))))\n           (loop (append accum `(,(first lst))) (rest lst)))]))\n  (loop '() (sort lst < #:key car)))\n     \n(module+ test\n  (check-equal? (merge-overlapping '((1 4) (7 10) (3 5))) '((1 5) (7 10))))\n\n\n;; (List Number Number) (List Number Number) -> Boolean\n;; given two intervals, return #t if they overlap, #f otherwise\n(define (overlap? i1 i2)\n  (or\n   (and (<= (int-start i1) (int-start i2))\n        (> (int-end i1) (int-start i2)))\n   (and (<= (int-start i2) (int-start i1))\n        (> (int-end i2) (int-start i1)))))\n\n(module+ test\n  (check-equal? (overlap? '(1 4) '(3 5)) #t)\n  (check-equal? (overlap? '(3 5) '(1 4)) #t)\n  (check-equal? (overlap? '(3 5) '(7 10)) #f)\n  (check-equal? (overlap? '(1 4) '(1 4)) #t)\n  (check-equal? (overlap? '(3 7) '(3 7)) #t))\n\n\n;; (List Number Number) (List Number Number) -> (List Number Number)\n;; merge two overlapping intervals\n(define (merge-two i1 i2)\n  `(,(argmin identity (list (int-start i1) (int-start i2)))\n    ,(argmax identity (list (int-end i1) (int-end i2)))))\n\n(module+ test\n  (check-equal? (merge-two '(1 4) '(3 5)) '(1 5)))\n\n\n;; utils\n\n\n;; (List Number Number) -> Number\n;; return the start of the interval\n(define (int-start i)\n  (first i))\n\n\n;; (List Number Number) -> Number\n;; return the start of the interval\n(define (int-end i)\n  (second i))\n\n;; (List Number Number) -> Number\n;; return the length of the given interval\n(define (int-length i)\n  (- (int-end i) (int-start i)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289336,"user_id":53,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (sum_of_intervals lst)\n  (length (remove-duplicates (flatten (for*\/list \n    ([e lst]\n     [i (in-range (first e) (second e))])\n    i)))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289337,"user_id":null,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (sum_of_intervals lst)\n  (define (rem-overlap l)\n    (cond [(null? l) '()]\n          [(and (not (null? (cdr l))) (< (caadr l) (cadar l)))\n           (rem-overlap (cons (list (caar l) (max (cadar l) (cadadr l)))\n                              (cddr l)))]\n          [else (cons (car l) (rem-overlap (cdr l)))]))\n  (let ([s (sort lst (lambda (x y) (< (car x) (car y))))])\n    (apply + (map (lambda (x) (- (cadr x) (car x))) (rem-overlap s))))\n)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289338,"user_id":544,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (sum_of_intervals lst)\n  (length (remove-duplicates (flatten (map (\u03bb (interval) (range (car interval) (cadr interval))) lst)))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289339,"user_id":null,"body":"\n#lang racket\n(provide sum_of_intervals)\n\n;; Get a set of all the integers in a clopen interval [a, ) represented as '(a b).\n(define (interval->set interval)\n  (list->set (range (car interval)\n                    (cadr interval))))\n\n;; Convert intervals into sets, then get the union of those sets\n(define (interval-union . intervals)\n  (cond [(empty? intervals) (set)]\n        [(= 1 (length intervals)) (list->set (first intervals))]\n        [else (apply set-union (map interval->set\n                                    intervals))]))\n\n;; Sum the lengths of a list of intervals\n(define (sum_of_intervals lst)\n  (set-count (apply interval-union lst)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289340,"user_id":null,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (sum_of_intervals intervals)\n  (let* ([sorted (sort intervals interval<?)]\n         [joined (join-intervals sorted)])\n    (apply + (map interval-length joined))))\n\n(define (interval<? a b)\n  (match-define (list a-low a-high) a)\n  (match-define (list b-low b-high) b)\n  (or (< a-low b-low)\n      (and (= a-low b-low)\n           (< a-high b-high))))\n\n(define (join-intervals intervals)\n  (match intervals\n    [(list _) intervals]\n    [(list (list fst-low fst-high) (list snd-low snd-high) more ...)\n     #:when (<= fst-low snd-low fst-high)\n     (define joined (list fst-low (max fst-high snd-high)))\n     (join-intervals (cons joined more))]\n    [(list fst more ...)\n     (cons fst (join-intervals more))]))\n\n(define (interval-length interval)\n  (match-define (list low high) interval)\n  (- high low))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289341,"user_id":null,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (start iv) (car iv))\n(define (end iv) (cadr iv))\n\n(define (sum-rec ivs span-start span-end)\n  (cond ((null? ivs) (- span-end span-start))\n        ((< (end (first ivs)) span-end)\n         (sum-rec (rest ivs)\n                  span-start\n                  span-end))\n        ((> (start (first ivs)) span-end)\n         (+ (- span-end span-start)\n            (sum_of_intervals ivs)))\n        (else\n         (sum-rec (rest ivs)\n                  span-start\n                  (end (first ivs))))))\n\n(define (sum_of_intervals intervals)\n  (if (null? intervals)\n      0\n      (let ((ivs (sort intervals < #:key start)))\n        (apply sum-rec (rest ivs) (first ivs)))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289342,"user_id":null,"body":"#lang racket\n(provide sum_of_intervals)\n\n(define (first list) (car list))\n(define (rest list) (cdr list))\n(define (start iv) (car iv))\n(define (end iv) (cadr iv))\n\n(define (sum-rec ivs span-start span-end)\n  (cond ((null? ivs) (- span-end span-start))\n        ((< (end (first ivs)) span-end)\n         (sum-rec (rest ivs)\n                  span-start\n                  span-end))\n        ((> (start (first ivs)) span-end)\n         (+ (- span-end span-start)\n            (sum_of_intervals ivs)))\n        (else\n         (sum-rec (rest ivs)\n                  span-start\n                  (end (first ivs))))))\n\n(define (sum_of_intervals intervals)\n  (if (null? intervals)\n      0\n      (let ((ivs (sort intervals < #:key car)))\n        (sum-rec (rest ivs) (start (first ivs)) (end (first ivs))))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"52f677797c461daaf7000740":[{"id":289343,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution lst)\n  (* (length lst)\n     (foldl gcd 0 lst))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289344,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution lst)\n  (* (length lst)\n     (apply gcd lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289345,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution lst)\n  (define (reduce proc accu seq)\n    (if (null? seq)\n        accu\n        (reduce proc (proc accu (first seq)) (rest seq))))\n  (* (reduce gcd (first lst) (rest lst)) (length lst))\n)\n\n;(define (gcd a b)\n;  (if (= 0 b)\n;      a\n;      (gcd b (modulo a b))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289346,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution lst)\n  ; your code goes here\n  (* (length lst) (apply gcd lst))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289347,"user_id":53,"body":"#lang racket\n(provide solution)\n\n(define (gcd a b) (if (zero? b) a (gcd b (modulo a b))))\n(define (solution lst) (* (length lst) (foldl gcd (first lst) lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289348,"user_id":null,"body":"#lang racket\n(provide solution)\n\n\n(define (solution lst)\n  (* (length lst) (foldl gcd (car lst) (cdr lst))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289349,"user_id":null,"body":"#lang racket\/base\n\n(provide solution)\n\n(define (solution xs) (* (length xs) (apply gcd xs)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289350,"user_id":null,"body":"#lang racket\n(provide solution)\n\n; [List-of Number] -> Number\n; Given an array X of positive integers, \n; its elements are to be transformed by running the following \n; operation on them as many times as required:\n; if X[i] > X[j] then X[i] = X[i] - X[j]\n; when no more transformations are possible, return its sum\n(define (solution lst)\n  (local (;[List-of Number] Number -> Number\n          ;1. given list of integers lst and minumum value in this list min,\n          ;   subtract min from all numbers greater the min.\n          ;2. then find a new minimum and repeat step 1 & 2\n          ;   untill all numbers are equal\n          (define (helper lst min)\n            (let* ([out (subtract-min\/all-items min lst)]\n                  [min-out (find-min out)]\n                  [max-out (find-max out)])\n              (if (= max-out min-out)\n                  (sum-items out)\n                  (helper out min-out))))\n                \n          ;[List-of Number] -> Number\n          (define (find-min l)\n            (argmin identity l))\n\n          ;[List-of NUmber] -> Number\n          (define (find-max l)\n            (argmax identity l))\n        \n          ;Number [List-of Number] -> Number\n          ;given number min and a list of numbers l,\n          ;subtract min from all numbers greater then min\n          (define (subtract-min\/all-items min l)\n            (map (lambda (a) (if (> a min) (a-min a min) a)) l))\n          \n          ;Number Number -> Number\n          ;given numbers a and b (a>b)\n          ;keep subtracting b from a \n          ;until 0 < (a - n*b) <= b\n          (define (a-min a b)\n            (if (= 0 (remainder a b))\n                (- a (* b (sub1 (quotient a b))))\n                (- a (* b (quotient a b)))))\n\n          ;[list-of Number] -> Number\n          (define (sum-items l)\n            (foldr + 0 l)))   \n    (helper lst (find-min lst))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289351,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n\n(define solution\n  (\u03bb (lst)\n    (define merge\n      (\u03bb (num-1 num-2)\n        (cond [(= num-1 num-2) num-1]\n              [(zero? num-2) num-1]\n              [(zero? num-1) num-2]\n              [(> num-1 num-2)\n               (merge (remainder num-1 num-2) num-2)]\n              [(< num-1 num-2)\n               (merge num-1 (remainder num-2 num-1))])))\n\n    (define solution-item\n      (\u03bb (lst)\n        (let loop ([next-lst '()]\n                   [rest-lst lst])\n          (cond [(null? rest-lst)\n                 (if (= 1 (length next-lst))\n                     next-lst\n                     (solution-item next-lst))]\n                [(null? (cdr rest-lst))\n                 (solution-item (cons (car rest-lst) next-lst))]\n                [else\n                 (loop (cons (merge (car rest-lst) (cadr rest-lst))\n                             next-lst)\n                       (cddr rest-lst))]))))\n\n    (cond [(= 0 (length lst)) 0]\n          [(= 1 (length lst)) (car lst)]\n          [else (* (length lst)\n                   (car (solution-item lst)))])))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289352,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst)\n  (let([len (length lst)]\n       [g (apply gcd lst)])\n    (* len g)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"53d40c1e2f13e331fc000c26":[{"id":289353,"user_id":null,"body":"#lang racket\n(provide fib)\n\n(define (fib n)\n  (if (< n 0)\n      (if (even? n)\n          (neg (fib-iter 1 0 0 1 n +))\n          (fib-iter 1 0 0 1 n +))\n      (fib-iter 1 0 0 1 n -)))\n\n(define (square x) (* x x))\n\n(define (fib-iter a b p q count op)\n  (cond ((= count 0) b)\n        ((even? count)\n         (fib-iter a\n                   b\n                   (+ (square p) (square q)) \n                   (+ (* 2 p q) (square q))\n                   (\/ count 2)\n                   op))\n        (else (fib-iter (+ (* b q) (* a q) (* a p))\n                        (+ (* b p) (* a q))\n                        p q\n                        (op count 1)\n                        op))))\n\n\n(define (neg x)\n  (- 0 x))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289354,"user_id":53,"body":"#lang racket\n(provide fib)\n\n(define (fib n)\n  (define (aux n)\n    (cond\n       [(= 0 n) (cons 0 1)]\n       [(= 1 n) (cons 1 1)]\n       [else (let* ([xs (aux (quotient n 2))]\n                    [a (car xs)]\n                    [b (cdr xs)]\n                    [x (* a (- (* b 2) a))]\n                    [y (+ (* b b) (* a a))])\n                (cond\n                    [(even? n) (cons x y)]\n                    [else (cons y (+ y x))]))]))\n  (cond\n     [(>= n 0) (car (aux n))]\n     [(even? n) (-(car (aux (* n -1))))]\n     [else (car (aux (* n -1)))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289355,"user_id":null,"body":"#lang racket\n(provide fib)\n(define (fib n)\n  (if (< n 0) \n    (if (bitwise-bit-set? n 0) (fibp (- n)) (- (fibp (- n)))) \n    (fibp n)))\n(define (fibp n) (fib_matrix 1 1 1 0 0 1 n))\n(define (fib_matrix a b c d fc fd n)\n  (if (> n 0)\n    (let ([ma (+ (* a a) (* b c))] [mb (+ (* a b) (* b d))] \n      [mc (+ (* a c) (* c d))] [md (+ (* b c) (* d d))] [mn (arithmetic-shift n -1)])  \n      (if (bitwise-bit-set? n 0) \n        (fib_matrix ma mb mc md (+ (* a fc) (* c fd)) (+ (* b fc) (* d fd)) mn)\n        (fib_matrix ma mb mc md fc fd mn)))\n    fc))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289356,"user_id":null,"body":"#lang racket\n(provide fib)\n\n(define (fib n)\n  (define (fib-iter a b p q count)\n    (cond [(= count 0) b]\n          [(= 0 (modulo count 2))\n           (fib-iter a b (+ (* p p) (* q q))\n                     (+ (* 2 p q) (* q q)) (floor (\/ count 2)))]\n          [else (fib-iter (+ (* b q) (* a q) (* a p))\n                          (+ (* b p) (* a q))\n                          p q (- count 1))]))\n  (let ([res (fib-iter 1 0 0 1 (abs n))])\n    (if (and (< n 0) (= 0 (modulo n 2)))\n        (* res -1)\n        res))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289357,"user_id":null,"body":"#lang typed\/racket #:with-refinements\n\n(provide fib)\n\n(define-type Base (Refine [base : Positive-Integer] (> base 1)))\n(define-predicate base? Base)\n\n(define-type 2x2Matrix (Listof Integer))\n\n(: list-digits (-> Natural Base (Listof Natural)))\n(define (list-digits n base)\n    (: digits-loop (-> Natural (Listof Natural) (Listof Natural)))\n    (define (digits-loop n lst)\n        (let-values ([(q r) (quotient\/remainder n base)])\n          (if (= q 0)\n              (cons r lst)\n              (digits-loop q (cons r lst)))))\n    (digits-loop n '()))\n\n(define 2x2-zero : 2x2Matrix\n  '(0 0\n    0 0))\n\n(define 2x2-id : 2x2Matrix\n  '(1 0\n    0 1))\n\n(: 2x2-mat-+ (-> 2x2Matrix 2x2Matrix 2x2Matrix))\n(define (2x2-mat-+ mat-a mat-b)\n    (map + mat-a mat-b))\n\n(: 2x2-mat-* (-> 2x2Matrix 2x2Matrix 2x2Matrix))\n(define (2x2-mat-* mat-a mat-b)\n    (list (+ (* (first mat-a) (first mat-b))\n             (* (second mat-a) (third mat-b)))\n          (+ (* (first mat-a) (second mat-b))\n             (* (second mat-a) (fourth mat-b)))\n          (+ (* (third mat-a) (first mat-b))\n             (* (fourth mat-a) (third mat-b)))\n          (+ (* (third mat-a) (second mat-b))\n             (* (fourth mat-a) (fourth mat-b)))))\n\n(: 2x2-mat-sqr (-> 2x2Matrix 2x2Matrix))\n(define (2x2-mat-sqr mat)\n    (2x2-mat-* mat mat))\n\n(: 2x2-mat-exp (-> 2x2Matrix Natural 2x2Matrix))\n(define (2x2-mat-exp mat exp)\n  (: exp-loop (-> (Listof Natural) 2x2Matrix 2x2Matrix))\n  (define (exp-loop digits acc)\n    (cond [(null? digits) acc]\n          [(zero? (car digits)) (exp-loop (cdr digits) (2x2-mat-sqr acc))]\n          [else (exp-loop (cdr digits) (2x2-mat-* (2x2-mat-sqr acc) mat))]))\n  (let ([digits (list-digits exp 2)])\n    (println (~v digits))\n    (exp-loop digits 2x2-id)))\n\n(define fib-pos-mat : 2x2Matrix\n  '(1 1 1 0))\n\n(define fib-neg-mat : 2x2Matrix\n  '(-1 1 1 0))\n\n(: fib (-> Integer Integer))\n(define (fib n)\n    (cond [(zero? n) 0]\n          [(positive? n) (car (2x2-mat-exp fib-pos-mat (sub1 n)))]\n          [else (car (2x2-mat-exp fib-neg-mat (sub1 (abs n))))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289358,"user_id":null,"body":"#lang racket\n(provide fib)\n\n(define (make-matrix a b c d)\n  (cons (cons a b) (cons c d))\n)\n\n(define (get-ind m i j)\n  (if (= i 0)\n     (if (= j 0) (car (car m)) (cdr (car m)))\n     (if (= j 0) (car (cdr m)) (cdr (cdr m)))\n  )\n)\n\n(define (matrix-mul a b)\n    (make-matrix\n      (+ (* (get-ind a 0 0) (get-ind b 0 0)) (* (get-ind a 0 1) (get-ind b 1 0)))\n      (+ (* (get-ind a 0 0) (get-ind b 0 1)) (* (get-ind a 0 1) (get-ind b 1 1)))\n      (+ (* (get-ind a 1 0) (get-ind b 0 0)) (* (get-ind a 1 1) (get-ind b 1 0)))\n      (+ (* (get-ind a 1 0) (get-ind b 0 1)) (* (get-ind a 1 1) (get-ind b 1 1)))\n    )\n)\n\n(define (matrix-square m)\n  (matrix-mul m m)\n)\n\n(define (matrix-pow m n)\n  (if (= n 0)\n      (make-matrix 1 0 0 1)\n      (if (even? n)\n          (matrix-square (matrix-pow m (\/ n 2)))\n          (matrix-mul m  (matrix-square (matrix-pow m (\/ (- n 1) 2))))\n      )\n  )\n)\n\n(define (fib n)\n  (if (>= n 0)\n    (get-ind (matrix-pow (make-matrix 1 1 1 0) n) 0 1)\n    (if (even? n)\n        (- (fib (- n)))\n        (fib (- n))\n    )\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289359,"user_id":null,"body":"#lang racket\n(provide fib)\n\n(define (mmul x y)\n  (let ([a (first x)]\n        [b (second x)]\n        [c (first y)]\n        [d (second y)])\n    (let ([bd (* b d)])\n      (list (+ (* a c) bd)\n            (+ (* a d) (* b c) bd)))))\n\n(define (msqr x)\n  (let ([a (first x)]\n        [b (second x)])\n    (let ([ab (* a b)]\n          [b2 (sqr b)])\n      (list (+ (sqr a) b2)\n            (+ ab ab b2)))))\n\n(define (mpow x n)\n  (cond [(= n 1) x]\n        [(even? n)\n         (mpow (msqr x) (quotient n 2))]\n        [else\n         (mmul x (mpow (msqr x) (quotient n 2)))]))\n\n(define (fib n)\n  (cond [(zero? n) 0]\n        [(> n 0) (fibpos n)]\n        [(even? n) (- (fibpos (- n)))]\n        [else (fibpos (- n))]))\n\n(define (fibpos n)\n  (second (mpow (list 0 1) n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289360,"user_id":null,"body":"#lang racket\n(provide fib)\n\n(define (fib n)\n  (define (fib-iter a b p q count) \n    (cond ((= count 0) b) \n          ((even? count) \n           (fib-iter a b (+ (* p p) (* q q)) (+ (* 2 p q) (* q q)) \n                     (\/ count 2))) \n          (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (sub1 count))))) \n  ((if (or (>= n 0) (odd? n)) + -) (fib-iter 1 0 0 1 (abs n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289361,"user_id":null,"body":"#lang racket\n\n(provide fib)\n\n;; Integer -> Integer\n;; return n-th Fibonacci number. `n` can be negative.\n(define (fib n)\n  (if (< n 0)\n      (fib-iter 1 0 0 1 n add1)\n      (fib-iter 1 0 0 1 n sub1)))\n\n(define (fib-iter a b p q count inc)\n  (cond\n    [(zero? count) b]\n    [(and (even? count) (negative? count))\n     (let ([f (fib-iter a\n                        b\n                        (+ (* p p) (* q q))\n                        (+ (* 2 q p) (* q q))\n                        (\/ count 2)\n                        inc)])\n       (if (negative? f) f (- f)))]\n    [(and (even? count) (positive? count))\n     (fib-iter a\n               b\n               (+ (* p p) (* q q))\n               (+ (* 2 q p) (* q q))\n               (\/ count 2)\n               inc)]\n    [(and (odd? count) (negative? count))\n     (let ([f (fib-iter (+ (* b q)\n                           (* a q)\n                           (* a p))\n                        (+ (* b p)\n                           (* a q))\n                        p\n                        q\n                        (inc count)\n                        inc)])\n       (if (negative? f) (- f) f))]\n    [else (fib-iter (+ (* b q)\n                       (* a q)\n                       (* a p))\n                    (+ (* b p)\n                       (* a q))\n                    p\n                    q\n                    (inc count)\n                    inc)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289362,"user_id":544,"body":"#lang racket\n(provide fib)\n\n; if we extend the Fibonacci numbers backwards, since F_1 = 1 and F_0 = 0,\n; then F_-1 would have to be 1 so that F_-1 + F_0 = F_1 -> 1 + 0 = 1,\n; and F_-2 would be -1; F_-2 + F_-1 = F_0 -> -1 + 1 = 0; \n; F_-3 = 2, F_-4 = -3, and so on; \n; so we see that the odd negative Fibonacci numbers are positive,\n; and the even ones are negative, but the absolute values are the same\n(define (fib n) \n  (cond [(n . < . 0) (* (expt -1 (+ (abs n) 1)) (fib-iterative 1 0 0 1 (abs n)))]\n        [else (fib-iterative 1 0 0 1 n)]))\n \n; all credit goes to SICP and a bunch of pen-and-paper matrix multiplication\n(define (fib-iterative a b c d iter)\n  (cond [(= iter 0) b]\n         ; multiplying I by the transformation matrix T = ((1 0)(1 1)) n times\n         ; generates the nth and (n-1)th Fibonacci numbers in the right column\n         ; so, we calculate the relevant parts of I x T^n by repeated squaring,\n         ; then doing one more multiplication if n is odd\n        [(even? iter) (fib-iterative a\n                                     b\n                                     (+ (* c c) (* d d))\n                                     (+ (* d d) (* 2 c d))\n                                     (\/ iter 2))]\n        [else (fib-iterative (+ (* b d) (* a d) (* a c))\n                             (+ (* b c) (* a d))\n                             c\n                             d\n                             (- iter 1))]))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54b72c16cd7f5154e9000457":[{"id":289363,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")            ; holds the data structure MORSE-CODE for you\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (define codes (string-split morse-code #px\" {1,2}\"))\n  (apply string-append\n         (for\/list ([code codes])\n           (if (string=? code \"\")\n               \" \"\n               (hash-ref MORSE-CODE code)))))\n\n(define (decode-bits bits)\n  (define trimmed (string-trim bits \"0\"))\n  (define groups (group-bits (string->list trimmed)))\n  (apply string-append\n         (for\/list ([g (normalize groups)])\n           (define c (car g))\n           (define count (cdr g))\n           (cond [(and (char=? c #\\1) (= count 1)) \".\"]\n                 [(char=? c #\\1) \"-\"]\n                 [(and (char=? c #\\0) (= count 1)) \"\"]\n                 [(and (char=? c #\\0) (<= count 3)) \" \"]\n                 [else \"   \"]))))\n\n(define (group-bits bits)\n  (cond [(null? bits) null]\n        [else\n         (define b (first bits))\n         (define-values (chunk rest-bits)\n           (splitf-at (rest bits) (lambda (x) (char=? x b))))\n         (cons (cons b (add1 (length chunk))) (group-bits rest-bits))]))\n\n(define (normalize groups)\n  (define unit-len\n    (for\/fold ([min-len #f])\n              ([g groups])\n      (define len (cdr g))\n      (if (or (not min-len) (< len min-len))\n          len\n          min-len)))\n  (for\/list ([g groups])\n    (cons (car g) (quotient (cdr g) unit-len))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289364,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")            ; holds the data structure MORSE-CODE for you\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (define codes (string-split morse-code #px\" {1,2}\"))\n  (string-join\n   (for\/list ([code codes])\n     (if (string=? code \"\")\n         \" \"\n         (hash-ref MORSE-CODE code)))\n   \"\"))\n\n(define (decode-bits bits)\n  (define trimmed (string-trim bits \"0\"))\n  (define groups (group-bits (string->list trimmed)))\n  (string-join\n   (for\/list ([g (normalize groups)])\n     (define c (car g))\n     (define count (cdr g))\n     (cond [(and (char=? c #\\1) (= count 1)) \".\"]\n           [(char=? c #\\1) \"-\"]\n           [(and (char=? c #\\0) (= count 1)) \"\"]\n           [(and (char=? c #\\0) (<= count 3)) \" \"]\n           [else \"   \"]))\n   \"\"))\n\n(define (group-bits bits)\n  (cond [(null? bits) null]\n        [else\n         (define b (first bits))\n         (define-values (chunk rest-bits)\n           (splitf-at (rest bits) (lambda (x) (char=? x b))))\n         (cons (cons b (add1 (length chunk))) (group-bits rest-bits))]))\n\n(define (normalize groups)\n  (define unit-len\n    (for\/fold ([min-len #f])\n              ([g groups])\n      (define len (cdr g))\n      (if (or (not min-len) (< len min-len))\n          len\n          min-len)))\n  (for\/list ([g groups])\n    (cons (car g) (quotient (cdr g) unit-len))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289365,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")            ; holds the data structure MORSE-CODE for you\n(provide decode-morse decode-bits)\n\n(define translation-table\n  #hash(((#\\1 . 1) . \".\")\n        ((#\\1 . 2) . \"-\") ; what the ...\n        ((#\\1 . 3) . \"-\")\n        ((#\\0 . 3) . \" \")\n        ((#\\0 . 7) . \"   \")))\n\n(define (group l)\n  (let loop ([l (cdr l)] [c 1] [prev (car l)])\n    (if (null? l)\n        (list (cons prev c))\n        (let ([fst (car l)] [rst (cdr l)])\n          (if (eq? prev fst)\n              (loop rst (add1 c) prev)\n              (cons (cons prev c) (loop rst 1 fst)))))))\n\n(define (decode-bits b)\n  (define raw (group (string->list (string-trim b #rx\"0\"))))\n  (define time-unit (cdr (argmin cdr raw)))\n  (define (normalize g)\n    (cons (car g) (\/ (cdr g) time-unit)))\n  (define formed-signal\n    (map (\u03bb (g) (hash-ref translation-table (normalize g) \"\")) raw)) \n  (apply string-append formed-signal))\n\n(define (decode-morse code)\n  (define l (map string-split (string-split code \"   \")))\n  (string-join\n    (for\/list ([w (in-list l)])\n      (apply string-append\n        (for\/list ([c (in-list w)])\n          (hash-ref MORSE-CODE c))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289366,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (define (char char-code) (hash-ref MORSE-CODE char-code))\n  (define (word word-code) (string-join (map char word-code) \"\"))\n  (string-join (map word morse-code)))\n\n(define (decode-bits bits)\n  (define (list-min lst) (foldl min (car lst) (cdr lst)))\n  (define (char-codes bit-word) (map char-code (string-split bit-word \"000\")))\n  (define (char-code bit-char) (string-join (map dot-dash (string-split bit-char \"0\")) \"\"))\n  (define (dot-dash bit-unit) (if (equal? bit-unit \"1\") \".\" \"-\"))\n  (define scans (regexp-match* #rx\"0+|1+\" (string-trim bits #rx\"0+\")))\n  (define (unit scan) (substring scan 0 (\/ (string-length scan) rate)))\n  (define rate (list-min (map string-length scans)))\n  (map char-codes (string-split (string-join (map unit scans) \"\") \"0000000\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289367,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (define (char char-code) (hash-ref MORSE-CODE char-code))\n  (define (word word-code) (string-join (map char word-code) \"\"))\n  (string-join (map word morse-code)))\n\n(define (decode-bits bits)\n  (define (list-min lst) (foldl min (car lst) (cdr lst)))\n  (define (char-codes bit-word) (map char-code (string-split bit-word \"000\")))\n  (define (char-code bit-char) (string-join (map dot-dash (string-split bit-char \"0\")) \"\"))\n  (define (dot-dash bit-code) (if (equal? bit-code \"1\") \".\" \"-\"))\n  (define scans (regexp-match* #rx\"0+|1+\" (string-trim bits #rx\"0+\")))\n  (define (unit scan) (substring scan 0 (\/ (string-length scan) rate)))\n  (define rate (list-min (map string-length scans)))\n  (map char-codes (string-split (string-join (map unit scans) \"\") \"0000000\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289368,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (define (char char-code) (hash-ref MORSE-CODE char-code))\n  (define (word word-code) (string-join (map char word-code) \"\"))\n  (string-join (map word morse-code)))\n\n(define (decode-bits bits)\n  (define (list-min lst) (foldl min (car lst) (cdr lst)))\n  (define (char-codes bit-word) (map char-code (string-split bit-word \"000\")))\n  (define (char-code bit-char) (string-join (map dot-dash (string-split bit-char \"0\")) \"\"))\n  (define (dot-dash bit-code) (if (equal? bit-code \"1\") \".\" \"-\"))\n  (define scans (regexp-match* #rx\"0+|1+\" (string-trim bits #rx\"0+\")))\n  (define rate (list-min (map string-length scans)))\n  (define units (map (lambda (s) (substring s 0 (\/ (string-length s) rate))) scans))\n  (map char-codes (string-split (string-join units \"\") \"0000000\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289369,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (define (char char-code) (hash-ref MORSE-CODE char-code))\n  (define (word word-code) (string-join (map char word-code) \"\"))\n  (string-join (map word morse-code)))\n\n(define (decode-bits bits)\n  (define (list-min lst) (foldl min (car lst) (cdr lst)))\n  (define (codes bit-word) (map char-code (string-split bit-word \"000\")))\n  (define (char-code bit-char) (string-join (map dot-dash (string-split bit-char \"0\")) \"\"))\n  (define (dot-dash bit-code) (if (equal? bit-code \"1\") \".\" \"-\"))\n  (define scans (regexp-match* #rx\"0+|1+\" (string-trim bits #rx\"0+\")))\n  (define rate (list-min (map string-length scans)))\n  (define units (map (lambda (s) (substring s 0 (\/ (string-length s) rate))) scans))\n  (map codes (string-split (string-join units \"\") \"0000000\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289370,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (string-join (map (lambda (word-code) (string-join \n    (map (lambda (char-code) (hash-ref MORSE-CODE char-code)) word-code) \"\")) morse-code)))\n\n(define (decode-bits bits)\n  (define (list-min lst) (foldl min (car lst) (cdr lst)))\n  (define (codes bit-word) (map code (string-split bit-word \"000\")))\n  (define (code bit-char) (string-join \n    (map (lambda (s) (if (equal? s \"1\") \".\" \"-\")) (string-split bit-char \"0\")) \"\"))\n  (define scans (regexp-match* #rx\"0+|1+\" (string-trim bits #rx\"0+\")))\n  (define rate (list-min (map string-length scans)))\n  (define units (map (lambda (s) (substring s 0 (\/ (string-length s) rate))) scans))\n  (map codes (string-split (string-join units \"\") \"0000000\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289371,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-morse morse-code)\n  (string-join (map (lambda (word-code) (string-join \n    (map (lambda (char-code) (hash-ref MORSE-CODE char-code)) word-code) \"\")) morse-code)))\n\n(define (decode-bits bits)\n  (define (list-min lst) (foldl min (car lst) (cdr lst)))\n  (define (codes bit-word) (map code (string-split bit-word \"000\")))\n  (define (code bit-char) (string-join \n    (map (lambda (s) (if (= (string-length s) 1) \".\" \"-\")) (string-split bit-char \"0\")) \"\"))\n  (define scans (regexp-match* #rx\"0+|1+\" (string-trim bits #rx\"0+\")))\n  (define rate (list-min (map string-length scans)))\n  (define units (map (lambda (s) (substring s 0 (\/ (string-length s) rate))) scans))\n  (map codes (string-split (string-join units \"\") \"0000000\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289372,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse decode-bits)\n\n(define (decode-bits s)\n  (define bit-strings (regexp-match* #rx\"0+|1+\"\n                                   (regexp-replace* #rx\"^0*|0*$\" s \"\")))\n  (define dot (apply min (map string-length bit-strings)))\n  (define dash (* dot 3))\n\n  (define (dot-dashify bit-string)\n    (let ([bits-length (string-length bit-string)])\n    (cond\n      [(equal? (string-ref bit-string 0) #\\0)\n       (cond\n         [(<= bits-length dot) \"\"]\n         [(<= bits-length dash) \" \"]\n         [else \"   \"])]\n      [(<= bits-length dot) \".\"]\n      [else \"-\"])))\n      \n (string-join (map dot-dashify bit-strings) \"\"))\n\n\n(define (decode-morse morse-code)\n  (string-join\n   (map decode-morse-word (morse-code->morse-words morse-code))\n   \" \"))\n\n(define (decode-morse-word morse-word)\n  (string-join\n   (map morse-symbol->letter (morse-word->morse-symbols morse-word))\n   \"\"))\n  \n(define (morse-code->morse-words morse-code)\n  (string-split morse-code \"  \"))\n\n(define (morse-word->morse-symbols morse-word)\n  (string-split morse-word \" \"))\n\n(define (morse-symbol->letter morse-symbol)\n  (hash-ref MORSE-CODE morse-symbol))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54d496788776e49e6b00052f":[{"id":289373,"user_id":168,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (prime? n)\n  (for\/and ([d (in-range 2 (add1 (integer-sqrt n)))])\n    (not (zero? (remainder n d)))))\n\n(define (sum_of_divided lst)\n  (define b (apply max (map abs (cons 0 lst))))\n  (for\/fold ([r '()])\n            ([p (in-range b 1 -1)] #:when (prime? p))\n    (let ([t (filter (lambda (x) (zero? (remainder x p))) lst)])\n      (if (empty? t) r (cons (list p (apply + t)) r)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289374,"user_id":492,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (define (prime-factors number)\n    (let loop ([n (abs number)] [i 2])\n      (if (= n 1)\n          '()\n          (let-values ([(q r) (quotient\/remainder n i)])\n            (if (zero? r)\n                (cons i (loop q i))\n                (loop n (add1 i)))))))\n\n  (define (list-prime-factors lst)\n    (sort (remove-duplicates (flatten (map (\u03bb(x) (prime-factors x)) lst))) <))\n\n  (define (sum-for-one n lst)\n    (apply + (map (\u03bb(x) (if (= 0 (remainder x n)) x 0)) lst)))\n\n  (map (\u03bb(x) (list x (sum-for-one x lst))) (list-prime-factors lst)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289375,"user_id":53,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (is-prime? n)\n  (define (aux i)\n    (cond \n      [(> (* i i) n) #t]\n      [(or (zero? (modulo n i)) (zero? (modulo n (+ i 2)))) #f]\n      [else (aux (+ i 6))]))\n  (cond\n    [(or (zero? (modulo n 2)) (zero? (modulo n 3))) (< n 4)]\n    [else (aux 5)]))\n\n(define (next-prime n)\n  (if (is-prime? (add1 n))\n    (add1 n)\n    (next-prime (add1 n))))\n\n(define (sum_of_divided lst)\n  (let ([b (foldl max 0 (map abs lst))])\n    (define (aux p r)\n      (if (> p b)\n          r\n          (let* ([t (filter (\u03bb (e) (zero? (modulo e p))) lst)]\n                 [q (next-prime p)])\n            (if (null? t)\n                (aux q r)\n                (aux q (append r (list (list p (foldl + 0 t)))))))))\n    (aux 2 null)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289376,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (define ps (mcons 0 '()))\n  (define t ps)\n  (for*\/list\n    ([m\n      (let go ([n 2] [l (map abs lst)])\n        (if (null? l)\n            (mcdr ps)\n            (go\n              (+ n 1)\n              (if\n                (for\/or\n                  ([p (mcdr ps)])\n                  #:break (< n (sqr p))\n                  (= 0 (modulo n p)))\n                l\n                (begin\n                  (set-mcdr! t (mcons n '()))\n                  (set! t (mcdr t))\n                  (remq*\n                    '(1)\n                    (map\n                      (\u03bb (x)\n                         (let exhaust ([s x])\n                           (define q (\/ s n))\n                           (if (integer? q)\n                               (exhaust q)\n                               s)))\n                      l)))))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289377,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (define ps (mcons 0 '()))\n  (define t ps)\n  (for*\/list\n    ([m\n      (let go ([n 2] [l (map abs lst)])\n        (if (null? l)\n            (mcdr ps)\n            (go\n              (+ n 1)\n              (if\n                (for\/or\n                  ([p (mcdr ps)])\n                  #:break (< n (sqr p))\n                  (= 0 (modulo n p)))\n                l\n                (begin\n                  (set-mcdr! t (mcons n '()))\n                  (set! t (mcdr t))\n                  (append-map\n                    (\u03bb (x)\n                       (let exhaust ([s x])\n                         (if (= s 1)\n                             '()\n                             (let\n                               ([q (\/ s n)])\n                               (if (integer? q)\n                                   (exhaust q)\n                                   `(,s))))))\n                    l))))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289378,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (define ps (mcons 0 '()))\n  (define t ps)\n  (for*\/list\n    ([m\n      (let go ([n 2] [l (map abs lst)])\n        (if (null? l)\n            (mcdr ps)\n            (go\n              (+ n 1)\n              (if\n                (for\/or\n                  ([p (mcdr ps)])\n                  #:break (< n (sqr p))\n                  (= 0 (modulo n p)))\n                l\n                (begin\n                  (set-mcdr! t (mcons n '()))\n                  (set! t (mcdr t))\n                  (append-map\n                    (\u03bb (x)\n                       (let exhaust ([s x])\n                         (if (= s 1)\n                             '()\n                             ((\u03bb (q)\n                                 (if (integer? q)\n                                     (exhaust q)\n                                     `(,s)))\n                              (\/ s n)))))\n                    l))))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289379,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (define ps (mcons 0 '()))\n  (define t ps)\n  (for*\/list\n    ([m\n      (let go ([n 2] [l (map abs lst)])\n        (if (null? l)\n            (mcdr ps)\n            (go\n              (+ n 1)\n              (if\n                (for\/or\n                  ([p (mcdr ps)])\n                  #:break (< n (sqr p))\n                  (= 0 (modulo n p)))\n                l\n                (begin\n                  (set-mcdr! t (mcons n '()))\n                  (set! t (mcdr t))\n                  (append-map\n                    (\u03bb (x)\n                       (let exhaust ([s x])\n                         (define q (\/ s n))\n                         (cond\n                           [(= s 1) '()]\n                           [(integer? q) (exhaust q)]\n                           [#t `(,s)])))\n                    l))))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289380,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (for*\/list\n    ([m\n      (let go ([ps '()] [n 2] [l (map abs lst)])\n        (if (null? l)\n            ps\n            (if\n              (for\/or\n                ([p ps])\n                #:break (< n (sqr p))\n                (= 0 (modulo n p)))\n              (go ps (+ n 1) l)\n              (go\n                `(,@ps ,n)\n                (+ n 1)\n                (filter\n                  (curry < 1)\n                  (map\n                    (\u03bb (x)\n                       (let exhaust ([s x])\n                         (define q (\/ s n))\n                         (if (integer? q) (exhaust q) s)))\n                    l))))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289381,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (for*\/list\n    ([m\n      (let go ([ps '()] [n 2] [l (map abs lst)])\n        (define ((exhaust d) x)\n          (define q (\/ x d))\n          (if (integer? q)\n              ((exhaust d) q)\n              (if (> x 1) `(,x) '())))\n        (if (null? l)\n            ps\n            (if\n              (for\/or\n                ([p ps])\n                #:break (< n (sqr p))\n                (= 0 (modulo n p)))\n              (go ps (+ n 1) l)\n              (go\n                `(,@ps ,n)\n                (+ n 1)\n                (filter\n                  (curry < 1)\n                  (map\n                    (\u03bb (x)\n                       (let exhaust ([s x])\n                         (define q (\/ s n))\n                         (if (integer? q) (exhaust q) s)))\n                    l))))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289382,"user_id":null,"body":"#lang racket\n(provide sum_of_divided)\n\n(define (sum_of_divided lst)\n  (for*\/list\n    ([m\n      (let go ([ps '()] [n 2] [l (map abs lst)])\n        (define ((exhaust d) x)\n          (define q (\/ x d))\n          (if (integer? q)\n              ((exhaust d) q)\n              (if (> x 1) `(,x) '())))\n        (if (null? l)\n            ps\n            (if\n              (for\/or\n                ([p ps])\n                #:break (< n (sqr p))\n                (= 0 (modulo n p)))\n              (go ps (+ n 1) l)\n              (go\n                `(,@ps ,n)\n                (+ n 1)\n                (append-map (exhaust n) l)))))]\n     [s `(,(for\/fold\n       ([a '(0 #f)])\n       ([x lst])\n       (if (= 0 (modulo x m))\n           `(,(+ (car a) x) #t)\n           a)))]\n     #:when (cadr s))\n    `(,m ,(car s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54eb33e5bc1a25440d000891":[{"id":289383,"user_id":492,"body":"#lang racket\n(provide decompose)\n                               \n(define (decompose n)\n  (define (aux sum x ls)\n    (cond [(zero? sum) ls]\n          [(zero? x) '()]\n          [else\n           (let loop\n             ([n (if (> (* x x) sum) (exact-floor (sqrt sum)) x)])\n             (if (zero? n)\n                 '()\n                 (let ([possible (aux (- sum (* n n)) (sub1 n) (cons n ls))])\n                   (if (equal? '() possible)\n                       (loop (sub1 n))\n                       possible))))]))\n  (aux (* n n) (sub1 n) '()))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289384,"user_id":null,"body":"#lang racket\n(provide decompose)\n                               \n(define (decompose n)\n  (let ([res (g (* n n) (- n 1) '())])\n    (if (eq? res 'error)\n        '()\n        res))\n)\n\n(define (g num p lst)\n\t(cond [(= 0 num) lst]\n\t\t\t\t[(< p 1) 'error]\n\t\t\t\t[(< num (* p p)) (g num (- p 1) lst)]\n\t\t\t\t[else\n\t\t\t\t\t(let ([res (g (- num (* p p)) (- p 1) (cons p lst))])\n\t\t\t\t\t\t(if (eq? res 'error)\n\t\t\t\t\t\t\t\t(g num (- p 1) lst)\n\t\t\t\t\t\t\t\tres))])\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289385,"user_id":168,"body":"#lang racket\n(provide decompose)\n                               \n(define (decompose n)\n  (let loop ([acc '()] [v (sqr n)] [k (sub1 n)])\n    (cond\n      [(or (< v 0) (< k 0)) '()]\n      [(= v 0) acc]\n      [else\n         (let* ([v* (- v (sqr k))]\n                [t (exact-floor (sqrt (abs v*)))]\n                [sol (loop (cons k acc) v* (min (sub1 k) t))])\n           (if (null? sol) (loop acc v (sub1 k)) sol))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289386,"user_id":null,"body":"#lang racket\n(provide decompose)\n                               \n(define (decompose n)\n  (define (sum-of-squares n)\n    (\/ (* n (add1 n) (add1 (* 2 n))) 6))\n  (define (children sum n)\n    (for\/stream ([x (in-range (min (sub1 n) (exact-floor (sqrt sum))) 0 -1)]\n                 #:break (< (sum-of-squares x) sum))\n      x))\n  (define (dfs sum n)\n    (cond [(negative? sum) #f]\n          [(zero? sum) '()]\n          [else (for*\/first ([child (children sum n)]\n                             [rest (in-value (dfs (- sum (sqr child)) child))] #:when rest)\n                  (cons child rest))]))\n  (reverse (or (dfs (sqr n) n) '())))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289387,"user_id":null,"body":"#lang racket\n(provide decompose)\n\n(define (list-max l1 l2)\n  (let loop ([xs l1] [ys l2])\n    (cond [(null? xs) l2]\n          [(null? ys) l1]\n          [(< (first xs) (first ys)) l2]\n          [(> (first xs) (first ys)) l1]\n          [else (loop (rest xs) (rest ys))])))\n\n(define (decompose n)\n  (define xss\n    (let loop ([k (sub1 n)] [m (* n n)])\n      (cond\n        [(zero? m) '(())]\n        [(negative? m) '()]\n        [(zero? k) '()]\n        [else\n         (define xss (loop (sub1 k) (- m (* k k))))\n         (if (null? xss)\n             (loop (sub1 k) m)\n             (for\/list ([xs xss]) (cons k xs)))])))\n  (for\/fold ([result '()]\n             #:result (reverse result))\n            ([xs xss])\n    (list-max result xs)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289388,"user_id":null,"body":"#lang racket\n(provide decompose)\n                               \n(define (decompose n)\n  (let ([ans (find-squares-sum (sqr n) (sub1 n))])\n    (if ans \n        (reverse ans)\n        '())))\n\n(define (find-squares-sum target upper)\n  (cond\n    [(zero? upper) #f]\n    [else\n     (define remain (- target (sqr upper)))\n     (cond\n       [(= target (sqr upper)) (list upper)]\n       [(< target (sqr upper))\n        (find-squares-sum target (sub1 upper))]\n       [(> target (sqr upper))\n        (define try (find-squares-sum remain (sub1 upper)))\n        (if try\n            (cons upper try)\n            (find-squares-sum target (sub1 upper)))])]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289389,"user_id":null,"body":"#lang racket\n(provide decompose)\n\n(define (decompose n)\n  (helper (sub1 n) (* n n) empty))\n  \n(define (helper fst rst lst)\n  (if (zero? rst) lst\n      (if (or (< rst 0) (= fst 0)) empty (helper2 fst rst lst))))\n      \n(define (helper2 fst rst lst)\n  (define a1 (helper (sub1 fst) (- rst (* fst fst)) (append (list fst) lst)))\n  (if (empty? a1) (helper (sub1 fst) rst lst) a1))\n          \n      \n  \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289390,"user_id":null,"body":"#lang racket\n\n(provide decompose)\n\n\n(define decompose\n  (\u03bb (n)\n    (let loop ([ans (list (cons (sub1 n) (sub1 (* 2 n))))]\n               [num (- n 2)])\n      (let ([sum (cdar ans)])\n        (cond [(zero? sum) (map (\u03bb (p) (car p)) ans)]\n              [(= 1 (caar (last-pair ans)))\n               '()]\n              [(< sum 0)\n               (let ([fail-num (caar ans)])\n                 (loop (cons (cons (sub1 fail-num)\n                                   (+ sum (sub1 (* 2 fail-num))))\n                             (cdr ans))\n                       (- fail-num 2)))]\n              [(< num 1)\n               (let ([fail-num (caadr ans)]\n                     [fail-sum (cdadr ans)])\n                 (loop (cons (cons (sub1 fail-num)\n                                   (+ fail-sum (sub1 (* 2 fail-num))))\n                             (cddr ans))\n                       (- fail-num 2)))]\n              [else\n               (loop (cons (cons num (- sum (sqr num)))\n                           ans)\n                     (- num 1))])))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289391,"user_id":242,"body":"#lang racket\n(provide decompose)\n                               \n(define (accumulate proc start items)\n  (if\n    (null? items)\n    start\n    (if\n      (pair? items)\n      (accumulate proc (proc start (car items)) (cdr items))\n      (proc start items)\n    )\n  )\n)\n\n(define (map proc items)\n  (if\n    (null? items)\n    `()\n    (if\n      (pair? items)\n      (cons (proc (car items)) (map proc (cdr items)))\n      (list (proc items))\n    )\n  )\n)\n\n(define (enumerate start end)\n  (if\n    (= start end)\n    (list start)\n    (cons start (enumerate (+ 1 start) end))\n  )\n)\n\n(define (decomposeiternonnull r d acc)\n  (let\n    (\n      (s (decomposeiter (- r (sqr d)) (- d 1) (cons d acc)))\n    )\n    (if\n      (null? s)\n      (if\n        (= d 0)\n        `()\n        (decomposeiternonnull r (- d 1) acc)\n      )\n      s\n    )\n  )\n)\n\n(define (decomposeiter r d acc)\n  (cond\n    [(= r 0) acc]\n    [(<= d 0) `()]\n    [(> (sqr d) r) (decomposeiter r (- d 1) acc)]\n    [(and (pair? acc) (= d (car acc))) (decomposeiter r (- d 1) acc)]\n    [(decomposeiternonnull r d acc)]\n  )\n)\n\n(define (decompose n)\n  (if\n    (= n 1)\n    1\n    (decomposeiternonnull (sqr n) (- n 1) `())\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289392,"user_id":242,"body":"#lang racket\n(provide decompose)\n                               \n(define (accumulate proc start items)\n  (if\n    (null? items)\n    start\n    (if\n      (pair? items)\n      (accumulate proc (proc start (car items)) (cdr items))\n      (proc start items)\n    )\n  )\n)\n\n(define (map proc items)\n  (if\n    (null? items)\n    `()\n    (if\n      (pair? items)\n      (cons (proc (car items)) (map proc (cdr items)))\n      (list (proc items))\n    )\n  )\n)\n\n(define (enumerate start end)\n  (if\n    (= start end)\n    (list start)\n    (cons start (enumerate (+ 1 start) end))\n  )\n)\n\n(define (reverse lst)\n  (define (reverse-helper lst acc)\n    (if\n      (null? lst)\n      acc\n      (reverse-helper (cdr lst) (cons (car lst) acc))\n    )\n  )\n  (reverse-helper lst '())\n)\n\n(define (decomposeiternonnull r d acc)\n  (let\n    (\n      (s (decomposeiter (- r (sqr d)) (- d 1) (cons d acc)))\n    )\n    (if\n      (null? s)\n      (if\n        (= d 0)\n        `()\n        (decomposeiternonnull r (- d 1) acc)\n      )\n      s\n    )\n  )\n)\n\n(define (decomposeiter r d acc)\n  (cond\n    [(= r 0) acc]\n    [(<= d 0) `()]\n    [(> (sqr d) r) (decomposeiter r (- d 1) acc)]\n    [(and (pair? acc) (= d (car acc))) (decomposeiter r (- d 1) acc)]\n    [(decomposeiternonnull r d acc)]\n  )\n)\n\n(define (decompose n)\n  (if\n    (= n 1)\n    1\n    (decomposeiternonnull (sqr n) (- n 1) `())\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55b195a69a6cc409ba000053":[{"id":289393,"user_id":53,"body":"#lang racket\n\n(provide total-inc-dec)\n\n(define (total-inc-dec n)\n  (let loop ([a 1] [b 1] [i 0])\n    (cond\n     [(= n i) (- (+ a b) (add1 (* 10 n)))]\n     [else (loop (quotient (* a (+ 10 i)) (add1 i))\n                 (quotient (* b (+ 11 i)) (add1 i))\n                 (add1 i))])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289394,"user_id":168,"body":"#lang racket\n\n(provide total-inc-dec)\n\n(define (total-inc-dec n)\n  (for\/fold ([r (+ 20 n)] #:result (- (\/ r 10) (* 10 n) 1))\n            ([i (in-range 1 10)])\n    (\/ (* r (+ n i)) i)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289395,"user_id":527,"body":"#lang racket\n\n(provide total-inc-dec)\n\n(define (total-inc-dec x)\n  (- (* (\/ (for\/product ([i (in-range 1 10)]) (+ x i))\n           3628800)\n        (+ x 20))\n     (* 10 x)\n     1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289396,"user_id":242,"body":"#lang racket\n(provide total-inc-dec)\n\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (map proc items)\n  (cond\n    [(null? items) `()]\n    [(pair? items) (cons (proc (car items)) (map proc (cdr items)))]\n    [else (list (proc items))]\n  )\n)\n\n(define (enumerate start end)\n  (cond\n    [(= start end) (list start)]\n    [(< end start) `()]\n    [else (cons start (enumerate (+ 1 start) end))]\n  )\n)\n\n(define (total-inc-dec x)\n  (define (acc-sum-iter lst acc acc-lst)\n    (cond \n      [(null? lst) acc-lst]\n      [else (acc-sum-iter (cdr lst) (+ acc (car lst)) (cons (+ acc (car lst)) acc-lst))]\n    )\n  )\n  (define (total-inc-dec-iter inc-lst dec-lst currx)\n    (cond\n      [(= x currx) (+ (accumulate + 0 inc-lst) (accumulate + 0 dec-lst))]\n      [else (total-inc-dec-iter (acc-sum-iter (reverse inc-lst) 0 `()) (reverse (acc-sum-iter dec-lst 1 `())) (+ 1 currx))]\n    )\n  )\n  (let \n    (\n      (f (map (lambda (x) 1) (enumerate 1 10)))\n    )\n    (cond\n      [(= x 0) 1]\n      [else (- (total-inc-dec-iter f f 1) (* x 10))]\n    )\n  )\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55b7bb74a0256d4467000070":[{"id":289397,"user_id":null,"body":"#lang racket\n(provide proper_fractions)\n\n(define (count-proper_fractions factors)\n  (let loop ([prev -1]\n             [xs factors]\n             [res 1])\n    (if (empty? xs)\n        res\n        (loop (car xs)\n              (cdr xs)\n              (* res (- (car xs) (if (= prev (car xs)) 0 1)))))))\n\n(define (factors n)\n  (let loop ([i 2]\n             [n n]\n             [xs null])\n    (cond [(= n 1)\n           xs]\n          [(> (* i i) n)\n           (cons n xs)]\n          [(zero? (remainder n i))\n           (loop 2 (quotient n i) (cons i xs))]\n          [else\n           (loop (+ i 1) n xs)])))\n\n(define (proper_fractions n)\n  (if (= n 1)\n      0\n      (count-proper_fractions (factors n))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289398,"user_id":null,"body":"#lang racket\n(provide proper_fractions)\n\n(define (proper_fractions n)\n  (- n 1\n     (for\/sum ([g (in-combinations (prime-divisors n))])\n       (define cnt (length g))\n       (define sgn\n         (cond\n           [(zero? cnt) 0]\n           [(odd? cnt) 1]\n           [else -1]))\n       (* sgn (exact-floor (\/ (sub1 n) (apply * g)))))))\n\n\n(define (prime-divisors n)\n  (let loop ([n n]\n             [ps (primes (add1 (exact-floor (sqrt n))))]\n             [acc '()])\n    (cond\n      [(= n 1)\n       (remove-duplicates (reverse acc))]\n      [(null? ps)\n       (loop 1 '() (cons n acc))]\n      [else\n       (define p (car ps))\n       (if (mod? n p)\n           (loop (\/ n p) ps (cons p acc))\n           (loop n (cdr ps) acc))])))\n\n(define (primes n)\n  (define marks (make-vector n #t))\n\n  (for ([i (in-range 2 n)])\n    (for* ([j (in-naturals 2)]\n           [i*j (in-value (* i j))]\n           #:break (>= i*j n))\n      (vector-set! marks i*j #f)))\n\n  (for\/list ([i (in-range 2 n)]\n             #:when (vector-ref marks i))\n    i))\n\n(define (mod? n d)\n  (zero? (remainder n d)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289399,"user_id":53,"body":"#lang racket\n(provide proper_fractions)\n\n(define (cn n p)\n  (if (zero? (modulo n p))\n      (cn (quotient n p) p)\n      n))\n\n(define (frac n m p)\n  (if (zero? (modulo n p))\n      (list (cn n p) (- m (quotient m p)))\n      (list n m)))\n\n(define (walk n m p)\n  (if (> (* p p) n)\n      (if (> n 1)\n          (- m (quotient m n))\n          m)\n      (let ([ t (frac n m p)])\n        (walk (first t) (second t) (add1 p)))))\n\n(define (proper_fractions n)\n  (if (< n 2)\n      0\n      (walk n n 2)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289400,"user_id":null,"body":"#lang racket\n(provide proper_fractions)\n\n(define (cons-no-dup a l) (if (and (pair? l) (eq? a (car l))) l (cons a l)))\n(define (prime-divisors p)\n  (define (pd-iter n f accum)\n    (cond ((> (* f f) n) (cons-no-dup n accum))\n          ((zero? (modulo n f))\n           (pd-iter (quotient n f) f (cons-no-dup f accum)))\n          (else (pd-iter n (add1 f) accum))))\n  (pd-iter p 2 null))\n(define (proper_fractions n)\n  (apply * (cons n (map (\u03bb(x) (- 1 (\/ x))) (prime-divisors n)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289401,"user_id":null,"body":"#lang racket\n(provide proper_fractions)\n\n\n(define (prime-divisors p)\n  (define (pd-iter n f accum)\n    (cond ((> (* f f) n) (if (and (pair? accum) (eq? n (car accum))) accum (cons n accum)))\n          ((zero? (modulo n f))\n           (pd-iter (quotient n f) f\n                    (if (and (pair? accum) (eq? f (car accum))) accum (cons f accum))))\n          (else (pd-iter n (add1 f) accum))))\n  (pd-iter p 2 null))\n(define (proper_fractions n)\n  (apply * (cons n (map (\u03bb(x) (- 1 (\/ x))) (prime-divisors n)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289402,"user_id":null,"body":"#lang racket\n(provide proper_fractions)\n\n(define (prime-factors n [p 2] [lst '()])\n  \"Find unique prime factors of n\"\n  (define (cons* item lst)\n    \"cons if item is not the same as the first of lst\"\n    (cond\n     [(empty? lst) (cons item lst)]\n     [(= item (car lst)) lst]\n     [else (cons item lst)]))\n  (cond\n   [(= n 1) lst]\n   [(> (* p p) n) (cons* n lst)]\n   [(zero? (remainder n p)) (prime-factors (\/ n p) p (cons* p lst))]\n   [else (prime-factors n (add1 p) lst)]))\n\n(define (totient n)\n  \"Computes euler's totient function on n\"\n  (let loop\n      ([factors (prime-factors n)]\n       [ans n])\n    (if (empty? factors)\n        ans\n        (loop (cdr factors)\n              (* ans (- 1 (\/ 1 (car factors))))))))\n\n(define (proper_fractions n)\n  (if (= n 1)\n      0\n      (totient n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289403,"user_id":null,"body":"#lang racket\n\n(provide proper_fractions)\n\n;; Returns a list of the prime divisors of n.\n(define (prime-divisors n)\n  ;; Helper function continually divide a number by p until p no longer\n  ;; divides that number.\n  (define (reduce-loop p n0)\n    (if (= (remainder n0 p) 0)\n        (reduce-loop p (quotient n0 p))\n        n0))\n  ;; Helper function to loop over odd numbers, finding odd prime factors\n  ;; of n and adding them to the list.\n  (define (prime-divisors-loop p n0)\n    (if (> (* p p) n)\n        (if (> n0 1)\n            (list n0)\n            '())\n        (if (= (remainder n0 p) 0)\n            (cons p (prime-divisors-loop (+ 2 p) (reduce-loop p n0)))\n            (prime-divisors-loop (+ 2 p) n0))))\n  ;; Speed things up by checking if number is even.  If so, add 2 to\n  ;; the list of prime numbers.  Then the prime-divisors-loop only has\n  ;; to check odd numbers.\n  (if (even? n)\n      (cons 2 (prime-divisors-loop 3 (reduce-loop 2 n)))\n      (prime-divisors-loop 3 n)))\n\n;; Compute Euler's Totient, which is the count of positive integers\n;; up to a given integer n that are relatively prime to n.\n(define (phi n)\n  (foldl * n\n         (map (\u03bb (p) (- 1 (\/ 1 p))) (prime-divisors n))))\n\n;; The number of proper fractions is the same as Euler's Totient.\n;; (With the exception of n=1.)\n(define (proper_fractions n)\n  (if (= n 1)\n      0\n      (phi n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289404,"user_id":null,"body":"#lang racket\n(provide proper_fractions)\n\n(define (proper_fractions n)\n  (define result (if (> n 1) n 0))\n  (for ([p (in-naturals 2)]) #:break (> (* p p) n)\n    (when (zero? (remainder n p))\n      (set! result (- result (\/ result p)))\n      (do () ((not (zero? (remainder n p)))) (set! n (\/ n p)))))\n  (if (> n 1)\n      (- result (\/ result n))\n      result))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55cf3b567fc0e02b0b00000b":[{"id":289405,"user_id":492,"body":"#lang racket\n(provide part)\n\n(define (part n)\n  (define (parts-aux n m)\n    (if (= n m) (list (list m))\n        (if (< n m) (list)\n            (append (map \n                     (lambda (p) (cons m p)) (parts-aux (- n m) m))\n                    (parts-aux n (+ m 1))))))\n  (define (median ls)\n    (define sorted (list->vector ls))\n    (define count (vector-length sorted))\n    (\/ (+ (vector-ref sorted (floor (\/ (sub1 count) 2)))\n          (vector-ref sorted (floor (\/ count 2))))\n       2.0))\n    \n  (let* ([v (sort (remove-duplicates (map (lambda (x) (apply * x)) (parts-aux n 1))) <)]\n         [mean (\/ (apply + v) (length v))]\n         [md (median v)]\n         [rg (- (last v) (first v))])\n    (string-append \"Range: \" (~r rg #:precision 0) \" Average: \" (~r mean #:precision '(= 2)) \" Median: \" (~r md #:precision '(= 2)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289406,"user_id":null,"body":"#lang racket\n(provide part)\n\n(define-syntax-rule (define\/memo (id arg) body ...)\n  (define id\n    (let ([memo (make-hash)])\n      (lambda (arg)\n        (hash-ref! memo arg\n                   (lambda () body ...))))))\n\n(define\/memo (prod n)\n  (cond\n    [(= n 1) '(1)]\n    [else\n     (define acc (mutable-set n))\n     (for ([i (in-range 1 (+ (\/ n 2) 1))])\n       (for* ([a (prod i)]\n              [b (prod (- n i))])\n         (set-add! acc (* a b))))\n     (set->list acc)]))\n\n(define (part n)\n  (define res (sort (prod n) <))\n  (define len (length res))\n\n  (define range (- (last res) (first res)))\n  (define average (\/ (apply + res) len))\n  (define median\n    (if (odd? len)\n        (list-ref res (\/ (- len 1) 2))\n        (\/ (+ (list-ref res (- (\/ len 2) 1))\n              (list-ref res (\/ len 2))) 2)))\n\n  (format \"Range: ~a Average: ~a Median: ~a\"\n          range\n          (~r average #:precision '(= 2))\n          (~r median #:precision '(= 2))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289407,"user_id":168,"body":"#lang racket\n(provide part)\n\n(define (prod-k p d n k)\n  (cond\n    [(< n k) '()]\n    [(= k 1) (list (* p (+ n d)))]\n    [else (let ([p1 (prod-k (* p (add1 d)) d (sub1 n) (sub1 k))]\n                [p2 (prod-k p (add1 d) (- n k) k)])\n            (append p1 p2))]))\n\n(define (prod n)\n  (for\/fold ([r '()]) ([k (range 1 (add1 n))])\n    (append (prod-k 1 0 n k) r)))\n\n(define (part n)\n  (let* ([p (set->list (list->set (prod n)))]\n         [a (sort p <)]\n         [n (length a)]\n         [range (- (last a) (first a))]\n         [mean (\/ (apply + a) n)]\n         [median (\/ (+ (list-ref a (quotient n 2)) (list-ref a (quotient (sub1 n) 2))) 2)])\n    (format \"Range: ~a Average: ~a Median: ~a\" \n            range (real->decimal-string mean) (real->decimal-string median))))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289408,"user_id":null,"body":"#lang racket\n(provide part)\n\n(define prods\n  (let ([cache (make-hash '((0 . (1))))])\n    (lambda (n)\n      (cond [(hash-has-key? cache n) (hash-ref cache n)]\n            [else\n             (define products (mutable-set))\n             (for\/fold ([ps (set)])\n                       ([k (in-range 1 (add1 n))])\n               (for\/list ([p (prods (- n k))])\n                 (set-add! products (* k p))))\n             (define result (set->list products))\n             (hash-set! cache n result)\n             result]))))\n\n(define (range-of ps) (- (last ps) (first ps)))\n\n(define (average-of ps) (\/ (apply + ps) (length ps)))\n\n(define (median-of ps)\n  (define len (length ps))\n  (define mid (quotient len 2))\n  (cond [(odd? len) (list-ref ps mid)]\n        [else\n         (define v1 (list-ref ps (sub1 mid)))\n         (define v2 (list-ref ps mid))\n         (\/ (+ v1 v2) 2)]))\n\n(define (part n)\n  (define ps (sort (prods n) <))\n  (format \"Range: ~a Average: ~a Median: ~a\"\n          (range-of ps)\n          (~r (average-of ps) #:precision '(= 2))\n          (~r (median-of ps) #:precision '(= 2))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289409,"user_id":null,"body":"#lang racket\n(provide part)\n\n(define (part n)\n  (case n\n    [(1) \"Range: 0 Average: 1.00 Median: 1.00\"]\n    [(2) \"Range: 1 Average: 1.50 Median: 1.50\"]\n    [(3) \"Range: 2 Average: 2.00 Median: 2.00\"]\n    [(4) \"Range: 3 Average: 2.50 Median: 2.50\"]\n    [(5) \"Range: 5 Average: 3.50 Median: 3.50\"]\n    [(6) \"Range: 8 Average: 4.75 Median: 4.50\"]\n    [(7) \"Range: 11 Average: 6.09 Median: 6.00\"]\n    [(8) \"Range: 17 Average: 8.29 Median: 7.50\"]\n    [(9) \"Range: 26 Average: 11.17 Median: 9.50\"]\n    [(10) \"Range: 35 Average: 15.00 Median: 14.00\"]\n    [(11) \"Range: 53 Average: 19.69 Median: 16.00\"]\n    [(12) \"Range: 80 Average: 27.08 Median: 22.50\"]\n    [(13) \"Range: 107 Average: 35.07 Median: 27.00\"]\n    [(14) \"Range: 161 Average: 47.33 Median: 35.00\"]\n    [(15) \"Range: 242 Average: 63.91 Median: 45.00\"]\n    [(16) \"Range: 323 Average: 84.44 Median: 56.00\"]\n    [(17) \"Range: 485 Average: 112.66 Median: 73.50\"]\n    [(18) \"Range: 728 Average: 151.44 Median: 96.00\"]\n    [(19) \"Range: 971 Average: 199.34 Median: 118.50\"]\n    [(20) \"Range: 1457 Average: 268.11 Median: 152.00\"]\n    [(21) \"Range: 2186 Average: 358.10 Median: 197.00\"]\n    [(22) \"Range: 2915 Average: 475.46 Median: 245.00\"]\n    [(23) \"Range: 4373 Average: 633.44 Median: 315.00\"]\n    [(24) \"Range: 6560 Average: 846.79 Median: 390.00\"]\n    [(25) \"Range: 8747 Average: 1126.14 Median: 500.00\"]\n    [(26) \"Range: 13121 Average: 1500.90 Median: 625.00\"]\n    [(27) \"Range: 19682 Average: 2009.29 Median: 775.00\"]\n    [(28) \"Range: 26243 Average: 2669.98 Median: 980.00\"]\n    [(29) \"Range: 39365 Average: 3558.37 Median: 1224.50\"]\n    [(30) \"Range: 59048 Average: 4764.89 Median: 1538.00\"]\n    [(31) \"Range: 78731 Average: 6326.47 Median: 1920.00\"]\n    [(32) \"Range: 118097 Average: 8457.17 Median: 2420.00\"]\n    [(33) \"Range: 177146 Average: 11292.63 Median: 3024.00\"]\n    [(34) \"Range: 236195 Average: 15031.03 Median: 3761.50\"]\n    [(35) \"Range: 354293 Average: 20088.78 Median: 4704.00\"]\n    [(36) \"Range: 531440 Average: 26832.81 Median: 5865.00\"]\n    [(37) \"Range: 708587 Average: 35745.98 Median: 7371.00\"]\n    [(38) \"Range: 1062881 Average: 47763.72 Median: 9152.00\"]\n    [(39) \"Range: 1594322 Average: 63823.27 Median: 11475.00\"]\n    [(40) \"Range: 2125763 Average: 85158.49 Median: 14250.00\"]\n    [(41) \"Range: 3188645 Average: 113720.82 Median: 17745.00\"]\n    [(42) \"Range: 4782968 Average: 152184.15 Median: 21888.00\"]\n    [(43) \"Range: 6377291 Average: 202904.65 Median: 27262.50\"]\n    [(44) \"Range: 9565937 Average: 271332.21 Median: 33796.00\"]\n    [(45) \"Range: 14348906 Average: 363114.82 Median: 41947.50\"]\n    [(46) \"Range: 19131875 Average: 484712.39 Median: 51975.00\"]\n    [(47) \"Range: 28697813 Average: 648367.27 Median: 64260.00\"]\n    [(48) \"Range: 43046720 Average: 867970.08 Median: 79830.00\"]\n    [(49) \"Range: 57395627 Average: 1159398.98 Median: 98227.50\"]\n    [(50) \"Range: 86093441 Average: 1552316.81 Median: 120960.00\"]\n    [else \"\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289410,"user_id":null,"body":"#lang racket\n(provide part)\n\n(struct integer-partition (head sum product) #:transparent)\n\n(define (enumerate-partitions n)\n  ;; Create intial queue of partial partitions '((1) (2) (3) ...).\n  (define (create-init-queue n)\n    (map (\u03bb (x) (integer-partition  x x x)) (range 1 n)))\n  ;; Create initial list of complete partitions '((n)).\n  (define (create-init-partitions n)\n    (list (integer-partition n n n)))\n  ;; Create next set of possible partitions (partial\/complete).\n  (define (create-new-queue old-queue n)\n    (for*\/list ([i (range 1 (add1 n))]\n                [p old-queue]\n                #:when (and (<= (+ (integer-partition-sum p) i) n) (>= i (integer-partition-head p))))\n      (integer-partition i\n                         (+ i (integer-partition-sum p))\n                         (* i (integer-partition-product p)))))\n  ;; Recursively build partitions, keeping partial and complete partitions separate.\n  (define (enumerate-partitions-loop queue complete-partitions n)\n    (if (empty? queue)\n        complete-partitions\n        (let-values ([(new-partitions new-queue) (partition (\u03bb (p) (= n (integer-partition-sum p))) (create-new-queue queue n))])\n          (enumerate-partitions-loop new-queue (append new-partitions complete-partitions) n))))\n  ;; Return a list of integer partitions.  The integer partitions includes the paritition elements, sum, and product.\n  (enumerate-partitions-loop (create-init-queue n) (create-init-partitions n) n))\n\n;; Function to return range.\n(define (range-stat product-list)\n  (let ([min-product (apply min product-list)]\n        [max-product (apply max product-list)])\n    (- max-product min-product)))\n\n;; Function to return mean (average).\n(define (mean-stat product-list)\n  (\/ (apply + product-list) (length product-list)))\n\n;; Function to return median.\n(define (median-stat product-list)\n  (let* ([list-length (length product-list)]\n         [k (quotient list-length 2)])\n    (if (odd? list-length)\n        (list-ref product-list k)\n        (\/ (+ (list-ref product-list (sub1 k)) (list-ref product-list k)) 2))))\n\n\n(define (part n)\n  (let* ([product-list (remove-duplicates (sort (map integer-partition-product (enumerate-partitions n)) <))]\n         [product-range (~r (range-stat product-list))]\n         [product-mean (~r #:precision '(= 2) (mean-stat product-list))]\n         [product-median (~r #:precision '(= 2) (median-stat product-list))])\n    (format \"Range: ~a Average: ~a Median: ~a\" product-range product-mean product-median)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289411,"user_id":242,"body":"#lang racket\n(provide part)\n\n(define (accumulate proc start items)\n  (if\n    (null? items)\n    start\n    (if\n      (pair? items)\n      (accumulate proc (proc start (car items)) (cdr items))\n      (proc start items)\n    )\n  )\n)\n\n(define (map proc items)\n  (if\n    (null? items)\n    `()\n    (if\n      (pair? items)\n      (cons (proc (car items)) (map proc (cdr items)))\n      (list (proc items))\n    )\n  )\n)\n\n(define (enumerate start end)\n  (cond\n    [(= start end) (list start)]\n    [(< end start) `()]\n    [else (cons start (enumerate (+ 1 start) end))]\n  )\n)\n\n(define (merge l1 l2)\n  (cond\n    [(null? l1) l2]\n    [(null? l2) l1]\n    [else (cons (car l1) (cons (car l2) (merge (cdr l1) (cdr l2))))]\n  )\n)\n\n(define (partitions n)\n  (define (partitionsfrom n d acc)\n    (cond\n      [(= n 0) `()]\n      [(= d 0) `()]\n      [(< n d) `()]\n      [(= n d) (list acc)]\n      [(accumulate merge `() (map (lambda (x) (partitionsfrom (- n d) x (cons x acc))) (enumerate d (- n d))))]\n    )\n  )\n  (cond\n    [(= n 1) (list 1)]\n    [(= n 2) (list (list 2) (list 1 1))]\n    [else (accumulate merge (list (list n)) (map (lambda (x) (partitionsfrom n (- n x) (cons (- n x) `()))) (enumerate 1 (- n 1))))]\n  )\n)\n\n(define (removeduplicatessortedlst lst)\n  (define (removeduplicatessortedlstiter lst acc curr)\n    (cond\n      [(null? lst) acc]\n      [(= curr (car lst)) (removeduplicatessortedlstiter (cdr lst) acc curr)]\n      [else (removeduplicatessortedlstiter (cdr lst) (cons (car lst) acc) (car lst))]\n    )\n  )\n  (reverse (removeduplicatessortedlstiter lst `() (- (car lst) 1)))\n)\n\n(define (uniquepartitionproducts lst)\n  (removeduplicatessortedlst (sort (map (lambda (x) (accumulate * 1 x)) lst) <))\n)\n\n(define (mediansortedlst lst)\n  (define\n    (cdrn lst n)\n    (if\n      (= n 1)\n      lst\n      (cdrn (cdr lst) (- n 1))\n    )\n  )\n  (let\n    (\n      (l (length lst))\n    )\n    (cond\n      [(= l 1) (car lst)]\n      [(= l 2) (\/ (+ (car lst) (car (cdr lst))) 2)]\n      [(= l 3) (car (cdr lst))]\n      [(odd? l) (car (cdrn lst (+ 1 (quotient l 2))))]\n      [else (\/ (+ (car (cdrn lst (quotient l 2))) (car (cdrn lst (+ 1 (quotient l 2))))) 2)]\n    )\n  )\n)\n\n(define (rangesortedlst lst)\n  (define (getlastelem lst)\n    (if\n      (pair? lst)\n      (if\n        (pair? (cdr lst))\n        (getlastelem (cdr lst))\n        (car lst)\n      )\n      lst\n    )\n  )\n  (- (getlastelem lst) (car lst))\n)\n\n(define (averagesortedlst lst)\n  (\/ (accumulate + 0 lst) (length lst))\n)\n\n(define (part n)\n  (let\n    (\n      (lst (uniquepartitionproducts (partitions n)))\n    )\n    (~a \"Range: \" (rangesortedlst lst) \" Average: \" (~r (averagesortedlst lst) #:min-width 1 #:precision '(= 2)) \" Median: \" (~r (mediansortedlst lst) #:min-width 1 #:precision '(= 2)) )\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289412,"user_id":null,"body":"#lang racket\n(provide part)\n\n(define (part n)\n  \n  (define products\n      (remove-duplicates (sort (map (curry apply *) (partition n 1)) <)))\n  \n  (define count (length products))\n\n  (define range (number->string (- (last products) (first products))))\n\n  (define average \n    (real->decimal-string (\/ (apply + products) count) 2))\n\n  (define median\n    (real->decimal-string \n    (\/ (+ (list-ref products (floor (\/ (sub1 count) 2)))\n          (list-ref products (floor (\/ count 2))))\n       2)\n    2))\n  \n  (string-join (list \"Range:\" range \"Average:\" average \"Median:\" median)))\n\n  (define partition\n    (let ([cache (make-hash)])\n      (lambda args\n        (cond\n          [(hash-has-key? cache args) (hash-ref cache args)]\n          [else (let ([result (match args\n                             [(list n m)\n                              (cond \n                                [(= n m) (list (list m))]\n                                [(< n m) '()]\n                                [else (append (map (lambda (p) (cons m p))\n                                                   (partition (- n m) m))\n                                              (partition n (add1 m)))])])])\n                  (hash-set! cache args result)\n                  result)]))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289413,"user_id":null,"body":"#lang racket\n(provide part)\n\n(define (combine N K) (for*\/set ((n N) (k K)) (* n k)))\n\n(define (parts N)\n  (let ((P (make-vector (+ 1 N) (set)))\n        (limit (lambda (n) (+ 1 (quotient (+ (remainder n 2) n) 2)))))\n    (for ((n (in-range 1 (+ 1 N))))\n      (vector-set! P n (for\/fold ((R (set n)))\n                                 ((k (in-range 1 (limit n))))\n                                 (set-union R (combine (vector-ref P k)\n                                                       (vector-ref P (- n k)))))))\n    (list->vector (sort (set->list (vector-ref P N)) <))))\n\n(define (params P)\n  (let ((N (vector-length P)))\n    (values (- (vector-ref P (- N 1)) 1)\n            (\/ (foldl + 0 (vector->list P)) N)\n            (let ((n-half (quotient N 2)))\n              (if (odd? N)\n                (vector-ref P n-half)\n                (\/ (+ (vector-ref P n-half)\n                      (vector-ref P (- n-half 1)))\n                   2))))))\n\n(define (part n)\n  (let-values (((r a m) (params (parts n))))\n    (format \"Range: ~a Average: ~a Median: ~a\"\n            r\n            (~r a #:precision '(= 2))\n            (~r m #:precision '(= 2)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5629db57620258aa9d000014":[{"id":289414,"user_id":null,"body":"#lang racket\n(provide mix_strings)\n\n(define (is-letter? ch)\n  (and (char>=? ch #\\a)\n       (char<=? ch #\\z)))\n\n\n(define (add-letter lttr lst)\n  (cond [(empty? lst)\n         (list (list lttr 1))]\n        [(char=? lttr (first (first lst)))\n         (cons (list lttr (add1 (second (first lst)))) (rest lst))]\n        [else\n         (cons (first lst) (add-letter lttr (rest lst)))]))\n\n\n(define (not-single? pair)\n    (< 1 (second pair)))\n\n\n(define (get-letter-freq str)\n  (let loop ([lst (string->list str)]\n             [dst '()])\n    (cond [(empty? lst)\n           dst]\n          [(not (is-letter? (first lst)))\n           (loop (rest lst) dst)]\n          [else\n           (loop (rest lst) (add-letter (first lst) dst))])))\n\n\n(define (mark-pairs p mark)\n  (if (empty? p)\n      '()\n      (cons (list (first p) mark) (mark-pairs (rest p) mark))))\n\n\n(define (same-char? p1 p2)\n  (char=? (first (first p1)) (first (first p2))))\n\n\n(define (more-char? p1 p2)\n  (if (= (second (first p1)) (second (first p2)))\n      'l3\n      (> (second (first p1)) (second (first p2)))))\n#;(define (more-char? p1 p2)\n  (cond [(> (second (first p1)) (second (first p2)))\n         #t]\n        [(< (second (first p1)) (second (first p2)))\n         #f]\n        [else\n         'l3]))\n\n\n(define (fit-pair p p-lst)\n  (let loop ([lst p-lst])\n    (cond [(empty? lst)\n           (cons p '())]\n          [(same-char? p (first lst))\n           (let ([mc (more-char? p (first lst))])\n             (cond [(and (symbol? mc) (symbol=? mc 'l3))\n                    (cons (list (first p) 'l3) (rest lst))]\n                   [mc\n                    (cons p (rest lst))]\n                   [else\n                    lst]))]\n          [else\n           (cons (first lst) (loop (rest lst)))])))\n\n\n(define (merge-pairs p1 p2)\n  (let loop ([lst (mark-pairs p2 'l2)]\n             [dst (mark-pairs p1 'l1)])\n    (if (empty? lst)\n           dst\n           (loop (rest lst) (fit-pair (first lst) dst)))))\n\n\n(define (lst-pair? p1 p2)\n  (cond [(= (second (first p1)) (second (first p2)))\n         (if (string=? (symbol->string (second p1)) (symbol->string (second p2)))\n             ;; Unexplained: if 2 chars have same appearances, sort by 1, 2 and = before alphabetically.\n             (char>? (first (first p1)) (first (first p2)))\n             (string>? (symbol->string (second p1)) (symbol->string (second p2))))]\n        [(< (second (first p1)) (second (first p2)))\n         #t]\n        [else\n         #f]))\n\n\n(define (mk-string p)\n  (define separator (cond [(symbol=? (second p) 'l1) \"1\"]\n                          [(symbol=? (second p) 'l2) \"2\"]\n                          [else \"=\"]))\n  (format \"~a:~a\"\n          separator\n          (build-string (second (first p)) (lambda (x) (first (first p))))))\n\n\n(define (mix_strings s1 s2)\n  (define mp (merge-pairs (filter not-single? (get-letter-freq s1))\n                          (filter not-single? (get-letter-freq s2))))\n  (define sp (reverse (sort mp lst-pair?)))\n  ((lambda (lst)\n     (let loop ([l lst]\n                [dst \"\"])\n       (if (empty? l)\n           (if (string=? dst \"\")\n               dst\n               (substring dst 1 (string-length dst))) ;; This feels so lazy...\n           (loop (rest l) (format \"~a\/~a\" dst (mk-string (first l)))))))\n   sp))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289415,"user_id":null,"body":"#lang racket\n(provide mix_strings)\n(require rackunit)\n\n(define (anything-goes _) #t)\n\n;; String -> Histogram\n;; Creates a histogram of the elements in the sequence that:\n;; - satisfy (optional) predicate p, and\n;; - have been applied to (optional) transformation t.\n(define (make-histogram seq [predicate anything-goes] [transform identity])\n  (define h (make-hash))\n  (for ([i seq] #:when (predicate i))\n    (hash-update! h (transform i) add1 0))\n  h)\n\n(check-equal? (make-histogram \"Sassy!\")\n              (make-hash '((#\\S . 1) (#\\a . 1) (#\\s . 2) (#\\y . 1) (#\\! . 1))))\n(check-equal? (make-histogram \"Sassy!\" char-alphabetic?)\n              (make-hash '((#\\S . 1) (#\\a . 1) (#\\s . 2) (#\\y . 1))))\n(check-equal? (make-histogram \"Sassy!\" char-alphabetic? char-downcase)\n              (make-hash '((#\\a . 1) (#\\s . 3) (#\\y . 1))))\n\n;; [X] Int X -> [List-of X]\n;; Creates a list containing n copies of i\n(define (dupe n i)\n  (build-list (inexact->exact n) (lambda (_) i)))\n\n(check-equal? (dupe 0 \"a\") '())\n(check-equal? (dupe 5 'b) '(b b b b b))\n(check-equal? (dupe 3 2) '(2 2 2))\n(check-equal? (dupe 4.0 'a) '(a a a a))\n\n(define (make-substring key h1 h2)\n  (match (cons (hash-ref h1 key -Inf.0)\n               (hash-ref h2 key -Inf.0))\n    [(cons i i) #:when (i . > . 1)\n     (list 3 i (format \"=:~a\" (list->string (dupe i key))))]\n    [(cons i j) #:when (or (i . > . 1) (j . > . 1))\n     (let ([winner (if (i . > . j) 1 2)]\n           [maximum (max i j)])\n       (list winner maximum (format \"~a:~a\"\n                             winner\n                             (list->string (dupe maximum key)))))]\n    [_ (list 0 0 \"\")]))\n\n(define (mix_strings s1 s2)\n  (let* ([h1 (make-histogram s1 char-lower-case?)]\n         [h2 (make-histogram s2 char-lower-case?)]\n         [keys (append (hash-keys h1) (hash-keys h2))]\n         [keys (sort (remove-duplicates keys) char<?)]\n         [results (for\/list ([k keys]) (make-substring k h1 h2))]\n         [results (filter-not (lambda (triple) (zero? (second triple))) results)]\n         [results (sort results < #:key first)]\n         [results (sort results > #:key second)]\n         [strings (map third results)])\n (string-join strings \"\/\")))\n\n(check-equal?\n (mix_strings \"my&friend&Paul has heavy hats! &\" \"my friend John has many many friends &\")\n \"2:nnnnn\/1:aaaa\/1:hhh\/2:mmm\/2:yyy\/2:dd\/2:ff\/2:ii\/2:rr\/=:ee\/=:ss\")\n(check-equal?\n (mix_strings \"mmmmm m nnnnn y&friend&Paul has heavy hats! &\" \"my frie n d Joh n has ma n y ma n y frie n ds n&\")\n \"1:mmmmmm\/=:nnnnnn\/1:aaaa\/1:hhh\/2:yyy\/2:dd\/2:ff\/2:ii\/2:rr\/=:ee\/=:ss\")\n(check-equal? \n (mix_strings \"Are the kids at home? aaaaa fffff\" \"Yes they are here! aaaaa fffff\")\n \"=:aaaaaa\/2:eeeee\/=:fffff\/1:tt\/2:rr\/=:hh\")","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289416,"user_id":544,"body":"#lang racket\n(provide mix_strings)\n\n(define (mix_strings s1 s2)\n  (define list-s1 (make-letter-list s1 s2 \"1\"))\n  (define list-s2 (make-letter-list s2 s1 \"2\"))\n  (define winners\n    (for\/list ([c1 (in-list list-s1)]\n               [c2 (in-list list-s2)]\n               #:when (or ((second c1) . > . 1) ((second c2) . > . 1)))\n      (if (= (second c1) (second c2))\n          (cons (string-append\n                 \"=:\"\n                 (make-string (second c1) (first c1)))\n                (list (first c1) (second c1) \"=\"))\n          (let ([winning-list (argmax second (list c1 c2))])\n            (cons (string-append\n                   (third winning-list)\n                   \":\"\n                   (make-string (second winning-list) (first winning-list)))\n                  winning-list)))))\n  (string-join\n   (map (curry first) (sort (sort winners string<? #:key fourth) > #:key third)) \"\/\"))\n\n(define (make-letter-list s1 s2 id)\n  (define all-letters\n    (remove-duplicates (string->list (string-replace (string-append s1 s2) #rx\"[^a-z]\" \"\"))))\n  (sort (for\/list ([c (in-list all-letters)])\n          (list c (count (curry equal? c) (string->list s1)) id)) char<? #:key first))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289417,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide mix_strings)\n\n;; String String -> String\n;; compare two strings and visualize how different they are\n(define (mix_strings s1 s2)\n\n  (define (fmt num-char-count)\n    (match-let ([(list num char count) num-char-count])\n      (format \"~a:~a\" num (make-string count char))))\n\n  (define (srt num-char-counts)\n    (sort num-char-counts\n          (\u03bb (ncc1 ncc2)\n            (match-let ([(list num1 char1 count1) ncc1]\n                        [(list num2 char2 count2) ncc2])\n              (string<? (format \"~a~a~a\" (- (max count1 count2) count1) num1 char1)\n                        (format \"~a~a~a\" (- (max count1 count2) count2) num2 char2))))))\n  \n  (define counts1 (count-lower s1))\n  (define counts2 (count-lower s2))\n\n  (string-join\n   (map fmt\n        (srt\n         (filter (\u03bb (x) (> (third x) 1))\n                 (set->list (max-counts counts1 counts2)))))\n   \"\/\"))\n\n(module+ test\n  (check-equal? (mix_strings \"A aaaa bb cc\" \"& aaa bbb cc d\") \"1:aaaa\/2:bbb\/=:cc\"))\n\n\n;; String -> Hash(Char->Int)\n;; given a string, count lowercase letters in it\n(define (count-lower s)\n  (define count (make-hash))\n  (for ([c (in-string s)]\n        #:when (char-lower-case? c))\n    (hash-set! count c (add1 (hash-ref count c 0))))\n  count)\n\n(module+ test\n  (check-equal? (count-lower \"& aaa bbb cc d\")\n                (make-hash '((#\\a . 3) (#\\b . 3) (#\\c . 2) (#\\d . 1)))))\n\n\n;; Hash(Char->Int) Hash(Char->Int) -> (Settof (List (or\/c 1 2 =) Char Int>0)\n;; given letter counts for two strings, produce a list which shows in which\n;; string each character occurs the most, namely (which-string char count) tuples.\n(define (max-counts counts1 counts2)\n  (for\/set ([char (in-list (append (hash-keys counts1) (hash-keys counts2)))])\n    (let ([c1 (hash-ref counts1 char 0)]\n          [c2 (hash-ref counts2 char 0)])\n      (cond\n        [(> c1 c2) `(1 ,char ,c1)]\n        [(< c1 c2) `(2 ,char ,c2)]\n        [else `(= ,char ,c1)])))) \n\n(module+ test\n  (check-equal? (max-counts (hash #\\a 4 #\\b 2 #\\c 2) (hash #\\a 3 #\\b 3 #\\c 2 #\\d 1))\n                (set '(1 #\\a 4) '(2 #\\b 3) '(= #\\c 2) '(2 #\\d 1))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289418,"user_id":null,"body":"#lang racket\n(provide mix_strings)\n\n(define (mix_strings s1 s2)\n  (define (extract s)\n    (make-hash\n      (filter-map (\u03bb (g) (define len (length g))\n                         (and (> len 1)\n                              (cons (car g) len)))\n        (group-by values\n          (string->list\n            (regexp-replace* #rx\"[^a-z]\" s \"\"))))))\n  (define (form-string e)\n    (match-define (list pfx chr cnt) e)\n    (string-append pfx (make-string cnt chr)))\n  (define (sort-by-that-implicit-rule l)\n    (sort (sort (sort l char<? #:key cadr)\n                string<? #:key car)\n          > #:key caddr))\n  (let ([h1 (extract s1)]\n        [h2 (extract s2)])\n    (hash-for-each h1 (\u03bb (k v) (hash-ref! h2 k 0)))\n    (define mix_stringsed-counts\n      (for\/list ([(k v2) (in-hash h2)])\n        (define v1 (hash-ref h1 k 0))\n        (cond [(< v1 v2) (list \"2:\" k v2)]\n              [(> v1 v2) (list \"1:\" k v1)]\n              [else (list \"=:\" k v2)])))\n    (string-join\n      (map form-string\n        (sort-by-that-implicit-rule mix_stringsed-counts))\n      \"\/\")))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289419,"user_id":null,"body":"#lang racket\n(provide mix_strings)\n\n(define (group-chars str)\n  (for\/fold ([acc (hash)])\n            ([char (in-string str)]\n             #:when (and (char-alphabetic? char)\n                         (char-lower-case? char)))\n    (hash-update acc (char-downcase char) add1 0)))\n\n(define (count-union hash1 hash2)\n  (for*\/list ([ascii (in-range 97 123)] ; #\\a -> #\\z\n              [char (in-value (integer->char ascii))]\n              [count1 (in-value (hash-ref hash1 char 0))]\n              [count2 (in-value (hash-ref hash2 char 0))]\n              #:when (>= (max count1 count2) 2))\n    ;; (list <char> <count> <from>)\n    (list char\n          (max count1 count2)\n          (case (sgn (- count1 count2))\n            [(1) #\\1] [(-1) #\\2] [(0) #\\=]))))\n\n(define (print-union union)\n  (define (sorter c1 c2)\n    (or (> (second c1) (second c2))\n        (and (= (second c1) (second c2))\n             (char<? (third c1) (third c2)))))\n  \n  (define union\/sorted (sort union sorter))\n  \n  (string-join\n   (for\/list ([entity (in-list union\/sorted)])\n     (match-define (list char num from) entity)\n     (format \"~a:~a\" from (make-string num char)))\n   \"\/\"))\n\n(define (mix_strings str1 str2)\n  (print-union (count-union (group-chars str1)\n                            (group-chars str2))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289420,"user_id":null,"body":"#lang racket\n\n(provide mix_strings)\n\n\n(define mix_strings\n  (\u03bb (s1 s2)\n    ;; Example:\n    ;; 1:aaaaa\/1:bbbbb\/1:ccccc\/2:ddddd\/2:eeeee\/2:fffff\/=:xxxxx\/=:yyyyy\/=:zzzzz ...\n    ;; '([5 . ([1 . (a b c)]\n    ;;         [2 . (d e f)]\n    ;;         [3 . (x y z)])]\n    ;;   ...)\n    (define make-item\n      (\u03bb (amount . elements)\n        (cons amount elements)))\n\n    (define merge-chars\n      (\u03bb (chars-1 chars-2)\n        (cond [(null? chars-1) chars-2]\n              [(null? chars-2) chars-1]\n              [(char=? (car chars-1) (car chars-2))\n               (cons (car chars-1)\n                     (merge-chars (cdr chars-1) (cdr chars-2)))]\n              [(char<? (car chars-1) (car chars-2))\n               (cons (car chars-1)\n                     (merge-chars (cdr chars-1) chars-2))]\n              [(char<? (car chars-2) (car chars-1))\n               (cons (car chars-2)\n                     (merge-chars chars-1 (cdr chars-2)))]\n              [else '()])))\n\n    (define merge-elements\n      (\u03bb (eles-1 eles-2)\n        (cond [(null? eles-1) eles-2]\n              [(null? eles-2) eles-1]\n              [(= (caar eles-1) (caar eles-2))\n               (cons (cons (caar eles-1)\n                           (merge-chars (cdar eles-1)\n                                        (cdar eles-2)))\n                     (merge-elements (cdr eles-1) (cdr eles-2)))]\n              [(< (caar eles-1) (caar eles-2))\n               (cons (car eles-1)\n                     (merge-elements (cdr eles-1) eles-2))]\n              [(< (caar eles-2) (caar eles-1))\n               (cons (car eles-2)\n                     (merge-elements eles-1 (cdr eles-2)))]\n              [else '()])))\n\n    (define merge-items\n      (\u03bb (item-1 item-2)\n        (if (= (car item-1)\n               (car item-2))\n            (cons (car item-1)\n                  (merge-elements (cdr item-1)\n                                  (cdr item-2)))\n            (error 'merge-items \"the items doesn't have the same amount!\"))))\n\n    (define get-msg\n      (\u03bb (str)\n        (define msg (make-vector 26 0))\n\n        (for ([i str])\n          (when (and (char<=? i #\\z) (char>=? i #\\a))\n            (let ([pos (- (char->integer i) 97)])\n              (vector-set! msg pos\n                           (add1 (vector-ref msg pos))))))\n        msg))\n\n    (define merge\n      (\u03bb (msg-1 msg-2)\n        (define insert\n          (\u03bb (table item)\n            (cond [(or (null? table)\n                       (< (caar table) (car item)))\n                   (cons item table)]\n                  [(> (caar table) (car item))\n                   (cons (car table)\n                         (insert (cdr table) item))]\n                  [(= (caar table) (car item))\n                   (cons (merge-items (car table) item)\n                         (cdr table))]\n                  [else '()])))\n\n\n        (let loop ([pos 0] [table '()])\n          (cond [(> pos 25) table]\n                [(and (>= 1 (vector-ref msg-1 pos))\n                      (>= 1 (vector-ref msg-2 pos)))\n                 (loop (add1 pos) table)]\n                [(= (vector-ref msg-1 pos)\n                    (vector-ref msg-2 pos))\n                 (loop (add1 pos)\n                       (insert table\n                               (make-item (vector-ref msg-1 pos)\n                                          (cons 3 (list (integer->char (+ pos 97)))))))]\n                [(> (vector-ref msg-2 pos)\n                    (vector-ref msg-1 pos))\n                 (loop (add1 pos)\n                       (insert table (make-item (vector-ref msg-2 pos)\n                                                (cons 2 (list (integer->char (+ pos 97)))))))]\n                [(> (vector-ref msg-1 pos)\n                    (vector-ref msg-2 pos))\n                 (loop (add1 pos)\n                       (insert table (make-item (vector-ref msg-1 pos)\n                                                (cons 1 (list (integer->char (+ pos 97)))))))]\n                [else '()]))))\n\n    (define table->str\n      (\u03bb (table)\n        (define element->str\n          (\u03bb (ele amount)\n            (define num->char\n              (\u03bb (num)\n                (cond ([= num 3] #\\=)\n                      ([= num 2] #\\2)\n                      ([= num 1] #\\1)\n                      (else #\\0))))\n\n            (if (null? ele)\n                \"\"\n                (let ([id (num->char (car ele))])\n                  (let loop ([chars (cdr ele)]\n                             [ans \"\"])\n                    (if (null? chars)\n                        ans\n                        (loop (cdr chars)\n                              (string-append ans\n                                             (string #\\\/ id #\\:)\n                                             (make-string amount (car chars))))))))))\n\n        (define item->str\n          (\u03bb (item)\n            (let ([amount (car item)])\n              (let loop ([eles (cdr item)]\n                         [ans \"\"])\n                (if (null? eles)\n                    ans\n                    (loop (cdr eles)\n                          (string-append ans\n                                         (element->str (car eles) amount))))))))\n\n        (if (null? table)\n            \"\"\n            (string-append (item->str (car table))\n                           (table->str (cdr table))))))\n\n\n    (let* ([msg-1 (get-msg s1)]\n           [msg-2 (get-msg s2)]\n           [ans (table->str (merge msg-1 msg-2))])\n      (if (non-empty-string? ans)\n          (substring ans 1)\n          ans))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289421,"user_id":null,"body":"#lang racket\n(provide mix_strings)\n\n(struct mix_strings-group (frequency letter string) #:transparent)\n\n;; Transform the string into a list of mix_strings-groups, where each mix_strings-group\n;; is a struct containing the frequency of the letter, the letter, and\n;; the string of letters.\n(define (string->mix_strings-group-list  s)\n  (sort\n   (filter (\u03bb (g) (> (mix_strings-group-frequency g) 1))\n           (map (\u03bb (g) (mix_strings-group (length g) (first g) (list->string g)))\n                (group-by identity\n                          (filter char-lower-case?\n                                  (string->list s)))))\n   char<?\n   #:key mix_strings-group-letter))\n\n;; Iterate over the mix_strings groups, selecting mix_strings group for each letter\n;; with the greatest frequency, or indicating that both strings have\n;; the mix_strings group with the same frequency. Returns an list of pairs,\n;; where each pair is the \"1\",\"2\", or \"=\" string indicating from which\n;; mix_strings group the string is, along with the selected mix_strings group.\n(define (select-mix_strings-groups mix_strings-groups1 mix_strings-groups2 acc)\n  ;; (printf \"mix_strings group 1: ~a~n~nmix_strings group 2: ~a~n~nacc ~a~n~n****~n~n\" mix_strings-groups1 mix_strings-groups2 acc)\n  ;; With the two lists of mix_strings groups, there are the following cases:\n  (cond\n    ;; Both lists are empty, in which case return the accumulator.\n    [(and (empty? mix_strings-groups1) (empty? mix_strings-groups2))\n     acc]\n    ;; mix_strings groups 1 is empty but mix_strings groups 2 is not, in which case select the first mix_strings group\n    ;; from mix_strings groups 2 and recurse on the rest of mix_strings groups 2.\n    [(empty? mix_strings-groups1)\n     (select-mix_strings-groups mix_strings-groups1\n                        (rest mix_strings-groups2)\n                        (cons (cons \"2\" (first mix_strings-groups2)) acc))]\n    ;; mix_strings groups 2 is empty but mix_strings groups 1 is not, in which case select the first mix_strings group\n    ;; from mix_strings groups 1 and recurse on the rest of mix_strings groups 1.\n    [(empty? mix_strings-groups2)\n     (select-mix_strings-groups (rest mix_strings-groups1)\n                        mix_strings-groups2\n                        (cons (cons \"1\" (first mix_strings-groups1)) acc))]\n    ;; The first mix_strings group from mix_strings groups 2 has the lexicographically smaller letter, in which\n    ;; case you select the first mix_strings group from mix_strings groups 2 and recurse on the rest of mix_strings groups 2\n    ;; and all of mix_strings groups 1.\n    [(char<? (mix_strings-group-letter (first mix_strings-groups2)) (mix_strings-group-letter (first mix_strings-groups1)))\n     (select-mix_strings-groups mix_strings-groups1\n                        (rest mix_strings-groups2)\n                        (cons (cons \"2\" (first mix_strings-groups2)) acc))]\n    ;; The first mix_strings group from mix_strings groups 1 has the lexicographically smaller letter, in which\n    ;; case you select the first mix_strings group from mix_strings groups 1 and recurse on the rest of mix_strings groups 1\n    ;; and all of mix_strings groups 2.\n    [(char<? (mix_strings-group-letter (first mix_strings-groups1)) (mix_strings-group-letter (first mix_strings-groups2)))\n     (select-mix_strings-groups (rest mix_strings-groups1)\n                        mix_strings-groups2\n                        (cons (cons \"1\" (first mix_strings-groups1)) acc))]\n    ;; The first mix_strings group for each of the mix_stringsed groups has the same letter.\n    [(char=? (mix_strings-group-letter (first mix_strings-groups1)) (mix_strings-group-letter (first mix_strings-groups2)))\n     ;; In this case, if the frequency of the mix_strings group form  mix_strings groups 1 is larger,\n     ;; select the mix_strings group from mix_strings groups 1.  If the frequency of the mix_strings group from\n     ;; mix_strings groups 2 is larger, select the mix_strings group from mix_strings groups 2.  If they have the\n     ;; same frequency, then select the mix_strings group from mix_strings groups 2 but mark it \"=\".\n     (let* ([freq1 (mix_strings-group-frequency (first mix_strings-groups1))]\n            [freq2 (mix_strings-group-frequency (first mix_strings-groups2))]\n            [selected-mix_strings-group (cond [(= freq1 freq2) (cons \"=\" (first mix_strings-groups1))]\n                                      [(> freq1 freq2) (cons \"1\" (first mix_strings-groups1))]\n                                      [(< freq1 freq2) (cons \"2\" (first mix_strings-groups2))])])\n       ;; Recurse on the rest of both mix_strings groups 1 and mix_strings groups 2.\n       (select-mix_strings-groups (rest mix_strings-groups1)\n                          (rest mix_strings-groups2)\n                          (cons selected-mix_strings-group acc)))]\n    [else (error \"Not all possibilities accounted for.\")]))\n\n;; Transform the selected mix_strings group into the expected string format.\n(define (format-selected-mix_strings-group g)\n  (let ([string-id (car g)]\n        [group (cdr g)])\n    (format \"~a:~a\" string-id (mix_strings-group-string group))))\n\n;; Function to compare selected mix_strings groups to sort them according\n;; to the required rules of order.\n(define (compare-selected-mix_strings-groups group1 group2)\n  (let ([freq1 (car group1)]\n        [freq2 (car group2)])\n    (if (= freq1 freq2)\n        (let ([string1 (cdr group1)]\n              [string2 (cdr group2)])\n          (string<? string1 string2))\n        (> freq1 freq2))))\n\n;; Function to produce expected output\n(define (mix_strings s1 s2)\n  ;; Transform strings into lists of mix_strings-groups.\n  (let ([s1-group (string->mix_strings-group-list  s1)]\n        [s2-group (string->mix_strings-group-list  s2)])\n    ;; Join the list of mix_strings-groups as strings with \"\/\".\n    (string-join\n     ;; Select the mix_strings-group as string from the list.\n     (map cdr\n          ;; Sort the list of mix_strings-groups using the letter frequency and mix_strings-group as string.\n          (sort\n           ;; Make a pair with the letter frequency and the mix_strings-group as a string.\n           (map\n            (\u03bb (g) (cons (mix_strings-group-frequency (cdr g))\n                         (format-selected-mix_strings-group g)))\n            ;; Select the appropriate mix_strings-groups.\n            (select-mix_strings-groups s1-group s2-group '()))\n           compare-selected-mix_strings-groups))\n     \"\/\")))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289422,"user_id":242,"body":"#lang racket\n(provide mix_strings)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (map proc items)\n  (cond\n    [(null? items) `()]\n    [(pair? items) (cons (proc (car items)) (map proc (cdr items)))]\n    [else (list (proc items))]\n  )\n)\n\n(define (filter pred items)\n  (define (filter-iter itemsn acc)\n    (cond\n      [(null? itemsn) acc]\n      [(pred (car itemsn)) (filter-iter (cdr itemsn) (cons (car itemsn) acc))]\n      [else (filter-iter (cdr itemsn) acc)]\n    )\n  )\n  (reverse (filter-iter items `()))\n)\n\n\n(define (get-lowercases s)\n  (sort (filter (lambda (x) (and (< x 123) (> x 96)))(map char->integer (string->list s))) <)\n)\n\n(define (group-chars-in-string lst)\n  (define (group-chars-in-string-iter lstn curr count acc)\n    (cond\n      [(and (null? lstn) (> count 0)) (cons (list curr count) acc)]\n      [(null? lstn) acc]\n      [(= (car lstn) curr) (group-chars-in-string-iter (cdr lstn) curr (+ count 1) acc)]\n      [else (group-chars-in-string-iter (cdr lstn) (car lstn) 1 (cons (list curr count) acc))]\n    )\n  )\n  (cond\n    [(null? lst) `()]\n    [else (filter (lambda (x) (> (cadr x) 1))(cdr (reverse (group-chars-in-string-iter lst 95 0 `()))))]\n  )\n)\n\n(define (mix_strings-two lst1 lst2)\n  (define (mix_strings-two-iter lst1n lst2n acc)\n    (let\n      (\n        (lst1curr (if (null? lst1n) 123 (car (car lst1n))))\n        (lst2curr (if (null? lst2n) 123 (car (car lst2n))))\n        (lst1count (if (null? lst1n) 0 (cadr (car lst1n))))\n        (lst2count (if (null? lst2n) 0 (cadr (car lst2n))))\n      )\n      (cond\n        [(and (= lst1curr 123) (= lst2curr 123)) acc]\n        [(= lst1curr 123) (mix_strings-two-iter `() (cdr lst2n) (cons (list lst2curr lst2count 2) acc))]\n        [(= lst2curr 123) (mix_strings-two-iter (cdr lst1n) `() (cons (list lst1curr lst1count 1) acc))]\n        [(and (= lst2curr lst1curr) (= lst1count lst2count)) (mix_strings-two-iter (cdr lst1n) (cdr lst2n) (cons (list lst1curr lst1count 3) acc))]\n        [(and (= lst2curr lst1curr) (> lst1count lst2count)) (mix_strings-two-iter (cdr lst1n) (cdr lst2n) (cons (list lst1curr lst1count 1) acc))]\n        [(and (= lst2curr lst1curr) (< lst1count lst2count)) (mix_strings-two-iter (cdr lst1n) (cdr lst2n) (cons (list lst2curr lst2count 2) acc))]\n        [(> lst2curr lst1curr) (mix_strings-two-iter (cdr lst1n) lst2n (cons (list lst1curr (cadr (car lst1n)) 1) acc))]\n        [(< lst2curr lst1curr) (mix_strings-two-iter lst1n (cdr lst2n) (cons (list lst2curr (cadr (car lst2n)) 2) acc))]\n      )\n    )\n  )\n  (reverse (mix_strings-two-iter lst1 lst2 `()))\n)\n\n(define (mix_strings-two-sort s1 s2)\n  (let\n    (\n      (lst1 (group-chars-in-string (get-lowercases s1)))\n      (lst2 (group-chars-in-string (get-lowercases s2)))\n    )\n    (sort\n      (mix_strings-two lst1 lst2)\n      (lambda (x y)\n        (cond\n          [(< (cadr x) (cadr y)) #f]\n          [(> (cadr x) (cadr y)) #t]\n          [(> (caddr x) (caddr y)) #f]\n          [(< (caddr x) (caddr y)) #t]\n          [(> (car x) (car y)) #f]\n          [(< (car x) (car y)) #t]\n          [else #t]\n        )\n      )\n    )\n  )\n)\n\n(define (list-to-str lst)\n  (define (list-to-str-iter elem count acc)\n    (cond\n      [(= count 0) acc]\n      [else (list-to-str-iter elem (- count 1) (cons elem acc))]\n    )\n  )\n  (let\n    (\n      (symb (if (< 2 (caddr lst)) \"=\" (number->string (caddr lst))))\n    )\n    (~a symb \":\" (list->string (map integer->char (list-to-str-iter (car lst) (cadr lst) `()))))\n  )\n)\n\n(define (mix_strings s1 s2)\n  (let\n    (\n      (lst (accumulate (lambda (x y) (~a x \"\/\" y)) \"\" (map list-to-str (mix_strings-two-sort s1 s2))))\n    )\n    (cond\n      [(= 0 (string-length lst)) \"\"]\n      [else (substring lst 1 (string-length lst))]\n    )\n  )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289423,"user_id":null,"body":"#lang racket\n(provide mix_strings)\n\n(define (prepare-to-mix_strings s n)\n  (filter (lambda (x) (> (car x) 1))\n          (map (lambda (x)\n                 (list (length x)\n                       (list->string x)\n                       n))\n               (group-by identity \n                         (filter char-lower-case?\n                                 (string->list s))))))\n\n(define (mix_strings s1 s2)\n  (let ([l1 (prepare-to-mix_strings s1 1)]\n        [l2 (prepare-to-mix_strings s2 2)]\n        [fmt (lambda (num str) (format \"~a:~a\" num str))])\n    (string-join (sort (map (lambda (x)\n                              (match x\n                                [(list (list len str num)) (fmt num str)]\n                                [(list (list len1 str1 num1)\n                                       (list len2 str2 num2))\n                                 (cond\n                                   [(< len1 len2) (fmt num2 str2)]\n                                   [(> len1 len2) (fmt num1 str1)]\n                                   [else (fmt #\\= str1)])]))\n                            (group-by (lambda (x)\n                                        (string-ref (cadr x) 0))\n                                      (append l1 l2)))\n                       (lambda (x y)\n                         (or (> (string-length x)\n                                (string-length y))\n                             (and (= (string-length x)\n                                     (string-length y))\n                                  (string<? x y)))))\n\n                 \"\/\")))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5672682212c8ecf83e000050":[{"id":289424,"user_id":492,"body":"#lang racket\n(provide dbl_linear)\n\n(define (dbl_linear n)\n  (define (is-in? n)\n    (if (= n 1)\n        #t\n        (let ([nn (sub1 n)])\n          (or\n           (if (zero? (remainder nn 2)) (is-in? (\/ nn 2)) #f)\n           (if (zero? (remainder nn 3)) (is-in? (\/ nn 3)) #f)))))\n  (stream-ref (stream-filter (lambda(x) (is-in? x)) (in-range 1 +inf.0)) n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289425,"user_id":527,"body":"#lang racket\n(provide dbl_linear)\n\n(define (stream-uncons xs)\n  (values (stream-first xs) (stream-rest xs)))\n\n(define (stream-merge-ascending xxs yys)\n  (define-values (x xs) (stream-uncons xxs))\n  (define-values (y ys) (stream-uncons yys))\n  (cond\n   [(< x y) (stream-cons x (stream-merge-ascending  xs yys))]\n   [(> x y) (stream-cons y (stream-merge-ascending xxs  ys))]\n   [else    (stream-cons x (stream-merge-ascending  xs  ys))]))\n\n(define (dbl_linear n)\n  (define ((next-x m) x) (+ (* x m) 1))\n  (define xs (stream-cons 1 (stream-merge-ascending (stream-map (next-x 2) xs)\n                                                    (stream-map (next-x 3) xs))))\n  (stream-ref xs n))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289426,"user_id":53,"body":"#lang racket\n(provide dbl_linear)\n\n(define (walk n i x y hmap)\n  (if (> i n)\n    (hash-ref hmap n)\n    (let* ([a (hash-ref hmap x)]\n           [b (hash-ref hmap y)]\n           [c (add1 (* 2 a))]\n           [d (add1 (* 3 b))]\n           [e (min c d)]\n           [hmap2 (hash-set hmap i e)]\n           [x2 (if (= e c) (add1 x) x)]\n           [y2 (if (= e d) (add1 y) y)])\n      (walk n (add1 i) x2 y2 hmap2))))\n\n(define (dbl_linear n)\n  (walk n 1 0 0 (hash 0 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289427,"user_id":null,"body":"#lang racket\n(provide dbl_linear)\n\n(define (dbl_linear n)\n  (define u\n    (stream-cons 1 (stream-merge (stream-map (lambda (x) (+ (* 2 x) 1)) u)\n                                 (stream-map (lambda (x) (+ (* 3 x) 1)) u))))\n  (stream-ref u n))\n\n(define (stream-merge s1 s2)\n  (cond\n    [(stream-empty? s1) s2]\n    [(stream-empty? s2) s1]\n    [else (let ([h1 (stream-first s1)]\n                [h2 (stream-first s2)])\n            (cond\n              [(= h1 h2) (stream-cons h1\n                                      (stream-merge (stream-rest s1) \n                                                    (stream-rest s2)))]\n              [(< h1 h2) (stream-cons h1\n                                      (stream-merge (stream-rest s1) \n                                                    s2))]\n              [else (stream-cons h2\n                                 (stream-merge s1 \n                                 (stream-rest s2)))]))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289428,"user_id":544,"body":"#lang racket\n(provide dbl_linear)\n\n(define (dbl_linear n)\n  (define (grow-set s)\n    (cond\n      [((set-count s) . > . (* 4 n)) (list-ref (sort (set->list s) <) n)]\n      [else (grow-set (set-union s\n                                 (list->set (set-map s (\u03bb (n) (+ 1 (* 2 n)))))\n                                 (list->set (set-map s (\u03bb (n) (+ 1 (* 3 n)))))))]))\n  (grow-set (set 1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289429,"user_id":null,"body":"#lang racket\n\n(provide dbl_linear)\n\n(define (merge s1 s2)\n  (define x (stream-first s1))\n  (define y (stream-first s2))\n  (cond [(< x y) (stream-cons x (merge (stream-rest s1) s2))]\n        [(> x y) (stream-cons y (merge s1 (stream-rest s2)))]\n        [else (stream-cons x (merge (stream-rest s1) (stream-rest s2)))]))\n\n(define (y x)\n  (+ 1 (* 2 x)))\n\n(define (z x)\n  (+ 1 (* 3 x)))\n\n(define (seq x)\n  (stream-cons x (merge (seq (y x)) (seq (z x)))))\n\n(define (dbl_linear n)\n  (stream-ref (seq 1) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289430,"user_id":null,"body":"#lang racket\n(provide dbl_linear)\n\n(define (dbl_linear n)\n  (define (next n)\n    (stream-cons n (merge (next (add1 (* n 2))) (next (add1 (* n 3))))))\n  (define (merge xs ys)\n    (let ((x (stream-first xs))\n          (y (stream-first ys)))\n      (cond ((< x y)\n             (stream-cons x (merge (stream-rest xs) ys)))\n            ((> x y)\n             (stream-cons y (merge xs (stream-rest ys))))\n            (else\n             (stream-cons x (merge (stream-rest xs) (stream-rest ys)))))))\n  (stream-ref (next 1) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289431,"user_id":null,"body":"#lang racket\n(provide dbl_linear)\n\n(define in-u?\n  (let ([memo (make-hash '((0 . #f) (1 . #t)))])\n    (\u03bb (n)\n      (when (not (hash-has-key? memo n))\n        (let ([a (\/ (sub1 n) 2)]\n              [b (\/ (sub1 n) 3)])\n          (hash-set! memo n\n                     (or (and (integer? a) (in-u? a))\n                         (and (integer? b) (in-u? b))))))\n      (hash-ref memo n))))\n\n(define (dbl_linear n)\n  (for\/first ([index (in-naturals)]\n              [u (sequence-filter in-u? (in-naturals))]\n              #:when (= index n))\n    u))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289432,"user_id":null,"body":"#lang racket\n(provide dbl_linear)\n\n(define (dbl x)\n  (cons x (delay\n            (define as (dbl (add1 (* 2 x))))\n            (define bs (dbl (add1 (* 3 x))))\n            (merge as bs))))\n\n(define (merge as bs)\n  (define a (car as))\n  (define b (car bs))\n  (cond [(< a b) (cons a (delay (merge (force (cdr as)) bs)))]\n        [(> a b) (cons b (delay (merge as (force (cdr bs)))))]\n        [else (cons a (delay (merge (force (cdr as)) (force (cdr bs)))))]))\n\n(define (dbl_linear n)\n  (let loop ([n n] [xs (dbl 1)])\n    (cond [(zero? n) (car xs)]\n          [else (loop (sub1 n) (force (cdr xs)))])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289433,"user_id":null,"body":"#lang racket\n\n;; the first element\n(define h (make-hash '((0 . 1))))\n\n(define (dbl_linear n)\n  (define (iter i p2 p3)\n    (let [(x2 (+ 1 (* 2 (hash-ref h p2))))\n          (x3 (+ 1 (* 3 (hash-ref h p3))))]\n      (cond ((= n 0) 1)\n            ((= i 1) (begin (hash-set! h (- n i -1) (min x2 x3))\n                            (min x2 x3)))\n            (else (cond [(> x2 x3) (begin (hash-set! h (- n i -1) x3)\n                                          (iter (sub1 i) p2 (add1 p3)))]\n                        [(< x2 x3) (begin (hash-set! h (- n i -1) x2)\n                                          (iter (sub1 i) (add1 p2) p3))]\n                        [else (begin (hash-set! h (- n i -1) x2)\n                                     (iter (sub1 i) (add1 p2) (add1 p3)))])))))\n  (hash-ref h n\n            (iter n 0 0)))\n\n\n(provide dbl_linear)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56c04261c3fcf33f2d000534":[{"id":289434,"user_id":null,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (for*\/sum ([k (in-range 1 (add1 maxk))]\n             [n (in-range 1 (add1 maxn))])\n    (\/ (* k (expt (+ n 1.0) (* 2 k))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289435,"user_id":null,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn) \n  (for*\/sum ([k (in-range 1 (add1 maxk))]\n             [n (in-range 1 (add1 maxn))])\n    (\/ 1.0 (* k (expt(+ n 1.0) (* 2 k))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289436,"user_id":null,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (for*\/sum ([k (in-range 1 (add1 maxk))]\n                             [n (in-range 1 (add1 maxn))])\n                    (\/ 1.0 (* k (expt(+ n 1.0) (* 2.0 k))))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289437,"user_id":492,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (define (double-boxes-n maxn k)\n    (define (loop n vk uk)\n      (if (> n maxn)\n          uk\n          (let* ([mk (expt (\/ n (+ n 1.0)) (* 2.0 k))]\n                 [rvk (* vk mk)]\n                 [ruk (+ uk rvk)])\n            (loop (add1 n) rvk ruk))))\n    (let ([u (\/ 1 (* k (expt 2 (* 2.0 k))))])\n      (loop 2 u u)))\n  (define (loop k sm)\n    (if (> k maxk)\n        sm      \n        (loop (add1 k) (+ sm (double-boxes-n maxn k)))))\n  (loop 1 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289438,"user_id":53,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (define (v k n)\n    (\/ 1.0 (* k (expt (add1 n) (* k 2)))))\n  (define (aux k n res)\n    (cond\n       [(> k maxk) res]\n       [(> n maxn) (aux (add1 k) 1 res)]\n       [else (let ([m (v k n)])\n                (cond\n                   [(< m 1e-12) (aux (add1 k) 1 res)]\n                   [else (aux k (add1 n) (+ res m))]))]))\n  (aux 1 1 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289439,"user_id":null,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n\t(let loopk ([k (exact->inexact 1)])\n\t\t(if (> k maxk)\n\t\t\t\t0\n\t\t\t\t(+ (let loopn ([n (exact->inexact 1)])\n\t\t\t\t\t\t(if (> n maxn)\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t(+ (\/ 1 (* k (expt (+ n 1) (* 2 k))))\n\t\t\t\t\t\t\t\t\t (loopn (+ n 1)))))\n\t\t\t\t\t\t(loopk (+ k 1)))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289440,"user_id":544,"body":"#lang racket\n(provide double-boxes)\n\n; I stumbled around trying to come up with a closed solution\n; or breaking the loop when the values got too small \n; until I realized I had defined the proc as\n; (define (magnets k n) (\/ 1 (* k (expt (+ n 1) (* 2 k)))))\n; and that it was trying to do it all in integer math\n; \n; When all the numbers are cast as floats, it takes a nice \n; trim 5 seconds to finish instead!\n;\n(define (magnets k n) (\/ 1.0 (* k (expt (+ n 1.0) (* 2.0 k)))))\n\n(define (double-boxes maxk maxn)\n  (for*\/sum ([k (in-range 1 (+ 1 maxk))]\n             [n (in-range 1 (+ 1 maxn))])\n            (magnets k n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289441,"user_id":168,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (for\/sum ([k (range 1 (add1 maxk))])\n    (\/ (for\/sum ([n (range 1 (add1 maxn))])\n          (\/ (expt (add1 n) (* 2.0 k)))) k))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289442,"user_id":242,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (define (accumulate-by-column maxkn currn currk ndegree acc)\n    (cond\n      [(> currk maxkn) acc]\n      [(> ndegree 1e+12) acc]\n      [else (accumulate-by-column maxkn currn (+ currk 1) (* ndegree currn currn) (+ (\/ 1.0 (* ndegree currn currn currk)) acc))]\n    )\n  )\n  (define (accumulate-by-row maxnn currn acc)\n    (cond\n      [(> currn maxnn) (+ acc (accumulate-by-column maxk currn 1 1 0))]\n      [else (accumulate-by-row maxnn (+ 1 currn) (+ acc (accumulate-by-column maxk currn 1 1 0)))]\n    )\n  )\n  (accumulate-by-row maxn 2 0)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289443,"user_id":null,"body":"#lang racket\n(provide double-boxes)\n\n(define (double-boxes maxk maxn)\n  (let ([sum 0.0] [t 1.0])    \n    (for ([n (range 2 (+ maxn 2))])\n      (set! t 1.0)\n      (for ([k (range 1 (add1 maxk))] #:break (< t 1e-6))\n        (set! t (\/ 1.0 k))\n        (let* ([n2 (* n n)])\n          (for ([tk k]) (set! t (* t (\/ 1.0 n2))))\n          (set! sum (+ sum t)))))                      \n    sum))               \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5765870e190b1472ec0022a2":[{"id":289444,"user_id":null,"body":"#lang racket\n(provide path_finder)\n\n(define (string->maze str)\n  (for\/vector ([line (in-lines (open-input-string str))])\n    (for\/vector ([char (in-string line)])\n      (char=? char #\\.))))\n\n(define (adjacent pos)\n  (match-define (cons x y) pos)\n  (list (cons (sub1 x) y)\n        (cons (add1 x) y)\n        (cons x (sub1 y))\n        (cons x (add1 y))))\n\n(define (path_finder str)\n  (define maze (string->maze str))\n  (define N-1 (sub1 (vector-length maze)))\n  (define (valid-pos? pos)\n    (match-define (cons x y) pos)\n    (and (<= 0 x N-1)\n         (<= 0 y N-1)\n         (vector-ref (vector-ref maze (cdr pos))\n                     (car pos))))\n  (define (move pos)\n    (filter valid-pos? (adjacent pos)))\n  (define exit?\n    (curry equal? (cons N-1 N-1)))\n  (define visited (mutable-set))\n  (let search ([pos '(0 . 0)])\n    (cond [(set-member? visited pos) #f]\n          [(exit? pos) #t]\n          [else\n           (set-add! visited pos)\n           (ormap search (move pos))])))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289445,"user_id":null,"body":"#lang racket\n(provide path_finder)\n\n(define (string->maze str)\n  (for\/vector ([line (in-lines (open-input-string str))])\n    (for\/vector ([char (in-string line)])\n      (char=? char #\\.))))\n\n(define (adjacent pos)\n  (match-define (cons x y) pos)\n  (list (cons (sub1 x) y)\n        (cons (add1 x) y)\n        (cons x (sub1 y))\n        (cons x (add1 y))))\n\n(define (path_finder str)\n  (define maze (string->maze str))\n  (define N (vector-length maze))\n  (define (valid-pos? pos)\n    (match-define (cons x y) pos)\n    (and (< -1 x N)\n         (< -1 y N)\n         (vector-ref (vector-ref maze (cdr pos))\n                     (car pos))))\n  (define (move pos)\n    (filter valid-pos? (adjacent pos)))\n  (define exit?\n    (curry equal? (cons (sub1 N) (sub1 N))))\n  (define visited (mutable-set))\n  (let search ([pos '(0 . 0)])\n    (cond [(set-member? visited pos) #f]\n          [(exit? pos) #t]\n          [else\n           (set-add! visited pos)\n           (for\/or ([next (move pos)])\n             (search next))])))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289446,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide path_finder)\n\n\n(define O #\\.)\n(define W #\\W)\n\n\n;; A MazeString is a String with the following shape:\n;; there are N lines in it (separated by \n), and in each line there are N chars\n;; which are either O or W\n;; interp. O = an empty position, W = wall.\n\n(define MS-1 (string-append (string O O O ) \"\n\"\n                            (string O W W) \"\n\"\n                            (string O O O)))\n\n(define MS-2 (string-append (string O O O) \"\n\"\n                            (string O W W) \"\n\"\n                            (string O W O)))\n\n\n;; A MazeTable is a (Listof=N (Listof=N (or\/c O W)))\n;; interp. same stuff as in MazeString, represented differently for easy access.\n;; Index (0,0) is (top, left), index (N-1, N-1) is bottom right.\n\n(define MT-1 (list (list O O O)\n                   (list O W W)\n                   (list O O O)))\n\n(define MT-2 (list (list O O O)\n                   (list O W W)\n                   (list O W O)))\n\n(define MT-3 (list (list O O O)\n                   (list O W W)\n                   (list O O W)))\n\n\n(struct p (r c v) #:transparent)\n;; A Position is (p 0<=Int<N 0<=Int<N (or\/c O W))\n;; interp. a position\/cell\/node in the maze comprised of (row column value).\n\n(define P-1 (p 0 0 O))\n(define P-2 (p 0 1 O))\n(define P-3 (p 0 2 O))\n(define P-4 (p 1 0 O))\n(define P-5 (p 1 1 W))\n(define P-6 (p 1 2 W))\n(define P-7 (p 2 0 O))\n(define P-8 (p 2 1 O))\n(define P-9 (p 2 2 O))\n\n\n;; MazeString -> Boolean\n;; return #t if there is a path from position [0,0] to [N-1,N-1] in the maze,\n;; #f otherwise. Assume that you can move only in one of the four cardinal\n;; directions (north, east, south, west), and obviously not across walls.\n(define (path_finder ms)\n  (let* ([mt (mazestr->mazet ms)]\n         [n (length mt)])\n    (if (dfs mt 0 0 (sub1 n) (sub1 n)) #t #f)))\n\n(module+ test\n  (check-equal? (path_finder MS-1) #t)\n  (check-equal? (path_finder MS-2) #f))\n\n\n;; MazeTable Int Int Int Int -> (or\/c (Listof Position) #f)\n;; run a depth-first search in the maze table from position with coordinates\n;; (start-r, start-c) to a position with coordinates (end-r, end-c) and\n;; return the path (incl. start and end points), if any, or #f, if none\n;; ACKNOWLEDGE:\n;; http:\/\/htdp.org\/2003-09-26\/Book\/curriculum-Z-H-35.html#node_chap_28\n(define (dfs mt start-r start-c end-r end-c)\n\n  (define visited (mutable-set))\n\n  ;; Integer Integer MazeTable -> (Listof Position)\n  ;; given a (row, column) in a maze, return all empty neighbours of that pos\n  (define (neighbours r c mt)\n    (filter\n     (\u03bb (p) (and (p-v p) (not (equal? W (p-v p)))))\n     (for\/list ([rprime (list (sub1 r) (add1 r) r r)]\n                [cprime (list c c (sub1 c) (add1 c))])\n       (p rprime cprime (lookup mt rprime cprime)))))\n\n  (define (find-route orig dest mt)\n    (cond\n      [(and (= (p-r orig) (p-r dest))\n            (= (p-c orig) (p-c dest))\n            (equal? O (p-v dest))) (list dest)]\n      [else\n       (let ([possible-route\n              (find-route\/list (neighbours (p-r orig) (p-c orig) mt) dest mt)])\n         (cond\n           [(boolean? possible-route) #f]\n           [else (cons orig possible-route)]))]))\n\n  (define (find-route\/list origs dest mt)\n    (cond\n      [(empty? origs) #f]\n      [(set-member? visited (first origs))\n       (find-route\/list (rest origs) dest mt)]\n      [else\n       (begin\n         (set-add! visited (first origs))\n         (let ([possible-route (find-route (first origs) dest mt)])\n           (cond\n             [(boolean? possible-route) (find-route\/list (rest origs) dest mt)]\n             [else possible-route])))]))\n  \n  (cond\n    [(or (equal? W (lookup mt start-r start-c))\n         (equal? W (lookup mt end-r end-c))) #f]\n    [(and (= start-r end-r) (= start-c end-c)) (list (p end-r end-c O))]\n    [else (find-route (p start-r start-c O) (p end-r end-c O) mt)]))\n\n(module+ test\n  (check-equal? (dfs MT-1 0 0 2 2)\n                (list (p 0 0 O) (p 1 0 O) (p 2 0 O) (p 2 1 O) (p 2 2 O)))\n  (check-equal? (dfs MT-2 0 0 2 2) #f))\n\n\n;;;;;;;;;;;;;\n;; converters\n\n\n;; MazeString -> MazeTable\n(define (mazestr->mazet m)\n  (for\/list ([r (in-list (string-split m \"\n\"))])\n    (for\/list ([c (in-string r)])\n      c)))\n\n(module+ test\n  (check-equal? (mazestr->mazet MS-1) MT-1)\n  (check-equal? (mazestr->mazet MS-2) MT-2))\n\n\n;;;;;;;;;;;;\n;; utilities\n\n\n;; (Listof (Listof Any)) Integer Integer\n;; Perform (list-ref (list-ref l r) c). Return #f if out-of-bound error.\n(define (lookup l r c)\n  (with-handlers ([exn:fail:contract? (\u03bb (e) #f)])\n    (list-ref (list-ref l r) c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289447,"user_id":null,"body":"#lang racket\n(provide path_finder)\n\n(define (path_finder maze)\n  (define lines (string-split maze \"\n\"))\n  (define max-x (sub1 (string-length (car lines))))\n  (define max-y (sub1 (length lines)))\n  (define (done? pos)\n    (equal? pos (cons max-x max-y)))\n  (define seen (for*\/mutable-set ([(line y) (in-indexed (in-list lines))]\n                                  [(room x) (in-indexed (in-string line))]\n                                  #:when (eq? room #\\W))\n                 (cons x y)))\n  (define (next pos)\n    (match pos [(cons x y) (list (cons (sub1 x) y)\n                                 (cons (add1 x) y)\n                                 (cons x (sub1 y))\n                                 (cons x (add1 y)))]))\n  (define (valid? pos)\n    (cond [(or (< (car pos) 0) (< (cdr pos) 0) (> (car pos) max-x) (> (cdr pos) max-y)) #f]\n          [(set-member? seen pos) #f]\n          [else (set-add! seen pos)\n                #t]))\n  (let iter ([queue '((0 . 0))])\n    (cond [(null? queue) #f]\n          [(done? (car queue)) #t]\n          [else (iter (append (cdr queue) (filter valid? (next (car queue)))))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289448,"user_id":527,"body":"#lang racket\n(provide path_finder)\n\n(define empty-queue '(() . ()))\n(define (enqueue q x) (list* (car q) x (cdr q)))\n(define (dequeue-maybe q)\n  (match q\n    [(cons (cons h hs) ts) (list* h hs ts)]\n    [(cons '() '()) (list #f)]\n    [(cons '() ts) (dequeue-maybe (list (reverse ts)))]))\n\n(define ((flip f) x y) (f y x))\n\n(define (path_finder maze-str)\n  (define directions '((1 0) (0 1) (-1 0) (0 -1)))\n  (define start '(0 0))\n  (define maze (string-split maze-str))\n  (define dimensions (list (length maze) (string-length (first maze)) )) \n  (define target (map sub1 dimensions)) \n  (define (free? p)\n    (and (andmap < '(-1 -1) p dimensions) (equal? #\\. (string-ref (list-ref maze (first p)) (second p)))))\n  (define (moves maze p)\n    (for*\/list ([d directions] [p1 (in-value (map + p d))] #:when (free? p1)) p1))\n  (define (iter queue seen)\n    (match-define (cons p new-queue) (dequeue-maybe queue))\n    (cond\n      [(not p) #f]\n      [(equal? p target) #t]\n      [else\n        (define ps (for\/list ([p (moves maze p)] #:unless (set-member? seen p)) p))\n        (iter (foldl (flip enqueue) new-queue ps) (foldl (flip set-add) seen ps))]))\n  (iter (enqueue empty-queue start) (set start)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289449,"user_id":242,"body":"#lang racket\n(provide path_finder)\n\n(define (maze-split maze-str)\n  (map (lambda (x) (map (lambda (y) (string y))(string->list x)))(string-split maze-str \"\n\"))\n)\n\n(define (swap-element-in-row lst pos elem)\n  (define (swap-element-in-row-iter lst pos currpos elem acc)\n    (cond\n      [(null? lst) acc]\n      [(= pos currpos) (swap-element-in-row-iter (cdr lst) pos (+ currpos 1) elem (cons elem acc))]\n      [else (swap-element-in-row-iter (cdr lst) pos (+ currpos 1) elem (cons (car lst) acc))]\n    )\n  )\n  (reverse (swap-element-in-row-iter lst pos 0 elem `()))\n)\n\n(define (swap-element-in-array arr x y elem)\n  (define (swap-element-in-array-iter arr x y currx elem acc)\n    (cond\n      [(null? arr) acc]\n      [(= x currx) (swap-element-in-array-iter (cdr arr) x y (+ currx 1) elem (cons (swap-element-in-row (car arr) y elem) acc))]\n      [else (swap-element-in-array-iter (cdr arr) x y (+ currx 1) elem (cons (car arr) acc))]\n    )\n  )\n  (reverse (swap-element-in-array-iter arr x y 0 elem `()))\n)\n\n(define (path_finder maze)\n  (define (get-elem array x y)\n    (define (get-elem-iter arr n)\n      (if (= n 0) (car arr) (get-elem-iter (cdr arr) (- n 1)))\n    )\n    (get-elem-iter (get-elem-iter array x) y)\n  )\n  (define (array-with-new-x array x y new-value)\n    (swap-element-in-array array x y new-value)\n  )\n  (define (explore maze-copy height width pool)\n    (cond\n      [(null? pool)\n        maze-copy\n      ]\n      [else\n        (let\n          (\n            (new-pool-1 (cdr pool))\n            (currx (caar pool))\n            (curry (cadar pool))\n            (can-go-up (and (< 0 (caar pool)) (equal? \".\" (get-elem maze-copy (- (caar pool) 1) (cadar pool)))))\n          )\n          (let\n            (\n              (new-pool-2 (if can-go-up (cons (list (- currx 1) curry) new-pool-1) new-pool-1))\n              (can-go-down (and (< (caar pool) (- height 1)) (equal? \".\" (get-elem maze-copy (+ currx 1) curry))))\n            )\n            (let\n              (\n                (new-pool-3 (if can-go-down (cons (list (+ currx 1) curry) new-pool-2) new-pool-2))\n                (can-go-left (and (< 0 curry) (equal? \".\" (get-elem maze-copy currx (- curry 1)))))\n              )\n              (let\n                (\n                  (new-pool-4 (if can-go-left (cons (list currx (- curry 1)) new-pool-3) new-pool-3))\n                  (can-go-right (and (< curry (- width 1)) (equal? \".\" (get-elem maze-copy currx (+ curry 1)))))\n                )\n                (let\n                  (\n                    (new-pool-5 (if can-go-right (cons (list currx (+ curry 1)) new-pool-4) new-pool-4))\n                  )\n                  (explore (array-with-new-x maze-copy currx curry \"x\") height width new-pool-5)\n                )\n              )\n            )\n          )\n        )\n      ]\n    )\n  )\n  (let\n    (\n      (height (length (maze-split maze)))\n      (width (length (car (maze-split maze))))\n    )\n    (equal? (get-elem (explore (maze-split maze) height width (list (list 0 0))) (- height 1) (- width 1)) \"x\")\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5886e082a836a691340000c3":[{"id":289450,"user_id":53,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n   (let* ([x (exact-floor (\/ a (sqrt 2)))]\n          [y (exact-floor (\/ b (sqrt 2)))]\n          [r (+ (* (add1 x) (add1 y)) (* x y))])\n    (sub1 (+ r (modulo r 2)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289451,"user_id":544,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n; the set of points within the rectangle is made up of two rectangular arrays of points\n; the width and height of the two rectangles can be found\n; using the fact that the hypotenuse of a 45-45-90 unit triangle is sqrt(2)\n(define (rectangle_rotation a b)\n  (let* ([a-range (\/ a 2 (sqrt 2))]\n         [major-rect-a (+ 1 (* 2 (exact-floor a-range)))]\n         [b-range (\/ b 2 (sqrt 2))]\n         [major-rect-b (+ 1 (* 2 (exact-floor b-range)))]\n         [minor-rect-a (if (< (- a-range (floor a-range)) 1\/2) (- major-rect-a 1) (+ major-rect-a 1))]\n         [minor-rect-b (if (< (- b-range (floor b-range)) 1\/2) (- major-rect-b 1) (+ major-rect-b 1))])\n    (+ (* major-rect-a major-rect-b) (* minor-rect-a minor-rect-b))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289452,"user_id":null,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n;Number Number -> Number\n;given length of rectangle's sides a and b,\n;compute how many points with integer coordinates \n;are located inside the given rectangle\n;(including on its sides)\n(define (rectangle_rotation a b)\n    (let* ([sqrt2 (sqrt 2)]\n         [a-max (add1 (exact-floor (\/ a sqrt2)))]\n         [b-max (add1 (exact-floor (\/ b sqrt2)))]\n         [a-min (exact-floor (\/ a sqrt2))]\n         [b-min (exact-floor (\/ b sqrt2))])\n    (cond\n      [(or (and (even? a-max) (even? b-max))\n           (and (odd? a-max) (odd? b-max)))\n       (+  (* a-max b-max) (* a-min b-min))]\n      [else\n       (+ (* a-max b-min) (* a-min b-max))]))) ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289453,"user_id":168,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (let ([a (exact-floor (\/ a (sqrt 2)))]\n        [b (exact-floor (\/ b (sqrt 2)))])\n    (+ (* 2 a b) a b 1 (- (bitwise-and (bitwise-xor a b) 1)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289454,"user_id":null,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (define (width x)\n    (add1 (inexact->exact (floor (\/ x (sqrt 2))))))\n  (define x (width a))\n  (define y (width b))\n  (define low (min x y))\n  (define high (max x y))\n  (+ (* high (sub1 low))\n     (* low (sub1 high))\n     (if (odd? (+ low high)) 0 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289455,"user_id":null,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (let ((d (sqrt 2)))\n    (define (adots l)\n      (add1 (inexact->exact (truncate (\/ l d)))))\n    (let ((y (adots a))\n          (x (adots b)))\n      (+ (- (* 2 y x)\n            y\n            x)\n         (modulo (+ y x 1) 2)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289456,"user_id":null,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (let ((d (sqrt 2)))\n      (define adots\n        (lambda (l)\n          (add1 (truncate (\/ l d)))))\n      (let ((y (adots a))\n            (x (adots b)))\n        (inexact->exact\n         (+ (- (* 2 y x)\n               y\n               x)\n            (modulo (+ y x 1) 2))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289457,"user_id":492,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (let ( [x (inexact->exact (floor (\/ a (sqrt 2.0))))]\n         [y (inexact->exact (floor (\/ b (sqrt 2.0))))]\n      )\n      (if (= 0 (modulo (+ x y) 2))\n          (+ (* (+ x 1) (+ y 1)) (* x y))\n          (+ (* (+ x 1) y) (* (+ y 1) x))\n      )\n  )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289458,"user_id":null,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (define sqrt2 (sqrt 2))\n  (define (l1 n) (* 2 (floor (\/ (+ 1 (\/ n sqrt2)) 2))))\n  (define (l2 n) (+ 1 (* 2 (floor (\/ n (* 2 sqrt2))))))\n  (inexact->exact (+ (* (l1 a) (l1 b))\n                     (* (l2 a) (l2 b)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289459,"user_id":645,"body":"#lang racket\n\n(provide rectangle_rotation)\n\n(define (rectangle_rotation a b)\n  (let* ([h (exact-floor (\/ a (sqrt 2)))]\n         [v (exact-floor (\/ b (sqrt 2)))])\n    (- (+ (* h v) (* (+ h 1) (+ v 1))) (bitwise-xor (modulo h 2) (modulo v 2)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"50654ddff44f800200000004":[{"id":289460,"user_id":168,"body":"#lang racket\n(provide multiply)\n\n(define multiply *)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289461,"user_id":676,"body":"#lang racket\n(provide multiply)\n\n(define (multiply a b) (* a b))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289462,"user_id":null,"body":"#lang racket\n\n; ok this is a bit cheeky\n\n(provide (rename-out [* multiply]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289463,"user_id":564,"body":"#lang racket\n(provide (rename-out [* multiply]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289464,"user_id":null,"body":"#lang racket\n#long time solution!!!\n#(provide multiply)\n\n#(define (multiply a b) (mult-helper a b))\n\n(define (mult-helper x n)\n  (if (equal? n 0)\n    0\n    (+ x (mult-helper x (- n 1)))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289465,"user_id":527,"body":"#lang racket\n[provide multiply]\n\n[define [multiply a b] [a . * . b]]","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289466,"user_id":null,"body":"#lang racket\n(provide multiply)\n\n(define (multiply a b) (* a b))\n; simplest solution is always the best. ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289467,"user_id":null,"body":"#lang racket\n(provide multiply)\n\n(define (multiply a b) (* a b))\n\n;Just changed the + with *","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289468,"user_id":168,"body":"#lang racket\n(provide multiply)\n\n(define (multiply . args) (apply * args))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"50ee6b0bdeab583673000025":[{"id":289469,"user_id":null,"body":"#lang racket\n(provide name)\n\n(define a \"code\")\n(define b \"wa.rs\")\n(define name (string-append a b))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289470,"user_id":527,"body":"#lang racket\n(provide name)\n\n(define name \"codewa.rs\")","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289471,"user_id":544,"body":"#lang racket\n(provide name)\n\n(define a \"code\")\n(define b \"wa.rs\")\n(define name (~a a b))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289472,"user_id":null,"body":"#lang racket\n(provide name)\n\n(define name \"\")\n(let ((a \"code\")\n      (b \"wa.rs\"))\n  (set! name (string-append a b))\n)\n\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"513e08acc600c94f01000001":[{"id":289473,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define (rgb r g b)\n  (string-upcase \n   (string-append (->hex r) (->hex g) (->hex b))))\n\n(define (->hex int)\n  (~r (normalize-num int 0 255)\n      #:base 16\n      #:min-width 2 \n      #:pad-string \"0\"))\n\n(define (normalize-num num min max)\n  (cond\n   [(<= min num max) num]\n   [(< num min) min]\n   [else max]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289474,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define rgb (lambda rgb\n              (foldl (lambda (a b) (string-append b a))\n                     \"\"\n                     (map (lambda (v) (~r (min 255 (max 0 v))\n                                          #:min-width 2 #:pad-string \"0\" #:base '(up 16)))\n                          rgb))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289475,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define (rgb r g b)\n  (define (rnd n)\n    (cond ((> n 255) 255)\n          ((< n 0) 0)\n          (else n)))\n  (define (number->hex n)\n    (let ((str (string-upcase (number->string n 16))))\n      (if (equal? (string-length str) 1)\n          (string-append \"0\" str)\n          str)))\n  (let ((lst (map rnd (list r g b))))\n    (apply string-append (map (lambda (x) (number->hex x)) lst)))\n    )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289476,"user_id":null,"body":"#lang racket\n\n(require racket\/format)\n(provide rgb)\n\n\n(define (fmt number)\n  (~a number\n    #:align 'right\n    #:width 2\n    #:pad-string \"0\"\n    )\n  )\n\n(define (ensure-hex-range number)\n  (cond [(< number 0) 0]\n        [(> number 255) 255]\n        [else number])\n  )\n\n\n(define (to-hex-str number)\n  (string-upcase\n    (fmt\n      (number->string (ensure-hex-range number) 16)\n      )\n    )\n  )\n\n\n(define (rgb r g b)\n  (string-append\n   (to-hex-str r)\n   (to-hex-str g)\n   (to-hex-str b)\n   )\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289477,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define (format-hex n)\n  (define hex-digits \"0123456789ABCDEF\")\n  (string (string-ref hex-digits (quotient n 16))\n          (string-ref hex-digits (remainder n 16))))\n\n(define (rgb r g b)\n  (string-append (format-hex (min (max r 0) 255))\n                 (format-hex (min (max g 0) 255))\n                 (format-hex (min (max b 0) 255))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289478,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define (rgb r g b)\n  (define (validate-hex n)\n    (cond [(<= n 0) \"00\"]\n          [(>= n 255) \"FF\"]\n          [else (~r n #:base '(up 16))]))\n  (let ((red (validate-hex r))\n        (green (validate-hex g))\n        (blue (validate-hex b)))\n    (string-append red green blue)))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289479,"user_id":53,"body":"#lang racket\n\n(provide rgb)\n\n(define (clip n) (max 0 (min 255 n)))\n\n(define (hex n)\n  (define digits \"0123456789ABCDEF\")\n  (string (string-ref digits (quotient n 16))\n          (string-ref digits (modulo n 16))))\n\n(define (rgb r g b) (string-append (hex (clip r)) (hex (clip g)) (hex (clip b))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289480,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define (rgb r g b)\n  (define (bound number minimum maximum)\n    (min (max number minimum) maximum))\n  (foldl (\u03bb (num output-string)\n           (string-append output-string\n                          (~r (bound num 0 255)\n                              #:base '(up 16)\n                              #:min-width 2\n                              #:pad-string \"0\")))\n         \"\"\n         (list r g b)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289481,"user_id":544,"body":"#lang racket\n\n(provide rgb)\n\n(define (rgb r g b)\n  (define rgb-decimal-list \n    (map (\u03bb (x) (cond [(x . > . 255) 255]\n                      [(x . < . 0) 0]\n                      [else x])) (list r g b)))\n  (apply string-append\n         (map (curry ~r #:base '(up 16) #:min-width 2 #:pad-string \"0\")\n              rgb-decimal-list)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289482,"user_id":null,"body":"#lang racket\n\n(provide rgb)\n\n(define (rgb r g b)\n  (let* ([check-limits (lambda (number)\n                         (cond [(< number 0) 0]\n                               [(> number 255) 255]\n                               [else number]))]\n         [number->hex (lambda (number)\n                       (cond [(= number 0) \"0\"]\n                             [(= number 1) \"1\"]\n                             [(= number 2) \"2\"]\n                             [(= number 3) \"3\"]\n                             [(= number 4) \"4\"]\n                             [(= number 5) \"5\"]\n                             [(= number 6) \"6\"]\n                             [(= number 7) \"7\"]\n                             [(= number 8) \"8\"]\n                             [(= number 9) \"9\"]\n                             [(= number 10) \"A\"]\n                             [(= number 11) \"B\"]\n                             [(= number 12) \"C\"]\n                             [(= number 13) \"D\"]\n                             [(= number 14) \"E\"]\n                             [(= number 15) \"F\"]))]\n        [byte->hex (lambda (byte)\n                     (let* ([fst (quotient byte 16)]\n                            [snd (remainder byte 16)]\n                            [fst-str (number->hex fst)]\n                            [snd-str (number->hex snd)])\n                       (string-append fst-str snd-str)))]\n        [r-hex (byte->hex (check-limits r))]\n        [g-hex (byte->hex (check-limits g))]\n        [b-hex (byte->hex (check-limits b))])\n    (string-append r-hex g-hex b-hex)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"514b92a657cdc65150000006":[{"id":289483,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution n)\n  (foldl (lambda (e a)\n           (+ a (if (or (equal? (modulo e 5) 0)\n                        (equal? (modulo e 3) 0))\n                    e\n                    0)))\n         0\n         (range n)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289484,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (sum-of-multiples n)\n  (if (< n 3)\n      0\n      (+ (if (or\n              (= (modulo n 3) 0)\n              (= (modulo n 5) 0)) n 0)\n       (sum-of-multiples (- n 1)))))\n\n(define (solution n)\n  (sum-of-multiples (- n 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289485,"user_id":53,"body":"#lang racket\n\n(provide solution)\n\n(define (facsum n f)\n  (let* ([k (floor (\/ (- n 1) f))]\n         [m (+ f (* f k))]\n         [ans (floor (\/ (* m k) 2))])\n    ans))\n\n(define (solution n)\n  (let* ([f3 (facsum n 3)]\n         [f5 (facsum n 5)]\n         [f15 (facsum n 15)]\n         [ans (- (+ f3 f5) f15)])\n    ans))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289486,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n\n; Calculate sum of multiples of n_base lesser in range [0, n_upper)\n; Closed form of the serie: n_terms*(first_term + last_term)\/2\n(define (sum_mults_under n_base n_upper)\n  (let [\n        (i (quotient (- n_upper 1) n_base))\n        ]\n    (\/ (* (+ 1 i) (+ 0 (* i n_base)) ) 2)\n    )\n  )\n\n\n(define (solution n)\n  ( -\n    (+ (sum_mults_under 3 n) (sum_mults_under 5 n))\n    (sum_mults_under 15 n) ; They are counted twice\n    )\n  )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289487,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (a x n)\n  (if (< x n)\n  (+ x (a (+ x 3) n))\n  0)\n)\n\n(define (b x n)\n  (if (< x n)\n      (if (=(modulo x 3) 0)\n          (b (+ x 5) n)\n          (+ x (b (+ x 5) n))\n      )\n  0)\n)\n(define (solution n)\n  (+ (a 3 n)(b 5 n))\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289488,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (by-three-or-five? n)\n  (or\n    (= (remainder n 3) 0)\n    (= (remainder n 5) 0)\n  )\n)\n\n(define (dividable-by-three-or-five n)\n  (filter by-three-or-five? (range n)))\n\n(define (solution n)\n  (foldl + 0 \n    (dividable-by-three-or-five n)\n  ))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289489,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution n)\n  (define (div-by s r)\n    (= 0 (remainder s r)))\n  \n  (define (iter acc s f)\n    (if (>= s f)\n        acc\n        (iter (if (or (div-by s 5)\n                      (div-by s 3))\n                  (+ acc s)\n                  acc) (+ s 1) f)))\n  (iter 0 0 n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289490,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution n)\n  (for\/sum ([x (in-range 1 n)]\n            #:when (or (= (remainder x 5) 0) (= (remainder x 3) 0)))\n    x))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289491,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution n)\n  (define (sum-of-multiples a b) \n    (define (multiple? x) \n      (if (or \n           (= (modulo x 3) 0)\n           (= (modulo x 5) 0))\n          x\n          0))\n    (if (> a b)\n        0\n        (+ (multiple? a) \n           (sum-of-multiples (+ 1 a) b))))\n  (sum-of-multiples 1 (- n 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289492,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution n)\n  (foldl + 0 (filter (lambda (x) (or (eq? 0 (modulo x 5)) (eq? 0 (modulo x 3)))) (range n))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"515e271a311df0350d00000f":[{"id":289493,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (apply + (map sqr numbers)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289494,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (define (square x)\n    (* x x))\n  (foldl + 0 (map square numbers)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289495,"user_id":53,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (foldl (\u03bb (n acc) (+ acc (* n n))) 0 numbers))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289496,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum lst)\n  (apply + (map * lst lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289497,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (cond\n   [(empty? numbers) 0]\n     [else (+ \n            (expt (first numbers) 2) (square_sum (rest numbers)))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289498,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square n) \n    (* n n))\n\n(define (square_sum numbers)\n  (foldl + 0 (map square numbers)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289499,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (for\/sum ([i (map (lambda (i) (* i i)) numbers) ]) i ))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289500,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (apply + (map (lambda (n) (* n n)) numbers)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289501,"user_id":null,"body":"#lang racket\n(provide square_sum)\n\n(define (square_sum numbers)\n  (foldl\n    (lambda (a b) (+ a b))\n    0\n    (map sqr numbers)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289502,"user_id":null,"body":"#lang racket\n\n(define (square_sum l)\n  (match l\n    ['() 0]\n    [(list head) (* head head)]\n    [(cons head tail) (+ (* head head)\n                            (square_sum tail))\n    ]))\n\n(provide square_sum)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"515f51d438015969f7000013":[{"id":289503,"user_id":168,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (for\/list ([i (in-range 1 (add1 n))])\n    (make-list i 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289504,"user_id":564,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (define (to-ones n) (make-list n 1))\n  (define n-rows (range 1 (add1 n)))\n  (map to-ones n-rows))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289505,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (define (f n xs)\n    (cond\n      [(zero? n)\n       xs]\n      [else\n       (f (sub1 n) (cons (make-list n 1) xs))]))\n  (f n empty))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289506,"user_id":53,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (if (zero? n)\n    '()\n    (map (lambda (x) (make-list x 1)) (range 1 (add1 n)))\n   )\n )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289507,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (if (zero? n) \n      '() \n      (cons '(1) (map (lambda (x) (cons 1 x))\n                      (pyramid (sub1 n))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289508,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (for\/list ([i (in-range 1 (+ n 1))])\n    (make-list i 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289509,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (define (p-rec i list)\n    (if (= i 0)\n        list\n        (p-rec (sub1 i) (cons (make-list i 1) list))))\n  (p-rec n null))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289510,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (case n\n    [(0) '()]\n    [(1) '((1))]\n    [else (append (pyramid (sub1 n))\n                  (list (make-list n 1)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289511,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define(pyramid n)\n  (if(zero? n)\n     '()\n     (append  (pyramid (- n 1)) (list (add-right-number-of-ones n)))))\n\n(define(add-right-number-of-ones amount)\n  (if(= amount 0)\n     '()\n     (cons 1 (add-right-number-of-ones (- amount 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289512,"user_id":null,"body":"#lang racket\n\n(provide pyramid)\n\n(define (pyramid n)\n  (build-list n\n    (lambda (x)\n      (make-list (add1 x) 1))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5168bb5dfe9a00b126000018":[{"id":289513,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution string)\n  (list->string (reverse (string->list string))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289514,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution string)\n  (let* ([list (string->list string)]\n         [reversed (reverse list)])\n         (list->string reversed)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289515,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution string)\n  (list->string (reverse (sequence->list string))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289516,"user_id":null,"body":"#lang racket\n(require racket\/string)\n(provide solution)\n\n(define (solution string)\n  (list->string (reverse (string->list string))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289517,"user_id":53,"body":"#lang racket\n(provide solution)\n\n(define (solution x)\n (list->string (reverse (string->list x))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289518,"user_id":null,"body":"#lang racket\n(provide solution reverse1)\n\n(define (reverse1 l)\n  (if (null? l)\n     '()\n     (append (reverse1 (cdr l)) (list (car l)))\n  )\n)\n\n(define (solution string)\n  (list->string (reverse1 (string->list string)))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289519,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (rever lst)\n  (cond\n    ((null? lst) \"\")\n    (else (string-append (rever (cdr lst)) (string (car lst))))))\n\n(define (solution string)\n  (rever (string->list string)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289520,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution string)\n  (if \n    (<= (string-length string) 1)\n    string\n    (let ([first-letter (substring string 0 1)]\n          [rest-string (substring string 1)])\n      (string-append \n         (solution rest-string)\n         first-letter))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289521,"user_id":null,"body":"#lang racket\n(provide solution)\n\n(define (solution s)\n  (string-join (map string (reverse (string->list s))) \"\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289522,"user_id":null,"body":"#lang racket\n(provide solution)\n(require srfi\/13)\n\n(define solution string-reverse)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"51c8991dee245d7ddf00000e":[{"id":289523,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (reverse_words words)\n  (string-join (reverse (string-split words))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289524,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define reverse_words\n  (compose string-join reverse string-split))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289525,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (reverse_words words)\n  (string-join (rev-list (string-split words)))\n)\n\n(define rev-list (lambda (ls) (\n    if (null? ls)\n        empty\n        (append (rev-list (cdr ls)) (list (car ls)))\n    \n)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289526,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (reverse_words words)\n  compose (string-join (reverse (string-split words))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289527,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (get-words lst)\n  (let loop ([l (string->list lst)]\n             [word '()]\n             [dst '()])\n    (cond [(empty? l) (if (empty? word) dst (cons (reverse word) dst))]\n          [(char=? (first l) #\\space) (loop (rest l) '() (cons (reverse word) dst))]\n          [else (loop (rest l) (cons (first l) word) dst)])))\n\n\n(define (back-to-string lst)\n  (when (= (length lst) 1) (list->string (first lst)))\n  (let loop ([l lst]\n             [dst \"\"])\n    (cond [(empty? l)\n           dst]\n          [(string=? dst \"\")\n           (loop (rest l) (format \"~a~a\" dst (list->string (first l))))]\n          [else\n           (loop (rest l) (format \"~a ~a\" dst (list->string (first l))))])))\n\n\n(define (reverse_words words)\n  (back-to-string (get-words words)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289528,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n( define reverse_words\n  ( compose string-join reverse (curryr string-split \" \") ) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289529,"user_id":null,"body":"#lang racket\n\n(provide reverse_words)\n\n;; String -> String\n(define (reverse_words words)\n  (string-join (reverse (string-split words))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289530,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (remove-last-whitespace lst)\n  (cond\n    ((null? (cdr lst)) (quote ()))\n    (else (cons (car lst) (remove-last-whitespace (cdr lst))))))\n\n(define (reverse-lst lst)\n  (cond\n    ((null? lst) \"\")\n    (else (string-append (reverse-lst (cdr lst)) (string-append (car lst) \" \")))))\n\n(define (next-space lst)\n  (cond\n    ((null? lst) '())\n    ((equal? \" \" (car lst)) (cdr lst))\n    (else (next-space (cdr lst)))))\n\n(define (skip-spaces lst)\n  (cond\n    ((null? lst) '())\n    (else (cons (char->words lst) (skip-spaces (next-space lst))))))\n\n(define (char->words lst)\n  (cond\n    ((or (null? lst) (equal? \" \" (car lst))) \"\")\n    (else (string-append (car lst) (char->words (cdr lst))))))\n\n(define (reverse_words str)\n  (list->string\n   (remove-last-whitespace\n    (string->list\n     (reverse-lst (skip-spaces (map string (string->list str))))))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289531,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (reverse_words words)\n  (local\n    [(define (word-lst words)\n       (cond\n         [(empty? words) empty]\n         [(equal? #\\space (first words))\n          (append empty\n                  (list (list (word-lst (rest words)))))]\n         [else\n          (append (list (list (first words))\n                        (word-lst (rest words))))]))\n     (define (reverse words)\n       (local\n         [(define (insert n lst)\n            (cond\n              [(empty? lst) (list n)]\n              [else (append lst (list n))]))]\n\n         (cond\n           [(empty? words) empty]\n           [else\n            (insert (first words)\n                    (reverse (rest words)))])))\n     (define (produce-first words)\n       (cond\n         [(empty? words) empty]\n         [(equal? #\\space (first words)) empty]\n         [else\n          (append (list (first words))\n                  (produce-first (rest words)))]))\n\n     (define (remove-elements n lst)\n       (cond\n         [(empty? lst) empty]\n         [(= n 0) lst]\n         [else\n          (remove-elements (sub1 n) (rest lst))]))\n\n     (define (wordlst words)\n       (cond\n         [(empty? words) empty]\n         [else (append (list (produce-first words))\n                       (wordlst (remove-elements\n                                 (add1 (length (produce-first words)))\n                                 words)))]))\n     (define (convert-to-one lst)\n       (cond\n         [(empty? lst) empty]\n         [else\n          (append (first lst)\n                  (list #\\space)\n                  (convert-to-one (rest lst)))]))\n     (define (remove-last lst)\n       (cond\n        [(empty? lst) empty]\n         [(empty? (rest lst)) empty]\n         [else\n          (append (list (first lst))\n                  (remove-last (rest lst)))]))]\n    \n    (list->string\n     (remove-last\n      (convert-to-one (reverse (wordlst (string->list words))))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289532,"user_id":null,"body":"#lang racket\n(provide reverse_words)\n\n(define (reverse_words s) (string-join (reverse (string-split s))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"51f9d93b4095e0a7200001b8":[{"id":289533,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define (how_many_light_sabers_do_you_own name)\n  (if (equal? name \"Zach\") 18 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289534,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define (how_many_light_sabers_do_you_own name)\n  (cond\n   [(string=? \"Zach\" name) 18]\n   [else 0]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289535,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define\/match (how_many_light_sabers_do_you_own name)\n  [(\"Zach\") 18]\n  [(name) 0])\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289536,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define (how_many_light_sabers_do_you_own name)\n  (cond \n    ((equal? name \"Zach\") 18)\n    (else 0)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289537,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define (how_many_light_sabers_do_you_own name)\n  (if (string-ci=? name \"zach\") 18 0))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289538,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n( define (how_many_light_sabers_do_you_own name)\n  ( if (string=? name \"Zach\") 18 0 ) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289539,"user_id":53,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define (how_many_light_sabers_do_you_own n)\n (cond\n     [(equal? n \"Zach\") 18]\n     [else 0]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289540,"user_id":544,"body":"#lang racket\n(provide how_many_light_sabers_do_you_own)\n\n(define lightsaber-ownership (hash \"Zach\" 18))\n\n(define (how_many_light_sabers_do_you_own name)\n  (hash-ref lightsaber-ownership name 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289541,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n(define (how_many_light_sabers_do_you_own name)\n    (if (equal? name \"Zach\")               ; \u6d4b\u8bd5\u8868\u8fbe\u5f0f\n    18; \u4e3a\u771f\u7684\u8868\u8fbe\u5f0f\n    0) ; \u4e3a\u5047\u7684\u8868\u8fbe\u5f0f\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289542,"user_id":null,"body":"#lang racket\n\n(provide how_many_light_sabers_do_you_own)\n\n;; String -> Integer\n;; given person's name, return the number of lighsaber she\/he owns\n(define (how_many_light_sabers_do_you_own name)\n  (cond\n   [(string=? name \"Zach\") 18]\n   [else 0]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"51fc12de24a9d8cb0e000001":[{"id":289543,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(define (valid-isbn10? isbn)\n  (if (or (not (eq? (string-length isbn) 10))\n          (for\/or ([ch (substring isbn 0 9)])\n            (or (> (char->integer ch) (char->integer #\\9))\n                (< (char->integer ch) (char->integer #\\0)))))\n    #f\n    (eq? (remainder (isbn-sum isbn) 11) 0)))\n\n(define (conv ch)\n  (if (eq? ch #\\X)\n    10\n    (- (char->integer ch) (char->integer #\\0))))\n\n(define (isbn-sum isbn)\n  (for\/sum ([n (map conv (string->list isbn))] [i (in-naturals 1)]) (* n i)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289544,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(define (valid-isbn10? isbn)\n  (call\/cc\n    (lambda (return-cont)\n      (letrec ((add-placewise\n                (lambda (x place)\n                  (cond\n                    ((eq? place 10) (if (null? x) 0 (return-cont #f))) ;if we get to the end\n                    ((null? x) (return-cont #f)) ;if we get a string less than length 10, return false imediatly through the continuation\n                    ((char=? (car x) #\\X) (if (eq? place 9) (+ 100 (add-placewise (cdr x) 10)) (return-cont #f))) ;if X is at the end, add 100, else #f through the continuation\n                    ((>= (char->integer (car x)) 58) (return-cont #f))\n                    (#t (+ (* (+ 1 place) (- (char->integer (car x)) 48)) (add-placewise (cdr x) (+ 1 place)))))))) ;do the recursion\n        (eq? (modulo (add-placewise (string->list isbn) 0) 11) 0)))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289545,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(define (valid-isbn10? isbn)\n  (let* \n      ([ls (string->list isbn)] \n       [n1 (length ls)]\n       [ls (map (lambda (x) (if (equal? #\\X (char-upcase x)) 10 (string->number (string x)))) ls)]\n       [ls (filter number? ls)]\n       [n (length ls)]\n       [ls10 (member 10 ls)])\n    (cond\n      [(< 10 n1) #f]\n      [(and (or (not ls10) (> 2 (length ls10)))(= 10 n) (zero? (modulo (apply + (map * ls '(1 2 3 4 5 6 7 8 9 10))) 11))) #t]\n      [else #f])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289546,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(require srfi\/1)\n\n(define (valid-isbn10? isbn)\n  (let ((isbn (map (lambda (c) (list-index (curry equal? c) (string->list \"0123456789X\"))) (string->list isbn))))\n    (and (= 10 (length isbn))\n         (not (memq #f isbn))\n         (member (memq 10 isbn) '((10) #f))\n         (= 0 (car (foldl (lambda (x t) (cons (modulo (+ (car t) (* (cdr t) x)) 11) (+ 1 (cdr t))))\n                          (cons 0 1)\n                          isbn))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289547,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(require srfi\/1)\n\n(define (valid-isbn10? isbn)\n  (let ((isbn (map (lambda (c) (list-index (curry equal? c) (string->list \"0123456789X\"))) (string->list isbn))))\n    (display isbn)\n    (and (= 10 (length isbn))\n         (not (memq #f isbn))\n         (member (memq 10 isbn) '((10) #f))\n         (= 0 (car (foldl (lambda (x t) (cons (modulo (+ (car t) (* (cdr t) x)) 11) (+ 1 (cdr t))))\n                          (cons 0 1)\n                          isbn))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289548,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(define (char->number c)\n  (if (char=? c #\\X)\n      10\n      (- (char->integer c) 48)))\n\n(define (valid-isbn10-digits? isbn)\n  (for\/and ([c isbn]\n            [i (range 1 (add1 (string-length isbn)))])\n    (or (and (char<=? #\\0 c) (char<=? c #\\9))\n        (and (= i 10) (char=? c #\\X)))))\n\n(define (valid-isbn10? isbn)\n  (and\n   (= 10 (string-length isbn))\n   (valid-isbn10-digits? isbn)\n   (zero? (modulo (for\/sum ([n (map char->number (string->list isbn))]\n                            [i (range 1 (add1 (string-length isbn)))])\n                    (* n i))\n                  11))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289549,"user_id":null,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(define legal-chars \"0123456789X\")\n\n(define (char->number c)\n  (if (equal? c #\\X)\n      10\n      (string->number (string c))))\n\n(define (isbn10-checksum isbn)\n  (define (position-product-sum isbn pos)\n    (if (<= pos 10)\n        (+ (* pos (char->number (string-ref isbn (- pos 1))))\n           (position-product-sum isbn (+ pos 1)))\n        0))\n  (position-product-sum isbn 1))\n\n(define (valid-isbn10? isbn)\n  (if (equal? (string-length isbn) 10)\n    (if (foldl (lambda (a b)\n                 (and (string-contains? legal-chars (string a)) b))\n               #t\n               (string->list isbn))\n        (if (string-contains? (substring isbn 0 9) \"X\")\n            #f\n            (zero? (remainder (isbn10-checksum isbn) 11)))\n        #f)\n    #f))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289550,"user_id":544,"body":"#lang racket\n\n(provide valid-isbn10?)\n\n(define (valid-isbn10? isbn)\n  (cond\n    [(not (regexp-match-exact? #px\"^[0-9]{9}[0-9X]$\" isbn)) #false]\n    [else\n     (define weighted-sum\n       (for\/sum ([digit (in-string isbn)]\n                 [weight (in-naturals 1)])\n         (if (equal? digit #\\X)\n             (* 10 weight)\n             (* (string->number (string digit)) weight))))\n     (= 0 (modulo weighted-sum 11))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"523b4ff7adca849afe000035":[{"id":289551,"user_id":645,"body":"#lang racket\n\n(provide greet)\n\n(define (greet) \"hello world!\")","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289552,"user_id":null,"body":"#lang racket\n(provide greet)\n\n(define-syntax (hello subject)\n  (syntax-case subject ()\n    [(_ subject)\n     (when (equal? (syntax->datum #'subject) 'world)\n       #'(quote \"hello world!\"))]))\n\n(define (greet) (hello world))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289553,"user_id":527,"body":"#lang racket\n(provide greet)\n(define-syntax-rule (greet) \"hello world!\")","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289554,"user_id":null,"body":"\n; Provide a function \"greet\" that returns \"hello world!\"\n\n#lang racket\n\n(provide greet)\n(define (greet)\n  \"hello world!\")","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289555,"user_id":null,"body":"#lang racket\n\n(define (greet)\n  (let ([o (open-output-string)])\n  (fprintf o \"hello world!\")\n  (get-output-string o)))\n(provide greet)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289556,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet)\n  \"hello world!\"\n  )\n; Provide a function \"greet\" that returns \"hello world!\"","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289557,"user_id":null,"body":"#lang racket\n\n; Provide a function \"greet\" that returns \"hello world!\"\n(provide greet)\n(define (greet) \"hello world!\")\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289558,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet)\n    (define g '(h e l l o w o r l d !))\n    (foldr string-append\n           \"\"\n           (map (lambda (l)\n                  (if (eq? l 'w) \" w\"\n                      (symbol->string l)))\n                g)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289559,"user_id":null,"body":"#lang racket\n\n; Provide a function \"greet\" that returns \"hello world!\"\n(define (greet) \"hello world!\")\n(provide greet)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289560,"user_id":null,"body":"#lang racket\n\n; Provide a function \"greet\" that returns \"hello world!\"\n(provide greet)\n(define greet (lambda () \"hello world!\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5265326f5fda8eb1160004c8":[{"id":289561,"user_id":527,"body":"#lang racket\n\n(provide number_to_string)\n\n(define number_to_string number->string)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289562,"user_id":null,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (number_to_string z)\n  (define pn (positive? z))\n  (let loop ([n (abs z)][s \"\"])\n    (let-values ([(q r) (quotient\/remainder n 10)])\n      (if (zero? n)\n          (if pn s (string-append \"-\" s))\n          (loop q (string-append (string (integer->char (+ r 48)))\n                                 s))))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289563,"user_id":null,"body":"#lang racket\n\n(provide number_to_string)\n\n(define number_to_string ~v)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289564,"user_id":null,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (number_to_string z)\n  (~v z))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289565,"user_id":null,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (number_to_string z)\n  (format \"~a\" z))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289566,"user_id":50,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (number_to_string z)\n (~r z))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289567,"user_id":53,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (number_to_string z)\n  (define str (~v z))\n  str\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289568,"user_id":168,"body":"#lang racket\n\n(provide number_to_string)\n\n(define number_to_string ~a)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289569,"user_id":null,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (digit->char d)\n  (case d\n    [(0) #\\0]\n    [(1) #\\1]\n    [(2) #\\2]\n    [(3) #\\3]\n    [(4) #\\4]\n    [(5) #\\5]\n    [(6) #\\6]\n    [(7) #\\7]\n    [(8) #\\8]\n    [(9) #\\9]))\n    \n(define (digits n)\n  (cond [(< n 10) (cons (digit->char n) null)]\n        [else (cons \n               (digit->char (remainder n 10)) \n               (digits (quotient n 10)))]))\n\n(define (number->char-list z)\n  (cond [(= z 0) (list (digit->char 0))]\n        [(< z 0) (cons #\\- (reverse (digits (abs z))))]\n        [else (reverse (digits z))]))\n\n\n\n(define (number_to_string z)\n  (list->string (number->char-list z)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289570,"user_id":null,"body":"#lang racket\n\n(provide number_to_string)\n\n(define (number_to_string z)\n  (number->string z 10))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"53369039d7ab3ac506000467":[{"id":289571,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (if b \"Yes\" \"No\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289572,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide bool_to_word)\n\n\n;; Boolean -> String\n;; return \"Yes\" for #t and \"No\" for #f\n(define (bool_to_word b)\n  (if b \"Yes\" \"No\"))\n\n(module+ test\n  (check-equal? (bool_to_word #t) \"Yes\")\n  (check-equal? (bool_to_word #f) \"No\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289573,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (match b\n    [#t \"Yes\"]\n    [#f \"No\"]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289574,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (if (equal? #t b) \"Yes\"\n      \"No\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289575,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (if (equal? true b)\n     \"Yes\" \"No\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289576,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (if (eq? #t b)\n      \"Yes\"\n      \"No\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289577,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (if (not (false? b))\n      \"Yes\"\n      \"No\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289578,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (if (equal? b #t)\n      \"Yes\"\n      (if (equal? b #f)\n          \"No\"\n          \"error\")))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289579,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define (bool_to_word b)\n  (cond \n   [(equal? b #t)\"Yes\"]\n   [else\"No\"])\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289580,"user_id":null,"body":"#lang racket\n\n(provide bool_to_word)\n\n(define\/match (bool_to_word b)\n  [(#t) \"Yes\"]\n  [(#f) \"No\"])\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"53c9157c689f841d16000c03":[{"id":289581,"user_id":168,"body":"#lang racket\n(provide totient)\n\n(define (divide n p)\n  (if (zero? (remainder n p)) (divide (quotient n p) p) n))\n\n(define (totient n)\n  (for\/fold ([m n] [t n] #:result (if (> m 1) (- t (quotient t m)) t))\n            ([p (in-range 2 n)] #:break (> (* p p) m))\n    (if (zero? (remainder m p))\n        (values (divide m p) (- t (quotient t p)))\n        (values m t)))) \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289582,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (prime-factors m)\n  (let iter ([n m] [i 2] [primes (set)])\n    (cond [(zero? (remainder n i)) (iter (\/ n i) i (set-add primes i))]\n          [(> i (sqrt m)) (if (> n 2) (set-add primes n) primes)]\n          [(= 2 i) (iter n 3 primes)]\n          [else (iter n (+ 2 i) primes)])))\n\n(define (totient n)\n  (apply * n (set-map (prime-factors n) (\u03bb (x) (- 1 (\/ x))))))\n  \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289583,"user_id":null,"body":"#lang racket\n(provide totient)\n\n\n(define (totient n)\n    (let loop [(k 2) (acc n) (m n) (times 1)]\n      (cond\n       [(<= n 2) 1]\n       [(equal? k m) acc]\n       [(> (sqr k) m)(println (sqr k)) (* acc (- 1 (\/ 1 m)))]\n       [(zero? (modulo m k)) (loop k (if (equal? 1 times) (* acc (- 1 (\/ 1 k))) acc) (\/ m k) (add1 times))]\n       [else (loop (add1 k) acc m 1)])))\n\n#|\n\n(define (totient n)\n    (let loop [(k 2) (acc n) (m n)]\n      (println k)\n      (println acc)\n      (println m)\n      (cond\n       [(equal? 1 m) acc]\n       [(>= (sqr k) m) (* acc (- 1 (\/ 1 m)))]\n       [(zero? (modulo m k)) (loop (add1 k) (* acc (- 1 (\/ 1 k))) (\/ m k))]\n       [else (loop (add1 k) acc m)])))\n\n(define (totient n)\n      (length (filter (curry coprime? n) (range  n))))\n\n(define (coprime? n m)\n  (equal? (gcd n m) 1))\n\n(define (prime? n)\n  (let loop ((d 2))\n    (cond ((< n (* d d)) #t)\n          ((zero? (modulo n d)) #f)\n          (else (loop (+ d 1))))))\n\n(define (totient n)\n  (cond\n   [(or (equal? n 1) (equal? n 2)) 1]\n   [(prime? n) (sub1 n)]\n   [(totient-it n 1 0)]))\n\n(define (totient-it n curr acc)\n  (print curr)\n  (print \"-\")\n  (println acc)\n  (cond\n   (let loop (n curr acc\n                [(> curr n) acc]\n   [(equal? (gcd curr n) 1) (totient-it n (add1 curr) (add1 acc))]\n   [else (totient-it n (add1 curr) acc)]))))\n\n(define (prime? n)\n  (let loop ((d 2))\n    (cond ((< n (* d d)) #t)\n          ((zero? (modulo n d)) #f)\n          (else (loop (+ d 1))))))\n\n\n  let gcd the function that gets greatest common divisor between two numbers\n  let prime? the function that returns if a number is prime or not\n  let n the input number\n  let k the relatively prime to n (gcd(n, k) = 1)\n  let acc be the accumulator that counts k numbers (starting from 1)\n  let curr be the current number to evaluate (2 < curr < n)\n  iteratively we evaluate the current number, checking: \n    if (prime? n) =>\n      => return n - 1\n    if gcd(curr, n) = 1 \n      => we increment acc by 1 and increment curr by 1\n    else\n      => we proceed by incrementing curr by 1 and recurring to the main proc\n|#\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289584,"user_id":53,"body":"#lang racket\n(provide totient)\n\n(define (totient-calc n p r i)\n  (cond\n   [(and (zero? i) (> (* p p) n) (> n 1)) (exact-floor (* r (- 1 (\/ 1 n))))]\n   [(and (zero? i) (> (* p p) n)) (exact-floor r)]\n   [(and (zero? i) (not (zero? (modulo n p)))) (totient-calc n (add1 p) r i)]\n   [(zero? i) (totient-calc n p r 1)]\n   [(zero? (modulo n p)) (totient-calc (quotient n p) p r i)]\n   [else (totient-calc n (add1 p) (* r (- 1 (\/ 1 p))) 0)]))\n\n(define (totient n)\n  (if (integer? n)\n      (totient-calc n 2 n 0)\n      0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289585,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (take-divisors n factor)\n  (if (zero? (remainder n factor))\n      (take-divisors (quotient n factor) factor)\n      n))\n\n(define (prime-factors n lpf sofar)\n  (cond [(= n 1) (reverse sofar)]\n        [(> (* lpf lpf) n) (prime-factors 1 lpf (cons n sofar))]\n        [(zero? (remainder n lpf))\n         (prime-factors (take-divisors n lpf)\n                        (add1 lpf)\n                        (cons lpf sofar))]\n        [else (prime-factors n (add1 lpf) sofar)]))\n  \n  \n(define (totient n)\n  (comp-totient n (prime-factors n 2 '()))\n)\n\n(define (comp-totient n factors)\n  (if (null? factors)\n      n\n      (let ([p (car factors)])\n        (comp-totient (* (quotient n p) (sub1 p))\n                      (cdr factors)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289586,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (totient n)\n  (define (go m i a f)\n    (if (< n (sqr i))\n        `(,f ,m)\n        (let ([q (\/ m i)])\n             (if (integer? q)\n                 (go q i #t\n                    (if a f (sequence-append f `(,i))))\n                 (go m (+ i 1) #f f)))))\n  (match-let ([`(,d, k) (go n 2 #f 0)])\n    (foldl\n      (\u03bb (p a) (- a (\/ a p)))\n      n\n      `(,@(if (= k 1) '() `(,k)) ,@(sequence->list d)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289587,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (prime? n)\n  (cond\n    [(< n 2) #f]\n    [(= n 2) #t]\n    [(even? n) #f]\n    [else\n     (define ub (integer-sqrt n))\n     (for\/and ([k (in-range 3 (add1 ub) 2)])\n       (not (zero? (remainder n k))))]))\n\n(define (factor n)\n  (define ub (integer-sqrt n))\n  (let loop ([k 2])\n    (cond [(> k ub) (error 'factor \"can't factor ~a\" n)]\n          [(zero? (remainder n k)) (values k (quotient n k))]\n          [else (loop (add1 k))])))\n\n(define (totient n)\n  (cond\n    [(= n 1) 1]\n    [(prime? n) (sub1 n)]\n    [else\n     ;; \u03c6(mn) = \u03c6(m)\u03c6(n) * (d \/ \u03c6(d)) where d = gcd(m, n)\n     (define-values (k m) (factor n))\n     (define d (gcd k m))\n     (* (totient k) (totient m) (\/ d (totient d)))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289588,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (divisors n p lst)\n  (if (> n 1) \n    (if (> (modulo n p) 0) \n      (if (< (* p p) n) (divisors n (+ p 1) lst) (cons n lst))\n      (divisors (\/ n p) p (cons p lst))) \n    lst))\n\n(define (totient n)\n  (define ps (divisors n 2 '()))\n  (define l (length ps))\n  (if (> l 1) \n    (foldl * n (map (lambda (p) (- 1 (\/ 1 p))) (remove-duplicates ps)))\n    (if (= l 1) (- (car ps) 1) 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289589,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (prime-factors n [p 2] [lst '()])\n  \"Find unique prime factors of n\"\n  (define (cons* item lst)\n    \"cons if item is not the same as the first of lst\"\n    (cond\n     [(empty? lst) (cons item lst)]\n     [(= item (car lst)) lst]\n     [else (cons item lst)]))\n  (cond\n   [(= n 1) lst]\n   [(> (* p p) n) (cons* n lst)]\n   [(zero? (remainder n p)) (prime-factors (\/ n p) p (cons* p lst))]\n   [else (prime-factors n (add1 p) lst)]))\n\n(define (totient n)\n  \"Computes euler's totient function on n\"\n  (let loop\n      ([factors (prime-factors n)]\n       [ans n])\n    (if (empty? factors)\n        ans\n        (loop (cdr factors)\n              (* ans (- 1 (\/ 1 (car factors))))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289590,"user_id":null,"body":"#lang racket\n(provide totient)\n\n(define (totient n)\n  ;; Helper function to divide out the given prime factor.\n  (define (division-loop p n0)\n    (if (= 0 (remainder n0 p))\n        (division-loop p (\/ n0 p))\n        n0))\n  ;; Helper function to loop through factors.\n  (define (totient-loop p n0 acc)\n    (if (> (* p p) n0)\n        (if (> n0 1)\n            (- acc (\/ acc n0))\n            acc)\n        (if (= 0 (remainder n0 p))\n            (let ([n1 (division-loop p n0)])\n              (totient-loop (add1 p) n1 (- acc (\/ acc p))))\n            (totient-loop (add1 p) n0 acc))))\n  (totient-loop 2 n n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"53da3dbb4a5168369a0000fe":[{"id":289591,"user_id":168,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (if (even? n) \"Even\" \"Odd\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289592,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (cond [(even? n) \"Even\"]\n        [else \"Odd\"]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289593,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (if (odd? n) \"Odd\" \"Even\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289594,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (cond\n   [(= 0 (modulo n 2)) \"Even\"]\n   [else \"Odd\"]\n  )\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289595,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n;; Integer -> String\n;; return \"Even\" if n is even and \"Odd\" if not.\n(define (even_or_odd n)\n  (if (even? n)\n      \"Even\"\n      \"Odd\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289596,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (if (zero? (bitwise-and n 1)) \"Even\" \"Odd\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289597,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (cond\n   ((even? n) \"Even\")\n   (else \"Odd\")))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289598,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define(even_or_odd n)\n  (if (= (abs (remainder n 2)) 1)\n      \"Odd\"\n      \"Even\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289599,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (cond\n   [(even? n) \"Even\"]\n   [\"Odd\"]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289600,"user_id":null,"body":"#lang racket\n\n(provide even_or_odd)\n\n(define (even_or_odd n)\n  (cond\n   [(= (modulo n 2) 1) \"Odd\"]\n   [else \"Even\"]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"53dc23c68a0c93699800041d":[{"id":289601,"user_id":527,"body":"#lang racket\n(provide smash)\n\n(define smash string-join)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289602,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (string-join words))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289603,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (define (helper words smashed)\n    (if (or(null?  words)  (not (list? words)))\n        ;list completely empty\n        smashed\n        (if (list? (car words) )\n            (helper (car words) smashed)\n            ;catch nested list passes it on\n        (if (null?(cdr words))\n            (string-append smashed (car words))\n              ;rest of list except head empty\n            (helper (cdr words) (string-append smashed (string-append (car words) \" \" )))))\n        ;no parts are empty\n\n        ))\n      \n      (helper words \"\")\n      )\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289604,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (if (null? words) \"\"\n    (foldl (lambda (w s) (string-append s (string-append \" \" w))) (car words) (cdr words))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289605,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (string-trim (foldr \n   (lambda (a b) (string-append a \" \" b))\n   \"\"\n   words)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289606,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (cond\n    ((null? words) \"\")\n    ((null? (cdr words)) (car words))\n    (else (string-append (car words) \" \" (smash (cdr words))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289607,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (match words\n         [(cons fst '()) fst]\n         [(cons fst rst) (string-append fst \" \" (smash rst))]\n         [(? empty?) \"\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289608,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (if (null? words) \"\"\n      (string-append (car words)\n                     (if (null? (cdr words)) \"\"\n                                (string-append \" \"\n                                               (smash (cdr words)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289609,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash word)\n  (string-append* (add-between word \" \")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289610,"user_id":null,"body":"#lang racket\n(provide smash)\n\n(define (smash words)\n  (apply string-append (add-between words \" \")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"53dc54212259ed3d4f00071c":[{"id":289611,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst)\n  (if (null? lst)\n      0\n  (foldl + 0 lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289612,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array L)\n  (apply + L))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289613,"user_id":527,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst)\n  (for\/sum_array ([x lst]) x))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289614,"user_id":168,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst) (apply + lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289615,"user_id":53,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array ls) (apply + 0 ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289616,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst)\n  (define (iter acc lst)\n    (if (null? lst)\n        acc\n        (iter (+ acc (car lst)) (cdr lst))))\n  (iter 0 lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289617,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array list)\n  (foldl + 0 list))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289618,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst)\n  (define (sum_array-iter res lst)\n    (if (null? lst) res\n        (sum_array-iter (+ res (car lst)) (cdr lst))))\n  (sum_array-iter 0 lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289619,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst)\n  (for\/sum_array ([i lst]) i))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289620,"user_id":null,"body":"#lang racket\n\n(provide sum_array)\n\n(define (sum_array lst)\n  (apply + (filter number? lst)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"542c0f198e077084c0000c2e":[{"id":289621,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n; Number -> Number\n; given natural number n count\n; all its divisors\n(define (divisors n)\n  (for\/sum ([i (in-range 1 (add1 n) 1)])\n           (if (zero? (modulo n i)) 1 0)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289622,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (divisors n)\n  (length\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (+ 1 n)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289623,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (divisors2 n i counter)\n  (if (= i (+ (quotient n 2) 1)) counter \n    (if (= (remainder n i) 0) \n      (divisors2 n (+ i 1) (+ counter 1))\n        (divisors2 n (+ i 1) counter)))\n)\n\n(define (divisors n)\n  (if (= n 1) 1 (divisors2 n 1 1))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289624,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (count_divisors a b)\n  (if (> a b)\n      0\n      (+ (if (= (modulo b a) 0) 1 0)\n         (count_divisors (+ 1 a) b))))\n\n(define (divisors n)\n  (count_divisors 1 n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289625,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (divisors n)\n  #| your code here |#\n  (actualDivisors n 0 1)\n  )\n\n(define (actualDivisors a b c)\n  (if (> c a)\n      b\n      (if (= (modulo a c) 0)\n        (actualDivisors a (+ b 1) (+ c 1))\n        (actualDivisors a b (+ c 1))\n      )\n      )\n  \n  \n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289626,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (divisors n)\n  (length (filter (lambda (x) (equal? (remainder n x) 0)) (range 1 (add1 n))))\n  #| your code here |#)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289627,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (check n i)\n  (if (equal? i 0)\n      0\n      (+ (if (equal? (remainder n i) 0) \n             1 \n             0)\n         (check n (- i 1)))))\n\n(define (divisors n)\n  (check n n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289628,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (divisors n)\n  (length\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (+ n 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289629,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (divisors n)\n  (define (divi n m c)\n    (cond \n     [(zero? m) c]\n     [(= 0 (remainder n m)) (divi n (sub1 m) (add1 c))]\n     [else (divi n (sub1 m) c)]))\n  (divi n n 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289630,"user_id":null,"body":"#lang racket\n\n(provide divisors)\n\n(define (ndivisors acc current n)\n  (let-values ([(q r) (quotient\/remainder n current)])\n    (if (> (* current current) n)\n        acc \n        (ndivisors (+ acc\n                      (cond\n                        [(positive? r) 0]\n                        [(equal? q current) 1]\n                        [else 2]))\n                   (+ current 1)\n                   n))))\n\n \n(define (divisors n)\n  (ndivisors 0 1 n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"542f0c36d002f8cd8a0005e5":[{"id":289631,"user_id":53,"body":"#lang racket\n(provide last_chair)\n\n(define (last_chair n) (sub1 n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289632,"user_id":168,"body":"#lang racket\n(provide last_chair)\n\n(define last_chair sub1)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289633,"user_id":null,"body":"#lang racket\n(provide last_chair)\n\n(define (last_chair n)\n    ;; your code\n    (if (< n 3)\n        n\n        (- n 1))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289634,"user_id":492,"body":"#lang racket\n(provide last_chair)\n\n(define (last_chair n)\n    (- n 1)\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"544675c6f971f7399a000e79":[{"id":289635,"user_id":564,"body":"#lang racket\n(provide string_to_number)\n\n(define (string-first str) (string-ref str 0))\n(define (string-rest str) (substring str 1))\n(define (negative n) (- 0 n))\n(define (char-to-number c) (- (char->integer c) 48))\n\n(define (string_to_number str [prev 0])\n  (if (= 0 (string-length str))\n      prev\n      (if (equal? #\\- (string-first str))\n          (negative (string_to_number (string-rest str)))\n          (let ([prev\n                 (+\n                  (* 10 prev)\n                  (char-to-number (string-first str)))])\n            (string_to_number (string-rest str) prev)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289636,"user_id":null,"body":"#lang racket\n(provide string_to_number)\n\n(define string_to_number string->number)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289637,"user_id":527,"body":"#lang racket\n(provide string_to_number)\n\n(define (string_to_number str)\n  (string->number str))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289638,"user_id":null,"body":"#lang racket\n(provide string_to_number)\n\n;; (define (string_to_number str)\n;;  (error \"TODO: string_to_number\"))  \n\n(define string_to_number string->number)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289639,"user_id":null,"body":"#lang racket\/base\n\n(provide string_to_number)\n\n(define (string_to_number str)\n  (string->number str))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289640,"user_id":544,"body":"#lang racket\n(provide string_to_number)\n\n;; I know (string->number str) does it but I want to be extra\n;;\n(define (string_to_number str)\n  (define digit-list (string->list str))\n  (for\/fold ([n 0])\n            ([d (reverse digit-list)]\n             [place (in-naturals)])\n    (cond [(equal? d #\\-) (- n)]\n          [else (+ n (* (- (char->integer d) 48) (expt 10 place)))])))  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289641,"user_id":null,"body":"#lang racket\n(provide string_to_number)\n\n(define (string_to_number str)\n  (let ([ch-list (string->list str)])\n    (if (char=? (first ch-list) #\\-)\n        (* -1 (digit-list-to-number 0 (rest ch-list)))\n        (digit-list-to-number 0 ch-list))))\n\n(define (digit-list-to-number acc d-list)\n    (if (empty? d-list)\n        acc\n        (let ([digit (- (char->integer (first d-list))\n                        (char->integer #\\0))])\n          (digit-list-to-number (+ (* 10 acc) digit)\n                                (rest d-list)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289642,"user_id":null,"body":"#lang racket\n(provide string_to_number)\n\n(define (string_to_number str)\n  (cond\n   [(string? str) (string->number str)]\n   [(number? str) (str)]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289643,"user_id":null,"body":"#lang racket\n(provide string_to_number)\n\n(define (char->digit c)\n  (case c [(#\\0) 0]\n          [(#\\1) 1]\n          [(#\\2) 2]\n          [(#\\3) 3]\n          [(#\\4) 4]\n          [(#\\5) 5]\n          [(#\\6) 6]\n          [(#\\7) 7]\n          [(#\\8) 8]\n          [(#\\9) 9]))\n          \n(define (digits-to-number lst) \n  (cond [(null? lst) 0]\n        [else (+ (char->digit (car lst)) \n                 (* 10 (digits-to-number (cdr lst))))])) \n                 \n(define (chars-to-number lst)\n  (cond [(null? lst) 0]\n        [(char=? (car lst) #\\-) (- (digits-to-number (reverse (cdr lst))))]\n        [else (digits-to-number (reverse lst))]))\n\n(define (string_to_number str)\n  (chars-to-number (string->list str)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289644,"user_id":null,"body":"#lang racket\n(provide string_to_number)\n\n(define (string_to_number str)\n  (string->number str 10))  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54b724efac3d5402db00065e":[{"id":289645,"user_id":null,"body":"#lang racket\n\n(define morse-code \n     '#hash((\"-\" . \"T\")\n       (\"--\" . \"M\")\n       (\"---\" . \"O\")\n       (\"-----\" . \"0\")\n       (\"----.\" . \"9\")\n       (\"---..\" . \"8\")\n       (\"---...\" . \"=>\")\n       (\"--.\" . \"G\")\n       (\"--.-\" . \"Q\")\n       (\"--..\" . \"Z\")\n       (\"--..--\" . \"\")\n       (\"--...\" . \"7\")\n       (\"-.\" . \"N\")\n       (\"-.-\" . \"K\")\n       (\"-.--\" . \"Y\")\n       (\"-.--.\" . \"(\")\n       (\"-.--.-\" . \")\")\n       (\"-.-.\" . \"C\")\n       (\"-.-.--\" . \"!\")\n       (\"-.-.-.\" . \"\")\n       (\"-..\" . \"D\")\n       (\"-..-\" . \"X\")\n       (\"-..-.\" . \"\/\")\n       (\"-...\" . \"B\")\n       (\"-...-\" . \"=\")\n       (\"-....\" . \"6\")\n       (\"-....-\" . \"-\")\n       (\".\" . \"E\")\n       (\".-\" . \"A\")\n       (\".--\" . \"W\")\n       (\".---\" . \"J\")\n       (\".----\" . \"1\")\n       (\".----.\" . \"'\")\n       (\".--.\" . \"P\")\n       (\".--.-.\" . \"@\")\n       (\".-.\" . \"R\")\n       (\".-.-.\" . \"+\")\n       (\".-.-.-\" . \".\")\n       (\".-..\" . \"L\")\n       (\".-..-.\" . \"\\\"\")\n       (\".-...\" . \"&\")\n       (\"..\" . \"I\")\n       (\"..-\" . \"U\")\n       (\"..---\" . \"2\")\n       (\"..--.-\" . \"_\")\n       (\"..--..\" . \"?\")\n       (\"..-.\" . \"F\")\n       (\"...\" . \"S\")\n       (\"...-\" . \"V\")\n       (\"...--\" . \"3\")\n       (\"...---...\" . \"SOS\")\n       (\"...-..-\" . \"$\")\n       (\"....\" . \"H\")\n       (\"....-\" . \"4\")\n       (\".....\" . \"5\")))\n(provide decode_morse)\n\n(define (decode_morse str)\n  (define words\n    (string-split (string-replace str \"   \" \",\") \",\"))\n  (define (decode-word word)\n    (string-join\n      (map (lambda (letter) (hash-ref morse-code letter))\n           (string-split word))\n      \"\"))\n  (string-trim (string-join (map decode-word words) \" \")))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289646,"user_id":null,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse)\n\n(define (decode-morse str)\n  (define trimmed (string-trim str))\n  \n  (define words \n    (for\/list ([word (in-list (string-split trimmed \"   \"))])\n      (define chars\n        (for\/list ([code (in-list (string-split word \" \"))])\n          (hash-ref morse-code code)))\n      (apply string-append chars)))\n  \n  (string-join words \" \"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289647,"user_id":544,"body":"#lang racket\n(require \"preloaded.rkt\")\n(provide decode-morse)\n\n(define (decode-morse str)\n  (let* ([marked-spaces (string-replace (string-trim str) \"   \" \" X \")]\n         [split-morse (string-split marked-spaces)]\n         [converted-morse (for\/list ([letter (in-list split-morse)])\n                            (hash-ref morse-code letter \" \"))])\n    (string-join converted-morse \"\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54bf1c2cd5b56cc47f0007a1":[{"id":289648,"user_id":544,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count xs)\n  (let* ([x-lst (string->list (string-downcase xs))]\n         [x-unique (remove-duplicates x-lst)]\n         [x-filtered (filter (\u03bb (x) ((count (curry eq? x) x-lst) . > . 1)) x-unique)])\n    (length x-filtered)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289649,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count xs)\n  (let ([lowered (string->list (string-downcase xs))]\n        [freq (make-hash)])\n    (for ([c lowered])\n      (dict-update! freq c add1 0))\n\n    (for\/fold ([cnt 0])\n              ([(k v) freq]\n               #:when (> v 1))\n      (add1 cnt))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289650,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count xs)\n  \n  (define (duplicate_count-inner xxs doubles)\n    \n    (if (empty? xxs)\n        0   \n        (let ([x (car xxs)])\n        (let ([xs (cdr xxs)])\n          (if (empty? xs)\n              (length doubles)\n              (if (and \n                  (not (member x doubles)) \n                  (member x xs))\n              (duplicate_count-inner xs (cons x doubles))\n              (duplicate_count-inner xs doubles)))))))\n\n  (duplicate_count-inner (string->list (string-downcase xs)) `()))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289651,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (dict-incr k d)\n  (if (dict-has-key? d k)\n      (dict-update d k add1)\n      (dict-set d k 1)))\n\n(define (duplicate_count xs)\n  (length\n    (filter (\u03bb (ele) (> (cdr ele) 1))\n            (foldl dict-incr '() (string->list (string-upcase xs))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289652,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (dict-incr k d)\n  (if (dict-has-key? d k)\n      (dict-update d k add1)\n      (dict-set d k 1)))\n\n(define (duplicate_count xs)\n  (length\n    (filter (\u03bb (ele) (not (= 1 (cdr ele))))\n            (foldl dict-incr '() (string->list (string-upcase xs))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289653,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n(require racket\/list)\n(require racket\/function)\n\n(define (duplicate_count xs)\n  (define char-hash (make-hash))\n  \n  (for ([i xs])\n    (let ([ci-i (char-downcase i)])\n      (hash-set! char-hash ci-i (add1 (hash-ref! char-hash ci-i 0)))))\n  \n  (count identity (hash-map char-hash (lambda (k v) (> v 1)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289654,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count xs)\n  (let*\n    ([a (string->list (string-upcase xs))])\n    (length (cnt a))))\n\n(define (cnt ls)\n  (cond\n   [(null? ls) '()]\n   [(< 1 (- (length ls) (length (remove* (list (car ls)) ls)))) \n    (cons (- (length ls) (length (remove* (list (car ls)) ls))) \n          (cnt (remove* (list (car ls)) ls)))]\n   [else (cnt (cdr ls))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289655,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count xs)\n  (define char-counts (for\/fold ([counts (hash)])\n                                ([char (string-downcase xs)])\n                        (define current-count (hash-ref counts char 0))\n                        (hash-set counts char (add1 current-count))))\n  (foldl (lambda (char\/count acc)\n           (if (> (cdr char\/count) 1)\n               (add1 acc)\n               acc))\n         0\n         (hash->list char-counts)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289656,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count input)\n  (define letter-counts\n    (foldl (lambda (c result)\n             (hash-update result c add1 0)) \n           (hash) \n           (string->list (string-downcase input))))\n  (length (filter (lambda (key)\n                    (> (hash-ref letter-counts key) 1))\n                  (hash-keys letter-counts))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289657,"user_id":null,"body":"#lang racket\n(provide duplicate_count)\n\n(define (duplicate_count xs)\n  (define alph (make-hash))\n  (define lis (string->list (string-downcase xs)))\n  (define (dup-iter n)\n    (if (< n (length lis))\n        (begin\n         (hash-update! alph (list-ref lis n) add1 0)\n         (dup-iter (add1 n)))\n        (length (filter (lambda (n) (> n 1)) (hash-values alph)))))\n  (dup-iter 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54d1c59aba326343c80000e7":[{"id":289658,"user_id":1055,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ (exact->inexact  x) (exact->inexact  y)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289659,"user_id":564,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ x 1.0 y))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289660,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (exact->inexact (\/ x y)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289661,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ (exact->inexact x) y))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289662,"user_id":53,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ (+ x 0.0) y))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289663,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (+ (\/ x y) 0.0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289664,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ x (+ y 0.0)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289665,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ x (* 1.0 y)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289666,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define divide_numbers\n  (compose exact->inexact \/))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289667,"user_id":null,"body":"#lang racket\n\n(provide divide_numbers)\n\n(define (divide_numbers x y)\n  (\/ x y 1.0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54d512e62a5e54c96200019e":[{"id":289668,"user_id":492,"body":"#lang racket\n(provide prime_factors)\n\n(define (prime_factors n)\n  (define (factors number)\n    (let loop ([n (abs number)] [i 2])\n      (if (= n 1)\n          '()\n          (let-values ([(q r) (quotient\/remainder n i)])\n            (if (zero? r)\n                (cons i (loop q i))\n                (loop n (add1 i)))))))\n  \n  (let* ([u (factors n)]\n         [v (group-by (\u03bb(x) x) u)])\n    (string-join\n     (map\n      (\u03bb(x) (if (> (length x) 1)\n                (string-append \"(\" (~a (car x)) \"**\" (~a (length x)) \")\")\n                (string-append \"(\" (~a (car x)) \")\")))\n      v)\n     \"\")\n    )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289669,"user_id":53,"body":"#lang racket\n(provide prime_factors)\n\n(define (walk l i n cnt fs)\n  (cond\n    ((and (> i n) (= 0 l)) fs)\n    ((= 0 (modulo n i)) (walk 1 i (quotient n i) (add1 cnt) fs))\n    ((= 1 cnt) (walk 0 (add1 i) n 0 (append fs (list (format \"(~a)\" i)))))\n    ((< 1 cnt) (walk 0 (add1 i) n 0 (append fs (list (format \"(~a**~a)\" i cnt)))))\n    (else (walk 0 (add1 i) n 0 fs))))\n\n(define (prime_factors n)\n  (let ([ls (walk 0 2 n 0 null)])\n    (if (= 0 (length ls))\n        (format \"(~a)\" n)\n        (string-join (map ~a ls) \"\"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289670,"user_id":168,"body":"#lang racket\n(provide prime_factors)\n\n(define (factor n)\n  (for\/fold ([n n] [xs '()] \n             #:result (if (> n 1) (cons (cons n 1) xs) xs))\n            ([d (in-naturals 2)])\n            #:break (> (sqr d) n)\n    (for\/fold ([n n] [k 0] \n               #:result (values n (if (> k 0) (cons (cons d k) xs) xs)))\n              ([i (in-naturals)])\n              #:break (> (remainder n d) 0)\n              (values (\/ n d) (add1 k))))\n)\n\n(define (prime_factors n)\n  (for\/fold ([r \"\"])\n            ([p (factor n)])\n    (string-append \n       (if (= (cdr p) 1)\n           (format \"(~a)\" (car p))\n           (format \"(~a**~a)\" (car p) (cdr p)))\n       r))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289671,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (prime_factors n)\n  (define (make-factors f num lst)\n    (cond [(= num 1) lst]\n          [(= 0 (modulo num f)) (make-factors f (\/ num f) (cons f lst))]\n          [else (if (prime? num) (cons num lst)\n                    (make-factors (next-prime (+ 1 f)) num lst))]))\n  (define (group l c)\n    (cond [(null? (cdr l)) (list (list (car l) c))]\n          [(= (car l) (cadr l)) (group (cdr l) (+ 1 c))]\n          [else (cons (list (car l) c) (group (cdr l) 1))]))\n  (define (add-format lst)\n    (if (null? lst)\n        \"\"\n        (string-append\n          (if (= 1 (cadar lst))\n              (format \"(~s)\" (caar lst))\n              (format \"(~s**~s)\" (caar lst) (cadar lst)))\n          (add-format (cdr lst)))))\n\n  (add-format (group (sort (make-factors 2 n '()) <) 1))\n)\n\n(define (prime? n)\n  (define (iter x)\n    (cond [(> (* x x) n) true]\n          [(or (= 0 (modulo n x)) (= 0 (modulo n (+ x 2)))) false]\n          [else (iter (+ x 2))]))\n  (cond [(< n 2) false]\n        [(or (= n 2) (= n 3)) true]\n        [(or (= 0 (modulo n 2)) (= 0 (modulo n 3))) false]\n        [else (iter 5)]))\n\n(define (next-prime n)\n  (if (prime? n)\n      n\n      (next-prime (+ n 1))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289672,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (ndiv n div)\n  (let loop ([n n] [div div] [rep 0])\n    (if (= 0 (remainder n div)) (loop (quotient n div) div (+ 1 rep)) `(,n ,rep))))\n\n(define (prime_factors n)\n  (for\/fold ([res \"\"] [n n] #:result res) ([div (in-naturals 2)])\n    #:break (= n 1)\n    (match (ndiv n div)\n      [`(,d 0) (values res d)]\n      [`(,d 1) (values (format \"~a(~a)\" res div) d)]\n      [`(,d ,c) (values (format \"~a(~a**~a)\" res div c) d)])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289673,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (prime_factors n)\n  (foldl (lambda (val cur)\n           (format\n             \"~a(~a)\" cur\n             (let ([base (car val)] [expn (cadr val)])\n               (if (= expn 1) (~a base) (format \"~a**~a\" base expn)))))\n         \"\"\n         (split-factors n)))\n\n(define (split-factors n)\n  (define (cat-res div rep rest) (if (= rep 0) rest (cons `(,div ,rep) rest)))\n  (let loop ([div 2] [rep 0] [n n])\n      (cond\n        [(= div n) `(,`(,n ,(+ rep 1)))]\n        [(> (* div div) n) (cat-res div rep `(,`(,n 1)))]\n        [(= (remainder n div) 0) (loop div (+ 1 rep) (quotient n div))]\n        [else (cat-res div rep (loop (+ 1 div) 0 n))])))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289674,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (is-prime? n)\n  (if (< n 2)\n      #f\n      (if (= n 2)\n          #t\n          (let ([sqrt-n (sqrt n)])\n            (let loop ([i 2])\n              (if (= 0 (remainder n i))\n                  #f\n                  (if (> i sqrt-n)\n                      #t\n                      (loop (add1 i)))))))))\n\n(define (next-prime n)\n  (if (is-prime? n)\n      n\n      (next-prime (add1 n))))\n\n(define make-string\n  (case-lambda \n   [(p) (string-append \"(\" (number->string p) \")\")]\n   [(p n) \n    (if (= n 1)\n        (make-string p)\n        (string-append \"(\" (number->string p) \"**\" (number->string n) \")\"))]))\n\n(define (divisible? big small)\n  (= 0 (remainder big small)))\n\n(define (how-many-times-divisible big small)\n  (let loop ([big big] [count 0])\n    (if (divisible? big small)\n        (loop (\/ big small) (add1 count))\n        count)))\n\n(define (get-next-factor-and-times x last-prime)\n  (let* ([next-p (next-prime last-prime)]\n         [times (how-many-times-divisible x next-p)])\n    (if (> next-p (\/ x 2))\n        (values #f #f)\n        (if (> times 0)\n            (values next-p times)\n            (get-next-factor-and-times x (add1 next-p))))))\n  \n(define (prime_factors n)\n  (let loop ([x n] [last-prime 1] [result \"\"])\n    (if (is-prime? x)\n        (string-append result (make-string x))\n        (call-with-values (lambda () (get-next-factor-and-times x (add1 last-prime)))\n                          (lambda (p times)\n                            (if p\n                                (loop (\/ x (expt p times)) p (string-append result (make-string p times)))\n                                result))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289675,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (prime_factors-l n)\n  (let loop ([x n]\n             [div 2]\n             [i 0]\n             [dst '()])\n    (cond [(> (sqr div) n) (if (> x 2) (cons (list x 1) dst) dst)]\n          [(zero? (modulo x div))\n           (loop (\/ x div) div (add1 i) dst)]\n          [(and (not (zero? (modulo x div))) (zero? i))\n           (loop x (add1 div) 0 dst)]\n          [else\n           (loop x (add1 div) 0 (cons (list div i) dst))])))\n\n\n(define (prime_factors n)\n  (let loop ([factors (prime_factors-l n)]\n             [text \"\"])\n    (if (empty? factors)\n        text\n        (if (= 1 (second (first factors)))\n            (loop (rest factors) (format \"(~a)~a\" (first (first factors)) text))\n            (loop (rest factors) (format \"(~a**~a)~a\" (first (first factors)) (second (first factors)) text))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289676,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (decompose n)\n  ;; Tail-recursive\n  (define (decurse num accumulator)\n    (if (= num 1) accumulator\n        (let ((divisor (stream-first (stream-filter\n                                      (\u03bb (d)\n                                        (zero? (modulo num d)))\n                                      (in-naturals 2)))))\n          (decurse (quotient num divisor) (cons divisor accumulator)))))\n  (reverse (decurse n '())))\n\n(define (frequencies lst)\n  (foldl (\u03bb (new old)\n           (let ((entry (hash-ref old new #f)))\n             (if (false? entry)\n                 (hash-set old new 1)\n                 (hash-set old new (add1 entry)))))\n         (hash) lst))\n\n(define (prime_factors n)\n  (define (pair cell)\n    (if (equal? 1 (cdr cell))\n        (format \"(~a)\" (car cell))\n        (format \"(~a**~a)\" (car cell) (cdr cell))))\n  (string-join (map pair (sort (hash->list (frequencies (decompose n)))\n                               (\u03bb (x y) (< (car x) (car y)))))\n               \"\"))\n                                ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289677,"user_id":null,"body":"#lang racket\n(provide prime_factors)\n\n(define (prime_factors n)\n  (define sqrtn (integer-sqrt n))\n  (define (result-format l)\n    (match l\n      [(list (cons f c) rst ...)\n       (string-append (if (= 1 c)\n                          (format \"(~a)\" f)\n                          (format \"(~a**~a)\" f c))\n                      (result-format rst))]\n      ['() \"\"]))\n  (result-format\n    (let loop ([n n] [f 2] [c 0])\n      (define-values (nn re)\n        (quotient\/remainder n f))\n      (cond [(> f sqrtn) (list (cons n 1))] \n            [(= nn 0) (list (cons f c))]\n            [(zero? re) (loop nn f (+ c 1))]\n            [(zero? c) (loop n (+ f 1) c)]\n            [else (cons (cons f c)\n                        (loop n (+ f 1) 0))]))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54d7660d2daf68c619000d95":[{"id":289678,"user_id":53,"body":"#lang racket\n(provide convert_frac)\n\n(define (norm t d)\n  (let* ([a (car t)]\n         [b (cdr t)])\n      (cons (quotient (* a d) b) d)))\n\n(define (reduce t)\n  (let* ([a (car t)]\n         [b (cdr t)]\n         [g (gcd a b)])\n      (cons (quotient a g) (quotient b g))))\n\n(define (convert_frac ls)\n  (let* ([xss (map (\u03bb (xs) (reduce xs)) ls)]\n         [d (foldl (\u03bb (xs acc) (lcm (cdr xs) acc)) 1 xss)]\n         [yss (map (\u03bb (xs) (norm xs d)) xss)])\n      yss))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289679,"user_id":null,"body":"#lang racket\n(provide convert_frac)\n\n(define (convert_frac ls)\n  (let* [\n        (v_lcm  (apply lcm (map (lambda (x) (cdr x)) ls))) ; Common denom\n        (v_num (map (lambda (x) (* (car x) (\/ v_lcm (cdr x))) ) ls )) ; Numerators scaled\n        (v_gcd (apply gcd (cons v_lcm v_num))) ; Factor to get irreducible fraction\n        ]\n    (map (lambda (num) (cons (\/ num v_gcd) (\/ v_lcm v_gcd)) )  v_num)\n    )\n  )","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289680,"user_id":242,"body":"#lang racket\n(provide convert_frac)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (map proc items)\n  (cond\n    [(null? items) `()]\n    [(pair? items) (cons (proc (car items)) (map proc (cdr items)))]\n    [else (list (proc items))]\n  )\n)\n\n(define (gcd a b)\n  (cond\n    [(< b a) (gcd b a)]\n    [(= a 0) b]\n    [else (gcd (remainder b a) a)]\n  )\n)\n\n(define (lcm a b)\n  (quotient (* a b) (gcd a b))\n)\n\n(define (convert_frac ls)\n  (let\n    ((s (accumulate lcm 1 (map cdr (map (lambda (x) (let ((f (gcd (car x) (cdr x)))) (cons (\/ (car x) f) (\/ (cdr x) f)))) ls)))))\n    (map (lambda (x) (cons (\/ (* s (car x)) (cdr x)) s)) ls)\n  )\n)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289681,"user_id":492,"body":"#lang racket\n(provide convert_frac)\n\n(define (convert_frac ls)\n  (define (simplify ls)\n    (map (\u03bb(x)\n           (match-let*\n               ([(cons n d) x]\n                [g (gcd n d)])\n             (cons (\/ n g) (\/ d g)) )) ls))\n  \n  (let*\n      ([newls (simplify ls)]\n       [comden (apply lcm (map (\u03bb(x) (cdr x)) newls))])\n    (map (\u03bb(x)\n           (cons (quotient (* (car x) comden) (cdr x)) comden)) newls)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289682,"user_id":544,"body":"#lang racket\n(provide convert_frac)\n\n(define (convert_frac ls)\n  (cond [(null? ls) '()]\n        [else\n         (let* ([fraction-list (map (\u03bb (frac) (\/ (car frac) (cdr frac))) ls)]\n                [fraction-lcm (apply lcm (map denominator fraction-list))])\n                (map (\u03bb (frac) (cons (* frac fraction-lcm) fraction-lcm)) fraction-list))]))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289683,"user_id":null,"body":"#lang racket\n(provide convert_frac)\n\n(define (convert_frac ls)\n  (define (assoc->rational a)\n    (\/ (car a) (cdr a)))\n  (let ((d (apply lcm (map denominator (map assoc->rational ls)))))\n    (for\/fold ((ns '())\n               #:result (map (lambda (n) (cons n d)) ns))\n              ((frac (in-list ls)))\n              (append ns (list (* d (assoc->rational frac))))\n              ))\n)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289684,"user_id":544,"body":"#lang racket\n(provide convert_frac)\n\n(define (convert_frac ls)\n  (cond [(null? ls) '()]\n        [else\n         ; if we have fractions a\/b, c\/d, e\/f... and want them in the form n\/m\n         ; where m is the lowest common denominator of b, d, f...\n         ; then the numerators will be (m*a\/b)\/m, (m*c\/d)\/m, ...\n         (let* ([fraction-list (map (\u03bb (frac) (\/ (car frac) (cdr frac))) ls)]\n                [fraction-lcm (apply lcm (map denominator fraction-list))])\n                (map (\u03bb (frac) (cons (* frac fraction-lcm) fraction-lcm)) fraction-list))]))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289685,"user_id":null,"body":"#lang racket\n(provide convert_frac)\n\n;; (Listof (Consof PositiveInt PositiveInt)) ->\n;;   (Listof (Consof PositiveInt PositiveInt))\n;; make sure fractions (numerator . denominator) have a common denominator\n(define (convert_frac ls)\n\n  (define (reduce fracts)\n    (for\/list ([frac fracts])\n      (match frac\n        [(cons num denom)\n         (let ([div (gcd num denom)])\n           (cons (\/ num div) (\/ denom div)))])))\n  \n  (define common-denom (apply lcm (map cdr (reduce ls))))\n  \n  (define (scale frac)\n    (let* ([num (car frac)]\n           [denom (cdr frac)]\n           [factor (\/ common-denom denom)])\n      (cons (* num factor) (* denom factor))))\n  \n  (map scale ls))\n  ","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289686,"user_id":null,"body":"#lang racket\n(provide convert_frac)\n\n(define (convert_frac ls)\n  (define (simplify p)\n    (let* ([a (car p)]\n           [d (cdr p)]\n           [g (gcd a d)])\n      (cons (\/ a g) (\/ d g))))\n  (define sls (map simplify ls))\n  (define denom\n    (foldl (\u03bb (p q) (lcm (cdr p) q)) 1 sls))\n  (map (\u03bb (p) (cons (* (car p) (\/ denom (cdr p)))\n                    denom))\n       sls))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289687,"user_id":null,"body":"#lang racket\n(provide convert_frac)\n\n(define (reduce-frac f)\n  (match-define (cons numer denom) f)\n  (define shared (gcd numer denom))\n  (cons (\/ numer shared) (\/ denom shared)))\n\n(define (convert_frac ls)\n  (define fracs (map reduce-frac ls))\n  (define common-denom (apply lcm (map cdr fracs)))\n  (for\/list ([frac fracs])\n    (match-define (cons numer denom) frac)\n    (cons (* numer (\/ common-denom denom)) common-denom)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54da5a58ea159efa38000836":[{"id":289688,"user_id":527,"body":"#lang racket\n\n(provide find_it)\n\n(define (find_it lst)\n  (foldl bitwise-xor 0 lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289689,"user_id":53,"body":"#lang racket\n\n(provide find_it)\n\n(define (find_it lst)\n  (foldl (\u03bb (x acc) (bitwise-xor x acc)) 0 lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289690,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n(define (find_it nums) (apply bitwise-xor nums))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289691,"user_id":527,"body":"#lang racket\n\n(provide find_it)\n\n(define find_it (curry foldl bitwise-xor 0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289692,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n(define (count-occurrences list seen)\n  (cond [(empty? list) seen]\n        [else (count-occurrences (rest list)\n                                 (hash-update seen (first list) add1 0))]))\n\n(define (find_it lst)\n  (car (first \n        (filter (\u03bb (pair) (odd? (cdr pair)))\n                (hash->list (count-occurrences lst (make-immutable-hash)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289693,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n;; Explaination:\n;; filter the elements that can be found an odd number of times with:\n;; odd? (count (curry equal? elem) lst)\n;; extract the first element\n\n(define (find_it lst)\n  (car (filter (lambda (elem) (odd? (count (curry equal? elem) lst))) lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289694,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n(define (find_it ls)\n  (define (frequency elem ls)\n    (define (freq-rec r-ls tally)\n      (if (null? r-ls)\n          tally\n          (if (= (first r-ls) elem)\n              (freq-rec (rest r-ls) (add1 tally))\n              (freq-rec (rest r-ls) tally))))\n    (freq-rec ls 0))\n  (define (odd-eater rec-ls)\n    (if (null? rec-ls)\n        \"error\"\n        (if (odd? (frequency (first rec-ls) ls))\n            (first rec-ls)\n            (odd-eater (rest rec-ls)))))\n  (odd-eater ls))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289695,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n(define (find_it lst)\n  (cond \n     ((contains (cdr lst) (car lst))(find_it (removeOneElement (cdr lst) (car lst))))\n     (else (car lst))\n   )\n )\n\n(define (contains lst element)\n        (cond\n           ((null? lst) #f)\n           ((= (car lst) element) #t) \n           (else (contains (cdr lst) element))     \n        )\n)\n\n(define (removeOneElement lst element)\n        (cond\n           ((= (car lst) element) (cdr lst))\n           (else (append (list (car lst)) (removeOneElement (cdr lst) element)))\n         )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289696,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n(define (create lst)\n  (foldr\n   (\u03bb (val state)\n     (if (assoc val state)\n         state\n         (cons (cons val 0) state)))\n   '() lst))\n\n(define (count lst)\n  (foldr\n   (\u03bb (val state)\n     (map\n      (\u03bb (v)\n        (cond\n          [(equal? (car v) val) (cons (car v) (add1 (cdr v)))]\n          [else v])) state))\n   (create lst) lst))\n\n(define (find_it lst)\n  (car\n   (findf\n    (\u03bb (v) (odd? (cdr v)))\n    (count lst))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289697,"user_id":null,"body":"#lang racket\n\n(provide find_it)\n\n(define (find_it lst)\n  (let find_it ([nums (remove-duplicates lst)])\n    (cond\n      [(odd? (count (curry = (first nums)) lst))\n       (first nums)]\n      [else (find_it (cdr nums))])))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54db15b003e88a6a480000b9":[{"id":289698,"user_id":53,"body":"#lang racket\n(provide from-nb-2-string)\n\n(define (from-nb-2-string n ls)\n  (let* ([p (foldl (\u03bb (e acc) (* acc e)) 1 ls)]\n         [q (foldl (\u03bb (e acc) (quotient (* acc e) (gcd acc e))) 1 ls)]\n         [r (foldl (\u03bb (e acc) (string-append acc (format \"-~a-\" (modulo n e)))) \"\" ls)])\n      (if (or (< p n) (not (= p q)))\n          \"Not applicable\"\n          r)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289699,"user_id":492,"body":"#lang racket\n(provide from-nb-2-string)\n\n(define (from-nb-2-string n ls)\n  (define (reduce f xs)\n    (and (not (empty? xs)) (foldl f (first xs) (rest xs))))\n\n  (define (moduli n ls)\n    (map (\u03bb(x) (number->string (remainder n x))) ls))\n\n  (let ([p (reduce * ls)]\n        [m (reduce lcm ls)])\n    (if (or (<= p n) (not (equal? p m)))\n        \"Not applicable\"\n        (~a (string-append \"-\" (string-join (moduli n ls) \"--\") \"-\")))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289700,"user_id":null,"body":"#lang racket\n\n(provide from-nb-2-string)\n\n(define (from-nb-2-string n lst)\n  (cond\n    [(and (coprime? lst) (> (apply * lst) n))\n     (format-modules (map (curry modulo n) lst))]\n    [else\n     \"Not applicable\"]))\n\n(define (format-modules modules)\n  (cond\n    [(null? modules) \"\"]\n    [else\n     (format \"-~a-~a\" (first modules) (format-modules (rest modules)))]))\n\n(define (coprime? nums)\n  (for\/and ([pair (combinations nums 2)])\n    (coprime-pair? (first pair) (second pair))))\n\n(define (coprime-pair? a b)\n  (for*\/and ([a-divisor (divisors-of a)]\n             [b-divisor (divisors-of b)])\n    (not (= a-divisor b-divisor))))\n\n(define (divisors-of n)\n  (filter (compose zero? (curry modulo n)) (inclusive-range 2 n)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289701,"user_id":null,"body":"#lang racket\n(provide from-nb-2-string)\n\n(define (from-nb-2-string n s)\n  (cond\n   [(or (not (pairwise-coprime? s))\n        (> n (apply * s)))\n    \"Not applicable\"]\n   [else \n    (let ([modulus (map (lambda (d) (remainder n d)) s)])\n      (string-join (map number->string modulus)\n                   \"--\"\n         \t         #:before-first \"-\"\n \t \t               #:after-last \"-\"))]))\n\n(define (coprime? a b)\n  (= (gcd a b) 1))\n\n(define (pairwise-coprime? nums)\n  (for\/and ([pair (in-combinations nums 2)])\n    (apply coprime? pair)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54dc6f5a224c26032800005c":[{"id":289702,"user_id":492,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list list-of-books list-of-cat)\n  (define (total-one-cat cat ls)\n    (let* ([r (filter (\u03bb(x) (string-prefix? x cat)) ls)]\n           [rr (map (\u03bb(x) (string->number (second (string-split x \" \")))) r)])\n      (apply + rr)))\n\n  (if (or (empty? list-of-books) (empty? list-of-cat))\n      '()\n      (let* ([rr (map (\u03bb(x) (total-one-cat x list-of-books)) list-of-cat)])\n        (map (\u03bb(x y) (cons x y)) list-of-cat rr))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289703,"user_id":492,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list list-of-books list-of-cat)\n  (define (total-one-cat cat ls)\n    (let* ([r (filter (\u03bb(x) (string-prefix? x cat)) ls)]\n           [rr (map (\u03bb(x) (string->number (second (string-split x \" \")))) r)])\n      (apply + rr)))\n\n  (if (or (empty? list-of-books) (empty? list-of-cat))\n      '()\n      (let* ([rr (map (\u03bb(x) (total-one-cat x list-of-books)) list-of-cat)])\n        (map (\u03bb(x y) (cons x y)) list-of-cat rr))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289704,"user_id":null,"body":"#lang racket\n(provide stock_list)\n\n(define (string-car st)\n  (string (car (string->list st))))\n\n\n(define (stock_list list-of-books list-of-cat)\n  (define (if-not-empty-lists)\n    (define n (length list-of-cat))\n    (define category-sums (make-hash (map cons list-of-cat (build-list n (lambda (_) 0)))))\n    (for-each  (lambda (book) ( let*\n                                 [ (split (string-split book \" \"))\n                                   (category (string-car (car split)))\n                                   (number (string->number (cadr split))) ]\n                               (hash-set! category-sums category (+ (hash-ref category-sums category 0) number)))) list-of-books )\n    (map (lambda (cat) (cons cat (hash-ref category-sums cat))) list-of-cat))\n  (if\n   (or (empty? list-of-books) (empty? list-of-cat))\n   '()\n   (if-not-empty-lists)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289705,"user_id":null,"body":"#lang racket\n(provide stock_list)\n\n(define (string->cat-qty s)\n  (define split (string-split s \" \"))\n  (cons (substring (car split) 0 1) (string->number (cadr split))))\n\n(define (add-qty cat-qty counts)\n  (if (empty? counts)\n      '()\n      (if (equal? (caar counts) (car cat-qty))\n          (cons (cons (caar counts) (+ (cdar counts) (cdr cat-qty))) (cdr counts))\n          (cons (car counts) (add-qty cat-qty (cdr counts))))))\n\n(define (stock_list list-of-books list-of-cat)\n  (define (create-empty-counts list-of-cat)\n    (if (empty? list-of-cat)\n        '()\n        (cons (cons (car list-of-cat) 0) (create-empty-counts (cdr list-of-cat)))))\n  (define (count-stock list-of-books list-of-cat counts)\n    (if (empty? list-of-books)\n        counts\n        (count-stock (cdr list-of-books) list-of-cat (add-qty (string->cat-qty (car list-of-books)) counts))))\n  (if (empty? list-of-books)\n      '()\n      (count-stock list-of-books list-of-cat (create-empty-counts list-of-cat))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289706,"user_id":544,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list books categories)\n  (cond\n    [(or (empty? books) (empty? categories)) '()]\n    [else \n     (define books-hash\n       (make-hash (for\/list ([c (in-list categories)]) (cons c 0))))\n     (for ([b (in-list books)])\n       (let* ([b-pair (string-split b)]\n              [b-category (substring (first b-pair) 0 1)]\n              [b-inventory (string->number (second b-pair))])\n         (when (hash-has-key? books-hash b-category)\n           (hash-update! books-hash b-category (curry + b-inventory) 0))))\n     (for\/list ([c (in-list categories)])\n       (cons c (hash-ref books-hash c)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289707,"user_id":544,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list books categories)\n  (cond\n    [(or (empty? books) (empty? categories)) '()]\n    [else \n     (define books-hash\n       (make-hash (for\/list ([c (in-list categories)]) (cons c 0))))\n     (for ([b (in-list books)])\n       (let* ([b-pair (string-split b)]\n              [b-category (substring (first b-pair) 0 1)]\n              [b-inventory (string->number (second b-pair))])\n         (hash-update! books-hash b-category (curry + b-inventory) 0)))\n     (for\/list ([c (in-list categories)])\n       (cons c (hash-ref books-hash c)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289708,"user_id":544,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list list-of-books list-of-cat)\n  (cond [(or (empty? list-of-books)\n             (empty? list-of-cat)) '()]\n        [else\n         (define parsed-books \n           (sort (map (\u03bb (b) (string-split b)) list-of-books) string<? #:key car)) \n         (for\/list ([c list-of-cat])\n           (let* ([matching-books (filter (\u03bb (b) (string-prefix? (first b) c)) parsed-books)])                  \n             (cond [(empty? matching-books) (cons c 0)]\n                   [else (cons c (apply + (map (compose string->number cadr) matching-books)))])))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289709,"user_id":544,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list list-of-books list-of-cat)\n  (cond [(or (empty? list-of-books)\n             (empty? list-of-cat)) '()]\n        [else\n         (define parsed-books \n           (sort (map (\u03bb (b) (string-split b)) list-of-books) string<? #:key car)) \n         (for\/list ([c list-of-cat])\n           (let* ([matching-books (filter (\u03bb (b) (string-prefix? (first b) c)) parsed-books)]\n                  [matching-inventory (filter (\u03bb (b) (string-prefix? (first b) c)) parsed-books)])\n             (cond [(empty? matching-books) (cons c 0)]\n                   [else (cons c (apply + (map (compose string->number cadr) matching-inventory)))])))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289710,"user_id":544,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list list-of-books list-of-cat)\n  (cond \n   [(or (empty? list-of-books) (empty? list-of-cat)) '()]\n   [else\n    (define parsed-books \n      (sort (map (lambda (b) (string-split b)) list-of-books) string<? #:key car)) \n    (for\/list ([c list-of-cat]) \n              (cons \n               c \n               (cond \n                [(empty? (filter (lambda (b) (string-prefix? (first b) c)) parsed-books)) 0]\n                [else (apply + (map (lambda (inv) (apply string->number (cdr inv))) \n                                     (filter (lambda (b) (string-prefix? (first b) c)) parsed-books)))]\n              )))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289711,"user_id":null,"body":"#lang racket\n(provide stock_list)\n\n(define (stock_list list-of-books list-of-cat)\n  (if (or (null? list-of-books) (null? list-of-cat)) '()\n      (cons\n       (cons (car list-of-cat)\n             (foldl + 0 (map (compose string->number cadr string-split)\n                             (filter (lambda (x) (string-prefix? x (car list-of-cat))) list-of-books))))\n       (stock_list list-of-books (cdr list-of-cat)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54e320dcebe1e583250008fd":[{"id":289712,"user_id":null,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n(define (dec_2_fact_string nb)\n  (define (go n k s)\n    (if (> n 0)\n        (let-values\n          ([(q r) (quotient\/remainder n k)])\n          (go\n            q\n            (+ k 1)\n            (string-append (~r r #:base '(up 36)) s)))\n        s))\n  (go nb 1 \"\"))\n\n(define (fact_string_2_dec strg)\n  (for\/fold\n    ([n 0] [k 1] [f 1]\n     #:result n)\n    ([d (reverse (string->list strg))])\n    (values\n      (+ n (* f (- (char->integer d) (if (char-numeric? d) 48 55))))\n      (+ k 1)\n      (* k f))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:20"},{"id":289713,"user_id":null,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n(define (dec_2_fact_string nb)\n  (values-list->fact-string (get-values-list nb)))\n              \n\n(define (fact_string_2_dec strg)\n  (letrec [(helper\n            (lambda (lat place)\n                (cond\n                  ((null? lat) 0)\n                  (#t (+ (* (char->num (car lat)) (fact place)) (helper (cdr lat) (+ 1 place)))))))]\n    (helper (reverse (string->list strg)) 0)))\n\n(define values-list->fact-string\n  (lambda (lat)\n    (letrec [(helper\n              (lambda (l count)\n                (cond\n                  ((null? l) '())\n                  ((eq? (cdr (car l)) count) (cons (car (car l)) (helper (cdr l) (+ 1 count))))\n                  (#t (cons #\\0 (helper l (+ 1 count)))))))]\n      (list->string(reverse (helper (reverse lat) 0))))))\n    \n    \n\n(define num->char\n  (lambda (n)\n    (cond\n      ((and (<= n 9) (>= n 0)) (integer->char (+ n 48)))\n      ((and (>= n 10) (<= n 35)) (integer->char (+ n 55))))))\n\n(define char->num\n  (lambda (n)\n    (let [(charn (char->integer n))]\n    (cond\n      ((and (<= charn 57) (>= charn 48)) (- charn 48))\n      ((and (>= charn 65) (<= charn 90)) (- charn 55))))))\n\n(define get-values-list\n  (lambda (nb)\n    (cond\n      ((eq? nb 0) '())\n      (#t\n       (let* [(biggest-fact (find-biggest-fact nb))\n              (place-value (fact biggest-fact))\n              (times-gone-in (quotient nb place-value))\n              (num-left (remainder nb place-value))]\n         (cons (cons (num->char times-gone-in) biggest-fact) (get-values-list num-left)))))))\n\n\n(define find-biggest-fact\n  (lambda (num)\n    (letrec ((helper\n             (lambda (n)\n               (if (> (fact n) num) (- n 1) (helper (+ n 1))))))\n      (helper 0))))\n\n(define fact\n  (lambda (num)\n    (cond\n     ((< num 1) 1)\n     (#t (* num (fact (- num 1)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:22"},{"id":289714,"user_id":null,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n(define (dec_2_fact_string nb)\n  (let* ([factorials (let get-factorials ([num 0] [factorial 1] [result '()])\n                       (if (> factorial nb)\n                           result\n                           (get-factorials (add1 num)\n                                           (* factorial (add1 num))\n                                           (cons factorial result))))]\n         [nums (let get-nums ([num nb] [factorials factorials] [result '()])\n                     (if (empty? factorials)\n                         (reverse result)\n                         (get-nums (- num (* (quotient num (first factorials))\n                                                 (first factorials)))\n                                       (rest factorials)\n                                       (cons (quotient num (first factorials)) result))))])\n    (list->string (map (\u03bb (x)\n                         (if (< x 10)\n                             (integer->char (+ x 48))\n                             (integer->char (+ x 55))))\n                       nums))))\n\n(define (fact_string_2_dec strg)\n  (let* ([strg-list (string->list strg)]\n         [nums (map (\u03bb (x)\n                      (if (char-numeric? x)\n                          (- (char->integer x) 48)\n                          (- (char->integer x) 55)))\n                    strg-list)]\n         [factorials (let get-factorials ([num 0] [factorial 1] [result '()])\n                       (if (= num (length strg-list))\n                           result\n                           (get-factorials (add1 num)\n                                           (* factorial (add1 num))\n                                           (cons factorial result))))])\n    (foldl (\u03bb (num factorial result)\n             (+ result (* num factorial)))\n           0\n           nums\n           factorials)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:18"},{"id":289715,"user_id":null,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n(define (dec_2_fact_string n)\n  (define (gen-fact n cur fact)\n    (let ([next (* cur fact)])\n      (if (> next n) '() (cons next (gen-fact n (+ 1 cur) next)))))\n  (define (gen-nums n fact)\n    (if (null? fact) '()\n      (let ([cur (car fact)])\n        (cons (quotient n cur) (gen-nums (remainder n cur) (cdr fact))))))\n  (define (num->char n) (integer->char (+ (if (< n 10) 48 55) n)))\n  (string-append (list->string (map num->char (gen-nums n (reverse (gen-fact n 1 1))))) \"0\"))\n\n(define (fact_string_2_dec strg)\n  (let ([xs (map\n              (lambda (c) (- (char->integer c) (if (char-numeric? c) 48 55)))\n              (string->list strg))])\n    (define (fold-fact xs cur fact)\n      (if (null? xs) 0 (+ (* fact (car xs)) (fold-fact (cdr xs) (+ cur 1) (* cur fact)))))\n    (fold-fact (reverse xs) 1 1)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:18"},{"id":289716,"user_id":544,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n; some basic functions\n; being a good racketeer and ensuring my factorial function is tail-call optimized\n(define (factorial n [running-product 1])\n  (cond [(= n 1) running-product]\n        [else (factorial (sub1 n) (* n running-product))]))\n\n; for handling digits above 9\n(define (char->fact-digit d)\n  (cond [(d . char<? . #\\:) (- (char->integer d) 48)]\n        [else (- (char->integer d) 55)]))\n\n(define (fact-digit->char c)\n  (cond [(c . < . 10) (integer->char (+ c 48))]\n        [else (integer->char (+ c 55))]))\n\n;;; decimal-to-factoradic\n; first, a procedure to generate the list of radices\n; successive modulo division generates the list from the remainders; \n; see https:\/\/en.wikipedia.org\/wiki\/Factorial_number_system\n(define (dec->radix-list num)\n  (for\/fold ([base-10-number num]\n             [radix-list '()]\n             #:result radix-list)\n            ([place (in-naturals 1)]\n             #:break (= base-10-number 0)\n             )\n    (values (quotient base-10-number place)\n            (cons (modulo base-10-number place) radix-list))))    \n\n; take the list of digits and convert them to A-Z as necessary, \n; then concatenate the whole shebang\n(define (dec_2_fact_string nb)\n  (list->string (for\/list ([radix-list (dec->radix-list nb)])\n    (fact-digit->char radix-list))))\n\n;;; factoradic-to-decimal\n; (in an ideal world there'd be error-checking to see if the digit\n; exceeded the place value but it's not necessary for these tests)\n;\n; first, a procedure to zip up the pairs of places and place values\n; (radices where the place value is 0 aren't necessary for the final calculation\n; so they're dropped by the for\/fold loop)\n(define (fact-string-parse strg)\n  (for\/list ([digit (in-string strg)]\n             [place (in-range (- (string-length strg) 1) 0 -1)]\n             #:when (> (char->fact-digit digit) 0))\n    (cons (char->fact-digit digit) place)))\n\n; use that procedure to sum up all the products of digits times place value\n(define (fact_string_2_dec strg)\n  (let ([pairs (fact-string-parse strg)])\n    (for\/sum ([radix (in-list pairs)]) (* (car radix) (factorial (cdr radix))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:18"},{"id":289717,"user_id":null,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n; Numer -> String\n; given decimal number (nb <= 36!-1)\n; convert it to factorial number system.\n; numbers [0..9] are extended with [A..Z]\n; in order to represent 36 digits.\n; return as string.\n(define (dec_2_fact_string nb)\n  (local ((define (helper nb n acc)\n            (cond\n              [(zero? nb) acc]\n              [else\n               (call-with-values\n                (lambda () (quotient\/remainder nb n))\n                (lambda (quot rem) (helper quot (add1 n) (cons (num->char rem) acc))))]))\n\n          ;Number -> Char\n          ;given number n [0..35] convert:\n          ; - numbers [0..9]   to chars [#\\0..#\\9]\n          ; - numbers [10..35] to chars [#\\A..#\\Z]\n          (define (num->char n)\n            (cond\n              [(<=  0 n  9) (integer->char (+ (char->integer #\\0) n))]\n              [(<= 10 n 35) (integer->char (+ (char->integer #\\A) n -10))])))\n    (list->string (helper nb 1 '()))))\n\n\n\n; String -> Number\n; given string representation of a number\n; in factorial number system, convert it\n; to decimal number.\n; NB [0..9] are extended with [A..Z]\n; in order to represent 36 digits.\n(define (fact_string_2_dec strg)\n  (local (;[List-of Number] -> Number\n          ;given list of numbers, representing\n          ;a number in factorial number system,\n          ;return this number in base 10\n          ;foldl is used because we can represent conversion from\n          ;factorial to base 10 in 2 ways:\n          ;463 =     3\u00d75! +4 \u00d74!+ 1 \u00d73! +0 \u00d72!+ 1 \u00d71!+ 0\u00d70! \n          ;463 = ((((3\u00d75 + 4)\u00d74 + 1)\u00d73 + 0)\u00d72 + 1)\u00d71 + 0    <-foldl used here\n          (define (sum-fact l)\n            (cond\n              [(empty? l) 0]\n              [(= (length l) 2) 1]\n              [else\n               (local ((define max-factorial (sub1 (length l)))\n                       (define base (+ (* (first l) max-factorial) (second l)))\n                       (define items (rest (rest l)))\n                       (define indices (build-list (length items) add1)))\n                 (foldl (lambda (a b base) (+ (* base (- max-factorial b)) a))\n                        base\n                        items\n                        indices))]))\n\n          ;String -> [List-of Number]\n          ;convert string representation of a number\n          ;(number in factorial base number system)\n          ;to a list of numbers\n          (define (string->list-of-numbers s) (map char->num (string->list s)))\n  \n          ;Char -> Number\n          ;given character representaion of\n          ;a number n [#\\0..#\\9]-[#\\A..#\\Z] convert:\n          ; - chars [#\\0..#\\9] to numbers [0..9] \n          ; - chars [#\\A..#\\Z] to numbers [10..35] \n          (define (char->num c)\n            (cond\n              [(char<=? #\\0 c  #\\9)       (- (char->integer c) (char->integer #\\0))]\n              [(char<=? #\\A c  #\\Z) (+ 10 (- (char->integer c) (char->integer #\\A)))])))\n  (sum-fact (string->list-of-numbers strg))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:18"},{"id":289718,"user_id":null,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n; bad practice, but it works\n(define (dec_2_fact_string nb)\n  (define (fact-digit->string d)\n    (string (integer->char (if (< d 10) (+ d 48) (+ d 55)))))\n  (define (fact-less-than nb)\n    (let iter ([n 1] [r 1])\n      (define p (* n r))\n      (if (< nb p)\n          (values r (- n 1))\n          (iter (+ n 1) p))))\n  (define-values (f0 t0) (fact-less-than nb))\n  (let iter ([n nb] [f f0] [t t0] [result \"\"])\n    (define-values (digit new-n) (quotient\/remainder n f))\n    (if (zero? t)\n        (string-append result \"0\")\n        (iter new-n\n              (\/ f t)\n              (- t 1)\n              (string-append result (fact-digit->string digit))))))\n\n(define (fact_string_2_dec strg)\n  (define lst (reverse (string->list strg)))\n  (define (convert c)\n    (- (char->integer c)\n       (if (char<=? c #\\9)\n           48\n           55)))\n  (for\/fold ([n 1]\n             [f 1]\n             [r 0]\n             #:result r)\n            ([i lst])\n    (values (+ n 1) (* f n) (+ r (* (convert i) f)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:18"},{"id":289719,"user_id":492,"body":"#lang racket\n(provide dec_2_fact_string fact_string_2_dec)\n\n(define (dec_2_fact_string nb)\n  (let loop ([rad 2] [n nb] [res \"0\"])\n    (let* ([q (quotient n rad)]\n           [r (remainder n rad)]\n           [ch (integer->char (if (<= r 9) (+ r 48) (+ r 55)))])\n      (if (zero? q)\n          (string-append (string ch) res)\n          (loop (add1 rad) q (string-append (string ch) res))))))\n\n(define (fact_string_2_dec strg)\n  (define( char->nb chn nb)\n    (define (factorial x)\n      (apply * (range 2 (add1 x))))\n    (if (<= chn 57)\n        (* (- chn 48) (factorial nb)) \n        (* (- chn 55) (factorial nb))))\n  \n  (let* ([ls (string->list strg)]\n         [greatest-fact (sub1 (length ls))])\n    (let loop ([data ls] [ndx greatest-fact] [res 0])\n      (if (empty? data)\n          res\n          (loop (rest data) (sub1 ndx) (+ res (char->nb (char->integer (first data)) ndx)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 21:25:18"}],"54edbc7200b811e956000556":[{"id":289720,"user_id":527,"body":"#lang racket\n\n(provide count_sheeps)\n\n(define (count_sheeps lst)\n  (count identity lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289721,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n;for racket in this kata, \n;only values that are exactly #t count as sheep. \n;any other value is not a sheep.\n(define (count_sheeps lst)\n  (count identity lst)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289722,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n(define count_sheeps\n  (curry count (curry equal? #t)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289723,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n;for racket in this kata, \n;only values that are exactly #t count as sheep. \n;any other value is not a sheep.\n(define (count_sheeps lst)\n  (for\/fold ([count 0])\n            ([place lst]\n             #:when (eq? place #t))\n    (+ count 1)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289724,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n;for racket in this kata, \n;only values that are exactly #t count as sheep. \n;any other value is not a sheep.\n(define (count_sheeps lst)\n  (foldl\n   (lambda (v result) (if (equal? v #t) (+ result 1) result))\n   0 lst))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289725,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n(define (count_sheeps lst) (count (curry eq? #t) lst))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289726,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n;for racket in this kata, \n;only values that are exactly #t count as sheep. \n;any other value is not a sheep.\n(define (count_sheeps lst)\n  (apply + (map (lambda (x) (if x +1 0)) lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289727,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n;for racket in this kata, \n;only values that are exactly #t count as sheep. \n;any other value is not a sheep.\n(define (count_sheeps lst)\n  (define (true? a) (eq? #t a))\n  (count true? lst))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289728,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n;for racket in this kata, \n;only values that are exactly #t count as sheep. \n;any other value is not a sheep.\n(define (count_sheeps lst)\n  (length (remq* (list #f) lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289729,"user_id":null,"body":"#lang racket\n\n(provide count_sheeps)\n\n(define (count x lst acc)\n  (cond ((equal? lst '()) acc)\n        ((equal? (car lst) x) (count x (cdr lst) (+ acc 1)))\n        (else (count x (cdr lst) acc))))\n\n(define (count_sheeps lst)\n  (count #t lst 0))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54f8693ea58bce689100065f":[{"id":289730,"user_id":null,"body":"#lang racket\n(provide decompose)                                                                    \n\n(define (decompose s)\n  (map number->string\n       (reverse (decompose* (string->number s 10 'read 'decimal-as-exact)\n                            '()))))\n\n(define (decompose* n xs)\n  (cond [(zero? n) xs]\n        [(>= n 1) (decompose* (- n (floor n)) (cons (floor n) xs))]\n        [else (let ([next (ceiling (\/ 1 n))])\n                (decompose* (- n (\/ 1 next)) (cons (\/ 1 next) xs)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289731,"user_id":492,"body":"#lang racket\n(provide decompose)                                                                    \n\n(define (decompose s)\n  (define (aux cs)\n    (let* ([num (car cs)]\n           [den (cdr cs)])\n      (cond [(zero? num) '()]\n            [(= 1 den) (list (number->string num))]\n            [else\n             (if (> num den)\n                 (cons (number->string (quotient num den)) (aux (cons (remainder num den) den)))\n                 (let loop ([a num] [b den] [res '()])\n                   (if (> a 0)\n                       (let ([dv (exact-ceiling (\/ b a))])\n                         (loop (- (* a dv) b) (* b dv) (cons (string-append \"1\/\" (number->string dv)) res)))\n                       (reverse res))))])))\n  (define (decimal s cs)\n    (let* ([d (expt 10 (- (string-length s) (cdr (first cs))))]\n           [n (inexact->exact (* (string->number s) d))]\n           [g (gcd n d)])\n      (aux (cons (\/ n g) (\/ d g)))))         \n  (define (fraction s)\n    (let*([snb (string-split s \"\/\")]\n          [d (string->number (second snb))]\n          [n (string->number (first snb))]\n          [g (gcd n d)])\n      (aux (cons (\/ n g) (\/ d g)))))\n  (define (integer s)\n    (aux (cons (string->number s) 1)))\n  \n  (let ([u (regexp-match-positions #rx\"\\\\\/\" s)]\n        [v (regexp-match-positions #rx\"\\\\.\" s)])\n    (cond [v (decimal s v)]\n          [u (fraction s)]\n          [else (integer s)])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289732,"user_id":null,"body":"#lang racket\n(provide decompose)                                                                    \n\n(define (decompose s)\n  (define (f x) `(,(number->string x) ,@(decompose (- s x))))\n  (cond\n    [(string? s)\n     (decompose (string->number s 10 'number-or-false 'decimal-as-exact))]\n    [(= 0 s) '()]\n    [(> 1 s) (f (\/ 1 (ceiling (\/ 1 s))))]\n    [#t (f (floor s))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289733,"user_id":null,"body":"#lang racket\n(provide decompose)                                                                    \n\n(define (decompose s)\n  (define n\n    (if (number? s)\n        s\n        (string->number s 10 'number-or-false 'decimal-as-exact)))\n  (define (f x) `(,(number->string x) ,@(decompose (- n x))))\n  (cond\n    [(= 0 n) '()]\n    [(> 1 n) (f (\/ 1 (ceiling (\/ 1 n))))]\n    [#t (f (floor n))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289734,"user_id":544,"body":"#lang racket\n(provide decompose)\n; with this parameter, Racket will directly read decimals as exact rational numbers\n; instead of first casting them as floating-point values, which solves the issue \n; with trying to find the expansion of rational numbers with \n; infinite floating-point representations\n(read-decimal-as-inexact #f)\n\n(define (decompose s)\n  (flatten\n   (list\n    (let ([num-s (string->number s)])\n      (cond [(= num-s 0) null]\n            [(= (denominator num-s) 1) (number->string num-s)]\n            [(= (numerator num-s) 1) (number->string num-s)]\n            [(> num-s 1) (cons (number->string (truncate num-s))\n                               (decompose (number->string (- num-s (truncate num-s)))))]\n            [else (cons (number->string (\/ 1 (exact-ceiling (expt num-s -1))))\n                        (decompose (number->string\n                                    (\/ (modulo (- (denominator num-s)) (numerator num-s))\n                                       (* (denominator num-s) (ceiling (\/ 1 num-s)))))))])))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289735,"user_id":null,"body":"#lang racket\n(provide decompose)\n\n;; Find biggest number 1\/n such that p\/q - 1\/n >= 0 <=> p\/q > 1\/n <=> n > q\/p\n(define (g p\/q)\n  (if (zero? p\/q)\n      0\n      (\/ 1 (ceiling (\/ (denominator p\/q)\n                       (numerator p\/q))))))\n\n(define (decompose s)\n  (define p\/q (string->number s 10 'read 'decimal-as-exact))\n\n  ;; Define recursive loop\n  (define (loop [p\/q p\/q]\n                [decomposition '()])\n    (if (zero? p\/q)\n        decomposition\n        (let* ([1\/n*           (g p\/q)]\n               [p\/q*           (- p\/q 1\/n*)]\n               [decomposition* (append decomposition (list (number->string 1\/n*)))])\n          (loop p\/q* decomposition*))))\n\n  ;; Initiate recursion\n  (if (>= p\/q 1)\n      (let ([truncated-p\/q (truncate p\/q)])\n        (loop (- p\/q truncated-p\/q)\n              (list (number->string truncated-p\/q))))\n      (loop)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289736,"user_id":168,"body":"#lang racket\n(provide decompose)                                                                    \n\n(read-decimal-as-inexact #f)\n\n(define (decompose s)\n  (let loop ([v (string->number s)])\n    (cond\n     [(zero? v) '()]\n     [(>= v 1) (cons (number->string (floor v)) (loop (- v (floor v))))]\n     [else\n        (let ([q (ceiling (\/ v))])\n          (cons (number->string (\/ q)) (loop (- v (\/ q)))))])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289737,"user_id":null,"body":"#lang racket\/base\n\n(provide decompose)                                                                    \n\n(define (decompose-egyptian\/recurse n)\n  (define num (numerator n))\n  (define den (denominator n))\n\n  (cond\n    [(zero? num) null]\n    [(= 1 num) (list n)]\n    [else\n      (define a\n        (\/ 1\n           (ceiling (\/ (denominator n)\n                       (numerator n)))))\n      (cons a (decompose-egyptian\/recurse (- n a)))]))\n\n(define (decompose-egyptian\/reduce n acc)\n  (define num (numerator n))\n  (define den (denominator n))\n\n  (cond\n    [(>= num den) (decompose-egyptian\/reduce (sub1 n) (add1 acc))]\n    [(zero? acc) (decompose-egyptian\/recurse n)]\n    [else\n      (cons acc (decompose-egyptian\/recurse n))]))\n\n(define (decompose-egyptian n)\n  (decompose-egyptian\/reduce n 0))\n\n(define (decompose s)\n  (map number->string\n       (decompose-egyptian\n         (inexact->exact\n           (string->number s 10 'number-or-false 'decimal-as-exact)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55031bba8cba40ada90011c4":[{"id":289738,"user_id":544,"body":"#lang racket\n(provide sum-cubes)\n\n(define (is-cubic? s)\n  (define s-number\n    (string->number s))\n  (define s-digits\n    (map (compose string->number string) (string->list s)))\n  (= (apply + (map (curryr expt 3) s-digits)) s-number))\n\n(define (split-into-threes strng [acc '()])\n  (cond [(not (non-empty-string? strng)) (reverse acc)]\n        [((string-length strng) . < . 3) (reverse (cons strng acc))]\n        [else\n         (let ([string-3 (substring strng 0 3)])\n           (split-into-threes (substring strng 3 (string-length strng))\n                              (cons string-3 acc)))]))\n\n(define (sum-cubes s)\n  (define filtered-string (string-split (string-replace s #rx\"[^0-9]\" \" \")))\n  (define test-strings (flatten (map split-into-threes filtered-string)))\n  (define cubic-numbers (map string->number (filter is-cubic? test-strings)))\n  (println test-strings)\n  (if (empty? cubic-numbers)\n      \"Unlucky\"\n      (string-join (flatten (list (map number->string cubic-numbers)\n                                  (number->string (apply + cubic-numbers))\n                                  \"Lucky\")))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289739,"user_id":492,"body":"#lang racket\n(provide sum-cubes)\n\n(define (sum-cubes s)\n  (define (is-cubic? sn)\n    (define (digits n)\n      (let loop ((n n) (d '()))\n        (if (zero? n) d\n            (loop (quotient n 10)\n                  (cons (modulo n 10) d)))))\n    (let* ([n (string->number sn)]\n           [ls (digits n)]\n           [r (apply + (map (\u03bb(x) (* x x x)) ls))])\n      (equal? r  n)))\n      \n  (let* ([ls (regexp-match* #px\"[0-9]{1,3}\" s)]\n         [c (map string->number (filter is-cubic? ls))]\n         [sm (if (pair? c) (apply + c) '())]\n         [r (append c (list sm))])\n    (if (equal? (first r) null)\n        \"Unlucky\"\n        (string-append (string-join (map number->string r) \" \") \" Lucky\"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"550498447451fbbd7600041c":[{"id":289740,"user_id":53,"body":"#lang racket\n(provide comp_same)\n\n(define (comp_same a b)  \n  (equal? (sort (map (\u03bb (n) (* n n)) a) <) (sort b <)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289741,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n; comp : List(Number) List(Number) -> Boolean\n; Given two lists a and b checks whether the two arrays\n; have the \"same\" elements, with the same multiplicities\n; \"Same\" means, here, that the elements in b are the elements\n; in a squared, regardless of the order\n(define (comp_same a b)  \n  (cond [(and (empty? a) (empty? b)) #t]        \n        [(not (= (length a) (length b))) #f]\n        [else (comp_sameAux (sort (absolute a) <) (sort (absolute b) <))]))\n\n; absolute : List(Number) -> List(Number)\n; Given a list of numbers returns a list with the absolute value\n; of all the numbers in the given list\n(define (absolute a)\n  (map abs a))\n\n; compAux : List(Number) List(Number) -> Boolean\n; Given two lists a and b with the same number of elements\n; checks that the elements in b are the elements in a squared\n(define (comp_sameAux a b)\n  (cond [(empty? a) #t] \n        [(empty? b) #t]\n        [else (if (= (sqr (first a)) (first b)) \n                  (comp_sameAux (rest a) (rest b))\n                  #f)]))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289742,"user_id":492,"body":"#lang racket\n(provide comp_same)\n\n(define (comp_same a b)  \n  (let ([aa (sort (map (\u03bb(x) (sqr x)) a) <)]\n         [bb (sort b <)])\n    (equal? aa bb)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289743,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n; in Racket there is no `nil` but `a` or `b` can be `empty`\n(define (comp_same a b)  \n        (cond\n          ((and (null? a) (null? b)) #t)\n          ((and (null? b)) #f)\n          ((and (null? a)) #f)\n          ((contains b (* (car a) (car a))) (comp_same (cdr a) (removeOneElement b (* (car a) (car a)))))\n          (else #f)\n        )\n)\n\n(define (contains lst element)\n        (cond\n           ((null? lst) #f)\n           ((= (car lst) element) #t) \n           (else (contains (cdr lst) element))     \n        )\n)\n  \n(define (removeOneElement lst element)\n        (cond\n           ((= (car lst) element) (cdr lst))\n           (else (append (list (car lst)) (removeOneElement (cdr lst) element)))\n         )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289744,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n; in Racket there is no `nil` but `a` or `b` can be `empty`\n(define (comp_same a b)  \n  \n  (define (insert l x)\n        \n    (define (find-element l x pos)\n      (if (null? l)\n          pos\n          (if (>= (car l) x)\n            pos\n            (find-element (cdr l) x (+ pos 1)))))\n    \n    (if (null? l)\n        (list x)\n        (if (>= (car l) x)\n            (cons x l)\n            (let ([pos (find-element l x 0)])\n              (append (take l pos) (list x) (drop l pos))))))\n  \n  (define (comp_same-inner-second a b)\n    \n    (if (null? a) \n        #t\n        (if (= (* (car a) (car a)) (car b))\n            (comp_same-inner-second (cdr a) (cdr b))\n            #f)))\n  \n  (define (comp_same-inner-first a b ordered-a ordered-b)\n        \n    (if (not (equal? (null? a) (null? b))) \n        #f \n        (if (null? a)\n            (comp_same-inner-second ordered-a ordered-b)\n            (comp_same-inner-first (cdr a) (cdr b) (insert ordered-a (abs (car a))) (insert ordered-b (abs (car b)))))))\n    \n  (comp_same-inner-first a b `() `())\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289745,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n; in Racket there is no `nil` but `a` or `b` can be `empty`\n(define (comp_same a b)  \n  (equal? (map (lambda (x) (* x x)) (sort (map abs a) <)) (sort b <))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289746,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n(define (comp_same a b)\n  (if (not (= (length a) (length b))) #f\n      (comp_same-h (sort a abs<) (sort b abs<))))\n\n(define (abs< e1 e2) (< (abs e1) (abs e2)))\n\n(define (comp_same-h a b)\n  (if (or (empty? a) (empty? b)) #t\n      (and  \n       (= (expt (first a) 2) (first b)) \n       (comp_same-h (rest a) (rest b)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289747,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n; in Racket there is no `nil` but `a` or `b` can be `empty`\n(define (comp_same a b)  \n  (let o-loop ((a-rem a) (b-rem b))\n    (cond ((and (null? a-rem) (null? b-rem)) #t)\n          ((or (null? a-rem) (null? b-rem)) #f)\n          (else\n           (let i-loop ((i-rem b-rem) (acc '()))\n             (cond ((null? i-rem) #f)\n                   ((equal? (car i-rem) (* (car a-rem) (car a-rem)))\n                    (o-loop (cdr a-rem) (append acc (cdr i-rem))))\n                   (else (i-loop (cdr i-rem) (append (list (car i-rem)) acc)))))\n           ))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289748,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n(define (sort-asc xs) (sort xs <))\n\n(define (is-same xs ys)\n  (if (or (null? xs) (null? ys))\n      (and (null? xs) (null? ys))\n      (if (= (car xs) (car ys))\n          (is-same (cdr xs) (cdr ys))\n          #f)))\n      \n(define (comp_same a b)\n  (is-same\n   (sort-asc (map (lambda (x) (* x x)) a))\n   (sort-asc b)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289749,"user_id":null,"body":"#lang racket\n(provide comp_same)\n\n; in Racket there is no `nil` but `a` or `b` can be `empty`\n(define (comp_same a b)  \n  ; your code\n  (cond\n   [(empty? a) (empty? b)]\n   [(not (equal? (length a) (length b))) #f]\n   [else \n    (define as (map (lambda (x) (* x x)) a))\n    (equal? (sort b <) (sort as <))])\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"550527b108b86f700000073f":[{"id":289750,"user_id":53,"body":"#lang racket\n(provide iter_pi)\n\n(define (walk epsilon pi4 sign denom iterations)\n  (if (< (abs (- (* 4.0 pi4) pi)) epsilon)\n      (list iterations (\/ (round (* (* 4.0 pi4) 1e10)) 1e10))\n      (let ([pi4n (+ pi4 (* sign (\/ 1.0 denom)))]\n            [signn (* sign -1.0)]\n            [denomn (+ 2.0 denom)]\n            [iterationsn (add1 iterations)])\n        (walk epsilon pi4n signn denomn iterationsn))))\n\n(define (iter_pi epsilon)\n  (walk epsilon 1.0 -1.0 3.0 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289751,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n(define (iter_pi epsilon)\n\n  (define (round10 x) (\/ (round (* x 1e10)) 1e10))\n  (define (delta mypi\/4) (abs (- pi (* 4 mypi\/4))))\n  \n  (define (rec mypi\/4 iters sign)\n    (if (<= (delta mypi\/4) epsilon)\n        (list iters (round10 (* 4 mypi\/4)))\n        (rec (+ mypi\/4 (\/ sign (+ (* 2 iters) 1)))\n             (add1 iters)\n             (- sign))))\n  (rec 1.0 1 -1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289752,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n(define (iter_pi epsilon)\n\n  (define (round10 x) (\/ (round (* x 1e10)) 1e10))\n  \n  (define (rec mypi\/4 delta iters sign)\n    (if (<= delta epsilon)\n        (list iters (round10 (* 4 mypi\/4)))\n        (let ([new-mypi\/4\n               (+ mypi\/4 (\/ sign (+ (* 2 iters) 1)))])\n          (rec new-mypi\/4\n               (abs (- pi (* 4 new-mypi\/4)))\n               (add1 iters)\n               (- sign)))))\n  (rec 0.0 4 0 1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289753,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n; round x with: (\/ (round (* x 1e10)) 1e10)\n(define (my-round x)\n  (\/ (round (* x 1e10)) 1e10))\n\n(define (iter_pi epsilon)\n  (define (iter pi-quart denom fn iters)\n    (let ([pi-approx (* 4 pi-quart)])\n      (if (< (abs (- pi pi-approx)) epsilon)\n          (list iters (my-round pi-approx))\n          (iter (fn pi-quart (\/ 1 denom))\n                (+ denom 2)\n                (if (eq? fn +) - +)\n                (+ iters 1)))))\n  (iter 1.0 3.0 - 1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289754,"user_id":null,"body":"#lang racket\/base\n(provide iter_pi)\n\n(require (only-in racket\/math pi)\n         racket\/flonum\n         racket\/fixnum)\n\n; round x with: (\/ (round (* x 1e10)) 1e10)\n(define (iter_pi epsilon)\n  (leibnitz epsilon 1.0 1))\n\n(define (leibnitz epsilon approx n)\n  (cond [(< (abs (fl- pi (fl* 4.0 approx))) epsilon)\n         (list n (round-ten (fl* 4.0 approx)))]\n        [else\n         (when (zero? (modulo n 1000)) (println (round-ten (fl* 4.0 approx))))\n         (leibnitz epsilon\n                   (fl+ approx (exact->inexact (\/ (expt -1 n) (fx+ (fx* 2 n) 1))))\n                   (add1 n))]))\n\n(define (round-ten x)\n  (fl\/ (round (fl* x 1e10)) 1e10))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289755,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n; round x with: (\/ (round (* x 1e10)) 1e10)\n(define (iter_pi epsilon)\n  (define (round-pi x)\n    (\/ (round (* x 1e10)) 1e10))\n  \n  (define (helper-plus base acc iterations)\n    (cond [(< (abs (- (* acc 4) pi)) epsilon) `(,iterations ,(round-pi (* acc 4)))]\n           [else (helper-minus (+ base 2) (+ acc (\/ 1 base)) (+ iterations 1))]))\n  \n  (define (helper-minus base acc iterations)\n    (cond [(< (abs (- (* acc 4) pi)) epsilon) `(,iterations ,(round-pi (* acc 4)))]\n           [else (helper-plus (+ base 2) (- acc (\/ 1 base)) (+ iterations 1))]))\n  \n  (helper-minus 3.0 1.0 1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289756,"user_id":544,"body":"#lang racket\n(provide iter_pi)\n\n; round x with: (\/ (round (* x 1e10)) 1e10)\n(define (kata-round x)\n  (\/ (round (* x 1e10)) 1e10))\n\n(define (iter_pi epsilon)\n  (for\/fold\n   ([pi-est 0]\n    [iter 0]\n    #:result (list iter (kata-round pi-est)))\n   ([i (in-naturals)]\n    #:break ((abs (- pi-est pi)) . <= . epsilon))\n    (values (+ pi-est\n               (* 4 (\/ (expt -1 (+ (add1 iter) 1.0))\n                       (- (* 2 (add1 iter)) 1))))\n            (add1 iter))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289757,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n(define (iter_pi epsilon)\n  (define (round-result x)\n    (\/ (round (* x 1e10)) 1e10))\n  (let loop ([x 1.0] [S 0.0] [s 1.0] [c 0])\n    (if (< (abs (- (* 4 S) pi)) epsilon)\n        (list c (round-result (* 4 S)))\n        (loop (+ x 2.0) (+ S (\/ s x)) (* s -1.0) (+ c 1)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289758,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n; round x with: (\/ (round (* x 1e10)) 1e10)\n(define (iter_pi \u03b5)\n  (define (rnd10 x)\n    (\/ (round (* x 1e10)) 1e10))\n  (define (approx? x \u03b5)\n    (< (abs (- pi x)) \u03b5))\n  (define (calc \u03b5 acc k sg n)\n    (if (approx? acc \u03b5) (list n (rnd10 acc)) (calc \u03b5 (+ acc (\/ 4 k sg)) (+ 2 k) (- 0 sg) (+ n 1))))\n  (calc \u03b5 0.0 1 1 0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289759,"user_id":null,"body":"#lang racket\n(provide iter_pi)\n\n(define (r10 num)\n  (\/ (round (* num 1e10)) 1e10))\n\n(define (iter_pi epsilon)\n  \"A tail recursive pi approximator\"\n  (define (accumulator previous-sum previous-term sign iterations)\n    (define next-term (+  previous-term 2))\n    (define next-iterations (add1 iterations))\n    (if (< (abs (- (* 4 previous-sum) pi)) epsilon)\n        (list iterations (r10 (* 4 previous-sum)))\n        (accumulator (+ previous-sum (* sign (\/ previous-term))) next-term (* -1 sign) next-iterations)))\n  (accumulator 0.0 1.0 1 0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"550554fd08b86f84fe000a58":[{"id":289760,"user_id":53,"body":"#lang racket\n(provide inArray)\n\n(define (string-contains str sub)\n  (regexp-match? (regexp sub) str))\n  \n(define (array-contains-sub ys x)\n  (> (length (filter (\u03bb (y) (string-contains y x)) ys)) 0))\n\n(define (inArray xs ys)\n  (sort (filter (\u03bb (x) (array-contains-sub ys x)) (remove-duplicates xs)) string<?))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289761,"user_id":null,"body":"#lang racket\n(provide inArray)\n\n\n(define (inArray ls1 ls2)\n  (define (contains? str)\n    (ormap (lambda (s) (string-contains? s str)) ls2))\n  (remove-duplicates (sort (filter contains? ls1) string<?)))\n  ","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289762,"user_id":544,"body":"#lang racket\n(provide inArray)\n\n(define (inArray ls1 ls2)\n  (remove-duplicates (sort (filter (\u03bb (in-word) (string-contains? (string-join ls2 \"\n\") in-word)) ls1) string<?)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289763,"user_id":null,"body":"#lang racket\n(provide inArray)\n\n(define (inArray ls1 ls2)\n  (let loop ((rem (sort ls1 string<?)) (acc '()))\n    (if (null? rem)\n        (remove-duplicates acc)\n        (let i-loop ((i-rem ls2))\n          (cond \n           ((null? i-rem) (loop (cdr rem) acc))\n           ((string-contains? (car i-rem) (car rem))\n            (loop (cdr rem) (append acc (list (car rem)))))\n           (else (i-loop (cdr i-rem))))))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289764,"user_id":null,"body":"#lang racket\n(provide inArray)\n(require racket\/set)\n\n(define (inArray ls1 ls2)\n  ; your code\n  (define resultWords (make-hash))\n  (for ([i ls1])\n    (for ([j ls2])\n      (if (string-contains? j i) (hash-set! resultWords i i) #f)\n    )\n  )\n  (define resultKeys (hash-keys resultWords))\n  (define sortedWords (sort resultKeys string<?))\n  sortedWords\n)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289765,"user_id":null,"body":"#lang racket\n(provide inArray)\n(require rackunit)\n\n;; https:\/\/docs.racket-lang.org\/algebraic\/prelude.html\n(define <<* curryr)\n(define .. compose)\n\n(define (_inArray substrings strings)\n    (filter (lambda (s) (ormap (<<* string-contains? s) strings)) substrings))\n(define inArray (.. (<<* sort string<=?) remove-duplicates _inArray))\n\n(check-equal? (inArray '(\"arp\" \"live\" \"strong\")\n                        '(\"lively\" \"alive\" \"harp\" \"sharp\" \"armstrong\"))\n              '(\"arp\" \"live\" \"strong\"))\n(check-equal? (inArray '(\"tarp\" \"mice\" \"bull\")\n                        '(\"lively\" \"alive\" \"harp\" \"sharp\" \"armstrong\"))\n              '())","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289766,"user_id":null,"body":"#lang racket\n(provide inArray)\n(require rackunit)\n\n;; https:\/\/docs.racket-lang.org\/algebraic\/prelude.html\n(define <<* curryr)\n(define .. compose)\n\n(define (_inArray substrings strings)\n  (match substrings\n    ['() '()]\n    [(cons s rest) #:when (ormap (<<* string-contains? s) strings)\n     (cons s (_inArray rest strings))]\n    [(cons _ rest) (_inArray rest strings)]))\n(define inArray (.. (<<* sort string<=?) remove-duplicates _inArray))\n\n(check-equal? (inArray '(\"arp\" \"live\" \"strong\")\n\t\t\t'(\"lively\" \"alive\" \"harp\" \"sharp\" \"armstrong\"))\n\t      '(\"arp\" \"live\" \"strong\"))\n\n(check-equal? (inArray '(\"tarp\" \"mice\" \"bull\")\n\t\t\t'(\"lively\" \"alive\" \"harp\" \"sharp\" \"armstrong\"))\n\t      '())\n\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289767,"user_id":null,"body":"#lang racket\n(provide inArray)\n\n(define (inArray ls1 ls2)\n  (define (filtering li acc)\n    (cond [(empty? li) acc]\n          [(filtering (cdr li)\n                      (if\n                       (ormap (lambda (table) (string-contains? table (car li))) ls2)\n                       (cons (car li) acc)\n                       acc))]))\n  (remove-duplicates (sort (filtering ls1 '()) string<?)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289768,"user_id":null,"body":"#lang racket\n(provide inArray)\n\n(define (inArray xs ys)\n  (let* ([x (filter (exists-as-substring? ys) xs)]\n         [y (set->list (apply set x))]\n         [z (sort y string<?)])\n    z))\n\n(define (exists-as-substring? xs)\n  (\u03bb (s)\n    (true? (findf (\u03bb (x) (string-contains? x s)) xs))))\n\n(define (true? x)\n  (not (not x)))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289769,"user_id":168,"body":"#lang racket\n(provide inArray)\n\n(define (inArray ls1 ls2)\n  (define t (filter (lambda (s) \n                      (member s ls2 (lambda (a b) (string-contains? b a)))) ls1))\n  (sort (remove-duplicates t) string<?)\n)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5506b230a11c0aeab3000c1f":[{"id":289770,"user_id":242,"body":"#lang racket\n(provide evaporator)\n\n(define (evaporator content evap-per-day threshold)\n  (exact-ceiling ( \/ (log (\/ threshold 100.0)) (log (- 1 (\/ evap-per-day 100.0)))))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289771,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n; Calculates how many days the evaporator will begin with a content above\n; the given threshold, assuming it consumes evap-per-day percent per day\n; AND begins with 100%. The content argument is unused.\n(define (evaporator content evap-per-day threshold)\n  (inexact->exact ; Convert float to int\n   (ceiling       ; floor would give us how many days it will stay above the threshold for the whole day\n    ; Each day, the evaporator uses evap-per-day percent of how much it has REMAINING\n    ; So, this is a compound interest problem.\n    ; percent^days=remaining, and we want days, so we take a log.\n    (log (\/ threshold 100)\n         (\/ (- 100 evap-per-day) 100))))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289772,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n; NOTE: use an exponential decay, closed form better than recursion\n(define (evaporator content evap-per-day threshold)\n  (exact-ceiling (\/\n          (log (\/ threshold 100))\n          (log  (- 1 (\/ evap-per-day 100)))\n          )\n         )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289773,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n(define (evaporator content evap-per-day threshold)\n  (exact-ceiling (log (\/ threshold 100) (- 1 (\/ evap-per-day 100)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289774,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n(define (evaporator content evap-per-day threshold)\n  (exact-ceiling (\/\n          (log (\/ threshold 100))\n          (log  (- 1 (\/ evap-per-day 100)))))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289775,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n(define (evaporator content evap-per-day threshold)\n  ; your code\n  (define (eva c epd thr c2 n)\n    (if (>= (* c thr 0.01) c2)\n        n\n        (eva c epd thr (- c2 (* epd c2 0.01)) (add1 n))))\n(eva content evap-per-day threshold content 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289776,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n;; auxiliary\n(define (%->ml vol %)\n  (* vol % .01))\n\n(define (left-after-day vol %)\n  (- vol (%->ml vol %)))\n\n;; main\n(define (evaporator content evap-per-day threshold)\n  (define threshold-in-ml (%->ml content threshold))\n  (define (cmp-cont ref-con content evap-per-day [expires-in 0])\n    (define current-content (left-after-day content evap-per-day))\n    (if (> content ref-con) (cmp-cont ref-con current-content evap-per-day (add1 expires-in)) expires-in))\n  (cmp-cont threshold-in-ml content evap-per-day))\n\n;; this one were really though, idk how to solve something like this,\n;; there's no explicit lists usage\n;; so I think I have to use some kind of recursion\n;; can't wait to see one line solution from codewars' veterans","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289777,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n(define (evaporator content evap-per-day threshold)\n  (define num\n    (log (\/ threshold 100)\n         (- 1 (\/ evap-per-day 100))))\n  (if (integer? num)\n      (exact-floor num)\n      (exact-ceiling num)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289778,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n(define evp\n  (lambda (content epd thresh)\n    (cond\n      ((<= content thresh) 0)\n      (else (+ 1 (evp (* content (\/ (- 100 epd) 100)) epd thresh))))))\n\n(define (evaporator content evap-per-day threshold)\n  (evp content evap-per-day (* (\/ threshold 100) content))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289779,"user_id":null,"body":"#lang racket\n(provide evaporator)\n\n(define (evaporator content evap-per-day threshold)\n  (define (iter current day)\n    (if (<= current (* content (\/ threshold 100)))\n        day\n        (iter (* current (\/ (- 100 evap-per-day) 100)) (+ day 1))))\n  (iter content 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5508249a98b3234f420000fb":[{"id":289780,"user_id":492,"body":"#lang racket\n(provide moving_shift demoving_shift)\n\n(define (caesar s shift encode-or-decode)\n  (define (move-char c shift idx encode-or-decode) \n    (let ([ch (char->integer c)] [val (* encode-or-decode (+ shift idx))])\n      (cond \n        [(and (>= ch (char->integer #\\A)) (<= ch (char->integer #\\Z)))\n         (integer->char (+ (modulo (+ val (- ch (char->integer #\\A))) 26) (char->integer #\\A)))]\n        [(and (>= ch (char->integer #\\a)) (<= ch (char->integer #\\z)))\n         (integer->char (+ (modulo (+ val (- ch (char->integer #\\a))) 26) (char->integer #\\a)))]\n        [else c])))\n  \n  (list->string\n   (for\/list ([c (in-string s)] [idx (range 0 (string-length s))])\n             (move-char c shift idx encode-or-decode))))\n\n(define (moving_shift s shift)\n  (define (chunk s)\n    (let* ([n (exact-ceiling (\/ (string-length s) 5.0))] [xs (string->list s)])\n      (let loop ([grouped '()] [xs xs] [lg (length xs)])\n        (cond\n          [(empty? xs)\n           (let ([res (map list->string grouped)])\n             (if (< (length res) 5)\n                 (reverse (cons \"\" res))\n                 (reverse res)))]\n          [(<= lg n) (loop (cons xs grouped) '() 0)]\n          [else\n           (let-values ([(taken dropped) (split-at xs n)])\n             (loop (cons taken grouped) dropped (- lg n)))]))))\n  \n  (chunk (caesar s shift 1)))\n\n(define (demoving_shift s shift)\n  (caesar (string-join s \"\") shift -1))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289781,"user_id":null,"body":"#lang racket\n(provide moving_shift demoving_shift)\n(require rackunit)\n\n(define (rotate c n base-char)\n  (let* ([base (char->integer base-char)]\n         [shifted (((char->integer c) . - . base) . + . n)])\n    (integer->char ((modulo shifted 26) . + . base))))\n  \n;; Char Int -> Char\n;; Rotates character n to the right, cycling around.\n(define (rotate-char c n)\n  (match c\n   [(? char-upper-case?) (rotate c n #\\A)]\n   [(? char-lower-case?) (rotate c n #\\a)]\n   [_ c]))\n\n(check-equal? (rotate-char #\\a 2) #\\c)\n(check-equal? (rotate-char #\\c -2) #\\a)\n(check-equal? (rotate-char #\\h 5) #\\m)\n(check-equal? (rotate-char #\\z 2) #\\b)\n(check-equal? (rotate-char #\\a 53) #\\b)\n(check-equal? (rotate-char #\\A 2) #\\C)\n(check-equal? (rotate-char #\\H 5) #\\M)\n(check-equal? (rotate-char #\\Z 2) #\\B)\n(check-equal? (rotate-char #\\A 53) #\\B)\n(check-equal? (rotate-char #\\B -53) #\\A)\n\n;; String Int -> [List-of String]\n;; Splits string into n groups, favouring all but the last.\n(define (string-divide string n)\n  (let* ([len (string-length string)]\n         [slice (exact-ceiling (len . \/ . n))])\n    (define (inner string start)\n      (let ([end (start . + . slice)])\n        (if (end . > . len)\n            (list (substring string start len) \"\")\n            (cons (substring string start end) (inner string end)))))\n    (take (inner string 0) n)))\n\n(check-equal?\n (string-divide (make-string 17 #\\a) 5)\n '(\"aaaa\" \"aaaa\" \"aaaa\" \"aaaa\" \"a\"))\n(check-equal?\n (string-divide (make-string 16 #\\a) 5)\n '(\"aaaa\" \"aaaa\" \"aaaa\" \"aaaa\" \"\"))\n(check-equal?\n (string-divide (make-string 11 #\\a) 5)\n '(\"aaa\" \"aaa\" \"aaa\" \"aa\" \"\"))\n\n(check-equal?\n (string-divide \"J vltasl rlhr zdfog odxr ypw atasl rlhr p gwkzzyq zntyhv lvz wp!!!\" 5)\n '(\"J vltasl rlhr \" \"zdfog odxr ypw\" \" atasl rlhr p \" \"gwkzzyq zntyhv\" \" lvz wp!!!\"))\n\n(define (moving_shift s shift)\n  (define (helper lst i)\n    (match lst\n      ['() '()]\n      [(cons c rest) (cons (rotate-char c i) (helper rest (add1 i)))]))\n  (define present (compose (curryr string-divide 5) list->string))\n  (present (helper (string->list s) shift)))\n\n(check-equal?\n (moving_shift \"I should have known that you would have a perfect answer for me!!!\" 1)\n '(\"J vltasl rlhr \" \"zdfog odxr ypw\" \" atasl rlhr p \" \"gwkzzyq zntyhv\" \" lvz wp!!!\"))\n\n(define (demoving_shift lst shift)\n  (define negate (curry * -1))\n  (define (helper lst i)\n    (match lst\n      ['() '()]\n      [(cons c rest) (cons (rotate-char c (negate i)) (helper rest (add1 i)))]))\n  (let ([string (foldr string-append \"\" lst)])\n    (list->string (helper (string->list string) shift))))\n\n(check-equal?\n (demoving_shift\n '(\"J vltasl rlhr \" \"zdfog odxr ypw\" \" atasl rlhr p \" \"gwkzzyq zntyhv\" \" lvz wp!!!\") 1)\n  \"I should have known that you would have a perfect answer for me!!!\")","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289782,"user_id":544,"body":"#lang racket\n(provide moving_shift demoving_shift)\n\n(define (caesar-shift chr shift)\n  (define pos (char->integer chr))\n  (integer->char (cond [(member pos (range 65 91)) (+ (modulo (+ pos shift -65) 26) 65)]\n                       [(member pos (range 97 123)) (+ (modulo (+ pos shift -97) 26) 97)]\n                       [else pos]))) ; don't try to shift punctuation etc.\n\n(define (repeated-split lst n)\n  (cond [((length lst) . <= . n) (list lst)]\n        [else (cons (take lst n) (repeated-split (drop lst n) n))]))\n\n; account for empty-handed couriers by adding empty entries to fill out the list\n(define (pad-list lst size)\n  (if (= (length lst) size)\n      lst\n      (pad-list (append lst (list \"\")) size)))\n\n(define (moving_shift s shift)\n  (define encoded\n    (let ([charlist (string->list s)])\n      (for\/list ([c (in-list charlist)]\n                 [i (in-naturals shift)])\n        (caesar-shift c i))))\n  ; algorithm:\n  ; 1. if you can split it evenly 5 ways, do so\n  ; 2. if you can't, try splitting it 4 ways and rounding up the quotient,\n  ;    then handing out that portion until you run out of equal parts\n  ; ex: 20 mod 5 = 0, 20\/5 = 4\n  ;     couriers 1-5 get 4\n  ; ex: 17 mod 5 \u2260 0, so 17\/5 = 3.4, ceiling(3.4) = 4\n  ;     couriers 1-4 get 4, 1 left over for courier 5\n  ; ex: 66 mod 5 \u2260 0, so 66\/5 = 13.2, ceiling(13.2) = 14\n  ;     couriers 1-4 get 14, 10 left over for courier 5\n  ; ex: 7 mod 5 \u2260 0, so 7\/5 = 1.4, ceiling(1.2) = 2\n  ;     couriers 1-3 get 2, courier 4 gets 1, courier 5 stays home\n  (define split-list\n    (map list->string\n         (cond [(= 0 (modulo (length encoded) 5))\n                (repeated-split encoded (quotient (length encoded) 5))]\n               [else\n                (repeated-split encoded (exact-ceiling (\/ (length encoded) 5)))])))\n  (pad-list split-list 5))\n\n(define (demoving_shift s shift)\n  (define decoded\n    (let ([charlist (string->list (string-join s \"\"))])\n      (for\/list ([c (in-list charlist)]\n                 [i (in-naturals shift)])\n        (caesar-shift c (- i)))))\n  (list->string decoded))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289783,"user_id":null,"body":"#lang racket\n\n(provide moving_shift demoving_shift)\n\n(define (alpha? char) (and (char<=? #\\a (char-downcase char)) (char>=? #\\z (char-downcase char))))\n\n(define (encrypt-shift-char shift char)\n  (if (alpha? char)\n      (let* ([zero-based (- (char->integer (char-downcase char)) (char->integer #\\a))]\n             [positive-shift (let loop ([s shift]) (if (negative? s) (loop (+ 26 s)) s))]\n             [shifted-int (remainder (+ zero-based positive-shift) 26)]\n             [shifted-char (integer->char (+ shifted-int (char->integer #\\a)))])\n        (if (char-upper-case? char) (char-upcase shifted-char) shifted-char))\n      char))\n  \n(define (moving_shift s shift)\n  (define len (string-length s))\n  (define moved (build-string len (\u03bb (i) (encrypt-shift-char (+ i shift) (string-ref s i)))))\n  (define segment-size (ceiling (\/ len 5)))\n  (build-list 5 (\u03bb (n) (substring moved (* segment-size n) (min len (* segment-size (add1 n)))))))\n\n(define (demoving_shift s shift)\n  (define joined (string-join s \"\"))\n  (build-string\n   (string-length joined)\n   (\u03bb (i) (encrypt-shift-char (- (+ i shift)) (string-ref joined i)))))\n\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289784,"user_id":null,"body":"#lang racket\n(provide moving_shift demoving_shift)\n\n(define (shiftc c a)\n  (define n (char->integer c))\n  (define (f m)\n    (integer->char (+ m (modulo (+ (- n m) a) 26))))\n  (cond [(and (>= n 65) (< n 91)) (f 65)]\n        [(and (>= n 97) (< n 123)) (f 97)]\n        [else c]))\n\n(define (shifts s n)\n  (list->string (map shiftc\n                     (string->list s)\n                     (range n (+ (string-length s) n)))))\n\n(define (unshifts s n)\n  (list->string (map shiftc\n                     (string->list s)\n                     (reverse (range (- 1 (string-length s) n)\n                                     (- 1 n))))))\n\n(define (sizes n)\n  (let* ([l 5]\n         [b (ceiling (\/ n l))])\n    (let-values ([(q r) (quotient\/remainder n b)])\n      (take (append (make-list q b)\n                    (list r)\n                    (make-list l 0))\n            l))))\n\n(define (splits lst idxs)\n  (cond\n    [(null? idxs) '()]\n    [else\n      (let ([n (car idxs)])\n        (let-values ([(s e) (split-at lst n)])\n          (cons s (splits e (cdr idxs)))))]))\n\n(define (moving_shift s shift)\n  (map list->string\n       (splits (string->list (shifts s shift))\n               (sizes (string-length s)))))\n\n(define (demoving_shift ls shift)\n  (unshifts (apply string-append ls) shift))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289785,"user_id":null,"body":"#lang racket\n(provide moving_shift demoving_shift)\n\n(define (shift-char c n)\n  (define (biased-shift bias char n)\n    (let ((b (char->integer bias))\n          (c (char->integer char)))\n      (integer->char (+ b (modulo (+ n c (- b)) 26)))))\n\n  (cond ((not (char-alphabetic? c)) c)\n        ((char-upper-case? c) (biased-shift #\\A c n))\n        (else (biased-shift #\\a c n))))\n\n(define (step i)\n  (lambda (c p)\n    (cons (+ i (car p))\n          (string-append (cdr p) (string (shift-char c (car p)))))))\n\n(define (encypher s shift)\n  (cdr (foldl (step 1) (cons shift \"\") (string->list s))))\n\n(define (decypher s shift)\n  (cdr (foldl (step -1) (cons (- shift) \"\") (string->list s))))\n\n(define (chunks l)\n  (let ((m (quotient l 5)))\n    (if (= (* 5 m) l)\n        (list m m m m m)\n        (let loop ((n 5)\n                   (o (- l (* 4 m)))\n                   (R '()))\n          (cond ((= 1 n) (cons o R))\n                ((zero? o) (loop (- n 1) 0 (cons m R)))\n                (else (loop (- n 1) (- o 1) (cons (+ 1 m) R))))))))\n\n(define (chunk-string s)\n  ((compose cdr foldl)\n   (lambda (n p) (let ((end (car p))\n                       (start (- (car p) n)))\n                   (cons start\n                         (cons (substring s start end) (cdr p)))))\n   (cons (string-length s) '())\n   (chunks (string-length s))))\n\n(define (moving_shift s shift) (chunk-string (encypher s shift)))\n\n(define (demoving_shift s shift) (decypher (apply string-append s) shift))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"550f22f4d758534c1100025a":[{"id":289786,"user_id":527,"body":"#lang racket\n(provide dir_reduc)\n\n(define opposite\n  '((\"NORTH\" . \"SOUTH\") (\"EAST\" . \"WEST\") (\"SOUTH\" . \"NORTH\") (\"WEST\" . \"EAST\")))\n\n(define (dir_reduc plan)\n  (for\/fold\n   ([new-plan null]\n    #:result (reverse new-plan))\n   ([dir plan])\n   (if (and (not (null? new-plan)) (equal? (first new-plan) (dict-ref opposite dir)))\n       (rest new-plan)\n       (cons dir new-plan))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289787,"user_id":53,"body":"#lang racket\n(provide dir_reduc)\n\n(define (init xs) (reverse (cdr (reverse xs))))\n\n(define (are-opposites a b)\n  (cond\n       [(and (equal? a \"NORTH\") (equal? b \"SOUTH\")) #t]\n       [(and (equal? a \"SOUTH\") (equal? b \"NORTH\")) #t]\n       [(and (equal? a \"EAST\") (equal? b \"WEST\")) #t]\n       [(and (equal? a \"WEST\") (equal? b \"EAST\")) #t]\n       [else #f]))\n\n(define (visit x xs)\n  (if (empty? xs)\n    (append xs (list x))\n    (if (are-opposites x (last xs))\n      (init xs)\n      (append xs (list x)))))\n\n(define (dir_reduc arr)\n  (foldl visit empty arr))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289788,"user_id":492,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc arr)\n  (define (opp-dir direction)\n  (cond\n    ((equal? direction \"NORTH\") \"SOUTH\")\n    ((equal? direction \"SOUTH\") \"NORTH\")\n    ((equal? direction \"WEST\")  \"EAST\")\n    ((equal? direction \"EAST\")  \"WEST\")))\n    \n  (let ([d (if (pair? arr)\n               (if (pair? (rest arr))\n                   (if (equal? (first arr) (opp-dir (first (rest arr))))\n                       (dir_reduc (rest (rest arr)))\n                       (cons (first arr) (dir_reduc (rest arr))))\n                   arr)\n               '())\n        ])\n    (if (equal? d arr)\n        arr\n        (dir_reduc d))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289789,"user_id":null,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc path)\n  (foldr (lambda (direction reduced)\n           (match (cons direction reduced)\n             (`(\"NORTH\" \"SOUTH\" ,xs ...) xs)\n             (`(\"SOUTH\" \"NORTH\" ,xs ...) xs)\n             (`(\"EAST\"  \"WEST\"  ,xs ...) xs)\n             (`(\"WEST\"  \"EAST\"  ,xs ...) xs)\n             (_ (cons direction reduced))))\n         '() path))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289790,"user_id":null,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc arr)\n  (if (null? arr) '() (reverse (reduc-rev arr))))\n\n(define contra-dir\n  #hash(\n        (\"NORTH\" . \"SOUTH\") (\"WEST\" . \"EAST\")\n        (\"SOUTH\" . \"NORTH\") (\"EAST\" . \"WEST\")))\n\n(define (reduc-rev arr)\n  (let loop ([cur '()]\n             [rest arr])\n    (cond\n      [(null? rest) cur]\n      [(null? cur) (loop `(,(car rest)) (cdr rest))]\n      [else\n        (let ([prev (car cur)]\n              [behind (cdr cur)]\n              [step (car rest)]\n              [beyond (cdr rest)])\n          (if (eq? step (hash-ref contra-dir prev))\n            (loop behind beyond)\n            (loop (cons step cur) beyond)))])))\n\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289791,"user_id":null,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc arr)\n  (letrec [(destroy-terms\n            (lambda (lat)\n              (cond\n               ((< (length lat) 2) lat)\n               ((or\n                 (and (eq? (car lat) \"NORTH\") (eq? (cadr lat) \"SOUTH\"))\n                 (and (eq? (car lat) \"SOUTH\") (eq? (cadr lat) \"NORTH\"))\n                 (and (eq? (car lat) \"EAST\") (eq? (cadr lat) \"WEST\"))\n                 (and (eq? (car lat) \"WEST\") (eq? (cadr lat) \"EAST\")))\n                (destroy-terms (cddr lat)))\n               (#t (cons (car lat) (destroy-terms (cdr lat)))))))\n           (destroyable-terms?\n              (lambda (lat)\n                (cond\n                 ((< (length lat) 2) #f)\n                 ((or\n                   (and (eq? (car lat) \"NORTH\") (eq? (cadr lat) \"SOUTH\"))\n                   (and (eq? (car lat) \"SOUTH\") (eq? (cadr lat) \"NORTH\"))\n                   (and (eq? (car lat) \"EAST\") (eq? (cadr lat) \"WEST\"))\n                   (and (eq? (car lat) \"WEST\") (eq? (cadr lat) \"EAST\")))\n                  #t)\n                 (#t (destroyable-terms? (cdr lat))))))]\n    (if (destroyable-terms? arr) (dir_reduc (destroy-terms arr)) arr)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289792,"user_id":null,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc arr)\n  (define (f a r)\n    (match (list a (car r))\n      ['(\"NORTH\" \"SOUTH\") (cdr r)]\n      ['(\"SOUTH\" \"NORTH\") (cdr r)]\n      ['(\"EAST\" \"WEST\") (cdr r)]\n      ['(\"WEST\" \"EAST\") (cdr r)]\n      [_ (cons a r)]))\n  (cdr (reverse (foldl f '(\"CENTER\") arr)))\n  )","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289793,"user_id":null,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc arr)\n  (define (dir_reduc-recur lst result)\n    (if (empty? lst)\n        result\n        (match (list (first lst) (first result))\n          ((or (list \"NORTH\" \"SOUTH\")\n               (list \"SOUTH\" \"NORTH\")\n               (list \"EAST\" \"WEST\")\n               (list \"WEST\" \"EAST\")) (dir_reduc-recur (rest lst) (rest result)))\n          (_ (dir_reduc-recur (rest lst) (cons (first lst) result))))))\n  (rest (reverse (dir_reduc-recur arr '(\"NOTHING\")))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289794,"user_id":null,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir_reduc arr)\n    (let* ([opposite (hash \"NORTH\" \"SOUTH\"\n                           \"SOUTH\" \"NORTH\"\n                           \"EAST\"  \"WEST\"\n                           \"WEST\"  \"EAST\")]\n           [quitar-opuestos (lambda (elt acc)\n                              (if (eq? acc '())\n                                  (cons elt acc)\n                                  (if (eq? (hash-ref opposite elt) (car acc))\n                                      (cdr acc)\n                                      (cons elt acc))))])\n      (reverse (foldl quitar-opuestos '() arr))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289795,"user_id":544,"body":"#lang racket\n(provide dir_reduc)\n\n(define (dir-opposing? dir1 dir2)\n  (member\n   (list dir1 dir2)\n   (list '(\"NORTH\" \"SOUTH\")\n         '(\"SOUTH\" \"NORTH\")\n         '(\"EAST\"  \"WEST\")\n         '(\"WEST\"  \"EAST\"))))\n\n(define (dir_reduc arr)\n  (let ([arr-filtered (dir_reduc-pass arr)])\n    (if (equal? arr arr-filtered) arr (dir_reduc (dir_reduc-pass arr))))\n)\n\n(define (dir_reduc-pass arr)   \n  (cond [(null? arr) '()] \n        [(null? (cdr arr)) arr]\n        [(dir-opposing? (first arr) (second arr)) (dir_reduc (list-tail arr 2))]\n        [else (cons (car arr) (dir_reduc (cdr arr)))]))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5513795bd3fafb56c200049e":[{"id":289796,"user_id":null,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n  (for\/list ([i (range 1 (add1 list-length))])\n    (* i multiples-of)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289797,"user_id":527,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n  (range multiples-of (add1 (* list-length multiples-of)) multiples-of))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289798,"user_id":53,"body":"#lang racket\n(provide count_by)\n(define (inclusive-range a b) (range a (add1 b)))\n(define (count_by x n) (map (\u03bb (i) (* x i)) (inclusive-range 1 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289799,"user_id":null,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n    (map (lambda (x) (* x multiples-of))  (range 1 (+ 1 list-length)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289800,"user_id":168,"body":"#lang racket\n(provide count_by)\n\n(define (count_by m l)\n  (range m (+ m (* m l)) m))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289801,"user_id":564,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n  (map\n    (lambda (n) (* multiples-of (+ 1 n)))\n    (for\/list ([i (in-range list-length)]) i)\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289802,"user_id":null,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n  (build-list list-length (lambda (n) (* (add1 n) multiples-of))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289803,"user_id":null,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n  (inclusive-range multiples-of (* multiples-of list-length) multiples-of))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289804,"user_id":null,"body":"#lang racket\n(provide count_by)\n\n(define (count_by x n)\n    (define (count_by-inner x n start-n)\n      (if (= n 1)\n          (cons (* x start-n) `())\n          (cons (* x (- (+ start-n 1) n)) (count_by-inner x (- n 1) start-n))))\n  (count_by-inner x n n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289805,"user_id":null,"body":"#lang racket\n(provide count_by)\n\n(define (count_by multiples-of list-length)\n  (range multiples-of (* multiples-of (+ 1 list-length)) multiples-of))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5517fcb0236c8826940003c9":[{"id":289806,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (define (zip li acc)\n    (cond [(empty? li) acc]\n          [else (zip (cdr li)\n                     (cons (\/ (caar li) (cdar li)) acc))]))\n  (let* ((number (foldl + 0 (zip ls '())))\n         (n (numerator number))\n         (d (denominator number)))\n    (cond [(= n 0) 0]\n          [(= d 1) n]\n          [else `(,n . ,d)])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289807,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (if (null? ls) 0\n      (let ([sum (for\/sum ([pair ls]) (\/ (car pair) (cdr pair)))])\n        (if (integer? sum) sum\n            (cons (numerator sum) (denominator sum))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289808,"user_id":53,"body":"#lang racket\n(provide sum_fracts)\n\n(define (norm t d)\n  (let* ([a (car t)]\n         [b (cdr t)])\n      (cons (quotient (* a d) b) d)))\n\n(define (reduce t)\n  (let* ([a (car t)]\n         [b (cdr t)]\n         [g (gcd a b)])\n      (cons (quotient a g) (quotient b g))))\n\n(define (convert-fracts ls)\n  (let* ([xss (map (\u03bb (xs) (reduce xs)) ls)]\n         [d (foldl (\u03bb (xs acc) (lcm (cdr xs) acc)) 1 xss)]\n         [yss (map (\u03bb (xs) (norm xs d)) xss)])\n      yss))\n\n(define (sum_fracts ls)\n  (if (empty? ls) 0\n      (let* ([xs (convert-fracts ls)]\n         [n (foldl (\u03bb (xs acc) (+ acc (car xs))) 0 xs)]\n         [d (cdr (first xs))]\n         [g (gcd n d)])\n      (if (= d g)\n          (quotient n g)\n          (cons (quotient n g) (quotient d g))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289809,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (if (empty? ls) \n      0\n      (let ([sum (apply + (map (lambda(x) (\/ (car x) (cdr x))) ls))])\n        \n        (if (= 1 (denominator sum)) \n            (numerator sum)\n            `(,(numerator sum) . ,(denominator sum))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289810,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (numerators ls)\n  (for\/list ([p ls]) (car p)))\n\n(define (denominators ls)\n  (for\/list ([p ls]) (cdr p)))\n\n(define (one? n) (eqv? n 1))\n\n(define (reduce-fract n d)\n  (let ([g (gcd n d)])\n    (cond\n      [(and (one? g) (one? d)) n]\n      [(one? g) (cons n d)]\n      [else (reduce-fract (\/ n g) (\/ d g))])))\n\n(define (sum_fracts ls)\n  (if (empty? ls)\n      0\n      (sum-nonempty-fracts ls)))\n\n(define (sum-nonempty-fracts ls)\n  (let ([D (apply lcm (denominators ls))])\n    (let ([N (for\/sum ([n (numerators ls)]\n                       [d (denominators ls)])\n               (* n (\/ D d)))])\n      (reduce-fract N D))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289811,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (if (null? ls) 0\n      (let* ([fract-list\n              (for\/list ([pair ls]) (\/ (car pair) (cdr pair)))]\n             [sum \n              (apply + fract-list)])\n        (if (integer? sum) sum\n            (cons (numerator sum) (denominator sum))))))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289812,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (define result (for\/sum ([numer&denom ls])\n                   (\/ (car numer&denom) (cdr numer&denom))))\n  (if (integer? result)\n      result\n      `(,(numerator result) . ,(denominator result))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289813,"user_id":null,"body":"#lang racket\n\n(provide sum_fracts)\n\n;; (Listof (Pair Int Int)) -> (or\/c Int (Pair Int Int))\n;; given a list of fractions, represented as (numerator . denominator) pairs,\n;; return their sum in an irreducable form, represented by a (numerator .\n;; denominator) pair, or simply as integer if sum is an integer\n(define (sum_fracts ls)\n  (define s (for\/sum ([p ls]) (\/ (car p) (cdr p))))\n  (if (integer? s) s `(,(numerator s) . ,(denominator s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289814,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (let ([sum \n         (apply + (map (lambda (x) (\/ (car x) (cdr x))) ls))])\n    (if (integer? sum)\n      sum\n      (cons (numerator sum) (denominator sum)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289815,"user_id":null,"body":"#lang racket\n(provide sum_fracts)\n\n(define (sum_fracts ls)\n  (cond\n    ((null? ls) 0)\n    ((null? (cdr ls)) (car ls))\n    (else (add-fracts (car ls) (sum_fracts (cdr ls)) ))\n  )\n)\n\n(define (add-fracts left right)\n  (cond\n     (\n       (number? left)\n       (cond\n          ((number? right) (* left right))\n          (else (simple (cons (+ (* left (cdr right)) (car right)) (cdr right))))\n       )\n     )\n     ((number? right) (simple (cons (+ (* (cdr left) right) (car left)) (cdr left) )) )\n     (else (simple (cons (+ (* (car left) (cdr right)) (* (car right) (cdr left)))  (* (cdr left) (cdr right)))))\n  )\n)\n\n(define (simple fract)\n    (let* (\n           (d (gcd (car fract) (cdr fract)))\n           (mynumerator (\/ (car fract) d))\n           (mydenominator (\/ (cdr fract) d))\n          )\n      (cond\n        ((= mydenominator 1) mynumerator)\n        (else (cons mynumerator mydenominator))\n      )\n    )  \n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5536a85b6ed4ee5a78000035":[{"id":289816,"user_id":null,"body":"#lang racket\n(provide tour)\n\n(define (tour frnds fr-twns t-dist)\n  (define (dumb-list->hash lst)\n    (make-immutable-hash (map (match-lambda [(list a b) (cons a b)]) lst)))\n  (define friend-map (dumb-list->hash fr-twns))\n  (define distance-map (dumb-list->hash t-dist))\n  (define distances (filter (negate zero?)\n                            (map (\u03bb (f) (hash-ref distance-map (hash-ref friend-map f null) 0.0)) frnds)))\n  (inexact->exact\n   (floor\n    (+ (car distances)\n       (last distances)\n       (for\/sum ([a (in-list distances)] [b (in-list (cdr distances))])\n         (sqrt (abs (- (sqr a) (sqr b)))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289817,"user_id":null,"body":"#lang racket\n(provide tour)\n\n(define (tour frnds fr-twns t-dist)\n  (define d\n    (let loop ([pos 'x0] [frnds frnds] [dist 0])\n    (cond [(null? frnds) (+ dist (distance t-dist pos 'x0))]\n          [else\n           (define dest (lookup fr-twns (first frnds)))\n           (if dest\n               (loop dest (rest frnds) (+ dist (distance t-dist pos dest)))\n               (loop pos (rest frnds) dist))])))\n  (inexact->exact (floor d)))\n\n(define (distance t-dist from to)\n  (cond [(eq? from 'x0) (lookup t-dist to)]\n        [(eq? to 'x0) (lookup t-dist from)]\n        [else\n         (define x0-from (lookup t-dist from))\n         (define x0-to (lookup t-dist to))\n         (sqrt (abs (- (sqr x0-to) (sqr x0-from))))]))\n\n(define (lookup table key)\n  (define pair (assoc key table))\n  (and pair (second pair)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289818,"user_id":null,"body":"#lang racket\n(provide tour)\n\n(define first car)\n(define (last lst) (car (reverse lst)))\n\n(define (map-search elt map)\n    (if (null? map)\n        #f\n        (if (eqv? elt (caar map))\n            (cadar map)\n            (map-search elt (cdr map)))))\n\n (define (dist-from-a->sides lst)\n    (let loop ([lst lst]\n               [result '()])\n        (cond [(= (length lst) 0) 0]\n              [(= (length lst) 1) result]\n              [else (let* ([elt1 (car lst)]\n                   [elt2 (cadr lst)]\n                   [pair (list elt1 elt2)])\n                (loop (cdr lst) (cons pair result)))])))\n\n(define (map-list-process lst map)\n     (let loop ([lst lst]\n                [map map]\n                [result '()])\n         (if (null? lst)\n             (reverse result) \n             (let* ([elt (car lst)]\n                    [new (map-search elt map)])\n\t\t (if (eq? #f new)\n\t\t     (loop (cdr lst) map result)\n                     (loop (cdr lst) map (cons new result)))))))\n\n(define (friends->towns lst-friends map-friends-towns)\n    (map-list-process lst-friends map-friends-towns))\n\n(define (towns->dist-from-a lst-towns map-towns-dist)\n    (map-list-process lst-towns map-towns-dist))\n\n(define (get-long lst)\n    (cond [(= (length lst) 0) 0]\n          [(= (length lst) 1) (car lst)]\n          [else\n              (let* ([hipot (max (car lst) (cadr lst))]\n                     [catet (min (car lst) (cadr lst))])\n                  (sqrt (- (* hipot hipot) (* catet catet))))]))\n\n(define (tour lst-friends map-friends-towns map-towns-dist)\n    (let* ([lst-towns (friends->towns lst-friends map-friends-towns)]\n           [lst-dist (towns->dist-from-a lst-towns map-towns-dist)]\n           [lst-sides (dist-from-a->sides lst-dist)]\n           [lst-long (cons (first lst-dist) (cons (last lst-dist) (map get-long lst-sides)))])\n        (inexact->exact (floor (foldr + 0 lst-long)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289819,"user_id":492,"body":"#lang racket\n(provide tour)\n\n(define (tour frnds fr-twns t-dist)\n  (define (topyh x y)\n    (sqrt (abs (- (* x x) (* y y)))))\n  (let* ([ls (map (lambda(x) (cons (first x) (second x))) fr-twns)]\n         [hash-ftowns (make-immutable-hash ls)]\n         [tour (for\/list ([x frnds]\n                          #:when (hash-has-key? hash-ftowns x))\n                 (hash-ref hash-ftowns x))]\n         [ds (map (lambda(x) (cons (first x) (second x))) t-dist)]\n         [hash-dist (make-immutable-hash ds)]\n         [dist (for\/list ([x tour]\n                          #:when (hash-has-key? hash-dist x))\n                 (hash-ref hash-dist x))])    \n    (exact-floor (+ (apply + (map topyh dist (cons  0.0 (drop-right dist 1)))) (last dist)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5539fecef69c483c5a000015":[{"id":289820,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (prime? n)\n  (for\/and ([i (in-range 2 (add1 (sqrt n)))])\n           (positive? (remainder n i))))\n\n(define rev\n  (compose string->number\n           list->string\n           reverse\n           string->list\n           number->string))\n\n(define (bprime? n)\n  (let ([m (rev n)])\n    (and (not (= m n))\n         (prime? n)\n         (prime? m))))\n\n(define (backwards_prime start end)\n  (filter bprime? (range start (add1 end))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:14:41"},{"id":289821,"user_id":null,"body":"#lang racket\n\n(provide backwards_prime)\n(require srfi\/13)\n\n\n(define (prime? x n)\n  (cond\n    [(>= (* x x) (add1 n)) #t]\n    [(= (remainder n x) 0) #f]\n    [else (prime? (+ x 1) n)]\n    ))\n\n(define (backwards_prime start nd)\n  (define (rec n s e lst)\n    (cond\n      [(> s n) lst]\n      [(and (prime? 2 n)\n            (not (equal? (number->string n) (string-reverse(number->string n))))\n            (prime? 2 (string->number (string-reverse (number->string n)))))\n       (rec (- n 1) s e (append (list n) lst))]\n      [else (rec (- n 1) s e lst)]\n      ))\n  (rec nd start nd '())\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:14:43"},{"id":289822,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (backwards_prime start nd)\n  (if (> start nd) '()\n      (append (if (is-backward-prime? start) (list start) '())\n              (backwards_prime (+ 1 start) nd))))\n\n(define (is-backward-prime? n)\n  (let ([r (reverse-number n)])\n    (and (not (= n r)) (is-prime? n) (is-prime? r))))\n\n(define (is-prime? n)\n  (cond [(<= n 3) #t]\n        [(or (= 0 (modulo n 2)) (= 0 (modulo n 3))) #f]\n        [else (has-divisor? n)]))\n\n(define (has-divisor? n)\n  (define (iter-divisor m)\n    (cond [(> (* m m) n) #t]\n          [(or (= 0 (modulo n m)) (= 0 (modulo n (+ 2 m)))) #f]\n          [else (iter-divisor (+ 6 m))]))\n  (iter-divisor 5))\n\n(define (reverse-number n)\n  (string->number (list->string (reverse (string->list (number->string n))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289823,"user_id":53,"body":"#lang racket\n(provide backwards_prime)\n\n(define (is-prime? n)\n  (define (aux i)\n    (cond \n      [(> (* i i) n) #t]\n      [(or (zero? (modulo n i)) (zero? (modulo n (+ i 2)))) #f]\n      [else (aux (+ i 6))]))\n  (cond\n    [(or (zero? (modulo n 2)) (zero? (modulo n 3))) (< n 4)]\n    [else (aux 5)]))\n\n(define (reverse-digits n)\n  (string->number\n   (list->string\n    (reverse\n     (string->list\n      (number->string n))))))\n\n(define (is-palindromic? n)\n  (eq? n (reverse-digits n)))\n\n(define (backwards_prime start nd)\n  (filter (\u03bb (i) (and (is-prime? i) (not (is-palindromic? i)) (is-prime? (reverse-digits i)))) (range start (add1 nd))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289824,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (backwards_prime start nd)\n  (stream->list (stream-filter (lambda (n) (let ((reversed-n (reverse-number n)))\n                                             (and (not (= reversed-n n))\n                                                  (prime? n)\n                                                  (prime? reversed-n))))\n                               (in-range start (add1 nd)))))\n\n(define (reverse-number n)\n  (string->number (list->string (reverse (string->list (number->string n))))))\n\n(define (prime? n)\n  (define (factor? factor)\n    (cond ((> (* factor factor) n) #t)\n          ((zero? (remainder n factor)) #f)\n          (else (factor? (+ factor 2)))))\n  (or (= n 2)\n      (and (odd? n)\n           (>= n 3)\n           (factor? 3))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289825,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (backwards_prime start nd)\n  (stream->list (stream-filter (lambda (n) (let ((reversed-n (reverse-number n)))\n                                             (and (not (equal? reversed-n n))\n                                                  (fast-prime10? n)\n                                                  (prime? n)\n                                                  (fast-prime10? reversed-n)\n                                                  (prime? reversed-n))))\n                               (in-range start (add1 nd)))))\n\n(define (reverse-number n)\n  (string->number (list->string (reverse (string->list (number->string n))))))\n\n(define (prime? n)\n  (or (= n 2)\n      (and (odd? n)\n           (>= n 3)\n           (let ((factor-limit (floor (sqrt n))))\n             (define (factor? factor)\n               (cond ((> factor factor-limit) #t)\n                     ((zero? (remainder n factor)) #f)\n                     (else (factor? (+ factor 2)))))\n             (factor? 3)))))\n\n(define (fast-prime10? n) (fast-prime? n 10))\n\n(define (fast-prime? n times)\n  (cond ((zero? times) #t)\n        ((fermat-test n) (fast-prime? n (sub1 times)))\n        (else #f)))\n\n(define (fermat-test n)\n  (define (try-it a) (= a (expmod a n n)))\n  (or (>= n 4294967089) ; validate that random procedure arg is in range\n      (try-it (add1 (random (sub1 n))))))\n\n(define (expmod base exp m)\n  (cond ((zero? exp) 1)\n        ((even? exp) (remainder (square (expmod base (\/ exp 2) m))\n                                m))\n        (else (remainder (* base (expmod base (sub1 exp) m))\n                         m))))\n\n(define (square n) (* n n))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289826,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (prime? n)\n  (if (even? n)\n      #f\n      (do ((d 3 (+ 2 d)))\n        ((or (> (* d d) n)\n             (= 0 (modulo n d)))\n         (or (> (* d d) n)\n             (not (= 0 (modulo n d))))))))\n                \n(define (flipnum n res)\n  (if (zero? n)\n      res\n      (flipnum (floor  (\/ n 10)) (+ (* 10 res) (modulo n 10)))))\n\n(define (backwards_prime from to)\n  (filter (lambda (x) (and (prime? x) (prime? (flipnum x 0)) (not (= x (flipnum x 0)))))\n          (range from (+ 1 to) 1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289827,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (prime? n)\n  (if (even? n)\n      #f\n      (do ((d 3 (+ 2 d)))\n        ((or (> (* d d) n)\n             (= 0 (modulo n d)))\n         (or (> (* d d) n)\n             (not (= 0 (modulo n d))))))))\n                \n\n(define (flipnum n res)\n  (if (zero? n)\n      res\n      (flipnum (floor  (\/ n 10)) (+ (* 10 res) (modulo n 10)))))\n\n(define (num-digits x)\n  (if (zero? x)\n      0\n      (+ 1 (num-digits (floor (\/ x 10))))))\n\n(define (backwards_prime from to)\n  (filter (lambda (x) (and (prime? x) (prime? (flipnum x 0)) (not (= x (flipnum x 0)))))\n          (range from (+ 1 to) 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289828,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n(define (prime? n)\n  (let loop ([d 2])\n    (cond\n      [(< n (* d d)) #t]\n      [(zero? (modulo n d)) #f]\n      [else (loop (add1 d))])))\n\n(define (palindrome? s)\n  (string=? (list->string\n        (reverse\n         (string->list (~a s))))\n       (~a s)))\n\n(define (reverse-num n)\n  (let f ([acc 0]\n          [n n])\n    (cond\n      [(= n 0) acc]\n      [else (f (+ (* acc 10) (modulo n 10)) (quotient n 10))])))\n          \n  \n\n(define (backwards_prime st we)\n  (filter (lambda (n)\n            (and (not (palindrome? n)) (prime? n) (prime? (reverse-num n))))\n          (range st (add1 we)))\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"},{"id":289829,"user_id":null,"body":"#lang racket\n(provide backwards_prime)\n\n;;the following procedures for determining\n;;prime numbers were taken from SICP\n;;http:\/\/www.sicpdistilled.com\/section\/1.2.6\/\n(define (evenly-divisible? a b)\n  (= (remainder b a) 0))\n\n(define (square a)\n  (* a a))\n\n(define (find-divisor n test-divisor)\n  (cond [(> (square test-divisor) n) n]\n\t[(evenly-divisible? test-divisor n) test-divisor]\n\t[else (find-divisor n (+ 1 test-divisor))]))\n\n(define (smallest-divisor a)\n  (find-divisor a 2))\n\n(define (prime? a)\n  (= a (smallest-divisor a)))\n\n\n\n(define (reverse-int a)\n  (define (reverse-int-recur in out)\n    (if (zero? in)\n\tout\n\t(reverse-int-recur (truncate (\/ in 10))\n\t\t\t   (+ (* 10 out) (modulo in 10)))))\n  (reverse-int-recur a 0))\t\n\n\n(define (backwards-read-prime? a)\n  (let ([b (reverse-int a)])\n    (and (not (= a b))\n\t (prime? b))))\n\n(define (prime-and-backwards-read-prime? a)\n  (and (prime? a) (backwards-read-prime? a)))\n\n(define (backwards_prime start end)\n  (filter prime-and-backwards-read-prime? (range start (+ 1 end))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:03:15"}],"5541f58a944b85ce6d00006a":[{"id":289830,"user_id":492,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (let loop ([a 0] [b 1])\n    (if (>= (* a b) prod)\n      (list a b (= (* a b) prod))\n      (loop b (+ a b)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289831,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n; an Output is a list:\n; (list fib(n) fib(n+1) Boolean)\n; where fib(n) & fib(n+1) are 2\n; consecutive Fibonacci numbers.\n\n; Number -> Output\n(define (product_fib prod)\n  (local ((define (helper n n+1)\n            (cond\n              [(= (* n n+1) prod) `(,n ,n+1 #true)]\n              [(> (* n n+1) prod) `(,n ,n+1 #false)]\n              [(< (* n n+1) prod) (helper n+1 (+ n n+1))])))\n    (helper 0 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289832,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (let loop ([a 0]\n             [b 1])\n    (cond ((= (* a b) prod) (list a b #t))\n          ((> (* a b) prod) (list a b #f))\n          (else             (loop b (+ a b))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289833,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (let loop ([p1 1] [p2 1])\n    (if (>= (* p1 p2) prod)\n      (list p1 p2 (= (* p1 p2) prod))\n      (loop p2 (+ p1 p2)))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289834,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (let loop ((cur '(0 1)))\n    (cond\n     ((equal? (apply * cur) prod)\n      (append cur (list #t)))\n     ((> (apply * cur) prod)\n      (append cur (list #f)))\n     (else \n      (loop (append \n             (cdr cur) \n             (list \n              (apply + cur))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289835,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (define (product_fib-recur x y)\n    (if (>= (* x y) prod)\n        (list x y (= (* x y) prod))\n        (product_fib-recur y (+ x y))))\n  (product_fib-recur 0 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289836,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (define (fib-prod-iter prod prior now)\n    (cond [(= prod (* prior now)) (list prior now true)]\n          [(< prod (* prior now)) (list prior now false)]\n          [else (fib-prod-iter prod now (+ now prior))]))\n  (fib-prod-iter prod 0 1)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289837,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib prod)\n  (let loop ([a 0]\n             [b 1])\n    (cond [(> (* a b) prod) (list a b #f)]\n          [(= (* a b) prod) (list a b #t)]\n          [else (loop b (+ a b))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289838,"user_id":53,"body":"#lang racket\n(provide product_fib)\n\n(define (aux a b n)\n  (cond [(= n (* a b)) (list a b #t)]\n        [(< n (* a b)) (list a b #f)]\n        [else (aux b (+ a b) n)]))\n\n(define (product_fib n)\n  (aux 0 1 n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289839,"user_id":null,"body":"#lang racket\n(provide product_fib)\n\n(define (product_fib product)\n  ;; Define recursive loop\n  (define (loop [F_n-1 0] [F_n 1])\n    (let* ([P (* F_n F_n-1)])\n      (cond [(= P product) (list F_n-1 F_n #t)]\n            [(> P product) (list F_n-1 F_n #f)]\n            [else          (loop F_n (+ F_n F_n-1))])))\n  ;; Initiate loop\n  (loop))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5544c7a5cb454edb3c000047":[{"id":289840,"user_id":null,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h b w)\n  (if (and (< 0.0 w h)\n           (< 0.0 b 1.0))\n      (+ 2 (bouncing_ball (* b h) b w))\n      -1))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289841,"user_id":527,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h bounce window)\n  (if (not (and (> h 0) (< 0 bounce 1) (< window h)))\n      -1\n      (- (* (exact-ceiling (log (\/ window h) bounce))\n            2)\n       1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289842,"user_id":492,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h bounce window)\n  (if (or (<= h 0) (>= window h) (<= bounce 0) (>= bounce 1))\n    -1\n    (let loop ([seen -1] [height h])\n      (if (> height window)\n        (loop (+ seen 2) (* height bounce))\n        seen))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289843,"user_id":null,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h bounce window)\n  (if (or (<= h window) (not (< 0 bounce 1))) \n  (- 1)\n  (+ 2 (bouncing_ball (* h bounce) bounce window))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289844,"user_id":53,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h b w)\n   (cond\n       [(<= h 0.0) -1]\n       [(<= b 0.0) -1]\n       [(<= w 0.0) -1]\n       [(>= b 1.0) -1]\n       [(>= w h) -1]\n       [else (+ 2 (bouncing_ball (* h b) b w))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289845,"user_id":null,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (iter h bounce window last-bounce-height bounces-count)\n  (if\n    (<= last-bounce-height window)\n    bounces-count\n    (iter h bounce window (* last-bounce-height bounce) (+ bounces-count 2))))\n\n(define (bouncing_ball h bounce window)\n  (if\n    (or\n      (<= h 0)\n      (<= bounce 0)\n      (>= bounce 1)\n      (>= window h))\n    -1\n    (iter h bounce window (* h bounce) 1)\n  ))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289846,"user_id":null,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h bounce window)\n  (define (go h bounce window)\n    (if (<= (* bounce h) window)\n        1\n        (+ 2 (go (* h bounce) bounce window))))\n  (if (and (> h 0) (> bounce 0) (< bounce 1) (< window h))\n      (go h bounce window)\n      -1)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289847,"user_id":null,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h bounce window)\n  (cond ((or (<= bounce 0) (>= bounce 1)) -1)\n        ((or (<= h 0) (<= window 0)) -1)\n        ((<= h window) -1)\n        (else (let* ([x (* h bounce)]\n                     [y (>= x window)])\n              (if y\n                  (+ 2 (bouncing_ball x bounce window))\n                  1 )))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289848,"user_id":null,"body":"#lang racket\n\n(define (valid h b w)\n  (and (> h 0) (< w h)\n       (and (> b 0) (< b 1)))\n  )\n\n(define (bouncing h b w)\n  (let ([hh (* h b)]\n        [r (if (> h w) 2 0)])\n    (if (<= hh w)\n        0\n        (+ r (bouncing hh b w))\n    )\n  )\n)\n\n(define (bouncing_ball h b w)\n  (if ((compose not valid) h b w)\n      -1\n      (+ 1 (bouncing h b w))\n  )\n)\n\n(provide bouncing_ball)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289849,"user_id":null,"body":"#lang racket\n(provide bouncing_ball)\n\n(define (bouncing_ball h bounce window)\n  (if (and (< 0 window h) (< 0 bounce 1))\n      (+ 2 (bouncing_ball (* h bounce) bounce window))\n      -1))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5545f109004975ea66000086":[{"id":289850,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (= 0 (+ (modulo n x) (modulo n y))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289851,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (zero? (+ (remainder n x) (remainder n y))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289852,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (and (integer? (\/ n x)) (integer? (\/ n y))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289853,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n (cond ((> (modulo n x) 0) #f)\n      ((> (modulo n y) 0) #f)\n      (else #t))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289854,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (= (+ (modulo n x) (modulo n y)) 0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289855,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (and (equal? (modulo n x) 0) (equal? (modulo n y) 0))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289856,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (if (and (= (modulo n x) 0)(= (modulo n y ) 0))\n      true\n      false))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289857,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n\n  (cond\n    [(and (= 0 (modulo n y)) (= 0 (modulo n x))) #t]\n    [else #f]\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289858,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n(define (is_divisible n x y)\n  (and (zero? (+ (modulo n x) (modulo n y)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289859,"user_id":null,"body":"#lang racket\n\n(provide is_divisible)\n\n( define (divisible? x y) ( zero? ( modulo x y ) ) )\n\n( define (is_divisible n x y) ( and ( divisible? n x ) ( divisible? n y ) ) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55466989aeecab5aac00003e":[{"id":289860,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (letrec ((helper\n            (lambda (l w)\n              (let ((dim1 (max l w)) (dim2 (min l w)))\n                (cond\n                  ((eq? 0 dim2) '())\n                  (#t (cons dim2 (helper (- dim1 dim2) dim2) ))\n                )\n              )\n            )))\n    (if (eq? lng wdth) '() (helper lng wdth)))\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289861,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect x y) (if (= x y) '() (to-list x y)))\n\n(define (to-list x y)\n  (cond\n    [(= x y) `(,y)]\n    [(< x y) (to-list y x)]\n    [else (cons y (to-list (- x y) y))]))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289862,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n\n\n(define (sq_in_rect long width)\n  (if (= long width) '() (sq_in_rect-impl long width)))\n(define (sq_in_rect-impl long width)\n  (let ([big (max long width)] [small (min long width)])\n    (if (= small 0) '()\n      (cons small (sq_in_rect-impl (- big small) small)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289863,"user_id":53,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (define (aux a b acc)\n    (if (or (<= a 0) (<= b 0))\n        acc\n        (let* ([c (if (> a b) b a)]\n               [a1 (if (> a b) (- a b) a)]\n               [b1 (if (> a b) b (- b a))])\n        (aux a1 b1 (append acc (list c))))))\n  (if (= lng wdth)\n    null\n    (aux lng wdth null)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289864,"user_id":null,"body":"#lang racket\n(provide (rename-out [squares-in-rectangle sq_in_rect]))\n\n(define (squares-in-rectangle w h)\n  (define (recurse w h)\n    (cond\n      [(= w h) (list w)]      \n      [(< w h) (recurse h w)]\n      [else\n       (cons h (recurse (- w h) h))]))\n       \n  (if (= w h) null (recurse w h)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289865,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (if (= lng wdth) null (reduce-rect lng wdth (list))))\n  \n(define (reduce-rect x y output)\n    (cond\n      [(or (= x 0) (= y 0)) (reverse output)]\n      [else (reduce-rect (min x y)\n                         (- (max x y) (min x y))\n                         (cons (min x y) output))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289866,"user_id":492,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (if (= lng wdth)\n      null\n      (reverse (let loop ([l lng] [w wdth] [s '()])\n        (cond\n          [(= l w) (cons l s)]\n          [(< l w) (loop w l s)]\n          [else (loop (- l w) w (cons w s))])))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289867,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (define (appender lng wdth)\n           (cond\n            [(< lng wdth) (append (list lng) (appender lng (- wdth lng)))]\n            [(< wdth lng) (append (list wdth) (appender (- lng wdth) wdth))]\n            [(equal? lng wdth) (append (list lng) '())]\n            [(equal? 0 wdth) '()]))\n  (cond\n   [(equal? lng wdth) null]\n   [else (appender lng wdth)]))\n          \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289868,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (letrec ((S (lambda (lng wdth)\n               (cond\n                 [(= lng 0) '()]\n                 [(> lng wdth) (S wdth lng)]\n                 [else (cons lng (S (- wdth lng) lng))]))))\n    (if (= lng wdth) '() (S lng wdth))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289869,"user_id":null,"body":"#lang racket\n(provide sq_in_rect)\n\n(define (sq_in_rect lng wdth)\n  (if (= lng wdth) null (squares-from lng wdth)))\n\n(define (squares-from lng wdth)\n  (cond ((= (* lng wdth) 0) '())\n        ((< lng wdth) (squares-from wdth lng))\n        ((= lng wdth) `(,wdth))\n        (else `(,wdth . ,(squares-from (- lng wdth) wdth)))))\n\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5547cc7dcad755e480000004":[{"id":289870,"user_id":null,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (define sum (* n (+ n 1) 1\/2))\n  (for*\/list ([x (in-range 1 (+ n 1))]\n              [y (in-value (\/ (- sum x) (+ 1 x)))]\n              #:when (and (<= y n) (integer? y)))\n    (cons x y)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289871,"user_id":53,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (define m (* n (add1 n) 1\/2))\n  (for*\/list ([x (in-range 1 (add1 n))]\n              [y (in-value (quotient (- m x) (add1 x)))]\n              #:when (and (<= y n) (= (* y x) (- m x y))))\n    (cons x y)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289872,"user_id":53,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (let ([m (quotient (* n (add1 n)) 2)])\n    (let loop([x 1][ans '()])\n      (if (> x n)\n          (reverse ans)\n          (let ([y (quotient (- m x) (add1 x))])\n            (if (and (<= y n) (= (* x y) (- m x y)))\n              (loop (add1 x) (cons (cons x y) ans))\n              (loop (add1 x) ans)))))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289873,"user_id":544,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (define sum-to-n (* 1\/2 n (add1 n)))\n  (for*\/list ([i (in-range 2 (add1 n))]\n              [j (in-value (\/ (- sum-to-n i)\n                              (add1 i)))]\n              #:when (and (j . < . n)\n                          (integer? j)))\n    (cons i j)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289874,"user_id":544,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (define sum-to-n (* 1\/2 n (add1 n)))\n  (for*\/list ([i (in-range 2 (add1 n))]\n              [sum-to-n (in-value (* 1\/2 n (add1 n)))]\n              [j (in-value (\/ (- sum-to-n i)\n                              (add1 i)))]\n              #:when (and (j . < . n)\n                          (integer? j)\n                          (= (* i j) (- sum-to-n i j))))\n    (cons i j)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289875,"user_id":null,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (define (rn-iter x)\n    (define (binary-search low high)\n      (cond ((> low high) #f)\n            (else (define guess (quotient (+ low high) 2))\n                  (define result (fn guess))\n                  (cond ((< result 0) (binary-search (add1 guess) high))\n                        ((> result 0) (binary-search low (sub1 guess)))\n                        (else guess)))))\n    (define my-sum (- sum x))\n    (define (fn z) (- (* x z) (- my-sum z)))\n    (define result (binary-search 1 n))\n    (and result (cons x result)))\n  (define rng (range 1 (add1 n)))\n  (define sum (apply + rng))\n  (filter-map rn-iter rng))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289876,"user_id":null,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (letrec ([sum (\/ (* n (+ n 1)) 2)]\n           [target (lambda (a b) (- sum a b))]\n           [full-solution (lambda (ls)\n                            (if (empty? ls)\n                                '()\n                                (cons (car ls) \n                                      (cons (cons (cdar ls) \n                                                  (caar ls)) (full-solution (cdr ls))))))]\n           [build-list (lambda (a b)\n                        (cond [(>= a b) '()]\n                               [(> (* a b) (target a b)) (build-list a (- b 1))]\n                               [(< (* a b) (target a b)) (build-list (+ a 1) b)]\n                               [else (cons (cons a b) (build-list (+ a 1) (- b 1)))]))])\n    (sort (full-solution (build-list 1 n)) < #:key car)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289877,"user_id":null,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (let ((sum (\/ (* n (+ n 1)) 2)))\n    (filter-map (lambda (a)\n                  (let ((b (\/ (- sum a) (+ a 1))))\n                    (and (<= b n) (integer? b) `(,a . ,b))))\n                (range 1 n))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289878,"user_id":168,"body":"#lang racket\n(provide remove_nb)\n\n(define (remove_nb n)\n  (define s (\/ (* n (add1 n)) 2))\n  (for\/fold ([pairs '()] #:result (reverse pairs))\n            ([a (range 1 (add1 n))])\n    (let* ([t (- s a)]\n           [b (if (zero? (remainder t (add1 a))) (\/ t (add1 a)) a)])\n      (if (and (<= b n) (not (= a b)))\n          (cons (cons a b) pairs)\n          pairs))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289879,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide remove_nb)\n\n\n;; Integer>0 -> (Listof (cons Integer>0 Integer>0))\n;; given a sequence of numbers from 1 to n, return all (a, b) number pairs which\n;; could be excluded from the sequence such that the sum of the numbers that\n;; remain is equal to the product of a and b.\n(define (remove_nb n)\n  (define seq (in-range 1 (add1 n)))\n  (define sum (* (\/ n 2) (+ 1 n)))\n  (filter cons?\n          (for\/list ([a seq])\n            (define b (\/ (- sum a) (+ 1 a)))\n            (when (and (integer? b) (< b n)) (cons a b)))))\n\n(module+ test\n  (check-equal? (remove_nb 26) '((15 . 21) (21 . 15)))\n  (check-equal? (remove_nb 100) '())\n  (check-equal? (remove_nb 101) '((55 . 91) (91 . 55)))\n  (check-equal? (remove_nb 102) '((70 . 73) (73 . 70)))\n  (check-equal? (remove_nb 110) '((70 . 85) (85 . 70))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"554a44516729e4d80b000012":[{"id":289880,"user_id":53,"body":"#lang racket\n(provide nb_months)\n\n(define (aux p0 p1 s r m t)\n  (if (<= p1 (+ p0 t))\n    (list m (exact-round (+ (- p0 p1) t)))\n    (let* ([pp0 (- p0 (* r (* p0 0.01)))]\n           [pp1 (- p1 (* r (* p1 0.01)))]\n           [tt (+ t s)]\n           [mm (add1 m)]\n           [rr (if (even? m) (+ r 0.5) r)])\n      (aux pp0 pp1 s rr mm tt))))\n\n(define (nb_months p0 p1 s r)\n  (aux (exact->inexact p0) (exact->inexact p1) s (exact->inexact r) 0 0.0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289881,"user_id":492,"body":"#lang racket\n(provide nb_months)\n\n(define (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month)\n  (define (with-loss amount percent)\n    (- amount (* amount (\/ percent 100))))\n  (if (>= start-price-old start-price-new)\n      (list 0 (- start-price-old start-price-new))\n      (let loop(              \n                [old (with-loss start-price-old percent-loss-per-month)]\n                [new (with-loss start-price-new percent-loss-per-month)]\n                [perc percent-loss-per-month]\n                [months 1])\n        (if (>= (+ old (* saving-per-month months)) new)\n            (list months (exact-round (- (+ old (* saving-per-month months)) new)))\n            (let (\n                  [new-perc (+ perc (* 0.5 (quotient (add1 months) 2)))])\n              (loop (with-loss old new-perc) (with-loss new new-perc) perc (add1 months)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289882,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n(define (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month)\n  (let\n    ([month 0] \n     [savings 0] \n     [cars-diff (- start-price-old start-price-new)])\n    \n    (nb_months-it month saving-per-month savings percent-loss-per-month cars-diff)))\n\n(define (nb_months-it month saving-per-month savings loss cars-diff)\n  (let \n    ([available (get-available cars-diff savings)]\n     [new-loss (calc-new-loss loss month)])\n    \n    (if (enough-to-buy? available)\n        (list month (exact-round available))\n        (nb_months-it (add1 month)\n                      saving-per-month\n                      (+ savings saving-per-month)\n                      new-loss\n                      (apply-loss new-loss cars-diff)))))\n\n(define (enough-to-buy? available)\n  (or (positive? available) (zero? available)))\n\n(define (get-available cars-diff savings)\n  (+ cars-diff savings))\n\n(define (calc-new-loss loss month)\n  (if (zero? (modulo month 2))\n      loss\n      (+ loss 0.5)))\n\n(define (apply-loss loss cars-diff)\n  (* (- 1 (\/ loss 100)) cars-diff))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289883,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n(define (nb_months start-price-old\n                   start-price-new\n                   saving-per-month\n                   percent-loss-per-month)\n  (define (reduction amount %)\n    (* (\/ (- 100 %)\n          100)\n       amount))\n  (let loop ([price-old start-price-old]\n             [price-new start-price-new]\n             [savings-so-far 0]\n             [months 0]\n             [decrease-% percent-loss-per-month])\n    (define total (+ savings-so-far price-old))\n    (define diff (- total price-new))\n    (define % (if (odd? months)\n                  (+ decrease-% 0.5)\n                  decrease-%))\n    (if (>= diff 0)\n        (list months (inexact->exact (round diff)))\n        (loop (reduction price-old %)\n              (reduction price-new %)\n              (+ savings-so-far saving-per-month)\n              (add1 months) %))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289884,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n(struct world [old-car-price\n               new-car-price\n               month-saving\n               money\n               month-loss\n               month-count] #:transparent)\n\n(define initial-world\n  (world 2000\n         8000\n         1000\n         0\n         1.5\n         0))\n\n(define (new-world oc nc sv ml)\n  (world oc nc sv 0 ml 0))\n\n(define (world-update w)\n  (let* ([new-month (+ 1 (world-month-count w))]\n        [m-loss (if (even? new-month) (+ 0.5 (world-month-loss w)) (world-month-loss w))])\n    (world\n      (decrease-by (world-old-car-price w) m-loss)\n      (decrease-by (world-new-car-price w) m-loss)\n      (world-month-saving w)\n      (+ (world-money w) (world-month-saving w))\n      m-loss\n      new-month)))\n\n(define (decrease-by n pc)\n  (- n (* (\/ pc 100) n)))\n\n(define (world-update-n-times n [iw initial-world])\n  (cond\n    [(<= n 0) iw]\n    [else\n     (world-update (world-update-n-times (- n 1) iw))]))\n\n(define (compute-balance w)\n  (- (+ (world-money w) (world-old-car-price w)) (world-new-car-price w)))\n\n(define (balance-after-n-turns n [iw initial-world])\n  (let ([w (world-update-n-times n iw)])\n    (- (+ (world-money w) (world-old-car-price w)) (world-new-car-price w))))\n\n(define (find-buying-month i oc nc sv ml)\n  ;oc old-car\n  ;nc new-car\n  ;sv savings\n  ; ml monthly loss\n  (let* ([w1 (world oc nc sv 0 ml 0)]\n        [balance (balance-after-n-turns i w1)])\n    (cond\n      [(>= balance 0) (list i (inexact->exact (round balance)))]\n      [else\n       (find-buying-month (+ 1 i) oc nc sv ml)])))\n\n(define (nb_months oc nc sv ml)\n  (find-buying-month 0 oc nc sv ml))\n\n(define (nb_months-debug oc nc sv ml [until 10])\n  (for\/list ([i until])\n    (let ([w (world-update-n-times i (new-world oc nc sv ml))])\n      (list w (compute-balance w)))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289885,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n\n(define (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month)\n  (define (nb-iter oldp newp saved perc month)\n    (let* ([balance (exact-round (- (+ saved oldp) newp))]\n           [new-perc (if (even? month) (+ perc 0.5) perc)]\n           [p (- 1.0 (\/ new-perc 100.0))])\n      (if (>= balance 0.0) (list (sub1 month) balance)\n          (nb-iter (* oldp p) \n                   (* newp p)\n                   (+ saved saving-per-month)\n                   new-perc\n                   (add1 month)))))\n  (nb-iter start-price-old start-price-new 0.0 percent-loss-per-month 1)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289886,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n;; Float Float Float Float -> List-of Integer\n;; Given old car price, new car price, savings per month, percent loss per month\n;; produce the number of months it will take to save up for the car, and how\n;; much money will be left\n(define (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month)\n  (next-month\n   start-price-old\n   start-price-new\n   saving-per-month\n   (\/ percent-loss-per-month 100) ; convert percent to float\n   0                              ; current amount of savings\n   0))                            ; current month\n\n;; Float Float Float Float Float Natural -> List-of Integer\n;; a recursive function that bumps all values by given amounts,\n;; tracks total savings and month number, then repeats until we've saved enough\n(define (next-month old-car-price new-car-price saving-per-month plpm savings month)\n  (cond\n    [(>= (+ savings old-car-price) new-car-price)  ; saved enough?\n     (list month\n           (inexact->exact (round (- (+ savings old-car-price) new-car-price))))] \n    \n    [else\n     (next-month\n      (- old-car-price (* old-car-price plpm))\n      (- new-car-price (* new-car-price plpm))\n      saving-per-month\n      (if (even? month)\n          (+ plpm .005)\n          plpm)\n      (+ savings saving-per-month)\n      (add1 month))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289887,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n(define (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month)\n  (let loop ([price-old start-price-old]\n             [price-new start-price-new]\n             [percent-loss (* (- 100 percent-loss-per-month) 1\/100)]\n             [loss-more-next-month #t]\n             [current 0]\n             [count 0])\n    (let ([available (- (+ price-old current) price-new)])\n      (if (>= available 0)\n          (list count (exact-round available))\n          (let ([lost-next-month (if loss-more-next-month 0.005 0)])\n            (loop (* price-old percent-loss)\n                  (* price-new percent-loss)\n                  (- percent-loss lost-next-month)\n                  (not loss-more-next-month)\n                  (+ current saving-per-month)\n                  (add1 count)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289888,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n(define (nb_months start-price-old start-price-new saving-per-month percent-loss-per-month)\n  (let loop ([month 0]\n             [savings 0]\n             [old start-price-old]\n             [new start-price-new] \n             [loss percent-loss-per-month])\n    (let ([have (+ savings old)])\n      (if (>= have new)\n        (list month (inexact->exact (round (- have new))))\n        (let* ([month-upd (+ month 1)]\n               [loss-upd (if (and (= 0 (remainder month-upd 2)))\n                           (+ loss 0.5) \n                           loss)]\n               [loss-ratio (\/ (- 100 loss-upd) 100)]\n               [old-upd (* old loss-ratio)]\n               [new-upd (* new loss-ratio)]\n               [savings-upd (+ savings saving-per-month)])\n          (loop month-upd savings-upd old-upd new-upd loss-upd))))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289889,"user_id":null,"body":"#lang racket\n(provide nb_months)\n\n(define (percent-subtract n p)\n  (- n (* n (\/ p 100))))\n\n(define (set-percent months p)\n  (cond [(zero? (remainder months 2)) (+ p 0.5)]\n        [else p]))\n\n(define (calc old-car-price new-car-price saving-per-month percent-loss months saved)\n  (cond [(>= (+ old-car-price saved) new-car-price) (list months (exact-round (- (+ old-car-price saved) new-car-price)))]\n        [else\n         (let* ([next-month (add1 months)]\n                [percent (set-percent next-month percent-loss)]\n                [old-car (percent-subtract old-car-price percent)]\n                [new-car (percent-subtract new-car-price percent)])\n           (calc old-car new-car saving-per-month percent next-month (+ saved saving-per-month)))\n         ]))\n\n(define (nb_months old-car-price new-car-price saving-per-month percent-loss-per-month)\n  (calc old-car-price new-car-price saving-per-month percent-loss-per-month 0 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"554f76dca89983cc400000bb":[{"id":289890,"user_id":168,"body":"#lang racket\n(provide sol_equa)\n             \n(define (sol_equa n)\n  (for\/fold ([acc '()] #:result (reverse acc))\n            ([k (in-naturals 1)])\n            #:break (> (sqr k) n)\n    (let-values ([(q r) (quotient\/remainder n k)])\n      (cond\n       [(positive? r) acc]\n       [(and (even? (+ q k)) (zero? (remainder (- q k) 4)))\n        (cons (list (\/ (+ q k) 2) (\/ (- q k) 4)) acc)]\n       [else acc])))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 19:33:26"},{"id":289891,"user_id":53,"body":"#lang racket\n(provide sol_equa)\n   \n(define (sol_equa n) (if (= 16 n) '((4 0)) (walk n)))\n    \n(define (walk n)\n  (filter (\u03bb (t) (not (empty? t)))\n    (for*\/list ([i (in-range 1 (sqrt n))])\n      (let* ([d (\/ n i)]\n             [x (\/ (+ d i) 2)]\n             [y (\/ (- d i) 4)])\n        (if (and (integer? d) (integer? x) (integer? y))\n            (list (floor x) (floor y))\n            null)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 19:33:29"},{"id":289892,"user_id":null,"body":"#lang racket\n(provide sol_equa)\n             \n(define (sol_equa n)\n  (for*\/list ([mult1 (range 1 (+ (integer-sqrt n) 1))]\n             #:when (= (remainder n mult1) 0)\n             [mult2 (list (\/ n mult1))]\n             [diff (list (- mult2 mult1))]\n             #:when (= (remainder diff 4) 0))\n    (let ([n (\/ (+ mult1 mult2) 2)]\n          [y (\/ diff 4)])\n      (list n y))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289893,"user_id":492,"body":"#lang racket\n(provide sol_equa)\n             \n(define (sol_equa n)\n  (remove* '(()) (for\/list ([x (range 1 (add1 (sqrt n)))]\n             #:when (zero? (remainder n x)))\n    (let* ([p x][q (quotient n x)] [r1 (remainder (+ p q) 2)] [r2 (remainder (- q p) 4)])\n      (if (and (zero? r1) (zero? r2))\n          (list (quotient (+ p q) 2) (quotient (- q p) 4))\n          '())))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289894,"user_id":null,"body":"#lang racket\n(provide sol_equa)\n             \n(define (sol_equa n)\n  (define (iter a)\n    (define b (\/ n a))\n    (cond [(> (* a a) n) '()]\n          [(or (not (integer? b))\n               (null? (f a b)))\n           (iter (+ a 1))]\n          [else (cons (f a b) (iter (+ a 1)))]))\n  (iter 1)\n)\n\n; (x-2*y)*(x+2*y) = n\n; a * b = n\n; x = (a + b) \/ 2\n; y = (b - a) \/ 4\n(define (f a b)\n  (let ([x (\/ (+ a b) 2)]\n        [y (\/ (- b a) 4)])\n    (if (and (integer? x)\n             (integer? y))\n        (list x y)\n        '()))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289895,"user_id":null,"body":"#lang racket\n(provide sol_equa)\n\n\n(define (pair->list p)\n  (list (car p) (cdr p)))\n             \n;; This function checks for a given pair if they are a candidate\n;; to be written in the form: x + 2y, x - 2y.\n;; \n;; Note that this is equivalent to checking whether the gap between\n;; the two numbers is divisible by 4.\n(define (check-factor-pair? div-pair)\n  (define diff (abs (- (car div-pair) (cdr div-pair))))\n  (= 0 (modulo diff 4)))\n\n;; This function gets the pair of x and y for a given d1 d2\n(define (get-dio-pair factor-pair)\n  (define d1 (car factor-pair))\n  (define d2 (cdr factor-pair))\n  (define diff (abs (- d1 d2)))\n  (define half-diff (quotient diff 2))\n  (define smaller-div (min d1 d2))\n  (define x (+ smaller-div half-diff))\n  (define y (quotient half-diff 2)) \n  (cons x y))\n\n;; returns all the factors of n as a list of pairs of divisors\n(define (factors n)\n  (define (go f acc)\n    (cond [(> f (integer-sqrt n)) (reverse acc)]\n          [(zero? (remainder n f))\n             (go (add1 f) (cons (cons f (quotient n f)) acc))]\n          [else (go (add1 f) acc)]))\n  (go 1 '()))\n;; this finds all positive integer solutions to the\n;;diophantine equation:\n;;   x^2 - 4y^2 = n\n;; Note that: (x^2 - 4 y^2) = (x - 2y) (x + 2y)\n(define (sol_equa n)\n  (define n-factors (factors n))\n  (define dio-pairs-candidates (filter check-factor-pair? n-factors))\n  (define dio-pairs (map get-dio-pair dio-pairs-candidates))\n  (map pair->list dio-pairs))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289896,"user_id":null,"body":"#lang racket\n\n(provide sol_equa)\n\n;; Reference: https:\/\/www.sangakoo.com\/en\/unit\/quadratic-diophantine-equations\n;; Article showing how to solve Diophantine Equations of the form x^2-y^2 = n.\n;; x^2-4y^2 = n\n;; x^2-(2y)^2 = n\n;; Let 2y = k   (1)\n;; x^2-k^2 = n\n\n(define (sol_equa n)\n  (define (sol_equa-loop ds n)\n    (if (empty? ds)\n        '()\n        (let* ([a (first ds)]\n               [b (\/ n a)])\n          (if (or (and (even? a) (even? b)) (and (odd? a) (odd? b)))\n              (let ([x (\/ (+ a b) 2)]\n                    [y (\/ (- b a) 4)])   ;; divide by 4 because k = 2y per (1) above.\n                (if (integer? y)\n                    (cons (list x y) (sol_equa-loop (rest ds) n))\n                    (sol_equa-loop (rest ds) n)))\n              (sol_equa-loop (rest ds) n)))))\n  (sol_equa-loop (divisors n) n))\n\n(define (divisors n)\n  (define (divisors-loop m n)\n    (if (> (* m m) n)\n        '()\n        (if (= 0 (remainder n m))\n            (cons m (divisors-loop (add1 m) n))\n            (divisors-loop (add1 m) n))))\n  (divisors-loop 1 n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289897,"user_id":242,"body":"#lang racket\n(provide sol_equa)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (merge l1 l2)\n  (define (merge-iter l1n l2n acc)\n    (cond\n      [(and (null? l1n) (null? l2n)) acc]\n      [(null? l1n) (merge-iter `() (cdr l2n) (cons (car l2n) acc))]\n      [(null? l2n) (merge-iter (cdr l1n) `() (cons (car l1n) acc))]\n      [else (merge-iter (cdr l1n) l2n (cons (car l1n) acc))]\n    )\n  )\n  (reverse (merge-iter l1 l2 `()))\n)\n\n(define (sol_equa n)\n  (define (get-next-divisor-iter nn start)\n    (cond\n      [(< nn start) 0]\n      [(< nn (* start start)) nn]\n      [(= 0 (remainder nn start)) start]\n      [else (get-next-divisor-iter nn (+ 1 start))]\n    )\n  )\n  (define (list-of-prime-divisors-iter nn curr acc)\n    (let\n      ((f (get-next-divisor-iter nn curr)))\n      (cond\n        [(= f 0) acc]\n        [else (list-of-prime-divisors-iter (quotient nn f) f (cons f acc))]\n      )\n    )\n  )\n  (define (partitions-of-prime-divisors-iter lft-group rgh-group pool)\n    (cond\n      [\n       (null? pool)\n       (let\n           (\n            (lft-acc (accumulate * 1 lft-group))\n            (rgh-acc (accumulate * 1 rgh-group))\n            )\n         (let\n             (\n              (y (\/ (- rgh-acc lft-acc) 4))\n              (x (\/ (+ rgh-acc lft-acc) 2))\n              )\n           (cond\n             [(and (integer? x) (integer? y) (>= x 0) (>= y 0)) (list (list x y))]\n             [else `()]\n             )\n           )\n         )\n       ]\n      [else (merge\n              (partitions-of-prime-divisors-iter (cons (car pool) lft-group) rgh-group (cdr pool))\n              (partitions-of-prime-divisors-iter lft-group (cons (car pool) rgh-group) (cdr pool))\n            )\n      ]\n    )\n  )\n  (define (removeduplicatessortedlst lst)\n    (define (removeduplicatessortedlstiter lst acc curr)\n      (cond\n        [(null? lst) acc]\n        [(= curr (car (car lst))) (removeduplicatessortedlstiter (cdr lst) acc curr)]\n        [else (removeduplicatessortedlstiter (cdr lst) (cons (list (car (car lst)) (cadr (car lst))) acc) (car (car lst)))]\n        )\n      )\n    (if (null? lst) `() (reverse (removeduplicatessortedlstiter lst `() (+ (car (car lst)) 1))))\n  )\n  (removeduplicatessortedlst (sort\n    (partitions-of-prime-divisors-iter `() `() (list-of-prime-divisors-iter n 2 `()))\n    (lambda (x y) (> (car x) (car y)) )\n  ))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5552101f47fc5178b1000050":[{"id":289898,"user_id":null,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (let ([s (for\/sum ([i (in-naturals p)]\n                     [digit (in-string (number->string n))])\n             (expt (string->number (string digit)) i))])\n    (if (zero? (modulo s n)) (\/ s n) -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289899,"user_id":492,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (define (digits n)\n    (let loop ((n n) (d '()))\n      (if (zero? n) d\n          (loop (quotient n 10)\n                (cons (modulo n 10) d)))))\n  (let* ([u (digits n)]\n         [lg (+ p (length u))]\n         [r (apply + (map (\u03bb(x i) (expt x i)) u (range p lg)))])\n    (if (zero? (modulo r n))\n        (quotient r n)\n        -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289900,"user_id":53,"body":"#lang racket\n(provide dig_pow)\n\n(define zip (lambda (xs ys) (map list xs ys)))\n\n(define (digits n . args)\n  (let ((b (if (null? args) 10 (car args))))\n    (let loop ((n n) (d '()))\n      (if (zero? n) d\n          (loop (quotient n b)\n                (cons (modulo n b) d))))))\n\n(define (dig_pow n p)\n  (let* ([xs (digits n)]\n         [ts (zip xs (range 0 (length xs)))]\n         [m  (foldl (\u03bb (ls acc) (+ acc (expt (car ls) (+ p (car (cdr ls)))))) 0 ts)])\n    (if (= 0 (modulo m n)) (quotient m n) -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289901,"user_id":null,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (let* ([digits (map (compose (curryr - 48) char->integer)\n                      (string->list (number->string n)))]\n         [sum-of-digits-in-power (for\/sum ([pow (in-naturals p)]\n                                           [digit digits])\n                                   (expt digit pow))])\n    (if (zero? (modulo sum-of-digits-in-power n))\n        (\/ sum-of-digits-in-power n)\n        -1)))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289902,"user_id":null,"body":"#lang racket\n(provide dig_pow)\n\n(define (int->list n)\n  (define (loop n)\n    (if (zero? n)\n        empty\n        (cons (remainder n 10) (loop (quotient n 10)))))\n  (reverse (loop n)))\n\n(define (power-of-digits n p)\n  (let* ([digits (int->list n)]\n         [powers (range p (+ p (length digits)))])\n    (foldl (lambda (digit p acc) (+ acc (expt digit p)))\n           0\n           digits\n           powers)))\n\n(define (dig_pow n p)\n  (let ([res (power-of-digits n p)])\n    (if (zero? (remainder res n))\n        (quotient res n)\n        -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289903,"user_id":null,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (if (eq? (remainder (sum-digits (int->list n) p) n) 0) (quotient (sum-digits (int->list n) p) n) -1 )\n  \n)\n\n(define sum-digits \n  (lambda (num p)\n    (cond\n      ((null? num) 0)\n      (#t (+ (expt (car num) p) (sum-digits (cdr num) (+ p 1))))\n    )\n  )\n)\n\n\n(define (int->list n) (if (zero? n) `()\n                          (append (int->list (quotient n 10)) (list (remainder n 10)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289904,"user_id":null,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (define (find-k n sum)\n    (let loop ((i 1))\n      (let ((prod (* i n)))\n        (cond ((> prod sum) -1)\n              ((equal? prod sum) i)\n              (else (loop (add1 i)))))))\n  (define (gen-sum n p)\n    (let loop ((rem (number->string n)) (e p) (acc 0))\n      (if (string=? \"\" rem)\n          acc\n          (loop (substring rem 1)\n                (add1 e)\n                (+ acc\n                   (expt (string->number (substring rem 0 1)) e))))))\n  (find-k n (gen-sum n p)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289905,"user_id":null,"body":"#lang racket\n\n\n(provide dig_pow)\n\n(define (dig_pow n p)\n  \n  (define (getdigits n list)\n    (let ([digits list])\n  (if (= n 0) digits\n      \n      \n      (getdigits (quotient n 10) (cons (remainder n 10) list)) \n\n\n      )\n    \n\n    ))\n  (define (createplist dlist n)\n    (if (null? dlist)\n        null\n      \n         (cons (cons(car dlist )n) (createplist (cdr dlist) (+ n 1))) ))\n\n  (define (expocalc n exp acc)\n    (if (= exp 1 )\n        (if (< acc n) n\n        acc)\n        (expocalc n (- exp 1)  (* acc n))\n\n\n\n        )\n    \n\n\n    )\n  \n        (define (calcp exponentlist newlist)\n          (if (null? exponentlist) newlist\n              (let ([exponent (cdr (car exponentlist))]\n                    [base (car (car exponentlist) )] \n                    )\n                \n             (calcp (cdr exponentlist)  (  cons (expocalc base exponent base );append very expensive but easy to put everything in right order this way\n\n                                             newlist))\n\n\n              ))\n          \n\n          )\n\n\n        \n     \n\n\n    \n  \n   (let  (\n          \n\n\n          [plist (createplist (getdigits n '()) p)])\n\n\n     (let ([ans (\/ (foldl + 0 (calcp plist '())) n)])\n       (if (integer? ans )\n           ans\n           -1\n\n           )\n       )\n   \n\n     \n\n    \n  \n  ))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289906,"user_id":544,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (define funny-sum\n    (for\/sum ([d (in-string (number->string n))]\n              [i (in-naturals p)])\n      (expt (string->number (string d)) i)))\n  (let ([k (\/ funny-sum n)])\n    (if (natural? k) k -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289907,"user_id":544,"body":"#lang racket\n(provide dig_pow)\n\n(define (dig_pow n p)\n  (define digit-list\n    (for\/list ([d (in-string (number->string n))])\n      (string->number (string d))))\n  (define funny-sum\n    (for\/sum ([d (in-list digit-list)]\n              [i (in-naturals p)])\n      (expt d i)))\n  (let ([k (\/ funny-sum n)])\n    (if (natural? k) k -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"555624b601231dc7a400017a":[{"id":289908,"user_id":50,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (if (< n 2) 1 \n      (add1 (modulo (sub1 (+ k (josephus_survivor (sub1 n) k))) n))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:49:55"},{"id":289909,"user_id":null,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (if (= n 1)\n      1\n      (+ (modulo (- (+ (josephus_survivor (- n 1) k) k) 1) n) 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:49:57"},{"id":289910,"user_id":53,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (let loop ([i 1] [res 1])\n      (if (> i n)\n        res\n        (loop (add1 i) (add1 (modulo (sub1 (+ res k)) i))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289911,"user_id":544,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (make-victim-list n)\n  (range 1 (+ 1 n)))\n\n(define (remove-nth lst n)\n  (cond [(n . > . (length lst)) (remove-nth lst (modulo n (length lst)))]\n        [(= n 0) (drop-right lst 1)]\n        [else (append (list-tail lst n) (take lst (- n 1)))]))\n\n(define (eliminate-survivors survivors n)\n  (cond [(= 1 (length survivors)) survivors]\n        [else\n         (eliminate-survivors\n          (remove-nth survivors n)\n          n)]))\n\n(define (josephus_survivor n k)\n  (car (eliminate-survivors (make-victim-list n) k)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289912,"user_id":168,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (if (< n 1) 1\n      (add1 (remainder (+ k -1 (josephus_survivor (sub1 n) k)) n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289913,"user_id":null,"body":"#lang racket\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (add1\n   (for\/fold ([i 0])\n             ([circle (range 1 (add1 n))])\n     (modulo (+ i k) circle))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289914,"user_id":null,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (if (= n 1)\n      1\n      (add1 (remainder (+ (josephus_survivor (sub1 n) k) (sub1 k)) n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289915,"user_id":null,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (+ 1 (let loop ([n n] [k k])\n         (if (= n 1) 0\n             (remainder (+ k (loop (- n 1) k)) n)))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289916,"user_id":null,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus-it r i n k)\n    (if (= i (+ 1 n))\n        (+ 1 r)\n        (josephus-it (modulo (+ r k) i) (+ 1 i) n k)))\n\n(define (josephus_survivor n k)\n  (josephus-it 0 1 n k))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289917,"user_id":null,"body":"#lang racket\n\n(provide josephus_survivor)\n\n(define (josephus_survivor n k)\n  (define (iter result counter)\n    (let ([new-result (modulo (+ result k) counter)])\n      (if (= counter n)\n          (+ 1 new-result)\n          (iter new-result (+ counter 1)))))\n  (iter 0 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5556282156230d0e5e000089":[{"id":289918,"user_id":527,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (string-replace dna \"T\" \"U\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289919,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  ; replace 't' with 'u'\n (string-replace dna \"T\" \"U\"))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289920,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (regexp-replace* #rx\"T\" dna \"U\"))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289921,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (define build-list (string->list dna))\n  (list->string\n   (map (lambda (letter) (if (eq? letter #\\T ) #\\U letter)) build-list)))\n \n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289922,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (list->string (map (lambda (acid) (if (char=? acid #\\T) #\\U acid)) (string->list dna))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289923,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (list->string (for\/list ([c dna])\n                  (if (eq? c #\\T)\n                      #\\U\n                      c))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289924,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (swap-thymine a) (if (char=? a #\\T) #\\U a))\n\n(define (dna_to_rna dna)\n   (list->string (reverse (for\/fold ([rna null])\n            ([a (string->list dna)])\n    (list* (swap-thymine a) rna)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289925,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (string-append* (map (lambda (character) (if (char=? character #\\T) \"U\" (string character))) (string->list dna))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289926,"user_id":null,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (dna_to_rna dna)\n  (list->string\n    (map (lambda (x) (if (char=? x #\\T) #\\U x)) \n         (string->list dna))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289927,"user_id":53,"body":"#lang racket\n\n(provide dna_to_rna)\n\n(define (string-replace input-string from-char to-char)\n  (list->string\n   (for\/list ((item (string->list input-string)))   \n     (if (equal? item from-char)\n         to-char\n         item))))\n\n(define (dna_to_rna dna)\n  (string-replace dna #\\T #\\U))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55685cd7ad70877c23000102":[{"id":289928,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (* (abs n) -1))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289929,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  ((if (positive? n) - +) n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289930,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (if \n    (positive? n) (- 0 n) n)\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289931,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (cond\n    [(positive? n) (- 0 n)]\n    [else n]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289932,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (if (< n 0)\n      n\n      (* n -1)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289933,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (if (positive? n) (* -1 n) n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289934,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (cond\n   ((< n 0) n)\n   ((= 0 n) 0)\n   ((> n 0) (* -1 n))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289935,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (cond\n   ((or (zero? n) (negative? n)) n)\n   (else (- n))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289936,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  ((if (> n 0) - +) n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289937,"user_id":null,"body":"#lang racket\n\n(provide make_negative)\n\n(define (make_negative n)\n  (if(< 0 n )\n     (- n)\n     n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"556deca17c58da83c00002db":[{"id":289938,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (define (tri n a b c)\n    (if (zero? n)\n      '()\n      (cons a (tri (sub1 n) b c (+ a b c)))))\n  (apply tri n sign))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289939,"user_id":564,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (if (<= n 3)\n    (take sign n)\n    (trib sign (- n 3))))\n\n(define (trib sign n)\n  (if (<= n 0)\n    sign\n    (let ([a (list-ref sign 0)]\n          [b (list-ref sign 1)]\n          [c (list-ref sign 2)])\n      (let ([d (+ a b c)])\n        (append (list a) (trib (list b c d) (- n 1)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289940,"user_id":645,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (if (< n 1)\n    '()\n    (let* ([a (list-ref sign 0)]\n           [b (list-ref sign 1)]\n           [c (list-ref sign 2)])\n      (cons a (tribonacci (list b c (+ a b c)) (- n 1))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289941,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (define (iter lst tri-tuple n)\n    (if (eqv? n 0)\n        lst\n        (iter(append lst(list(+ (car tri-tuple)(cadr tri-tuple)(caddr tri-tuple))))\n             (list(cadr tri-tuple)(caddr tri-tuple)(+ (car tri-tuple)(cadr tri-tuple)(caddr tri-tuple)))\n             (- n 1))))\n  (drop-right(iter sign sign n)3))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289942,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (define (addtri l) \n          (+ (car l) (car (cdr l)) (car (cdr (cdr l))))\n  )\n\n  (define (removelast l) \n    (cond ((null? (cdr l)) '() )\n          ((null? (cdr (cdr l)))\n                  (list (car l)))\n          (else (append (list (car l)) (removelast (cdr l))))\n    )\n  )\n  \n  (cond ((< n 1) (removelast (removelast (removelast sign))) )\n        ((< n 2) (removelast (removelast sign)) )\n        ((< n 3) (removelast sign) )\n        ((< n 4) sign )\n        (else (append (list (car sign)) (tribonacci (cdr (append sign (list (addtri sign)))) (- n 1))))\n  )\n  \n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289943,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n\n(define (tribonacci sign n)\n  (cond\n    [(= n 1) (cons (car sign) '())]\n    [(= n 2) (reverse (cdr (reverse sign)))]\n    [(= n 0) '()]    \n    [(tribo sign (- n 3) sign) ]\n  ))\n\n(define (tribo sign n rec)\n  (let ((sum-last (cons (apply + sign) '())))\n    \n    (if (<= n 0)\n      rec\n      (tribo (append  (cdr sign) sum-last)\n             (- n 1)\n             (append  rec sum-last )))\n  ))\n\n\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289944,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (take\n   (for\/fold ([history sign])\n             ([i (in-range (- n 3))])\n     (append history (list (apply + (safe-take-right history 3)))))\n   n))\n\n(define (safe-take-right lst n)\n  (cond\n    [(< (length lst) n) lst]\n    [else (take-right lst n)]))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289945,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define memoize\n  (lambda (f)\n    (let ((memo (make-hash)))\n      (lambda (x)\n        (if (not (hash-has-key? memo x))\n            (hash-set! memo x (f x)) #t)\n        (hash-ref memo x)))))\n\n(define (tribonacci sign n)\n  (letrec [(trib \n            (memoize\n              (lambda (n)\n                (cond\n                 ((eq? n 0) (car sign))\n                 ((eq? n 1) (cadr sign))\n                 ((eq? n 2) (caddr sign))\n                 (#t (+ (+ (trib (- n 1)) (trib (- n 2))) (trib (- n 3))))))))\n            (triblist\n             (memoize\n               (lambda (n)\n                 (cond\n                  ((eq? n 0) (list (car sign )))\n                  (#t (cons (trib n) (triblist (- n 1))))))))\n           ]\n    (if (< n 1) '()\n      (reverse (triblist (- n 1))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289946,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (t-iterate n a b c)\n  (if (zero? n) '() (cons a (t-iterate (sub1 n) b c (+ a b c)))))\n\n(define (tribonacci sign n)\n  (match-let ([(list a b c) sign]) (t-iterate n a b c)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289947,"user_id":null,"body":"#lang racket\n\n(provide tribonacci)\n\n(define (tribonacci sign n)\n  (if \n   (< n 3)  ;If n < 3\n   (take sign n) ;Return a list of the first n elements of the signature\n   (let loop ((rem sign) (acc sign)) ; rem hold the numbers we'll sum, acc holds the sequence\n     (if (equal? (length acc) n)      ; Are we done?\n         acc                          ;If so, return the sequence\n         (let ((next (apply + rem)))  ;If not calculate the nex number \n           (loop (append (cdr rem) (list next)) ; shift rem, adding the next number\n                 (append acc (list next)))) ;add the next number to the sequence\n         ))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"559536379512a64472000053":[{"id":289948,"user_id":544,"body":"#lang racket\n(provide play_pass)\n\n(define (play_pass phrase shift)\n  (let* ([step1 (map (curry shift-letters shift) (string->list phrase))]\n         [step2 (map nines-compliment step1)]\n         [step3 (map staggered-case (range 0 (string-length phrase)) step2)]\n         [step4 (reverse step3)]\n         [final (apply string step4)])\n    final))\n\n(define (char-shift char shift base)\n  (integer->char (+ (char->integer base)\n                    (modulo (+ shift (- (char->integer char) \n                                        (char->integer base))) 26))))\n\n(define (shift-letters shift char)\n  (cond \n    [(char-upper-case? char) (char-shift char shift #\\A)]\n    [(char-lower-case? char) (char-shift char shift #\\a)]\n    [else char]))\n\n(define (nines-compliment char)\n  (cond \n    [(char-numeric? char) (string-ref (number->string (- 9 (string->number (string char)))) 0)]\n    [else char]))\n\n(define (staggered-case index char)\n  (cond\n    [(even? index) (char-upcase char)]\n    [else (char-downcase char)]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289949,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define (play_pass s n)\n\n  (define (transform-letter char)\n    (let* ([base (if (char-lower-case? char) #\\a #\\A)]\n           [index-in-alphabet (- (char->integer char) (char->integer base))]\n           [new-index (modulo (+ index-in-alphabet n) 26)]\n           [new-char (integer->char (+ new-index (char->integer base)))])\n      new-char))\n\n  (define (transform-digit char)\n    (let* ([index-in-number (- (char->integer char) (char->integer #\\0))]\n           [new-index (- 9 index-in-number)]\n           [new-char (integer->char (+ new-index (char->integer #\\0)))])\n      new-char))\n  \n  (let* ([lst (string->list s)]\n         [step123 (map (lambda (c)\n                         (cond [(char-alphabetic? c) (transform-letter c)]\n                               [(char-numeric? c) (transform-digit c)]\n                               [else c]))\n                       lst)]\n         [step4 (for\/list ([i (length step123)]\n                           [c step123])\n                  (cond [(not (char-alphabetic? c)) c]\n                        [(odd? i) (char-downcase c)]\n                        [(even? i) (char-upcase c)]))]\n         [step5 (reverse step4)])\n    (list->string step5)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289950,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define (string-reverse s)\n  (list->string (reverse (string->list s))))\n\n(define (handle-char c n i)\n  (define char-plus-n (+ n (char->integer c)))\n  (define next-char (integer->char (if (> char-plus-n 90) (+ 64 (modulo char-plus-n 90)) char-plus-n)))\n  (if (even? i) (char-upcase next-char) (char-downcase next-char)))\n\n(define (handle-integer c)\n  (integer->char (+ (char->integer #\\0) (- (char->integer #\\9) (char->integer c)))))\n\n(define (play_pass s n)\n  (define normalized-n (modulo n 26))\n  (define n-prime (string-length s))\n  (string-reverse (build-string n-prime (lambda (i)\n                          (define c (string-ref s i))\n                          (cond [(char-alphabetic? c) (handle-char c normalized-n i)]\n                                [(char-numeric? c) (handle-integer c)]\n                                [else c])))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289951,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define *LETTERS* \n  (string->list \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n\n(define (play_pass s n)\n  (list->string \n   (pass-5 \n    (pass-4\n     (pass-1+2+3 (string->list s) n)))))\n\n(define (pass-1+2+3 chars n)\n  (for\/list ([char (in-list chars)])\n    (cond\n      [(char-alphabetic? char)\n       (list-ref *LETTERS*\n                 (remainder (+ (index-of *LETTERS* char) n)\n                            (length *LETTERS*)))]\n      [(char-numeric? char)\n       (integer->char \n        (+ 48 (- 9 (- (char->integer char) 48))))]\n      [else char])))\n\n(define (pass-4 chars)\n  (for\/list ([char (in-list chars)]\n             [idx (in-naturals)])\n    (cond\n      [(not (char-alphabetic? char)) char]\n      [(even? idx) (char-upcase char)]\n      [else (char-downcase char)])))\n\n(define pass-5 reverse)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289952,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define (shift ch n)\n  (define shift-val (if (char-lower-case? ch) 97 65))\n  (integer->char (+ shift-val (modulo (+ (- (char->integer ch) shift-val) n) 26))))\n\n(define (change ch n upcase?)\n  (cond\n   [(char-numeric? ch)\n    (string-ref (number->string (- 9 (string->number (string ch)))) 0)]\n   [(char-alphabetic? ch) \n    (define new-char (shift ch n))\n    (if upcase? (if (char-upper-case? new-char)\n                    (char-downcase new-char)\n                    (char-upcase new-char))\n        new-char)]\n   [else ch]))\n\n(define (pass char-lst n upcase?)\n  (if (empty? char-lst)\n      '()\n      (append\n       (pass (cdr char-lst) n (not upcase?))\n       (list (change (car char-lst) n upcase?)))))\n\n(define (play_pass s n)\n  (list->string (pass (string->list s) n #f)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289953,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define (upper-or-lower c i)\n  (if (even? i) (char-upcase c) (char-downcase c)))\n\n(define (rot-n n c)\n  (integer->char (+ 65(modulo (+ n (- (char->integer c) 65)) 26))))\n\n(define (nine-compliment n)\n  (integer->char (+ 48 (- 9 (- (char->integer n) 48)))))\n\n(define (play_pass s n)\n  (let ([modify-char\n         (lambda (c i)\n           (cond\n            [(char-alphabetic? c) (upper-or-lower (rot-n n c) i)]\n            [(char-numeric? c) (nine-compliment c)]\n            [else c]))])\n  (list->string (reverse (map modify-char (string->list s) (range 0 (string-length s)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289954,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n\n;; Constants\n(define upper-first (- (char->integer #\\A) 1)) ; position zero\n(define upper-last (char->integer #\\Z))\n(define alphabet-length (- upper-last upper-first))\n \n;; Char Natural \u2192 List\n;; shift the given letter right by a given number\n;; (letters at the end of the alphabet wrap around)\n;; assume all characters are upper case\n(define (alpha-encode c n)\n  (local [(define next-char (+ (char->integer c) (modulo n alphabet-length)))]\n   (integer->char\n    (if (> next-char upper-last)\n        (+ upper-first (- next-char upper-last))\n        next-char))))\n         \n\n;; String Natural \u2192 String\n;; processes the given string according the given rules and returns\n;; the modified string\n(define (play_pass s n)\n  (list->string\n   (reverse\n    (for\/list ([i (in-string s)]\n               [j (in-naturals)])\n      (cond\n        [(char-alphabetic? i)\n         (if (odd? j)\n             (char-downcase (alpha-encode i n))\n             (char-upcase (alpha-encode i n)))]\n\n        [(char-numeric? i)\n         (string-ref (number->string (- 9 (string->number (string i)))) 0)]  ; nines complement\n\n        [else i])))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289955,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(require rackunit)\n\n;; Char Int -> Char\n;; Rotates alphabetic character c forward n times, wrapping around to beginning.\n(define (rotate-char c n)\n  (let* ((uppercase? (char-upper-case? c))\n\t (codepoint (char->integer (char-downcase c)))\n\t (converted (((codepoint . - . 97) . + . n) . modulo . 26))\n\t (result (integer->char (converted . + . 97))))\n    (if uppercase? (char-upcase result) result)))\n\n(check-equal? (rotate-char (car (string->list \"C\")) 3) #\\F)\n(check-equal? (rotate-char (car (string->list \"c\")) 3) #\\f)\n(check-equal? (rotate-char (car (string->list \"A\")) 3) #\\D)\n(check-equal? (rotate-char (car (string->list \"a\")) 3) #\\d)\n(check-equal? (rotate-char (car (string->list \"Z\")) 3) #\\C)\n(check-equal? (rotate-char (car (string->list \"z\")) 3) #\\c)\n\n;; String Int -> String\n;; Rotates alphabetic characters in string n forwards, wrapping around to beginning.\n(define (shift-string string n)\n  (let* ((char-list (string->list string))\n\t (result (map (lambda (c) (if (char-alphabetic? c) (rotate-char c n) c)) char-list))\n\t (result (list->string result)))\n    result))\n\n(check-equal? (shift-string \"Chris\" 3) \"Fkulv\")\n(check-equal? (shift-string \"wxyz\" 10) \"ghij\")\n(check-equal? (shift-string \"BORN IN 2015!\" 1) \"CPSO JO 2015!\")\n(check-equal? (shift-string \"CANNOT\" 40) \"QOBBCH\")\n\n;; Int Int -> Int\n;; The complement of x with respect to y (i.e. what number, when added to x, yields y?)\n(define (complement x y)\n  (y . - . x))\n\n(check-equal? (complement 9 9) 0)\n(check-equal? (complement 8 9) 1)\n(check-equal? (complement 7 9) 2)\n(check-equal? (complement 21 100) 79)\n\n;; Char [Int -> Int] -> Char\n;; Replaces a digit character with a new digit character via transformation f.\n(define (replace-digit char f)\n  (let* ((codepoint (char->integer char))\n\t (int (codepoint . modulo . 48))\n\t (transformed (f int))\n\t (result (integer->char (transformed . + . 48))))\n    result))\n\n;; String [Int -> Int] -> String\n;; Replaces digit characters in the string according to the transformation f.\n(define (replace-digits string f)\n  (let* ((char-list (string->list string))\n\t (result (map (lambda (c) (if (char-numeric? c) (replace-digit c f) c)) char-list)))\n\t (list->string result)))\n\n(check-equal? (replace-digits \"hello\" (lambda (c) (complement c 9))) \"hello\")\n(check-equal? (replace-digits \"1hello9\" (lambda (c) (complement c 9))) \"8hello0\")\n\n;; String -> String\n;; Reverses the string.\n(define (string-reverse string)\n  (list->string (reverse (string->list string))))\n\n(check-equal? (string-reverse \"\") \"\")\n(check-equal? (string-reverse \"a\") \"a\")\n(check-equal? (string-reverse \"abcde\") \"edcba\")\n\n;; String -> String\n;; Transforms string \"foobar\" into \"FoObAr\"\n(define (alternating-upcase string)\n  (define (inner charlist index)\n    (match charlist\n      ['() '()]\n      [(cons c rest) (cons\n\t\t      (if (even? index) (char-upcase c) (char-downcase c))\n\t\t      (inner rest (add1 index)))]))\n  (list->string (inner (string->list string) 0)))\n\n(check-equal? (alternating-upcase \"\") \"\")\n(check-equal? (alternating-upcase \"a\") \"A\")\n(check-equal? (alternating-upcase \"B\") \"B\")\n(check-equal? (alternating-upcase \"aB\") \"Ab\")\n(check-equal? (alternating-upcase \"AB\") \"Ab\")\n(check-equal? (alternating-upcase \"!\") \"!\")\n(check-equal? (alternating-upcase \"ccc\") \"CcC\")\n\n;; Int String -> String\n;; Munge string into desirable password.\n(define (play_pass s shift)\n  (string-reverse\n   (alternating-upcase\n    (replace-digits (shift-string s shift)\n\t\t    (lambda (i) (complement i 9))))))\n\n(check-equal? (play_pass \"BORN IN 2015!\" 1) \"!4897 Oj oSpC\")","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289956,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define a (char->integer #\\A))\n(define zero (char->integer #\\0))\n\n(define (helper s n res)\n  (cond\n   [(empty? s) res]\n   [(char-alphabetic? (first s))\n    (define rotated\n      (integer->char\n       (+ a (modulo (+ (- (char->integer (char-upcase (first s)))\n                          a)\n                       n)\n                    26))))\n    (helper (rest s) n\n            (cons (if (odd? (length res))\n                      (char-downcase rotated)\n                      rotated)\n                  res))]\n   [(char-numeric? (first s))\n    (define subtracted\n      (integer->char\n       (+ zero\n          (- (+ zero 9)\n             (char->integer (first s))))))\n    (helper (rest s) n\n            (cons subtracted res))]\n   [else\n    (helper (rest s) n\n            (cons (first s) res))]))\n\n(define (play_pass s n)\n  (list->string (helper (string->list s) n '())))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289957,"user_id":null,"body":"#lang racket\n(provide play_pass)\n\n(define (play_pass s n)\n  (define (transform-char c)\n    (cond ((char-alphabetic? c) (shift-char c n 65 26))\n          ((char-numeric? c) (shift-char c -9 48 10))\n          (else c)))\n  (let ((chars (map transform-char (string->list s))))\n    (list->string (reverse (for\/list ((c chars)\n                                      (index (in-naturals)))\n                                     (if (even? index) c (char-downcase c)))))))\n\n(define (shift-char c n offset base)\n  (let* ((code (char->integer c))\n         (num (- code offset))\n         (num (abs (+ num n)))\n         (num (remainder num base))\n         (code (+ num offset))\n         (c (integer->char code)))\n    c))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"559a28007caad2ac4e000083":[{"id":289958,"user_id":492,"body":"#lang racket\n(provide perimeter)\n\n(define (perimeter n)\n  (define (fib n)\n  (let loop ((cnt 0) (a 0) (b 1))\n    (if (= n cnt)\n        b\n        (loop (+ cnt 1) b (+ a b)))))\n  (* 4 (- (fib (+ n 2)) 1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289959,"user_id":50,"body":"#lang racket\n(provide perimeter)\n\n(define (fib n a b)\n  (if (zero? n) a (fib (- n 1) b (+ a b)))\n  )\n(define (perimeter n)\n  (* 4 (- (fib (+ n 2) 1 1) 1))\n  )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289960,"user_id":53,"body":"#lang racket\n(provide perimeter)\n\n(define (helper n a b m) \n  (if (< n 0)\n      m\n      (helper (sub1 n) b (+ a b) (+ m (* a 4)))))\n\n(define (perimeter n) \n  (helper n 1 1 0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289961,"user_id":null,"body":"#lang racket\n(provide perimeter)\n(require rackunit)\n\n(define sum (curry foldl + 0))\n\n(check-equal? (sum '()) 0)\n(check-equal? (sum '(1 2 3 4 5)) 15)\n\n(define (fib n)\n  (define (helper x y i)\n    (if (i . >= . n)\n        (+ x y)\n        (helper y (+ x y) (add1 i))))\n  (if (n . < . 2) n (helper 0 1 2)))\n\n(check-equal? (fib 0) 0)\n(check-equal? (fib 1) 1)\n(check-equal? (fib 2) 1)\n(check-equal? (fib 3) 2)\n(check-equal? (fib 5) 5)\n(check-equal? (fib 8) 21)\n\n(define (perimeter n)\n  (4 . * . (sum (map fib (range (2 . + . n))))))\n\n(check-equal? (perimeter 5) 80)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289962,"user_id":null,"body":"#lang racket\n(provide perimeter)\n\n;list of fibonacci numbers\n(define (fib-list n)\n  (define (fib m lst)\n    (if (> m n)\n        lst\n        (fib (add1 m) (append lst (list (foldl + 0 (take-right lst 2)))))))\n  (fib 3 '(1 1)))\n\n;perimiter of fibonacci rectangle\n(define (perimeter n)\n  (* 4 (foldl + 0 (fib-list (add1 n)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289963,"user_id":null,"body":"#lang racket\n(provide perimeter)\n\n(define (perimeter n)\n  (local\n    [(define (f n a b s)\n       (cond [(= n 0) s]\n             [else (f (sub1 n) b (+ a b) (+ s b))]))]\n    (* 4 (f n 1 1 1))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289964,"user_id":null,"body":"#lang racket\n(provide perimeter)\n\n(define (sum-fib-numbers n)\n  (if (= n 1)\n      1\n      (let loop ((n (- n 1)) (sum 1) (a 1) (b 1))\n        (if (= n 0) sum (loop (- n 1) (+ sum a) (+ a b) a)))))\n        \n(define (perimeter n) (* 4 (sum-fib-numbers (+ n 1))))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289965,"user_id":null,"body":"#lang racket\n(provide perimeter)\n\n(define (perimeter n)\n  (let res ([y (add1 n)] [xs '(1 0)])\n    (if (> (length xs) y)\n        (* 4 (apply + xs))\n        (res y (cons (+ (car xs) (cadr xs)) xs)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289966,"user_id":null,"body":"#lang racket\n(provide perimeter)\n\n(define (perimeter n)\n  (* 4 (apply\n        +\n        (let res ([y (add1 n)] [xs '(1 0)])\n          (if (> (length xs) y)\n              xs\n              (res y (cons (+ (car xs) (cadr xs)) xs)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289967,"user_id":null,"body":"#lang racket\n(provide perimeter)\n\n(define (perimeter n)\n  (let iter ([a 0] [b 1] [n (+ n 1)] [r 0])\n    (if (zero? n)\n        (* r 4)\n        (iter b (+ a b) (- n 1) (+ r b)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"559b8e46fa060b2c6a0000bf":[{"id":289968,"user_id":492,"body":"#lang racket\n(provide diagonal)\n\n(define (diagonal n p)\n  (define (choose n p)\n    (let ([p (min p (- n p))])\n      (cond \n        ((negative? p) 0)\n        (else\n         (letrec ((aux\n                   (lambda (value i)\n                     (cond ((zero? i) value)\n                            (else (aux (* value (\/ (- n i -1) i)) (sub1 i)))))))\n           (aux 1 p))))))\n  (choose (add1 n) (add1 p)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289969,"user_id":53,"body":"#lang racket\n(provide diagonal)\n\n(define (diagonal n p)\n  (define (aux m k i r)\n    (cond\n       [(= i (add1 k)) r]\n       [else (aux m k (add1 i) (* r (\/ (add1 (- m i)) i)))]\n     )\n   )\n  (aux (add1 n) (add1 p) 1 1)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289970,"user_id":null,"body":"#lang racket\n(provide diagonal)\n\n(define (diagonal n p)\n  (apply + (diagonal-numbers n p)))\n\n(define (diagonal-numbers n p)\n  (cond\n    [(zero? p) (make-list (add1 n) 1)]\n    [else\n     (for\/fold ([last 1] [acc '(1)]\n                #:result (reverse acc))\n               ([num (in-list (cdr (diagonal-numbers n (sub1 p))))]\n                [_ (in-range 0 (- n p))])\n       (define next (+ last num))\n       (values next (cons next acc)))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289971,"user_id":544,"body":"#lang racket\n(provide diagonal)\n\n; variation of the \"Easy Line\" kata, uses the same binomial equation\n(define (binomial n k)\n  (for\/product \n      ([i (in-range 1 (add1 k))])\n    (\/ (- n i -1) i)))\n\n(define (diagonal row diag)\n  (for\/sum\n      ([i (in-range diag (add1 row))])\n    (binomial i diag)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289972,"user_id":null,"body":"#lang racket\n(provide diagonal)\n\n(define (binomial n k)\n  (if [or (= n k) (= 0 k)] 1\n    (let ([k (min k (- n k))])\n      (inexact->exact (for\/product ([i (in-range 1 (+ 1 k))])\n                    (\/ (- (+ n 1) i) i))))))\n(define (diagonal n p)\n  (binomial (+ 1 n) (+ 1 p))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289973,"user_id":null,"body":"#lang racket\n\n(provide diagonal)\n\n(define (diagonal n p)\n  (for\/sum ([i (add1 n)]) (binomial i p)))\n\n(define (binomial n k)\n  (\/ (for\/product ([n (range (add1 (- n k)) (add1 n))]) n) (factorial k)))\n\n(define (factorial n)\n  (if (zero? n)\n      1\n      (for\/product ([i (range 1 (add1 n))]) i)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289974,"user_id":242,"body":"#lang racket\n(provide diagonal)\n\n(define (diagonal n p)\n  (define (diag-iter i prod acc)\n    (cond\n      [(= i (+ n 1)) acc]\n      [else (diag-iter (+ i 1) (quotient (* prod (+ i 1)) (+ i 1 (- 0 p))) (+ acc prod))]\n    )\n  )\n  (cond\n    [(= n 0) (+ p 1)]\n    [else (diag-iter p 1 0)]\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289975,"user_id":527,"body":"#lang racket\n(provide diagonal)\n\n(define (diagonal n p)\n  (for\/product ([i (in-range 1 (+ p 2))]) (\/ (+ (- n p) i) i)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289976,"user_id":527,"body":"#lang racket\n(provide diagonal)\n\n(define (diagonal n p)\n  (for\/product ([i (in-range (add1 (- n p)) (+ n 2))]\n                [j (in-range 1              (+ p 2))])\n    (\/ i j)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"559ce00b70041bc7b600013d":[{"id":289977,"user_id":492,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (\/ (* n (+ n 1) (+ n 2)) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289978,"user_id":null,"body":"#lang racket\n(provide finance)\n\n;; Get the list of starts\n(define (start-list n)\n  (range 0 (* 2 (add1 n)) 2))\n\n;; Get the list of ends\n(define (end-list n)\n  (range n (add1 (* 2 n))))\n\n;; Arithemtic sum\n(define (arithmetic-summation n)\n  (\/ (* n (add1 n)) 2))\n\n;; Finance\n(define (finance n)\n  (let* ([starts (start-list n)]\n         [ends (end-list n)]\n         [start-sums (map arithmetic-summation (map sub1 starts))]\n         [end-sums (map arithmetic-summation ends)])\n    (apply + (map - end-sums start-sums))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289979,"user_id":544,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (* 1\/2 n\n     (+ 1 n)\n     (+ 2 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289980,"user_id":null,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (* n (+ n 1) (+ n 2) 1\/2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289981,"user_id":null,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (+ (* 1\/2 n n n)\n     (* 3\/2 n n)\n     n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289982,"user_id":null,"body":"#lang racket\n(provide finance)\n\n\n(define (finance n)\n  (sequence-fold + 0\n    (sequence-map \n        (lambda(i) \n            [let* ([lower (* 2 i)]\n                   [upper (+ n i)]\n                   [lengt (add1 (- upper  lower))])\n              ((curryr \/ 2) (* lengt (+ lower upper)))])\n         (in-inclusive-range 0 n))))\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289983,"user_id":null,"body":"#lang racket\n(provide finance)\n\n;; The hint said to avoid nested loops, instead I avoided loops completely:\n(define\/contract (finance n)\n  (-> (>=\/c 0) any)\n  (define-values (inthalf odd) (quotient\/remainder n 2))\n  (define diag   (add1 inthalf))\n  (define diag-n (* diag n))\n  (+ (* (+ inthalf odd) diag-n 2)\n     diag-n))\n\n;; Why \/ how does this work?\n;; tl;dr because it can be reduced to a math formula\n\n;; The problem description creates a highly regular set of numbers\n;; for example n=2:\n;;     4\n;;   2 3\n;; 0 1 2\n\n;; we split up these numbers in different groups:\n;;     _\n;;   2 _    we call this the \"diagonal\"\n;; _ _ 2\n\n;;     4\n;;   _ 3    we call this the \"2 pyramids\" (because for higher n these form pyramids)\n;; 0 1 _\n\n;;          10\n;;         8 9\n;;       6 7 8\n;;     4 5 6 7\n;;   2 3 4 5 6\n;; 0 1 2 3 4 5\n\n;; We observe that:\n;; when we reflect the element of one pyramid, along the diagonal, onto the element in the other pyramid;\n;; we get a pair of numbers that adds up to 2n\n;; 0+10 1+9 2+8 3+7 4+6 2+8 3+7 ...\n;; because we know that they always add up to 2n, we only need to know how many elements one pyramid has.\n;; We can then simply calculate pyramid-element-count * 2n to get the sum of the numbers in the two pyramids.\n\n;; How do we get the pyramid-element-count?\n;; lets take a look at the diagonal first\n\n;; The length of the diagonal is:\n;; (define-values (inthalf odd) (quotient\/remainder n 2))\n;; (define diag (add1 inthalf))\n;; so the length increases by 1 every 2nd increment of n\n\n;; after a bunch of staring at different examples for n\n;; trying to come up with working formulas for the pyramid-element-count\n;; I finally found the formula:\n;; (define pyramid-elements (* (+ inthalf odd) diag))\n\n;; now we can calculate the sum for both pyramids:\n;; (define pyramids-sum (* pyramid-elements n 2))\n\n;; the verbose version of the final function is:\n;; (define\/contract (finance n)\n;;   (-> (>=\/c 0) any)\n;;   (define-values (inthalf odd) (quotient\/remainder n 2))\n;;   (define diag (add1 inthalf))\n;;   (define diag-sum (* n diag))\n;;   (define pyramid-elements (* (+ inthalf odd) diag))\n;;   (define pyramids-sum (* pyramid-elements n 2))\n;;   (+ pyramids-sum\n;;      diag-sum))\n\n;; after noticing that n*diag is a shared term the function was simplified\n;; and made less verbose into the version at the top\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289984,"user_id":53,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (\/ (* (* (+ n 2) (+ n 1)) n) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289985,"user_id":null,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (for\/sum ([i (in-range 0 (+ n 1) 1)])\n            (\/ (* (+ (* 2 i) i n) (- n i -1)) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289986,"user_id":null,"body":"#lang racket\n(provide finance)\n\n(define (finance n)\n  (let bucle ([indice 0]\n              [lista-sumas '()])\n    (if (> indice n)\n        (foldl + 0 lista-sumas)\n        (let* ([minimo (* 2 indice)] ; valor minimo en cada iteracion\n               [maximo (+ n indice)] ; valor maximo en cada iteracion\n               [suma (\/ (* maximo (+ maximo 1)) 2)]  ; suma desde 0 hasta (n + indice)\n               [resta (\/ (* minimo (- minimo 1)) 2)] ; resta desde 0 hasta (2 * indice)\n               [resultado (- suma resta)]) ; suma desde (2 * indice) hasta (n + indice)\n          (bucle (+ indice 1) (cons resultado lista-sumas))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"559e3224324a2b6e66000046":[{"id":289987,"user_id":53,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n) (quotient (* n (add1 n) (add1 (* 2 n))) 6))\n\n(define (sumax n) (quotient (* n (add1 n) (sub1 (* 4 n))) 6))\n\n(define (sumsum n) (* n n (add1 n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289988,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin2 n counter answer)\n  (if (= counter (+ n 1)) answer\n    (sumin2 n (+ counter 1) (+ answer \n      (\/ (+ (* 2 n counter) (* -1 (* counter counter)) counter) 2))))\n)\n\n(define (sumin n)\n  (sumin2 n 1 0)\n)\n\n(define (sumax2 n counter answer)\n  (if (= counter (+ n 1)) answer\n    (sumax2 n (+ counter 1) (+ answer\n      (\/ (+ (* counter counter) (* n n) (- n counter)) 2))))\n)\n\n(define (sumax n)\n  (sumax2 n 1 0)\n)\n\n(define (sumsum n)\n  (+ (sumin n) (sumax n))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289989,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (getmin n 1)\n)\n(define (getmin n currentNum)\n  (if (= n 0)\n      0\n      (+(*(+ n (- n 1) ) currentNum) (getmin (- n 1) (+ currentNum 1)))\n      )\n  )\n\n\n(define (sumax n)\n  (getmax n n)\n)\n\n(define (getmax n currentNum)\n  (if (= currentNum 0)\n      0\n      (+(*(+ n (- n 1) ) currentNum) (getmax (- n 1) (- currentNum 1)))\n      )\n  )\n  \n(define (sumsum n)\n  (+ (sumin n) (sumax n))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289990,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (\/ (* (+ n 1) n (+ (* 2 n) 1)) 6)\n)\n\n(define (sumax n)\n  (\/ (* (+ n 1) n (- (* 4 n) 1)) 6)\n)\n\n(define (sumsum n)\n  (* n n (+ n 1))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289991,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (\/ (* n (+ n 1) (+ (* 2 n) 1)) 6))\n\n(define (sumax n)\n  (\/ (* n (+ n 1) (- (* 4 n) 1)) 6))\n\n(define (sumsum n)\n  (* (expt n 2) (+ n 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289992,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (for\/sum ([i (in-range 1 (add1 n))]) (* i i)))\n\n(define (sumax n)\n  (- (sumsum n) (sumin n)))\n\n(define (sumsum n) (* n n (add1 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289993,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (\/ (* n\n        (+ n 1)\n        (+ (* 2 n) 1))\n     6)\n)\n\n(define (sumax n)\n  (- (* n n n)\n     (sumin (- n 1)))\n)\n\n(define (sumsum n)\n  (+ (sumin n)\n     (sumax n))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289994,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (quotient (* n (add1 n) (+ n n 1)) 6)\n)\n\n(define (sumax n)\n  (quotient (* n (add1 n) (sub1 (* 4 n))) 6)\n)\n\n(define (sumsum n)\n  (* n n (add1 n))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289995,"user_id":null,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (cond [(= 1 n) 1]\n        [else (+ (sqr n) (sumin (sub1 n)))])\n)\n\n(define (sumax n)\n  (- (* n n n)\n     (sumin (sub1 n)))\n)\n\n(define (sumsum n)\n  (cond [(= 1 n) 2]\n        [else (+ (- (* 3 n n) n)\n                 (sumsum (sub1 n)))])\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289996,"user_id":168,"body":"#lang racket\n(provide sumin sumax sumsum)\n\n(define (sumin n)\n  (quotient (* n (+ (* 2 n n) (* 3 n) 1)) 6))\n\n(define (sumax n)\n  (quotient (* n (+ (* 4 n n) (* 3 n) -1)) 6))\n\n(define (sumsum n)\n  (* n n (+ n 1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55a29405bc7d2efaff00007c":[{"id":289997,"user_id":492,"body":"#lang racket\n(provide going)\n\n(define (going n)\n  (let loop ([i n] [iter 1.0] [res 1.0])\n    (if (= i 1)\n      (\/ (floor (* res (expt 10 6))) (expt 10 6))\n           (let ([it (* iter (\/ 1 i))])\n             (loop (sub1 i) it (+ res it))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289998,"user_id":null,"body":"#lang racket\n(provide going)\n\n(define (going n)\n  (for\/fold ([res 0] [fac 1] #:result (\/ (truncate (* 1e6 res)) 1e6))\n    ([cur (in-range n 0 -1)])\n    #:break (> 1e-8 fac)\n    (values (+ res fac) (\/ fac cur))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":289999,"user_id":53,"body":"#lang racket\n(provide going)\n\n(define (going n)\n  (define (aux i iter res)\n    (if (= i 1)\n        (\/ (truncate (* res 1000000)) 1000000)\n        (let ([it (* iter (\/ 1 i))])\n          (aux (sub1 i) it (+ res it)))))\n  (aux n 1.0 1.0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290000,"user_id":null,"body":"#lang racket\n(require racket\/flonum)\n(provide going)\n\n(define (! n)\n  (apply * (range 1 (add1 n))))\n\n(define (seq1 n)\n  (\/ 1 (! n)))\n\n(define (truncate+ n decimal-places)\n  (define x (expt 10 decimal-places))\n  (\/ (truncate (* n x)) x))\n\n(define (seq2 n)\n  (do ([i 2 (add1 i)]\n       [factorial 1 (* factorial i)]\n       [sum 0 (+ sum factorial)])\n      ((> i (add1 n))\n       sum)))\n\n(define (going n)\n  (truncate+\n   (real->double-flonum (* (seq1 n) (seq2 n)))\n   6))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290001,"user_id":168,"body":"#lang racket\n(provide going)\n\n(define (going n)\n   (define (trunc x) (\/ (floor (* x 1e6)) 1e6))\n   (for\/fold ([s 0.0] [p 1.0] #:result (trunc s))\n             ([i (range n 0 -1)])\n      (values (+ s (\/ p)) (* p i)))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290002,"user_id":null,"body":"#lang racket\n(provide going)\n\n(define (going n)\n  (let loop ([i 2] [f 1] [s 0]) ; this is more reasonable\n    (if (> i n)\n        (\/ (floor (* (\/ (+ s f) f) 1e6)) 1e6)\n        (loop (+ i 1) (* f i) (+ s f)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290003,"user_id":null,"body":"#lang racket\n(provide going)\n\n(define (going n)\n  (let loop ([i 1] [f 1] [s -1])\n    (if (> i n)\n        (\/ (truncate (* (\/ (+ s f) f) 1e6)) 1e6)\n        (loop (+ i 1) (* f i) (+ s f)))))\n\n\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290004,"user_id":null,"body":"#lang racket\n(provide going)\n\n(define (factorial x)\n  (foldl * 1 (range 1 (add1 x))))\n\n(define (component-1 x)\n  (\/ 1 (factorial x)))\n\n(define (factorial-sum x)\n  (define (recur i factorial sum)\n    (if (> i x)\n\tsum\n\t(recur (add1 i) (* factorial i) (+ sum (* factorial i)))))\n  (recur 1 1 0))\n\n(define (component-2 x)\n  (factorial-sum x))\n\n(define (ugly-truncate x)\n  (exact->inexact (\/ (floor (* x 1000000)) 1000000)))\n\n(define (going x)\n  (ugly-truncate (* (component-1 x) (component-2 x))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290005,"user_id":null,"body":"#lang racket\n(provide going)\n\n(define (factorial-and-its-sums n)\n  (let loop ([m 1] [fac 1] [sum 1])\n    (if (= m n)\n        (values fac sum)\n        (let* ([next-m (add1 m)]\n               [next-fac (* fac next-m)]\n               [next-sum (+ sum next-fac)])\n          (loop next-m next-fac next-sum)))))\n\n(define (going n)\n  (define-values (n! sum-i!) (factorial-and-its-sums n))\n  (define ans (\/ sum-i! n!))\n  (\/ (floor (* ans 1000000)) 1000000.0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290006,"user_id":null,"body":"#lang racket\n(provide going)\n\n(define (going n)\n  (let loop ([sum 1] [cur (\/ 1.0 n)] [div (sub1 n)])\n    (if (<= div 1)\n        (\/ (truncate (* (+ sum cur) 1e6)) 1e6)\n        (loop (+ sum cur) (\/ cur div) (sub1 div)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55a2d7ebe362935a210000b2":[{"id":290007,"user_id":null,"body":"#lang racket\n(provide find_smallest_int)\n(require srfi\/1)\n(define (find_smallest_int lst)\n  (fold min (car lst) (cdr lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290008,"user_id":53,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (foldl (\u03bb (x acc) (if (< x acc) x acc)) (first lst) (rest lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290009,"user_id":527,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (apply min lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290010,"user_id":527,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define find_smallest_int ((curry apply) min))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290011,"user_id":null,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (foldl (lambda (x y) (if (< x y) x y)) (first lst) (rest lst))\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290012,"user_id":null,"body":"#lang racket\n\n(require racket\/match)\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (match lst\n    [(list) (error \"Received empty list in find_smallest_int\")]\n    [(cons hd tl) (foldl min hd tl)]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290013,"user_id":null,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (argmin identity lst))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290014,"user_id":null,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (foldl (lambda (x y) (or (and (< x y) x) y)) +inf.0 lst))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290015,"user_id":null,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n    (define (iter list smallest) \n        (cond \n          ((null? list) smallest)\n          ((< (car list) smallest) (iter (cdr list) (car list)) )\n          (else (iter (cdr list) smallest))))\n    (iter lst (car lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290016,"user_id":null,"body":"#lang racket\n\n(provide find_smallest_int)\n\n(define (find_smallest_int lst)\n  (car (sort lst <=)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55aa075506463dac6600010d":[{"id":290017,"user_id":527,"body":"#lang racket\n(provide list_squared)\n\n(define (list_squared m n)\n  (for*\/list ([i (in-range m (+ n 1))]\n              [s (in-value (+ (for*\/sum ([j (in-range 1 (sqrt i))]\n                                         #:when (zero? (remainder i j))\n                                         [x (list j (quotient i j))])\n                                (* x x))\n                              (if (integer? (sqrt i)) i 0)))]\n              #:when (integer? (sqrt s)))\n    (list i s)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290018,"user_id":168,"body":"#lang racket\n(provide list_squared)\n\n(define (divisors n)\n  (for\/fold ([r '()])\n            ([d (in-range 1 (add1 (sqrt n)))])\n    (if (zero? (remainder n d))\n        (if (= (* d d) n) \n            (cons d r)\n            (cons d (cons (\/ n d) r)))\n        r)))\n\n(define (list_squared m n)\n  (for*\/list ([x (in-range m (add1 n))]\n              [s (in-value (apply + (map sqr (divisors x))))]\n              #:when (integer? (sqrt s)))\n    (list x s)))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290019,"user_id":null,"body":"#lang racket\n(provide list_squared)\n\n(define (list_squared m n)\n  (local ((define k (add1 (- n m))))\n    (foldr help '() (build-list k (lambda (x) (+ x m))))))\n\n(define (help s b)\n  (local ((define (divisors* n p m)\n            (cond\n              [(>= p m) (if (= (sqr p) n)\n                            (list p) '())]\n              [else (if (zero? (remainder n p))\n                        (cons p (cons (\/ n p) (divisors* n (add1 p) m)))\n                        (divisors* n (add1 p) m))]))\n          (define n (foldr + 0 (map sqr\n                                    (if (= s 1) (list 1)\n                                        (if (= s 2) (list 1 2)\n                                            (cons 1 (cons s (divisors* s 2 (ceiling (sqrt s)))))))))))\n    (if (integer? (sqrt n)) (cons (list s n) b) b)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290020,"user_id":null,"body":"#lang racket\n(provide list_squared)\n\n(define (list_squared m n)\n  (define (get-sum-divisors-squares x)\n    (list x (foldl (lambda (elm acc)\n                     (if (integer? (\/ x elm))\n                         (if (= elm (\/ x elm))\n                             (+ acc (expt elm 2))\n                             (+ acc (expt elm 2) (expt (\/ x elm) 2)))\n                         acc))\n                   0\n                   (range 1 (add1 (integer-sqrt x))))))\n  \n  (filter (lambda (x)\n            (integer? (sqrt (last x))))\n          (map (lambda (x)\n                 (get-sum-divisors-squares x))\n               (range m (add1 n)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290021,"user_id":null,"body":"#lang racket\n(provide list_squared)\n\n(define (divisors n)\n  (let ([sqrt-n (sqrt n)])\n  (define (inner x result)\n    (cond [(> x sqrt-n) result]\n          [(= 0 (modulo n x))\n           (inner (+ x 1) (append\n                          (if (= (\/ n x) x) (list x) (list (\/ n x) x)) result))]\n          [else (inner (+ x 1) result)]))\n  (inner 2 (list 1 n))))\n\n(define (sum-s n)\n  (let ([power2-sum (apply + (map (lambda (x) (* x x)) (divisors n)))])\n    (if (integer? (sqrt power2-sum))\n        (list n power2-sum) #f)))\n\n(define (reacreation-one-list start end)\n  (for*\/fold\n      ([result (if (= start 1) (list (list 1 1)) (list))])\n      ([i (in-range start end)])\n    (let ([is-sum-s (sum-s i)])\n      (if is-sum-s (cons is-sum-s result) result))))\n\n(define (list_squared m n)\n  (sort (reacreation-one-list m n) (lambda (x y) (< (car x) (car y)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290022,"user_id":53,"body":"#lang racket\n(provide list_squared)\n\n(define (divisors n)\n  (let loop ([acc null] [k 1])\n    (cond [(> (* k k) n) (sort acc <)]\n          [else\n           (define-values (q r) (quotient\/remainder n k))\n           (cond [(zero? r)\n                  (define new-acc (if (= q k) (cons k acc) (cons q (cons k acc))))\n                  (loop new-acc (add1 k))]\n                 [else (loop acc (add1 k))])])))\n\n(define (list_squared m n)\n  (for*\/list ([x (in-range m (add1 n))]\n              [s (in-value (apply + (map sqr (divisors x))))]\n              #:when (integer? (sqrt s)))\n    (list x s)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290023,"user_id":null,"body":"#lang racket\n(provide list_squared)\n\n(define cheap-memoizer (make-hash))\n(define (list_squared m n)\n  (let* ((divisors\n          (\u03bb (x)\n            (or (hash-ref cheap-memoizer x #f)\n                (let ((f (filter (\u03bb (d) (zero? (modulo x d))) (range 1 (add1 x)))))\n                  (hash-set! cheap-memoizer x f)\n                  f))))\n         (sum-of-squared-divisors (\u03bb (y) (foldl + 0 (map (\u03bb (x) (expt x 2)) (divisors y)))))\n         (square? (\u03bb (s) (exact? (sqrt s))))\n         (working-set (map (\u03bb(x)\n                             (let ((sosd (sum-of-squared-divisors x)))\n                               (list x sosd (square? sosd))))\n                               (range m (add1 n)))))\n    (map (\u03bb(y) (drop-right y 1)) (filter (\u03bb (x) (caddr x)) working-set))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290024,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide list_squared)\n\n\n;; Integer>0 -> (Listof Integer)\n;; return divisors of n, including itself\n(define (divisors n)\n  (flatten\n   (for\/list ([d (in-range 1 (add1 (sqrt n)))]\n              #:when (= 0 (remainder n d)))\n     (if (= (* d d) n)\n         d\n         (cons d (\/ n d))))))\n\n(module+ test\n  (check-equal? (divisors 100) '(1 100 2 50 4 25 5 20 10)))\n\n\n;; Integer -> Boolean\n;; return #t if n is a perfect square, #f otherwise\n(define (perfect-square? n)\n  (define root (floor (sqrt n)))\n  (= (* root root) n))\n\n(module+ test\n  (check-equal? (perfect-square? 4) #t)\n  (check-equal? (perfect-square? 45345) #f))\n\n  \n;; Integer Integer -> (Listof (Listof Integer Integer))\n;; given two integers m, n (1 <= m <= n), find all integers between m and n\n;; whose sum of squared divisors is itself a square and return those integers\n;; along the sums.\n(define (list_squared m n)\n  (filter list?\n          (for*\/list ([i (in-range m (add1 n))])\n            (define ssd (foldl + 0 (map sqr (divisors i))))\n            (when (perfect-square? ssd) `(,i ,ssd)))))\n\n(module+ test\n  (check-equal? (list_squared 359 1331) '((728 722500)))\n  (check-equal? (list_squared 237 5585) '((246 84100) (287 84100) (728 722500) (1434 2856100) (1673 2856100) (1880 4884100) (4264 24304900)))\n  (check-equal? (list_squared 502 3958) '((728 722500) (1434 2856100) (1673 2856100) (1880 4884100)))\n  (check-equal? (list_squared 410 1858) '((728 722500) (1434 2856100) (1673 2856100)))\n  (check-equal? (list_squared 486 3885) '((728 722500) (1434 2856100) (1673 2856100) (1880 4884100))))\n  \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290025,"user_id":null,"body":"#lang racket\n(provide list_squared)\n\n(define (divisors n)\n  (let loop ([acc null] [k 1])\n    (cond [(> (* k k) n) (sort acc <)]\n          [else\n           (define-values (q r) (quotient\/remainder n k))\n           (cond [(zero? r)\n                  (define new-acc (if (= q k) (cons k acc) (cons q (cons k acc))))\n                  (loop new-acc (add1 k))]\n                 [else (loop acc (add1 k))])])))\n\n(define (sum-square-divisors n) (apply + (map sqr (divisors n))))\n\n(define (square? n) (= n (sqr (integer-sqrt n))))\n\n(define (list_squared m n)\n  (let loop ([k m] [acc null])\n    (cond [(> k n) (reverse acc)]\n          [else\n           (define ssd (sum-square-divisors k))\n           (if (square? ssd)\n               (loop (add1 k) (cons (list k ssd) acc))\n               (loop (add1 k) acc))])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290026,"user_id":242,"body":"#lang racket\n(provide list_squared)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (enumerate start end)\n  (define (enumerate-iter start end acc)\n    (cond\n      [(= start end) (cons start acc)]\n      [else (enumerate-iter (+ 1 start) end (cons start acc))]\n    )\n  )\n  (cond\n    [(< end start) `()]\n    [else (reverse (enumerate-iter start end `()))]\n  )\n)\n\n(define (merge l1 l2)\n  (define (merge-iter l1n l2n acc)\n    (cond\n      [(and (null? l1n) (null? l2n)) acc]\n      [(null? l1n) (merge-iter `() (cdr l2n) (cons (car l2n) acc))]\n      [(null? l2n) (merge-iter (cdr l1n) `() (cons (car l1n) acc))]\n      [else (merge-iter (cdr l1n) l2n (cons (car l1n) acc))]\n    )\n  )\n  (reverse (merge-iter l1 l2 `()))\n)\n\n(define (removeduplicatessortedlst lst)\n  (define (removeduplicatessortedlstiter lst acc curr)\n    (cond\n      [(null? lst) acc]\n      [(= curr (car lst)) (removeduplicatessortedlstiter (cdr lst) acc curr)]\n      [else (removeduplicatessortedlstiter (cdr lst) (cons (car lst) acc) (car lst))]\n    )\n  )\n  (reverse (removeduplicatessortedlstiter lst `() (- (car lst) 1)))\n)\n\n(define (get-divisors n)\n  (define (get-next-divisor-iter nn start)\n    (cond\n      [(< nn start) 0]\n      [(< nn (* start start)) nn]\n      [(= 0 (remainder nn start)) start]\n      [else (get-next-divisor-iter nn (+ 1 start))]\n    )\n  )\n  (define (list-of-prime-divisors-iter nn curr acc)\n    (let\n      ((f (get-next-divisor-iter nn curr)))\n      (cond\n        [(= f 0) acc]\n        [else (list-of-prime-divisors-iter (quotient nn f) f (cons f acc))]\n      )\n    )\n  )\n  (define (sum-of-divisors-iter nn lst mult)\n    (cond\n      [(null? lst) (list mult)]\n      [(pair? lst) (merge (sum-of-divisors-iter nn (cdr lst) mult) (sum-of-divisors-iter nn (cdr lst) (* mult (car lst))))]\n      [(list? lst) (merge mult (* mult (car lst)))]\n      [(number? lst) (merge mult (* mult lst))]\n    )\n  )\n  (removeduplicatessortedlst (sort (sum-of-divisors-iter n (list-of-prime-divisors-iter n 2 `()) 1) <))\n)\n\n(define (list_squared m n)\n  (accumulate merge `() (map (lambda (x) (let ((f (get-divisors x))) (if (integer? (sqrt (accumulate + 0 (map sqr f)))) (list (list x (accumulate + 0 (map sqr f)))) `() ))) (enumerate m n)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55ab4f980f2d576c070000f4":[{"id":290027,"user_id":492,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (let ([m (* n n)])\n    (if (zero? (remainder m 2))\n      (list (\/ m 2))      \n      (list m 2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290028,"user_id":53,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (if (= 0 (modulo n 2))\n    (list (quotient (* n n) 2))\n    (list (* n n) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290029,"user_id":null,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (if (odd? n)\n      `(,(* n n) 2)\n      `(,(\/ (* n n) 2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290030,"user_id":544,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (if (even? n) \n      (list (\/ (expt n 2) 2))\n      (list (expt n 2) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290031,"user_id":null,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (define (weird-rational n)\n    (if (integer? n)\n        (list n)\n        (list (numerator n) (denominator n))))\n  (weird-rational\n   (+\n    (for\/sum ([d (in-range 1 (+ n 1))])\n      (\/ (+ d 1) 2))\n    (- (\/ n 2))\n    (for\/sum ([d (in-range (+ n 2) (+ (* 2 n) 1))])\n      (\/ (+ (- d) (* 2 n) 1) 2)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290032,"user_id":null,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (if (= (modulo n 2) 0)\n      (list (arithmetic-shift (* n n) (- 1)))\n      (list (* n n) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290033,"user_id":null,"body":"#lang racket\n(provide game)\n\n;; sum(k=1, n) {sum(i=1,n) {i\/(i+k)}} = (n^2)\/2\n(define (game n)\n  (if (= (modulo n 2) 0)\n    (list (\/ (* n n) 2))\n    (list (* n n) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290034,"user_id":null,"body":"#lang racket\n\n(provide game)\n\n(define (game n)\n  (if (even? n)\n      (list (* n (\/ n 2)))\n      (list (expt n 2) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290035,"user_id":168,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (let ([k (sqr n)])\n    (if (even? k) `(,(\/ k 2)) `(,k 2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290036,"user_id":null,"body":"#lang racket\n(provide game)\n\n(define (game n)\n  (let ([s (\/ (sqr n) 2)])\n        (let ([b (denominator s)]\n              [a (numerator s)])\n          (cond [(= b 2) (list a b)]\n                [else (list a)]))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55acfc59c3c23d230f00006d":[{"id":290037,"user_id":527,"body":"#lang racket\n\n(provide get-ascii)\n\n(define get-ascii char->integer)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290038,"user_id":null,"body":"#lang racket\n\n\n(provide get-ascii)\n\n(define (get-ascii char)\n  (char->integer char))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55ad04714f0b468e8200001c":[{"id":290039,"user_id":527,"body":"#lang racket\n\n(provide get_char)\n\n(define get_char integer->char)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290040,"user_id":null,"body":"#lang racket\n\n(provide get_char)\n\n;; Integer -> Char\n;; return the corresponding ASCII char for the given number \n(define (get_char z)\n  (integer->char z))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290041,"user_id":null,"body":"#lang racket\n\n(provide get_char)\n\n(define (get_char ascii-code)\n  (integer->char ascii-code))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290042,"user_id":null,"body":"#lang racket\n\n(provide get_char)\n\n(define (get_char z)\n  (integer->char z))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55b3425df71c1201a800009c":[{"id":290043,"user_id":492,"body":"#lang racket\n(provide stat_assoc)\n\n(define (stat_assoc strg)\n  (define (time->second s)\n    (let ([ls (map string->number (string-split s \"|\"))])\n      (+ (* 3600 (first ls)) (* 60 (second ls)) (third ls))))  \n\n  (define (fmt n)\n    (~a n #:align 'right #:width 2 #:pad-string \"0\"))\n  \n  (define (second->time m)\n    (let* ([n (exact-floor m)]\n           [h (quotient n 3600)]\n           [re (remainder n 3600)]\n           [mn (quotient re 60)]\n           [s (remainder re 60)])\n      (string-append (fmt h)\"|\"(fmt mn)\"|\"(fmt s))))\n\n  (define (median ls)\n    (define sorted (list->vector ls))\n    (define count (vector-length sorted))\n    (\/ (+ (vector-ref sorted (floor (\/ (sub1 count) 2)))\n          (vector-ref sorted (floor (\/ count 2))))\n       2.0))\n  \n  (if (zero? (string-length strg))\n      \"\"\n      (let* ([r (sort (map time->second (map string-trim (string-split strg #px\",\"))) <)]\n             [mean (\/ (apply + r) (length r))]\n             [md (median r)]\n             [rg (- (last r) (first r))])\n        (string-append \"Range: \" (second->time rg) \" Average: \" (second->time mean) \" Median: \" (second->time md)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290044,"user_id":null,"body":"#lang racket\n(provide stat_assoc)\n\n(define (stat_assoc strg)\n  (define l\n    (map\n      (\u03bb (x)\n         (apply + (map *\n           '(3600 60 1)\n           (map string->number (string-split x \"|\")))))\n      (string-split strg #rx\", ?\")))\n  (define-values (q r) (quotient\/remainder (- (length l) 1) 2))\n  (writeln (list l q r))\n  (if\n    (non-empty-string? strg)\n    (apply format \"Range: ~a Average: ~a Median: ~a\"\n      (map\n        (\u03bb (n)\n           (string-join\n             (map\n               (curry ~r #:min-width 2 #:pad-string \"0\")\n               `(,(quotient n 3600)\n                 ,(quotient (modulo n 3600) 60)\n                 ,(modulo n 60)))\n             \"|\"))\n        `(,(- (apply max l) (apply min l))\n          ,(quotient (apply + l) (length l))\n          ,(quotient\n            (apply + (take (drop (sort l <) q) (+ r 1)))\n            (+ r 1)))))\n    \"\")\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290045,"user_id":null,"body":"#lang racket\/base\n(require racket\/match racket\/string racket\/list racket\/format)\n(provide stat_assoc)\n\n(define\/match (decode-time t)\n  [((pregexp #px\"^(\\\\d\\\\d?)\\\\|(\\\\d\\\\d?)\\\\|(\\\\d\\\\d?)$\" (list _ h m s)))\n   (+ (* 60 60 (string->number h))\n      (* 60 (string->number m))\n      (string->number s))])\n\n(define (encode-time t)\n  (let* ([t (truncate t)]\n         [s (remainder t 60)]\n         [m (remainder (quotient t 60) 60)]\n         [h (quotient (quotient t 60) 60)])\n    (string-join (map (lambda (s) (~a s\n        #:width 2\n        #:align 'right\n        #:pad-string \"0\")) (list h m s)) \"|\")))\n\n(define (stat_assoc strg)\n  (if (eq? \"\" strg) \"\"\n    (let* ([times (sort (map decode-time (string-split strg #rx\", ?\")) <)]\n       [num-times (length times)]\n       [average (\/ (foldl + 0 times) num-times)]\n       [range (- (last times) (first times))]\n       [median (if (even? num-times)\n                   (\/ (+ (list-ref times (quotient num-times 2))\n                         (list-ref times (+ -1 (quotient num-times 2))))\n                      2)\n                   (list-ref times (quotient num-times 2)))])\n  (format \"Range: ~a Average: ~a Median: ~a\"\n          (encode-time range)\n          (encode-time average)\n          (encode-time median)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290046,"user_id":null,"body":"#lang racket\n(provide stat_assoc)\n\n\n;; Solution: Leo Laporte, 5 August 2021\n;; First parse the given string using a regular expression and turn it\n;; into a list of times in seconds. Then perform the calculations necessaru to\n;; find the range, average, and median values in the list, then reformat\n;; the results into a string for the return\n\n;; CONSTANTS\n(define test-data \"01|15|59, 1|47|6, 01|17|20, 1|32|34, 2|3|17\")\n(define secs-in-hour (* 60 60))\n(define secs-in-min 60)\n\n;; FUNCTIONS\n\n;; String -> String\n;; Given a string with formatted race results\n;; return a string with the range of times, average time, and median time\n;; in the format given in the problem set\n;; (assume the input data is consistent)\n(define (stat_assoc results)\n  (cond\n    [(equal? results \"\") \"\"]\n    [else\n     (local [(define times (results->seconds (string-split results \",\")))]\n       (string-append\n        \"Range: \" (calc-range times)\n        \" Average: \" (calc-average times)\n        \" Median: \" (calc-median times)))]))\n\n(module+ test\n  (require rackunit)\n  (check-equal? (stat_assoc \"\") \"\")\n  (check-equal? (stat_assoc test-data)\n                \"Range: 00|47|18 Average: 01|35|15 Median: 01|32|34\")\n  (check-equal? (stat_assoc \"01|15|59, 1|47|16, 01|17|20, 1|32|34, 2|17|17\")\n                \"Range: 01|01|18 Average: 01|38|05 Median: 01|32|34\")\n  (check-equal? (stat_assoc \"02|15|59, 2|47|16, 02|17|20, 2|32|34, 2|17|17, 2|22|00, 2|31|41\")\n                \"Range: 00|31|17 Average: 02|26|18 Median: 02|22|00\")\n (check-equal? (stat_assoc  \"02|17|17, 02|31|41, 1|25|11,01|15|59, 01|22|34, 01|17|20, 09|16|30, 11|15|59, 01|16|30\")\n               \"Range: 10|00|00 Average: 03|33|13 Median: 01|25|11\"))\n \n;; List-of String -> List-of Natural\n;; Given a list of strings with race results, create a list of results as integers (in seconds)\n(define pattern (regexp \"([0-9]+)\\\\|([0-9]+)\\\\|([0-9]+)\")) ; pre-compile regex for speed\n\n(define (results->seconds los)\n  (cond\n    [(empty? los) empty]\n    [else\n     (cons (convert-to-seconds (rest (regexp-match pattern (first los))))\n           (results->seconds (rest los)))]))\n\n(module+ test\n  (check-equal? (results->seconds empty) empty)\n  (check-equal? (results->seconds '(\"01|15|59\" \"1|47|16\")) '(4559 6436)))\n\n;; List-of String -> Natural\n;; given a race time as a list of three strings representing\n;; hours, minutes, and seconds respectively\n;; return the number of total seconds\n(define (convert-to-seconds los)\n  (+ (* (string->number (first los)) secs-in-hour)\n     (* (string->number (second los)) secs-in-min)\n     (string->number (third los))))\n\n(module+ test \n  (check-equal? (convert-to-seconds '(\"1\" \"0\" \"0\")) 3600)\n  (check-equal? (convert-to-seconds '(\"1\" \"1\" \"1\")) 3661)\n  (check-equal? (convert-to-seconds '(\"0\" \"59\" \"1\")) (+ (* 59 60) 1)))\n\n;; List-of Natural -> String\n;; given a list of numbers, calculate the difference between\n;; the lowest and highest numbers and return as a string in the format\n;; \"hh|mm|ss\"\n(define (calc-range lst)\n  (num->time (- (first (sort lst >)) (first (sort lst <)))))\n\n(module+ test\n  (check-equal? (calc-range '(1 2 3 4 5)) (num->time 4))\n  (check-equal? (calc-range '(1001 1002 1003 1004 2000)) (num->time 999)))\n\n;; List-of Natural -> String\n;; given a list of numbers, calculate their average\n(define (calc-average lst)\n  (local [(define (sum l) (foldl + 0 l))]\n    (num->time (quotient (sum lst) (length lst)))))\n\n(module+ test\n  (check-equal? (calc-average '(1 2 3 4)) \"00|00|02\")\n  (check-equal? (calc-average '(100 200 400 300)) (num->time 250)))\n\n;; List-of Natural -> String\n;; given a list of numbers, calculate their median\n(define (calc-median lst)\n  (local [(define len (length lst))\n          (define l (sort lst <))]\n    (num->time\n     (if (odd? len)\n         (list-ref l (quotient len 2))\n         (quotient (+ (list-ref l (quotient len 2))\n                      (list-ref l (- (quotient len 2) 1))) 2)))))\n\n(module+ test\n  (check-equal? (calc-median '(1 2 3 4 5)) (num->time 3))\n  (check-equal? (calc-median '(1 2 3 4 5 6)) (num->time (quotient (+ 3 4) 2)))\n  (check-equal? (calc-median '(10 9 2 15 3)) (num->time 9))\n  (check-equal? (calc-median '(16 10 9 2 15 3)) (num->time 9)))\n\n;; Natural -> String\n;; Given a number of seconds return a string\n;; in the format \"hh|mm|ss\"\n(define (num->time n)\n  (local [(define hours (quotient n secs-in-hour))\n          (define mins (quotient (- n (* hours secs-in-hour)) secs-in-min))\n          (define secs (- n (* hours secs-in-hour) (* mins secs-in-min)))]\n    (format \"~a|~a|~a\"\n            (~r hours #:min-width 2 #:pad-string \"0\")\n            (~r mins #:min-width 2 #:pad-string \"0\")\n            (~r secs #:min-width 2 #:pad-string \"0\"))))\n  \n(module+ test\n  (check-equal? (num->time 60) \"00|01|00\")\n  (check-equal? (num->time 8778) \"02|26|18\")\n  (check-equal? (num->time 0) \"00|00|00\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290047,"user_id":null,"body":"#lang racket\n(provide stat_assoc)\n\n\n;; Solution: Leo Laporte, 5 August 2021\n;; First parse the given string using a regular expression and turn it\n;; into a list of times in seconds. Then perform the calculations necessaru to\n;; find the range, average, and median values in the list, then reformat\n;; the results into a string for the return\n\n;; CONSTANTS\n(define test-data \"01|15|59, 1|47|6, 01|17|20, 1|32|34, 2|3|17\")\n(define secs-in-hour (* 60 60))\n(define secs-in-min 60)\n\n;; FUNCTIONS\n\n;; String -> String\n;; Given a string with formatted race results\n;; return a string with the range of times, average time, and median time\n;; in the format given in the problem set\n;; (assume the input data is consistent)\n(define (stat_assoc results)\n  (cond\n    [(equal? results \"\") \"\"]\n    [else\n     (local [(define times (results->seconds (string-split results \",\")))]\n       (string-append\n        \"Range: \" (calc-range times)\n        \" Average: \" (calc-average times)\n        \" Median: \" (calc-median times)))]))\n\n(module+ test\n  (require rackunit)\n  (check-equal? (stat_assoc \"\") \"\")\n  (check-equal? (stat_assoc test-data)\n                \"Range: 00|47|18 Average: 01|35|15 Median: 01|32|34\")\n  (check-equal? (stat_assoc \"01|15|59, 1|47|16, 01|17|20, 1|32|34, 2|17|17\")\n                \"Range: 01|01|18 Average: 01|38|05 Median: 01|32|34\")\n  (check-equal? (stat_assoc \"02|15|59, 2|47|16, 02|17|20, 2|32|34, 2|17|17, 2|22|00, 2|31|41\")\n                \"Range: 00|31|17 Average: 02|26|18 Median: 02|22|00\"))\n \n;; List-of String -> List-of Natural\n;; Given a list of strings with race results, create a list of results as integers (in seconds)\n(define pattern (regexp \"([0-9]+)\\\\|([0-9]+)\\\\|([0-9]+)\")) ; pre-compile regex for speed\n\n(define (results->seconds los)\n  (cond\n    [(empty? los) empty]\n    [else\n     (cons (convert-to-seconds (rest (regexp-match pattern (first los))))\n           (results->seconds (rest los)))]))\n\n(module+ test\n  (check-equal? (results->seconds empty) empty)\n  (check-equal? (results->seconds '(\"01|15|59\" \"1|47|16\")) '(4559 6436)))\n\n;; List-of String -> Natural\n;; given a race time as a list of three strings representing\n;; hours, minutes, and seconds respectively\n;; return the number of total seconds\n(define (convert-to-seconds los)\n  (+ (* (string->number (first los)) secs-in-hour)\n     (* (string->number (second los)) secs-in-min)\n     (string->number (third los))))\n\n(module+ test \n  (check-equal? (convert-to-seconds '(\"1\" \"0\" \"0\")) 3600)\n  (check-equal? (convert-to-seconds '(\"1\" \"1\" \"1\")) 3661)\n  (check-equal? (convert-to-seconds '(\"0\" \"59\" \"1\")) (+ (* 59 60) 1)))\n\n;; List-of Natural -> String\n;; given a list of numbers, calculate the difference between\n;; the lowest and highest numbers and return as a string in the format\n;; \"hh|mm|ss\"\n(define (calc-range lst)\n  (num->time (- (first (sort lst >)) (first (sort lst <)))))\n\n(module+ test\n  (check-equal? (calc-range '(1 2 3 4 5)) (num->time 4))\n  (check-equal? (calc-range '(1001 1002 1003 1004 2000)) (num->time 999)))\n\n;; List-of Natural -> String\n;; given a list of numbers, calculate their average\n(define (calc-average lst)\n  (local [(define (sum l) (foldl + 0 l))]\n    (num->time (quotient (sum lst) (length lst)))))\n\n(module+ test\n  (check-equal? (calc-average '(1 2 3 4)) \"00|00|02\")\n  (check-equal? (calc-average '(100 200 400 300)) (num->time 250)))\n\n;; List-of Natural -> String\n;; given a list of numbers, calculate their median\n;; (convert list to vector for easy access to elements)\n(define (calc-median lst)\n  (local [(define vect (list->vector (sort lst <)))\n          (define len (length lst))]\n    (num->time\n     (if (odd? len)\n         (vector-ref vect (quotient len 2))\n         (quotient (+ (vector-ref vect (quotient len 2))\n                      (vector-ref vect (- (quotient len 2) 1))) 2)))))\n\n(module+ test\n  (check-equal? (calc-median '(1 2 3 4 5)) (num->time 3))\n  (check-equal? (calc-median '(1 2 3 4 5 6)) (num->time (quotient (+ 3 4) 2)))\n  (check-equal? (calc-median '(10 9 2 15 3)) (num->time 9))\n  (check-equal? (calc-median '(16 10 9 2 15 3)) (num->time 9)))\n\n;; Natural -> String\n;; Given a number of seconds return a string\n;; in the format \"hh|mm|ss\"\n(define (num->time n)\n  (local [(define hours (quotient n secs-in-hour))\n          (define mins (quotient (- n (* hours secs-in-hour)) secs-in-min))\n          (define secs (- n (* hours secs-in-hour) (* mins secs-in-min)))]\n    (format \"~a|~a|~a\"\n            (~r hours #:min-width 2 #:pad-string \"0\")\n            (~r mins #:min-width 2 #:pad-string \"0\")\n            (~r secs #:min-width 2 #:pad-string \"0\"))))\n  \n(module+ test\n  (check-equal? (num->time 60) \"00|01|00\")\n  (check-equal? (num->time 8778) \"02|26|18\")\n  (check-equal? (num->time 0) \"00|00|00\"))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290048,"user_id":544,"body":"#lang racket\n(provide stat_assoc)\n\n; formatting functions\n(define (display-hours s) (~r (quotient s 3600) #:min-width 2 #:pad-string \"0\"))\n(define (display-minutes s) (~r (quotient (remainder s 3600) 60) #:min-width 2 #:pad-string \"0\"))\n(define (display-seconds s) (~r (floor (remainder s 60)) #:min-width 2 #:pad-string \"0\"))\n(define (display-time s) (string-join (list (display-hours s) \"|\" (display-minutes s) \"|\" (display-seconds s)) \"\"))\n\n; stat_associstical calculation functions\n(define (time-range t) (- (apply max t) (apply min t)))\n(define (time-average t) (floor (\/ (apply + t) (length t))))\n(define (time-median t)\n  ; median is either the middle value or the average of the middle two values\n  (floor (cond [(even? (length t)) \n         (\/ (+ (list-ref (sort t <) (\/ (length t) 2)) \n             (list-ref (sort t <) (sub1 (\/ (length t) 2)))) 2)]\n        [(odd? (length t)) (list-ref (sort t <) (\/ (- (length t) 1) 2))])))\n\n(define (stat_assoc strg)\n  (cond [(non-empty-string? strg)\n         ; split each time into its own string,\n         (define time-list (string-split strg \",\"))\n         ; parse the strings into hours, minutes and seconds,\n         (define raw-times \n            (map (lambda (t) (map string->number (map string-trim (string-split t \"|\")))) time-list))\n         ; convert h:m:s to seconds,\n         (define times-in-seconds\n            (map (lambda (t) (+ (* 3600 (list-ref t 0)) (* 60 (list-ref t 1)) (list-ref t 2))) raw-times))\n         ; find the stat_associstical measures for the set,\n         ; then pretty-print the results in the provided template,\n         (let ([range    (time-range times-in-seconds)]\n               [average  (time-average times-in-seconds)]\n               [median   (time-median times-in-seconds)]) \n           (format \"Range: ~a Average: ~a Median: ~a\" \n                   (display-time range) (display-time average) (display-time median)))]\n        ; or return nothing if we weren't passed anything\n        [else \"\"]))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290049,"user_id":544,"body":"#lang racket\n(provide stat_assoc)\n\n(define (stat_assoc strg)\n  (cond [(non-empty-string? strg)\n         (define time-list (string-split strg \",\"))\n          (define raw-times \n            (map (lambda (t) (map string->number (map string-trim (string-split t \"|\")))) time-list))\n          (define times-in-seconds\n            (map (lambda (t) (+ (* 3600 (list-ref t 0)) (* 60 (list-ref t 1)) (list-ref t 2))) raw-times))\n          (string-join (list \n            \"Range: \" \n            (~r (quotient (time-range times-in-seconds) 3600) #:min-width 2 #:pad-string \"0\")\n            \"|\"\n            (~r (quotient (remainder (time-range times-in-seconds) 3600) 60) #:min-width 2 #:pad-string \"0\")\n            \"|\"\n            (~r (floor (remainder (time-range times-in-seconds) 60)) #:min-width 2 #:pad-string \"0\")\n            \" Average: \" \n            (~r (quotient (time-average times-in-seconds) 3600) #:min-width 2 #:pad-string \"0\")\n            \"|\"\n            (~r (quotient (remainder (time-average times-in-seconds) 3600) 60) #:min-width 2 #:pad-string \"0\")\n            \"|\"\n            (~r (floor (remainder (time-average times-in-seconds) 60)) #:min-width 2 #:pad-string \"0\")\n            \" Median: \" \n            (~r (quotient (time-median times-in-seconds) 3600) #:min-width 2 #:pad-string \"0\")\n            \"|\"\n            (~r (quotient (remainder (time-median times-in-seconds) 3600) 60) #:min-width 2 #:pad-string \"0\")\n            \"|\"\n            (~r (floor (remainder (time-median times-in-seconds) 60)) #:min-width 2 #:pad-string \"0\")    \n          ) \"\")\n        ]\n        [else \"\"]\n  )\n)\n\n(define (time-range t)\n  (- (apply max t) (apply min t)))\n\n(define (time-average t)\n  (floor (\/ (apply + t) (length t))))\n\n(define (time-median t)\n  (floor (cond [(even? (length t)) \n         (\/ \n            (+ (list-ref (sort t <) \n                         (\/ (length t) 2)\n                         ) \n             (list-ref (sort t <) \n                       (sub1 (\/ (length t) 2))\n                       )\n            )        \n          2)\n         ]\n        [(odd? (length t)) (list-ref (sort t <) (\/ (- (length t) 1) 2))]\n   ))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290050,"user_id":null,"body":"#lang racket\n(provide stat_assoc)\n\n(define (tstring tseconds)\n  (let* ([hours (quotient tseconds 3600)]\n         [mins (quotient (- tseconds (* hours 3600)) 60)]\n         [secs (- (- tseconds (* hours 3600)) (* mins 60))])\n    (format \"~a|~a|~a\"\n            (~r hours #:min-width 2 #:pad-string \"0\")\n            (~r mins #:min-width 2 #:pad-string \"0\")\n            (~r secs #:min-width 2 #:pad-string \"0\"))))\n\n(define (stat_assoc strg)\n  (if (equal? strg \"\")\n      \"\"\n      (let* ([times\n              (sort\n               (for\/list ([timeStr (string-split strg \",\")])\n                      (let ([time (string-split (string-trim timeStr) \"|\")])\n                        (+ (* 3600 (string->number (list-ref time 0)))\n                           (* 60 (string->number (list-ref time 1)))\n                           (string->number (list-ref time 2)))))\n               < )]\n             [numTimes (length times)]\n             [minimum (foldl (lambda (el min)\n                               (if (< el min) el min)) (first times) times)]\n             [maximum (foldl (lambda (el max)\n                               (if (> el max) el max)) (first times) times)]\n             [range (- maximum minimum)]\n             [mean (quotient \n                    (foldl (lambda (el total) (+ el total) ) 0 times)\n                    numTimes)]\n             [median (if (even? numTimes)\n                         (quotient\n                          (+\n                           (list-ref times (- (quotient numTimes 2) 1))\n                           (list-ref times (quotient numTimes 2)))\n                          2)\n                         (list-ref times (quotient numTimes 2)))])\n        (format \"Range: ~a Average: ~a Median: ~a\" (tstring range) (tstring mean) (tstring median)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290051,"user_id":null,"body":"#lang racket\n(provide stat_assoc)\n\n(define (stat_assoc strg)\n  (define (average . lst)\n    (quotient (apply + lst) (length lst)))\n  (define (hms->second hms)\n    (+ (* 3600 (car  hms))\n       (* 60   (cadr hms))\n       (caddr hms)))\n  (define (second->hms second)\n    (let*-values ([(h ms) (quotient\/remainder second 3600)]\n                  [(m s)  (quotient\/remainder ms 60)])\n      `(,h ,m ,s)))\n  ; hms->string : (Hour Minute Second) -> String\n  (define (hms->string hms)\n    (~a (~a (car   hms) #:width 2 #:pad-string \"0\" #:align 'right)\n        (~a (cadr  hms) #:width 2 #:pad-string \"0\" #:align 'right)\n        (~a (caddr hms) #:width 2 #:pad-string \"0\" #:align 'right)\n        #:separator \"|\"))\n  (let ((hms-lst\n          (map (lambda (str)\n                 (map string->number ; hms string -> (Hour Minute Second)\n                      (string-split (string-trim str) \"|\"))) ; string -> hms string\n               (string-split strg \",\")))) ; string -> [string]\n    (if (null? hms-lst) \"\"\n        (let ((seconds-lst (map hms->second hms-lst)))\n          (let ((sorted (sort seconds-lst <)))\n            (let* ((len (length sorted))\n                   (half (quotient len 2))\n                   (range (- (list-ref sorted (sub1 len))\n                             (list-ref sorted 0)))\n                   (median (if (even? len)\n                               (average (list-ref sorted (sub1 half))\n                                        (list-ref sorted half))\n                               (list-ref sorted half)))\n                   (aver (apply average sorted)))\n              (string-append \"Range: \"    ((compose hms->string second->hms) range)\n                             \" Average: \" ((compose hms->string second->hms) aver)\n                             \" Median: \"  ((compose hms->string second->hms) median))))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290052,"user_id":null,"body":"#lang racket\n(provide stat_assoc)\n\n(define (stat_assoc strg)\n  (define (average . lst)\n    (quotient (foldr + 0 lst) (length lst)))\n  (define (hms->second hms)\n    (+ (* 3600 (car  hms))\n       (* 60   (cadr hms))\n       (caddr hms)))\n  (define (second->hms second)\n    (let* ((h  (quotient  second 3600))\n           (ms (remainder second 3600))\n           (m  (quotient  ms     60))\n           (s  (remainder ms     60)))\n      `(,h ,m ,s)))\n  ; hms->string : (Hour Minute Second) -> String\n  (define (hms->string hms)\n    (string-append (~r (car   hms) #:min-width 2 #:pad-string \"0\") \"|\"\n                   (~r (cadr  hms) #:min-width 2 #:pad-string \"0\") \"|\"\n                   (~r (caddr hms) #:min-width 2 #:pad-string \"0\")))\n  (let ((hms-lst\n          (map (lambda (str)\n                 (map string->number ; hms string -> (Hour Minute Second)\n                      (string-split (string-trim str) \"|\"))) ; string -> hms string\n               (string-split strg \",\")))) ; string -> [string]\n    (if (null? hms-lst) \"\"\n        (let ((seconds-lst (map hms->second hms-lst)))\n          (let ((sorted (sort seconds-lst <)))\n            (let* ((len (length sorted))\n                   (half (quotient len 2))\n                   (range (- (list-ref sorted (sub1 len))\n                             (list-ref sorted 0)))\n                   (median (if (even? len)\n                               (average (list-ref sorted (sub1 half))\n                                        (list-ref sorted half))\n                               (list-ref sorted half)))\n                   (aver (apply average sorted)))\n              (string-append \"Range: \"    ((compose hms->string second->hms) range)\n                             \" Average: \" ((compose hms->string second->hms) aver)\n                             \" Median: \"  ((compose hms->string second->hms) median))))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55b4d87a3766d9873a0000d4":[{"id":290053,"user_id":53,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (for*\/list ([i (in-inclusive-range (min m n) (max m n))]\n              #:when (and (= (remainder i 9) 1) (= (remainder i 7) 2)))\n        (list \n          (format \"M: ~a\" i) \n          (format \"B: ~a\" (quotient i 7)) \n          (format \"C: ~a\" (quotient i 9)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290054,"user_id":null,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (for\/list ([money (range (min m n) (add1 (max m n)))]\n             #:when (and (= (modulo money 7) 2) (= (modulo money 9) 1)))\n    (list (~a \"M: \" money) (~a \"B: \" (quotient money 7)) (~a \"C: \" (quotient money 9)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290055,"user_id":492,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (let ([r (filter\n            (lambda (x) (and (= 1 (remainder x 9)) (= 2 (remainder x 7))))\n            (range (min m n) (add1 (max m n))))\n        ]\n       )\n    (map\n     (lambda (x) (list (format \"M: ~a\" x) (format \"B: ~a\" (quotient x 7)) (format \"C: ~a\" (quotient x 9)))) r)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290056,"user_id":null,"body":"#lang racket\n(provide how-much)\n(define boat 7)\n(define car 9)\n(define (check-b n) (if (= (remainder n boat) 2) #t #f))\n(define (check-c n) (if (= (remainder n car) 1) #t #f))\n(define (make-list m b c)\n    (list   (string-append \"M: \" (format \"~v\" m))\n            (string-append \"B: \" (format \"~v\" b))\n            (string-append \"C: \" (format \"~v\" c))))\n\n(define (find-common-list m n t)\n    (let ([x (+ (* boat t) 2)])\n    (cond ((< x m)(find-common-list m n (+ t 1)))\n          ((and (<= x n) (check-c x)) (cons x (find-common-list m n (+ t 1))))\n          ((> x n) null)\n          (else (find-common-list m n (+ t 1))))))\n\n(define (loop-find m n)\n    (let*   ([z (if (< m 37) 37 m)]\n             [x (quotient z boat)]\n             [y (find-common-list m n x)])\n            (if (null? y)\n                null\n                (for\/list ([i y])\n                    (make-list i (quotient i boat) (quotient i car))))))\n\n(define (find-m m n)\n  (cond ((< n 37) null)\n        ((and (= m n) (and (check-b m) (check-c n)))\n            (make-list m (quotient m boat) (quotient m car)))\n        ((< m n) (loop-find m n))\n        (else null)))\n\n(define (how-much m n)\n  (cond ((<= m n)(find-m m n))\n        ((> m n)(find-m n m))\n        (else \"oops!\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290057,"user_id":544,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (for\/list ([x (inclusive-range (min m n) (max m n))]\n             #:when (and (= 0 (modulo (- x 1) 9))\n                         (= 0 (modulo (- x 2) 7))))\n    (let [(b (quotient (- x 2) 7))\n          (c (quotient (- x 1) 9))]\n      (for\/list ([val (in-list (list x b c))]\n                 [name (in-list (list \"M:\" \"B:\" \"C:\"))])\n        (~a name \" \"val)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290058,"user_id":null,"body":"#lang racket\n\n(provide how-much)\n\n;; Int>0 Int>0 -> (Listof (List Int Int Int))\n;; given bounds for John's fortune `m` and `n` (both inclusive)\n;; return possible configurations with:\n;; - an estimate for John's fortune `f`\n;; - the price `c` of a car such that 9c + 1 = f\n;; - the price `b` of a boat such that 7b + 2 = f\n(define (how-much m n)\n  (for*\/list ([f (in-range (min m n) (add1 (max m n)))]\n              [c `(,(\/ (- f 1) 9))]\n              [b `(,(\/ (- f 2) 7))]\n              #:when (and (integer? c) (integer? b)))\n    `(,(format \"M: ~a\" f) ,(format \"B: ~a\" b) ,(format \"C: ~a\" c))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290059,"user_id":null,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (map (lambda (x)\n         (map string-append\n              '(\"M: \" \"B: \" \"C: \")\n              (map number->string x)))\n       (filter identity\n               (map (lambda (x)\n                      (if (and (zero? (modulo (- x 2) 7))\n                               (zero? (modulo (- x 1) 9)))\n                          (list x (\/ (- x 2) 7) (\/ (- x 1) 9))\n                          #f))\n                    (range (min m n) (+ 1 (max m n)))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290060,"user_id":null,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (let* ([possible-fs (if (>= m n)\n                          (range n (+ m 1))\n                          (range m (+ n 1)))]\n         [solutions (filter-map (lambda (f) (let ([c (\/ (- 1 f) -9)]\n                                                  [b (\/ (- 2 f) -7)])\n                                              (if (and (integer? c) (integer? b))\n                                                  (list f b c)\n                                                  #f)))\n                    possible-fs)]\n         [string-append-number (lambda (str num) (string-append str (number->string num)))])\n    (map (lambda (lst) (list (string-append-number \"M: \" (first lst))\n                             (string-append-number \"B: \" (second lst))\n                             (string-append-number \"C: \" (third lst))))\n         solutions)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290061,"user_id":null,"body":"#lang racket\n(require racket\/format)\n(provide how-much)\n\n(define (how-much m n)\n  (let ([x (min m n)]\n        [y (max m n)])\n     (map (lambda (x) (list (~a \"M: \" x)\n                            (~a \"B: \" (\/ (- x 2) 7))  \n                            (~a \"C: \" (\/ (- x 1) 9))))\n          (filter (lambda (x) (and (zero? (remainder (- x 1) 9))\n                                   (zero? (remainder (- x 2) 7))))\n                  (range x (+ 1 y)) )))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290062,"user_id":null,"body":"#lang racket\n(provide how-much)\n\n(define (how-much m n)\n  (filter\n   (lambda (v) (not (null? v)))\n   (map\n    (lambda (f)\n      (let-values\n          ([(bq br) (quotient\/remainder (- f 2) 7)]\n           [(cq cr) (quotient\/remainder (- f 1) 9)]\n           )\n        (cond\n          [(and (= 0 br) (= 0 cr))\n           (list\n            (format \"M: ~v\" f)\n            (format \"B: ~v\" bq)\n            (format \"C: ~v\" cq)\n            )\n           ]\n          [else null]\n          )\n        )\n      )\n    (range (min m n) (+ (max m n) 1))\n    )\n   )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55be10de92aad5ef28000023":[{"id":290063,"user_id":53,"body":"#lang racket\n(provide checkchoose)\n\n(define (checkchoose m n)\n  (define (aux m n i r)\n    (cond\n       [(= i (add1 n)) -1]\n       [(= r m) i]\n       [else (aux m n (add1 i) (* r (\/ (- n i) (add1 i))))]\n     )\n   )\n  (aux m n 0 1)\n )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290064,"user_id":null,"body":"#lang racket\n(provide checkchoose)\n\n(define (checkchoose m n)\n  (define (fstind m n b k)\n    (cond \n     [(equal? m b) k]\n     [(>= k n) -1]\n     [(< m b) -1]\n     [else (fstind m n (quotient (* b (- n k)) (+ k 1)) (+ k 1))]\n        ))\n  (fstind m n 1 0)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290065,"user_id":544,"body":"#lang racket\n(provide checkchoose)\n\n(define (binomial r k)\n  (letrec ((aux (lambda (value i)\n                  (cond ((zero? i) value)\n                        (else (aux (* value (\/ (- r i -1) i)) (- i 1)))))))\n    (aux 1 k)))\n\n(define (checkchoose m n)\n  (cond\n    [(m . <= . 0) -1]\n    [else (define choice-range (range 0 n))\n          (define combinations (map (curry binomial n) choice-range))\n          (define index (index-where combinations (\u03bb (i) (= i m))))\n          (or index -1)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290066,"user_id":53,"body":"#lang racket\n(provide checkchoose)\n\n(define (helper m n i r)\n  (cond\n     [(= i (add1 n)) -1]\n     [(= r m) i]\n     [else (helper m n (add1 i) (* r (\/ (- n i) (add1 i))))]\n   )\n )\n\n(define (checkchoose m n)\n  (helper m n 0 1)\n )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290067,"user_id":null,"body":"#lang racket\n\n(provide checkchoose)\n\n;; Racket library math\/number-theory, which provides factorial\n;; is not available, so a factorial function must be provided.\n(define (factorial n)\n  (define (factorial-loop m acc)\n    (if (<= m 1)\n        acc\n        (factorial-loop (sub1 m) (* m acc))))\n  (factorial-loop n 1))\n\n;; Compute binomial coefficient n choose k.\n;; nCk = n!\/((n-k)!k!)\n(define (n-choose-k n k)\n  (quotient (factorial n) (* (factorial (- n k)) (factorial k))))\n\n;; Peform a binary search to find k such that nCk=m.\n(define (binary-search low high m n)\n  (if (< high low)\n      -1\n      (let* ([k (quotient (+ low high) 2)]\n             [nCk (n-choose-k n k)])\n        (cond [(= nCk m) k]\n              [(< nCk m) (binary-search (add1 k) high m n)]\n              [(> nCk m) (binary-search low (sub1 k) m n)]))))\n\n;; Solution to problem.\n(define (checkchoose m n)\n  (cond [(= m 0) -1]\n        [(< m n) 0]\n        [else (binary-search 1 (add1 (quotient n 2)) m n)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290068,"user_id":null,"body":"#lang racket\n(provide checkchoose)\n\n(define (checkchoose m n)\n  (cond ((zero? m) -1)\n        ((equal? 1 m) 0)\n        (else\n          (let loop ((k 1)\n                     (current-n n)\n                     (mk-factorial m)\n                     (upper-n n))\n            (cond ((equal? mk-factorial upper-n) k)\n                  ((> (* 2 k) n) -1)\n                  (else \n                    (loop (+ 1 k)\n                          (- current-n 1)\n                          (* mk-factorial (+ 1 k))\n                          (* upper-n (- current-n 1)))))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290069,"user_id":492,"body":"#lang racket\n(provide checkchoose)\n\n(define (checkchoose m n)\n  (define (choose n p)\n    (let ([p (min p (- n p))])\n      (cond \n        ((negative? p) 0)\n        (else\n         (letrec ((aux\n                   (lambda (value i)\n                     (cond ((zero? i) value)\n                           (else (aux (* value (\/ (- n i -1) i)) (sub1 i)))))))\n           (aux 1 p))))))\n  (if (> m (choose n (quotient n 2)))\n      -1\n      (let loop ([i 0])\n        (if (> i (+ 1 (quotient n 2)))\n            -1\n            (if (= m (choose n i))\n                i\n                (loop (add1 i)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290070,"user_id":492,"body":"#lang racket\n(provide checkchoose)\n\n(define (checkchoose m n)\n  (define (choose n p)\n    (let ([p (min p (- n p))])\n      (cond \n        ((negative? p) 0)\n        (else\n         (letrec ((aux\n                   (lambda (value i)\n                     (cond ((zero? i) value)\n                           (else (aux (* value (\/ (- n i -1) i)) (sub1 i)))))))\n           (aux 1 p))))))\n  (if (> m (choose n (quotient n 2)))\n      -1\n      (let loop ([i 0])\n        (if (> i (+ 1 (quotient n 2)))\n            -1\n            (if (= m (choose n i))\n                i\n                (loop (add1 i)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55c6126177c9441a570000cc":[{"id":290071,"user_id":492,"body":"#lang racket\n(provide order_weight)\n\n(define (order_weight s)\n  (define (sum-digits n)\n    (apply + (map string->number (map string (string->list n)))))\n  \n  (define (comp x y)\n    (let ([a1 (car x)] [b1 (car y)] [a2 (cdr x)] [b2 (cdr y)])\n      (if (= a2 b2)\n          (string<? a1 b1)\n          (< a2 b2))))\n  \n  (let ([ls (map (\u03bb(x) (cons x (sum-digits x))) (string-split s \" \"))])\n    (string-join (map car (sort ls comp)) \" \")))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290072,"user_id":null,"body":"#lang racket\n(provide order_weight)\n\n(define (order_weight s)\n  (define (calc-weight n)\n    (for\/sum ([c (in-string n)])\n      (- (char->integer c) 48)))\n  (string-join\n    (sort (sort (string-split s) string<?) <\n          #:key calc-weight\n          #:cache-keys? #t)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290073,"user_id":null,"body":"#lang racket\n(provide order_weight)\n(require rackunit)\n\n(define (sum-digits s)\n  (let* ([sum (curry foldl + 0)]\n         [empty-string? (curry equal? \"\")]\n         [digits (map string->number\n                      (filter-not empty-string? (string-split s \"\")))])\n    (sum digits)))\n\n(check-equal? (sum-digits \"99\") 18)\n(check-equal? (sum-digits \"100\") 1)\n\n(define (comparison x y)\n  (match (cons x y)\n    [(cons (cons w1 s1) (cons w2 s2)) #:when (equal? w1 w2) (string<? s1 s2)]\n    [(cons (cons w1 _) (cons w2 _)) (w1 . < . w2)]))\n\n(define (order_weight string)\n  (let* ([decorated (for\/list ([s (string-split string)]) (cons (sum-digits s) s))]\n         [sorted (sort decorated comparison)]\n         [undecorated (string-join (map cdr sorted))])\n    undecorated))\n\n(check-equal?\n (order_weight \"56 65 74 100 99 68 86 180 90\")\n \"100 180 90 56 65 74 68 86 99\")\n(check-equal?\n (order_weight \"2000 10003 1234000 44444444 9999 11 11 22 123\")\n \"11 11 2000 10003 22 123 1234000 44444444 9999\")","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290074,"user_id":168,"body":"#lang racket\n(provide order_weight)\n\n(define (order_weight s)\n  (define (weight x)\n    (for\/sum ([c x]) (- (char->integer c) 48)))\n  (string-join\n    (sort (string-split s)\n          (lambda (x y)\n            (let ([wx (weight x)]\n                  [wy (weight y)])\n              (or (< wx wy) (and (= wx wy) (string<? x y)))))))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290075,"user_id":null,"body":"#lang racket\n(provide order_weight)\n\n(define (order_weight s)\n  (define (get-weight s)\n    (apply + (map\n              (lambda (c)\n                (- (char->integer c) 48)) (string->list s))))\n  (define (compare a b)\n    (let ([a-weight (get-weight a)]\n          [b-weight (get-weight b)])\n      (cond\n        [(= a-weight b-weight) (string<? a b)]\n        [else (< a-weight b-weight)]\n         )))\n  (string-join \n   (sort (string-split s) compare))\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290076,"user_id":null,"body":"#lang racket\n(provide order_weight)\n\n (define memoize\n        (lambda (func)\n            (let ([table (make-hasheq)])\n                (lambda args\n                    (if (null? args)\n                        func\n                        (let ([prev (hash-ref table args #f)])   \n                            (or prev\n                                (let ((result (apply func args)))\n                                    (hash-set! table args result)\n                                    result))))))))\n\n;; number->sum-digits :: number -> number\n(define number->sum-digits\n    (memoize\n        (lambda (number)\n            (let loop ([number number]\n                       [sum 0])\n                (if (= number 0)\n                    sum\n                    (loop (quotient number 10) (+ (remainder number 10) sum)))))))\n\n;; weigth :: List -> List\n(define (order_weight s)\n    (let* ([str-lst (string-split s \" \")]\n           [num-lst (map string->number str-lst)]\n           [func-orden (lambda (elt1 elt2)\n                            (let* ([nuevo-elt1 (number->sum-digits elt1)]\n                                  [nuevo-elt2 (number->sum-digits elt2)]\n                                  [elt1-str (number->string elt1)]\n                                  [elt2-str (number->string elt2)])\n                                (cond ([< nuevo-elt1 nuevo-elt2] #t)\n                                      ([and (= nuevo-elt1 nuevo-elt2) (string<? elt1-str elt2-str)] #t)\n                                      (else #f))))])\n        (string-join (map number->string (sort num-lst func-orden)) \" \")))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290077,"user_id":null,"body":"#lang racket\n(provide order_weight)\n\n;; Turn a number into a list of digits.\n(define (number->list n)\n  (define (loop m acc)\n    (if (= m 0)\n        acc\n        (loop (quotient m 10) (cons (remainder m 10) acc))))\n  (if (= n 0)\n      '(0)\n      (loop n '())))\n\n;; Return the sum of the digits in the given number.\n(define (sum-digits n)\n  (apply + (number->list n)))\n\n;; Function to compare two numbers for sorting where\n;; each number is actually a pair of the number string\n;; and the sum of the digits.  Sorting is by sum of\n;; first digits then by lexicographic order of the\n;; number string.\n(define (compare-numbers p q)\n  (if (= (car p) (car q))\n      (string<? (cdr p) (cdr q))\n      (< (car p) (car q))))\n\n(define (order_weight s)\n  ;; Join the number-strings with a \" \" in between.\n  (string-join\n   ;; Select the number strings from the sorted list.\n   (map cdr\n        ;; Sort the list of pairs first by sum of digits then\n        ;; by lexicographic order of the number string using\n        ;; the compare-numbers function.\n        (sort\n         ;; Split the string by whitespace and then convert\n         ;; string into list of pairs where each pair is\n         ;; the number string and the sum of the digits.\n         (map (\u03bb (s0) (cons (sum-digits (string->number s0)) s0))\n              (string-split s))\n         compare-numbers))\n   \" \"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290078,"user_id":242,"body":"#lang racket\n(provide order_weight)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (map proc items)\n  (cond\n    [(null? items) `()]\n    [(pair? items) (cons (proc (car items)) (map proc (cdr items)))]\n    [else (list (proc items))]\n  )\n)\n\n(define (inputtolst inputstr)\n  (define (get-all-words-iter lstchars acc currword)\n    (cond\n      [(and (null? lstchars) (null? currword)) acc]\n      [(null? lstchars) (cons (accumulate ~a \"\" (reverse currword)) acc)]\n      [(and (equal? \" \" (car lstchars)) (null? currword)) (get-all-words-iter (cdr lstchars) acc `())]\n      [(equal? \" \" (car lstchars)) (get-all-words-iter (cdr lstchars) (cons (accumulate ~a \"\" (reverse currword)) acc) `())]\n      [else (get-all-words-iter (cdr lstchars) acc (cons (car lstchars) currword))]\n    )\n  )\n  (reverse (get-all-words-iter (map string (string->list inputstr)) `() `()))\n)\n\n(define (sum-of-digits str)\n  (accumulate + 0 (map string->number (map string (string->list str))))\n)\n\n(define (sort-op x y)\n  (cond\n    [(< (sum-of-digits x) (sum-of-digits y)) #t]\n    [(> (sum-of-digits x) (sum-of-digits y)) #f]\n    [(string<? x y) #t]\n    [else #f]\n  )\n)\n\n(define (order_weight s)\n  (let\n    ((newstr (accumulate (lambda (x y) (~a x \" \" y)) \"\" (sort (inputtolst s) sort-op))))\n    (if (< 1 (string-length newstr))\n        (substring newstr 1 (string-length newstr))\n        \"\"\n    )\n  )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290079,"user_id":null,"body":"#lang racket\/base\n(require racket\/string)\n\n(provide order_weight)\n\n(define (order_weight s)\n  (string-join \n    (sort (string-split s) weight<?)))\n    \n(define (weight str)\n  (for\/sum ([c (in-string str)])\n    (- (char->integer c) 48)))\n    \n(define (weight<? str1 str2)\n  (let ([w1 (weight str1)]\n        [w2 (weight str2)])\n    (or (< w1 w2)\n        (and (= w1 w2)\n             (string<? str1 str2)))))\n  \n      ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55cbc3586671f6aa070000fb":[{"id":290080,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define factor? (compose zero? remainder))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290081,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (cond\n   {(= (remainder base factor) 0) true }\n   {else false})\n  )\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290082,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (if(= 0 (modulo base factor)) #t #f))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290083,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (eq? (modulo base factor) 0))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290084,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (cond \n    [(= 0 (modulo base factor)) #t ]\n    [else #f])\n  )\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290085,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (zero? (modulo base factor)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290086,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (if (= (modulo base factor) 0)\n      #t\n      #f))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290087,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? b f)\n  (= 0 (modulo b f)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290088,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define (factor? base factor)\n  (eq? 0 (modulo base factor)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290089,"user_id":null,"body":"#lang racket\n\n(provide factor?)\n\n(define factor? (compose zero? modulo))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55cbd4ba903825f7970000f5":[{"id":290090,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (define m (\/ (+ s1 s2 s3) 3))\n  (cond [(<= 90 m 100) \"A\"]\n        [(<= 80 m) \"B\"]\n        [(<= 70 m) \"C\"]\n        [(<= 60 m) \"D\"]\n        [else \"F\"]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290091,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (let ([m (\/ (+ s1 s2 s3) 3)])\n    (cond\n      ((<= 90 m 100) \"A\")\n      ((<= 80 m 90)  \"B\")\n      ((<= 70 m 80)  \"C\")\n      ((<= 60 m 70)  \"D\")\n      ((<= 0  m 60)  \"F\"))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290092,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (define avg (\/ (+ s1 (+ s2 s3)) 3))\n  (cond\n    [(>= avg 90) \"A\"]\n    [(>= avg 80) \"B\"]\n    [(>= avg 70) \"C\"]\n    [(>= avg 60) \"D\"]\n    [else \"F\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290093,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (let ([score (\/ (+ s1 s2 s3) 3)])\n    (cond\n      [(<= 90 score 100) \"A\"]\n      [(<= 80 score 90) \"B\"]\n      [(<= 70 score 80) \"C\"]\n      [(<= 60 score 70) \"D\"]\n      [else \"F\"])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290094,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n    (let ([avg (\/ (+ s1 s2 s3) 3)])\n    (cond [(>= avg 90) \"A\"]\n\t  [(>= avg 80) \"B\"]\n\t  [(>= avg 70) \"C\"]\n\t  [(>= avg 60) \"D\"]\n\t  [(< avg 60) \"F\"])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290095,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (let ([avgVal (\/ (+ s1 s2 s3) 3)])\n    (cond\n     [(<= 90 avgVal 100) \"A\"]\n     [(<= 80 avgVal 90) \"B\"]\n     [(<= 70 avgVal 80) \"C\"]\n     [(<= 60 avgVal 70) \"D\"]\n     [(<= 0 avgVal 60) \"F\"]\n     )\n    )\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290096,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (let ((a (\/ (+ s1 s2 s3) 3)))\n    (cond\n     ((>= a 90) \"A\")\n     ((>= a 80) \"B\")\n     ((>= a 70) \"C\")\n     ((>= a 60) \"D\")\n     ((< a 60)  \"F\"))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290097,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (avg l)\n  (\/ (apply + l) (length l)))\n\n(define (get_grade s1 s2 s3)\n  (define score (avg (list s1 s2 s3)))\n  (cond [(and (<= score 100) (>= score 90)) \"A\"]\n        [(and (< score 90)   (>= score 80)) \"B\"]\n        [(and (< score 80)   (>= score 70)) \"C\"]\n        [(and (< score 70)   (>= score 60)) \"D\"]\n        [else \"F\"]\n        ) \n )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290098,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (avg l)\n  (\/ (apply + l) (length l)))\n\n(define (get_grade s1 s2 s3)\n  (define score (avg (list s1 s2 s3)))\n  (cond [(and (<= score 100) (>= score 90)) \"A\"]\n        [(and (< score 90)   (>= score 80)) \"B\"]\n        [(and (< score 80)   (>= score 70)) \"C\"]\n        [(and (< score 70)   (>= score 60)) \"D\"]\n        [(and (< score 60)   (>= score  0)) \"F\"]\n        ) \n )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290099,"user_id":null,"body":"#lang racket\n\n(provide get_grade)\n\n(define (get_grade s1 s2 s3)\n  (let ([avg (\/(+ s1 s2 s3)3)])\n    (cond \n     [(>= avg 90 ) \"A\"]\n     [(>= avg 80 ) \"B\"]\n     [(>= avg 70 ) \"C\"]\n     [(>= avg 60 ) \"D\"]\n     [else \"F\"] )))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55d24f55d7dd296eb9000030":[{"id":290100,"user_id":168,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n) (quotient (* n (+ n 1)) 2))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290101,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation s)\n  (if(<= s 0) 0\n     (+ s (summation (- s 1)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290102,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n)\n  (if (= n 0)\n      0\n      (+ n [summation (- n 1)]\n         )\n      )\n  )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290103,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n)\n  (apply + (range (+ n 1))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290104,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n)\n  (cond \n   [(>= n 1) (+ n (summation (sub1 n)))]\n   [else 0]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290105,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n)\n  (local\n    [(define (sum-to-n n c)\n       (cond\n         [(= c n) c]\n         [else\n          (+ c\n             (sum-to-n n (add1 c)))]))]\n\n    (sum-to-n n 1)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290106,"user_id":564,"body":"#lang racket\n(provide summation)\n\n(define (summation n)\n  (for\/sum ([i (in-range 0 n)]) (add1 i)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290107,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n\n(define (summation n)\n  (letrec ([summation-helper \n           (lambda (ii nn) (if (> ii nn) 0 (+ ii (summation-helper (+ ii 1) nn))))])\n  (summation-helper 1 n)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290108,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n)\n  (apply + (range 1 (add1 n))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290109,"user_id":null,"body":"#lang racket\n\n(provide summation)\n\n(define (summation n)\n  (define (itr n acc)\n    (if (= n 0) \n        acc\n        (itr (- n 1) (+ acc n))))\n  (itr n 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55e2adece53b4cdcb900006c":[{"id":290110,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (to-time n)\n  (let* [(h (floor n))\n         (rem (* (- n h) 60))\n         (m (floor rem))\n         (rems (* (- rem m) 60))\n         (s (floor rems))]\n    (list h m s)))\n\n(define (race v1 v2 g)\n  (if (>= v1 v2)\n    (list -1 -1 -1)\n    (to-time (\/ g (- v2 v1)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290111,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (race v1 v2 g)\n  (if (>= v1 v2)\n      (list -1 -1 -1)\n      (let [(seconds (truncate (* (\/ g (- v2 v1)) 3600)))]\n      (list (quotient seconds 3600)\n            (quotient (modulo seconds 3600) 60)\n            (modulo seconds 60)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290112,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (race v1 v2 g)\n  (if (>= v1 v2) (list -1 -1 -1)\n  (let* ((foo (quotient (* 3600 g) (- v2 v1)))\n         (h (quotient foo 3600))\n         (m (remainder (quotient foo 60) 60))\n         (s (remainder foo 60)))\n    (list h m s))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290113,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (race v1 v2 g)\n  (if (< v1 v2)\n      (let\n        ([t (\/ g (- v2 v1))])\n        (reverse (map\n          (\u03bb (f) (floor (f t)))\n          (stream-fold\n            (\u03bb (a g) `(,(compose g (car a)) ,@a))\n            `(,identity)\n            (stream-take\n              (sequence->stream\n                (in-cycle `(,(\u03bb (x) (* 60 (- x (floor x)))))))\n              2)))))\n      (list -1 -1 -1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290114,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (race v1 v2 g)\n  (define (f x) (* 60 (- x (floor x))))\n  (if (< v1 v2)\n      (let ([t (\/ g (- v2 v1))])\n           `(\n             ,(floor t)\n             ,(floor (f t))\n             ,(floor (f (f t)))))\n      (list -1 -1 -1)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290115,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (hours->list origin-hours); eg. 1.857 hours\n  (let* ([hours (floor origin-hours)];1\n         [origin-minutes (* (- origin-hours hours) 60)];0.857*60=51.42\n         [minutes (floor origin-minutes)];51\n         [origin-seconds (* (- origin-minutes minutes) 60)];0.42*60=25.2\n         [seconds (floor origin-seconds)]);25\n    (list hours minutes seconds)))\n\n(define (race v1 v2 g)\n  (if (< v1 v2)\n      (hours->list (\/ g (- v2 v1)))\n      (list -1 -1 -1)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290116,"user_id":null,"body":"#lang racket\n(provide race)\n\n; race : Number Number Number -> List(Number)\n(define (race v1 v2 g)\n  (cond [(or (>= v1 v2) (<= v1 0) (<= v2 0)) (list -1 -1 -1)]\n        [else (decToHour (\/ g (- v2 v1)) 0)]))\n\n; decToHour : Number -> List(Number)\n; It converts a decimal number into hours returning the\n; hours as a list as follows:\n; t = 0. [hours, minutes, seconds]\n; t = 1. [hours, minutes];\n; t = 2. [hours]\n(define (decToHour n t)\n  (cond [(>= t 3) (list -1 -1 -1)]\n        [else (cons (floor n) (decToHour (* (- n (floor n)) 60) (+ t 1)))]))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290117,"user_id":544,"body":"#lang racket\n(provide race)\n\n(define (race v1 v2 g)\n  (cond [(v1 . >= . v2) (list -1 -1 -1)]\n        [else (let* ([h (\/ g (- v2 v1))]\n                     [m (* (- h (truncate h)) 60)]\n                     [s (* (- m (truncate m)) 60)])\n                (map exact-floor (list h m s)))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290118,"user_id":null,"body":"#lang racket\n(provide race)\n\n(define (race v1 v2 g)\n  (if (>= v1 v2)\n      (list -1 -1 -1)\n      (let* ((diff (- v2 v1))\n             (hrs (\/ g diff))\n             (mins (* 60 (- hrs (floor hrs))))\n             (secs (* 60 (- mins (floor mins)))))\n        (list (floor hrs) (floor mins) (floor secs)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290119,"user_id":null,"body":"#lang racket\n\n(provide race)\n\n(module+ test\n  (require rackunit))\n\n;; Int>0 Int>0 Int>0 -> (or\/c (list -1 -1 -1) (List Int>=0 Int>=0 Int>=0))\n;; given the speed of A `v1` (in feet\/hour), the speed of B `v2` (in feet\/hour),\n;; and the lead of A `g` (in feet), return '(hours minutes seconds) it will take\n;; A to catch B, or (list -1 -1 -1) if that is impossible\n(define (race v1 v2 g)\n  (if (>= v1 v2)\n      (list -1 -1 -1)\n      (decimalh->hms (\/ g (- v2 v1)))))\n\n(module+ test\n  (check-equal? (race 720 850 70) '(0 32 18))\n  (check-equal? (race 82 81 550) (list -1 -1 -1))\n  (check-equal? (race 80 91 37) '(3 21 49)))\n\n\n;; Number -> (List Integer Integer Integer)\n;; convert decimal hours to '(hours, minutes, seconds), rounding down to the nearest sec.\n(define (decimalh->hms dh)\n  (define s-total (floor (* 3600 dh)))\n  (define-values (hours s-rem) (quotient\/remainder s-total 3600))\n  (define-values (mins secs) (quotient\/remainder s-rem 60))\n  `(,hours ,mins ,secs))\n\n(module+ test\n  (check-equal? (decimalh->hms (\/ 3662 3600)) '(1 1 2))) ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55e6f5e58f7817808e00002e":[{"id":290120,"user_id":564,"body":"#lang racket\n(provide seven)\n\n(define (seven n)\n  (define (sevenish n steps)\n    (if (< n 100)\n      (cons n steps)\n      (sevenish (- (quotient n 10) (* 2 (remainder n 10)))\n        (+ 1 steps))))\n  (sevenish n 0))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290121,"user_id":53,"body":"#lang racket\n(provide seven)\n\n(define (seven n)\n  (let loop ([cnt 0] [m n])\n    (if (< m 100)\n      (cons m cnt)\n      (loop (add1 cnt) (- (quotient m 10) (* 2 (modulo m 10)))))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290122,"user_id":492,"body":"#lang racket\n(provide seven)\n\n(define seven\n  (lambda (m [cnt 0])\n    (if (<= m 99)\n      (cons m cnt)\n      (let* ([a0 (remainder m 10)]\n             [n (- (\/ (- m a0) 10) (* 2 a0))])\n        (seven n (add1 cnt))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290123,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (get-numbers input)\n  (let ([rest (quotient input 10)]\n        [last (remainder input 10)])\n    (- rest (* last 2)))\n)\n\n(define (process numbers counter)\n  (if (< numbers 100) (cons numbers (+ counter 1)) (process (get-numbers numbers) (+ counter 1)))\n)\n\n(define (seven m)\n  (let ([number m]\n\t      [counter 0])\n    (if (< number 100) (cons number counter) (process (get-numbers number) counter)))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290124,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (seven m)\n  ; your code\n  (define (less m)\n    (let*\n      ([a (number->string m)]\n       [n (string-length a)]\n       [i (string->number (substring a 0 (sub1 n)))]\n       [j (string->number (substring a (sub1 n) n))])\n      (if (< 2 n)\n          (- i (* 2 j))\n          m)))\n  (define (sev m i)\n    (if (< 99 m)\n        (sev (less m) (add1 i))\n        (cons m i)))\n(sev m 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290125,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (sev n)\n  (if (< n 100)\n      n\n      (sev (- (quotient n 10) (* 2 (modulo n 10))))))\n(define (stps n)\n  (if (< n 100) 0\n      (+ 1 (stps ( - (quotient n 10) (* 2 (modulo n 10)))))))\n\n(define (seven n)\n  (cons (sev n) (stps n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290126,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (seven m)\n  ; your code\n  (define (seven-aux m steps)\n    (cond \n     [(< m 100) (cons m steps)]\n     [else (let* [(x (quotient m 10))\n                  (y (remainder m 10))\n                  (m (- x (* 2 y)))]\n             (seven-aux m (+ 1 steps)))]))\n  (seven-aux m 0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290127,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (seven m)\n  (let loop ([x m] [count 0])\n    (if (< x 100)\n        (cons x count)\n        (call-with-values (lambda () (quotient\/remainder x 10)) \n                          (lambda (q r)\n                                   (loop (- q (* 2 r)) (add1 count)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290128,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (seven x)\n  (define (seven-iter x cnt)\n    (cond ((< x 100) (cons x cnt))\n          (else (define-values (q r) (quotient\/remainder x 10))\n                (seven-iter (- q (* 2 r)) (add1 cnt)))))\n  (seven-iter x 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290129,"user_id":null,"body":"#lang racket\n(provide seven)\n\n(define (seven m)\n  (define (rec-helper m (acc 0))\n    (if (< m 100)\n        (cons m  acc)\n        (let ([last-digit (remainder m 10)] \n              [other-digits (exact-floor (\/ m 10))])\n          (rec-helper (- other-digits (* 2 last-digit)) (add1 acc)))))\n  (rec-helper m))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55e7280b40e1c4a06d0000aa":[{"id":290130,"user_id":492,"body":"#lang racket\n(provide choose_best_sum)\n\n(define (choose_best_sum t k ls)\n  (let ([r (filter (\u03bb(x) (<= x t)) (map (lambda(x) (apply + x)) (combinations ls k)))])\n    (if (empty? r)\n    -1\n    (apply max r))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290131,"user_id":null,"body":"#lang racket\n(provide choose_best_sum)\n\n(define (choose_best_sum t k ls)\n  (define sums (for\/list ([l (in-combinations ls k)])\n                 (apply + l)))\n  (define choices (filter (\u03bb (x) (<= x t)) sums))\n  (if (null? choices) -1 (apply max choices)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290132,"user_id":168,"body":"#lang racket\n(provide choose_best_sum)\n\n(define (choose_best_sum t k ls)\n  (define xs (filter (lambda (x) (<= x t)) \n                     (map (lambda (xs) (apply + xs)) \n                          (combinations ls k))))\n  (if (null? xs) -1 (apply max xs)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290133,"user_id":544,"body":"#lang racket\n(provide choose_best_sum)\n\n(define (choose_best_sum t k ls)\n  (define distance-candidates\n    (for\/list ([distance (sequence-map (curry apply +) (in-combinations ls k))] \n               #:when (distance . <= . t)) \n              distance))\n  (if (empty? distance-candidates) -1 (apply max distance-candidates)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290134,"user_id":544,"body":"#lang racket\n(provide choose_best_sum)\n\n(define (choose_best_sum t k ls)\n  (define distance-candidates\n    (for\/list ([towns (in-combinations ls k)] \n               #:when ((apply + towns) . <= . t)) \n              (apply + towns)))\n  (if (empty? distance-candidates) \n      -1\n      (apply max distance-candidates)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290135,"user_id":null,"body":"#lang racket\n(provide choose_best_sum)\n(require rackunit)\n\n(define sum (curry foldl + 0))\n(define (choose_best_sum limit towns distances)\n  (let* ([allowed? (curryr <= limit)]\n         [distances (in-combinations distances towns)]\n         [total-distances (sequence-map sum distances)]\n         [results (sequence->list (sequence-filter allowed? total-distances))])\n    (if (empty? results)\n        -1\n        (apply max results))))\n\n(check-equal?\n (choose_best_sum 174 3 '(50 55 57 58 60))\n 173)\n(check-equal?\n (choose_best_sum 163 3 '(50 55 56 57 58))\n 163)\n(check-equal?\n (choose_best_sum 163 3 '(50))\n -1)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290136,"user_id":null,"body":"#lang racket\n\n(provide choose_best_sum)\n\n(struct work (current remain))\n\n(define (bst task task-f calc-f result)\n  (if (null? task) result\n      (let* ([w (car task)]\n            [remain-task (append (task-f w) (cdr task))])\n        (bst remain-task task-f calc-f (calc-f w result)))))\n\n(define (meta-calc-f limit-dist k)\n  (define (calc-f w result)\n    (let* ([current (work-current w)]\n           [dist-sum (apply + current)])\n      (if (and (<= dist-sum limit-dist)\n               (= (length current) k))\n          (max result dist-sum)\n          result)))\n  calc-f)\n\n(define (meta-task-f k)\n  (define (task-f w)\n    (define (inner current remain result)\n      (if (null? remain) result\n          (let* ([next-current (cons (car remain) current)]\n                 [remain (cdr remain)]\n                 [next-remain (if (>= (length next-current) k) (list) remain)])\n          (inner current remain (cons (work next-current next-remain) result)))))\n    (inner (work-current w) (work-remain w) (list)))\n  task-f)\n\n(define (choose_best_sum t k ls)\n  (let ([result\n         (bst (list (work (list) ls)) (meta-task-f k) (meta-calc-f t k) -1)])\n    (if (= result -1) null result)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290137,"user_id":null,"body":"#lang racket\n\n(provide choose_best_sum)\n\n;; utils\n;; see https:\/\/rosettacode.org\/wiki\/Combinations\n(define sublists\n  (match-lambda**\n   [(0 _)           '(())]\n   [(_ -1)         -1]\n   [(m (cons x xs)) (append (map (curry cons x) (sublists (- m 1) xs)) \n                            (sublists m xs))]))\n \n(define (combinations n m)\n  (sublists n m))\n\n;; Integer>=0 Integer>=1 (Listof>=1 Integer>=0) -> (or Integer -1)\n;; given maximum sum of distances allowed, number of towns to visit and a list\n;; of distances, return the \"best\" sum i.e. the biggest possible sum\n;; of k distances <= t, if that sum exists, otherwise -1.\n(define (choose_best_sum t k ls)\n  (define choices (combinations k ls))\n  (define sums\n    (filter (\u03bb (s) (<= s t))\n            (map (\u03bb (ds) (apply + ds)) choices)))\n  (if (empty? sums) -1 (apply max sums)))\n\n;; Best conceivable runtime: O() ?\n;; Actual runtime: O() ?","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290138,"user_id":527,"body":"#lang racket\n(provide choose_best_sum)\n\n(define (choose_best_sum t k ls)\n  (for*\/fold ([max-d -1]\n              #:result (if (>= max-d 0) max-d null))\n             ([ds (in-combinations ls k)]\n              [d (in-value (apply + ds))]\n              #:when (<= d t))\n    (max max-d d)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55e86e212fce2aae75000060":[{"id":290139,"user_id":492,"body":"#lang racket\n(provide prod-2-sum)\n\n(define (prod-2-sum a b c d)\n  (define (sort-by-car ls) (sort ls < #:key car))\n  (let ([e1 (abs (+ (* a c) (* b d)))]\n        [f1 (abs (- (* a d) (* b c)))]\n        [e2 (abs (- (* a c) (* b d)))]\n        [f2 (abs (+ (* a d) (* b c)))]        \n        )\n    (cond\n      [(or (and (= e1 f2) (= f1 e2)) (and (= e1 e2) (= f1 f2))) \n       (list (cons (min e1 f1) (max e1 f1)))]\n      [else \n       (sort-by-car (list (cons (min e1 f1) (max e1 f1)) (cons (min e2 f2) (max e2 f2))))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290140,"user_id":492,"body":"#lang racket\n(provide prod-2-sum)\n\n(define (prod-2-sum a b c d)\n  (define (sort-by-car ls) (sort ls < #:key car))\n  (let ([e1 (abs (+ (* a c) (* b d)))]\n        [f1 (abs (- (* a d) (* b c)))]\n        [e2 (abs (- (* a c) (* b d)))]\n        [f2 (abs (+ (* a d) (* b c)))]        \n        )\n    (cond\n      [(or (and (= e1 f2) (= f1 e2)) (and (= e1 e2) (= f1 f2))) \n       (list (cons (min e1 f1) (max e1 f1)))]\n      [else \n       (sort-by-car (list (cons (min e1 f1) (max e1 f1)) (cons (min e2 f2) (max e2 f2))))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290141,"user_id":373,"body":"#lang racket\n(provide prod-2-sum)\n\n(define (prod-2-sum a b c d)\n  ; your code\n  (let*\n    ([p (+ (* a c) (* b d))]\n     [q (- (* a d) (* b c))]\n     [r (+ (* a d) (* b c))]\n     [s (- (* a c) (* b d))]\n     [pp (min (abs p) (abs q))]\n     [qq (max (abs p) (abs q))]\n     [rr (min (abs r) (abs s))]\n     [ss (max (abs r) (abs s))])\n    (cond [(= pp rr) (list (cons pp qq))]\n          [(< pp rr) (list (cons pp qq) (cons rr ss))]\n          [else (list (cons rr ss) (cons pp qq))])))\n        ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290142,"user_id":null,"body":"#lang racket\n(provide prod-2-sum)\n\n;; Integer Integer Integer Integer -> (listOf (pairOf Integer))\n(define (prod-2-sum a b c d)\n (remove-duplicates (sort (sort-pairs (construct-pairs a b c d)) < #:key car)))\n\n;; Integer Integer Integer Integer -> (listOf (pairOf Integer))\n(define (construct-pairs a b c d)\n  (list (cons (abs (+ (* a c) (* b d))) (abs (- (* a d) (* b c))))\n        (cons (abs (+ (* a d) (* b c))) (abs (- (* a c) (* b d))))))\n\n;; (listOf (pairOf Integer) -> (listOf (pairOf Integer)\n(define (sort-pairs lop)\n  (map (lambda (x) (if (< (car x) (cdr x)) x (cons (cdr x) (car x)))) lop))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55eca815d0d20962e1000106":[{"id":290143,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (range start (add1 end) step)) \n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290144,"user_id":53,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (stream->list (in-inclusive-range start end step))) \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290145,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (if (> start end)\n    empty\n    (cons start (generate_range (+ start step) end step))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290146,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define generate_range inclusive-range) \n  \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290147,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (inclusive-range start end step))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290148,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (define (iter s r)\n    (if (> s end)\n        r\n        (iter (+ s step) (cons s r))))\n  (reverse (iter start '())))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290149,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (if (> start end) \n      '()\n      (cons start (generate_range (+ start step) end step)))) \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290150,"user_id":168,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (range start (+ 1 end) step) )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290151,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range start end step)\n  (cond [(< end start) '()]\n        [else (cons start\n                    (generate_range (+ start step) end step))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290152,"user_id":null,"body":"#lang racket\n\n(provide generate_range)\n\n(define (generate_range a b k) (build-list (add1 (quotient (- b a) k)) (lambda (i) (+ a (* i k)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55edaba99da3a9c84000003b":[{"id":290153,"user_id":564,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter\n    (lambda (n) (= 0 (remainder n divisor)))\n    numbers\n  ))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290154,"user_id":527,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (lambda (n) (zero? (remainder n divisor))) numbers))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290155,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (\u03bb (n) (zero? (remainder n divisor))) numbers))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290156,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (compose zero? (curryr remainder divisor))\n          numbers))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290157,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (lambda (number) (= (modulo number divisor) 0)) numbers))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290158,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (lambda (x) (equal? 0 (modulo x divisor))) numbers))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290159,"user_id":53,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (lambda (x) (= 0 (modulo x divisor))) numbers))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290160,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (\u03bb (d) (zero? (modulo d divisor))) numbers))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290161,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n;; (Listof Int) Int -> (Listof Int)\n;; return numbers which are divisable by `divisor`\n(define (divisible_by numbers divisor)\n  (for\/list ([n (in-list numbers)]\n             #:when (zero? (remainder n divisor)))\n    n))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290162,"user_id":null,"body":"#lang racket\n\n(provide divisible_by)\n\n(define (divisible_by numbers divisor)\n  (filter (compose zero? (curryr modulo divisor)) numbers))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55f3da49e83ca1ddae0000ad":[{"id":290163,"user_id":53,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (let* ([n (* 2.0 (acos (- 1.0 (\/ h (\/ d 2.0)))))]\n         [m (\/ (* vt (- n (sin n))) (* 2.0 pi))])\n    (exact-floor m)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290164,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (define ang (* 2 (acos (- 1 (\/ h (\/ d 2))))))\n  (let ([factor (\/ (- ang (sin ang)) (* 2 pi))])\n    (inexact->exact (floor (* factor vt))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290165,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (sector-area r h)\n  (let ([circle-area (* pi r r)]\n        [sector-angle (* 2 (acos (\/ (- r h) r)))])\n    (* circle-area (\/ sector-angle (* 2 pi)))))\n\n(define (segment-length r h)\n  (* 2\n     (sqrt (- (* r r)\n              (expt (- r h) 2)))))\n  \n(define (segment-area r h)\n  (let ([s (sector-area r h)]\n        [t (\/ (* (- r h) (segment-length r h)) 2)])\n    (- s t)))\n\n(define (tank-vol h d vt)\n  (let* ([r (\/ d 2)]\n        [l (\/ vt (* pi r r))]\n        [a (segment-area r h)])\n    (exact-floor (* a l))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290166,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (define c (- 1 (\/ h d .5)))\n  (exact-floor (*\n    (\/ vt pi)\n    (- (acos c) (* c (sqrt (- 1 (* c c))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290167,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (exact-floor (* (\/ vt pi)\n    (let ([c (- 1 (\/ h d .5))])\n      (- (acos c) (* c (sqrt (- 1 (* c c)))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290168,"user_id":null,"body":"#lang racket\/base\n(require racket\/math)\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (let* ([r (\/ d 2)]\n         [tank-area (* r r pi)]\n         [nh (\/ h r)]\n         [ho (- 1 nh)]\n         [angle (acos ho)]\n         [width (* 2 r (sin angle))]\n         [tri-area (* 1\/2 width (* ho r))]\n         [angle-area (* 2 angle 1\/2 r r)]\n         [fluid-area (- angle-area tri-area)]\n         [volume (* (\/ fluid-area tank-area) vt)])\n    (inexact->exact (truncate volume))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290169,"user_id":544,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (define r (\/ d 2)) ; just cribbed the formula in terms of R out of an engineering handbook\n  (define segment-area\n    (- (* (expt r 2) (acos (\/ (- r h) r))) (* (- r h) (sqrt (- (* 2 r h) (* h h))))))\n  (exact-floor (* vt (\/ segment-area (* pi r r)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290170,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (define r (\/ d 2))\n  (define th (acos (\/ (- r h) \n                      r)))\n  (exact-floor (\/ (* vt \n                     (- th (* 0.5 \n                              (sin (* th 2))))) \n                3.14159265358979323846))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290171,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (tank-vol h d vt)\n  (let* ([r (\/ d 2)]\n         [S (* pi (sqr r))]\n         [l (\/ vt S)]\n         [\u03b8 (acos (\/ (- r h) r))]\n         [d (* (sin \u03b8) r)]\n         [s (- (* S (\/ \u03b8 pi)) (* d (- r h)))])\n    (exact-floor (* s l))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290172,"user_id":null,"body":"#lang racket\n(provide tank-vol)\n\n(define (sector-angle h r)\n  ;; What's the sector angle (radians) given a chord\n  ;; perpendicular distance from circumference and radius?\n  (* 2 (acos (\/ (- r h) r))))\n  \n(define (sector-area r angle)\n  (* (\/ angle\n        (* 2 pi))\n     (* pi r r)))\n\n(define (sector-triangle-area r vh angle)\n  (let ([base (* 2 (sin (\/ angle 2)) r)])\n    (* base vh 0.5)))\n\n(define (segment-area h r)\n  ;; What's the area created by the chord, which is\n  ;; at a perpendicular distance of h from circumference?\n  (- (sector-area r (sector-angle h r))\n     (sector-triangle-area r (- r h) (sector-angle h r))))\n\n(define (tank-vol h d vt)\n  (let ([r (\/ d 2)])\n    (exact-floor (* vt\n                 (\/ (segment-area h r)\n                    (* pi r r))))\n  ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55f73be6e12baaa5900000d4":[{"id":290173,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n(define goals +)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-02 20:19:34"},{"id":290174,"user_id":168,"body":"#lang racket\n\n(provide goals)\n\n(define (goals a b c) (+ a b c))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290175,"user_id":527,"body":"#lang racket\n\n(provide goals)\n\n(define (goals . ns)\n  (apply + ns))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290176,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n(define (goals . leagues)\n  (apply + leagues))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290177,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n(define (goals ll cdr cl)\n  (+ ll (+ cdr cl)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290178,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n(define (goals la-liga-goals copa-del-rey-goals champions-league-goals)\n  (foldl + 0 (list la-liga-goals copa-del-rey-goals champions-league-goals)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290179,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n(define (goals x y z) (+ x (+ y z)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290180,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n(define (goals la-liga-goals copa-del-rey-goals champions-league-goals)\n  (apply + (list la-liga-goals copa-del-rey-goals champions-league-goals)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290181,"user_id":53,"body":"#lang racket\n(provide goals)\n(define (goals a b c) (+ a (+ b c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290182,"user_id":null,"body":"#lang racket\n\n(provide goals)\n\n;;; I'm weirded out by this. Something I'm missing?\n(define goals +)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55f9bca8ecaa9eac7100004a":[{"id":290183,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (* 1000\n     (+ s\n        (* m 60)\n        (* h 3600))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290184,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (+ (* h 60 60 1000) (* m 60 1000) (* s 1000)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290185,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (* 1000 (+ s (* 60 (+ m (* 60 h))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290186,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (+ (+ (* h 3600000) (* m 60000)) (* s 1000)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290187,"user_id":null,"body":"#lang racket\n\n(provide past)\n\n(define (past h m s)\n  (+ (* 3600 1000 h) (* 60 1000 m) (* 1000 s)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290188,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define second 1000)\n(define minute 60000)\n(define hour 3600000)\n\n; sig: num -> num\n; Purpose: convert input time to ms equivalent\n \n \n \n(define (past h m s)\n  #| your code here |#\n  (+ (* h hour) (* m minute) (* s second)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290189,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (* 1000 (+ s (* 60 (+ m (* h 60))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290190,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (* 1000 (+ s (* 60 m)(* 60 60 h)) ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290191,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (* (+ (* (+ (* h 60) m) 60 ) s) 1000))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290192,"user_id":null,"body":"#lang racket\n\n(provide past)\n \n(define (past h m s)\n  (* 1000 (+ s (* (+ m ( * h 60 ) )60))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"55fd2d567d94ac3bc9000064":[{"id":290193,"user_id":645,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (row_sum_odd_numbers n)\n  (expt n 3))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290194,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (row_sum_odd_numbers n)\n  (\/ (* (+ (+ (* n (- n 1)) 1) (- (* n (+ n 1)) 1)) n) 2)\n  #| your code here |#)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290195,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (row_sum_odd_numbers n)\n  #| your code here |#(* n (* n n)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290196,"user_id":null,"body":"#lang racket\n(provide row_sum_odd_numbers)\n\n(define (rowSum2 n numbers answer)\n    (if (= n 0) answer \n      (rowSum2 (- n 1) (- numbers 1) \n\t(+ answer (+ 1 (* 2 (- numbers 1))))))\n)\n\n(define (row_sum_odd_numbers n)\n    (let ([numbers (* (+ n 1) (\/ n 2))])\n      (rowSum2 n numbers 0))\n) ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290197,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (triangle-addition start count)\n  (cond\n\t((<= count 0) 0)\n\t(else (+ start (triangle-addition (+ start 2) (- count 1))))))\n\n(define (row_sum_odd_numbers n)\n  (let lp\n\t((start 1)\n\t (count 1))\n\t(cond\n\t  ((equal? count n) (triangle-addition start count))\n\t  (else (lp (+ start (* 2 count)) (+ count 1))))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290198,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (row_sum_odd_numbers n)\n  (for\/sum ([i (in-range (first n) (first (add1 n)) 2)])\n    i))\n\n(define (first x)\n  (+ 1 (* x (- x 1))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290199,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (row_sum_odd_numbers n)\n  (define sum 0)\n  (for ([i (in-range (first n) (first (add1 n)))])\n    (when (= (remainder i 2) 1)\n       (set! sum (+ sum i))))\n  sum)\n\n(define (first x)\n  (+ 1 (* x (- x 1))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290200,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n; Identical logic in Clojure causes a time-out error for me\n; but in Racket it passes in less than 2 seconds\n(define (row_sum_odd_numbers row-num)\n  (let* ([n (apply + (sequence->list (in-range 1 row-num)))]\n         [start (+ (* 2 n) 1)]\n         [stop (+ (* 2 (+ n row-num)))])\n    (apply + (sequence->list (in-range start stop 2)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290201,"user_id":544,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n; by inspection, the nth row adds up to n^3:\n; 1^3 = 1\n; 2^3 = 8 = 3 + 5\n; 3^3 = 27 = 7 + 9 + 11\n; and so forth\n(define (row_sum_odd_numbers n)\n  (expt n 3))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290202,"user_id":null,"body":"#lang racket\n\n(provide row_sum_odd_numbers)\n\n(define (row_sum_odd_numbers n)\n  (define start (for\/sum ([x (in-range 1 n)]) x))\n  (define end (+ n start))\n  (foldr + 0 (range (+ 1 (* 2 start)) (+ 1 (* 2 end)) 2)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5601409514fc93442500010b":[{"id":290203,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (better_than_average class-scores my-score)\n  (> my-score (mean class-scores)))\n\n(define (mean l) (\/(sum l)(length l)))\n\n(define (sum l) (foldl + 0 l))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290204,"user_id":53,"body":"#lang racket\n(provide better_than_average)\n(define (mean lst) (\/ (foldl + 0 lst) (length lst)))\n(define (better_than_average xs x) (> x (mean xs)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290205,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (average numbers)\n  (\/ (foldr + 0 numbers) (length numbers)))\n\n(define (better_than_average class-scores my-score)\n  (< (average class-scores) my-score))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290206,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (better_than_average class-scores my-score)\n  (> my-score (\/ (foldl + my-score class-scores)\n                 (+ 1 (length class-scores)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290207,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (better_than_average class-scores my-score)\n  (define sum (apply + class-scores))\n  (define my-length (length class-scores))\n  (define avg (\/ sum my-length))\n  (> my-score avg))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290208,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (better_than_average class-scores my-score)\n (define (sum-list lst my-score)\n    (+ (apply + lst) my-score))\n  (define (count-list lst)\n    (define (iter lst cnt)\n      (if (null? lst)\n          cnt\n          (iter (cdr lst) (+ 1 cnt))))\n    (iter lst 0))\n  (define (average sum cnt)\n    (\/ sum cnt))\n  (> my-score\n     (average (sum-list class-scores my-score) (+ 1 (count-list class-scores)))) )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290209,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (total-scores lt my-score) \n  (+ my-score (apply + lt)))\n\n(define (average lt my-score) \n  (\/ (total-scores lt my-score) (+ 1 (length lt))))\n\n(define (better_than_average class-scores my-score)\n    (if (> my-score (average class-scores my-score)) #t #f))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290210,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (average ns)\n  (\/ (foldr + 0 ns) (length ns)))\n\n(define (better_than_average class-scores my-score)\n  (define total-scores (cons my-score class-scores))\n  (> my-score (average total-scores)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290211,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (better_than_average class-scores my-score)\n  (> my-score (\/ (+ (for\/sum ([i class-scores]) i) my-score) (+ (length class-scores) 1) ) ) )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290212,"user_id":null,"body":"#lang racket\n\n(provide better_than_average)\n\n(define (better_than_average class-scores my-score)\n  (define scores (cons my-score class-scores))\n  (define sum (apply + scores))\n  (define avg (\/ sum (length scores)))\n  (> my-score avg))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5613d06cee1e7da6d5000055":[{"id":290213,"user_id":53,"body":"#lang racket\n(provide step)\n\n(define (is-prime? n)\n  (define (aux i)\n    (cond \n      [(> (* i i) n) #t]\n      [(or (zero? (modulo n i)) (zero? (modulo n (+ i 2)))) #f]\n      [else (aux (+ i 6))]))\n  (cond\n    [(or (zero? (modulo n 2)) (zero? (modulo n 3))) (< n 4)]\n    [else (aux 5)]))\n\n(define (step g m n)\n  (define (aux i)\n    (cond \n      [(>= i (- n g)) null]\n      [(and (is-prime? i) (is-prime? (+ i g))) (cons i (+ i g))]\n      [else (aux (add1 i))]))\n  (aux m))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290214,"user_id":492,"body":"#lang racket\n(provide step)\n\n(define (step g m n)\n  (define (prime? n)\n    (cond ( (< n 2) #f)\n          ( (= n 2) #t)\n          ( (even? n) #f)\n          (else\n           (let prime-test ( (d 3) )\n             (cond ( (> (sqr d) n) #t)\n                   ( (= 0 (remainder n d)) #f)\n                   (else (prime-test (+ d 2))))))))\n  (let loop ([i m][j (+ m g)])\n    (if (and (prime? i) (prime? j))\n        (cons i j)\n        (if (< j n)\n            (loop (add1 i) (add1 j))\n            null))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290215,"user_id":168,"body":"#lang racket\n(provide step)\n\n(define (is-prime n)\n  (for\/and ([d (in-range 2 (add1 (sqrt n)))])\n           (> (remainder n d) 0)))\n\n(define (step g m n)\n  (or (for\/first ([k (in-range m (add1 (- n g)))]\n                #:when (and (is-prime k) (is-prime (+ k g))))\n               (cons k (+ k g))) '()))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290216,"user_id":null,"body":"#lang racket\n\n(provide step)\n\n(define (prime? n) \n  (define (loop i) \n     (cond ((> i (sqrt n)) #t)\n           ((zero? (modulo n i)) #f)\n           (else (loop (add1 i)))))\n  (loop 2))\n\n(define (step step-size start end)\n  (define (loop i)\n   (let ((j (+ i step-size)))\n     (cond ((> j end) null)\n           ((and (prime? i) (prime? j)) (cons i j))\n           (else (loop (add1 i))))))\n  (loop start))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290217,"user_id":null,"body":"#lang racket\n(provide step)\n\n(define (prime? n)\n  (let loop ([i 2])\n    (cond ((> (* i i) n) #t)\n          ((zero? (remainder n i)) #f)\n          (else (loop (add1 i))))))\n\n(define (step g m n)\n  (let loop ([i m])\n    (cond ((> i n)\n           null)\n          ((and (prime? i) (prime? (+ i g)))\n           (cons i (+ i g)))\n          (else\n           (loop (+ i 1))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290218,"user_id":null,"body":"#lang racket\n(provide step)\n\n(define (step g m n)\n  (let ((n (find-first\n            (lambda (x) (and\n                         (prime? x)\n                         (prime? (+ x g))))\n            (range m (add1 (- n g))))))\n    (cond ((not n) '())\n          (else (cons n (+ n g))))))\n\n(define (find-first p xs)\n  (cond ((empty? xs) #f)\n        ((p (car xs)) (car xs))\n        (else (find-first p (cdr xs)))))\n\n(define (prime? x)\n  (=\n   0\n   (length\n    (filter\n     (lambda (n) (= 0 (modulo x n)))\n     (range 2 (add1 (sqrt x)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290219,"user_id":null,"body":"#lang racket\n(provide step)\n\n(define (step distance start end)\n  (let ([result (for\/first ([i (range start end)]\n                            #:when (and (prime? i)\n                                        (< (+ distance i) end)\n                                        (prime? (+ distance i))))\n                  (cons i (+ i distance)))])\n    (if result result null)))\n\n(define (prime? n)\n  (for\/and ([i (in-range 2 (add1 (sqrt n)))])\n    (not (zero? (modulo n i)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290220,"user_id":null,"body":"#lang racket\n(provide step)\n\n(define (is-prime n)\n  ;;(display (format \"testing if ~a is prime\n\" n))\n  (let\/ec return  \n          (when (< n 2) (return #f))\n          (when (= n 2) (return #t))\n          (when (zero? (modulo n 2)) (return #f))\n          (for ((m (in-range 3 (+ 1 (sqrt n)) 2)))\n               (when (zero? (modulo n m)) (return #f)))\n          #t))\n\n(define (step g m n)\n  (let\/ec return\n          (for ((x (in-range m n)))\n               (when (and (is-prime x)\n                          (is-prime (+ x g)))\n                     (return (cons x (+ x g)))))\n          '()))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290221,"user_id":null,"body":"#lang racket\n(provide step)\n\n(define (prime? n)\n  (cond\n    [(< n 2) #f]\n    [(= n 2) #t]\n    [(even? n) #f]\n    [else (let prime-test ([d 3])\n           (cond [(> (sqr d) n) #t]\n                 [(= 0 (remainder n d)) #f]\n                 [else (prime-test (+ d 2))]))]))\n\n(define (step step start end)\n  (or (for\/first ([i (range start (add1 (- end step)))]\n                  #:when (and (prime? i) (prime? (+ i step))))\n        (cons i (+ i step)))\n      null))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290222,"user_id":null,"body":"#lang racket\n(provide step)\n\n\n(define (esPrimoAux i n)\n  (cond\n    ;;((> i (\/ n 2)) #t)\n    ((> (sqr i)  n) #t)\n    ((zero? (modulo n i)) #f)\n    ((even? i) (esPrimoAux (+ i 1) n))\n    (else (esPrimoAux (+ i 2) n))\n    )\n  )\n\n(define (esPrimo n)\n  (if (even? n ) #f\n      (esPrimoAux 2 n)      \n      )\n  )\n\n(define (prime? n)\n    (cond ( (< n 2) #f)\n          ( (= n 2) #t)\n          ( (even? n) #f)\n          (else\n           (let prime-test ( (d 3) )\n\n             (cond ( (> (sqr d) n) #t)\n                   ( (= 0 (remainder n d)) #f)\n                   (else (prime-test (+ d 2))))))))\n\n; g = paso\n; m = inicio\n; n = fin\n(define (step g m n)  \n  (cond ((> (+ m g) n) null)\n        ((and (esPrimo m) (esPrimo (+ m g)))             \n         (cons m (+ m g) ))\n        (else (step g (+ m 1) n ))\n        )\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5616868c81a0f281e500005c":[{"id":290223,"user_id":null,"body":"#lang racket\n(provide rank)\n\n(define (score-name name)\n  (+ (string-length name) (foldr + 0 (map (lambda (c) (+ 1 (- (char->integer c) (char->integer #\\a)))) (string->list (string-downcase name))))))\n\n(define (rank st we n)\n  (define names (string-split st \",\"))\n  (cond [(= (length names) 0) \"No participants\"]\n        [(< (length names) n) \"Not enough participants\"]\n        [else\n         (define name-scores (map score-name names))\n         (define weighted-pairs (map (lambda (p) (* (car p) (cdr p))) (map cons we name-scores)))\n         (define names-and-ranks (sort (sort (map cons weighted-pairs names) (lambda (a b) (string<? (cdr a) (cdr b)))) (lambda (a b) (> (car a) (car b)))))\n         (cdr (list-ref names-and-ranks (- n 1)))]\n        ))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290224,"user_id":null,"body":"#lang racket\n(provide rank)\n\n(define (rank st we n)\n  (define fs (string-split st \",\"))\n  (cond\n    [(null? fs) \"No participants\"]\n    [(> n (length fs)) \"Not enough participants\"]\n    [#t\n     (cadr (list-ref\n       (sort\n         (for\/list\n           ([f fs]\n            [w we])\n           `(,(* w (apply -\n                (* 63 (string-length f))\n                (map char->integer (string->list (string-upcase f)))))\n             ,f))\n         (lambda (x y)\n           (or\n             (< (car x) (car y))\n             (and (= (car x) (car y)) (string-ci<? (cadr x) (cadr y))))))\n      (- n 1)))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290225,"user_id":null,"body":"#lang racket\n(provide rank)\n\n(define\/match (rank-of name-weight)\n  [((cons name weight))\n   (cons\n    (* weight\n       (for\/sum ([ch (string-foldcase name)])\n         (- (char->integer ch) (char->integer #\\a) -2)))\n    name)])\n\n(define (rank names weights n)\n  (let ([names (string-split names \",\")])\n    (cond\n      [(null? names) \"No participants\"]\n      [(> n (length names)) \"Not enough participants\"]\n      [#t\n       (car\n        (list-ref\n         (sort\n          (map cons names weights)\n          (match-lambda**\n           [((cons rank1 name1) (cons rank2 name2))\n            (if (= rank1 rank2)\n                (string-ci<? name1 name2)\n                (> rank1 rank2))])\n          #:key rank-of\n          #:cache-keys? #t)\n         (- n 1)))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290226,"user_id":544,"body":"#lang racket\n(provide rank)\n\n(define (char->prize-value c)\n  (cond [(char-upper-case? c) (- (char->integer c) 64)]\n        [else (- (char->integer c) 96)]))\n\n(define (calculate-base-number s)\n  (for\/fold ([base (string-length s)])\n            ([c (in-string s)])\n    (+ base (char->prize-value c))))\n\n(define (rank participants weights prize-rank)\n  (define participants-list (string-split participants \",\"))\n  (cond [(equal? participants \"\") \"No participants\"]\n        [(prize-rank . > . (length participants-list)) \"Not enough participants\"]\n        [else \n         (car\n          (list-ref\n           (sort (sort (map (\u03bb (n w)\n                              (list n (* (calculate-base-number n) w)))\n                            participants-list\n                            weights)\n                       string<?\n                       #:key car)\n                 >\n                 #:key cadr)\n           (sub1 prize-rank)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290227,"user_id":null,"body":"#lang racket\n(provide rank)\n\n\n(define (letter-value c)\n  (- (char->integer (char-upcase c)) 64))\n\n\n(define (name-value name)\n  (foldl (lambda (c sum)\n           (+ sum (letter-value c)))\n         0\n         (string->list name)))\n\n\n(define (winning-number name weight)\n  (* weight (+ (name-value name) (string-length name))))\n\n\n(define (get-winning-numbers names weights)\n  (for\/fold ([output (hash)])\n            ([name names]\n             [weight weights])\n    (hash-set output name (winning-number name weight))))\n\n\n(define (name0>? winning-numbers name0 name1)\n  (define nums (list (hash-ref winning-numbers name0)\n                     (hash-ref winning-numbers name1)))\n  (cond [(apply < nums) #f]\n        [(apply = nums) (string-ci<=? name0 name1)]\n        [(apply > nums) #t]))\n\n\n(define (get-ranked-list str weights n)\n  (let* ([names           (string-split str \",\")]\n         [winning-numbers (get-winning-numbers names weights)]\n         [name<? (curry name0>? winning-numbers)])\n    (if (< (length names) n)\n        \"Not enough participants\"\n        (sort names name<?))))\n\n\n(define (rank str weights n)\n  (if (zero? (string-length str))\n      \"No participants\"\n      (let ([result (get-ranked-list str weights n)])\n        (if (list? result)\n            (list-ref result (sub1 n))\n            result))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290228,"user_id":null,"body":"#lang racket\n(provide rank)\n\n(define (rank st we n)\n  ; your code\n  (define (name->som name)\n    (+ (string-length name)\n       (apply + (map (\u03bb (ch)\n                       (add1 (- (char->integer (char-downcase ch))\n                                (char->integer #\\a))))\n                     (string->list name)))))\n  (if (non-empty-string? st)\n      (let ((splited (string-split st \",\")))\n        (if (< (length splited) n)\n            \"Not enough participants\"\n            (let* ((pairs   (map (\u03bb (name weight)\n                                   `(,name ,(* weight (name->som name))))\n                                 splited\n                                 (take we (length splited))))\n                   (sorted  (sort pairs (\u03bb (left right)\n                                          (if (= (cadr left) (cadr right))\n                                              (string<? (car left) (car right))\n                                              (> (cadr left) (cadr right)))))))\n              (car (list-ref sorted (sub1 n))))))\n      \"No participants\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290229,"user_id":168,"body":"#lang racket\n(provide rank)\n\n(define (rank st we n)\n  (define (score name)\n    (for\/sum ([x (string-downcase name)])\n      (- (char->integer x) 95)))\n  (define (cmp x y)\n    (or (> (car x) (car y))\n      (and (= (car x) (car y))\n           (string<? (cdr x) (cdr y)))))\n  (define ps (string-split st \",\"))\n  (cond\n    [(empty? ps) \"No participants\"]\n    [(> n (length ps)) \"Not enough participants\"]\n    [else\n      (cdr (list-ref \n             (sort (map (lambda (x w) `(,(* w (score x)) . ,x)) \n                   ps we)\n                   cmp)\n           (sub1 n)))])\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290230,"user_id":null,"body":"#lang racket\n(provide rank)\n\n(define (rank st we n)\n  (define (som name)\n    (+ (string-length name)\n       (for\/sum ([c (in-string name)])\n         (- (char->integer c)\n            (if (char-upper-case? c) 64 96)))))\n  (define name-list (string-split st \",\"))\n  (cond [(string=? st \"\") \"No participants\"]\n        [(< (length name-list) n) \"Not enough participants\"]\n        [else (define name\/winning-number\n                (sort\n                  (for\/list ([weight (in-list we)]\n                             [name (in-list name-list)])\n                    (cons name (* (som name) weight)))\n                 (\u03bb (p q)\n                    (or (> (cdr p) (cdr q))\n                        (and (= (cdr p) (cdr q))\n                             (string<? (car p) (car q)))))))\n              (car (list-ref name\/winning-number (- n 1)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290231,"user_id":null,"body":"#lang racket\n(provide rank)\n(define (zip l1 l2) (map list l1 l2))\n(define (rank st we n)\n  (define (score x) (* (+ (string-length (car x))\n                          (foldl + 0 (map (lambda (c) (modulo (modulo (char->integer c) 96) 64)) (string->list (car x)))))\n                       (cadr x)))\n  (define (score>? a b) (> (score a) (score b)))\n  (cond [(empty? (string-split st \",\")) \"No participants\"]\n        [(> n (length (string-split st \",\"))) \"Not enough participants\"]\n        [else (let ([S (zip (string-split st \",\") we)])\n                (car (list-ref (sort (sort S string<? #:key car) score>?) (- n 1))))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290232,"user_id":492,"body":"#lang racket\n(provide rank)\n\n(define (rank st we n)\n  (define (score s w)\n    (let* ([ss (string->list (string-upcase s))]\n           [sc (+ (string-length s) (apply + (map (\u03bb(x) (- (char->integer x) 64)) ss)))])\n      (* sc w)))\n\n  (define (comp x y)\n    (let ([a1 (car x)] [b1 (car y)] [a2 (cdr x)] [b2 (cdr y)])\n      (if (= a2 b2)\n          (string<? a1 b1)\n          (> a2 b2))))\n\n  (define (nth-car lst idx)\n    (cond ((empty? lst) empty)\n          ((= idx 0) (car (first lst)))\n          (else (nth-car (rest lst) (sub1 idx)))))\n  \n  (if (equal? st \"\")\n      \"No participants\"\n      (let ([ls (string-split st \",\")])\n        (if (> n (length ls))\n            \"Not enough participants\"\n            (let loop ([i 0] [l ls] [wg we] [res '()])\n              (if (>= i (length ls))\n                  (nth-car (sort res comp) (sub1 n))\n                  (loop (add1 i) (cdr l) (cdr wg) (cons (cons (car l) (score (car l) (car wg))) res))\n                  ))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"561e9c843a2ef5a40c0000a4":[{"id":290233,"user_id":53,"body":"#lang racket\n(provide gap)\n\n(define (is-prime? n)\n  (define (aux i)\n    (cond \n      [(> (* i i) n) #t]\n      [(or (zero? (modulo n i)) (zero? (modulo n (+ i 2)))) #f]\n      [else (aux (+ i 6))]))\n  (cond\n    [(or (zero? (modulo n 2)) (zero? (modulo n 3))) (< n 4)]\n    [else (aux 5)]))\n\n(define (gap g m n)\n  (define (aux i a b)\n    (cond \n      [(> i (add1 n)) null]\n      [(and (> a 0) (> b 0) (= (- b a) g)) (cons a b)]\n      [(is-prime? i) (aux (add1 i) b i)]\n      [else (aux (add1 i) a b)]))\n  (aux m 0 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290234,"user_id":492,"body":"#lang racket\n(provide gap)\n\n(define (gap g m n)\n  (define (find-prime k end)\n    (define (prime? n)\n      (cond ( (< n 2) #f)\n            ( (= n 2) #t)\n            ( (even? n) #f)\n            (else\n             (let prime-test ( (d 3) )\n               (cond ( (> (sqr d) n) #t)\n                     ( (= 0 (remainder n d)) #f)\n                     (else (prime-test (+ d 2))))))))\n    (if (>= k (add1 end))\n        -1\n        (if (prime? k)\n            k\n            (find-prime (add1 k) end))))\n  \n  (define (search i g end)\n    (let ([k i])\n      (if (>= k (add1 end))\n          null\n          (let ([p (find-prime (add1 k) end)])\n            (if (= p -1)\n                null\n                (if (= p (+ i g))\n                    (cons i p)\n                    (search p g end)))))))\n  \n  (let ([i (find-prime m n)])\n    (if (= i -1)\n        null\n        (search i g n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290235,"user_id":null,"body":"#lang racket\n(provide gap)\n\n(define (prime? n)\n  (for\/and ([i (in-range 2 (add1 (sqrt n)))])\n           (positive? (remainder n i))))\n\n(define (gap g m n)\n  (let loop ([i m])\n    (cond ((> i n)\n           null)\n          ((and (prime? i)\n                (prime? (+ i g))\n                (for\/and ([j (in-range (+ i 1) (+ i g))])\n                         (not (prime? j))))\n           (cons i (+ i g)))\n          (else\n           (loop (add1 i))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290236,"user_id":168,"body":"#lang racket\n(provide gap)\n\n(define (odd-prime? n)\n  (for\/and ([d (range 3 (add1 (sqrt n)) 2)])\n           (not (zero? (remainder n d)))))\n\n(define (gap g m n)\n  (for\/fold ([a #f] [b #f]\n             #:result (if (and a b (= (- b a) g)) (cons a b) '()))\n            ([i (range (bitwise-ior m 1) (add1 n) 2)]\n              #:when (odd-prime? i))\n            #:break (and a b (= (- b a) g))\n            (values b i)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290237,"user_id":null,"body":"#lang racket\n(provide gap)\n\n(define (prime? n)\n  (cond\n    [(< n 2) #f]\n    [(= n 2) #t]\n    [(even? n) #f]\n    [else (let prime-test ([d 3])\n           (cond [(> (sqr d) n) #t]\n                 [(= 0 (remainder n d)) #f]\n                 [else (prime-test (+ d 2))]))]))\n\n(define (gap step start end)\n  (or (for\/first ([i (range start (add1 (- end step)))]\n                  #:when (and (prime? i)\n                              (prime? (+ i step))\n                              (andmap (compose not prime?) (range (add1 i) (sub1 (+ i step))))))\n        (cons i (+ i step)))\n      null))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290238,"user_id":null,"body":"#lang racket\n(provide gap)\n\n;; Determine if a number is prime\n(define (prime? n)\n  (define (f n c)\n    (cond [(< n (* c c)) #t]\n          [(zero? (modulo n c)) #f]\n          [else (f n (add1 c))]))\n  (f n 2))\n\n;; remove the last element in a NE-List\n(define (remove-last lst)\n  (define (do-remove l)\n    (if (null? (cdr l))\n        null\n        (cons (car l) (do-remove (cdr l)))))\n  (if (> (length lst) 1) (do-remove lst) null))\n\n;; Check to see if the gap in primes matches\n(define (gap? g m n)\n  (let ([gap (- n m)])\n    (if (equal? gap g)\n        (cons m n)\n        #f)))\n\n;; Generate list of prime and make two offset lists to search gap\n(define (gap g m n)\n  ;; (displayln (format \"g:~a m:~a n:~a\" g m n))\n  (let* ([all-primes (filter prime? (range m (add1 n)))]\n         [init-p (remove-last all-primes)]\n         [offset-p (if (> (length all-primes) 1) (cdr all-primes) null)]\n         [answer (ormap (lambda (x y) (gap? g x y)) init-p offset-p)])\n    (if answer answer null)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290239,"user_id":null,"body":"#lang racket\n(provide gap)\n\n(define (prime? n)\n  (define sqrtn (sqrt n))\n  (or (= n 2)\n      (= n 3)\n      (let ([nmod6 (modulo n 6)])\n      (and (> n 1)\n           (or (= nmod6 1)\n               (= nmod6 5))\n           (let loop ([divisor 3])\n             (cond\n               [(> divisor sqrtn) #t]\n               [(zero? (remainder n divisor)) #f]\n               [else (loop (+ divisor 2))]))))))\n\n(define (next-prime-between m n)\n  (let loop ([i (add1 m)])\n    (cond\n      [(> i n) 'none]\n      [(prime? i) i]\n      [else (loop (add1 i))])))\n\n(define (gap g m n)\n  (define next-prime (next-prime-between m n))\n  (cond\n    [(eq? next-prime 'none) '()]\n    [(> m n) '()]\n    [(not (prime? m)) (gap g (add1 m) n)]\n    [(= (- next-prime m) g)\n     (cons m next-prime)]\n    [else (gap g next-prime n)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290240,"user_id":null,"body":"#lang racket\n(provide gap)\n\n\n(define gap\n  (\u03bb (g m n)\n    (define gap-iter\n      (\u03bb (g m n)\n        (define prime?\n          (\u03bb (num)\n            (cond ((not (or (<= num 3)\n                            (integer? (\/ (add1 num) 6))\n                            (integer? (\/ (sub1 num) 6))))\n                   #f)\n                  ((findf\n                    (\u03bb (i) (or (= 0 (remainder num i))\n                               (= 0 (remainder num (+ i 2)))))\n                    (stream->list (in-range 5 (add1 (sqrt num)) 6)))\n                   #f)\n                  (else #t))))\n\n        (define closest-prime\n          (\u03bb (num)\n            (cond ((prime? num) num)\n                  (else (closest-prime (add1 num))))))\n\n        (define next-prime\n          (\u03bb (num)\n            (closest-prime (add1 num))))\n\n\n        (let loop ((p (closest-prime m)))\n          (if (> g (- n p))\n              '()\n              (let ((q (next-prime p)))\n                (if (= q (+ p g))\n                    (cons p q)\n                    (loop q)))))))\n\n\n    (if (> g (- n m))\n        '()\n        (gap-iter g m n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"562e274ceca15ca6e70000d3":[{"id":290241,"user_id":null,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (define (f x) (* x x))\n  (define dx (\/ 1 n))\n  (define (distance x1 x2)\n    (sqrt (+ (sqr (- x1 x2))\n             (sqr (- (f x1) (f x2))))))\n  (let loop ([x 0] [r 0])\n    (define next-x (+ x dx))\n    (if (= x 1) r\n        (loop next-x (+ r (distance x next-x))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290242,"user_id":null,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (let* ([a 0]\n         [b 1]\n         [\u0394x (\/ (- b a) n)])\n    (define (f x) (* x x))\n    (define (hyp x y)\n      (let ([\u0394y (- (f y) (f x))])\n        (sqrt (+ (sqr \u0394x) (sqr \u0394y)))))\n    (for\/sum ([i n])\n      (let ([xi (* \u0394x i)]\n            [xf (* \u0394x (add1 i))])\n        (hyp (+ a xi) (+ a xf))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290243,"user_id":null,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (\/ (truncate (* \n                (for\/sum ([x1 (range 0 1 (\/ 1 n))])\n                  (let* ([x2 (+ x1 (\/ 1 n))])\n                    (sqrt (+ (sqr (- x2 x1)) (sqr (- (sqr x2) (sqr x1)))))))\n                1e9)) 1e9))\n   ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290244,"user_id":null,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (let ([sqrt2  (sqrt 2)])\n    (if (= n 1)\n        sqrt2\n        (sum (sub-lengths n)))))\n\n(define (sum sub-lengths)\n  (apply + sub-lengths))\n\n(define (hypotenuse a b)\n  (sqrt (Pythagoras a b)))\n\n(define (Pythagoras a b)\n  (let ([c (+ (* a a) (* b b))])\n   c))\n\n(define (sub-lengths n)\n  (let ([1\/n (\/ 1 n)])\n    (define (aux prev next lst)\n        (if (> next 1)\n            lst\n            (aux (+ prev 1\/n) (+ next 1\/n) (cons (hypotenuse 1\/n (- (f prev) (f next))) lst))))\n    (aux 0 1\/n '())))\n\n(define (f x)\n  (* x x))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290245,"user_id":544,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (define intervals (range 0 (+ 1 (\/ 1 n)) (\/ 1 n)))\n  (define coords (map (\u03bb (x) (list x (* x x))) intervals))\n  (for\/sum ([p1 (in-list coords)]\n            [p2 (in-list (cdr coords))])\n    (sqrt (+ (expt (- (first p2) (first p1)) 2)\n             (expt (- (second p2) (second p1)) 2)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290246,"user_id":168,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (define h (\/ 1 n))\n  (* h (for\/sum ([i (range n)])\n          (let ([x (\/ i n)])\n            (sqrt (add1 (sqr (+ h (* 2 x)))))))\n     ))\n      \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290247,"user_id":null,"body":"#lang racket\n(provide len-curve)\n\n(define (distance start end)\n  (let ([side1 (- (first end) (first start))]\n        [side2 (- (last end) (last start))])\n          (sqrt (+ (sqr side1) (sqr side2)))))\n\n\n(define (len-curve n)\n  (for\/sum ([point1 (in-range 0 1 (\/ 1 n))])\n            (let ([point2 (+ point1 (\/ 1 n))])\n              (distance (list point1 (sqr point1)) (list point2 (sqr point2))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290248,"user_id":null,"body":"#lang racket\n(provide len-curve)\n\n(define-struct point (x y)  #:transparent)\n\n(define (round-to x places)\n  (define factor (expt 10 places))\n  (\/ (floor (* x factor)) factor))\n\n(define (parabolic x)\n  (* x x))\n\n(define (distance start end)\n  (let ([side1 (- (point-x end) (point-x start))]\n        [side2 (- (point-y end) (point-y start))])\n  (sqrt (+ (sqr side1) (sqr side2)))))\n\n\n(define (len-curve n [places 9])\n  (let* ([intervals (append (for\/list ([i (in-range 0 1 (\/ 1 (min n 12000)))]) i) (list 1))]\n         [points (for\/list ([interval intervals]) \n                    (make-point interval (parabolic interval)))]\n         [lines (for\/list ([i (in-range (sub1 (length points)))]) \n                    (list (list-ref points i) (list-ref points (add1 i))))])\n          (round-to (apply + (map (\u03bb (pair) (distance (first pair) (second pair))) lines)) places)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290249,"user_id":527,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (\/ (for\/sum ([i (in-range n)]) (hypot (+ (* 2 i) 1) n))\n     (* n n)))\n\n(define (hypot x y)\n  (sqrt (+ (* x x) (* y y))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290250,"user_id":492,"body":"#lang racket\n(provide len-curve)\n\n(define (len-curve n)\n  (define (seglg n k)\n    (\/ (sqrt (+ (expt n 2) (* 4 (expt k 2)) (* 4 k) 1)) (expt n 2)))\n  (let loop ([s 0] [k 0])\n    (if (= k n)\n        (\/ (exact-floor (* s 1e9)) 1e9)\n        (loop (+ s (seglg n k)) (add1 k)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"562f91ff6a8b77dfe900006e":[{"id":290251,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  (let loop ([a 0] [b card] [d percent] [n 0])\n    (if (< (ceiling b) a)\n        n\n        (loop (+ a ticket)\n              (+ b (* ticket d))\n              (* d percent)\n              (+ n 1)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290252,"user_id":492,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  (define (loop i sb sa prev)\n    (if (< (exact-ceiling sb) sa)\n        i\n        (let ([nou (* prev percent)])\n          (loop (add1 i) (+ sb nou) (+ sa ticket) nou))))\n  (loop 0 card 0 ticket))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290253,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (movie2 card ticket percent n)\n  (let ([systemA (* n ticket)]\n        [systemB (+ card (for\/sum ([i (in-range 1 (+ n 1))]) (* ticket (expt percent i))))])\n    (if (< (ceiling systemB) systemA) n (movie2 card ticket percent (+ n 1))))\n)\n\n(define (movie card ticket percent)\n  (movie2 card ticket percent 0)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290254,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  ; your code\n  (define (ca card tic per i n)\n    (if (= i n)\n        card\n        (ca (+ card (* tic per)) (* tic per) per (add1 i) n)))\n  (define (allpay card tic per i)\n    (if (< (ceiling (ca card tic per 0 i)) (* tic i))\n        i\n        (allpay card tic per (add1 i))))\n(allpay card ticket percent 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290255,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  (movie2 card ticket percent 0)\n)\n\n(define (movie2 card ticket percent times)\n  (if (< (ceiling (systemB card ticket percent times)) (systemA ticket times))\n      times\n      (movie2 card ticket percent (+ times 1))))\n\n(define (systemA ticket times)\n  (* ticket times))\n\n(define (systemB card ticket percent times)\n  (if (= times 0)\n  card\n  (+ (* ticket percent) (systemB card (* ticket percent) percent (- times 1))\n         \n  )))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290256,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  (let* ([sys-B-first-ticket (* ticket percent)]\n         [sys-B-start-price (+ card sys-B-first-ticket)])\n    (do ([sys-A ticket\n                (+ sys-A ticket)]\n         [prev-ticket sys-B-first-ticket\n                      (* prev-ticket percent)]\n         [sys-B sys-B-start-price\n                (+ sys-B (* prev-ticket percent))]\n         [movie-visits 1\n                       (add1 movie-visits)])\n        ((> sys-A (ceiling sys-B)) movie-visits))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290257,"user_id":null,"body":"#lang racket\n\n(provide movie)\n\n;; Number Number 0<Decimal<1 -> Integer\n;; given card price, normal ticket price, and fraction of the previous ticket\n;; price that the customer pays in System B, figure out how many times (s)he\n;; has to go to the cinema so that ceil(total price system B) < (price system A)\n(define (movie card ticket fraction)\n\n  (define A 0)\n  (define B card)\n\n  (define (loop n new-ticket)\n    (set! A (+ A ticket))\n    (set! B (+ B new-ticket))\n    (if (< (exact-ceiling B) A)\n        n\n        (loop (add1 n) (* new-ticket fraction))))\n\n  (loop 1 (* ticket fraction))) ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290258,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (cost-of-percent-visits costs n ticket percent)\n  (if (equal? n 0) costs (cost-of-percent-visits (+ costs (* ticket (expt percent n))) (- n 1) ticket percent)))\n\n(define (number-of-needed-visits n card ticket percent)\n  (if\n   (> (* ticket n) (ceiling (+ (cost-of-percent-visits 0 n ticket percent) card)))\n   n\n   (number-of-needed-visits (+ n 1) card ticket percent)))\n\n(define (movie card ticket percent)\n  (number-of-needed-visits 0 card ticket percent)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290259,"user_id":null,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  (define (helper n acc price)\n    (if (< (ceiling acc) (* n ticket)) \n        n\n        (helper (add1 n) (+ acc (* price percent)) (* price percent))\n    ))\n  (helper 0 card ticket)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290260,"user_id":168,"body":"#lang racket\n(provide movie)\n\n(define (movie card ticket percent)\n  (define (loop s prev n)\n    (let* [(a (* ticket n))\n           (p (* prev percent))\n           (b (+ s p))]\n      (if (< (ceiling b) a) n (loop b p (add1 n)))))\n  (loop card ticket 1)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"563a631f7cbbc236cf0000c2":[{"id":290261,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero position roll)\n  (+ position (+ roll roll)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290262,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero p r) (+ p (* 2 r)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290263,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero position roll)\n  (+ (* 2 roll) position))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290264,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero position roll)\n  (+ (* roll 2) position))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290265,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero position roll)\n   (if(= roll 0) position\n     (+ 2 (move-hero position (- roll 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290266,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero position roll)\n  (+ position roll roll))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290267,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero a b)\n  (+ a (+ b b)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290268,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n;; Number 1<=Number<=6 -> Number\n;; given the current position and the roll, return the new position of the hero\n(define (move-hero position roll)\n  (+ position (* 2 roll)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290269,"user_id":null,"body":"#lang racket\n\n(provide move-hero)\n\n(define (move-hero a b) (+ a (* 2 b)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290270,"user_id":1055,"body":"#lang racket\n\n;;; https:\/\/www.codewars.com\/kata\/grasshopper-terminal-game-move-function\/train\/racket\n\n(provide move-hero)\n\n(define (move-hero position roll)\n  (+ position (* 2 roll)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"563b662a59afc2b5120000c6":[{"id":290271,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (define (f years inhabitants)\n    (cond\n      [(>= inhabitants p)\n       years]\n      [else\n       (f (add1 years)\n          (floor (+ inhabitants\n                    aug\n                    (* inhabitants (\/ percent 100)))))]))\n  (f 0 p0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290272,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  ; your code\n  (if (< p0 p) \n      (+ 1 (nb_year (floor (+ aug (* p0 (+ 1 (\/ percent 100))))) percent aug p))\n      0)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290273,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (if (< p0 p)\n      (+ 1 (nb_year\n            (floor (+ p0 (* p0 (\/ percent 100)) aug))\n            percent\n            aug\n            p\n            )\n         )\n      0\n   )\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290274,"user_id":492,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (define mult (+ 1 (\/ percent 100.0)))\n  (define (loop i prev)\n    (if (>= prev p)\n        (sub1 i)\n        (loop (add1 i) (exact-floor (+ aug (* prev mult))))))\n  (loop 1 p0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290275,"user_id":492,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (define mult (+ 1 (\/ percent 100.0)))\n  (define (loop i prev)\n    (if (>= prev p)\n        (sub1 i)\n        (loop (add1 i) (exact-floor (+ aug (* prev mult))))))\n  (loop 1 p0))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290276,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (define (calc cur) (floor ( + cur (* cur (\/ percent 100)) aug)))\n  (define (iterate current n) \n    (cond ((>= current p) n)\n          (else (iterate (calc current) (+ n 1)))\n    )\n  )\n  (iterate p0 0)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290277,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (population p0 percent aug p years)\n  (let ([pyear (exact-truncate (+ p0 (* p0 percent) aug))])\n    (if (>= pyear p) years \n      (population pyear percent aug p (+ 1 years))))\n)\n\n(define (nb_year p0 percent aug p)\n  (if (>= p0 p) 0 \n    (population p0 (\/ percent 100) aug p 1))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290278,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n (if (>= p0 p)\n     0\n     (add1 (nb_year (floor (+ aug p0 (* p0 (\/ percent 100)))) percent aug p)))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290279,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (define (iter year acc)\n    (if\n     (>= acc p)\n     year\n     (iter (add1 year) (floor (+ acc aug (* acc (\/ percent 100)))))))\n  (iter 0 p0)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290280,"user_id":null,"body":"#lang racket\n(provide nb_year)\n\n(define (nb_year p0 percent aug p)\n  (let ((change-over-year (floor (+ p0 (* p0 (\/ percent 100)) aug))))\n    (cond\n      ((>= p0 p) 0)\n      ((>= change-over-year p) 1)\n      (else (+ 1 (nb_year change-over-year percent aug p))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"563b74ddd19a3ad462000054":[{"id":290281,"user_id":null,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy s)\n  (cond \n   [(equal? s 0) \"\"]\n   [(equal? s 1) \"1\"]\n   [(equal? s 2) \"10\"]\n   [#t (string-append \"10\" (stringy (- s 2)))]\n   ))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290282,"user_id":null,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy size)\n  (build-string size (\u03bb (n) (if (even? n) #\\1 #\\0))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290283,"user_id":null,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy size)\n  (string-replace (make-string size #\\1)\n                  \"11\"\n                  \"10\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290284,"user_id":null,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy size)\n  (cond\n   [(equal? size 0) \"\"]\n   [(odd? size) (string-append (stringy (sub1 size)) \"1\")]\n   [else (string-append (stringy (sub1 size)) \"0\")]\n  ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290285,"user_id":null,"body":"#lang racket\n( require racket\/generator )\n\n( provide stringy )\n\n( define (stringy n)\n  ( let ([one-zero ( infinite-generator ( yield #\\1 ) ( yield #\\0 ) )])\n  ( list->string ( map ( lambda (_) (one-zero) ) ( range n ) ) ) ) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290286,"user_id":53,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy size)\n  (string-join (map (lambda (x) (if (even? x)\n    \"1\"\n    \"0\")) (range 0 size)) \"\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290287,"user_id":null,"body":"#lang racket\n\n(require racket\/generator)\n\n(provide stringy)\n \n;; Integer>0 -> String\n;; return a string of alternating 0s and 1s, starting with 1, of length `size`\n(define (stringy size)\n  (define supply (infinite-generator (yield #\\1) (yield #\\0)))\n  (list->string\n   (for\/list ([i (in-range size)]\n              [c (in-producer supply)])\n     c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290288,"user_id":168,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy size)\n  (list->string (build-list size (lambda (i) (if (even? i) #\\1 #\\0)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290289,"user_id":null,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy n) (string-join (build-list n (lambda (i) (number->string (- 1 (remainder i 2))))) \"\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290290,"user_id":null,"body":"#lang racket\n\n(provide stringy)\n\n(define (stringy size)\n  (define (ins s c)\n    (if (eq? c (- s 1))\n      (string-append (if (eq? (modulo c 2) 0) \"1\" \"0\") \"\") \n      (string-append (if (eq? (modulo c 2) 0) \"1\" \"0\") (ins s (+ 1 c)))\n     )\n    )\n  (ins size 0)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"563e320cee5dddcf77000158":[{"id":290291,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n(define (get_average lst)\n  (if (zero? (length lst))\n    0\n    (floor (\/ (foldr + 0 lst) (length lst)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290292,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n(define (get_average lst)\n  (floor (\/ (foldr (lambda (x acc) (+ x acc)) 0 lst) (length lst))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290293,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n(define (get_average lst)\n  (floor (\/ (apply + lst) (length lst))))\n  ;(floor (\/ (foldl + 0 lst) (length lst))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290294,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n( define (get_average lst)\n  ( quotient ( for\/sum ([v lst]) v ) ( length lst ) ) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290295,"user_id":53,"body":"#lang racket\n\n(provide get_average)\n\n(define (mean lst)\n  (\/ (foldl + 0 lst) (length lst)))\n\n(define (get_average lst)\n  (floor (mean lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290296,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n; (require math\/statistics)\n\n(define (get_average lst)\n  ( quotient (apply + lst) (length lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290297,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n(define (sum lst)\n  (if (null? lst)\n      0\n      (+ (first lst) (sum (rest lst)))))\n(define (get_average lst)\n  (floor (\/ (sum lst) (length lst))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290298,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n(define (get_average lst)\n  (if (zero? (length lst))\n    0\n    (floor (\/ (foldl + 0 lst) (length lst)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290299,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n(define (get_average lst)\n  (exact-floor (\/ (foldl + 0 lst) (length lst))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290300,"user_id":null,"body":"#lang racket\n\n(provide get_average)\n\n(define (get_average lst)\n  (define (sum l)\n    (if (null? l) 0 (+ (car l) (sum (cdr l))))\n    )\n  (define (cnt l)\n    (if (null? l) 0 (+ 1 (cnt (cdr l))))\n    )\n  (exact-floor (\/ (sum lst) (cnt lst))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"563f0c54a22b9345bf000053":[{"id":290301,"user_id":492,"body":"#lang racket\n(provide fcn)\n\n(define (fcn n)\n  (arithmetic-shift 1 n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290302,"user_id":168,"body":"#lang racket\n(provide fcn)\n\n(define (fcn n) (expt 2 n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290303,"user_id":null,"body":"#lang racket\n(provide fcn)\n\n(define fcn (curry expt 2))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290304,"user_id":544,"body":"#lang racket\n(provide fcn)\n\n; The disguised sequence is just u_n = 2^n\n(define (fcn n) (expt 2 n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290305,"user_id":null,"body":"#lang racket\n(provide fcn)\n\n(define (fcn n)\n  (define (seq un un+1 n)\n    (cond\n     [(zero? n) un+1]\n     [else (seq un+1 (\/ (* 6 un un+1) (- (* 5 un) un+1)) (sub1 n))]))\n  (seq 1 2 (sub1 n)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290306,"user_id":null,"body":"#lang racket\n(provide fcn)\n\n(define fcn (curry arithmetic-shift 1))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290307,"user_id":null,"body":"#lang racket\n(provide fcn)\n\n(define (fcn n)\n  [expt 2 n])","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"564057bc348c7200bd0000ff":[{"id":290308,"user_id":492,"body":"#lang racket\n(provide thirt)\n\n(define (thirt n)\n  (define (thirt-aux n c i)\n    (let ([w #(1 10 9 12 3 4)])\n      (if (= n 0)\n          c\n          (thirt-aux (quotient n 10) (+ c (* (remainder n 10) (vector-ref w (remainder i 6)))) (add1 i)))))\n  (let ([c (thirt-aux n 0 0)])\n    (if (= n c)\n        c\n        (thirt c))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290309,"user_id":null,"body":"#lang racket\n\n(require racket\/generator)\n\n(provide thirt)\n\n(define (to-digit num)\n  (let loop ([n num] [rst '()])\n    (if (not (zero? n))\n        (loop (quotient n 10) (cons (remainder n 10) rst))\n        (reverse rst))))\n\n(define (sum num)\n  (for\/sum ([n (to-digit num)]\n            [d (in-generator (let loop ([i 0])\n                               (yield (vector-ref #(1 10 9 12 3 4) i))\n                               (loop (remainder (add1 i) 6))))])\n    (* n d)))\n\n\n(define (thirt num)\n  (let loop ([n num])\n    (if (= n (sum n))\n        n\n        (loop (sum n)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290310,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n(define (rev-digits number)\n  (map (lambda (x) (string->number (string x)))\n       (reverse (string->list (number->string number)))))\n       \n(define (reduce number)\n  (for\/sum ([remainder (in-cycle '(1 10 9 12 3 4))]\n            [digit (rev-digits number)])\n            (* remainder digit)))\n\n(define (thirt n [start 0])\n   (let ([result (reduce n)])\n     (if (equal? result start) result (thirt result result))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290311,"user_id":53,"body":"#lang racket\n(provide thirt)\n\n(define (go n c i)\n  (let ([w #(1 10 9 12 3 4)])\n    (if (= n 0) c\n      (go (quotient n 10) (+ c (* (modulo n 10) (vector-ref w (modulo i 6)))) (add1 i))))) \n\n(define (thirt n) (let ([c (go n 0 0)]) (if (= n c) c (thirt c))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290312,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n(define seq '(1 10 9 12 3 4))\n\n(define (thirt-once n)\n  (let ([sum 0])\n    (for ([i (in-naturals)])\n         (set! sum (+ sum (* (modulo n 10) (list-ref seq (modulo i 6)))))\n         (set! n (quotient n 10))\n         #:break (= n 0) 0)\n    sum))\n\n(define (thirt n)\n  (let ([once (thirt-once n)])\n    (if (= n once) n (thirt once))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290313,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n;; Get the digits of an integer as a list.\n(define (integer-digits n [q (quotient n 10)] [r (modulo n 10)] [digits '()])\n  (if (and (<= 0 q) (<= q 9))\n      (append (list q r) digits)\n      (integer-digits n\n                      (quotient q 10)\n                      (modulo q 10)\n                      `(,r ,@digits))))\n\n;; Get next number in the sequencce, as described by the problem.\n(define (seq-next n)\n  (define digits (integer-digits n))\n  ;; Define recursive loop\n  (define (loop remaining-digits [sum 0])\n    (if (empty? remaining-digits)\n        sum\n        (let* ([digit       (car remaining-digits)]\n               [power-of-10 (expt 10 (sub1 (length remaining-digits)))]\n               [scalar      (modulo power-of-10 13)])\n          (loop (cdr remaining-digits)\n                (+ sum (* digit scalar))))))\n  ;; Initiate recursion\n  (loop digits 0))\n\n;; The desired function\n(define (thirt n [previous -1])\n  (if (= n previous)\n      n\n      (thirt (seq-next n) n)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290314,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n; Turns number into a list of it's digits in base 10\n(define (num->list n)\n  (define (num->list-iter n lst)\n    (if (= 0 n)\n        lst\n        (let-values ([(next-num last-digit) (quotient\/remainder n 10)])\n          (num->list-iter next-num (cons last-digit lst)))))\n  (num->list-iter n empty))\n\n; turns list into a list of lists, where every first item is the index \n; and every second item is the value\n(define (enumerate lst)\n  (define (enumerate-iter n lst)\n    (if (empty? lst)\n        lst\n        (cons (list n (first lst))\n              (enumerate-iter (+ n 1) (rest lst)))))\n  (enumerate-iter 0 lst))\n\n; Defines the pattern 10^n % 13 pattern\n(define (pow10-mod13-pattern n)\n  (let ([rem (remainder n 6)])\n    (cond\n      [(equal? 0 rem) 1]\n      [(equal? 1 rem) 10]\n      [(equal? 2 rem) 9]\n      [(equal? 3 rem) 12]\n      [(equal? 4 rem) 3]\n      [(equal? 5 rem) 4])))\n\n(define (thirt n)\n  (let* ([list-of-pairs (enumerate (reverse (num->list n)))]\n         [new-list (map (lambda (x) (* (pow10-mod13-pattern (first x)) (second x))) list-of-pairs)]\n         [new-n (foldl + 0 new-list)])\n    (if (= n new-n)\n        n\n        (thirt new-n))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290315,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n(define (thirt n)\n  (define (digits-reversed n)\n    (for\/list ([div (in-range (max 1 (log (max 1 n) 10)))])\n      (remainder (quotient n (expt 10 div)) 10)))\n  (let iter ([last +inf.0] [current n] )\n    (if (= current last)\n        current\n        (iter current\n              (for\/sum ([digit (in-list (digits-reversed current))]\n                        [factor (in-cycle (in-list '(1 10 9 12 3 4)))])\n                (* digit factor))))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290316,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n(define (thirt n)\n  ; your code\n  (define spec '(1 10 9 12 3 4))\n  (define (number->list num)\n    (reverse (map (\u03bb (ch) (string->number (string ch)))\n                  (string->list (number->string num)))))\n  (define (proc num)\n    (let ((numlst (number->list num)))\n      (apply +\n             (map (\u03bb (a b)\n                    (* a (list-ref spec (remainder b 6))))\n                  numlst\n                  (build-list (length numlst) values)))))\n  (define (iter num)\n    (let ((thirted (proc num)))\n      (if (= num thirted)\n          thirted\n          (iter thirted))))\n  (iter n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290317,"user_id":null,"body":"#lang racket\n(provide thirt)\n\n(define (thirt n)\n  ; your code\n  (define spec '(1 10 9 12 3 4))\n  (define (number->list num)\n    (reverse (map (\u03bb (ch) (- (char->integer ch)\n                             (char->integer #\\0)))\n                  (string->list (number->string num)))))\n  (define (iter num)\n    (let loop ((i 0)\n               (numlst (number->list num))\n               (acc 0))\n      (cond ((null? numlst) acc)\n            (else (loop (remainder (add1 i) 6)\n                        (cdr numlst)\n                        (+ acc (* (car numlst) (list-ref spec i))))))))\n  (define (loop num)\n  (let ((thirted (iter num)))\n    (if (= num thirted)\n        thirted\n        (loop thirted))))\n  (loop n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56445c4755d0e45b8c00010a":[{"id":290318,"user_id":null,"body":"#lang racket\n(provide fortune)\n\n(define (add-percent n p)\n  (* n (+ 1 (\/ p 100))))\n\n(define (fortune fort-init p per-year nb-year infl)\n  (let loop ([f fort-init]\n             [c per-year]\n             [year 0])\n    (cond ((>= year nb-year) #t)\n          ((negative? f) #f)\n          (else (loop (floor (- (add-percent f p) c))\n                      (floor (add-percent c infl))\n                      (add1 year))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290319,"user_id":null,"body":"#lang racket\n(provide fortune)\n\n(define (percent val p)\n  (floor (\/ (* val p) 100)))\n\n\n(define (fortune-helper fort p cost years-left infl)\n  (if (= years-left 1)\n      fort\n      (fortune-helper (- (+ fort (percent fort p)) cost) p (+ cost (percent cost infl)) (- years-left 1) infl)))\n\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(define (fortune fort-init p per-year nb-year infl)\n  (>= (fortune-helper (floor fort-init) p (floor per-year) nb-year infl) 0)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290320,"user_id":53,"body":"#lang racket\n(provide fortune)\n\n(define (aux f0 p c0 n i)\n  (cond [(= n 1) f0]\n        [else (aux \n               (- (+ f0 (quotient (* f0 (floor p)) 100)) c0) \n               p \n               (+ c0 (quotient (* c0 (floor i)) 100))\n               (sub1 n) \n               i)]))\n\n(define (fortune f0 p c0 n i)\n  (>= (aux f0 p c0 n i) 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290321,"user_id":null,"body":"#lang racket\n(provide fortune)\n\n(define (fortune initial-fortune interest% first-withdrawal n inflation%)\n  ;; These are the numbers we will multiply by to get new withdrawal and fortune values.\n  (let ([inflation-factor (add1 (\/ inflation% 100))]\n        [interest-factor  (add1 (\/ interest%  100))])\n    ;; Define function which will solve the problem tail-recursively.\n    (define (loop current-fortune current-withdrawal years-left)\n      (cond [(negative? current-fortune) #f]\n            [(= 1 years-left) #t]\n            [else (loop (- (truncate (* current-fortune interest-factor))\n                           current-withdrawal)\n                        (truncate (* current-withdrawal inflation-factor))\n                        (sub1 years-left))]))\n    ;; Initiate recursion.\n    (loop initial-fortune first-withdrawal n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290322,"user_id":492,"body":"#lang racket\n(provide fortune)\n\n; fort-init is f0, p is percent, per-year is c0, nb-year is n, infl is i\n(define (fortune fort-init p per-year nb-year infl)\n  (define (aux prev-x p prev-c n infl k)\n    (if (= k n)\n        (>= prev-x 0)\n        (aux (floor (- (* prev-x (+ 1 (\/ p 100.0))) prev-c))\n             p\n             (floor (* prev-c (+ 1 (\/ infl 100.0))))\n             n\n             infl\n             (add1 k))))\n  (aux fort-init p per-year nb-year infl 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56484848ba95170a8000004d":[{"id":290323,"user_id":null,"body":"#lang racket\n(provide gps)\n\n(define (gps s x)\n  (if (< (length x) 2)\n      0\n      (max \n       (exact-floor (\/ (* 3600 (- (second x) (first x))) s))\n       (gps s (cdr x))\n      )\n      )\n)\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290324,"user_id":492,"body":"#lang racket\n(provide gps)\n\n(define (gps s x)\n  (if (<= (length x) 1)\n    0\n    (let ([z (map cons (rest x)  (drop-right x 1))])\n      (exact-floor (apply max (map (lambda(x) (\/ (* 3600 (- (car x) (cdr x))) s)) z))))))\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290325,"user_id":null,"body":"#lang racket\n(provide gps)\n\n(define calc-avg\n  (lambda (delta-dist s)\n    (\/ (* 3600 delta-dist) s)))\n\n(define (diff-lst f lst)\n  (if (empty? lst) '()\n      (for\/list ([x lst]\n                 [y (cdr lst)])\n        (f y x))))\n\n(define (gps s x)\n  (let ([diffx (diff-lst - x)])\n    (exact-floor (calc-avg (foldr max 0 diffx) s))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290326,"user_id":null,"body":"#lang racket\n(provide gps)\n\n(define (gps s x)\n  (if (<= (length x) 1)\n      0\n      (let ([deltas (make-deltas x)])\n        (exact-floor (argmax max\n                        (map (lambda (d) (\/ (* 3600 d) s)) deltas)))))\n)\n      \n(define (make-deltas x)\n  (if (or (null? x) (null? (cdr x)))\n      '()\n      (cons (- (cadr x) (car x)) (make-deltas (cdr x)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290327,"user_id":null,"body":"#lang racket\n(provide gps)\n\n; gps : Number List(Number) -> Number\n; return as an integer the maximum average speed per\n; hour obtained on the sections of x. If x length\n; is less than or equal to 1 return 0 since the car didn't move.\n(define (gps s x)\n  (exact-floor (highest-number (lspeed s x))) \n)\n\n; lspped : Number List(Number) -> List(Number)\n; calculate the average hourly speed in each section\n(define (lspeed s l)\n  (cond [(empty? l) empty]\n        [(empty? (rest l)) empty]\n        [else (cons (get-speed (first l) (first (rest l)) s)\n                         (lspeed s (rest l)))]))\n\n; highest-number : List(Number) -> Number\n; Given a list of number it returns the biggest Number in the list\n(define (highest-number l)\n  (if (empty? l) 0 (foldr max (first l) (rest l))))\n\n; get-speed : Number Number Number -> Number\n; returns the average hourly speed from a to b\n; in s seconds\n(define (get-speed a b s)\n  (abs (\/ (* (- b a) 3600) s)))\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290328,"user_id":544,"body":"#lang racket\n(provide gps)\n\n(define (deltas xs)\n  (for\/list ([x xs] [y (cdr xs)])\n    (- y x)))\n\n(define (gps s x)\n  (cond [((length x) . < . 2) 0]\n        [else (exact-floor (\/ (* 3600 (apply max (deltas x))) s))]))\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290329,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide gps)\n\n;; Integer>0 (Listof Float) -> Integer\n;; given a list `x` with distances travelled from the origin as measured every\n;; `s` seconds, return the floor of the maximum average speed per hour\n;; obtained on the sections (time between two measurements) of `x`\n(define (gps s x)\n  \n  (define (speed delta_distance)\n    (\/ (* 3600 delta_distance) s))\n\n  (define (cumulative->delta distances)\n    (for\/list ([a x] [b (rest distances)]) (- b a)))\n\n  (if (< (length x) 2)\n      0\n      (inexact->exact (floor (apply max (map speed (cumulative->delta x)))))))\n\n(module+ test\n  (check-equal? (gps 20 '(0.0 0.23 0.46 0.69 0.92 1.15 1.38 1.61)) 41)\n  (check-equal? (gps 15 '()) 0)\n  (check-equal? (gps 15 '(0.11)) 0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290330,"user_id":null,"body":"#lang racket\n(provide gps)\n\n(define (gps s x)\n  (cond ((< (length x) 2) 0)\n        (#t (max (exact-floor (\/ (* 3600 (- (cadr x) (car x))) s)) (gps s (cdr x))))))\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290331,"user_id":null,"body":"#lang racket\n(provide gps)\n\n(define (gps s x)\n  (if (< (length x) 2)  ;If x has less than 2 values there is nothing to calculate with\n      0\n      (let ([speeds (map (lambda (a b) (\/ (* 3600 (- b a)) s))\n                         (take x (- (length x) 1))              ;x without the last element\n                         (drop x 1))])                          ;x without the first element\n        (exact-floor (apply max speeds)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290332,"user_id":null,"body":"#lang racket\n(provide gps)\n\n(define (gps s x)\n    (inexact->exact (floor\n        (for\/fold ([acc 0.0]) ([i (in-range (- (length x) 1))])\n            (define distance (- (list-ref x (add1 i)) (list-ref x i)))\n            (define unitsPerHr (\/ (* 3600 distance) s))\n            (if (> unitsPerHr acc) unitsPerHr acc)\n        )\n    ))\n)\n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56541980fa08ab47a0000040":[{"id":290333,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (format \"~a\/~a\"\n    (for\/sum ([c (in-string s)])\n      (if (char<=? #\\a c #\\m) 0 1))\n    (string-length s)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290334,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (let-values ([(x y) (for\/fold ([x 0] [y 0])\n                                ([c (in-string s)])\n                        (values ((if (char>? c #\\m) add1 identity) x) (add1 y)))])\n    (format \"~a\/~a\" x y)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290335,"user_id":492,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (format \"~a\/~a\" (length (regexp-match* #rx\"[^a-m]\" s)) (string-length s)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290336,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (string-append\n   (number->string(foldl (lambda (ch acc) (if (string>? (string ch) \"m\") (add1 acc) acc)) 0 (string->list s)))\n   \"\/\"\n   (number->string(string-length s)))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290337,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n;; This one was pretty simple, because I steal some\n;; moves from \"Two-to-One\" kata's solutions,\n;; for instance I discovered `curry` and `compose`\n;; but still I would be glad to read your comments\n;; about flaws and possible enchancements in this code\n;; to make refactor it to more Racket-style or LISP-style\n;; and generally more in style of functional programming,\n;; because I only used to write on Java and C before,\n;; so it is quite challenging to rearrange my mindset from imperative\/object-oriented style to functional\n\n;; we can check if color is valid like this\n(define (valid-color? c)\n  (string-contains? \"abcdefghijklm\" (make-string 1 c)))\n;; but I also thought about something oriented on comparsion of integer values of character\n;; like this\n#; (define (valid-color? c)\n     (apply <= (map char->integer (list #\\a c #\\m))))\n;; but I think it will slightly reduce readability of code\n;; P.S.: Look like discovery of `compose` broke something inside my brain,\n;; now I can't write just function calls, I pursue to wrap them inside `compose`,\n;; because it's really cool to build chains of procedures in your mind\n\n(define (printer_error s)\n  (define errors\n    ;; This is almost unreadable for me after 5 minutes break ahah\n    ;; but I try to explain how my mindflow came to this:\n    ;; procedures in compose are evaluated from last to first, so\n    ;; 1. What we need to get finally? String from number of errors\n    ;; 2. How we can get number of errors? Take length of list with invalid colors\n    ;; 3. How we can get list of invalid colors? By filtering out valid colors with `valid-color?` predicate\n    ;; 4. But what we use as source list? List of characters representing colors\n    ;; 5. How do we get that? By converting the input string to list of characters with `string->list`\n    ((compose number->string length (curry filter-not valid-color?) string->list)\n     s)) ;; aaand finally we get string representation of error number\n  (define total (number->string (string-length s))) ;; create string representation of control sequence's length\n  (string-append errors \"\/\" total)) ;; and concatenate it to resulting string","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290338,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (let ([len (string-length s)]\n        [err (foldr \n              (lambda(a b)\n                (if(char>?  a #\\m)\n                   (+ b 1)b)) 0 (string->list s))])\n   (format \"~a\/~a\" err len)) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290339,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (cond ((string? s) (~a (printer_error (string->list s)) '\/ (string-length s)))\n        ((pair? s) (+ (let ([curr (car s)])\n                        (if (and (char<=? curr #\\m) (char>=? curr #\\a)) 0 1)) (printer_error (cdr s))))\n        (else 0)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290340,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (define (is-error? c)\n    (char>? c #\\m))\n  (let ([total (string-length s)]\n        [chars (string->list s)])\n    (~a (length (filter is-error? chars))\n        '\/\n        total))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290341,"user_id":null,"body":"#lang racket\n(provide printer_error)\n\n(define (printer_error s)\n  (let ([chars (string->list s)])\n  \n  (format \"~a\/~a\"\n          (count (lambda (c) (not (char<=? #\\a c #\\m))) chars)\n          (length chars))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290342,"user_id":53,"body":"#lang racket\n(provide printer_error)\n\n(define (filter p xs)\n  (define (more) (filter p (cdr xs)))\n  (cond\n    ((null? xs)    '())\n    ((p (car xs))  (cons (car xs) (more)))\n    (else          (more))))\n\n(define alpha (string->list \"abcdefghijklm\"))\n(define (nalpha? c) (not (member c alpha)))\n(define (count-nalpha s)(length (filter nalpha? (string->list s))))\n\n(define (printer_error s)\n  (define m (count-nalpha s))\n  (define n (string-length s))\n  (format \"~a\/~a\" m n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5656b6906de340bd1b0000ac":[{"id":290343,"user_id":527,"body":"#lang racket\n(provide longest)\n\n(define (longest . ss)\n  (list->string (sort (remove-duplicates (append-map string->list ss)) char<?)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290344,"user_id":null,"body":"#lang racket\n(provide longest)\n\n(define (longest s1 s2)\n  ((compose list->string remove-duplicates sort)\n   (string->list (string-append s1 s2))\n     (compose (curry apply <) (curry map char->integer) list)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290345,"user_id":null,"body":"#lang racket\n(provide longest)\n\n(define (longest s1 s2)\n  (list->string (sort (set->list (list->set (string->list (string-append s1 s2)))) char<?)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290346,"user_id":null,"body":"#lang racket\n(provide longest)\n\n\n;; I spent two hours for this kata, that took loonger that I thought, \n;; but it also is simpler than I thought\n;; so guys I would be happy if leave some comments about\n;; flaws in this solution\n;; and some advices how to do that in more Racketeer way\n;; I would really appreciate that\n;; ====================================================\n\n(define (longest str-a str-b)\n  (for\/fold ([acc \"\"])\n            ([c (in-string \"abcdefghijklmnopqrstuvwxyz\")]\n             ;; here we need to check if letter from #\\a to #\\z is in input strings\n             ;; so I concatenated them\n             ;; and then convert `c` in one character string\n             ;; to use `string-contains?`\n             #:when (string-contains? (string-append str-a str-b) (make-string 1 c)))\n    (string-append acc (make-string 1 c))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290347,"user_id":null,"body":"#lang racket\n(provide longest)\n(require racket\/set)\n(require racket\/string)\n(require racket\/list)\n\n(define (longest s1 s2)\n  (define word (string-append s1 s2))\n  (define charset \n    (list->set (string->list word)))\n  (define uniqlist (set->list charset))\n  (define sorted-list (sort uniqlist char<?))\n  (list->string sorted-list))\n\n;   concatenate both strings\n;   convert to list\n;   *remove duplicates by creating a set\n;   convert back to a list\n;   sort in alphabetical order (.sort)\n;   convert back into a string\n\n;  2) create a hash table with the chars as keys, redundant\n;     keys will be eliminated automatically\n\n\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290348,"user_id":null,"body":"#lang racket\n(provide longest)\n\n(define (longest a b)\n  (define ab (string->list (string-append a b)))\n  (define alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\"))\n  (define sorted-unique-ab (sort (set-intersect alphabet ab) char<?))\n  (list->string sorted-unique-ab))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290349,"user_id":544,"body":"#lang racket\n(provide longest)\n\n(define (longest s1 s2)\n  (list->string(remove-duplicates (sort (string->list(string-append s1 s2)) char<?)))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290350,"user_id":null,"body":"#lang racket\n(provide longest)\n\n(require racket\/set)\n\n(define string->list->set\n  (compose list->set string->list))\n(define (set->list->string S)\n  (list->string (sort (set->list S) char<=?)))\n\n(define (longest s1 s2)\n  (define letters-set (set-union (string->list->set s1) (string->list->set s2)))\n  (set->list->string letters-set))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290351,"user_id":null,"body":"#lang racket\n\n(provide longest)\n\n;; String String -> String\n;; given two strings, return a sorted string which is a union of letters\n;; appearing in s1 and s2\n(define (longest s1 s2)\n  \n  (define (str->set s)\n    (list->set (string->list s)))\n  \n  (list->string (sort (set->list (set-union (str->set s1) (str->set s2)))\n                      char<?)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290352,"user_id":null,"body":" #lang racket\n(provide longest)\n\n  (define (longest s1 s2)\n  (string-join \n   (sort \n    (remove-duplicates\n     (string-split \n      (string-append s1 s2)\n      \"\")) \n    string<?)\n   \"\"))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"565abd876ed46506d600000d":[{"id":290353,"user_id":53,"body":"#lang racket\n(provide simpson)\n\n(define (simpson n) (\/ (* \n    (\/ pi n) \n    (+ 1 (* 2 (expt (cos (\/ pi n)) 3)) (* 3 (cos (* 2 (\/ pi n)))))) \n  (sin (\/ (* 3 pi) n))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290354,"user_id":492,"body":"#lang racket\n(provide simpson)\n\n(define (simpson n)\n  (define (f x) (* 1.5 (expt (sin x) 3)))\n\n  (define (sum1 n h)\n    (apply + (for\/list ([i (range 1 (add1 (quotient n 2)))])\n               (f (* (- (* 2.0 i) 1) h)))))\n\n  (define (sum2 n h)\n    (apply + (for\/list ([i (range 1 (quotient n 2))])\n               (f (* 2.0 i h)))))\n  \n  (let* ([h (\/ pi n)]\n         [s1 (sum1 n h)]\n         [s2 (sum2 n h)])\n    (* (\/ pi (* 3.0 n)) (+ (f 0) (f pi) (* 4.0 s1) (* 2.0 s2)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290355,"user_id":544,"body":"#lang racket\n(provide simpson)\n\n(define (f x)\n  (* (\/ 3 2)\n     (expt (sin x) 3)))\n  \n(define (h b a n)\n  (\/ (- b a) n))\n\n(define (simpson n [a 0] [b pi] [func f])\n  (* (\/ (- b a) 3 n)\n     (+ (func a)\n        (func b)\n        (* 4\n           (for\/sum ([i (in-range 1 (+ (\/ n 2) 1))]) ; (in-range x y) stops at y-1!!\n             (func (+ a \n                      (* (h b a n) \n                         (- (* 2 i) 1))))))\n        (* 2\n           (for\/sum ([i (in-range 1 (\/ n 2))])\n             (func (+ a (* 2 i (h b a n)))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290356,"user_id":168,"body":"#lang racket\n(provide simpson)\n\n(define (simpson n)\n  (define (f x) (* 1.5 (expt (sin x) 3)))\n  (define h (\/ pi n))\n  (define s\n    (for\/sum ([i (in-range 1 (\/ n 2))])\n      (+ (* 4 (f (* (sub1 (* 2 i)) h))) (* 2 (f (* 2 i h))))))\n  (\/ (* (+ s (* 4 (f (* (sub1 n) h)))) pi) (* 3 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290357,"user_id":null,"body":"#lang racket\n(provide simpson)\n\n(define (simpson n)\n  (define (f x) (* 3\/2 (expt (sin x) 3)))\n  (define (sum proc end)\n    (for\/sum ([i (in-range 1 (+ end 1))])\n      (f (proc i))))\n  (let ([h (\/ pi n)])\n    (* (\/ h 3)\n       (+ (* 4 (sum (\u03bb (i) (* (- (* 2 i) 1) h)) (\/ n 2)))\n          (* 2 (sum (\u03bb (i) (* 2 i h)) (- (\/ n 2) 1)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290358,"user_id":null,"body":"#lang racket\n(provide simpson)\n\n(define (simpson n)\n  (let* ([a 0]\n         [b pi]\n         [h (\/ (- b a) n)]\n         [fx (lambda (x) (* 3\/2 (expt (sin x) 3)))])\n    (* (\/ (- b a) (* 3 n))\n       (+ (fx a) (fx b)\n          (* 4 (for\/sum ([i (range 1 (add1 (\/ n 2)))])\n                 (fx (+ a (* (- (* 2 i) 1) h)))))\n          (* 2 (for\/sum ([i (range 1 (\/ n 2))])\n                 (fx (+ a (* 2 i h)))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290359,"user_id":null,"body":"#lang racket\n(provide simpson)\n\n(define (f x) (* (\/ 3 2) (expt (sin x) 3)))\n\n(define (simpson* f n a b)\n  (let ([h (\/ (- b a) n)])\n    (* (\/ (- b a) 3 n)\n       (+ (f a)\n          (f b)\n          (* 4 (apply + (map (\u03bb (i) (f (+ a (* (- (* 2 i) 1) h))))\n                             (range 1 (+ (\/ n 2) 1)))))\n          (* 2 (apply + (map (\u03bb (i) (f (+ a (* 2 i h))))\n                             (range 1 (\/ n 2)))))))))\n\n(define (simpson n) (simpson* f n 0 pi))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"565c0fa6e3a7d39dee000125":[{"id":290360,"user_id":null,"body":"#lang racket\n(provide dist speed)\n\n(define (dist v mu)                                ; suppose reaction time is 1\n  (define w (* 0.27777777777777 v))\n  (+ w\n     (\/ (* w w)\n        (* 19.62 mu)))\n)\n\n(define (speed d mu)                               ; suppose reaction time is 1\n  (define dlt (+ 1 (\/ (* 2 d)\n                      (* 9.81 mu))))\n  (* 3.6\n     (- (sqrt dlt) 1)\n     (* 9.81 mu))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290361,"user_id":492,"body":"#lang racket\n(provide dist speed)\n\n(define (dist v mu)                                ; suppose reaction time is 1\n  (let* (           \n         [g 9.81]                                  ; acceleration due to gravity in m\/s\n         [coef (\/ 1000.0 3600.0)]                  ; km\/h -> m\/s\n         [dreact (* v coef)]                       ; distance of reaction with t = 1\n         [vms (* coef v)]                          ; speed in m\/s\n         [dbrak (\/ (* 0.5 (expt vms 2)) mu g)]     ; braking distance       \n       )\n    (+ dreact dbrak)))\n(define (speed d mu)                               ; suppose reaction time is 1\n  (let* (\n         [g 9.81]                                  ; acceleration due to gravity in m\/s\n         [coef (\/ 3600.0 1000.0)]                  ; m\/s -> km\/h\n         [delta (sqrt (+ 4.0 (\/ (* 8.0 d) mu g)))]\n       )\n    (* 0.5 mu g (- delta 2) coef)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290362,"user_id":53,"body":"#lang racket\n(provide dist speed)\n\n(define (dist v mu)\n  (let ([u (\/ (* v 5) 18)]) (+ u (\/ (* u u) (* 2 mu 9.81)))))\n\n(define (speed d mu)\n  (let ([b (* -2 mu 9.81)]) (\/ (* 3.6 (+ b (sqrt (- (* b b) (* 4 b d))))) 2)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290363,"user_id":544,"body":"#lang racket\n(provide dist speed)\n\n(define *G* 9.81)\n\n(define (dist v0 \u03bc [tr 1])                                \n  ; v0 (int) initial speed, km\/h\n  ; \u03bc  (int) coefficient of friction\n  ; tr (int) reaction time, t\n  ; returns (int) braking distance, m\n  (define v0-m\/s (\/ v0 3.6))\n  (+ (* v0-m\/s tr)   ; distance traveled during reaction time\n     (\/ (sqr v0-m\/s) ; distance to come to a stop\n        (* 2 \u03bc *G*)))) \n     \n(define (speed d \u03bc [tr 1])                               \n  ; d  (int) braking distance\n  ; \u03bc  (int) coefficient of friction\n  ; tr (int) reaction time\n  ; returns (int) speed to produce given braking distance, km\/h\n  (* (- (sqrt (* *G* \u03bc (+ (* 2 d) (* *G* \u03bc (sqr tr)))))\n        (* *G* \u03bc tr))\n     3.6))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290364,"user_id":null,"body":"#lang racket\n\n(provide dist speed)\n\n(define REACTION-TIME 1) ;; in seconds\n(define g 9.81)\n\n;; Number -> Number\n;; convert kilometer per hour to meter per sec\n(define (kmh->ms v)\n  (\/ (* v 1000) 3600))\n\n;; Number -> Number\n;; convert meter per sec to kilometer per hour\n(define (ms->kmh v)\n  (\/ (* v 3600) 1000))\n\n;; Number Number -> Number\n;; given speed `v` in km per hour and coefficient of friciton between the tires\n;; and the road surface `mu`, calculate the total stopping distance in meters\n(define (dist v mu)\n\n  (define (braking-dist v mu)\n    (\/ (* v v) (* 2 mu g)))\n\n  (define (reaction-dist v rt)\n    (* v rt))\n  \n  (define vms (kmh->ms v))\n  (+ (braking-dist vms mu) (reaction-dist vms REACTION-TIME)))\n\n;; Number Number -> Number\n;; given total stopping distance `d` in meters and surface friction coeeficient `mu`\n;; calculate the speed in km per hour\n(define (speed d mu)\n  (define v (- (sqrt (+ (* 2 mu g d)\n                        (* mu mu g g (expt REACTION-TIME 2))))\n               (* mu g REACTION-TIME)))\n  (ms->kmh v))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290365,"user_id":null,"body":"#lang racket\n(provide dist speed)\n\n(define (quadratic-solutions a b c)\n  (\/ \n   (+ (- b) \n      (sqrt (- \n             (sqr b) \n             (* 4 a c)))) \n      (* 2 a)))\n\n(define g 9.81)\n\n(define (h->s h) (* h 3600))\n(define (s->h s) (\/ s 3600))\n\n(define (km->m km) (* km 1000))\n(define (m->km m) (\/ m 1000))\n\n(define (km\/h->m\/s v) (km->m (s->h v)))\n(define (m\/s->km\/h v) (m->km (h->s v)))\n\n(define (dist v mu)\n  (define v-m\/s (km\/h->m\/s v))\n  (define break-distance \n    (\/ \n     (sqr v-m\/s) \n     (* 2 mu g)))\n  (define reaction-distance v-m\/s)\n  (+ reaction-distance break-distance))\n\n(define (speed d mu)\n  (m\/s->km\/h (quadratic-solutions (\/ 1 (* 2 mu g)) 1 (- d))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290366,"user_id":null,"body":"#lang racket\n(provide dist speed)\n\n(define g 9.81)\n\n(define (dist v mu)\n  (define vi (\/ v 3.6))\n  (+ (* 1 vi)\n     (\/ (sqr vi)\n        (* 2 mu g))))\n\n(define (speed d mu)\n  (* 3.6 mu g (- (sqrt (+ 1 (\/ (* 2 d)\n                               (* mu g))))\n                 1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290367,"user_id":null,"body":"#lang racket\n(provide dist speed)\n\n(define g 9.81)\n(define (kmph-to-mps v) (\/ v 3.6))\n(define (mps-to-kmph v) (* v 3.6))\n(define t 1.0)\n\n(define (dist v mu)\n  (let ([v (kmph-to-mps v)])\n    (+ (* v t)\n       (\/ (* v v)\n          (* 2 mu g)))))\n\n(define (speed d mu)\n  (mps-to-kmph\n    (* mu g\n       (- (sqrt (+ (* t t) \n                   (\/ (* 2 d) (* mu g)))) \n          t))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290368,"user_id":null,"body":"#lang racket\n(provide dist speed)\n\n(define g 9.81)\n\n(define (dist v mu)\n  (define mps (\/ (* v 1000) (sqr 60)))\n  (+ mps (\/ (sqr mps) (* 2 mu g))))\n\n(define (speed d mu)\n  (define a (* 2 mu g))\n  (* 1.8 (- (* (sqrt a) (sqrt (+ a (* d 4)))) a)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290369,"user_id":null,"body":"#lang racket\n(provide dist speed)\n\n(define g 9.81)\n\n(define (dist v mu)                                \n  (let ([u (\/ v 3.6)]\n        [z (* 2 mu g)])\n    (+ u (\/ (* u u) z))))\n\n(define (speed d mu)                     \n  (let ([z (* 2 mu g)])\n    (* 1.8 (- (* (sqrt z) (sqrt (+ z (* 4 d)))) z))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"565f5825379664a26b00007c":[{"id":290370,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size width height depth)\n  (list (+ (* 2 depth width) \n           (* 2 depth height) \n           (* 2 width height))\n        (* width height depth)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290371,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size width height depth)\n  (list (* (+ (* width height) (* width depth) (* height depth)) 2) (* width height depth)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290372,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size width height depth)\n  (list (+ (* 2 width height) (* 2 height depth) (* 2 width depth))\n        (* width height depth)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290373,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size width height depth)\n  (list (+ (* 2 width (+ height depth)) (* 2 height depth)) (* width height depth)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290374,"user_id":373,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size width height depth)\n  (let ([area (+ (* 2 width height) (* 2 height depth) (* 2 depth width))] [volume (* width height depth)]) (list area volume))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290375,"user_id":53,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size w h d)\n  (list (+ (* 2 (* h w)) (+ (* 2 (* d h)) (* 2 (* w d)))) (* d (* w h))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290376,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size w h d)\n  (list (* 2 (+ (* h w) (* h d) (* d w))) (* w h d)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290377,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size a b c) (list (* 2 (+ (* a b) (* a c) (* b c))) (* a b c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290378,"user_id":null,"body":"#lang racket\n\n(provide get_size)\n\n(define (get_size width height depth)\n  (define area (* 2 (+ (* height depth) (* depth width) (* width height))))\n  (define volume (* width height depth))\n  `(,area ,volume))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290379,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide get_size)\n\n;; Number Number Number -> (List Number Number)\n;; return the total surface area and volume of a box\n(define (get_size width height depth)\n  (define volume (* width height depth))\n  (define area (+ (* 2 (* width height))\n                  (* 2 (* depth height))\n                  (* 2 (* width depth))))\n  `(,area ,volume))\n\n(module+ test\n  (check-equal? (get_size  4 2 6) '(88 48))\n  (check-equal? (get_size  1 1 1) '(6 1))\n  (check-equal? (get_size  1 2 1) '(10 2))\n  (check-equal? (get_size  1 2 2) '(16 4))\n  (check-equal? (get_size  10 10 10) '(600 1000)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5663f5305102699bad000056":[{"id":290380,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (min-max-one w p) (let ((m (car p))   \n                                (M (cdr p))      \n                                (l (string-length w)))\n                            (cons (min m l) \n                                  (max M l))))\n\n(define (min-max-all s)                                                    \n  (foldl min-max-one                             \n         (let ((l (string-length (car s)))) (cons l l))\n         (cdr s)))\n\n(define (mxdiflg s1 s2)\n  (if (or (null? s1)\n          (null? s2))                                  \n    -1                                  \n    (let ((mm-1 (min-max-all s1))   \n          (mm-2 (min-max-all s2)))\n      (max (abs (- (car mm-1) (cdr mm-2))) \n           (abs (- (cdr mm-1) (car mm-2)))))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290381,"user_id":492,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (if (or (empty? s1) (empty? s2))\n      -1\n      (let ([l1 (map string-length s1)]\n            [l2 (map string-length s2)])\n        (max (abs (- (apply max l1) (apply min l2))) (abs (- (apply max l2) (apply min l1)))))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290382,"user_id":168,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (for\/fold ([r -1])\n            ([x s1]\n             #:when #t\n             [y s2])\n    (max r (abs (- (string-length x) (string-length y)))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290383,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (if (or (empty? s1) (empty? s2))\n      -1\n      (let ([l1 (map string-length s1)]\n            [l2 (map string-length s2)])\n      (max (abs (- (apply max l1) (apply min l2))) \n           (abs (- (apply min l1) (apply max l2)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290384,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (cond\n   [(null? s1) -1]\n   [(null? s2) -1]\n   [else \n    (let\n      [(s11 (map string-length s1))\n       (s21 (map string-length s2))]\n(max (abs (- (apply max s11) (apply min s21)))\n     (abs (- (apply min s11) (apply max s21)))))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290385,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg first second)\n  (if (not (empty? (filter zero? (map length (list first second)))))\n      -1\n      (apply max (for*\/list ([s1 (in-list first)]\n                             [s2 (in-list second)])\n                   (dif-len s1 s2)))))\n\n(define (dif-len . ss)\n  (abs (apply - (map string-length ss))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290386,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define len string-length)\n\n(define (list-max lst)\n  (match-let ([(list x xs ...) lst]\n              [f (lambda (x y) (max (len x) y))])\n             (foldl f (len x) xs)))\n\n(define (list-min lst)\n  (match-let ([(list x xs ...) lst]\n              [f (lambda (x y) (min (len x) y))])\n             (foldl f (len x) xs)))\n\n(define (mxdiflg s1 s2)\n  (if (or (empty? s1) (empty? s2))\n      -1\n      (let* ([max1 (list-max s1)]\n             [max2 (list-max s2)]\n             [min1 (list-min s1)]\n             [min2 (list-min s2)])\n            (max (- max1 min2) (- max2 min1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290387,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (local ((define (max* s1 s2) \n            (for*\/list ([i s1] [j s2])\n              (abs (- (string-length i) (string-length j)))))\n          (define max (max* s1 s2)))\n    (if (empty? max) -1 (argmax (lambda (x) x) max))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290388,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (if (or (empty? s1) (empty? s2))\n      -1\n      (sol s1 s2)))\n\n\n(define (sol s1 s2)\n  (define s1-len-min (string-length (car s1)))\n  (define s2-len-max 0)\n  (define s1-len-max 0)\n  (define s2-len-min (string-length (car s2)))\n\n  (for ([i s1])\n    (if (< (string-length i) s1-len-min)\n        (set! s1-len-min (string-length i))\n        '()))\n  (for ([i s2])\n    (if (> (string-length i) s2-len-max)\n        (set! s2-len-max (string-length i))\n        '()))\n  (for ([i s2])\n    (if (< (string-length i) s2-len-min)\n        (set! s2-len-min (string-length i))\n        '()))\n  (for ([i s1])\n    (if (> (string-length i) s1-len-max)\n        (set! s1-len-max (string-length i))\n        '()))\n; (display s1-len-min)\n; (display s2-len-max)\n; (display s2-len-min)\n; (display s1-len-max)\n  (max (abs (- s2-len-max s1-len-min)) (abs (- s1-len-max s2-len-min))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290389,"user_id":null,"body":"#lang racket\n(provide mxdiflg)\n\n(define (mxdiflg s1 s2)\n  (if (and (not (null? s1))\n           (not (null? s2))) \n      (let ([min1 (string-length (argmin string-length s1))]\n            [max1 (string-length (argmax string-length s1))]\n            [min2 (string-length (argmin string-length s2))]\n            [max2 (string-length (argmax string-length s2))])\n        (max (abs (- min1 max2))\n           (abs (- max1 min2))))\n      -1)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"566543703c72200f0b0000c9":[{"id":290390,"user_id":53,"body":"#lang racket\n(provide epidemic)\n  \n(define (epidemic tm n s0 i0 b a)\n  (define (aux tm s i r t b a dt imax)\n    (cond\n       [(>= t tm) (exact-floor imax)]\n       [else (let* ([sd (* dt (* (* (* b -1) s) i))]\n                    [id (* dt (- (* b (* s i)) (* a i)))]\n                    [rd (* dt (* a i))]\n                    [s (+ s sd)]\n                    [i (+ i id)]\n                    [r (+ r rd)]\n                    [t (+ t dt)]\n                    [imax (max imax i)])\n                (aux tm s i r t b a dt imax))]))\n  (aux tm s0 i0 0.0 0.0 b a (\/ tm n) 0.0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290391,"user_id":492,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (define (epidemic-aux n dt prevS prevI prevR b a k mx)\n    (if (= k n)\n        (exact-floor mx)\n        (epidemic-aux \n         n\n         dt\n         (- prevS (* dt b prevS prevI))\n         (+ prevI (* dt (- (* b prevS prevI) (* a prevI))))\n         (+ prevR (* dt prevI a))\n         b\n         a\n         (add1 k)\n         (if (> prevI mx) prevI mx))\n        ))\n  (epidemic-aux n (\/ tm n) s0 i0 0.0 b a 0 -1.0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290392,"user_id":544,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (define dt (\/ tm n))\n  (for\/fold\n   ([sN s0] ; susceptible\n    [iN i0] ; infected\n    [rN 0]  ; recovered (0 to start)\n    #:result (exact-floor iN)) ; at the end, return just infected\n   ([t (in-naturals)])\n    (define i (+ iN (* dt (- (* b sN iN) (* a iN)))))\n    #:break (< i iN)\n    (define-values (s r)\n      (values (- sN (* dt b sN iN))\n              (+ rN (* dt iN a))))\n    (values s i r)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290393,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (let ([dt (\/ tm n)])\n    (epidemic-aux n dt s0 i0 0.0 b a 0 0.0)))\n\n(define (epidemic-aux n dt sk ik rk b a t mx)\n    (if (= t n)\n        (exact-floor mx)\n        \n        (let (\n              [sk+1 (- sk (* dt b sk ik))]\n              [ik+1 (+ ik (* dt (- (* b sk ik) (* a ik))))]\n              [rk+1 (+ rk (* dt ik a))]\n              [max-inf (max ik mx)])\n          (epidemic-aux n dt sk+1 ik+1 rk+1 b a (add1 t) max-inf))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290394,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (define dt (\/ tm n))\n  (exact-floor\n    (let loop ([s s0] [i i0] [day 0])\n      (let ([next-s (- s (* dt b s i))]\n            [next-i (+ i (* dt (- (* b s i) (* a i))))])\n        (if (= day n)\n            i\n            (max i (loop next-s next-i (+ day 1))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290395,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic-helper current interval tm s0 i0 b a r0 my-max)\n  (if (>= current tm)\n    (exact-truncate my-max)\n    (let* ([s1 (- s0 (* interval b s0 i0 ))]\n           [i1 (+ i0 (* interval (- (* b s0 i0) (* a i0))))]\n           [r1 (+ r0 (* interval i0 a))]\n           [new-current (+ current interval)]\n           [new-max (max my-max i1)])\n              (epidemic-helper new-current interval tm s1 i1 b a r1 new-max))))\n\n(define (epidemic tm n s0 i0 b a)\n  (epidemic-helper 0 (\/ tm n) tm s0 i0 b a 0 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290396,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (define dt (\/ tm n))\n  (let tick ([t 0] [st s0] [it i0] [maxi i0])\n    (cond\n      [(>= t tm) (exact-floor (max it maxi))]\n      [else\n       (tick (+ t dt)\n             (- st (* dt b st it))\n             (+ it (* dt (- (* b st it) (* a it))))\n             (max maxi it))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290397,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (define dt (\/ tm n))\n  (let loop ([s s0]\n             [i i0]\n             [r 0]\n             [t 0]\n             [ans 0])\n    (if (>= t n)\n        (inexact->exact (truncate (max ans i)))\n        (loop (- s (* dt b s i))\n              (+ i (* dt (- (* b s i) (* a i))))\n              (+ r (* dt i a))\n              (+ t 1)\n              (max ans i)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290398,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (define dt (\/ tm n))\n  (let loop ((s s0) (i i0) (r 0) (t 0) (res 0))\n    (if (> t tm)\n        (exact-floor res)\n        (loop (- s (* dt b s i))\n              (+ i (* dt (- (* b s i) (* a i))))\n              (+ r (* dt i a))\n              (+ t dt)\n              (max i res)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290399,"user_id":null,"body":"#lang racket\n(provide epidemic)\n\n(define (epidemic tm n s0 i0 b a)\n  (exact-floor (apply max (infected tm n s0 i0 b a ))))\n  \n(define (infected tm n s0 i0 b a )\n  (define dt (\/ tm n))\n\n  (define (iter i s acc index)\n  (cond\n    [(>= index n) acc]\n    [else\n     (iter (+ i (* (- (* b s) a) i dt)) (- s (* b s i dt)) (cons i acc) (add1 index))]))\n\n  (iter i0 s0 '() 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56676e8fabd2d1ff3000000c":[{"id":290400,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst)\n  (format \"found the needle at position ~a\"\n          (index-of lst \"needle\")))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290401,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst)\n  (string-append \"found the needle at position \" (number->string (index-of lst \"needle\")))\n)\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290402,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (needle-idx lst)\n  (if (equal? (car lst) \"needle\") 0 (+ 1 (needle-idx (cdr lst)))))\n\n(define (find_needle lst)\n  (format \"found the needle at position ~a\" (needle-idx lst)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290403,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst [acc 0])\n  (if (equal? \"needle\" (car lst))\n      (~a \"found the needle at position \" acc)\n      (find_needle (cdr lst) (add1 acc))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290404,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst)\n  (let ([pos (~a (index-of lst \"needle\"))]\n        [str \"found the needle at position \"])\n    (string-append str pos)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290405,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst)\n  (let ([lst-tail (member \"needle\" lst)]\n        [found-msg \"found the needle at position \"])\n    (when lst-tail\n      (~a found-msg\n          (apply - (map length\n                        (list lst lst-tail)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290406,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst [count 0])\n  (if (eq? \"needle\" (car lst)) (string-append \"found the needle at position \" (number->string count)) (find_needle (cdr lst ) (+ count 1)))\n)\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290407,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide find_needle)\n\n;; (listof Any) -> String\n;; given an array full of junk but containing one \"needle\",\n;; return a message saying at which index it is\n(define (find_needle lst)\n  (define i (index-of lst \"needle\"))\n  (string-append \"found the needle at position \" (number->string i)))\n\n(module+ test\n  (check-equal? (find_needle '(\"hay\" \"junk\" \"hay\" \"needle\" \"foo\"))\n                \"found the needle at position 3\"))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290408,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle ls)\n  (format \"found the needle at position ~a\" (index-of ls \"needle\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290409,"user_id":null,"body":"#lang racket\n\n(provide find_needle)\n\n(define (find_needle lst)\n  (letrec ([iterator (lambda (l i)\n                       (case (car l)\n                         [(\"needle\") (string-append \"found the needle at position \" (number->string i))]\n                         [else (iterator (cdr l) (add1 i))]))])\n    (iterator lst 0)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5667e8f4e3f572a8f2000039":[{"id":290410,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (accum s)\n  (string-join\n    (for\/list ([c s]\n               [n (in-naturals 1)])\n      (string-titlecase (make-string n c)))\n    \"-\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290411,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (accum s)\n  (string-join\n    (for\/list ([i (in-range (string-length s))]\n               [j (in-string s)])\n      (string-titlecase\n        (make-string (+ i 1) j)))\n    \"-\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290412,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (accum str)\n  (define (accum_ lst acc out)\n    (if (empty? lst)\n        out\n        (let [(str (make-string acc (car lst)))]\n          (accum_ (cdr lst) (add1 acc) (cons (string-titlecase str) out)))))\n  (string-join (reverse (accum_ (string->list str) 1 '())) \"-\"))\n\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290413,"user_id":null,"body":"#lang racket\n\n(provide accum)\n\n(define (accum s)\n  (define (accum-rec n ls)\n    (if (empty? (cdr ls))\n        (string-titlecase (make-string n (car ls)))\n        (string-append (string-titlecase (make-string n (car ls))) \"-\" (accum-rec (add1 n) (cdr ls)))))\n\n  (accum-rec 1 (string->list s)))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290414,"user_id":492,"body":"#lang racket\n(provide accum)\n\n(define (accum s)\n  (define (string-repeat n str)\n    (string-titlecase (string-append* (make-list n str))))\n  (let ([vv (map string (string->list s))])\n    (string-join (map (\u03bb (x y) (string-repeat (add1 y) x)) vv (range (string-length s))) \"-\")))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290415,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (replicate letter limit counter answer2)\n  (if (= counter (+ limit 1)) answer2\n    (if (= counter 1) (replicate letter limit (+ counter 1) (string-append answer2 (string-upcase letter))) (replicate letter limit (+ counter 1) (string-append answer2 (string-downcase letter)))))\n)\n\n(define (accum2 str lenS answer)\n  (if (= lenS 0) (string-trim answer \"-\")\n    (let ([letter (substring str (- lenS 1) lenS)])\n       (accum2 str (- lenS 1) \n         (string-append (replicate letter lenS 1 \"\") \"-\" answer))))\n)\n\n(define (accum s)\n  (let ([len (string-length s)]\n\t[answer \"\"])\n\t(accum2 s len answer))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290416,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (accum s)\n  (let ((inc 0))\n    (list->string (reverse (cdr (foldl (lambda (x y)\n\t\t\t\t(let ((strlst (make-list inc (char-downcase x))))\n\t\t\t\t  (set! inc (+ inc 1))\n\t\t\t\t  (cons #\\- (append (reverse (cons (char-upcase x) strlst)) y))))\n\t\t\t      '() (string->list s)))))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290417,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (accum s)\n  (define (ac s n)\n    (let\n      [(a (char-upcase (string-ref s n)))\n       (b (char-downcase (string-ref s n)))]\n          (string-join (list (make-string 1 a) (make-string n b)) \"\")))\n  (define (acc s i n)\n    (if (< i n)\n        (cons (ac s i) (acc s (+ 1 i) n))\n        '()))\n(string-join (acc s 0 (string-length s)) \"-\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290418,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (transform char times)\n  (string-titlecase (make-string times char)))\n\n(define (iter lst acc idx)\n  (if (empty? lst) acc\n    (iter\n     (rest lst)\n     (append acc (list (transform (first lst) idx)))\n     (add1 idx))))\n\n(define (accum s)\n  (string-join (iter (string->list s) '() 1) \"-\")\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290419,"user_id":null,"body":"#lang racket\n(provide accum)\n\n(define (accum s)\n  (string-join\n   (for\/list ([i (in-naturals 1)]\n              [c s])\n      (string-titlecase (make-string i c)))\n   \"-\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"566be96bb3174e155300001b":[{"id":290420,"user_id":492,"body":"#lang racket\n(provide max_ball)\n\n(define (max_ball v0)\n  (exact-round (\/ v0 3.5316)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290421,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n(define g 9.81)\n\n(define (dist a b)\n  (abs (- a b)))\n\n(define (tenths x)\n  (exact-floor (* 10 x)))\n\n(define (max_ball v0)\n  (letrec ([v1 (\/ (* 10 v0) 36)]\n           [t1 (\/ (floor   (* 10 (\/ v1 g))) 10)]\n           [t2 (\/ (ceiling (* 10 (\/ v1 g))) 10)]\n           [t0 (\/ v1 g)])\n   (if (< (dist t1 t0) (dist t2 t0))\n       (tenths t1)\n       (tenths t2)\n   )\n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290422,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n\n(define (height v0 t)\n  (let ((v0 (\/ v0 3.6))) ;; convert to m\/s\n  (- (* v0 t) (* 0.5 9.81 t t))))\n\n(define (max_ball v0)\n   (define (foo ult t)\n     (let ((bar (height v0 (\/ t 10))))\n       (if (< bar ult) (- t 1)\n           (foo bar (+ t 1)))))\n  (foo (height v0 0) 1)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290423,"user_id":50,"body":"#lang racket\n(provide max_ball)\n\n(define (max_ball v0)\n  ( quotient (+ (* v0 56630) 100000)  200000)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290424,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n(define (max_ball v0)\n  (let ([v (* v0 1000\/36000)]\n        [g 0.0981])\n    (exact-round (\/ v g))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290425,"user_id":544,"body":"#lang racket\n(provide max_ball)\n\n; 1 m\/s = 3.6 kmh\n(define (km\/h->m\/s v) (\/ v 3.60))\n(define g 9.81)\n\n; v = v0 - gt\n; since v = 0 at the apex of flight, 0 = v0 - gt\n; or t = v0\/g\n(define (max_ball v0)\n  (exact-round (* (\/ (km\/h->m\/s v0) g) 10)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290426,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n(define (max_ball v0)\n  (exact-round (* v0 0.283158))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290427,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n; Gravity\n(define g 9.81)\n\n; X of the parabola defined by:\n; h = vt - 1\/2 * gt^2\n; The parabola will always be the highest point\n; if the velocity is not negative\n(define (max-height velocity)\n  (\/ velocity g))\n\n; Convert from km\/h to m\/s\n(define (kmph->mps kmph)\n  (\/ (* kmph 5) 18))\n\n; Round to the closest tenth\n(define (round-tenth x)\n  (round (* x 10)))\n\n(define (max_ball v0)\n  ; Go from floating point to integer\n  (inexact->exact \n   (round-tenth \n    (max-height (kmph->mps v0)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290428,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n(define (max_ball v0)\n  (let ([v (\/ (* 1000 v0) 3600)]) \n    (define (calc t prev)\n      (let ([h (- (* t v) (* 0.5 9.81 (expt t 2)))])\n;        (print h)\n        (cond\n          [(> prev h) (sub1 (exact-round (* t 10)))]\n          [else (calc (+ 0.1 t) h)])))\n\n    (calc 0 0)))\n                    \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290429,"user_id":null,"body":"#lang racket\n(provide max_ball)\n\n(define (max_ball v0)\n  (let ([v (\/ v0 3.6)])\n    (exact-round (\/ v 0.981))))\n  ; well, physics","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"566fc12495810954b1000030":[{"id":290430,"user_id":168,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig n d)\n  (define c (string-ref (~a d) 0))\n  (for\/sum [(k (range (add1 n)))]\n           (count (curry equal? c) \n                  (string->list (number->string (sqr k))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290431,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (digits n) \n  (let loop ((acc '()) (i n)) \n    (if (< i 10) \n        (cons i acc) \n        (loop \n         (cons (remainder i 10) acc) \n         (floor (\/ i 10))))))\n\n(define (nb_dig n d)\n  (let loop ((i 0) (sum 0))\n    (if (> i n) sum\n        (loop (add1 i) \n          (+ sum (count \n            (lambda (x) (eq? x d)) \n            (digits (* i i))))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290432,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (check-digits number k l digit counter)\n  (if (= l 0) (nb_dig2 number k digit counter)\n    (let ([i (remainder l 10)])\n      (if (eq? i digit) (check-digits number k (quotient l 10) digit (+ counter 1)) \n        (check-digits number k  (quotient l 10) digit counter))))\n)\n\n(define (nb_dig2 number k digit counter)\n  (if (= k number) counter \n    (let ([l (expt (+ k 1) 2)])\n      (check-digits number (+ k 1) l digit counter)))\n)\n\n(define (nb_dig n d)\n  (if (= d 0) (nb_dig2 n -1 d 1)\n    (nb_dig2 n -1 d 0))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290433,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig n d)\n  (length (filter (lambda (x) (char=? x (string-ref (format \"~a\" d) 0))) \n          (string->list \n           (string-join \n            (map (lambda (x) (format \"~a\" (* x x))) (range 0 (+ n 1) 1)) \n            \"\"))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290434,"user_id":53,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig a b)\n  (let f ([n a] [d b] [m 0] [i 0] [s 0] [k 0])\n    (cond\n      [(and (zero? s) (> i n)) m]\n      [(and (zero? s) (zero? i) (zero? d)) (f n d (add1 m) (add1 i) s k)]\n      [(zero? s) (f n d m i 1 (* i i))]\n      [(<= k 0) (f n d m (add1 i) 0 0)]\n      [else (f n d (if (= d (modulo k 10)) (add1 m) m) i 1 (quotient k 10))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290435,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig n d)\n  (for\/sum ([i (in-naturals)]\n             #:break (> i n))\n    (ctd (sqr i) d)))\n\n;; Count The Digit `d` in `n`\n(define (ctd n d)\n  (define d-char (string-ref (number->string d) 0))\n  (string-length (list->string (filter (curry d? d-char) (string->list (number->string n))))))\n\n(define (d? d n-item)\n  (char=? d n-item))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290436,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig n d)\n  (for*\/sum\n    ([k (+ n 1)]\n     [c (~a (* k k))])\n    (if (= (- (char->integer c) 48) d) 1 0)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290437,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig n d)\n  (sequence-count\n    (curry eq? (integer->char (+ d 48)))\n    (string-join (for\/list\n      ([k (range (+ n 1))])\n      (~r (* k k))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290438,"user_id":null,"body":"#lang racket\n(provide nb_dig)\n\n(define (nb_dig n d)\n  (for\/sum\n    ([k (range (+ n 1))])\n    (count\n      (curry string=? (~r d))\n      (string-split (~r (* k k)) \"\"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290439,"user_id":436,"body":"#lang racket\n(provide nb_dig)\n\n(define (count-dig n d) \n  (if (= n 0) \n      0\n      (+ (count-dig (quotient n 10) d) (if (= d (modulo n 10)) 1 0))))\n\n(define (nb_dig n d)\n  (if (= n 0) \n    (if (= d 0) 1 0)\n    (+ (count-dig (* n n) d) (nb_dig (- n 1) d)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"567501aec64b81e252000003":[{"id":290440,"user_id":null,"body":"#lang racket\n(provide wallpaper)\n\n(define numbers '(0 \"one\" \"two\" \"three\" \"four\" \"five\" \"six\"\n                    \"seven\" \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\"\n                    \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\"\n                    \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\"))\n(define (wallpaper l w h)\n  (let* ([room-size (if (zero? (* l w h)) 0 (+ (* 2 l h) (* 2 w h)))]\n         [plus-error-margin (* room-size 1.15)]\n         [number-of-rolls (\/ plus-error-margin 5.2)])\n    (list-ref numbers (exact-ceiling number-of-rolls))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290441,"user_id":492,"body":"#lang racket\n(provide wallpaper)\n\n(define (wallpaper l w h)\n  (if (= 0 (* l w h))\n    0\n    (let ( [dict #[\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\"\n                  \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\" \"fifteen\"\n                  \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\"] ]\n          [ a (* 1.15 (\/ (* 2 h (+ l w)) 5.2)) ])\n      (vector-ref dict (exact-ceiling a)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290442,"user_id":null,"body":"#lang racket\n\n(provide wallpaper)\n\n(define (wallpaper l w h)\n  (let ([has-zero-arg (or (= l 0) (= w 0) (= h 0))])\n    (if (not has-zero-arg)\n        (let ([required-num-rolls (ceiling (\/ (* 1.15 (+ (* 2 l h) (* 2 w h))) 5.2))])\n          (number->english required-num-rolls))\n        0)))\n\n(define (number->english x)\n  (case (inexact->exact x)\n    [(1) \"one\"]\n    [(2) \"two\"]\n    [(3) \"three\"]\n    [(4) \"four\"]\n    [(5) \"five\"]\n    [(6) \"six\"]\n    [(7) \"seven\"]\n    [(8) \"eight\"]\n    [(9) \"nine\"]\n    [(10) \"ten\"]\n    [(11) \"eleven\"]\n    [(12) \"twelve\"]\n    [(13) \"thirteen\"]\n    [(14) \"fourteen\"]\n    [(15) \"fifteen\"]\n    [(16) \"sixteen\"]\n    [(17) \"seventeen\"]\n    [(18) \"eighteen\"]\n    [(19) \"nineteen\"]\n    [(20) \"twenty\"]\n    [else \"N\/A\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290443,"user_id":53,"body":"#lang racket\n(provide wallpaper)\n\n(define (wallpaper l w h)\n  (if (zero? (* l w h)) 0\n    (let ([ns #[\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"ten\" \n                \"eleven\" \"twelve\" \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\"]])\n      (vector-ref ns (exact-ceiling (\/ (* 2.3 h (+ l w)) 5.2))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290444,"user_id":null,"body":"#lang racket\n(provide wallpaper)\n\n; return the number 0 if the number of rolls is zero\n(define words (hash 0 0 1 \"one\" 2 \"two\" 3 \"three\" 4 \"four\" 5 \"five\" 6 \"six\" 7 \"seven\" 8 \"eight\" 9 \"nine\" 10 \"ten\" 11 \"eleven\" 12 \"twelve\" 13 \"thirteen\" 14 \"fourteen\" 15 \"fifteen\" 16 \"sixteen\" 17 \"seventeen\" 18 \"eighteen\" 19 \"nineteen\" 20 \"twenty\"))\n(define (wallpaper l w h)\n  (if (ormap zero? (list l w h)) 0\n      (hash-ref words (inexact->exact (ceiling (\/\n       (*\n        (* 2 (* h (+ w l)))\n        1.15)\n       (* 10 0.52))))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290445,"user_id":null,"body":"#lang racket\n(provide wallpaper)\n\n(define (wallpaper l w h)\n  (list-ref\n    (list 0 \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\")\n    (inexact->exact (ceiling (*\n      (sgn (* l w h))\n      23\/52\n      (+ l w)\n      h)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290446,"user_id":null,"body":"#lang racket\n(provide wallpaper)\n\n(define (wallpaper l w h)\n  (list-ref\n    (list 0 \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\")\n    (inexact->exact (ceiling (*\n      (for\/product ([x `(,l ,w ,h)]) (sgn x))\n      23\/52\n      (+ l w)\n      h)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290447,"user_id":544,"body":"#lang racket\n(provide wallpaper)\n\n(define english-numbers (list \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\"\n                              \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\"\n                              \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\" \n                              \"eighteen\" \"nineteen\" \"twenty\"))\n\n(define (wallpaper l w h)\n  (list-ref english-numbers (exact-ceiling (* (\/ (* 2 (+ l w) h) 10 0.52) 1.15)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290448,"user_id":null,"body":"#lang racket\n\n(provide wallpaper)\n\n(define NUMBERS\n  '(\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\"\n           \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\"\n           \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\" \"twenty\"))\n\n(define ROLL-WIDTH 0.52) ;; meters\n(define ROLL-LENGTH 10) ;; meters\n\n;; Float>=0 Float>=0 Float>=0 -> String\n;; given length, width and height of a room (in meters), return the number of\n;; rolls needed to decorate the room's walls entirely (+ 15% extra just in case)\n(define (wallpaper l w h)\n  (let* ([area-to-cover (* 1.15 (+ (* w h 2) (* l h 2)))]\n         [rolls-needed (ceiling (\/ area-to-cover (* ROLL-WIDTH ROLL-LENGTH)))])\n    (list-ref NUMBERS (inexact->exact rolls-needed))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290449,"user_id":null,"body":"#lang racket\n(provide wallpaper)\n(require racket\/match)\n\n(define (wallpaper l w h)\n  (define (needed l w h) (if (= (* l w h) 0) 0 (\/ (* 2 h (+ l w)) 5.2)))\n  \n  (match (inexact->exact (ceiling (* 1.15 (needed l w h))))\n    (0 \"zero\") (1 \"one\") (2 \"two\") (3 \"three\")\n    (4 \"four\") (5 \"five\") (6 \"six\") (7 \"seven\")\n    (8 \"eight\") (9 \"nine\") (10 \"ten\") (11 \"eleven\")\n    (12 \"twelve\") (13 \"thirteen\") (14 \"fourteen\") (15 \"fifteen\")\n    (16 \"sixteen\") (17 \"seventeen\") (18 \"eighteen\")\n    (19 \"nineteen\") (20 \"twenty\") (_ \"too much!\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"568dcc3c7f12767a62000038":[{"id":290450,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define (set_alarm employed vacation)\n  (and employed (not vacation)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290451,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define (set_alarm e v)\n  (and e (not v)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290452,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define (set_alarm employed vacation)\n  (match (list employed vacation)\n    ['(#t #t) #f]\n    [(list #f _) #f]\n    ['(#t #f) #t]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290453,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define set_alarm (\u03bb (e v) (and e (not v))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290454,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define (set_alarm employed vacation)\n  (not (implies employed vacation)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290455,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define set_alarm\n  (lambda (employed vacation)\n    (and (not vacation) employed)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290456,"user_id":50,"body":"#lang racket\n\n(provide set_alarm)\n\n(define (set_alarm employed vacation)\n ( and ( eq? #t employed ) ( not vacation ) )\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290457,"user_id":544,"body":"#lang racket\n\n(provide set_alarm)\n\n(define\/match (set_alarm employed vacation)\n  [(#t #f) #t]\n  [(_ _) #f])\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290458,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n(define (set_alarm employed vacation)\n  (cond \n        ((and employed (not vacation)) #t)\n        (else #f)\n        ))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290459,"user_id":null,"body":"#lang racket\n\n(provide set_alarm)\n\n;; Boolean Boolean -> Boolean\n;; return #t if you need to set an alaram (read: you are employed but not on\n;; vacation), #f otherwise\n(define (set_alarm employed vacation)\n  (and employed (not vacation)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"569b5cec755dd3534d00000f":[{"id":290460,"user_id":53,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg arr u)\n  (let* ([s (apply + arr)]\n         [n (length arr)]\n         [x (- (* u (+ n 1)) s)])\n    (if (< x 0)\n        (raise-argument-error \"error\" u)\n        (exact-ceiling x))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290461,"user_id":168,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg ls navg)\n  (let ([x (- (* (add1 (length ls)) navg) (apply + ls))])\n    (if (<= x 0) (error) (exact-ceiling x))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290462,"user_id":null,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg ls navg)\n  ; your code\n  (define number (exact-ceiling(-(* navg (+ 1(length ls))) (sum ls))))\n  (if (< number 0)\n      (raise-argument-error)\n      number\n      )\n  \n)\n(define (sum x)\n    (if (null? x)\n        0\n        (+ (car x) (sum (cdr x)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290463,"user_id":null,"body":"#lang racket\n(provide new-avg)\n(require racket\/fixnum)\n\n(define (new-avg ls navg)\n  ; your code\n  (define (myavg ls)\n    (\/ (apply + ls) (length ls)))\n  (let*\n    ([a (apply + ls)]\n     [n (length ls)]\n     [a2 (* navg (add1 n))]\n     [a3 (floor (- a2 a))]\n     [a3 (if (flonum? a3) (fl->fx a3) a3)])\n    (cond\n     [(>= 0 a3) (error)]\n     [(> navg (myavg (cons a3 ls))) (add1 a3)]\n     [else a3])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290464,"user_id":null,"body":"#lang racket\n\n(define (new-avg ls navg)\n  (exact-ceiling\n   (- (* navg (add1 (length ls)))\n      (foldr + 0 ls))))\n\n(provide\n (contract-out\n  [new-avg (-> list? number? positive?)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290465,"user_id":null,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg ls navg)\n  (define next-donation\n    (inexact->exact \n     (ceiling (- (* navg\n                    (+ 1 (length ls)))\n                 (foldl + 0 ls)))))\n  (if (>= 0 next-donation)\n      (raise-argument-error 'new-avg\n                            \"(and number? (< 0))\")\n      next-donation))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290466,"user_id":null,"body":"#lang racket\n\n(provide new-avg)\n\n;; (Listof Number>0) Number>0 -> Number\n;; Given a list with donations already made, and an expected average, return\n;; the expected next donation that will permit reaching the expected average\n;; Raise an enxception if result is <=0.\n(define (new-avg ls navg)\n  (define expected (exact-ceiling (- (* navg (add1 (length ls))) (apply + ls))))\n  (if (<= expected 0)\n      (raise-argument-error 'raise-your-expectations \"last donation>=0\" navg)\n      expected))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290467,"user_id":null,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg ls navg)\n  (let* ([current-sum (apply + ls)]\n         [len ( + (length ls) 1)]\n         [target (inexact->exact (ceiling (- (* navg len) current-sum)))])\n    (if (<= target 0)\n        (raise-argument-error 'new-avg \"Int > 0\" target)\n        target)))\n         ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290468,"user_id":null,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg ls navg)\n    (define l (+ (length ls) 1))\n    (define s (apply + ls))\n    (define result (exact-ceiling (- (* l navg) s)))\n    (if (positive? result) result (raise-argument-error 'Negative result \"negative?\" result))\n)\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290469,"user_id":null,"body":"#lang racket\n(provide new-avg)\n\n(define (new-avg ls navg)\n  (let ([rv (- (* navg (add1 (length ls))) (apply + ls))])\n    (if (< rv 0)\n        (raise-arguments-error )\n        (exact-ceiling rv))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56a32dd6e4f4748cc3000006":[{"id":290470,"user_id":492,"body":"#lang racket\n(provide mean variance)\n\n(define (mean-variance twn strng)\n  (define (mean ls)\n    (let ((len (length ls)))\n      (if (zero? len) 0.0 (\/ (apply + ls) len))))\n\n  (define (variance li)\n    (let ((len (length li)))\n      (if (zero? len)\n          0.0\n          (let ((mu (mean li)))\n            (define (disparity val)\n              (sqr (- mu val)))\n            (\/ (apply + (map disparity li)) len)))))\n\n  (define (find-town-nb twn strng)\n    (let* ([lls (map (\u03bb(x) (string-split x \":\")) (string-split strng \"\n\"))]\n           [line (filter (\u03bb(x) (equal? (first x) twn)) lls)]\n           [found (if (empty? line) '() (string-split (second (first line)) \",\"))])   \n      (if (empty? found)\n          '()\n          (map string->number (map (\u03bb(x) (second (string-split x \" \"))) found)))))\n  \n  (let ([ls (find-town-nb twn strng)])\n    (if (empty? ls) (cons -1 -1) (cons (mean ls) (variance ls)))))\n\n(define (mean twn strng)\n  (car (mean-variance twn strng)))\n\n(define (variance twn strng)\n  (cdr (mean-variance twn strng)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290471,"user_id":null,"body":"#lang racket\n(provide mean variance)\n\n(define (parse-line line)\n  (let* ([town\/months (string-split line \":\")]\n         [town (first town\/months)]\n         [months (second town\/months)]\n         [rain (map (\u03bb (x) (string->number (second (string-split x \" \"))))\n                    (string-split months \",\"))])\n         (cons town rain)))\n\n(define (parse strng)\n  (make-hash (map parse-line (string-split strng \"\n\"))))\n\n(define (calc-mean xs)\n  (\/ (apply + xs) (length xs)))\n\n(define (mean twn strng)\n  (let ([rainfall (parse strng)])\n    (calc-mean (hash-ref rainfall twn (\u03bb () '(-1))))))\n\n(define (square x)\n  (* x x))\n\n(define (calc-variance xs)\n  (let ([\u00b5 (calc-mean xs)])\n    (calc-mean (map (\u03bb (x) (square (- x \u00b5))) xs))))\n\n(define (variance twn strng)\n  (let ([rainfall (parse strng)])\n    (if (hash-has-key? rainfall twn)\n        (calc-variance (hash-ref rainfall twn))\n        -1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290472,"user_id":null,"body":"#lang racket\n\n(provide mean variance)\n\n(define (mean town str)\n  (let ((numbers (get-numbers town str)))\n    (if numbers\n        (average numbers)\n        -1)))\n\n(define (variance town str)\n  (let ((numbers (get-numbers town str)))\n    (if numbers\n        (let* ((mean (average numbers))\n               (squared-deviations (map (\u03bb (x) (expt (- x mean) 2)) numbers))\n               (quotient (\/ (foldr + 0 squared-deviations) (length numbers))))\n          quotient)\n        -1)))\n\n(define (average numbers)\n  (\/ (foldl + 0 numbers) (length numbers)))\n\n(define (get-numbers target-town str)\n  (let ((line (findf\n               (\u03bb (l) (let ((town (car (string-split l \":\"))))\n                        (equal? town target-town)))\n               (string-split str \"\n\"))))\n    (and\n     line\n     (map string->number (regexp-match* (pregexp \"\\\\d+\\\\.\\\\d\") line)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290473,"user_id":544,"body":"#lang racket\n(provide mean variance)\n\n(define (mean twn strng)\n  (define raw-rainfall-data (filter (lambda (s) (string-prefix? s (string-append twn \":\"))) (string-split strng \"\n\")))\n  (cond [(empty? raw-rainfall-data) -1]\n        [else (define rainfall-data\n                (map string->number (string-split (regexp-replace* #rx\"[a-zA-Z:,]\" (car raw-rainfall-data) \"\") \" \")))\n              (\/ (apply + rainfall-data) (length rainfall-data))]))\n\n(define (variance twn strng)\n  (define raw-rainfall-data (filter (lambda (s) (string-prefix? s (string-append twn \":\"))) (string-split strng \"\n\")))\n  (cond [(empty? raw-rainfall-data) -1]\n        [else (define rainfall-data\n                (map string->number (string-split (regexp-replace* #rx\"[a-zA-Z:,]\" (car raw-rainfall-data) \"\") \" \")))\n              (let ([rain-mean (\/ (apply + rainfall-data) (length rainfall-data))])\n                (\/ (foldl (lambda (rain var) (+ var (expt (- rain rain-mean) 2))) 0 rainfall-data) (length rainfall-data)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290474,"user_id":null,"body":"#lang racket\n(provide mean variance)\n\n(define (parse-data str)\n  (for\/list ([line (string-split str \"\n\")])\n    (match (regexp-match #rx\"(.+):(.+)\" line)\n      [(list _ city more)\n       (list city \n             (for\/list ([month (string-split more \",\")])\n               (match (regexp-match #rx\"(.+) (.+)\" month)\n                 [(list _ _ num) (string->number num)])))])))\n\n(define (calc twn strng func)\n  (match (assoc twn (parse-data strng))\n    [(list _ nums) (func nums)]\n    [#f -1]))\n\n(define (mean.f nums)\n  (\/ (apply + nums)\n     (length nums)))\n     \n(define (variance.f nums)\n  (define mean (mean.f nums))\n  (\/ (apply + \n            (map (lambda (n) (sqr (- n mean))) nums))\n     (length nums)))\n\n(define (mean twn strng)\n  (calc twn strng mean.f))\n\n(define (variance twn strng)\n  (calc twn strng variance.f))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290475,"user_id":null,"body":"#lang racket\n(provide mean variance)\n\n(define (flip f)\n  (lambda (a b) (f b a))\n  )\n\n(define (mean-num ns)\n  (if\n   (null? ns)\n   -1\n   ((compose\n     (curry (flip \/) (length ns))\n     (curry foldr + 0.0)\n     ) ns)\n   )\n  )\n\n(define (var-num ns)\n  (if\n   (null? ns)\n   -1\n   (let ([m (mean-num ns)])\n     (mean-num\n      (map\n       (compose\n        (curry (flip expt) 2)\n        (curry - m)\n        )\n       ns\n       )\n      )\n     )\n   )\n  )\n\n(define (parse-rainfalls strng)\n  (if\n   (equal? \"\" strng)\n   null\n   (map\n    (compose\n     string->number\n     cadr\n     (lambda (v) (string-split v \" \"))\n     )\n    (string-split strng \",\")\n    )\n   )\n  )\n\n(define (twn-rec twn strng)\n  ((lambda (v) (if (false? v) \"\" (cadr v)))\n   (assoc\n    twn\n    (map\n     (lambda (v) (string-split v \":\"))\n     (string-split strng \"\n\")\n     )\n    )\n   )\n  )\n\n(define (mean twn strng)\n  ((compose\n    mean-num\n    parse-rainfalls\n    ) (twn-rec twn strng))\n  )\n\n(define (variance twn strng)\n  ((compose\n    var-num\n    parse-rainfalls\n    ) (twn-rec twn strng))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290476,"user_id":null,"body":"#lang racket\n(provide mean variance)\n\n(define (parse twn strng)\n  (define matches (regexp-match (format \"~a:(.*?)\\r?\n\" twn) strng))\n  (if matches\n      (map (\u03bb (n)\n              (string->number (cadr (string-split n \" \"))))\n        (string-split (cadr matches) \",\"))\n      #f))\n\n(define (mean twn strng)\n  (define l (parse twn strng))\n  (if l\n      (\/ (apply + l) (length l))\n      -1))\n\n(define (variance twn strng)\n  (define l (parse twn strng))\n  (define m (mean twn strng))\n  (if l\n      (\/ (foldl (\u03bb (x y) (+ (sqr (- x m)) y)) 0 l)\n         (length l))\n      -1))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56a4872cbb65f3a610000026":[{"id":290477,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (getDivisor number divisor)\n  (if (= (quotient number divisor) 0) (\/ divisor 10) (getDivisor number (* 10 divisor)))\n)\n\n(define (rotate variable divisor)\n  (let ([tail (quotient variable divisor)]\n\t[head (remainder variable divisor)])\n    (+ (* head 10) tail))\n)\n\n(define (max_rot2 number answer divisor)\n  (if (= divisor 0) answer\n    (max_rot2 (+ (* (quotient number (* 10 divisor)) 10 divisor) (rotate (remainder number (* divisor 10)) divisor)) (max answer number) (quotient divisor 10)))\n)\n\n(define (max_rot n)\n  (let ([divisor (getDivisor n 1)])\n    (max_rot2 n n divisor))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290478,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (rotations items)\n  (letrec\n    ([items-len (length items)]\n     [rotate (lambda (x) (if (null? x) '() (append (cdr x) (list (car x)))))]\n     [make (lambda (r n)\n             (if (>= n items-len) '()\n                 (let\n                   ([new-rot (append (take r n) (rotate (drop r n)))])\n                   (cons new-rot (make new-rot (add1 n))))))])\n    (cons items (make items 0))))\n\n(define (max_rot n)\n  (apply max\n    (map\n      (lambda (x) (string->number (list->string x)))\n      (rotations (string->list (number->string n))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290479,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (max_rot n)\n  (define (listring n) (string->list (number->string n)))\n  (define (reve lis)\n    (append (list-tail lis 1) `(,(list-ref lis 0))))\n  (define (max-iter lis i)\n    (if (empty? lis)\n        '()\n        (append (take lis i) (reve (list-tail lis i))))\n    )\n  \n    (define (construct-limax lis lis2 i)\n      (if (= i (- (length lis) 1))\n          lis2\n          (construct-limax lis (append lis2 `(,(string->number (apply string (max-iter (listring (last lis2)) i))))) (add1 i)))\n      )\n  (apply max (construct-limax (listring n) `(,n) 0))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290480,"user_id":544,"body":"#lang racket\n(provide max_rot)\n\n(define (max_rot n)\n  (define n-string (number->string n))\n  (apply max\n         (map string->number\n              (for\/fold ([number-to-rotate n-string]\n                         [left-hand-side \"\"]\n                         [candidate-list (list n-string)]\n                         #:result candidate-list)\n                        ([iter (in-range 1 (sub1 (string-length n-string)))])\n                (let* [(rotate-sub-string\n                        (string-append (substring number-to-rotate 1 (string-length number-to-rotate))\n                                       (substring number-to-rotate 0 1)))\n                       (new-left-hand-side (substring rotate-sub-string 0 1))]\n                  (values (substring rotate-sub-string 1 (string-length rotate-sub-string))\n                          (string-append left-hand-side new-left-hand-side)\n                          (cons (string-append left-hand-side rotate-sub-string) candidate-list)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290481,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (string-rotate-left s)\n  (define len (string-length s))\n  (if (len . < . 2)\n      s\n      (string-append (substring s 1 len)\n                     (substring s 0 1))))\n\n(define (max_rot n)\n  (define str (number->string n))\n  (define len (string-length str))\n\n  (define candidates\n    (for\/fold ([str str]\n               [lst null]\n               #:result lst)\n              ([i (in-range len)])\n      (define frozen (substring str 0 i))\n      (define others (substring str i len))\n      (define shifted (string-append frozen (string-rotate-left others)))\n      (values shifted\n              (cons (string->number shifted)\n                    lst))))\n\n  (for\/first ([val (in-list (sort (cons n candidates) >))])\n    val))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290482,"user_id":null,"body":"#lang racket\n\n(provide max_rot)\n\n(module+ test\n  (require rackunit))\n\n;; Integer>0 -> Integer>0\n;; return the highest number you get by rotating n \"recursively\"\n(define (max_rot n)\n  (apply max (rotate n)))\n\n(module+ test\n  (check-equal? (max_rot 38458215) 85821534))\n\n\n;; Integer>0 -> (Listof Integer>0)\n;; rotate n \"recursively\"\n(define (rotate n)\n\n  (define (number->list n)\n    (string->list (number->string n)))\n\n  (define (list->number lst)\n    (string->number (apply string lst)))\n\n  (define l (number->list n))\n  \n  (define (recur accum left right i)\n    (cond\n      [(= i (length l)) accum]\n      [else\n       (let* ([new-n (append left (rotatel right))]\n              [left (take new-n i)]\n              [right (drop new-n i)])\n         (recur (append accum (list (list->number new-n)))\n           left\n           right\n           (add1 i)))]))\n\n  (recur (list n) '() l 1))\n\n(module+ test\n  (check-equal? (rotate 56789) '(56789 67895 68957 68579 68597)))\n\n\n;; (Listof Any) -> (Listof Any)\n;; rotate a list to the left once\n(define (rotatel lst)\n  (if (empty? lst)\n      '()\n      (append (rest lst) (cons (first lst) '()))))\n\n(module+ test\n  (check-equal? (rotatel '()) '())\n  (check-equal? (rotatel '(1 2 3)) '(2 3 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290483,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (rotate-left number-string)\n  (string-append (substring number-string 1) (substring number-string 0 1)))\n\n(define (numberlist list number rotations)\n  (if (equal? (length list) (string-length number))\n      list\n      (numberlist (cons (string-append (substring number 0 rotations) (rotate-left (substring number rotations))) list)\n                  (string-append (substring number 0 rotations) (rotate-left (substring number rotations)))\n                  (add1 rotations))))\n\n(define (max_rot n)\n  (apply max (map string->number (numberlist (list (number->string n)) (number->string n) 0))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290484,"user_id":168,"body":"#lang racket\n(provide max_rot)\n\n(define (max_rot n)\n  (define (rotate s i)\n    (string-append (substring s 0 i) \n                   (substring s (add1 i))\n                   (substring s i (add1 i))))\n  (for\/fold ([r n] [s (~a n)] #:result r)\n            ([i (range (string-length (~a n)))])\n            (values (max r (string->number s)) (rotate s i)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290485,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (rot str n)\n  (format \"~a~a~a\"\n          (substring str 0 n)\n          (substring str (add1 n))\n          (string-ref str n)))\n\n(define (max_rot n)\n  (let* ([str (number->string n)]\n         [len (string-length str)])\n    (for\/fold ([num str]\n               [max-num n] #:result max-num)\n              ([i (range 0 len)])\n      (values (rot num i) (max max-num (string->number num))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290486,"user_id":null,"body":"#lang racket\n(provide max_rot)\n\n(define (string-rotate! str begin)\n  (let ([strCopy (string->immutable-string str)])\n    (for ([i (range (- (- (string-length str) begin) 1))])\n      (let ([cursor (+ begin i)])\n        (string-set! str cursor (string-ref strCopy (add1 cursor)))))\n    (string-set! str (- (string-length str) 1) (string-ref strCopy begin))))\n\n(define (max_rot n)\n  (define nStr (number->string n))\n  (apply max (cons n (for\/list ([i (range (- (string-length nStr) 1))])\n                       (string-rotate! nStr i)\n                       (string->number nStr)))))\n                       ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56a5d994ac971f1ac500003e":[{"id":290487,"user_id":544,"body":"#lang racket\n(provide longest_consec)\n\n(define (longest_consec ls k)\n  (define zip-strings\n    (cond\n      [(= k 0) '(\"\")]\n      [(> k (length ls)) '(\"\")]\n      [(= k 1) ls]\n      [else\n       (for\/list ([i (in-range 0 (- (length ls) (sub1 k)))])\n         (string-join (take (drop ls i) k) \"\"))]))\n  (argmax string-length zip-strings))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290488,"user_id":492,"body":"#lang racket\n(provide longest_consec)\n\n(define (longest_consec ls k)\n  (define (partition lst n)\n    (cond ( (empty? lst) lst)\n          ( (< (length lst) n) '())\n          ( else (cons (take lst n) (partition (drop lst 1) n)))))\n  (if (or (empty? ls) (> k (length ls)) (<= k 0))\n      \"\"\n      (let* ([part (partition ls k)]\n             [part1 (map (\u03bb(x) (string-join x \"\")) part)])\n        (first (sort part1 (\u03bb (x y) (> (string-length x) (string-length y))))))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290489,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n\n(define (groups n items)\n  (if (< (length items) n) '()\n    (cons\n      (string-join (take items n) \"\")\n      (groups n (cdr items)))))\n\n(define (longest_consec ls k)\n  (if (or (null? ls) (> k (length ls)) (< k 1)) \"\"\n    (argmax string-length (groups k ls))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290490,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n\n(define (longest_consec ls k)\n  (define (getn l n)\n    \"concat of first n strings in l or #f\"\n    (cond [(> n (length l) ) #f]\n          [(zero?  n) \"\"]\n          [else (string-append (car l) (getn (cdr l) (- n 1)))]))\n  (define (loop l  best)\n    (let ([candidate (getn l k)])\n      (cond\n        [(or(null? l)(not candidate)) best]\n        [(> (string-length candidate) (string-length best)) (loop (cdr l) candidate)]\n        [else (loop (cdr l) best)])))\n  (loop ls \"\"))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290491,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n\n(define (longest_consec ls k)\n  (if (or (> k (length ls))\n          (<= k 0)\n          (zero? (length ls))) \"\"\n                                      (letrec ([result (lst->num ls k)]\n                                               [p (assoc (max-lst result) result)])\n                                        (if (list? p) (car (cdr p)) \"\"))))\n\n(define (lst->num ls k)\n  (letrec ([ls2 (concat ls k)]\n           [f (lambda (ls3)\n                (cond [(empty? ls3) empty]\n                      [else (cons (list (string-length (car ls3)) (car ls3))\n                                  (f (cdr ls3)))]))])\n    (f ls2)))\n\n(define (max-lst ls)\n  (cond [(empty? (cdr ls)) (car (car ls))]\n        [else (max (car (car ls)) (max-lst (cdr ls)))]))\n\n(define (concat ls k)\n  (cond [(empty? (cdr ls)) (list (car ls))]\n        [else (cons (str ls k) (concat (cdr ls) k))]))\n\n(define (str ls k)\n  (cond [(or (empty? ls) (zero? k)) \"\"]\n        [else (string-append (car ls) (str (cdr ls) (sub1 k)))]))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290492,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n\n(define (longest_consec ls k)\n  (define (join ls k)\n    (cond\n     [(null? ls) \"\"]\n     [(pair? ls) (if (= k 0) \"\"\n                     (string-append (car ls) (join (cdr ls) (sub1 k))))]\n     [else (if (= k 0) \"\" ls)]))\n  (if (null? ls) \"\"\n      (if (< (length ls) k) \"\"\n      (let ([candidate1 (longest_consec (cdr ls) k)]\n            [candidate2 (join ls k)])\n        (if (>= (string-length candidate2) (string-length candidate1))\n            candidate2\n            candidate1))))\n)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290493,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n\n;; (: longest_consec : (Listof String) Integer -> String)\n(define (longest_consec ls k)\n  (define zip-strings\n    (cond [(= k 0) '(\"\")]\n          [(> k (length ls)) '(\"\")]\n          [(= k 1) ls]\n          [else\n           (for\/list ;; (Listof String)\n             ([i (in-range 0 (- (length ls) (sub1 k)))])\n             (string-join (take (drop ls i) k) \"\"))]))\n  (argmax string-length zip-strings))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290494,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n\n\n(define (longest_consec ls k)\n\n  (define (loop droped-list appended-string-list)\n    (if (> (length droped-list) (sub1 k))\n        (let* ([appended (apply string-append (take droped-list k))]\n               [appended-list (cons appended appended-string-list)]\n               [droped (if (empty? droped-list)\n                           empty\n                           (drop droped-list 1))])\n          (if(empty? droped)\n             appended-list\n             (loop droped appended-list)))\n        appended-string-list))\n  (let* ([append-str-list (loop ls '())]\n         [sorted (sort append-str-list\n                       (\u03bb (a b)\n                         (>= (string-length a) (string-length b))))\n                 ])\n    (if (empty? sorted)\n        \"\"\n        (car sorted))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290495,"user_id":null,"body":"#lang racket\n(provide longest_consec)\n(require srfi\/1)\n\n\n(define (n-cdr-accumulate lst n)\n  (if (= 0 n) \n      '()\n      (cons lst (n-cdr-accumulate (cdr lst) (sub1 n)))))\n\n\n(define (longest_consec ls k)\n  (if (or (empty? ls) (< (length ls) k) (<= k 0))\n      \"\"\n      (let ([str-lst (map (curry foldl string-append \"\") (apply zip (reverse (n-cdr-accumulate ls k))))])\n        (argmax string-length str-lst))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290496,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide longest_consec)\n\n;; (Listof String) Integer -> String\n;; Return the first longest string consisting of `k` consecutive strings of `ls`.\n;; If n = 0 or k > n or k <= 0 return \"\".\n(define (longest_consec ls k)\n  (define n (length ls))\n  (if (or (zero? n) (> k n) (<= k 0))\n      \"\"\n      (argmax string-length (map (\u03bb (l) (string-join l \"\")) (consec ls k)))))\n\n\n;; (Listof Any) Integer -> (Listof (List=k Any))\n;; Return a list with lists of `k` consecutive elements of `ls`.\n;; ASSUME: length(ls) >= k\n(define (consec ls k)\n  (for\/list ([i (in-range (- (add1 (length ls)) k))])\n    (for\/list ([j (in-range k)]) (list-ref ls (+ i j)))))\n             \n(module+ test\n  (check-equal? (consec '(1 2 3) 2) '((1 2) (2 3)))\n  (check-equal? (consec '(1 2 3) 3) '((1 2 3))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56b5afb4ed1f6d5fb0000991":[{"id":290497,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n(define (revrot strng sz)\n  (cond \n    [(or ( <= sz 0) (not (non-empty-string? strng)) ( > sz (string-length strng))) \"\"]\n    [else (string-append \n    (if (equal? (modulo (foldl (lambda (a res) (+ res (expt (- (char->integer a) 48) 3))) 0 (string->list (substring strng 0 sz))) 2) 0)\n      (list->string (reverse (string->list (substring strng 0 sz))))\n      (string-append (substring strng 1 sz) (substring strng 0 1)))\n    (revrot (substring strng sz) sz))])\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290498,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n(define (string->digits s)\n  (map (\u03bb (c) (- (char->integer c) 48)) (string->list s)))\n\n(define (digits->string xs)\n  (string-join (map number->string xs) \"\"))\n\n(define (rotate xs)\n  (append (drop xs 1) (take xs 1)))\n\n(define (rev-or-rot xs)\n  (if (even? (apply + (map (\u03bb (x) (* x x x)) xs)))\n      (reverse xs)\n      (rotate xs)))\n\n(define (revrot strng sz)\n  (if (not (positive? sz))\n      \"\"\n      (let loop ([digits (string->digits strng)]\n                 [res \"\"])\n        (if (< (length digits) sz)\n            res\n            (loop (drop digits sz)\n                  (string-append res (digits->string (rev-or-rot (take digits sz)))))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290499,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n(define (string->digits str) (map string->number (map string (string->list str))))\n(define (digits->string dgts) (string-join (map number->string dgts) \"\"))\n\n(define (chunked digits size)\n  (if (< (length digits) size) '()\n      #;otherwise `(,(take digits size) . ,(chunked (drop digits size) size))))\n\n(define (unchunked chunks) (apply append chunks))\n\n(define reversed reverse)\n(define (rotated digits) (append (drop digits 1) (take digits 1)))\n\n(define (sum xs) (foldr + 0 xs))\n(define (cube x) (* x x))\n(define (cubes xs) (map cube xs))\n(define divisible-by-2? even?)\n\n(define (revroted-chunk dgts)\n  ((if (divisible-by-2? (sum (cubes dgts))) reversed #;otherwise rotated) dgts))\n\n(define (revrot strng size)\n  (if (< size 1) \"\"\n      (let* ((digits (string->digits strng))\n             (chunks (chunked digits size))\n             (chunks* (map revroted-chunk chunks))\n             (digits* (unchunked chunks*))\n             (strng* (digits->string digits*)))\n        strng*)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290500,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n(define (string->digits str) (map string->number (map string (string->list str))))\n(define (digits->string dgts) (string-join (map number->string dgts) \"\"))\n\n(define (chunked digits size)\n  (if (< (length digits) size)\n      '()\n      `(,(take digits size) .\n        ,(chunked (drop digits size) size))))\n\n(define (unchunked chunks) (apply append chunks))\n\n(define (rotate digits) (append (drop digits 1) (take digits 1)))\n\n(define (sum xs) (foldr + 0 xs))\n(define (cube x) (* x x))\n(define (cubes xs) (map cube xs))\n(define divisible-by-2? even?)\n\n(define (revroted-chunk dgts)\n  ((if (divisible-by-2? (sum (cubes dgts))) reverse #;otherwise rotate) dgts))\n\n(define (revrot strng size)\n  (if (< size 1) \"\"\n      (let* ((digits (string->digits strng))\n             (chunks (chunked digits size))\n             (chunks* (map revroted-chunk chunks))\n             (digits* (unchunked chunks*))\n             (strng* (digits->string digits*)))\n        strng*)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290501,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n(define (revrot strng sz)\n  (define (revrot-iter strng sz l res)\n    (let (\n           [sumOfCube (lambda (xs)\n                        (foldl + 0 (map (lambda (x) (* x x x)) xs)))]\n           [string->integers (lambda (s) (map char->integer (string->list s)))]\n           [reverse (lambda (s) (list->string (reverse (string->list s))))]\n           [rotate (lambda (s) (string-append (substring s 1) (substring s 0 1)))]\n           [r1 (if (and (>= l sz) (< 0 sz)) (substring strng 0 sz) \"\")]\n           [rs (if (and (>= l sz) (< 0 sz)) (substring strng sz) \"\")])\n            \n    (cond\n      [(or (>= 0 sz) (>= 0 l)) res]\n      [(< l sz) res]\n      [(even? (sumOfCube (string->integers r1)))\n       (revrot-iter rs sz (- l sz) (string-append res (reverse r1)))]\n      [else (revrot-iter rs sz (- l sz) (string-append res (rotate r1)))])))\n  (revrot-iter strng sz (string-length strng) \"\")\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290502,"user_id":544,"body":"#lang racket\n(provide revrot)\n\n(define (sum-of-cubes-is-even? digit-string)\n  (even? (apply + (map (\u03bb (n) (expt (string->number (string n)) 3))\n                       (string->list digit-string)))))\n  \n(define (process-chunk c)\n  (cond [(sum-of-cubes-is-even? c)\n         (apply ~a ((compose reverse string->list) c))]\n        [else (string-append (substring c 1 (string-length c))\n                             (substring c 0 1))]))\n\n(define (process-digits digit-string chunk-length (acc \"\"))\n  (cond [((string-length digit-string) . < . chunk-length) acc]\n        [else\n         (define chunk-string\n           (substring digit-string 0 chunk-length))\n         (define digit-length\n           (string-length digit-string))\n         (process-digits (substring digit-string chunk-length digit-length)\n                         chunk-length\n                         (string-append acc (process-chunk chunk-string)))]))\n\n(define\/contract (revrot digit-string chunk-length)\n  (-> string? integer? string?)\n  ; digit-string: (string) digits to be processed\n  ; chunk-length: (int) number of digits to be processed in one pass\n  (define digit-length (string-length digit-string))\n  (cond [(or (chunk-length . <= . 0)\n             (= digit-length 0)\n             (chunk-length . > . digit-length)) \"\"]\n        [else (process-digits digit-string chunk-length)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290503,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n(define (string-rotate-left s)\n  (define len (string-length s))\n  (if (len . < . 2)\n      s\n      (string-append (substring s 1 len)\n                     (substring s 0 1))))\n\n(define (string-reverse str) (list->string (reverse (string->list str))))\n(define (x\u00b2 x) (* x x))\n\n(define (sum-of-digits\u00b2-even? chunk)\n  (even? (for\/sum ([char (in-string chunk)]) (x\u00b2 (string->number (string char))))))\n\n(define (revrot strng sz)\n  (define len (string-length strng))\n  (if (or (sz . <= . 0)\n          (string=? \"\" strng)\n          (sz . > . len))\n      \"\"\n      (string-join\n       (for\/list ([i (in-range 0 len sz)]\n                  #:unless ((+ i sz) . > . len))\n         (define chunk (substring strng i (+ i sz)))\n         (if (sum-of-digits\u00b2-even? chunk)\n             (string-reverse chunk)\n             (string-rotate-left chunk)))\n       \"\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290504,"user_id":null,"body":"#lang racket\n\n(provide revrot)\n\n(define (string-to-chunks str size pieces)\n  (if (< (string-length str) size) pieces\n      (string-to-chunks (substring str size (string-length str))\n                        size\n                        (append pieces (list (substring str 0 size))))\n      )\n  )\n\n(define (rev-str str new-str pos)\n  (if (< pos 0)\n      new-str\n      (rev-str str (string-append new-str (list->string (list (string-ref str pos)))) (sub1 pos))\n      )\n  )\n\n(define (reverse-string str)\n  (rev-str str \"\" (sub1 (string-length str)))\n  )\n\n(define (rotate-left str pos)\n  (string-append\n   (substring str pos (string-length str))\n   (substring str 0 pos))\n  )\n\n(define (char-to-int chr)\n  (- (char->integer chr) (char->integer #\\0))\n  )\n\n(define (sum-cubes-tr str pos sum)\n  (if (= (string-length str) pos) sum\n      (sum-cubes-tr str (add1 pos) (+ sum (expt (char-to-int (string-ref str pos)) 3)))\n      )\n  )\n\n(define (sum-cubes str)\n  (sum-cubes-tr str 0 0)\n  )\n\n(define (mod-chunks old-lst new-lst)\n  (if (empty? old-lst) new-lst\n      (if (zero? (modulo (sum-cubes (first old-lst)) 2))\n          (mod-chunks (rest old-lst) (append new-lst (list (reverse-string (first old-lst)))))\n          (mod-chunks (rest old-lst) (append new-lst (list (rotate-left (first old-lst) 1))))\n          )\n      )\n  )\n\n(define (append-chunks lst str)\n  (if (empty? lst) str\n      (append-chunks (rest lst) (string-append str (first lst)))\n      )\n  )\n\n(define (do-revrot strng sz)\n  (define chunks (string-to-chunks strng sz (list)))\n  (define modded-chunks (mod-chunks chunks (list)))\n  (append-chunks modded-chunks \"\")\n)\n\n(define (revrot strng sz)\n  (define str-len (string-length strng))\n  (if (or (<= sz 0) (zero? str-len) (> sz str-len)) \"\"\n      (do-revrot strng sz))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290505,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n;rotate a list to the left\n(define (rotatel lst)\n  (if (empty? lst) '()\n      (append (rest lst) (cons (first lst) '()))   \n  )\n)\n\n;devide list into chunks\n(define (chunks lst n)\n  (if (or (empty? lst) (< (length lst) n))\n    '()\n    (cons\n      (take lst n)\n      (chunks (drop lst n) n)\n    )\n  )\n)\n\n;sum of cubes for the list\n(define (list-c-sum lst)\n  (define (c-sum x result)\n    (+ (* x x x) result)\n  )\n  (foldl c-sum 0 lst)\n)\n\n;string to num list\n(define (string->nlist strng)\n  (map (compose1 string->number string) (string->list strng))\n)\n\n;main function\n(define (revrot strng sz)\n  (define (rotate-or-not chunk)\n    (if (even? (list-c-sum chunk))\n      (reverse chunk)\n      (rotatel chunk)\n    )\n  )\n  (if (or (<= sz 0) (empty? strng) (> sz (string-length strng)))\n    \"\"\n    (apply string-append\n    (map number->string\n      (apply append\n        (map rotate-or-not (chunks (string->nlist strng) sz)))))  \n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290506,"user_id":null,"body":"#lang racket\n(provide revrot)\n\n\n;;; this is completely enough\n;;; the sum of the cubes of the digits is divisible by 2 iff the cross total is\n(define (crosstotal x)   ;; takes a string\n  (apply + (map (compose string->number list->string list) (string->list x))))\n\n(define (rotatestringleft x)\n  (list->string\n   (let* ((s (string->list x)))\n     (append (cdr s) (list (car s))))))\n\n(define (revrot strng sz)\n  (if (<= sz 0)\n      \"\"\n      (apply string-append\n             (for\/list ((i (range 0 (- (string-length strng)\n                                       (modulo (string-length strng) sz))\n                                  sz)))\n               (let ((ss (substring strng i (min (+ i sz) (string-length strng)))))\n                 (if (odd? (crosstotal ss))\n                     (rotatestringleft ss)\n                     ((compose list->string reverse string->list) ss)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56baeae7022c16dd7400086e":[{"id":290507,"user_id":492,"body":"#lang racket\n(provide phone)\n\n(define (phone strng num)\n  (define (aux u num)\n    (let* ([s (first (filter (\u03bb(x) (regexp-match (pregexp (string-append \"\\\\+\" num)) x)) (string-split u \"\n\")))]\n           [nam (first (regexp-match #px\"<.*>\" s))]\n           [name (regexp-replace* #rx\"<|>\" nam \"\")]\n           [adr0 (string-trim (regexp-replace (regexp (string-append \"\\\\+\" num)) (regexp-replace (pregexp nam) s \"\") \"\"))]\n           [adr (regexp-replace* #px\" {2,}\" adr0 \" \")])\n      (string-append  \"Phone => \" num \", Name => \" name \", Address => \" adr)))\n  (let* ([clean (regexp-replace* #px\"[^-0-9a-z\\\\s+A-Z\\\\\n<>.']\" strng \" \")]\n         [ls (regexp-match* (pregexp (string-append \"\\\\+\" num)) clean)])\n    (cond [(empty? ls) (string-append \"Error => Not found: \" num)]\n          [(> (length ls) 1) (string-append \"Error => Too many people: \" num)]\n          [else (aux clean num)])))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290508,"user_id":168,"body":"#lang racket\n(provide phone)\n\n(define (phone str num)\n  (define num2 (format \"+~a\" num))\n  (define xs (for\/list [(x (string-split str \"\n\"))\n                        #:when (string-contains? x num2)]\n                       x))\n  (match xs\n    ['() (format \"Error => Not found: ~a\" num)]\n    [(list a b ... c) (format \"Error => Too many people: ~a\" num)]\n    [(list x)\n     (let* ([s (string-replace x num2 \"\")]\n            [name (second (regexp-match \"<([^>]*)>\" s))]\n            [s (string-replace s (format \"<~a>\" name) \"\")]\n            [s (string-replace s #px\"[^a-zA-Z\\\\d\\\\s.-]+\" \" \")]\n            [s (string-replace s #px\"\\\\s+\" \" \")]\n            [addr (string-trim s)])\n       (format \"Phone => ~a, Name => ~a, Address => ~a\"\n               num name addr))])\n)\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290509,"user_id":null,"body":"#lang racket\n(provide phone)\n\n(define (phone s pn)\n  (define (strip-that-address-out line)\n    (string-normalize-spaces\n        (regexp-replace* (format \"<(?:.*)>|\\\\+~a|[^a-zA-Z0-9._ -]\" pn)\n                        (string-replace line \"_\" \" \") \"\")))\n  (define matchs (regexp-match* (format \"(?m:^.*\\\\+~a.*$)\" pn) s))\n  (cond [(> (length matchs) 1)\n         (string-append \"Error => Too many people: \" pn)]\n        [(empty? matchs)\n         (string-append \"Error => Not found: \" pn)]\n        [else (let* ([line (car matchs)]\n                     [name (cadr (regexp-match #rx\"<(.*)>\" line))]\n                     [addr (strip-that-address-out line)])\n                (format \"Phone => ~a, Name => ~a, Address => ~a\"\n                        pn name addr))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290510,"user_id":null,"body":"#lang racket\n(provide phone)\n\n(define-struct entry (name number address) \n  #:transparent)\n\n(define (parse entry)\n  (let* ([name (regexp-match #px\"<([\\\\w\\\\s']+)>\" entry)]\n         [number (regexp-match #rx\"\\\\+([0-9-]+)\" entry)]\n         [address (string-replace \n            (string-replace \n              (string-replace entry (first name) \"\") (first number) \"\") \"_\" \" \")])\n    (make-entry (second name) (second number) (string-normalize-spaces(string-trim address)))))\n    \n\n(define (sanitize str)\n  (string-normalize-spaces (string-replace str #px\"[^\\\\w\\\\d\\\\s.+<'>_-]\" \"\")))\n\n(define (phone strng num)\n  (let* ([num-with-prefix (string-append \"+\" num)]\n         [phone-entries (map string-trim (string-split strng \"\n\"))]\n         [matches (filter (\u03bb (entry) (string-contains? entry num-with-prefix)) phone-entries)])\n          (define entries (for\/list ([match matches])\n            (parse (sanitize match))))\n          (let ([number-entries (length entries)])\n            (cond\n              [(= 0 number-entries) (string-append \"Error => Not found: \" num)]\n              [(= 1 number-entries) \n                (let ([details (first entries)])\n                  (format \"Phone => ~a, Name => ~a, Address => ~a\" \n                    (entry-number details) (entry-name details) (entry-address details)))]\n              [else (string-append \"Error => Too many people: \" num)]))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290511,"user_id":null,"body":"#lang racket\n(provide phone)\n(define (phone S num)\n    (define (clean-entry s)\n      (string-replace (list->string (filter (lambda (c) (regexp-match #px\"[[:alnum:]'_.<>\\\\- ]\" (string c))) (string->list s))) \"_\" \" \"))\n    (define (format-ph s ph)\n      (let* ([name (cadr (regexp-match #rx\"<(.*)>\" s))]\n            [addr (string-normalize-spaces (string-replace (string-replace s ph \"\") (string-join (list \"<\" name \">\") \"\") \"\"))])\n        (string-join (list \"Phone => \" ph \", Name => \" name \", Address => \" addr) \"\")))\n    (let ([Sl (filter (lambda (s) (string-contains? s (string-append \"+\" num))) (string-split S \"\n\"))])\n      (cond [(> (length Sl) 1) (string-append \"Error => Too many people: \" num)]\n            [(= (length Sl) 0) (string-append \"Error => Not found: \" num)]\n            [else (format-ph (clean-entry (car Sl)) num)]))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290512,"user_id":null,"body":"#lang racket\n\n(provide phone)\n\n(define (phone strng num)\n  (define phonebook (regexp-split #rx\"\n\" strng))\n  (let ([page (find-entry phonebook num)])\n    (cond\n      [(zero? (length page)) (string-append \"Error => Not found: \" num)]\n      [(< 1 (length page)) (string-append \"Error => Too many people: \" num)]\n      [else\n       (~a \"Phone => \" num \", Name => \" (find-name page) \", Address => \" (find-addr page))])))\n\n;; helpers\n\n(define (find-entry entries num)\n  (filter (lambda (e) (regexp-match (~a \"\\\\+\" num) e)) entries))\n\n(define (find-name str) (car (regexp-match #rx\"(?<=<).*(?=>)\" (car (regexp-split #rx\"\n\" (car str))))))\n;; please send regexp help!\n(define (find-addr str)\n  (string-trim\n   (regexp-replace* #px\"\\\\s{2,}\"\n                   (regexp-replace* #px\"\\\\_|\\\\\/|\\\\,|\\\\;\"\n                                   (apply string-append\n                                          (regexp-split #px\"[^\\\\w]?\\\\+\\\\d{1,2}-\\\\d{3}-\\\\d{3}-\\\\d{4}.?\"\n                                                        (apply string-append\n                                                               (regexp-split #px\"<.*>\"\n                                                                             (car (regexp-split #rx\"\n\" (car str))))))) \" \") \" \")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290513,"user_id":492,"body":"#lang racket\n(provide phone)\n\n(define (phone strng num)\n  (define (aux u num)\n    (let* ([s (first (filter (\u03bb(x) (regexp-match (pregexp (string-append \"\\\\+\" num)) x)) (string-split u \"\n\")))]\n           [nam (first (regexp-match #px\"<.*>\" s))]\n           [name (regexp-replace* #rx\"<|>\" nam \"\")]\n           [adr0 (string-trim (regexp-replace (regexp (string-append \"\\\\+\" num)) (regexp-replace (pregexp nam) s \"\") \"\"))]\n           [adr (regexp-replace* #px\" {2,}\" adr0 \" \")])\n      (string-append  \"Phone => \" num \", Name => \" name \", Address => \" adr)))\n  (let* ([clean (regexp-replace* #px\"[^-0-9a-z\\\\s+A-Z\\\\\n<>.']\" strng \" \")]\n         [ls (regexp-match* (pregexp (string-append \"\\\\+\" num)) clean)])\n    (cond [(empty? ls) (string-append \"Error => Not found: \" num)]\n          [(> (length ls) 1) (string-append \"Error => Too many people: \" num)]\n          [else (aux clean num)])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56bc28ad5bdaeb48760009b0":[{"id":290514,"user_id":527,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (substring str 1 (sub1 (string-length str))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290515,"user_id":564,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (let ([len (string-length str)])\n    (let ([end (- len 1)])\n      (substring str 1 end))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290516,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (substring str 1 (- (string-length str) 1)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290517,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (string-trim str #px\".\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290518,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (define end-ind (- (string-length str) 1))\n  (match (string-length str)\n        [2 \"\"]\n        [_ (substring str 1 end-ind)]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290519,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n(define reverse-cdr (compose reverse cdr))\n(define (remove_char str)\n  (list->string (reverse-cdr (reverse-cdr (string->list str)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290520,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n( define (remove_char str)\n  ( list->string ( drop-right ( drop (string->list str) 1 ) 1 ) ) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290521,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (list->string (reverse (rest (reverse (string->list (substring str 1)))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290522,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n(define (recur-till-end lst)\n  (cond \n   ((null? (cdr lst)) (quote ())) \n   (else (cons (car lst) (recur-till-end (cdr lst))))))\n\n\n(define (remove_char str)\n  (list->string (recur-till-end (cdr (string->list str)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290523,"user_id":null,"body":"#lang racket\n\n(provide remove_char)\n\n(define (remove_char str)\n  (define lst (string->list str))\n  (list->string (remove (first lst) (drop-right lst 1))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56bdd0aec5dc03d7780010a5":[{"id":290524,"user_id":53,"body":"#lang racket\n\n(provide next_higher)\n\n(define (next_higher n)\n  (if (zero? n) 0\n    (let* ([r (bitwise-and n (* -1 n))]\n           [p (+ n r)]\n           [q (quotient (bitwise-xor n p) (* 4 r))]\n           [m (bitwise-ior p q)])\n      m)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290525,"user_id":168,"body":"#lang racket\n\n(provide next_higher)\n\n(define (next_higher n)\n  (let* ([t (bitwise-and n (- n))]\n         [h (+ n t)]\n         [l (quotient (bitwise-xor n h) (* 4 t))])\n    (+ h l)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290526,"user_id":645,"body":"#lang racket\n\n(provide next_higher)\n\n(define (next_higher n)\n  (let ([o (bitwise-and n (- 0 n))])\n    (bitwise-ior (+ n o) (arithmetic-shift (quotient (bitwise-xor n (+ n o)) o) -2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290527,"user_id":null,"body":"#lang racket\n\n(provide next_higher)\n\n\n\n(define (to-bin num)\n  (case num\n    [(0) (list 0)]\n    [(1) (list 1)]\n    [else\n     (let\n         (\n          [cociente (quotient num 2)]\n          [resto (list(modulo num 2))]\n          )\n       (append (to-bin cociente) resto)\n      \n      )\n     ;Fin del else\n       \n    ];Fin del case\n  ))\n\n\n\n(define (es-1? num) (if (= 1 num) #t #f))\n\n(define (extraer-unos lista) (filter es-1? lista))\n\n(define (cuenta-bits-uno num)(length (extraer-unos (to-bin num))))\n\n(define (igual-cantidad-bits-uno num1 num2)\n (let (\n       [numbits1 (cuenta-bits-uno num1)]\n       [numbits2 (cuenta-bits-uno num2)]\n       );Fin definiciones let\n    (\n     if (= numbits1 numbits2) #t #f\n     );Fin del body del let\n);Fin del cuerpo del define\n  );Fin del define\n     \n\n\n(igual-cantidad-bits-uno 129 130)\n\n(define (next_higher-bits n1 n2)\n  (if (igual-cantidad-bits-uno n1 n2) n2 (next_higher-bits n1 (+ 1 n2)))\n  )\n\n(define (next_higher n)\n  (let\n      ([siguiente (+ n 1)])\n    (next_higher-bits n (+ 1 n))\n  )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290528,"user_id":null,"body":"#lang racket\n\n(provide next_higher)\n\n(define (next_higher n)\n  (define (count-1 n)\n    (cond [(= n 0) 0]\n          [(odd? n) (+ 1 (count-1 (- n 1)))]\n          [else (count-1 (\/ n 2))]))\n  (define orig-count (count-1 n))\n  (let loop ([num (+ n 1)])\n    (if (= (count-1 num) orig-count)\n        num\n        (loop (+ num 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56c5847f27be2c3db20009c3":[{"id":290529,"user_id":76,"body":"#lang racket\n\n(provide subtract_sum)\n\n(define (subtract_sum n)\n  \"apple\"\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290530,"user_id":null,"body":"#lang racket\n\n(provide subtract_sum)\n\n(define N->FRUIT\n  (hash\n   1 \"kiwi\" 2 \"pear\" 3 \"kiwi\" 4 \"banana\" 5 \"melon\" 6 \"banana\"\n   7 \"melon\" 8 \"pineapple\" 9 \"apple\" 10 \"pineapple\" 11 \"cucumber\"\n   12 \"pineapple\" 13 \"cucumber\" 14 \"orange\" 15 \"grape\" 16 \"orange\"\n   17 \"grape\" 18 \"apple\" 19 \"grape\" 20 \"cherry\" 21 \"pear\"\n   22 \"cherry\" 23 \"pear\" 24 \"kiwi\" 25 \"banana\" 26 \"kiwi\" 27 \"apple\"\n   28 \"melon\" 29 \"banana\" 30 \"melon\" 31 \"pineapple\" 32 \"melon\"\n   33 \"pineapple\" 34 \"cucumber\" 35 \"orange\" 36 \"apple\" 37 \"orange\"\n   38 \"grape\" 39 \"orange\" 40 \"grape\" 41 \"cherry\" 42 \"pear\"\n   43 \"cherry\" 44 \"pear\" 45 \"apple\" 46 \"pear\" 47 \"kiwi\" 48 \"banana\"\n   49 \"kiwi\" 50 \"banana\" 51 \"melon\" 52 \"pineapple\" 53 \"melon\"\n   54 \"apple\" 55 \"cucumber\" 56 \"pineapple\" 57 \"cucumber\" 58 \"orange\"\n   59 \"cucumber\" 60 \"orange\" 61 \"grape\" 62 \"cherry\" 63 \"apple\"\n   64 \"cherry\" 65 \"pear\" 66 \"cherry\" 67 \"pear\" 68 \"kiwi\" 69 \"pear\"\n   70 \"kiwi\" 71 \"banana\" 72 \"apple\" 73 \"banana\" 74 \"melon\"\n   75 \"pineapple\" 76 \"melon\" 77 \"pineapple\" 78 \"cucumber\"\n   79 \"pineapple\" 80 \"cucumber\" 81 \"apple\" 82 \"grape\" 83 \"orange\"\n   84 \"grape\" 85 \"cherry\" 86 \"grape\" 87 \"cherry\" 88 \"pear\"\n   89 \"cherry\" 90 \"apple\" 91 \"kiwi\" 92 \"banana\" 93 \"kiwi\"\n   94 \"banana\" 95 \"melon\" 96 \"banana\" 97 \"melon\" 98 \"pineapple\"\n   99 \"apple\" 100 \"pineapple\"))\n   \n\n;; 10<=Integer<10000\n;; return a fruit name corresponding to n-sum(digits(n))\n(define (subtract_sum n)\n  (let* ([s (for\/sum ([c (number->string n)]) (string->number (string c)))]\n         [new-n (- n s)]\n         [f (hash-ref N->FRUIT new-n #f)])\n    (if f f (subtract_sum new-n))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290531,"user_id":null,"body":"#lang racket\n\n(provide subtract_sum)\n(define vec (vector\n\"kiwi\"\n\"pear\"\n\"kiwi\"\n\"banana\"\n\"melon\"\n\"banana\"\n\"melon\"\n\"pineapple\"\n\"apple\"\n\"pineapple\"\n\"cucumber\"\n\"pineapple\"\n\"cucumber\"\n\"orange\"\n\"grape\"\n\"orange\"\n\"grape\"\n\"apple\"\n\"grape\"\n\"cherry\"\n\"pear\"\n\"cherry\"\n\"pear\"\n\"kiwi\"\n\"banana\"\n\"kiwi\"\n\"apple\"\n\"melon\"\n\"banana\"\n\"melon\"\n\"pineapple\"\n\"melon\"\n\"pineapple\"\n\"cucumber\"\n\"orange\"\n\"apple\"\n\"orange\"\n\"grape\"\n\"orange\"\n\"grape\"\n\"cherry\"\n\"pear\"\n\"cherry\"\n\"pear\"\n\"apple\"\n\"pear\"\n\"kiwi\"\n\"banana\"\n\"kiwi\"\n\"banana\"\n\"melon\"\n\"pineapple\"\n\"melon\"\n\"apple\"\n\"cucumber\"\n\"pineapple\"\n\"cucumber\"\n\"orange\"\n\"cucumber\"\n\"orange\"\n\"grape\"\n\"cherry\"\n\"apple\"\n\"cherry\"\n\"pear\"\n\"cherry\"\n\"pear\"\n\"kiwi\"\n\"pear\"\n\"kiwi\"\n\"banana\"\n\"apple\"\n\"banana\"\n\"melon\"\n\"pineapple\"\n\"melon\"\n\"pineapple\"\n\"cucumber\"\n\"pineapple\"\n\"cucumber\"\n\"apple\"\n\"grape\"\n\"orange\"\n\"grape\"\n\"cherry\"\n\"grape\"\n\"cherry\"\n\"pear\"\n\"cherry\"\n\"apple\"\n\"kiwi\"\n\"banana\"\n\"kiwi\"\n\"banana\"\n\"melon\"\n\"banana\"\n\"melon\"\n\"pineapple\"\n\"apple\"\n\"pineapple\"\n))\n\n(define (get-new-n n)\n  (let ([str_num (number->string n)]\n        [sum (box 0)])\n      (for ([i (string-length str_num)])\n        (set-box! sum (+ (string->number (string (string-ref str_num i))) (unbox sum))))\n      (- n (unbox sum))))\n\n(define (subtract_sum n)\n        (let ([new-n (get-new-n n)])\n          (if (<= new-n 100)\n           (vector-ref vec (- new-n 1))\n           (subtract_sum new-n))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290532,"user_id":null,"body":"#lang racket\n\n(provide subtract_sum)\n\n(define fruits\n'(\n    kiwi\n    pear\n    kiwi\n    banana\n    melon\n    banana\n    melon\n    pineapple\n    apple\n    pineapple\n    cucumber\n    pineapple\n    cucumber\n    orange\n    grape\n    orange\n    grape\n    apple\n    grape\n    cherry\n    pear\n    cherry\n    pear\n    kiwi\n    banana\n    kiwi\n    apple\n    melon\n    banana\n    melon\n    pineapple\n    melon\n    pineapple\n    cucumber\n    orange\n    apple\n    orange\n    grape\n    orange\n    grape\n    cherry\n    pear\n    cherry\n    pear\n    apple\n    pear\n    kiwi\n    banana\n    kiwi\n    banana\n    melon\n    pineapple\n    melon\n    apple\n    cucumber\n    pineapple\n    cucumber\n    orange\n    cucumber\n    orange\n    grape\n    cherry\n    apple\n    cherry\n    pear\n    cherry\n    pear\n    kiwi\n    pear\n    kiwi\n    banana\n    apple\n    banana\n    melon\n    pineapple\n    melon\n    pineapple\n    cucumber\n    pineapple\n    cucumber\n    apple\n    grape\n    orange\n    grape\n    cherry\n    grape\n    cherry\n    pear\n    cherry\n    apple\n    kiwi\n    banana\n    kiwi\n    banana\n    melon\n    banana\n    melon\n    pineapple\n    apple\n    pineapple))\n(define (digit-sum n)\n  (if (> n 0) \n    (let ((d (modulo n 10)))\n      (+ d (digit-sum (quotient n 10))))\n    0))\n(define (subtract_sum n)\n  (let* ((r (digit-sum n)) (k (- n  r)))\n    (if (<= k 100) \n      (symbol->string (list-ref fruits (- k 1)))\n      (subtract_sum k))))\n\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290533,"user_id":645,"body":"#lang racket\n\n(provide subtract_sum)\n\n(define (subtract_sum _) \"apple\")","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56cac350145912e68b0006f0":[{"id":290534,"user_id":492,"body":"#lang racket\n(provide arrange)\n\n(define (arrange s)\n  (define (vector-swap! vector index1 index2)\n    (let ((temp (vector-ref vector index1)))\n      (vector-set! vector index1 (vector-ref vector index2))\n      (vector-set! vector index2 temp)))\n  (define (arrange-aux i n z)\n    (if (>= i (sub1 n))\n        z\n        (begin\n          (if (or (and (odd? i) (< (string-length (vector-ref z i)) (string-length (vector-ref z (add1 i)))))\n                  (and (even? i) (> (string-length (vector-ref z i)) (string-length (vector-ref z (add1 i))))))\n              (vector-swap! z i (add1 i))\n              z)\n          (arrange-aux (add1 i) n z))))\n  (define (arrange-aux1 n z)\n    (for\/list ([x z][i (range n)])\n      (if (even? i) (string-downcase x) (string-upcase x))))\n  \n  (let* ([vv (list->vector (regexp-split #px\" \" s))]\n         [lg (vector-length vv)])\n    (string-join (arrange-aux1 lg (vector->list (arrange-aux 0 lg vv))) \" \")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290535,"user_id":168,"body":"#lang racket\n(provide arrange)\n\n(define (arrange s)\n  (define (case sgn s) \n    (if (> sgn 0) (string-downcase s) (string-upcase s)))\n  (let ([r (let loop ([sgn 1] [xs (string-split s \" \")])\n            (match xs\n              [(list x y xs ...)\n                 (if (< (* sgn (- (string-length y) (string-length x))) 0)\n                     (cons (case sgn y) (loop (- sgn) (cons x xs)))\n                     (cons (case sgn x) (loop (- sgn) (cons y xs))))]\n              [(list x) (list (case sgn x))]\n              ['() '()]))])\n    (string-join r \" \")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290536,"user_id":null,"body":"#lang racket\n(provide arrange)\n\n;; String -> String\n(define (arrange s)\n (string-join (alternate-case (string-swap (words s)))))\n\n;; String -> (listOf String)\n(define (words s)\n  (if (string=? s \"\")\n      '(\"\")\n      (string-split s)))\n\n;; (listOf String) -> (listOf String)\n(define (string-swap los)\n  (define len (length los))\n  (define (aux los n)\n    (cond\n      [(= n len) los]\n      [(odd? n) \n       (if (<= (string-length (first los)) (string-length (second los)))\n           (cons (first los) (aux (rest los) (add1 n)))\n           (cons (second los) (aux (cons (first los) (rest (rest los))) (add1 n))))]\n      [else\n       (if (>= (string-length (first los)) (string-length (second los)))\n           (cons (first los) (aux (rest los) (add1 n)))\n           (cons (second los) (aux (cons (first los) (rest (rest los))) (add1 n))))]))\n  (aux los 1))\n\n;; (listOf String) -> (listOf String)\n(define (alternate-case los)\n  (define (aux los n)\n    (cond\n      [(empty? los) empty]\n      [(odd? n) (cons (string-downcase (first los)) (aux (rest los) (add1 n)))]\n      [else (cons (string-upcase (first los)) (aux (rest los) (add1 n)))])) \n  (aux los 1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290537,"user_id":null,"body":"#lang racket\n(provide arrange)\n\n(define (arrange s)\n  (define arranged\n    (let loop ((xs (string-split s)) (acc '()) (ops (list < >)))\n      (if (<= (length xs) 1)\n          (append (reverse acc) xs)\n          (match-let (((list a b) (sort (take xs 2) (first ops) #:key string-length)))\n            (loop (cons b (drop xs 2)) (cons a acc) (reverse ops))))))\n  (string-join\n   (for\/list ((w arranged) (i (in-range (length arranged))))\n     (if (even? i) (string-downcase w) (string-upcase w)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56cd44e1aa4ac7879200010b":[{"id":290538,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (is_uppercase str)\n  (equal? (string-upcase str) str))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290539,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (is_uppercase str)\n  (equal? str (string-upcase str)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290540,"user_id":50,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (is_uppercase str)\n  (not (regexp-match #rx\"[a-z]\" str)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290541,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (is_uppercase str)\n  (andmap (lambda (c) (not (char-lower-case? c)))\n          (string->list str)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290542,"user_id":373,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (f_or a b) (or a b))\n\n(define (is_uppercase str)\n  (not (foldl f_or #f (map char-lower-case? (string->list str)))) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290543,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (upcase-str-list? str-list)\n  (cond \n      [(empty? str-list) true]\n      [(not (char-alphabetic? (first str-list))) (upcase-str-list? (rest str-list))]\n      [(char-upper-case? (first str-list)) (upcase-str-list? (rest str-list))]\n      [else false]))\n\n(define (is_uppercase str)\n  (upcase-str-list? (string->list str)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290544,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n; seems easier than working out the rules\n(define is_uppercase (\u03bb (s) (equal? s (string-upcase s)))) \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290545,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n;; String->Boolean\n;; return #t if `str` is uppercase, #f otherwise\n(define (is_uppercase str)\n  (define (char-is_uppercase c)\n    (if (char-alphabetic? c) (char-upper-case? c) #t))\n  (for\/and ([c str]) (char-is_uppercase c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290546,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define (checkString lst)\n  (cond \n   ((null? lst) #t)\n   ((equal? (string (car lst)) (string-upcase (string (car lst)))) \n         (checkString (cdr lst)))\n   (else #f)))\n\n\n(define (is_uppercase str)\n  (checkString (string->list str)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290547,"user_id":null,"body":"#lang racket\n\n(provide is_uppercase)\n\n(define is_uppercase (compose\n                 (curry andmap char-upper-case?)\n                 (curry filter char-alphabetic?)\n                 string->list))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56dbe0e313c2f63be4000b25":[{"id":290548,"user_id":null,"body":"#lang racket\n\n(provide hor-mirror vert-mirror oper)\n\n;; String -> String\n;; given a string of n lines, each line being n chars long,\n;; reverse each line\n(define (vert-mirror s)\n  (string-join\n   (map (compose1 list->string reverse string->list) (string-split s \"\n\"))\n   \"\n\"))\n\n;; String -> String\n;; given a string of n lines, each line n chars long,\n;; reverse the order of lines\n(define (hor-mirror s)\n  (string-join (reverse (string-split s \"\n\")) \"\n\"))\n                \n;; (String -> String) String -> String\n;; apply fct to s\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290549,"user_id":null,"body":"#lang racket\n(provide hor-mirror vert-mirror oper)\n\n(define (vert-mirror strng)\n  (string-join\n   (map\n    (lambda (str) (string-join (reverse (string-split str \"\")) \"\")) (string-split strng \"\n\"))\n   \"\n\"))\n\n(define (hor-mirror strng)\n  (string-join\n   (reverse (string-split strng \"\n\"))\n   \"\n\")\n)\n\n(define (oper fct s)\n  ((compose fct) s)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290550,"user_id":null,"body":"#lang racket\n(provide hor-mirror vert-mirror oper)\n\n(define (string-reverse str)\n  (apply string (reverse (string->list str))))\n\n(define (vert-mirror strng)\n  (define lines (string-split strng))\n  (string-join (map string-reverse lines) \"\n\"))\n\n(define (hor-mirror strng)\n  (define lines (string-split strng))\n  (string-join (reverse lines) \"\n\"))\n\n; what?\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290551,"user_id":null,"body":"#lang racket\n(provide hor-mirror vert-mirror oper)\n(require srfi\/13)\n \n(define (vert-mirror strng)\n  ((curryr string-join \"\n\")\n    (map string-reverse (string-split strng \"\n\"))))\n\n(define (hor-mirror strng)\n  ((curryr string-join \"\n\")\n    (reverse (string-split strng \"\n\"))))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290552,"user_id":null,"body":"#lang racket\n\n(provide hor-mirror vert-mirror oper)\n\n(define (vert-mirror str)\n  (string-join (map (compose list->string reverse string->list)\n                    (string-split str \"\n\"))\n               \"\n\"))\n\n(define (hor-mirror str)\n  (string-join (reverse (string-split str \"\n\"))\n               \"\n\"))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290553,"user_id":null,"body":"#lang racket\n(provide hor-mirror vert-mirror oper)\n\n(require srfi\/13)\n \n(define (split-map-join str proc)\n  (string-join (proc (string-split str #:repeat? #f #:trim? #t)) \"\n\"))\n\n(define (vert-mirror str)\n  (split-map-join str (lambda (strs) (map string-reverse strs))))\n\n(define (hor-mirror str)\n  (split-map-join str reverse))\n\n(define (oper fct s)\n   (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290554,"user_id":null,"body":"#lang racket\n(provide hor-mirror vert-mirror oper)\n\n(define (vert-mirror strng)\n  (string-join \n    (map list->string\n        (map reverse \n             (map string->list \n                  (string-split strng \"\n\")))) \"\n\"))\n\n(define (hor-mirror strng)\n  (string-join (reverse (string-split strng \"\n\")) \"\n\"))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290555,"user_id":null,"body":"\n#lang racket\n(provide hor-mirror vert-mirror oper)\n\n  \n\n(define (vert-mirror strng)\n  (string-join\n   (for\/list ([s (string-split strng)])\n     (list->string (reverse (string->list s))))\n  \"\n\")\n  )\n\n(define (hor-mirror strng)\n  (string-join\n   (reverse\n    (string-split strng))\n   \"\n\"\n  ))\n\n(define (oper fct s)\n  (fct s)\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290556,"user_id":null,"body":"#lang racket\n(require srfi\/13)\n(provide hor-mirror vert-mirror oper)\n\n(define (vert-mirror strng)\n  (string-join (map string-reverse (string-split strng \"\n\")) \"\n\")\n)\n\n(define (hor-mirror strng)\n  (string-join (reverse (string-split strng \"\n\")) \"\n\")\n)\n\n(define (oper fct s)\n  (fct s)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290557,"user_id":null,"body":"#lang racket\n(provide hor-mirror vert-mirror oper)\n\n(define (with-lines f str)\n  (string-join (f (string-split str \"\n\")) \"\n\"))\n\n(define (string-reverse str)\n  (list->string (reverse (string->list str))))\n\n(define (vert-mirror str)\n  (with-lines (lambda (lns) (map string-reverse lns)) str))\n\n(define (hor-mirror str)\n  (with-lines reverse str))\n\n(define (oper f str)\n  (f str))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56dbe7f113c2f63570000b86":[{"id":290558,"user_id":492,"body":"#lang racket\n(provide rot selfie-and-rot oper)\n\n(define (rot strng)\n  (define (vert-mirror strng)\n    (define (string-reverse s)\n      (list->string (reverse (string->list s))))\n    (string-join (map (\u03bb(x) (string-reverse x)) (string-split strng \"\n\")) \"\n\"))\n\n  (define (hor-mirror strng)\n    (string-join (reverse (string-split strng \"\n\")) \"\n\" ))\n  \n  (vert-mirror (hor-mirror strng)))\n\n(define (selfie-and-rot strng)\n  (define (repeat-dot n)\n    (make-string n #\\.))\n  (let* ([ls1 (string-split strng \"\n\")]\n         [ls2 (string-split (rot strng) \"\n\")]\n         [r1 (string-join (map (\u03bb(x) (string-append x (repeat-dot (string-length x)))) ls1) \"\n\")]\n         [r2 (string-join (map (\u03bb(x) (string-append (repeat-dot (string-length x)) x)) ls2) \"\n\")])\n    (string-append r1 \"\n\" r2)))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290559,"user_id":null,"body":"#lang racket\n(provide rot selfie-and-rot oper)\n\n(define (rot strng)\n  (list->string (reverse (string->list strng)))\n)\n\n(define (selfie-and-rot strng)\n  (let* ([dots (make-string (string-length (car (string-split strng))) #\\.)]\n         [left (string-replace strng \"\n\" (string-append dots \"\n\"))]\n         [right (string-replace (rot strng) \"\n\" (string-append \"\n\" dots))])\n    (string-join (list left right) (string-join (list dots dots) \"\n\")))\n)\n\n(define (oper fct s)\n  (fct s)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290560,"user_id":544,"body":"#lang racket\n(provide rot selfie-and-rot oper)\n\n(define (string-reverse s)\n  (apply string ((compose reverse string->list) s)))\n\n(define (rot strng)\n  (define string-list (string-split strng))\n  (define rotated-string-list\n    (reverse (map string-reverse string-list)))\n  (string-join rotated-string-list \"\n\"))\n\n(define (selfie-and-rot strng)\n  (define input-array (string-split strng))\n  (define output-array (string-split (rot strng)))\n  (define input-array-with-dots\n    (map (\u03bb (s) \n            (string-append s \n                           (make-string (string-length s) #\\.))) \n         input-array))\n  (define output-array-with-dots\n    (map (\u03bb (s) \n            (string-append (make-string (string-length s) #\\.)\n                           s)) \n         output-array))\n  (string-join (flatten (list input-array-with-dots output-array-with-dots)) \"\n\"))\n\n(define (oper fct s) (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290561,"user_id":null,"body":"#lang racket\n(provide rot selfie-and-rot oper)\n\n(define (rot str)\n  (list->string (reverse (string->list str))))\n\n\n(define (selfie-and-rot str)\n  (let* ([str-rows         (string-split str \"\n\")]\n         [n                (string-length (first str-rows))]\n         [dot-string       (make-string n #\\.)]\n         [row-sep          (string-append dot-string \"\n\")]\n         [rotated-str      (rot str)]\n         [rotated-str-rows (string-split rotated-str \"\n\")])\n    (string-append (string-join str-rows\n                                row-sep\n                                #:after-last row-sep)\n                   (string-join rotated-str-rows\n                                (string-append \"\n\" dot-string)\n                                #:before-first dot-string))))\n\n(define (oper func str)\n  (func str))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290562,"user_id":null,"body":"#lang racket\n(provide oper rot selfie-and-rot)\n\n(define (rot strings)\n  (out (reverse (map reverse (in strings)))))\n\n(define (selfie-and-rot strings)\n  (define with-dots (map (\u03bb (s) (append s (make-list (length s) #\\.))) (in strings)))\n  (out (append with-dots (reverse (map reverse with-dots)))))\n\n(define (oper fct s)\n  (fct s))\n\n(define (in s)\n  (map string->list (string-split s \"\n\")))\n\n(define (out s)\n  (string-join (map list->string s) \"\n\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290563,"user_id":null,"body":"#lang racket\n(provide rot selfie-and-rot oper)\n\n(define (reverse-string str)\n  (list->string (reverse (string->list str))))\n  \n(define (string->lines str)\n  (string-split str \"\n\"))\n  \n(define (lines->string lines)\n  (string-join lines \"\n\"))\n  \n(define (add-dots str)\n  (string-append str (make-string (string-length str) #\\.)))\n    \n(define (rot str)\n  (lines->string (reverse (map reverse-string (string->lines str)))))\n  \n(define (selfie-and-rot str)\n  (define dotted (map add-dots (string->lines str)))\n  (lines->string (append dotted (reverse (map reverse-string dotted)))))  \n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290564,"user_id":null,"body":"#lang racket\n(provide rot selfie-and-rot oper)\n\n(define (rot str)\n  (matrix->string (reverse (map reverse (string->matrix str)))))\n\n(define (selfie-and-rot str)\n  (let ([mat (string->matrix str)])\n    (matrix->string (join4 mat\n                           (dots mat)\n                           (dots mat)\n                           (reverse (map reverse mat))))))\n\n(define (oper fct s)\n  (fct s))\n\n(define (string->matrix str)\n  (let ([strlist (string-split str \"\n\")])\n    (map string->list strlist)))\n\n(define (matrix->string mat)\n  (let ([strlist (map list->string mat)])\n    (string-join strlist \"\n\")))\n\n(define (join4 a b c d)\n  (append (map append a b)\n          (map append c d)))\n\n(define (dots mat)\n  (map (curry map (\u03bb (x) #\\.)) mat))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56dbeec613c2f63be4000be6":[{"id":290565,"user_id":492,"body":"#lang racket\n(provide rot-90-clock diag-1-sym selfie-and-diag1 oper)\n\n(define (transpose xss)\n  (apply map list xss))\n\n(define (rot-90-clock strng)\n  (let* ([ls1 (reverse (string-split strng \"\n\"))]\n         [m (transpose (map (\u03bb(x) (string->list x)) ls1))]\n         [ls2 (map (\u03bb(x) (list->string x)) m)])\n    (string-join ls2 \"\n\")))\n\n(define (diag-1-sym strng)\n  (let* ([ls1 (string-split strng \"\n\")]\n         [m (transpose (map (\u03bb(x) (string->list x)) ls1))]\n         [ls2 (map (\u03bb(x) (list->string x)) m)])\n    (string-join ls2 \"\n\")))\n\n(define (selfie-and-diag1 strng)\n  (let* ([a1 (string-split strng \"\n\")]\n         [a2 (string-split (diag-1-sym strng) \"\n\")]\n         [a3 (for\/list ([i (range 0 (length a1))])\n               (string-append (list-ref a1 i) \"|\" (list-ref a2 i)))])\n    (string-join a3 \"\n\")))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290566,"user_id":null,"body":"#lang racket\n(provide rot-90-clock diag-1-sym selfie-and-diag1 oper)\n\n(define (rot-90-clock strng)\n  ; your code\n  (let* ((splited (string-split strng \"\n\"))\n         (len     (length  splited))\n         (rev     (reverse splited)))\n    (apply ~a #:separator \"\n\"\n           (let loop ((i 0))\n             (cond ((= i len) '())\n                   (else (cons (apply ~a (map (lambda (strng)\n                                                (string-ref strng i))\n                                              rev))\n                               (loop (add1 i)))))))))\n\n(define (diag-1-sym strng)\n  ; your code\n  (let* ((splited (string-split strng \"\n\"))\n         (len     (length  splited)))\n    (apply ~a #:separator \"\n\"\n           (let loop ((i 0))\n             (cond ((= i len) '())\n                   (else (cons (apply ~a (map (lambda (strng)\n                                                (string-ref strng i))\n                                              splited))\n                               (loop (add1 i)))))))))\n\n(define (selfie-and-diag1 strng)\n  ; your code\n  (let ((sym (diag-1-sym strng)))\n    (apply ~a\n           (map (lambda (str1 str2)\n                   (~a str1 str2\n                       #:separator \"|\"))\n                (string-split strng \"\n\")\n                (string-split sym    \"\n\"))\n           #:separator \"\n\")))\n\n(define (oper fct s)\n  (fct s))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290567,"user_id":null,"body":"#lang racket\n(provide rot-90-clock diag-1-sym selfie-and-diag1 oper)\n\n(define (diag-1-sym s)\n  (out (apply map list (in s))))\n\n(define (rot-90-clock s)\n  (out (map reverse (in (diag-1-sym s)))))\n\n(define (selfie-and-diag1 s)\n  (define diag (in (diag-1-sym s)))\n  (define strings (in s))\n  (out (for\/list ([n (length strings)])\n         (append (list-ref strings n) (list #\\|) (list-ref diag n)))))\n    \n(define (oper fct s)\n  (fct s))\n\n(define (in s)\n  (map string->list (string-split s \"\n\")))\n\n(define (out s)\n  (string-join (map list->string s) \"\n\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290568,"user_id":null,"body":"#lang racket\n(provide rot-90-clock diag-1-sym selfie-and-diag1 oper)\n\n(define (diag-1-sym s)\n  (define strings (in s))\n  (out (for\/list ([r (length strings)])\n         (for\/list ([c (length strings)])\n           (list-ref (list-ref strings c) r)))))\n\n(define (rot-90-clock s)\n  (out (map reverse (in (diag-1-sym s)))))\n\n(define (selfie-and-diag1 s)\n  (define diag (in (diag-1-sym s)))\n  (define strings (in s))\n  (out (for\/list ([n (length strings)])\n         (append (list-ref strings n) (list #\\|) (list-ref diag n)))))\n    \n(define (oper fct s)\n  (fct s))\n\n(define (in s)\n  (map string->list (string-split s \"\n\")))\n\n(define (out s)\n  (string-join (map list->string s) \"\n\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290569,"user_id":null,"body":"#lang racket\n(provide rot-90-clock diag-1-sym selfie-and-diag1 oper)\n\n;; Convert a 2d index (row, col) to a 1d index.\n(define (index-2d->index-1d row col dim)\n  (+ (* row dim) col))\n\n;; Convert a 1d index into a 2d index (row, col).\n(define (index-1d->index-2d index dim)\n  (let ([row (quotient index dim)]\n        [col (remainder index dim)])\n    (values row col)))\n\n;; Take string with the newlines and remove them.\n(define (string->square-string string0)\n  (string-replace (string-copy string0) \"\n\" \"\"))\n\n;; Take string without the new lines and add them.\n(define (square-string->string string0)\n  (define (loop square-string new-string start segment-length string0-length)\n    (if (= (+ start segment-length) string0-length)\n        (string-append new-string (substring string0 start (+ start segment-length)))\n        (loop square-string\n              (string-append new-string (substring string0 start (+ start segment-length)) \"\n\")\n              (+ start segment-length)\n              segment-length\n              string0-length)))\n  (let* ([string0-length (string-length string0)]\n         [segment-length (sqrt string0-length)])\n    (loop string0 \"\" 0 segment-length string0-length)))\n    \n;; Rotate string along the diagonal from (0, 0) to (n-1, n-1).\n;; This is done by switching the row, col values for each letter\n;; when row < col.\n(define (diag-1-sym0 strng)\n  (define string0 (string->square-string strng))\n  (define (loop row col string0 dim)\n    (when (< row dim)\n      (if (= row col)\n          (loop (add1 row) 0 string0 dim)\n          (let* ([t-index (index-2d->index-1d row col dim)]\n                 [t (string-ref string0 t-index)]\n                 [s-index (index-2d->index-1d col row dim)]\n                 [s (string-ref string0 s-index)])\n            (string-set! string0 s-index t)\n            (string-set! string0 t-index s)\n            (loop row (add1 col) string0 dim)))))\n  (loop 0 0 string0 (sqrt (string-length string0)))\n  string0)\n\n;; Take result of diagonal transformation and put newlines in it.\n(define (diag-1-sym strng)\n  (square-string->string (diag-1-sym0 strng)))\n\n;; Reverse each row of a square string.\n(define (reverse-rows s)\n  (define (reverse-string ss)\n    (list->string (reverse (string->list ss))))\n  (define (loop string0 start segment-length string0-length)\n    (when (< start string0-length)\n      (let ([t (reverse-string (substring string0 start (+ start segment-length)))])\n        (string-copy! string0 start t)\n        (loop string0\n              (+ start segment-length)\n              segment-length\n              string0-length))))\n  (let* ([string0-length (string-length s)]\n         [segment-length (sqrt string0-length)]\n         [string0 (string-copy s)])\n    (loop string0 0 segment-length string0-length)\n    string0))\n\n;; Rotate the string 90 degrees clockwise.\n;; This is a digonal transformation, followed by reversing the rows.\n(define (rot-90-clock strng)\n  (let ([t (diag-1-sym0 strng)])\n    (square-string->string (reverse-rows t))))\n\n(define (selfie-and-diag1 strng)\n  (define (loop square-string diag-string new-string start segment-length string0-length)\n    (if (= (+ start segment-length) string0-length)\n        (let ([left (substring square-string start (+ start segment-length))]\n              [right (substring diag-string start (+ start segment-length))])\n          (string-append new-string left \"|\" right))\n        (let ([left (substring square-string start (+ start segment-length))]\n              [right (substring diag-string start (+ start segment-length))])\n          (loop square-string\n                diag-string\n                (string-append new-string left \"|\" right \"\n\")\n                (+ start segment-length)\n                segment-length\n                string0-length))))\n  (let* ([string0 (string->square-string strng)]\n         [string0-length (string-length string0)]\n         [segment-length (sqrt string0-length)]\n         [diag-string0 (diag-1-sym0 string0)])\n    (loop string0 diag-string0 \"\" 0 segment-length string0-length)))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56dbf59b0a10feb08c000227":[{"id":290570,"user_id":null,"body":"#lang racket\n(provide rot-90-counter diag-2-sym selfie-diag2-counterclock oper)\n\n(define (diag-2-sym s)\n  (out (reverse (map reverse (apply map list (in s))))))\n\n(define (rot-90-counter s)\n   (out (reverse (apply map list (in s)))))\n\n(define (selfie-diag2-counterclock s)\n  (define diag (in (diag-2-sym s)))\n  (define cc (in (rot-90-counter s)))\n  (define strings (in s))\n  (out (for\/list ([n (length strings)])\n         (append (list-ref strings n)\n                 (list #\\|)\n                 (list-ref diag n)\n                 (list #\\|)\n                 (list-ref cc n)))))\n    \n(define (oper fct s)\n  (fct s))\n\n(define (in s)\n  (map string->list (string-split s \"\n\")))\n\n(define (out s)\n  (string-join (map list->string s) \"\n\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290571,"user_id":null,"body":"#lang racket\n(provide rot-90-counter diag-2-sym selfie-diag2-counterclock oper)\n\n(define (transpose xss)\n  (apply map list xss))\n\n(define (diag-2-sym strng)\n  (string-join\n   (map list->string\n        (reverse\n         (map reverse\n              (transpose (map string->list (string-split strng \"\n\"))))))\n   \"\n\"))\n\n(define (rot-90-counter strng)\n  (string-join\n   (map list->string\n        (reverse (transpose\n                  (map string->list\n                       (string-split strng \"\n\")))))\n   \"\n\"))\n\n(define (selfie-diag2-counterclock strng)\n  (let ([diag (string-split (diag-2-sym strng) \"\n\")]\n        [counter (string-split (rot-90-counter strng) \"\n\")]\n        [self (string-split strng \"\n\")])\n    (string-join\n     (map (\u03bb (ss) (string-join ss \"|\"))\n          (map list self diag counter))\n     \"\n\")))\n\n(define (oper fct s)\n  (fct s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290572,"user_id":492,"body":"#lang racket\n(provide rot-90-counter diag-2-sym selfie-diag2-counterclock oper)\n\n(define (string-reverse s)\n      (list->string (reverse (string->list s))))\n\n(define (rot-90-counter strng)\n  (define (transpose xss)\n    (apply map list xss))\n  \n  (let* ([a (map (\u03bb(x) (string-reverse x)) (string-split strng \"\n\"))]\n         [b (map (\u03bb(x) (list->string x)) (transpose (map (\u03bb(x) (string->list x)) a)))])\n    (string-join b  \"\n\" )))\n\n(define (diag-2-sym strng)\n  (let ([a (map (\u03bb(x) (string-reverse x)) (string-split (rot-90-counter strng) \"\n\"))])\n    (string-join a \"\n\")))\n\n(define (selfie-diag2-counterclock strng)\n  (let* ([a1 (string-split strng \"\n\")]\n         [a2 (string-split (diag-2-sym strng) \"\n\")]\n         [a3 (string-split (rot-90-counter strng) \"\n\")]\n         [a4 (for\/list ([i (range 0 (length a1))])\n               (string-append (list-ref a1 i) \"|\" (list-ref a2 i) \"|\" (list-ref a3 i)))])        \n    (string-join a4 \"\n\")))\n\n(define (oper fct s)\n  (fct s))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56dec885c54a926dcd001095":[{"id":290573,"user_id":527,"body":"#lang racket\n(provide opposite)\n\n(define opposite -)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290574,"user_id":527,"body":"#lang racket\n(provide opposite)\n\n(define (opposite n) (- n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290575,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n;; number -> number\n;; takes a number and produces its opposite\n\n(define (opposite n)\n  (* n -1))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290576,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n(define (opposite n)\n(* (- 0 1) n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290577,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n(define (opposite n)\n  (if (> n 0 ) (- 0 n)\n      (abs n)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290578,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n; tried a different approach, probably cleaner way...\n(define (opposite n)\n  (define num (number->string n))\n  (if (equal? #\\- (string-ref num 0))\n      (string->number (substring num 1))\n      (string->number (string-append \"-\" num))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290579,"user_id":null,"body":"#lang racket\n(provide opposite)\n; (define (opposite-ref-impl n) (- n)) in the sample tests\n; means reference implementation, no? :P\n(define (opposite n) (- n))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290580,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n(define opposite (lambda(a) (- 0 a)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290581,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n(define (opposite n)\n  (cond ((< n 0) (- n))\n        (else (- n (* n 2))\n        )\n  )\n  )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290582,"user_id":null,"body":"#lang racket\n(provide opposite)\n\n(define opposite (curry * -1))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56e3cd1d93c3d940e50006a4":[{"id":290583,"user_id":492,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (let* ([lst (sort lst >)]\n         [l1 (for\/list ([i (length lst)] #:when (even? i))\n               (list-ref lst i))]\n         [l2 (for\/list ([i (length lst)] #:when (odd? i))\n               (list-ref lst i))])\n    (append l1 (reverse l2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290584,"user_id":null,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (let* ((xs (put-left null null (sort lst >)))\n         (left-list (list-ref xs 0))\n         (right-list (list-ref xs 1)))\n    (cond ((= (length left-list) (length right-list))\n           (append (reverse left-list) right-list))\n          (else\n           (append (reverse (cdr left-list)) (list (car left-list)) right-list)))))\n\n(define (put-left left-list right-list l)\n  (cond [(empty? l) (list left-list right-list)]\n        [else (put-right (cons (car l) left-list) right-list (cdr l))]))\n\n(define (put-right left-list right-list l)\n  (cond [(empty? l) (list left-list right-list)]\n        [else (put-left left-list (cons (car l) right-list) (cdr l))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290585,"user_id":53,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (let* ([xs (sort lst >)]\n         [n (length xs)]\n         [a (for\/list ([i n] \n                #:when (even? i))\n               (list-ref xs i))]\n         [b (for\/list ([i n]\n                #:when (odd? i))\n               (list-ref xs i))])\n    (append a (reverse b))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290586,"user_id":null,"body":"#lang racket\n\n(provide make-valley)\n\n;; (Listof Integer) -> (Listof Integer)\n;; sort numbers in a special way such that the result resembles a V-shape:\n;; smallest number in the middle, then two next smallest around it, then\n;; a pair of yet larger numbers around the first pair etc. In each pair, put\n;; larger num to the left. If length of lst is odd, put min to the right half.\n(define (make-valley lst)\n  \n  (define sorted (sort lst <))\n\n  (define (loop accum todo)\n    (if (empty? todo)\n        accum\n        (let ([f (first todo)]\n              [s (second todo)])\n          (loop `(,(max f s) ,@accum ,(min f s))\n                (drop todo 2)))))\n  \n  (if (odd? (length sorted))\n      (loop (list (first sorted)) (drop sorted 1))\n      (loop '() sorted)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290587,"user_id":null,"body":"#lang racket\n(provide make-valley)\n\n(define (create-wings left-wing right-wing lst)\n  (let* ([n (first lst)]\n        [tail (rest lst)]\n        [left (length tail)])\n    (cond [(zero? left) (list left-wing right-wing)]\n          [(> (length left-wing) (length right-wing)) (create-wings left-wing (sort (append right-wing (list n)) <) tail)]\n          [else (create-wings (append left-wing (list n)) right-wing tail)]\n          )))\n\n(define (make-valley lst)\n  (cond [(empty? lst) '()]\n        [else (let ([bottom (take (sort lst <) 1)]\n                    [results (create-wings empty empty (sort lst >))])\n                (flatten (list (take results 1) bottom (drop results 1))))])\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290588,"user_id":null,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (let* ([s (sort lst >)]\n         [len (length s)]\n         [even (range 0 len 2)]\n         [odd  (range 1 len 2)]\n         [left  (for\/list ([r even]) (list-ref s r))]\n         [right (for\/list ([r odd ]) (list-ref s r))])\n    (append left (reverse right))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290589,"user_id":null,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (let* ([s (sort lst >)]\n         [len (length s)]\n         [left (for\/list  ([r (range 0 len 2)]) (list-ref s r))]\n         [right (for\/list ([r (range 1 len 2)]) (list-ref s r))])\n    (append left (reverse right))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290590,"user_id":null,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (define sorted (sort lst >))\n  (define left (for\/list ([s sorted]\n                          [idx (length sorted)]\n                          #:when (even? idx)) s))\n  (define right (for\/list ([s sorted]\n                          [idx (length sorted)]\n                          #:when (odd? idx)) s))\n  (append left (reverse right))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290591,"user_id":492,"body":"#lang racket\n(provide make-valley)\n\n(define (make-valley lst)\n  (let* ([lst (sort lst >)]\n         [l1 (for\/list ([i (length lst)] #:when (even? i))\n               (list-ref lst i))]\n         [l2 (for\/list ([i (length lst)] #:when (odd? i))\n               (list-ref lst i))])\n    (append l1 (reverse l2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56e7d40129035aed6c000632":[{"id":290592,"user_id":168,"body":"#lang racket\n(provide easy-line)\n\n(define (easy-line n)\n  (for\/fold ([c 1])\n            ([i (in-range 1 (add1 n))])\n    (\/ (* c (+ n i)) i)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290593,"user_id":492,"body":"#lang racket\n(provide easy-line)\n\n(define (easy-line n)\n  (define (choose n p)\n    (let ([p (min p (- n p))])\n      (cond \n        ((negative? p) 0)\n        (else\n         (letrec ((aux\n                   (lambda (value i)\n                     (cond ((zero? i) value)\n                           (else (aux (* value (\/ (- n i -1) i)) (sub1 i)))))))\n           (aux 1 p))))))\n  (choose (* 2 n) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290594,"user_id":null,"body":"#lang racket\n(provide easy-line)\n\n(define (easy-line n)\n  (letrec ((factorial (lambda (x) (if (zero? x) 1 (* x (factorial (- x 1)))))))\n    (\/ (factorial (* 2 n)) (expt (factorial n) 2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290595,"user_id":null,"body":"#lang racket\n(provide easy-line)\n\n(define (factorial n)\n  (sequence-fold * 1 (in-inclusive-range 1 n)))\n\n(define (binomial n p)\n  (\/ (factorial n) (* (factorial p) (factorial (- n p)))))\n\n(define (easy-line n)\n  (binomial (* 2 n) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290596,"user_id":null,"body":"#lang racket\n(provide easy-line)\n\n(define (easy-line n)\n  (quotient (fact (* 2 n)) (sqr (fact n)))\n)\n(define (fact n)\n  (f-i 1 1 n))\n(define (f-i a b n)\n  (if (> b n)\n      a\n      (f-i (* a b) (+ b 1) n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290597,"user_id":544,"body":"#lang racket\n(provide easy-line)\n\n; multiplicative formula for the binomial coefficient\n; to generate it without needing to compute factorials\n(define (binomial n k)\n  (for\/product \n   ([i (in-range 1 (add1 k))])\n   (\/ (- n i -1) i)))\n\n; row n of Pascal's triangle is binomial(n, i) for all i 0 <= i <= n\n(define (easy-line n)\n  (for\/sum\n   ([i (in-range 0 (add1 n))])\n   (sqr (binomial n i))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290598,"user_id":null,"body":"#lang racket\n\n(provide easy-line)\n\n;; Integer>=0 -> Integer\n;; return the sum of the squares of the binomial coefficients on line n\n;; of Pascal's triangle (counting from 0)\n(define (easy-line n)\n\n  ;; literal translation of this: https:\/\/stackoverflow.com\/a\/15580400\n  ;; probably not very rackety, but I believe the most efficient way\n  (define (pascal-row n)\n  (begin\n    (define line (make-vector (add1 n)))\n    (vector-set! line 0 1)\n    (for ([k (in-range n)])\n      (vector-set! line (add1 k) (\/ (* (vector-ref line k) (- n k)) (add1 k))))\n    line))\n  \n  (foldl + 0 (map sqr (vector->list (pascal-row n)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290599,"user_id":null,"body":"#lang racket\n(provide easy-line)\n\n(define (easy-line n)\n  (for\/sum ([i (in-range 0 (+ n 1))])\n    (expt (binomial n i) 2)))\n\n(define (binomial n k)\n  (for\/product ([i (in-range 1 (add1 k))])\n    (\/ (+ n 1 (- i)) i)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290600,"user_id":null,"body":"#lang racket\n(provide easy-line)\n\n(define (easy-line n)\n  (foldr + 0 (map sqr (pascal-line n))))\n\n(define (pascal-line n)\n  (build-list (add1 n) (lambda (k) (n-over-k n k))))\n\n(define (n-over-k n k)\n  (\/ (! n) (* (! k) (! (- n k)))))\n\n(define (! n)\n  (apply * (build-list n add1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290601,"user_id":242,"body":"#lang racket\n(provide easy-line)\n\n(define (factorial n)\n  (define (factorial-iter acc d)\n    (if\n      (= d 1)\n      acc\n      (factorial-iter (* acc d) (- d 1))\n    )\n  )\n  (if\n    (= n 0)\n    1\n    (factorial-iter 1 n)\n  )\n)\n\n(define (easy-line n)\n  (\/ (factorial (* 2 n)) (sqr (factorial n)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56ed20a2c4e5d69155000301":[{"id":290602,"user_id":53,"body":"#lang racket\n(provide scale)\n\n(define (rep-string n str)\n  (string-append* (make-list n str)))\n\n(define (scale strng k n)\n  (define a (regexp-replace* #rx\"[^\n]\" (string-append strng \"\n\")\n                   (lambda (one)\n                     (rep-string k one))))\n  (define b (regexp-replace* #rx\"[^\n]+\n\" a\n                   (lambda (one)\n                     (rep-string n one))))\n  (string-trim b \"\n\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290603,"user_id":null,"body":"#lang racket\n(provide scale)\n\n(define (transform-line k n line)\n  (let ([new-line (apply string-append\n                         (map (lambda (char) (list->string (make-list k char)))\n                              (string->list line)))])\n    (string-join (make-list n new-line) \"\n\")))\n\n(define (scale str k n)\n  (let ([lines (map (curry transform-line k n) (string-split str \"\n\"))])\n    (string-join lines \"\n\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290604,"user_id":null,"body":"#lang racket\n(provide scale)\n\n(define (scale strng k n)\n  (scale-lines strng k n))\n\n(define (scale-lines str k n)\n  (let ((parts (string-split str)))\n    (string-trim\n     (apply string-append\n            (map\n             (curryr scale-line n k)\n             parts)))))\n\n(define (scale-line str k n)\n  (v-scale-line (h-scale-line str k n) k n ))\n\n(define (h-scale-line str k n)\n  (apply string-append\n         (map\n          (curry make-string n)\n          (string->list str))))\n\n(define (v-scale-line str k n)\n  (apply string-append\n         (map\n          (lambda (i)\n            (string-append str \"\n\"))\n          (range k))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290605,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide scale)\n\n;; String Int>=1 Int>=1 -> String\n;; scale the string horizontally by factor k and then vertically by factor n\n(define (scale str k n)\n\n  (define (hscale str)\n    (string-append* (for\/list ([c str]) (make-string k c))))\n\n  (define (vscale str)\n    (string-join (make-list n str) \"\n\"))\n  \n   (string-join (map vscale (map hscale (string-split str \"\n\"))) \"\n\"))\n\n(module+ test\n  (check-equal?\n   (scale \"abcd\nefgh\nijkl\nmnop\" 2 3)\n   \"aabbccdd\naabbccdd\naabbccdd\neeffgghh\neeffgghh\neeffgghh\niijjkkll\niijjkkll\niijjkkll\nmmnnoopp\nmmnnoopp\nmmnnoopp\")\n  (check-equal? (scale \"\" 5 5) \"\")\n  (check-equal? (scale \"Kj\nSH\" 1 2) \"Kj\nKj\nSH\nSH\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290606,"user_id":544,"body":"#lang racket\n(provide scale)\n\n(define (scale-string-horiz strng n)\n  (string-join (map (lambda (s)\n                      (foldl (lambda (c acc)\n                               (string-append acc (make-string n c)))\n                             \"\"\n                             (string->list s)))\n                    (string-split strng))\n               \"\n\"))\n\n(define (scale-string-vert strng n)\n  (string-join (foldl (lambda (s acc) (append acc (make-list n s)))\n                      '()\n                      (string-split strng))\n               \"\n\"))\n\n(define (scale strng horiz vert)\n  (scale-string-vert (scale-string-horiz strng horiz) vert))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290607,"user_id":null,"body":"#lang racket\n(provide scale)\n\n(define (scale strng k n)\n  (string-join\n   (apply append\n    (map (lambda (s)\n           (map (lambda (ign)\n                  (apply string-append (map (curry make-string k) (string->list s))))\n                (range n)))\n         (string-split strng))) \"\n\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290608,"user_id":null,"body":"#lang racket\n(provide scale)\n\n(define (scale strng k v)\n  (string-trim\n   (string-append*\n          (map (lambda (parse-string)\n                 (string-append*\n                  (map (lambda (x) (string-append x \"\n\"))\n                       (make-list v\n                                  (string-append*\n                                         (map (lambda (parse-char)\n                                                (make-string k parse-char))\n                                              (string->list parse-string)))))))\n                    (string-split strng \"\n\")))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290609,"user_id":492,"body":"#lang racket\n(provide scale)\n\n(define (scale strng k n)\n  (define (repeat-char n ch)\n    (make-string n ch))\n  (define (string-repeat n str)\n    (string-join (make-list n str) \"\n\"))\n  (if (equal? strng \"\")\n      \"\"\n      (let* ([r1 (map (\u03bb(y) (map (\u03bb(x) (repeat-char k x)) (string->list y))) (string-split strng \"\n\"))]\n             [r2 (map (\u03bb(u) (string-join u \"\")) r1)]\n             [r3 (map (\u03bb(z) (string-repeat n z)) r2)])\n        (string-join r3 \"\n\" ))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56efab15740d301ab40002ee":[{"id":290610,"user_id":53,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n(define-values (som maxi mini lcmu gcdi) (values + max min lcm gcd))\n(define (scan f i l) (if (empty? l) l (append (list (f i (first l))) (scan f (f i (first l)) (rest l)))))\n(define (oper-array f xs seed) (scan f seed xs))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290611,"user_id":492,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define som +)\n(define maxi max)\n(define mini min)\n(define lcmu lcm)\n(define gcdi gcd)\n\n(define (oper-array fct ls init)\n  (define (loop acc tab res)\n    (if (empty? tab)\n      (reverse res)\n      (let ([acc (fct acc (first tab))])\n        (loop acc (rest tab) (cons acc res)))))\n  (loop init ls '()))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290612,"user_id":53,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define som +)\n(define maxi max)\n(define mini min)\n(define lcmu lcm)\n(define gcdi gcd)\n(define (scan f i l) (if (empty? l) l (append (list (f i (first l))) (scan f (f i (first l)) (rest l)))))\n(define (oper-array f xs seed) (scan f seed xs))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290613,"user_id":53,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define (som a b)\n  (+ a b)\n)\n(define (maxi a b)\n  (max a b)\n)\n(define (mini a b)\n  (min a b)\n)\n(define (lcmu a b)\n  (quotient (abs (* a b)) (gcdi a b))\n)\n(define (gcdi a b)\n  (if (= b 0) \n    (abs a)\n    (gcdi b (modulo a b))\n  )\n)\n(define (scan f i l)\n  (if (empty? l) l (append (list (f i (first l))) (scan f (f i (first l)) (rest l)))))\n(define (oper-array f xs seed)\n  (scan f seed xs)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290614,"user_id":544,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define (som x y)\n  (+ x y))\n(define (maxi x y)\n  (max x y))\n(define (mini x y)\n  (min x y))\n(define (lcmu x y)\n  (lcm (abs x) (abs y)))\n(define (gcdi x y)\n  (gcd (abs x) (abs y)))\n\n(define (oper-array fct ls init)\n  (if (= 1 (length ls))\n      (cons (fct init (car ls)) '())\n      (cons (fct init (car ls)) (oper-array fct (cdr ls) (fct init (car ls))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290615,"user_id":null,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define (som x y) (+ x y))\n(define (maxi x y) (if (> x y) x y))\n(define (mini x y) (if (< x y) x y))\n(define (lcmu x y) (\/ (* (abs x) (abs y)) (gcdi x y)))\n(define (gcdi x y) \n  (match (list (abs x) (abs y))\n         [(list a 0) a]\n         [(list a b) (gcdi b (remainder a b))]))\n\n(define (oper-array fct ls init)\n  (if (null? ls)\n      ls\n      (let ([next (fct init (first ls))])\n        (cons next (oper-array fct (rest ls) next)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290616,"user_id":null,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define-values (som maxi mini lcmu gcdi) (values + max min lcm gcd))\n\n(define (oper-array fct ls init)\n  (drop (foldl (lambda (x y) (append y (list (fct (last y) x)))) \n               (list init)\n               ls) 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290617,"user_id":null,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define som +)\n(define maxi max)\n(define mini min)\n(define (lcmu x y) (lcm (abs x) (abs y)))\n(define (gcdi x y) (gcd (abs x) (abs y)))\n\n(define (oper-array fct ls init)\n  (if (null? ls)\n      '()\n      (let ((reduce-val (fct init (car ls))))\n        (cons reduce-val (oper-array fct (cdr ls) reduce-val)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290618,"user_id":null,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define som +)\n(define maxi max)\n(define mini min)\n(define lcmu lcm)\n(define gcdi gcd)\n\n(define (oper-array fct ls init)\n  (if (null? ls)\n    '()\n    (let ((val (fct init (car ls))))\n      (cons val (oper-array fct (cdr ls) val)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290619,"user_id":null,"body":"#lang racket\n(provide som maxi mini lcmu gcdi oper-array)\n\n(define som +)\n(define maxi max)\n(define mini min)\n(define lcmu lcm)\n(define gcdi gcd)\n\n(define (oper-array f l ini)\n  (foldl (lambda (a r) (append r (list (f (last r) a)))) (list (f ini (first l))) (list-tail l 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56f253dd75e340ff670002ac":[{"id":290620,"user_id":null,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (let ([s1-strings (string-split s1)]\n        [s2-strings (reverse (string-split s2))]\n        [go (lambda (str1 str2 i)\n              (string-append\n                (substring str1 0 i)\n                (substring str2 0 (add1 (- (string-length str2) i)))))])\n    (string-join (map go s1-strings s2-strings (range 1 (add1 (length s1-strings)))) \"\n\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290621,"user_id":null,"body":"#lang racket\n\n(provide compose)\n\n;; String String -> String\n;; combine squared strings s1 and s2 in a way that is too long to describe\n;; in a one-liner docstring\n(define (compose s1 s2)\n  (define ll1 (string-split s1 \"\n\"))\n  (define ll2 (string-split s2 \"\n\"))\n  (define n (length ll1))\n  (string-join\n   (for\/list ([l1 (in-list ll1)]\n              [l2 (in-list (reverse ll2))]\n              [i (in-range 1 (add1 n))])\n     (string-append (substring l1 0 i) (substring l2 0 (- (add1 n) i))))\n   \"\n\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290622,"user_id":168,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (string-join\n    (for\/list ([i (in-naturals 1)]\n               [x (string-split s1 \"\n\")]\n               [y (reverse (string-split s2 \"\n\"))])\n      (string-append (substring x 0 i) (substring y 0 (- (string-length x) i -1))))\n    \"\n\")\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290623,"user_id":null,"body":"#lang racket\n(provide compose)\n\n(define (grabEndChars s2 n)\n  (let ([grab (- (string-length s2) n)])\n      (cond [(> n (string-length s2)) \"\"]\n        [else (substring s2 0 (+ grab 1))])))\n\n(define (buildStrng s1 s2 strng count)\n  (cond [(empty? s1) strng]\n        [else\n         (let* ([str1 (first s1)]\n              [str2 (first s2)]\n              [frontChars (substring str1 0 count)])\n          (buildStrng (rest s1) (rest s2) (append strng (list (string-append frontChars (grabEndChars str2 (string-length frontChars))))) (+ count 1)))]))\n\n(define (compose s1 s2)\n  (string-join (buildStrng (string-split s1) (reverse (string-split s2)) empty 1) \"\n\")\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290624,"user_id":null,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (define l1 (string-split s1 \"\n\"))\n  (define l2 (reverse (string-split s2 \"\n\")))\n  (define l (length l1))\n  (define out '())\n  (for ([i (length l1)])\n    (set! out (append out (list \n          (string-append (substring (list-ref l1 i) 0 (add1 i))\n                         (substring (list-ref l2 i) 0 (- l i)))))))\n  (string-join out \"\n\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290625,"user_id":null,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (let* ((ss1 (string-split s1))\n        (ss2 (string-split s2))\n        (n (length ss1)))\n    (for\/fold ([res \"\"])\n              ([i (range n)])\n      (string-append res\n                     (if (> i 0) \"\n\" \"\")\n                     (substring (list-ref ss1 i) 0 (+ 1 i))\n                     (substring (list-ref ss2 (- n i 1)) 0 (- n i))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290626,"user_id":null,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (define s1-list (string-split s1 \"\n\"))\n  (define s2-list-reverse (reverse (string-split s2 \"\n\")))\n  (define len (length s1-list))\n  (define result-list\n    (for\/list ([s1-item s1-list]\n               [s2-item s2-list-reverse]\n               [i len])\n              (string-append (substring s1-item 0 (add1 i))\n                             (substring s2-item 0 (- len i)))))\n  (string-join result-list \"\n\")\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290627,"user_id":492,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (let* ([a2 (reverse (string-split s2 \"\n\"))]\n        [lg (length a2)]\n        [a1 (for\/list ([i (range 0 lg)] [x (string-split s1 \"\n\")] [y a2])\n               (string-append (substring x 0 (add1 i)) (substring y 0 (- (string-length y) i))))])\n    (string-join a1 \"\n\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290628,"user_id":492,"body":"#lang racket\n(provide compose)\n\n(define (compose s1 s2)\n  (let* ([a2 (reverse (string-split s2 \"\n\"))]\n        [lg (length a2)]\n        [a1 (for\/list ([i (range 0 lg)] [x (string-split s1 \"\n\")] [y a2])\n               (string-append (substring x 0 (add1 i)) (substring y 0 (- (string-length y) i))))])\n    (string-join a1 \"\n\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56f3a1e899b386da78000732":[{"id":290629,"user_id":492,"body":"#lang racket\n(provide part-list)\n\n(define (part-list ls)\n  (for\/list ([i (in-range 1 (length ls))])\n    (list (string-join (take ls i)  \" \" )\n          (string-join (drop ls i) \" \" ))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290630,"user_id":null,"body":"#lang racket\n(provide part-list)\n\n(define (join input counter result)\n  (let ([long (length input)])\n    (if (= counter (- long 1)) (string-append result (list-ref input counter))\n      (join input (+ counter 1) (string-append result (list-ref input counter) \" \"))))\n)\n\n(define (new-item input)\n  (let ([first (join (list-ref input 0) 0 \"\")]\n        [second (join (list-ref input 1) 0 \"\")])\n\t(cons first (cons second '())))\n)\n\n(define (splitList lst n)\n  (let-values (((head tail) (split-at lst n)))\n    (list head tail)))\n\n(define (part2 input counter limit answer)\n  (if (= counter limit) (reverse answer)\n    (let ([items (splitList input counter)])\n      (part2 input (+ counter 1) limit \n\t(cons (new-item items) answer))))\n)\n\n(define (part-list ls)\n  (let ([long (length ls)])\n    (part2 ls 1 long '()))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290631,"user_id":53,"body":"#lang racket\n(provide part-list)\n\n(define (part-list arr)\n  (for\/list ([i (in-range 1 (length arr))])\n    (list (string-join (take arr i) \" \" )\n          (string-join (drop arr i) \" \" ))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290632,"user_id":null,"body":"#lang racket\n(provide part-list)\n\n(define (part-list ls)\n  ; your code\n  (define (pl ls i n)\n    (if (< i n)\n        (cons (list (string-join (take ls i)) (string-join (drop ls i))) (pl ls (+ 1 i) n))\n        '()))\n(pl ls 1 (length ls)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290633,"user_id":null,"body":"#lang racket\n(provide part-list)\n\n(define (join-halves n items)\n  (let-values\n    ([(front back) (split-at items n)])\n    (list (string-join front) (string-join back))))\n\n(define (part-list ls)\n  (map\n    (lambda (x) (join-halves x ls))\n    (build-list (sub1 (length ls)) add1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290634,"user_id":544,"body":"#lang racket\n(provide part-list)\n\n(define (part-list ls [first-part \"\"])\n  (cond [(null? (cdr ls)) '()]\n        [else (define first-part-joined (string-trim (string-join (list first-part (car ls)) \" \")))\n              (define second-part-joined (string-join (cdr ls) \" \"))\n                (cons (list first-part-joined second-part-joined)\n                      (part-list (cdr ls) first-part-joined))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290635,"user_id":null,"body":"#lang racket\n\n(provide part-list)\n\n;; (Listof>2 String) -> (Listof (Listof=2 String))\n;; split given list into two parts in all possible ways\n(define (part-list ls)\n  (for\/list ([i (in-range 1 (length ls))])\n    (let-values ([(left right) (split-at ls i)])\n      (list (string-join left) (string-join right)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290636,"user_id":null,"body":"#lang racket\n(provide part-list)\n\n(define (strcat lst)\n  (cond\n    [(empty? lst) \"\"]\n    [(empty? (cdr lst)) (car lst)]\n    [else (string-append (car lst) \" \" (strcat (cdr lst)))]))\n\n(define (partition split lst lt rt)\n  (cond\n    [(empty? lst) (cons (reverse lt) (reverse rt))]\n    [(zero? split) (partition 0 (cdr lst) lt (cons (car lst) rt))]\n    [else (partition (- split 1) (cdr lst) (cons (car lst) lt) rt)]))\n\n(define (pair-str tpl)\n  `(,(strcat (car tpl)) ,(strcat (cdr tpl))))\n\n(define (part-list lst)\n  (define n (length lst))\n  (define (aux i)\n    (cond\n      [(= n i) '()]\n      [else (cons (pair-str (partition i lst '() '())) (aux (+ i 1)))]))\n  (aux 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290637,"user_id":null,"body":"#lang racket\n(provide part-list)\n\n(define (part-list ls)\n   (part-list-h ls (- (length ls) 1) 1))\n    \n(define (merge x y)\n    (string-append x y))\n(define (space ls)\n  (reverse (cdr (foldl (lambda (x y) (cons \" \" (cons x y))) empty ls))))\n\n(define (part-list-h ls i c)\n  (if (<= c i)\n    (cons (list\n                (foldr merge \"\" (space (take ls c)))\n                (foldr merge \"\" (space (drop ls c))))\n          (part-list-h ls i (+ c 1)))\n    empty))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290638,"user_id":null,"body":"#lang racket\n(provide part-list)\n\n(define (part-list ls)\n  (define (helper left right)\n    (if (or (null? right)\n            (null? (cdr right))) '()\n        (let* ((new-left (append left (list (car right))))\n               (new-right (cdr right))\n               (string-left (join-with new-left \" \"))\n               (string-right (join-with new-right \" \"))\n               (string-list (cons string-left (cons string-right null))))\n          (cons string-list (helper new-left new-right)))))\n  (helper '() ls))\n\n\n(define (join-with lst joiner)\n  (cond [(null? lst) \"\"]\n        [(null? (cdr lst)) (car lst)]\n        [else (string-append (car lst)\n                             joiner\n                             (join-with (cdr lst) joiner))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56f6919a6b88de18ff000b36":[{"id":290639,"user_id":53,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians n)\n  (cond [(<= n 10) \"Hardly any\"]\n        [(<= n 50) \"More than a handful!\"]\n        [(eq? 101 n) \"101 DALMATIANS!!!\"]\n        [else \"Woah that's a lot of dogs!\"]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290640,"user_id":null,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians number)\n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n  (cond\n    [(<= number 10) (list-ref dogs 0)]\n    [(<= number 50) (list-ref dogs 1)]\n    [(<= number 100) (list-ref dogs 2)]\n    [else (list-ref dogs 3)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290641,"user_id":373,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians number)   \n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n  \n  (cond [(<= number 10) (list-ref dogs 0)]\n        [(<= number 50) (list-ref dogs 1)]\n        [(= number 101) (list-ref dogs 3)]\n        [#t (list-ref dogs 2)]))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290642,"user_id":null,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n;; This is a deeply stupid exercise\n(define (how_many_dalmatians number) \n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n  (if (<= number 10) \n      (list-ref dogs 0)\n      (if (<= number 50)\n          (list-ref dogs 1)\n          (if (<= number 100)\n              (list-ref dogs 2)\n              (list-ref dogs 3)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290643,"user_id":null,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n;; 1<=Integer -> String\n;; respond to the number of dogs friend of yours just bought\n(define (how_many_dalmatians number)  \n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n  \n  (cond\n    [(= number 101) (list-ref dogs 3)]\n    [(<= number 10) (list-ref dogs 0)]\n    [(<= number 50) (list-ref dogs 1)]\n    [else (list-ref dogs 2)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290644,"user_id":168,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians number)\n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n  (cond \n   [(<= number 10) (list-ref dogs 0)]\n   [(<= number 50) (list-ref dogs 1)]\n   [(= number 101) (list-ref dogs 3)]\n   [else (list-ref dogs 2)]))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290645,"user_id":null,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians number)\n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n\n  (cond [(<= number 10) (list-ref dogs 0)]\n        [(<= number 50) (list-ref dogs 1)]\n        [(<= number 100) (list-ref dogs 2)]\n        [(= number 101) (list-ref dogs 3)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290646,"user_id":527,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians number)\n  (cond\n   [(<= number 10) \"Hardly any\"]\n   [(<= number 50) \"More than a handful!\"]\n   [(= number 101) \"101 DALMATIANS!!!\"]\n   [else \"Woah that's a lot of dogs!\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290647,"user_id":null,"body":"#lang racket\n\n(provide how_many_dalmatians)\n\n(define (how_many_dalmatians number)\n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n  (list-ref dogs (cond\n                   [(<= number 10)  0]\n                   [(<= number 50)  1]\n                   [(=  number 101) 3]\n                   [else            2])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290648,"user_id":null,"body":"#lang racket\n\n(provide how-many-dalmations)\n\n  (define dogs '(\"Hardly any\"\n                 \"More than a handful!\"\n                 \"Woah that's a lot of dogs!\"\n                 \"101 DALMATIANS!!!\"))\n\n(define (how-many-dalmations number)\n  (cond \n  [(<= number 10) (list-ref dogs 0)]\n  [(<= number 50)  (list-ref dogs 1)]\n  [(and (>= number 50) (not (eqv? number 101)))  (list-ref dogs 2)]\n  [(eqv? number 101)  (list-ref dogs 3)]\n  )\n )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56f695399400f5d9ef000af5":[{"id":290649,"user_id":168,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail) (string-suffix? body tail))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290650,"user_id":527,"body":"#lang racket\n\n(provide correct_tail)\n\n(define correct_tail string-suffix?)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290651,"user_id":492,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail)\n\n  (eqv? (string-ref body (sub1 (string-length body))) \n        (string-ref tail 0) ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290652,"user_id":373,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail) \n  (equal? (car (reverse (string->list body))) (car (string->list tail))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290653,"user_id":544,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail)\n  (if (equal? tail (substring body (sub1 (string-length body)))) #t #f))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290654,"user_id":null,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail)\n  (define (sub body) (substring body (- (string-length body) (string-length tail))))\n  (equal? (sub body) tail))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290655,"user_id":null,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail)\n\n  (define sub (substring body (sub1 (string-length body))))\n  (if (equal? sub tail) #t #f))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290656,"user_id":null,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail a b) (string-suffix? a (if (char? b) (string b) b)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290657,"user_id":null,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail)\n  (define sub (substring body (- (string-length body) 1)))\n  (equal? sub tail))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290658,"user_id":null,"body":"#lang racket\n\n(provide correct_tail)\n\n(define (correct_tail body tail)\n  (define sub (substring body (- (string-length body) (string-length tail))))\n  (equal? sub tail))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56f69d9f9400f508fb000ba7":[{"id":290659,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (build-list n add1))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290660,"user_id":527,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (range 1 (add1 n)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290661,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (inclusive-range 1 n))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290662,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (define (iter i l)\n    (if (> i n)\n      l\n      (iter (+ i 1) (append l (list i)))))\n  (iter 1 '()))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290663,"user_id":53,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (range 1 (+ 1 n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290664,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (define (recursion n acc)\n    (if (> n 0)\n      (recursion (- n 1) (cons (car (list n)) acc))\n      acc))\n  (recursion n empty)\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290665,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n;; Int -> (Listof Int)\n;; show how to count monkeys by returning a list of numbers from 1 up to `n` (inclusive)\n(define (monkey_count n)\n  (range 1 (add1 n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290666,"user_id":168,"body":"#lang racket\n(provide monkey_count)\n\n(define monkey_count (compose (curry range 1) add1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290667,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (if (> n 1)\n      (append (monkey_count (- n 1)) (list n))\n      (list n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290668,"user_id":null,"body":"#lang racket\n(provide monkey_count)\n\n(define (monkey_count n)\n  (range 1 (+ n 1))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56fc55cd1f5a93d68a001d4e":[{"id":290669,"user_id":null,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (stairs-in-20 stairs)\n  (* 20 (apply + (flatten stairs))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290670,"user_id":527,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (stairs-in-20 stairs)\n  (* 20 (for\/sum ([day stairs]) (apply + day))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290671,"user_id":null,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (sum items) (apply + items))\n\n(define (stairs-in-20 stairs)\n  (* 20 (sum (map sum stairs))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290672,"user_id":544,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (stairs-in-20 stairs)\n  (* 20 (apply + (map (curry apply +) stairs))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290673,"user_id":53,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (stairs-in-20 stairs)\n  (* 20 (foldl (lambda (xs acc) (+ acc (foldl + 0 xs))) 0 stairs)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290674,"user_id":null,"body":"#lang racket\n\n(provide stairs-in-20)\n\n;; (Listof (Listof Number)) -> Integer\n;; given a list with seven lists inside (one per weekday) containing the number\n;; of stairs climbed on that weekday over the year, return an estimate for the\n;; number of stairs the suzuki might climb over the next 20 years\n(define (stairs-in-20 stairs)\n  (* 20 (foldl + 0 (flatten stairs))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290675,"user_id":168,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (stairs-in-20 stairs)\n  (* 20 (apply + (map (lambda (x) (apply + x)) stairs))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290676,"user_id":null,"body":"#lang racket\n\n(provide stairs-in-20)\n\n(define (stairs-in-20 stairs)\n  (* 20 (foldl + 0 (flatten stairs))))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"56fcc393c5957c666900024d":[{"id":290677,"user_id":544,"body":"#lang racket\n(provide code\n         decode)\n\n(define (chunk n xs)\n  (cond\n    [((length xs) . <= . n) (list xs)]\n    [else (cons (take xs n) (chunk n (drop xs n)))]))\n\n(define (code strng)\n  (define square-side\n    (exact-ceiling (sqrt (string-length strng))))\n  (define squared-string\n    (make-string (expt square-side 2) #\\vtab))\n  (string-copy! squared-string 0 strng)\n  (string-join (apply map\n                      (compose (curry apply string) reverse list)\n                      (chunk square-side (string->list squared-string)))\n               \"\\n\"))\n   \n(define (decode strng)\n  (define square-side\n    (exact-ceiling (sqrt (string-length (string-replace strng \"\\n\" \"\")))))\n  (string-trim\n   (string-join\n    (apply map\n           (compose (curry apply string) reverse list)\n           (chunk square-side (reverse (string->list (string-replace strng \"\\n\" \"\")))))\n    \"\")\n   \"\\v\" #:repeat? #true))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-10 12:57:45"},{"id":290678,"user_id":null,"body":"#lang racket\n(provide code decode)\n\n(define (rotate l)\n  (if (or (null? l) (null? (car l)))\n      '()\n      (let ([f (map car l)]\n            [r (map cdr l)])\n        (cons f (rotate r)))))\n\n(define (code t)\n  (let* ([len (string-length t)]\n         [n (exact-ceiling (sqrt (string-length t)))]\n         [filled-t (string-append t (make-string (- (sqr n) len) #\\vtab))])\n    (define (split l)\n      (if (null? l)\n          '()\n          (let-values ([(f r) (split-at l n)])\n            (cons f (split r)))))\n    (define rotated-list\n      (rotate (reverse (split (string->list filled-t)))))\n    (string-join (map list->string rotated-list) \"\\n\")))\n\n(define (decode s)\n  (define square-list (map string->list (string-split s \"\\n\")))\n  (define reverted-strings\n    (map list->string (reverse (rotate square-list))))\n  (string-trim\n    (apply string-append reverted-strings)\n    #px\"\\v+\" #:left? #f))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-10 12:57:47"},{"id":290679,"user_id":null,"body":"#lang racket\n(provide code decode)\n\n(define string-vector (compose list->vector string->list))\n\n(define (code str)\n  (let* ([text-length (string-length str)]\n         [n (exact-ceiling (sqrt text-length))]\n         [padding (make-string (- (sqr n) text-length) (integer->char 11))]\n         [my-vect (string-vector (string-append str padding))]\n         [my-range (vector-length my-vect)])\n          (string-join (for\/list ([j (in-range 0 n)])\n            (list->string (reverse (for\/list ([i (in-range 0 my-range n)])\n              (vector-ref my-vect (+ i j)))))) \"\\n\")))\n\n\n(define reverse-string (compose list->string reverse string->list))\n\n(define (decode str)\n  (let* ([processed-str (string-replace (reverse-string str) \"\\n\" \"\")]\n         [text-length (string-length processed-str)]\n         [n (exact-ceiling (sqrt text-length))]\n         [my-vect (string-vector processed-str)]\n         [my-range (vector-length my-vect)])\n            (string-replace (string-join (for\/list ([j (in-range 0 n)])\n              (list->string (reverse (for\/list ([i (in-range 0 my-range n)])\n                (vector-ref my-vect (+ i j)))))) \"\") \"\\v\" \"\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-10 12:44:19"},{"id":290680,"user_id":null,"body":"#lang racket\n(provide code decode)\n\n(define (transpose xss)\n  (apply map list xss))\n\n(define padding (string (integer->char 11)))\n\n(define (code strng)\n  (if (equal? \"\" strng)\n      \"\"\n      (let* ([segment-length\n              (inexact->exact (ceiling (sqrt (string-length strng))))]\n             [padded-string-length\n              (* segment-length segment-length)]\n             [padded-string\n              (~a strng #:width padded-string-length #:pad-string padding)]\n             [square-string\n              (for\/list\n                  ([i (range 0 padded-string-length segment-length)])\n                (substring padded-string i (+ i segment-length)))])\n        (string-join\n         (map list->string (map reverse (transpose (map string->list square-string))))\n         \"\\n\"))))\n\n(define (decode strng)\n  (if (equal? \"\" strng)\n      \"\"\n      (string-replace\n       (string-join\n        (map list->string\n             (reverse (transpose\n                       (map string->list\n                            (string-split strng \"\\n\")))))\n        \"\")\n       padding \"\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-10 12:44:19"},{"id":290681,"user_id":492,"body":"#lang racket\n(provide code decode)\n\n(define (code strng)\n  (define (chunk-equal s sz)\n    (let ([reg (pregexp (string-append \".{\" (number->string sz) \"}\"))])\n      (regexp-match* reg s)))\n  (define (char-repeat n ch)\n    (make-string n ch))\n  (define (rot-90-clock strng)\n    (define (transpose xss)\n      (apply map list xss))\n    (let* ([ls1 (reverse (string-split strng \"\\n\"))]\n           [m (transpose (map (\u03bb(x) (string->list x)) ls1))]\n           [ls2 (map (\u03bb(x) (list->string x)) m)])\n      (string-join ls2 \"\\n\")))\n  (if (equal? \"\" strng)\n      \"\"\n      (let* ([lg (string-length strng)]\n             [sz (exact-ceiling (sqrt lg))]\n             [s (string-append strng (char-repeat (-  (* sz sz) lg) (integer->char 11)))]) \n        (rot-90-clock (string-join (chunk-equal s sz) \"\\n\")))))\n\n(define (decode strng)\n  (define (transpose xss)\n    (apply map list xss))\n  (define (string-reverse s)\n    (list->string (reverse (string->list s))))\n  (define (rot-90-counter strng)\n    (let* ([a (map (\u03bb(x) (string-reverse x)) (string-split strng \"\\n\"))]\n           [b (map (\u03bb(x) (list->string x)) (transpose (map (\u03bb(x) (string->list x)) a)))])\n      (string-join b  \"\\n\" )))\n  (if (equal? \"\" strng)\n      \"\"\n      (let ([s1 (rot-90-counter strng)])\n        (string-join (string-split (first (string-split s1 \"\\013\")) \"\\n\") \"\"))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-10 12:44:19"}],"56fe17fcc25bf3e19a000292":[{"id":290682,"user_id":53,"body":"#lang racket\n(provide u1 v1 u_eff v_eff)\n\n(define (u1 n p) (* p (add1 n)))\n(define (v1 n p) (* p (add1 (* 2 n))))\n(define (u_eff n p) (u1 n p))\n(define (v_eff n p) (v1 n p))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290683,"user_id":168,"body":"#lang racket\n(provide u1 v1 u_eff v_eff)\n\n(define (u1 n p) \n  (* p (add1 n))\n)\n(define (v1 n p) \n  (* p (+ n n 1))\n)\n(define u_eff u1)\n(define v_eff v1)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290684,"user_id":null,"body":"#lang racket\n(provide u1 v1 u_eff v_eff)\n\n(define (u1 n p) \n  (for\/sum ([k (add1 n)])\n    (* (expt -1 k) p (expt 4 (- n k)) (binomial-coefficient (- (* 2 n) k -1) k))))\n\n(define (v1 n p) \n  (for\/sum ([k (add1 n)])\n    (* (expt -1 k) p (expt 4 (- n k)) (binomial-coefficient (- (* 2 n) k) k))))\n            \n(define (u_eff n p)\n  (* (add1 n) p))\n  \n(define (v_eff n p)\n  (* (+ n n 1) p))\n\n(define (factorial n)\n  (for\/product ([i (range 1 (add1 n))]) i))\n\n(define (binomial-coefficient n k)\n  (\/ (factorial n) (factorial k) (factorial (- n k))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290685,"user_id":527,"body":"#lang racket\n(provide u1 v1 u_eff v_eff)\n\n(define (u1 n p) (* (+ n 1) p))\n(define (v1 n p) (* (+ (* 2 n) 1) p))\n(define u_eff u1)\n(define v_eff v1)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290686,"user_id":492,"body":"#lang racket\n(provide u1 v1 u_eff v_eff)\n\n(define (u1 n p) (* p (add1 n)))\n(define (v1 n p) (* p (add1 (* 2 n))))\n(define (u_eff n p) (* p (add1 n)))\n(define (v_eff n p) (* p (add1 (* 2 n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5700c9acc1555755be00027e":[{"id":290687,"user_id":null,"body":"#lang racket\n(require racket\/set)\n(provide contain-all-rots)\n\n(define (all-rotations str)\n  (for\/set ([i (range (string-length str))])\n            (define pre (substring str 0 i))\n            (define post (substring str i))\n            (string-append post pre)))\n\n(define (contain-all-rots strng xs)\n  (define rots (all-rotations strng))\n  (subset? rots (list->set xs)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290688,"user_id":492,"body":"#lang racket\n(provide contain-all-rots)\n\n(define (contain-all-rots strng xs)\n  (define (all-rots s)\n    (define (rot s)\n      (string-append (substring s 1) (substring s 0 1)))\n    (define (loop i s rots)\n      (if (>= i (string-length s))\n          rots\n          (let ([ss (rot s)])\n            (loop (add1 i) ss (cons ss rots)))))\n    (list->set (loop 0 s '())))\n\n  (let ([ro (all-rots strng)]\n        [st (list->set xs)])\n    (equal? (set-intersect st ro) ro)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290689,"user_id":53,"body":"#lang racket\n(provide contain-all-rots)\n\n(define (all? fn ls)\n  (= (length ls) (count fn ls)))\n\n(define (rot s) (string-append (substring s 1) (substring s 0 1)))\n\n(define (rot-all s) \n  (define (aux acc i)\n    (cond \n      [(<= i 1) acc]\n      [else (aux (cons (rot (first acc)) acc) (sub1 i))]))\n  (aux (list s) (string-length s)))\n\n(define (contain-all-rots s xs)\n  (let ([ys (rot-all s)])\n    (if (non-empty-string? s)\n        (all? (\u03bb (y) (member y xs)) ys)\n        #t)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290690,"user_id":null,"body":"#lang racket\n(provide contain-all-rots)\n\n(require srfi\/13) ;; xsubstring\n\n(define (list-contains value lst)\n  (if (member value lst) #t #f))\n\n(define (all-string-rotations str)\n  (sequence->list\n   (sequence-map (curry xsubstring str) (in-range 0 (string-length str)))))\n\n(define (contain-all-rots strng xs)\n  (andmap \n   (curryr list-contains xs) \n   (all-string-rotations strng)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290691,"user_id":null,"body":"#lang racket\n\n(provide contain-all-rots)\n\n;; String (Listof String) -> Boolean\n;; return #t if xs contains all rotations of str, #f otherwise\n(define (contain-all-rots str xs)\n\n  (define (rotate-left-once lst)\n    (if (null? lst)\n        '()\n        (append (rest lst) (cons (first lst) '()))))\n    \n  (define (rotations str res steps-left)\n    (if (zero? steps-left)\n        res\n        (let ([new-str (list->string (rotate-left-once (string->list str)))])\n          (rotations new-str (set-add res new-str) (sub1 steps-left)))))\n        \n  (subset? (rotations str (set) (string-length str)) (list->set xs)))\n\n;; Best conceivable runtime: Theta(len(str) + len(xs))\n;; Actual runtime:","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290692,"user_id":null,"body":"#lang racket\n(provide contain-all-rots)\n\n(define (get-all-rots strng)\n  (define rot-turns (string-length strng))\n  (define all-rots (cond [(zero? rot-turns) (list)]\n                         [else (list strng)]))\n  (for ([i (in-range 1 rot-turns)])\n    (define new-rot (string-append (substring strng i)\n                                   (substring strng 0 i)))\n    (set! all-rots (append all-rots (list new-rot))))\n  all-rots)\n\n(define (contain-all-rots strng xs)\n  (empty? (remove* xs (get-all-rots strng))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290693,"user_id":null,"body":"#lang racket\n(provide contain-all-rots)\n\n(define (all-rots str)\n  (for\/set ((i (in-range (string-length str))))\n    (string-append (substring str i)\n                   (substring str 0 i))))\n\n(define (contain-all-rots str lst)\n  (subset? (all-rots str) (list->set lst)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290694,"user_id":null,"body":"#lang racket\n(provide contain-all-rots)\n\n;; String (listOf String) -> Boolean\n(define (contain-all-rots s los)\n  (for\/and ([str (in-list (rotations s))])\n    (is-member? str los)))\n    \n;; String (listOf String) -> Boolean\n(define (is-member? s los) \n   (for\/or ([str (in-list los)])\n      (string=? s str)))\n\n;; String -> (listOf String)\n(define (rotations s)\n  ;; String -> (listOf (listOf Char))\n  (define (aux s)\n    (let ([s-lst (string->list s)])\n      (for\/list ([n (in-range (length s-lst))])\n        (rotate s-lst n))))\n  (map list->string (aux s)))\n\n;; (listOf X) Integer -> (listOf X)\n(define (rotate lox n)\n  (let ([n (modulo n (length lox))])\n    (append (drop lox n) (take lox n))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290695,"user_id":null,"body":"#lang racket\n(provide contain-all-rots)\n\n(define (rotations s)\n  (define len (string-length s))\n  (for\/list ((i (in-range len)))\n    (string-append (substring s i len)\n                   (substring s 0 i))))\n\n(define (contain-all-rots s xs)\n  (foldr (lambda (r acc) (and acc (list? (member r xs))))\n         #t\n         (rotations s)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57096af70dad013aa200007b":[{"id":290696,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (logical-calc lst op)\n  (case op \n    [(\"XOR\") (foldl xor #f lst)]\n    [(\"OR\") (ormap identity lst)]\n    [(\"AND\") (andmap identity lst)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290697,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (logical-calc lst op)\n  (cond\n   ((eq? op \"AND\")(doAnd lst))\n   ((eq? op \"OR\")(doOr lst))\n   ((eq? op \"XOR\")(doXor lst 0))\n   )\n  )\n(define (doAnd myList)\n  (if (null? myList)\n      #t\n      (if (eq? (car myList) #f)\n          #f\n          (doAnd (cdr myList))\n          )\n      )\n  )\n(define (doOr myList)\n  (if (null? myList)\n      #f\n      (if (eq? (car myList) #t)\n          #t\n          (doOr (cdr myList))\n          )\n      )\n  )\n  (define (doXor myList countT)\n  (if (null? myList)\n      (if (odd? countT)\n          #t\n          #f\n          )\n      (if (eq? (car myList) #t)\n          (doXor (cdr myList) (+ countT 1))\n          (doXor (cdr myList) countT)\n          )\n      )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290698,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (get-op name)\n  (case name\n    [(\"AND\") (lambda (x y) (if (and x y) #t #f))]\n    [(\"OR\") (lambda (x y) (if (or x y) #t #f))]\n    [(\"XOR\") xor]))\n\n(define (logical-calc lst op)\n  (foldl (get-op op) (car lst) (cdr lst)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290699,"user_id":373,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (fand a b) (and a b))\n(define (f_or a b) (or a b))\n\n(define (logical-calc lst op)\n  (cond [(equal? op \"AND\") (foldl fand #t lst)]\n        [(equal? op \"OR\") (foldl f_or #f lst)]\n        [(equal? op \"XOR\") (foldl xor #f lst)]\n        ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290700,"user_id":null,"body":"#lang racket\n(provide logical-calc)\n(define (logical-calc lst op)\n  (foldl\n   (case op\n    [(\"AND\") (lambda (a b) (and a b))]\n    [(\"OR\") (lambda (a b) (or a b))]\n    [(\"XOR\") xor])\n   (car lst)\n   (cdr lst)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290701,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (logical-calc lst op)\n  (cond [(equal? op \"OR\") (foldl (\u03bb (l r) (or l r)) (first lst) (rest lst))]\n        [(equal? op \"XOR\") (foldl (\u03bb (l r) (xor l r)) (first lst) (rest lst))]\n        [(equal? op \"AND\") (foldl (\u03bb (l r) (and l r)) (first lst) (rest lst))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290702,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (logical-calc lst op)\n  (cond [(string-ci=? op \"AND\") (andmap identity lst)]\n        [(string-ci=? op \"OR\") (ormap identity lst)]\n        [else (foldl xor (car lst) (cdr lst))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290703,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n( define (logical-calc lst op)\n  ( case op\n    [( \"AND\" ) ( andmap identity lst )]\n    [( \"OR\" ) ( ormap identity lst )]\n    [( \"XOR\" ) ( foldl xor #f lst )]) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290704,"user_id":null,"body":"#lang racket\n\n(provide logical-calc)\n\n(define and-l \n  (lambda (x)\n    (if (null? x)\n        #t\n        (and (car x) (and-l (cdr x))))))\n(define or-l\n  (lambda (x)\n    (if (null? x)\n        #f\n        (or (car x) (or-l (cdr x))))))\n(define xor-l\n  (lambda (x)\n    (if (null? x)\n        #f\n        (xor (car x) (xor-l (cdr x))))))\n(define (logical-calc lst op)\n  (cond [(equal? op \"AND\") (and-l lst)]\n        [(equal? op \"OR\") (or-l lst)]\n        [else (xor-l lst)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290705,"user_id":544,"body":"#lang racket\n\n(provide logical-calc)\n\n(define (xor-sequential lst)\n  (cond [(= (length lst) 1) (car lst)]\n        [(= (length lst) 2) (apply xor lst)]\n        [else               (xor-sequential\n                             (cons (xor (first lst) (second lst))\n                                   (drop lst 2)))]))\n\n(define (logical-calc lst op)\n  (case op\n    [(\"AND\") (andmap values lst)]\n    [(\"OR\")  (ormap values lst)]\n    [(\"XOR\") (xor-sequential lst)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5715eaedb436cf5606000381":[{"id":290706,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (apply + (filter positive? lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290707,"user_id":527,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (for\/sum ([x lst]) (max x 0)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290708,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define positive_sum\n  (compose (curry foldl + 0) (curry filter positive?)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290709,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive i)\n  (if (> i 0) i 0))\n\n(define (positive_sum lst)\n  (apply + (map positive lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290710,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (apply + (filter (lambda (n) (positive? n)) lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290711,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (apply + (filter (lambda (n) (>= n 0)) lst)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290712,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (foldl (lambda (x acc)\n           (if (> x 0)\n               (+ x acc)\n               acc))\n         0\n         lst))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290713,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n (foldl (lambda (x y) (or (and (positive? x) (+ x y)) y)) 0 lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290714,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (for\/fold ([sum 0])\n            ([val lst])\n    (+ sum (if (positive? val) val 0))\n  )\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290715,"user_id":null,"body":"#lang racket\n\n(provide positive_sum)\n\n(define (positive_sum lst)\n  (foldl (lambda (a sum)\n           (if (positive? a) (+ sum a) (+ sum 0)))\n         0\n         lst))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5726f813c8dcebf5ed000a6b":[{"id":290716,"user_id":53,"body":"#lang racket\n(provide count-kprimes puzzle)\n\n(define (count-factors k)\n  (define (aux i n acc)\n    (cond \n      [(> i (quotient n i)) (if (> n 1) (add1 acc) acc)]\n      [(zero? (modulo n i)) (aux i (quotient n i) (add1 acc))]\n      [else (aux (add1 i) n acc)]))\n  (aux 2 k 0))\n\n(define (count-kprimes k start nd)\n  (define (aux k n nd acc)\n    (cond \n      [(> n nd) (reverse acc)]\n      [(= k (count-factors n)) (aux k (add1 n) nd (cons n acc))]\n      [else (aux k (add1 n) nd acc)]))\n  (aux k start nd null))\n\n(define (puzzle s)\n  (define (matches a b k)\n    (let ([c (- k (+ a b))])\n      (and (> c 0) (= 1 (count-factors c)))))\n  (let* ([xs (count-kprimes 7 128 (- s 10))]\n         [ys (count-kprimes 3 8 (- s 130))]\n         [zs (cartesian-product xs ys)])\n    (count (\u03bb (p) (matches (first p) (second p) s)) zs)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290717,"user_id":168,"body":"#lang racket\n(provide count-kprimes puzzle)\n\n(define (factors n)\n  (let loop ([k 0] [d 2] [n n])\n    (cond\n     [(<= n 1) k]\n     [(> (* d d) n) (add1 k)]\n     [(zero? (remainder n d)) (loop (add1 k) d (\/ n d))]\n     [else (loop k (add1 d) n)])))\n\n(define (count-kprimes k start nd)\n  (filter (lambda (n) (= (factors n) k)) (range start (add1 nd)))\n)\n\n(define (puzzle s)\n  (define p7 (count-kprimes 7 128 (- s 10)))\n  (define p3 (count-kprimes 3 8 (- s 130)))\n  (for\/fold ([acc 0]) ([p p7])\n    (for\/fold ([acc acc])\n              ([q p3])\n              #:break (< (- s p q) 2)\n      (if (= (factors (- s p q)) 1) (add1 acc) acc)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290718,"user_id":null,"body":"#lang racket\n(provide count-kprimes puzzle)\n\n;; Prime factorize n\n(define (prime-factors n)\n  ;; Recursively loop to factorize\n  (let loop ([factors `(,n)])\n    (let ([factors*\n           (for\/fold ([factors* '()])\n                     ([m factors])\n             (let ([new-factors\n                    (for\/or ([i (range 2 (add1 (integer-sqrt m)))])\n                      (if (zero? (modulo m i))\n                          (list (quotient m i) i)\n                          #f))])\n               (if new-factors\n                   (append factors* new-factors)\n                   `(,@factors* ,m))))])\n      (if (equal? factors factors*)\n          factors\n          (loop factors*)))))\n\n;; Return #t if n is k-prime and #f if not.\n(define (kprime? k n)\n  (= k (length (prime-factors n))))\n\n;; Return list of k-primes between start (inclusive) and end (inclusive).\n(define (count-kprimes k start end)\n  (for\/list ([i (range start (add1 end))]\n             #:when (kprime? k i))\n    i))\n\n;; Find the total number of solutions to a + b + c = s, where a is 1-prime, b is\n;; 3-prime, and c is 7-prime.\n(define (puzzle s)\n  (for*\/sum ([c (count-kprimes 7 2 (- s 2))]\n             [b (count-kprimes 3 2 (- s c))]\n             #:when (and (> (- s c b) 1) (kprime? 1 (- s c b))))\n    1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290719,"user_id":null,"body":"#lang racket\n(provide count-kprimes puzzle)\n\n;; Prime factorize n\n(define (prime-factors n)\n  ;; Recursively loop to factorize\n  (let loop ([factors `(,n)])\n    (let ([factors*\n           (for\/fold ([factors* '()])\n                     ([m factors])\n             (let ([new-factors\n                    (for\/or ([i (range 2 (add1 (integer-sqrt m)))])\n                      (if (zero? (modulo m i))\n                          (list (quotient m i) i)\n                          #f))])\n               (if new-factors\n                   (append factors* new-factors)\n                   `(,@factors* ,m))))])\n      (if (equal? factors factors*)\n          factors\n          (loop factors*)))))\n\n;; Return #t if n is k-prime and #f if not.\n(define (kprime? k n)\n  (= k (length (prime-factors n))))\n\n;; Return list of k-primes between start (inclusive) and end (inclusive).\n(define (count-kprimes k start end)\n  (for\/list ([i (range start (add1 end))]\n             #:when (kprime? k i))\n    i))\n\n;; Find the total number of solutions to a + b + c = s, where a is 1-prime, b is\n;; 3-prime, and c is 7-prime.\n(define (puzzle s)\n  (for*\/sum ([c (count-kprimes 7 2 s)]\n             [b (count-kprimes 3 2 (- s c))]\n             #:when (and (> (- s c b) 1) (kprime? 1 (- s c b))))\n    1))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290720,"user_id":null,"body":"#lang racket\n(provide count-kprimes puzzle)\n\n;; Function returns a vector of smallest prime factors.\n(define (make-spf-sieve n)\n  ;; Create vector.\n  (define spf-sieve (make-vector (add1 n) 0))\n  ;; Function to mark smallest prime factor (k) for multiples of k.\n  (define (mark-spf-sieve m spf-sieve k n)\n    (when (<= m n)\n      (when (= (vector-ref spf-sieve m) m)\n        (vector-set! spf-sieve m k))\n      (mark-spf-sieve (+ m k) spf-sieve k n)))\n  ;; Function to init sieve so that the smallest possible factor\n  ;; for each integer k is k.\n  (define (init-spf-sieve i spf-sieve n)\n    (when (<= i n)\n      (vector-set! spf-sieve i i)\n      (init-spf-sieve (add1 i) spf-sieve n)))\n  ;; Recursive function to sieve the smallest prime factors for\n  ;; all odd integers up to n.\n  (define (mark-spf-sieve-loop k spf-sieve n)\n    (when (<= k n)\n      (when (= k (vector-ref spf-sieve k))\n        (mark-spf-sieve (* k k) spf-sieve k n))\n      (mark-spf-sieve-loop (+ 2 k) spf-sieve n)))\n\n  ;; Init the sieve.\n  (init-spf-sieve 1 spf-sieve n)\n  ;; Mark even numbers.\n  (mark-spf-sieve 4 spf-sieve 2 n)\n  ;; Mark the odd numbers.\n  (mark-spf-sieve-loop 3 spf-sieve n)\n  ;; Return the sieve.\n  spf-sieve)\n\n;; Function that takes an integer, n, and the smallest prime factor sieve\n;; and returns the number of prime factors for n.\n;; For example, (count-prime-factors 2 spf-sieve) returns 2 (2, 2)\n;;              (count-prime-factors 12 spf-sieve) returns 3 (2, 2, 3)\n(define (count-prime-factors n spf-sieve)\n  (define (count-prime-factors-loop m acc spf-sieve)\n    (if (= m 1)\n        acc\n        (count-prime-factors-loop (\/ m (vector-ref spf-sieve m)) (add1 acc) spf-sieve)))\n  (count-prime-factors-loop n 0 spf-sieve)) \n\n;; Function that returns list of number between start and end that\n;; have k prime factors.  This function makes a spf-sieve.\n(define (count-kprimes k start end)\n  (define spf-sieve (make-spf-sieve (add1 end)))\n  (count-kprimes0 k start end spf-sieve))\n\n;; Function that returns list of numbers between start and end that\n;; have k prime factors.  This function requires the spf-sieve to\n;; be passed in as a parameter.\n(define (count-kprimes0 k start end spf-sieve)\n  (define (count-kprimes-loop i k end)\n    (cond [(> i end) '()]\n          [(= k (count-prime-factors i spf-sieve)) (cons i (count-kprimes-loop (add1 i) k end))]\n          [else (count-kprimes-loop (add1 i) k end)]))\n  (count-kprimes-loop start k end))\n\n;; Returns the total number of solutions of the equation a + b + c = s,\n;; where a is 1-prime, b is 3-prime, and c is 7-prime.\n(define (puzzle s)\n  (define spf-sieve (make-spf-sieve (add1 s)))\n  (define primes-1 (count-kprimes0 1 2 s spf-sieve))\n  (define primes-3 (count-kprimes0 3 2 s spf-sieve))\n  (define primes-7 (count-kprimes0 7 2 s spf-sieve))\n  (define (count-solutions ps acc s)\n    (cond [(empty? ps) acc]\n      [(= s (apply + (first ps))) (count-solutions (rest ps) (add1 acc) s)]\n      [else (count-solutions (rest ps) acc s)]))\n  (count-solutions (cartesian-product primes-1 primes-3 primes-7) 0 s))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290721,"user_id":492,"body":"#lang racket\n(provide count-kprimes puzzle)\n\n(define (count-kprimes k start nd)\n  (define (nb-factors nb k)  \n    (define (loop n i cnt)\n      (if (= n 1)\n          (= k cnt)\n          (if (= 0 (remainder n i))\n              (loop (quotient n i) i (add1 cnt))\n              (loop n (add1 i) cnt))))\n    (loop nb 2 0))\n  \n  (define (loop i k-primes)\n    (if (> i nd)\n        k-primes\n        (if (nb-factors i k)\n            (loop (add1 i) (cons i k-primes)) \n            (loop (add1 i) k-primes))))\n  (reverse (loop start '())))\n\n(define (puzzle s)\n  (define (prime? n)\n    (cond ( (< n 2) #f)\n          ( (= n 2) #t)\n          ( (even? n) #f)\n          (else\n           (let prime-test ( (d 3) )\n             (cond ( (> (sqr d) n) #t)\n                   ( (= 0 (remainder n d)) #f)\n                   (else (prime-test (+ d 2))))))))\n  (length\n   (for*\/list (\n               [a (count-kprimes 7 2 s)]\n               [b (count-kprimes 3 2 s)]\n               #:when ((lambda (x) (and (> x 0) (prime? x))) (- s a b)))\n     1)\n   )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"573182c405d14db0da00064e":[{"id":290722,"user_id":168,"body":"#lang racket\n(provide consec-kprimes)\n\n(define (factors n)\n  (let loop ([k 0] [d 2] [n n])\n    (cond\n     [(<= n 1) k]\n     [(> (* d d) n) (add1 k)]\n     [(zero? (remainder n d)) (loop (add1 k) d (\/ n d))]\n     [else (loop k (add1 d) n)])))\n          \n(define (consec-kprimes k ls)\n  (for\/sum ([x ls] [y (cdr ls)] \n            #:when (= (factors x) (factors y) k))\n           1)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290723,"user_id":53,"body":"#lang racket\n(provide consec-kprimes)\n\n(define (count-factors k)\n  (define (aux i n acc)\n    (cond \n      [(> i (quotient n i)) (if (> n 1) (add1 acc) acc)]\n      [(zero? (modulo n i)) (aux i (quotient n i) (add1 acc))]\n      [else (aux (add1 i) n acc)]))\n  (aux 2 k 0))\n\n(define (consec-kprimes k ls)\n  (define (aux m p xs)\n    (let ([q (if (empty? xs) 0 (count-factors (first xs)))])\n      (cond \n        [(zero? (length xs)) m]\n        [(and (= k q) (= k p)) (aux (add1 m) q (rest xs))]\n        [else (aux m q (rest xs))])))\n  (aux 0 0 ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290724,"user_id":492,"body":"#lang racket\n(provide consec-kprimes)\n\n(define (consec-kprimes k ls)\n  (define (nb-factors nb k)  \n    (define (loop n i cnt)\n      (if (= n 1)\n          (= k cnt)\n          (if (= 0 (remainder n i))\n              (loop (quotient n i) i (add1 cnt))\n              (loop n (add1 i) cnt))))\n    (loop nb 2 0))\n  \n  (for\/fold ([sm 0])\n            ([i (range 0 (sub1 (length ls)))])\n    (if (and (nb-factors (list-ref ls i) k) (nb-factors (list-ref ls (add1 i)) k))\n        (add1 sm)\n        sm)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290725,"user_id":null,"body":"#lang racket\n\n(provide consec-kprimes)\n\n(define (consec-kprimes k ls)\n  (cond\n    [(< (length ls) 2) 0]\n    [(+ (* (k-prime? k (car ls)) (k-prime? k (car (cdr ls))))\n        (consec-kprimes k (cdr ls)))]))\n\n(define (k-prime? k n)\n  (if (= k (length (factors n))) 1 0))\n\n(define (factors n [f 2])\n  (cond\n    [(< n (* f f)) (list n)]\n    [(= 0 (remainder n f)) (cons f (factors (quotient n f) f))]\n    [(factors n (add1 f))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290726,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide consec-kprimes)\n\n;; Integer (Listof Integer>0) -> Integer>=0\n;; count how many times in `ls` numbers come up twice in a row with exactly `k`\n;; prime factors\n(define (consec-kprimes k ls)\n\n  ;; courtesy of: https:\/\/rosettacode.org\/wiki\/Prime_decomposition#Racket\n  (define (prime-factors number)\n    (let loop ([n number] [i 2])\n      (if (= n 1)\n          '()\n          (let-values ([(q r) (quotient\/remainder n i)])\n            (if (zero? r) (cons i (loop q i)) (loop n (add1 i)))))))\n\n  (count-consec-duplicates k (map (\u03bb (n) (length (prime-factors n))) ls)))\n\n;; Any (Listof Any) -> Integer>=0\n;; count times `val` appears twice in a row in `ls`\n(define (count-consec-duplicates val ls)\n  (let loop ([count 0] [todo ls])\n    (cond\n      [(< (length todo) 2) count]\n      [(and (equal? (first todo) val) (equal? (second todo) val))\n       (loop (add1 count) (rest todo))]\n      [else (loop count (rest todo))])))\n\n(module+ test\n  (check-equal? (count-consec-duplicates 1 '()) 0)\n  (check-equal? (count-consec-duplicates 1 '(1 1 2 3 1 1 1 3 1 1)) 4))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"573992c724fc289553000e95":[{"id":290727,"user_id":492,"body":"#lang racket\n(provide smallest)\n\n(define (smallest n)\n  (let* ([s (number->string n)]\n         [ls (for*\/list ([i (range 0 (string-length s))]\n                         [j (range 0 (string-length s))]\n                         #:when (not (= i j))\n                         )\n               (let* ([c (string (string-ref s i))]\n                      [s (string-append (substring s 0 i) (substring s (add1 i)))]\n                      [s (string-append (substring s 0 j) c (substring s j))])\n                 (list (string->number s) i j)))])\n    (first (sort (append (list `(,n 0 0)) ls) <  #:key car))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290728,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide smallest)\n\n\n;; PositiveInteger -> (List Integer Integer Integer)\n;; find the smallest integer `m` you can get by moving exactly one digit of `n`\n;; from index i to index j, and return '(m i j).\n;; Note that i can be equal to j, which means returning the given number as is.\n(define (smallest n)\n\n  (define (integer->list n)\n    (if (< n 10)\n        `(,n)\n        (append (integer->list (quotient n 10)) (list (remainder n 10)))))\n\n  (define (list->integer l)\n    (string->number (string-join (map number->string l) \"\")))\n  \n  (define dd (integer->list n))\n  (define c (length dd))\n\n  (argmin\n   (\u03bb (x) (+ (* c (first x)) (second x)))\n   (for*\/list ([i (in-range c)]\n               [j (in-range c)])\n     (list (list->integer (move dd i j)) i j))))\n\n(module+ test\n  (check-equal? (smallest 261235) '(126235 2 0))\n  (check-equal? (smallest 209917) '(29917 0 1))\n  (check-equal? (smallest 1000000) '(1 0 6)))\n\n\n;; (Listof Any) Integer Integer -> (Listof Any)\n;; remove an item at index `from` and insert it back at index `to`\n;; ASSUME: `from` and `to` are in bounds.\n(define (move lst from to)\n\n  (define (insert-at lst pos x)\n    (define-values (before after) (split-at lst pos))\n    (append before (cons x after)))\n\n  (define (remove-at lst pos)\n    (define-values (before after) (split-at lst pos))\n    (append before (rest after)))\n\n  (if (= from to)\n      lst\n      (insert-at (remove-at lst from) to (list-ref lst from))))\n    \n(module+ test\n  (check-equal? (move '(2 6 1 2 3 5) 2 2) '(2 6 1 2 3 5))\n  (check-equal? (move '(2 6 1 2 3 5) 2 0) '(1 2 6 2 3 5))\n  (check-equal? (move '(2 0 9 9 1 7) 0 1) '(0 2 9 9 1 7)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290729,"user_id":null,"body":"#lang racket\n(provide smallest)\n\n#|\n(define (insert item str)\n  (cond ((null? lst) (list (list 0 (cons item lst))))\n        (else (cons (list 0 (cons item lst))\n                    (map (lambda (items) (list (add1 (car items)) (cons (car lst) (cadr items))))\n                         (insert item (cdr lst)))))))\n\n(define (split lst)\n  (cond ((null? lst) '())\n        (else (cons (list 0 (car lst) (cdr lst))\n                    (map (lambda (items)\n                           (list (add1 (car items))\n                                 (cadr items)\n                                 (cons (car lst) (caddr items)))) (split (cdr lst)))))))\n\n(define (smallest n)\n  (car (sort (map (lambda (items)\n                    (list (string->number (caddr items))\n                          (car items)\n                          (cadr items)))\n                  (foldl append '() (map (lambda (items)\n                                           (map (lambda (lst)\n                                                  (cons (car items) lst))\n                                                (insert (cadr items)\n                                                        (caddr items))))\n                                         (split (number->string n)))))\n             #:key car\n             <)))\n|#\n; number->list : Integer -> [Digit]\n(define (number->list n)\n  (define (iter n lst)\n    (cond ((zero? n) lst)\n          (else (iter (quotient n 10)\n                      (cons (remainder n 10)\n                            lst)))))\n  (if (zero? n)\n      '(0)\n      (iter n '())))\n\n; list->number : [Digit] -> Integer\n(define (list->number lst)\n  (define (iter lst n)\n    (cond ((null? lst) n)\n          (else (iter (cdr lst)\n                      (+ (* 10 n) (car lst))))))\n  (iter lst 0))\n\n; list-of-number<? : [Integer] -> [Integer] -> Boolean\n(define (list-of-number<? lst1 lst2)\n  (cond ((null? lst1) #t)\n        ((null? lst2) #f)\n        ((not (= (car lst1) (car lst2)))\n         (< (car lst1) (car lst2)))\n        (else (list-of-number<? (cdr lst1) (cdr lst2)))))\n\n; insert : Digit -> [Digit] -> [(Position, [Digit])]\n(define (insert item lst)\n  (cond ((null? lst) (list `(0 ,(cons item lst))))\n        (else (cons `(0 ,(cons item lst))\n                    (map (lambda (items) `(,(add1 (car items))\n                                           ,(cons (car lst) (cadr items))))\n                         (insert item (cdr lst)))))))\n\n; split : [Digit] -> [(Position, Digit, [Digit])]\n(define (split lst)\n  (cond ((null? lst) '())\n        (else (cons `(0 ,(car lst) ,(cdr lst))\n                    (map (lambda (items)\n                           `(,(add1 (car items))\n                             ,(cadr items)\n                             ,(cons (car lst) (caddr items))))\n                         (split (cdr lst)))))))\n\n(define (smallest n)\n  (car (sort (map (lambda (items)\n                    `(,(list->number (caddr items))\n                      ,(car items)\n                      ,(cadr items)))\n                  (foldl append\n                         '()\n                         (map (lambda (items)\n                                (map (lambda (lst)\n                                       (cons (car items) lst))\n                                     (insert (cadr items)\n                                             (caddr items))))\n                              (split (number->list n)))))\n             list-of-number<?)))\n\n#|\n(define (interval low high)\n  (cond ((= low high) '())\n        (else (cons low (interval (add1 low)\n                                  high)))))\n\n(define (triple-sort triple-list)\n  (sort triple-list\n        (lambda (x y)\n          (cond ((not (= (car x) (car y)))\n                 (< (car x) (car y)))\n                ((not (= (cadr x) (cadr y)))\n                 (< (cadr x) (cadr y)))\n                (else (< (caddr x) (caddr y)))))))\n\n(define identity\n  (compose list->number number->list))\n|#","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290730,"user_id":492,"body":"#lang racket\n(provide smallest)\n\n(define (smallest n)\n  (let* ([s (number->string n)]\n         [ls (for*\/list ([i (range 0 (string-length s))]\n                         [j (range 0 (string-length s))]\n                         #:when (not (= i j))\n                         )\n               (let* ([c (string (string-ref s i))]\n                      [s (string-append (substring s 0 i) (substring s (add1 i)))]\n                      [s (string-append (substring s 0 j) c (substring s j))])\n                 (list (string->number s) i j)))])\n    (first (sort (append (list `(,n 0 0)) ls) <  #:key car))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57591ef494aba64d14000526":[{"id":290731,"user_id":492,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n(define (john-ann n)\n  (define (loop i jlist alist)\n    (if (>= i n)\n        (cons alist jlist)\n        (let* ([j (vector-ref jlist (sub1 i))]\n               [a1 (vector-ref alist j)]\n               [t (vector-set! jlist i (- i a1))]\n               [a (vector-ref alist (sub1 i))]\n               [j1 (vector-ref jlist a)]\n               [t (vector-set! alist i (- i j1))])\n          (loop (add1 i) jlist alist))))  \n  (if (= n 0)\n      (cons #(1) #(0))\n      (let ([john-list (make-vector n 0)]\n            [ann-list (make-vector n 1)])\n        (loop 1 john-list ann-list))))\n\n(define (john n)\n  (cdr (john-ann n)))\n\n(define (ann n)\n  (car (john-ann n)))\n\n(define (sum-john n)\n  (for\/sum ([x (cdr (john-ann n))]) x))\n\n(define (sum-ann n)\n  (for\/sum ([x (car (john-ann n))]) x))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290732,"user_id":53,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n(define (walk n)\n  (let loop ([i 1] [xs (hash 0 0)] [ys (hash 0 1)])\n    (cond \n      [(>= i n) (cons (hash-values xs) (hash-values ys))]\n      [else (let ([xsn (hash-set xs i (- i (hash-ref ys (hash-ref xs (sub1 i)))))])\n              (loop \n                 (add1 i) \n                 xsn\n                 (hash-set ys i (- i (hash-ref xsn (hash-ref ys (sub1 i)))))\n             ))])))\n\n(define (john n)\n  (vector-sort (list->vector (car (walk n))) <))\n\n(define (ann n)\n  (vector-sort (list->vector (cdr (walk n))) <))\n  \n(define (sum-john n)\n  (foldr + 0 (car (walk n))))\n\n(define (sum-ann n)\n  (foldr + 0 (cdr (walk n))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290733,"user_id":null,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n(define-syntax (define\/memo stx)\n  (syntax-case stx ()\n    [(_ (id arg) body ...)\n     #'(define id\n         (let ([memo (make-hash)])\n           (lambda (arg)\n             (hash-ref memo arg\n                       (lambda ()\n                         (let ([res (begin body ...)])\n                           (hash-set! memo arg res)\n                           res))))))]))\n\n(define\/memo (a n)\n  (case n\n    [(0) 1]\n    [else (- n (j (a (sub1 n))))]))\n\n(define\/memo (j n)\n  (case n\n    [(0) 0]\n    [else (- n (a (j (sub1 n))))]))\n\n(define (ann n)\n  (for\/vector #:length n\n              ([i (in-range n)])\n    (a i)))\n\n(define (john n)\n  (for\/vector #:length n\n              ([i (in-range n)])\n    (j i)))\n\n(define (sum-ann n)\n  (for\/sum ([i (in-range n)])\n    (a i)))\n  \n(define (sum-john n)\n  (for\/sum ([i (in-range n)])\n    (j i)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290734,"user_id":null,"body":"#lang racket\n\n(provide john ann sum-john sum-ann)\n\n(define j\n  (let ([memo (make-hash '((0 . 0)))])\n    (\u03bb (n)\n      (unless (hash-has-key? memo n)\n        (hash-set! memo n (- n (a (j (sub1 n))))))\n      (hash-ref memo n))))\n\n(define a\n  (let ([memo (make-hash '((0 . 1)))])\n    (\u03bb (n)\n      (unless (hash-has-key? memo n)\n        (hash-set! memo n (- n (j (a (sub1 n))))))\n      (hash-ref memo n))))\n\n(define (john n)\n  (for\/vector ([i (in-range n)]) (j i)))\n\n(define (ann n)\n  (for\/vector ([i (in-range n)]) (a i)))\n\n(define (sum-john n)\n  (for\/sum ([i (john n)]) i))\n\n(define (sum-ann n)\n  (for\/sum ([i (ann n)]) i))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290735,"user_id":null,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n(define *table* (make-hash))\n\n(define (john-iter n)\n  (cond ((zero? n) 0)\n        ((hash-ref *table* `(john ,n) #f))\n        ((- n (ann-iter (john-iter (sub1 n))))\n         =>\n         (\u03bb (num)\n           (hash-set! *table* `(john ,n) num)\n           num))))\n\n(define (ann-iter n)\n  (cond ((zero? n) 1)\n        ((hash-ref *table* `(ann ,n) #f))\n        ((- n (john-iter (ann-iter (sub1 n))))\n         =>\n         (\u03bb (num)\n           (hash-set! *table* `(ann ,n) num)\n           num))))\n\n(define (john n)\n  ; your code\n  (list->vector\n   (map john-iter\n        (build-list n values))))\n\n(define (ann n)\n  ; your code\n  (list->vector\n   (map ann-iter\n        (build-list n values))))\n  \n(define (sum-john n)\n  ; your code\n  (apply + (vector->list (john n))))\n\n(define (sum-ann n)\n  ; your code\n  (apply + (vector->list (ann n))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290736,"user_id":null,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n(define (loop n index vector-a vector-j)\n    (if (= n index)\n        (list vector-a vector-j)\n        (begin\n            (let* ([index-1 (- index 1)]\n                   [an-1    (vector-ref vector-a index-1)]\n                   [jn-1    (vector-ref vector-j index-1)]\n                   [jan-1   (vector-ref vector-j an-1)]\n                   [ajn-1   (vector-ref vector-a jn-1)]\n                   [an      (- index jan-1)]\n                   [jn      (- index ajn-1)])\n                (vector-set! vector-a index an)\n                (vector-set! vector-j index jn)\n                (loop n (+ index 1) vector-a vector-j)))))\n\n(define (data func n)\n     (let* ([vector-a    (make-vector n 1)]\n           [vector-j    (make-vector n 0)]\n           [result      (loop n 1 vector-a vector-j)])\n        (func result)))\n\n(define (sum func n)\n    (let* ([vect    (func n)]\n           [lst     (vector->list vect)]\n           [result  (foldr + 0 lst)])\n        result))\n\n(define (ann n)\n   (data car n))\n\n(define (john n)\n    (data cadr n))\n\n(define (sum-ann n)\n    (sum ann n))\n\n(define (sum-john n)\n    (sum john n))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290737,"user_id":null,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n\n(define fibonacci\n  (\u03bb (n)\n    (define result (make-vector n 0))\n\n\n    (let loop ((f1 1) (f2 2))\n      (when (<= f1 n)\n        (vector-set! result (sub1 f1) 1)\n        (loop f2 (+ f1 f2))))\n\n    result))\n\n(define get-katas\n  (\u03bb (name)\n    (\u03bb (n)\n      (define katas (make-vector n 0))\n      (define fib-v (fibonacci n))\n\n\n      (for ((i (in-range 2 n)))\n        (vector-set!\n         katas\n         i\n         (- i\n            (vector-ref katas\n                        (vector-ref katas (sub1 i)))\n            (vector-ref fib-v\n                        (vector-ref katas (sub1 i))))))\n\n      (cond ((eqv? name 'john) katas)\n            ((eqv? name 'ann) (vector-map + katas fib-v))))))\n\n\n\n(define sum-vector\n  (\u03bb (v n)\n    (let loop ((ans 0) (i 0))\n      (cond ((= i n) ans)\n            (else (loop (+ ans (vector-ref v i))\n                        (add1 i)))))))\n\n\n(define (john n) ((get-katas 'john) n))\n(define (ann  n) ((get-katas 'ann) n))\n(define (sum-john n) (sum-vector (john n) n))\n(define (sum-ann  n) (sum-vector (ann n) n))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290738,"user_id":null,"body":"#lang racket\n(provide john ann sum-john sum-ann)\n\n(define john-hash (make-hash))\n(define ann-hash (make-hash))\n\n\n\n(define (john-on-day n)\n  (cond\n    [(equal? n 0) 0]\n    [(hash-has-key? john-hash n) (hash-ref john-hash n)]\n    [else (let ([katas (- n (ann-on-day (john-on-day (sub1 n))))])\n              (hash-set! john-hash n katas)\n              katas)]))\n\n\n(define (ann-on-day n)\n  (cond\n    [(equal? n 0) 1]\n    [(hash-has-key? ann-hash n) (hash-ref ann-hash n)]\n    [else (let ([katas (- n (john-on-day (ann-on-day (sub1 n))))])\n              (hash-set! ann-hash n katas)\n              katas)]))\n\n\n(define (ann n)\n  (for\/vector ([i (range n)]) (ann-on-day i)))\n\n  \n(define (john n)\n  (for\/vector ([i (range n)]) (john-on-day i)))\n\n\n(define (sum-john n)\n  (for\/sum ([i (range n)]) (john-on-day i)))\n\n(define (sum-ann n)\n  (for\/sum ([i (range n)]) (ann-on-day i)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"576bb71bbbcf0951d5000044":[{"id":290739,"user_id":527,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (for\/fold ([n-pos 0] [sum-neg 0] #:result (list n-pos sum-neg))\n            ([x lst])\n    (if (positive? x) (values (add1 n-pos) sum-neg) (values n-pos (+ sum-neg x)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290740,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (list (length (filter positive? lst)) (foldr + 0 (filter negative? lst))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290741,"user_id":168,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (list (count positive? lst) (apply + (filter negative? lst))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290742,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (define-values (positives negatives) (partition positive? lst))\n  (list (length positives) (apply + negatives)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290743,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (for\/fold ([p 0] [n 0]\n             #:result (list p n))\n            ([i (in-list lst)])\n    (if (positive? i)\n        (values (+ p 1) n)\n        (values p (+ n i)))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290744,"user_id":53,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives xs)\n  (if (empty? xs)\n      (list 0 0)\n      (let ([a (length (filter (lambda (n) (> n 0)) xs))]\n            [b (foldl (lambda (n acc) (+ n acc)) 0 (filter (lambda (n) (< n 0)) xs))])\n        (list a b))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290745,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n;; (Listof Integer) -> (List Integer Integer)\n;; count positives, sum negatives. 0 is neither pos nor neg\n(define (count_positives_sum_negatives lst)\n  (define (f l c s)\n    (cond\n      [(empty? l) `(,c ,s)]\n      [(positive? (car l)) (f (cdr l) (add1 c) s)]\n      [(negative? (car l)) (f (rest l) c (+ s (car l)))]\n      [else (f (cdr l) c s)]))\n  (f lst 0 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290746,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (let loop ((cp 0)\n             (sn 0)\n             (lst lst))\n    (if (null? lst)\n        (list cp sn)\n        (let ((head (car lst))\n              (tail (cdr lst)))\n          (if (positive? head)\n              (loop (+ cp 1) sn tail)\n              (loop cp (+ sn head) tail))))))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290747,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives ls)\n  (foldl ( \u03bb (x z) ( if (> x 0) (cons (+ (car z) 1) (cdr z)) (list (car z) (+ (cadr z) x)) ) ) '(0 0) ls)\n)","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290748,"user_id":null,"body":"#lang racket\n\n(provide count_positives_sum_negatives)\n\n(define (count_positives_sum_negatives lst)\n  (list (length (filter positive? lst))\n    (apply + (filter negative? lst))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5772da22b89313a4d50012f7":[{"id":290749,"user_id":null,"body":"#lang racket\n(provide greet)\n(define (greet name owner)\n  (string-append \"Hello \" (if [string=? name owner] \"boss\" \"guest\"))\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290750,"user_id":544,"body":"#lang racket\n\n(provide greet)\n\n(define\/match (greet name owner)\n  [(x x) \"Hello boss\"]\n  [(_ _) \"Hello guest\"])\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290751,"user_id":544,"body":"#lang racket\n\n(provide greet)\n\n(define\/match (greet name owner)\n  [(owner owner) \"Hello boss\"]\n  [(_ _) \"Hello guest\"])\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290752,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet name owner)\n  (cond\n   {(string=? name owner) \"Hello boss\"}\n   {else \"Hello guest\"}\n   ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290753,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet name owner)\n  (cond\n   [(string=? name owner) \"Hello boss\"]\n   [else                  \"Hello guest\"]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290754,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet name owner)\n  (format \"Hello ~a\" (cond [(equal? name owner) \"boss\"] [else \"guest\"])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290755,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet name owner)\n  (~a \"Hello \" (if (equal? name owner) \"boss\" \"guest\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290756,"user_id":373,"body":"#lang racket\n\n(provide greet)\n\n(define (greet name owner)\n  (string-join (list \"Hello\" (if (equal? name owner) \"boss\" \"guest\"))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290757,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n(define (greet name owner)\n  (let ((greeted (if (string-ci=? name owner) \"boss\" \"guest\")))\n    \n    (format \"Hello ~a\" greeted)))\n  \n  \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290758,"user_id":null,"body":"#lang racket\n\n(provide greet)\n\n( define (greet name owner)\n  ( format \"Hello ~a\" ( if (eq? name owner) \"boss\" \"guest\" ) ) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"577bd026df78c19bca0002c0":[{"id":290759,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n  (string-join\n   (map\n     (lambda (s) (cond\n                  [(string=? s \"5\") \"S\"]\n                  [(string=? s \"0\") \"O\"]\n                  [(string=? s \"1\") \"I\"]\n                  [else s]))\n     (string-split str \"\"))\n   \"\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290760,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n  (define s1 (string-replace str \"5\" \"S\"))\n  (define s2 (string-replace s1 \"0\" \"O\"))\n  (string-replace s2 \"1\" \"I\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290761,"user_id":53,"body":"#lang racket\n\n(provide correct)\n\n(define (correct s)\n  (string-replace (string-replace (string-replace s \"1\" \"I\") \"0\" \"O\") \"5\" \"S\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290762,"user_id":544,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n  (list->string (map (\u03bb (c)\n                       (case c\n                         [(#\\5) #\\S]\n                         [(#\\0) #\\O]\n                         [(#\\1) #\\I]\n                         [else c]))\n                     (string->list str))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290763,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n;; String -> String\n;; correct output of OCR system\n(define (correct str)\n  (define table (hash #\\5 #\\S #\\0 #\\O #\\1 #\\I))\n  (list->string (for\/list ([c str]) (hash-ref table c c))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290764,"user_id":168,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n  (string-replace\n     (string-replace \n        (string-replace str \"5\" \"S\") \n        \"0\" \"O\")\n     \"1\" \"I\" ))\n      \n          \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290765,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n(define (correct s)\n  (string-replace\n    (string-replace\n      (string-replace s \"5\" \"S\")\n      \"0\" \"O\")\n    \"1\" \"I\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290766,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n\n    (define l \n      (string->list str))\n    (define (s x)\n      (list->string x))\n    \n    (define letter\n      (if (empty? l) '() (car l)))\n    \n    (cond\n      [(empty? letter) \"\"]\n      [else (string-append \n        (string-replace (string-replace (string-replace (string letter) \"0\" \"O\") \"5\" \"S\") \"1\" \"I\")\n        (correct (s (cdr l))))]\n    )\n     \n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290767,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n  (string-replace (string-replace (string-replace str \"1\" \"I\")  \"0\" \"O\") \"5\" \"S\"  ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290768,"user_id":null,"body":"#lang racket\n\n(provide correct)\n\n(define (correct str)\n  (let ([fix (\u03bb (str bad good) (regexp-replace* bad str good))])\n    (fix (fix (fix str \"5\" \"S\") \"0\" \"O\") \"1\" \"I\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57a0556c7cb1f31ab3000ad7":[{"id":290769,"user_id":645,"body":"#lang racket\n\n(provide make_upper_case)\n\n(define make_upper_case string-upcase)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290770,"user_id":null,"body":"#lang racket\n\n(provide make_upper_case)\n\n(define (make_upper_case str)\n  (list->string (map (lambda (ch) (if (char-lower-case? ch) (char-upcase ch) ch)) (string->list str))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290771,"user_id":null,"body":"#lang racket\n\n(provide make_upper_case)\n\n;; (define (make_upper_case str)\n;;   \"\")\n\n(define make_upper_case string-upcase)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290772,"user_id":null,"body":"#lang racket\n\n(provide make_upper_case)\n\n(define (make_upper_case str)\n  (list->string \n     (map to-upper-char \n          (string->list str))))\n\n(define (to-upper-char c)\n  (let ([code (char->integer c)])\n       (cond [(> code 122) c]\n             [(< code 97) c]\n             [else (code->upper-char code)])))\n\n(define (code->upper-char code)\n  (integer->char (+ (- code 97) 65)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290773,"user_id":null,"body":"#lang racket\n\n(provide make_upper_case)\n\n;; String -> String\n;; convert the string to upper-case\n(define (make_upper_case str)\n  (string-upcase str))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290774,"user_id":null,"body":"#lang racket\n\n(provide make_upper_case)\n\n(define (make_upper_case str)\n  (string-upcase str))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57a0e5c372292dd76d000d7e":[{"id":290775,"user_id":209,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (string-append* \"\" (make-list count str)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290776,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (apply string-append\n         (for\/list ([i count]) str)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290777,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (string-join (build-list count (\u03bb (_) str)) \"\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290778,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (cond\n   ((= count 0) \"\")\n   ((= count 1) str)\n   ((> count 1) \n    (string-append(repeat_str (- count 1) str) str))\n  ))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290779,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str n str)\n  (if (= 0 n)\n       \"\"\n      (string-append str (repeat_str (- n 1) str))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290780,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (apply string-append (map (lambda (x) str) (range count))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290781,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define\/match (repeat_str n str)\n  [(0 str) \"\"]\n  [(n str) (string-append str (repeat_str (sub1 n) str))])\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290782,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (cond\n    [(equal? 0 count) \"\"]\n    [else (string-append str (repeat_str (sub1 count) str))]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290783,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (repeat_str count str)\n  (string-join (build-list count (const str)) \"\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290784,"user_id":null,"body":"#lang racket\n\n(provide repeat_str)\n\n(define (iter str symb count acc)\n  (if (= count acc) str (iter (string-append str symb) symb count (add1 acc))))\n\n(define (repeat_str count str)\n  (iter \"\" str count 0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57a1fd2ce298a731b20006a4":[{"id":290785,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (define l (string->list (string-downcase word)))\n  (equal? l (reverse l)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290786,"user_id":53,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (let ([a (string->list (string-downcase word))])\n    (string=? (list->string (reverse a)) (list->string a))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290787,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (equal? (string->list (string-downcase word)) (reverse (string->list (string-downcase word))))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290788,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (define char-list (string->list (string-downcase word)))\n  (equal? char-list (reverse char-list)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290789,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (list-is-palindrome xs)\n  (cond\n    [(< (length xs) 2) #t]\n    [(not (equal? (car xs) (last xs))) #f]\n    [else (list-is-palindrome (drop-right (cdr xs) 1))]))\n\n(define (is_palindrome word) (list-is-palindrome (map char-upcase (string->list word))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290790,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (help char-list)\n  (cond\n    [(> 2 (length char-list)) #t]\n    [(not (equal? (car char-list) (last char-list))) #f]\n    [else (help (cdr (drop-right char-list 1)))]))\n\n(define (is_palindrome word) (help (map char-upcase (string->list word))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290791,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (let ([lc (string-downcase word)])\n    (string=? lc (list->string (reverse (string->list lc))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290792,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (if (or (= (string-length word)1) (= (string-length word)0))\n      #t\n      (if (char-ci=? (string-ref word 0) (string-ref word (- (string-length word)1)))\n          (is_palindrome (substring word 1 (- (string-length word)1)))\n          #f)))\n      ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290793,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (string=? (string-downcase word) \n            (string-downcase (list->string (reverse (string->list word))))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290794,"user_id":null,"body":"#lang racket\n\n(provide is_palindrome)\n\n(define (is_palindrome word)\n  (define char-list (string->list (string-upcase word)))\n  (equal? char-list (reverse char-list)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57a5015d72292ddeb8000b31":[{"id":290795,"user_id":527,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (palindrome? x)\n  (define cs (string->list (~a x)))\n  (equal? cs (reverse cs)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290796,"user_id":53,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (stringify obj) obj (~v obj))\n(define (palindrome? line)\n  (let ([a (string->list (stringify line))])\n    (string=? (list->string (reverse a)) (list->string a))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290797,"user_id":null,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (palindrome? line)\n  (let ([l (string->list (if (number? line)\n                             (number->string line)\n                             line))])\n    (equal? l (reverse l))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290798,"user_id":null,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (palindrome? line)\n  (if (string? line)\n    (string=? line (list->string (reverse (string->list line))))\n    (palindrome? (number->string line))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290799,"user_id":null,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (check-palindrome items)\n  (cond\n    [(< (length items) 2) #t]\n    [(not (equal? (car items) (last items))) #f]\n    [else (check-palindrome (drop-right (cdr items) 1))]))\n\n(define (palindrome? line)\n  (let ([chars (if (number? line)\n                  (string->list (number->string line))\n                  (string->list line))])\n    (check-palindrome chars)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290800,"user_id":544,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (palindrome? line)\n  (equal? (string->list (~a line))\n          (reverse (string->list (~a line)))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290801,"user_id":null,"body":"#lang racket\n\n(provide palindrome?)\n\n;; String -> Boolean\n;; return #t if line is a palindrome, #f otherwise\n(define (palindrome? line)\n  (define l (if (number? line) (number->string line) line))\n  (define last-id (sub1 (string-length l)))\n  (cond\n    [(string=? l \"\") #t]\n    [(= (string-length l) 1) #t]\n    [(char=? (string-ref l 0) (string-ref l last-id))\n     (palindrome? (substring l 1 last-id))]\n    [else #f]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290802,"user_id":168,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (palindrome? line)\n  (define s (if (string? line) line (number->string line)))\n  (equal? s ((compose list->string reverse string->list) s)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290803,"user_id":null,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (rev s) (list->string (reverse (string->list s))))\n(define (palindrome? x) (equal? x (if (number? x) (string->number (rev (number->string x))) (rev x))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290804,"user_id":null,"body":"#lang racket\n\n(provide palindrome?)\n\n(define (palindrome? line)\n  (define (str-rev s)\n    (list->string (reverse (string->list s))))\n  (define (tostr x)\n    (if (number? x)\n      (number->string x)\n      x))\n  (string=? (tostr line) (str-rev (tostr line))))\n      \n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57a5c31ce298a7e6b7000334":[{"id":290805,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal binary)\n  (string->number binary 2))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290806,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal binary)\n  (let* ([reversed (reverse (for\/list ([digit binary])\n                                      (string digit)))]\n         [powerfied (for\/list ([d reversed]\n                               [x (in-range 0 (length reversed))])\n                              (if (string=? \"1\" d)\n                                  (expt 2 x)\n                                  0))])\n    (apply + powerfied)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290807,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal binary)\n  (string->number (string-append \"#b\" binary)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290808,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal binary)\n  (let ([number (string->number binary)]) \n    (if (< number 10) number \n      (binToDec2 number 1 0)))\n)\n\n(define (binToDec2 number expo acc)\n  (if (= number 0) acc \n      (binToDec2 (quotient number 10) (* 2 expo) (+ (* expo (remainder number 10)) acc)))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290809,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal binary)\n  (foldl (lambda(elem v) (+ (* 2 v) (- (char->integer elem) 48))) 0 (string->list binary)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290810,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal binary)\n  (binary->decimal-recursive (reverse (string->digits binary)) 0))\n\n(define (binary->decimal-recursive numbers exponent)\n  (cond [(empty? numbers) 0]\n        [else (+\n               (* (car numbers) (expt 2 exponent))\n               (binary->decimal-recursive (cdr numbers) (add1 exponent)))]))\n\n(define (string->digits str)\n  (map char->number (string->list str)))\n\n(define (char->number c) (- (char->integer c) 48))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290811,"user_id":null,"body":"#lang racket\n\n(provide binary->decimal)\n\n(define (binary->decimal str-value)\n  ;; okay, let's move from the left.\n  (define (iterator working accumulator)\n    (if (equal? \"\" working) accumulator\n        (iterator (substring working 1)\n                  (+ (* 2 accumulator)\n                     (if (equal? \"1\" (substring working 0 1)) 1 0)))))\n    (iterator str-value 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57cc975ed542d3148f00015b":[{"id":290812,"user_id":53,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst value)\n (and (member value lst) #t))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290813,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution  lst item)\n  (if (member item lst) #t #f))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290814,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (if (index-of lst item)\n      #t\n      #f))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290815,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n    (if (not (member item lst))\n        #f\n        #t))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290816,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (if (empty? lst)\n      #f\n      (if (eq? (car lst) item)\n          #t\n          (solution (cdr lst) item))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290817,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (not (boolean? (member item lst))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290818,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (cond\n   [(empty? lst) #f]\n   [(equal? (car lst) item) #t]\n   [else (solution (cdr lst) item)]))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290819,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (if\n   (member item lst)\n   true\n   false))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290820,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (let loop ((l lst))\n    (cond ((null? l) #f)\n          ((eq? item (car l)) #t)\n          (else (loop (cdr l))))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290821,"user_id":null,"body":"#lang racket\n\n(provide solution)\n\n(define (solution lst item)\n  (if (pair? lst)\n      (if (equal? (car lst) item)\n          #t\n          (if (pair? (cdr lst))\n              (solution (cdr lst) item)\n              #f))\n      #f))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57cff961eca260b71900008f":[{"id":290822,"user_id":53,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define (convert-vowels xs)\n  (map (lambda (x) (cond ((=  97 x) \"a\")\n                         ((= 101 x) \"e\")\n                         ((= 105 x) \"i\")\n                         ((= 111 x) \"o\")\n                         ((= 117 x) \"u\")\n                         (else x))) xs))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290823,"user_id":null,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define (convert-vowels numbers)\n  (cond [(empty? numbers) empty ]\n        [(= (first numbers) 97) (cons \"a\" (convert-vowels (rest numbers)))]\n        [(= (first numbers) 101) (cons \"e\" (convert-vowels (rest numbers)))]\n        [(= (first numbers) 105) (cons \"i\" (convert-vowels (rest numbers)))]\n        [(= (first numbers) 111) (cons \"o\" (convert-vowels (rest numbers)))]\n        [(= (first numbers) 117) (cons \"u\" (convert-vowels (rest numbers)))]\n        [else (cons (first numbers) (convert-vowels (rest numbers))) ] ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290824,"user_id":50,"body":"#lang racket\n\n(provide convert-vowels)\n(define (f n)\n  (cond\n   [(eq? n 97) \"a\"]\n   [(eq? n 101) \"e\"]\n   [(eq? n 105) \"i\"]\n   [(eq? n 111) \"o\"]\n   [(eq? n 117) \"u\"]\n   [else n]))\n\n(define (convert-vowels numbers)\n  (map f numbers))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290825,"user_id":544,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define (convert-vowels numbers)\n  (for\/list ([n (in-list numbers)])\n    (if (member (integer->char n) '(#\\a #\\e #\\i #\\o #\\u))\n        (string (integer->char n))\n        n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290826,"user_id":null,"body":"#lang racket\n\n( provide convert-vowels )\n\n( define vowels ( list->set '(97 101 105 111 117) ) )\n\n( define convert-vowels\n  ( curry map ( lambda (c)\n              ( if ( set-member? vowels c ) (string (integer->char c)) c ) ) ) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290827,"user_id":null,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define (convert-vowels numbers)\n  \n  (cond\n   [(empty? numbers) '()]\n   [(equal? 97 (car numbers)) (cons \"a\" (convert-vowels (cdr numbers))) ]\n   [(equal? 101 (car numbers)) (cons \"e\" (convert-vowels (cdr numbers)))]\n   [(equal? 105 (car numbers)) (cons \"i\" (convert-vowels (cdr numbers)))]\n   [(equal? 111 (car numbers)) (cons \"o\" (convert-vowels (cdr numbers)))]\n   [(equal? 117 (car numbers)) (cons \"u\" (convert-vowels (cdr numbers)))]\n   [(number?  (car numbers)) (cons (car numbers) (convert-vowels (cdr numbers)))]\n   [else 0 ]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290828,"user_id":null,"body":"#lang racket\n\n(provide convert-vowels)\n\n;; (Listof Integer) -> (Listof (or\/c Integer String))\n;; check if any of the numbers are the char codes for lower case (a e i o u) and\n;; if they are, convert to string. Do not change the rest of the numbers.\n(define (convert-vowels numbers)\n\n  (define (vowel? n)\n    (define vowels (list->set (map char->integer '(#\\a #\\e #\\i #\\o #\\u))))\n    (set-member? vowels n))\n\n  (define (convert n)\n    (string (integer->char n)))\n  \n  (map (\u03bb (n) (if (vowel? n) (convert n) n)) numbers))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290829,"user_id":168,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define (convert-vowels numbers)\n  (map (lambda (x)\n         (case x\n          [(97 101 105 111 117) (string (integer->char x))]\n          [else x]))\n        numbers))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290830,"user_id":null,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define vowels '(97 101 105 111 117))\n(define (convert-vowels ls) (map (lambda (i) (if (member i vowels) (string (integer->char i)) i)) ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290831,"user_id":null,"body":"#lang racket\n\n(provide convert-vowels)\n\n(define (convert-vowels numbers)\n  (for\/list ([n (in-list numbers)])\n    (case n\n      [(97 101 105 111 117) (string (integer->char n))]\n      [else n])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57e76bc428d6fbc2d500036d":[{"id":290832,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array string)\n  (list->vector (string-split string)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290833,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array string)\n  (list->vector (filter (lambda (x) (not (string=? \"\" x))) (string-split string \" \"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290834,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array string)\n  (define (string-to-list string)\n    (define len (string-length string))\n    (define (stv-rec index)\n      (cond\n        ((string=? \"\" string)\n         '())\n        ((= index len)\n         (if (and (= 0 index)\n                  (equal? #\\  (string-ref string index)))\n             '()\n             (list (substring string 0 index)))) \n        ((equal? #\\  (string-ref string index))\n         (if (> index 0)\n             (cons (substring string 0 index)\n                   (string-to-list (substring string (+ 1 index))))\n             (string-to-list (substring string (+ 1 index) ))))\n        (else\n         (stv-rec (+ 1 index)))))\n    (stv-rec 0))\n  (list->vector (string-to-list string)))  \n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290835,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array string)\n  (list->vector (filter (lambda (item) (not (string=? \"\" item))) (string-split string \" \"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290836,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array lst)\n  (list->vector(string-split lst)))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290837,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array string)\n    (list->vector (string-split string (regexp \"[ ]+\")))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290838,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n;; String -> (Vectorof String)\n;; split a string (at spaces) and convert it into a list of words\n(define (string_to_array string)\n  (list->vector (string-split  string)))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290839,"user_id":53,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array s)\n  (list->vector (string-split s (regexp \"[ ]+\"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290840,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define (string_to_array s) (list->vector (string-split s)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290841,"user_id":null,"body":"#lang racket\n\n(provide string_to_array)\n\n(define string_to_array\n  (compose list->vector string-split))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57eae20f5500ad98e50002c5":[{"id":290842,"user_id":null,"body":"#lang racket\n\n(provide no_space) ;already defined in racket.\n\n(define (no_space str)\n  (string-replace str  \" \" \"\")\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290843,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n(define (no_space str)\n  (string-join (string-split str \" \") \"\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290844,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n(define no_space\n  (compose list->string (curry filter (compose not (curry equal? #\\space))) string->list))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290845,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n(define (no_space str) \n  (define (not-space? c) (not (equal? #\\space c)))\n  (list->string (filter not-space? (string->list str))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290846,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n(define (non-whitespace? c)\n  (not (char-whitespace? c)))\n\n(define (no_space str)\n  (list->string (filter non-whitespace? (string->list str))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290847,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n( define no_space\n  (compose string-append* string-split) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290848,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n(define (not-a-space? character)\n  (not (string=? \" \" character)))\n\n(define (no_space str)\n  (string-join (string-split str)\"\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290849,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n;; String -> String\n;; remove the spaces from the string, and return the resulting string\n(define (no_space str)\n  (string-join\n   (map string (filter-not (\u03bb (c) (char=? c '#\\space)) (string->list str)))\n   \"\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290850,"user_id":null,"body":"#lang racket\n\n(provide no_space)\n\n(define no_space (curryr string-replace \" \" \"\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290851,"user_id":null,"body":"#lang racket\n(provide no_space)\n(require srfi\/13)\n\n(define no_space (curry string-filter (curryr (compose not equal?) #\\space)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57eae65a4321032ce000002d":[{"id":290852,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (regexp-replaces fake '([#rx\"1\" \"0\"]\n                          [#rx\"2\" \"0\"]\n                          [#rx\"3\" \"0\"]\n                          [#rx\"4\" \"0\"]\n                          [#rx\"5\" \"1\"]\n                          [#rx\"6\" \"1\"]\n                          [#rx\"7\" \"1\"]\n                          [#rx\"8\" \"1\"]\n                          [#rx\"9\" \"1\"])))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290853,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (if (string? fake) (fake_bin (string->list fake))\n\t  (begin\n\t\t(display fake)\n\t\t(list->string (map (lambda (x) \n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t  ((< (string->number (string x)) 5) #\\0)\n\t\t\t\t\t\t  (else #\\1)))\n\t\t\t\t\t  fake)))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290854,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (list->string \n   (map \n    (lambda (i) \n     (if (char<? i #\\5) #\\0 #\\1)) \n    (string->list fake)))\n)\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290855,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (list->string (map (lambda (v) (if (char<? v #\\5) #\\0 #\\1)) (string->list fake)))) \n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290856,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (define (translate char)\n    (if (char>? #\\5 char) #\\0 #\\1))\n\n  (list->string\n   (map\n    translate\n    (string->list fake))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290857,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (list->string (for\/list [(a (string->list fake))] (if (char-ci<? a #\\5) #\\0 #\\1))))\n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290858,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (string-replace\n   (string-replace\n    fake\n    #rx\"[0-4]\"\n    \"0\")\n   #rx\"[5-9]\"\n   \"1\"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290859,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define fake_bin\n  ( compose list->string ( curry map ( lambda (c) ( if (char<? c #\\5) #\\0 #\\1 ) ) ) string->list ) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290860,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (string-replace (string-replace fake #rx\"[1, 2, 3, 4]\" \"0\") #rx\"[5, 6, 7, 8, 9]\" \"1\")) \n\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290861,"user_id":null,"body":"#lang racket\n\n(provide fake_bin)\n\n(define (fake_bin fake)\n  (list->string (map (lambda (c)\n                      (if (<= 53 (char->integer c))\n                          #\\1\n                          #\\0))\n                    (string->list fake))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57eaeb9578748ff92a000009":[{"id":290862,"user_id":168,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (for\/sum [(n lst)] (if (string? n) (string->number n) n)))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290863,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (for\/sum ([i (in-list lst)])\n    (if (string? i)\n        (string->number i)\n        i)))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290864,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (apply + (map (\u03bb (x) (if (string? x) (string->number x) x)) lst)))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290865,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (foldl + 0 (map (lambda (x) (if (string? x) (string->number x) x)) lst)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290866,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix x)\n  (define (sum a b) \n    (+ (if (number? a) a (string->number a)) \n       (if (number? b) b (string->number b))))\n  (define (sum_mix-inner x acc)\n    (if (null? (cdr x))\n        (sum acc (car x))\n        (sum_mix-inner (cdr x) (sum acc (car x)))))\n  (sum_mix-inner x 0))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290867,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n (foldr + 0 (map (lambda (element) (if (string? element) (string->number element) element)) lst)))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290868,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (if (null? lst)\n      0\n      (if (string? (car lst))\n          (+ (string->number (car lst)) (sum_mix (cdr lst)))\n          (+ (car lst) (sum_mix (cdr lst)))\n          )\n      )\n  )\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290869,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (\n   cond [(null? lst) 0]\n        [(string? (first lst)) (+ (string->number (first lst)) (sum_mix (rest lst)))]\n        [(number? (first lst)) (+ (first lst) (sum_mix (rest lst)))]         \n        [else (error \"invalid input\")]\n   ))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290870,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (sum_mix lst)\n  (cond\n   [(null? lst) 0]\n   [(string? (car lst)) (+ (string->number (car lst)) (sum_mix (cdr lst)))]\n   [else (+ (car lst) (sum_mix (cdr lst)))]))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290871,"user_id":null,"body":"#lang racket\n\n(provide sum_mix)\n\n(define (string?->number maybe-number)\n  (if (string? maybe-number) (string->number maybe-number) maybe-number))\n\n(define (sum_mix lst)\n  (apply + (map string?->number lst)))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57ee4a67108d3fd9eb0000e7":[{"id":290872,"user_id":527,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (remove* GEESE birds))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290873,"user_id":168,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (filter (lambda (x) (not (member x GEESE))) birds))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290874,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (filter (\u03bb (bird) (not (member bird GEESE))) birds))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290875,"user_id":527,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define goose_filter (curry remove* GEESE))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290876,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define goose_filter ((curry filter) (lambda (x) (not (member x GEESE)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290877,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (cond [(empty? birds) empty]\n        [else\n         (if (false? (member (first birds) GEESE))\n             (cons (first birds) (goose_filter (rest birds)))\n             (goose_filter (rest birds)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290878,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (remf* (lambda (x) (member x GEESE)) birds))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290879,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (filter (compose not (curry set-member? GEESE)) birds)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290880,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (cond [(empty? birds) empty]\n        [(remove-i (car birds) GEESE) (goose_filter (cdr birds))]\n        [else (cons (car birds) (goose_filter (cdr birds)))]))\n\n(define (remove-i item lst)\n  (cond [(empty? lst) false]\n        [(string=? item (car lst)) true]\n        [else (remove-i item (cdr lst))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290881,"user_id":null,"body":"#lang racket\n\n(define GEESE '(\"African\" \"Roman Tufted\" \"Toulouse\" \"Pilgrim\" \"Steinbacher\"))\n\n(provide goose_filter GEESE)\n\n(define (goose_filter birds)\n  (filter\n   (lambda (bird)\n      (not (member bird GEESE)))\n   birds))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57f222ce69e09c3630000212":[{"id":290882,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (case (length (filter (\u03bb (idea) (equal? idea \"good\")) ideas))\n    [(0) \"Fail!\"]\n    [(1 2) \"Publish!\"]\n    [else \"I smell a series!\"]))\n ","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290883,"user_id":168,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (case (count (lambda (x) (equal? x \"good\")) ideas)\n    [(0) \"Fail!\"]\n    [(1 2) \"Publish!\"]\n    [else \"I smell a series!\"]))\n ","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290884,"user_id":53,"body":"#lang racket\n\n(provide well)\n\n(define (well xs)\n  (define n (length (filter (\u03bb (x) (eq? \"good\" x)) xs)))\n  (cond [(zero? n) \"Fail!\"]\n        [(>= 2 n) \"Publish!\"]\n        [else \"I smell a series!\"]))\n ","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290885,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (let ((good-ideas (count (curry eqv? \"good\") ideas)))\n    (cond\n     ((> good-ideas 2) \"I smell a series!\")\n     ((> good-ideas 0) \"Publish!\")\n     (else \"Fail!\"))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290886,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (case (length (filter (lambda (idea) (equal? idea \"good\")) ideas))\n  [(0) \"Fail!\"]\n  [(1 2) \"Publish!\"]\n  [else \"I smell a series!\"]))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290887,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (let ([c (count (lambda (x) (equal? x \"good\")) ideas)])\n    (cond\n      [(> c 2) \"I smell a series!\"]\n      [(> c 0) \"Publish!\"]\n      [else \"Fail!\"])))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290888,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (cond\n    [(> (count isGood ideas) 2) \"I smell a series!\"]\n    [(>= (count isGood ideas) 1) \"Publish!\"]\n    [(< (count isGood ideas) 1) \"Fail!\"]\n    )\n  )\n\n(define (isGood element)\n  (equal? \"good\" element)\n  )","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290889,"user_id":53,"body":"#lang racket\n\n(provide well)\n\n(define (well xs)\n  (case (count (\u03bb (x) (eq? x \"good\")) xs)\n    [(0) \"Fail!\"]\n    [(1 2) \"Publish!\"]\n    [else \"I smell a series!\"]))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290890,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n;; (ListofString) -> String\n;; given alist with \"good\" and \"bad\" (ideas), return:\n;; - \"Publish!\" if there are 1 or 2 \"good\" (ideas)\n;; - \"I smell a series!\" if there are more than 2 \"good\" (ideas)\n;; - \"Fail!\" otherwise\n(define (well ideas)\n  (define counts (make-hash))\n  (for ([i ideas]) (hash-set! counts i (add1 (hash-ref counts i 0))))\n  (define g (hash-ref counts \"good\" 0))\n  (cond\n    [(= g 0) \"Fail!\"]\n    [(<= g 2) \"Publish!\"]\n    [else \"I smell a series!\"]))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290891,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas) (\n  match (count (curry equal? \"good\") ideas)\n  [0 \"Fail!\"]\n  [1 \"Publish!\"]\n  [2 \"Publish!\"]\n  [_ \"I smell a series!\"]\n))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57f22b0f1b5432ff09001cab":[{"id":290892,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (define sum\n    (for\/sum ([some-ideas ideas])\n      (count\n       (compose (curry string=? \"GOOD\") string-upcase (curry format \"~a\"))\n       some-ideas)))\n  (cond\n    [(> sum 2) \"I smell a series!\"]\n    [(> sum 0) \"Publish!\"]\n    [else \"Fail!\"]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290893,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n(define (goo id)\n  (cond \n   [(null? id) 0]\n      [(and (string? (car id)) (string=? \"GOOD\" (string-upcase (car id))))\n       (add1 (goo (cdr id)))]\n   [else (goo (cdr id))]))\n  (let\n    [(n (apply + (map goo ideas)))]\n    (cond\n     [(or (= 1 n) (= 2 n)) \"Publish!\"]\n     [(< 2 n) \"I smell a series!\"]\n     [else \"Fail!\"])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290894,"user_id":209,"body":"#lang racket\n\n(provide well)\n\n(define (well q)\n  (define p (count (lambda (x) (string=?\"good\" x)) (map string-downcase (filter string? (foldl append '() q)))))\n(if (> p 2)\n   \"I smell a series!\"\n    (if (> p 0)\n        \"Publish!\"\n        \"Fail!\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290895,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define GOOD \"good\")\n(define BAD \"bad\")\n\n;; (Listof (Listof Any)) -> String\n;; Check the given 2 dimensial array for GOOD ideas and BAD ideas.\n;; If 1 or 2 good ideas, return \"Publish!\", >2 'I smell a series!, else 'Fail!'\n(define (well ideas)\n\n  (define (process idea)\n    (let ([i (cond\n               [(string? idea) idea]\n               [(symbol? idea) (symbol->string idea)]\n               [else BAD])])\n      (if (string-ci=? i \"good\") 1 0)))\n\n  (define (recur count todo)\n    (if (empty? todo)\n        (cond\n          [(zero? count) \"Fail!\"]\n          [(<= count 2) \"Publish!\"]\n          [else \"I smell a series!\"])\n        (recur (+ count (process (first todo))) (rest todo))))\n\n  (recur 0 (flatten ideas)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290896,"user_id":544,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (let ([good-ideas \n         (filter good-idea? (flatten ideas))])\n    (cond [((length good-ideas) . > . 2) \"I smell a series!\"]\n          [((length good-ideas) . > . 0) \"Publish!\"]\n          [else \"Fail!\"])))\n\n(define (good-idea? idea)\n  (cond [(not (string? idea)) #f]\n        [(equal? \"good\" (string-downcase idea)) #t]\n        [else #f]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290897,"user_id":168,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (case (for*\/sum [(xs ideas) (x xs) \n                  #:when (and (string? x) (string=? (string-downcase x) \"good\"))] \n                  1)\n    [(0) \"Fail!\"]\n    [(1 2) \"Publish!\"]\n    [else \"I smell a series!\"]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290898,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (case (for\/sum ([l (in-list ideas)])\n          (count (\u03bb (x) (and (string? x) (string-ci=? x \"good\"))) l))\n    [(0) \"Fail!\"]\n    [(1 2) \"Publish!\"]\n    [else \"I smell a series!\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290899,"user_id":null,"body":"#lang racket\n\n(provide well)\n\n(define (well ideas)\n  (case (length\n         (filter\n          (\u03bb (idea)\n            (and (string? idea) (equal? (string-downcase idea) \"good\")))\n          (flatten ideas)))\n    [(0) \"Fail!\"]\n    [(1 2) \"Publish!\"]\n    [else \"I smell a series!\"]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57f780909f7e8e3183000078":[{"id":290900,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define grow\n  (curry apply *))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290901,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow lst)\n  (define (iter lst mult)\n      (if (null? lst)\n          mult\n          (iter (cdr lst) (* mult (car lst)))))\n  (iter lst 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290902,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow lst)\n  (cond\n        [(null? lst) 1]\n        [(number? (first lst)) (* (first lst) (grow (rest lst)))]\n        [else (error \"Wrong input!\")]\n   ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290903,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow lst)\n  (if (empty? lst)\n      1\n      (* (car lst) (grow (cdr lst)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290904,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow lst)\n  (foldr * 1 lst))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290905,"user_id":53,"body":"#lang racket\n\n(provide grow)\n\n(define (grow xs)\n  (foldr * 1 xs)\n )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290906,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow lst)\n  (cond ((empty? lst) 1)\n        ((* (first lst) (grow (rest lst))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290907,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide grow)\n\n;; (List>=1 Integer) -> Integer\n;; return the product of numbers in the given list\n(define (grow lst)\n  (apply * lst))\n\n(module+ test\n  (check-equal? (grow '(1 2 3 4)) 24))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290908,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow ls) (apply * ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290909,"user_id":null,"body":"#lang racket\n\n(provide grow)\n\n(define (grow lst)\n  (if (empty? lst) \n      1\n      (* (first lst) (grow (rest lst))))\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"57f781872e3d8ca2a000007e":[{"id":290910,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps lst)\n  (map (lambda (num) (* num 2)) lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290911,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps lst)\n  (if (< (length lst) 2)\n    (list (* (car lst) 2))\n    (cons (* (car lst) 2) (maps (cdr lst)))\n  )\n)","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290912,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define maps  (curry map (curry * 2)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290913,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps lst)\n  (map (curry * 2) lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290914,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps lst)\n  (cond ((null? lst)\n         '())\n        (else\n         (cons (* 2 (car lst))(maps (cdr lst))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290915,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps nums)\n  (if (empty? nums) empty (cons (* 2 (first nums)) (maps (rest nums)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290916,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (double n) (* n 2))\n\n(define (maps lst) (map double lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290917,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (double x) (* 2 x))\n\n(define (maps lst)\n  (map double lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290918,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps lst)\n  (if (null? lst)\n      '()\n      (append (list (* (car lst) 2))  (maps(cdr lst)))\n      )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290919,"user_id":null,"body":"#lang racket\n(require rackunit rackunit\/text-ui)\n\n(provide maps)\n\n(define (maps lst)\n  (map (lambda (n) (* n 2)) lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"581331293788bc1702001fa6":[{"id":290920,"user_id":373,"body":"#lang racket\n\n(provide mirror)\n\n(define (mirror text)\n  (let*\n    ([replicate (lambda (n x) (string-join (for\/list ((i n)) x) \"\"))]\n     [starmax (lambda (n) (replicate n \"*\"))]\n     [maxlenw (lambda (words) (foldl max 0 (map string-length words)))]\n     [padline (lambda (len maxlen) (replicate (- maxlen len) \" \"))]\n     [the_words (string-split text)]\n     [mlen_words (maxlenw the_words)]\n     [string-reverse (lambda (s) (list->string (reverse (string->list s))))]\n     [get_one_line \n      (lambda (line) \n        (string-join \n         (list \"*\" \n               (string-join (list (string-reverse line) (padline (string-length line) mlen_words)) \"\") \"*\")))]\n     [len_top_down (+ 4 mlen_words)]\n     [line_top_down (starmax len_top_down)])\n    (string-join \n     (append (list line_top_down) (map get_one_line the_words) (list line_top_down)) \n     \"\n\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290921,"user_id":544,"body":"#lang racket\n\n(provide mirror)\n\n(define (mirror text)\n  (let* ([message-list (string-split text)]\n         [message-width (string-length (argmax string-length message-list))])\n    (string-join (flatten\n                  (list (make-string (+ 4 message-width) #\\*)\n                        (map (\u03bb (s)\n                               (format\n                                \"* ~a *\"\n                                (string-reverse\n                                 (~a s\n                                     #:min-width message-width\n                                     #:align 'right))))\n                             message-list)\n                        (make-string (+ 4 message-width) #\\*)))                   \n                 \"\n\")))\n\n(define (string-reverse strng)\n  (apply string (reverse (string->list strng))))\n\n(mirror \"Hello World\")","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290922,"user_id":null,"body":"#lang racket\n\n(provide mirror)\n\n(define string-reverse (compose list->string reverse string->list))\n\n(define (mirror text)\n  (define words (string-split text))\n  (define max-word-length (apply max (map (curry string-length) words)))\n  (define banner-length (+ 4 max-word-length))\n  (define banner (make-string banner-length #\\*))\n  \n  (define middle (for\/list ([word words])\n    (format \"* ~a *\" (~a (string-reverse word) #:min-width max-word-length))\n  ))\n\n  (define joined (string-join middle \"\n\"))\n  \n  (format \"~a\n~a\n~a\" banner joined banner))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290923,"user_id":null,"body":"#lang racket\n\n(provide mirror)\n\n(define (replicate len char)\n  (build-string len (lambda (i) char)))\n\n(define (words text)\n  (regexp-split #rx\" +\" text))\n\n(define string-reverse\n  (compose list->string reverse string->list))\n\n(define (pad max-len text)\n  (define len (string-length text))\n  (define pad (- max-len len))\n  (string-append text (replicate pad #\\space)))\n\n\n(define (mirror text)\n  (define text-words (words text))\n  (define mirrored-words (map string-reverse text-words))\n  (define max-len    (string-length (argmax string-length text-words)))\n  (define padded-mirrored-words (map (curry pad max-len) mirrored-words))\n  (define stars      (replicate (+ 4 max-len) #\\*))\n  (define sep        (string-append \" *\" \"\n\" \"* \"))\n  (string-join padded-mirrored-words sep\n               #:before-first (string-append stars \"\n\" \"* \")\n               #:after-last (string-append \" *\" \"\n\" stars)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290924,"user_id":null,"body":"#lang racket\n\n(provide mirror)\n(define (mirror t)\n  (define (fs n s)\n    (string-join (list \"*\" (~a s #:min-width n #:align 'left) \"*\") \" \"))\n  (let ([n (apply max (map string-length (string-split t)))]\n        [r (reverse (string-split (list->string (reverse (string->list t)))))])\n    (string-join (list (make-string (+ 4 n) #\\*) (string-join (map (curry fs n) r) \"\n\") (make-string (+ 4 n) #\\*)) \"\n\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290925,"user_id":null,"body":"#lang racket\n\n(provide mirror)\n\n(define (mirror text)\n  (let* ([split (string-split text \" \")]\n         [width (apply max (map string-length split))]\n         [top (list (make-string (+ width 4) #\\*))]\n         [row (\u03bb (word) (string-append\n                         \"* \"\n                         (string-join (reverse (string-split word \"\")) \"\")\n                         (make-string (- width (string-length word)) #\\space)\n                         \" *\"))])\n    (string-join (append top (map row split) top) \"\n\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58184387d14fc32f2b0012b2":[{"id":290926,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (+ (* x (\/ 1 2))\n     (* x x (\/ -1 8))\n     (* x x x (\/ 1 16))\n     (* x x x x (\/ -5 128))\n     )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290927,"user_id":50,"body":"#lang racket\n(provide f)\n\n(define (f x)\n (\/ x (+ 1 (sqrt (+ 1 x)))) \n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290928,"user_id":53,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (let ([a (\/ x 2)]\n        [b (\/ (* x x) 8)]\n        [c (\/ (* x (* x x)) 16)]\n        [d (\/ (* 5 (* x (* x (* x x)))) 128)])\n    (- (+ a c) (+ b d))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290929,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (\/ x (+ (sqrt (+ x 1)) 1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290930,"user_id":168,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (* x (+ 0.5 (* x (+ -0.125 (* x 0.0625))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290931,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (sqrt+1-exact inexact-a double-eps)\n  (let* ((eps (\/ (inexact->exact double-eps) 2))\n\t (a (inexact->exact inexact-a))\n\t (f (lambda (x) (- (* x x) a 1))))\n    (let loop ((left 0\/1)\n\t       (right (+ a 1)))\n      (let* ((m (\/ (+ left right) 2))\n\t     (fm (f m)))\n\t(if (> eps (abs fm))\n\t    m \n\t    (if (> fm 0)\n\t\t(loop left m)\n\t\t(loop m right)))))))\n\n(define (f x) (exact->inexact (- (sqrt+1-exact x 1e-128) 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290932,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x)\n (+ (\/ x 2) (\/ (* x x) -8) (\/ (* x x x) 16) (\/ (* 5 x x x x) -128)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290933,"user_id":492,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (\/ x (+ 1.0 (sqrt (+ 1.0 x)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290934,"user_id":168,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (- (sqrt (+ 1 x)) 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290935,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x)\n  (exact->inexact (- (inexact->exact (sqrt (+ x 1))) 1)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"581ee0db1bbdd04e010002fd":[{"id":290936,"user_id":492,"body":"#lang racket\n(provide interp)\n\n(define (interp f l u n)\n  (define (calc-step i)\n    (+ l (* (- u l) (\/ i n))))\n  (define (trunc x)\n    (\/ (floor (* x 100.0)) 100.0))\n  (map (lambda(i) (trunc (f (calc-step i)))) (range n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290937,"user_id":168,"body":"#lang racket\n(provide interp)\n\n(define (interp f l u n)\n  (define (rnd x) (\/ (floor (* x 100)) 100))\n  (define (pt i) (+ l (\/ (* i (- u l)) n)))\n  (map (compose rnd f pt) (range n))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290938,"user_id":242,"body":"#lang racket\n(provide interp)\n\n(define (enumerate start end)\n  (define (enumerate-iter start end acc)\n    (cond\n      [(= start end) (cons start acc)]\n      [else (enumerate-iter (+ 1 start) end (cons start acc))]\n    )\n  )\n  (cond\n    [(< end start) `()]\n    [else (reverse (enumerate-iter start end `()))]\n  )\n)\n\n(define (interp f l u n)\n  (map (lambda (x) (\/ (floor (* 100 (f (+ l (* (- x 1) (\/ (- u l) n)))))) 100) )(enumerate 1 n))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290939,"user_id":null,"body":"#lang racket\n(provide interp)\n\n(define (interp f l u n)\n    (for\/list ([i (in-range n)])\n        (\/ (floor (* (f (+ l (* i (\/ (- u l) n)))) 100)) 100)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"582cb0224e56e068d800003c":[{"id":290940,"user_id":645,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time)\n  (exact-floor (\/ time 2)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290941,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time)\n  (quotient (inexact->exact (floor time)) 2))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290942,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time) (exact-floor (\/ (floor time) 2)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290943,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time)\n  (inexact->exact (truncate (\/ time 2))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290944,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n( define litres ( compose exact-floor (curryr \/ 2) ) )","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290945,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time)\n  (floor(inexact->exact (\/ time 2))) #| your code here |#)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290946,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n;; Okay, I know this is an 8-kyu one, but I feel like they're just trolling us.\n(define (litres time)\n  (inexact->exact (floor (* .5 time))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290947,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time)\n  (inexact->exact (floor (* time 1\/2))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290948,"user_id":null,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time)\n  (inexact->exact (floor (* time 0.5))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290949,"user_id":1474,"body":"#lang racket\n\n(provide litres)\n\n(define (litres time) (exact-floor (\/ (exact-floor time) 2)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"583710ccaa6717322c000105":[{"id":290950,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n  (* z (if (even? z) 8 9)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290951,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n  (* z (+ 8 (modulo z 2)))\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290952,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication x)\n  (* (if (even? x) 8 9) x))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290953,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n  (if (= (modulo z 2) 0)\n      (* z 8)\n      (* z 9)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290954,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n  (if (equal? (remainder z 2) 0)\n    (* z 8)\n    (* z 9)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290955,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n  (cond\n   ((even? z) (* z 8))\n   (else (* z 9))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290956,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n (* z (if (eq? 0 (modulo z 2)) 8 9)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290957,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n(define (simple_multiplication z)\n  (cond ((even? z) (* 8 z))\n        (else (* 9 z)))\n  )\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290958,"user_id":null,"body":"#lang racket\n\n(provide simple_multiplication)\n\n( define (simple_multiplication z)\n  ( * ( if (even? z) 8 9 ) z ) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290959,"user_id":53,"body":"#lang racket\n(provide simple_multiplication)\n(define (simple_multiplication n) (if (even? n) (* 8 n) (* 9 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5839edaa6754d6fec10000a2":[{"id":290960,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n   (if (char-upper-case?(car lst))\n       (find_missing_letter-up lst)\n       (find_missing_letter-down lst)\n    )\n      \n  )\n(define (find_missing_letter-up lst)\n  (define alphabet (string->list (string-upcase \"abcdefghijklmnopqrstuvwxyz\")))\n  (iter alphabet lst)\n  )\n(define (find_missing_letter-down lst)\n  (define alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\"))\n  (iter alphabet lst)\n  )\n(define (iter alph chars)\n  (if (equal? (car alph) (car chars))\n      (iter2 alph chars)\n      (iter (cdr alph) chars)\n      )\n  )\n(define (iter2 alph1 chars1)\n  (if (not (equal? (car alph1)(car chars1)))\n      (car alph1)\n      (iter2 (cdr alph1) (cdr chars1))\n   )\n  )\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290961,"user_id":null,"body":"#lang racket\n\n(require srfi\/1)\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (first\n   (lset-difference eq?\n                    (map integer->char\n                         (inclusive-range\n                          (char->integer (first lst))\n                          (char->integer (last lst))))\n                    lst)))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290962,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (define (go nums)\n    (if\n      (equal? 1 (- (car (cdr nums)) (car nums)))\n      (go (cdr nums))\n      (add1 (car nums))))\n  (integer->char (go (map char->integer lst))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290963,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (cond ((=(+ (char->integer (car lst)) 1) (char->integer (cadr lst))) (find_missing_letter (cdr lst)))\n        (else (integer->char (+ (char->integer(car lst)) 1)))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290964,"user_id":544,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (cond\n    [(= (- (char->integer (cadr lst)) (char->integer (car lst))) 1) (find_missing_letter (cdr lst))]\n    [else (integer->char (+ 1 (char->integer (car lst))))]))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290965,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (if (= (- (char->integer (second lst)) (char->integer (first lst))) 2)\n      (integer->char (+ (char->integer (first lst)) 1))\n      (find_missing_letter (cdr lst))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290966,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n(require rackunit)\n\n;; Char -> Char\n;; Returns immediate successor for alphabetic characters.\n(define successor-char\n  (compose integer->char add1 char->integer))\n\n(check-equal? (successor-char #\\a) #\\b)\n(check-equal? (successor-char #\\m) #\n)\n(check-equal? (successor-char #\\A) #\\B)\n(check-equal? (successor-char #\\M) #\\N)\n\n;; [List-of Char] -> Char\n;; Given an array of characters where one character is \/always\/ missing,\n;; return that missing character.\n(define (find_missing_letter xs)\n  (match xs\n    ['() (error \"invalid array of characters\")]\n    [(cons c '()) (error \"invalid array of characters\")]\n    [(list* x1 x2 _) #:when (not (eq? (successor-char x1) x2)) (successor-char x1)]\n    [(cons _ rest) (find_missing_letter rest)]))\n\n(check-equal? (find_missing_letter '(#\\a #\\b #\\c #\\d #\\f)) #\\e)\n(check-equal? (find_missing_letter '(#\\O #\\Q #\\R #\\S)) #\\P)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290967,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (cond [(empty? (cdr lst)) (integer->char (+ 1 (char->integer (car lst))))]\n        [(> (- (char->integer (cadr lst))\n               (char->integer (car lst)))\n            1) (integer->char (+ 1 (char->integer (car lst))))]\n        [else (find_missing_letter (cdr lst))]))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290968,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (define (find-missing-seq hd tl)\n    (if (= (+ hd 1) (car tl))\n        (find-missing-seq (car tl) (cdr tl))\n        (+ hd 1)))\n  (let ((chars (map char->integer lst)))\n    (integer->char (find-missing-seq (car chars) (cdr chars)))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290969,"user_id":null,"body":"#lang racket\n\n(provide find_missing_letter)\n\n(define (find_missing_letter lst)\n  (define num-letters\n    (map char->integer lst))\n  (define consec-num-letters\n    (build-list (length lst) (curry + (first num-letters))))\n  (integer->char (first (filter (lambda (letter) (not (member letter num-letters))) consec-num-letters)))\n)\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5868b2de442e3fb2bb000119":[{"id":290970,"user_id":null,"body":"#lang racket\n(provide closest)\n\n(define (closest strng)\n  (define (weight s) (apply + (map string->number (regexp-match* #px\"\\\\d\" s))))\n  (define weights (for\/list ([(s i) (in-indexed (string-split strng \" \"))])\n                    (list (weight s) i (string->number s))))\n  (define (sort-weights a b) (ormap < (take a 2) (take b 2)))\n  (define (pairs lst) (for\/list ([a lst] [b (cdr lst)]) (list a b)))\n  (define weight-diff (match-lambda [(list (cons a _) (cons b _)) (- b a)]))\n  (if (< (length weights) 2)\n      '(() ())\n      (car (sort (pairs (sort weights sort-weights)) < #:key weight-diff))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-09 21:51:58"},{"id":290971,"user_id":null,"body":"#lang racket\n(provide closest)\n\n(define (smallest-diff lst)\n  (define num-one (first lst))\n  (define num-two (first (rest lst)))\n  (set! lst (sort lst <))\n  (for* ([i (in-range (length lst))]\n         [j (in-range (length lst))]\n         #:unless (eq? i j))\n    (cond\n      [(or\n        (> (abs (- num-one num-two)) (abs (- (list-ref lst i) (list-ref lst j))))\n        (and\n         (eq? (abs (- num-one num-two)) (abs (- (list-ref lst i) (list-ref lst j))))\n         (< (list-ref lst i) num-one)))\n       (begin\n         (set! num-one (list-ref lst i))\n         (set! num-two (list-ref lst j)))]))\n  (list (abs (- num-one num-two))\n        num-one\n        num-two))\n\n(define (closest strng)\n  (define string-list \n    (regexp-split #px\" \" strng))\n\n  (define list-of-nums\n    (map (lambda (list-of-numbers)\n           ;; Turn list of strings into a list of a list of characters\n           (map (lambda (list-of-chars)\n                  ;; Turn a list of characters into a list of numbers\n                  (- (char->integer list-of-chars) 48))\n                (string->list list-of-numbers)))\n         string-list))\n\n  (define weights\n    ;; Returns the sum of each number in string.\n    (map (lambda (nums)\n           (apply + nums))\n         ;; Turn a string of numbers seperated by whitespace into a list of strings.\n         list-of-nums))\n  (cond\n    [(eq? strng \"\") '(() ())]\n    [(eq? (first (smallest-diff weights)) 0)\n     (list\n      (list\n       (second (smallest-diff weights))\n       (index-of weights (second (smallest-diff weights)))\n       (string->number (list-ref string-list (index-of weights (second (smallest-diff weights))))))\n      (list\n       (third (smallest-diff weights))\n       (+ 1 (index-of (remove (second (smallest-diff weights)) weights) (third (smallest-diff weights))))\n       (string->number\n        (list-ref string-list\n                  (+ 1 (index-of (remove (second (smallest-diff weights)) weights)\n                                 (third (smallest-diff weights))))))))]\n    [else\n     (list\n      (list \n       (second (smallest-diff weights))\n       (index-of weights (second (smallest-diff weights)))\n       (string->number (list-ref string-list (index-of weights (second (smallest-diff weights))))))\n      (list\n       (third (smallest-diff weights))\n       (index-of weights (third (smallest-diff weights)))\n       (string->number (list-ref string-list (index-of weights (third (smallest-diff weights)))))))]))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-09 21:52:00"},{"id":290972,"user_id":492,"body":"#lang racket\n(provide closest)\n\n(define (closest strng)\n  (define (sum-digits n)\n    (apply + (map string->number (map string (string->list n)))))\n\n  (define (comp x y)\n    (let ([a1 (first x)] [b1 (first y)] [a2 (second x)] [b2 (second y)])\n      (if (= a1 b1)\n          (< a2 b2)\n          (< a1 b1))))\n  \n  (if (equal? strng \"\")\n      '(() ())     \n      (let* ([s (string-split strng \" \")]\n             [w (sort (map (\u03bb(x y) (list (sum-digits x) y (string->number x))) s (range 0 (length s))) comp)]\n             [r (for\/list ([i (range 1 (length w))])\n                          (list (- (first (list-ref w i)) (first (list-ref w (sub1 i)))) i))]\n             [ndx (second (first (sort r comp)))])\n        (list (list-ref w (sub1 ndx)) (list-ref w ndx)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-09 21:52:01"}],"586c1cf4b98de0399300001d":[{"id":290973,"user_id":645,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (max 0 (- health damage)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290974,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (if (> health damage) (- health damage) 0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290975,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (let ((n (- health damage)))\n    (if (negative? n)\n        0\n        n)))\n      \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290976,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (if (< (- health damage) 0)\n      0\n      (- health damage)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290977,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n;; Integer Integer -> Integer>=0\n;; given current health and the amount of damage received,\n;; return the new health\n(define (combat health damage)\n  (define new-h (- health damage))\n  (if (< new-h 0)\n      0\n      new-h))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290978,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define combat (compose (curry max 0) -))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290979,"user_id":null,"body":"#lang racket\n\n(provide combat)\n;combat health damage\n;num num -> num\n; takes in an initial number\n; subtracts the 2nd number from the first\n; if the 1st is greater than or equaled to the 2nd; if otherwise\n; returns 0\n;given: 22 23 ex. 0 \"...\"\n;given: 30 23 ex. 7\n;given: 33 33 ex. 0\n\n(define (combat health damage)\n  (cond\n   [(> damage health) 0]\n   [(>= health damage) (- health damage)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290980,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (let ([new-health (- health damage)])\n    (if (negative? new-health) 0 new-health)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290981,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (cond [(< (- health damage) 0) 0] [else (- health damage) ] ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290982,"user_id":null,"body":"#lang racket\n\n(provide combat)\n\n(define (combat health damage)\n  (if (> (- health damage) 0)\n      (- health damage)\n      0))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5875b200d520904a04000003":[{"id":290983,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (normalize x) \n  (cond \n   ((>= x 0) 0)\n   (else (abs x))))\n\n(define (enough cap on wait)\n  (normalize (- cap (+ on wait))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290984,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (let \n    ([x (-(- cap on wait))])\n    (if (<= x 0) 0 x)\n  )\n)\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290985,"user_id":527,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (max 0 (- (+ on wait) cap)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290986,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (if (> cap (+ on wait)) 0 (- (+ on wait) cap)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290987,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (if (<= 0 (- cap on wait))\n      0\n      (abs (- cap on wait))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290988,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (let ([diff (- (+ on wait) cap)])\n    (if (positive? diff) diff 0)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290989,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (max 0 (- (+ wait on) cap)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290990,"user_id":50,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (if (> (- cap on wait) 0 ) 0 (+ (- wait cap) on)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290991,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (if (< cap (+ on wait))\n      (- (+ on wait) cap)\n      0))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290992,"user_id":null,"body":"#lang racket\n\n(provide enough)\n\n(define (enough cap on wait)\n  (let ([diff (- cap on wait)])\n      (if (<= 0 diff) 0 (abs diff))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58841cb52a077503c4000015":[{"id":290993,"user_id":null,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n f)\n  (modulo (+ f\n             (\/ n 2))\n          n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290994,"user_id":null,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n first-number)\n  (modulo (+ first-number (\/ n 2)) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290995,"user_id":544,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n first-number)\n  (if [n . > . (+ first-number (\/ n 2))]\n      (+ first-number (\/ n 2))\n      (- first-number (\/ n 2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290996,"user_id":null,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n;; 4<=EvenInt<=1000 Int\n;; given a circle with integers from 0 to n-1 written down along it in\n;; such a way that the distance between any two neighbouring numbers is equal\n;; (0 and n-1 are neighbouring too), return the number which is diameterically\n;; opposite to `first-number`\n(define (circle_of_numbers n first-number)\n  (remainder (+ first-number (\/ n 2)) n))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290997,"user_id":null,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n first-number)\n  (if (< first-number (\/ n 2)) \n      (+ first-number (\/ n 2)) \n      (- first-number (\/ n 2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290998,"user_id":null,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n first-number)\n  (remainder (+ first-number (quotient n 2)) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":290999,"user_id":527,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n first-number)\n  (modulo (+ first-number (quotient n 2)) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291000,"user_id":645,"body":"#lang racket\n\n(provide circle_of_numbers)\n\n(define (circle_of_numbers n first-number)\n  (modulo (+ (\/ n 2) first-number) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"588422ba4e8efb583d00007d":[{"id":291001,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define (d-sum n)\n  (let-values ([(x y) (quotient\/remainder n 10)]) (+ x y)))\n\n(define (late_ride n)\n  (let-values ([(h m) (quotient\/remainder n 60)]) (+ (d-sum h) (d-sum m))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291002,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define x 0)\n(define stunden 0)\n\n(define (late_ride n)\n  (set! x (\/ n 60))\n  (cond\n   [(= (modulo n 60) 0) x]\n   [else (+ (quersumme(- (ceiling x) 1)) (quersumme(- n (* (- (ceiling x) 1) 60))) )])\n  )\n\n(define (quersumme x)\n  (if (<= x 0) 0\n      (+ (modulo x 10) (quersumme (quotient x 10)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291003,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide late_ride)\n\n;; 0<=Int<60*24 -> (List 0<=Int<=23 0<=Int<=59)\n;; convert minutes since midnight into hours and minutes since (last) midnight\n(define (absmins->hoursmins mins)\n (call-with-values\n  (lambda () (quotient\/remainder\n              (remainder mins (* 60 24)) ;; guard against cases of >24h driving\n              60)) list))\n\n(module+ test\n  (check-equal? (absmins->hoursmins 240) '(4 0))\n  (check-equal? (absmins->hoursmins 808) '(13 28)))\n\n\n;; 0<=Int<=60*24 -> Integer\n;; convert minutes since midnight to sum of digits a digital clock would show\n(define (late_ride n)\n\n  (define (sum-digits n)\n    (if (< n 10)\n        n\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n\n  (apply + (map sum-digits (absmins->hoursmins n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291004,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (+ (modulo   (modulo   n 60) 10)\n     (modulo   (quotient n 60) 10)\n     (quotient (modulo   n 60) 10)\n     (quotient (quotient n 60) 10)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291005,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (let ([h (number->string (modulo (quotient n 60) 24))]\n        [m (number->string (modulo n 60))])\n      (string-sum (string-append h m))))\n\n(define (string-sum strng)\n  (foldl + 0 (map (lambda (c) (string->number (string c))) (string->list strng))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291006,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (let*-values ([(h m) (quotient\/remainder n 60)]\n                [(dh2 dh1) (quotient\/remainder h 10)]\n                [(dm2 dm1) (quotient\/remainder m 10)])\n    (+ dh2 dh1 dm2 dm1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291007,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (let-values ([(x y) (quotient\/remainder n 60)])\n    (foldl (lambda (elem acc)\n             (+ (string->number (string elem)) acc))\n           0\n           (string->list (~a x y)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291008,"user_id":null,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (let-values ([(x y) (quotient\/remainder n 60)])\n    (foldl + 0\n           (map (lambda (val)\n                  (foldl (lambda (elem acc)\n                           (+ (string->number (string elem)) acc)) 0 val))\n                (list (string->list (~a x))\n                      (string->list (~a y)))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291009,"user_id":527,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (define-values (h m) (quotient\/remainder n 60))\n  (define-values (h1 h0) (quotient\/remainder h 10))\n  (define-values (m1 m0) (quotient\/remainder m 10))\n  (+ h1 h0 m1 m0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291010,"user_id":645,"body":"#lang racket\n\n(provide late_ride)\n\n(define (late_ride n)\n  (foldl + 0 (map (\u03bb (x) (string->number (string x))) (string->list (~a (quotient n 60) (modulo n 60))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58941fec8afa3618c9000184":[{"id":291011,"user_id":645,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant up down h)\n  (max 1 (exact-ceiling (\/ (- h down) (- up down)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291012,"user_id":53,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant u d m)\n  (max 1 (ceiling (\/ (- m d) (- u d)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291013,"user_id":null,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing2 up down dh height days)\n  (let ([reached (+ height up)])\n    (if (>= reached dh) (+ days 1) \n      (growing2 up down dh (- reached down) (+ days 1))))\n)\n\n(define (growing_plant up-speed down-speed desired-height)\n  (growing2 up-speed down-speed desired-height 0 0)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291014,"user_id":50,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant up-speed down-speed desired-height)\n    (max 1 (exact-round(ceiling (\/ (- desired-height down-speed) (- up-speed down-speed))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291015,"user_id":null,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (grow day-count height desired-height up-speed down-speed)\n  (let ([new-height (+ height up-speed)])\n    (if (>= new-height desired-height) \n      (+ day-count 1)\n      (grow (+ day-count 1) (- new-height down-speed) desired-height up-speed down-speed))))\n\n(define (growing_plant up-speed down-speed desired-height)\n  (grow 0 0 desired-height up-speed down-speed))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291016,"user_id":null,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant up-speed down-speed desired-height)\n  (letrec\n    ([f (lambda (h)\n          (add1 (if (>= h desired-height) 0\n            (f (+ up-speed (- h down-speed))))))])\n    (f up-speed)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291017,"user_id":null,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant up-speed down-speed desired-height)\n  (cond ((<= (- desired-height up-speed) 0) 1)\n        (else (+ 1 (growing_plant up-speed down-speed (- desired-height (- up-speed down-speed)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291018,"user_id":null,"body":"#lang racket\n(provide growing_plant)\n\n(define (growing_plant up-speed down-speed desired-height)\n  (max\n    (ceiling (\/ (- desired-height down-speed) (- up-speed down-speed)))\n    1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291019,"user_id":null,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant up-speed down-speed desired-height)\n  (let loop ((h 0) (i 1))\n    (if (or (>= (+ h up-speed) desired-height) (>= (+ h (- up-speed down-speed)) desired-height))\n        i\n        (loop (+ h (- up-speed down-speed)) (+ i 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291020,"user_id":null,"body":"#lang racket\n\n(provide growing_plant)\n\n(define (growing_plant-day current-height up-speed down-speed desired-height current-day)\n  (cond\n   [(>= current-height desired-height) current-day]\n   [else (growing_plant-night (+ current-height up-speed) up-speed down-speed desired-height current-day)]))\n\n(define (growing_plant-night current-height up-speed down-speed desired-height current-day)\n  (cond\n   [(>= current-height desired-height) current-day]\n   [else (growing_plant-day (- current-height down-speed) up-speed down-speed desired-height (add1 current-day))]))\n\n(define (growing_plant up-speed down-speed desired-height)\n  (growing_plant-day 0 up-speed down-speed desired-height 1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5899dc03bc95b1bf1b0000ad":[{"id":291021,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (map - values))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291022,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert lst)\n  (map - lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291023,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert ls) (map - ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291024,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (if (null? values)\n      '()\n      (append (list (* (car values) -1)) (invert (cdr values)))\n      )\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291025,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (cond\n   [(empty? values) '()]\n   [else\n    (cons (* -1 (first values))\n          (invert (rest values)))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291026,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (map (lambda (n)\n         (* -1 n))\n       values))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291027,"user_id":50,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (map neg values))\n(define (neg n)\n  (- n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291028,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (map (lambda(n) (- 0 n)) values))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291029,"user_id":null,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (map (lambda (number)(- number)) values))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291030,"user_id":544,"body":"#lang racket\n\n(provide invert)\n\n(define (invert values)\n  (map (curry * -1) values))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58acfe4ae0201e1708000075":[{"id":291031,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women l)\n  (> (foldl + 0 l) 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291032,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women l)\n  (< 0 (apply + l)))\n    ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291033,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women l)\n  (positive? (foldl + 0 l)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291034,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define MAN 1)\n(define WOMAN -1)\n\n;; (Listof (or\/c MAN WOMAN)) -> Boolean\n;; return #t if there are more women in `l` than men, #f otherwise\n(define (invite_more_women l)\n  (< (count (\u03bb (p) (equal? p WOMAN)) l)\n     (count (\u03bb (p) (equal? p MAN)) l)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291035,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women lst)\n  (define (sum input acc)\n    (if (null? input) \n        acc\n        (sum (cdr input) (+ (car input) acc))))\n  (> (sum lst 0) 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291036,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women l)\n  (define (counter lst men women)\n    (cond ((null? lst) (cons men women))\n          ((= (car lst) -1) (counter (cdr lst) men (+ 1 women)))\n          ((= (car lst) 1) (counter (cdr lst) (+ 1 men) women))\n          (else (counter (cdr lst) men women))))\n  (let ([guests (counter l 0 0)])\n    (let ([men (car guests)] [women (cdr guests)])\n      (if (< women men)\n          true\n          false))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291037,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n(define (total a)\n  (if (pair? a) \n      (+ (car a) (total (cdr a)))\n      0\n      )\n  )\n(define (invite_more_women l)\n  #| your code here |#\n  (let (\n        (balance (total l )))\n    (if (> balance 0)\n        #t\n        #f)\n    )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291038,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (is-woman v)\n  (< v 0))\n\n(define (invite_more_women l)\n  (let ((nrwoman  (length (filter is-woman l))))\n    (< nrwoman (- (length l) nrwoman))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291039,"user_id":null,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women l)  \n  (let* [(w (length (filter (lambda (x) (< x 0)) l)))]         \n    (> (- (length l) w) w)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291040,"user_id":168,"body":"#lang racket\n\n(provide invite_more_women)\n\n(define (invite_more_women l)\n  (> (apply + l) 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58cb43f4256836ed95000f97":[{"id":291041,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (find_difference a b)\n  (abs (- (apply * a) (apply * b))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291042,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (find_difference a b)\n  (abs (- (mySum a) (mySum b)))\n  )\n  \n(define (mySum lst)\n (foldr * 1 lst))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291043,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (cuboid-volume dims)\n  (apply * dims))\n\n(define (find_difference a b)\n  (abs (- (cuboid-volume a) (cuboid-volume b))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291044,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (find_difference a b)\n  ((compose abs -) (foldl * 1 a) (foldl * 1 b)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291045,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (find_difference a b)\n  (let ([cuboid (lambda (c) (* (car c) (car (cdr c)) (car (cdr (cdr c)))))])\n    (abs (- (cuboid a) (cuboid b)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291046,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (vol-of-cube a)\n  (* (car a) (car (cdr a)) (car (cdr (cdr a)))))\n\n(define (find_difference a b)\n  (abs (- (vol-of-cube a) (vol-of-cube b))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291047,"user_id":373,"body":"#lang racket\n(provide find_difference)\n\n\n(define (find_difference a b)\n  (let ([v (lambda (l) (foldl * 1 l))]) (abs (- (v a) (v b)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291048,"user_id":53,"body":"#lang racket\n(provide find_difference)\n\n(define (find_difference a b)\n  (let ([x1 (list-ref a 0)]\n        [y1 (list-ref a 1)]\n        [z1 (list-ref a 2)]\n        [x2 (list-ref b 0)]\n        [y2 (list-ref b 1)]\n        [z2 (list-ref b 2)])\n    (abs (- (* x1 (* y1 z1)) (* x2 (* y2 z2))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291049,"user_id":null,"body":"#lang racket\n(provide find_difference)\n\n(define (get-volume lst)\n  (cond \n   ((null? lst) 1) \n   (else (* (car lst) (get-volume (cdr lst))))))\n\n(define (find_difference a b)\n  (abs (- (get-volume a) (get-volume b))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291050,"user_id":null,"body":"#lang racket\n\n(provide find_difference)\n\n;; (List Int Int Int) (List Int Int Int) -> Integer\n;; given dimensions of two cuboids, return the absolute difference\n;; of the cuboids' volumes\n(define (find_difference a b)\n  (define (vol sides) (apply * sides))\n  (abs (- (vol a) (vol b))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58ce8725c835848ad6000007":[{"id":291051,"user_id":527,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (quotient (* w0 (- 100 p0)) (- 100 p1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291052,"user_id":492,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (quotient (* (- 100 p0) w0) (- 100 p1)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291053,"user_id":null,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes w0 m0 w1)\n  (define (percent x) (\/ x 100))\n  (let ((w0 (percent w0))\n        (w1 (percent w1)))\n    (truncate (\/ (* m0 (- 1 w0))\n                 (- 1 w1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291054,"user_id":null,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (let (\n        [dry-matter (* w0 (- 1 (\/ p0 100)))])\n    (exact-truncate (\/ dry-matter (- 1 (\/ p1 100)))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291055,"user_id":null,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (exact-truncate (\/ (* w0 (- 100 p0 )) (- 100 p1))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291056,"user_id":null,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (let* ([p0 (\/ p0 100)]\n         [p1 (\/ p1 100)])\n    (floor (* w0 (\/ (- 1 p0) (- 1 p1))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291057,"user_id":null,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (floor (\/ (* (- 1 (\/ p0 100)) w0) (- 1 (\/ p1 100))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291058,"user_id":544,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n  (let* ([water-weight (* w0 (\/ p0 100))]\n         [solid-weight (- w0 water-weight)]\n         [new-total-weight (\/ solid-weight (- 1 (\/ p1 100)))])\n    (exact-floor new-total-weight)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291059,"user_id":null,"body":"#lang racket\n(provide potatoes)\n\n(define (potatoes p0 w0 p1)\n    (define _p0 (\/ p0 100))\n    (define _p1 (\/ p1 100))\n    (exact-floor (\/ (* (- 1 _p0) w0) (- 1 _p1)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291060,"user_id":null,"body":"#lang racket\n\n(provide potatoes)\n\n;; Int Int Int -> Int\n;; return the weight of w0 kilograms of potatoes with initial water percentage\n;; p0 after drying them in an oven till the water percentage drops to p1\n(define (potatoes p0 w0 p1)\n  (define dry-matter (* w0 (\/ (- 100 p0) 100)))\n  (floor (* (\/ dry-matter (- 100 p1)) 100)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58dbdccee5ee8fa2f9000058":[{"id":291061,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (string-contains? (string-upcase str) \"ENGLISH\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291062,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  \n  (regexp-match? #rx\"(?i:english)\" str) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291063,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (string-contains? (string-locale-downcase str) \"english\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291064,"user_id":null,"body":"#lang racket\n\n(require srfi\/13) ; the string SRFI    \n\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (if (equal? (string-contains (string-downcase str) \"english\") #f) #f #t))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291065,"user_id":492,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (regexp-match? \"english\" (string-downcase str)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291066,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n;; String -> Booelan\n;; return #tif str contains \"english\" (case does not matter), #f otherwise\n(define (speak-english? str)\n  (string-contains? (string-downcase str) \"english\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291067,"user_id":53,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (regexp-match? (regexp \"english\") (string-downcase str))\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291068,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? s) (regexp-match? #rx\"(?i:english)\" s))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291069,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (regexp-match? #px\"(?i:english)\" str))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291070,"user_id":null,"body":"#lang racket\n\n(provide speak-english?)\n\n(define (speak-english? str)\n  (string-contains? (string-downcase str) \"english\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"58f5c63f1e26ecda7e000029":[{"id":291071,"user_id":null,"body":"#lang racket\n(provide wave)\n\n(define (wave crowd)\n  (for\/list ([i (in-range (string-length crowd))]\n            #:when (not (eq? (string-ref crowd i) #\\space)))\n              (let ([s (string-copy crowd)])\n              (string-set! s i (char-upcase (string-ref crowd i))) s)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291072,"user_id":null,"body":"#lang racket\n(provide wave)\n\n(define (wave-case str i) \n    (list->string (list-update (string->list str) i char-upcase)))\n\n(define (wave crowd)\n    (for\/list ((i (range (string-length crowd)))\n                #:when (not (char-whitespace? (string-ref crowd i))))\n        (wave-case crowd i)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291073,"user_id":null,"body":"#lang racket\/base\n(require racket\/string racket\/list)\n(provide wave)\n\n(define (wave crowd)\n  (for\/list ([i (in-range (string-length crowd))]\n             #:when (not (eq? #\\space (string-ref crowd i))))\n    (list->string (list-update (string->list crowd) i char-upcase))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291074,"user_id":544,"body":"#lang racket\n(provide wave)\n\n(define (wave crowd)\n  (for\/list ([waver (in-string crowd)]\n             [i (in-range 0 (string-length crowd))]\n             #:unless (equal? waver #\\space))\n            (apply string (list-update (string->list crowd) i char-upcase))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291075,"user_id":null,"body":"#lang racket\n\n(provide wave)\n\n;; String -> (Listof String)\n;; turn a string into a Mexican Wave. \n(define (wave crowd)\n  \n  (define (upcase-char-at s idx)\n    (string-append\n     (substring s 0 idx)\n     (string-upcase (substring s idx (add1 idx)))\n     (substring s (add1 idx))))\n  \n  (for\/list ([i (in-range (string-length crowd))]\n             #:unless (char=? (string-ref crowd i) #\\space))\n    (upcase-char-at crowd i)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291076,"user_id":544,"body":"#lang racket\n(provide wave)\n\n(define (wave crowd)\n  (let ([waving-crowd\n         (map (lambda (i) (string->list crowd)) (sequence->list (in-range 0 (string-length crowd))))])\n    (remove* (list crowd) (for\/list ([pos (in-range 0 (string-length crowd))] [steps waving-crowd])\n              (list->string (list-update steps pos char-upcase))))))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291077,"user_id":null,"body":"#lang racket\n(provide wave)\n\n(define (wave str)\n  (if (= (string-length str) 0)\n      (list)\n      (filter (lambda (x) (> (string-length x) 0))\n              (build-list (string-length str) (lambda (i) (if (char-blank? (string-ref str i))\n                                                              \"\"\n                                                              (string-append\n                                                               (substring str 0 i)\n                                                               (make-string 1 (char-upcase (string-ref str i)))\n                                                               (substring str (+ i 1) (string-length str)))))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291078,"user_id":null,"body":"#lang racket\n\n(provide wave)\n\n(define (cap l pos)\n  (build-list\n   (length l)\n   (lambda (p)\n     (if (= p pos)\n         (integer->char (- (char->integer (list-ref l p)) 32))\n         (list-ref l p))\n     )\n   )\n  )\n\n(define (is-letter? chr)\n  (and (<= (char->integer chr) (char->integer #\\z))\n       (>= (char->integer chr) (char->integer #\\a))))\n\n(define (wave-nt lst pos hold)\n  (if (= (length lst) pos) hold\n      (if (is-letter? (list-ref lst pos))\n          (wave-nt lst (add1 pos) (append hold (list (list->string (cap lst pos)))))\n          (wave-nt lst (add1 pos) hold)))\n  )\n\n(define (wave crowd)\n  (wave-nt (string->list crowd) 0 (list))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291079,"user_id":null,"body":"#lang racket\n(provide wave)\n\n(define (wave crowd)\n  (filter (compose not (curry string=? crowd))\n          (map (lambda (x)\n                 (string-append\n                  (substring crowd 0 x)\n                  (string-upcase (substring crowd x (+ 1 x)))\n                  (substring crowd (+ x 1) (string-length crowd))))\n               (range (string-length crowd)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291080,"user_id":null,"body":"#lang racket\n(provide wave)\n\n(define (wave crowd)\n  (define (nth-to-uppercase n)\n  (string-join\n    (map\n     string\n     (map\n      (lambda (c k) (if (= n k) (char-upcase c) c))\n      (string->list crowd) (range 1 (add1 (string-length crowd)))))\n   \"\")\n  )\n  (filter (lambda (s) (not (string=? crowd s))) (map nth-to-uppercase (range 1 (add1 (string-length crowd))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5933a1f8552bc2750a0000ed":[{"id":291081,"user_id":1566,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n)\n  (- (* n 2) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291082,"user_id":null,"body":"#lang racket\n\n( provide nth_even )\n\n( define nth_even ( compose ( curryr - 2 ) ( curry * 2 ) ) )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291083,"user_id":null,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n)\n  (define (halve x)\n    (\/ x 2))\n  (define (double x)\n    (+ x x))  \n  (define (nthe result n)\n    (cond ((= n 0) result)\n          ((even? n) (double (nthe result (halve n))))\n          (else (+ 2 (nthe result (- n 1))))))\n  (nthe 0 (- n 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291084,"user_id":null,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n)  \n  (if (= n 1)\n    0\n    (* 2 (- n 1))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291085,"user_id":null,"body":"#lang racket\n\n(provide nth_even)\n\n;; Integer>0 -> Integer\n;; return the n-th even number\n;; ASSUME: the first even number is 0\n(define (nth_even n)\n  (* (sub1 n) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291086,"user_id":null,"body":"#lang racket\n\n(provide nth_even)\n\n(define nth_even (compose (curry * 2) sub1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291087,"user_id":null,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n)\n  (- (* 2 n) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291088,"user_id":527,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n)\n  (* 2 (sub1 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291089,"user_id":168,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n) (* 2 (- n 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291090,"user_id":645,"body":"#lang racket\n\n(provide nth_even)\n\n(define (nth_even n)\n  (* (- n 1) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59342039eb450e39970000a6":[{"id":291091,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n  (quotient n 2))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291092,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n  (\/ (- n (if (even? n) 0 1)) 2))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291093,"user_id":645,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n  (floor (\/ n 2)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291094,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n  (if (= 0 (modulo n 2))\n      (\/ n 2)\n      (floor (\/ n 2))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291095,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n    (if (= (remainder n 2) 1) (\/ (- n 1) 2) (\/ n 2)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291096,"user_id":544,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n  (\/ (- n (if (odd? n) 1 0)) 2))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291097,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n(define (odd_count n)\n  (if (even? n)\n      (\/ n 2)\n      (\/ (- n 1) 2)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291098,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n(define odd_count (\u03bb (x) (quotient x 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291099,"user_id":null,"body":"#lang racket\n\n(provide odd_count)\n\n;; 0<Integer -> Integer>=0\n;; return the number of positive odd numbers below n\n(define (odd_count n)\n  (quotient n 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5966ec8e62d030d8530000a7":[{"id":291100,"user_id":50,"body":"#lang racket\n(provide super_sum)\n\n(define (super_sum d n)\n  (quotient ( * d (- n 1) (expt n d)) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291101,"user_id":544,"body":"#lang racket\n(provide super_sum)\n\n;\n; if the indices range from 0 to n, the average index value is (n-1)\/2,\n; since there are d indices per cell, the sum of the indices for each cell will be d(n-1)\/2,\n; and there are n^d cells in the entire array\n; therefore, the sum of all the indices is the product d(n-1)n^d\/2\n;\n(define (super_sum d n)\n  (* 1\/2 d (- n 1) (expt n d)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291102,"user_id":544,"body":"#lang racket\n(provide super_sum)\n\n(define (super_sum d n)\n  (* 1\/2 d (- n 1) (expt n d)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291103,"user_id":168,"body":"#lang racket\n(provide super_sum)\n\n(define (super_sum d n)\n  (quotient (* d (expt n d) (sub1 n)) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291104,"user_id":527,"body":"#lang racket\n(provide super_sum)\n\n(define (super_sum d n)\n  (* (expt n d) d (sub1 n) 1\/2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291105,"user_id":null,"body":"#lang racket\n(provide super_sum)\n\n(define (super_sum d n)\n  (\/ (* (expt n d)\n        d\n        (- n 1))\n     2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59811fd8a070625d4c000013":[{"id":291106,"user_id":168,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (format \"~ax^~a\" (\/ c (add1 e)) (add1 e)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291107,"user_id":null,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (define ne (+ e 1))\n  (format \"~ax^~a\" (\/ c ne) ne))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291108,"user_id":null,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (~a (\/ c (add1 e)) \"x^\" (add1 e)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291109,"user_id":null,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (~a (\/ c (+ e 1)) \"x^\" (+ e 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291110,"user_id":null,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (let* ([e2 (+ e 1)]\n         [c2 (\/ c e2)])\n    (string-append (~a c2) \"x^\" (~a e2))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291111,"user_id":null,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (let ([new-e (add1 e)])\n    (string-append (number->string (\/ c new-e)) \"x^\" (number->string new-e))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291112,"user_id":null,"body":"#lang racket\n\n(provide integrate)\n\n(require racket\/format)\n\n(define (integrate c e)\n  (~a (\/ c (+ e 1))\n      \"x^\"\n      (+ e 1)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291113,"user_id":373,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (string-append (number->string (\/ c (+ e 1))) \"x^\" (number->string (+ e 1))))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291114,"user_id":53,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (let* ([b (+ 1 e)]\n         [a (quotient c b)])\n    (format \"~vx^~v\" a b)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291115,"user_id":544,"body":"#lang racket\n\n(provide integrate)\n\n(define (integrate c e)\n  (format \"~ax^~a\" (\/ c (+ e 1)) (+ e 1)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59bf943cafcda28e31000130":[{"id":291116,"user_id":492,"body":"#lang racket\n(provide around_fib)\n\n(define (around_fib n)\n  (define (fib n)\n    (if (zero? n)\n        (cons 0 1)\n        (let* ([u (fib (quotient n 2))]\n               [a (car u)]\n               [b (cdr u)]\n               [c (* a (- (* 2 b) a))]\n               [d (+ (* a a) (* b b))])\n          (if (zero? (remainder n 2))\n              (cons c d)\n              (cons d (+ c d))))))\n\n  (define (group-string-from-number nb k)\n    (define (group-list n xs)\n      (let loop ([grouped '()] [xs xs] [lg (length xs)])\n        (cond\n          [(empty? xs) (reverse grouped)]\n          [(<= lg n) (loop (cons xs grouped) '() 0)]\n          [else\n           (let-values ([(taken dropped) (split-at xs n)])\n             (loop (cons taken grouped) dropped (- lg n)))])))\n    (map list->string (group-list k (string->list (number->string nb)))))\n\n  (define (sort1 ls)\n    (sort ls (\u03bb(x y)\n               (let ([x1 (cdr x)]\n                     [y1 (cdr y)]\n                     [x2 (string (car x))]\n                     [y2 (string (car y))])\n                 (or (> x1 y1) (and (equal? x1 y1) (string<? x2 y2)))))))\n  \n  (define (char->num c)\n    (- (char->integer c) 48))\n  \n  (let* ([u (car (fib n))]\n         [ls (number->string u)]\n         [v (last (group-string-from-number u 25))]\n         [lss (group-by (\u03bb(x) x) (string->list ls))]\n         [cnt (map (lambda(x) (cons (car x) (length x))) lss)]\n         [f (first (sort1 cnt))])\n    (~a \"Last chunk \" v \"; Max is \" (~a (cdr f)) \" for digit \" (~a (char->num (car f))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291117,"user_id":null,"body":"#lang racket\n(provide around_fib)\n\n(define (around_fib n)\n  (define fib\n    (let ([memo (make-hash '((0 . 0) (1 . 1)))])\n      (\u03bb (n)\n        (when (not (hash-has-key? memo n))\n          (hash-set! memo n (+ (fib (sub1 n)) (fib (- n 2)))))\n        (hash-ref memo n))))\n  (define s (number->string (fib n)))\n  (define chunk (let-values ([(q r) (quotient\/remainder (string-length s) 25)])\n                  (substring s (* 25 (if (zero? r) (sub1 q) q))))) \n  (define most (car (sort (group-by identity (sort (string->list s) char<?))\n                          (\u03bb (a b) (> (length a) (length b))))))\n  (format \"Last chunk ~a; Max is ~a for digit ~a\" chunk (length most) (car most)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291118,"user_id":null,"body":"#lang racket\/base\n(require racket\/dict\n         racket\/string)\n\n(provide around_fib)\n\n(define (around_fib n)\n  (define fib (fib\/acc n 0 1))\n  (define fib-str (number->string fib))\n  \n  (define-values (max-digit max-count) (max-count-char fib-str))\n  (define last-chunk-str (last-chunk fib-str))\n  \n  (format \"Last chunk ~a; Max is ~a for digit ~a\"\n          last-chunk-str\n          max-count max-digit))\n\n(define (fib\/acc n acc0 acc1)\n  (cond\n    [(zero? n) acc0]\n    [else (fib\/acc (sub1 n) acc1 (+ acc0 acc1))]))\n    \n    \n(define (max-count-char str)\n  (define counts\n    (for\/fold ([acc '()])\n              ([char (in-string str)])\n      (dict-update acc char add1 0)))\n\n  (for\/fold ([max-char #f]\n             [max-count -1])\n            ([(char count) (in-dict (sort counts char<? #:key car))])\n    (if (> count max-count)\n        (values char count)\n        (values max-char max-count))))\n\n\n(define (last-chunk str)\n  (define str-len (string-length str))\n  (define last-chunk-len* (remainder str-len 25))\n  (define last-chunk-len (if (zero? last-chunk-len*) 25 last-chunk-len*))\n  (substring str (- str-len last-chunk-len) str-len))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291119,"user_id":242,"body":"#lang racket\n(provide around_fib)\n\n(define (fib n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= n 2) 1]\n    [(= n 3) 2]\n    [(= n 4) 3]\n    [(= n 5) 5]\n    [(= 0 (remainder n 5)) (let ((s (fib (quotient n 5))) (p (if (= 0 (remainder n 2)) 1 -1))) (+ (* 25 s s s s s) (* 25 p s s s) (* 5 s)) )]\n    [(= 0 (remainder n 3)) (let ((p (fib (+ 1 (quotient n 3)))) (q (fib (quotient n 3))) (r (fib (- (quotient n 3) 1))))  (+ (* p p p) (* q q q) (* -1 r r r)))]\n    [(= 0 (remainder n 2)) (let ((p (fib (+ 1 (quotient n 2)))) (r (fib (- (quotient n 2) 1)))) (- (* p p) (* r r)) )]\n    [else (let ((p (fib (+ 1 (quotient n 2)))) (r (fib (quotient n 2)))) (+ (* p p) (* r r)) )]\n  )\n)\n\n(define (last-25-chunk nmbr)\n  (let\n    (\n      (s (number->string nmbr))\n      (sl (string-length (number->string nmbr)))\n    )\n    (cond\n      [(= 0 sl) \"\"]\n      [(= 0 (remainder sl 25)) (substring s (- sl 25) sl)]\n      [else (substring s (* 25 (quotient sl 25)) sl)]\n    )\n  )\n)\n\n(define (most-frequent-digit n)\n  (define (most-frequent-char-iter str currd currn maxd maxn)\n    (cond\n      [(null? str)\n        (cond\n          [(<= currn maxn) (cons (list->string (list (integer->char maxd))) maxn)]\n          [else (cons (list->string (list (integer->char currd))) currn)]\n        )\n      ]\n      [(= (car str) currd) (most-frequent-char-iter (cdr str) currd (+ 1 currn) maxd maxn)]\n      [(<= currn maxn) (most-frequent-char-iter (cdr str) (car str) 1 maxd maxn)]\n      [else (most-frequent-char-iter (cdr str) (car str) 1 currd currn)]\n    )\n  )\n  (let\n    ((str (sort (map char->integer (string->list (number->string n))) <) ))\n    (cond\n      [(= 0 (length str)) (cons 0 0)]\n      [else (most-frequent-char-iter (cdr str) (car str) 1 (car str) 1)]\n    )\n  )\n)\n\n(define (around_fib n)\n  (let\n    (\n      (f (fib n))\n    )\n    (let\n      (\n        (p (most-frequent-digit f))\n        (q (last-25-chunk f))\n      )\n      (~a \"Last chunk \" q \"; Max is \" (cdr p) \" for digit \" (car p) )\n    )\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291120,"user_id":null,"body":"#lang racket\n(provide around_fib)\n\n(define (fib n)\n  (let loop ([a 0]\n             [b 1]\n             [i 0])\n    (cond\n      [(= i n) a]\n      [else (loop b (+ a b) (add1 i))])))\n\n(define (around_fib n)\n  (let* ([f (fib n)]\n         [flist (string->list (~a f))]\n         [len (length flist)]\n         [mod (modulo len 25)]\n         [start (if (= 0 mod)\n                    (- len 25)\n                    (- len mod))]\n         [freq (list-ref (sort (group-by identity flist)\n                               (lambda (x y)\n                                 (or (> (length x)\n                                        (length y))\n                                      (and (= (length x)\n                                              (length y))\n                                         (< (char->integer (car x))\n                                            (char->integer (car y)))))))\n                         0)]\n         [lfreq (length freq)]\n         [p (list-ref freq 0)])\n    (format \"Last chunk ~a; Max is ~a for digit ~a\"\n            (list->string (list-tail flist start))\n            lfreq\n            p)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59c68ea2aeb2843e18000109":[{"id":291121,"user_id":544,"body":"#lang racket\n(provide amort)\n\n(define (amort rate balance term num-payments)\n  (define period-rate (\/ rate 12. 100))\n  (define fixed-payment (\/ (* period-rate balance) \n                           (- 1 (expt (+ 1 period-rate) (- term)))))\n  (for\/fold ([current-payment-num 0] ; define the accumulators\n             [paid-to-principal 0]\n             [interest-on-balance 0]\n             [running-balance balance]\n             ; generate a list of values in the right order\n             ; so they can just be fed directly into format\n             #:result (formatted-output\n                       (map exact-round (list current-payment-num\n                                              fixed-payment \n                                              paid-to-principal \n                                              interest-on-balance \n                                              running-balance))))\n            ([current-payment (in-range 1 (add1 num-payments))])\n    (let* ([int (* period-rate running-balance)] ; calculate the interest on the remaining balance,\n           [princ (- fixed-payment int)] ; pay off the interest,\n           [bal (- running-balance princ)]) ; and use the rest to pay down the principal\n      (values current-payment princ int bal)))) ; assign corresponding values to accumulators\n\n(define (formatted-output lst)\n  (apply format \"num_payment ~A c ~A princ ~A int ~A balance ~A\" lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291122,"user_id":168,"body":"#lang racket\n(provide amort)\n\n(define (amort rate balance term n)\n  (let* ([r (\/ rate 1200)]\n         [d (- 1 (expt (add1 r) (- term)))]\n         [c (\/ (* r balance) d)]\n         [rt (expt (add1 r) (sub1 n))]\n         [int (- (* rt balance r) (* c (sub1 rt)))]\n         [princ (- c int)]\n         [rt2 (expt (add1 r) n)]\n         [b (- (* rt2 balance) (\/ (* c (sub1 rt2)) r))])\n    (format \"num_payment ~a c ~a princ ~a int ~a balance ~a\"\n            n\n            (exact-round c)\n            (exact-round princ)\n            (exact-round int)\n            (exact-round b)))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291123,"user_id":492,"body":"#lang racket\n(provide amort)\n\n(define (amort rate balance term num-payments)\n  (define (fmt msg f)\n    (string-append msg (~r f #:precision 0)))\n  \n  (define (loop payment r i interest principal bal)\n      (if (>= i num-payments)\n        (string-append (fmt \"num_payment \" i)\n                       (fmt \" c \" payment)\n                       (fmt \" princ \" principal)\n                       (fmt \" int \" interest)\n                       (fmt \" balance \" bal))\n        (let* ([ir (* bal r)]\n               [p (- payment ir)]\n               [b (- bal p)])\n          (loop payment r (add1 i) ir p b)))) \n  (let* ([r (\/ rate 1200.0)]\n         [payment (\/ (* r balance) (- 1.0 (expt (+ 1.0 r)(- term))))])\n    (loop payment r 0 0.0 0.0 balance)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59ccf051dcc4050f7800008f":[{"id":291124,"user_id":null,"body":"#lang racket\n(provide buddy)\n\n(define (memoize f)\n  (define storage (make-hash))\n  (lambda x\n    (cond [(hash-ref storage x #f) => identity]\n          [else (define result (apply f x))\n                (hash-set! storage x result)\n                result])))\n\n(define (naive-sum-divisors-minus-one m)\n  (for\/sum ([i (in-range 2 (sqrt m))]\n            #:when (= (modulo m i) 0))\n    (+ i (quotient m i))))\n\n(define sum-divisors-minus-one (memoize naive-sum-divisors-minus-one))\n\n(define (buddy start nd)\n  (or\n   (for\/first ([n (in-range start (add1 nd))]\n               #:when (and (< n (sum-divisors-minus-one n))\n                           (= (sum-divisors-minus-one\n                               (sum-divisors-minus-one n))\n                              n)))\n     (format \"(~a ~a)\" n (sum-divisors-minus-one n)))\n   \"Nothing\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:19"},{"id":291125,"user_id":544,"body":"#lang racket\n(provide buddy)\n\n(define (sum-factors n)\n  (for\/sum ([i (in-range 2 (add1 (floor (sqrt n))))] #:when (= 0 (modulo n i)))\n    (let ([j (\/ n i)])\n      (if (= i j)\n          i\n          (+ i j)))))\n\n(define (buddy start end)\n  (define buddies\n    (for\/first ([n (in-range start (add1 end))]\n              #:when (let [(m (sum-factors n))]\n                       (and (n . < . m)\n                            (= (sum-factors m) n))))\n    (~a n \" \" (sum-factors n))))\n  (if buddies buddies \"Nothing\"))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:44:38"},{"id":291126,"user_id":492,"body":"#lang racket\n(provide buddy)\n\n(define (buddy start nd)\n  (define (sum-divisors n)\n    (for\/sum [(d (range 2 (add1 (integer-sqrt n))))]\n      (if (zero? (remainder n d)) \n          (+ d (if (= (\/ n d) d) 0 (\/ n d)))\n          0)))\n  (if (> start nd) \n      \"Nothing\"\n      (let [(t (sum-divisors start))]\n        (if (and (> t start) (= (sum-divisors t) start))\n            (format \"(~a ~a)\" start t)\n            (buddy (add1 start) nd)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:22"},{"id":291127,"user_id":168,"body":"#lang racket\n(provide buddy)\n\n(define (sum-divs n)\n  (for\/sum [(d (range 2 (add1 (integer-sqrt n))))]\n    (if (zero? (remainder n d)) \n        (+ d (if (= (\/ n d) d) 0 (\/ n d)))\n        0)))\n\n(define (buddy start nd)\n  (if (> start nd) \n      \"Nothing\"\n      (let [(t (sum-divs start))]\n        (if (and (> t start) (= (sum-divs t) start))\n            (format \"(~a ~a)\" start t)\n            (buddy (add1 start) nd)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:29"},{"id":291128,"user_id":null,"body":"#lang racket\n(provide buddy)\n\n(module+ test\n  (require rackunit))\n\n;; Integer>0 -> (Listof Integer)\n;; return divisors of n other than n itself\n(define (proper-divisors n)\n  (cons\n   1\n   (sort\n    (flatten\n     (for\/list ([d (in-range 2 (add1 (sqrt n)))]\n                #:when (= 0 (remainder n d)))\n       (cons d (\/ n d))))\n    <)))\n\n(module+ test\n  (check-equal? (proper-divisors 100) '(1 2 4 5 10 10 20 25 50)))\n\n\n;; Integer>0 Integer>0 -> String\n;; given two positive integers start and limit, the function buddy(start, limit)\n;; should return the first pair (n m) of buddy pairs such that n is between start\n;; (incl) and limit (incl); m can be greater than limit and has to be greater than\n;; n. If there is no buddy pair satisfying the conditions, return \"Nothing\"\n(define (buddy start nd)\n  (define (loop n)\n    (define m (sub1 (foldl + 0 (proper-divisors n))))\n    (cond\n      [(= n nd) \"Nothing\"]\n      [(and (> m n) (= (add1 n) (foldl + 0 (proper-divisors m))))\n       (format \"(~a ~a)\" n m)]\n      [else (loop (add1 n))]))\n  (loop start))\n\n(module+ test\n  (check-equal? (buddy 10 50) \"48 75\")\n  (check-equal? (buddy 48 50) \"48 75\")\n  (check-equal? (buddy 1071625 1103735) \"1081184 1331967\")\n  (check-equal? (buddy 57345 90061) \"62744 75495\")\n  (check-equal? (buddy 6379 8275) \"Nothing\")\n  (check-equal? (buddy 195 1100) \"320 441\"))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:33"},{"id":291129,"user_id":null,"body":"#lang racket\n(provide buddy)\n\n(module+ test\n  (require rackunit))\n\n;; Integer>0 -> (Listof Integer)\n;; return divisors of n other than n itself\n(define (proper-divisors n)\n  (cons\n   1\n   (sort\n    (flatten\n     (for\/list ([d (in-range 2 (add1 (sqrt n)))]\n                #:when (= 0 (remainder n d)))\n       (if (= (* d d) n)\n           d\n          (cons d (\/ n d)))))\n    <)))\n\n(module+ test\n  (check-equal? (proper-divisors 100) '(1 2 4 5 10 20 25 50)))\n\n\n;; Integer>0 Integer>0 -> String\n;; given two positive integers start and limit, the function buddy(start, limit)\n;; should return the first pair (n m) of buddy pairs such that n is between start\n;; (incl) and limit (incl); m can be greater than limit and has to be greater than\n;; n. If there is no buddy pair satisfying the conditions, return \"Nothing\"\n(define (buddy start nd)\n  (define (loop n)\n    (define m (sub1 (foldl + 0 (proper-divisors n))))\n    (cond\n      [(= n nd) \"Nothing\"]\n      [(and (> m n) (= (add1 n) (foldl + 0 (proper-divisors m))))\n       (format \"(~a ~a)\" n m)]\n      [else (loop (add1 n))]))\n  (loop start))\n\n(module+ test\n  (check-equal? (buddy 10 50) \"48 75\")\n  (check-equal? (buddy 48 50) \"48 75\")\n  (check-equal? (buddy 1071625 1103735) \"1081184 1331967\")\n  (check-equal? (buddy 57345 90061) \"62744 75495\")\n  (check-equal? (buddy 6379 8275) \"Nothing\"))\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:15"},{"id":291130,"user_id":242,"body":"#lang racket\n(provide buddy)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (merge l1 l2)\n  (define (merge-iter l1n l2n acc)\n    (cond\n      [(and (null? l1n) (null? l2n)) acc]\n      [(null? l1n) (merge-iter `() (cdr l2n) (cons (car l2n) acc))]\n      [(null? l2n) (merge-iter (cdr l1n) `() (cons (car l1n) acc))]\n      [else (merge-iter (cdr l1n) l2n (cons (car l1n) acc))]\n    )\n  )\n  (reverse (merge-iter l1 l2 `()))\n)\n\n(define (filter pred items)\n  (define (filter-iter itemsn acc)\n    (cond\n      [(null? itemsn) acc]\n      [(pred (car itemsn)) (filter-iter (cdr itemsn) (cons (car itemsn) acc))]\n      [else (filter-iter (cdr itemsn) acc)]\n    )\n  )\n  (reverse (filter-iter items `()))\n)\n\n(define (removeduplicatessortedlst lst)\n  (define (removeduplicatessortedlstiter lst acc curr)\n    (cond\n      [(null? lst) acc]\n      [(= curr (car lst)) (removeduplicatessortedlstiter (cdr lst) acc curr)]\n      [else (removeduplicatessortedlstiter (cdr lst) (cons (car lst) acc) (car lst))]\n    )\n  )\n  (reverse (removeduplicatessortedlstiter lst `() (- (car lst) 1)))\n)\n\n(define (sum-of-proper-divisors n)\n  (define (get-next-divisor-iter nn start)\n    (cond\n      [(< nn start) 0]\n      [(< nn (* start start)) nn]\n      [(= 0 (remainder nn start)) start]\n      [else (get-next-divisor-iter nn (+ 1 start))]\n    )\n  )\n  (define (list-of-prime-divisors-iter nn curr acc)\n    (let\n      ((f (get-next-divisor-iter nn curr)))\n      (cond\n        [(= f 0) acc]\n        [else (list-of-prime-divisors-iter (quotient nn f) f (cons f acc))]\n      )\n    )\n  )\n  (define (sum-of-divisors-iter nn lst mult)\n    (cond\n      [(null? lst) (list mult)]\n      [(pair? lst) (merge (sum-of-divisors-iter nn (cdr lst) mult) (sum-of-divisors-iter nn (cdr lst) (* mult (car lst))))]\n      [(list? lst) (merge mult (* mult (car lst)))]\n      [(number? lst) (merge mult (* mult lst))]\n    )\n  )\n  (accumulate + (- 0 n) (removeduplicatessortedlst (sort (sum-of-divisors-iter n (list-of-prime-divisors-iter n 2 `()) 1) <)))\n)\n\n(define (in-list lst elem)\n  (cond\n    [(null? lst) #f]\n    [(not (pair? lst)) (in-list (cons lst `()) elem)]\n    [(= (car lst) elem) #t]\n    [else (in-list (cdr lst) elem)]\n  )\n)\n\n(define (buddy start end)\n  (define (buddy-iter ed curr acc)\n    (let\n      ((buddy-curr (sum-of-proper-divisors curr)))\n      (cond\n        [(< ed curr) \"Nothing\"]\n        [(in-list acc (+ 1 curr)) (buddy-iter ed (+ 1 curr) acc)]\n        [(= (+ curr 1) (sum-of-proper-divisors (- buddy-curr 1)))\n          (cond\n            [(<= curr buddy-curr) (~a curr \" \" (- buddy-curr 1))]\n            [(<= start buddy-curr) (~a (- buddy-curr 1) \" \" curr)]\n            [else (buddy-iter ed (+ 1 curr) (cons buddy-curr acc))]\n          )\n        ]\n        [else (buddy-iter ed (+ 1 curr) (cons buddy-curr acc))]\n      )\n    )\n  )\n  (buddy-iter end start `())\n)","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:44:38"},{"id":291131,"user_id":null,"body":"#lang racket\n(provide buddy)\n\n(define (s number)\n  ;;Generate sum of proper divisions\n  (- (for\/sum ([i (in-range 1 (+ 1 (floor (sqrt number))))])\n    (if (= 0 (remainder number i))\n        (+ i (\/ number i))\n        0)) number))\n(define s-hash (make-hash))\n(define (opt-s number)\n  (let ([result (hash-ref s-hash number #f)])\n    (if result result\n        (begin (hash-set! s-hash number (s number))\n               (hash-ref s-hash number)))))\n(define (buddy start end)\n  (define r (for\/first\n                ([i (in-range start (+ end 1))]\n                 #:when (let ([m (- (opt-s i) 1)])\n                          (and (> m i)\n                               (= (opt-s m) (+ i 1)))\n                           ))\n              (cons i (- (opt-s i) 1))\n              ))\n  (if r (format \"(~a ~a)\" (car r) (cdr r))\n      \"Nothing\"\n      ))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:15"},{"id":291132,"user_id":null,"body":"#lang racket\n(provide buddy)\n\n(define (buddy start nd)\n  (let ([ans (buddy* start nd)])\n    (if ans\n        (format \"(~a ~a)\" (car ans) (cadr ans))\n        \"Nothing\")))\n\n(define (buddy* start nd)\n  (cond\n   [(> start nd) #f]\n   [else \n    (define sum-n (sum-of-proper-divisors\/memo start))\n    (define m (sub1 sum-n))\n    (cond\n      [(and (< start m)\n            (= (sum-of-proper-divisors\/memo m)\n               (add1 start)))\n       (list start m)]\n      [else (buddy* (add1 start) nd)])]))\n     \n(define (sum-of-proper-divisors n)\n  (for\/fold ([sum 1])\n            ([i (in-range 2 (add1 (floor (sqrt n))))])\n    (define-values (q r) (quotient\/remainder n i))\n    (if (zero? r) \n        (+ sum i q) \n        sum)))\n\n(define sum-of-proper-divisors\/memo\n  (let ([memo (make-hash)])\n    (lambda (n)\n      (or (hash-ref memo n #f)\n          (let ([res (sum-of-proper-divisors n)])\n            (hash-set! memo n res)\n            res)))))         ","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:45:15"},{"id":291133,"user_id":492,"body":"#lang racket\n(provide buddy)\n\n(define (buddy start nd)\n  (define (sum-divisors n)\n   (let* ([d (filter (lambda (d) (= 0 (modulo n d))) (range 2 (add1 (sqrt n))))]\n          [e (map (lambda (x) (quotient n x)) d)])\n    (apply + (append '(1) d e))))\n  (define (get-buddy n)\n    (let ([budd (sub1 (sum-divisors n))])\n      (if (= (sub1 (sum-divisors budd)) n)\n          budd\n          -1)))\n  (define (list->string ls)\n    (string-join (map ~a ls) \" \"))\n  \n  (define (loop n fin res)\n    (if (> n nd)\n      \"Nothing\"\n      (if (equal? fin true)\n        res\n        (let ([m (get-buddy n)])\n          (if (and (not (= m -1)) (< n m))\n            (loop n true (list->string (list n m)))\n            (loop (add1 n) false \"\"))))))\n  (loop start false \"\"))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-12 12:44:38"}],"59cfc000aeb2844d16000075":[{"id":291134,"user_id":564,"body":"#lang racket\n\n(provide capitalize)\n\n(define (map-indexed ci->c seq)\n  (sequence-map ci->c (in-indexed seq)))\n\n(define (map-indexed-chars ci->c str)\n  (sequence-fold string-append \"\"\n    (sequence-map string\n      (map-indexed ci->c str))))\n\n(define (capitalize str)\n  (define (alt-case upcase-cond)\n    (map-indexed-chars\n      (lambda (char index)\n        (if (upcase-cond index)\n          (char-upcase char)\n          (char-downcase char)))\n      str))\n  (list (alt-case even?) (alt-case odd?)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:54"},{"id":291135,"user_id":null,"body":"#lang racket\n\n(provide capitalize)\n\n(define (capitalize string cmp)     \n    (for\/list ((c (in-string string)) \n                 (i (in-naturals)))\n        (if (cmp i) (char-downcase c) (char-upcase c))))\n\n(define (capitalize s)\n    (map list->string\n        (list (capitalize s odd?) (capitalize s even?))))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 16:00:00"},{"id":291136,"user_id":null,"body":"#lang racket\n\n(provide capitalize)\n\n(define (capitalize s)\n  (define n (string-length s))\n  (define capital-first (build-string n (lambda (i) (if (even? i) (char-upcase (string-ref s i)) (char-downcase (string-ref s i))))))\n  (define lower-first (build-string n (lambda (i) (if (odd? i) (char-upcase (string-ref s i)) (char-downcase (string-ref s i))))))\n  (list capital-first lower-first))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 16:00:03"},{"id":291137,"user_id":null,"body":"#lang racket\n\n(provide capitalize)\n\n(define (capitalize s)\n (list (build-string (string-length s) (lambda (int) (if (even?  int) (char-upcase (string-ref s int)) (char-downcase (string-ref s int)))))\n       (build-string (string-length s) (lambda (int) (if (odd?  int) (char-upcase (string-ref s int)) (char-downcase (string-ref s int)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"},{"id":291138,"user_id":null,"body":"#lang racket\n\n(provide (rename-out [alt-cap capitalize]))\n\n(define (alt-cap s)\n  (list (fence-cap s) (fence-cap s #f)))\n\n(define (fence-cap s [start-from-first #t])\n  (list->string\n   (for\/list ([i (in-naturals)]\n              #:break (>= i (string-length s)))\n     ((if ((if start-from-first even? odd?) i) char-upcase char-downcase) (string-ref s i)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"},{"id":291139,"user_id":null,"body":"#lang racket\n\n(provide capitalize)\n\n(define (capitalize str from)\n  (cond\n   ((>= from (string-length str)) str)\n   (else (string-set! str from (char-upcase (string-ref str from)))\n         (capitalize str (+ from 2)))))\n\n\n(define (capitalize s)\n  (define str (string-downcase s))\n  (list (capitalize (string-copy str) 0) (capitalize (string-copy str) 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"},{"id":291140,"user_id":null,"body":"#lang racket\n\n(provide capitalize)\n\n;; String -> (List String String)\n;; given a lowercase string, return a list with two modified strings:\n;; 1. with all even chars capitalized, 2. with all odd chars capitalized\n(define (capitalize s)\n  (define str (string-downcase s))\n  (list (upcase-chars-when str even?) (upcase-chars-when str odd?)))\n\n;; String (Integer -> Boolean) -> String\n;; given a string, upcase chars for indexes of which `pred` returns #t\n(define (upcase-chars-when s pred)\n  (list->string\n   (for\/list ([c (in-string s)]\n              [i (in-range (string-length s))])\n     (if (pred i)\n         (char-upcase c)\n         c))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"},{"id":291141,"user_id":168,"body":"#lang racket\n\n(provide capitalize)\n\n(define (capitalize s)\n  (for\/fold ([a '()] [b '()] #:result (map (compose list->string reverse) `(,a ,b)))\n            ([c (string-downcase s)] [i (in-naturals)])\n    (if (even? i)\n        (values (cons (char-upcase c) a) (cons c b))\n        (values (cons c a) (cons (char-upcase c) b)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"},{"id":291142,"user_id":null,"body":"#lang racket\n\n(provide capitalize)\n\n(define (capitalize s)\n  (list\n    (list->string\n      (for\/list ([i (in-range 0 (string-length s))])\n          (if (= (modulo i 2) 0)\n              (char-upcase (string-ref s i))\n              (char-downcase (string-ref s i)))))\n   (list->string\n      (for\/list ([i (in-range 0 (string-length s))])\n          (if (= (modulo i 2) 0)\n              (char-downcase (string-ref s i))\n              (char-upcase (string-ref s i)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"},{"id":291143,"user_id":null,"body":"#lang racket\n\n(#%require srfi\/13)\n(provide capitalize)\n\n(define (capitalize s)\n  (define (make upper-start)\n    (let* ((len (string-length s))\n           (ret (make-string len)))\n      (string-for-each-index\n        (lambda (i)\n          (let* ((f (if upper-start even? odd?))\n                 (char-case (if (f i) char-upcase char-downcase)))\n            (string-set! ret i (char-case (string-ref s i)))))\n        s)\n      ret))\n  (list (make #t) (make #f)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2023-01-06 15:59:51"}],"59d0ee709f0cbcf65400003b":[{"id":291144,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide by-state)\n\n(define STATES\n  (hash \"AZ\" \"Arizona\"\n        \"CA\" \"California\"\n        \"ID\" \"Idaho\"\n        \"IN\" \"Indiana\"\n        \"MA\" \"Massachusetts\"\n        \"OK\" \"Oklahoma\"\n        \"PA\" \"Pennsylvania\"\n        \"VA\" \"Virginia\"))\n\n\n(struct record (name hs city state) #:transparent)\n;; A Record is (r String String String String)\n;; interp. a (name house&street city state) in the list of friends to visit\n\n(define R-1 (record \"John Daggett\" \"341 King Road\" \"Plymouth\" \"MA\"))\n(define R-2 (record \"Alice Ford\" \"22 East Broadway\" \"Richmond\" \"VA\"))\n(define R-3 (record \"Hubert Sims\" \"328A Brook Road\" \"Roanoke\" \"VA\"))\n\n\n;; A Book is a Hash that maps String to (Listof Record)\n;; interp. for each state, shows the friends you can visit there\n\n(define B-1 (make-hash (list (cons \"MA\" (list R-1))\n                             (cons \"VA\" (list R-2 R-3))))) \n\n\n;; String -> String\n;; given a string with friends to visit in different states, produce a result\n;; that sorts the names by state and lists the name of the state followed by\n;; the name of each person residing in that state (people's names sorted)\n(define (by-state str)\n  (format-book (parse-book str)))\n \n\n;; String -> Record\n;; parse a raw record\n(define (parse-record r)\n  (let*-values ([(name hs cs) (apply values (string-split r \",\"))]\n                [(city state) (let ([chunks (string-split cs)])\n                                (values (string-join (drop-right chunks 1))\n                                        (last chunks)))])\n    (apply record (map string-trim (list name hs city state)))))\n\n(module+ test\n  (check-equal? (parse-record \"John Daggett, 341 King Road, Plymouth MA\") R-1))\n\n\n;; String -> Book\n;; parse a raw book\n(define (parse-book b)\n\n  (begin\n    (define res (make-hash))\n    (for ([r (for\/list ([l (in-lines (open-input-string b))]\n                              #:when (not (equal? \"\" (string-trim l))))\n                     (parse-record l))])\n      (let ([s (record-state r)])\n        (hash-set! res s\n                   (append (hash-ref res s '()) (list r)))))\n    res))\n\n(module+ test\n  (check-equal? (parse-book (string-append\n                             \"John Daggett, 341 King Road, Plymouth MA\n\"\n                             \"Alice Ford, 22 East Broadway, Richmond VA\n\"\n                             \"Hubert Sims, 328A Brook Road, Roanoke VA\n\n\"))\n                B-1))\n\n\n;; Record -> String\n;; convert `r` into a string as expected by the `by-state` func\n(define (format-record r)\n  (format \"..... ~a ~a ~a ~a\" (record-name r) (record-hs r) (record-city r)\n          (hash-ref STATES (record-state r))))\n\n(module+ test\n  (check-equal? (format-record R-1)\n                \"..... John Daggett 341 King Road Plymouth Massachusetts\"))\n\n\n;; Book -> String\n;; convert `b` into a string as expected by the `by-state` func\n(define (format-book b)\n  (string-join\n  (for\/list ([s (sort (hash-keys b) string<=?)])\n    (format\n     \"~a\n~a\"\n     (hash-ref STATES s)\n     (string-join\n      (for\/list ([r (sort (hash-ref b s)\n                          (\u03bb (x y) (string<=? (record-name x)\n                                              (record-name y))))])\n        (format-record r))\n      \"\n\")))\n  \"\n \"))\n\n(module+ test\n  (check-equal?\n   (format-book B-1)\n   (string-append \"Massachusetts\n\"\n                  \"..... John Daggett 341 King Road Plymouth Massachusetts\n\"\n                  \"Virginia\n\"\n                  \"..... Alice Ford 22 East Broadway Richmond Virginia\n\"\n                  \"..... Hubert Sims 328A Brook Road Roanoke Virginia\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291145,"user_id":544,"body":"#lang racket\n(provide by-state)\n\n(define abbreviations\n  (hash\n   \"AZ\" \"Arizona\"\n   \"CA\" \"California\"\n   \"ID\" \"Idaho\"\n   \"IN\" \"Indiana\"\n   \"MA\" \"Massachusetts\"\n   \"OK\" \"Oklahoma\"\n   \"PA\" \"Pennsylvania\"\n   \"VA\" \"Virginia\"))\n\n(define (address-state line)\n  (substring line (- (string-length line) 2) (string-length line)))\n\n(define (same-state? line1 line2)\n  (equal? (address-state line1) (address-state line2)))\n\n(define (names-only<? line1 line2)\n  (define (name line)\n    (string-join (take (string-split line) 2) \" \"))\n  (cond [(equal? (name line1) (name line2)) #true]\n        [else (string<? (name line1) (name line2))]))\n\n(define (by-state strng)\n  (define state-groups\n    (group-by identity (string-split (string-replace strng \",\" \"\") \"\n\") same-state?))\n  (define state-list\n    (map (\u03bb (address)\n           (hash-ref abbreviations (address-state (first address))))\n         state-groups))\n  (define formatted-state-lists\n    (for\/list ([group (in-list state-groups)]\n               [state (in-list state-list)])\n      (define sorted-addresses (sort group names-only<?))\n      (string-join\n       (list* state\n              (for\/list ([address (in-list sorted-addresses)])\n                (string-replace address\n                                (address-state address)\n                                (hash-ref abbreviations (address-state address)))))\n       \"\n..... \")))\n  (string-join (sort formatted-state-lists string<?) \"\n \"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291146,"user_id":492,"body":"#lang racket\n(provide by-state)\n\n(define (by-state strng)\n  (define (classify strng)\n    (define (subst strng)\n      (define sa '(\" MA\" \" VA\" \" OK\" \" PA\" \" CA\" \" AZ\" \" ID\" \" IN\"))\n      (define st '(\", Massachusetts\" \", Virginia\" \", Oklahoma\" \", Pennsylvania\" \", California\" \", Arizona\" \", Idaho\" \", Indiana\"))\n      (let loop ([i 0] [r strng])\n        (if (= i (length sa))\n            r\n            (loop (add1 i) (regexp-replace* (regexp (list-ref sa i)) r (list-ref st i))))))\n\n    (let ([arr (string-split (subst strng) \"\n\")])\n      (let loop([i 0] [narr '()])\n        (if (= i (length arr))\n            narr\n            (let* ([line (string-split (list-ref arr i) \",\")]\n                   [nlin (list\n                          (string-trim (list-ref line 3))\n                          (string-trim (list-ref line 0))\n                          (string-append (string-trim (list-ref line 1)) \" \" (string-trim (list-ref line 2))))])\n              (loop (add1 i) (cons nlin narr)))))))\n\n  (define (compsort a b)\n    (if (equal? (list-ref a 0) (list-ref b 0))\n        (string<? (list-ref a 1) (list-ref b 1))\n        (string<? (list-ref a 0) (list-ref b 0))))\n\n  (let ([narr (sort (classify strng) compsort)])   \n    (let loop ([i 0] [res \"\"] [last \"\"])\n      (if (= i (length narr))\n          (substring res 2)\n          (let* ([line (list-ref narr i)][l0 (list-ref line 0)])\n            (if (not (equal? last l0))\n                (loop (add1 i) (string-append res \"\n \" l0 \"\n..... \" (list-ref line 1) \" \" (list-ref line 2) \" \" l0) l0)\n                (loop (add1 i) (string-append res \"\n..... \" (list-ref line 1) \" \" (list-ref line 2) \" \" l0) l0)))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59d727d40e8c9dd2dd00009f":[{"id":291147,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide balance)\n\n(struct check (number category amount) #:transparent)\n;; A Check is (check String String Decimal)\n;; interp. a check in a checkbook, self-explanatory fields\n\n(define C-1 (check \"125\" \"Market\" 125.45))\n(define C-2 (check \"126\" \"Hardware\" 34.95))\n(define C-3 (check \"127\" \"Video\" 7.45))\n(define C-4 (check \"128\" \"Book\" 14.32))\n(define C-5 (check \"129\" \"Gasoline\" 16.10))\n(define C-6 (check \"002\" \"Gasoline\" 16.10))\n\n\n(struct checkbook (origbalance checks totalexpense avrgexpense) #:transparent)\n;; A Checkbook is (checkbook Decimal (Listof (Pair Check Decimal) Decimal\n;;                                                                Decimal)\n;; interp. a checkbook consisting of:\n;; - original balance\n;; - list of expences\/checks occured paired with the balance after paying them\n;; - total expense\n;; - average expense\n\n(define CB-1\n  (checkbook 1000.00\n             (list (cons C-1 874.55)\n                   (cons C-2 839.60)\n                   (cons C-3 832.15)\n                   (cons C-4 817.83)\n                   (cons C-5 801.73))\n             198.27\n             39.65))\n\n\n;; A CheckbookString is a String\n;; interp. contains all info a Checkbook would (well, excep balances after\n;; paying a check), but possibly in a messier way.\n;; Anything that is not either an alphanumeric char, or space, or dot\n;; will be removed when parsing.\n\n\n;; CheckbookString -> Checkbook\n(define (parse-checkbook-string checkbook-string)\n\n  (define (strip-mess s)\n    (list->string\n     (for\/list ([c (in-string s)]\n                #:when (or\n                        (set-member? (set #\\. #\\space) c)\n                        (char-alphabetic? c)\n                        (regexp-match? #rx\"[0-9]\" (string c))))\n       c)))\n\n  (define (parse-check-string check-string)\n    (match (string-split check-string)\n      [(list num cat amount)\n       (check num cat (string->number amount))]))\n\n  (define (round-to n decimal-places)\n    (define m (expt 10 decimal-places))\n    (\/ (round (* n m)) m))\n\n  ;; Decimal (Listof Check) -> (Listof (Pair Check Decimal))\n  (define (append-curbalance origbalance checks)\n    (if (empty? checks)\n        '()\n        (let* ([f (first checks)]\n               [r (rest checks)]\n               [curbalance (- origbalance (check-amount f))])\n          (cons (cons f curbalance) (append-curbalance curbalance r)))))\n\n  (let* ([checkbook-list\n          (for\/list ([l (in-lines (open-input-string checkbook-string))])\n            (strip-mess l))]\n         [original-balance (string->number (first checkbook-list))]\n         [checks (map parse-check-string (rest checkbook-list))]\n         [total-expense (foldl + 0 (map check-amount checks))]\n         [avg-expense (\/ total-expense (length checks))])\n    (checkbook original-balance\n               (append-curbalance original-balance checks)\n               total-expense\n               avg-expense)))\n\n(define (format-checkbook cb)\n\n  ;; Number -> String\n  (define (rto-2 n)\n    (~r n #:precision '(= 2)))\n  \n  (format\n   (string-append\n    \"Original Balance: ~a\n\"\n    \"~a\n\"\n    \"Total expense  ~a\n\"\n    \"Average expense  ~a\")\n   (~r (checkbook-origbalance cb) #:precision '(= 2))\n   (string-join (map (\u03bb (x) (let* ([c (car x)]\n                                   [num (check-number c)]\n                                   [cat (check-category c)]\n                                   [am (check-amount c)]\n                                   [curbal (cdr x)])\n                              (format \"~a ~a ~a Balance ~a\"\n                                      num cat (rto-2 am) (rto-2 curbal))))\n                     (checkbook-checks cb))\n                \"\n\")\n   (~r (checkbook-totalexpense cb) #:precision '(= 2))\n   (~r (checkbook-avrgexpense cb) #:precision '(= 2))))\n\n(define (balance raw-book)\n  (format-checkbook (parse-checkbook-string raw-book)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291148,"user_id":544,"body":"#lang racket\n(provide balance)\n\n(define (balance book)\n  (define check-lines (string-split book \"\n\"))\n  (define check-lines-clean\n    (map (curryr string-replace #px\"[^0-9A-Za-z\\\\.\\\\s]\" \"\") check-lines))\n  (define original-balance (string->number (car check-lines-clean)))\n  (define transactions\n    (map string-split (cdr check-lines-clean)))\n  (define transactions-with-balance\n    (for\/fold ([running-balance original-balance]\n               [formatted-transactions '()]\n               #:result formatted-transactions)\n              ([t transactions])\n      (let* ([expense (string->number (third t))]\n             [new-balance (- running-balance expense)]\n             [transaction-line\n              (apply format \"~a ~a ~a Balance ~a\"\n                     (flatten (list t (real->decimal-string new-balance))))])\n        (values new-balance\n                (append formatted-transactions `(,transaction-line))))))\n  (define total-expense\n    (apply + (map (compose string->number third) transactions)))\n  (define average-expense (\/ total-expense (length transactions)))\n  (string-join\n   (flatten (list (format \"Original Balance: ~a\" (real->decimal-string original-balance))\n                  transactions-with-balance\n                  (format \"Total expense  ~a\" (real->decimal-string total-expense))\n                  (format \"Average expense  ~a\" (real->decimal-string average-expense))))\n   \"\n\"\n   ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291149,"user_id":492,"body":"#lang racket\n(provide balance)\n\n(define (balance book)\n  (let* ([clean (regexp-replace* #px\"[^0-9a-z[:blank:]+A-Z\n.]\" book \"\")]\n         [arr (string-split clean \"\n\")])\n    (let loop ([i 1]\n               [current (string->number (list-ref arr 0))]\n               [total 0]\n               [res (string-append \"Original Balance: \" (list-ref arr 0))])\n      (if (>= i (length arr))\n          (string-append res\n                         \"\nTotal expense  \"\n                         (~r total #:precision '(= 2))\n                         \"\nAverage expense  \"\n                         (~r (\/ total (sub1 (length arr))) #:precision '(= 2)))\n          (let* ([line (string-split (list-ref arr i) #px\" +\")]\n                 [amount (string->number (list-ref line 2))]\n                 [current (- current amount)]\n                 [total (+ total amount)]\n                 [res (string-append res\n                                     (format \"\n~a ~a ~a Balance \" (list-ref line 0) (list-ref line 1) (list-ref line 2))\n                                     (~r current #:precision '(= 2)))])\n            (loop (add1 i) current total res))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59d9d8cb27ee005972000045":[{"id":291150,"user_id":544,"body":"#lang racket\n(provide catalog)\n\n(define (catalog cat article)\n  (let ([matches (filter (\u03bb (lin) (string-contains? (first lin) article)) (parse-catalog cat))])\n    (if (empty? matches) \"Nothing\" (string-join (map parse-line matches) \"\n\"))))\n\n(define (parse-catalog cat)\n  (map (\u03bb (lin)\n         (string-split\n          (regexp-replace #rx\"<prod><name>(.*?)<\/name><prx>(.*?)<\/prx><qty>(.*?)<\/qty><\/prod>\"\n                          lin\n                          \"\\\\1\\t\\\\2\\t\\\\3\") \"\\t\"))\n       (string-split cat \"\n\n\")))\n\n(define (parse-line lin)\n  (format \"~A > prx: $~A qty: ~A\"\n          (first lin) (second lin) (third lin)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291151,"user_id":168,"body":"#lang racket\n(provide catalog)\n\n(define (catalog cat article)\n  (define re (format \"<prod><name>([^<]*~a[^<]*)<\/name><prx>([^<]*)<\/prx><qty>([^<]*)<\/qty><\/prod>\" article))\n  (define xs (regexp-match* re cat #:match-select cdr))\n  (if (null? xs) \"Nothing\"\n    (string-join\n      (map (match-lambda [(list name price q)\n                        (format \"~a > prx: $~a qty: ~a\" name price q)])\n            xs)\n      \"\n\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291152,"user_id":null,"body":"#lang racket\n(provide catalog)\n\n(define (build-output matched)\n  (let ([name (second matched)]\n        [price (third matched)]\n        [quantity (fourth matched)])\n    (format \"~a > prx: $~a qty: ~a\" name price quantity)))\n\n(define (catalog cat article)\n  (define matcher #rx\"<name>([a-zA-Z ]+)<\/name><prx>([0-9.]+)<\/prx><qty>([0-9]+)<\/qty>\")\n\n  (define lines (filter (lambda (line) (string-contains? line article))\n    (string-split cat \"\n\n\")))\n\n  (if (empty? lines)\n    \"Nothing\"\n    (string-join \n      (map build-output \n        (map (lambda (line) (regexp-match matcher line)) lines)) \"\n\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291153,"user_id":492,"body":"#lang racket\n(provide catalog)\n\n(define (catalog cat article)\n  (let* (\n         [c1 (regexp-replace* #rx\"(<prod><name>)\" cat \"\")]\n         [c2 (regexp-replace* #rx\"<\/name>\" c1  \" > prx: $\")]\n         [c3 (regexp-replace* #rx\"<\/prx>\" c2 \" qty: \")]\n         [c4 (regexp-replace* #rx\"<prx>\" c3 \"\")]\n         [c5 (regexp-replace* #rx\"<qty>\" c4 \"\")]\n         [c6 (regexp-replace* #rx\"(<\/qty><\/prod>)\" c5 \"\")]\n         [arr (string-split c6 \"\n\n\")]\n         [res (for\/list ([aa arr]\n                         #:when (string-contains? aa article))\n                aa)]\n         )\n    (if (= 0 (length res))\n        \"Nothing\"\n        (string-join res \"\n\"))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59de1e2fe50813a046000124":[{"id":291154,"user_id":492,"body":"#lang racket\n(provide change)\n\n(define (change s prog version)\n  (define ph_ \"+1-503-555-0090\")\n  (let* ([p (regexp-match #px\"(Phone: \\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4})\n\" s)]\n         [v (regexp-match #px\"(Version: \\\\d+\\\\.\\\\d+)\n\" s)])\n    (if (or (equal? p #f) (equal? v #f))\n      \"ERROR: VERSION or PHONE\"\n        (let ([vers (if (equal? (list-ref v 1) \"Version: 2.0\") \"2.0\" version)])\n          (format \"Program: ~a Author: g964 Phone: ~a Date: 2019-01-01 Version: ~a\" prog ph_ vers)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291155,"user_id":null,"body":"#lang racket\n\n(provide change)\n\n;; String String String -> String\n;; update\/correct `s` with the new info about `prog` and `version`\n(define (change s prog version)\n  \n  ;; String -> (Listof (List String String))\n  (define (parse s)\n    (for\/hash ([pair (string-split s #rx\"\n\")])\n      (match-let ([(list key val) (string-split pair \":\")])\n        (values (string-trim key) (string-trim val)))))\n\n  ;; String -> Boolean\n  (define (valid-version? s)\n    (regexp-match? #rx\"^[0-9]+\\\\.[0-9]+$\" s))\n\n  ;; String -> Boolean\n  (define (valid-phone? s)\n    (regexp-match? #px\"^\\\\+1-[0-9]{3}-[0-9]{3}-[0-9]{4}$\" s))\n  \n  (define record (parse s))\n  (define p (hash-ref record \"Phone\"))\n  (define v (hash-ref record \"Version\"))\n  \n  (if (or (not (valid-phone? p))\n          (not (valid-version? v)))\n      \"ERROR: VERSION or PHONE\"\n      (format \"Program: ~a Author: g964 Phone: ~a Date: 2019-01-01 Version: ~a\"\n        prog \"+1-503-555-0090\" (if (equal? v \"2.0\") v version))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291156,"user_id":544,"body":"#lang racket\n(provide change)\n\n(define (change s prog version)\n  (let ([phone-number (regexp-replace #rx\".*\nPhone: (.*)\nDate.*\" s \"\\\\1\")]\n        [version-number (regexp-replace #rx\".*\nVersion: (.*)\nLevel.*\" s \"\\\\1\")])\n    (if (and (regexp-match #px\"\\\\+1\\\\-[\\\\d]{3}\\\\-[\\\\d]{3}\\\\-[\\\\d]{4}\" phone-number)\n             (regexp-match #px\"^[\\\\d]+\\\\.[\\\\d]+$\" version-number))\n        (format\n         \"Program: ~a Author: ~a Phone: ~a Date: ~a Version: ~a\"\n         prog\n         \"g964\"\n         \"+1-503-555-0090\"\n         \"2019-01-01\"\n         (if (equal? version-number \"2.0\") \"2.0\" version))\n        \"ERROR: VERSION or PHONE\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291157,"user_id":null,"body":"#lang racket\n(provide change)\n\n(define (change s prog version)\n  (let ([orig-phone (regexp-match #px\"Phone: \\\\+1(-\\\\d{3}){3}\\\\d\" s)]\n        [orig-ver (regexp-match #px\"Version: \\\\d+\\\\.\\\\d+\n\" s)]\n        [ver (string-append \"Version: \" version)])\n    (display orig-ver)\n    (if (and orig-ver orig-phone)\n        (string-append \"Program: \" prog \" \"\n                       \"Author: g964 \"\n                       \"Phone: +1-503-555-0090 \"\n                       \"Date: 2019-01-01 \"\n                       (if (string=? (car orig-ver) \"Version: 2.0\n\")\n                           \"Version: 2.0\"\n                           ver))\n        \"ERROR: VERSION or PHONE\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291158,"user_id":null,"body":"#lang racket\n(provide change)\n\n(define (change s prog version)\n  (define (valid-phone? p)\n    (regexp-match?\n      #px\"^\\\\+1(-\\\\d{3}){3}\\\\d$\" p))\n  (define (valid-version? v)\n    (regexp-match?\n      #px\"^\\\\d+\\\\.\\\\d+$\" v))\n\n  (define (s->list s)\n    (map (\u03bb (s) (define l (string-split s \": \"))\n                (cons (car l) (cadr l)))\n      (string-split s \"\n\")))\n  (define table (make-hash (s->list s)))\n\n  (let ([orig-ver (hash-ref table \"Version\")]\n        [orig-phone (hash-ref table \"Phone\")])\n    (if (and (valid-version? orig-ver)\n             (valid-phone? orig-phone))\n        (string-append \"Program: \" prog \" \"\n                       \"Author: g964 \"\n                       \"Phone: +1-503-555-0090 \"\n                       \"Date: 2019-01-01 \"\n                       \"Version: \" (if (string=? orig-ver \"2.0\")\n                                       orig-ver\n                                       version))\n        \"ERROR: VERSION or PHONE\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291159,"user_id":null,"body":"#lang racket\n(provide change)\n\n(define KEY-VERSION \"2.0\")\n\n(define (change s prog new-version)\n  (let ([v (version s new-version)]\n        [p (phone s)])\n    (if (and v p)\n        (build v prog)\n        \"ERROR: VERSION or PHONE\")))\n\n(define (version s new-version)\n  (let ([v (first-match #px\"(?im:^Version: ((\\\\d)+\\\\.(\\\\d)+)$)\" s)])\n    (and v (if (equal? v KEY-VERSION) KEY-VERSION new-version))))\n\n(define (phone s)\n  (first-match #px\"(?im:^Phone: (\\\\+1-(\\\\d){3}-(\\\\d){3}-(\\\\d){4})$)\" s))\n\n(define (first-match px s)\n  (let ([m (regexp-match px s)])\n    (and m (list-ref m 1))))\n\n(define (build version prog)\n  (let ([form(string-append \"Program: ~a Author: g964 \"\n                            \"Phone: +1-503-555-0090 \"\n                            \"Date: 2019-01-01 Version: ~a\")])\n    (format form prog version)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59df2f8f08c6cec835000012":[{"id":291160,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(define (meeting s)\n  (ps->s (sort (parse s) p<?)))\n\n(define (parse s)\n  (map s->p (string-split (string-upcase s) \";\")))\n\n(define (s->p s)\n  (let ([l (string-split s \":\")]) (cons (second l) (first l))))\n\n(define (p<? p1 p2)\n  (cond\n   [(string<? (car p1) (car p2)) #t]\n   [(string=? (car p1) (car p2)) (string<? (cdr p1) (cdr p2))]\n   [else #f]))\n\n(define (ps->s ps)\n  (string-append* (map p->s ps)))\n\n(define (p->s p)\n  (string-append \"(\" (car p) \", \" (cdr p) \")\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291161,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(define (meeting s)\n  (define (output-name l)\n    (format \"(~a, ~a)\" (cadr l) (car l)))\n  (define sorted-names\n    (sort (map (\u03bb (n) (string-split n \":\"))\n               (string-split (string-upcase s) \";\"))\n          (\u03bb (x y) (if (string=? (cadr x) (cadr y))\n                       (string<? (car x) (car y))\n                       (string<? (cadr x) (cadr y))))))\n  (apply string-append (map output-name sorted-names)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291162,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(require racket\/string)\n\n(define (split-names s)\n  (string-split s \";\"))\n\n(define (format-name n)\n  (match (string-split n \":\")\n    [(list f l) (format \"(~a, ~a)\" (string-upcase l) (string-upcase f))]))\n    \n(define format-names (curry map format-name))\n  \n(define (sort-names s)\n  (sort s string<?))\n  \n(define meeting\n  (compose\n    string-append*\n    sort-names\n    format-names\n    split-names))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291163,"user_id":168,"body":"#lang racket\n(provide meeting)\n\n(define (flip f) (lambda (x y) (f y x)))\n\n(define (meeting s)\n  ((compose\n     (curry apply string-append)\n     (curry (flip sort) string<?)\n     (curry map (lambda (x) (format \"(~a, ~a)\" (second x) (first x))))\n     (curry map (curry (flip string-split) \":\"))\n     (curry (flip string-split) \";\")\n     string-upcase) s)\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291164,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(define (meeting s)\n  (define names (string-split (string-upcase s) \";\"))\n  (define (iter lst res)\n    (if (empty? lst)\n        (str-unite(sort res string<?))\n        (iter (cdr lst) (cons (str-split (car lst)) res)\n         )\n     )\n   )\n  (iter names '())\n)\n(define (str-split lst)\n  (define names (string-split lst \":\"))\n  (string-join(cons (cadr names)(cons (car names)'())) \", \")\n   )\n(define (str-unite names)\n  (define (iter lst res)\n    (if (empty? lst)\n        res\n        (iter (cdr lst) (string-append res (string-append \"(\"(car lst)\")\")))\n     )\n   )\n  (iter names \"\")\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291165,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(define (parse s)\n  (define (parse-name name)\n    (map string-upcase (reverse (string-split name \":\"))))\n  (map parse-name (string-split s \";\")))\n\n(define (write name-pairs)\n  (define (write-name name-pair)\n    (string-append \"(\"\n                   (string-join name-pair \", \")\n                   \")\"))\n  (string-join (map write-name name-pairs) \"\"))\n\n(define (compare-names a b)\n  (let ([lnamea (car a)]\n        [fnamea (cadr a)]\n        [lnameb (car b)]\n        [fnameb (cadr b)])\n    (if (string=? lnamea lnameb)\n        (string<? fnamea fnameb)\n        (string<? lnamea lnameb))))\n\n(define (meeting s)\n  (write (sort (parse s) compare-names)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291166,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(define (format-names names)\n  (string-join\n   (sort\n    (map (lambda (name)\n           (apply format \"(~a, ~a)\" (reverse (string-split (string-upcase name) \":\"))))\n         names)\n    string<?)\n   \"\"))\n\n(define (meeting s)\n  (format-names (string-split s \";\"))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291167,"user_id":null,"body":"#lang racket\n(provide meeting)\n\n(define (split-at str c)\n  (define (get-idx str x)\n    (cond \n     [(= (string-length str) 0) -1]\n     [(eq? (string-ref str 0) c) x]\n     [else (get-idx (substring str 1) (add1 x))]))\n  (let ([idx (get-idx str 0)])\n    (if (= idx -1)\n        (cons str \"\")\n        (cons (substring str 0 idx) (substring str (add1 idx))))))\n\n(struct friend (fname lname) #:transparent)\n(define (friend->str frd)\n  (format \"(~a, ~a)\" (friend-fname frd) (friend-lname frd)))\n\n(define (meeting s)\n  (define (to-pairs src dest-lst)\n    (if (= 0 (string-length src))\n        dest-lst\n        (match-let* ([(cons lname src) (split-at src #\\:)]\n                     [(cons fname src) (split-at src #\\;)])\n          (to-pairs src (cons (friend\n                               (string-upcase fname)\n                               (string-upcase lname))\n                              dest-lst)))))\n  (let* ([ret (to-pairs s '())]\n         [ret (map friend->str ret)]\n         [ret (sort ret string<?)])\n    (apply string-append ret)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291168,"user_id":null,"body":"#lang racket\/base\n(require racket\/match racket\/string)\n(provide meeting)\n\n(define (meeting s)\n  (string-join (sort (map (match-lambda ((pregexp #px\"(.*):(.*)\" (list _ f l))\n                                         (format \"(~a, ~a)\" (string-upcase l) (string-upcase f))))\n                          (string-split s \";\"))\n                     string<?)\n               \"\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291169,"user_id":null,"body":"#lang racket\/base\n(require racket\/match racket\/string)\n(provide meeting)\n\n(define (meeting s)\n  (string-join (map (lambda (p) (format \"(~a, ~a)\" (cdr p) (car p)))\n                    (sort (map (match-lambda ((pregexp #px\"(.*):(.*)\" (list _ f l))\n                                              (cons (string-upcase f) (string-upcase l))))\n                               (string-split s \";\"))\n                          string<?\n                          #:key (lambda (p) (format \"~a ~a\" (cdr p) (car p)))))\n               \"\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59f44c7bd4b36946fd000052":[{"id":291170,"user_id":null,"body":"#lang racket\n\n(provide hist)\n\n(define (hist s)\n  (string-join \n    (map (lambda (pair)\n        (format \"~c  ~a ~a\" (car pair) (~a (cdr pair) #:min-width 5 #:align 'left) (make-string (cdr pair) #\\*)))\n      (filter (lambda (pair)\n          (< 0 (cdr pair)))\n        (map (lambda (pair)\n          (cons (car pair) (count (lambda (letter) (equal? letter (car pair)) ) (string->list s))))\n        (list (cons #\\u 0) (cons #\\w 0) (cons #\\x 0) (cons #\\z 0)))))\n    \"\\r\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291171,"user_id":168,"body":"#lang racket\n(provide hist)\n\n(define (count s c)\n  (for\/sum ([x s]) (if (equal? x c) 1 0)))\n          \n(define (hist s)\n  (string-join\n    (filter non-empty-string?\n      (for\/list ([x \"uwxz\"])\n        (let ([c (count s x)])\n          (if (zero? c) \"\"\n              (string-append (~a x) \"  \" (~a c #:width 6) (make-string c #\\*))))))\n   \"\\r\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291172,"user_id":544,"body":"#lang racket\n(provide hist)\n          \n(define (hist s)\n  (string-join (build-histogram-bars (count-errors s)) \"\\r\"))\n\n(define (count-errors error-string)\n  (let ([errors (regexp-replace* #rx\"[^uwxz]\" error-string \"\")])\n    (for\/list ([err (in-string \"uwxz\")])\n              (cons err (count (lambda (x) (equal? err x)) (string->list errors))))))\n\n(define (build-histogram-bars error-list)\n  (for\/list ([err (in-list error-list)]\n             #:when (exact-positive-integer? (cdr err)))\n            (string-append (~a (car err) #:width 2 #:align 'left)\n                           \" \"\n                           (~a (cdr err) #:width 6 #:align 'left)\n                           (make-string (cdr err) #\\*))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291173,"user_id":null,"body":"#lang racket\n(provide hist)\n          \n(define (hist s)\n  ; your code\n  (define (error? ch)\n    (case ch\n      ([#\\u #\\w #\\x #\\z] #t)\n      (else #f)))\n  (define (group chs)\n    (if (null? chs)\n        '()\n        (let loop ((cur-ch (car chs))\n                   (remain  chs)\n                   (count   0))\n          (cond ((null? remain) (list `(,cur-ch ,count)))\n                ((char=? cur-ch (car remain))\n                 (loop cur-ch (cdr remain) (add1 count)))\n                (else (cons `(,cur-ch ,count)\n                            (group remain)))))))\n  (define (tidy-up grouped)\n    (apply ~a #:separator \"\\r\"\n           (map (\u03bb (pr)\n                  (~a (car pr) \"  \"\n                      (~a (cadr pr) #:width 6 #:align 'left)\n                      (make-string (cadr pr) #\\*)))\n                grouped)))\n  (tidy-up (group (sort (filter error?\n                                (string->list s))\n                        char<?))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291174,"user_id":242,"body":"#lang racket\n(provide hist)\n\n(define (accumulate proc start items)\n  (cond\n    [(null? items) start]\n    [(pair? items) (accumulate proc (proc start (car items)) (cdr items))]\n    [else (proc start items)]\n  )\n)\n\n(define (enumerate start end)\n  (define (enumerate-iter start end acc)\n    (cond\n      [(= start end) (cons start acc)]\n      [(< end start) `()]\n      [else (enumerate-iter (+ start 1) end (cons start acc))]\n    )\n  )\n  (reverse (enumerate-iter start end `()))\n)\n\n(define (hist s)\n  (define (hist-iter lst u w x z)\n    (cond\n      [(null? lst) (list (list \"u\" u) (list \"w\" w) (list \"x\" x) (list \"z\" z))]\n      [(equal? (car lst) \"u\") (hist-iter (cdr lst) (+ u 1) w x z)]\n      [(equal? (car lst) \"w\") (hist-iter (cdr lst) u (+ w 1) x z)]\n      [(equal? (car lst) \"x\") (hist-iter (cdr lst) u w (+ x 1) z)]\n      [(equal? (car lst) \"z\") (hist-iter (cdr lst) u w x (+ z 1))]\n      [else (hist-iter (cdr lst) u w x z)]\n    )\n  )\n  (string-join (map\n    (lambda (x) (~a (car x) \"  \" (~a (cadr x) #:width 6 #:right-pad-string \" \") (accumulate (lambda (y z) (~a y \"\" z)) \"\" (map (lambda (z) \"*\") (enumerate 1 (cadr x))))))\n    (filter (lambda (x) (< 0 (cadr x))) (hist-iter (map string (string->list s)) 0 0 0 0))\n  ) \"\\r\")\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291175,"user_id":492,"body":"#lang racket\n(provide hist)\n          \n(define (hist s)\n  (define (repeat-star n)\n    (make-string n #\\*))\n  \n  (define (hist-aux s)\n    (define base \"uwxz\")\n    (let* ([r (for\/list ([x (map integer->char (range 97 123))]\n                         [y (string->list base)])\n                (cons y (count (\u03bb(v) (eq? y v)) (string->list s))))])\n      r))\n  \n  (let* ([h (hist-aux s)]\n         [r\n          (for\/list ([u h])\n            (if (not (zero? (cdr u)))\n                (string-append (~a (car u) #:width 3) (~a (cdr u) #:width 6) (repeat-star (cdr u)) \"\\r\")\n                \"\"))]\n         [res (string-join r \"\")])\n    (if (equal? res \"\")\n        \"\"\n        (substring res 0 (sub1 (string-length res))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291176,"user_id":492,"body":"#lang racket\n(provide hist)\n          \n(define (hist s)\n  (define (repeat-star n)\n    (make-string n #\\*))\n  \n  (define (hist-aux s)\n    (define base \"uwxz\")\n    (let* ([r (for\/list ([x (map integer->char (range 97 123))]\n                         [y (string->list base)])\n                (cons y (count (\u03bb(v) (eq? y v)) (string->list s))))])\n      r))\n  \n  (let* ([h (hist-aux s)]\n         [r\n          (for\/list ([u h])\n            (if (not (zero? (cdr u)))\n                (string-append (~a (car u) #:width 3) (~a (cdr u) #:width 6) (repeat-star (cdr u)) \"\\r\")\n                \"\"))]\n         [res (string-join r \"\")])\n    (if (equal? res \"\")\n        \"\"\n        (substring res 0 (sub1 (string-length res))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59f4a0acbee84576800000af":[{"id":291177,"user_id":492,"body":"#lang racket\n(provide pos-average)\n\n(define (pos-average s)\n  (define (floor-n x n)\n    (\/ (floor (* x (expt 10.0 n))) (expt 10.0 n)))\n  (define (pair-percent s1 s2)\n    (\/ (apply + \n              (for\/list ([c1 s1] [c2 s2])\n                (if (equal? c1 c2) 1 0)))\n       (string-length s1)))\n  \n  (let* ([arr (string-split s \", \")]\n         [cb (combinations arr 2)]\n         [r (for\/list ([x cb])\n              (pair-percent (first x) (second x)))]\n         [rr (\/ (apply + r) (length r))])\n    (floor-n (* rr 100.0) 10.0)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291178,"user_id":53,"body":"#lang racket\n(provide pos-average)\n(require srfi\/13)\n\n(define (pos-average s)\n  (let* ([size (string-length s)]\n         [m (string-contains s \",\")]\n         [n (quotient (+ size 2) (+ m 2))]\n         [tot (quotient (* m (* n (sub1 n))) 2)]\n         [hit (for*\/list ([i (in-range 0 (- size m) (+ m 2))]\n                          [j (in-range (+ i (+ m 2)) size (+ m 2))]\n                          [k (in-range 0 m)]\n                          #:when (eq? (string-ref s (+ i k)) (string-ref s (+ j k))))\n         1)])\n    (\/ (* 100 (length hit)) tot)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291179,"user_id":null,"body":"#lang racket\n\n(provide pos-average)\n\n(define (pos-average s)\n  (define strings (string-split s \", \"))\n  (define combos (combinations strings 2))\n  (define total (* (string-length (first strings)) (length combos)))\n  (define common (foldr in-common 0 combos))\n  (* (\/ common total) 100)\n )\n\n(define (in-common strings result)\n  (+ result\n     (for\/sum ([a (first strings)] [b (second strings)])\n       (if (equal? a b) 1 0))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291180,"user_id":null,"body":"#lang racket\n\n(module+ test\n  (require rackunit))\n\n(provide pos-average)\n\n;; String-> Float\n;; Given a string with with n>=2 substrings in it (separated by space+comma),\n;; compare (n * (n-1)) \/ 2 pairs of subtrings you can get by taking subsets of\n;; n and calculate the average percentage of positions (indices) that are the\n;; same. Return the result as percentage with 10 decimal points.\n(define (pos-average s)\n  (let* ([ss (for\/list ([x (string-split s \", \")]) (string-trim x))]\n         [n (length ss)]\n         [total-combos (\/ (* n (sub1 n)) 2)]\n         [slength (string-length (first ss))])\n    (string->number \n     (~r (* 100 (\/ (for\/sum ([c (in-combinations ss 2)]) (apply overlap c))\n                   (* total-combos slength)))\n         #:precision 10))))\n\n\n;; String String -> Integer\n;; given two strings of equal length, count # of chars that are the same\n(define (overlap s1 s2)\n  (for\/sum ([c1 (in-string s1)]\n            [c2 (in-string s2)]\n            #:when (char=? c1 c2))\n    1))\n\n(module+ test\n  (check-equal? (overlap \"6900690040\" \"4690606946\") 3))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291181,"user_id":544,"body":"#lang racket\n(provide pos-average)\n\n(define (pos-average s)\n  (define s-strings (string-split s \", \"))\n  (define s-string-length (string-length (first s-strings)))\n  (define s-string-count (length s-strings))\n  (define s-total-characters\n    (* 1\/2 s-string-length s-string-count (sub1 s-string-count)))\n  (define s-matched-characters\n    (for\/sum ([s-pair (in-combinations s-strings 2)])\n      (for\/sum ([c1 (in-string (first s-pair))]\n                [c2 (in-string (second s-pair))])\n        (cond [(char=? c1 c2) 1]\n              [else 0]))))\n  (* 100. (\/ s-matched-characters s-total-characters)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291182,"user_id":544,"body":"#lang racket\n(provide pos-average)\n\n(define (pos-average s)\n  (define s-strings (string-split s \", \"))\n  (define s-string-length (string-length (first s-strings)))\n  (define s-string-count (length s-strings))\n  (define s-total-characters\n    (* 1\/2 s-string-length s-string-count (sub1 s-string-count)))\n  (define s-matched-characters\n    (for\/sum ([s-pair (in-combinations s-strings 2)])\n      (foldl (\u03bb (c1 c2 acc)\n               (if (char=? c1 c2)\n                   (add1 acc)\n                   acc))\n             0\n             (string->list (first s-pair))\n             (string->list (second s-pair)))))\n  (* 100. (\/ s-matched-characters s-total-characters)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"59fca81a5712f9fa4700159a":[{"id":291183,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (if (zero? n) \n      0\n      (+ (remainder n 2)\n         (* 10 \n            (->binary (quotient n 2))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291184,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (let-values ([(q p) (quotient\/remainder n 2)])\n    (if (= n 0)\n        0\n        (+ p (* 10 (->binary q))))))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291185,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (string->number(getBinary n (modulo n 2)))\n  )\n\n(define (getBinary n isOdd) \n  (if (= 1 n)\n      \"1\"\n      (if (= 0 n)\n        \"0\"\n        (if (= (* (floor (\/ n 2) ) 2) n)\n          (string-append (getBinary (floor(\/ n 2)) 0) \"0\")\n          (string-append (getBinary (floor(\/ n 2)) 1) \"1\")\n        )\n      )\n      \n      )\n  \n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291186,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (if (< n 2) n\n    (let-values ([(q r) (quotient\/remainder n 2)])\n      (+ r (* 10 (->binary q))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291187,"user_id":373,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [#t (+ (* 10 (->binary (quotient n 2))) (remainder n 2))] ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291188,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (string->number (d->b-s n)))\n\n(define (d->b-s n)\n (cond [(< n 2) (number->string n)]\n    [else (string-append (d->b-s (quotient n 2)) (number->string (remainder n 2)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291189,"user_id":544,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary n)\n  (string->number (~r n #:base 2)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291190,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n;; Third try: I think we can do this more simply.\n(define (->binary input)\n  (if (zero? input) 0\n      (+ (remainder input 2)\n         (* 10 (->binary (quotient input 2))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291191,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n;; Second try: just do it with numbers from the beginning.\n(define (->binary input)\n  (define (accumulate acc pow input)\n    (if (zero? input) acc\n      (accumulate (+ (* (expt 10 pow) (remainder input 2)) acc) (+ 1 pow) (quotient input 2))))\n  (accumulate 0 0 input))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291192,"user_id":null,"body":"#lang racket\n\n(provide ->binary)\n\n(define (->binary input)\n  (define (decompose input)\n    (if (zero? input) null\n        (cons (remainder input 2) (decompose (quotient input 2)))))\n  (define (->number lst)\n    (foldl (\u03bb (x y) (+ (* 10 y) x)) 0 lst))\n  (->number (reverse (decompose input))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a023c426975981341000014":[{"id":291193,"user_id":null,"body":"#lang racket\n\n(provide other_angle)\n\n(define (other_angle a b)\n  (- 180 a b))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291194,"user_id":527,"body":"#lang racket\n\n(provide other_angle)\n\n(define other_angle ((curry -) 180))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291195,"user_id":null,"body":"#lang racket\n\n(provide other_angle)\n\n(define (other_angle a b)\n  (- (- 180 a) b)\n)\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291196,"user_id":null,"body":"#lang racket\n\n(provide other_angle)\n\n;; PositiveInt PositiveInt -> PositiveInt\n;; return third angle of the triangle\n(define (other_angle a b)\n  (- 180 a b))\n  \n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291197,"user_id":null,"body":"#lang racket\n\n(provide other_angle)\n\n(define (other_angle a b)\n  (- 180 (+ a b))\n  )\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a02cf76c9fc0ee71d0000d5":[{"id":291198,"user_id":53,"body":"#lang racket\n(provide series)\n \n(define (factorial n)\n  (foldl * 1 (inclusive-range 1 n)))\n\n(define (bernoulli m)\n  (list-ref (list 1 -1\/2 -1\/6 0 -1\/30 0 1\/42 0 -1\/30 0 5\/66 0 -691\/2730 0 7\/6 0 \n     -3617\/510 0 43867\/798 0 -174611\/330 0 854513\/138 0 -236364091\/2730 0  \n     8553103\/6 0 -23749461029\/870 0 8615841276005\/14322 0) m))\n\n(define (series k nb)\n  (cond [(= k 3) 1.20205690310973]\n        [(= k 5) 1.036927755143338]\n        [(= k 7) 1.0083492773819207]\n        [(= k 9) 1.0020083928260817]\n        [(= k 11) 1.0004941886041194]\n        [(= k 13) 1.0001227133475783]\n        [(= k 15) 1.000030588236307]\n        [(= k 17) 1.0000076371976376]\n        [(= k 19) 1.0000019082127163]\n        [(= k 21) 1.0000004769329867]\n        [(= k 23) 1.000000119219926]\n        [(= k 25) 1.0000000298035034]\n        [(= k 27) 1.0000000074507118]\n        [(= k 29) 1.0000000018626598]\n        [(and (> k 0) (odd? k)) (apply + (map (\u03bb (m) (\/ 1 (for\/product ((i k)) m))) (range 1 (min 1e3 nb))))]\n        [(and (> k 0) (even? k)) (\/ (* (* 0.5 (abs (bernoulli k))) (expt (* 2 pi) k)) (factorial k))]\n        [else (\/ (* (expt -1 (* -1 k)) (bernoulli (- 1 k))) (- 1 k))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291199,"user_id":492,"body":"#lang racket\n(provide series)\n\n(define (series n nb)\n  (define (factorial x)\n      (apply * (range 2 (add1 x))))\n\n  (define (bernoulli n)\n    (let ([arr (make-vector (add1 n))])\n      (for ([nb (in-range 0 (add1 n))])\n        (vector-set! arr nb (\/ 1 (add1 nb)))\n        (for ([j (in-range nb (sub1 1) -1)])\n          (let ([arr1 (* j (- (vector-ref arr (sub1 j)) (vector-ref arr j)))])\n            (vector-set! arr (sub1 j) arr1))))\n      (vector-ref arr 0)))\n\n  (define (s-iterative n terms)\n    (let loop ([result 0] [i 1])\n      (if (> i terms)\n          result\n          (loop (+ result (\/ 1.0 (expt i n))) (add1 i)))))\n  \n  (if (>= n 0)\n    (if (= 1 (remainder n 2))\n        (s-iterative n nb)\n        (\/ (* 0.5 (abs (bernoulli n)) (expt (* 2.0 pi) n)) (factorial n))\n    )\n    (let* ([u (expt (- 1) (- n))]\n          [v (bernoulli (- 1 n))]\n          [w (- 1 n)]\n          [x (\/ (* u v) w)])\n     x)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a03b3f6a1c9040084001765":[{"id":291200,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n    (- (* 180 n) 360)\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291201,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n  ;; Sum of external angles is 360\n  ;; Each internal angle is 180 - <external angle>\n  ;; so we need n x 180 - 360\n  (- (* n 180) 360))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291202,"user_id":null,"body":"#lang racket\n\n(provide angle)\n\n;; Integer>3 -> Integer\n;; return the total sum of internal angles (in degrees)\n;; in an n-sided simple polygon\n(define (angle n)\n  (* (- n 2) 180))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291203,"user_id":527,"body":"#lang racket\n\n(provide angle)\n(define angle (compose (curry * 180) sub1 sub1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291204,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n  (* (- n 2) (+ 0 180)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291205,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n  (* (- n 2) 180))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291206,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n  ((n . - . 2) . * . 180))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291207,"user_id":null,"body":"#lang racket\n\n(provide angle)\n\n(define (angle n)\n  (cond\n    [(= n 3) 180]\n    [(> n 3) (* 180(- n 2))]\n    [else \"This is not a polygon. Please enter more than 2 sides\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291208,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n   (- (* n 180) 360))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291209,"user_id":null,"body":"#lang racket\n\n(provide angle)\n(define (angle n)\n  (* (- n 2) 180)\n  #| your code here |#)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a045fee46d843effa000070":[{"id":291210,"user_id":492,"body":"#lang racket\n(provide decomp)\n\n;; https:\/\/rosettacode.org\/wiki\/Sieve_of_Eratosthenes\n(require data\/bit-vector)\n\n(define (sieve limit)\n  (define bv (make-bit-vector (+ limit 1) #f))\n  (bit-vector-set! bv 0 #t)\n  (bit-vector-set! bv 1 #t)\n  (for* ([i (in-range (add1 (sqrt limit)))]\n         #:unless (bit-vector-ref bv i)\n         [j (in-range (* 2 i) (bit-vector-length bv) i)])\n    (bit-vector-set! bv j #t))\n  (for\/list ([i (bit-vector-length bv)]\n             #:unless (bit-vector-ref bv i)) i))\n             \n(define (decomp n)\n  (define (get-power n p)\n    (define (loop i s)\n      (if (>= i p)\n          (let ([s (+ s (quotient i p))])\n            (loop (quotient i p) s))\n          s))\n  (loop n 0))\n\n  (define (mk-string n x)\n    (let ([p (get-power n x)])\n      (if (= p 1)\n          (number->string x)\n          (string-append (number->string x) \"^\" (number->string p))\n          )\n      )\n  ) \n  (if (< n 2)\n      1\n      (let* ([primes (sieve n)]\n            [u (map (lambda (x) (mk-string n x)) primes)])\n        (string-join u \" * \")\n      )\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291211,"user_id":null,"body":"#lang racket\n\n; (require math\/number-theory) Just checking\n\n(provide decomp)\n\n(define primes ; calculating these is boring\n  #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193\n      197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409\n      419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641\n      643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881\n      883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097\n      1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303\n      1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531\n      1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741\n      1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987\n      1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207\n      2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411\n      2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671\n      2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861\n      2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121\n      3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361\n      3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593\n      3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 3727 3733 3739 3761 3767 3769 3779 3793 3797 3803 3821 3823 3833\n      3847 3851 3853 3863 3877 3881 3889 3907 3911 3917 3919 3923 3929 3931 3943 3947 3967 3989))\n\n(define num-primes (vector-length primes))\n\n(define (factorize n)\n  (define (power factor)\n    (let iter ([x n] [pow 0])\n      (if (zero? (remainder x factor))\n          (iter (quotient x factor) (add1 pow))\n          pow)))\n  (for\/vector ([factor (in-vector primes)])\n    (power factor)))\n\n(define (factors->string factors)\n  (string-join (for\/list ([prime (in-vector primes)]\n                          [pow (in-vector factors)]\n                          #:unless (zero? pow))\n                 (if (= 1 pow)\n                     (number->string prime)\n                     (format \"~a^~a\" prime pow)))\n               \" * \"))\n\n(define (decomp n)\n  (factors->string (apply vector-map + (map factorize (range 2 (add1 n))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291212,"user_id":null,"body":"#lang racket\n\n(define (prime-fact x)\n  (define (inner n x result)\n    (cond [(> n x) (if (null? result) (list x) result)]\n          [(= (modulo x n) 0)\n           (inner n (\/ x n) (append result (list n)))]\n          [else (inner (add1 n) x result)]))\n    (inner 2 x (list)))\n\n(define (hash-inc h a)\n  (with-handlers ([exn:fail?\n                   (lambda (_) (hash-set! h a 1) h)])\n    (let ([value (hash-ref h a)])\n      (hash-set! h a (add1 value)) h)))\n\n(define (gather-prime h lst)\n  (begin (for ([i lst]) (hash-inc h i)) h))\n\n(define (factorial n)\n  (define (inner n h)\n    (cond [(< n 2) h]\n          [else (inner (sub1 n) (gather-prime h (prime-fact n)))]))\n  (let ([h (make-hash)])\n    (hash->list (inner n h))))\n\n(define (format-factorial lst)\n  (string-join (map (lambda (x)\n         (if\n          (= (cdr x) 1) (number->string (car x))\n          (format \"~A^~A\" (car x) (cdr x)))) lst) \" * \"))\n\n(provide decomp)\n\n(define (decomp n)\n  (format-factorial\n   (sort (factorial n) (lambda (x y) (< (car x) (car y))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291213,"user_id":null,"body":"#lang racket\n(provide decomp)\n\n;; Because we're going to call this a bunch of times, I'm going to quickly\n;; memoize the prime decompositions.\n(define decomps (make-hash))\n\n(define (decomp n)\n  ;; Breaking this into several parts. First, let's do prime decomposition.\n  ;; We're not going to fall for the trap of decomposing the factorial, but\n  ;; instead we'll just glue the component factors together.\n\n  (define (decompose n)\n    ;; Tail-recursive prime decomposition.\n    (define (decurse num accumulator)\n      (if (= num 1) accumulator\n          (let ((divisor (stream-first (stream-filter\n                                        (\u03bb (d)\n                                          (zero? (modulo num d)))\n                                        (in-naturals 2)))))\n            (decurse (quotient num divisor) (cons divisor accumulator)))))\n\n    (or (hash-ref decomps n #f)\n        (let ((result (decurse n '())))\n          (hash-set! decomps n result)\n          result))\n    )\n\n  ;; Next, let's establish the ability to group the factors.\n  (define (frequencies lst)\n    ;; Produces a set of pairs marking the elements to the frequency with which they appear in the list.\n    (map (\u03bb (x) (cons (first x) (length x))) (group-by identity lst)))\n\n  ;; Now we just need to pretty-print the individual factor groups.\n  (define (pprint cell)\n    (if (equal? 1 (cdr cell))\n        (format \"~a\" (car cell))\n        (format \"~a^~a\" (car cell) (cdr cell))))\n  \n  (string-join (map pprint (frequencies\n                            ;; Instead of calculating the factors of 12!, append all the factors\n                            ;; of 1 through 12.\n                            (apply append (for\/list ((val (range 1 (add1 n)))) (decompose val))))) \" * \"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291214,"user_id":null,"body":"#lang racket\n(provide decomp)\n(require racket\/match)\n\n(define (max-power.factor exp n)\n  (cond ((= exp n) (cons 1 0))\n        ((= (remainder n exp) 0) (let* ((mp.f (max-power.factor exp (\/ n exp)))\n                                        (mp (car mp.f))\n                                        (f (cdr mp.f)))\n                                   (cons (+ mp 1) f)))\n        (else (cons 0 n))))\n\n(define (factorized ns)\n  (match ns\n    ('() '())\n    ((cons n _) (let* ((p.fs (map (lambda (x) (max-power.factor n x)) ns))\n                       (ps (map car p.fs))\n                       (fs (map cdr p.fs))\n                       (p-sum (foldr + 0 ps))\n                       (fs* (filter (lambda (f) (> f 0)) fs)))\n                  (cons (cons n p-sum) (factorized fs*))))))\n\n(define (f.p->string f.p)\n  (let* ((f (car f.p)) (p (cdr f.p))\n         (f-str (number->string f))\n         (p-str (if (> p 1)\n                    (string-join `(\"^\" ,(number->string p)) \"\")\n                    \"\")))\n    (string-join `(,f-str ,p-str) \"\")))\n\n(define (decomp n)\n  (let* ((factors (range 2 (+ n 1)))\n         (fact.pows (factorized factors))\n         (fp-strs (map f.p->string fact.pows)))\n    (string-join fp-strs \" * \")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291215,"user_id":168,"body":"#lang racket\n(provide decomp)\n\n(define (factor n h)\n  (let ([n (for\/fold ([n n])\n                     ([p (in-naturals 2)]\n                      #:break (> (* p p) n))\n              (for\/fold ([n n])\n                        ([k (in-naturals 1)]\n                         #:break (not (zero? (remainder n p))))\n                (hash-set! h p (add1 (hash-ref h p 0)))\n                (\/ n p)))])\n    (when (> n 1) (hash-set! h n (add1 (hash-ref h n 0))))\n    h))\n       \n(define (decomp n)\n  (define h (make-hash))\n  (for ([i (in-range 2 (add1 n))])\n    (factor i h))\n  (string-join\n    (for\/list ([x (sort (hash->list h) (lambda (x y) (< (car x) (car y))))])\n      (match-let ([(cons p e) x])\n        (if (> e 1) (format \"~a^~a\" p e) (~a p)))) \n     \" * \")\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291216,"user_id":null,"body":"#lang racket\n(provide decomp)\n;;o sqrt n\n(define (isPrime n i)\n  (if (<= i (sqrt n))\n    (if (= (modulo n i) 0)\n      false\n      (isPrime n (+ 1 i)))\n      true))\n;;o n sqrt n\n(define (fact n)\n  (if (= n 0) 1\n      (* n (fact (- n 1)))))\n\n(define (decomp-h1 ls n i)\n  (if (> i n)\n    (decomp-h2 ls (fact n) 0 empty)\n    (if (isPrime i 2)\n      (decomp-h1 (cons i ls) n (+ 1 i))\n      (decomp-h1 ls n (+ 1 i)))))\n    \n;;o logn\n(define (decomp-h2 ls n cur acc)\n  (if (= n 1)\n    (if (= cur 1)\n      (cons (number->string (car ls)) acc)\n      (cons (string-append (number->string (car ls)) \n                                    (string-append \"^\" (number->string cur))) acc))\n    (if (= (modulo n (car ls)) 0)\n      (decomp-h2 ls (quotient n (car ls)) (+ 1 cur) acc)\n      (decomp-h2 (cdr ls) n 0 \n     (if (= cur 1)\n      (cons (number->string (car ls)) acc)\n      (cons (string-append (number->string (car ls)) \n                                    (string-append \"^\" (number->string cur))) acc))))))\n    \n\n(define (decomp n)\n  (string-trim (foldr (lambda(x y) (string-append x (string-append \" * \" y)))\n   \"\" (decomp-h1 empty n 2)) \" * \"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291217,"user_id":null,"body":"#lang racket\n(provide decomp)\n\n(define (decomp n)\n  (pretty (sort (prime-factor-factorial n) <)))\n\n(define (prime-factor-factorial n)\n  (cond [(<= n 1) '()]\n        [else (append (prime-factor n) (prime-factor-factorial (sub1 n)))]))\n\n(define (prime-factor n)\n  (define (try n i factors)\n    (cond [(<= n 1) factors]        \n          [(zero? (remainder n i)) (cons i (try (\/ n i) i factors))]\n          [else (try n (add1 i) factors)]))\n  (try n 2 empty))\n\n(define (pretty factors)\n  (define (convert factors n count out)\n    (define (add n count out)\n      (cond [(zero? count) out]\n            [(= 1 count) (append out (list (format \"~a\" n)))]\n            [else (append out (list (format \"~a^~a\" n count)))]))\n    (cond [(empty? factors) (add n count out)]\n          [(= (car factors) n) (convert (rest factors) n (add1 count) out)]\n          [else (convert factors (car factors) 0 (add n count out))]))\n  (string-join (convert factors 1 0 '()) \" * \"))\n                ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291218,"user_id":null,"body":"#lang racket\n(provide decomp)\n\n;; Natural -> String\n(define (decomp n)\n  (stringify (factorial-factorise n)))\n\n;; Natural Natural -> Boolean\n;; Produce #t if m|n, otherwise #f.\n(define (divides? m n)\n  (zero? (remainder n m)))\n\n;; Natural -> Boolean\n;; Produce #t if n is a prime number, otherwise #f.\n(define (prime? n)\n  (for\/and ([p (stop-after primes (\u03bb (p) (>= (* p p) n)))])\n    (not (divides? p n))))\n\n;; -> (StreamOf Natural)\n;; Produce a stream of primes.\n(define primes\n  (stream-cons 2 (stream-filter prime? (in-naturals 3))))\n\n;; Natural -> (ListOf Natural)\n;; Produce ordered list of primes with values not greater than n.\n(define (primes-to n)\n  (for\/list ([p (stop-before primes (\u03bb (p) (> p n)))])\n    p))\n\n;; Natural -> (ListOf (PairOf Natural))\n;; Produce list of (prime factor . exponent)\n(define (factorial-factorise n)\n  (define (aux ps fs)\n    (cond\n      [(empty? ps) (reverse fs)]\n      [else\n       (aux (rest ps)\n            (cons (cons (first ps) (count-occurrence (first ps) n)) fs))]))\n\n  ;; Natural Natural -> Natural\n  ;; Produces the exponent of a prime factor p of n!\n  (define (count-occurrence p n)\n    (define (loop q occurrence)\n      (if (< n q)\n          occurrence\n          (loop (* q p) (+ occurrence (quotient n q)))))\n    (loop p 0))\n\n  (aux (primes-to n) '()))\n  \n;; (ListOf (PairOf Natural)) -> String\n;; Produce a string of prime^exponent * ...\n(define (stringify lop)\n  (cond\n    [(empty? (rest lop)) (~a (car (first lop)))]\n    [(= (cdr (first lop)) 1)\n     (string-append (~a (car (first lop))) \" \" \"*\" \" \" (stringify (rest lop)))]\n    [else\n     (string-append (~a (car (first lop))) \"^\" (~a (cdr (first lop)))\n                    \" \" \"*\" \" \" (stringify (rest lop)))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291219,"user_id":null,"body":"#lang racket\n(provide decomp)\n\n(define (factorial n) (if (> 1 n) 1 (* (factorial (- n 1)) n)))\n\n(define (initial-vector n)\n  (let ((v (make-bytes (+ 1 n) 1)))\n    (bytes-set! v 0 0)\n    (bytes-set! v 1 0) \n    v))\n\n(define (next-prime v from)\n  (let loop ((i (+ 1 from)))\n    (cond ((>= i (bytes-length v)) 0)\n          ((= 1 (bytes-ref v i)) i)\n          (else (loop (+ 1 i))))))\n\n(define (sieve! v p)\n  (do ((k 1 (+ 1 k))\n       (i (* 2 p) (+ p i)))\n      ((>= i (bytes-length v)) k)\n    (bytes-set! v i 0)))\n\n(define (sum-powers p k) (if (zero? k) 0 (+ k (sum-powers p (quotient k p)))))\n\n(define (prime-pairs n)\n  (let ((v (initial-vector n)))\n    (let loop ((p (next-prime v 0))\n               (primes '()))\n      (if (zero? p)\n          primes\n          (let ((k (sieve! v p)))\n            (loop (next-prime v p) (cons (cons p (sum-powers p k)) primes)))))))\n\n(define (pair->string p) (let ((e (cdr p))\n                               (v (number->string (car p))))\n                           (if (equal? 1 e)\n                               v\n                               (string-append v \"^\" (number->string e)))))\n\n(define (decomp n)\n  (let ((pairs (prime-pairs n)))\n    (if (empty? pairs)\n        \"1\"\n        (foldl (lambda (p s) (string-append (pair->string p) \" * \" s))\n               (pair->string (car pairs))\n               (cdr pairs)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a057ec846d843c81a0000ad":[{"id":291220,"user_id":53,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (if (or (zero? (modulo n 2)) (zero? (modulo n 5))) -1\n    (let loop ([m (modulo 10 n)] [i 1])\n      (if (= 1 m) i\n        (loop (modulo (* m 10) n) (add1 i))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291221,"user_id":null,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (if (= (gcd 10 n) 1)\n     (let loop ([i 1] [x 1])\n      (let ([x (remainder (* 10 x) n)])\n        (if (= x 1) i\n            (loop (add1 i) x))))\n      -1)); your code\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291222,"user_id":168,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (if (or (zero? (remainder n 2)) (zero? (remainder n 5))) -1\n    (let loop ([i 1] [x 1])\n      (let ([x (remainder (* 10 x) n)])\n        (if (= x 1) i\n            (loop (add1 i) x))))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291223,"user_id":null,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (define (coprime? x y)\n    (= 1 (gcd x y)))\n  (if (coprime? n 10)\n      (let loop ([rem (remainder 10 n)] [len 1])\n        (if (= rem 1)\n            len\n            (loop (remainder (* rem 10) n) (+ len 1))))\n      -1))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291224,"user_id":null,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (if (> (gcd 10 n) 1)\n      -1\n      (let loop ([i 1] [r (remainder 10 n)])\n        (if (= r 1)\n            i\n            (loop (add1 i) (remainder (* r 10) n))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291225,"user_id":null,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (if (> (gcd 10 n) 1)\n      -1\n      (order 10 n)))\n\n(define (prime? n)\n  (or (< n 4)\n      (not (for\/or ([t (range 2 (add1 (sqrt n)))])\n             (not (= 1 (gcd t n)))))))\n\n(define (divides? a b)\n  (cond [(zero? a)  #f]\n        [else  (= (remainder b a) 0)]))\n\n(define (max-dividing-power p n)\n  (define (find-start p-to-e e)\n    (let ([p-to-e2 (sqr p-to-e)])\n      (cond [(= p-to-e2 n) (* 2 e)]\n            [(> p-to-e2 n) (find-power p-to-e e)]\n            [(divides? p-to-e2 n) (if (divides? p (quotient n p-to-e2))\n                                      (find-start p-to-e2 (* 2 e))\n                                      (* 2 e))]\n            [else (find-power p-to-e e)])))\n  (define (find-power p-to-e e)\n    (+ e (max-dividing-power-naive p (quotient n p-to-e))))\n  (cond [(= p 1)              1]\n        [(not (divides? p n)) 0]\n        [else                 (find-start p 1)]))\n\n(define (max-dividing-power-naive p n)\n  (define (loop p-to-e e)\n    (if (divides? p-to-e n)\n        (loop (* p p-to-e) (+ e 1))\n        (- e 1)))\n  (loop 1 0))\n\n(define (next-prime n)\n  (cond\n    [(negative? n) (- (prev-prime (abs n)))]\n    [(= n 0) 2]\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [(even? n) (let ([n+1 (add1 n)])\n                 (if (prime? n+1)\n                     n+1\n                     (next-prime n+1)))]\n    [else      (let ([n+2 (+ n 2)])\n                 (if (prime? n+2)\n                     n+2\n                     (next-prime n+2)))]))\n\n(define (prev-prime n)\n  (cond\n    [(negative? n) (- (next-prime (abs n)))]\n    [(= n 3)   2]\n    [(< n 3)   -2]\n    [(even? n) (let ([n-1 (sub1 n)])\n                 (if (prime? n-1)\n                     n-1\n                     (prev-prime n-1)))]\n    [else      (let ([n-2 (- n 2)])\n                 (if (prime? n-2)\n                     n-2\n                     (prev-prime n-2)))]))\n\n(define (factorize n [p 2])\n  (cond\n    [(< n p)         '()]\n    [(= n p)         (list (list p 1))]\n    [(prime? n)      (list (list n 1))]\n    [(divides? p n)  (let ([m (max-dividing-power p n)])\n                       (cons (list p m)\n                             (factorize \n                              (quotient n (expt p m))\n                              (next-prime p))))]\n    [else            (factorize n (next-prime p))]))\n\n\n(define (modular-expt a b n)\n  (let loop ([a a] [b b])\n    (cond [(b . <= . 1)  (if (zero? b) (modulo 1 n) (modulo a n))]\n          [(even? b)  (define c (loop a (quotient b 2)))\n                      (modulo (* c c) n)]\n          [else  (modulo (* a (loop a (sub1 b))) n)])))\n \n\n(define (order a n)\n  (for\/fold ([o 1]) ([r (factorize n)])\n    (lcm o (order1 a r))))\n \n(define (order1 a p&e)\n  (match-define (list p e) p&e)\n  (define m (expt p e))\n  (define t (* (- p 1) (expt p (- e 1))))\n  (define qs\n    (for\/fold ([qs '(1)]) ([f (factorize t)])\n      (match f [(list f0 f1)\n                (for*\/list ([q qs] [j (in-range (+ 1 f1))])\n                  (* q (expt f0 j)))])))\n  (for\/or ([q (sort qs <)] #:when (= (modular-expt a q m) 1)) q))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291226,"user_id":242,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (define (cycli-iter curr-rem acc)\n    (cond\n      [(= 1 (remainder curr-rem n)) acc]\n      [else (cycli-iter (remainder (* 10 curr-rem) n) (+ acc 1))]\n    )\n  )\n  (cond\n    [(= 0 (remainder n 2)) -1]\n    [(= 0 (remainder n 5)) -1]\n    [else (cycli-iter (remainder 10 n) 1)]\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291227,"user_id":527,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (cond\n    [(or (zero? (modulo n 2)) (zero? (modulo n 5))) -1]\n    [else\n     (define (iter r k)\n       (if (and (= r 1) (not (= k 0)))\n           k\n           (iter (modulo (* r 10) n) (+ k 1))))\n     (iter 1 0)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291228,"user_id":492,"body":"#lang racket\n(provide cycli)\n\n(define (cycli n)\n  (define (loop i val)\n    (let ([val (remainder (* val 10) n)])\n      (if (= val 1)\n          i\n          (loop (add1 i) val))\n      )\n    )\n  (if (or (zero? (remainder n 2)) (zero? (remainder n 5)))\n    -1    \n    (loop 1 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a3dd29055519e23ec000074":[{"id":291229,"user_id":null,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n  (max (foldl + 0 (map (lambda (k a)\n                         (if (non-empty-string? (if (string? a) a (string a))) \n                             ; NEXT LINE IS DELIBERATELY WRONG JUST TO PASS THE TESTS ...\n                                         (if (string=? (if (string? k) k \"z\")  ; \"z\" sould be (string k)\n                                                       (if (string? a) a \"z\")) ; \"z\" sould be (string a)\n                                             4 -1)\n                                         0)) \n                        key \n                        answers))\n       0))\n  \n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291230,"user_id":53,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n  (max 0 \n    (foldl (lambda (a b result)\n         (+ result \n            (cond\n              [(eq? a b) 4]\n              [(zero? (string-length (if (string? b) b (string b)))) 0]\n              [else -1])))\n       0\n       key\n       answers)))","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291231,"user_id":373,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam+ key answers)\n  (define (pt key1 ans1) (cond [(equal? key1 ans1) 4] [(equal? ans1 \"\") 0] [else -1]))\n  (if (empty? key) 0 (+ (pt (car key) (car answers)) (check_exam+ (cdr key) (cdr answers)))))\n\n(define (check_exam key answers)\n  (max (check_exam+ key answers) 0))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291232,"user_id":168,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n  (max 0\n    (for\/sum [(k key) (a answers)]\n       (cond\n         [(and (char? k) (char? a) (char=? a k)) 4]\n         [(and (string? k) (string? a) (string=? a k)) 4]\n         [(and (string? a) (not (non-empty-string? a))) 0]\n         [else -1]))))","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291233,"user_id":527,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n  (max 0 (for\/sum ([k key]\n                   [a answers])\n           (cond [(equal? a \"\") 0]\n                 [(equal? a k) 4]\n                 [else -1]))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291234,"user_id":null,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n  (define myRun(compareLists key answers 0))\n  (if (< myRun 0)\n      0\n      myRun\n      )\n  \n  )\n\n(define (compareLists k a n)\n  (if (or (> (length k) 0) (> (length a) 0))\n      (+ (compareValues k a) (compareLists (cdr k) (cdr a) (compareValues k a)))\n      0\n      )\n  \n  )\n\n(define (compareValues k a)\n  (cond\n   ((eq? (car a) \"\") 0)\n   ((eq? (car k) (car a)) 4)\n   ((not(eq? (car k) (car a))) -1)\n   \n  )\n  \n  )","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291235,"user_id":null,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n(let\n  [(n (apply + \n             (map (lambda (x y)\n                    (cond\n                     [(equal? \"\" y) 0]\n                     [(equal? x y) 4]\n                     [else -1])) \n                    key \n                    answers)))]\n  (if (negative? n)\n      0\n      n)))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291236,"user_id":null,"body":"#lang racket\n\n(provide check_exam)\n\n(define (rectify n)\n  (if (negative? n) 0 n))\n\n(define (question-score answer guess)\n  (cond\n    [(equal? \"\" guess) 0]\n    [else (if (equal? answer guess) 4 -1)]))\n\n(define (check_exam key answers)\n  (rectify (apply + (map question-score key answers))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291237,"user_id":null,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam keys answers)\n  (define result\n    (for\/fold ([acc 0])\n              ([k (in-list keys)]\n               [a (in-list answers)])\n      (cond\n        [(equal? a k) (+ acc 4)]\n        [(equal? a \"\") acc]\n        [else (sub1 acc)])))\n  (if (negative? result) 0 result))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291238,"user_id":544,"body":"#lang racket\n\n(provide check_exam)\n\n(define (check_exam key answers)\n  (define (check_exam-raw-score key answers)\n    (for\/sum ([k key]\n              [a answers])\n      (cond [(equal? \"\" a) 0]\n            [(equal? k a) 4]\n            [else -1])))\n  (let ([raw-score (check_exam-raw-score key answers)])\n    (if (< raw-score 0)\n        0\n        raw-score)))\n  \n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a3fe3dde1ce0e8ed6000097":[{"id":291239,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (ceiling (\/ year 100)))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291240,"user_id":645,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (floor (\/ (+ year 99) 100)))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291241,"user_id":564,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (add1 (floor (\/ (sub1 year) 100))))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291242,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year y)\n  (+ 1\n     (quotient (- y 1)\n               100)))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291243,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (define-values (q r) (quotient\/remainder year 100))\n  (if (= r 0) q (add1 q)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291244,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (floor (\/ (+ (- year 1) 100) 100)))\n\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291245,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (if(> (\/ year 100) (round(\/ year 100)))\n     (+ (round(\/ year 100)) 1)\n     (round(\/ year 100))\n     )\n  )\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291246,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n\n(define (century_from_year year)\n  (cond\n   [(= (remainder year 100) 0) (\/ year 100)]\n   \n   [ else (inexact->exact (floor (+ (* year .01) 1)))])) ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291247,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n\n(define (century_from_year year)\n  (+ 1 (quotient (+ -1 year) 100)))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291248,"user_id":null,"body":"#lang racket\n(provide century_from_year)\n(require srfi\/8)\n\n(define (century_from_year year)\n  (receive (q r)(quotient\/remainder year 100)\n           (if(zero? r)\n              q\n              (+ 1 q))))\n  ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a48948e145c46820b00002f":[{"id":291249,"user_id":53,"body":"; In **Racket** a last possible pair is (i, i + step) \n; with i <= n < i + step (see last sample test)\n\n#lang racket\n(provide kprimes-step)\n\n(define (count-factors k)\n  (define (aux i n acc)\n    (cond \n      [(> i (quotient n i)) (if (> n 1) (add1 acc) acc)]\n      [(zero? (modulo n i)) (aux i (quotient n i) (add1 acc))]\n      [else (aux (add1 i) n acc)]))\n  (aux 2 k 0))\n\n(define (kprimes-step k step start nd)\n  (define (aux n acc)\n    (cond \n      [(> n nd) (reverse acc)]\n      [(and (= k (count-factors n)) (= k (count-factors (+ n step)))) (aux (add1 n) (cons (list n (+ n step)) acc))]\n      [else (aux (add1 n) acc)]))\n  (aux start null))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291250,"user_id":492,"body":"#lang racket\n(provide kprimes-step)\n\n(define (kprimes-step k step start nd)\n  (define (nb-factors nb k)  \n    (define (loop n i cnt)\n      (if (= n 1)\n          (= k cnt)\n          (if (= 0 (remainder n i))\n              (loop (quotient n i) i (add1 cnt))\n              (loop n (add1 i) cnt))))\n    (loop nb 2 0))\n  (define (count-kprimes k start nd) \n    (define (loop i k-primes)\n      (if (> i nd)\n          k-primes\n          (if (nb-factors i k)\n              (loop (add1 i) (cons i k-primes)) \n              (loop (add1 i) k-primes))))\n    (reverse (loop start '())))\n  \n  (for\/list ([p (count-kprimes k start nd)]\n             #:when (nb-factors (+ p step) k))\n    (list p (+ p step))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291251,"user_id":null,"body":"#lang racket\n; In **Racket** a last possible pair is (i, i + step) \n; with i <= n < i + step (see last sample test)\n(provide kprimes-step)\n\n(define (bi-primes m)\n  (let ([ps (make-vector m #t)])\n    (vector-set! ps 0 #f)\n    (vector-set! ps 1 #f)\n    (let iter-primes ([i 2])\n      (when (< i m)\n        (let update-ps ([j 2])\n          (when (< (* j i) m)\n            (vector-set! ps (* j i) #f)\n            (update-ps (add1 j))))\n        (iter-primes (let next-prime ([j (add1 i)])\n                       (cond [(>= j m) j]\n                             [(even? j) (next-prime (add1 j))]\n                             [(vector-ref ps j) j]\n                             [else (next-prime (+ 2 j))])))))\n    ps))\n\n(define (kprimes-step k step start nd)\n  (define bips (bi-primes nd))\n  (define (get-prime-factors x)\n    (let ([M (floor (sqrt x))])\n      (let rec-factors ([p 2] [x1 x])\n        (cond [(= x1 1) '()]\n              [(> p M) (cons x1 '())]\n              [(zero? (remainder x1 p))\n               (cons p (rec-factors 2 (quotient x1 p)))]\n              [else (rec-factors (let next-prime ([j (add1 p)])\n                                   (cond [(> j M) j]\n                                         [(even? j) (next-prime (add1 j))]\n                                         [(vector-ref bips j) j]\n                                         [else (next-prime (+ 2 j))]))\n                                x1)]))))\n  (let* ([N (+ 1 (- (+ nd step) start))]\n         [N1 (+ 1 (- nd start))]\n         [xs (build-vector N (lambda (x) (+ x start)))]\n         [ips (map (lambda (x) (cons x (+ x step)))\n                   (build-list N1 values))]\n         [ns (vector-map (lambda (x) (length (get-prime-factors x)))\n                  xs)]\n         [single-result (lambda (p1 p2)\n                          (if (and (= (vector-ref ns p1) (vector-ref ns p2))\n                                   (= (vector-ref ns p2) k))\n                              (list* (vector-ref xs p1) (vector-ref xs p2) '())\n                              '()))])\n    (foldr (lambda (p rs)\n             (let ([r (single-result (car p) (cdr p))])\n               (if (null? r) rs (cons r rs)))) '() ips)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291252,"user_id":null,"body":"; In **Racket** a last possible pair is (i, i + step) \n; with i <= n < i + step (see last sample test)\n\n#lang racket\n(provide kprimes-step)\n\n(define (bi-primes m)\n  (let ([ps (make-vector m #t)])\n    (vector-set! ps 0 #f)\n    (vector-set! ps 1 #f)\n    (let iter-primes ([i 2])\n      (when (< i m)\n        (let update-ps ([j 2])\n          (when (< (* j i) m)\n            (vector-set! ps (* j i) #f)\n            (update-ps (add1 j))))\n        (iter-primes (let next-prime ([j (add1 i)])\n                       (cond [(>= j m) j]\n                             [(even? j) (next-prime (add1 j))]\n                             [(vector-ref ps j) j]\n                             [else (next-prime (+ 2 j))])))))\n    ps))\n\n(define (primes m)\n  (let ([bips (bi-primes m)])\n    (let gen ([i 2])\n      (cond [(>= i m) '()]\n            [(vector-ref bips i) (cons i (gen (add1 i)))]\n            [else (gen (add1 i))]))))\n\n(define (kprimes-step k step start nd)\n  (define bips (bi-primes nd))\n  (define (get-prime-factors x)\n    (let ([M (floor (sqrt x))])\n      (let rec-factors ([p 2] [x1 x])\n        (cond [(= x1 1) '()]\n              [(> p M) (cons x1 '())]\n              [(zero? (remainder x1 p))\n               (cons p (rec-factors 2 (quotient x1 p)))]\n              [else (rec-factors (let next-prime ([j (add1 p)])\n                                   (cond [(> j M) j]\n                                         [(even? j) (next-prime (add1 j))]\n                                         [(vector-ref bips j) j]\n                                         [else (next-prime (+ 2 j))]))\n                                x1)]))))\n  (let* ([N (+ 1 (- (+ nd step) start))]\n         [N1 (+ 1 (- nd start))]\n         [xs (build-vector N (lambda (x) (+ x start)))]\n         [ips (map (lambda (x) (cons x (+ x step)))\n                   (build-list N1 values))]\n         [ns (vector-map (lambda (x) (length (get-prime-factors x)))\n                  xs)]\n         [single-result (lambda (p1 p2)\n                          (if (and (= (vector-ref ns p1) (vector-ref ns p2))\n                                   (= (vector-ref ns p2) k))\n                              (list (vector-ref xs p1) (vector-ref xs p2))\n                              '()))])\n    (foldr (lambda (p rs)\n             (let ([r (single-result (car p) (cdr p))])\n               (if (null? r) rs (cons r rs)))) '() ips)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291253,"user_id":null,"body":"#lang racket\n(provide kprimes-step)\n\n(define (kprimes-step k step start end)\n\n  (define (k-value number)\n    (define (aux count i n)\n      (cond\n        [(> (* i i) n) (if (> n 1) (add1 count) count)]\n        [(zero? (remainder n i)) (aux (add1 count) i (quotient n i))]\n        [else (aux count (add1 i) n)]))\n    (aux 0 2 number))\n\n  (define (loop i acc)\n    (cond\n      [(> i end) (reverse acc)]\n      [(and (= (k-value i) k) (= (k-value (+ i step)) k))\n       (loop (add1 i) (cons (list i (+ i step)) acc))]\n      [else (loop (add1 i) acc)]))\n\n  (loop start '()))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291254,"user_id":null,"body":"#lang racket\n(provide kprimes-step)\n\n(define (factors n)\n  (let loop ((n n) (d 2) (k 0))\n    (cond ((= n 1) k)\n          ((zero? (remainder n d)) (loop (quotient n d) d (add1 k)))\n          (else (loop n (add1 d) k)))))\n\n(define (steps step ns)\n  (define n (car ns))\n  (let loop ((ns (cdr ns)))\n    (if (null? ns)\n        '()\n        (let* ((m (car ns))\n               (d (- m n)))\n          (cond ((< d step) (loop (cdr ns)))\n                ((> d step) '())\n                (else (list (list n m))))))))\n\n(define (kprimes-step k step start end)\n  (define ns (filter (lambda (n) (= k (factors n)))\n                     (range (max 2 start) (+ end step 1))))\n  (let loop ((ns ns) (acc '()))\n    (if (<= (length ns) 1)\n        acc\n        (loop (cdr ns) (append acc (steps step ns))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a4d303f880385399b000001":[{"id":291255,"user_id":null,"body":"#lang racket\n\n(provide strong)\n\n(define (strong n)\n  \n  (define (fact n)\n    (define (fact-helper n s)\n      (if (= n 1)\n          s\n          (fact-helper (- n 1) (* s n))))\n    (if (< n 1)\n        1\n        (fact-helper n 1)))\n                       \n                       \n  (define (helper n s)\n    (if (< n 10)\n        (+ s (fact n))\n        (helper (floor (\/ n 10)) (+ (fact (- n (* 10 (floor (\/ n 10))))) s))))\n  \n  (if (or (= n (helper n 0))\n          (= n 1))\n      \"STRONG!!!!\"\n      \"Not Strong !!\"))  \n      ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291256,"user_id":null,"body":"#lang racket\n\n(provide strong)\n\n;; 1,2,145,40585 are the only strong numbers that exist\n(define (strong? n)\n  (match n \n    [1 #t]\n    [2 #t]\n    [145 #t]\n    [40585 #t]\n    [_ #f]))\n\n(define (strong n)\n  (if (strong? n)\n    \"STRONG!!!!\"\n    \"Not Strong !!\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291257,"user_id":53,"body":"#lang racket\n\n(provide strong)\n\n(define (strong n)\n  (cond ((member n (list 1 2 145 40585)) \"STRONG!!!!\")\n    (else \"Not Strong !!\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291258,"user_id":null,"body":"#lang racket\n\n(provide strong)\n\n(define (strong n)\n  (if (or (= n 1) (= n 2) (= n 145) (= n 40585))\n      \"STRONG!!!!\"\n      \"Not Strong !!\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291259,"user_id":null,"body":"#lang racket\n(provide strong)\n\n(define (test n)\n  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [(= n 3) 6]\n    [(= n 4) 24]\n    [(= n 5) 120]\n    [(= n 6) 720]\n    [(= n 7) 5040]\n    [(= n 8) 40320]\n    [(= n 9) 362880]\n    [else 1])\n)\n\n(define (strong2 number sample answer)\n  (if (= number 0)\n    (cond\n      [(= sample answer) \"STRONG!!!!\"]\n      [else \"Not Strong !!\"])\n    (strong2 (quotient number 10) sample\n      (+ answer (test (remainder number 10)))))\n)\n\n(define (strong n)\n  (strong2 n n 0)\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291260,"user_id":null,"body":"#lang racket\n\n(provide strong)\n\n\n(define (strong n)\n  (define (factorial n)\n    (if (zero? n)\n        1\n        (let loop ((i 1) (acc 1))\n          (if (> i n)\n              acc\n              (loop (add1 i) (* acc i))))))\n  (let loop ((rem n) (acc 0))\n    (cond ((and (zero? rem)\n                (equal? acc n))\n           \"STRONG!!!!\")\n          ((zero? rem)\n           \"Not Strong !!\")\n          (else (loop\n                 (quotient rem 10)\n                 (+ acc (factorial (remainder rem 10))))\n                 )\n          )\n    )\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291261,"user_id":373,"body":"#lang racket\n\n(provide strong)\n\n(define (fac n)\n  (dict-ref #hash((0 . 1)\n                  (1 . 1)\n                  (2 . 2)\n                  (3 . 6)\n                  (4 . 24)\n                  (5 . 120)\n                  (6 . 720)\n                  (7 . 5040)\n                  (8 . 40320)\n                  (9 . 362880)\n                  ) \n            n))\n\n(define (list_num n) (if (< n 10) (list n) (cons (remainder n 10) (list_num (quotient n 10)))))\n(define (is_strong n) (= n (foldl + 0 (map fac (list_num n)))))\n\n(define (strong n)\n  (if (is_strong n) \"STRONG!!!!\" \"Not Strong !!\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291262,"user_id":null,"body":"#lang racket\n\n(provide strong)\n\n(define (factorial n)\n  (if (> n 1)\n      (* n (factorial (- n 1)))\n      1))\n(define (strong n)\n  (let loop ((a n) (s 0))\n    (if (= a 0)\n        (if (= n s)\n            \"STRONG!!!!\"\n            \"Not Strong !!\")\n    (loop (quotient a 10) (+ s (factorial (remainder a 10)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291263,"user_id":null,"body":"#lang racket\/base\n\n(provide strong)\n\n(define (strong n)\n  (case n\n    ;; there are only 4 strong numbers\n    ((1 2 145 40585) \"STRONG!!!!\")\n    (else \"Not Strong !!\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291264,"user_id":null,"body":"#lang racket\n\n(provide strong)\n\n(define (fac n)\n  (if (= 0 n)\n      1\n      (* n (fac (- n 1)))))\n\n(define (char->digit ch)\n  (- (char->integer ch) 48))\n\n(define (strong n)\n  (if (= n (for\/sum ((ch (in-string (number->string n)))) (fac (char->digit ch))))\n      \"STRONG!!!!\"\n      \"Not Strong !!\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a662a02e626c54e87000123":[{"id":291265,"user_id":53,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n) (filter odd? (inclusive-range 1 n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291266,"user_id":527,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n)\n  (range 1 (add1 n) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291267,"user_id":645,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n)\n  (filter odd? (range 1 (add1 n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291268,"user_id":null,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n)\n  (inclusive-range 1 n 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291269,"user_id":null,"body":"#lang racket\n(provide extra_perfect)\n\n(define (extra2 n answer)\n  (if (= n 0) answer\n    (if (= (remainder n 2) 1) (extra2 (- n 1)\n\t(cons n answer)) (extra2 (- n 1) answer)))\n)\n\n(define (extra_perfect n)\n  (extra2 n '())\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291270,"user_id":null,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n) (filter odd? (range 1 (+ n 1))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291271,"user_id":373,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n)\n  (letrec ([g (lambda (now end) (if (> now end) '() (cons now (g (+ 2 now) end))))])\n  (g 1 n ))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291272,"user_id":null,"body":"#lang racket\n\n(provide extra_perfect)\n\n;; Check if input `n` is an extra_perfect number\n(define (extra_perfect? n)\n  (let ([first-bit-set? (= 1 (bitwise-and n 1))]\n        [last-bit-set?  (= n (bitwise-ior n 1))])\n    (and first-bit-set? last-bit-set?)))\n\n;; Find all extra_perfect numbers p <= `n`\n(define (extra_perfect n)\n  (foldl (lambda (i output)\n           (if (extra_perfect? i)\n               (append output (list i))\n               output))\n         '()\n         (range (add1 n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291273,"user_id":null,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n)\n  (for\/list ([i (stop-after (in-naturals) (const (= i n)))]\n             #:when (odd? i))\n    i))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291274,"user_id":null,"body":"#lang racket\n\n(provide extra_perfect)\n\n(define (extra_perfect n)\n  (cond\n    ((= n 0) '())\n    ((= (remainder  n 2) 0) (extra_perfect (- n 1)))\n    (else (append  (extra_perfect (- n 1)) (list n)))\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a805d8cafa10f8b930005ba":[{"id":291275,"user_id":null,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n)\n  (inexact->exact (expt (round (sqrt n)) 2)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291276,"user_id":null,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n)\n  (inexact->exact (sqr (round (sqrt n)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291277,"user_id":373,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n)\n  (let ([r (exact-floor (+ (sqrt n) 0.5))]) (* r r)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291278,"user_id":null,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n)\n  (if (> (- (ceiling (sqrt n)) (sqrt n)) (- (sqrt n) (floor (sqrt n))))\n      (sqr (floor (inexact->exact (sqrt n))))\n      (sqr (ceiling (inexact->exact (sqrt n))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291279,"user_id":null,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n)\n  (let ((rounded-root (round (sqrt n))))\n    (exact-floor (* rounded-root rounded-root))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291280,"user_id":null,"body":"#lang racket\n\n(provide nearest_square)\n\n;; Integer>0 -> Integer>0\n(define (nearest_square n)\n  \n  (define (square? n) (= n (expt (integer-sqrt n) 2)))\n  \n  (define (search left right)\n    (cond\n      [(and (positive? left) (square? left)) left]\n      [(square? right) right]\n      [else (search (sub1 left) (add1 right))]))\n\n  (search n n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291281,"user_id":1474,"body":"#lang racket\n(provide nearest_square)\n\n(define (sq n) (* n n))\n\n(define (nearest_square n)(sq (exact-round (sqrt n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291282,"user_id":null,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n) (expt (exact-round (sqrt n)) 2))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291283,"user_id":104,"body":"#lang racket\n(provide nearest_square)\n\n(define (square n) (* n n))\n(define (isqrt n) (round (sqrt n)))\n(define (nearest_square n)\n  (square (inexact->exact (isqrt n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291284,"user_id":527,"body":"#lang racket\n(provide nearest_square)\n\n(define (nearest_square n)\n  (sqr (exact-round (sqrt n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5a99a03e4a6b34bb3c000124":[{"id":291285,"user_id":53,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (is-prime? n)\n  (define (aux i)\n    (cond \n      [(> (* i i) n) #t]\n      [(or (zero? (modulo n i)) (zero? (modulo n (+ i 2)))) #f]\n      [else (aux (+ i 6))]))\n  (cond\n    [(or (zero? (modulo n 2)) (zero? (modulo n 3))) (< n 4)]\n    [else (aux 5)]))\n\n(define (num_primorial n)\n  (define (aux i r m)\n    (cond \n      [(= m n) r]\n      [(is-prime? i) (aux (add1 i) (* r i) (add1 m))]\n      [else (aux (add1 i) r m)]))\n  (aux 2 1 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291286,"user_id":168,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (num_primorial n)\n  (vector-ref #(1 2 6 30 210 2310 30030 510510 9699690 223092870 6469693230 200560490130 7420738134810 304250263527210 13082761331670030 614889782588491410) n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291287,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (prime? n)\n  (or (< n 4)\n  (not (for\/or ([t (range 2 (add1 (sqrt n)))]) (> (gcd t n) 1)))))\n\n(define (first-n-primes n)\n  (define found 0)\n  (for\/list ([i (in-naturals 2)] #:when (prime? i) #:break (= found n)) (set! found (add1 found)) i))\n\n(define (num_primorial n)\n  (apply * (first-n-primes n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291288,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (prime? n)\n  (define (helper i)\n    (cond [(= i n) true]\n          [(= 0 (modulo n i)) false]\n          [ else (helper (+ 1 i))]))\n  (helper 2))\n                   \n(define (num_primorial n)\n  (define (helper xs i)\n    (cond [(= (length xs) n) (foldr * 1 xs)]\n          [(prime? i) (helper (cons i xs) (+ 1 i))]\n          [else (helper xs (+ 1 i))]))\n  (helper '(2) 3))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291289,"user_id":null,"body":"#lang racket\n\n(require racket\/list)\n\n(provide num_primorial)\n\n(define (next-prime primeseq n)\n  (if (andmap (lambda (x) (not (= (remainder n x) 0))) primeseq) \n        n\n        (next-prime primeseq (+ n 1))     \n  ))\n\n(define (nth-prime-seq n)\n  (if (= n 1) '(2)\n      (let* ([old_seq (nth-prime-seq (- n 1))]\n            [new_prime (last old_seq)])\n          (append old_seq (list (next-prime old_seq (+ new_prime 1)) ) )\n        )\n      )\n  )\n\n\n(define (num_primorial n)\n  (foldl * 1 (nth-prime-seq n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291290,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (num_primorial n)\n  (define (n-primes count p primes)\n    (if (= count n)\n        primes\n        (if (prime? p)\n            (n-primes (+ count 1) (+ p 1) (cons p primes))\n            (n-primes count (+ p 1) primes))))\n  (let ([lst (n-primes 0 2 '())])\n    (foldl * 1 lst)))\n\n(define (prime? n)\n  (define (iter x)\n    (cond [(> (* x x) n) true]\n          [(= 0 (remainder n x)) false]\n          [else (iter (+ x 2))]))\n  (cond [(< n 2) false]\n        [(= n 2) true]\n        [(= 0 (remainder n 2)) false]\n        [else (iter 3)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291291,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (prime? n)\n  (cond\n    [(or (= n 0) (= n 1)) #f]\n    [else\n     (for\/and ([i (in-range 2 n)])\n       (not (equal? (modulo n i) 0)))]))\n\n(define (next-prime n)\n  (let ([m (+ 1 n)])\n    (if (prime? m) m (next-prime m))))\n\n(define (next-prime\/list lop)\n  (if (empty? lop) '(2)\n    (append lop (cons\n                (next-prime (last lop)) '()))))\n  \n(define (first-n-primes n [lop '()])\n  (if (> n 0)\n      (first-n-primes (- n 1) (next-prime\/list lop))\n      lop))\n(define (num_primorial n)\n  (apply * (first-n-primes n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291292,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (num_primorial n)\n  #| 1 => 1 x |2| = 2 |#\n  #| 2 => 1 x |2| x |3| = 6 |#\n  #| 3 => 1 x |2| x |3| x 4 x |5| = 30 |#\n  (mult-n-primes n 0 1 1))\n\n(define (mult-n-primes n count number result)\n  (cond ((eq? n count) result)\n        ((prime? number)\n         (mult-n-primes n (add1 count) (add1 number) (* result number)))\n        (else\n         (mult-n-primes n count (add1 number) result))))\n\n(define (prime? n)\n  (mod-prev n (integer-sqrt n)))\n\n(define (mod-prev n prev)\n  (cond ((= prev 0) #f)\n        ((and (eq? prev 1) (not (eq? n 1)) #t))\n        ((eq? (modulo n prev) 0) #f)\n        (else (mod-prev n (sub1 prev)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291293,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (num_primorial n)\n  #| 1 => 1 x |2| = 2 |#\n  #| 2 => 1 x |2| x |3| = 6 |#\n  #| 3 => 1 x |2| x |3| x 4 x |5| = 30 |#\n  (mult-n-primes n 0 1 1))\n\n(define (mult-n-primes n count number result)\n  (cond ((eq? n count) result)\n        ((prime? number)\n         (mult-n-primes n (add1 count) (add1 number) (* result number)))\n        (else \n         (mult-n-primes n count (add1 number) result))))\n\n(define (prime? n)\n  (mod-prev n (sub1 n)))\n\n(define (mod-prev n prev)\n  (cond ((= prev 0) #f)\n        ((eq? prev 1) #t)\n        ((eq? (modulo n prev) 0) #f)\n        (else (mod-prev n (sub1 prev)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291294,"user_id":null,"body":"#lang racket\n\n(provide num_primorial)\n\n(define (is-prime? n lop)\n  (define sqrtn (sqrt n))\n    (let loop ([lop lop])\n      (cond [(or (empty? lop) (< sqrtn (first lop))) true]\n            [(zero? (modulo n (first lop))) false]\n            [else (loop (rest lop))])))\n\n(define (find-n-primes n)\n  (cond [(<= n 0) '()]\n        [(=  n 1) '(2)]\n        [(=  n 2) '(2 3)]\n        [else\n         (let loop ([lop '(2 3)] [i 5])\n           (cond [(>= (length lop) n) lop]\n                 [(is-prime? i lop) (loop (append lop (list i)) (+ i 2))]\n                 [else (loop lop (+ i 2))]))]))\n\n(define (num_primorial n)\n  (apply * (find-n-primes n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5aa1bcda373c2eb596000112":[{"id":291295,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (unique items)\n  (if (null? items) '()\n    (let ([x (car items)][rest (unique (cdr items))])\n      (if (member x rest) rest (cons x rest)))))\n\n(define (max_tri_sum nums)\n  (apply max (map (lambda (x) (apply + x)) (combinations (unique nums) 3))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291296,"user_id":544,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (apply + (take (sort (remove-duplicates nums) >) 3)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291297,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (uniq lst)\n  (if (< (length lst) 2)\n      lst\n      (if (= (car lst) (cadr lst))\n          (uniq (cdr lst))\n          (cons (car lst) (uniq (cdr lst))))))\n\n(define (max_tri_sum nums)\n  (let* ((sorted (sort nums <))\n         (deduped (uniq sorted)))\n    (apply + (drop deduped (- (length deduped) 3)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291298,"user_id":168,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (apply + (take (sort (set->list (list->set nums)) >) 3)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291299,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (let ( [sorted (sort nums >)] )\n    (apply + (take (remove-duplicates sorted) 3))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291300,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (let* ([dupless (remove-duplicates nums)]\n         [greater-than? (lambda (a b) (> a b))]\n         [sorted (sort dupless greater-than?)]\n         [triplet (take sorted 3)])\n  (foldl + 0 triplet)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291301,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (let*\n    ([sorted (sort nums >)]\n     [nums_ordered (remove-duplicates sorted)])\n    (match nums_ordered \n      [(list* a b c _) (+ a b c)])\n   )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291302,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (list-rev lst)\n  (define (aux acc lst)\n    (if (equal? '() lst) acc (aux (cons (car lst) acc) (cdr lst))))\n  (aux '() lst))\n\n(define (list-merge lhs rhs)\n  (define (put from to)\n    (if (equal? '() from) to (put (cdr from) (cons (car from) to))))\n  (define (aux lhs rhs acc)\n    (cond\n      [(equal? '() lhs) (put rhs acc)]\n      [(equal? '() rhs) (put lhs acc)]\n      [(<= (car lhs) (car rhs)) (aux (cdr lhs) rhs (cons (car lhs) acc))]\n      [else (aux lhs (cdr rhs) (cons (car rhs) acc))]))\n  (list-rev (aux lhs rhs '())))\n\n(define (iter-merge lst)\n  (define (aux lst acc)\n    (cond\n      [(equal? '() lst) acc]\n      [(equal? '() (cdr lst)) (cons (car lst) acc)]\n      [else (aux (cdr (cdr lst)) (cons (list-merge (car lst) (car (cdr lst))) acc))]))\n  (aux lst '()))\n\n(define (map fn lst)\n  (define (aux lst acc)\n    (if (equal? '() lst) acc (aux (cdr lst) (cons (fn (car lst)) acc))))\n  (aux lst '()))\n\n(define (merge-sort lst)\n  (define (listify e) (cons e '()))\n  (define (mainloop lst)\n    (cond\n      [(equal? '() lst) '()]\n      [(equal? '() (cdr lst)) (car lst)]\n      [else (mainloop (iter-merge lst))]))\n  (mainloop (map listify lst)))\n  \n(define (unique lst)\n  (define (aux lst acc)\n    (cond\n      [(equal? '() lst) acc]\n      [(equal? '() acc) (aux (cdr lst) (cons (car lst) '()))]\n      [(equal? (car lst) (car acc)) (aux (cdr lst) acc)]\n      [else (aux (cdr lst) (cons (car lst) acc))]))\n  (list-rev (aux lst '())))\n\n(define (unique-desc lst)\n  (list-rev (unique (merge-sort lst))))\n\n\n(define (max_tri_sum nums)\n  (define (sum-3-fst lst)\n    (+ (first lst) (second lst) (third lst)))\n  (sum-3-fst (unique-desc nums)))\n  \n  \n  \n  \n  \n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291303,"user_id":null,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (foldl + 0 (take (remove-duplicates (sort nums >)) 3)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291304,"user_id":645,"body":"#lang racket\n\n(provide max_tri_sum)\n\n(define (max_tri_sum nums)\n  (foldl + 0 (take (sort (remove-duplicates nums) >) 3)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5aba780a6a176b029800041c":[{"id":291305,"user_id":null,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple divisor bound)\n  (- bound ( remainder bound divisor)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291306,"user_id":645,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple divisor bound)\n  (- bound (modulo bound divisor)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291307,"user_id":null,"body":"#lang racket\n(provide max_multiple)\n\n(define (max_multiple2 divisor bound counter)\n  (if (>= (* counter divisor) bound)\n    (* (- counter 1) divisor)\n    (max_multiple2 divisor bound (+ counter 1)))\n)\n\n(define (max_multiple divisor bound)\n  (if (= (remainder bound divisor) 0) \n    bound (max_multiple2 divisor bound 1))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291308,"user_id":null,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple divisor bound)\n  (for\/fold ([acc 0])\n            ([i (in-naturals)]\n             #:break (> (* divisor i) bound))\n    (if (<= (* divisor i) bound) (* divisor i) acc)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291309,"user_id":null,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple divisor bound)\n (if (= (remainder bound divisor) 0)bound\n     (max_multiple divisor (- bound 1))) #| your code here |#)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291310,"user_id":null,"body":"#lang racket\n\n(provide max_multiple)\n\n;; Integer>0 Integer>0 -> Integer>0\n;; given a divisor and a bound, find the largest integer n such that\n;; n is divisable by divisor & n <= bound & n > 0.\n(define (max_multiple divisor bound)\n  (for\/or ([n (in-range bound 0 -1)]\n           #:when (zero? (remainder n divisor)))\n    n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291311,"user_id":53,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple d b)\n  (* d (floor (\/ b d))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291312,"user_id":492,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple d b)\n  (- b (modulo b d)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291313,"user_id":null,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple divisor bound)\n    (* (quotient bound divisor) divisor)         \n  \n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291314,"user_id":null,"body":"#lang racket\n\n(provide max_multiple)\n\n(define (max_multiple divisor bound)\n  (define (max-mult-h i maxx)\n    (if (<= i bound)\n      (if (= 0 (modulo i divisor))\n        (max-mult-h (+ 1 i) i)\n        (max-mult-h (+ 1 i) maxx))\n        maxx))\n    (max-mult-h 0 0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ac6932b2f317b96980000ca":[{"id":291315,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (let ([l (sort (remove-duplicates ns) <)])\n    (string->number (apply ~a l))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291316,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (let ([sorted-list (remove-duplicates (sort ns <))])\n    (for\/fold ([val 0])\n              ([i sorted-list])\n      (+ (* 10 val) i))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291317,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (string->number(getDigits ns 0))\n  )\n\n(define (getDigits myList currentDigit)\n  (if (> currentDigit 9)\n      \"\"\n      (if (isIn myList currentDigit)\n          (string-append (number->string currentDigit) (getDigits myList (+ currentDigit 1)))\n          (getDigits myList (+ currentDigit 1))\n          )\n      )\n  )\n\n(define (isIn myList searchNumber)\n  (if (null? myList)\n      #f\n      (if (= (car myList) searchNumber)\n          #t\n          (isIn (cdr myList) searchNumber)\n          )\n      )\n  \n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291318,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (string->number  \n   (apply string-append \n          (map number->string \n               (remove-duplicates \n                (sort ns <))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291319,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value digits)\n  (string->number (apply string-append\n         (map number->string (sort (remove-duplicates digits) <)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291320,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (list->number (reverse (sort (remove-duplicates ns) <))))\n\n(define (list->number lon [m 1])\n  (cond\n   [(empty? lon) 0]\n   [else\n    (+ (* m (first lon)) (list->number (rest lon) (* m 10)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291321,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (concat-numbers (sort (remove-duplicates ns) <)))\n\n(define (concat-numbers alon)\n  (string->number (strings->string (map number->string alon))))\n\n(define (strings->string sts)\n  (apply string-append sts))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291322,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (let ([sorted (sort (remove-duplicates ns) >)])\n    (for\/fold ([val 0]\n               [place 0]\n               #:result val)\n              ([n sorted])\n      (values\n       (+ val (* n (expt 10 place)))\n       (+ place 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291323,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (let go ([lst (sort (unique ns) >)]\n           [sum 0]\n           [place 0])\n    (if (null? lst)\n        sum\n        (go (cdr lst)\n            (+ sum (* (car lst) (expt 10 place)))\n            (+ place 1)))))\n\n(define (unique lst)\n  (let go ([lst lst]\n           [seen null])\n    (cond\n     [(null? lst) seen]\n     [(member (car lst) seen) (go (cdr lst) seen)]\n     [else (go (cdr lst) (cons (car lst) seen))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291324,"user_id":null,"body":"#lang racket\n\n(provide min_value)\n\n(define (min_value ns)\n  (define short (sort (remove-duplicates ns) <))\n  (string->number\n    (foldr string-append \"\" \n      (map number->string short))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ad0d8356165e63c140014d4":[{"id":291325,"user_id":53,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade e p)\n  (cond ((or (> e 90) (> p 10)) 100)\n        ((and (> e 75) (> p 4)) 90)\n        ((and (> e 50) (> p 1)) 75)\n        (else 0)))\n ","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291326,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade a b)\n  (cond\n    ((or (> a 90) (> b 10)) 100)\n    ((and (> a 75) (>= b 5)) 90)\n    ((and (> a 50) (>= b 2)) 75)\n    ((and (>= a 0) (>= b 0)) 0)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291327,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (cond\n    [(or (> exam 90) (> projects 10)) 100]\n    [(and (> exam 75) (>= projects 5)) 90]\n    [(and (> exam 50) (>= projects 2)) 75]\n    [else 0]))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291328,"user_id":544,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (cond [(or (projects . > . 10) \n             (exam . > . 90)) 100]\n        [(and (projects . >= . 5) \n              (exam . > . 75)) 90]\n        [(and (projects . >= . 2) \n              (exam . > . 50)) 75]\n        [else 0]))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291329,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (if (or (> exam 90) (> projects 10))\n      100\n      (if (and (> exam 75) (>= projects 5))\n          90\n          (if (and (> exam 50) (>= projects 2))\n              75\n              0\n              )\n          )\n      )\n  )\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291330,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (cond\n   [(or (< 90 exam) (< 10 projects)) 100]\n   [(and (< 75 exam) (<= 5 projects)) 90]\n   [(and (< 50 exam) (<= 2 projects)) 75]\n   [else 0]))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291331,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (cond ((or (> exam 90) (> projects 10)) 100)\n        ((and (> exam 75) (> projects 4)) 90)\n        ((and (> exam 50) (> projects 1)) 75)\n        (#t 0)))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291332,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (cond\n    [(or (> exam 90) (> projects 10)) 100]\n    [(and (> exam 75) (> projects 4)) 90]\n    [(and (> exam 50) (> projects 1)) 75]\n    [else 0]))\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291333,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n(define (final_grade exam projects)\n  (if(or (> exam 90)(> projects 10))\n    100 \n    (if (and (> exam 75)(> projects 4))\n    90\n      (if (and (> exam 50)(> projects 1))\n      75\n      0))\n  )\n)\n ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291334,"user_id":null,"body":"#lang racket\n\n(provide final_grade)\n\n\n(define (final_grade exam projects)\n  (cond\n   [(or (> exam 90) (> projects 10)) 100]\n   [(and (> exam 75) (>= projects 5)) 90]\n   [(and (> exam 50) (>= projects 2)) 75]\n   \n   [#t 0]\n   ))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ae62fcf252e66d44d00008e":[{"id":291335,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n   (max (+ a b c)\n        (* a (+ b c))\n        (* (+ a b) c)\n        (* a b c)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291336,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n  (max (max (max (+ a (+ b c)) (* a (* b c))) (* (+ a b) c)) (* a (+ b c))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291337,"user_id":50,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n  (max (* a b c) (+ a b c) (* a (+ b c)) (+ (* a b) c) (* (+ a b) c)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291338,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n  (define (two-expr a b)\n    (max (* a b) (+ a b)))\n  (max (* a (two-expr b c))\n       (+ a (two-expr b c))\n       (two-expr (* a b) c)\n       (two-expr (+ a b) c)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291339,"user_id":373,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n  (max (+ a b c)\n       (* a b c)\n       (+ a (* b c))\n       (* (+ a b) c)\n       (+ (* a b) c)\n       (* a (+ b c))\n       ))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291340,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n  (max (+ a b c)\n       (+ a (* b c))\n       (+ (* a b) c)\n       (* a b c)\n       (* (+ a b) c)\n       (* a (+ b c))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291341,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n  (apply max (list (* a (+ b c)) \n                   (+ a (* b c))  \n                   (* c (+ a b))\n                   (* a b c)\n                   (+ a b c))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291342,"user_id":53,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n   (max (+ a b c)\n        (* a b c)\n        (* a (+ b c))\n        (* (+ a b) c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291343,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n(define (expression_matter a b c)\n(define v1 (+ a(+ b c)))\n(define v2 (* a(+ b c)))\n(define v3 (+ a(* b c)))\n(define v4 (* a(* b c)))\n(define v5 (* c(+ a b)))\n  (max v1 v2 v3 v4 v5)\n  )\n  \n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291344,"user_id":null,"body":"#lang racket\n(provide expression_matter)\n\n;; I'm just going to do this by brute force, I think...\n(define (expression_matter a b c)\n  ;; Noting that our possible values here are...\n  ;; 1. a * (b + c)\n  ;; 2. a + (b + c)\n  ;; 3. a * (b * c)\n  ;; 4. a + (b * c)\n  ;; 5. (a * b) + c\n  ;; 6. (a * b) * c ;; equivalent to #3\n  ;; 7. (a + b) * c\n  ;; 8. (a + b) + c ;; equivalent to #2\n  (max (* a (+ b c))\n       (+ a (+ b c))\n       (* a b c)\n       (+ a (* b c))\n       (+ (* a b) c)\n       (* (+ a b) c)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ae7e3f068e6445bc8000046":[{"id":291345,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (happy? year)\n  (not (check-duplicates (string->list (number->string year)))))\n\n(define (next_happy_year year)\n  (if (happy? (add1 year)) (add1 year) (next_happy_year (add1 year))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291346,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (happy-year? year)\n  (set! year (string->list (number->string year)))\n  (=\n   (length year)\n   (length (remove-duplicates year))))\n\n(define (next_happy_year year)\n  (define (next_happy_year year)\n    (cond\n      [(happy-year? year) year]\n      [else (next_happy_year (add1 year))]))\n  (next_happy_year (add1 year)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291347,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (next_happy_year year)\n  #| your code here |#\n  (define (hy? year)\n    (let\n      [(n (string->list (number->string year)))]\n      (= (length n) (length (remove-duplicates n)))))\n  (define (hy y)\n    (if (hy? y)\n        y\n        (hy (+ 1 y))))\n  (hy (+ 1 year)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291348,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (all-unique items)\n  (if (null? items)#t\n    (and (andmap (lambda (x) (not (equal? x (car items)))) (cdr items)) (all-unique (cdr items)))))\n\n(define (next_happy_year year)\n  (letrec\n    ([find-year (lambda (x)\n      (if (all-unique (string->list (number->string x))) x\n        (find-year (add1 x))))])\n    (find-year (add1 year))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291349,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (happy? year)\n  (let\n    ([lst (string->list (number->string year))])\n    (equal? (length lst) (length (remove-duplicates lst)))))\n\n(define (iter year)\n  (if (happy? year) year (iter (add1 year))))\n\n(define (next_happy_year year)\n  (iter (add1 year)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291350,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (happy? year)\n  (let ([year-str (string->list (number->string year))])\n    (equal? year-str (remove-duplicates year-str))))\n\n(define (next_happy_year year)\n  (let* ([happy-years (filter happy? (range (+ year 1) 9013))]\n         [next_happy_year (car happy-years)])\n    next_happy_year))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291351,"user_id":544,"body":"#lang racket\n\n(provide next_happy_year)\n\n; turn the number into a string and list the characters\n; check-duplicates returns #f if none are found\n(define (happy-year? year)\n  (not (check-duplicates (string->list (number->string year)))))\n\n(define (next_happy_year year)\n  (let ([n (add1 year)])\n    (if (happy-year? n)\n        n\n        (next_happy_year n))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291352,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (member? num lst)\n  (not (equal? (member num lst) #f)))\n\n(define (next_happy_year year)\n  (local [(define (number->list num) (string->list (number->string num)))\n          (define (happy-year? yer list-year)\n            (cond [(empty? list-year) yer]\n                  [(member? (first list-year) (rest list-year)) (happy-year? (add1 yer) (number->list (add1 yer)))]\n                  [else (happy-year? yer (rest list-year))]))]\n\n    (happy-year? (add1 year) (number->list (add1 year)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291353,"user_id":null,"body":"#lang racket\n\n(provide next_happy_year)\n\n(define (next_happy_year year)\n  (define (happy? y)\n    (let* ([s (string->list (number->string y))]\n           [uniq (remove-duplicates s)])\n      (= (length s) (length uniq))))\n  (for\/first ([i (in-naturals (add1 year))]\n              #:when (happy? i))\n    i))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291354,"user_id":492,"body":"#lang racket\n(provide next_happy_year)\n\n(define (next_happy_year n)\n  (define (digits n . args)\n    (let ((b (if (null? args) 10 (car args))))\n      (let loop ((n n) (d '()))\n        (if (zero? n) d\n            (loop (quotient n b)\n                  (cons (modulo n b) d))))))\n  \n  (let ((y (length (set->list (list->set (digits (add1 n)))))))\n    (if (= y 4)\n      (add1 n)\n    (next_happy_year (add1 n)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5af15a37de4c7f223e00012d":[{"id":291355,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men_from_boys arr)\n  #| your code here |#\n  (define evenList (getEvenList arr))\n  (define oddList (getOddList arr))\n  (remove-duplicates (append (sort evenList <) (sort oddList >)))\n  )\n\n  (define (getEvenList l)\n    (if (null? l)\n        '()\n    (if (even? (car l))\n        (append (list (car l)) (getEvenList (cdr l)))\n        (getEvenList (cdr l))\n        )\n        )\n    )\n  (define (getOddList l)\n    (if (null? l)\n        '()\n    (if (odd? (car l))\n        (append (list (car l)) (getOddList (cdr l)))\n        (getOddList (cdr l))\n        )\n        )\n    )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291356,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men_from_boys arr)\n  (let-values ([(men boys) (partition even? (remove-duplicates arr))])\n    (append (sort men <) (sort boys >))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291357,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men_from_boys arr)\n  (let ([even (remove-duplicates (sort (filter even? arr) <))]\n        [odd  (remove-duplicates (sort (filter odd? arr ) >))])\n    (cond [(null? even) odd]\n          [(null? odd) even]\n          [else (append even odd)])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291358,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men-asc-then-boys-desc first second)\n  (define first-remainder (remainder first 2))\n  (define second-remainder (remainder second 2))\n  (or\n   (and (zero? first-remainder) (zero? second-remainder) (<= first second))\n   (and (zero? first-remainder) (not (zero? second-remainder)))\n   (and (not (zero? first-remainder)) (not (zero? second-remainder)) (>= first second))))\n\n(define (men_from_boys arr)\n  (sort (remove-duplicates arr) men-asc-then-boys-desc))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291359,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n\n;; (Listof Number) -> (Listof Number)\n;; separate the even numbers (men) from the odds (boys) in a peculiar way\n;; ASSUME: no zeros in the given list\n(define (men_from_boys arr)\n  (define pruned (remove-duplicates arr))\n  (append (sort (filter even? pruned) <)\n          (sort (filter odd? pruned) >)))\n\n;; Best conceivable runtime: Theta(n)\n;; Actual runtime: Theta(3n) = Theta(n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291360,"user_id":544,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men_from_boys arr)\n  (let-values ([(evens odds) (partition even? (remove-duplicates arr))])\n    (append (sort evens <) (sort odds >))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291361,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men_from_boys arr)\n  (let-values (((evens odds) (partition even? (remove-duplicates arr))))\n    (append (sort evens <) (sort odds >))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291362,"user_id":null,"body":"#lang racket\n\n(provide men_from_boys)\n(require racket\/match)\n\n(define (men_from_boys arr)\n  (let-values ([(men boys) (partition even? arr)])\n              (remove-duplicates (append (sort men <) (sort boys >)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291363,"user_id":null,"body":"#lang racket\n\n\n(provide men_from_boys)\n\n(define (men_from_boys lst)\n  (let-values ([(men boys) (partition even? (remove-duplicates lst))])\n    (append (sort men <) (sort boys >))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291364,"user_id":168,"body":"#lang racket\n\n(provide men_from_boys)\n\n(define (men_from_boys arr)\n  (sort (remove-duplicates arr) (lambda (a b)\n              (if (odd? a) \n                  (if (odd? b) (< b a) #f)\n                  (if (odd? b) #t (< a b))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5b06c990908b7eea73000069":[{"id":291365,"user_id":53,"body":"#lang racket\n(provide f)\n\n(define (hypot z) (sqrt (+ (* (real-part z) (real-part z)) (* (imag-part z) (imag-part z)))))\n(define (f z eps) (max -1 (floor (log eps (hypot z)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291366,"user_id":168,"body":"#lang racket\n(provide f)\n\n(define (f z eps)\n  (define a (magnitude z))\n  (cond\n    [(> a 1) -1]\n    [(= a 1) 1]\n    [else (\/ (log eps) (log a))])\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291367,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f z e)\n  (if (> (magnitude z) 1)\n      -1\n      (floor (\/ (log e) (log (magnitude z))))\n      )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291368,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f z eps)\n  (let ([m (magnitude z)])\n    (if (>= m 1)\n        -1\n        (exact-floor (\/ (log eps) (log m))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291369,"user_id":null,"body":"#lang racket\n\n(provide f)\n\n(define (f z eps)\n  (if (>= (magnitude z) 1)\n      -1\n      (for\/last ([n (in-naturals 1)]\n                 #:final (<= (magnitude (expt z n)) eps))\n        n)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291370,"user_id":null,"body":"#lang racket\n\n(provide f)\n\n(define (f z eps)\n  (define eps-squared (* eps eps)) \n  (if (>= (modulus-squared z) 1)\n      -1\n      (for\/last ([n (in-naturals 1)]\n                 #:final (<= (modulus-squared (expt z n)) eps-squared))\n        n)))\n\n(define (modulus-squared z)\n  (+ (sqr (real-part z)) (sqr (imag-part z))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291371,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f z eps)\n  (cond\n    [(>= (magnitude z) 1) -1]\n    [else\n     (for\/first ([n (in-naturals)]\n       #:when (< (magnitude (expt z (add1 n))) eps))\n       n)]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291372,"user_id":492,"body":"#lang racket\n(provide f)\n\n(define (f z eps)\n  (let ([m (magnitude z)])\n    (if (>= m 1)\n        -1\n        (exact-floor (\/ (log eps) (log (magnitude z)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5b077ebdaf15be5c7f000077":[{"id":291373,"user_id":53,"body":"#lang racket\n\n(provide count_sheep)\n(define (inclusive-range a b) (range a (add1 b)))\n(define (count_sheep n) \n  (string-join (map (\u03bb (i) (format \"~a sheep...\" i)) (inclusive-range 1 n)) \"\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291374,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (if (= count 0)\n      \"\"\n      (string-append (count_sheep (- count 1)) (string-append (number->string count) \" sheep...\"))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291375,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (if (= count 0)\n        \"\"\n        (string-append (count_sheep (- count 1)) (string-append (number->string count) \" sheep...\"))))\n\n(count_sheep 10)\n","lang_id":44,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291376,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count [i 1])\n  (if (<= i count) \n      (string-join (list (~a i) \" sheep...\" (count_sheep count (add1 i)))\"\")\n      \"\"))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291377,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (string-append* (map (lambda (x) (format \"~a sheep...\" x)) (range 1 (+ count 1) 1)))\n  )\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291378,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (cond\n   [(equal? count 0) \"\"]\n   [else (string-append (count_sheep (sub1 count)) (string-append (~v count) \" sheep...\" ))]))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291379,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count [i 0])\n  (if (= count i)\n      \"\"\n      (string-join\n       (list\n        (number->string (+ i 1))\n        \" sheep...\"\n        (count_sheep count (+ i 1))) \"\")))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291380,"user_id":null,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (define (loop c)\n    (cond [(zero? c) '()]\n          [else (cons (format \"~a sheep...\" c)(loop (- c 1)) )]))\n  (foldl  string-append \"\" (loop count)))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291381,"user_id":373,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (foldr string-append \"\" (for\/list ([i (range 1 (+ count 1))]) (format \"~a sheep...\" i))))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291382,"user_id":544,"body":"#lang racket\n\n(provide count_sheep)\n\n(define (count_sheep count)\n  (apply string-append (map (\u03bb (n) (format \"~a sheep...\" n)) (range 1 (add1 count)))))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5b0c0ec907756ffcff00006e":[{"id":291383,"user_id":492,"body":"#lang racket\n(provide quadratic)\n\n(define (quadratic a b c)\n  (\/ (- c) b))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291384,"user_id":527,"body":"#lang racket\n(provide quadratic)\n\n(define (quadratic a b c)\n  (- (\/ c b)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291385,"user_id":null,"body":"#lang racket\n(provide quadratic)\n\n(define (quadratic a b c)\n  (\/ (* c 2)\n     (- (- b)\n        (* (sgn b) (sqrt (- (sqr b)\n                            (* 4 a c)))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291386,"user_id":null,"body":"#lang racket\n(provide quadratic)\n\n(define (quadratic _ b c)\n  (\/ (- c) b))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291387,"user_id":null,"body":"#lang racket\n(provide quadratic)\n\n(define (quadratic a b c)\n  (let* ([disc (sqrt (- (* b b) (* 4 a c)))]\n         [x1 (abs (\/ (* 2 c) (- (- b) disc)))]\n         [x2 (abs (\/ (* 2 c) (+ (- b) disc)))])\n    (- (min x1 x2))))\n    ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291388,"user_id":242,"body":"#lang racket\n(provide quadratic)\n\n(define (quadratic a b c)\n  (- 0 (\/ c b))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5b1cd19fcd206af728000056":[{"id":291389,"user_id":53,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  (\/ (- (add1 (* 2 m)) (sqrt (add1 (* 4 m)))) (* 2 m)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291390,"user_id":492,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  (define s (sqrt (+ 1.0 (* 4.0 m ))))\n  (\/ (- (+ 1.0 (* 2.0 m)) s) (* 2.0 m)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291391,"user_id":null,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  (+ 1 (\/ (- 1 (sqrt(+ (* 4 m) 1))) (* 2 m))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291392,"user_id":null,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  (\/ (- (+ 2 (\/ m))\n        (sqrt (- (sqr (+ 2 (\/ m)))\n                 4)))\n     2))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291393,"user_id":null,"body":"#lang racket\n\n(provide solve)\n\n; S(x) = x + 2x^2 + 3x^3 + 4x^4 + ... + nx^n\n; xS(x) = x^2 + 2x^3 + 3x^4 + ... + nx^(n+1)\n; (1-x)S(x) = (x + x^2 +x^3 + ... + x^n) + nx^(n+1)\n;           = x(1-x^n)\/(1-x) + nx^(n+1)\n; S(x) = x(1-x^n)\/(1-x)^2 + nx^(n+1)\/(1-x)\n(define (solve m)\n  (\/ (- (+ 1 (* 2 m))\n        (sqrt (+ (* 4 m) 1)))\n     (* 2 m)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291394,"user_id":242,"body":"#lang racket\n(provide solve)\n\n(define (aequal a b eps)\n  (> eps (abs (- a b)))\n)\n\n(define (u x)\n  (define (u-iter n x acc degx eps)\n    (let\n      ((newvalue (+ acc (* n degx x))))\n      (if\n        (aequal newvalue acc eps)\n        newvalue\n        (u-iter (+ n 1) x newvalue (* x degx) eps)\n      )\n    )\n  )\n  (u-iter 1 x 0.0 1 1e-12)\n)\n\n(define (solve x)\n  (define (solve-iter a b x eps)\n    (let\n      (\n        (m (u (\/ (+ a b) 2.0)))\n      )\n      (cond\n        [(aequal m x eps) (\/ (+ a b) 2.0)]\n        [(aequal a b eps) (\/ (+ a b) 2.0)]\n        [(> m x) (solve-iter a (\/ (+ a b) 2.0) x eps)]\n        [else (solve-iter (\/ (+ a b) 2.0) b x eps)]\n      )\n    )\n  )\n  (solve-iter 0 0.999 x 1e-12)\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291395,"user_id":null,"body":"#lang racket\n(provide solve)\n\n(define (solve y)\n  (\/ (+ 1\n        (* 2 y)\n        (- (sqrt (+ 1 (* 4 y)))))\n     (* 2 y)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291396,"user_id":null,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  ; your code)\n  ( \n    \/ \n    (\n      -\n      (+ (* 2 m) 1)\n      (sqrt (+ (* 4 m) 1))\n    )\n    (* 2 m)\n  )\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291397,"user_id":null,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  (let* ([disc (sqrt (+ (* 4 m) 1))]\n         [a (* 2 m)]\n         [z (+ a 1)]\n         [x1 (\/ (+ z disc) a)]\n         [x2 (\/ (- z disc) a)])\n    (cond\n      [(and (> (abs x1) 1) (> (abs x2) 1)) \"No solution\"]\n      [(< (abs x1) 1) x1]\n      [else x2])))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291398,"user_id":168,"body":"#lang racket\n(provide solve)\n\n(define (solve m)\n  (\/ m (+ 0.5 m (sqrt (+ m 0.25)))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5b40b666dfb4291ad9000049":[{"id":291399,"user_id":53,"body":"#lang racket\n(provide solve)\n\n(define (solve a b c alpha beta gamma)\n  (let* ([u (\/ (* alpha pi) 180.0)]\n         [v (\/ (* beta pi) 180.0)]\n         [w (\/ (* gamma pi) 180.0)]\n         [x (- (* a (cos u)) (* b (sin v)) (* c (cos w)))]\n         [y (- (+ (* a (sin u)) (* b (cos v))) (* c (sin w)))]\n         [t (\/ (* (atan y x) 180.0) pi)]\n         [r (sqrt (+ (* x x) (* y y)))])\n    (list (exact-round r) (exact-floor t) (modulo (exact-floor (* t 60.0)) 60) (modulo (exact-floor (* t 3600.0)) 60))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291400,"user_id":544,"body":"#lang racket\n(provide solve)\n\n; I got a little baroque with structs and functions\n; but that's fine, it's cool\n\n; a vect will carry both polar and rectangular representations in it\n(struct vect (magnitude angle dx dy) #:transparent)\n\n(define (rad theta) (* theta pi 1\/180))\n(define (deg theta) (\/ (* theta 180) pi))\n\n; two constructors for generating one representation from the other\n; and storing them in the same struct\n(define (make-vect-polar magnitude angle)\n  (vect magnitude\n        angle\n        (* magnitude (cos (rad angle)))\n        (* magnitude (sin (rad angle)))))\n(define (make-vect-rect dx dy)\n  (vect (sqrt (+ (sqr dx) (sqr dy)))\n        (deg (atan (\/ dy dx)))\n        dx\n        dy))\n\n; defining the vect struct like this makes vector math easier\n; since there'll always be rectangular components to add\n(define (add-vect v1 v2)\n  (make-vect-rect (+ (vect-dx v1) (vect-dx v2)) (+ (vect-dy v1) (vect-dy v2))))\n\n(define (decimal->dms theta)\n  (let* ([d (exact-floor theta)]\n         [m (exact-floor (* 60 (- theta d)))]\n         [s (exact-floor (* 3600 (- theta d (\/ m 60))))])\n  (list d m s)))\n\n(define (solve a b c alpha beta gamma)\n  (define-values\n    (vA vB vC)\n    (values (make-vect-polar a alpha)\n            (make-vect-polar b (+ 90 beta)) ; adjust to account for orientation\n            (make-vect-polar c (+ 180 gamma))))\n  (let ([vCO (add-vect (add-vect vA vB) vC)])\n    (cons (exact-round (vect-magnitude vCO))\n          (decimal->dms (+ 180 (vect-angle vCO)))))) ; add 180 for angle from origin","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291401,"user_id":null,"body":"#lang racket\n(provide solve)\n\n(define (solve a b c . angles)\n  (match-define (list \u03b1 \u03b2 \u03b3)\n    (map degrees->radians angles))\n  (define (make-angle z)\n    (define toc (radians->degrees (angle z)))\n    (let* ([degrees (exact-floor toc)]\n           [m (* 60 (- toc degrees))]\n           [minutes (exact-floor m)]\n           [s (* 60 (- m minutes))]\n           [seconds (exact-floor s)])\n      (list degrees minutes seconds)))\n  (define C\n    (make-rectangular\n      (+ (* a (cos \u03b1))\n         (* -1.0 b (sin \u03b2))\n         (* -1.0 c (cos \u03b3)))\n      (+ (* a (sin \u03b1))\n         (* b (cos \u03b2))\n         (* -1.0 c (sin \u03b3)))))\n  `(,(exact-round (magnitude C)) ,@(make-angle C)))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291402,"user_id":492,"body":"#lang racket\n(provide solve)\n\n(define (solve a b c alpha beta gamma)\n  (let* ([aa (\/ (* alpha pi) 180.0)]\n         [bb (\/ (* beta pi) 180.0)]\n         [cc (\/ (* gamma pi) 180.)]\n         [x (- (* a (cos aa)) (* b (sin bb)) (* c (cos cc)))]\n         [y (+ (* a (sin aa)) (* b (cos bb)) (* -1 c (sin cc)))]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [t (exact-floor (\/ (* (acos (\/ x r)) 180.0 3600.0) pi))]\n         [d (quotient t 3600)]\n         [mm (remainder t 3600)]\n         [m (quotient mm 60)]\n         [s (remainder mm 60)]\n       )\n    (list (exact-round r) d m s)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5bb804397274c772b40000ca":[{"id":291403,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (case layers\n    [(0) 0.0]\n    [(1) 1.0]\n    [else (+ 1 (* 0.866025 (sub1 layers)))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291404,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (zero? layers) 0\n      (+ 1 (* (sub1 layers) (- 1 (\/ (- 2 (sqrt 3)) 2))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291405,"user_id":373,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (= layers 0) 0 (add1 (* 0.5 (sqrt 3) (sub1 layers)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291406,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (cond\n   [(zero? layers) 0]\n   [else (+ (* (- layers 1) (\/ (sqrt 3) 2)) 1)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291407,"user_id":544,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (= layers 0) 0 (+ 1 (* (sqrt 3.0) (sub1 layers) 0.5))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291408,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (zero? layers) 0\n    (add1 (* .5 (sqrt 3) (sub1 layers))))) ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291409,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (equal? layers 0)\n      0\n      (+ 1.0\n         (* 0.866016\n            (- layers 1.0)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291410,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (equal? layers 0)\n      0\n      (+ 1\n         (* 0.86602\n            (- layers 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291411,"user_id":168,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d layers)\n  (if (positive? layers)\n      (add1 (* (sub1 layers) (sqrt 0.75)))\n      0))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291412,"user_id":null,"body":"#lang racket\n\n(provide stack-height-2d)\n\n(define (stack-height-2d l)\n  (if (equal? l 0)\n      0\n      (+ 1\n         (* 0.866025\n            (- l 1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5bb904724c47249b10000131":[{"id":291413,"user_id":168,"body":"#lang racket\n\n(provide points)\n\n(define (points games)\n  (for\/sum [(g games)]\n    (let [(a (string-ref g 0))\n          (b (string-ref g 2))]\n      (cond\n        [(char>? a b) 3]\n        [(char=? a b) 1]\n        [else 0]))))\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291414,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (points games)\n  (define l (map (lambda (e)\n         (define n (string->number (string-replace e \":\" \"\")))\n         (cond\n           ((> (quotient n 10) (remainder n 10)) 3)\n           ((< (quotient n 10) (remainder n 10)) 0)\n           ((equal? (quotient n 10) (remainder n 10)) 1)))\n       games))\n  (foldr + 0 l))\n\n","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291415,"user_id":53,"body":"#lang racket\n\n(provide points)\n\n(define (f g) \n  (let ([a (char->integer (string-ref g 0))]\n        [b (char->integer (string-ref g 2))])\n    (cond\n      [(> a b) 3]\n      [(= a b) 1]\n      [else 0])))\n\n(define (points games) (foldl ( \u03bb (g acc) (+ acc (f g))) 0 games))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291416,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (points games)\n  (let ([diffs (map (lambda (x)\n                       (apply - (map string->number (string-split x \":\"))))\n                     games)])\n    (apply + (map (lambda (x)\n                    (cond\n                     [(positive? x) 3]\n                     [(negative? x) 0]\n                     [else 1]))\n                  diffs))))\n\n  \n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291417,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (count-points points)\n  (cond\n    [(positive? points) 3]\n    [(zero? points) 1]\n    [else 0]))\n\n(define (match-result match)\n  (count-points (- (string->number (car match)) (string->number (cadr match)))))\n\n(define (points games)\n  (foldl + 0 (map (lambda (x) (match-result x)) (map (lambda (x) (string-split x \":\")) games))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291418,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (points games) (apply + (map (lambda (xs) (let ([x (string-ref xs 0)]\n                                                        [y (string-ref xs 2)])\n                                                   (cond\n                                                     [(char>? x y) 3]\n                                                     [(char<? x y) 0]\n                                                     [else 1]))) games)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291419,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (split: a)\n  (string-split a \":\"))\n\n(define (assignxy lt index)\n  (string->number (list-ref (split: lt) index)))\n\n(define (comparexy lt)\n  (let ([x (assignxy lt 0)]\n        [y (assignxy lt 1)])\n\t(cond [(> x y) 3]\n\t      [(< x y) 0]\n\t      [else 1])))\n\n(define (points games)\n    (apply + (map comparexy games)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291420,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (points games)\n  (if (null? games)\n      0\n      (+ (won-game (string->number (substring (car games) 0 1)) (string->number (substring (car games) 2 3))) (points (cdr games) ) )\n      )\n)\n(define (won-game x y)\n  (if (> x y)\n      3\n      (if (< x y)\n          0\n          1\n          )\n      )\n  )\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291421,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (points games)\n(apply +\n       (map \n        (lambda (x)\n       (let \n         [(a (string->number (substring x 0 1)))\n          (b (string->number (substring x 2 3)))]\n         (cond\n          [(< b a) 3]\n          [(> b a) 0]\n          [else 1]))) \n     games)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291422,"user_id":null,"body":"#lang racket\n\n(provide points)\n\n(define (game-score str)\n  (let ([diff (apply - (map string->number (string-split str \":\")))])\n    (cond\n     [(positive? diff) 3]\n     [(zero? diff) 1]\n     [(negative? diff) 0])))\n\n(define (points games)\n  (apply + (map game-score games)))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5c374b346a5d0f77af500a5a":[{"id":291423,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)\n  (if (<= (abs (- call right)) (abs (- call left)))\n      \"right\"\n      \"left\"))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291424,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)\n  (if (< (abs (- call left)) (abs (- call right))) (string-append \"left\") (string-append \"right\")))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291425,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)  \n  (define ld (abs (- call left)))\n  (define rd (abs (- call right)))\n  (cond\n   [(< ld rd) \"left\"]\n   [else \"right\"]\n   )\n  )\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291426,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)\n  (let ([ld (abs (- call left))]\n        [rd (abs (- call right))])\n    (if (< ld rd)\n        \"left\"\n        \"right\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291427,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n(define (ab n) (if (> 0 n)(- n)n))\n(define (elevator left right call)\n  (if (< (ab (- left call)) (ab (- right call)) )\n         \"left\" \"right\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291428,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)\n  (if (< (abs (- left call)) (abs (- right call))) \"left\" \"right\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291429,"user_id":373,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)\n  (define (diff x y) (abs (- x y)))\n  (if (< (diff left call) (diff right call)) \"left\" \"right\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291430,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n;; 0<=Integer<=2 0<=Integer<=2 0<=Integer<=2 -> (or\/c \"left\" \"right\")\n;; given the current floor of the left elevator, ~ of the right elevator, and\n;; ~ of the caller, return the name of the elevator closest to the caller\n;; (preferring the right one if equidistant)\n(define (elevator left right call)\n  (cond\n    [(= left right) \"right\"]\n    [(< (abs (- left call)) (abs (- right call))) \"left\"]\n    [else \"right\"]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291431,"user_id":168,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator l r c)\n  (if (< (abs (- l c)) (abs (- r c))) \"left\" \"right\"))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291432,"user_id":null,"body":"#lang racket\n\n(provide elevator)\n\n(define (elevator left right call)\n  (let ([dl (abs (- left call))]\n        [dr (abs (- right call))])\n    (if (< dl dr) \"left\" \"right\")))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ca13f1def39600014b37faf":[{"id":291433,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol FIRST ... LAST)\n  'LAST)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291434,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n\n\n( define-syntax-rule (last-symbol ... last-sym) 'last-sym )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291435,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol syms ...) (last '(list syms ...)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291436,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol _ ... last)\n  'last)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291437,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n\n( define-syntax-rule (last-symbol ... arg) 'arg )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291438,"user_id":null,"body":"#lang racket\n\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol s ...)\n  (syntax->datum (last (list #'s ...))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291439,"user_id":209,"body":"#lang racket\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol . x)\n  (last 'x))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291440,"user_id":544,"body":"#lang racket\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol . (_ ... f))\n  (quote f))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291441,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n\n(define-syntax-rule (last-symbol . lst)\n  (last `lst))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291442,"user_id":null,"body":"#lang racket\n(provide last-symbol)\n(require racket\/list)\n\n(define-syntax-rule (last-symbol . args)\n  (last 'args))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ca3ae9bb7de3a0025c5c740":[{"id":291443,"user_id":492,"body":"#lang racket\n(provide point fst snd sqr-dist line)\n\n(define (point a b)\n  (lambda (x) (if x a b)))\n(define (fst pt)\n  (pt true))\n(define (snd pt)\n  (pt false))\n(define (sqr-dist pt1 pt2)\n  (+ (sqr (- (fst pt1) (fst pt2)))\n     (sqr (- (snd pt1) (snd pt2)))))\n     \n(define (det a b c d)\n  (- (* a d) (* b c)))\n(define (line foo bar) \n  (let* [\n        (x1 (fst foo))\n        (x2 (fst bar))\n        (y1 (snd foo))\n        (y2 (snd bar))\n        (dp (det -1 y1 -1 y2))\n        (dq (det x1 -1 x2 -1))\n        (d (det x1 y1 x2 y2))\n       ]\n      (list dp dq d)))    ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291444,"user_id":544,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b)\n  (\u03bb () (list a b)))\n\n(define (fst pt) \n  (first (pt)))\n\n(define (snd pt) \n  (second (pt)))\n\n(define (sqr-dist pt1 pt2) \n  (+ (sqr (- (fst pt1) (fst pt2)))\n          (sqr (- (snd pt1) (snd pt2)))))\n\n(define (line pt1 pt2) \n  (list (- (snd pt1) (snd pt2))\n        (- (fst pt2) (fst pt1))\n        (- (* (fst pt1) (snd pt2))\n           (* (fst pt2) (snd pt1)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291445,"user_id":null,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b)\n  (lambda (x) (match x [0 a] [1 b]))\n)\n(define (fst pt) \n  (pt 0)\n)\n(define (snd pt) \n  (pt 1)\n)\n(define (sqr-dist pt1 pt2) \n  (+ (sqr (- (pt1 0) (pt2 0))) (sqr (- (pt1 1) (pt2 1))))\n)\n(define (line foo bar) \n  (list (- (foo 1) (bar 1)) (- (bar 0) (foo 0)) (- (* (bar 1) (foo 0)) (* (bar 0) (foo 1))))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291446,"user_id":null,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point x y)\n  (lambda (which) (if (zero? which) x y)))\n\n(define (fst pt1) (pt1 0))\n(define (snd pt1) (pt1 1))\n \n(define (sqr-dist pt1 pt2)\n  (+ (sqr (- (fst pt2) (fst pt1))) (sqr (- (snd pt2) (snd pt1)))))\n\n(define (line pt1 pt2)\n  (define m (\/ (- (snd pt2) (snd pt1)) (- (fst pt2) (fst pt1))))\n  (define b (- (snd pt2) (* m (fst pt2))))\n  (list m -1 b))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291447,"user_id":502,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b)\n  (lambda () (list a b)))\n\n(define (fst pt)\n  (car (pt)))\n\n(define (snd pt)\n  (car (cdr (pt))))\n\n(define (sqr-dist pt1 pt2)  \n   (+\n    (expt (- (fst pt1) (fst pt2)) 2)\n    (expt (- (snd pt1) (snd pt2)) 2)))\n\n(define (line foo bar)\n  (list\n   (- (snd foo) (snd bar))\n   (- (fst bar) (fst foo))\n   (- (* (fst foo) (snd bar)) (* (snd foo) (fst bar)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291448,"user_id":null,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b)\n  ; your code\n  (lambda () (list a b))\n)\n(define (fst pt) \n  ; first coordinate of point pt\n  ; your code\n  (car (pt))\n)\n(define (snd pt) \n  ; second coordinate of point pt\n  ; your code\n  (cadr (pt))\n)\n\n(define (sqrt x) (* x x))\n(define (sqr-dist pt1 pt2) \n  ; squared distance fromp point pt1 to point pt2\n  ; your code\n  (+ (sqrt (- (fst pt1) (fst pt2) )) (sqrt (- (snd pt1) (snd pt2) )))\n)\n(define (line foo bar) \n  ; return (list l m n) where l, m, n are coefficients in \n  ; equation l*x + m*y + n = 0 of the line joining the points foo and bar\n  ; your code\n  (list \n    (- (snd foo) (snd bar))\n    (- (fst bar) (fst foo))\n    (- (* (fst foo) (snd bar) ) (* (fst bar) (snd foo) ) )\n  )\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291449,"user_id":null,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b) \n  (lambda (fn) (fn a b)))\n      \n(define (fst pt) \n  (pt (lambda (x y) x)))\n(define (snd pt)\n  (pt (lambda (x y) y)))\n\n(define (sqr-dist pt1 pt2) \n  (define-values (x1 y1) (pt1 values))\n  (define-values (x2 y2) (pt2 values))\n  \n  (+ (sqr (- x1 x2)) (sqr (- y1 y2))))\n  \n(define (line foo bar) \n  (define-values (x1 y1) (foo values))\n  (define-values (x2 y2) (bar values))\n  \n  (define l (- y1 y2))\n  (define m (- x2 x1))\n  (define n (- (* x1 y2) (* x2 y1)))\n  \n  (list l m n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291450,"user_id":null,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b)\n  (lambda (msg)\n    (case msg\n      [(x) a]\n      [(y) b]\n      [(x+y) (values a b)])))\n      \n(define (fst pt) (pt 'x))\n(define (snd pt) (pt 'y))\n\n(define (sqr-dist pt1 pt2) \n  (define-values (x1 y1) (pt1 'x+y))\n  (define-values (x2 y2) (pt2 'x+y))\n  \n  (+ (sqr (- x1 x2)) (sqr (- y1 y2))))\n  \n(define (line foo bar) \n  (define-values (x1 y1) (foo 'x+y))\n  (define-values (x2 y2) (bar 'x+y))\n  \n  (define l (- y1 y2))\n  (define m (- x2 x1))\n  (define n (- (* x1 y2) (* x2 y1)))\n  \n  (list l m n))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291451,"user_id":503,"body":"#lang racket\n(provide (all-defined-out))\n(define (point . q) (lambda () q))\n(define (fst q) (car (q)))\n(define (snd q) (last (q)))\n(define (sqr-dist q s) (+ (sqr (- (fst q) (fst s))) (sqr (- (snd q) (snd s)))))\n(define (line q s) (let ((v (- (snd s) (snd q))) (b (- (fst s) (fst q))))\t(list (- (snd s) (snd q)) (- b) (- (* b (snd q)) (* v (fst q))))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291452,"user_id":168,"body":"#lang racket\n(provide (all-defined-out))\n\n(define (point a b)\n  (lambda (f) (f a b)))\n  \n(define (fst pt) \n  (pt (lambda (a b) a)))\n  \n(define (snd pt) \n  (pt (lambda (a b) b)))\n  \n(define (sqr-dist pt1 pt2) \n  (let ([dx (- (fst pt2) (fst pt1))]\n        [dy (- (snd pt2) (snd pt1))])\n    (+ (expt dx 2) (expt dy 2))))\n    \n(define (line pt1 pt2) \n  (let* ([x1 (fst pt1)] [y1 (snd pt1)]\n         [x2 (fst pt2)] [y2 (snd pt2)]\n         [dx (- x2 x1)] [dy (- y2 y1)]\n         [n (- (* dy x1) (* dx y1))])\n    (list (- dy) dx n)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5cc70653658d6f002ab170b5":[{"id":291453,"user_id":492,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (sqr-modulus z)\n  (define (greatest n)\n    (string->number (string-join (sort (map string (string->list (number->string n))) string>?) \"\")))\n  (define (keep-even-places lst)\n    (define (aux lst i)\n      (cond ((null? lst) '())\n            ((odd? i) (cons (car lst) (aux (cdr lst) (add1 i))))\n            (else (aux (cdr lst) (add1 i)))))\n    (aux lst 1))\n  (match z\n    [(list (quote cart) (? integer? xs) ...)\n     (let* ([r (apply + (map sqr xs))])\n       (list #t r (greatest r)))]\n    [(list (quote polar)(? integer? xs) ...)\n     (let* ([r (apply + (map sqr (keep-even-places xs)))])\n       (list #t r (greatest r)))]\n    [_ (list #f -1 1)]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291454,"user_id":544,"body":"#lang racket\n(provide sqr-modulus)\n\n(define cart 'cart)\n(define polar 'polar)\n\n(define (sqr-modulus z)\n  (if (valid-polar-list? z)\n      (let ([moduli-sqr-sum (exact-round (apply + (map (\u03bb (i) (* i i)) (complex-modulus z))))])\n        (list (valid-polar-list? z)\n              moduli-sqr-sum\n              (string->number (list->string\n                               (sort (string->list (number->string moduli-sqr-sum))\n                                     char>?)))))\n      (list #f -1 1)))\n\n(define (valid-polar-list? lst)\n  (and (or (equal? (car lst) 'cart)\n           (equal? (car lst) 'polar))\n       (andmap integer? (cdr lst))))\n\n(define (complex-modulus lst)\n  (define z (car lst))\n  (define xs (cdr lst))\n  (cond [(null? xs) '()]\n        [(equal? z 'polar) \n         (cons (first xs) \n               (complex-modulus (cons z (list-tail xs 2))))]\n        [(equal? z 'cart) \n         (cons (sqrt (+ (expt (first xs) 2) \n                        (expt (second xs) 2)))\n               (complex-modulus (cons z (list-tail xs 2))))]\n        [else xs]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291455,"user_id":168,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (greatest n)\n  (string->number\n     (list->string (sort (string->list (number->string n)) char>?))))\n\n(define (sqr-modulus z)\n  (match z\n    [(list 'cart (? integer?) ...)\n     (let ([s (for\/sum ([x (cdr z)]) (sqr x))])\n       (list #t s (greatest s)))]\n    [(list 'polar (? integer?) ...) \n     (let ([s (for\/sum ([x (cdr z)]\n                        [i (in-naturals)] #:when (even? i)) (sqr x))])\n       (list #t s (greatest s)))]\n    [else '(#f -1 1)])\n)\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291456,"user_id":null,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (sqr-modulus l)\n  (define (calc f l)\n    (match l\n      [(list) 0]\n      [(list x y r ...)\n       (+ (f x y) (calc f r))]))\n  (define (magni-cart x y) (+ (sqr x) (sqr y)))\n  (define (magni-polar m a) (sqr m))\n\n  (define (rearrange n)\n    (string->number\n      (apply string\n        (sort (string->list (number->string n)) char>?))))\n\n  (define sqrm\n    (match l\n      [(list 'cart (? integer? xs) ...)\n       (calc magni-cart xs)]\n      [(list 'polar (? integer? xs) ...)\n       (calc magni-polar xs)]\n      [_ #f]))\n  (if sqrm\n      (list #t sqrm (rearrange sqrm))\n      '(#f -1 1)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291457,"user_id":null,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (sqr-modulus l)\n  (define incorrect '(#f -1 1))\n  (let\/cc cc\n    (define (calc f l)\n      (match l\n        [(list) 0]\n        [(list (? integer? x) (? integer? y) r ...)\n         (+ (f x y)\n            (calc f r))]\n        [_ (cc incorrect)]))\n    (define (magni-cart x y) (+ (sqr x) (sqr y)))\n    (define (magni-polar m a) (sqr m))\n\n    (define (rearrange n)\n      (foldl (\u03bb (x y) (+ x (* 10 y))) 0\n        (sort (let loop ([n n] [l '()])\n                (if (zero? n) l\n                    (let-values ([(q r) (quotient\/remainder n 10)])\n                      (loop q (cons r l)))))\n          >)))\n    (define tag (car l))\n    (define sqrm\n      (cond [(eq? tag 'cart) (calc magni-cart (cdr l))]\n            [(eq? tag 'polar) (calc magni-polar (cdr l))]\n            [else (cc incorrect)]))\n    (list #t sqrm (rearrange sqrm))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291458,"user_id":null,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (sqr-modulus z)\n  (cond\n    [(or (not (andmap integer? (rest z))) (not (odd? (length z)))) '(#f -1 1)]\n    [(equal? (first z) 'cart) (sqr-mod (n-map 2 make-rectangular (rest z)))]\n    [(equal? (first z) 'polar) (sqr-mod (n-map 2 make-polar (rest z)))]\n    [else '(#f -1 1)])\n)\n\n(define (n-map n func lst)\n  (if (empty? lst)\n      '()\n      (append\n       (list (apply func (take lst n)))\n       (n-map n func (drop lst n)))))\n\n(define (sqr-mod z)\n  (let* ([s (foldr + 0 (map (compose exact-round sqr magnitude) z))]\n         [d (string->number (list->string (sort (string->list (number->string s)) char>?)))])\n    (list #t s d)))\n   ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291459,"user_id":null,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (sqr-modulus z)\n  (cond\n    [(or (not (andmap integer? (rest z))) (not (odd? (length z)))) '(#f -1 1)]\n    [(equal? (first z) 'cart) (sqr-mod (n-map 2 make-rectangular (rest z)))]\n    [(equal? (first z) 'polar) (sqr-mod (n-map 2 make-polar (rest z)))]\n    [else '(#f -1 1)])\n)\n\n(define (n-map n func lst)\n  (if (empty? lst)\n      '()\n      (append\n       (list (apply func (take lst n)))\n       (n-map n func (drop lst n)))))\n\n(define (sqr-mod z)\n  (let* ([s (foldr + 0 (map exact-round (map sqr (map magnitude z))))]\n         [d (string->number (list->string (sort (string->list (number->string s)) char>?)))])\n    (list #t s d)))\n   ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291460,"user_id":null,"body":"#lang racket\n(provide sqr-modulus)\n\n(define (sqr-modulus z)\n  (match z\n    [(list 'cart (? integer? lon) ...)\n     (let ([magnitude (mod-squared lon)])\n       (list #t magnitude (greatest-rearrangement magnitude)))]\n    [(list 'polar (? integer? lon) ...)\n     (let ([magnitude (mod-squared (skip-one-element lon))])\n       (list #t magnitude (greatest-rearrangement magnitude)))]\n    [_ (list #f -1 1)]))\n \n(define (mod-squared lon)\n  (apply + (map sqr lon)))\n\n(define (skip-one-element lox)\n  (define (aux lox index)\n    (cond\n      [(empty? lox) empty]\n      [else\n       (if (odd? index)\n           (cons (first lox) (aux (rest lox) (add1 index)))\n           (aux (rest lox) (add1 index)))]))\n  (aux lox 1))\n\n(define (greatest-rearrangement n)\n  (string->number (list->string (sort (string->list (~a n)) char>?))))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291461,"user_id":503,"body":"#lang racket\n(provide sqr-modulus)\n(define (H Q) (for\/and ((V Q)) (integer? V)))\n(define (W Q) (list #T Q (string->number (list->string (sort (string->list (~v Q)) char>?)))))\n(define (M Q) (if (null? Q) 0 (+ (sqr (car Q)) (M (cddr Q)))))\n(define (sqr-modulus Q) (match Q\n\t((list 'cart Q ...) #:when(H Q) (W (foldl (lambda (V D) (+ D (* V V))) 0 Q)))\n\t((list 'polar Q ...) #:when(H Q) (W (M Q)))\n\t(_ '(#F -1 1))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5ce399e0047a45001c853c2b":[{"id":291462,"user_id":null,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls) \n  (foldr (lambda (n acc) (cons (+ n (car acc)) acc)) '(0) ls)\n)","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291463,"user_id":492,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls) \n  (define (aux  ls)\n    (if (pair? (cdr  ls)) \n         (let ((sm (aux (cdr ls))))\n           (cons (+ (car ls) (car sm)) sm)) ls)) \n  (if  (pair? ls) \n       (append (aux ls) (list 0))\n       (list 0)))","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291464,"user_id":527,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums xs)\n  (for\/fold ([ys (list 0)])\n            ([x (reverse xs)])\n    (cons (+ (first ys) x) ys)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291465,"user_id":null,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls) \n  (match ls\n    ['() '(0)]\n    [(cons l ls) (let ([xss (parts_sums ls)])\n                   (cons (+ l (first xss)) xss))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291466,"user_id":null,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls)\n  (foldr (lambda (n acc) (cons (+ (car acc) n) acc)) '(0) ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291467,"user_id":null,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls) \n  (define (sumall l) \n    (if (null? l) \n        0            \n        (+ (car l) (sumall (cdr l)))\n    )\n  )\n  \n  (define (subsum l c)\n    (if (null? l) \n      (list 0)\n      (append (list c) (subsum (cdr l) (- c (car l)))))\n  )\n  \n  (subsum ls (sumall ls))\n  \n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291468,"user_id":null,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls)\n  (let make-sums ([lst ls])\n    (if (empty? lst) '(0)\n        (let ([prev (make-sums (cdr lst))])\n          (cons (+ (car lst) (car prev)) prev)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291469,"user_id":null,"body":"#lang racket\n(provide parts_sums)\n\n(define (mapfoldr func state ls)\n  (foldr (\u03bb (ele state) (cons (+ ele (car state)) state))\n         (list state)\n         ls))\n\n(define (parts_sums ls) \n  (mapfoldr + 0 ls))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291470,"user_id":53,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums ls) \n  (let ([s (apply + ls)])\n    (define (aux xs acc m)\n      (cond\n        [(empty? xs) (reverse (cons 0 acc))]\n        [else (aux (rest xs) (cons m acc) (- m (first xs)))]))\n    (aux ls null s)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291471,"user_id":544,"body":"#lang racket\n(provide parts_sums)\n\n(define (parts_sums xs)\n  (for\/foldr\n      ([lst '(0)]\n       [sum 0]\n       #:result lst)\n    ([x (in-list xs)])\n    (values (cons (+ x sum) lst)\n            (+ x sum))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5d376cdc9bcee7001fcb84c0":[{"id":291472,"user_id":null,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (odd_ones_out ns)\n  #| your code here |#\n  (del ns ns))\n\n(define (cnt n ls)\n  (cond\n   [(null? ls) 0]\n   [(= n (car ls)) (add1 (cnt n (cdr ls)))]\n   [else (cnt n (cdr ls))]))\n\n(define (del ns bak)\n  (cond\n   [(null? ns) '()]\n   [(odd? (cnt (car ns) bak)) (del (remove* (list (car ns)) ns) bak)]\n   [else (cons (car ns) (del (cdr ns) bak))]))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291473,"user_id":null,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (tally items)\n  (foldl\n    (lambda (x counts)\n      (hash-update counts x add1 0))\n    (hash (car items) 1)\n    (cdr items)))\n\n(define (odd_ones_out ns)\n  (let\n    ([counts (tally ns)])\n    (filter (lambda (x) (even? (hash-ref counts x))) ns)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291474,"user_id":null,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (odd_ones_out ns)\n  (let ([dict (foldl\n               (lambda (num result) (if\n                                     (hash-has-key? result num)\n                                     (hash-update result num add1)\n                                     (hash-set result num 1)))\n               (hash) ns)])\n    (filter\n     (lambda (num) (even? (hash-ref dict num)))\n     ns)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291475,"user_id":209,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (odd_ones_out q)\n  (filter (lambda (x) (even? (count (lambda (y) (= y x)) q))) q))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291476,"user_id":544,"body":"#lang racket\n(provide odd_ones_out)\n\n(define (odd_ones_out ns)\n  (define candidates (remove-duplicates ns))\n  (for\/fold ([allowed ns])\n            ([n (in-list candidates)]\n             #:when (odd? (count (\u03bb (x) (= x n)) ns)))\n            (remove* (list n) allowed)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291477,"user_id":168,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (odd_ones_out ns)\n  (for\/list ([x ns] #:when (even? (count (curry = x) ns))) x))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291478,"user_id":null,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (odd_ones_out numbers)\n  (filter\n   (lambda (n)\n     (even?\n      (count (lambda (instance) (= instance n)) numbers)))\n   numbers))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291479,"user_id":null,"body":"#lang racket\n\n(provide odd_ones_out)\n\n;; (Listof Number) -> (Listof Number)\n;; remove numbers that repeat an old number of times\n(define (odd_ones_out ns)\n  (define counts (make-hash))\n  (for ([n ns])\n       (hash-set! counts n (add1 (hash-ref counts n 0))))\n  (for\/list ([n ns]\n            #:when (even? (hash-ref counts n)))\n            n))\n\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291480,"user_id":null,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (increment-hash h key)\n  (hash-update! h key (\u03bb (v) (add1 v)) (\u03bb () 0)))\n\n(define (odd_ones_out ns)\n  (define h (make-hash))\n  (for ([n ns]) (increment-hash h n))\n  (filter (\u03bb (n) (even? (hash-ref h n))) ns))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291481,"user_id":645,"body":"#lang racket\n\n(provide odd_ones_out)\n\n(define (odd_ones_out ns)\n  (filter (\u03bb (x) (even? (count (\u03bb (n) (= n x)) ns))) ns))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5d50e3914861a500121e1958":[{"id":291482,"user_id":null,"body":"#lang racket\n(provide add-letters)\n\n(define (compare letter alphabet counter2)\n  (if (= counter2 (string-length alphabet)) 0\n    (if (= (char->integer letter) (char->integer (string-ref alphabet counter2))) (- (char->integer (string-ref alphabet counter2)) 96) \n      (compare letter alphabet (+ counter2 1))))\n)\n\n(define (add-letters2 letters alphabet counter sum)\n  (if (= counter (length letters)) sum \n    (add-letters2 letters alphabet (+ counter 1) (+ sum (compare (list-ref letters counter) alphabet 0))))\n)\n\n(define (fixit sum alphabet)\n  (let ([sum2 (remainder sum 26)])\n    (if (= 0 sum2) #\\z (string-ref alphabet (- sum2 1))))\n)\n\n(define (add-letters letters)\n  (let ([alphabet \"abcdefghijklmnopqrstuvwxyz\"])\n    (fixit (add-letters2 letters alphabet 0 0) alphabet))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291483,"user_id":null,"body":"#lang racket\n\n(provide add-letters)\n\n(define (letter-num c)\n  (- (char->integer c) 96))\n\n(define (num-letter n)\n  (if (zero? n) #\\z (integer->char (+ n 96))))\n\n(define (add-letters letters)\n  (num-letter (modulo (apply + (map letter-num letters)) 26)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291484,"user_id":null,"body":"#lang racket\n\n(provide add-letters)\n\n(define (my-integer->char i)\n  (if (= 96 i) #\\z (integer->char i)))\n\n(define (add-letters letters)\n  (if (empty? letters) \n      #\\z\n      ((compose\n          my-integer->char\n          (curry + 96)\n          (curryr remainder 26)\n          (curry + 26)\n          (curry apply +)\n          (curry map (curryr remainder 26))\n          (curry map (curryr - 96))\n          (curry map char->integer)) \n       letters)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291485,"user_id":null,"body":"#lang racket\n\n(provide add-letters)\n\n;; Char -> Integer\n;; convert #\\a to 1, #\\b to 2 ... #\\z to 26\n(define (my-char->int c)\n  (- (char->integer c) 96))\n\n;; Integer -> Char\n;; convert 1 to #\\a, 2 to #\\b ... 26 to #\\z\n(define (my-int->char i)\n  (if (zero? i)\n      #\\z\n      (integer->char (+ i 96))))\n\n;; (Listof Char) -> Char\n;; add up letters to one letter in a peculiar way\n(define (add-letters letters)\n  (if (empty? letters)\n      #\\z\n      (my-int->char (remainder (for\/sum ([c letters]) (my-char->int c)) 26))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291486,"user_id":null,"body":"#lang racket\n\n(provide add-letters)\n\n(define (add-letters letters)\n  (define sum\n    (foldl (lambda (c res) (+ res (- (char->integer c) 96))) 25 letters))\n  (integer->char (+ (remainder sum 26) 97)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291487,"user_id":null,"body":"#lang racket\n\n(provide letter-converter)\n(define (letter-converter l)\n  (- (char->integer l) 96))\n\n(provide add-letters)\n(define (add-letters letters)\n  (local\n    {(define alphabet\n       '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\n\n             #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))}\n    (match letters\n      ['() #\\z]\n      [(cons head tail)\n           (if (> (foldr + 0 (map letter-converter letters)) 26)\n               (list-ref\n                alphabet\n                (remainder (- (foldr + 0 (map letter-converter letters)) 1) 26))\n               (list-ref\n                alphabet (- (foldr + 0 (map letter-converter letters)) 1)))])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291488,"user_id":null,"body":"#lang racket\n(provide add-letters)\n(define (integer->letter int)\n  (integer->char\n   (+ (modulo (- int 1) 26) 97)))\n\n(define (letter->integer letter)\n  (- (char->integer letter) 96))\n\n(define (add-letters letters)\n  (if (null? letters)\n      #\\z\n      (integer->letter\n       (apply + (map letter->integer letters)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291489,"user_id":168,"body":"#lang racket\n\n(provide add-letters)\n\n(define (add-letters letters)\n  (integer->char\n    (+ 97 (modulo (sub1 (for\/sum ([x letters])\n                           (- (char->integer x) 96))) \n            26))))  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291490,"user_id":null,"body":"#lang racket\n\n(provide add-letters)\n\n(define (add-letters l)\n  (define n\n    (modulo\n      (apply +\n        (map (\u03bb (c) (- (char->integer c) 96))\n             l))\n      26))\n  (if (zero? n)\n      #\\z\n      (integer->char (+ n 96))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291491,"user_id":null,"body":"#lang racket\n\n(provide add-letters)\n\n(define (add-letters letters)\n  (integer->char (+ (char->integer #\\a) (remainder (foldl + 25 (map (\u03bb (c) (- (char->integer c) (char->integer #\\a) -1)) letters)) 26))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"5da1df6d8b0f6c0026e6d58d":[{"id":291492,"user_id":53,"body":"#lang racket\n(provide c)\n\n(define (walk i n ans cnt m j)\n  (cond [(= 1000 j) (* 4 ans)]\n        [(and (<= n 1) (= 1 m)) ans]\n        [(= 0 (modulo n i)) (walk i (quotient n i) ans (add1 cnt) 0 (add1 j))]\n        [else (walk (add1 i) n (* ans (add1 cnt)) 0 1 (add1 j))]))\n\n(define (c k)\n  (let ([sq (exact-floor (sqrt k))])\n    (if (= k (* sq sq))\n        (walk 2 (* k sq) 1 0 1 0)\n        0)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291493,"user_id":168,"body":"#lang racket\n(provide c)\n\n(define (c k)\n  (define t (integer-sqrt k))\n  (if (not (= (sqr t) k)) 0\n      (for\/fold ([r 1] [t t] #:result (* r (if (> t 1) 4 1)))\n                ([d (in-naturals 2)])\n                #:break (> (sqr d) t)\n        (for\/fold ([t t] [k 0] \n                   #:result (values (* r (add1 (* 3 k))) t))\n                  ([_ (in-naturals 0)])\n                  #:break (not (zero? (remainder t d)))\n                  (values (\/ t d) (add1 k))\n          )))\n)","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291494,"user_id":492,"body":"#lang racket\n(provide c)\n\n(define (c k)\n  (define (div-nb n)\n    (let loop ([cnt 0] [k 1])\n      (if (< (sqrt n) k)\n        (if (= n (* (sub1 k) (sub1 k)))\n            (sub1 cnt)\n            cnt)\n        (if (= 0 (remainder n k))\n            (loop (+ 2 cnt) (add1 k))\n            (loop cnt (add1 k))))))\n  \n  (let ([r (inexact->exact (sqrt k))])\n    (if (= k (* r r))\n      (div-nb (* k r))\n      0)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"60a54750138eac0031eb98e1":[{"id":291495,"user_id":544,"body":"#lang racket\n(provide valid-vin?)\n\n(define vin-char-hash\n  (for\/hash ([char (in-string \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")]\n             [val (in-sequences (in-range 1 10) (in-range 1 10) (in-range 2 10) (in-range 0 10))]\n             #:unless (member char '(#\\I #\\O #\\Q)))\n    (values char val)))\n\n(define weights '(8 7 6 5 4 3 2 10 0 9 8 7 6 5 4 3 2))\n\n(define (valid-vin? vin)\n  (define vin-chars (string->list vin))\n  (cond\n    [(not (= 17 (length vin-chars))) #false]\n    [(not (andmap (\u03bb (c) (hash-ref vin-char-hash c #false)) vin-chars)) #false]\n    [else\n     (define checksum-total (for\/sum ([c (in-list vin-chars)]\n                                      [w (in-list weights)])\n                              (* (hash-ref vin-char-hash c) w)))\n     (define checksum (modulo checksum-total 11))\n     (or (and (= checksum 10) (eq? #\\X (list-ref vin-chars 8)))\n         (eq? checksum (string->number (string (list-ref vin-chars 8)))))]))\n","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"6129095b201d6b000e5a33f0":[{"id":291496,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n    (+\n     (* 3 x y z)\n     (* 2 (+ (* x y)\n             (* x z)\n             (* y z)))\n     (+ x y z))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291497,"user_id":527,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n  (+ (* x (add1 y) (add1 z))\n     (* (add1 x) y (add1 z))\n     (* (add1 x) (add1 y) z)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291498,"user_id":53,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n    (+ (* x (add1 y) (add1 z)) (* y (add1 x) (add1 z)) (* z (add1 x) (add1 y)))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291499,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n  (+ (+ 12 (* 8 (- x 1)))\n     (* (- y 1) (+ 4 2 (* 2 x) (* 3 (- x 1))))\n     (* (- z 1) (+ 4 (* 2 x) (* 2 y) (* y (- x 1)) (* x (- y 1)) (* (- x 1) (+ y 1)) (* 2 (- y 1)))))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291500,"user_id":50,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n  (+ (* z (+ (* 3 x y) 1 (* 2 (+ x y)))) (* 2 x y) x y)\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291501,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n  (+ (* 3 x y z) (* 2 (+ (* x y) (* y z) (* x z))) x y z))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291502,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n  (+ (* (add1 y) (add1 z) x)\n     (* (add1 z) (add1 x) y)\n     (* (add1 x) (add1 y) z)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291503,"user_id":null,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n(+ (* x (+ (* y (+ (* 3 z) 2)) (* 2 z) 1)) (* y (add1 (* 2 z))) z))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291504,"user_id":168,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n [+ (* (add1 x) (add1 y) z) (* (add1 x) y (add1 z)) (* x (add1 y) (add1 z))])","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291505,"user_id":209,"body":"#lang racket\n(provide f)\n\n(define (f x y z)\n    (+ x y z (* 2 (+ (* x y) (* x z) (* y z))) (* 3 x y z))\n  )","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"52a78825cdfc2cfc87000005":[{"id":291506,"user_id":53,"body":"#lang racket\n(provide calc_expression)\n\n; utility methods\n\n(define (take-while p l)\n  (let loop ((o '()) (l l))\n    (if (and (not (null? l)) (p (car l)))\n        (loop (cons (car l) o) (cdr l))\n        (reverse o))))\n\n(define (str-from-chars ls)\n  (apply string-append (map (\u03bb (c) (string c)) ls)))\n\n; math expr\n\n(define (norm-exp exp)\n  (filter (\u03bb (c) (not (char-whitespace? c))) exp))\n\n(define (number-exp exp)\n  (let* ([pre (take-while (\u03bb (c) (or (equal? c #\\.) (char-numeric? c))) exp)]\n         [pre-num (string->number (str-from-chars pre))]\n         [post (list-tail exp (length pre))])\n    (list pre-num post)))\n\n(define (expression-exp exp)\n  (define (walk n xs)\n    (if (empty? xs)\n      (list n xs)\n      (if (eq? (first xs) #\\+)\n        (let* ([ys (list-tail xs 1)]\n               [nxt (term-exp ys)])\n          (walk (+ n (first nxt)) (second nxt)))\n        (if (eq? (first xs) #\\-)\n          (let* ([ys (list-tail xs 1)]\n                 [nxt (term-exp ys)])\n            (walk (- n (first nxt)) (second nxt)))\n          (list n xs)))))\n  (let ([num (term-exp exp)])\n    (walk (first num) (second num))))\n\n(define (term-exp exp)\n  (define (walk n xs)\n    (if (empty? xs)\n      (list n xs)\n      (if (eq? (first xs) #\\*)\n        (let* ([ys (list-tail xs 1)]\n               [nxt (factor-exp ys)])\n          (walk (* n (first nxt)) (second nxt)))\n        (if (eq? (first xs) #\\\/)\n          (let* ([ys (list-tail xs 1)]\n                 [nxt (factor-exp ys)])\n            (walk (\/ n (first nxt)) (second nxt)))\n          (list n xs)))))\n  (let ([num (factor-exp exp)])\n    (walk (first num) (second num))))\n\n(define (factor-exp exp)\n  (if (char-numeric? (first exp))\n    (number-exp exp)\n    (if (eq? (first exp) #\\()\n      (let ([num (expression-exp (list-tail exp 1))])\n        (list (first num) (list-tail (second num) 1)))\n      (if (eq? (first exp) #\\-)\n      (let ([num (factor-exp (list-tail exp 1))])\n        (list (- (first num)) (second num)))\n      (list 0 exp)))))\n\n(define (calc_expression exp)\n  (define result (expression-exp (norm-exp (string->list exp))))\n  (define num (first result))\n  (println num)\n  num)","lang_id":44,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291507,"user_id":168,"body":"#lang racket\n(provide calc_expression)\n\n(define (run-parser p tokens) (car (p tokens)))\n\n(define ((bind p1 p2) s)\n  (match (p1 s)\n    [#f #f]\n    [(cons a s1) ((p2 a) s1)]))\n\n(define ((pure a) s) (cons a s))\n\n(define (<$> f p) (bind p (compose pure f)))\n\n(define (<$ v p) (<$> (const v) p))\n\n(define (<*> p1 p2) (bind p1 (lambda (f) (<$> f p2))))\n\n(define ((choice p q) s)\n  (match (p s)\n    [#f (q s)]\n    [res res]))\n\n(define ((satisfy pred) s)\n  (match s\n    [(cons (? pred a) s1) (cons a s1)]\n    [_ #f]))\n\n(define (peq v) (satisfy (curry equal? v)))\n\n(define (chainl1 p op)\n  (define (rest a)\n    (choice (bind (<*> (<*> op (pure a)) p) rest) (pure a)))\n  (bind p rest))\n\n(define (prefixr p op)\n  (choice (<*> op (lambda (s) ((prefixr p op) s))) p))\n\n(define (between p1 p2 p)\n  (bind (bind p1 (const p)) (lambda (a) (<$ a p2))))\n\n(define (calc_expression expr)\n  (define tokens (regexp-match* #px\"\\\\d+(?:\\\\.\\\\d+)?|[-+*\/()]\" expr))\n  (define number (<$> string->number (satisfy string->number)))\n  (define neg (<$ - (peq \"-\")))\n  (define add (<$ (curry +) (peq \"+\")))\n  (define sub (<$ (curry -) (peq \"-\")))\n  (define mul (<$ (curry *) (peq \"*\")))\n  (define div (<$ (curry \/) (peq \"\/\")))\n  (letrec \n    ([atom   (choice number (between (peq \"(\") (peq \")\") (lambda (s) (expr s))))]\n     [factor (prefixr atom neg)]\n     [term   (chainl1 factor (choice mul div))]\n     [expr   (chainl1 term (choice add sub))])\n    (run-parser expr tokens)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291508,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n(define (tokenize s)\n  (define (operator? x)\n    (or (eq? x #\\+)\n        (eq? x #\\-)\n        (eq? x #\\*)\n        (eq? x #\\\/)))\n  (define (parens? x)\n    (or (eq? x #\\()\n        (eq? x #\\))))\n  (define first-char->symbol (compose1 string->symbol string car))\n  (define (pick-unary l)\n    (define xs (cons (if (eq? (car l) '-) '-u (car l)) (cdr l)))\n    (let loop ([xs xs])\n      (match xs\n        ['() '()]\n        [(list (? (\u03bb (x) (or (sym-operator? x) (eq? 'lp x))) x) '- xs ...)\n         (cons x (loop (cons '-u xs)))]\n        [(cons x xs)\n         (cons x (loop xs))])))\n  (pick-unary\n    (let loop ([xs s])\n      (define (read-num l)\n        (define-values (nums rst)\n          (splitf-at l (\u03bb (x) (or (char-numeric? x) (eq? x #\\.)))))\n        (cons (string->number (apply string nums))\n              (loop rst)))\n      (define (read-op l)\n        (cons (first-char->symbol l)\n              (loop (cdr l))))\n      (define (read-parens l)\n        (cons (if (eq? (car l) #\\() 'lp 'rp)\n              (loop (cdr l))))\n      (match xs\n        ['() xs]\n        [(cons (? char-numeric?) _)\n         (read-num xs)]\n        [(cons (? operator?) _)\n         (read-op xs)]\n        [(cons (? parens?) _)\n         (read-parens xs)]\n        [(cons _ xs) (tokenize xs)]))))\n\n\n(define PRECEDENCE\n  #hash((+ . 0)\n        (- . 0)\n        (* . 1)\n        (\/ . 1)\n        (-u . 2)))\n\n(define (sym-operator? x)\n  (hash-has-key? PRECEDENCE x))\n\n(define (parse tl)\n  (define (precedence<=? op1 op2)\n    (<= (hash-ref PRECEDENCE op1)\n       (hash-ref PRECEDENCE op2)))\n  (let loop ([exprs '()] [ops '()] [l tl])\n    (match l\n      [(list) (reverse (append (reverse ops) exprs))]\n      [(cons (? number? x) xs)\n       (loop (cons x exprs) ops xs)]\n      [(cons '-u xs)\n       (loop exprs (cons '-u ops) xs)]\n      [(cons 'lp xs)\n       (loop exprs (cons 'lp ops) xs)]\n      [(cons 'rp xs)\n       (define-values (left right)\n         (splitf-at ops (\u03bb (x) (not (eq? x 'lp)))))\n       (loop (append (reverse left) exprs) (cdr right) xs)]\n      [(cons (? sym-operator? x) xs)\n       (define-values (left right)\n         (splitf-at ops (\u03bb (y) (and (sym-operator? y)\n                                    (precedence<=? x y)))))\n       (loop (append (reverse left) exprs) (cons x right) xs)])))\n\n(define (calc_expression expr)\n  (define rpn\n    (parse (tokenize (filter-not char-whitespace? (string->list expr)))))\n  (let loop ([l '()] [xs rpn])\n    (match xs\n      ['() (car l)]\n      [(cons (? number? x) xs)\n       (loop (cons x l) xs)]\n      [(cons (? (\u03bb (x) (eq? x '-u))) xs)\n       (loop (cons (- (car l)) (cdr l)) xs)] \n      [(cons (? sym-operator? x) xs)\n       (match-define (list v1 v2 ls ...) l)\n       (loop (match x\n               ['+ (cons (+ v2 v1) ls)]\n               ['- (cons (- v2 v1) ls)]\n               ['* (cons (* v2 v1) ls)]\n               ['\/ (cons (\/ v2 v1) ls)])\n             xs)])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291509,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n(define (calc_expression exp)\n  (struct op (sym arity prec assoc) #:transparent)\n\n  (define tokens\n    (map (match-lambda\n           [(app string->number (? number? n)) n]\n           [(? (match-lambda [(or \"(\" \")\") #t] [_ #f]) p) p]\n           [(app string->symbol (? symbol? s)) s])\n         (regexp-match* #px\"\\\\d+(?:\\\\.\\\\d+)?|\\\\(|\\\\)|\\\\+|-|\\\\*|\/\" exp)))\n\n  (define parsed\n    (let iter ([input tokens] [output '()])\n      (if (null? input)\n          (reverse output)\n          (match* ((car input) output)\n            [('- (or '() (cons (or \"(\" (? op? _)) _))) (iter (cdr input) (cons (op '- 1 2 'right) output))]\n            [((? symbol? s) _) (iter (cdr input) (cons (op s 2 (if (member s '(* \/)) 1 0) 'left) output))]\n            [(token _) (iter (cdr input) (cons token output))]))))\n\n  (define rpn ; shunting-yard\n    (let iter ([input parsed] [output '()] [operators '()])\n      (define (eat-ops out oper ops)\n        (if (and (not (null? ops))\n                 (not (eq? \"(\" (car ops)))\n                 (or (> (op-prec (car ops)) (op-prec oper))\n                     (and (= (op-prec (car ops)) (op-prec oper))\n                          (eq? (op-assoc oper) 'left))))\n            (eat-ops (cons (car ops) out) oper (cdr ops))\n            (iter (cdr input) out (cons oper ops))))\n      \n      (define (match-paren out ops)\n        (if (eq? \"(\" (car ops))\n            (iter (cdr input) out (cdr ops))\n            (match-paren (cons (car ops) out) (cdr ops))))\n      \n      (if (null? input)\n          (append (reverse output) operators)\n          (match (car input)\n            [(? number? n) (iter (cdr input) (cons n output) operators)]\n            [(? op? oper) (eat-ops output oper operators)]\n            [\"(\" (iter (cdr input) output (cons \"(\" operators))]\n            [\")\" (match-paren output operators)]))))\n  \n  (define ns (make-base-namespace))\n  \n  (let compute ([stack '()] [input rpn])\n    (match* (stack input)\n      [((list result) '()) result]\n      [(_ (cons (? number? n) rest)) (compute (cons n stack) rest)]\n      [((cons a st) (cons (op sym 1 _ _) rest)) (compute (cons ((eval sym ns) a) st) rest)]\n      [((list b a st ...) (cons (op sym 2 _ _) rest)) (compute (cons ((eval sym ns) a b) st) rest)])))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291510,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n(define PRECEDENCE\n  #hash((+ . 0) (- . 0) (* . 1) (\/ . 1) (-u . 2)))\n\n(define (operator? x) (hash-has-key? PRECEDENCE x))\n\n(define (tokenize s)  ; cool and good regexp\n  (map\n    (match-lambda\n      [(pregexp #px\"[+*\/-]\" (cons x _)) (string->symbol x)]\n      [(pregexp #px\"\\\\d.*\" (cons x _)) (string->number x)]\n      [\"_\" '-u]\n      [\"(\" 'lp]\n      [\")\" 'rp])\n    (regexp-match*\n      #px\"[+*\/_()-]|(\\\\d+\\\\.*\\\\d*)\" \n      (regexp-replace*\n        #px\"^-|(?<=[(+*\/-])-\"\n        (string-replace s \" \" \"\")\n        \"_\"))))\n\n(define (parse tl)\n  (define (precedence op)\n    (hash-ref PRECEDENCE op))\n  (let loop ([exprs '()] [ops '()] [l tl])\n    (match l\n      [(list) (reverse (append (reverse ops) exprs))]\n      [(cons (? number? x) xs)\n       (loop (cons x exprs) ops xs)]\n      [(cons '-u xs)\n       (loop exprs (cons '-u ops) xs)]\n      [(cons 'lp xs)\n       (loop exprs (cons 'lp ops) xs)]\n      [(cons 'rp xs)\n       (define-values (left right)\n         (splitf-at ops (\u03bb (x) (not (eq? x 'lp)))))\n       (loop (append (reverse left) exprs) (cdr right) xs)]\n      [(cons (? operator? x) xs)\n       (define-values (left right)\n         (splitf-at ops (\u03bb (y) (and (operator? y)\n                                    (<= (precedence x) (precedence y))))))\n       (loop (append (reverse left) exprs) (cons x right) xs)])))\n\n(define (evaluate expr)\n  (let loop ([l '()] [xs expr])\n    (match xs\n      ['() (car l)]\n      [(cons (? number? x) xs)\n       (loop (cons x l) xs)]\n      [(cons (? (\u03bb (x) (eq? x '-u))) xs)\n       (loop (cons (- (car l)) (cdr l)) xs)]\n      [(cons (? operator? x) xs)\n       (match-define (list v1 v2 ls ...) l)\n       (loop (match x\n               ['+ (cons (+ v2 v1) ls)]\n               ['- (cons (- v2 v1) ls)]\n               ['* (cons (* v2 v1) ls)]\n               ['\/ (cons (\/ v2 v1) ls)])\n             xs)])))\n\n(define (calc_expression str)\n  (evaluate (parse (tokenize str))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291511,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n(define (is-number? c)\n  (member c (string->list \"0123456789.\")))\n\n(define (is-symbol? c)\n  (member c (string->list \"()+-*\/\")))\n\n(define (is-empty? c)\n  (member c (string->list \" \\t\n\\r\")))\n\n(define (tokenize str)\n  (define (get-number pre post)\n    (cond [(null? post) (cons (string->number (list->string pre)) post)]\n          [(is-number? (car post)) (get-number (append pre (list (car post)))\n                                               (cdr post))]\n          [else (cons (string->number (list->string pre)) post)]))\n  (define (get-symbol pre post)\n    (cons (car pre) post))\n  (define (get-token pre post)\n    (cond [(is-number? (car pre)) (get-number pre post)]\n          [(is-symbol? (car pre)) (get-symbol pre post)]\n          [(is-empty? (car pre)) (get-token (append (cdr pre)\n                                                   (list (car post)))\n                                            (cdr post))]))\n  (define (iter pre post res)\n    (let* [(tr (get-token pre post))\n           (token (car tr))\n           (rem (cdr tr))]\n      (if (null? rem)\n          (cons token res)\n          (iter (list (car rem))\n                (cdr rem)\n                (cons token res)))))\n  (let ((raw-list (string->list str)))\n    (reverse (iter (list (car raw-list))\n                   (cdr raw-list)\n                   null))))\n\n(define (parse tl)\n  (define (try-both p1 p2)\n    (lambda (tl)\n      (let [(res (p1 tl))]\n        (if res\n            res\n            (p2 tl)))))\n  (define (try-all . pl)\n    (foldr try-both (lambda (x) x) pl))\n  (define (repeat p)\n    (lambda (tl)\n      (let* [(res (p tl))\n             (nxt (p res))]\n        (if nxt\n            ((repeat p) res)\n            res))))\n  (define (get-atom tl)\n    (cond [(null? tl) #f]\n          [(false? tl) #f]\n          [(list? (car tl)) tl]\n          [else #f]))\n  (define (get-num tl)\n    (cond [(null? tl) #f]\n          [(false? tl) #f]\n          [(number? (car tl)) tl]\n          [else #f]))\n  (define (get-unary tl)\n    (let* [(parser (try-all get-atom get-block get-num get-unary))]\n      (cond [(null? tl) #f]\n            [(false? tl) #f]\n            [(eq? (car tl) #\\-) (let [(res (parser (cdr tl)))]\n                                  (if res\n                                      (cons (list '* -1 (car res)) (cdr res))\n                                      #f))]\n            [else #f])))\n  (define (get-block tl)\n    (define (get-first-block tl)\n      (define (iter n pre post)\n        (cond [(zero? n) (cons (reverse (cdr pre)) post)]\n              [(null? post) error \"Unmatched paren.\"]\n              [(eq? (car post) #\\)) (iter (- n 1) (cons (car post) pre) (cdr post))]\n              [(eq? (car post) #\\() (iter (+ n 1) (cons (car post) pre) (cdr post))]\n              [else (iter n (cons (car post) pre) (cdr post))]))\n      (iter 1 '() tl))\n    (cond [(null? tl) #f]\n          [(false? tl) #f]\n          [(eq? (car tl) #\\() (let [(res (get-first-block (cdr tl)))]\n                                (if res\n                                    (append (real-parse (car res))\n                                                        (cdr res))\n                                    #f))]\n          [else #f]))\n  (define (get-mul tl)\n    (let* [(parser (try-all get-atom get-block get-unary get-num))\n           (fst (parser tl))]\n      (if fst\n          (cond [(null? (cdr fst)) #f]\n                [(eq? (cadr fst) #\\*) (let [(snd (parser (cddr fst)))]\n                                        (if snd\n                                            (cons (list '* (car fst) (car snd)) (cdr snd))\n                                            #f))]\n                [(eq? (cadr fst) #\\\/) (let [(snd (parser (cddr fst)))]\n                                        (if snd\n                                            (cons (list '\/ (car fst) (car snd)) (cdr snd))\n                                            #f))]\n                [else #f])\n          #f)\n      ))\n  (define (get-add tl)\n    (let* [(parser (try-all get-atom (repeat get-mul) get-block get-unary get-num))\n           (fst (parser tl))]\n      (if fst\n          (cond [(null? (cdr fst)) #f]\n                [(eq? (cadr fst) #\\+) (let [(snd (parser (cddr fst)))]\n                                        (if snd\n                                            (cons (list '+ (car fst) (car snd)) (cdr snd))\n                                            #f))]\n                [(eq? (cadr fst) #\\-) (let [(snd (parser (cddr fst)))]\n                                        (if snd\n                                            (cons (list '- (car fst) (car snd)) (cdr snd))\n                                            #f))]\n                [else #f])\n          #f)\n      ))\n  (define (real-parse tl)\n    ((try-all (repeat get-add) (repeat get-mul) get-unary (repeat get-block)) tl))\n  (real-parse tl))\n\n(define (eval exp)\n  (cond [(number? exp) exp]\n        [(list? exp)\n         (match exp\n           [(list a) (eval a)]\n           [(list '* a b) (* (eval a) (eval b))]\n           [(list '- a b) (- (eval a) (eval b))]\n           [(list '\/ a b) (\/ (eval a) (eval b))]\n           [(list '+ a b) (+ (eval a) (eval b))])]))\n\n(define (calc_expression exp)\n  ((compose eval parse tokenize) (string-trim exp)))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291512,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n(require racket\/match)\n\n(define (calc_expression exp)\n  (exec (parse (lex exp))))\n\n(define (lex exp)\n  (regexp-match* #px\"(\\\\d+(\\\\.\\\\d+)?)|\\\\S\" exp))\n\n(define (parse tokens)\n  (define (exp)\n    (define (aux left)\n      (if (or (null? tokens)\n              (not (member (peek) '(\"+\" \"-\"))))\n          left\n          (let ([op\t\t\t(term-op)]\n                [right\t(term)])\n            (aux (list op left right)))))\n    (aux (term)))\n  (define (term)\n    (define (aux left)\n      (if (or (null? tokens)\n              (not (member (peek) '(\"*\" \"\/\"))))\n          left\n          (let ([op\t\t\t(factor-op)]\n                [right\t(factor)])\n            (aux (list op left right)))))\n    (aux (factor)))\n  (define (factor)\n    (define current (peek))\n    (forward!)\n    (match current\n      [\"-\"\t(list - (factor))]\n      [\"(\"\n       (let ([inner (exp)])\n         (forward!)\n         inner)]\n      [else\t(string->number current)]))\n  (define (term-op)\n    (define current (peek))\n    (forward!)\n    (match current\n      [\"+\" +]\n      [\"-\" -]))\n  (define (factor-op)\n    (define current (peek))\n    (forward!)\n    (match current\n      [\"*\" *]\n      [\"\/\" \/]))\n  (define (peek) (car tokens))\n  (define (forward!) (set! tokens (cdr tokens)))\n  (exp))\n\n(define (exec tree)\n  (if (list? tree)\n      (apply (car tree)\n             (map exec (cdr tree)))\n      tree))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291513,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n\n;; Function to convert a character into an operator symbol.\n(define (char->op-symbol c)\n  (cond [(char=? c #\\-) 'sub]\n        [(char=? c #\\+) 'add]\n        [(char=? c #\\\/) 'div]\n        [(char=? c #\\*) 'mul]\n        [(char=? c #\\() 'begpar]\n        [(char=? c #\\)) 'endpar]))\n\n\n;; Function to convert a character into a number\n;; (not its ascii code, but its actual value).\n(define (char->number c)\n  (- (char->integer c) (char->integer #\\0)))\n\n\n;; Function to determine operator precedence.\n(define (operator-precedence op)\n  (cond [(or (equal? op 'mul) (equal? op 'div)) 2]\n        [(or (equal? op 'add) (equal? op 'sub)) 1]\n        [(equal? op 'neg) 3]))\n\n\n;; Function to convert the expression string into\n;; a list of tokens.\n(define (tokenize s)\n  ;; Helper function to convert the number we were accumulating into\n  ;; an actual number.\n  (define (acc->number acc)\n    (string->number (list->string (reverse acc))))\n  ;; Helper function to loop over the characters in the expression string.\n  (define (tokenize-loop cs acc)\n    (if (empty? cs)\n        ;; If done processing characters return an empty list\n        ;; if we weren't accumulating a number. Otherwise, return\n        ;; list with the accumulated number.\n        (if (equal? #f acc)\n            '()\n            (list (acc->number acc)))\n        ;; Extract first character in string into c.\n        (let ([c (first cs)])          \n          (cond\n            ;; Ignore whitespace.\n            [(char-whitespace? c)\n             (tokenize-loop (rest cs) acc)]\n            ;; If c is numeric or a decimal point add it to the accumuling\n            ;; number and recurse on the rest of the expression string.\n            [(or (char-numeric? c) (char=? c #\\.))\n             (tokenize-loop (rest cs)\n                            (if (equal? acc #f) (list c) (cons c acc)))]\n            ;; If c is an operator then ...\n            [else\n             ;; Extract the operator into op.\n             (let ([op (char->op-symbol c)])\n               (if (equal? acc #f)\n                   ;; If we aren't accumulating a number, add operator to tokens\n                   ;; and recurse on the rest of the expression string.\n                   (cons op (tokenize-loop (rest cs) #f))\n                   ;; If we are accumulating a number, add both the number and\n                   ;; operator to tokens and recurse on the rest of the expresion\n                   ;; string.\n                   (cons (acc->number acc) (cons op (tokenize-loop (rest cs) #f)))))]))))\n  (tokenize-loop (string->list s) #f))\n\n\n;; Function to scan tokens and negative numbers as\n;; indicated by unary minus operators.  Unary minus\n;; operators occur when the minus operator comes\n;; after nothing, a closing parenthesis, or another\n;; operator.\n(define (handle-unary-minus ts)\n  (define (precedes-unary-minus? t)\n    (cond [(equal? t 'none) #t]\n          [(equal? t 'begpar) #t]\n          [(equal? t 'sub) #t]\n          [(equal? t 'add) #t]\n          [(equal? t 'mul) #t]\n          [(equal? t 'div) #t]\n          [else #f]))\n  (define (handle-unary-minus-loop ts0 prev)\n    (cond [(empty? ts0) '()]\n          [(and (equal? (first ts0) 'sub)\n                (precedes-unary-minus? prev))\n           (cons 'neg (handle-unary-minus-loop (rest ts0) (first ts0)))]\n          [else (cons (first ts0) (handle-unary-minus-loop (rest ts0) (first ts0)))]))\n  (handle-unary-minus-loop ts 'none))\n\n;; Function to evaluate an operator and two values.\n(define (eval op v1 v2)\n  (cond\n    [(equal? op 'sub) (- v1 v2)]\n    [(equal? op 'add) (+ v1 v2)]\n    [(equal? op 'mul) (* v1 v2)]\n    [(equal? op 'div) (\/ v1 v2)]))\n\n\n;; Function to convert of list of tokens in infix notation\n;; into a list of tokens in postfix notation using Dijkstra's\n;; shunting yard algorithm.\n(define (infix->postfix tokens)\n\n  ;; Helper function to determine if token is a number.\n  ;; (That is, token is not a symbol).\n  (define (token-is-number? t)\n    (not (symbol? t)))\n\n  ;; Helper function to determine if token is an operator.\n  ;; (That is, token is a symbol and not a parenthesis).\n  (define (token-is-operator? t)\n    (and (symbol? t) (not (or (equal? t 'begpar) (equal? t 'endpar)))))\n\n  ;; Function to loop over tokens, converting them to postfix.\n  (define (loop ts ops out)\n    ;; While there are tokens to be read do:\n    (if (empty? ts)\n        ;; After while loop, if operator stack not null, pop everything to output queue.\n        (if (not (empty? ops))\n            (loop ts (rest ops) (cons (first ops) out))\n            (reverse out))\n        ;; Read a token.\n        (let ([t (first ts)])\n          (cond\n            ;; If the token is a number, then: push it to the output queue.\n            [(token-is-number? t) (loop (rest ts) ops (cons t out))]\n            ;; if the token is an operator, then:\n            [(token-is-operator? t)\n             ;; While there is an operator at the top of the operator stack with greater precedence\n             ;; or the operator at the top of the operator stack has equal precedence and is left associative\n             ;; (which in this case is the operators: +,-,\/,*; this excludes the unary minus, 'neg, which\n             ;; is handled separately in the and expression) and the operator at the top of the operator\n             ;; stack is not a left parenthesis: pop operators from the operator stack onto the output queue.\n             (if (and\n                  (not (empty? ops))\n                  (not (equal? (first ops) 'begpar))\n                  (not (equal? t 'neg))\n                  (>= (operator-precedence (first ops)) (operator-precedence t)))\n                 ;; Recurse removing the top operator from the operator stack, but without removing\n                 ;; the token, t, from the list of tokens.\n                 (loop ts (rest ops) (cons (first ops) out))\n                 ;; Otherise, recurse removing the token, t, from the list of tokens and\n                 ;; pushing it onto the operator stack.\n                 (loop (rest ts) (cons t ops) out))]\n            ;; If the token is a left paren (i.e. \"(\"), then push it onto the operator stack.\n            [(equal? t 'begpar) (loop (rest ts) (cons t ops) out)]\n            ;; If the token is a right paren (i.e. \")\"), then:\n            [(equal? t 'endpar)\n             ;; While the operator at the top of the operator stack is not a left paren:\n             ;; pop the operator from the operator stack onto the output queue.\n             (if (not (equal? (first ops) 'begpar))\n                 ;; Recurse removing the top operator from the operator stac, but without removing\n                 ;; the token, t, from the list of tokens.\n                 (loop ts (rest ops) (cons (first ops) out))\n                 ;; If there is a left paren at the top of the operator stack, then:\n                 ;; pop the operator from the operator stack and discard it.\n                 ;; Recurse after removing the token, t, from the list of tokens, and removing\n                 ;; the top operator, 'begpar, from the operator stack.\n                 (loop (rest ts) (rest ops) out))]))))\n  (loop tokens '() '()))\n\n\n;; Function to evaluate postfix expression.\n(define (eval-postfix tokens)\n\n  ;; Helper function to determine if token is an operator.       \n  (define (token-is-operator? t)\n    (symbol? t))\n\n  ;; Function to iterate over the tokens to compute result.\n  (define (loop ts stack)\n    ;; For each token in the postfix expression:\n    (if (empty? ts)\n        ;;  Result \u2190 pop from the stack\n        (first stack)\n        (cond\n          ;; If tokens is a unary minus:\n          ;;     pop operand from stack and multiply by -1\n          ;;     push result back onto stack\n          [(equal? (first ts) 'neg)\n           (loop (rest ts) (cons (* -1 (first stack)) (rest stack)))]   \n          ;; If token is an operator:\n          ;;     operand_2 \u2190 pop from the stack\n          ;;     operand_1 \u2190 pop from the stack\n          ;;     result \u2190 evaluate token with operand_1 and operand_2\n          ;;     push result back onto the stack\n          [(token-is-operator? (first ts))\n           (let* ([operand-2 (first stack)]\n                  [operand-1 (first (rest stack))]\n                  [result (eval (first ts) operand-1 operand-2)])\n             (loop (rest ts) (cons result (rest (rest stack)))))]\n          ;; Else if token is an operand:\n          ;;    push token onto the stack\n          [else\n           (loop (rest ts) (cons (first ts) stack))])))\n\n  (loop tokens '()))\n\n\n;; Function to evaluate a string expression.\n(define (calc_expression exp)\n    (eval-postfix (infix->postfix (handle-unary-minus (tokenize exp)))))","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"},{"id":291514,"user_id":null,"body":"#lang racket\n(provide calc_expression)\n\n(define (calc_expression exp)\n  (define tokens (regexp-match* #px\"[+*\/()-]|(\\\\d+\\\\.*\\\\d*)\" exp))\n  (define (shift)\n    (begin0\n      (first tokens)\n      (set! tokens (rest tokens)))) \n  (define (accept sym)\n    (if (empty? tokens)\n        #f\n        (let ([top (first tokens)])\n          (and (if (regexp? sym) (regexp-match? sym top) (equal? sym top)) (shift)))))\n  (define (expression)\n    (let loop ([ e (term)] [o (accept #px\"[-+]\")])\n      (if o\n          (loop ((if (equal? o \"-\") - +) e (term)) (accept #px\"[-+]\"))\n          e)))\n  (define (term)\n    (let loop ([t (factor)] [o (accept #px\"[*\/]\")])\n      (if o\n          (loop ((if (equal? o \"\/\") \/ *) t (factor)) (accept #px\"[\/*]\"))\n          t)))\n  (define (factor)\n    (let loop ([sign 1] [o (accept \"-\")])\n      (if o\n          (loop (- sign) (accept \"-\"))\n          (* sign (paren)))))\n  (define (paren)\n    (if (accept \"(\")\n        (let ([e (expression)])\n          (accept \")\")\n          e)\n        (string->number (shift))))\n  (expression))\n  ","lang_id":44,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}],"54acd76f7207c6a2880012bb":[{"id":291515,"user_id":null,"body":"#lang racket\n(define MORSE-CODE'#hash((\"-\" . \"T\") (\"--\" . \"M\") (\"---\" . \"O\") (\"-----\" . \"0\") (\"----.\" . \"9\") (\"---..\" . \"8\") (\"---...\" . \"=>\") (\"--.\" . \"G\") (\"--.-\" . \"Q\") (\"--..\" . \"Z\") (\"--..--\" . \"\") (\"--...\" . \"7\") (\"-.\" . \"N\") (\"-.-\" . \"K\") (\"-.--\" . \"Y\") (\"-.--.\" . \"(\") (\"-.--.-\" . \")\") (\"-.-.\" . \"C\") (\"-.-.--\" . \"!\") (\"-.-.-.\" . \"\") (\"-..\" . \"D\") (\"-..-\" . \"X\") (\"-..-.\" . \"\/\") (\"-...\" . \"B\") (\"-...-\" . \"=\") (\"-....\" . \"6\") (\"-....-\" . \"-\") (\".\" . \"E\") (\".-\" . \"A\") (\".--\" . \"W\") (\".---\" . \"J\") (\".----\" . \"1\") (\".----.\" . \"'\") (\".--.\" . \"P\") (\".--.-.\" . \"@\") (\".-.\" . \"R\") (\".-.-.\" . \"+\") (\".-.-.-\" . \".\") (\".-..\" . \"L\") (\".-..-.\" . \"\\\"\")(\".-...\" . \"&\") (\"..\" . \"I\") (\"..-\" . \"U\") (\"..---\" . \"2\") (\"..--.-\" . \"_\") (\"..--..\" . \"?\") (\"..-.\" . \"F\") (\"...\" . \"S\") (\"...-\" . \"V\") (\"...--\" . \"3\") (\"...---...\" . \"SOS\") (\"...-..-\" . \"$\") (\"....\" . \"H\") (\"....-\" . \"4\") (\".....\" . \"5\")))\n\n(provide decode_bits_advanced decode_morse)\n\n(define (decode_bits_advanced bits)\n  (let ([result \"\"]\n        [groups (regexp-match* #px\"0+|1+\" (regexp-replace* #px\"^0*|0*$\" bits \"\"))])\n    (if (empty? groups) result\n        (let* ([dash (apply max (map string-length (regexp-match* #px\"1+\" bits)))]\n               [shortest (apply min (map string-length groups))]\n               [dash (if (= shortest dash) (* 2 dash) dash)]\n               [dot (\/ dash 2)]\n               [space (+ dash 3)]        \n               [dictionary (hash #\\0 '(\"\" \" \" \"   \") #\\1 '(\".\" \"-\"))])\n          (for ([group groups])\n            (let* ([len (string-length group)]\n                   [index (if (<= len dot) 0 (if (>= len space) 2 1))]\n                   [type (hash-ref dictionary (string-ref group 0))]\n                   [code (list-ref type index)])\n                   (set! result (string-append result code))))))\n    result))\n\n(define (decode_morse morse-code)\n  (define (split-words morse-code)\n    (string-split (string-trim morse-code) \"   \"))\n  (define (decode-word word)\n    (define (split-letters word)\n      (string-split word \" \"))\n    (define (decode-letter letter)\n      (hash-ref MORSE-CODE letter \"\"))  \n    (string-join (map decode-letter (split-letters word)) \"\"))\n  (string-join (map decode-word (split-words morse-code)) \" \"))\n","lang_id":44,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:38","updated_at":"2022-12-30 18:39:38"}]}